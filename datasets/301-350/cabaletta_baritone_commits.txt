File: src/main/java/baritone/utils/schematic/litematica/LitematicaHelper.java
Patch:
@@ -29,6 +29,7 @@
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Vec3i;
 import net.minecraft.util.Tuple;
+import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Mirror;
 import net.minecraft.world.level.block.Rotation;
 import net.minecraft.world.level.block.state.BlockState;
@@ -98,7 +99,7 @@ public static Tuple<IStaticSchematic, Vec3i> getSchematic(int i) {
         int minY = Integer.MAX_VALUE;
         int minZ = Integer.MAX_VALUE;
         HashMap<Vec3i, StaticSchematic> subRegions = new HashMap<>();
-        WorldSchematic schematicWorld = SchematicWorldHandler.getSchematicWorld();
+        Level schematicWorld = SchematicWorldHandler.getSchematicWorld();
         for (Map.Entry<String, SubRegionPlacement> entry : placement.getEnabledRelativeSubRegionPlacements().entrySet()) {
             SubRegionPlacement subPlacement = entry.getValue();
             Vec3i pos = transform(subPlacement.getPos(), placement.getMirror(), placement.getRotation());
@@ -152,4 +153,4 @@ public String toString() {
             return name;
         }
     }
-}
\ No newline at end of file
+}

File: src/main/java/baritone/utils/schematic/litematica/LitematicaHelper.java
Patch:
@@ -29,6 +29,7 @@
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Vec3i;
 import net.minecraft.util.Tuple;
+import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Mirror;
 import net.minecraft.world.level.block.Rotation;
 import net.minecraft.world.level.block.state.BlockState;
@@ -98,7 +99,7 @@ public static Tuple<IStaticSchematic, Vec3i> getSchematic(int i) {
         int minY = Integer.MAX_VALUE;
         int minZ = Integer.MAX_VALUE;
         HashMap<Vec3i, StaticSchematic> subRegions = new HashMap<>();
-        WorldSchematic schematicWorld = SchematicWorldHandler.getSchematicWorld();
+        Level schematicWorld = SchematicWorldHandler.getSchematicWorld();
         for (Map.Entry<String, SubRegionPlacement> entry : placement.getEnabledRelativeSubRegionPlacements().entrySet()) {
             SubRegionPlacement subPlacement = entry.getValue();
             Vec3i pos = transform(subPlacement.getPos(), placement.getMirror(), placement.getRotation());
@@ -152,4 +153,4 @@ public String toString() {
             return name;
         }
     }
-}
\ No newline at end of file
+}

File: src/main/java/baritone/pathing/calc/AStarPathFinder.java
Patch:
@@ -41,8 +41,8 @@ public final class AStarPathFinder extends AbstractNodeCostSearch {
     private final Favoring favoring;
     private final CalculationContext calcContext;
 
-    public AStarPathFinder(int startX, int startY, int startZ, Goal goal, Favoring favoring, CalculationContext context) {
-        super(startX, startY, startZ, goal, context);
+    public AStarPathFinder(BetterBlockPos realStart, int startX, int startY, int startZ, Goal goal, Favoring favoring, CalculationContext context) {
+        super(realStart, startX, startY, startZ, goal, context);
         this.favoring = favoring;
         this.calcContext = context;
     }
@@ -96,7 +96,7 @@ protected Optional<IPath> calculate0(long primaryTimeout, long failureTimeout) {
             numNodes++;
             if (goal.isInGoal(currentNode.x, currentNode.y, currentNode.z)) {
                 logDebug("Took " + (System.currentTimeMillis() - startTime) + "ms, " + numMovementsConsidered + " movements considered");
-                return Optional.of(new Path(startNode, currentNode, numNodes, goal, calcContext));
+                return Optional.of(new Path(realStart, startNode, currentNode, numNodes, goal, calcContext));
             }
             for (Moves moves : allMoves) {
                 int newX = currentNode.x + moves.xOffset;

File: buildSrc/src/main/java/baritone/gradle/util/Determinizer.java
Patch:
@@ -71,10 +71,10 @@ public static void determinize(String inputPath, String outputPath, List<File> t
                     ByteArrayOutputStream cancer = new ByteArrayOutputStream();
                     copy(jarFile.getInputStream(entry), cancer);
                     String manifest = new String(cancer.toByteArray());
-                    if (!manifest.contains("baritone.launch.BaritoneTweaker")) {
+                    if (!manifest.contains("baritone.launch.tweaker.BaritoneTweaker")) {
                         throw new IllegalStateException("unable to replace");
                     }
-                    manifest = manifest.replace("baritone.launch.BaritoneTweaker", "org.spongepowered.asm.launch.MixinTweaker");
+                    manifest = manifest.replace("baritone.launch.tweaker.BaritoneTweaker", "org.spongepowered.asm.launch.MixinTweaker");
                     jos.write(manifest.getBytes());
                 } else {
                     copy(jarFile.getInputStream(entry), jos);

File: tweaker/src/main/java/baritone/launch/tweaker/BaritoneTweaker.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.launch;
+package baritone.launch.tweaker;
 
 import io.github.impactdevelopment.simpletweaker.SimpleTweaker;
 import net.minecraft.launchwrapper.Launch;

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -387,7 +387,7 @@ public final class Settings {
 
     /**
      * How many ticks between breaking a block and starting to break the next block. Default in game is 6 ticks.
-     * Values under 2 will be clamped.
+     * Values under 1 will be clamped. The delay only applies to non-instant (1-tick) breaks.
      */
     public final Setting<Integer> blockBreakSpeed = new Setting<>(6);
 

File: src/main/java/baritone/utils/player/BaritonePlayerController.java
Patch:
@@ -20,7 +20,6 @@
 import baritone.api.utils.IPlayerController;
 import baritone.utils.accessor.IPlayerControllerMP;
 import net.minecraft.client.Minecraft;
-import net.minecraft.client.multiplayer.ClientLevel;
 import net.minecraft.client.player.LocalPlayer;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -54,7 +53,7 @@ public void syncHeldItem() {
 
     @Override
     public boolean hasBrokenBlock() {
-        return ((IPlayerControllerMP) mc.gameMode).getCurrentBlock().getY() == -1;
+        return !((IPlayerControllerMP) mc.gameMode).isHittingBlock();
     }
 
     @Override

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -124,7 +124,7 @@ public void build(String name, ISchematic schematic, Vec3i origin) {
             @Override
             public boolean partOfMask(int x, int y, int z, BlockState current) {
                 // partOfMask is only called inside the schematic so desiredState is not null
-                return !Baritone.settings().buildSkipBlocks.value.contains(this.desiredState(x, y, z, current, null).getBlock());
+                return !Baritone.settings().buildSkipBlocks.value.contains(this.desiredState(x, y, z, current, Collections.emptyList()).getBlock());
             }
         };
         int x = origin.getX();

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -124,7 +124,7 @@ public void build(String name, ISchematic schematic, Vec3i origin) {
             @Override
             public boolean partOfMask(int x, int y, int z, BlockState current) {
                 // partOfMask is only called inside the schematic so desiredState is not null
-                return !Baritone.settings().buildSkipBlocks.value.contains(this.desiredState(x, y, z, current, null).getBlock());
+                return !Baritone.settings().buildSkipBlocks.value.contains(this.desiredState(x, y, z, current, Collections.emptyList()).getBlock());
             }
         };
         int x = origin.getX();

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -1115,7 +1115,7 @@ public double costOfPlacingAt(int x, int y, int z, BlockState current) {
                 if (sch.getBlock() instanceof AirBlock) {
                     // we want this to be air, but they're asking if they can place here
                     // this won't be a schematic block, this will be a throwaway
-                    return placeBlockCost * 2; // we're going to have to break it eventually
+                    return placeBlockCost * Baritone.settings().placeIncorrectBlockPenaltyMultiplier.value; // we're going to have to break it eventually
                 }
                 if (placeable.contains(sch)) {
                     return 0; // thats right we gonna make it FREE to place a block where it should go in a structure
@@ -1128,7 +1128,7 @@ public double costOfPlacingAt(int x, int y, int z, BlockState current) {
                 }
                 // we want it to be something that we don't have
                 // even more of a pain to place something wrong
-                return placeBlockCost * 3;
+                return placeBlockCost * 1.5 * Baritone.settings().placeIncorrectBlockPenaltyMultiplier.value;
             } else {
                 if (hasThrowaway) {
                     return placeBlockCost;

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -440,8 +440,8 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
         return onTick(calcFailed, isSafeToCancel, 0);
     }
 
-    public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel, int recursions) {
-        if (recursions > 1000) { // onTick calls itself, don't crash
+    private PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel, int recursions) {
+        if (recursions > 100) { // onTick calls itself, don't crash
             return new PathingCommand(null, PathingCommandType.SET_GOAL_AND_PATH);
         }
         approxPlaceable = approxPlaceable(36);

File: src/main/java/baritone/Baritone.java
Patch:
@@ -79,7 +79,7 @@ public class Baritone implements IBaritone {
     private final ExploreProcess exploreProcess;
     private final FarmProcess farmProcess;
     private final InventoryPauserProcess inventoryPauserProcess;
-    private final ElytraProcess elytraProcess;
+    private final IElytraProcess elytraProcess;
 
     private final PathingControlManager pathingControlManager;
     private final SelectionManager selectionManager;

File: src/main/java/baritone/Baritone.java
Patch:
@@ -79,7 +79,7 @@ public class Baritone implements IBaritone {
     private final ExploreProcess exploreProcess;
     private final FarmProcess farmProcess;
     private final InventoryPauserProcess inventoryPauserProcess;
-    private final ElytraProcess elytraProcess;
+    private final IElytraProcess elytraProcess;
 
     private final PathingControlManager pathingControlManager;
     private final SelectionManager selectionManager;

File: src/main/java/baritone/cache/FasterWorldScanner.java
Patch:
@@ -151,7 +151,7 @@ private Stream<BlockPos> scanChunkInternal(IPlayerContext ctx, BlockOptionalMeta
         long chunkX = (long) pos.x << 4;
         long chunkZ = (long) pos.z << 4;
 
-        int playerSectionY = ctx.playerFeet().y >> 4;
+        int playerSectionY = (ctx.playerFeet().y - ctx.world().getMinBuildHeight()) >> 4;
 
         return collectChunkSections(lookup, chunkProvider.getChunk(pos.x, pos.z, false), chunkX, chunkZ, playerSectionY).stream();
     }

File: src/main/java/baritone/cache/FasterWorldScanner.java
Patch:
@@ -151,7 +151,7 @@ private Stream<BlockPos> scanChunkInternal(IPlayerContext ctx, BlockOptionalMeta
         long chunkX = (long) pos.x << 4;
         long chunkZ = (long) pos.z << 4;
 
-        int playerSectionY = ctx.playerFeet().y >> 4;
+        int playerSectionY = (ctx.playerFeet().y - ctx.world().getMinBuildHeight()) >> 4;
 
         return collectChunkSections(lookup, chunkProvider.getChunk(pos.x, pos.z, false), chunkX, chunkZ, playerSectionY).stream();
     }

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -743,7 +743,7 @@ public final class Settings {
     /**
      * Automatically elytra fly without having to force the client-sided rotations.
      */
-    public final Setting<Boolean> elytraFreeLook = new Setting<>(false);
+    public final Setting<Boolean> elytraFreeLook = new Setting<>(true);
 
     /**
      * Forces the client-sided yaw rotation to an average of the last {@link #smoothLookTicks} of server-sided rotations.
@@ -753,7 +753,7 @@ public final class Settings {
     /**
      * Same as {@link #smoothLook} but for elytra flying.
      */
-    public final Setting<Boolean> elytraSmoothLook = new Setting<>(true);
+    public final Setting<Boolean> elytraSmoothLook = new Setting<>(false);
 
     /**
      * The number of ticks to average across for {@link #smoothLook};
@@ -1426,7 +1426,7 @@ public final class Settings {
      * Whether nether-pathfinder should generate terrain based on {@link #elytraNetherSeed}.
      * If false all chunks that haven't been loaded are assumed to be air.
      */
-    public final Setting<Boolean> elytraPredictTerrain = new Setting<>(true);
+    public final Setting<Boolean> elytraPredictTerrain = new Setting<>(false);
 
     /**
      * Automatically swap the current elytra with a new one when the durability gets too low

File: src/main/java/baritone/behavior/LookBehavior.java
Patch:
@@ -82,7 +82,6 @@ public void onTick(TickEvent event) {
 
     @Override
     public void onPlayerUpdate(PlayerUpdateEvent event) {
-        System.out.println(event.getState() + " " + ctx.player().getXRot() + " " + ctx.player().getYRot() + " " + ctx.player().xRotO + " " + ctx.player().yRotO);
 
         if (this.target == null) {
             return;

File: src/main/java/baritone/process/ElytraProcess.java
Patch:
@@ -405,8 +405,6 @@ public enum State {
 
     @Override
     public void onRenderPass(RenderEvent event) {
-        System.out.println(event.getPartialTicks() + " " + ctx.player().getXRot() + " " + ctx.player().getYRot() + " " + ctx.player().xRotO + " " + ctx.player().yRotO);
-
         if (this.behavior != null) this.behavior.onRenderPass(event);
     }
 

File: buildSrc/src/main/java/baritone/gradle/task/ProguardTask.java
Patch:
@@ -63,7 +63,6 @@ public String getExtract() {
 
     private List<String> requiredLibraries;
 
-    private File mixin;
     private File pathfinder;
 
     @TaskAction
@@ -75,7 +74,7 @@ protected void exec() throws Exception {
         downloadProguard();
         extractProguard();
         generateConfigs();
-        acquireDependencies();
+        pathfinder = acquireDependencies().filter(file -> file.getName().contains("nether-pathfinder")).findAny().get();
         processArtifact();
         proguardApi();
         proguardStandalone();

File: src/launch/java/baritone/launch/mixins/MixinClientPlayerEntity.java
Patch:
@@ -121,5 +121,5 @@ private boolean isFlyEnabled(ItemStack stack) {
             return false;
         }
         return ElytraItem.isFlyEnabled(stack);
-    } // bradyfix is this right?
+    }
 }

File: src/main/java/baritone/process/ElytraProcess.java
Patch:
@@ -115,8 +115,8 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
                 if (landingSpot != null) {
                     this.pathTo0(landingSpot, true);
                     this.landingSpot = landingSpot;
-                    this.goingToLandingSpot = true;
                 }
+                this.goingToLandingSpot = true;
             }
 
             if (last != null && ctx.player().getDistanceSqToCenter(last) < 1) {
@@ -504,7 +504,7 @@ private BetterBlockPos findSafeLandingSpot(BetterBlockPos start) {
 
         while (!queue.isEmpty()) {
             BetterBlockPos pos = queue.poll();
-            if (ctx.world().isBlockLoaded(pos) && isInBounds(pos) && ctx.world().getBlockState(pos).getBlock() == Blocks.AIR) {
+            if (ctx.world().isBlockLoaded(pos, false) && isInBounds(pos) && ctx.world().getBlockState(pos).getBlock() == Blocks.AIR) {
                 BetterBlockPos actualLandingSpot = checkLandingSpot(pos, checkedPositions);
                 if (actualLandingSpot != null && isColumnAir(actualLandingSpot, LANDING_COLUMN_HEIGHT) && hasAirBubble(actualLandingSpot.up(LANDING_COLUMN_HEIGHT)) && !badLandingSpots.contains(actualLandingSpot.up(LANDING_COLUMN_HEIGHT))) {
                     return actualLandingSpot.up(LANDING_COLUMN_HEIGHT);

File: src/main/java/baritone/behavior/LookBehavior.java
Patch:
@@ -117,9 +117,9 @@ public void onPlayerUpdate(PlayerUpdateEvent event) {
                         ctx.player().rotationPitch = this.prevRotation.getPitch();
                     } else if ((ctx.player().isElytraFlying() && Baritone.settings().elytraSmoothLook.value) || (!ctx.player().isElytraFlying() && Baritone.settings().smoothLook.value)) {
                         ctx.player().rotationYaw = (float) this.smoothYawBuffer.stream().mapToDouble(d -> d).average().orElseGet(this.prevRotation::getYaw);
-                        ctx.player().rotationPitch = ctx.player().isElytraFlying()
-                                ? (float) this.smoothPitchBuffer.stream().mapToDouble(d -> d).average().orElseGet(this.prevRotation::getPitch)
-                                : this.prevRotation.getPitch();
+                        if (ctx.player().isElytraFlying()) {
+                            ctx.player().rotationPitch = (float) this.smoothPitchBuffer.stream().mapToDouble(d -> d).average().orElseGet(this.prevRotation::getPitch);
+                        }
                     }
 
                     this.prevRotation = null;

File: src/main/java/baritone/process/ElytraProcess.java
Patch:
@@ -389,8 +389,7 @@ private boolean isSafeLandingSpot(BlockPos pos, LongOpenHashSet checkedSpots) {
 
     private BetterBlockPos findSafeLandingSpot() {
         final BetterBlockPos start = ctx.playerFeet();
-        Queue<BetterBlockPos> queue = new PriorityQueue<>(Comparator.<BetterBlockPos>comparingInt(Vec3i::getY).reversed());
-        //Queue<BetterBlockPos> queue = new LinkedList<>();
+        Queue<BetterBlockPos> queue = new PriorityQueue<>(Comparator.<BetterBlockPos>comparingInt(pos -> (pos.x-start.x)*(pos.x-start.x) + (pos.z-start.z)*(pos.z-start.z)).thenComparingInt(pos -> -pos.y));
         Set<BetterBlockPos> visited = new HashSet<>();
         LongOpenHashSet checkedPositions = new LongOpenHashSet();
         queue.add(start);

File: src/main/java/baritone/process/elytra/LegacyElytraBehavior.java
Patch:
@@ -195,7 +195,7 @@ public CompletableFuture<Void> pathRecalcSegment(final int upToIncl) {
             }
 
             this.recalculating = true;
-            final List<BetterBlockPos> after = this.path.subList(upToIncl, this.path.size());
+            final List<BetterBlockPos> after = this.path.subList(upToIncl + 1, this.path.size());
             final boolean complete = this.completePath;
 
             return this.path0(ctx.playerFeet(), this.path.get(upToIncl), segment -> segment.append(after.stream(), complete))
@@ -288,6 +288,7 @@ private void pathfindAroundObstacles() {
             while (rangeEndExcl < path.size() && ctx.world().isBlockLoaded(path.get(rangeEndExcl), false)) {
                 rangeEndExcl++;
             }
+            // rangeEndExcl now represents an index either not in the path, or just outside render distance
             if (rangeStartIncl >= rangeEndExcl) {
                 // not loaded yet?
                 return;

File: src/main/java/baritone/utils/GuiClick.java
Patch:
@@ -43,7 +43,6 @@
 import java.util.Collections;
 
 import static baritone.api.command.IBaritoneChatControl.FORCE_COMMAND_PREFIX;
-import static org.lwjgl.opengl.GL11.*;
 
 public class GuiClick extends Screen implements Helper {
 

File: src/main/java/baritone/behavior/ElytraBehavior.java
Patch:
@@ -386,7 +386,7 @@ public void onWorldEvent(WorldEvent event) {
 
     @Override
     public void onChunkEvent(ChunkEvent event) {
-        if (event.isPostPopulate()) {
+        if (event.isPostPopulate() && this.context != null) {
             final Chunk chunk = ctx.world().getChunk(event.getX(), event.getZ());
             this.context.queueForPacking(chunk);
         }
@@ -1069,13 +1069,13 @@ private PitchResult solvePitch(final SolverContext context, final Vec3d goal, fi
                 // Ensure that the goal is visible along the entire simulated path
                 // Reverse order iteration since the last position is most likely to fail
                 for (int i = result.steps.size() - 1; i >= 1; i--) {
-                    if (!clearView(context.start.add(result.steps.get(i)), goal, false)) {
+                    if (!clearView(context.start.add(result.steps.get(i)), goal, context.ignoreLava)) {
                         continue outer;
                     }
                 }
             } else {
                 // Ensure that the goal is visible from the final position
-                if (!clearView(context.start.add(result.steps.get(result.steps.size() - 1)), goal, false)) {
+                if (!clearView(context.start.add(result.steps.get(result.steps.size() - 1)), goal, context.ignoreLava)) {
                     continue;
                 }
             }

File: src/main/java/baritone/command/defaults/ElytraCommand.java
Patch:
@@ -42,7 +42,7 @@ public ElytraCommand(IBaritone baritone) {
     public void execute(String label, IArgConsumer args) throws CommandException {
         ICustomGoalProcess customGoalProcess = baritone.getCustomGoalProcess();
         args.requireMax(0);
-        Goal iGoal = customGoalProcess.getGoal();
+        Goal iGoal = customGoalProcess.mostRecentGoal();
         if (iGoal == null) {
             throw new CommandInvalidStateException("No goal has been set");
         }

File: src/main/java/baritone/behavior/InventoryBehavior.java
Patch:
@@ -25,10 +25,8 @@
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.init.Blocks;
-import net.minecraft.init.Items;
 import net.minecraft.inventory.ClickType;
 import net.minecraft.item.*;
-import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.NonNullList;
 

File: src/main/java/baritone/command/defaults/ElytraCommand.java
Patch:
@@ -17,7 +17,6 @@
 
 package baritone.command.defaults;
 
-import baritone.Baritone;
 import baritone.api.IBaritone;
 import baritone.api.command.Command;
 import baritone.api.command.argument.IArgConsumer;

File: src/main/java/baritone/command/defaults/ExecutionControlCommands.java
Patch:
@@ -17,7 +17,6 @@
 
 package baritone.command.defaults;
 
-import baritone.Baritone;
 import baritone.api.IBaritone;
 import baritone.api.command.Command;
 import baritone.api.command.argument.IArgConsumer;

File: src/main/java/baritone/command/defaults/ForceCancelCommand.java
Patch:
@@ -17,7 +17,6 @@
 
 package baritone.command.defaults;
 
-import baritone.Baritone;
 import baritone.api.IBaritone;
 import baritone.api.behavior.IPathingBehavior;
 import baritone.api.command.Command;

File: src/main/java/baritone/utils/BaritoneMath.java
Patch:
@@ -22,11 +22,11 @@
  */
 public final class BaritoneMath {
 
-    private BaritoneMath() {}
-
     private static final double FLOOR_DOUBLE_D = 1_073_741_824.0;
     private static final int FLOOR_DOUBLE_I = 1_073_741_824;
 
+    private BaritoneMath() {}
+
     public static int fastFloor(final double v) {
         return (int) (v + FLOOR_DOUBLE_D) - FLOOR_DOUBLE_I;
     }

File: src/launch/java/baritone/launch/mixins/MixinEntityLivingBase.java
Patch:
@@ -51,7 +51,7 @@ public abstract class MixinEntityLivingBase extends Entity {
     @Unique
     private RotationMoveEvent elytraRotationEvent;
 
-    public MixinEntityLivingBase(World worldIn) {
+    private MixinEntityLivingBase(World worldIn) {
         super(worldIn);
     }
 

File: src/launch/java/baritone/launch/mixins/MixinEntity.java
Patch:
@@ -40,7 +40,4 @@ public abstract class MixinEntity {
 
     @Shadow
     public float rotationYaw;
-
-    @Shadow
-    public abstract void moveRelative(float strafe, float up, float forward, float friction);
 }

File: src/launch/java/baritone/launch/mixins/MixinEntityLivingBase.java
Patch:
@@ -117,7 +117,8 @@ private void onPostElytraMove(float strafe, float vertical, float forward, Callb
     private void onMoveRelative(EntityLivingBase self, float strafe, float up, float forward, float friction) {
         Optional<IBaritone> baritone = this.getBaritone();
         if (!baritone.isPresent()) {
-            this.moveRelative(strafe, up, forward, friction);
+            // If a shadow is used here it breaks on Forge
+            self.moveRelative(strafe, up, forward, friction);
             return;
         }
 
@@ -127,7 +128,7 @@ private void onMoveRelative(EntityLivingBase self, float strafe, float up, float
         this.rotationYaw = event.getYaw();
         this.rotationPitch = event.getPitch();
 
-        this.moveRelative(strafe, up, forward, friction);
+        self.moveRelative(strafe, up, forward, friction);
 
         this.rotationYaw = event.getOriginal().getYaw();
         this.rotationPitch = event.getOriginal().getPitch();

File: src/api/java/baritone/api/utils/RotationUtils.java
Patch:
@@ -217,7 +217,8 @@ public static Optional<Rotation> reachable(IPlayerContext ctx, BlockPos pos, dou
     public static Optional<Rotation> reachableOffset(IPlayerContext ctx, BlockPos pos, Vec3d offsetPos, double blockReachDistance, boolean wouldSneak) {
         Vec3d eyes = wouldSneak ? RayTraceUtils.inferSneakingEyePosition(ctx.player()) : ctx.player().getPositionEyes(1.0F);
         Rotation rotation = calcRotationFromVec3d(eyes, offsetPos, ctx.playerRotations());
-        RayTraceResult result = RayTraceUtils.rayTraceTowards(ctx.player(), rotation, blockReachDistance, wouldSneak);
+        Rotation actualRotation = BaritoneAPI.getProvider().getBaritoneForPlayer(ctx.player()).getLookBehavior().getAimProcessor().peekRotation(rotation);
+        RayTraceResult result = RayTraceUtils.rayTraceTowards(ctx.player(), actualRotation, blockReachDistance, wouldSneak);
         //System.out.println(result);
         if (result != null && result.typeOfHit == RayTraceResult.Type.BLOCK) {
             if (result.getBlockPos().equals(pos)) {

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -684,7 +684,8 @@ static PlaceResult attemptToPlaceABlock(MovementState state, IBaritone baritone,
                 double faceY = (placeAt.getY() + against1.getY() + 0.5D) * 0.5D;
                 double faceZ = (placeAt.getZ() + against1.getZ() + 1.0D) * 0.5D;
                 Rotation place = RotationUtils.calcRotationFromVec3d(wouldSneak ? RayTraceUtils.inferSneakingEyePosition(ctx.player()) : ctx.playerHead(), new Vec3d(faceX, faceY, faceZ), ctx.playerRotations());
-                RayTraceResult res = RayTraceUtils.rayTraceTowards(ctx.player(), place, ctx.playerController().getBlockReachDistance(), wouldSneak);
+                Rotation actual = baritone.getLookBehavior().getAimProcessor().peekRotation(place);
+                RayTraceResult res = RayTraceUtils.rayTraceTowards(ctx.player(), actual, ctx.playerController().getBlockReachDistance(), wouldSneak);
                 if (res != null && res.typeOfHit == RayTraceResult.Type.BLOCK && res.getBlockPos().equals(against1) && res.getBlockPos().offset(res.sideHit).equals(placeAt)) {
                     state.setTarget(new MovementState.MovementTarget(place, true));
                     found = true;

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -351,9 +351,10 @@ private Optional<Placement> possibleToPlace(IBlockState toPlace, int x, int y, i
                 double placeY = placeAgainstPos.y + aabb.minY * placementMultiplier.y + aabb.maxY * (1 - placementMultiplier.y);
                 double placeZ = placeAgainstPos.z + aabb.minZ * placementMultiplier.z + aabb.maxZ * (1 - placementMultiplier.z);
                 Rotation rot = RotationUtils.calcRotationFromVec3d(RayTraceUtils.inferSneakingEyePosition(ctx.player()), new Vec3d(placeX, placeY, placeZ), ctx.playerRotations());
-                RayTraceResult result = RayTraceUtils.rayTraceTowards(ctx.player(), rot, ctx.playerController().getBlockReachDistance(), true);
+                Rotation actualRot = baritone.getLookBehavior().getAimProcessor().peekRotation(rot);
+                RayTraceResult result = RayTraceUtils.rayTraceTowards(ctx.player(), actualRot, ctx.playerController().getBlockReachDistance(), true);
                 if (result != null && result.typeOfHit == RayTraceResult.Type.BLOCK && result.getBlockPos().equals(placeAgainstPos) && result.sideHit == against.getOpposite()) {
-                    OptionalInt hotbar = hasAnyItemThatWouldPlace(toPlace, result, rot);
+                    OptionalInt hotbar = hasAnyItemThatWouldPlace(toPlace, result, actualRot);
                     if (hotbar.isPresent()) {
                         return Optional.of(new Placement(hotbar.getAsInt(), placeAgainstPos, against.getOpposite(), rot));
                     }

File: src/api/java/baritone/api/utils/RotationUtils.java
Patch:
@@ -217,7 +217,8 @@ public static Optional<Rotation> reachable(IPlayerContext ctx, BlockPos pos, dou
     public static Optional<Rotation> reachableOffset(IPlayerContext ctx, BlockPos pos, Vec3d offsetPos, double blockReachDistance, boolean wouldSneak) {
         Vec3d eyes = wouldSneak ? RayTraceUtils.inferSneakingEyePosition(ctx.player()) : ctx.player().getPositionEyes(1.0F);
         Rotation rotation = calcRotationFromVec3d(eyes, offsetPos, ctx.playerRotations());
-        RayTraceResult result = RayTraceUtils.rayTraceTowards(ctx.player(), rotation, blockReachDistance, wouldSneak);
+        Rotation actualRotation = BaritoneAPI.getProvider().getBaritoneForPlayer(ctx.player()).getLookBehavior().getAimProcessor().peekRotation(rotation);
+        RayTraceResult result = RayTraceUtils.rayTraceTowards(ctx.player(), actualRotation, blockReachDistance, wouldSneak);
         //System.out.println(result);
         if (result != null && result.typeOfHit == RayTraceResult.Type.BLOCK) {
             if (result.getBlockPos().equals(pos)) {

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -684,7 +684,8 @@ static PlaceResult attemptToPlaceABlock(MovementState state, IBaritone baritone,
                 double faceY = (placeAt.getY() + against1.getY() + 0.5D) * 0.5D;
                 double faceZ = (placeAt.getZ() + against1.getZ() + 1.0D) * 0.5D;
                 Rotation place = RotationUtils.calcRotationFromVec3d(wouldSneak ? RayTraceUtils.inferSneakingEyePosition(ctx.player()) : ctx.playerHead(), new Vec3d(faceX, faceY, faceZ), ctx.playerRotations());
-                RayTraceResult res = RayTraceUtils.rayTraceTowards(ctx.player(), place, ctx.playerController().getBlockReachDistance(), wouldSneak);
+                Rotation actual = baritone.getLookBehavior().getAimProcessor().peekRotation(place);
+                RayTraceResult res = RayTraceUtils.rayTraceTowards(ctx.player(), actual, ctx.playerController().getBlockReachDistance(), wouldSneak);
                 if (res != null && res.typeOfHit == RayTraceResult.Type.BLOCK && res.getBlockPos().equals(against1) && res.getBlockPos().offset(res.sideHit).equals(placeAt)) {
                     state.setTarget(new MovementState.MovementTarget(place, true));
                     found = true;

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -351,9 +351,10 @@ private Optional<Placement> possibleToPlace(IBlockState toPlace, int x, int y, i
                 double placeY = placeAgainstPos.y + aabb.minY * placementMultiplier.y + aabb.maxY * (1 - placementMultiplier.y);
                 double placeZ = placeAgainstPos.z + aabb.minZ * placementMultiplier.z + aabb.maxZ * (1 - placementMultiplier.z);
                 Rotation rot = RotationUtils.calcRotationFromVec3d(RayTraceUtils.inferSneakingEyePosition(ctx.player()), new Vec3d(placeX, placeY, placeZ), ctx.playerRotations());
-                RayTraceResult result = RayTraceUtils.rayTraceTowards(ctx.player(), rot, ctx.playerController().getBlockReachDistance(), true);
+                Rotation actualRot = baritone.getLookBehavior().getAimProcessor().peekRotation(rot);
+                RayTraceResult result = RayTraceUtils.rayTraceTowards(ctx.player(), actualRot, ctx.playerController().getBlockReachDistance(), true);
                 if (result != null && result.typeOfHit == RayTraceResult.Type.BLOCK && result.getBlockPos().equals(placeAgainstPos) && result.sideHit == against.getOpposite()) {
-                    OptionalInt hotbar = hasAnyItemThatWouldPlace(toPlace, result, rot);
+                    OptionalInt hotbar = hasAnyItemThatWouldPlace(toPlace, result, actualRot);
                     if (hotbar.isPresent()) {
                         return Optional.of(new Placement(hotbar.getAsInt(), placeAgainstPos, against.getOpposite(), rot));
                     }

File: src/main/java/baritone/behavior/ElytraBehavior.java
Patch:
@@ -39,6 +39,7 @@
 
 import java.util.*;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Future;
 import java.util.function.UnaryOperator;
 
@@ -68,8 +69,8 @@ public final class ElytraBehavior extends Behavior implements IElytraBehavior, H
     public ElytraBehavior(Baritone baritone) {
         super(baritone);
         this.context = new NetherPathfinderContext(NETHER_SEED);
-        this.clearLines = new ArrayList<>();
-        this.blockedLines = new ArrayList<>();
+        this.clearLines = new CopyOnWriteArrayList<>();
+        this.blockedLines = new CopyOnWriteArrayList<>();
         this.visiblePath = Collections.emptyList();
         this.pathManager = this.new PathManager();
     }

File: src/main/java/baritone/command/defaults/GotoCommand.java
Patch:
@@ -20,7 +20,6 @@
 import baritone.api.IBaritone;
 import baritone.api.command.Command;
 import baritone.api.command.argument.IArgConsumer;
-import baritone.api.command.datatypes.BlockById;
 import baritone.api.command.datatypes.ForBlockOptionalMeta;
 import baritone.api.command.datatypes.RelativeCoordinate;
 import baritone.api.command.datatypes.RelativeGoal;
@@ -61,7 +60,7 @@ public void execute(String label, IArgConsumer args) throws CommandException {
     public Stream<String> tabComplete(String label, IArgConsumer args) throws CommandException {
         // since it's either a goal or a block, I don't think we can tab complete properly?
         // so just tab complete for the block variant
-        return args.tabCompleteDatatype(BlockById.INSTANCE);
+        return args.tabCompleteDatatype(ForBlockOptionalMeta.INSTANCE);
     }
 
     @Override

File: src/main/java/baritone/command/defaults/MineCommand.java
Patch:
@@ -21,7 +21,6 @@
 import baritone.api.IBaritone;
 import baritone.api.command.Command;
 import baritone.api.command.argument.IArgConsumer;
-import baritone.api.command.datatypes.BlockById;
 import baritone.api.command.datatypes.ForBlockOptionalMeta;
 import baritone.api.command.exception.CommandException;
 import baritone.api.utils.BlockOptionalMeta;
@@ -53,7 +52,7 @@ public void execute(String label, IArgConsumer args) throws CommandException {
 
     @Override
     public Stream<String> tabComplete(String label, IArgConsumer args) {
-        return args.tabCompleteDatatype(BlockById.INSTANCE);
+        return args.tabCompleteDatatype(ForBlockOptionalMeta.INSTANCE);
     }
 
     @Override

File: src/main/java/baritone/behavior/ElytraBehavior.java
Patch:
@@ -340,7 +340,6 @@ public void onTick(TickEvent event) {
             return;
         }
         if (isPaused()) return;
-        this.lines.clear();
         this.clearLines.clear();
         this.blockedLines.clear();
 

File: src/main/java/baritone/behavior/ElytraBehavior.java
Patch:
@@ -455,7 +455,7 @@ private boolean isClear(final Vec3d start, final Vec3d dest, final Double growAm
     }
 
     private boolean clearView(Vec3d start, Vec3d dest) {
-        boolean oxy = !rayTraceBlocks(start.x, start.y, start.z, dest.x, dest.y, dest.z);
+        boolean oxy = !rayTraceBlocks(start.x + 0.0001 * Math.random(), start.y + 0.0001 * Math.random(), start.z + 0.0001 * Math.random(), dest.x + 0.0001 * Math.random(), dest.y + 0.0001 * Math.random(), dest.z + 0.0001 * Math.random());
         boolean meow = !rayTraceBlocks(start, dest);
         if (oxy != meow) {
             logDirect(start + " " + dest + " " + oxy + " " + meow);

File: src/main/java/baritone/behavior/ElytraBehavior.java
Patch:
@@ -386,7 +386,7 @@ public void onTick(TickEvent event) {
                             continue;
                         }
                         long b = System.currentTimeMillis();
-                        System.out.println("Solved pitch in " + (b - a) + " total time " + (b - t));
+                        //System.out.println("Solved pitch in " + (b - a) + " total time " + (b - t));
                         this.pathManager.setGoingTo(i);
                         this.aimPos = path.get(i).add(0, dy, 0);
                         baritone.getLookBehavior().updateTarget(new Rotation(rot.getYaw(), pitch), false);
@@ -648,4 +648,4 @@ private RayTraceResult rayTraceBlocks(Vec3d start, Vec3d end) {
         }
         return null;
     }
-}
+}
\ No newline at end of file

File: src/main/java/baritone/behavior/elytra/NetherPathfinderContext.java
Patch:
@@ -100,7 +100,7 @@ private static boolean[] pack(Chunk chunk) {
                         for (int x = 0; x < 16; x++) {
                             IBlockState state = bsc.get(x, y1, z);
                             if (!passable(state)) {
-                                packed[x + (z << 4) + (y << 8)] = true;
+                                packed[x | (z << 4) | (y << 8)] = true;
                             }
                         }
                     }
@@ -112,4 +112,4 @@ private static boolean[] pack(Chunk chunk) {
             throw new RuntimeException(e);
         }
     }
-}
+}
\ No newline at end of file

File: src/main/java/baritone/behavior/ElytraBehavior.java
Patch:
@@ -319,11 +319,12 @@ public void onTick(TickEvent event) {
                 Math.min(playerNear + 30, path.size())
         );
 
-        baritone.getInputOverrideHandler().clearAllKeys(); // FIXME: This breaks the regular path-finder
-
         if (!ctx.player().isElytraFlying()) {
             return;
         }
+
+        baritone.getInputOverrideHandler().clearAllKeys();
+
         if (ctx.player().collidedHorizontally) {
             logDirect("hbonk");
         }

File: src/main/java/baritone/command/defaults/ElytraCommand.java
Patch:
@@ -41,7 +41,7 @@ public void execute(String label, IArgConsumer args) throws CommandException {
         ICustomGoalProcess customGoalProcess = baritone.getCustomGoalProcess();
         args.requireMax(0);
         GoalXZ goal = (GoalXZ) customGoalProcess.getGoal();
-        ((Baritone) baritone).elytra.path(146008555100680L, new BlockPos(goal.getX(), 64, goal.getZ()));
+        ((Baritone) baritone).elytra.path(new BlockPos(goal.getX(), 64, goal.getZ()));
     }
 
     @Override

File: src/main/java/baritone/utils/PathRenderer.java
Patch:
@@ -106,8 +106,8 @@ public static void render(RenderEvent event, PathingBehavior behavior) {
         }
 
         drawPath(behavior.baritone.elytra.visiblePath, 0, Color.RED, false, 0, 0);
-        if (behavior.baritone.elytra.goal != null) {
-            drawGoal(renderView, new GoalBlock(behavior.baritone.elytra.goal), partialTicks, Color.GREEN);
+        if (behavior.baritone.elytra.aimPos != null) {
+            drawGoal(renderView, new GoalBlock(behavior.baritone.elytra.aimPos), partialTicks, Color.GREEN);
         }
         if (!behavior.baritone.elytra.lines.isEmpty() && Baritone.settings().renderRaytraces.value) {
             IRenderer.startLines(Color.BLUE, settings.pathRenderLineWidthPixels.value, settings.renderPathIgnoreDepth.value);

File: src/main/java/baritone/utils/IRenderer.java
Patch:
@@ -116,7 +116,7 @@ static void emitAABB(AxisAlignedBB aabb, double expand) {
     }
 
     static void drawAABB(AxisAlignedBB aabb) {
-        buffer.begin(GL_LINES, DefaultVertexFormats.POSITION);
+        buffer.begin(GL_LINES, DefaultVertexFormats.POSITION_COLOR);
         emitAABB(aabb);
         tessellator.draw();
     }

File: src/main/java/baritone/utils/GuiClick.java
Patch:
@@ -119,7 +119,7 @@ public void onRender() {
             if (clickStart != null && !clickStart.equals(currentMouseOver)) {
                 GlStateManager.enableBlend();
                 GlStateManager.tryBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);
-                GlStateManager.color(Color.RED.getColorComponents(null)[0], Color.RED.getColorComponents(null)[1], Color.RED.getColorComponents(null)[2], 0.4F);
+                IRenderer.glColor(Color.RED, 0.4F);
                 GlStateManager.glLineWidth(Baritone.settings().pathRenderLineWidthPixels.value);
                 GlStateManager.disableTexture2D();
                 GlStateManager.depthMask(false);

File: src/main/java/baritone/utils/IRenderer.java
Patch:
@@ -116,7 +116,7 @@ static void emitAABB(AxisAlignedBB aabb, double expand) {
     }
 
     static void drawAABB(AxisAlignedBB aabb) {
-        buffer.begin(GL_LINES, DefaultVertexFormats.POSITION);
+        buffer.begin(GL_LINES, DefaultVertexFormats.POSITION_COLOR);
         emitAABB(aabb);
         tessellator.draw();
     }

File: src/main/java/baritone/utils/PathRenderer.java
Patch:
@@ -115,7 +115,6 @@ public static void render(RenderEvent event, PathingBehavior behavior) {
             settings.renderPathAsLine.value = true;
             for (Pair<Vec3d, Vec3d> line : behavior.baritone.elytra.lines) {
                 emitLine(line.first().x, line.first().y, line.first().z, line.second().x, line.second().y, line.second().z);
-                tessellator.draw();
             }
             settings.renderPathAsLine.value = orig;
             IRenderer.endLines(settings.renderPathIgnoreDepth.value);

File: src/launch/java/baritone/launch/mixins/MixinEntityPlayerSP.java
Patch:
@@ -61,9 +61,8 @@ private void sendChatMessage(String msg, CallbackInfo ci) {
             method = "onUpdate",
             at = @At(
                     value = "INVOKE",
-                    target = "net/minecraft/client/entity/EntityPlayerSP.isRiding()Z",
-                    shift = At.Shift.BY,
-                    by = -3
+                    target = "net/minecraft/client/entity/AbstractClientPlayer.onUpdate()V",
+                    shift = At.Shift.AFTER
             )
     )
     private void onPreUpdate(CallbackInfo ci) {

File: src/main/java/baritone/utils/PathRenderer.java
Patch:
@@ -108,14 +108,14 @@ public static void render(RenderEvent event, PathingBehavior behavior) {
 
         drawPath(Elytra.path.subList(Math.max(behavior.baritone.elytra.playerNear - 30, 0), Math.min(behavior.baritone.elytra.playerNear + 30, Elytra.path.size())), 0, Color.RED, false, 0, 0);
         if (behavior.baritone.elytra.goal != null) {
-            drawDankLitGoalBox(renderView, new GoalBlock(behavior.baritone.elytra.goal), partialTicks, Color.GREEN);
+            drawGoal(renderView, new GoalBlock(behavior.baritone.elytra.goal), partialTicks, Color.GREEN);
         }
         if (!behavior.baritone.elytra.lines.isEmpty() && Baritone.settings().renderRaytraces.value) {
             IRenderer.startLines(Color.BLUE, settings.pathRenderLineWidthPixels.value, settings.renderPathIgnoreDepth.value);
             boolean orig = settings.renderPathAsLine.value;
             settings.renderPathAsLine.value = true;
             for (Pair<Vec3d, Vec3d> line : behavior.baritone.elytra.lines) {
-                drawLine(line.first().x, line.first().y, line.first().z, line.second().x, line.second().y, line.second().z);
+                emitLine(line.first().x, line.first().y, line.first().z, line.second().x, line.second().y, line.second().z);
                 tessellator.draw();
             }
             settings.renderPathAsLine.value = orig;

File: src/api/java/baritone/api/utils/IPlayerContext.java
Patch:
@@ -75,6 +75,8 @@ default Vec3d playerHead() {
         return new Vec3d(player().posX, player().posY + player().getEyeHeight(), player().posZ);
     }
 
+    BetterBlockPos viewerPos();
+
     default Rotation playerRotations() {
         return new Rotation(player().rotationYaw, player().rotationPitch);
     }

File: src/main/java/baritone/BaritoneProvider.java
Patch:
@@ -45,7 +45,7 @@ public final class BaritoneProvider implements IBaritoneProvider {
         this.all = Collections.singletonList(this.primary);
 
         // Setup chat control, just for the primary instance
-        new ExampleBaritoneControl(this.primary);
+        this.primary.registerBehavior(ExampleBaritoneControl::new);
     }
 
     @Override

File: src/main/java/baritone/command/defaults/ExploreFilterCommand.java
Patch:
@@ -41,7 +41,7 @@ public ExploreFilterCommand(IBaritone baritone) {
     @Override
     public void execute(String label, IArgConsumer args) throws CommandException {
         args.requireMax(2);
-        File file = args.getDatatypePost(RelativeFile.INSTANCE, mc.gameDir.getAbsoluteFile().getParentFile());
+        File file = args.getDatatypePost(RelativeFile.INSTANCE, ctx.minecraft().gameDir.getAbsoluteFile().getParentFile());
         boolean invert = false;
         if (args.hasAny()) {
             if (args.getString().equalsIgnoreCase("invert")) {
@@ -65,7 +65,7 @@ public void execute(String label, IArgConsumer args) throws CommandException {
     @Override
     public Stream<String> tabComplete(String label, IArgConsumer args) throws CommandException {
         if (args.hasExactlyOne()) {
-            return RelativeFile.tabComplete(args, RelativeFile.gameDir());
+            return RelativeFile.tabComplete(args, RelativeFile.gameDir(ctx.minecraft()));
         }
         return Stream.empty();
     }

File: src/main/java/baritone/command/defaults/RenderCommand.java
Patch:
@@ -37,8 +37,8 @@ public RenderCommand(IBaritone baritone) {
     public void execute(String label, IArgConsumer args) throws CommandException {
         args.requireMax(0);
         BetterBlockPos origin = ctx.playerFeet();
-        int renderDistance = (mc.gameSettings.renderDistanceChunks + 1) * 16;
-        mc.renderGlobal.markBlockRangeForRenderUpdate(
+        int renderDistance = (ctx.minecraft().gameSettings.renderDistanceChunks + 1) * 16;
+        ctx.minecraft().renderGlobal.markBlockRangeForRenderUpdate(
                 origin.x - renderDistance,
                 0,
                 origin.z - renderDistance,

File: src/main/java/baritone/command/defaults/SelCommand.java
Patch:
@@ -92,7 +92,7 @@ public void execute(String label, IArgConsumer args) throws CommandException {
             if (action == Action.POS2 && pos1 == null) {
                 throw new CommandInvalidStateException("Set pos1 first before using pos2");
             }
-            BetterBlockPos playerPos = mc.getRenderViewEntity() != null ? BetterBlockPos.from(new BlockPos(mc.getRenderViewEntity())) : ctx.playerFeet();
+            BetterBlockPos playerPos = ctx.viewerPos();
             BetterBlockPos pos = args.hasAny() ? args.getDatatypePost(RelativeBlockPos.INSTANCE, playerPos) : playerPos;
             args.requireMax(0);
             if (action == Action.POS1) {
@@ -198,7 +198,7 @@ public void execute(String label, IArgConsumer args) throws CommandException {
             baritone.getBuilderProcess().build("Fill", composite, origin);
             logDirect("Filling now");
         } else if (action == Action.COPY) {
-            BetterBlockPos playerPos = mc.getRenderViewEntity() != null ? BetterBlockPos.from(new BlockPos(mc.getRenderViewEntity())) : ctx.playerFeet();
+            BetterBlockPos playerPos = ctx.viewerPos();
             BetterBlockPos pos = args.hasAny() ? args.getDatatypePost(RelativeBlockPos.INSTANCE, playerPos) : playerPos;
             args.requireMax(0);
             ISelection[] selections = manager.getSelections();
@@ -239,7 +239,7 @@ public void execute(String label, IArgConsumer args) throws CommandException {
             clipboardOffset = origin.subtract(pos);
             logDirect("Selection copied");
         } else if (action == Action.PASTE) {
-            BetterBlockPos playerPos = mc.getRenderViewEntity() != null ? BetterBlockPos.from(new BlockPos(mc.getRenderViewEntity())) : ctx.playerFeet();
+            BetterBlockPos playerPos = ctx.viewerPos();
             BetterBlockPos pos = args.hasAny() ? args.getDatatypePost(RelativeBlockPos.INSTANCE, playerPos) : playerPos;
             args.requireMax(0);
             if (clipboard == null) {

File: src/main/java/baritone/command/defaults/SurfaceCommand.java
Patch:
@@ -54,7 +54,7 @@ public void execute(String label, IArgConsumer args) throws CommandException {
         for (int currentIteratedY = startingYPos; currentIteratedY < worldHeight; currentIteratedY++) {
             final BetterBlockPos newPos = new BetterBlockPos(playerPos.getX(), currentIteratedY, playerPos.getZ());
 
-            if (!(mc.world.getBlockState(newPos).getBlock() instanceof BlockAir) && newPos.getY() > playerPos.getY()) {
+            if (!(ctx.world().getBlockState(newPos).getBlock() instanceof BlockAir) && newPos.getY() > playerPos.getY()) {
                 Goal goal = new GoalBlock(newPos.up());
                 logDirect(String.format("Going to: %s", goal.toString()));
                 baritone.getCustomGoalProcess().setGoalAndPath(goal);

File: src/main/java/baritone/process/InventoryPauserProcess.java
Patch:
@@ -34,14 +34,14 @@ public InventoryPauserProcess(Baritone baritone) {
 
     @Override
     public boolean isActive() {
-        if (mc.player == null || mc.world == null) {
+        if (ctx.player() == null || ctx.world() == null) {
             return false;
         }
         return true;
     }
 
     private double motion() {
-        return Math.sqrt(mc.player.motionX * mc.player.motionX + mc.player.motionZ * mc.player.motionZ);
+        return Math.sqrt(ctx.player().motionX * ctx.player().motionX + ctx.player().motionZ * ctx.player().motionZ);
     }
 
     private boolean stationaryNow() {

File: src/main/java/baritone/utils/PathingControlManager.java
Patch:
@@ -160,7 +160,7 @@ public boolean forceRevalidate(Goal newGoal) {
             if (newGoal.isInGoal(current.getPath().getDest())) {
                 return false;
             }
-            return !newGoal.toString().equals(current.getPath().getGoal().toString());
+            return !newGoal.equals(current.getPath().getGoal());
         }
         return false;
     }

File: src/api/java/baritone/api/pathing/goals/GoalBlock.java
Patch:
@@ -77,7 +77,7 @@ public boolean equals(Object o) {
 
         GoalBlock goal = (GoalBlock) o;
         return x == goal.x
-                && y != goal.y
+                && y == goal.y
                 && z == goal.z;
     }
 

File: src/api/java/baritone/api/pathing/goals/GoalStrictDirection.java
Patch:
@@ -80,7 +80,7 @@ public boolean equals(Object o) {
 
         GoalStrictDirection goal = (GoalStrictDirection) o;
         return x == goal.x
-                && y != goal.y
+                && y == goal.y
                 && z == goal.z
                 && dx == goal.dx
                 && dz == goal.dz;

File: src/main/java/baritone/utils/PathingControlManager.java
Patch:
@@ -160,7 +160,7 @@ public boolean forceRevalidate(Goal newGoal) {
             if (newGoal.isInGoal(current.getPath().getDest())) {
                 return false;
             }
-            return !newGoal.toString().equals(current.getPath().getGoal().toString());
+            return !newGoal.equals(current.getPath().getGoal());
         }
         return false;
     }

File: src/main/java/baritone/Elytra.java
Patch:
@@ -109,7 +109,7 @@ && new Vec3d(ctx.player().motionX, ctx.player().posY < path.get(goingTo).y ? Mat
                 int lookahead = relaxation == 0 ? 2 : 3; // ideally this would be expressed as a distance in blocks, rather than a number of voxel steps
                 //int minStep = Math.max(0, playerNear - relaxation);
                 int minStep = playerNear;
-                for (int i = Math.min(playerNear + 20, path.size()); i >= minStep; i--) {
+                for (int i = Math.min(playerNear + 20, path.size() - 1); i >= minStep; i--) {
                     for (int dy : heights) {
                         Vec3d dest = new Vec3d(path.get(i)).add(0, dy, 0);
                         if (dy != 0) {

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -726,7 +726,7 @@ public final class Settings {
     /**
      * Break and place blocks without having to force the client-sided rotations
      */
-    public final Setting<Boolean> blockFreeLook = new Setting<>(true);
+    public final Setting<Boolean> blockFreeLook = new Setting<>(false);
 
     /**
      * Will cause some minor behavioral differences to ensure that Baritone works on anticheats.

File: src/main/java/baritone/Baritone.java
Patch:
@@ -88,6 +88,7 @@ public class Baritone implements IBaritone {
 
     private IPlayerContext playerContext;
     private WorldProvider worldProvider;
+    public Elytra elytra;
 
     public BlockStateInterface bsi;
 
@@ -100,6 +101,7 @@ public class Baritone implements IBaritone {
         {
             // the Behavior constructor calls baritone.registerBehavior(this) so this populates the behaviors arraylist
             pathingBehavior = new PathingBehavior(this);
+            elytra = new Elytra(this);
             lookBehavior = new LookBehavior(this);
             inventoryBehavior = new InventoryBehavior(this);
             inputOverrideHandler = new InputOverrideHandler(this);

File: buildSrc/src/main/java/baritone/gradle/task/CreateDistTask.java
Patch:
@@ -41,6 +41,7 @@ public class CreateDistTask extends BaritoneGradleTask {
 
     @TaskAction
     protected void exec() throws Exception {
+        super.doFirst();
         super.verifyArtifacts();
 
         // Define the distribution file paths

File: buildSrc/src/main/java/baritone/gradle/task/CreateDistTask.java
Patch:
@@ -41,6 +41,7 @@ public class CreateDistTask extends BaritoneGradleTask {
 
     @TaskAction
     protected void exec() throws Exception {
+        super.doFirst();
         super.verifyArtifacts();
 
         // Define the distribution file paths

File: src/main/java/baritone/pathing/precompute/PrecomputedData.java
Patch:
@@ -52,7 +52,7 @@ private int fillData(int id, IBlockState state) {
         if (canWalkThroughState == YES) {
             blockData |= CAN_WALK_THROUGH_MASK;
         }
-        if (canWalkOnState == MAYBE) {
+        if (canWalkThroughState == MAYBE) {
             blockData |= CAN_WALK_THROUGH_SPECIAL_MASK;
         }
 

File: src/main/java/baritone/pathing/precompute/PrecomputedData.java
Patch:
@@ -52,7 +52,7 @@ private int fillData(int id, IBlockState state) {
         if (canWalkThroughState == YES) {
             blockData |= CAN_WALK_THROUGH_MASK;
         }
-        if (canWalkOnState == MAYBE) {
+        if (canWalkThroughState == MAYBE) {
             blockData |= CAN_WALK_THROUGH_SPECIAL_MASK;
         }
 

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -51,7 +51,7 @@
 public interface MovementHelper extends ActionCosts, Helper {
 
     static boolean avoidBreaking(BlockStateInterface bsi, int x, int y, int z, IBlockState state) {
-        if (!bsi.worldBorder.canPlaceAt(x, y)) {
+        if (!bsi.worldBorder.canPlaceAt(x, z)) {
             return true;
         }
         Block b = state.getBlock();

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -51,7 +51,7 @@
 public interface MovementHelper extends ActionCosts, Helper {
 
     static boolean avoidBreaking(BlockStateInterface bsi, int x, int y, int z, IBlockState state) {
-        if (!bsi.worldBorder.canPlaceAt(x, y)) {
+        if (!bsi.worldBorder.canPlaceAt(x, z)) {
             return true;
         }
         Block b = state.getBlock();

File: src/main/java/baritone/cache/WorldProvider.java
Patch:
@@ -142,6 +142,8 @@ private final void detectAndHandleBrokenLoading() {
             if (mc.world != null) {
                 initWorld(mc.world.provider.getDimensionType().getId());
             }
+        } else if (currentWorld == null && mc.world != null) {
+            initWorld(mc.world.provider.getDimensionType().getId());
         }
     }
 }

File: src/main/java/baritone/cache/FasterWorldScanner.java
Patch:
@@ -25,7 +25,6 @@
 import baritone.utils.accessor.IBitArray;
 import baritone.utils.accessor.IBlockStateContainer;
 import io.netty.buffer.Unpooled;
-import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import net.minecraft.block.Block;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.network.PacketBuffer;
@@ -49,12 +48,12 @@ public enum FasterWorldScanner implements IWorldScanner {
     INSTANCE;
     @Override
     public List<BlockPos> scanChunkRadius(IPlayerContext ctx, BlockOptionalMetaLookup filter, int max, int yLevelThreshold, int maxSearchRadius) {
-        return new WorldScannerContext(filter, ctx).scanAroundPlayerRange(maxSearchRadius);
+        return new WorldScannerContext(filter, ctx).scanAroundPlayer(maxSearchRadius, max);
     }
 
     @Override
     public List<BlockPos> scanChunk(IPlayerContext ctx, BlockOptionalMetaLookup filter, ChunkPos pos, int max, int yLevelThreshold) {
-        return new WorldScannerContext(filter, ctx).scanAroundPlayerUntilCount(max);
+        return new WorldScannerContext(filter, ctx).scanChunkInternal(pos).collect(Collectors.toList());
     }
 
     @Override

File: src/main/java/baritone/utils/schematic/format/defaults/LitematicaSchematic.java
Patch:
@@ -136,7 +136,7 @@ private static <T extends Comparable<T>> IBlockState setPropertyValue(IBlockStat
      * @return amount of bits used to encode a block.
      */
     private static int getBitsPerBlock(int amountOfBlockTypes) {
-        return (int) Math.floor((Math.log(amountOfBlockTypes)) / Math.log(2)) + 1;
+        return (int) Math.max(2,Math.ceil(Math.log(amountOfBlockTypes) / Math.log(2)));
     }
 
     /**

File: src/api/java/baritone/api/command/registry/Registry.java
Patch:
@@ -84,7 +84,7 @@ public boolean register(V entry) {
      * @param entry The entry to unregister.
      */
     public void unregister(V entry) {
-        if (registered(entry)) {
+        if (!registered(entry)) {
             return;
         }
         _entries.remove(entry);

File: src/main/java/baritone/cache/WorldProvider.java
Patch:
@@ -83,6 +83,7 @@ public final void initWorld(ResourceKey<Level> worldKey, DimensionType world) {
                     folderName = mc.getCurrentServer().ip;
                 } else {
                     //replaymod causes null currentServerData and false singleplayer.
+                    System.out.println("BARITONE: setting current world to null");
                     currentWorld = null;
                     return;
                 }

File: buildSrc/src/main/java/baritone/gradle/task/ProguardTask.java
Patch:
@@ -225,6 +225,7 @@ private void generateConfigs() throws Exception {
 
         template.add(2, "-libraryjars  <java.home>/jmods/java.base.jmod(!**.jar;!module-info.class)");
         template.add(3, "-libraryjars  <java.home>/jmods/java.desktop.jmod(!**.jar;!module-info.class)");
+        template.add(4, "-libraryjars  <java.home>/jmods/jdk.unsupported.jmod(!**.jar;!module-info.class)");
 
         {
             final Stream<File> libraries;

File: src/api/java/baritone/api/command/registry/Registry.java
Patch:
@@ -84,7 +84,7 @@ public boolean register(V entry) {
      * @param entry The entry to unregister.
      */
     public void unregister(V entry) {
-        if (registered(entry)) {
+        if (!registered(entry)) {
             return;
         }
         _entries.remove(entry);

File: src/main/java/baritone/utils/schematic/format/defaults/LitematicaSchematic.java
Patch:
@@ -136,7 +136,7 @@ private static <T extends Comparable<T>> IBlockState setPropertyValue(IBlockStat
      * @return amount of bits used to encode a block.
      */
     private static int getBitsPerBlock(int amountOfBlockTypes) {
-        return (int) Math.floor((Math.log(amountOfBlockTypes)) / Math.log(2)) + 1;
+        return (int) Math.max(2,Math.ceil(Math.log(amountOfBlockTypes) / Math.log(2)));
     }
 
     /**

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -123,7 +123,7 @@ protected boolean playerInValidPosition() {
     public MovementStatus update() {
         ctx.player().getAbilities().flying = false;
         currentState = updateState(currentState);
-        if (MovementHelper.isLiquid(ctx, ctx.playerFeet())) {
+        if (MovementHelper.isLiquid(ctx, ctx.playerFeet()) && ctx.player().position().y < dest.y + 0.6) {
             currentState.setInput(Input.JUMP, true);
         }
         if (ctx.player().isInWall()) {

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -70,7 +70,7 @@ public double calculateCost(CalculationContext context) {
 
     @Override
     protected Set<BetterBlockPos> calculateValidPositions() {
-        return ImmutableSet.of(src, dest);
+        return ImmutableSet.of(src, dest); // src.above means that we don't get caught in an infinite loop in water
     }
 
     public static double cost(CalculationContext context, int x, int y, int z, int destX, int destZ) {
@@ -237,6 +237,7 @@ public MovementState updateState(MovementState state) {
         if (feet.getY() != dest.getY() && !ladder) {
             logDebug("Wrong Y coordinate");
             if (feet.getY() < dest.getY()) {
+                System.out.println("In movement traverse");
                 return state.setInput(Input.JUMP, true);
             }
             return state;

File: src/main/java/baritone/command/defaults/ExecutionControlCommands.java
Patch:
@@ -79,7 +79,7 @@ public String displayName0() {
                     }
                 }
         );
-        pauseCommand = new Command(baritone, "pause", "p") {
+        pauseCommand = new Command(baritone, "pause", "p", "paws") {
             @Override
             public void execute(String label, IArgConsumer args) throws CommandException {
                 args.requireMax(0);
@@ -112,7 +112,7 @@ public List<String> getLongDesc() {
                 );
             }
         };
-        resumeCommand = new Command(baritone, "resume", "r", "unpause") {
+        resumeCommand = new Command(baritone, "resume", "r", "unpause", "unpaws") {
             @Override
             public void execute(String label, IArgConsumer args) throws CommandException {
                 args.requireMax(0);

File: src/main/java/baritone/process/BackfillProcess.java
Patch:
@@ -55,12 +55,12 @@ public boolean isActive() {
             Baritone.settings().backfill.value = false;
             return false;
         }
-        amIBreakingABlockHMMMMMMM();
         for (BlockPos pos : new ArrayList<>(blocksToReplace.keySet())) {
-            if (ctx.world().getChunk(pos) instanceof EmptyChunk) {
+            if (ctx.world().getChunk(pos) instanceof EmptyChunk || ctx.world().getBlockState(pos).getBlock() != Blocks.AIR) {
                 blocksToReplace.remove(pos);
             }
         }
+        amIBreakingABlockHMMMMMMM();
         baritone.getInputOverrideHandler().clearAllKeys();
 
         return !toFillIn().isEmpty();
@@ -92,7 +92,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
     }
 
     private void amIBreakingABlockHMMMMMMM() {
-        if (!ctx.getSelectedBlock().isPresent()) {
+        if (!ctx.getSelectedBlock().isPresent() || !baritone.getPathingBehavior().isPathing()) {
             return;
         }
         blocksToReplace.put(ctx.getSelectedBlock().get(), ctx.world().getBlockState(ctx.getSelectedBlock().get()));

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -26,9 +26,9 @@
 import baritone.api.process.PathingCommand;
 import baritone.api.process.PathingCommandType;
 import baritone.api.schematic.FillSchematic;
-import baritone.api.schematic.SubstituteSchematic;
 import baritone.api.schematic.ISchematic;
 import baritone.api.schematic.IStaticSchematic;
+import baritone.api.schematic.SubstituteSchematic;
 import baritone.api.schematic.format.ISchematicFormat;
 import baritone.api.utils.BetterBlockPos;
 import baritone.api.utils.RayTraceUtils;

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -123,7 +123,7 @@ protected boolean playerInValidPosition() {
     public MovementStatus update() {
         ctx.player().getAbilities().flying = false;
         currentState = updateState(currentState);
-        if (MovementHelper.isLiquid(ctx, ctx.playerFeet())) {
+        if (MovementHelper.isLiquid(ctx, ctx.playerFeet()) && ctx.player().position().y < dest.y + 0.6) {
             currentState.setInput(Input.JUMP, true);
         }
         if (ctx.player().isInWall()) {

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -70,7 +70,7 @@ public double calculateCost(CalculationContext context) {
 
     @Override
     protected Set<BetterBlockPos> calculateValidPositions() {
-        return ImmutableSet.of(src, src.above(), dest); // src.above means that we don't get caught in an infinite loop in water
+        return ImmutableSet.of(src, dest); // src.above means that we don't get caught in an infinite loop in water
     }
 
     public static double cost(CalculationContext context, int x, int y, int z, int destX, int destZ) {
@@ -237,6 +237,7 @@ public MovementState updateState(MovementState state) {
         if (feet.getY() != dest.getY() && !ladder) {
             logDebug("Wrong Y coordinate");
             if (feet.getY() < dest.getY()) {
+                System.out.println("In movement traverse");
                 return state.setInput(Input.JUMP, true);
             }
             return state;

File: src/main/java/baritone/utils/schematic/format/defaults/LitematicaSchematic.java
Patch:
@@ -62,7 +62,7 @@ public LitematicaSchematic(NBTTagCompound nbtTagCompound, boolean rotated) {
     }
 
     private int getMinOfSchematic(String s) {
-        int n = 0;
+        int n = Integer.MAX_VALUE;
         for (String subReg : getRegions(nbt)) {
             n = Math.min(n, getMinOfSubregion(nbt, subReg, s));
         }

File: src/main/java/baritone/utils/schematic/format/DefaultSchematicFormats.java
Patch:
@@ -78,7 +78,7 @@ public IStaticSchematic parse(InputStream input) throws IOException {
             int version = nbt.getInteger("Version");
             switch (version) {
                 case 4: //1.12
-                    return new LitematicaSchematic(nbt);
+                    return new LitematicaSchematic(nbt, false);
                 case 5: //1.13-1.17
                 case 6: //1.18+
                     throw new UnsupportedOperationException("This litematic Verion is to new.");

File: src/main/java/baritone/pathing/movement/movements/MovementDiagonal.java
Patch:
@@ -135,6 +135,7 @@ public static void cost(CalculationContext context, int x, int y, int z, int des
                     return;
                 }
             }
+            frostWalker &= !context.assumeWalkOnWater; // do this after checking for descends because jesus can't prevent the water from freezing, it just prevents us from relying on the water freezing
         }
         double multiplier = WALK_ONE_BLOCK_COST;
         // For either possible soul sand, that affects half of our walking

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -74,7 +74,7 @@ public static double cost(CalculationContext context, int x, int y, int z, int d
         IBlockState destOn = context.get(destX, y - 1, destZ);
         Block srcDown = context.getBlock(x, y - 1, z);
         boolean standingOnABlock = MovementHelper.mustBeSolidToWalkOn(context, x, y-1, z, context.get(x, y-1, z));
-        boolean frostWalker = standingOnABlock && MovementHelper.canUseFrostWalker(context, destOn);
+        boolean frostWalker = standingOnABlock && !context.assumeWalkOnWater && MovementHelper.canUseFrostWalker(context, destOn);
         if (MovementHelper.canWalkOn(context.bsi, destX, y - 1, destZ, destOn) || frostWalker) { //this is a walk, not a bridge
             double WC = WALK_ONE_BLOCK_COST;
             boolean water = false;

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -96,7 +96,7 @@ public static void cost(CalculationContext context, int x, int y, int z, EnumFac
             return;
         }
         // we can't jump from (frozen) water with assumeWalkOnWater because we can't be sure it will be frozen
-        if (standingOn.getBlock() instanceof BlockLiquid && (!MovementHelper.canUseFrostWalker(context, standingOn) || context.assumeWalkOnWater)) {
+        if (context.assumeWalkOnWater && standingOn.getBlock() instanceof BlockLiquid) {
             return;
         }
         int maxJump;

File: src/api/java/baritone/api/process/IBuilderProcess.java
Patch:
@@ -58,7 +58,7 @@ default boolean build(String schematicFile, BlockPos origin) {
 
     void buildOpenSchematic();
 
-    void buildOpenLitematic();
+    void buildOpenLitematic(int i);
 
     void pause();
 

File: src/schematica_api/java/fi/dy/masa/litematica/schematic/placement/SchematicPlacementManager.java
Patch:
@@ -23,7 +23,9 @@
 public class SchematicPlacementManager {
     private final List<SchematicPlacement> schematicPlacements = new ArrayList<>();
 
-    public List<SchematicPlacement> getAllSchematicPlacements() {
+    //in case of a java.lang.NoSuchMethodError try change the name of this method to getAllSchematicPlacements()
+    // there are inconsistencies in the litematica mod about the naming of this method
+    public List<SchematicPlacement> getAllSchematicsPlacements() {
         return schematicPlacements;
     }
 }

File: src/main/java/baritone/utils/schematic/format/defaults/LitematicaSchematic.java
Patch:
@@ -48,8 +48,8 @@ public final class LitematicaSchematic extends StaticSchematic {
     private static NBTTagCompound nbt;
 
     public LitematicaSchematic(NBTTagCompound nbt) {
+        this.nbt = nbt;
         regNames = getRegions();
-        LitematicaSchematic.nbt = nbt;
         minCord();
 
         this.x = Math.abs(nbt.getCompoundTag(meta).getCompoundTag(schemSize).getInteger("x"));

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -603,7 +603,7 @@ enum PlaceResult {
 
     static boolean isTransparent(Block b) {
 
-        return b == Blocks.AIR ||
+        return b instanceof AirBlock ||
                 b == Blocks.LAVA ||
                 b == Blocks.WATER;
     }

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -603,7 +603,7 @@ enum PlaceResult {
 
     static boolean isTransparent(Block b) {
 
-        return b == Blocks.AIR ||
+        return b instanceof AirBlock ||
                 b == Blocks.LAVA ||
                 b == Blocks.WATER;
     }

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -148,7 +148,7 @@ public static double cost(CalculationContext context, int x, int y, int z, int d
                 if (srcDown == Blocks.SOUL_SAND || (srcDown instanceof BlockSlab && !((BlockSlab) srcDown).isDouble())) {
                     return COST_INF; // can't sneak and backplace against soul sand or half slabs (regardless of whether it's top half or bottom half) =/
                 }
-                if (srcDown == Blocks.FLOWING_WATER || srcDown == Blocks.WATER) {
+                if (!standingOnABlock) { // standing on water / swimming
                     return COST_INF; // this is obviously impossible
                 }
                 WC = WC * (SNEAK_ONE_BLOCK_COST / WALK_ONE_BLOCK_COST);//since we are sneak backplacing, we are sneaking lol

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -70,7 +70,7 @@ public double calculateCost(CalculationContext context) {
 
     @Override
     protected Set<BetterBlockPos> calculateValidPositions() {
-        return ImmutableSet.of(src, dest);
+        return ImmutableSet.of(src, src.above(), dest); // src.above means that we don't get caught in an infinite loop in water
     }
 
     public static double cost(CalculationContext context, int x, int y, int z, int destX, int destZ) {

File: src/main/java/baritone/pathing/movement/movements/MovementDiagonal.java
Patch:
@@ -127,7 +127,8 @@ public static void cost(CalculationContext context, int x, int y, int z, int des
             destWalkOn = destInto;
         } else {
             destWalkOn = context.get(destX, y - 1, destZ);
-            frostWalker = MovementHelper.canUseFrostWalker(context, destWalkOn) && !(context.assumeWalkOnWater && context.getBlock(x, y - 1, z) instanceof BlockLiquid);
+            boolean standingOnABlock = !(context.getBlock(x, y - 1, z) instanceof BlockLiquid) || (!context.assumeWalkOnWater && !(context.getBlock(x, y, z) instanceof BlockLiquid));
+            frostWalker = standingOnABlock && MovementHelper.canUseFrostWalker(context, destWalkOn);
             if (!MovementHelper.canWalkOn(context.bsi, destX, y - 1, destZ, destWalkOn) && !frostWalker) {
                 descend = true;
                 if (!context.allowDiagonalDescend || !MovementHelper.canWalkOn(context.bsi, destX, y - 2, destZ) || !MovementHelper.canWalkThrough(context.bsi, destX, y - 1, destZ, destWalkOn)) {

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -1017,7 +1017,7 @@ public final class Settings {
     /**
      * What Y level to go to for legit strip mining
      */
-    public final Setting<Integer> legitMineYLevel = new Setting<>(11);
+    public final Setting<Integer> legitMineYLevel = new Setting<>(-59);
 
     /**
      * Magically see ores that are separated diagonally from existing ores. Basically like mining around the ores that it finds

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -124,9 +124,7 @@ static Optional<Boolean> canWalkThroughBlockState(IBlockState state) {
         }
 
         if (block instanceof BlockDoor || block instanceof BlockFenceGate) {
-            // Because there's no nice method in vanilla to check if a door is openable or not, we just have to assume
-            // that anything that isn't an iron door isn't openable, ignoring that some doors introduced in mods can't
-            // be opened by just interacting.
+            // TODO this assumes that all doors in all mods are openable
             if (block == Blocks.IRON_DOOR) {
                 return FALSE;
             }

File: src/main/java/baritone/pathing/movement/movements/MovementDescend.java
Patch:
@@ -130,7 +130,7 @@ public static boolean dynamicFallCost(CalculationContext context, int x, int y,
             // and potentially replace the water we're going to fall into
             return false;
         }
-        if (!context.precomputedData.canWalkThrough(context.bsi, destX, y - 2, destZ, below)) {
+        if (!MovementHelper.canWalkThrough(context, destX, y - 2, destZ, below)) {
             return false;
         }
         double costSoFar = 0;

File: src/main/java/baritone/pathing/movement/movements/MovementDiagonal.java
Patch:
@@ -58,7 +58,7 @@ private MovementDiagonal(IBaritone baritone, BetterBlockPos start, BetterBlockPo
     }
 
     @Override
-    protected boolean safeToCancel(MovementState state) { // TODO move this function to use precomputed data, not urgent as it only runs once a tick
+    protected boolean safeToCancel(MovementState state) {
         //too simple. backfill does not work after cornering with this
         //return context.precomputedData.canWalkOn(ctx, ctx.playerFeet().down());
         EntityPlayerSP player = ctx.player();

File: src/main/java/baritone/pathing/precompute/PrecomputedDataForBlockState.java
Patch:
@@ -23,6 +23,7 @@
 import net.minecraft.world.IBlockAccess;
 
 import java.lang.reflect.Array;
+import java.util.Iterator;
 import java.util.Optional;
 import java.util.function.Function;
 
@@ -41,7 +42,8 @@ public PrecomputedDataForBlockState(Function<IBlockState, Optional<Boolean>> pre
     }
 
     public void refresh() {
-        for (IBlockState state : Block.BLOCK_STATE_IDS) { // state should never be null
+        for (Iterator<IBlockState> it = Block.BLOCK_STATE_IDS.iterator(); it.hasNext(); ) { // Can be replaced with an enhanced for because that breaks github actions for some reason I can't be bothered to dig into
+            IBlockState state = it.next(); // state should never be null
             Optional<Boolean> applied = precomputer.apply(state);
 
             int id = Block.BLOCK_STATE_IDS.get(state);

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -1305,7 +1305,9 @@ public final T get() {
 
         public void set(T value) {
             this.value = value;
-            BaritoneAPI.getProvider().getAllBaritones().forEach(iBaritone -> iBaritone.getGameEventHandler().onSettingChanged(new SettingChangedEvent(this)));
+            if (BaritoneAPI.getProvider() != null) {
+                BaritoneAPI.getProvider().getAllBaritones().forEach(iBaritone -> iBaritone.getGameEventHandler().onSettingChanged(new SettingChangedEvent(this)));
+            }
         }
 
         public final String getName() {

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -108,6 +108,7 @@ public void build(String name, ISchematic schematic, Vec3i origin) {
         this.layer = Baritone.settings().startAtLayer.value;
         this.numRepeats = 0;
         this.observedCompleted = new LongOpenHashSet();
+        this.incorrectPositions = null;
     }
 
     public void resume() {

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -108,6 +108,7 @@ public void build(String name, ISchematic schematic, Vec3i origin) {
         this.layer = Baritone.settings().startAtLayer.value;
         this.numRepeats = 0;
         this.observedCompleted = new LongOpenHashSet();
+        this.incorrectPositions = null;
     }
 
     public void resume() {

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -96,7 +96,7 @@ static boolean canWalkThrough(BlockStateInterface bsi, int x, int y, int z, Bloc
         if (block instanceof AirBlock) { // early return for most common case
             return true;
         }
-        if (block instanceof BaseFireBlock || block == Blocks.TRIPWIRE || block == Blocks.COBWEB || block == Blocks.END_PORTAL || block == Blocks.COCOA || block instanceof AbstractSkullBlock || block == Blocks.BUBBLE_COLUMN || block instanceof ShulkerBoxBlock || block instanceof SlabBlock || block instanceof TrapDoorBlock || block == Blocks.HONEY_BLOCK || block == Blocks.END_ROD || block == Blocks.SWEET_BERRY_BUSH) {
+        if (block instanceof AbstractFireBlock || block == Blocks.TRIPWIRE || block == Blocks.COBWEB || block == Blocks.END_PORTAL || block == Blocks.COCOA || block instanceof AbstractSkullBlock || block == Blocks.BUBBLE_COLUMN || block instanceof ShulkerBoxBlock || block instanceof SlabBlock || block instanceof TrapDoorBlock || block == Blocks.HONEY_BLOCK || block == Blocks.END_ROD || block == Blocks.SWEET_BERRY_BUSH) {
             return false;
         }
         if (Baritone.settings().blocksToAvoid.value.contains(block)) {
@@ -284,7 +284,6 @@ static boolean avoidWalkingInto(BlockState state) {
                 || block == Blocks.MAGMA_BLOCK
                 || block == Blocks.CACTUS
                 || block == Blocks.SWEET_BERRY_BUSH
-                || block instanceof BaseFireBlock
                 || block instanceof AbstractFireBlock
                 || block == Blocks.END_PORTAL
                 || block == Blocks.COBWEB

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -850,14 +850,14 @@ private List<BlockState> approxPlaceable(int size) {
             BlockState itemState = ((BlockItem) stack.getItem())
                 .getBlock()
                 .getStateForPlacement(
-                    new BlockItemUseOnContext(
-                        new ItemUseContext(ctx.world(), ctx.player(), InteractionHand.MAIN_HAND, stack, new BlockRayTraceResult(new Vector3d(ctx.player().position().x, ctx.player().position().y, ctx.player().position().z), Direction.UP, ctx.playerFeet(), false)) {}
+                    new BlockItemUseContext(
+                        new ItemUseContext(ctx.world(), ctx.player(), Hand.MAIN_HAND, stack, new BlockRayTraceResult(new Vector3d(ctx.player().getPositionVec().x, ctx.player().getPositionVec().y, ctx.player().getPositionVec().z), Direction.UP, ctx.playerFeet(), false)) {}
                     )
                 );
             if (itemState != null) {
                 result.add(itemState);
             } else {
-                result.add(Blocks.AIR.defaultBlockState());
+                result.add(Blocks.AIR.getDefaultState());
             }
             // </toxic cloud>
         }

File: src/main/java/baritone/utils/GuiClick.java
Patch:
@@ -88,12 +88,12 @@ public boolean mouseReleased(double mouseX, double mouseY, int mouseButton) {
                     BaritoneAPI.getProvider().getPrimaryBaritone().getSelectionManager().removeAllSelections();
                     BaritoneAPI.getProvider().getPrimaryBaritone().getSelectionManager().addSelection(BetterBlockPos.from(clickStart), BetterBlockPos.from(currentMouseOver));
                     TextComponent component = new StringTextComponent("Selection made! For usage: " + Baritone.settings().prefix.value + "help sel");
-                    component.getStyle()
+                    component.setStyle(component.getStyle()
                             .setFormatting(TextFormatting.WHITE)
                             .setClickEvent(new ClickEvent(
                                     ClickEvent.Action.RUN_COMMAND,
                                     FORCE_COMMAND_PREFIX + "help sel"
-                            ));
+                            )));
                     Helper.HELPER.logDirect(component);
                     clickStart = null;
                 } else {

File: src/main/java/baritone/utils/GuiClick.java
Patch:
@@ -88,12 +88,12 @@ public boolean mouseReleased(double mouseX, double mouseY, int mouseButton) {
                     BaritoneAPI.getProvider().getPrimaryBaritone().getSelectionManager().removeAllSelections();
                     BaritoneAPI.getProvider().getPrimaryBaritone().getSelectionManager().addSelection(BetterBlockPos.from(clickStart), BetterBlockPos.from(currentMouseOver));
                     TextComponent component = new StringTextComponent("Selection made! For usage: " + Baritone.settings().prefix.value + "help sel");
-                    component.getStyle()
+                    component.setStyle(component.getStyle()
                             .setFormatting(TextFormatting.WHITE)
                             .setClickEvent(new ClickEvent(
                                     ClickEvent.Action.RUN_COMMAND,
                                     FORCE_COMMAND_PREFIX + "help sel"
-                            ));
+                            )));
                     Helper.HELPER.logDirect(component);
                     clickStart = null;
                 } else {

File: src/main/java/baritone/cache/ChunkPacker.java
Patch:
@@ -82,7 +82,7 @@ public static CachedChunk pack(LevelChunk chunk) {
                             Block block = state.getBlock();
                             if (CachedChunk.BLOCKS_TO_KEEP_TRACK_OF.contains(block)) {
                                 String name = BlockUtils.blockToString(block);
-                                specialBlocks.computeIfAbsent(name, b -> new ArrayList<>()).add(new BlockPos(x, y, z));
+                                specialBlocks.computeIfAbsent(name, b -> new ArrayList<>()).add(new BlockPos(x, y+chunk.getMinBuildHeight(), z));
                             }
                         }
                     }

File: src/main/java/baritone/command/defaults/MineCommand.java
Patch:
@@ -70,7 +70,7 @@ public List<String> getLongDesc() {
                 "Also see the legitMine settings (see #set l legitMine).",
                 "",
                 "Usage:",
-                "> mine diamond_ore - Mines all diamonds it can find.",
+                "> mine diamond_ore - Mines all diamonds it can find."
         );
     }
 }

File: buildSrc/src/main/java/baritone/gradle/task/BaritoneGradleTask.java
Patch:
@@ -83,7 +83,7 @@ public BaritoneGradleTask() {
 
     protected void verifyArtifacts() throws IllegalStateException {
         if (!Files.exists(this.artifactPath)) {
-            throw new IllegalStateException("Artifact not found! Run build first!");
+            throw new IllegalStateException("Artifact not found! Run build first! Missing file: " + this.artifactPath);
         }
     }
 

File: src/main/java/baritone/cache/CachedWorld.java
Patch:
@@ -209,7 +209,7 @@ private synchronized void prune() {
     private BlockPos guessPosition() {
         for (IBaritone ibaritone : BaritoneAPI.getProvider().getAllBaritones()) {
             IWorldData data = ibaritone.getWorldProvider().getCurrentWorld();
-            if (data != null && data.getCachedWorld() == this) {
+            if (data != null && data.getCachedWorld() == this && ibaritone.getPlayerContext().player() != null) {
                 return ibaritone.getPlayerContext().playerFeet();
             }
         }

File: buildSrc/src/main/java/baritone/gradle/task/BaritoneGradleTask.java
Patch:
@@ -83,7 +83,7 @@ public BaritoneGradleTask() {
 
     protected void verifyArtifacts() throws IllegalStateException {
         if (!Files.exists(this.artifactPath)) {
-            throw new IllegalStateException("Artifact not found! Run build first!");
+            throw new IllegalStateException("Artifact not found! Run build first! Missing file: " + this.artifactPath);
         }
     }
 

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -99,7 +99,7 @@ static boolean canWalkThrough(BlockStateInterface bsi, int x, int y, int z, Bloc
         if (block instanceof AirBlock) { // early return for most common case
             return true;
         }
-        if (block instanceof BaseFireBlock || block == Blocks.TRIPWIRE || block == Blocks.COBWEB || block == Blocks.END_PORTAL || block == Blocks.COCOA || block instanceof AbstractSkullBlock || block == Blocks.BUBBLE_COLUMN || block instanceof ShulkerBoxBlock || block instanceof SlabBlock || block instanceof TrapDoorBlock || block == Blocks.HONEY_BLOCK || block == Blocks.END_ROD || block == Blocks.POINTED_DRIPSTONE || block == Blocks.AMETHYST_CLUSTER || block instanceof AmethystClusterBlock || block instanceof AzaleaBlock) {
+        if (block instanceof BaseFireBlock || block == Blocks.TRIPWIRE || block == Blocks.COBWEB || block == Blocks.END_PORTAL || block == Blocks.COCOA || block instanceof AbstractSkullBlock || block == Blocks.BUBBLE_COLUMN || block instanceof ShulkerBoxBlock || block instanceof SlabBlock || block instanceof TrapDoorBlock || block == Blocks.HONEY_BLOCK || block == Blocks.END_ROD || block == Blocks.SWEET_BERRY_BUSH || block == Blocks.POINTED_DRIPSTONE || block instanceof AmethystClusterBlock || block instanceof AzaleaBlock) {
             return false;
         }
         if (block == Blocks.BIG_DRIPLEAF) {
@@ -291,6 +291,7 @@ static boolean avoidWalkingInto(BlockState state) {
         return !state.getFluidState().isEmpty()
                 || block == Blocks.MAGMA_BLOCK
                 || block == Blocks.CACTUS
+                || block == Blocks.SWEET_BERRY_BUSH
                 || block instanceof BaseFireBlock
                 || block == Blocks.END_PORTAL
                 || block == Blocks.COBWEB

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -99,7 +99,7 @@ static boolean canWalkThrough(BlockStateInterface bsi, int x, int y, int z, Bloc
         if (block instanceof AirBlock) { // early return for most common case
             return true;
         }
-        if (block instanceof BaseFireBlock || block == Blocks.TRIPWIRE || block == Blocks.COBWEB || block == Blocks.END_PORTAL || block == Blocks.COCOA || block instanceof AbstractSkullBlock || block == Blocks.BUBBLE_COLUMN || block instanceof ShulkerBoxBlock || block instanceof SlabBlock || block instanceof TrapDoorBlock || block == Blocks.HONEY_BLOCK || block == Blocks.END_ROD || block == Blocks.POINTED_DRIPSTONE || block instanceof AmethystClusterBlock || block instanceof AzaleaBlock) {
+        if (block instanceof BaseFireBlock || block == Blocks.TRIPWIRE || block == Blocks.COBWEB || block == Blocks.END_PORTAL || block == Blocks.COCOA || block instanceof AbstractSkullBlock || block == Blocks.BUBBLE_COLUMN || block instanceof ShulkerBoxBlock || block instanceof SlabBlock || block instanceof TrapDoorBlock || block == Blocks.HONEY_BLOCK || block == Blocks.END_ROD || block == Blocks.SWEET_BERRY_BUSH || block == Blocks.POINTED_DRIPSTONE || block instanceof AmethystClusterBlock || block instanceof AzaleaBlock) {
             return false;
         }
         if (block == Blocks.BIG_DRIPLEAF) {
@@ -291,6 +291,7 @@ static boolean avoidWalkingInto(BlockState state) {
         return !state.getFluidState().isEmpty()
                 || block == Blocks.MAGMA_BLOCK
                 || block == Blocks.CACTUS
+                || block == Blocks.SWEET_BERRY_BUSH
                 || block instanceof BaseFireBlock
                 || block == Blocks.END_PORTAL
                 || block == Blocks.COBWEB

File: src/api/java/baritone/api/utils/BlockOptionalMeta.java
Patch:
@@ -29,7 +29,6 @@
 import net.minecraft.server.packs.repository.PackRepository;
 import net.minecraft.server.packs.repository.ServerPacksSource;
 import net.minecraft.server.packs.resources.ReloadableResourceManager;
-import net.minecraft.server.packs.resources.SimpleReloadableResourceManager;
 import net.minecraft.util.Unit;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
@@ -147,11 +146,11 @@ public static LootTables getManager() {
             PackRepository rpl = new PackRepository(PackType.SERVER_DATA, new ServerPacksSource());
             rpl.reload();
             PackResources thePack = rpl.getAvailablePacks().iterator().next().open();
-            ReloadableResourceManager resourceManager = new SimpleReloadableResourceManager(PackType.SERVER_DATA);
+            ReloadableResourceManager resourceManager = new ReloadableResourceManager(PackType.SERVER_DATA);
             manager = new LootTables(predicate);
             resourceManager.registerReloadListener(manager);
             try {
-                resourceManager.reload(new ThreadPerTaskExecutor(Thread::new), new ThreadPerTaskExecutor(Thread::new), Collections.singletonList(thePack), CompletableFuture.completedFuture(Unit.INSTANCE)).get();
+                resourceManager.createReload(new ThreadPerTaskExecutor(Thread::new), new ThreadPerTaskExecutor(Thread::new), CompletableFuture.completedFuture(Unit.INSTANCE), Collections.singletonList(thePack)).done().get();
             } catch (Exception exception) {
                 throw new RuntimeException(exception);
             }

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -99,7 +99,7 @@ static boolean canWalkThrough(BlockStateInterface bsi, int x, int y, int z, Bloc
         if (block instanceof AirBlock) { // early return for most common case
             return true;
         }
-        if (block instanceof BaseFireBlock || block == Blocks.TRIPWIRE || block == Blocks.COBWEB || block == Blocks.END_PORTAL || block == Blocks.COCOA || block instanceof AbstractSkullBlock || block == Blocks.BUBBLE_COLUMN || block instanceof ShulkerBoxBlock || block instanceof SlabBlock || block instanceof TrapDoorBlock || block == Blocks.HONEY_BLOCK || block == Blocks.END_ROD || block == Blocks.POINTED_DRIPSTONE || block == Blocks.AMETHYST_CLUSTER || block instanceof AzaleaBlock) {
+        if (block instanceof BaseFireBlock || block == Blocks.TRIPWIRE || block == Blocks.COBWEB || block == Blocks.END_PORTAL || block == Blocks.COCOA || block instanceof AbstractSkullBlock || block == Blocks.BUBBLE_COLUMN || block instanceof ShulkerBoxBlock || block instanceof SlabBlock || block instanceof TrapDoorBlock || block == Blocks.HONEY_BLOCK || block == Blocks.END_ROD || block == Blocks.POINTED_DRIPSTONE || block == Blocks.AMETHYST_CLUSTER || block instanceof AmethystClusterBlock || block instanceof AzaleaBlock) {
             return false;
         }
         if (block == Blocks.BIG_DRIPLEAF) {

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -99,7 +99,7 @@ static boolean canWalkThrough(BlockStateInterface bsi, int x, int y, int z, Bloc
         if (block instanceof AirBlock) { // early return for most common case
             return true;
         }
-        if (block instanceof BaseFireBlock || block == Blocks.TRIPWIRE || block == Blocks.COBWEB || block == Blocks.END_PORTAL || block == Blocks.COCOA || block instanceof AbstractSkullBlock || block == Blocks.BUBBLE_COLUMN || block instanceof ShulkerBoxBlock || block instanceof SlabBlock || block instanceof TrapDoorBlock || block == Blocks.HONEY_BLOCK || block == Blocks.END_ROD || block == Blocks.POINTED_DRIPSTONE || block == Blocks.AMETHYST_CLUSTER || block instanceof AzaleaBlock) {
+        if (block instanceof BaseFireBlock || block == Blocks.TRIPWIRE || block == Blocks.COBWEB || block == Blocks.END_PORTAL || block == Blocks.COCOA || block instanceof AbstractSkullBlock || block == Blocks.BUBBLE_COLUMN || block instanceof ShulkerBoxBlock || block instanceof SlabBlock || block instanceof TrapDoorBlock || block == Blocks.HONEY_BLOCK || block == Blocks.END_ROD || block == Blocks.POINTED_DRIPSTONE || block == Blocks.AMETHYST_CLUSTER || block instanceof AmethystClusterBlock || block instanceof AzaleaBlock) {
             return false;
         }
         if (block == Blocks.BIG_DRIPLEAF) {

File: src/main/java/baritone/command/defaults/FindCommand.java
Patch:
@@ -71,10 +71,10 @@ public String getShortDesc() {
     @Override
     public List<String> getLongDesc() {
         return Arrays.asList(
-                "",
+                "The find command searches through Baritone's cache and attempts to find the location of the block.",
                 "",
                 "Usage:",
-                "> "
+                "> find <block> - Find positions of a certain block"
         );
     }
 }

File: src/api/java/baritone/api/pathing/movement/ActionCosts.java
Patch:
@@ -65,8 +65,8 @@ public interface ActionCosts {
 
 
     static double[] generateFallNBlocksCost() {
-        double[] costs = new double[257];
-        for (int i = 0; i < 257; i++) {
+        double[] costs = new double[4097];
+        for (int i = 0; i < 4097; i++) {
             costs[i] = distanceToTicks(i);
         }
         return costs;

File: src/test/java/baritone/pathing/movement/ActionCostsTest.java
Patch:
@@ -26,10 +26,10 @@ public class ActionCostsTest {
 
     @Test
     public void testFallNBlocksCost() {
-        assertEquals(FALL_N_BLOCKS_COST.length, 257); // Fall 0 blocks through fall 256 blocks
-        for (int i = 0; i < 257; i++) {
+        assertEquals(FALL_N_BLOCKS_COST.length, 4097); // Fall 0 blocks through fall 4096 blocks
+        for (int i = 0; i < 4097; i++) {
             double blocks = ticksToBlocks(FALL_N_BLOCKS_COST[i]);
-            assertEquals(blocks, i, 0.000000000001); // If you add another 0 the test fails at i=217 LOL
+            assertEquals(blocks, i, 0.00000000001); // If you add another 0 the test fails at i=989 LOL
         }
         assertEquals(FALL_1_25_BLOCKS_COST, 6.2344, 0.00001);
         assertEquals(FALL_0_25_BLOCKS_COST, 3.0710, 0.00001);

File: src/main/java/baritone/utils/BlockStateInterface.java
Patch:
@@ -43,7 +43,7 @@ public class BlockStateInterface {
 
     private final ClientChunkCache provider;
     private final WorldData worldData;
-    protected final BlockGetter world;
+    protected final Level world;
     public final BlockPos.MutableBlockPos isPassableBlockPos;
     public final BlockGetter access;
 
@@ -97,9 +97,9 @@ public BlockState get0(BlockPos pos) {
     }
 
     public BlockState get0(int x, int y, int z) { // Mickey resigned
-        y -= worldData.dimension.minY();
+        y -= world.dimensionType().minY();
         // Invalid vertical position
-        if (y < 0 || y >= worldData.dimension.height()) {
+        if (y < 0 || y >= world.dimensionType().height()) {
             return AIR;
         }
 

File: src/main/java/baritone/utils/BlockStateInterface.java
Patch:
@@ -97,6 +97,9 @@ public BlockState get0(BlockPos pos) {
     }
 
     public BlockState get0(int x, int y, int z) { // Mickey resigned
+        if (worldData == null) {
+            return AIR;
+        }
         y -= worldData.dimension.minY();
         // Invalid vertical position
         if (y < 0 || y >= worldData.dimension.height()) {
@@ -124,9 +127,6 @@ public BlockState get0(int x, int y, int z) { // Mickey resigned
         // except here, it's 512x512 tiles instead of 16x16, so even better repetition
         CachedRegion cached = prevCached;
         if (cached == null || cached.getX() != x >> 9 || cached.getZ() != z >> 9) {
-            if (worldData == null) {
-                return AIR;
-            }
             CachedRegion region = worldData.cache.getRegion(x >> 9, z >> 9);
             if (region == null) {
                 return AIR;

File: src/api/java/baritone/api/pathing/movement/ActionCosts.java
Patch:
@@ -65,8 +65,8 @@ public interface ActionCosts {
 
 
     static double[] generateFallNBlocksCost() {
-        double[] costs = new double[257];
-        for (int i = 0; i < 257; i++) {
+        double[] costs = new double[4097];
+        for (int i = 0; i < 4096; i++) {
             costs[i] = distanceToTicks(i);
         }
         return costs;

File: src/test/java/baritone/pathing/movement/ActionCostsTest.java
Patch:
@@ -26,7 +26,7 @@ public class ActionCostsTest {
 
     @Test
     public void testFallNBlocksCost() {
-        assertEquals(FALL_N_BLOCKS_COST.length, 257); // Fall 0 blocks through fall 256 blocks
+        assertEquals(FALL_N_BLOCKS_COST.length, 4097); // Fall 0 blocks through fall 4096 blocks
         for (int i = 0; i < 257; i++) {
             double blocks = ticksToBlocks(FALL_N_BLOCKS_COST[i]);
             assertEquals(blocks, i, 0.000000000001); // If you add another 0 the test fails at i=217 LOL

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -50,7 +50,7 @@ public interface MovementHelper extends ActionCosts, Helper {
 
     static boolean avoidBreaking(BlockStateInterface bsi, int x, int y, int z, IBlockState state) {
         if (!bsi.worldBorder.canPlaceAt(x, y)) {
-            return false;
+            return true;
         }
         Block b = state.getBlock();
         return Baritone.settings().blocksToDisallowBreaking.value.contains(b)

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -134,7 +134,9 @@ static boolean canWalkThrough(BlockStateInterface bsi, int x, int y, int z, IBlo
             }
             return block == Blocks.WATER || block == Blocks.FLOWING_WATER;
         }
-
+        if (block instanceof BlockCauldron) {
+            return false;
+        }
         return block.isPassable(bsi.access, bsi.isPassableBlockPos.setPos(x, y, z));
     }
 

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -105,6 +105,9 @@ static boolean canWalkThrough(BlockStateInterface bsi, int x, int y, int z, Bloc
         if (block == Blocks.BIG_DRIPLEAF) {
             return false;
         }
+        if (block == Blocks.POWDER_SNOW) {
+            return false;
+        }
         if (Baritone.settings().blocksToAvoid.value.contains(block)) {
             return false;
         }

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -134,7 +134,9 @@ static boolean canWalkThrough(BlockStateInterface bsi, int x, int y, int z, IBlo
             }
             return block == Blocks.WATER || block == Blocks.FLOWING_WATER;
         }
-
+        if (block instanceof BlockCauldron) {
+            return false;
+        }
         return block.isPassable(bsi.access, bsi.isPassableBlockPos.setPos(x, y, z));
     }
 

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -105,6 +105,9 @@ static boolean canWalkThrough(BlockStateInterface bsi, int x, int y, int z, Bloc
         if (block == Blocks.BIG_DRIPLEAF) {
             return false;
         }
+        if (block == Blocks.POWDER_SNOW) {
+            return false;
+        }
         if (Baritone.settings().blocksToAvoid.value.contains(block)) {
             return false;
         }

File: src/launch/java/baritone/launch/mixins/MixinMinecraft.java
Patch:
@@ -63,7 +63,7 @@ private void postInit(CallbackInfo ci) {
             value = "FIELD",
             opcode = Opcodes.GETFIELD,
             target = "Lnet/minecraft/client/Minecraft;screen:Lnet/minecraft/client/gui/screens/Screen;",
-            ordinal = 5,
+            ordinal = 4,
             shift  = At.Shift.BY,
             by = -3
             )

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -741,6 +741,7 @@ public final class Settings {
 
     /**
      * Sets the minimum y level whilst mining - set to 0 to turn off.
+     * if world has negative y values, subtract the min world height to get the value to put here
      */
     public final Setting<Integer> minYLevelWhileMining = new Setting<>(0);
 

File: src/launch/java/baritone/launch/mixins/MixinItemStack.java
Patch:
@@ -63,6 +63,8 @@ private void onItemDamageSet(CallbackInfo ci) {
 
     @Override
     public int getBaritoneHash() {
+        // TODO: figure out why <init> mixin not working, was 0 for some reason
+        if (baritoneHash == 0) recalculateHash();
         return baritoneHash;
     }
 }

File: src/main/java/baritone/pathing/calc/AStarPathFinder.java
Patch:
@@ -111,7 +111,7 @@ protected Optional<IPath> calculate0(long primaryTimeout, long failureTimeout) {
                 if (!moves.dynamicXZ && !worldBorder.entirelyContains(newX, newZ)) {
                     continue;
                 }
-                if (currentNode.y + moves.yOffset > height || currentNode.y + moves.yOffset < 0) {
+                if (currentNode.y + moves.yOffset > height || currentNode.y + moves.yOffset < minY) {
                     continue;
                 }
                 res.reset();

File: src/main/java/baritone/pathing/movement/movements/MovementFall.java
Patch:
@@ -179,7 +179,7 @@ private static BetterBlockPos[] buildPositionsToBreak(BetterBlockPos src, Better
         BetterBlockPos[] toBreak;
         int diffX = src.getX() - dest.getX();
         int diffZ = src.getZ() - dest.getZ();
-        int diffY = src.getY() - dest.getY();
+        int diffY = Math.abs(src.getY() - dest.getY());
         toBreak = new BetterBlockPos[diffY + 2];
         for (int i = 0; i < toBreak.length; i++) {
             toBreak[i] = new BetterBlockPos(src.getX() - diffX, src.getY() + 1 - i, src.getZ() - diffZ);

File: src/main/java/baritone/process/MineProcess.java
Patch:
@@ -418,7 +418,7 @@ private static List<BlockPos> prune(CalculationContext ctx, List<BlockPos> locs2
                     }
                 })
 
-                .filter(pos -> pos.getY() >= Baritone.settings().minYLevelWhileMining.value)
+                .filter(pos -> pos.getY() >= Baritone.settings().minYLevelWhileMining.value + ctx.world.dimensionType().minY())
 
                 .filter(pos -> !blacklist.contains(pos))
 

File: src/main/java/baritone/utils/BlockStateInterface.java
Patch:
@@ -97,9 +97,9 @@ public BlockState get0(BlockPos pos) {
     }
 
     public BlockState get0(int x, int y, int z) { // Mickey resigned
-
+        y -= worldData.dimension.minY();
         // Invalid vertical position
-        if (y < 0 || y >= 256) {
+        if (y < 0 || y >= worldData.dimension.height()) {
             return AIR;
         }
 

File: buildSrc/src/main/java/baritone/gradle/task/ProguardTask.java
Patch:
@@ -92,11 +92,11 @@ private void copyMcJar() throws IOException {
             .map(f -> {
                 switch (compType) {
                     case "OFFICIAL":
-                        return new File(f.getParentFile().getParentFile(), f.getName().toString().split("mapped")[0] + "merged.jar");
+                        return new File(f.getParentFile().getParentFile(), "minecraft-merged.jar");
                     case "FABRIC":
-                        return new File(f.getParentFile().getParentFile(), f.getName().toString().replace("mapped", "intermediary"));
+                        return new File(f.getParentFile(), "minecraft-intermediary.jar");
                     case "FORGE":
-                        return new File(f.getParentFile().getParentFile(), f.getName().toString().replace("mapped", "srg"));
+                        return new File(f.getParentFile(), "minecraft-srg.jar");
                 }
                 return null;
                 })

File: src/api/java/baritone/api/pathing/goals/GoalBlock.java
Patch:
@@ -87,8 +87,8 @@ public BlockPos getGoalPos() {
     public static double calculate(double xDiff, int yDiff, double zDiff) {
         double heuristic = 0;
 
-        // if yDiff is 1 that means that pos.getY()-this.y==1 which means that we're 1 block below where we should be
-        // therefore going from 0,0,0 to a GoalYLevel of pos.getY()-this.y is accurate
+        // if yDiff is 1 that means that pos.getY()-this.y==1 which means that we're 1 block above where we should be
+        // therefore going from 0,pos.getY()-this.y,0 to a GoalYLevel of 0 is accurate
         heuristic += GoalYLevel.calculate(0, yDiff);
 
         //use the pythagorean and manhattan mixture from GoalXZ

File: src/api/java/baritone/api/pathing/goals/GoalBlock.java
Patch:
@@ -89,7 +89,7 @@ public static double calculate(double xDiff, int yDiff, double zDiff) {
 
         // if yDiff is 1 that means that pos.getY()-this.y==1 which means that we're 1 block below where we should be
         // therefore going from 0,0,0 to a GoalYLevel of pos.getY()-this.y is accurate
-        heuristic += GoalYLevel.calculate(yDiff, 0);
+        heuristic += GoalYLevel.calculate(0, yDiff);
 
         //use the pythagorean and manhattan mixture from GoalXZ
         heuristic += GoalXZ.calculate(xDiff, zDiff);

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -156,7 +156,7 @@ protected boolean prepared(MovementState state) {
         }
         boolean somethingInTheWay = false;
         for (BetterBlockPos blockPos : positionsToBreak) {
-            if (!ctx.world().getEntities(ctx.player(), new AABB(0, 0, 0, 1, 1.1, 1).move(blockPos)).isEmpty() && Baritone.settings().pauseMiningForFallingBlocks.value) {
+            if (!ctx.world().getEntitiesOfClass(FallingBlockEntity.class, new AABB(0, 0, 0, 1, 1.1, 1).move(blockPos)).isEmpty() && Baritone.settings().pauseMiningForFallingBlocks.value) {
                 return false;
             }
             if (!MovementHelper.canWalkThrough(ctx, blockPos)) { // can't break air, so don't try

File: src/api/java/baritone/api/utils/gui/BaritoneToast.java
Patch:
@@ -44,7 +44,7 @@ public Visibility render(PoseStack matrixStack, ToastComponent toastGui, long de
         }
 
 
-        //TODO: fix
+        //TODO: check
         toastGui.getMinecraft().getTextureManager().bindForSetup(new ResourceLocation("textures/gui/toasts.png"));
         //GlStateManager._color4f(1.0F, 1.0F, 1.0F, 255.0F);
         toastGui.blit(matrixStack, 0, 0, 0, 32, 160, 32);

File: src/launch/java/baritone/launch/mixins/MixinClientPlayNetHandler.java
Patch:
@@ -175,7 +175,7 @@ private void postHandleMultiBlockChange(ClientboundSectionBlocksUpdatePacket pac
             method = "handlePlayerCombatKill",
             at = @At(
                     value = "INVOKE",
-                    target = "net/minecraft/client/Minecraft.setScreen(Lnet/minecraft/client/gui/screen/Screen;)V"
+                    target = "Lnet/minecraft/client/Minecraft;setScreen(Lnet/minecraft/client/gui/screens/Screen;)V"
             )
     )
     private void onPlayerDeath(ClientboundPlayerCombatKillPacket packetIn, CallbackInfo ci) {

File: src/launch/java/baritone/launch/mixins/MixinLootContext.java
Patch:
@@ -48,7 +48,7 @@ private MinecraftServer getServer(ServerLevel world) {
             method = "create",
             at = @At(
                     value = "INVOKE",
-                    target = "net/minecraft/server/MinecraftServer.getLootTableManager()Lnet/minecraft/loot/LootTableManager;"
+                    target = "Lnet/minecraft/server/MinecraftServer;getLootTables()Lnet/minecraft/world/level/storage/loot/LootTables;"
             )
     )
     private LootTables getLootTableManager(MinecraftServer server) {
@@ -62,7 +62,7 @@ private LootTables getLootTableManager(MinecraftServer server) {
             method = "create",
             at = @At(
                     value = "INVOKE",
-                    target = "net/minecraft/server/MinecraftServer.func_229736_aP_()Lnet/minecraft/loot/LootPredicateManager;"
+                    target = "Lnet/minecraft/server/MinecraftServer;getPredicateManager()Lnet/minecraft/world/level/storage/loot/PredicateManager;"
             )
     )
     private PredicateManager getLootPredicateManager(MinecraftServer server) {

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -156,7 +156,7 @@ protected boolean prepared(MovementState state) {
         }
         boolean somethingInTheWay = false;
         for (BetterBlockPos blockPos : positionsToBreak) {
-            if (!ctx.world().getEntities(null, new AABB(0, 0, 0, 1, 1.1, 1).move(blockPos)).isEmpty() && Baritone.settings().pauseMiningForFallingBlocks.value) {
+            if (!ctx.world().getEntities(ctx.player(), new AABB(0, 0, 0, 1, 1.1, 1).move(blockPos)).isEmpty() && Baritone.settings().pauseMiningForFallingBlocks.value) {
                 return false;
             }
             if (!MovementHelper.canWalkThrough(ctx, blockPos)) { // can't break air, so don't try

File: src/main/java/baritone/utils/GuiClick.java
Patch:
@@ -128,8 +128,8 @@ public void onRender(PoseStack modelViewStack, Matrix4f projectionMatrix) {
             if (clickStart != null && !clickStart.equals(currentMouseOver)) {
                 RenderSystem.enableBlend();
                 RenderSystem.blendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);
-                //TODO: fix
-                //RenderSystem.color4f(Color.RED.getColorComponents(null)[0], Color.RED.getColorComponents(null)[1], Color.RED.getColorComponents(null)[2], 0.4F);
+                //TODO: check
+                IRenderer.glColor(Color.RED, 0.4F);
                 RenderSystem.lineWidth(Baritone.settings().pathRenderLineWidthPixels.value);
                 RenderSystem.disableTexture();
                 RenderSystem.depthMask(false);

File: buildSrc/src/main/java/baritone/gradle/task/BaritoneGradleTask.java
Patch:
@@ -99,14 +99,14 @@ protected String formatVersion(String string) {
     }
 
     protected Path getRelativeFile(String file) {
-        return Paths.get(new File(getProject().getBuildDir(), file).getAbsolutePath());
+        return Paths.get(new File(new File(getProject().getBuildDir(), "../"), file).getAbsolutePath());
     }
 
     protected Path getTemporaryFile(String file) {
         return Paths.get(new File(getTemporaryDir(), file).getAbsolutePath());
     }
 
     protected Path getBuildFile(String file) {
-        return getRelativeFile("libs/" + file);
+        return getRelativeFile("build/libs/" + file);
     }
 }

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -30,6 +30,7 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.*;
+import java.util.List;
 import java.util.function.Consumer;
 
 /**

File: src/api/java/baritone/api/utils/BlockOptionalMeta.java
Patch:
@@ -21,7 +21,6 @@
 import com.google.common.collect.ImmutableSet;
 import io.netty.util.concurrent.ThreadPerTaskExecutor;
 import net.minecraft.core.BlockPos;
-import net.minecraft.loot.*;
 import net.minecraft.resources.*;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.packs.PackResources;
@@ -145,7 +144,7 @@ public BlockState getAnyBlockState() {
 
     public static LootTables getManager() {
         if (manager == null) {
-            PackRepository rpl = new PackRepository(Pack::new, new ServerPacksSource());
+            PackRepository rpl = new PackRepository(PackType.SERVER_DATA, new ServerPacksSource());
             rpl.reload();
             PackResources thePack = rpl.getAvailablePacks().iterator().next().open();
             ReloadableResourceManager resourceManager = new SimpleReloadableResourceManager(PackType.SERVER_DATA);

File: src/api/java/baritone/api/utils/IPlayerContext.java
Patch:
@@ -86,7 +86,7 @@ default Vec3 playerHead() {
     }
 
     default Rotation playerRotations() {
-        return new Rotation(player().yRot, player().xRot);
+        return new Rotation(player().getYRot(), player().getXRot());
     }
 
     static double eyeHeight(boolean ifSneaking) {

File: src/api/java/baritone/api/utils/IPlayerController.java
Patch:
@@ -25,7 +25,6 @@
 import net.minecraft.world.InteractionResult;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.inventory.ClickType;
-import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.GameType;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.phys.BlockHitResult;
@@ -44,7 +43,7 @@ public interface IPlayerController {
 
     void resetBlockRemoving();
 
-    ItemStack windowClick(int windowId, int slotId, int mouseButton, ClickType type, Player player);
+    void windowClick(int windowId, int slotId, int mouseButton, ClickType type, Player player);
 
     GameType getGameType();
 

File: src/api/java/baritone/api/utils/RotationUtils.java
Patch:
@@ -179,7 +179,7 @@ public static Optional<Rotation> reachable(LocalPlayer entity, BlockPos pos, dou
              *
              * or if you're a normal person literally all this does it ensure that we don't nudge the pitch to a normal level
              */
-            Rotation hypothetical = new Rotation(entity.yRot, entity.xRot + 0.0001F);
+            Rotation hypothetical = new Rotation(entity.getYRot(), entity.getXRot() + 0.0001F);
             if (wouldSneak) {
                 // the concern here is: what if we're looking at it now, but as soon as we start sneaking we no longer are
                 HitResult result = RayTraceUtils.rayTraceTowards(entity, hypothetical, blockReachDistance, true);
@@ -226,7 +226,7 @@ public static Optional<Rotation> reachable(LocalPlayer entity, BlockPos pos, dou
      */
     public static Optional<Rotation> reachableOffset(Entity entity, BlockPos pos, Vec3 offsetPos, double blockReachDistance, boolean wouldSneak) {
         Vec3 eyes = wouldSneak ? RayTraceUtils.inferSneakingEyePosition(entity) : entity.getEyePosition(1.0F);
-        Rotation rotation = calcRotationFromVec3d(eyes, offsetPos, new Rotation(entity.yRot, entity.xRot));
+        Rotation rotation = calcRotationFromVec3d(eyes, offsetPos, new Rotation(entity.getYRot(), entity.getXRot()));
         HitResult result = RayTraceUtils.rayTraceTowards(entity, rotation, blockReachDistance, wouldSneak);
         //System.out.println(result);
         if (result != null && result.getType() == HitResult.Type.BLOCK) {

File: src/launch/java/baritone/launch/mixins/MixinItemStack.java
Patch:
@@ -39,10 +39,10 @@ public abstract class MixinItemStack implements IItemStack {
     private int baritoneHash;
 
     @Shadow
-    protected abstract int getDamage();
+    protected abstract int getDamageValue();
 
     private void recalculateHash() {
-        baritoneHash = item == null ? -1 : item.hashCode() + getDamage();
+        baritoneHash = item == null ? -1 : item.hashCode() + getDamageValue();
     }
 
     @Inject(
@@ -54,7 +54,7 @@ private void onInit(CallbackInfo ci) {
     }
 
     @Inject(
-            method = "setDamage",
+            method = "setDamageValue",
             at = @At("TAIL")
     )
     private void onItemDamageSet(CallbackInfo ci) {

File: src/launch/java/baritone/launch/mixins/MixinPlayerController.java
Patch:
@@ -27,15 +27,15 @@
 @Mixin(MultiPlayerGameMode.class)
 public abstract class MixinPlayerController implements IPlayerControllerMP {
 
-    @Accessor
+    @Accessor("isDestroying")
     @Override
     public abstract void setIsHittingBlock(boolean isHittingBlock);
 
-    @Accessor
+    @Accessor("destroyBlockPos")
     @Override
     public abstract BlockPos getCurrentBlock();
 
-    @Invoker
+    @Invoker("ensureHasSentCarriedItem")
     @Override
     public abstract void callSyncCurrentPlayItem();
 }

File: src/launch/java/baritone/launch/mixins/MixinWorldRenderer.java
Patch:
@@ -40,7 +40,7 @@
 public class MixinWorldRenderer {
 
     @Inject(
-            method = "updateCameraAndRender",
+            method = "renderLevel",
             at = @At("RETURN"),
             locals = LocalCapture.CAPTURE_FAILSOFT
     )

File: src/main/java/baritone/Baritone.java
Patch:
@@ -217,7 +217,7 @@ public void openClick() {
         new Thread(() -> {
             try {
                 Thread.sleep(100);
-                Helper.mc.execute(() -> Helper.mc.displayGuiScreen(new GuiClick()));
+                Helper.mc.execute(() -> Helper.mc.setScreen(new GuiClick()));
             } catch (Exception ignored) {}
         }).start();
     }

File: src/main/java/baritone/behavior/MemoryBehavior.java
Patch:
@@ -60,7 +60,7 @@ public void onPlayerDeath() {
 
     public EnderChestMemory getCurrent() {
         Path path = baritone.getWorldProvider().getCurrentWorld().directory;
-        return EnderChestMemory.getByServerAndPlayer(path.getParent(), ctx.player().getUniqueID());
+        return EnderChestMemory.getByServerAndPlayer(path.getParent(), ctx.player().getUUID());
     }
 
     public static class EnderChestMemory {

File: src/main/java/baritone/cache/CachedChunk.java
Patch:
@@ -196,7 +196,7 @@ public final BlockState getBlock(int x, int y, int z, ResourceKey<Level> dimensi
         if (special != null) {
             String str = special.get(index);
             if (str != null) {
-                return BlockUtils.stringToBlockRequired(str).getDefaultState();
+                return BlockUtils.stringToBlockRequired(str).defaultBlockState();
             }
         }
 

File: src/main/java/baritone/cache/CachedRegion.java
Patch:
@@ -242,7 +242,7 @@ public synchronized void load(String directory) {
                     for (int z = 0; z < 32; z++) {
                         if (present[x][z]) {
                             for (int i = 0; i < 256; i++) {
-                                overview[x][z][i] = BlockUtils.stringToBlockRequired(in.readUTF()).getDefaultState();
+                                overview[x][z][i] = BlockUtils.stringToBlockRequired(in.readUTF()).defaultBlockState();
                             }
                         }
                     }

File: src/main/java/baritone/cache/ChunkPacker.java
Patch:
@@ -20,7 +20,6 @@
 import baritone.api.utils.BlockUtils;
 import baritone.pathing.movement.MovementHelper;
 import baritone.utils.pathing.PathingBlockType;
-import net.minecraft.block.*;
 import net.minecraft.core.BlockPos;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.world.level.Level;

File: src/main/java/baritone/cache/ContainerMemory.java
Patch:
@@ -176,7 +176,7 @@ public final int getSize() {
 
         public void updateFromOpenWindow(IPlayerContext ctx) {
             items.clear();
-            items.addAll(ctx.player().openContainer.getInventory().subList(0, size));
+            items.addAll(ctx.player().containerMenu.getItems().subList(0, size));
         }
     }
 }

File: src/main/java/baritone/cache/WorldScanner.java
Patch:
@@ -46,7 +46,7 @@ public List<BlockPos> scanChunkRadius(IPlayerContext ctx, BlockOptionalMetaLooku
         if (filter.blocks().isEmpty()) {
             return res;
         }
-        ClientChunkCache chunkProvider = (ClientChunkCache) ctx.world().getChunkProvider();
+        ClientChunkCache chunkProvider = (ClientChunkCache) ctx.world().getChunkSource();
 
         int maxSearchRadiusSq = maxSearchRadius * maxSearchRadius;
         int playerChunkX = ctx.playerFeet().getX() >> 4;
@@ -96,7 +96,7 @@ public List<BlockPos> scanChunk(IPlayerContext ctx, BlockOptionalMetaLookup filt
             return Collections.emptyList();
         }
 
-        ClientChunkCache chunkProvider = (ClientChunkCache) ctx.world().getChunkProvider();
+        ClientChunkCache chunkProvider = (ClientChunkCache) ctx.world().getChunkSource();
         LevelChunk chunk = chunkProvider.getChunk(pos.x, pos.z, null, false);
         int playerY = ctx.playerFeet().getY();
 
@@ -116,7 +116,7 @@ public int repack(IPlayerContext ctx) {
 
     @Override
     public int repack(IPlayerContext ctx, int range) {
-        ChunkSource chunkProvider = ctx.world().getChunkProvider();
+        ChunkSource chunkProvider = ctx.world().getChunkSource();
         ICachedWorld cachedWorld = ctx.worldData().getCachedWorld();
 
         BetterBlockPos playerPos = ctx.playerFeet();

File: src/main/java/baritone/command/ExampleBaritoneControl.java
Patch:
@@ -99,7 +99,7 @@ public boolean runCommand(String msg) {
             return false;
         } else if (msg.trim().equalsIgnoreCase("orderpizza")) {
             try {
-                ((IGuiScreen) mc.currentScreen).openLinkInvoker(new URI("https://www.dominos.com/en/pages/order/"));
+                ((IGuiScreen) mc.screen).openLinkInvoker(new URI("https://www.dominos.com/en/pages/order/"));
             } catch (NullPointerException | URISyntaxException ignored) {}
             return false;
         }

File: src/main/java/baritone/command/defaults/BuildCommand.java
Patch:
@@ -35,7 +35,7 @@
 
 public class BuildCommand extends Command {
 
-    private static final File schematicsDir = new File(mc.gameDir, "schematics");
+    private static final File schematicsDir = new File(mc.gameDirectory, "schematics");
 
     public BuildCommand(IBaritone baritone) {
         super(baritone, "build");

File: src/main/java/baritone/command/defaults/ComeCommand.java
Patch:
@@ -37,7 +37,7 @@ public ComeCommand(IBaritone baritone) {
     @Override
     public void execute(String label, IArgConsumer args) throws CommandException {
         args.requireMax(0);
-        Entity entity = mc.getRenderViewEntity();
+        Entity entity = mc.getCameraEntity();
         if (entity == null) {
             throw new CommandInvalidStateException("render view entity is null");
         }

File: src/main/java/baritone/command/defaults/ExploreFilterCommand.java
Patch:
@@ -41,7 +41,7 @@ public ExploreFilterCommand(IBaritone baritone) {
     @Override
     public void execute(String label, IArgConsumer args) throws CommandException {
         args.requireMax(2);
-        File file = args.getDatatypePost(RelativeFile.INSTANCE, mc.gameDir.getAbsoluteFile().getParentFile());
+        File file = args.getDatatypePost(RelativeFile.INSTANCE, mc.gameDirectory.getAbsoluteFile().getParentFile());
         boolean invert = false;
         if (args.hasAny()) {
             if (args.getString().equalsIgnoreCase("invert")) {

File: src/main/java/baritone/command/defaults/RenderCommand.java
Patch:
@@ -37,8 +37,8 @@ public RenderCommand(IBaritone baritone) {
     public void execute(String label, IArgConsumer args) throws CommandException {
         args.requireMax(0);
         BetterBlockPos origin = ctx.playerFeet();
-        int renderDistance = (mc.gameSettings.renderDistanceChunks + 1) * 16;
-        mc.worldRenderer.markBlockRangeForRenderUpdate(
+        int renderDistance = (mc.options.renderDistance + 1) * 16;
+        mc.levelRenderer.setBlocksDirty(
                 origin.x - renderDistance,
                 0,
                 origin.z - renderDistance,

File: src/main/java/baritone/command/defaults/SelCommand.java
Patch:
@@ -39,6 +39,7 @@
 import baritone.utils.IRenderer;
 import java.awt.*;
 import java.util.*;
+import java.util.List;
 import java.util.function.Function;
 import java.util.stream.Stream;
 import net.minecraft.core.Direction;
@@ -64,7 +65,7 @@ public void onRenderPass(RenderEvent event) {
                 float lineWidth = Baritone.settings().selectionLineWidth.value;
                 boolean ignoreDepth = Baritone.settings().renderSelectionIgnoreDepth.value;
                 IRenderer.startLines(color, opacity, lineWidth, ignoreDepth);
-                IRenderer.drawAABB(event.getModelViewStack(), new AABB(pos1, pos1.add(1, 1, 1)));
+                IRenderer.drawAABB(event.getModelViewStack(), new AABB(pos1, pos1.offset(1, 1, 1)));
                 IRenderer.endLines(ignoreDepth);
             }
         });
@@ -80,7 +81,7 @@ public void execute(String label, IArgConsumer args) throws CommandException {
             if (action == Action.POS2 && pos1 == null) {
                 throw new CommandInvalidStateException("Set pos1 first before using pos2");
             }
-            BetterBlockPos playerPos = mc.getRenderViewEntity() != null ? BetterBlockPos.from(mc.getRenderViewEntity().getPosition()) : ctx.playerFeet();
+            BetterBlockPos playerPos = mc.getCameraEntity() != null ? BetterBlockPos.from(mc.getCameraEntity().blockPosition()) : ctx.playerFeet();
             BetterBlockPos pos = args.hasAny() ? args.getDatatypePost(RelativeBlockPos.INSTANCE, playerPos) : playerPos;
             args.requireMax(0);
             if (action == Action.POS1) {

File: src/main/java/baritone/command/defaults/SurfaceCommand.java
Patch:
@@ -43,7 +43,7 @@ public void execute(String label, IArgConsumer args) throws CommandException {
 
         // Ensure this command will not run if you are above the surface level and the block above you is air
         // As this would imply that your are already on the open surface
-        if (playerPos.getY() > surfaceLevel && mc.world.getBlockState(playerPos.up()).getBlock() instanceof AirBlock) {
+        if (playerPos.getY() > surfaceLevel && mc.level.getBlockState(playerPos.above()).getBlock() instanceof AirBlock) {
             logDirect("Already at surface");
             return;
         }
@@ -53,8 +53,8 @@ public void execute(String label, IArgConsumer args) throws CommandException {
         for (int currentIteratedY = startingYPos; currentIteratedY < worldHeight; currentIteratedY++) {
             final BetterBlockPos newPos = new BetterBlockPos(playerPos.getX(), currentIteratedY, playerPos.getZ());
 
-            if (!(mc.world.getBlockState(newPos).getBlock() instanceof AirBlock) && newPos.getY() > playerPos.getY()) {
-                Goal goal = new GoalBlock(newPos.up());
+            if (!(mc.level.getBlockState(newPos).getBlock() instanceof AirBlock) && newPos.getY() > playerPos.getY()) {
+                Goal goal = new GoalBlock(newPos.above());
                 logDirect(String.format("Going to: %s", goal.toString()));
                 baritone.getCustomGoalProcess().setGoalAndPath(goal);
                 return;

File: src/main/java/baritone/command/defaults/ThisWayCommand.java
Patch:
@@ -38,7 +38,7 @@ public void execute(String label, IArgConsumer args) throws CommandException {
         args.requireExactly(1);
         GoalXZ goal = GoalXZ.fromDirection(
                 ctx.playerFeetAsVec(),
-                ctx.player().rotationYawHead,
+                ctx.player().getYHeadRot(),
                 args.getAs(Double.class)
         );
         baritone.getCustomGoalProcess().setGoal(goal);

File: src/main/java/baritone/command/defaults/TunnelCommand.java
Patch:
@@ -54,7 +54,7 @@ public void execute(String label, IArgConsumer args) throws CommandException {
                 width--;
                 BlockPos corner1;
                 BlockPos corner2;
-                Direction enumFacing = ctx.player().getHorizontalFacing();
+                Direction enumFacing = ctx.player().getDirection();
                 int addition = ((width % 2 == 0) ? 0 : 1);
                 switch (enumFacing) {
                     case EAST:
@@ -82,7 +82,7 @@ public void execute(String label, IArgConsumer args) throws CommandException {
         } else {
             Goal goal = new GoalStrictDirection(
                     ctx.playerFeet(),
-                    ctx.player().getHorizontalFacing()
+                    ctx.player().getDirection()
             );
             baritone.getCustomGoalProcess().setGoalAndPath(goal);
             logDirect(String.format("Goal: %s", goal.toString()));

File: src/main/java/baritone/event/GameEventHandler.java
Patch:
@@ -114,7 +114,7 @@ public final void onWorldEvent(WorldEvent event) {
         if (event.getState() == EventState.POST) {
             cache.closeWorld();
             if (event.getWorld() != null) {
-                cache.initWorld(event.getWorld().getDimensionKey());
+                cache.initWorld(event.getWorld().dimension());
             }
         }
 

File: src/main/java/baritone/pathing/movement/CalculationContext.java
Patch:
@@ -85,7 +85,7 @@ public CalculationContext(IBaritone baritone, boolean forUseOnAnotherThread) {
         this.bsi = new BlockStateInterface(world, worldData, forUseOnAnotherThread);
         this.toolSet = new ToolSet(player);
         this.hasThrowaway = Baritone.settings().allowPlace.value && ((Baritone) baritone).getInventoryBehavior().hasGenericThrowaway();
-        this.hasWaterBucket = Baritone.settings().allowWaterBucketFall.value && Inventory.isHotbarSlot(player.inventory.findSlotMatchingItem(STACK_BUCKET_WATER)) && world.dimension() != Level.NETHER;
+        this.hasWaterBucket = Baritone.settings().allowWaterBucketFall.value && Inventory.isHotbarSlot(player.getInventory().findSlotMatchingItem(STACK_BUCKET_WATER)) && world.dimension() != Level.NETHER;
         this.canSprint = Baritone.settings().allowSprint.value && player.getFoodData().getFoodLevel() > 6;
         this.placeBlockCost = Baritone.settings().blockPlacementPenalty.value;
         this.allowBreak = Baritone.settings().allowBreak.value;

File: src/main/java/baritone/pathing/movement/Moves.java
Patch:
@@ -31,7 +31,7 @@ public enum Moves {
     DOWNWARD(0, -1, 0) {
         @Override
         public Movement apply0(CalculationContext context, BetterBlockPos src) {
-            return new MovementDownward(context.getBaritone(), src, src.down());
+            return new MovementDownward(context.getBaritone(), src, src.below());
         }
 
         @Override
@@ -43,7 +43,7 @@ public double cost(CalculationContext context, int x, int y, int z) {
     PILLAR(0, +1, 0) {
         @Override
         public Movement apply0(CalculationContext context, BetterBlockPos src) {
-            return new MovementPillar(context.getBaritone(), src, src.up());
+            return new MovementPillar(context.getBaritone(), src, src.above());
         }
 
         @Override

File: src/main/java/baritone/pathing/movement/movements/MovementDownward.java
Patch:
@@ -83,8 +83,8 @@ public MovementState updateState(MovementState state) {
         } else if (!playerInValidPosition()) {
             return state.setStatus(MovementStatus.UNREACHABLE);
         }
-        double diffX = ctx.player().getPositionVec().x - (dest.getX() + 0.5);
-        double diffZ = ctx.player().getPositionVec().z - (dest.getZ() + 0.5);
+        double diffX = ctx.player().position().x - (dest.getX() + 0.5);
+        double diffZ = ctx.player().position().z - (dest.getZ() + 0.5);
         double ab = Math.sqrt(diffX * diffX + diffZ * diffZ);
 
         if (numTicks++ < 10 && ab < 0.2) {

File: src/main/java/baritone/process/BackfillProcess.java
Patch:
@@ -104,7 +104,7 @@ public List<BlockPos> toFillIn() {
                 .filter(pos -> ctx.world().getBlockState(pos).getBlock() == Blocks.AIR)
                 .filter(pos -> baritone.getBuilderProcess().placementPlausible(pos, Blocks.DIRT.defaultBlockState()))
                 .filter(pos -> !partOfCurrentMovement(pos))
-                .sorted(Comparator.<BlockPos>comparingDouble(ctx.playerFeet()::distanceSq).reversed())
+                .sorted(Comparator.<BlockPos>comparingDouble(ctx.playerFeet()::distSqr).reversed())
                 .collect(Collectors.toList());
     }
 

File: src/main/java/baritone/process/CustomGoalProcess.java
Patch:
@@ -92,7 +92,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
                 if (this.goal == null || (this.goal.isInGoal(ctx.playerFeet()) && this.goal.isInGoal(baritone.getPathingBehavior().pathStart()))) {
                     onLostControl(); // we're there xd
                     if (Baritone.settings().disconnectOnArrival.value) {
-                        ctx.world().sendQuittingDisconnectingPacket();
+                        ctx.world().disconnect();
                     }
                     if (Baritone.settings().desktopNotifications.value && Baritone.settings().notificationOnPathComplete.value) {
                         NotificationHelper.notify("Pathing complete", false);

File: src/main/java/baritone/process/FarmProcess.java
Patch:
@@ -32,7 +32,6 @@
 import baritone.pathing.movement.MovementHelper;
 import baritone.utils.BaritoneProcessHelper;
 import baritone.utils.NotificationHelper;
-import net.minecraft.block.*;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.world.entity.Entity;
@@ -230,7 +229,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
             }
             if (state.getBlock() instanceof BonemealableBlock) {
                 BonemealableBlock ig = (BonemealableBlock) state.getBlock();
-                if (ig.isValidBonemealTarget(ctx.world(), pos, state, true) && ig.isBonemealSuccess(ctx.world(), ctx.world().rand, pos, state)) {
+                if (ig.isValidBonemealTarget(ctx.world(), pos, state, true) && ig.isBonemealSuccess(ctx.world(), ctx.world().random, pos, state)) {
                     bonemealable.add(pos);
                 }
             }

File: src/main/java/baritone/selection/SelectionRenderer.java
Patch:
@@ -38,13 +38,13 @@ public static void renderSelections(PoseStack stack, ISelection[] selections) {
             IRenderer.glColor(settings.colorSelectionPos1.value, opacity);
 
             for (ISelection selection : selections) {
-                IRenderer.drawAABB(stack, new AABB(selection.pos1(), selection.pos1().add(1, 1, 1)));
+                IRenderer.drawAABB(stack, new AABB(selection.pos1(), selection.pos1().offset(1, 1, 1)));
             }
 
             IRenderer.glColor(settings.colorSelectionPos2.value, opacity);
 
             for (ISelection selection : selections) {
-                IRenderer.drawAABB(stack, new AABB(selection.pos2(), selection.pos2().add(1, 1, 1)));
+                IRenderer.drawAABB(stack, new AABB(selection.pos2(), selection.pos2().offset(1, 1, 1)));
             }
         }
 

File: src/main/java/baritone/utils/BlockBreakHelper.java
Patch:
@@ -56,12 +56,12 @@ public void tick(boolean isLeftClick) {
             if (!didBreakLastTick) {
                 ctx.playerController().syncHeldItem();
                 ctx.playerController().clickBlock(((BlockHitResult) trace).getBlockPos(), ((BlockHitResult) trace).getDirection());
-                ctx.player().swingArm(InteractionHand.MAIN_HAND);
+                ctx.player().swing(InteractionHand.MAIN_HAND);
             }
 
             // Attempt to break the block
             if (ctx.playerController().onPlayerDamageBlock(((BlockHitResult) trace).getBlockPos(), ((BlockHitResult) trace).getDirection())) {
-                ctx.player().swingArm(InteractionHand.MAIN_HAND);
+                ctx.player().swing(InteractionHand.MAIN_HAND);
             }
 
             ctx.playerController().setHittingBlock(false);

File: src/main/java/baritone/utils/BlockPlaceHelper.java
Patch:
@@ -40,16 +40,16 @@ public void tick(boolean rightClickRequested) {
             return;
         }
         HitResult mouseOver = ctx.objectMouseOver();
-        if (!rightClickRequested || ctx.player().isRowingBoat() || mouseOver == null || mouseOver.getType() != HitResult.Type.BLOCK) {
+        if (!rightClickRequested || ctx.player().isHandsBusy() || mouseOver == null || mouseOver.getType() != HitResult.Type.BLOCK) {
             return;
         }
         rightClickTimer = Baritone.settings().rightClickSpeed.value;
         for (InteractionHand hand : InteractionHand.values()) {
             if (ctx.playerController().processRightClickBlock(ctx.player(), ctx.world(), hand, (BlockHitResult) mouseOver) == InteractionResult.SUCCESS) {
-                ctx.player().swingArm(hand);
+                ctx.player().swing(hand);
                 return;
             }
-            if (!ctx.player().getHeldItem(hand).isEmpty() && ctx.playerController().processRightClick(ctx.player(), ctx.world(), hand) == InteractionResult.SUCCESS) {
+            if (!ctx.player().getItemInHand(hand).isEmpty() && ctx.playerController().processRightClick(ctx.player(), ctx.world(), hand) == InteractionResult.SUCCESS) {
                 return;
             }
         }

File: src/main/java/baritone/utils/ToolSet.java
Patch:
@@ -106,7 +106,7 @@ public int getBestSlot(Block b, boolean preferSilkTouch, boolean pathingCalculat
         possible, this lets us make pathing depend on the actual tool to be used (if auto tool is disabled)
         */
         if (Baritone.settings().disableAutoTool.value && pathingCalculation) {
-            return player.inventory.selected;
+            return player.getInventory().selected;
         }
 
         int best = 0;
@@ -115,7 +115,7 @@ possible, this lets us make pathing depend on the actual tool to be used (if aut
         boolean bestSilkTouch = false;
         BlockState blockState = b.defaultBlockState();
         for (int i = 0; i < 9; i++) {
-            ItemStack itemStack = player.inventory.getItem(i);
+            ItemStack itemStack = player.getInventory().getItem(i);
             double speed = calculateSpeedVsBlock(itemStack, blockState);
             boolean silkTouch = hasSilkTouch(itemStack);
             if (speed > highestSpeed) {
@@ -144,7 +144,7 @@ possible, this lets us make pathing depend on the actual tool to be used (if aut
      * @return A double containing the destruction ticks with the best tool
      */
     private double getBestDestructionTime(Block b) {
-        ItemStack stack = player.inventory.getItem(getBestSlot(b, false, true));
+        ItemStack stack = player.getInventory().getItem(getBestSlot(b, false, true));
         return calculateSpeedVsBlock(stack, b.defaultBlockState()) * avoidanceMultiplier(b);
     }
 

File: src/main/java/baritone/utils/player/PrimaryPlayerContext.java
Patch:
@@ -49,7 +49,7 @@ public IPlayerController playerController() {
 
     @Override
     public Level world() {
-        return mc.world;
+        return mc.level;
     }
 
     @Override

File: src/main/java/baritone/utils/PathRenderer.java
Patch:
@@ -210,7 +210,7 @@ public static void drawDankLitGoalBox(Entity player, Goal goal, float partialTic
         double y, y1, y2;
         if (settings.renderGoalAsBox.value) {
             // y = 1 causes rendering issues when the player is at the same y as the top of a block for some reason
-            y = .999F;
+            y = 0.999F;
         }
         else {
             y = MathHelper.cos((float) (((float) ((System.nanoTime() / 100000L) % 20000L)) / 20000F * Math.PI * 2));

File: src/main/java/baritone/utils/PathRenderer.java
Patch:
@@ -209,7 +209,8 @@ public static void drawDankLitGoalBox(Entity player, Goal goal, float partialTic
         double minY, maxY;
         double y, y1, y2;
         if (settings.renderGoalAsBox.value) {
-            y = 1;
+            // y = 1 causes rendering issues when the player is at the same y as the top of a block for some reason
+            y = .999F;
         }
         else {
             y = MathHelper.cos((float) (((float) ((System.nanoTime() / 100000L) % 20000L)) / 20000F * Math.PI * 2));

File: src/main/java/baritone/command/defaults/SchematicaCommand.java
Patch:
@@ -51,7 +51,7 @@ public String getShortDesc() {
     @Override
     public List<String> getLongDesc() {
         return Arrays.asList(
-                "Builds the schematica currently open in Schematica.",
+                "Builds the schematic currently open in Schematica.",
                 "",
                 "Usage:",
                 "> schematica"

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -848,9 +848,9 @@ public final class Settings {
     public final Setting<Boolean> skipFailedLayers = new Setting<>(false);
 
     /**
-     * Only build the selected part of the schematic when using #schematica
+     * Only build the selected part of schematics
      */
-     public final Setting<Boolean> schematicaOnlyBuildSelection = new Setting<>(false);
+     public final Setting<Boolean> buildOnlySelection = new Setting<>(false);
 
     /**
      * How far to move before repeating the build. 0 to disable repeating on a certain axis, 0,0,0 to disable entirely

File: src/main/java/baritone/command/defaults/SchematicaCommand.java
Patch:
@@ -51,7 +51,7 @@ public String getShortDesc() {
     @Override
     public List<String> getLongDesc() {
         return Arrays.asList(
-                "Builds the schematica currently open in Schematica.",
+                "Builds the schematic currently open in Schematica.",
                 "",
                 "Usage:",
                 "> schematica"

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -664,7 +664,7 @@ public final class Settings {
 
     /**
      * When GetToBlockProcess or MineProcess fails to calculate a path, instead of just giving up, mark the closest instance
-     * of that block as "unreachable" and go towards the next closest. GetToBlock expands this seaarch to the whole "vein"; MineProcess does not.
+     * of that block as "unreachable" and go towards the next closest. GetToBlock expands this search to the whole "vein"; MineProcess does not.
      * This is because MineProcess finds individual impossible blocks (like one block in a vein that has gravel on top then lava, so it can't break)
      * Whereas GetToBlock should blacklist the whole "vein" if it can't get to any of them.
      */

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -664,7 +664,7 @@ public final class Settings {
 
     /**
      * When GetToBlockProcess or MineProcess fails to calculate a path, instead of just giving up, mark the closest instance
-     * of that block as "unreachable" and go towards the next closest. GetToBlock expands this seaarch to the whole "vein"; MineProcess does not.
+     * of that block as "unreachable" and go towards the next closest. GetToBlock expands this search to the whole "vein"; MineProcess does not.
      * This is because MineProcess finds individual impossible blocks (like one block in a vein that has gravel on top then lava, so it can't break)
      * Whereas GetToBlock should blacklist the whole "vein" if it can't get to any of them.
      */

File: src/main/java/baritone/cache/ChunkPacker.java
Patch:
@@ -123,7 +123,7 @@ private static PathingBlockType getPathingBlockType(IBlockState state, Chunk chu
                 return PathingBlockType.AVOID;
             }
             if (x == 0 || x == 15 || z == 0 || z == 15) {
-                if (BlockLiquid.getSlopeAngle(chunk.getWorld(), new BlockPos(x + chunk.x << 4, y, z + chunk.z << 4), state.getMaterial(), state) == -1000.0F) {
+                if (BlockLiquid.getSlopeAngle(chunk.getWorld(), new BlockPos(x + (chunk.x << 4), y, z + (chunk.z << 4)), state.getMaterial(), state) == -1000.0F) {
                     return PathingBlockType.WATER;
                 }
                 return PathingBlockType.AVOID;

File: src/main/java/baritone/cache/ChunkPacker.java
Patch:
@@ -123,7 +123,7 @@ private static PathingBlockType getPathingBlockType(IBlockState state, Chunk chu
                 return PathingBlockType.AVOID;
             }
             if (x == 0 || x == 15 || z == 0 || z == 15) {
-                if (BlockLiquid.getSlopeAngle(chunk.getWorld(), new BlockPos(x + chunk.x << 4, y, z + chunk.z << 4), state.getMaterial(), state) == -1000.0F) {
+                if (BlockLiquid.getSlopeAngle(chunk.getWorld(), new BlockPos(x + (chunk.x << 4), y, z + (chunk.z << 4)), state.getMaterial(), state) == -1000.0F) {
                     return PathingBlockType.WATER;
                 }
                 return PathingBlockType.AVOID;

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -1121,7 +1121,7 @@ public final class Settings {
     /**
      * Use sword to mine.
      */
-    public final Setting<Boolean> useSwordToMine = new Setting<>(false);
+    public final Setting<Boolean> useSwordToMine = new Setting<>(true);
 
     /**
      * Desktop notifications

File: src/main/java/baritone/utils/ToolSet.java
Patch:
@@ -125,14 +125,13 @@ possible, this lets us make pathing depend on the actual tool to be used (if aut
         IBlockState blockState = b.getDefaultState();
         for (int i = 0; i < 9; i++) {
             ItemStack itemStack = player.inventory.getStackInSlot(i);
-            if (!Baritone.settings().useSwordToMine.value && itemStack.getItem() instanceof ItemSword){
+            if (!Baritone.settings().useSwordToMine.value && itemStack.getItem() instanceof ItemSword) {
                 continue;
             }
           
             if (Baritone.settings().itemSaver.value && itemStack.getItemDamage() >= itemStack.getMaxDamage() && itemStack.getMaxDamage() > 1) {
                 continue;
             }
-          
             double speed = calculateSpeedVsBlock(itemStack, blockState);
             boolean silkTouch = hasSilkTouch(itemStack);
             if (speed > highestSpeed) {

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -1111,7 +1111,7 @@ public final class Settings {
     /**
      * Use sword to mine.
      */
-    public final Setting<Boolean> useSwordToMine = new Setting<>(true);
+    public final Setting<Boolean> useSwordToMine = new Setting<>(false);
 
     /**
      * Desktop notifications

File: src/main/java/baritone/behavior/MemoryBehavior.java
Patch:
@@ -175,7 +175,7 @@ public void onBlockInteract(BlockInteractEvent event) {
     @Override
     public void onPlayerDeath() {
         Waypoint deathWaypoint = new Waypoint("death", Waypoint.Tag.DEATH, ctx.playerFeet());
-        baritone.getWorldProvider().getCurrentWorld().getWaypoints().addWaypoint(new Waypoint("death", Waypoint.Tag.DEATH, ctx.playerFeet()));
+        baritone.getWorldProvider().getCurrentWorld().getWaypoints().addWaypoint(deathWaypoint);
         ITextComponent component = new TextComponentString("Death position saved.");
         component.getStyle()
                 .setColor(TextFormatting.WHITE)

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -562,9 +562,9 @@ static PlaceResult attemptToPlaceABlock(MovementState state, IBaritone baritone,
     enum PlaceResult {
         READY_TO_PLACE, ATTEMPTING, NO_OPTION;
     }
-    public static boolean isTransparent(Block b) {
+    static boolean isTransparent(Block b) {
 
-        return b== Blocks.AIR ||
+        return b == Blocks.AIR ||
                 b == Blocks.FLOWING_LAVA ||
                 b == Blocks.FLOWING_WATER ||
                 b == Blocks.WATER;

File: src/main/java/baritone/utils/IRenderer.java
Patch:
@@ -45,7 +45,6 @@ static void glColor(Color color, float alpha) {
 
     static void startLines(Color color, float alpha, float lineWidth, boolean ignoreDepth) {
         GlStateManager.enableBlend();
-        GlStateManager.disableLighting();
         GlStateManager.tryBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);
         glColor(color, alpha);
         GlStateManager.glLineWidth(lineWidth);
@@ -68,7 +67,6 @@ static void endLines(boolean ignoredDepth) {
 
         GlStateManager.depthMask(true);
         GlStateManager.enableTexture2D();
-        GlStateManager.enableLighting();
         GlStateManager.disableBlend();
     }
 

File: src/main/java/baritone/utils/IRenderer.java
Patch:
@@ -45,7 +45,6 @@ static void glColor(Color color, float alpha) {
 
     static void startLines(Color color, float alpha, float lineWidth, boolean ignoreDepth) {
         GlStateManager.enableBlend();
-        GlStateManager.disableLighting();
         GlStateManager.tryBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);
         glColor(color, alpha);
         GlStateManager.glLineWidth(lineWidth);
@@ -68,7 +67,6 @@ static void endLines(boolean ignoredDepth) {
 
         GlStateManager.depthMask(true);
         GlStateManager.enableTexture2D();
-        GlStateManager.enableLighting();
         GlStateManager.disableBlend();
     }
 

File: src/main/java/baritone/behavior/PathingBehavior.java
Patch:
@@ -378,7 +378,8 @@ public CalculationContext secretInternalGetCalculationContext() {
     }
 
     public Optional<Double> estimatedTicksToGoal() {
-        if (goal == null) {
+        BetterBlockPos currentPos = ctx.playerFeet();
+        if (goal == null || currentPos == null || startPosition == null) {
             return Optional.empty();
         }
         if (goal.isInGoal(ctx.playerFeet())) {
@@ -388,7 +389,6 @@ public Optional<Double> estimatedTicksToGoal() {
         if (ticksElapsedSoFar == 0) {
             return Optional.empty();
         }
-        BetterBlockPos currentPos = ctx.playerFeet();
         double current = goal.heuristic(currentPos.x, currentPos.y, currentPos.z);
         double start = goal.heuristic(startPosition.x, startPosition.y, startPosition.z);
         if (current == start) {//can't check above because current and start can be equal even if currentPos and startPosition are not

File: src/main/java/baritone/utils/BaritoneProcessHelper.java
Patch:
@@ -30,7 +30,6 @@ public abstract class BaritoneProcessHelper implements IBaritoneProcess, Helper
     public BaritoneProcessHelper(Baritone baritone) {
         this.baritone = baritone;
         this.ctx = baritone.getPlayerContext();
-        baritone.getPathingControlManager().registerProcess(this);
     }
 
     @Override

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -734,7 +734,7 @@ public final class Settings {
     /**
      * When allowOnlyExposedOres is enabled this is the distance around to search.
      * <p>
-     * It is recommended to keep this value low, as it exponentially increases calculation times and also to keep the
+     * It is recommended to keep this value low, as it dramatically increases calculation times.
      */
     public final Setting<Integer> allowOnlyExposedOresDistance = new Setting<>(1);
 

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -64,7 +64,7 @@ public final class Settings {
     /**
      * Disable baritone's auto-tool at runtime, but still assume that another mod will provide auto tool functionality
      * <p>
-     * Specifically, path calculation will still assume that an auto tool wil run at execution time, even though
+     * Specifically, path calculation will still assume that an auto tool will run at execution time, even though
      * Baritone itself will not do that.
      */
     public final Setting<Boolean> assumeExternalAutoTool = new Setting<>(false);

File: src/api/java/baritone/api/process/IBaritoneProcess.java
Patch:
@@ -75,7 +75,7 @@ public interface IBaritoneProcess {
      * to start eating this tick. {@code PauseForAutoEatProcess} should only actually right click once onTick is called with
      * {@code isSafeToCancel} true though.
      *
-     * @return Whethor or not if this control is temporary
+     * @return Whether or not if this control is temporary
      */
     boolean isTemporary();
 

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -64,7 +64,7 @@ public final class Settings {
     /**
      * Disable baritone's auto-tool at runtime, but still assume that another mod will provide auto tool functionality
      * <p>
-     * Specifically, path calculation will still assume that an auto tool wil run at execution time, even though
+     * Specifically, path calculation will still assume that an auto tool will run at execution time, even though
      * Baritone itself will not do that.
      */
     public final Setting<Boolean> assumeExternalAutoTool = new Setting<>(false);

File: src/api/java/baritone/api/process/IBaritoneProcess.java
Patch:
@@ -75,7 +75,7 @@ public interface IBaritoneProcess {
      * to start eating this tick. {@code PauseForAutoEatProcess} should only actually right click once onTick is called with
      * {@code isSafeToCancel} true though.
      *
-     * @return Whethor or not if this control is temporary
+     * @return Whether or not if this control is temporary
      */
     boolean isTemporary();
 

File: src/main/java/baritone/command/defaults/ETACommand.java
Patch:
@@ -72,7 +72,7 @@ public List<String> getLongDesc() {
                 "Be aware that the ETA to your goal is really unprecise",
                 "",
                 "Usage:",
-                "> proc - View ETA, if present"
+                "> eta - View ETA, if present"
         );
     }
 }

File: src/main/java/baritone/command/defaults/GotoCommand.java
Patch:
@@ -72,7 +72,7 @@ public String getShortDesc() {
     @Override
     public List<String> getLongDesc() {
         return Arrays.asList(
-                "The got command tells Baritone to head towards a given goal or block.",
+                "The goto command tells Baritone to head towards a given goal or block.",
                 "",
                 "Wherever a coordinate is expected, you can use ~ just like in regular Minecraft commands. Or, you can just use regular numbers.",
                 "",

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -756,7 +756,7 @@ public final class Settings {
      * Start building the schematic at a specific layer.
      * Can help on larger builds when schematic wants to break things its already built
      */
-    public final Setting<Integer> startAtLayer = new Setting<>(1);
+    public final Setting<Integer> startAtLayer = new Setting<>(0);
 
     /**
      * How far to move before repeating the build. 0 to disable repeating on a certain axis, 0,0,0 to disable entirely

File: buildSrc/src/main/java/baritone/gradle/task/ProguardTask.java
Patch:
@@ -99,7 +99,7 @@ private void extractProguard() throws Exception {
         }
     }
 
-    private String getJavaBinPathForProguard() {
+    private String getJavaBinPathForProguard() throws Exception {
         String path;
         try {
             path = findJavaPathByGradleConfig();

File: src/main/java/baritone/cache/WorldScanner.java
Patch:
@@ -162,7 +162,7 @@ private boolean scanChunkInto(int chunkX, int chunkZ, Chunk chunk, BlockOptional
             final int imax = 1 << 12;
             for (int i = 0; i < imax; i++) {
                 BlockState state = bsc.getAtPalette(storage[i]);
-                if (filter.has(state)) {
+                if (state != null && filter.has(state)) {
                     int y = yReal | ((i >> 8) & 15);
                     if (result.size() >= max) {
                         if (Math.abs(y - playerY) < yLevelThreshold) {

File: src/main/java/baritone/command/defaults/GotoCommand.java
Patch:
@@ -72,7 +72,7 @@ public String getShortDesc() {
     @Override
     public List<String> getLongDesc() {
         return Arrays.asList(
-                "The got command tells Baritone to head towards a given goal or block.",
+                "The goto command tells Baritone to head towards a given goal or block.",
                 "",
                 "Wherever a coordinate is expected, you can use ~ just like in regular Minecraft commands. Or, you can just use regular numbers.",
                 "",

File: src/launch/java/baritone/launch/mixins/MixinLivingEntity.java
Patch:
@@ -33,7 +33,6 @@
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
 import static org.objectweb.asm.Opcodes.GETFIELD;
-//import static org.spongepowered.asm.lib.Opcodes.GETFIELD;
 
 /**
  * @author Brady

File: src/launch/java/baritone/launch/mixins/MixinMinecraft.java
Patch:
@@ -27,7 +27,6 @@
 import net.minecraft.client.entity.player.ClientPlayerEntity;
 import net.minecraft.client.gui.screen.Screen;
 import net.minecraft.client.world.ClientWorld;
-//import org.spongepowered.asm.lib.Opcodes;
 import org.objectweb.asm.Opcodes;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Shadow;

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -89,7 +89,7 @@ static boolean canWalkThrough(BlockStateInterface bsi, int x, int y, int z, IBlo
         if (block == Blocks.AIR) { // early return for most common case
             return true;
         }
-        if (block == Blocks.FIRE || block == Blocks.TRIPWIRE || block == Blocks.WEB || block == Blocks.END_PORTAL || block == Blocks.COCOA || block instanceof BlockSkull || block instanceof BlockTrapDoor) {
+        if (block == Blocks.FIRE || block == Blocks.TRIPWIRE || block == Blocks.WEB || block == Blocks.END_PORTAL || block == Blocks.COCOA || block instanceof BlockSkull || block instanceof BlockTrapDoor || block == Blocks.END_ROD) {
             return false;
         }
         if (Baritone.settings().blocksToAvoid.value.contains(block)) {
@@ -302,7 +302,7 @@ static boolean canWalkOn(BlockStateInterface bsi, int x, int y, int z, IBlockSta
         if (block == Blocks.FARMLAND || block == Blocks.GRASS_PATH) {
             return true;
         }
-        if (block == Blocks.ENDER_CHEST || block == Blocks.CHEST || block == Blocks.TRAPPED_CHEST ) {
+        if (block == Blocks.ENDER_CHEST || block == Blocks.CHEST || block == Blocks.TRAPPED_CHEST) {
             return true;
         }
         if (isWater(block)) {

File: src/main/java/baritone/command/defaults/BuildCommand.java
Patch:
@@ -19,13 +19,13 @@
 
 import baritone.Baritone;
 import baritone.api.IBaritone;
-import baritone.api.utils.BetterBlockPos;
 import baritone.api.command.Command;
+import baritone.api.command.argument.IArgConsumer;
 import baritone.api.command.datatypes.RelativeBlockPos;
 import baritone.api.command.datatypes.RelativeFile;
 import baritone.api.command.exception.CommandException;
 import baritone.api.command.exception.CommandInvalidStateException;
-import baritone.api.command.argument.IArgConsumer;
+import baritone.api.utils.BetterBlockPos;
 import net.minecraft.client.Minecraft;
 import org.apache.commons.io.FilenameUtils;
 
@@ -59,7 +59,7 @@ public void execute(String label, IArgConsumer args) throws CommandException {
         }
         boolean success = baritone.getBuilderProcess().build(file.getName(), file, buildOrigin);
         if (!success) {
-            throw new CommandInvalidStateException("Couldn't load the schematic");
+            throw new CommandInvalidStateException("Couldn't load the schematic. Make sure to use the FULL file name, including the extension (e.g. blah.schematic).");
         }
         logDirect(String.format("Successfully loaded schematic for building\nOrigin: %s", buildOrigin));
     }

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -302,7 +302,7 @@ static boolean canWalkOn(BlockStateInterface bsi, int x, int y, int z, IBlockSta
         if (block == Blocks.FARMLAND || block == Blocks.GRASS_PATH) {
             return true;
         }
-        if (block == Blocks.ENDER_CHEST || block == Blocks.CHEST) {
+        if (block == Blocks.ENDER_CHEST || block == Blocks.CHEST || block == Blocks.TRAPPED_CHEST ) {
             return true;
         }
         if (isWater(block)) {

File: src/main/java/baritone/command/defaults/TunnelCommand.java
Patch:
@@ -107,7 +107,7 @@ public List<String> getLongDesc() {
                 "",
                 "Usage:",
                 "> tunnel - No arguments, mines in a 1x2 radius.",
-                "> tunnel height/width/depth - Tunnels in a user defined height, width and depth."
+                "> tunnel <height> <width> <depth> - Tunnels in a user defined height, width and depth."
         );
     }
 }

File: src/launch/java/baritone/launch/mixins/MixinMinecraft.java
Patch:
@@ -145,7 +145,7 @@ private void postLoadWorld(WorldClient world, String loadingMessage, CallbackInf
     )
     private boolean isAllowUserInput(GuiScreen screen) {
         // allow user input is only the primary baritone
-        return (BaritoneAPI.getProvider().getPrimaryBaritone().getPathingBehavior().getCurrent() != null && player != null) || screen.allowUserInput;
+        return (BaritoneAPI.getProvider().getPrimaryBaritone().getPathingBehavior().isPathing() && player != null) || screen.allowUserInput;
     }
 
     @Inject(

File: src/main/java/baritone/behavior/PathingBehavior.java
Patch:
@@ -103,7 +103,7 @@ public void onTick(TickEvent event) {
 
     @Override
     public void onPlayerSprintState(SprintStateEvent event) {
-        if (current != null) {
+        if (isPathing()) {
             event.setState(current.isSprinting());
         }
     }

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -302,7 +302,7 @@ static boolean canWalkOn(BlockStateInterface bsi, int x, int y, int z, IBlockSta
         if (block == Blocks.FARMLAND || block == Blocks.GRASS_PATH) {
             return true;
         }
-        if (block == Blocks.ENDER_CHEST || block == Blocks.CHEST) {
+        if (block == Blocks.ENDER_CHEST || block == Blocks.CHEST || block == Blocks.TRAPPED_CHEST ) {
             return true;
         }
         if (isWater(block)) {

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -177,7 +177,7 @@ protected boolean prepared(MovementState state) {
                 //i'm doing it anyway
                 //i dont care if theres snow in the way!!!!!!!
                 //you dont own me!!!!
-                state.setTarget(new MovementState.MovementTarget(RotationUtils.calcRotationFromVec3d(ctx.player().getPositionEyes(1.0F),
+                state.setTarget(new MovementState.MovementTarget(RotationUtils.calcRotationFromVec3d(ctx.playerHead(),
                         VecUtils.getBlockPosCenter(blockPos), ctx.playerRotations()), true)
                 );
                 // don't check selectedblock on this one, this is a fallback when we can't see any face directly, it's intended to be breaking the "incorrect" block

File: src/main/java/baritone/pathing/movement/movements/MovementAscend.java
Patch:
@@ -175,7 +175,7 @@ public MovementState updateState(MovementState state) {
         IBlockState jumpingOnto = BlockStateInterface.get(ctx, positionToPlace);
         if (!MovementHelper.canWalkOn(ctx, positionToPlace, jumpingOnto)) {
             ticksWithoutPlacement++;
-            if (MovementHelper.attemptToPlaceABlock(state, baritone, dest.down(), false) == PlaceResult.READY_TO_PLACE) {
+            if (MovementHelper.attemptToPlaceABlock(state, baritone, dest.down(), false, true) == PlaceResult.READY_TO_PLACE) {
                 state.setInput(Input.SNEAK, true);
                 if (ctx.player().isSneaking()) {
                     state.setInput(Input.CLICK_RIGHT, true);

File: src/main/java/baritone/pathing/movement/movements/MovementDescend.java
Patch:
@@ -224,7 +224,7 @@ public MovementState updateState(MovementState state) {
             double destZ = (src.getZ() + 0.5) * 0.17 + (dest.getZ() + 0.5) * 0.83;
             EntityPlayerSP player = ctx.player();
             state.setTarget(new MovementState.MovementTarget(
-                    new Rotation(RotationUtils.calcRotationFromVec3d(player.getPositionEyes(1.0F),
+                    new Rotation(RotationUtils.calcRotationFromVec3d(ctx.playerHead(),
                             new Vec3d(destX, dest.getY(), destZ),
                             new Rotation(player.rotationYaw, player.rotationPitch)).getYaw(), player.rotationPitch),
                     false

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -250,7 +250,7 @@ public MovementState updateState(MovementState state) {
             }
         } else if (!ctx.playerFeet().equals(src)) {
             if (ctx.playerFeet().equals(src.offset(direction)) || ctx.player().posY - src.y > 0.0001) {
-                if (!MovementHelper.canWalkOn(ctx, dest.down()) && !ctx.player().onGround && MovementHelper.attemptToPlaceABlock(state, baritone, dest.down(), true) == PlaceResult.READY_TO_PLACE) {
+                if (!MovementHelper.canWalkOn(ctx, dest.down()) && !ctx.player().onGround && MovementHelper.attemptToPlaceABlock(state, baritone, dest.down(), true, false) == PlaceResult.READY_TO_PLACE) {
                     // go in the opposite order to check DOWN before all horizontals -- down is preferable because you don't have to look to the side while in midair, which could mess up the trajectory
                     state.setInput(Input.CLICK_RIGHT, true);
                 }

File: src/main/java/baritone/pathing/movement/movements/MovementPillar.java
Patch:
@@ -184,7 +184,7 @@ public MovementState updateState(MovementState state) {
         }
         boolean ladder = fromDown.getBlock() == Blocks.LADDER || fromDown.getBlock() == Blocks.VINE;
         boolean vine = fromDown.getBlock() == Blocks.VINE;
-        Rotation rotation = RotationUtils.calcRotationFromVec3d(ctx.player().getPositionEyes(1.0F),
+        Rotation rotation = RotationUtils.calcRotationFromVec3d(ctx.playerHead(),
                 VecUtils.getBlockPosCenter(positionToPlace),
                 new Rotation(ctx.player().rotationYaw, ctx.player().rotationPitch));
         if (!ladder) {

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -280,7 +280,7 @@ public MovementState updateState(MovementState state) {
                 }
             }
             double dist1 = Math.max(Math.abs(ctx.player().posX - (dest.getX() + 0.5D)), Math.abs(ctx.player().posZ - (dest.getZ() + 0.5D)));
-            PlaceResult p = MovementHelper.attemptToPlaceABlock(state, baritone, dest.down(), false);
+            PlaceResult p = MovementHelper.attemptToPlaceABlock(state, baritone, dest.down(), false, true);
             if ((p == PlaceResult.READY_TO_PLACE || dist1 < 0.6) && !Baritone.settings().assumeSafeWalk.value) {
                 state.setInput(Input.SNEAK, true);
             }

File: src/main/java/baritone/process/BackfillProcess.java
Patch:
@@ -75,7 +75,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
         baritone.getInputOverrideHandler().clearAllKeys();
         for (BlockPos toPlace : toFillIn()) {
             MovementState fake = new MovementState();
-            switch (MovementHelper.attemptToPlaceABlock(fake, baritone, toPlace, false)) {
+            switch (MovementHelper.attemptToPlaceABlock(fake, baritone, toPlace, false, false)) {
                 case NO_OPTION:
                     continue;
                 case READY_TO_PLACE:

File: src/main/java/baritone/process/FarmProcess.java
Patch:
@@ -232,7 +232,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
         both.addAll(openSoulsand);
         for (BlockPos pos : both) {
             boolean soulsand = openSoulsand.contains(pos);
-            Optional<Rotation> rot = RotationUtils.reachableOffset(ctx.player(), pos, new Vec3d(pos.getX() + 0.5, pos.getY() + 1, pos.getZ() + 0.5), ctx.playerController().getBlockReachDistance());
+            Optional<Rotation> rot = RotationUtils.reachableOffset(ctx.player(), pos, new Vec3d(pos.getX() + 0.5, pos.getY() + 1, pos.getZ() + 0.5), ctx.playerController().getBlockReachDistance(), false);
             if (rot.isPresent() && isSafeToCancel && baritone.getInventoryBehavior().throwaway(true, soulsand ? this::isNetherWart : this::isPlantable)) {
                 RayTraceResult result = RayTraceUtils.rayTraceTowards(ctx.player(), rot.get(), ctx.playerController().getBlockReachDistance());
                 if (result.typeOfHit == RayTraceResult.Type.BLOCK && result.sideHit == EnumFacing.UP) {

File: src/api/java/baritone/api/utils/Helper.java
Patch:
@@ -50,7 +50,7 @@ static ITextComponent getPrefix() {
         // Inner text component
         final Calendar now = Calendar.getInstance();
         final boolean xd = now.get(Calendar.MONTH) == Calendar.APRIL && now.get(Calendar.DAY_OF_MONTH) <= 3;
-        ITextComponent baritone = new TextComponentString(BaritoneAPI.getSettings().shortBaritonePrefix.value ? "B" : (xd ? "Baritoe" : "Baritone"));
+        ITextComponent baritone = new TextComponentString(xd ? "Baritoe" : BaritoneAPI.getSettings().shortBaritonePrefix.value ? "B" : "Baritone");
         baritone.getStyle().setColor(TextFormatting.LIGHT_PURPLE);
 
         // Outer brackets

File: src/launch/java/baritone/launch/mixins/MixinScreen.java
Patch:
@@ -29,5 +29,5 @@ public abstract class MixinScreen implements IGuiScreen {
 
     @Override
     @Invoker("openLink")
-    public abstract void openLink(URI url);
+    public abstract void openLinkInvoker(URI url);
 }

File: src/main/java/baritone/command/BaritoneChatControl.java
Patch:
@@ -100,7 +100,7 @@ public boolean runCommand(String msg) {
             return false;
         } else if (msg.trim().equalsIgnoreCase("orderpizza")) {
             try {
-                ((IGuiScreen) mc.currentScreen).openLink(new URI("https://www.dominos.com/en/pages/order/"));
+                ((IGuiScreen) mc.currentScreen).openLinkInvoker(new URI("https://www.dominos.com/en/pages/order/"));
             } catch (NullPointerException | URISyntaxException ignored) {}
             return false;
         }

File: src/main/java/baritone/utils/accessor/IGuiScreen.java
Patch:
@@ -21,5 +21,5 @@
 
 public interface IGuiScreen {
 
-    void openLink(URI url);
+    void openLinkInvoker(URI url);
 }

File: src/main/java/baritone/command/defaults/SelCommand.java
Patch:
@@ -68,7 +68,7 @@ public void onRenderPass(RenderEvent event) {
                 float lineWidth = Baritone.settings().selectionLineWidth.value;
                 boolean ignoreDepth = Baritone.settings().renderSelectionIgnoreDepth.value;
                 IRenderer.startLines(color, opacity, lineWidth, ignoreDepth);
-                IRenderer.drawAABB(event.getMatrixStack(), new AxisAlignedBB(pos1, pos1.add(1, 1, 1)));
+                IRenderer.drawAABB(event.getModelViewStack(), new AxisAlignedBB(pos1, pos1.add(1, 1, 1)));
                 IRenderer.endLines(ignoreDepth);
             }
         });

File: src/main/java/baritone/selection/SelectionRenderer.java
Patch:
@@ -53,6 +53,6 @@ public static void renderSelections(MatrixStack stack, ISelection[] selections)
 
     @Override
     public void onRenderPass(RenderEvent event) {
-        renderSelections(event.getMatrixStack(), manager.getSelections());
+        renderSelections(event.getModelViewStack(), manager.getSelections());
     }
 }

File: src/main/java/baritone/pathing/movement/movements/MovementAscend.java
Patch:
@@ -176,7 +176,7 @@ public MovementState updateState(MovementState state) {
             ticksWithoutPlacement++;
             if (MovementHelper.attemptToPlaceABlock(state, baritone, dest.down(), false) == PlaceResult.READY_TO_PLACE) {
                 state.setInput(Input.SNEAK, true);
-                if (ctx.player().movementInput.field_228350_h_) {
+                if (ctx.player().isCrouching()) {
                     state.setInput(Input.CLICK_RIGHT, true);
                 }
             }

File: src/main/java/baritone/pathing/movement/movements/MovementPillar.java
Patch:
@@ -251,7 +251,7 @@ public MovementState updateState(MovementState state) {
                     state.setInput(Input.JUMP, false); // breaking is like 5x slower when you're jumping
                     state.setInput(Input.CLICK_LEFT, true);
                     blockIsThere = false;
-                } else if (ctx.player().movementInput.field_228350_h_ && (ctx.isLookingAt(src.down()) || ctx.isLookingAt(src)) && ctx.player().getPositionVec().y > dest.getY() + 0.1) {
+                } else if (ctx.player().isCrouching() && (ctx.isLookingAt(src.down()) || ctx.isLookingAt(src)) && ctx.player().getPositionVec().y > dest.getY() + 0.1) {
                     state.setInput(Input.CLICK_RIGHT, true);
                 }
             }

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -286,7 +286,7 @@ public MovementState updateState(MovementState state) {
             }
             switch (p) {
                 case READY_TO_PLACE: {
-                    if (ctx.player().movementInput.field_228350_h_ || Baritone.settings().assumeSafeWalk.value) {
+                    if (ctx.player().isCrouching() || Baritone.settings().assumeSafeWalk.value) {
                         state.setInput(Input.CLICK_RIGHT, true);
                     }
                     return state;

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -445,7 +445,7 @@ public int lengthZ() {
             BetterBlockPos pos = toBreak.get().getA();
             baritone.getLookBehavior().updateTarget(rot, true);
             MovementHelper.switchToBestToolFor(ctx, bcc.get(pos));
-            if (ctx.player().movementInput.field_228350_h_) {
+            if (ctx.player().isCrouching()) {
                 // really horrible bug where a block is visible for breaking while sneaking but not otherwise
                 // so you can't see it, it goes to place something else, sneaks, then the next tick it tries to break
                 // and is unable since it's unsneaked in the intermediary tick

File: src/main/java/baritone/cache/CachedWorld.java
Patch:
@@ -184,7 +184,9 @@ private synchronized void prune() {
             int distZ = ((region.getZ() << 9) + 256) - pruneCenter.getZ();
             double dist = Math.sqrt(distX * distX + distZ * distZ);
             if (dist > 1024) {
-                logDebug("Deleting cached region " + region.getX() + "," + region.getZ() + " from ram");
+                if (!Baritone.settings().censorCoordinates.value) {
+                    logDebug("Deleting cached region " + region.getX() + "," + region.getZ() + " from ram");
+                }
                 cachedRegions.remove(getRegionID(region.getX(), region.getZ()));
             }
         }

File: src/api/java/baritone/api/command/datatypes/RelativeGoalXZ.java
Patch:
@@ -37,7 +37,7 @@ public GoalXZ apply(IDatatypeContext ctx, BetterBlockPos origin) throws CommandE
         final IArgConsumer consumer = ctx.getConsumer();
         return new GoalXZ(
                 MathHelper.floor(consumer.getDatatypePost(RelativeCoordinate.INSTANCE, (double) origin.x)),
-                MathHelper.floor(consumer.getDatatypePost(RelativeCoordinate.INSTANCE, (double) origin.y))
+                MathHelper.floor(consumer.getDatatypePost(RelativeCoordinate.INSTANCE, (double) origin.z))
         );
     }
 

File: src/launch/java/baritone/launch/mixins/MixinGameRenderer.java
Patch:
@@ -38,9 +38,9 @@ public class MixinGameRenderer {
                     args = {"ldc=hand"}
             )
     )
-    private void renderWorldPass(float partialTicks, long finishTimeNano, MatrixStack idfk, CallbackInfo ci) {
+    private void renderWorldPass(float partialTicks, long finishTimeNano, MatrixStack matrixStack, CallbackInfo ci) {
         for (IBaritone ibaritone : BaritoneAPI.getProvider().getAllBaritones()) {
-            ibaritone.getGameEventHandler().onRenderPass(new RenderEvent(partialTicks));
+            ibaritone.getGameEventHandler().onRenderPass(new RenderEvent(partialTicks, matrixStack));
         }
     }
 }

File: src/main/java/baritone/command/defaults/SelCommand.java
Patch:
@@ -68,7 +68,7 @@ public void onRenderPass(RenderEvent event) {
                 float lineWidth = Baritone.settings().selectionLineWidth.value;
                 boolean ignoreDepth = Baritone.settings().renderSelectionIgnoreDepth.value;
                 IRenderer.startLines(color, opacity, lineWidth, ignoreDepth);
-                IRenderer.drawAABB(new AxisAlignedBB(pos1, pos1.add(1, 1, 1)));
+                IRenderer.drawAABB(event.getMatrixStack(), new AxisAlignedBB(pos1, pos1.add(1, 1, 1)));
                 IRenderer.endLines(ignoreDepth);
             }
         });

File: src/launch/java/baritone/launch/mixins/MixinGameRenderer.java
Patch:
@@ -20,6 +20,7 @@
 import baritone.api.BaritoneAPI;
 import baritone.api.IBaritone;
 import baritone.api.event.events.RenderEvent;
+import com.mojang.blaze3d.matrix.MatrixStack;
 import net.minecraft.client.renderer.GameRenderer;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
@@ -30,14 +31,14 @@
 public class MixinGameRenderer {
 
     @Inject(
-            method = "updateCameraAndRender",
+            method = "func_228378_a_",
             at = @At(
                     value = "INVOKE_STRING",
                     target = "Lnet/minecraft/profiler/IProfiler;endStartSection(Ljava/lang/String;)V",
                     args = {"ldc=hand"}
             )
     )
-    private void renderWorldPass(float partialTicks, long finishTimeNano, boolean idfk, CallbackInfo ci) {
+    private void renderWorldPass(float partialTicks, long finishTimeNano, MatrixStack idfk, CallbackInfo ci) {
         for (IBaritone ibaritone : BaritoneAPI.getProvider().getAllBaritones()) {
             ibaritone.getGameEventHandler().onRenderPass(new RenderEvent(partialTicks));
         }

File: src/launch/java/baritone/launch/mixins/MixinChatScreen.java
Patch:
@@ -45,6 +45,7 @@ public class MixinChatScreen {
 
     @Shadow
     protected TextFieldWidget inputField;
+    //FIXME
 /*
     @Shadow
     @Final

File: src/launch/java/baritone/launch/mixins/MixinMinecraft.java
Patch:
@@ -138,6 +138,7 @@ private boolean passEvents(Screen screen) {
         // allow user input is only the primary baritone
         return (BaritoneAPI.getProvider().getPrimaryBaritone().getPathingBehavior().getCurrent() != null && player != null) || screen.passEvents;
     }
+    //FIXME stupid LVT
 /*
     @Inject(
             method = "rightClickMouse",

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -286,7 +286,6 @@ public MovementState updateState(MovementState state) {
             }
             switch (p) {
                 case READY_TO_PLACE: {
-
                     if (ctx.player().movementInput.field_228350_h_ || Baritone.settings().assumeSafeWalk.value) {
                         state.setInput(Input.CLICK_RIGHT, true);
                     }

File: src/main/java/baritone/utils/GuiClick.java
Patch:
@@ -61,7 +61,7 @@ public boolean isPauseScreen() {
     public void render(int mouseX, int mouseY, float partialTicks) {
         double mx = mc.mouseHelper.getMouseX();
         double my = mc.mouseHelper.getMouseY();
-
+//FIXME this entire class
         /*my = mc.mainWindow.getHeight() - my;
         my *= mc.mainWindow.getFramebufferHeight() / (double) mc.mainWindow.getHeight();
         mx *= mc.mainWindow.getFramebufferWidth() / (double) mc.mainWindow.getWidth();
@@ -110,6 +110,7 @@ public boolean mouseClicked(double mouseX, double mouseY, int mouseButton) {
     }
 
     public void onRender() {
+        //FIXME
         /*GlStateManager.getMatrix(GL_MODELVIEW_MATRIX, (FloatBuffer) MODELVIEW.clear());
         GlStateManager.getMatrix(GL_PROJECTION_MATRIX, (FloatBuffer) PROJECTION.clear());
         GL11.glGetIntegerv(GL_VIEWPORT, (IntBuffer) VIEWPORT.clear());

File: src/main/java/baritone/utils/IRenderer.java
Patch:
@@ -21,15 +21,14 @@
 import baritone.api.Settings;
 import baritone.api.utils.Helper;
 import baritone.utils.accessor.IEntityRenderManager;
-import com.mojang.blaze3d.platform.GlStateManager;
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.Tessellator;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.util.math.AxisAlignedBB;
 
 import java.awt.*;
 
-import static org.lwjgl.opengl.GL11.*;
+import static org.lwjgl.opengl.GL11.GL_LINES;
 
 public interface IRenderer {
 
@@ -38,6 +37,7 @@ public interface IRenderer {
     IEntityRenderManager renderManager = (IEntityRenderManager) Helper.mc.getRenderManager();
     Settings settings = BaritoneAPI.getSettings();
 
+    //FIXME this entire class
     static void glColor(Color color, float alpha) {
         float[] colorComponents = color.getColorComponents(null);
         //GlStateManager.color4f(colorComponents[0], colorComponents[1], colorComponents[2], alpha);

File: src/main/java/baritone/utils/PathRenderer.java
Patch:
@@ -26,9 +26,7 @@
 import baritone.api.utils.interfaces.IGoalRenderPos;
 import baritone.behavior.PathingBehavior;
 import baritone.pathing.path.PathExecutor;
-import com.mojang.blaze3d.platform.GlStateManager;
 import net.minecraft.block.BlockState;
-import net.minecraft.client.renderer.tileentity.BeaconTileEntityRenderer;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.entity.Entity;
 import net.minecraft.util.ResourceLocation;
@@ -247,9 +245,10 @@ public static void drawDankLitGoalBox(Entity player, Goal goal, float partialTic
 
                 Helper.mc.getTextureManager().bindTexture(TEXTURE_BEACON_BEAM);
                 if (settings.renderGoalIgnoreDepth.value) {
+                    // FIXME
                     //GlStateManager.disableDepthTest();
                 }
-
+//FIXME
                /* BeaconTileEntityRenderer.renderBeamSegment(
                         goalPos.getX() - renderPosX,
                         -renderPosY,
@@ -267,6 +266,7 @@ public static void drawDankLitGoalBox(Entity player, Goal goal, float partialTic
                 );*/
 
                 if (settings.renderGoalIgnoreDepth.value) {
+                    //FIXME
                     //GlStateManager.enableDepthTest();
                 }
 

File: src/api/java/baritone/api/utils/BlockOptionalMeta.java
Patch:
@@ -20,7 +20,8 @@
 import baritone.api.utils.accessor.IItemStack;
 import com.google.common.collect.ImmutableSet;
 import io.netty.util.concurrent.ThreadPerTaskExecutor;
-import net.minecraft.block.*;
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockState;
 import net.minecraft.item.Item;
 import net.minecraft.item.ItemStack;
 import net.minecraft.resources.*;
@@ -143,7 +144,7 @@ public static LootTableManager getManager() {
             rpl.reloadPacksFromFinders();
             IResourcePack thePack = ((ResourcePackInfo) rpl.getAllPacks().iterator().next()).getResourcePack();
             IReloadableResourceManager resourceManager = new SimpleReloadableResourceManager(ResourcePackType.SERVER_DATA, null);
-            manager = new LootTableManager();
+            manager = new LootTableManager(new LootPredicateManager());
             resourceManager.addReloadListener(manager);
             try {
                 resourceManager.reloadResourcesAndThen(new ThreadPerTaskExecutor(Thread::new), new ThreadPerTaskExecutor(Thread::new), Collections.singletonList(thePack), CompletableFuture.completedFuture(Unit.INSTANCE)).get();

File: src/api/java/baritone/api/utils/IPlayerContext.java
Patch:
@@ -56,7 +56,7 @@ default Stream<Entity> entitiesStream() {
 
     default BetterBlockPos playerFeet() {
         // TODO find a better way to deal with soul sand!!!!!
-        BetterBlockPos feet = new BetterBlockPos(player().posX, player().posY + 0.1251, player().posZ);
+        BetterBlockPos feet = new BetterBlockPos(player().getPositionVec().x, player().getPositionVec().y + 0.1251, player().getPositionVec().z);
 
         // sometimes when calling this from another thread or while world is null, it'll throw a NullPointerException
         // that causes the game to immediately crash
@@ -76,11 +76,11 @@ default BetterBlockPos playerFeet() {
     }
 
     default Vec3d playerFeetAsVec() {
-        return new Vec3d(player().posX, player().posY, player().posZ);
+        return new Vec3d(player().getPositionVec().x, player().getPositionVec().y, player().getPositionVec().z);
     }
 
     default Vec3d playerHead() {
-        return new Vec3d(player().posX, player().posY + player().getEyeHeight(), player().posZ);
+        return new Vec3d(player().getPositionVec().x, player().getPositionVec().y + player().getEyeHeight(), player().getPositionVec().z);
     }
 
     default Rotation playerRotations() {

File: src/api/java/baritone/api/utils/VecUtils.java
Patch:
@@ -105,7 +105,7 @@ public static double distanceToCenter(BlockPos pos, double x, double y, double z
      * @see #getBlockPosCenter(BlockPos)
      */
     public static double entityDistanceToCenter(Entity entity, BlockPos pos) {
-        return distanceToCenter(pos, entity.posX, entity.posY, entity.posZ);
+        return distanceToCenter(pos, entity.getPositionVec().x, entity.getPositionVec().y, entity.getPositionVec().z);
     }
 
     /**
@@ -118,6 +118,6 @@ public static double entityDistanceToCenter(Entity entity, BlockPos pos) {
      * @see #getBlockPosCenter(BlockPos)
      */
     public static double entityFlatDistanceToCenter(Entity entity, BlockPos pos) {
-        return distanceToCenter(pos, entity.posX, pos.getY() + 0.5, entity.posZ);
+        return distanceToCenter(pos, entity.getPositionVec().x, pos.getY() + 0.5, entity.getPositionVec().z);
     }
 }

File: src/launch/java/baritone/launch/mixins/MixinChatScreen.java
Patch:
@@ -45,7 +45,7 @@ public class MixinChatScreen {
 
     @Shadow
     protected TextFieldWidget inputField;
-
+/*
     @Shadow
     @Final
     protected List<String> commandUsage;
@@ -95,5 +95,5 @@ private void preUpdateSuggestion(CallbackInfo ci) {
                 this.pendingSuggestions.complete(suggestions);
             }
         }
-    }
+    }*/
 }

File: src/launch/java/baritone/launch/mixins/MixinGameRenderer.java
Patch:
@@ -30,14 +30,14 @@
 public class MixinGameRenderer {
 
     @Inject(
-            method = "updateCameraAndRender(FJ)V",
+            method = "updateCameraAndRender",
             at = @At(
                     value = "INVOKE_STRING",
                     target = "Lnet/minecraft/profiler/IProfiler;endStartSection(Ljava/lang/String;)V",
                     args = {"ldc=hand"}
             )
     )
-    private void renderWorldPass(float partialTicks, long finishTimeNano, CallbackInfo ci) {
+    private void renderWorldPass(float partialTicks, long finishTimeNano, boolean idfk, CallbackInfo ci) {
         for (IBaritone ibaritone : BaritoneAPI.getProvider().getAllBaritones()) {
             ibaritone.getGameEventHandler().onRenderPass(new RenderEvent(partialTicks));
         }

File: src/main/java/baritone/behavior/InventoryBehavior.java
Patch:
@@ -137,7 +137,7 @@ public boolean hasGenericThrowaway() {
 
     public boolean selectThrowawayForLocation(boolean select, int x, int y, int z) {
         BlockState maybe = baritone.getBuilderProcess().placeAt(x, y, z, baritone.bsi.get0(x, y, z));
-        if (maybe != null && throwaway(select, stack -> stack.getItem() instanceof BlockItem && maybe.equals(((BlockItem) stack.getItem()).getBlock().getStateForPlacement(new BlockItemUseContext(new ItemUseContext(ctx.world(), ctx.player(), Hand.MAIN_HAND, stack, new BlockRayTraceResult(new Vec3d(ctx.player().posX, ctx.player().posY, ctx.player().posZ), Direction.UP, ctx.playerFeet(), false)) {}))))) {
+        if (maybe != null && throwaway(select, stack -> stack.getItem() instanceof BlockItem && maybe.equals(((BlockItem) stack.getItem()).getBlock().getStateForPlacement(new BlockItemUseContext(new ItemUseContext(ctx.world(), ctx.player(), Hand.MAIN_HAND, stack, new BlockRayTraceResult(new Vec3d(ctx.player().getPositionVec().x, ctx.player().getPositionVec().y, ctx.player().getPositionVec().z), Direction.UP, ctx.playerFeet(), false)) {}))))) {
             return true; // gotem
         }
         if (maybe != null && throwaway(select, stack -> stack.getItem() instanceof BlockItem && ((BlockItem) stack.getItem()).getBlock().equals(maybe.getBlock()))) {

File: src/main/java/baritone/behavior/PathingBehavior.java
Patch:
@@ -381,8 +381,8 @@ public BetterBlockPos pathStart() { // TODO move to a helper or util class
         BetterBlockPos feet = ctx.playerFeet();
         if (!MovementHelper.canWalkOn(ctx, feet.down())) {
             if (ctx.player().onGround) {
-                double playerX = ctx.player().posX;
-                double playerZ = ctx.player().posZ;
+                double playerX = ctx.player().getPositionVec().x;
+                double playerZ = ctx.player().getPositionVec().z;
                 ArrayList<BetterBlockPos> closest = new ArrayList<>();
                 for (int dx = -1; dx <= 1; dx++) {
                     for (int dz = -1; dz <= 1; dz++) {

File: src/main/java/baritone/cache/ChunkPacker.java
Patch:
@@ -23,7 +23,7 @@
 import net.minecraft.block.*;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.Vec3d;
-import net.minecraft.world.chunk.BlockStateContainer;
+import net.minecraft.util.palette.PalettedContainer;
 import net.minecraft.world.chunk.Chunk;
 import net.minecraft.world.chunk.ChunkSection;
 
@@ -59,7 +59,7 @@ public static CachedChunk pack(Chunk chunk) {
                     // since a bitset is initialized to all zero, and air is saved as zeros
                     continue;
                 }
-                BlockStateContainer<BlockState> bsc = extendedblockstorage.getData();
+                PalettedContainer<BlockState> bsc = extendedblockstorage.getData();
                 int yReal = y0 << 4;
                 // the mapping of BlockStateContainer.getIndex from xyz to index is y << 8 | z << 4 | x;
                 // for better cache locality, iterate in that order

File: src/main/java/baritone/cache/WorldScanner.java
Patch:
@@ -22,15 +22,14 @@
 import baritone.api.utils.BetterBlockPos;
 import baritone.api.utils.BlockOptionalMetaLookup;
 import baritone.api.utils.IPlayerContext;
-import baritone.utils.accessor.IBlockStateContainer;
+import baritone.utils.accessor.IPalettedContainer;
 import net.minecraft.block.BlockState;
 import net.minecraft.client.multiplayer.ClientChunkProvider;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.ChunkPos;
 import net.minecraft.world.chunk.AbstractChunkProvider;
 import net.minecraft.world.chunk.Chunk;
 import net.minecraft.world.chunk.ChunkSection;
-import net.minecraft.world.chunk.IChunk;
 
 import java.util.*;
 import java.util.stream.IntStream;
@@ -156,7 +155,7 @@ private boolean scanChunkInto(int chunkX, int chunkZ, Chunk chunk, BlockOptional
                 continue;
             }
             int yReal = y0 << 4;
-            IBlockStateContainer bsc = (IBlockStateContainer) section.getData();
+            IPalettedContainer bsc = (IPalettedContainer) section.getData();
             // storageArray uses an optimized algorithm that's faster than getAt
             // creating this array and then using getAtPalette is faster than even getFast(int index)
             int[] storage = bsc.storageArray();

File: src/main/java/baritone/pathing/movement/movements/MovementAscend.java
Patch:
@@ -176,7 +176,7 @@ public MovementState updateState(MovementState state) {
             ticksWithoutPlacement++;
             if (MovementHelper.attemptToPlaceABlock(state, baritone, dest.down(), false) == PlaceResult.READY_TO_PLACE) {
                 state.setInput(Input.SNEAK, true);
-                if (ctx.player().isSneaking()) {
+                if (ctx.player().movementInput.field_228350_h_) {
                     state.setInput(Input.CLICK_RIGHT, true);
                 }
             }
@@ -199,8 +199,8 @@ public MovementState updateState(MovementState state) {
 
         int xAxis = Math.abs(src.getX() - dest.getX()); // either 0 or 1
         int zAxis = Math.abs(src.getZ() - dest.getZ()); // either 0 or 1
-        double flatDistToNext = xAxis * Math.abs((dest.getX() + 0.5D) - ctx.player().posX) + zAxis * Math.abs((dest.getZ() + 0.5D) - ctx.player().posZ);
-        double sideDist = zAxis * Math.abs((dest.getX() + 0.5D) - ctx.player().posX) + xAxis * Math.abs((dest.getZ() + 0.5D) - ctx.player().posZ);
+        double flatDistToNext = xAxis * Math.abs((dest.getX() + 0.5D) - ctx.player().getPositionVec().x) + zAxis * Math.abs((dest.getZ() + 0.5D) - ctx.player().getPositionVec().z);
+        double sideDist = zAxis * Math.abs((dest.getX() + 0.5D) - ctx.player().getPositionVec().x) + xAxis * Math.abs((dest.getZ() + 0.5D) - ctx.player().getPositionVec().z);
 
         double lateralMotion = xAxis * ctx.player().getMotion().z + zAxis * ctx.player().getMotion().x;
         if (Math.abs(lateralMotion) > 0.1) {

File: src/main/java/baritone/pathing/movement/movements/MovementDiagonal.java
Patch:
@@ -226,7 +226,7 @@ public MovementState updateState(MovementState state) {
         } else if (!playerInValidPosition() && !(MovementHelper.isLiquid(ctx, src) && getValidPositions().contains(ctx.playerFeet().up()))) {
             return state.setStatus(MovementStatus.UNREACHABLE);
         }
-        if (dest.y > src.y && ctx.player().posY < src.y + 0.1 && ctx.player().collidedHorizontally) {
+        if (dest.y > src.y && ctx.player().getPositionVec().y < src.y + 0.1 && ctx.player().collidedHorizontally) {
             state.setInput(Input.JUMP, true);
         }
         if (sprint()) {

File: src/main/java/baritone/pathing/movement/movements/MovementDownward.java
Patch:
@@ -84,8 +84,8 @@ public MovementState updateState(MovementState state) {
         } else if (!playerInValidPosition()) {
             return state.setStatus(MovementStatus.UNREACHABLE);
         }
-        double diffX = ctx.player().posX - (dest.getX() + 0.5);
-        double diffZ = ctx.player().posZ - (dest.getZ() + 0.5);
+        double diffX = ctx.player().getPositionVec().x - (dest.getX() + 0.5);
+        double diffZ = ctx.player().getPositionVec().z - (dest.getZ() + 0.5);
         double ab = Math.sqrt(diffX * diffX + diffZ * diffZ);
 
         if (numTicks++ < 10 && ab < 0.2) {

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -414,7 +414,7 @@ private boolean shouldSprintNextTick() {
                 // playerFeet adds 0.1251 to account for soul sand
                 // farmland is 0.9375
                 // 0.07 is to account for farmland
-                if (ctx.player().posY >= center.getY() - 0.07) {
+                if (ctx.player().getPositionVec().y >= center.getY() - 0.07) {
                     behavior.baritone.getInputOverrideHandler().setInputForceState(Input.JUMP, false);
                     return true;
                 }
@@ -485,7 +485,7 @@ private Tuple<Vec3d, BlockPos> overrideFall(MovementFall movement) {
     }
 
     private static boolean skipNow(IPlayerContext ctx, IMovement current) {
-        double offTarget = Math.abs(current.getDirection().getX() * (current.getSrc().z + 0.5D - ctx.player().posZ)) + Math.abs(current.getDirection().getZ() * (current.getSrc().x + 0.5D - ctx.player().posX));
+        double offTarget = Math.abs(current.getDirection().getX() * (current.getSrc().z + 0.5D - ctx.player().getPositionVec().z)) + Math.abs(current.getDirection().getZ() * (current.getSrc().x + 0.5D - ctx.player().getPositionVec().x));
         if (offTarget > 0.1) {
             return false;
         }
@@ -495,7 +495,7 @@ private static boolean skipNow(IPlayerContext ctx, IMovement current) {
             return true;
         }
         // wait 0.3
-        double flatDist = Math.abs(current.getDirection().getX() * (headBonk.getX() + 0.5D - ctx.player().posX)) + Math.abs(current.getDirection().getZ() * (headBonk.getZ() + 0.5 - ctx.player().posZ));
+        double flatDist = Math.abs(current.getDirection().getX() * (headBonk.getX() + 0.5D - ctx.player().getPositionVec().x)) + Math.abs(current.getDirection().getZ() * (headBonk.getZ() + 0.5 - ctx.player().getPositionVec().z));
         return flatDist > 0.8;
     }
 

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -445,7 +445,7 @@ public int lengthZ() {
             BetterBlockPos pos = toBreak.get().getA();
             baritone.getLookBehavior().updateTarget(rot, true);
             MovementHelper.switchToBestToolFor(ctx, bcc.get(pos));
-            if (ctx.player().isSneaking()) {
+            if (ctx.player().movementInput.field_228350_h_) {
                 // really horrible bug where a block is visible for breaking while sneaking but not otherwise
                 // so you can't see it, it goes to place something else, sneaks, then the next tick it tries to break
                 // and is unable since it's unsneaked in the intermediary tick
@@ -781,7 +781,7 @@ private List<BlockState> approxPlaceable(int size) {
                 continue;
             }
             // <toxic cloud>
-            result.add(((BlockItem) stack.getItem()).getBlock().getStateForPlacement(new BlockItemUseContext(new ItemUseContext(ctx.world(), ctx.player(), Hand.MAIN_HAND, stack, new BlockRayTraceResult(new Vec3d(ctx.player().posX, ctx.player().posY, ctx.player().posZ), Direction.UP, ctx.playerFeet(), false)) {})));
+            result.add(((BlockItem) stack.getItem()).getBlock().getStateForPlacement(new BlockItemUseContext(new ItemUseContext(ctx.world(), ctx.player(), Hand.MAIN_HAND, stack, new BlockRayTraceResult(new Vec3d(ctx.player().getPositionVec().x, ctx.player().getPositionVec().y, ctx.player().getPositionVec().z), Direction.UP, ctx.playerFeet(), false)) {})));
             // </toxic cloud>
         }
         return result;

File: src/main/java/baritone/process/FarmProcess.java
Patch:
@@ -282,7 +282,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
                 ItemEntity ei = (ItemEntity) entity;
                 if (PICKUP_DROPPED.contains(ei.getItem().getItem())) {
                     // +0.1 because of farmland's 0.9375 dummy height lol
-                    goalz.add(new GoalBlock(new BlockPos(entity.posX, entity.posY + 0.1, entity.posZ)));
+                    goalz.add(new GoalBlock(new BlockPos(entity.getPositionVec().x, entity.getPositionVec().y + 0.1, entity.getPositionVec().z)));
                 }
             }
         }

File: src/main/java/baritone/process/FollowProcess.java
Patch:
@@ -60,7 +60,7 @@ private Goal towards(Entity following) {
             pos = new BlockPos(following);
         } else {
             GoalXZ g = GoalXZ.fromDirection(following.getPositionVector(), Baritone.settings().followOffsetDirection.value, Baritone.settings().followOffsetDistance.value);
-            pos = new BlockPos(g.getX(), following.posY, g.getZ());
+            pos = new BlockPos(g.getX(), following.getPositionVec().y, g.getZ());
         }
         return new GoalNear(pos, Baritone.settings().followRadius.value);
     }

File: src/main/java/baritone/utils/BlockStateInterface.java
Patch:
@@ -44,7 +44,7 @@ public class BlockStateInterface {
     private final ClientChunkProvider provider;
     private final WorldData worldData;
     protected final IBlockReader world;
-    public final BlockPos.MutableBlockPos isPassableBlockPos;
+    public final BlockPos.Mutable isPassableBlockPos;
     public final IBlockReader access;
 
     private Chunk prev = null;
@@ -74,7 +74,7 @@ public BlockStateInterface(World world, WorldData worldData, boolean copyLoadedC
         if (!Minecraft.getInstance().isOnExecutionThread()) {
             throw new IllegalStateException();
         }
-        this.isPassableBlockPos = new BlockPos.MutableBlockPos();
+        this.isPassableBlockPos = new BlockPos.Mutable();
         this.access = new BlockStateInterfaceAccessWrapper(this);
     }
 

File: src/main/java/baritone/utils/PlayerMovementInput.java
Patch:
@@ -29,7 +29,7 @@ public class PlayerMovementInput extends MovementInput {
     }
 
     @Override
-    public void tick(boolean p_217607_1_, boolean p_217607_2_) {
+    public void func_225607_a_(boolean p_225607_1_) {
         this.moveStrafe = 0.0F;
         this.moveForward = 0.0F;
 
@@ -51,7 +51,7 @@ public void tick(boolean p_217607_1_, boolean p_217607_2_) {
             this.moveStrafe--;
         }
 
-        if (this.sneak = handler.isInputForcedDown(Input.SNEAK)) {
+        if (this.field_228350_h_ = handler.isInputForcedDown(Input.SNEAK)) {
             this.moveStrafe *= 0.3D;
             this.moveForward *= 0.3D;
         }

File: src/main/java/baritone/utils/accessor/IPalettedContainer.java
Patch:
@@ -19,7 +19,7 @@
 
 import net.minecraft.block.BlockState;
 
-public interface IBlockStateContainer {
+public interface IPalettedContainer {
 
     BlockState getAtPalette(int index);
 

File: src/main/java/baritone/utils/schematic/format/defaults/MCEditSchematic.java
Patch:
@@ -70,4 +70,4 @@ public MCEditSchematic(CompoundNBT schematic) {
             }
         }
     }
-}
\ No newline at end of file
+}

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -39,6 +39,7 @@
 import baritone.utils.BlockStateInterface;
 import baritone.utils.PathingCommandContext;
 import baritone.utils.schematic.MapArtSchematic;
+import baritone.utils.schematic.StaticSchematic;
 import baritone.utils.schematic.format.SchematicFormat;
 import baritone.utils.schematic.schematica.SchematicaHelper;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
@@ -129,7 +130,7 @@ public boolean build(String name, File schematic, Vec3i origin) {
         }
 
         if (Baritone.settings().mapArtMode.value) {
-            parsed = new MapArtSchematic(parsed);
+            parsed = new MapArtSchematic((StaticSchematic) parsed);
         }
 
         build(name, parsed, origin);

File: src/main/java/baritone/utils/schematic/parse/ISchematicParser.java
Patch:
@@ -17,7 +17,7 @@
 
 package baritone.utils.schematic.parse;
 
-import baritone.api.schematic.ISchematic;
+import baritone.utils.schematic.StaticSchematic;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -28,5 +28,5 @@
  */
 public interface ISchematicParser {
 
-    ISchematic parse(InputStream input) throws IOException;
+    StaticSchematic parse(InputStream input) throws IOException;
 }

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -114,7 +114,7 @@ public static void cost(CalculationContext context, int x, int y, int z, EnumFac
                 return;
             }
             IBlockState destInto = context.bsi.get0(destX, y, destZ);
-            if (!MovementHelper.fullyPassable(destInto)) {
+            if (!MovementHelper.fullyPassable(context.bsi.access, context.bsi.isPassableBlockPos.setPos(destX, y, destZ), destInto)) {
                 if (i <= 3 && context.allowParkourAscend && context.canSprint && MovementHelper.canWalkOn(context.bsi, destX, y, destZ, destInto) && checkOvershootSafety(context.bsi, destX + xDiff, y + 1, destZ + zDiff)) {
                     res.x = destX;
                     res.y = y + 1;

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -466,7 +466,7 @@ private Tuple<Vec3d, BlockPos> overrideFall(MovementFall movement) {
             }
             for (int y = next.getDest().y; y <= movement.getSrc().y + 1; y++) {
                 BlockPos chk = new BlockPos(next.getDest().x, y, next.getDest().z);
-                if (!MovementHelper.fullyPassable(ctx.world().getBlockState(chk))) {
+                if (!MovementHelper.fullyPassable(ctx, chk)) {
                     break outer;
                 }
             }
@@ -491,7 +491,7 @@ private static boolean skipNow(IPlayerContext ctx, IMovement current) {
         }
         // we are centered
         BlockPos headBonk = current.getSrc().subtract(current.getDirection()).up(2);
-        if (MovementHelper.fullyPassable(ctx.world().getBlockState(headBonk))) {
+        if (MovementHelper.fullyPassable(ctx, headBonk)) {
             return true;
         }
         // wait 0.3
@@ -524,7 +524,7 @@ private static boolean sprintableAscend(IPlayerContext ctx, MovementTraverse cur
                 if (x == 1) {
                     chk = chk.add(current.getDirection());
                 }
-                if (!MovementHelper.fullyPassable(ctx.world().getBlockState(chk))) {
+                if (!MovementHelper.fullyPassable(ctx, chk)) {
                     return false;
                 }
             }

File: src/api/java/baritone/api/command/exception/CommandInvalidTypeException.java
Patch:
@@ -26,14 +26,14 @@ public CommandInvalidTypeException(ICommandArgument arg, String expected) {
     }
 
     public CommandInvalidTypeException(ICommandArgument arg, String expected, Throwable cause) {
-        super(arg, String.format("Expected %s.\nMore details: %s", expected, cause.getMessage()));
+        super(arg, String.format("Expected %s", expected), cause);
     }
 
     public CommandInvalidTypeException(ICommandArgument arg, String expected, String got) {
         super(arg, String.format("Expected %s, but got %s instead", expected, got));
     }
 
     public CommandInvalidTypeException(ICommandArgument arg, String expected, String got, Throwable cause) {
-        super(arg, String.format("Expected %s, but got %s instead.\nMore details: %s", expected, got, cause.getMessage()));
+        super(arg, String.format("Expected %s, but got %s instead", expected, got), cause);
     }
 }

File: src/api/java/baritone/api/command/exception/CommandUnhandledException.java
Patch:
@@ -37,7 +37,7 @@ public CommandUnhandledException(Throwable cause) {
 
     @Override
     public void handle(ICommand command, List<ICommandArgument> args) {
-        HELPER.logDirect("An unhandled exception occurred." +
+        HELPER.logDirect("An unhandled exception occurred. " +
                 "The error is in your game's log, please report this at https://github.com/cabaletta/baritone/issues",
                 TextFormatting.RED);
 

File: src/main/java/baritone/command/argument/ArgConsumer.java
Patch:
@@ -316,8 +316,7 @@ public <T, O, D extends IDatatypePost<T, O>> T getDatatypePost(D datatype, O ori
         try {
             return datatype.apply(this.context, original);
         } catch (Exception e) {
-            e.printStackTrace();
-            throw new CommandInvalidTypeException(hasAny() ? peek() : consumed(), datatype.getClass().getSimpleName());
+            throw new CommandInvalidTypeException(hasAny() ? peek() : consumed(), datatype.getClass().getSimpleName(), e);
         }
     }
 
@@ -346,7 +345,7 @@ public <T, D extends IDatatypeFor<T>> T getDatatypeFor(D datatype) throws Comman
         try {
             return datatype.get(this.context);
         } catch (Exception e) {
-            throw new CommandInvalidTypeException(hasAny() ? peek() : consumed(), datatype.getClass().getSimpleName());
+            throw new CommandInvalidTypeException(hasAny() ? peek() : consumed(), datatype.getClass().getSimpleName(), e);
         }
     }
 

File: src/api/java/baritone/api/command/exception/CommandUnhandledException.java
Patch:
@@ -37,7 +37,7 @@ public CommandUnhandledException(Throwable cause) {
 
     @Override
     public void handle(ICommand command, List<ICommandArgument> args) {
-        HELPER.logDirect("An unhandled exception occurred." +
+        HELPER.logDirect("An unhandled exception occurred. " +
                 "The error is in your game's log, please report this at https://github.com/cabaletta/baritone/issues",
                 TextFormatting.RED);
 

File: src/api/java/baritone/api/command/exception/CommandInvalidTypeException.java
Patch:
@@ -26,14 +26,14 @@ public CommandInvalidTypeException(ICommandArgument arg, String expected) {
     }
 
     public CommandInvalidTypeException(ICommandArgument arg, String expected, Throwable cause) {
-        super(arg, String.format("Expected %s.\nMore details: %s", expected, cause.getMessage()));
+        super(arg, String.format("Expected %s", expected), cause);
     }
 
     public CommandInvalidTypeException(ICommandArgument arg, String expected, String got) {
         super(arg, String.format("Expected %s, but got %s instead", expected, got));
     }
 
     public CommandInvalidTypeException(ICommandArgument arg, String expected, String got, Throwable cause) {
-        super(arg, String.format("Expected %s, but got %s instead.\nMore details: %s", expected, got, cause.getMessage()));
+        super(arg, String.format("Expected %s, but got %s instead", expected, got), cause);
     }
 }

File: src/main/java/baritone/command/argument/ArgConsumer.java
Patch:
@@ -316,8 +316,7 @@ public <T, O, D extends IDatatypePost<T, O>> T getDatatypePost(D datatype, O ori
         try {
             return datatype.apply(this.context, original);
         } catch (Exception e) {
-            e.printStackTrace();
-            throw new CommandInvalidTypeException(hasAny() ? peek() : consumed(), datatype.getClass().getSimpleName());
+            throw new CommandInvalidTypeException(hasAny() ? peek() : consumed(), datatype.getClass().getSimpleName(), e);
         }
     }
 
@@ -346,7 +345,7 @@ public <T, D extends IDatatypeFor<T>> T getDatatypeFor(D datatype) throws Comman
         try {
             return datatype.get(this.context);
         } catch (Exception e) {
-            throw new CommandInvalidTypeException(hasAny() ? peek() : consumed(), datatype.getClass().getSimpleName());
+            throw new CommandInvalidTypeException(hasAny() ? peek() : consumed(), datatype.getClass().getSimpleName(), e);
         }
     }
 

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -466,7 +466,7 @@ private Tuple<Vec3d, BlockPos> overrideFall(MovementFall movement) {
             }
             for (int y = next.getDest().y; y <= movement.getSrc().y + 1; y++) {
                 BlockPos chk = new BlockPos(next.getDest().x, y, next.getDest().z);
-                if (!MovementHelper.fullyPassable(ctx.world().getBlockState(chk))) {
+                if (!MovementHelper.fullyPassable(ctx, chk)) {
                     break outer;
                 }
             }
@@ -491,7 +491,7 @@ private static boolean skipNow(IPlayerContext ctx, IMovement current) {
         }
         // we are centered
         BlockPos headBonk = current.getSrc().subtract(current.getDirection()).up(2);
-        if (MovementHelper.fullyPassable(ctx.world().getBlockState(headBonk))) {
+        if (MovementHelper.fullyPassable(ctx, headBonk)) {
             return true;
         }
         // wait 0.3
@@ -524,7 +524,7 @@ private static boolean sprintableAscend(IPlayerContext ctx, MovementTraverse cur
                 if (x == 1) {
                     chk = chk.add(current.getDirection());
                 }
-                if (!MovementHelper.fullyPassable(ctx.world().getBlockState(chk))) {
+                if (!MovementHelper.fullyPassable(ctx, chk)) {
                     return false;
                 }
             }

File: src/launch/java/baritone/launch/mixins/MixinGuiChat.java
Patch:
@@ -79,7 +79,7 @@ private void preUpdateSuggestion(CallbackInfo ci) {
             if (event.completions.length == 0) {
                 this.pendingSuggestions = Suggestions.empty();
             } else {
-                int offset = this.inputField.getCursorPosition();
+                int offset = this.inputField.getText().endsWith(" ") ? this.inputField.getCursorPosition() : 0;
 
                 List<Suggestion> suggestionList = Stream.of(event.completions)
                         .map(s -> new Suggestion(StringRange.between(offset, offset + s.length()), s))

File: src/api/java/baritone/api/IBaritoneProvider.java
Patch:
@@ -18,7 +18,7 @@
 package baritone.api;
 
 import baritone.api.cache.IWorldScanner;
-import baritone.api.command.Command;
+import baritone.api.command.ICommand;
 import baritone.api.command.ICommandSystem;
 import net.minecraft.client.entity.EntityPlayerSP;
 
@@ -77,7 +77,7 @@ default IBaritone getBaritoneForPlayer(EntityPlayerSP player) {
 
     /**
      * Returns the {@link ICommandSystem} instance. This is not bound to a specific {@link IBaritone}
-     * instance because {@link ICommandSystem} itself controls global behavior for {@link Command}s.
+     * instance because {@link ICommandSystem} itself controls global behavior for {@link ICommand}s.
      *
      * @return The {@link ICommandSystem} instance.
      */

File: src/api/java/baritone/api/command/argument/IArgConsumer.java
Patch:
@@ -17,7 +17,7 @@
 
 package baritone.api.command.argument;
 
-import baritone.api.command.Command;
+import baritone.api.command.ICommand;
 import baritone.api.command.exception.CommandTooManyArgumentsException;
 import baritone.api.utils.Helper;
 import baritone.api.command.argparser.IArgParser;
@@ -34,7 +34,7 @@
 import java.util.stream.Stream;
 
 /**
- * The {@link IArgConsumer} is how {@link Command}s read the arguments passed to them. This class has many benefits:
+ * The {@link IArgConsumer} is how {@link ICommand}s read the arguments passed to them. This class has many benefits:
  *
  * <ul>
  * <li>Mutability. The whole concept of the {@link IArgConsumer}} is to let you gradually consume arguments in any way

File: src/api/java/baritone/api/command/exception/CommandNotFoundException.java
Patch:
@@ -17,7 +17,7 @@
 
 package baritone.api.command.exception;
 
-import baritone.api.command.Command;
+import baritone.api.command.ICommand;
 import baritone.api.command.argument.ICommandArgument;
 
 import java.util.List;
@@ -34,7 +34,7 @@ public CommandNotFoundException(String command) {
     }
 
     @Override
-    public void handle(Command command, List<ICommandArgument> args) {
+    public void handle(ICommand command, List<ICommandArgument> args) {
         HELPER.logDirect(getMessage());
     }
 }

File: src/api/java/baritone/api/command/exception/CommandUnhandledException.java
Patch:
@@ -17,7 +17,7 @@
 
 package baritone.api.command.exception;
 
-import baritone.api.command.Command;
+import baritone.api.command.ICommand;
 import baritone.api.command.argument.ICommandArgument;
 import net.minecraft.util.text.TextFormatting;
 
@@ -36,7 +36,7 @@ public CommandUnhandledException(Throwable cause) {
     }
 
     @Override
-    public void handle(Command command, List<ICommandArgument> args) {
+    public void handle(ICommand command, List<ICommandArgument> args) {
         HELPER.logDirect("An unhandled exception occurred." +
                 "The error is in your game's log, please report this at https://github.com/cabaletta/baritone/issues",
                 TextFormatting.RED);

File: src/api/java/baritone/api/command/exception/ICommandException.java
Patch:
@@ -17,7 +17,7 @@
 
 package baritone.api.command.exception;
 
-import baritone.api.command.Command;
+import baritone.api.command.ICommand;
 import baritone.api.command.argument.ICommandArgument;
 import net.minecraft.util.text.TextFormatting;
 
@@ -27,7 +27,7 @@
 
 /**
  * The base for a Baritone Command Exception, checked or unchecked. Provides a
- * {@link #handle(Command, List)} method that is used to provide useful output
+ * {@link #handle(ICommand, List)} method that is used to provide useful output
  * to the user for diagnosing issues that may have occurred during execution.
  * <p>
  * Anything implementing this interface should be assignable to {@link Exception}.
@@ -49,7 +49,7 @@ public interface ICommandException {
      * @param command The command that threw it.
      * @param args    The arguments the command was called with.
      */
-    default void handle(Command command, List<ICommandArgument> args) {
+    default void handle(ICommand command, List<ICommandArgument> args) {
         HELPER.logDirect(this.getMessage(), TextFormatting.RED);
     }
 }

File: src/api/java/baritone/api/command/manager/ICommandManager.java
Patch:
@@ -18,7 +18,7 @@
 package baritone.api.command.manager;
 
 import baritone.api.IBaritone;
-import baritone.api.command.Command;
+import baritone.api.command.ICommand;
 import baritone.api.command.argument.ICommandArgument;
 import baritone.api.command.registry.Registry;
 import net.minecraft.util.Tuple;
@@ -34,13 +34,13 @@ public interface ICommandManager {
 
     IBaritone getBaritone();
 
-    Registry<Command> getRegistry();
+    Registry<ICommand> getRegistry();
 
     /**
      * @param name The command name to search for.
      * @return The command, if found.
      */
-    Command getCommand(String name);
+    ICommand getCommand(String name);
 
     boolean execute(String string);
 

File: src/api/java/baritone/api/utils/Helper.java
Patch:
@@ -27,6 +27,9 @@
 import java.util.stream.Stream;
 
 /**
+ * An ease-of-access interface to provide the {@link Minecraft} game instance,
+ * chat and console logging mechanisms, and the Baritone chat prefix.
+ *
  * @author Brady
  * @since 8/1/2018
  */

File: src/main/java/baritone/command/defaults/DefaultCommands.java
Patch:
@@ -18,17 +18,17 @@
 package baritone.command.defaults;
 
 import baritone.api.IBaritone;
-import baritone.api.command.Command;
+import baritone.api.command.ICommand;
 
 import java.util.*;
 
 public final class DefaultCommands {
 
     private DefaultCommands() {}
 
-    public static List<Command> createAll(IBaritone baritone) {
+    public static List<ICommand> createAll(IBaritone baritone) {
         Objects.requireNonNull(baritone);
-        List<Command> commands = new ArrayList<>(Arrays.asList(
+        List<ICommand> commands = new ArrayList<>(Arrays.asList(
             new HelpCommand(baritone),
             new SetCommand(baritone),
             new CommandAlias(baritone, Arrays.asList("modified", "mod", "baritone", "modifiedsettings"), "List modified settings", "set modified"),

File: src/main/java/baritone/command/defaults/HelpCommand.java
Patch:
@@ -19,6 +19,7 @@
 
 import baritone.api.IBaritone;
 import baritone.api.command.Command;
+import baritone.api.command.ICommand;
 import baritone.api.command.exception.CommandException;
 import baritone.api.command.exception.CommandNotFoundException;
 import baritone.api.command.argument.IArgConsumer;
@@ -79,7 +80,7 @@ public void execute(String label, IArgConsumer args) throws CommandException {
             );
         } else {
             String commandName = args.getString().toLowerCase();
-            Command command = this.baritone.getCommandManager().getCommand(commandName);
+            ICommand command = this.baritone.getCommandManager().getCommand(commandName);
             if (command == null) {
                 throw new CommandNotFoundException(commandName);
             }

File: src/main/java/baritone/pathing/movement/CalculationContext.java
Patch:
@@ -135,7 +135,7 @@ public Block getBlock(int x, int y, int z) {
         return get(x, y, z).getBlock();
     }
 
-    public double costOfPlacingAt(int x, int y, int z) {
+    public double costOfPlacingAt(int x, int y, int z, IBlockState current) {
         if (!hasThrowaway) { // only true if allowPlace is true, see constructor
             return COST_INF;
         }
@@ -149,7 +149,7 @@ public double costOfPlacingAt(int x, int y, int z) {
         return placeBlockCost;
     }
 
-    public double breakCostMultiplierAt(int x, int y, int z) {
+    public double breakCostMultiplierAt(int x, int y, int z, IBlockState current) {
         if (!allowBreak) {
             return COST_INF;
         }

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -376,7 +376,7 @@ static double getMiningDurationTicks(CalculationContext context, int x, int y, i
             if (block instanceof BlockLiquid) {
                 return COST_INF;
             }
-            double mult = context.breakCostMultiplierAt(x, y, z);
+            double mult = context.breakCostMultiplierAt(x, y, z, state);
             if (mult >= COST_INF) {
                 return COST_INF;
             }

File: src/main/java/baritone/pathing/movement/movements/MovementAscend.java
Patch:
@@ -69,7 +69,7 @@ public static double cost(CalculationContext context, int x, int y, int z, int d
         IBlockState toPlace = context.get(destX, y, destZ);
         double additionalPlacementCost = 0;
         if (!MovementHelper.canWalkOn(context.bsi, destX, y, destZ, toPlace)) {
-            additionalPlacementCost = context.costOfPlacingAt(destX, y, destZ);
+            additionalPlacementCost = context.costOfPlacingAt(destX, y, destZ, toPlace);
             if (additionalPlacementCost >= COST_INF) {
                 return COST_INF;
             }

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -147,11 +147,11 @@ public static void cost(CalculationContext context, int x, int y, int z, EnumFac
         // time 2 pop off with that dank skynet parkour place
         int destX = x + 4 * xDiff;
         int destZ = z + 4 * zDiff;
-        double placeCost = context.costOfPlacingAt(destX, y - 1, destZ);
+        IBlockState toReplace = context.get(destX, y - 1, destZ);
+        double placeCost = context.costOfPlacingAt(destX, y - 1, destZ, toReplace);
         if (placeCost >= COST_INF) {
             return;
         }
-        IBlockState toReplace = context.get(destX, y - 1, destZ);
         if (!MovementHelper.isReplaceable(destX, y - 1, destZ, toReplace, context.bsi)) {
             return;
         }

File: src/main/java/baritone/pathing/movement/movements/MovementPillar.java
Patch:
@@ -57,7 +57,8 @@ protected Set<BetterBlockPos> calculateValidPositions() {
     }
 
     public static double cost(CalculationContext context, int x, int y, int z) {
-        Block from = context.get(x, y, z).getBlock();
+        IBlockState fromState = context.get(x, y, z);
+        Block from = fromState.getBlock();
         boolean ladder = from == Blocks.LADDER || from == Blocks.VINE;
         IBlockState fromDown = context.get(x, y - 1, z);
         if (!ladder) {
@@ -86,7 +87,7 @@ public static double cost(CalculationContext context, int x, int y, int z) {
         double placeCost = 0;
         if (!ladder) {
             // we need to place a block where we started to jump on it
-            placeCost = context.costOfPlacingAt(x, y, z);
+            placeCost = context.costOfPlacingAt(x, y, z, fromState);
             if (placeCost >= COST_INF) {
                 return COST_INF;
             }

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -117,7 +117,7 @@ public static double cost(CalculationContext context, int x, int y, int z, int d
                     // this happens when assume walk on water is true and this is a traverse in water, which isn't allowed
                     return COST_INF;
                 }
-                double placeCost = context.costOfPlacingAt(destX, y - 1, destZ);
+                double placeCost = context.costOfPlacingAt(destX, y - 1, destZ, destOn);
                 if (placeCost >= COST_INF) {
                     return COST_INF;
                 }

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -363,7 +363,7 @@ public IBlockState desiredState(int x, int y, int z, IBlockState current, List<I
 
                 @Override
                 public boolean inSchematic(int x, int y, int z, IBlockState currentState) {
-                    return ISchematic.super.inSchematic(x, y, z, currentState) && y >= minYInclusive && y <= maxYInclusive;
+                    return ISchematic.super.inSchematic(x, y, z, currentState) && y >= minYInclusive && y <= maxYInclusive && realSchematic.inSchematic(x, y, z, currentState);
                 }
 
                 @Override

File: src/main/java/baritone/utils/BlockBreakHelper.java
Patch:
@@ -63,11 +63,12 @@ public void tick(boolean isLeftClick) {
                 ctx.player().swingArm(EnumHand.MAIN_HAND);
             }
 
+            ctx.playerController().setHittingBlock(false);
+
             didBreakLastTick = true;
         } else if (didBreakLastTick) {
             stopBreakingBlock();
             didBreakLastTick = false;
         }
-        ctx.playerController().setHittingBlock(false);
     }
 }

File: src/api/java/baritone/api/utils/command/datatypes/RelativeCoordinate.java
Patch:
@@ -35,9 +35,6 @@ public Double apply(IDatatypeContext ctx, Double origin) throws CommandException
             origin = 0.0D;
         }
 
-        System.out.println(ctx.getConsumer().args);
-        new Throwable().printStackTrace();
-
         Matcher matcher = PATTERN.matcher(ctx.getConsumer().getString());
         if (!matcher.matches()) {
             throw new IllegalArgumentException("pattern doesn't match");

File: src/main/java/baritone/utils/command/manager/CommandManager.java
Patch:
@@ -43,7 +43,7 @@ public class CommandManager implements ICommandManager {
 
     public CommandManager(Baritone baritone) {
         this.baritone = baritone;
-        DefaultCommands.commands(baritone).forEach(this.registry::register);
+        DefaultCommands.createAll(baritone).forEach(this.registry::register);
     }
 
     @Override

File: src/api/java/baritone/api/process/IMineProcess.java
Patch:
@@ -21,7 +21,7 @@
 import baritone.api.utils.BlockOptionalMetaLookup;
 import net.minecraft.block.Block;
 
-import java.util.Arrays;
+import java.util.stream.Stream;
 
 /**
  * @author Brady
@@ -93,7 +93,7 @@ default void mine(BlockOptionalMeta... boms) {
      */
     default void mine(int quantity, Block... blocks) {
         mine(quantity, new BlockOptionalMetaLookup(
-                Arrays.stream(blocks)
+                Stream.of(blocks)
                         .map(BlockOptionalMeta::new)
                         .toArray(BlockOptionalMeta[]::new)
         ));

File: src/api/java/baritone/api/utils/Helper.java
Patch:
@@ -24,6 +24,7 @@
 import net.minecraft.util.text.TextFormatting;
 
 import java.util.Arrays;
+import java.util.stream.Stream;
 
 /**
  * @author Brady
@@ -88,7 +89,7 @@ default void logDirect(ITextComponent... components) {
      * @param color   The color to print that message in
      */
     default void logDirect(String message, TextFormatting color) {
-        Arrays.stream(message.split("\n")).forEach(line -> {
+        Stream.of(message.split("\n")).forEach(line -> {
             ITextComponent component = new TextComponentString(line.replace("\t", "    "));
             component.getStyle().setColor(color);
             logDirect(component);

File: src/api/java/baritone/api/utils/SettingsUtil.java
Patch:
@@ -34,14 +34,14 @@
 import java.nio.file.NoSuchFileException;
 import java.nio.file.Path;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 import java.util.Objects;
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
 import static net.minecraft.client.Minecraft.getMinecraft;
 
@@ -242,7 +242,7 @@ public Object parse(ParserContext context, String raw) {
                 Type type = ((ParameterizedType) context.getSetting().getType()).getActualTypeArguments()[0];
                 Parser parser = Parser.getParser(type);
 
-                return Arrays.stream(raw.split(","))
+                return Stream.of(raw.split(","))
                         .map(s -> parser.parse(context, s))
                         .collect(Collectors.toList());
             }
@@ -301,7 +301,7 @@ public boolean accepts(Type type) {
         }
 
         public static Parser getParser(Type type) {
-            return Arrays.stream(values())
+            return Stream.of(values())
                     .filter(parser -> parser.accepts(type))
                     .findFirst().orElse(null);
         }

File: src/api/java/baritone/api/utils/Helper.java
Patch:
@@ -37,8 +37,11 @@ public interface Helper {
     Helper HELPER = new Helper() {};
 
     static ITextComponent getPrefix() {
+        // Inner text component
         ITextComponent baritone = new TextComponentString(BaritoneAPI.getSettings().shortBaritonePrefix.value ? "B" : "Baritone");
         baritone.getStyle().setColor(TextFormatting.LIGHT_PURPLE);
+
+        // Outer brackets
         ITextComponent prefix = new TextComponentString("");
         prefix.getStyle().setColor(TextFormatting.DARK_PURPLE);
         prefix.appendText("[");

File: src/api/java/baritone/api/utils/command/argparser/ArgParserManager.java
Patch:
@@ -67,7 +67,7 @@ public static <T, S> IArgParser.Stated<T, S> getParserStated(Class<T> type, Clas
      * @param type  The type to try and parse the argument into.
      * @param arg   The argument to parse.
      * @return An instance of the specified class.
-     * @throws CommandInvalidTypeException     If the parsing failed
+     * @throws CommandInvalidTypeException If the parsing failed
      */
     public static <T> T parseStateless(Class<T> type, CommandArgument arg) throws CommandInvalidTypeException {
         IArgParser.Stateless<T> parser = getParserStateless(type);
@@ -89,7 +89,7 @@ public static <T> T parseStateless(Class<T> type, CommandArgument arg) throws Co
      * @param arg   The argument to parse.
      * @param state The state to pass to the {@link IArgParser.Stated}.
      * @return An instance of the specified class.
-     * @throws CommandInvalidTypeException     If the parsing failed
+     * @throws CommandInvalidTypeException If the parsing failed
      * @see IArgParser.Stated
      */
     public static <T, S> T parseStated(Class<T> type, Class<S> stateKlass, CommandArgument arg, S state) throws CommandInvalidTypeException {

File: src/api/java/baritone/api/utils/command/execution/CommandExecution.java
Patch:
@@ -71,7 +71,6 @@ public void execute() {
         } catch (CommandException e) {
             e.handle(command, args.args);
         } catch (Throwable t) {
-            t.printStackTrace();
             new CommandUnhandledException(t).handle(command, args.args);
         }
     }

File: src/api/java/baritone/api/utils/command/argument/CommandArgument.java
Patch:
@@ -34,7 +34,7 @@
  * A {@link CommandArgument} is an immutable object representing one command argument. It contains data on the index of
  * that argument, its value, and the rest of the string that argument was found in
  * <p>
- * You're recommended to use {@link ArgConsumer}s to handle these. Check out {@link ArgConsumer#from(String)}
+ * You're recommended to use {@link ArgConsumer}s to handle these.
  */
 public class CommandArgument {
 

File: src/api/java/baritone/api/utils/command/helpers/tabcomplete/TabCompleteHelper.java
Patch:
@@ -21,6 +21,7 @@
 import baritone.api.Settings;
 import baritone.api.event.events.TabCompleteEvent;
 import baritone.api.utils.SettingsUtil;
+import baritone.api.utils.command.datatypes.IDatatype;
 import baritone.api.utils.command.execution.CommandExecution;
 import baritone.api.utils.command.helpers.arguments.ArgConsumer;
 import baritone.api.utils.command.manager.ICommandManager;
@@ -45,7 +46,7 @@
  * {@link #filterPrefix(String)}</li>
  * <li>Get the stream using {@link #stream()}</li>
  * <li>Pass it up to whatever's calling your tab complete function (i.e.
- * {@link ICommandManager#tabComplete(CommandExecution)} or {@link ArgConsumer#tabCompleteDatatype(Class)})</li>
+ * {@link ICommandManager#tabComplete(CommandExecution)} or {@link ArgConsumer#tabCompleteDatatype(IDatatype)})</li>
  * </ul>
  * <p>
  * For advanced users: if you're intercepting {@link TabCompleteEvent}s directly, use {@link #build()} instead for an

File: src/main/java/baritone/utils/GuiClick.java
Patch:
@@ -23,7 +23,6 @@
 import baritone.api.pathing.goals.GoalTwoBlocks;
 import baritone.api.utils.BetterBlockPos;
 import baritone.api.utils.Helper;
-import baritone.utils.command.BaritoneChatControl;
 import net.minecraft.client.gui.GuiScreen;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.entity.Entity;
@@ -45,6 +44,7 @@
 import java.util.Collections;
 
 import static org.lwjgl.opengl.GL11.*;
+import static baritone.api.utils.command.IBaritoneChatControl.FORCE_COMMAND_PREFIX;
 
 public class GuiClick extends GuiScreen {
 
@@ -88,7 +88,7 @@ protected void mouseReleased(int mouseX, int mouseY, int mouseButton) {
                         .setColor(TextFormatting.WHITE)
                         .setClickEvent(new ClickEvent(
                                 ClickEvent.Action.RUN_COMMAND,
-                                BaritoneChatControl.FORCE_COMMAND_PREFIX + "help sel"
+                                FORCE_COMMAND_PREFIX + "help sel"
                         ));
                 Helper.HELPER.logDirect(component);
                 clickStart = null;

File: src/main/java/baritone/utils/command/defaults/HelpCommand.java
Patch:
@@ -35,7 +35,7 @@
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
-import static baritone.utils.command.BaritoneChatControl.FORCE_COMMAND_PREFIX;
+import static baritone.api.utils.command.IBaritoneChatControl.FORCE_COMMAND_PREFIX;
 
 public class HelpCommand extends Command {
 

File: src/main/java/baritone/utils/command/defaults/SetCommand.java
Patch:
@@ -41,7 +41,7 @@
 
 import static baritone.api.utils.SettingsUtil.settingTypeToString;
 import static baritone.api.utils.SettingsUtil.settingValueToString;
-import static baritone.utils.command.BaritoneChatControl.FORCE_COMMAND_PREFIX;
+import static baritone.api.utils.command.IBaritoneChatControl.FORCE_COMMAND_PREFIX;
 
 public class SetCommand extends Command {
 

File: src/main/java/baritone/utils/command/defaults/WaypointsCommand.java
Patch:
@@ -43,7 +43,7 @@
 import java.util.function.Function;
 import java.util.stream.Stream;
 
-import static baritone.utils.command.BaritoneChatControl.FORCE_COMMAND_PREFIX;
+import static baritone.api.utils.command.IBaritoneChatControl.FORCE_COMMAND_PREFIX;
 
 public class WaypointsCommand extends Command {
 

File: src/api/java/baritone/api/utils/BetterBlockPos.java
Patch:
@@ -35,6 +35,8 @@
  */
 public final class BetterBlockPos extends BlockPos {
 
+    public static final BetterBlockPos ORIGIN = new BetterBlockPos(0, 0, 0);
+
     public final int x;
     public final int y;
     public final int z;

File: src/api/java/baritone/api/utils/command/datatypes/IDatatypeFor.java
Patch:
@@ -17,7 +17,9 @@
 
 package baritone.api.utils.command.datatypes;
 
+import baritone.api.utils.command.exception.CommandException;
+
 public interface IDatatypeFor<T> extends IDatatype {
 
-    T get();
+    T get(IDatatypeContext ctx) throws CommandException;
 }

File: src/api/java/baritone/api/utils/command/execution/CommandExecution.java
Patch:
@@ -93,7 +93,7 @@ public static CommandExecution from(ICommandManager manager, String label, ArgCo
     }
 
     public static CommandExecution from(ICommandManager manager, Pair<String, List<CommandArgument>> pair) {
-        return from(manager, pair.first(), new ArgConsumer(pair.second()));
+        return from(manager, pair.first(), new ArgConsumer(manager, pair.second()));
     }
 
     public static CommandExecution from(ICommandManager manager, String string) {

File: src/api/java/baritone/api/utils/command/manager/ICommandManager.java
Patch:
@@ -17,6 +17,7 @@
 
 package baritone.api.utils.command.manager;
 
+import baritone.api.IBaritone;
 import baritone.api.utils.command.Command;
 import baritone.api.utils.command.argument.CommandArgument;
 import baritone.api.utils.command.execution.CommandExecution;
@@ -32,6 +33,8 @@
  */
 public interface ICommandManager {
 
+    IBaritone getBaritone();
+
     Registry<Command> getRegistry();
 
     /**

File: src/main/java/baritone/utils/command/defaults/BuildCommand.java
Patch:
@@ -44,15 +44,15 @@ public BuildCommand(IBaritone baritone) {
 
     @Override
     protected void executed(String label, ArgConsumer args) throws CommandException {
-        File file = args.getDatatypePost(RelativeFile.class, schematicsDir).getAbsoluteFile();
+        File file = args.getDatatypePost(RelativeFile.INSTANCE, schematicsDir).getAbsoluteFile();
         if (!file.getName().toLowerCase(Locale.US).endsWith(".schematic")) {
             file = new File(file.getAbsolutePath() + ".schematic");
         }
         BetterBlockPos origin = ctx.playerFeet();
         BetterBlockPos buildOrigin;
         if (args.hasAny()) {
             args.requireMax(3);
-            buildOrigin = args.getDatatype(RelativeBlockPos.class).apply(origin);
+            buildOrigin = args.getDatatypePost(RelativeBlockPos.INSTANCE, origin);
         } else {
             args.requireMax(0);
             buildOrigin = origin;
@@ -70,7 +70,7 @@ protected Stream<String> tabCompleted(String label, ArgConsumer args) throws Com
             return RelativeFile.tabComplete(args, schematicsDir);
         } else if (args.has(2)) {
             args.get();
-            return args.tabCompleteDatatype(RelativeBlockPos.class);
+            return args.tabCompleteDatatype(RelativeBlockPos.INSTANCE);
         }
         return Stream.empty();
     }

File: src/main/java/baritone/utils/command/defaults/ClearareaCommand.java
Patch:
@@ -44,7 +44,7 @@ protected void executed(String label, ArgConsumer args) throws CommandException
         BetterBlockPos pos2;
         if (args.hasAny()) {
             args.requireMax(3);
-            pos2 = args.getDatatype(RelativeBlockPos.class).apply(pos1);
+            pos2 = args.getDatatypePost(RelativeBlockPos.INSTANCE, pos1);
         } else {
             args.requireMax(0);
             Goal goal = baritone.getCustomGoalProcess().getGoal();
@@ -60,7 +60,7 @@ protected void executed(String label, ArgConsumer args) throws CommandException
 
     @Override
     protected Stream<String> tabCompleted(String label, ArgConsumer args) {
-        return args.tabCompleteDatatype(RelativeBlockPos.class);
+        return args.tabCompleteDatatype(RelativeBlockPos.INSTANCE);
     }
 
     @Override

File: src/main/java/baritone/utils/command/defaults/ExploreCommand.java
Patch:
@@ -43,7 +43,7 @@ protected void executed(String label, ArgConsumer args) throws CommandException
             args.requireMax(0);
         }
         GoalXZ goal = args.hasAny()
-                ? args.getDatatypePost(RelativeGoalXZ.class, ctx.playerFeet())
+                ? args.getDatatypePost(RelativeGoalXZ.INSTANCE, ctx.playerFeet())
                 : new GoalXZ(ctx.playerFeet());
         baritone.getExploreProcess().explore(goal.getX(), goal.getZ());
         logDirect(String.format("Exploring from %s", goal.toString()));
@@ -52,7 +52,7 @@ protected void executed(String label, ArgConsumer args) throws CommandException
     @Override
     protected Stream<String> tabCompleted(String label, ArgConsumer args) {
         if (args.hasAtMost(2)) {
-            return args.tabCompleteDatatype(RelativeGoalXZ.class);
+            return args.tabCompleteDatatype(RelativeGoalXZ.INSTANCE);
         }
         return Stream.empty();
     }

File: src/main/java/baritone/utils/command/defaults/ExploreFilterCommand.java
Patch:
@@ -42,7 +42,7 @@ public ExploreFilterCommand(IBaritone baritone) {
     @Override
     protected void executed(String label, ArgConsumer args) throws CommandException {
         args.requireMax(2);
-        File file = args.getDatatypePost(RelativeFile.class, mc.gameDir.getAbsoluteFile().getParentFile());
+        File file = args.getDatatypePost(RelativeFile.INSTANCE, mc.gameDir.getAbsoluteFile().getParentFile());
         boolean invert = false;
         if (args.hasAny()) {
             if (args.getString().equalsIgnoreCase("invert")) {

File: src/main/java/baritone/utils/command/defaults/FindCommand.java
Patch:
@@ -41,7 +41,7 @@ public FindCommand(IBaritone baritone) {
     protected void executed(String label, ArgConsumer args) throws CommandException {
         List<Block> toFind = new ArrayList<>();
         while (args.hasAny()) {
-            toFind.add(args.getDatatypeFor(BlockById.class));
+            toFind.add(args.getDatatypeFor(BlockById.INSTANCE));
         }
         BetterBlockPos origin = ctx.playerFeet();
         toFind.stream()
@@ -61,7 +61,7 @@ protected void executed(String label, ArgConsumer args) throws CommandException
 
     @Override
     protected Stream<String> tabCompleted(String label, ArgConsumer args) {
-        return args.tabCompleteDatatype(BlockById.class);
+        return args.tabCompleteDatatype(BlockById.INSTANCE);
     }
 
     @Override

File: src/main/java/baritone/utils/command/defaults/GoalCommand.java
Patch:
@@ -53,7 +53,7 @@ protected void executed(String label, ArgConsumer args) throws CommandException
         } else {
             args.requireMax(3);
             BetterBlockPos origin = baritone.getPlayerContext().playerFeet();
-            Goal goal = args.getDatatype(RelativeGoal.class).apply(origin);
+            Goal goal = args.getDatatypePost(RelativeGoal.INSTANCE, origin);
             goalProcess.setGoal(goal);
             logDirect(String.format("Goal: %s", goal.toString()));
         }
@@ -67,7 +67,7 @@ protected Stream<String> tabCompleted(String label, ArgConsumer args) throws Com
         } else {
             if (args.hasAtMost(3)) {
                 while (args.has(2)) {
-                    if (args.peekDatatypeOrNull(RelativeCoordinate.class) == null) {
+                    if (args.peekDatatypeOrNull(RelativeCoordinate.INSTANCE) == null) {
                         break;
                     }
                     args.get();

File: src/main/java/baritone/utils/command/defaults/MineCommand.java
Patch:
@@ -18,7 +18,6 @@
 package baritone.utils.command.defaults;
 
 import baritone.api.IBaritone;
-import baritone.api.Settings;
 import baritone.api.utils.BlockOptionalMeta;
 import baritone.api.utils.command.Command;
 import baritone.api.utils.command.datatypes.BlockById;
@@ -44,7 +43,7 @@ protected void executed(String label, ArgConsumer args) throws CommandException
         args.requireMin(1);
         List<BlockOptionalMeta> boms = new ArrayList<>();
         while (args.hasAny()) {
-            boms.add(args.getDatatypeFor(ForBlockOptionalMeta.class));
+            boms.add(args.getDatatypeFor(ForBlockOptionalMeta.INSTANCE));
         }
         WorldScanner.INSTANCE.repack(ctx);
         logDirect(String.format("Mining %s", boms.toString()));
@@ -53,7 +52,7 @@ protected void executed(String label, ArgConsumer args) throws CommandException
 
     @Override
     protected Stream<String> tabCompleted(String label, ArgConsumer args) {
-        return args.tabCompleteDatatype(BlockById.class);
+        return args.tabCompleteDatatype(BlockById.INSTANCE);
     }
 
     @Override

File: src/main/java/baritone/utils/command/defaults/PathCommand.java
Patch:
@@ -46,7 +46,7 @@ protected void executed(String label, ArgConsumer args) throws CommandException
         Goal goal;
         if (args.hasAny()) {
             args.requireMax(3);
-            goal = args.getDatatype(RelativeGoal.class).apply(ctx.playerFeet());
+            goal = args.getDatatypePost(RelativeGoal.INSTANCE, ctx.playerFeet());
         } else if ((goal = customGoalProcess.getGoal()) == null) {
             throw new CommandInvalidStateException("No goal");
         }
@@ -60,7 +60,7 @@ protected void executed(String label, ArgConsumer args) throws CommandException
     protected Stream<String> tabCompleted(String label, ArgConsumer args) throws CommandException {
         if (args.hasAny() && !args.has(4)) {
             while (args.has(2)) {
-                if (args.peekDatatypeOrNull(RelativeCoordinate.class) == null) {
+                if (args.peekDatatypeOrNull(RelativeCoordinate.INSTANCE) == null) {
                     break;
                 }
                 args.get();

File: src/api/java/baritone/api/utils/command/BaritoneChatControl.java
Patch:
@@ -194,9 +194,9 @@ public Stream<String> tabComplete(String msg) {
                     if (setting.getValueClass() == Boolean.class) {
                         TabCompleteHelper helper = new TabCompleteHelper();
                         if ((Boolean) setting.value) {
-                            helper.append(Stream.of("true", "false"));
+                            helper.append("true", "false");
                         } else {
-                            helper.append(Stream.of("false", "true"));
+                            helper.append("false", "true");
                         }
                         return helper.filterPrefix(argc.getString()).stream();
                     } else {

File: src/main/java/baritone/utils/command/defaults/GoalCommand.java
Patch:
@@ -63,7 +63,7 @@ protected void executed(String label, ArgConsumer args) throws CommandException
     protected Stream<String> tabCompleted(String label, ArgConsumer args) throws CommandException {
         TabCompleteHelper helper = new TabCompleteHelper();
         if (args.hasExactlyOne()) {
-            helper.append(Stream.of("reset", "clear", "none", "~"));
+            helper.append("reset", "clear", "none", "~");
         } else {
             if (args.hasAtMost(3)) {
                 while (args.has(2)) {

File: src/main/java/baritone/utils/command/defaults/SetCommand.java
Patch:
@@ -207,9 +207,9 @@ protected Stream<String> tabCompleted(String label, ArgConsumer args) throws Com
                     if (setting.getType() == Boolean.class) {
                         TabCompleteHelper helper = new TabCompleteHelper();
                         if ((Boolean) setting.value) {
-                            helper.append(Stream.of("true", "false"));
+                            helper.append("true", "false");
                         } else {
-                            helper.append(Stream.of("false", "true"));
+                            helper.append("false", "true");
                         }
                         return helper.filterPrefix(args.getString()).stream();
                     } else {

File: src/api/java/baritone/api/utils/command/argparser/IArgParser.java
Patch:
@@ -39,7 +39,7 @@ interface Stateless<T> extends IArgParser<T> {
          * @throws RuntimeException if you want the parsing to fail. The exception will be caught and turned into an
          *                          appropriate error.
          */
-        T parseArg(CommandArgument arg) throws RuntimeException;
+        T parseArg(CommandArgument arg) throws Exception;
     }
 
     /**
@@ -59,6 +59,6 @@ interface Stated<T, S> extends IArgParser<T> {
          * @throws RuntimeException if you want the parsing to fail. The exception will be caught and turned into an
          *                          appropriate error.
          */
-        T parseArg(CommandArgument arg, S state) throws RuntimeException;
+        T parseArg(CommandArgument arg, S state) throws Exception;
     }
 }

File: src/api/java/baritone/api/utils/command/datatypes/IDatatype.java
Patch:
@@ -17,7 +17,7 @@
 
 package baritone.api.utils.command.datatypes;
 
-import baritone.api.utils.command.argparser.ArgParser;
+import baritone.api.utils.command.argparser.IArgParser;
 import baritone.api.utils.command.exception.CommandException;
 import baritone.api.utils.command.exception.CommandInvalidArgumentException;
 import baritone.api.utils.command.helpers.arguments.ArgConsumer;
@@ -34,7 +34,7 @@
 public interface IDatatype {
 
     /**
-     * One benefit over datatypes over {@link ArgParser}s is that instead of each command trying to guess what values
+     * One benefit over datatypes over {@link IArgParser}s is that instead of each command trying to guess what values
      * the datatype will accept, or simply not tab completing at all, datatypes that support tab completion can provide
      * accurate information using the same methods used to parse arguments in the first place.
      * <p>

File: src/api/java/baritone/api/utils/command/execution/CommandExecution.java
Patch:
@@ -17,8 +17,6 @@
 
 package baritone.api.utils.command.execution;
 
-import baritone.api.BaritoneAPI;
-import baritone.api.Settings;
 import baritone.api.utils.command.Command;
 import baritone.api.utils.command.argument.CommandArgument;
 import baritone.api.utils.command.exception.CommandException;

File: src/api/java/baritone/api/utils/Helper.java
Patch:
@@ -87,7 +87,7 @@ default void logDirect(ITextComponent... components) {
      * @param color   The color to print that message in
      */
     default void logDirect(String message, TextFormatting color) {
-        Arrays.stream(message.split("\\n")).forEach(line -> {
+        Arrays.stream(message.split("\n")).forEach(line -> {
             ITextComponent component = new TextComponentString(line.replace("\t", "    "));
             component.getStyle().setColor(color);
             logDirect(component);

File: src/api/java/baritone/api/utils/ISchematic.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.List;
 
 /**
- * Basic representation of a schematic. Provides the dimensions and the desired statefor a given position relative to
+ * Basic representation of a schematic. Provides the dimensions and the desired state for a given position relative to
  * the origin.
  *
  * @author leijurv

File: src/main/java/baritone/utils/command/defaults/MineCommand.java
Patch:
@@ -46,8 +46,8 @@ protected void executed(String label, ArgConsumer args, Settings settings) {
             boms.add(args.getDatatypeFor(ForBlockOptionalMeta.class));
         }
         WorldScanner.INSTANCE.repack(ctx);
-        baritone.getMineProcess().mine(quantity, boms.toArray(new BlockOptionalMeta[0]));
         logDirect(String.format("Mining %s", boms.toString()));
+        baritone.getMineProcess().mine(quantity, boms.toArray(new BlockOptionalMeta[0]));
     }
 
     @Override

File: src/api/java/baritone/api/event/listener/IGameEventListener.java
Patch:
@@ -66,7 +66,7 @@ public interface IGameEventListener {
 
     /**
      * Runs whenever the client player tries to tab complete in chat once completions have been recieved from the
-     * server. This will only be called if the {@link TabCompleteEvent.Pre#cancel()} method was not called.
+     * server. This will only be called if the {@link TabCompleteEvent#cancel()} method was not called.
      *
      * @param event The event
      */

File: src/api/java/baritone/api/utils/command/argparser/ArgParserManager.java
Patch:
@@ -68,7 +68,6 @@ public static <T, S> ArgParser.Stated<T, S> getParserStated(Class<T> klass, Clas
      * @return An instance of the specified class.
      * @throws CommandNoParserForTypeException If no parser exists for that type
      * @throws CommandInvalidTypeException     If the parsing failed
-     * @see ArgParser.Stateless
      */
     public static <T> T parseStateless(Class<T> klass, CommandArgument arg) {
         ArgParser.Stateless<T> parser = getParserStateless(klass);

File: src/api/java/baritone/api/utils/command/datatypes/ForWaypoints.java
Patch:
@@ -76,7 +76,7 @@ public static IWaypoint[] getWaypoints() {
     public static String[] getWaypointNames() {
         return Arrays.stream(getWaypoints())
                 .map(IWaypoint::getName)
-                .filter(name -> !"".equals(name))
+                .filter(name -> !name.isEmpty())
                 .toArray(String[]::new);
     }
 

File: src/api/java/baritone/api/event/listener/IGameEventListener.java
Patch:
@@ -66,7 +66,7 @@ public interface IGameEventListener {
 
     /**
      * Runs whenever the client player tries to tab complete in chat once completions have been recieved from the
-     * server. This will only be called if the {@link TabCompleteEvent.Pre#cancel()} method was not called.
+     * server. This will only be called if the {@link TabCompleteEvent#cancel()} method was not called.
      *
      * @param event The event
      */

File: src/api/java/baritone/api/utils/command/argparser/ArgParserManager.java
Patch:
@@ -68,7 +68,6 @@ public static <T, S> ArgParser.Stated<T, S> getParserStated(Class<T> klass, Clas
      * @return An instance of the specified class.
      * @throws CommandNoParserForTypeException If no parser exists for that type
      * @throws CommandInvalidTypeException     If the parsing failed
-     * @see ArgParser.Stateless
      */
     public static <T> T parseStateless(Class<T> klass, CommandArgument arg) {
         ArgParser.Stateless<T> parser = getParserStateless(klass);

File: src/api/java/baritone/api/utils/command/datatypes/ForWaypoints.java
Patch:
@@ -76,7 +76,7 @@ public static IWaypoint[] getWaypoints() {
     public static String[] getWaypointNames() {
         return Arrays.stream(getWaypoints())
                 .map(IWaypoint::getName)
-                .filter(name -> !"".equals(name))
+                .filter(name -> !name.isEmpty())
                 .toArray(String[]::new);
     }
 

File: src/main/java/baritone/cache/ChunkPacker.java
Patch:
@@ -87,9 +87,9 @@ public static CachedChunk pack(Chunk chunk) {
         //System.out.println("Chunk packing took " + (end - start) + "ms for " + chunk.x + "," + chunk.z);
         IBlockState[] blocks = new IBlockState[256];
 
+        // @formatter:off
         for (int z = 0; z < 16; z++) {
-            https:
-//www.ibm.com/developerworks/library/j-perry-writing-good-java-code/index.html
+            https://www.ibm.com/developerworks/library/j-perry-writing-good-java-code/index.html
             for (int x = 0; x < 16; x++) {
                 for (int y = 255; y >= 0; y--) {
                     int index = CachedChunk.getPositionIndex(x, y, z);
@@ -101,6 +101,7 @@ public static CachedChunk pack(Chunk chunk) {
                 blocks[z << 4 | x] = Blocks.AIR.getDefaultState();
             }
         }
+        // @formatter:on
         return new CachedChunk(chunk.x, chunk.z, bitSet, blocks, specialBlocks, System.currentTimeMillis());
     }
 

File: src/main/java/baritone/cache/ChunkPacker.java
Patch:
@@ -87,9 +87,9 @@ public static CachedChunk pack(Chunk chunk) {
         //System.out.println("Chunk packing took " + (end - start) + "ms for " + chunk.x + "," + chunk.z);
         IBlockState[] blocks = new IBlockState[256];
 
+        // @formatter:off
         for (int z = 0; z < 16; z++) {
-            https:
-//www.ibm.com/developerworks/library/j-perry-writing-good-java-code/index.html
+            https://www.ibm.com/developerworks/library/j-perry-writing-good-java-code/index.html
             for (int x = 0; x < 16; x++) {
                 for (int y = 255; y >= 0; y--) {
                     int index = CachedChunk.getPositionIndex(x, y, z);
@@ -101,6 +101,7 @@ public static CachedChunk pack(Chunk chunk) {
                 blocks[z << 4 | x] = Blocks.AIR.getDefaultState();
             }
         }
+        // @formatter:on
         return new CachedChunk(chunk.x, chunk.z, bitSet, blocks, specialBlocks, System.currentTimeMillis());
     }
 

File: src/main/java/baritone/behavior/LookBehavior.java
Patch:
@@ -72,6 +72,8 @@ public void onPlayerUpdate(PlayerUpdateEvent event) {
                     float oldPitch = ctx.player().rotationPitch;
                     float desiredPitch = this.target.getPitch();
                     ctx.player().rotationPitch = desiredPitch;
+                    ctx.player().rotationYaw += (Math.random() - 0.5) * Baritone.settings().randomLooking.value;
+                    ctx.player().rotationPitch += (Math.random() - 0.5) * Baritone.settings().randomLooking.value;
                     if (desiredPitch == oldPitch && !Baritone.settings().freeLook.value) {
                         nudgeToLevel();
                     }

File: src/api/java/baritone/api/schematic/ReplaceSchematic.java
Patch:
@@ -29,7 +29,7 @@ public class ReplaceSchematic extends MaskSchematic {
     public ReplaceSchematic(IBaritone baritone, ISchematic schematic, BlockOptionalMetaLookup filter) {
         super(baritone, schematic);
         this.filter = filter;
-        this.cache = new boolean[lengthZ()][heightY()][widthX()];
+        this.cache = new boolean[widthX()][heightY()][lengthZ()];
     }
 
     protected boolean partOfMask(int x, int y, int z, IBlockState currentState) {

File: src/main/java/baritone/utils/command/defaults/AxisCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.pathing.goals.Goal;

File: src/main/java/baritone/utils/command/defaults/BlacklistCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.process.IGetToBlockProcess;

File: src/main/java/baritone/utils/command/defaults/BuildCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.utils.BetterBlockPos;

File: src/main/java/baritone/utils/command/defaults/CancelCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.utils.command.Command;

File: src/main/java/baritone/utils/command/defaults/ChestsCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.cache.IRememberedInventory;

File: src/main/java/baritone/utils/command/defaults/ClearareaCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.pathing.goals.Goal;

File: src/main/java/baritone/utils/command/defaults/ClickCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.utils.command.Command;

File: src/main/java/baritone/utils/command/defaults/ComeCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.pathing.goals.GoalBlock;

File: src/main/java/baritone/utils/command/defaults/CommandAlias.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.utils.command.Command;

File: src/main/java/baritone/utils/command/defaults/DefaultCommands.java
Patch:
@@ -15,9 +15,10 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.utils.command.Command;
+import baritone.api.utils.command.manager.CommandManager;
 
 import java.util.Collections;
 import java.util.List;
@@ -30,7 +31,6 @@ public class DefaultCommands {
         new SetCommand(),
         new CommandAlias(asList("modified", "mod", "baritone", "modifiedsettings"), "List modified settings", "set modified"),
         new CommandAlias("reset", "Reset all settings or just one", "set reset"),
-        new ExcCommand(), // TODO: remove this debug command... eventually
         new GoalCommand(),
         new PathCommand(),
         new ProcCommand(),

File: src/main/java/baritone/utils/command/defaults/EmptyCommand.java
Patch:
@@ -15,10 +15,9 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
-import baritone.api.utils.Helper;
 import baritone.api.utils.command.Command;
 import baritone.api.utils.command.helpers.arguments.ArgConsumer;
 

File: src/main/java/baritone/utils/command/defaults/ExploreCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.pathing.goals.GoalXZ;

File: src/main/java/baritone/utils/command/defaults/ExploreFilterCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.utils.command.Command;

File: src/main/java/baritone/utils/command/defaults/FarmCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.utils.command.Command;

File: src/main/java/baritone/utils/command/defaults/FindCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.utils.BetterBlockPos;

File: src/main/java/baritone/utils/command/defaults/FollowCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.utils.command.Command;

File: src/main/java/baritone/utils/command/defaults/ForceCancelCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.behavior.IPathingBehavior;

File: src/main/java/baritone/utils/command/defaults/GcCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.utils.command.Command;

File: src/main/java/baritone/utils/command/defaults/GoalCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.pathing.goals.Goal;

File: src/main/java/baritone/utils/command/defaults/HelpCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.utils.command.Command;

File: src/main/java/baritone/utils/command/defaults/InvertCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.pathing.goals.Goal;

File: src/main/java/baritone/utils/command/defaults/MineCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.utils.BlockOptionalMeta;

File: src/main/java/baritone/utils/command/defaults/PathCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.pathing.goals.Goal;

File: src/main/java/baritone/utils/command/defaults/PauseResumeCommands.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.BaritoneAPI;
 import baritone.api.Settings;

File: src/main/java/baritone/utils/command/defaults/ProcCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.pathing.calc.IPathingControlManager;

File: src/main/java/baritone/utils/command/defaults/ReloadAllCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.utils.command.Command;

File: src/main/java/baritone/utils/command/defaults/RenderCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.utils.BetterBlockPos;

File: src/main/java/baritone/utils/command/defaults/RepackCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.cache.ICachedWorld;

File: src/main/java/baritone/utils/command/defaults/SaveAllCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.utils.command.Command;

File: src/main/java/baritone/utils/command/defaults/SchematicaCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.utils.command.Command;

File: src/main/java/baritone/utils/command/defaults/SelCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.event.events.RenderEvent;

File: src/main/java/baritone/utils/command/defaults/SetCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.utils.SettingsUtil;

File: src/main/java/baritone/utils/command/defaults/ThisWayCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.pathing.goals.GoalXZ;

File: src/main/java/baritone/utils/command/defaults/TunnelCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.pathing.goals.Goal;

File: src/main/java/baritone/utils/command/defaults/VersionCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.utils.command.Command;

File: src/main/java/baritone/utils/command/defaults/WaypointsCommand.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.api.utils.command.defaults;
+package baritone.utils.command.defaults;
 
 import baritone.api.Settings;
 import baritone.api.cache.IWaypoint;

File: src/api/java/baritone/api/utils/command/defaults/SelCommand.java
Patch:
@@ -365,11 +365,11 @@ public void onRenderPass(RenderEvent event) {
 
         Color color = settings.colorSelectionPos1.value;
         float opacity = settings.selectionOpacity.value;
-        float lineWidth = settings.selectionRenderLineWidthPixels.value;
+        float lineWidth = settings.selectionLineWidth.value;
         boolean ignoreDepth = settings.renderSelectionIgnoreDepth.value;
 
         IRenderer.startLines(color, opacity, lineWidth, ignoreDepth);
-        IRenderer.drawAABB(new AxisAlignedBB(pos1, pos1.add(1, 1, 1)), -.01f);
+        IRenderer.drawAABB(new AxisAlignedBB(pos1, pos1.add(1, 1, 1)));
         IRenderer.endLines(ignoreDepth);
     }
 }

File: src/api/java/baritone/api/utils/command/defaults/SelCommand.java
Patch:
@@ -364,11 +364,12 @@ public void onRenderPass(RenderEvent event) {
         }
 
         Color color = settings.colorSelectionPos1.value;
+        float opacity = settings.selectionOpacity.value;
         float lineWidth = settings.selectionRenderLineWidthPixels.value;
         boolean ignoreDepth = settings.renderSelectionIgnoreDepth.value;
 
-        IRenderer.startLines(color, lineWidth, ignoreDepth);
-        IRenderer.drawAABB(new AxisAlignedBB(pos1, pos1.add(1, 1, 1)));
+        IRenderer.startLines(color, opacity, lineWidth, ignoreDepth);
+        IRenderer.drawAABB(new AxisAlignedBB(pos1, pos1.add(1, 1, 1)), -.01f);
         IRenderer.endLines(ignoreDepth);
     }
 }

File: src/main/java/baritone/utils/PathRenderer.java
Patch:
@@ -175,7 +175,6 @@ public static void drawPath(IPath path, int startIndex, Color color, boolean fad
     }
 
     public static void drawLine(double x1, double y1, double z1, double x2, double y2, double z2) {
-        RenderManager renderManager = Helper.mc.getRenderManager();
         double vpX = renderManager.viewerPosX;
         double vpY = renderManager.viewerPosY;
         double vpZ = renderManager.viewerPosZ;
@@ -215,7 +214,6 @@ public static void drawManySelectionBoxes(Entity player, Collection<BlockPos> po
     }
 
     public static void drawDankLitGoalBox(Entity player, Goal goal, float partialTicks, Color color) {
-        RenderManager renderManager = Helper.mc.getRenderManager();
         double renderPosX = renderManager.viewerPosX;
         double renderPosY = renderManager.viewerPosY;
         double renderPosZ = renderManager.viewerPosZ;

File: src/api/java/baritone/api/utils/command/defaults/SelCommand.java
Patch:
@@ -319,8 +319,8 @@ public static String[] getAllNames() {
 
     enum TransformTarget {
         ALL(sels -> sels, "all", "a"),
-        NEWEST(sels -> new ISelection[] {sels[0]}, "newest", "n"),
-        OLDEST(sels -> new ISelection[] {sels[sels.length - 1]}, "oldest", "o");
+        NEWEST(sels -> new ISelection[] {sels[sels.length - 1]}, "newest", "n"),
+        OLDEST(sels -> new ISelection[] {sels[0]}, "oldest", "o");
 
         private final Function<ISelection[], ISelection[]> transform;
         private final String[] names;

File: src/api/java/baritone/api/schematic/CompositeSchematic.java
Patch:
@@ -1,5 +1,6 @@
 package baritone.api.schematic;
 
+import baritone.api.IBaritone;
 import baritone.api.utils.ISchematic;
 import net.minecraft.block.state.IBlockState;
 
@@ -20,8 +21,8 @@ private void recalcArr() {
         }
     }
 
-    public CompositeSchematic(int x, int y, int z) {
-        super(x, y, z);
+    public CompositeSchematic(IBaritone baritone, int x, int y, int z) {
+        super(baritone, x, y, z);
         schematics = new ArrayList<>();
         recalcArr();
     }

File: src/api/java/baritone/api/schematic/MaskSchematic.java
Patch:
@@ -1,13 +1,14 @@
 package baritone.api.schematic;
 
+import baritone.api.IBaritone;
 import baritone.api.utils.ISchematic;
 import net.minecraft.block.state.IBlockState;
 
 public abstract class MaskSchematic extends AbstractSchematic {
     private final ISchematic schematic;
 
-    public MaskSchematic(ISchematic schematic) {
-        super(schematic.widthX(), schematic.heightY(), schematic.lengthZ());
+    public MaskSchematic(IBaritone baritone, ISchematic schematic) {
+        super(baritone, schematic.widthX(), schematic.heightY(), schematic.lengthZ());
         this.schematic = schematic;
     }
 

File: src/api/java/baritone/api/schematic/ShellSchematic.java
Patch:
@@ -1,11 +1,12 @@
 package baritone.api.schematic;
 
+import baritone.api.IBaritone;
 import baritone.api.utils.ISchematic;
 import net.minecraft.block.state.IBlockState;
 
 public class ShellSchematic extends MaskSchematic {
-    public ShellSchematic(ISchematic schematic) {
-        super(schematic);
+    public ShellSchematic(IBaritone baritone, ISchematic schematic) {
+        super(baritone, schematic);
     }
 
     protected boolean partOfMask(int x, int y, int z, IBlockState currentState) {

File: src/api/java/baritone/api/schematic/WallsSchematic.java
Patch:
@@ -1,11 +1,12 @@
 package baritone.api.schematic;
 
+import baritone.api.IBaritone;
 import baritone.api.utils.ISchematic;
 import net.minecraft.block.state.IBlockState;
 
 public class WallsSchematic extends MaskSchematic {
-    public WallsSchematic(ISchematic schematic) {
-        super(schematic);
+    public WallsSchematic(IBaritone baritone, ISchematic schematic) {
+        super(baritone, schematic);
     }
 
     protected boolean partOfMask(int x, int y, int z, IBlockState currentState) {

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -522,7 +522,7 @@ private void fullRecalc(BuilderCalculationContext bcc) {
                     int blockX = x + origin.getX();
                     int blockY = y + origin.getY();
                     int blockZ = z + origin.getZ();
-                    IBlockState current = bcc.bsi.get0(x, y, z);
+                    IBlockState current = bcc.bsi.get0(blockX, blockY, blockZ);
                     if (!schematic.inSchematic(x, y, z, current)) {
                         continue;
                     }

File: src/api/java/baritone/api/utils/command/defaults/HelpCommand.java
Patch:
@@ -86,7 +86,7 @@ protected void executed(String label, ArgConsumer args, Settings settings) {
                         }});
                     }};
                 },
-                FORCE_COMMAND_PREFIX + "help %d"
+                FORCE_COMMAND_PREFIX + "help"
             );
         } else {
             String commandName = args.getString().toLowerCase();

File: src/api/java/baritone/api/utils/command/defaults/SetCommand.java
Patch:
@@ -112,7 +112,7 @@ protected void executed(String label, ArgConsumer args, Settings settings) {
                         getStyle().setColor(TextFormatting.DARK_GRAY);
                     }});
                 }},
-                FORCE_COMMAND_PREFIX + "set " + arg + " " + search + " %d"
+                FORCE_COMMAND_PREFIX + "set " + arg + " " + search
             );
 
             return;

File: src/main/java/baritone/utils/ToolSet.java
Patch:
@@ -117,7 +117,8 @@ public byte getBestSlot(Block b, boolean preferSilkTouch) {
                 bestSilkTouch = silkTouch;
             } else if (speed == highestSpeed) {
                 int cost = getMaterialCost(itemStack);
-                if ((cost < lowestCost && (!preferSilkTouch || (!bestSilkTouch && silkTouch)))) {
+                if (cost < lowestCost && (silkTouch || !bestSilkTouch) ||
+                    (preferSilkTouch && !bestSilkTouch && silkTouch)) {
                     highestSpeed = speed;
                     best = i;
                     lowestCost = cost;

File: src/launch/java/baritone/launch/mixins/MixinItemStack.java
Patch:
@@ -41,7 +41,7 @@ public abstract class MixinItemStack implements IItemStack {
     private int baritoneHash;
 
     private void recalculateHash() {
-        baritoneHash = item == null ? -1 : item.hashCode() * itemDamage;
+        baritoneHash = item == null ? -1 : item.hashCode() + itemDamage;
     }
 
     @Inject(method = "<init>*", at = @At("RETURN"))

File: src/api/java/baritone/api/utils/command/defaults/ExploreFilterCommand.java
Patch:
@@ -67,7 +67,7 @@ protected void executed(String label, ArgConsumer args, Settings settings) {
     @Override
     protected Stream<String> tabCompleted(String label, ArgConsumer args, Settings settings) {
         if (args.hasExactlyOne()) {
-            return RelativeFile.tabComplete(args, MC.gameDir.getAbsoluteFile().getParentFile());
+            return RelativeFile.tabComplete(args, RelativeFile.gameDir());
         }
 
         return Stream.empty();

File: src/launch/java/baritone/launch/mixins/MixinBitArray.java
Patch:
@@ -23,9 +23,6 @@
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Overwrite;
 import org.spongepowered.asm.mixin.Shadow;
-import org.spongepowered.asm.mixin.Unique;
-
-import java.util.Arrays;
 
 @Mixin(BitArray.class)
 public abstract class MixinBitArray implements IBitArray {

File: src/main/java/baritone/cache/WorldScanner.java
Patch:
@@ -114,10 +114,10 @@ private boolean scanChunkInto(int chunkX, int chunkZ, Chunk chunk, BlockOptional
             }
             int yReal = y0 << 4;
             IBlockStateContainer bsc = (IBlockStateContainer) extendedblockstorage.getData();
-            // the mapping of BlockStateContainer.getIndex from xyz to index is y << 8 | z << 4 | x;
-            // for better cache locality, iterate in that order
+            // storageArray uses an optimized algorithm that's faster than getAt
+            // creating this array and then using getAtPalette is faster than even getFast(int index)
             int[] storage = bsc.storageArray();
-            int imax = 1 << 12;
+            final int imax = 1 << 12;
             for (int i = 0; i < imax; i++) {
                 IBlockState state = bsc.getAtPalette(storage[i]);
                 if (filter.has(state)) {

File: src/api/java/baritone/api/pathing/goals/GoalXZ.java
Patch:
@@ -93,7 +93,7 @@ public static GoalXZ fromDirection(Vec3d origin, float yaw, double distance) {
         float theta = (float) Math.toRadians(yaw);
         double x = origin.x - MathHelper.sin(theta) * distance;
         double z = origin.z + MathHelper.cos(theta) * distance;
-        return new GoalXZ((int) x, (int) z);
+        return new GoalXZ(MathHelper.floor(x), MathHelper.floor(z));
     }
 
     public int getX() {

File: src/api/java/baritone/api/utils/command/argparser/DefaultArgParsers.java
Patch:
@@ -50,7 +50,7 @@ public FloatArgumentParser() {
         public Float parseArg(CommandArgument arg) throws RuntimeException {
             String value = arg.value;
 
-            if (!value.matches("^[+-]?\\d+(?:\\.\\d+)$")) {
+            if (!value.matches("^([+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)|)$")) {
                 throw new RuntimeException("failed float format check");
             }
 
@@ -69,7 +69,7 @@ public DoubleArgumentParser() {
         public Double parseArg(CommandArgument arg) throws RuntimeException {
             String value = arg.value;
 
-            if (!value.matches("^[+-]?\\d+(?:\\.\\d+)$")) {
+            if (!value.matches("^([+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)|)$")) {
                 throw new RuntimeException("failed double format check");
             }
 

File: src/api/java/baritone/api/utils/command/defaults/DefaultCommands.java
Patch:
@@ -60,6 +60,7 @@ public class DefaultCommands {
         new BlacklistCommand(),
         new FindCommand(),
         new MineCommand(),
-        new ClickCommand()
+        new ClickCommand(),
+        new ThisWayCommand()
     ));
 }

File: src/api/java/baritone/api/utils/BlockListFilter.java
Patch:
@@ -22,12 +22,12 @@ public BlockListFilter(Block... blocks) {
 
     @Override
     public boolean selected(@Nonnull IBlockState blockstate) {
-        return false;
+        return blocks.contains(blockstate.getBlock());
     }
 
     @Override
     public List<Block> blocks() {
-        return null;
+        return blocks;
     }
 
     @Override

File: src/api/java/baritone/api/utils/BlockSelector.java
Patch:
@@ -17,6 +17,7 @@
 public class BlockSelector implements IBlockFilter {
     private final Block block;
     private final IBlockState blockstate;
+    private final int damage;
     private static final Pattern pattern = Pattern.compile("^(.+?)(?::(\\d+))?$");
 
     public BlockSelector(@Nonnull String selector) {
@@ -38,12 +39,12 @@ public BlockSelector(@Nonnull String selector) {
         block = Block.REGISTRY.getObject(id);
         //noinspection deprecation
         blockstate = hasData ? block.getStateFromMeta(Integer.parseInt(matchResult.group(2))) : null;
+        damage = block.damageDropped(blockstate);
     }
 
     @Override
     public boolean selected(@Nonnull IBlockState blockstate) {
-        return blockstate.getBlock() == block && (isNull(this.blockstate) ||
-            block.damageDropped(blockstate) == block.damageDropped(this.blockstate));
+        return blockstate.getBlock() == block && (isNull(this.blockstate) || block.damageDropped(blockstate) == damage);
     }
 
     @Override

File: src/api/java/baritone/api/utils/command/argument/CommandArgument.java
Patch:
@@ -39,7 +39,7 @@ private CommandArgument(int index, String value, String rawRest) {
         this.rawRest = rawRest;
     }
 
-    public <E extends Enum<?>> E getE(Class<E> enumClass) {
+    public <E extends Enum<?>> E getEnum(Class<E> enumClass) {
         //noinspection OptionalGetWithoutIsPresent
         return Arrays.stream(enumClass.getEnumConstants())
             .filter(e -> e.name().equalsIgnoreCase(value))

File: src/api/java/baritone/api/utils/command/datatypes/BlockById.java
Patch:
@@ -16,7 +16,7 @@ public BlockById() {
     }
 
     public BlockById(ArgConsumer consumer) {
-        ResourceLocation id = new ResourceLocation(consumer.getS());
+        ResourceLocation id = new ResourceLocation(consumer.getString());
 
         if ((block = Block.REGISTRY.getObject(id)) == Blocks.AIR) {
             throw new RuntimeException("no block found by that id");
@@ -36,7 +36,7 @@ public Stream<String> tabComplete(ArgConsumer consumer) {
                     .stream()
                     .map(Object::toString)
             )
-            .filterPrefixNamespaced(consumer.getS())
+            .filterPrefixNamespaced(consumer.getString())
             .sortAlphabetically()
             .stream();
     }

File: src/api/java/baritone/api/utils/command/datatypes/EntityClassById.java
Patch:
@@ -18,7 +18,7 @@ public EntityClassById() {
     }
 
     public EntityClassById(ArgConsumer consumer) {
-        ResourceLocation id = new ResourceLocation(consumer.getS());
+        ResourceLocation id = new ResourceLocation(consumer.getString());
 
         if (isNull(entity = EntityList.REGISTRY.getObject(id))) {
             throw new RuntimeException("no entity found by that id");
@@ -38,7 +38,7 @@ public Stream<String> tabComplete(ArgConsumer consumer) {
                     .stream()
                     .map(Object::toString)
             )
-            .filterPrefixNamespaced(consumer.getS())
+            .filterPrefixNamespaced(consumer.getString())
             .sortAlphabetically()
             .stream();
     }

File: src/api/java/baritone/api/utils/command/datatypes/ForBlockSelector.java
Patch:
@@ -13,7 +13,7 @@ public ForBlockSelector() {
     }
 
     public ForBlockSelector(ArgConsumer consumer) {
-        selector = new BlockSelector(consumer.getS());
+        selector = new BlockSelector(consumer.getString());
     }
 
     @Override

File: src/api/java/baritone/api/utils/command/datatypes/PlayerByUsername.java
Patch:
@@ -20,7 +20,7 @@ public PlayerByUsername() {
     }
 
     public PlayerByUsername(ArgConsumer consumer) {
-        String username = consumer.getS();
+        String username = consumer.getString();
 
         if (isNull(
             player = players
@@ -46,7 +46,7 @@ public Stream<String> tabComplete(ArgConsumer consumer) {
                     .stream()
                     .map(EntityPlayer::getName)
             )
-            .filterPrefix(consumer.getS())
+            .filterPrefix(consumer.getString())
             .sortAlphabetically()
             .stream();
     }

File: src/api/java/baritone/api/utils/command/datatypes/RelativeCoordinate.java
Patch:
@@ -23,7 +23,7 @@ public RelativeCoordinate(ArgConsumer consumer) {
             throw new RuntimeException("relative coordinate requires an argument");
         }
 
-        Matcher matcher = PATTERN.matcher(consumer.getS());
+        Matcher matcher = PATTERN.matcher(consumer.getString());
 
         if (!matcher.matches()) {
             throw new RuntimeException("pattern doesn't match");
@@ -48,7 +48,7 @@ public int applyFloor(double origin) {
 
     @Override
     public Stream<String> tabComplete(ArgConsumer consumer) {
-        if (!consumer.has(2) && consumer.getS().matches("^(~|$)")) {
+        if (!consumer.has(2) && consumer.getString().matches("^(~|$)")) {
             return Stream.of("~");
         }
 

File: src/api/java/baritone/api/utils/command/datatypes/RelativeFile.java
Patch:
@@ -20,7 +20,7 @@ public RelativeFile() {
 
     public RelativeFile(ArgConsumer consumer) {
         try {
-            path = FileSystems.getDefault().getPath(consumer.getS());
+            path = FileSystems.getDefault().getPath(consumer.getString());
         } catch (InvalidPathException e) {
             throw new RuntimeException("invalid path");
         }
@@ -32,7 +32,7 @@ public Stream<String> tabComplete(ArgConsumer consumer) {
     }
 
     public static Stream<String> tabComplete(ArgConsumer consumer, File base) {
-        String currentPathStringThing = consumer.getS();
+        String currentPathStringThing = consumer.getString();
         Path currentPath = FileSystems.getDefault().getPath(currentPathStringThing);
         Path basePath = currentPath.isAbsolute() ? currentPath.getRoot() : base.toPath();
         boolean useParent = !currentPathStringThing.isEmpty() && !currentPathStringThing.endsWith(File.separator);

File: src/api/java/baritone/api/utils/command/defaults/BuildCommand.java
Patch:
@@ -36,7 +36,7 @@ public BuildCommand() {
 
     @Override
     protected void executed(String label, ArgConsumer args, Settings settings) {
-        String filename = String.format("%s.schematic", args.getS());
+        String filename = String.format("%s.schematic", args.getString());
         BetterBlockPos origin = ctx.playerFeet();
         BetterBlockPos buildOrigin;
 

File: src/api/java/baritone/api/utils/command/defaults/ExploreFilterCommand.java
Patch:
@@ -44,7 +44,7 @@ protected void executed(String label, ArgConsumer args, Settings settings) {
         boolean invert = false;
 
         if (args.has()) {
-            if (args.getS().equalsIgnoreCase("invert")) {
+            if (args.getString().equalsIgnoreCase("invert")) {
                 invert = true;
             } else {
                 throw new CommandInvalidTypeException(args.consumed(), "either \"invert\" or nothing");

File: src/api/java/baritone/api/utils/command/defaults/GoalCommand.java
Patch:
@@ -43,7 +43,7 @@ public GoalCommand() {
     protected void executed(String label, ArgConsumer args, Settings settings) {
         ICustomGoalProcess goalProcess = baritone.getCustomGoalProcess();
 
-        if (args.has() && asList("reset", "clear", "none").contains(args.peekS())) {
+        if (args.has() && asList("reset", "clear", "none").contains(args.peekString())) {
             args.requireMax(1);
 
             if (nonNull(goalProcess.getGoal())) {
@@ -83,7 +83,7 @@ protected Stream<String> tabCompleted(String label, ArgConsumer args, Settings s
             }
         }
 
-        return helper.filterPrefix(args.getS()).stream();
+        return helper.filterPrefix(args.getString()).stream();
     }
 
     @Override

File: src/api/java/baritone/api/utils/command/defaults/HelpCommand.java
Patch:
@@ -89,7 +89,7 @@ protected void executed(String label, ArgConsumer args, Settings settings) {
                 FORCE_COMMAND_PREFIX + "help %d"
             );
         } else {
-            String commandName = args.getS().toLowerCase();
+            String commandName = args.getString().toLowerCase();
             Command command = getCommand(commandName);
 
             if (isNull(command)) {
@@ -112,7 +112,7 @@ protected void executed(String label, ArgConsumer args, Settings settings) {
     @Override
     protected Stream<String> tabCompleted(String label, ArgConsumer args, Settings settings) {
         if (args.hasExactlyOne()) {
-            return new TabCompleteHelper().addCommands().filterPrefix(args.getS()).stream();
+            return new TabCompleteHelper().addCommands().filterPrefix(args.getString()).stream();
         }
 
         return Stream.empty();

File: src/api/java/baritone/api/utils/command/defaults/PathCommand.java
Patch:
@@ -68,7 +68,7 @@ protected Stream<String> tabCompleted(String label, ArgConsumer args, Settings s
                 if (!args.has(2)) {
                     return new TabCompleteHelper()
                         .append("~")
-                        .filterPrefix(args.getS())
+                        .filterPrefix(args.getString())
                         .stream();
                 }
             }

File: src/api/java/baritone/api/utils/ExampleBaritoneControl.java
Patch:
@@ -576,10 +576,9 @@ public boolean isInGoal(int x, int y, int z) {
                 }
                 name = parts[0];
             }
-            for (IWaypoint.Tag tag : IWaypoint.Tag.values())
-            {
+            for (IWaypoint.Tag tag : IWaypoint.Tag.values()) {
                 if (tag.name().equalsIgnoreCase(name)) {
-                    logDirect("Unable to use Tags as name. Tags are: " + Arrays.asList(IWaypoint.Tag.values()).toString().toLowerCase());
+                    logDirect("Unable to use tags as name. Tags are: " + Arrays.asList(IWaypoint.Tag.values()).toString().toLowerCase());
                     return true;
                 }
             }

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -662,7 +662,7 @@ public final class Settings {
     public final Setting<Boolean> replantCrops = new Setting<>(true);
 
     /**
-     * Replant nether wart while farming
+     * Replant nether wart while farming. This setting only has an effect when replantCrops is also enabled
      */
     public final Setting<Boolean> replantNetherWart = new Setting<>(false);
 

File: src/main/java/baritone/utils/BaritoneAutoTest.java
Patch:
@@ -104,7 +104,9 @@ public void onTick(TickEvent event) {
         // If the integrated server is launched and the world has initialized, set the spawn point
         // to our defined starting position
         if (server != null && server.getWorld(DimensionType.OVERWORLD) != null) {
-            server.getWorld(DimensionType.OVERWORLD).setSpawnPoint(STARTING_POSITION);
+            if (mc.player == null) {
+                server.getWorld(DimensionType.OVERWORLD).setSpawnPoint(STARTING_POSITION);
+            }
             server.getCommandManager().handleCommand(server.getCommandSource(), "/difficulty peaceful");
             int result = server.getCommandManager().handleCommand(server.getCommandSource(), "/gamerule spawnRadius 0");
             if (result != 0) {

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -186,7 +186,7 @@ public final class Settings {
      * Enables some more advanced vine features. They're honestly just gimmicks and won't ever be needed in real
      * pathing scenarios. And they can cause Baritone to get trapped indefinitely in a strange scenario.
      * <p>
-     * Never turn this on lol
+     * Almost never turn this on lol
      */
     public final Setting<Boolean> allowVines = new Setting<>(false);
 

File: src/main/java/baritone/cache/WorldProvider.java
Patch:
@@ -74,7 +74,7 @@ public final void initWorld(DimensionType dimension) {
             directory = new File(directory, "baritone");
             readme = directory;
         } else { // Otherwise, the server must be remote...
-            String folderName = mc.getCurrentServerData().serverIP;
+            String folderName = mc.isConnectedToRealms() ? "realms" : mc.getCurrentServerData().serverIP;
             if (SystemUtils.IS_OS_WINDOWS) {
                 folderName = folderName.replace(":", "_");
             }

File: src/launch/java/baritone/launch/mixins/MixinMinecraft.java
Patch:
@@ -32,7 +32,6 @@
 import net.minecraft.item.ItemStack;
 import net.minecraft.util.ActionResultType;
 import net.minecraft.util.Hand;
-import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.BlockRayTraceResult;
 import org.spongepowered.asm.lib.Opcodes;
 import org.spongepowered.asm.mixin.Mixin;

File: src/main/java/baritone/utils/PlayerMovementInput.java
Patch:
@@ -27,7 +27,8 @@ public class PlayerMovementInput extends MovementInput {
         this.handler = handler;
     }
 
-    public void updatePlayerMoveState() {
+    @Override
+    public void tick(boolean p_217607_1_, boolean p_217607_2_) {
         this.moveStrafe = 0.0F;
         this.moveForward = 0.0F;
 

File: src/main/java/baritone/utils/schematic/schematica/SchematicaHelper.java
Patch:
@@ -32,7 +32,7 @@ public static boolean isSchematicaPresent() {
         try {
             Class.forName(Schematica.class.getName());
             return true;
-        } catch (ClassNotFoundException ex) {
+        } catch (ClassNotFoundException | NoClassDefFoundError ex) {
             return false;
         }
     }

File: src/main/java/baritone/utils/schematic/schematica/SchematicaHelper.java
Patch:
@@ -32,7 +32,7 @@ public static boolean isSchematicaPresent() {
         try {
             Class.forName(Schematica.class.getName());
             return true;
-        } catch (ClassNotFoundException ex) {
+        } catch (ClassNotFoundException | NoClassDefFoundError ex) {
             return false;
         }
     }

File: src/main/java/baritone/pathing/movement/movements/MovementAscend.java
Patch:
@@ -168,7 +168,7 @@ public MovementState updateState(MovementState state) {
             return state;
         }
 
-        if (ctx.playerFeet().equals(dest)) {
+        if (ctx.playerFeet().equals(dest) || ctx.playerFeet().equals(dest.add(getDirection().down()))) {
             return state.setStatus(MovementStatus.SUCCESS);
         }
 

File: src/schematica_api/java/com/github/lunatrius/core/util/math/MBlockPos.java
Patch:
@@ -20,7 +20,7 @@
 import net.minecraft.util.math.BlockPos;
 
 public class MBlockPos extends BlockPos {
-    private MBlockPos() {
+    MBlockPos() {
         super(6, 6, 6);
     }
 

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -226,7 +226,7 @@ public MovementState updateState(MovementState state) {
                 state.setStatus(MovementStatus.SUCCESS);
             }
         } else if (!ctx.playerFeet().equals(src)) {
-            if (ctx.playerFeet().equals(src.offset(direction)) || ctx.player().posY - ctx.playerFeet().getY() > 0.0001) {
+            if (ctx.playerFeet().equals(src.offset(direction)) || ctx.player().posY - src.y > 0.0001) {
                 if (!MovementHelper.canWalkOn(ctx, dest.down()) && !ctx.player().onGround && MovementHelper.attemptToPlaceABlock(state, baritone, dest.down(), true) == PlaceResult.READY_TO_PLACE) {
                     // go in the opposite order to check DOWN before all horizontals -- down is preferable because you don't have to look to the side while in midair, which could mess up the trajectory
                     state.setInput(Input.CLICK_RIGHT, true);

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -227,7 +227,7 @@ public MovementState updateState(MovementState state) {
                 state.setStatus(MovementStatus.SUCCESS);
             }
         } else if (!ctx.playerFeet().equals(src)) {
-            if (ctx.playerFeet().equals(src.offset(direction)) || ctx.player().posY - ctx.playerFeet().getY() > 0.0001) {
+            if (ctx.playerFeet().equals(src.offset(direction)) || ctx.player().posY - src.y > 0.0001) {
                 if (!MovementHelper.canWalkOn(ctx, dest.down()) && !ctx.player().onGround && MovementHelper.attemptToPlaceABlock(state, baritone, dest.down(), true) == PlaceResult.READY_TO_PLACE) {
                     // go in the opposite order to check DOWN before all horizontals -- down is preferable because you don't have to look to the side while in midair, which could mess up the trajectory
                     state.setInput(Input.CLICK_RIGHT, true);

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -427,7 +427,7 @@ private boolean shouldSprintNextTick() {
         if (current instanceof MovementFall) {
             Tuple<Vec3d, BlockPos> data = overrideFall((MovementFall) current);
             if (data != null) {
-                BlockPos fallDest = data.getSecond();
+                BetterBlockPos fallDest = new BetterBlockPos(data.getSecond());
                 if (!path.positions().contains(fallDest)) {
                     throw new IllegalStateException();
                 }

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -94,7 +94,7 @@ static boolean canWalkThrough(BlockStateInterface bsi, int x, int y, int z, IBlo
         if (block instanceof BlockAir) { // early return for most common case
             return true;
         }
-        if (block == Blocks.FIRE || block == Blocks.TRIPWIRE || block == Blocks.COBWEB || block == Blocks.END_PORTAL || block == Blocks.COCOA || block instanceof BlockSkull || block == Blocks.BUBBLE_COLUMN || block instanceof BlockShulkerBox || block instanceof BlockSlab || block instanceof BlockTrapDoor) {
+        if (block == Blocks.FIRE || block == Blocks.TRIPWIRE || block == Blocks.COBWEB || block == Blocks.END_PORTAL || block == Blocks.COCOA || block instanceof BlockAbstractSkull || block == Blocks.BUBBLE_COLUMN || block instanceof BlockShulkerBox || block instanceof BlockSlab || block instanceof BlockTrapDoor) {
             return false;
         }
         if (Baritone.settings().blocksToAvoid.value.contains(block)) {

File: src/main/java/baritone/pathing/movement/movements/MovementDiagonal.java
Patch:
@@ -184,7 +184,7 @@ public MovementState updateState(MovementState state) {
 
         if (ctx.playerFeet().equals(dest)) {
             return state.setStatus(MovementStatus.SUCCESS);
-        } else if (!getValidPositions().contains(ctx.playerFeet()) && !(MovementHelper.isLiquid(ctx, src) && getValidPositions().contains(ctx.playerFeet().up()))) {
+        } else if (!playerInValidPosition() && !(MovementHelper.isLiquid(ctx, src) && getValidPositions().contains(ctx.playerFeet().up()))) {
             return state.setStatus(MovementStatus.UNREACHABLE);
         }
         if (sprint()) {

File: src/main/java/baritone/pathing/movement/movements/MovementDownward.java
Patch:
@@ -81,7 +81,7 @@ public MovementState updateState(MovementState state) {
 
         if (ctx.playerFeet().equals(dest)) {
             return state.setStatus(MovementStatus.SUCCESS);
-        } else if (!getValidPositions().contains(ctx.playerFeet())) {
+        } else if (!playerInValidPosition()) {
             return state.setStatus(MovementStatus.UNREACHABLE);
         }
         double diffX = ctx.player().posX - (dest.getX() + 0.5);

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -114,7 +114,7 @@ public boolean onTick() {
                     return false;
                 }
             }
-            for (int i = pathPosition + 3; i < path.length(); i++) { //dont check pathPosition+1. the movement tells us when it's done (e.g. sneak placing)
+            for (int i = pathPosition + 3; i < path.length() - 1; i++) { //dont check pathPosition+1. the movement tells us when it's done (e.g. sneak placing)
                 // also don't check pathPosition+2 because reasons
                 if (((Movement) path.movements().get(i)).getValidPositions().contains(whereAmI)) {
                     if (i - pathPosition > 2) {

File: src/main/java/baritone/process/BackfillProcess.java
Patch:
@@ -85,6 +85,8 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
                     // patience
                     baritone.getLookBehavior().updateTarget(fake.getTarget().getRotation().get(), true);
                     return new PathingCommand(null, PathingCommandType.REQUEST_PAUSE);
+                default:
+                    throw new IllegalStateException();
             }
         }
         return new PathingCommand(null, PathingCommandType.DEFER); // cede to other process

File: src/main/java/baritone/process/MineProcess.java
Patch:
@@ -114,7 +114,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
                 .filter(pos -> !(BlockStateInterface.get(ctx, pos).getBlock() instanceof BlockAir)) // after breaking a block, it takes mineGoalUpdateInterval ticks for it to actually update this list =(
                 .min(Comparator.comparingDouble(ctx.player()::getDistanceSq));
         baritone.getInputOverrideHandler().clearAllKeys();
-        if (shaft.isPresent()) {
+        if (shaft.isPresent() && ctx.player().onGround) {
             BlockPos pos = shaft.get();
             IBlockState state = baritone.bsi.get0(pos);
             if (!MovementHelper.avoidBreaking(baritone.bsi, pos.getX(), pos.getY(), pos.getZ(), state)) {

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -114,6 +114,7 @@ public MovementStatus update() {
             currentState.setInput(Input.JUMP, true);
         }
         if (ctx.player().isEntityInsideOpaqueBlock()) {
+            ctx.getSelectedBlock().ifPresent(pos -> MovementHelper.switchToBestToolFor(ctx, BlockStateInterface.get(ctx, pos)));
             currentState.setInput(Input.CLICK_LEFT, true);
         }
 

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -147,10 +147,10 @@ protected boolean prepared(MovementState state) {
             }
             if (!MovementHelper.canWalkThrough(ctx, blockPos) && !(BlockStateInterface.getBlock(ctx, blockPos) instanceof BlockLiquid)) { // can't break liquid, so don't try
                 somethingInTheWay = true;
+                MovementHelper.switchToBestToolFor(ctx, BlockStateInterface.get(ctx, blockPos));
                 Optional<Rotation> reachable = RotationUtils.reachable(ctx.player(), blockPos, ctx.playerController().getBlockReachDistance());
                 if (reachable.isPresent()) {
                     Rotation rotTowardsBlock = reachable.get();
-                    MovementHelper.switchToBestToolFor(ctx, BlockStateInterface.get(ctx, blockPos));
                     state.setTarget(new MovementState.MovementTarget(rotTowardsBlock, true));
                     if (ctx.isLookingAt(blockPos) || ctx.playerRotations().isReallyCloseTo(rotTowardsBlock)) {
                         state.setInput(Input.CLICK_LEFT, true);

File: src/launch/java/baritone/launch/mixins/MixinChunkRenderContainer.java
Patch:
@@ -41,7 +41,7 @@ public class MixinChunkRenderContainer {
             )
     )
     private BlockPos getPosition(RenderChunk renderChunkIn) {
-        if (Baritone.settings().renderCachedChunks.value && Minecraft.getMinecraft().getIntegratedServer() == null && Minecraft.getMinecraft().world.getChunk(renderChunkIn.getPosition()).isEmpty()) {
+        if (Baritone.settings().renderCachedChunks.value && !Minecraft.getMinecraft().isSingleplayer() && Minecraft.getMinecraft().world.getChunk(renderChunkIn.getPosition()).isEmpty()) {
             GlStateManager.enableAlpha();
             GlStateManager.enableBlend();
             GL14.glBlendColor(0, 0, 0, Baritone.settings().cachedChunksOpacity.value);

File: src/launch/java/baritone/launch/mixins/MixinChunkRenderWorker.java
Patch:
@@ -43,7 +43,7 @@ public abstract class MixinChunkRenderWorker {
             )
     )
     private boolean isChunkExisting(ChunkRenderWorker worker, BlockPos pos, World world) {
-        if (Baritone.settings().renderCachedChunks.value && Minecraft.getMinecraft().getIntegratedServer() == null) {
+        if (Baritone.settings().renderCachedChunks.value && !Minecraft.getMinecraft().isSingleplayer()) {
             Baritone baritone = (Baritone) BaritoneAPI.getProvider().getPrimaryBaritone();
             IPlayerContext ctx = baritone.getPlayerContext();
             if (ctx.player() != null && ctx.world() != null && baritone.bsi != null) {

File: src/launch/java/baritone/launch/mixins/MixinRenderChunk.java
Patch:
@@ -47,7 +47,7 @@ private boolean isEmpty(ChunkCache chunkCache) {
         if (!chunkCache.isEmpty()) {
             return false;
         }
-        if (Baritone.settings().renderCachedChunks.value && Minecraft.getMinecraft().getIntegratedServer() == null) {
+        if (Baritone.settings().renderCachedChunks.value && !Minecraft.getMinecraft().isSingleplayer()) {
             Baritone baritone = (Baritone) BaritoneAPI.getProvider().getPrimaryBaritone();
             IPlayerContext ctx = baritone.getPlayerContext();
             if (ctx.player() != null && ctx.world() != null && baritone.bsi != null) {
@@ -76,7 +76,7 @@ private boolean isEmpty(ChunkCache chunkCache) {
             )
     )
     private IBlockState getBlockState(ChunkCache chunkCache, BlockPos pos) {
-        if (Baritone.settings().renderCachedChunks.value && Minecraft.getMinecraft().getIntegratedServer() == null) {
+        if (Baritone.settings().renderCachedChunks.value && !Minecraft.getMinecraft().isSingleplayer()) {
             Baritone baritone = (Baritone) BaritoneAPI.getProvider().getPrimaryBaritone();
             IPlayerContext ctx = baritone.getPlayerContext();
             if (ctx.player() != null && ctx.world() != null && baritone.bsi != null) {

File: src/launch/java/baritone/launch/mixins/MixinRenderList.java
Patch:
@@ -38,7 +38,7 @@ public class MixinRenderList {
             )
     )
     private void popMatrix() {
-        if (Baritone.settings().renderCachedChunks.value && Minecraft.getMinecraft().getIntegratedServer() == null) {
+        if (Baritone.settings().renderCachedChunks.value && !Minecraft.getMinecraft().isSingleplayer()) {
             // reset the blend func to normal (not dependent on constant alpha)
             GlStateManager.tryBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);
         }

File: src/launch/java/baritone/launch/mixins/MixinVboRenderList.java
Patch:
@@ -38,7 +38,7 @@ public class MixinVboRenderList {
             )
     )
     private void popMatrix() {
-        if (Baritone.settings().renderCachedChunks.value && Minecraft.getMinecraft().getIntegratedServer() == null) {
+        if (Baritone.settings().renderCachedChunks.value && !Minecraft.getMinecraft().isSingleplayer()) {
             // reset the blend func to normal (not dependent on constant alpha)
             GlStateManager.tryBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);
         }

File: src/main/java/baritone/cache/WorldProvider.java
Patch:
@@ -62,7 +62,7 @@ public final void initWorld(int dimension) {
         IntegratedServer integratedServer = mc.getIntegratedServer();
 
         // If there is an integrated server running (Aka Singleplayer) then do magic to find the world save file
-        if (integratedServer != null) {
+        if (mc.isSingleplayer()) {
             WorldServer localServerWorld = integratedServer.getWorld(dimension);
             IChunkProviderServer provider = (IChunkProviderServer) localServerWorld.getChunkProvider();
             IAnvilChunkLoader loader = (IAnvilChunkLoader) provider.getChunkLoader();

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -301,6 +301,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
             if (realSchematic == null) {
                 realSchematic = schematic;
             }
+            ISchematic realSchematic = this.realSchematic; // wrap this properly, dont just have the inner class refer to the builderprocess.this
             schematic = new ISchematic() {
                 @Override
                 public IBlockState desiredState(int x, int y, int z) {

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -78,7 +78,7 @@ static boolean avoidAdjacentBreaking(BlockStateInterface bsi, int x, int y, int
                 && BlockFalling.canFallThrough(bsi.get0(x, y - 1, z))) { // and if it would fall (i.e. it's unsupported)
             return true; // dont break a block that is adjacent to unsupported gravel because it can cause really weird stuff
         }
-        return state.getFluidState().isEmpty();
+        return !state.getFluidState().isEmpty();
     }
 
     static boolean canWalkThrough(IPlayerContext ctx, BetterBlockPos pos) {

File: src/main/java/baritone/process/MineProcess.java
Patch:
@@ -111,7 +111,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
         }
         Optional<BlockPos> shaft = curr.stream()
                 .filter(pos -> pos.getX() == ctx.playerFeet().getX() && pos.getZ() == ctx.playerFeet().getZ())
-                .filter(pos -> pos.getY() > ctx.playerFeet().getY())
+                .filter(pos -> pos.getY() >= ctx.playerFeet().getY())
                 .filter(pos -> !(BlockStateInterface.get(ctx, pos).getBlock() instanceof BlockAir)) // after breaking a block, it takes mineGoalUpdateInterval ticks for it to actually update this list =(
                 .min(Comparator.comparingDouble(ctx.player()::getDistanceSq));
         baritone.getInputOverrideHandler().clearAllKeys();

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -18,6 +18,7 @@
 package baritone.pathing.movement;
 
 import baritone.Baritone;
+import baritone.api.BaritoneAPI;
 import baritone.api.IBaritone;
 import baritone.api.pathing.movement.ActionCosts;
 import baritone.api.pathing.movement.MovementStatus;
@@ -55,8 +56,7 @@ static boolean avoidBreaking(BlockStateInterface bsi, int x, int y, int z, IBloc
                 || bsi.get0(x + 1, y, z).getBlock() instanceof BlockLiquid
                 || bsi.get0(x - 1, y, z).getBlock() instanceof BlockLiquid
                 || bsi.get0(x, y, z + 1).getBlock() instanceof BlockLiquid
-                || bsi.get0(x, y, z - 1).getBlock() instanceof BlockLiquid
-                || Baritone.settings().blocksToAvoidBreaking.value.contains(b);
+                || bsi.get0(x, y, z - 1).getBlock() instanceof BlockLiquid;
     }
 
     static boolean canWalkThrough(IPlayerContext ctx, BetterBlockPos pos) {
@@ -363,7 +363,7 @@ static double getMiningDurationTicks(CalculationContext context, int x, int y, i
             if (block instanceof BlockLiquid) {
                 return COST_INF;
             }
-            double m = Blocks.CRAFTING_TABLE.equals(block) ? 10 : 1; // TODO see if this is still necessary. it's from MineBot when we wanted to penalize breaking its crafting table
+            double m = Baritone.settings().blocksToAvoidBreaking.value.contains(block) ? 10 : 1;
             double strVsBlock = context.toolSet.getStrVsBlock(state);
             if (strVsBlock <= 0) {
                 return COST_INF;

File: src/api/java/baritone/api/utils/SettingsUtil.java
Patch:
@@ -29,6 +29,7 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.nio.file.Files;
+import java.nio.file.NoSuchFileException;
 import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -80,6 +81,8 @@ public static void readAndApply(Settings settings) {
                     ex.printStackTrace();
                 }
             });
+        } catch (NoSuchFileException ignored) {
+            System.out.println("Baritone settings file not found, resetting.");
         } catch (Exception ex) {
             System.out.println("Exception while reading Baritone settings, some settings may be reset to default values!");
             ex.printStackTrace();

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -338,6 +338,7 @@ public int lengthZ() {
             layer = 0;
             origin = new BlockPos(origin).offset(direction, distance);
             logDirect("Repeating build " + distance + " blocks to the " + direction + ", new origin is " + origin);
+            return onTick(calcFailed, isSafeToCancel);
         }
         trim(bcc);
 

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -55,7 +55,8 @@ static boolean avoidBreaking(BlockStateInterface bsi, int x, int y, int z, IBloc
                 || bsi.get0(x + 1, y, z).getBlock() instanceof BlockLiquid
                 || bsi.get0(x - 1, y, z).getBlock() instanceof BlockLiquid
                 || bsi.get0(x, y, z + 1).getBlock() instanceof BlockLiquid
-                || bsi.get0(x, y, z - 1).getBlock() instanceof BlockLiquid;
+                || bsi.get0(x, y, z - 1).getBlock() instanceof BlockLiquid
+                || Baritone.settings().blocksToAvoidBreaking.value.contains(b);
     }
 
     static boolean canWalkThrough(IPlayerContext ctx, BetterBlockPos pos) {

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -74,6 +74,9 @@ static boolean canWalkThrough(BlockStateInterface bsi, int x, int y, int z, IBlo
         if (block == Blocks.FIRE || block == Blocks.TRIPWIRE || block == Blocks.WEB || block == Blocks.END_PORTAL || block == Blocks.COCOA || block instanceof BlockSkull || block instanceof BlockTrapDoor) {
             return false;
         }
+        if (Baritone.settings().blocksToAvoid.value.contains(block)) {
+            return false;
+        }
         if (block instanceof BlockDoor || block instanceof BlockFenceGate) {
             // Because there's no nice method in vanilla to check if a door is openable or not, we just have to assume
             // that anything that isn't an iron door isn't openable, ignoring that some doors introduced in mods can't

File: src/main/java/baritone/process/BackfillProcess.java
Patch:
@@ -87,7 +87,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
                     return new PathingCommand(null, PathingCommandType.REQUEST_PAUSE);
             }
         }
-        return null; // cede to other process
+        return new PathingCommand(null, PathingCommandType.DEFER); // cede to other process
     }
 
     public void amIBreakingABlockHMMMMMMM() {
@@ -119,7 +119,7 @@ private boolean partOfCurrentMovement(BlockPos pos) {
 
     @Override
     public void onLostControl() {
-        blocksToReplace = new HashMap<>();
+        blocksToReplace.clear();
     }
 
     @Override

File: src/api/java/baritone/api/cache/ICachedWorld.java
Patch:
@@ -81,4 +81,6 @@ public interface ICachedWorld {
      * in a new thread by default.
      */
     void save();
+
+
 }

File: src/api/java/baritone/api/cache/Waypoint.java
Patch:
@@ -15,9 +15,8 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.cache;
+package baritone.api.cache;
 
-import baritone.api.cache.IWaypoint;
 import net.minecraft.util.math.BlockPos;
 
 import java.util.Date;
@@ -47,7 +46,7 @@ public Waypoint(String name, Tag tag, BlockPos location) {
      * @param location          The waypoint location
      * @param creationTimestamp When the waypoint was created
      */
-    Waypoint(String name, Tag tag, BlockPos location, long creationTimestamp) {
+    public Waypoint(String name, Tag tag, BlockPos location, long creationTimestamp) {
         this.name = name;
         this.tag = tag;
         this.location = location;

File: src/api/java/baritone/api/process/IGetToBlockProcess.java
Patch:
@@ -25,4 +25,6 @@
 public interface IGetToBlockProcess extends IBaritoneProcess {
 
     void getToBlock(Block block);
+
+    boolean blacklistClosest();
 }

File: src/main/java/baritone/behavior/MemoryBehavior.java
Patch:
@@ -24,7 +24,7 @@
 import baritone.api.event.events.TickEvent;
 import baritone.api.event.events.type.EventState;
 import baritone.cache.ContainerMemory;
-import baritone.cache.Waypoint;
+import baritone.api.cache.Waypoint;
 import baritone.utils.BlockStateInterface;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockBed;

File: src/main/java/baritone/cache/CachedChunk.java
Patch:
@@ -17,6 +17,7 @@
 
 package baritone.cache;
 
+import baritone.api.utils.BlockUtils;
 import baritone.utils.pathing.PathingBlockType;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import net.minecraft.block.Block;
@@ -177,7 +178,7 @@ public final IBlockState getBlock(int x, int y, int z, int dimension) {
         if (special != null) {
             String str = special.get(index);
             if (str != null) {
-                return ChunkPacker.stringToBlockRequired(str).getDefaultState();
+                return BlockUtils.stringToBlockRequired(str).getDefaultState();
             }
         }
 

File: src/main/java/baritone/cache/CachedWorld.java
Patch:
@@ -22,7 +22,7 @@
 import baritone.api.IBaritone;
 import baritone.api.cache.ICachedWorld;
 import baritone.api.cache.IWorldData;
-import baritone.utils.Helper;
+import baritone.api.utils.Helper;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import net.minecraft.util.math.BlockPos;

File: src/main/java/baritone/cache/WaypointCollection.java
Patch:
@@ -19,6 +19,7 @@
 
 import baritone.api.cache.IWaypoint;
 import baritone.api.cache.IWaypointCollection;
+import baritone.api.cache.Waypoint;
 import net.minecraft.util.math.BlockPos;
 
 import java.io.*;

File: src/main/java/baritone/cache/WorldProvider.java
Patch:
@@ -19,7 +19,7 @@
 
 import baritone.Baritone;
 import baritone.api.cache.IWorldProvider;
-import baritone.utils.Helper;
+import baritone.api.utils.Helper;
 import baritone.utils.accessor.IAnvilChunkLoader;
 import baritone.utils.accessor.IChunkProviderServer;
 import net.minecraft.server.integrated.IntegratedServer;

File: src/main/java/baritone/event/GameEventHandler.java
Patch:
@@ -24,7 +24,7 @@
 import baritone.api.event.listener.IGameEventListener;
 import baritone.cache.WorldProvider;
 import baritone.utils.BlockStateInterface;
-import baritone.utils.Helper;
+import baritone.api.utils.Helper;
 import net.minecraft.world.World;
 import net.minecraft.world.chunk.Chunk;
 

File: src/main/java/baritone/pathing/calc/AbstractNodeCostSearch.java
Patch:
@@ -24,7 +24,7 @@
 import baritone.api.utils.BetterBlockPos;
 import baritone.api.utils.PathCalculationResult;
 import baritone.pathing.movement.CalculationContext;
-import baritone.utils.Helper;
+import baritone.api.utils.Helper;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 
 import java.util.Optional;

File: src/main/java/baritone/pathing/calc/Path.java
Patch:
@@ -25,7 +25,7 @@
 import baritone.pathing.movement.Movement;
 import baritone.pathing.movement.Moves;
 import baritone.pathing.path.CutoffPath;
-import baritone.utils.Helper;
+import baritone.api.utils.Helper;
 import baritone.utils.pathing.PathBase;
 
 import java.util.ArrayList;

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -25,7 +25,7 @@
 import baritone.api.utils.input.Input;
 import baritone.pathing.movement.MovementState.MovementTarget;
 import baritone.utils.BlockStateInterface;
-import baritone.utils.Helper;
+import baritone.api.utils.Helper;
 import baritone.utils.ToolSet;
 import net.minecraft.block.*;
 import net.minecraft.block.properties.PropertyBool;

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -35,7 +35,7 @@
 import baritone.pathing.movement.MovementHelper;
 import baritone.pathing.movement.movements.*;
 import baritone.utils.BlockStateInterface;
-import baritone.utils.Helper;
+import baritone.api.utils.Helper;
 import net.minecraft.block.BlockLiquid;
 import net.minecraft.init.Blocks;
 import net.minecraft.util.Tuple;

File: src/main/java/baritone/process/ExploreProcess.java
Patch:
@@ -22,6 +22,7 @@
 import baritone.api.pathing.goals.Goal;
 import baritone.api.pathing.goals.GoalComposite;
 import baritone.api.pathing.goals.GoalXZ;
+import baritone.api.process.IExploreProcess;
 import baritone.api.process.PathingCommand;
 import baritone.api.process.PathingCommandType;
 import baritone.cache.CachedWorld;
@@ -31,7 +32,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-public class ExploreProcess extends BaritoneProcessHelper {
+public class ExploreProcess extends BaritoneProcessHelper implements IExploreProcess {
 
     private BlockPos explorationOrigin;
 
@@ -44,6 +45,7 @@ public boolean isActive() {
         return explorationOrigin != null;
     }
 
+    @Override
     public void explore(int centerX, int centerZ) {
         explorationOrigin = new BlockPos(centerX, 0, centerZ);
     }

File: src/main/java/baritone/process/MineProcess.java
Patch:
@@ -22,6 +22,7 @@
 import baritone.api.process.IMineProcess;
 import baritone.api.process.PathingCommand;
 import baritone.api.process.PathingCommandType;
+import baritone.api.utils.BlockUtils;
 import baritone.api.utils.IPlayerContext;
 import baritone.api.utils.RotationUtils;
 import baritone.cache.CachedChunk;
@@ -219,7 +220,7 @@ public static List<BlockPos> searchWorld(CalculationContext ctx, List<Block> min
         for (Block m : mining) {
             if (CachedChunk.BLOCKS_TO_KEEP_TRACK_OF.contains(m)) {
                 // maxRegionDistanceSq 2 means adjacent directly or adjacent diagonally; nothing further than that
-                locs.addAll(ctx.worldData.getCachedWorld().getLocationsOf(ChunkPacker.blockToString(m), Baritone.settings().maxCachedWorldScanCount.value, ctx.getBaritone().getPlayerContext().playerFeet().getX(), ctx.getBaritone().getPlayerContext().playerFeet().getZ(), 2));
+                locs.addAll(ctx.worldData.getCachedWorld().getLocationsOf(BlockUtils.blockToString(m), Baritone.settings().maxCachedWorldScanCount.value, ctx.getBaritone().getPlayerContext().playerFeet().getX(), ctx.getBaritone().getPlayerContext().playerFeet().getZ(), 2));
             } else {
                 uninteresting.add(m);
             }
@@ -303,7 +304,7 @@ public static boolean plausibleToBreak(BlockStateInterface bsi, BlockPos pos) {
 
     @Override
     public void mineByName(int quantity, String... blocks) {
-        mine(quantity, blocks == null || blocks.length == 0 ? null : Arrays.stream(blocks).map(ChunkPacker::stringToBlockRequired).toArray(Block[]::new));
+        mine(quantity, blocks == null || blocks.length == 0 ? null : Arrays.stream(blocks).map(BlockUtils::stringToBlockRequired).toArray(Block[]::new));
     }
 
     @Override

File: src/main/java/baritone/utils/BaritoneAutoTest.java
Patch:
@@ -22,6 +22,7 @@
 import baritone.api.event.listener.AbstractGameEventListener;
 import baritone.api.pathing.goals.Goal;
 import baritone.api.pathing.goals.GoalBlock;
+import baritone.api.utils.Helper;
 import baritone.api.utils.IPlayerContext;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.GuiMainMenu;

File: src/main/java/baritone/utils/BaritoneProcessHelper.java
Patch:
@@ -19,6 +19,7 @@
 
 import baritone.Baritone;
 import baritone.api.process.IBaritoneProcess;
+import baritone.api.utils.Helper;
 import baritone.api.utils.IPlayerContext;
 
 public abstract class BaritoneProcessHelper implements IBaritoneProcess, Helper {

File: src/main/java/baritone/utils/BlockBreakHelper.java
Patch:
@@ -17,6 +17,7 @@
 
 package baritone.utils;
 
+import baritone.api.utils.Helper;
 import baritone.api.utils.IPlayerContext;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.EnumHand;

File: src/main/java/baritone/utils/BlockPlaceHelper.java
Patch:
@@ -18,6 +18,7 @@
 package baritone.utils;
 
 import baritone.Baritone;
+import baritone.api.utils.Helper;
 import baritone.api.utils.IPlayerContext;
 import net.minecraft.util.EnumActionResult;
 import net.minecraft.util.EnumHand;

File: src/main/java/baritone/utils/PathRenderer.java
Patch:
@@ -23,6 +23,7 @@
 import baritone.api.pathing.calc.IPath;
 import baritone.api.pathing.goals.*;
 import baritone.api.utils.BetterBlockPos;
+import baritone.api.utils.Helper;
 import baritone.api.utils.interfaces.IGoalRenderPos;
 import baritone.behavior.PathingBehavior;
 import baritone.pathing.path.PathExecutor;

File: src/main/java/baritone/utils/player/PrimaryPlayerContext.java
Patch:
@@ -22,7 +22,7 @@
 import baritone.api.utils.IPlayerContext;
 import baritone.api.utils.IPlayerController;
 import baritone.api.utils.RayTraceUtils;
-import baritone.utils.Helper;
+import baritone.api.utils.Helper;
 import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.util.math.RayTraceResult;
 import net.minecraft.world.World;

File: src/main/java/baritone/utils/player/PrimaryPlayerController.java
Patch:
@@ -18,7 +18,7 @@
 package baritone.utils.player;
 
 import baritone.api.utils.IPlayerController;
-import baritone.utils.Helper;
+import baritone.api.utils.Helper;
 import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.client.multiplayer.WorldClient;
 import net.minecraft.entity.player.EntityPlayer;

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -296,7 +296,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
         }
         baritone.getInputOverrideHandler().clearAllKeys();
         if (paused) {
-            return new PathingCommand(null, PathingCommandType.REQUEST_PAUSE);
+            return new PathingCommand(null, PathingCommandType.CANCEL_AND_SET_GOAL);
         }
         if (Baritone.settings().buildInLayers.value) {
             if (realSchematic == null) {

File: src/main/java/baritone/cache/ChunkPacker.java
Patch:
@@ -128,7 +128,7 @@ public static Block stringToBlockRequired(String name) {
     }
 
     public static Block stringToBlockNullable(String name) {
-        return resourceCache.computeIfAbsent(name, n -> IRegistry.BLOCK.get(new ResourceLocation(n.contains(":") ? n : "minecraft:" + n)));
+        return resourceCache.computeIfAbsent(name, n -> IRegistry.BLOCK.get(ResourceLocation.tryCreate(n.contains(":") ? n : "minecraft:" + n)));
     }
 
     private static PathingBlockType getPathingBlockType(IBlockState state, Chunk chunk, int x, int y, int z) {

File: src/main/java/baritone/cache/CachedWorld.java
Patch:
@@ -180,8 +180,8 @@ private synchronized void prune() {
             if (region == null) {
                 continue;
             }
-            int distX = (region.getX() << 9 + 256) - pruneCenter.getX();
-            int distZ = (region.getZ() << 9 + 256) - pruneCenter.getZ();
+            int distX = ((region.getX() << 9) + 256) - pruneCenter.getX();
+            int distZ = ((region.getZ() << 9) + 256) - pruneCenter.getZ();
             double dist = Math.sqrt(distX * distX + distZ * distZ);
             if (dist > 1024) {
                 logDebug("Deleting cached region " + region.getX() + "," + region.getZ() + " from ram");
@@ -216,7 +216,7 @@ private BlockPos guessPosition() {
         if (mostRecentlyModified == null) {
             return new BlockPos(0, 0, 0);
         }
-        return new BlockPos(mostRecentlyModified.x << 4 + 8, 0, mostRecentlyModified.z << 4 + 8);
+        return new BlockPos((mostRecentlyModified.x << 4) + 8, 0, (mostRecentlyModified.z << 4) + 8);
     }
 
     private synchronized List<CachedRegion> allRegions() {

File: src/main/java/baritone/cache/CachedWorld.java
Patch:
@@ -180,8 +180,8 @@ private synchronized void prune() {
             if (region == null) {
                 continue;
             }
-            int distX = (region.getX() << 9 + 256) - pruneCenter.getX();
-            int distZ = (region.getZ() << 9 + 256) - pruneCenter.getZ();
+            int distX = ((region.getX() << 9) + 256) - pruneCenter.getX();
+            int distZ = ((region.getZ() << 9) + 256) - pruneCenter.getZ();
             double dist = Math.sqrt(distX * distX + distZ * distZ);
             if (dist > 1024) {
                 logDebug("Deleting cached region " + region.getX() + "," + region.getZ() + " from ram");
@@ -216,7 +216,7 @@ private BlockPos guessPosition() {
         if (mostRecentlyModified == null) {
             return new BlockPos(0, 0, 0);
         }
-        return new BlockPos(mostRecentlyModified.x << 4 + 8, 0, mostRecentlyModified.z << 4 + 8);
+        return new BlockPos((mostRecentlyModified.x << 4) + 8, 0, (mostRecentlyModified.z << 4) + 8);
     }
 
     private synchronized List<CachedRegion> allRegions() {

File: src/api/java/baritone/api/pathing/goals/GoalNear.java
Patch:
@@ -61,6 +61,6 @@ public String toString() {
                 ", y=" + y +
                 ", z=" + z +
                 ", rangeSq=" + rangeSq +
-                '}';
+                "}";
     }
 }

File: src/main/java/baritone/behavior/LookBehavior.java
Patch:
@@ -72,7 +72,7 @@ public void onPlayerUpdate(PlayerUpdateEvent event) {
                     float oldPitch = ctx.player().rotationPitch;
                     float desiredPitch = this.target.getPitch();
                     ctx.player().rotationPitch = desiredPitch;
-                    if (desiredPitch == oldPitch && Baritone.settings().freeLook.value) {
+                    if (desiredPitch == oldPitch && !Baritone.settings().freeLook.value) {
                         nudgeToLevel();
                     }
                     this.target = null;

File: src/api/java/baritone/api/utils/Rotation.java
Patch:
@@ -36,6 +36,9 @@ public class Rotation {
     public Rotation(float yaw, float pitch) {
         this.yaw = yaw;
         this.pitch = pitch;
+        if (Float.isInfinite(yaw) || Float.isNaN(yaw) || Float.isInfinite(pitch) || Float.isNaN(pitch)) {
+            throw new IllegalStateException(yaw + " " + pitch);
+        }
     }
 
     /**

File: src/main/java/baritone/pathing/movement/CalculationContext.java
Patch:
@@ -60,6 +60,7 @@ public class CalculationContext {
     public final boolean allowJumpAt256;
     public final boolean assumeWalkOnWater;
     public final boolean allowDiagonalDescend;
+    public final boolean allowDownward;
     public final int maxFallHeightNoWater;
     public final int maxFallHeightBucket;
     public final double waterWalkSpeed;
@@ -91,6 +92,7 @@ public CalculationContext(IBaritone baritone, boolean forUseOnAnotherThread) {
         this.allowJumpAt256 = Baritone.settings().allowJumpAt256.value;
         this.assumeWalkOnWater = Baritone.settings().assumeWalkOnWater.value;
         this.allowDiagonalDescend = Baritone.settings().allowDiagonalDescend.value;
+        this.allowDownward = Baritone.settings().allowDownward.value;
         this.maxFallHeightNoWater = Baritone.settings().maxFallHeightNoWater.value;
         this.maxFallHeightBucket = Baritone.settings().maxFallHeightBucket.value;
         int depth = EnchantmentHelper.getDepthStriderModifier(player);

File: src/main/java/baritone/pathing/movement/movements/MovementDownward.java
Patch:
@@ -48,6 +48,9 @@ public double calculateCost(CalculationContext context) {
     }
 
     public static double cost(CalculationContext context, int x, int y, int z) {
+        if (!context.allowDownward) {
+            return COST_INF;
+        }
         if (!MovementHelper.canWalkOn(context.bsi, x, y - 2, z)) {
             return COST_INF;
         }

File: src/main/java/baritone/process/CustomGoalProcess.java
Patch:
@@ -90,6 +90,9 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
                 }
                 if (this.goal == null || (this.goal.isInGoal(ctx.playerFeet()) && this.goal.isInGoal(baritone.getPathingBehavior().pathStart()))) {
                     onLostControl(); // we're there xd
+                    if (Baritone.settings().disconnectOnArrival.value) {
+                        ctx.world().sendQuittingDisconnectingPacket();
+                    }
                     return new PathingCommand(this.goal, PathingCommandType.CANCEL_AND_SET_GOAL);
                 }
                 return new PathingCommand(this.goal, PathingCommandType.SET_GOAL_AND_PATH);

File: src/api/java/baritone/api/utils/IPlayerController.java
Patch:
@@ -50,4 +50,6 @@ default double getBlockReachDistance() {
     }
 
     EnumActionResult processRightClickBlock(EntityPlayerSP player, World world, BlockPos pos, EnumFacing direction, Vec3d vec, EnumHand hand);
+
+    EnumActionResult processRightClick(EntityPlayerSP player, World world, EnumHand hand);
 }

File: src/main/java/baritone/utils/BlockPlaceHelper.java
Patch:
@@ -46,6 +46,9 @@ public void tick(boolean rightClickRequested) {
                 ctx.player().swingArm(hand);
                 return;
             }
+            if (!ctx.player().getHeldItem(hand).isEmpty() && ctx.playerController().processRightClick(ctx.player(), ctx.world(), hand) == EnumActionResult.SUCCESS) {
+                return;
+            }
         }
     }
 }

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -234,7 +234,7 @@ public MovementState updateState(MovementState state) {
             }
             Block low = BlockStateInterface.get(ctx, src).getBlock();
             Block high = BlockStateInterface.get(ctx, src.up()).getBlock();
-            if (!ctx.player().onGround && (low == Blocks.VINE || low == Blocks.LADDER || high == Blocks.VINE || high == Blocks.LADDER)) {
+            if (ctx.player().posY > src.y + 0.1D && !ctx.player().onGround && (low == Blocks.VINE || low == Blocks.LADDER || high == Blocks.VINE || high == Blocks.LADDER)) {
                 // hitting W could cause us to climb the ladder instead of going forward
                 // wait until we're on the ground
                 return state;

File: src/main/java/baritone/process/CustomGoalProcess.java
Patch:
@@ -88,7 +88,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
                     onLostControl();
                     return new PathingCommand(this.goal, PathingCommandType.CANCEL_AND_SET_GOAL);
                 }
-                if (this.goal == null || (this.goal.isInGoal(ctx.playerFeet()) && ctx.player().onGround)) {
+                if (this.goal == null || (this.goal.isInGoal(ctx.playerFeet()) && this.goal.isInGoal(baritone.getPathingBehavior().pathStart()))) {
                     onLostControl(); // we're there xd
                     return new PathingCommand(this.goal, PathingCommandType.CANCEL_AND_SET_GOAL);
                 }

File: src/main/java/baritone/process/GetToBlockProcess.java
Patch:
@@ -101,7 +101,7 @@ public boolean isInGoal(int x, int y, int z) {
             CalculationContext context = new CalculationContext(baritone, true);
             Baritone.getExecutor().execute(() -> rescan(current, context));
         }
-        if (goal.isInGoal(ctx.playerFeet()) && ctx.player().onGround && isSafeToCancel) {
+        if (goal.isInGoal(ctx.playerFeet()) && goal.isInGoal(baritone.getPathingBehavior().pathStart()) && isSafeToCancel) {
             // we're there
             if (rightClickOnArrival(gettingTo)) {
                 if (rightClick()) {

File: src/api/java/baritone/api/utils/RotationUtils.java
Patch:
@@ -179,7 +179,7 @@ public static Optional<Rotation> reachable(EntityPlayerSP entity, BlockPos pos,
         }
 
         IBlockState state = entity.world.getBlockState(pos);
-        VoxelShape shape = state.getRaytraceShape(entity.world, pos);
+        VoxelShape shape = state.getShape(entity.world, pos);
         for (Vec3d sideOffset : BLOCK_SIDE_MULTIPLIERS) {
             double xDiff = shape.getStart(EnumFacing.Axis.X) * sideOffset.x + shape.getEnd(EnumFacing.Axis.X) * (1 - sideOffset.x);
             double yDiff = shape.getStart(EnumFacing.Axis.Y) * sideOffset.y + shape.getEnd(EnumFacing.Axis.Y) * (1 - sideOffset.y);

File: src/main/java/baritone/pathing/movement/movements/MovementPillar.java
Patch:
@@ -163,7 +163,6 @@ public MovementState updateState(MovementState state) {
                 state.setInput(Input.MOVE_FORWARD, true);
             }
             if (ctx.playerFeet().equals(dest)) {
-                logDebug("wtf2");
                 return state.setStatus(MovementStatus.SUCCESS);
             }
             return state;
@@ -186,7 +185,6 @@ public MovementState updateState(MovementState state) {
             }
 
             if (ctx.playerFeet().equals(against.up()) || ctx.playerFeet().equals(dest)) {
-                logDebug("wtf3");
                 return state.setStatus(MovementStatus.SUCCESS);
             }
             if (MovementHelper.isBottomSlab(BlockStateInterface.get(ctx, src.down()))) {

File: src/main/java/baritone/process/CustomGoalProcess.java
Patch:
@@ -88,7 +88,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
                     onLostControl();
                     return new PathingCommand(this.goal, PathingCommandType.CANCEL_AND_SET_GOAL);
                 }
-                if (this.goal == null || (this.goal.isInGoal(ctx.playerFeet()) && ctx.player().onGround)) {
+                if (this.goal == null || (this.goal.isInGoal(ctx.playerFeet()) && this.goal.isInGoal(baritone.getPathingBehavior().pathStart()))) {
                     onLostControl(); // we're there xd
                     return new PathingCommand(this.goal, PathingCommandType.CANCEL_AND_SET_GOAL);
                 }

File: src/main/java/baritone/process/GetToBlockProcess.java
Patch:
@@ -101,7 +101,7 @@ public boolean isInGoal(int x, int y, int z) {
             CalculationContext context = new CalculationContext(baritone, true);
             Baritone.getExecutor().execute(() -> rescan(current, context));
         }
-        if (goal.isInGoal(ctx.playerFeet()) && ctx.player().onGround && isSafeToCancel) {
+        if (goal.isInGoal(ctx.playerFeet()) && goal.isInGoal(baritone.getPathingBehavior().pathStart()) && isSafeToCancel) {
             // we're there
             if (rightClickOnArrival(gettingTo)) {
                 if (rightClick()) {

File: src/main/java/baritone/utils/PathRenderer.java
Patch:
@@ -23,7 +23,6 @@
 import baritone.api.pathing.calc.IPath;
 import baritone.api.pathing.goals.*;
 import baritone.api.utils.BetterBlockPos;
-import baritone.api.utils.IPlayerContext;
 import baritone.api.utils.interfaces.IGoalRenderPos;
 import baritone.behavior.PathingBehavior;
 import baritone.pathing.path.PathExecutor;
@@ -34,7 +33,6 @@
 import net.minecraft.client.renderer.tileentity.TileEntityBeaconRenderer;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.entity.Entity;
-import net.minecraft.init.Blocks;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
@@ -224,6 +222,8 @@ public static void drawManySelectionBoxes(Entity player, Collection<BlockPos> po
 
             VoxelShape shape = state.getShape(player.world, pos);
             AxisAlignedBB toDraw = shape.isEmpty() ? VoxelShapes.fullCube().getBoundingBox() : shape.getBoundingBox();
+            System.out.println("Shape is " + shape);
+            System.out.println("Drawing " + toDraw);
 
             toDraw = toDraw.expand(expand, expand, expand).offset(-mc.getRenderManager().viewerPosX, -mc.getRenderManager().viewerPosY, -mc.getRenderManager().viewerPosZ);
             BUFFER.begin(GL_LINE_STRIP, DefaultVertexFormats.POSITION);

File: src/main/java/baritone/process/CustomGoalProcess.java
Patch:
@@ -88,7 +88,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
                     onLostControl();
                     return new PathingCommand(this.goal, PathingCommandType.CANCEL_AND_SET_GOAL);
                 }
-                if (this.goal == null || this.goal.isInGoal(ctx.playerFeet())) {
+                if (this.goal == null || (this.goal.isInGoal(ctx.playerFeet()) && ctx.player().onGround)) {
                     onLostControl(); // we're there xd
                     return new PathingCommand(this.goal, PathingCommandType.CANCEL_AND_SET_GOAL);
                 }

File: src/main/java/baritone/process/GetToBlockProcess.java
Patch:
@@ -101,7 +101,7 @@ public boolean isInGoal(int x, int y, int z) {
             CalculationContext context = new CalculationContext(baritone, true);
             Baritone.getExecutor().execute(() -> rescan(current, context));
         }
-        if (goal.isInGoal(ctx.playerFeet()) && isSafeToCancel) {
+        if (goal.isInGoal(ctx.playerFeet()) && ctx.player().onGround && isSafeToCancel) {
             // we're there
             if (rightClickOnArrival(gettingTo)) {
                 if (rightClick()) {

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -188,7 +188,7 @@ static boolean isReplacable(int x, int y, int z, IBlockState state, BlockStateIn
          *     }
          */
         Block block = state.getBlock();
-        if (block == Blocks.AIR || isWater(state)) {
+        if (block == Blocks.AIR) {
             // early return for common cases hehe
             return true;
         }
@@ -500,7 +500,7 @@ static boolean isLiquid(IBlockState blockState) {
     }
 
     static boolean possiblyFlowing(IBlockState state) {
-        IFluidState fluidState  = state.getFluidState();
+        IFluidState fluidState = state.getFluidState();
         return fluidState.getFluid() instanceof FlowingFluid
                 && fluidState.getFluid().getLevel(fluidState) != 8;
     }

File: src/main/java/baritone/process/CustomGoalProcess.java
Patch:
@@ -88,7 +88,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
                     onLostControl();
                     return new PathingCommand(this.goal, PathingCommandType.CANCEL_AND_SET_GOAL);
                 }
-                if (this.goal == null || this.goal.isInGoal(ctx.playerFeet())) {
+                if (this.goal == null || (this.goal.isInGoal(ctx.playerFeet()) && ctx.player().onGround)) {
                     onLostControl(); // we're there xd
                     return new PathingCommand(this.goal, PathingCommandType.CANCEL_AND_SET_GOAL);
                 }

File: src/main/java/baritone/process/GetToBlockProcess.java
Patch:
@@ -101,7 +101,7 @@ public boolean isInGoal(int x, int y, int z) {
             CalculationContext context = new CalculationContext(baritone, true);
             Baritone.getExecutor().execute(() -> rescan(current, context));
         }
-        if (goal.isInGoal(ctx.playerFeet()) && isSafeToCancel) {
+        if (goal.isInGoal(ctx.playerFeet()) && ctx.player().onGround && isSafeToCancel) {
             // we're there
             if (rightClickOnArrival(gettingTo)) {
                 if (rightClick()) {

File: src/launch/java/baritone/launch/BaritoneTweaker.java
Patch:
@@ -31,7 +31,6 @@
  * @author Brady
  * @since 7/31/2018
  */
-@Deprecated
 public class BaritoneTweaker extends SimpleTweaker {
 
     @Override

File: src/main/java/baritone/cache/WorldProvider.java
Patch:
@@ -93,7 +93,7 @@ public final void initWorld(DimensionType dimension) {
         } catch (IOException ignored) {}
 
         // We will actually store the world data in a subfolder: "DIM<id>"
-        Path dir = new File(directory, "DIM" + dimension).toPath();
+        Path dir = new File(directory, "DIM" + dimension.getId()).toPath();
         if (!Files.exists(dir)) {
             try {
                 Files.createDirectories(dir);

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -502,15 +502,15 @@ static boolean isLiquid(IBlockState blockState) {
     static boolean possiblyFlowing(IBlockState state) {
         IFluidState fluidState  = state.getFluidState();
         return fluidState.getFluid() instanceof FlowingFluid
-                && state.get(FlowingFluid.LEVEL_1_8) != 0;
+                && fluidState.getFluid().getLevel(fluidState) != 8;
     }
 
     static boolean isFlowing(int x, int y, int z, IBlockState state, BlockStateInterface bsi) {
         IFluidState fluidState = state.getFluidState();
         if (!(fluidState.getFluid() instanceof FlowingFluid)) {
             return false;
         }
-        if (fluidState.get(FlowingFluid.LEVEL_1_8) != 0) {
+        if (fluidState.getFluid().getLevel(fluidState) != 8) {
             return true;
         }
         return possiblyFlowing(bsi.get0(x + 1, y, z))

File: src/launch/java/baritone/launch/mixins/MixinRenderChunk.java
Patch:
@@ -36,7 +36,7 @@
 @Mixin(RenderChunk.class)
 public class MixinRenderChunk {
 
-    // TODO: Resolve this issue
+    // TODO: (1.13.2) Resolve this issue
     // Looks like generateCache will return null if the chunk is empty, so we're probably going to want to hook that method
     /*
     @Redirect(

File: src/main/java/baritone/utils/GuiClickMeme.java
Patch:
@@ -91,7 +91,7 @@ public void onRender() {
     }
 
     public Vec3d toWorld(double x, double y, double z) {
-        // TODO: Fix unproject
+        // TODO: (1.13.2) Fix unproject
 //        boolean result = GLU.gluUnProject((float) x, (float) y, (float) z, MODELVIEW, PROJECTION, VIEWPORT, (FloatBuffer) TO_WORLD_BUFFER.clear());
 //        if (result) {
 //            return new Vec3d(TO_WORLD_BUFFER.get(0), TO_WORLD_BUFFER.get(1), TO_WORLD_BUFFER.get(2));

File: src/launch/java/baritone/launch/mixins/MixinChunkRenderContainer.java
Patch:
@@ -45,7 +45,7 @@ private BlockPos getPosition(RenderChunk renderChunkIn) {
         if (Baritone.settings().renderCachedChunks.value && Minecraft.getInstance().getIntegratedServer() == null && Minecraft.getInstance().world.getChunk(renderChunkIn.getPosition()).isEmpty()) {
             GlStateManager.enableAlphaTest();
             GlStateManager.enableBlend();
-            GL14.glBlendColor(0, 0, 0, Baritone.settings().cachedChunksOpacity.get());
+            GL14.glBlendColor(0, 0, 0, Baritone.settings().cachedChunksOpacity.value);
             GlStateManager.blendFuncSeparate(GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, GL_ONE, GL_ZERO);
         }
         return renderChunkIn.getPosition();

File: src/main/java/baritone/utils/PathRenderer.java
Patch:
@@ -134,7 +134,7 @@ public static void drawPath(IPath path, int startIndex, Entity player, float par
         GlStateManager.enableBlend();
         GlStateManager.blendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);
         GlStateManager.color4f(color.getColorComponents(null)[0], color.getColorComponents(null)[1], color.getColorComponents(null)[2], 0.4F);
-        GlStateManager.lineWidth(Baritone.settings().pathRenderLineWidthPixels.get());
+        GlStateManager.lineWidth(Baritone.settings().pathRenderLineWidthPixels.value);
         GlStateManager.disableTexture2D();
         GlStateManager.depthMask(false);
         if (Baritone.settings().renderPathIgnoreDepth.value) {
@@ -348,7 +348,7 @@ public static void drawDankLitGoalBox(Entity player, Goal goal, float partialTic
         GlStateManager.enableBlend();
         GlStateManager.blendFuncSeparate(770, 771, 1, 0);
         GlStateManager.color4f(color.getColorComponents(null)[0], color.getColorComponents(null)[1], color.getColorComponents(null)[2], 0.6F);
-        GlStateManager.lineWidth(Baritone.settings().goalRenderLineWidthPixels.get());
+        GlStateManager.lineWidth(Baritone.settings().goalRenderLineWidthPixels.value);
         GlStateManager.disableTexture2D();
         GlStateManager.depthMask(false);
         if (Baritone.settings().renderGoalIgnoreDepth.value) {

File: src/main/java/baritone/utils/PathRenderer.java
Patch:
@@ -62,7 +62,7 @@ public static void render(RenderEvent event, PathingBehavior behavior) {
         float partialTicks = event.getPartialTicks();
         Goal goal = behavior.getGoal();
         if (mc.currentScreen instanceof GuiClickMeme) {
-            ((GuiClickMeme) mc.currentScreen).onRender(partialTicks);
+            ((GuiClickMeme) mc.currentScreen).onRender();
         }
 
         int thisPlayerDimension = behavior.baritone.getPlayerContext().world().getDimension().getType().getId();

File: src/launch/java/baritone/launch/mixins/MixinChunkRenderContainer.java
Patch:
@@ -41,7 +41,7 @@ public class MixinChunkRenderContainer {
             )
     )
     private BlockPos getPosition(RenderChunk renderChunkIn) {
-        if (Baritone.settings().renderCachedChunks.get() && Minecraft.getMinecraft().world.getChunk(renderChunkIn.getPosition()).isEmpty()) {
+        if (Baritone.settings().renderCachedChunks.get() && Minecraft.getMinecraft().getIntegratedServer() == null && Minecraft.getMinecraft().world.getChunk(renderChunkIn.getPosition()).isEmpty()) {
             GlStateManager.enableAlpha();
             GlStateManager.enableBlend();
             GL14.glBlendColor(0, 0, 0, Baritone.settings().cachedChunksOpacity.get());

File: src/launch/java/baritone/launch/mixins/MixinChunkRenderWorker.java
Patch:
@@ -20,6 +20,7 @@
 import baritone.Baritone;
 import baritone.api.BaritoneAPI;
 import baritone.api.utils.IPlayerContext;
+import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.chunk.ChunkRenderWorker;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.world.World;
@@ -42,7 +43,7 @@ public abstract class MixinChunkRenderWorker {
             )
     )
     private boolean isChunkExisting(ChunkRenderWorker worker, BlockPos pos, World world) {
-        if (Baritone.settings().renderCachedChunks.get()) {
+        if (Baritone.settings().renderCachedChunks.get() && Minecraft.getMinecraft().getIntegratedServer() == null) {
             Baritone baritone = (Baritone) BaritoneAPI.getProvider().getPrimaryBaritone();
             IPlayerContext ctx = baritone.getPlayerContext();
             if (ctx.player() != null && ctx.world() != null && baritone.bsi != null) {

File: src/launch/java/baritone/launch/mixins/MixinRenderChunk.java
Patch:
@@ -21,6 +21,7 @@
 import baritone.api.BaritoneAPI;
 import baritone.api.utils.IPlayerContext;
 import net.minecraft.block.state.IBlockState;
+import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.chunk.RenderChunk;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.world.ChunkCache;
@@ -46,7 +47,7 @@ private boolean isEmpty(ChunkCache chunkCache) {
         if (!chunkCache.isEmpty()) {
             return false;
         }
-        if (Baritone.settings().renderCachedChunks.get()) {
+        if (Baritone.settings().renderCachedChunks.get() && Minecraft.getMinecraft().getIntegratedServer() == null) {
             Baritone baritone = (Baritone) BaritoneAPI.getProvider().getPrimaryBaritone();
             IPlayerContext ctx = baritone.getPlayerContext();
             if (ctx.player() != null && ctx.world() != null && baritone.bsi != null) {
@@ -75,7 +76,7 @@ private boolean isEmpty(ChunkCache chunkCache) {
             )
     )
     private IBlockState getBlockState(ChunkCache chunkCache, BlockPos pos) {
-        if (Baritone.settings().renderCachedChunks.get()) {
+        if (Baritone.settings().renderCachedChunks.get() && Minecraft.getMinecraft().getIntegratedServer() == null) {
             Baritone baritone = (Baritone) BaritoneAPI.getProvider().getPrimaryBaritone();
             IPlayerContext ctx = baritone.getPlayerContext();
             if (ctx.player() != null && ctx.world() != null && baritone.bsi != null) {

File: src/launch/java/baritone/launch/mixins/MixinRenderList.java
Patch:
@@ -18,6 +18,7 @@
 package baritone.launch.mixins;
 
 import baritone.Baritone;
+import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.RenderList;
 import org.spongepowered.asm.mixin.Mixin;
@@ -37,7 +38,7 @@ public class MixinRenderList {
             )
     )
     private void popMatrix() {
-        if (Baritone.settings().renderCachedChunks.get()) {
+        if (Baritone.settings().renderCachedChunks.get() && Minecraft.getMinecraft().getIntegratedServer() == null) {
             // reset the blend func to normal (not dependent on constant alpha)
             GlStateManager.tryBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);
         }

File: src/launch/java/baritone/launch/mixins/MixinVboRenderList.java
Patch:
@@ -18,6 +18,7 @@
 package baritone.launch.mixins;
 
 import baritone.Baritone;
+import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.VboRenderList;
 import org.spongepowered.asm.mixin.Mixin;
@@ -37,7 +38,7 @@ public class MixinVboRenderList {
             )
     )
     private void popMatrix() {
-        if (Baritone.settings().renderCachedChunks.get()) {
+        if (Baritone.settings().renderCachedChunks.get() && Minecraft.getMinecraft().getIntegratedServer() == null) {
             // reset the blend func to normal (not dependent on constant alpha)
             GlStateManager.tryBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);
         }

File: src/main/java/baritone/behavior/LookBehavior.java
Patch:
@@ -109,7 +109,7 @@ public void onPlayerRotationMove(RotationMoveEvent event) {
 
             // If we have antiCheatCompatibility on, we're going to use the target value later in onPlayerUpdate()
             // Also the type has to be MOTION_UPDATE because that is called after JUMP
-            if (!Baritone.settings().antiCheatCompatibility.get() && event.getType() == RotationMoveEvent.Type.MOTION_UPDATE) {
+            if (!Baritone.settings().antiCheatCompatibility.get() && event.getType() == RotationMoveEvent.Type.MOTION_UPDATE && !this.force) {
                 this.target = null;
             }
         }

File: src/main/java/baritone/behavior/MemoryBehavior.java
Patch:
@@ -25,7 +25,6 @@
 import baritone.api.event.events.type.EventState;
 import baritone.cache.ContainerMemory;
 import baritone.cache.Waypoint;
-import baritone.pathing.movement.CalculationContext;
 import baritone.utils.BlockStateInterface;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockBed;
@@ -196,7 +195,7 @@ private ContainerMemory getCurrentContainer() {
     }
 
     private BlockPos neighboringConnectedBlock(BlockPos in) {
-        BlockStateInterface bsi = new CalculationContext(baritone).bsi;
+        BlockStateInterface bsi = baritone.bsi;
         Block block = bsi.get0(in).getBlock();
         if (block != Blocks.TRAPPED_CHEST && block != Blocks.CHEST) {
             return null; // other things that have contents, but can be placed adjacent without combining

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -232,14 +232,14 @@ public boolean onTick() {
             // do this only once, when the movement starts, and deliberately get the cost as cached when this path was calculated, not the cost as it is right now
             currentMovementOriginalCostEstimate = movement.getCost();
             for (int i = 1; i < Baritone.settings().costVerificationLookahead.get() && pathPosition + i < path.length() - 1; i++) {
-                if (path.movements().get(pathPosition + i).calculateCostWithoutCaching() >= ActionCosts.COST_INF && canCancel) {
+                if (((Movement) path.movements().get(pathPosition + i)).calculateCost(behavior.secretInternalGetCalculationContext()) >= ActionCosts.COST_INF && canCancel) {
                     logDebug("Something has changed in the world and a future movement has become impossible. Cancelling.");
                     cancel();
                     return true;
                 }
             }
         }
-        double currentCost = movement.recalculateCost();
+        double currentCost = ((Movement) movement).recalculateCost(behavior.secretInternalGetCalculationContext());
         if (currentCost >= ActionCosts.COST_INF && canCancel) {
             logDebug("Something has changed in the world and this movement has become impossible. Cancelling.");
             cancel();

File: src/main/java/baritone/process/BuilderProcess.java
Patch:
@@ -465,6 +465,9 @@ public boolean isInGoal(int x, int y, int z) {
     }
 
     public Goal placementgoal(BlockPos pos, BuilderCalculationContext bcc) {
+        if (ctx.world().getBlockState(pos).getBlock() != Blocks.AIR) {
+            return new GoalPlace(pos);
+        }
         boolean allowSameLevel = ctx.world().getBlockState(pos.up()).getBlock() != Blocks.AIR;
         for (EnumFacing facing : Movement.HORIZONTALS_BUT_ALSO_DOWN____SO_EVERY_DIRECTION_EXCEPT_UP) {
             if (MovementHelper.canPlaceAgainst(ctx, pos.offset(facing)) && ctx.world().mayPlace(bcc.getSchematic(pos.getX(), pos.getY(), pos.getZ()).getBlock(), pos, false, facing, null)) {

File: src/main/java/baritone/utils/ExampleBaritoneControl.java
Patch:
@@ -558,7 +558,7 @@ public boolean isInGoal(int x, int y, int z) {
             while (moves.contains(null)) {
                 moves.remove(null);
             }
-            moves.sort(Comparator.comparingDouble(Movement::getCost));
+            moves.sort(Comparator.comparingDouble(move -> move.getCost(new CalculationContext(baritone))));
             for (Movement move : moves) {
                 String[] parts = move.getClass().toString().split("\\.");
                 double cost = move.getCost();

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -178,7 +178,7 @@ public MovementState updateState(MovementState state) {
             float pitchToBreak = state.getTarget().getRotation().get().getPitch();
 
             state.setTarget(new MovementState.MovementTarget(new Rotation(yawToDest, pitchToBreak), true));
-            return state.setInput(Input.MOVE_FORWARD, true);
+            return state.setInput(Input.MOVE_FORWARD, true).setInput(Input.SPRINT, true);
         }
 
         //sneak may have been set to true in the PREPPING state while mining an adjacent block

File: src/main/java/baritone/behavior/LookBehavior.java
Patch:
@@ -103,7 +103,7 @@ public void pig() {
 
     @Override
     public void onPlayerRotationMove(RotationMoveEvent event) {
-        if (this.target != null && !this.force) {
+        if (this.target != null) {
 
             event.setYaw(this.target.getYaw());
 

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -541,6 +541,9 @@ private static boolean sprintableAscend(IPlayerContext ctx, MovementTraverse cur
         if (!MovementHelper.canWalkOn(ctx, current.getDest().down())) {
             return false;
         }
+        if (!MovementHelper.canWalkOn(ctx, next.getDest().down())) {
+            return false;
+        }
         for (int x = 0; x < 2; x++) {
             for (int y = 0; y < 3; y++) {
                 BlockPos chk = current.getSrc().up(y);

File: src/main/java/baritone/pathing/movement/movements/MovementFall.java
Patch:
@@ -78,7 +78,7 @@ public MovementState updateState(MovementState state) {
         }
 
         BlockPos playerFeet = ctx.playerFeet();
-        Rotation toDest = RotationUtils.calcRotationFromVec3d(ctx.playerHead(), VecUtils.getBlockPosCenter(dest),ctx.playerRotations());
+        Rotation toDest = RotationUtils.calcRotationFromVec3d(ctx.playerHead(), VecUtils.getBlockPosCenter(dest), ctx.playerRotations());
         Rotation targetRotation = null;
         Block destBlock = ctx.world().getBlockState(dest).getBlock();
         boolean isWater = destBlock == Blocks.WATER || destBlock == Blocks.FLOWING_WATER;
@@ -141,7 +141,7 @@ public MovementState updateState(MovementState state) {
         }
         if (targetRotation == null) {
             Vec3d destCenterOffset = new Vec3d(destCenter.x + 0.125 * avoid.getX(), destCenter.y, destCenter.z + 0.125 * avoid.getZ());
-            state.setTarget(new MovementTarget(RotationUtils.calcRotationFromVec3d(ctx.playerHead(), destCenterOffset,ctx.playerRotations()), false));
+            state.setTarget(new MovementTarget(RotationUtils.calcRotationFromVec3d(ctx.playerHead(), destCenterOffset, ctx.playerRotations()), false));
         }
         return state;
     }

File: src/main/java/baritone/pathing/movement/movements/MovementPillar.java
Patch:
@@ -151,7 +151,7 @@ public MovementState updateState(MovementState state) {
         IBlockState fromDown = BlockStateInterface.get(ctx, src);
         if (MovementHelper.isWater(fromDown.getBlock()) && MovementHelper.isWater(ctx, dest)) {
             // stay centered while swimming up a water column
-            state.setTarget(new MovementState.MovementTarget(RotationUtils.calcRotationFromVec3d(ctx.playerHead(), VecUtils.getBlockPosCenter(dest),ctx.playerRotations()), false));
+            state.setTarget(new MovementState.MovementTarget(RotationUtils.calcRotationFromVec3d(ctx.playerHead(), VecUtils.getBlockPosCenter(dest), ctx.playerRotations()), false));
             Vec3d destCenter = VecUtils.getBlockPosCenter(dest);
             if (Math.abs(ctx.player().posX - destCenter.x) > 0.2 || Math.abs(ctx.player().posZ - destCenter.z) > 0.2) {
                 state.setInput(Input.MOVE_FORWARD, true);

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -479,6 +479,9 @@ private Tuple<Vec3d, BlockPos> overrideFall(MovementFall movement) {
         if (dir.getY() < -3) {
             return null;
         }
+        if (!movement.toBreakCached.isEmpty()) {
+            return null; // it's breaking
+        }
         Vec3i flatDir = new Vec3i(dir.getX(), 0, dir.getZ());
         int i;
         outer:

File: src/main/java/baritone/pathing/movement/movements/MovementAscend.java
Patch:
@@ -200,7 +200,7 @@ public MovementState updateState(MovementState state) {
         return state.setInput(Input.JUMP, true);
     }
 
-    private boolean headBonkClear() {
+    public boolean headBonkClear() {
         BetterBlockPos startUp = src.up(2);
         for (int i = 0; i < 4; i++) {
             BetterBlockPos check = startUp.offset(EnumFacing.byHorizontalIndex(i));

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -160,7 +160,7 @@ protected boolean prepared(MovementState state) {
                 //i dont care if theres snow in the way!!!!!!!
                 //you dont own me!!!!
                 state.setTarget(new MovementState.MovementTarget(RotationUtils.calcRotationFromVec3d(ctx.player().getPositionEyes(1.0F),
-                        VecUtils.getBlockPosCenter(blockPos)), true)
+                        VecUtils.getBlockPosCenter(blockPos), ctx.playerRotations()), true)
                 );
                 // don't check selectedblock on this one, this is a fallback when we can't see any face directly, it's intended to be breaking the "incorrect" block
                 state.setInput(Input.CLICK_LEFT, true);

File: src/main/java/baritone/pathing/movement/movements/MovementFall.java
Patch:
@@ -78,7 +78,7 @@ public MovementState updateState(MovementState state) {
         }
 
         BlockPos playerFeet = ctx.playerFeet();
-        Rotation toDest = RotationUtils.calcRotationFromVec3d(ctx.playerHead(), VecUtils.getBlockPosCenter(dest));
+        Rotation toDest = RotationUtils.calcRotationFromVec3d(ctx.playerHead(), VecUtils.getBlockPosCenter(dest),ctx.playerRotations());
         Rotation targetRotation = null;
         Block destBlock = ctx.world().getBlockState(dest).getBlock();
         boolean isWater = destBlock == Blocks.WATER || destBlock == Blocks.FLOWING_WATER;
@@ -141,7 +141,7 @@ public MovementState updateState(MovementState state) {
         }
         if (targetRotation == null) {
             Vec3d destCenterOffset = new Vec3d(destCenter.x + 0.125 * avoid.getX(), destCenter.y, destCenter.z + 0.125 * avoid.getZ());
-            state.setTarget(new MovementTarget(RotationUtils.calcRotationFromVec3d(ctx.playerHead(), destCenterOffset), false));
+            state.setTarget(new MovementTarget(RotationUtils.calcRotationFromVec3d(ctx.playerHead(), destCenterOffset,ctx.playerRotations()), false));
         }
         return state;
     }

File: src/main/java/baritone/pathing/movement/movements/MovementPillar.java
Patch:
@@ -151,7 +151,7 @@ public MovementState updateState(MovementState state) {
         IBlockState fromDown = BlockStateInterface.get(ctx, src);
         if (MovementHelper.isWater(fromDown.getBlock()) && MovementHelper.isWater(ctx, dest)) {
             // stay centered while swimming up a water column
-            state.setTarget(new MovementState.MovementTarget(RotationUtils.calcRotationFromVec3d(ctx.playerHead(), VecUtils.getBlockPosCenter(dest)), false));
+            state.setTarget(new MovementState.MovementTarget(RotationUtils.calcRotationFromVec3d(ctx.playerHead(), VecUtils.getBlockPosCenter(dest),ctx.playerRotations()), false));
             Vec3d destCenter = VecUtils.getBlockPosCenter(dest);
             if (Math.abs(ctx.player().posX - destCenter.x) > 0.2 || Math.abs(ctx.player().posZ - destCenter.z) > 0.2) {
                 state.setInput(Input.MOVE_FORWARD, true);

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -174,7 +174,7 @@ public MovementState updateState(MovementState state) {
 
             // combine the yaw to the center of the destination, and the pitch to the specific block we're trying to break
             // it's safe to do this since the two blocks we break (in a traverse) are right on top of each other and so will have the same yaw
-            float yawToDest = RotationUtils.calcRotationFromVec3d(ctx.playerHead(), VecUtils.calculateBlockCenter(ctx.world(), dest)).getYaw();
+            float yawToDest = RotationUtils.calcRotationFromVec3d(ctx.playerHead(), VecUtils.calculateBlockCenter(ctx.world(), dest), ctx.playerRotations()).getYaw();
             float pitchToBreak = state.getTarget().getRotation().get().getPitch();
 
             state.setTarget(new MovementState.MovementTarget(new Rotation(yawToDest, pitchToBreak), true));
@@ -198,7 +198,7 @@ public MovementState updateState(MovementState state) {
                 isDoorActuallyBlockingUs = true;
             }
             if (isDoorActuallyBlockingUs && !(Blocks.IRON_DOOR.equals(pb0.getBlock()) || Blocks.IRON_DOOR.equals(pb1.getBlock()))) {
-                return state.setTarget(new MovementState.MovementTarget(RotationUtils.calcRotationFromVec3d(ctx.playerHead(), VecUtils.calculateBlockCenter(ctx.world(), positionsToBreak[0])), true))
+                return state.setTarget(new MovementState.MovementTarget(RotationUtils.calcRotationFromVec3d(ctx.playerHead(), VecUtils.calculateBlockCenter(ctx.world(), positionsToBreak[0]), ctx.playerRotations()), true))
                         .setInput(Input.CLICK_RIGHT, true);
             }
         }
@@ -212,7 +212,7 @@ public MovementState updateState(MovementState state) {
             }
 
             if (blocked != null) {
-                return state.setTarget(new MovementState.MovementTarget(RotationUtils.calcRotationFromVec3d(ctx.playerHead(), VecUtils.calculateBlockCenter(ctx.world(), blocked)), true))
+                return state.setTarget(new MovementState.MovementTarget(RotationUtils.calcRotationFromVec3d(ctx.playerHead(), VecUtils.calculateBlockCenter(ctx.world(), blocked), ctx.playerRotations()), true))
                         .setInput(Input.CLICK_RIGHT, true);
             }
         }

File: src/main/java/baritone/behavior/PathingBehavior.java
Patch:
@@ -378,7 +378,7 @@ public BetterBlockPos pathStart() { // TODO move to a helper or util class
                     }
                     if (MovementHelper.canWalkOn(ctx, possibleSupport.down()) && MovementHelper.canWalkThrough(ctx, possibleSupport) && MovementHelper.canWalkThrough(ctx, possibleSupport.up())) {
                         // this is plausible
-                        logDebug("Faking path start assuming player is standing off the edge of a block");
+                        //logDebug("Faking path start assuming player is standing off the edge of a block");
                         return possibleSupport;
                     }
                 }
@@ -387,7 +387,7 @@ public BetterBlockPos pathStart() { // TODO move to a helper or util class
                 // !onGround
                 // we're in the middle of a jump
                 if (MovementHelper.canWalkOn(ctx, feet.down().down())) {
-                    logDebug("Faking path start assuming player is midair and falling");
+                    //logDebug("Faking path start assuming player is midair and falling");
                     return feet.down();
                 }
             }

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -398,7 +398,7 @@ private boolean shouldSprintNextTick() {
         IMovement current = path.movements().get(pathPosition);
         if (current instanceof MovementDescend) {
 
-            if (((MovementDescend) current).safeMode()) {
+            if (((MovementDescend) current).safeMode() && !((MovementDescend) current).skipToAscend()) {
                 logDebug("Sprinting would be unsafe");
                 return false;
             }

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -481,7 +481,7 @@ public final class Settings {
     /**
      * Whether or not to use the "#" command prefix
      */
-    public final Setting<Boolean> prefix = new Setting<>(false);
+    public final Setting<Boolean> prefixControl = new Setting<>(true);
 
     /**
      * Don't stop walking forward when you need to break blocks in your way

File: src/main/java/baritone/pathing/movement/movements/MovementPillar.java
Patch:
@@ -35,6 +35,8 @@
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.Vec3d;
 
+import java.util.Objects;
+
 public class MovementPillar extends Movement {
 
     public MovementPillar(IBaritone baritone, BetterBlockPos start, BetterBlockPos end) {
@@ -224,7 +226,7 @@ public MovementState updateState(MovementState state) {
                 if (!(fr instanceof BlockAir || fr.isReplaceable(ctx.world(), src))) {
                     state.setInput(Input.CLICK_LEFT, true);
                     blockIsThere = false;
-                } else if (ctx.player().isSneaking()) { // 1 tick after we're able to place
+                } else if (ctx.player().isSneaking() && (Objects.equals(src.down(), ctx.objectMouseOver().getBlockPos()) || Objects.equals(src, ctx.objectMouseOver().getBlockPos()))) {
                     state.setInput(Input.CLICK_RIGHT, true);
                 }
             }

File: src/api/java/baritone/api/pathing/path/IPathExecutor.java
Patch:
@@ -26,4 +26,6 @@
 public interface IPathExecutor {
 
     IPath getPath();
+
+    int getPosition();
 }

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -461,6 +461,7 @@ private void cancel() {
         failed = true;
     }
 
+    @Override
     public int getPosition() {
         return pathPosition;
     }

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -123,7 +123,7 @@ public MovementStatus update() {
                 baritone.getLookBehavior().updateTarget(
                         rotation,
                         currentState.getTarget().hasToForceRotations()));
-
+        baritone.getInputOverrideHandler().clearAllKeys();
         currentState.getInputStates().forEach((input, forced) -> {
             baritone.getInputOverrideHandler().setInputForceState(input, forced);
         });

File: src/launch/java/baritone/launch/mixins/MixinEntityPlayerSP.java
Patch:
@@ -98,9 +98,8 @@ private boolean isAllowFlying(PlayerCapabilities capabilities) {
             )
     )
     private boolean isKeyDown(KeyBinding keyBinding) {
-        EntityPlayerSP self = (EntityPlayerSP) (Object) this;
-        SprintStateEvent event = new SprintStateEvent(self);
-        BaritoneAPI.getProvider().getBaritoneForPlayer(self).getGameEventHandler().onPlayerSprintState(event);
+        SprintStateEvent event = new SprintStateEvent();
+        BaritoneAPI.getProvider().getBaritoneForPlayer((EntityPlayerSP) (Object) this).getGameEventHandler().onPlayerSprintState(event);
         return event.getState() == null ? keyBinding.isKeyDown() : event.getState();
     }
 }

File: src/api/java/baritone/api/utils/PathCalculationResult.java
Patch:
@@ -19,6 +19,7 @@
 
 import baritone.api.pathing.calc.IPath;
 
+import java.util.Objects;
 import java.util.Optional;
 
 public class PathCalculationResult {
@@ -31,11 +32,9 @@ public PathCalculationResult(Type type) {
     }
 
     public PathCalculationResult(Type type, IPath path) {
+        Objects.requireNonNull(type);
         this.path = path;
         this.type = type;
-        if (type == null) {
-            throw new IllegalArgumentException("come on");
-        }
     }
 
     public final Optional<IPath> getPath() {

File: src/main/java/baritone/behavior/PathingBehavior.java
Patch:
@@ -499,7 +499,7 @@ public static AbstractNodeCostSearch createPathfinder(BlockPos start, Goal goal,
         Goal transformed = goal;
         if (Baritone.settings().simplifyUnloadedYCoord.get() && goal instanceof IGoalRenderPos) {
             BlockPos pos = ((IGoalRenderPos) goal).getGoalPos();
-            if (context.world.getChunk(pos) instanceof EmptyChunk) {
+            if (!context.bsi.worldContainsLoadedChunk(pos.getX(), pos.getZ())) {
                 transformed = new GoalXZ(pos.getX(), pos.getZ());
             }
         }

File: src/main/java/baritone/utils/ExampleBaritoneControl.java
Patch:
@@ -240,7 +240,7 @@ public boolean runCommand(String msg0) {
             return true;
         }
         if (msg.startsWith("build")) {
-            String file = msg.substring(5) + ".schematic";
+            String file = msg.substring(6) + ".schematic";
             logDirect("" + baritone.getBuilderProcess().build(file));
             return true;
         }

File: src/api/java/baritone/api/utils/IPlayerController.java
Patch:
@@ -30,8 +30,6 @@
  */
 public interface IPlayerController {
 
-    boolean clickBlock(BlockPos pos, EnumFacing side);
-
     boolean onPlayerDamageBlock(BlockPos pos, EnumFacing side);
 
     void resetBlockRemoving();

File: src/main/java/baritone/utils/BlockBreakHelper.java
Patch:
@@ -55,7 +55,8 @@ public void tryBreakBlock(BlockPos pos, EnumFacing side) {
     }
 
     public void stopBreakingBlock() {
-        if (playerContext.playerController() != null) {
+        // The player controller will never be null, but the player can be
+        if (playerContext.player() != null) {
             playerContext.playerController().resetBlockRemoving();
         }
         lastBlock = null;

File: src/main/java/baritone/process/MineProcess.java
Patch:
@@ -39,7 +39,6 @@
 import net.minecraft.item.ItemStack;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.world.World;
-import net.minecraft.world.chunk.EmptyChunk;
 
 import java.util.*;
 import java.util.stream.Collectors;
@@ -255,7 +254,8 @@ public static List<BlockPos> prune(CalculationContext ctx, List<BlockPos> locs2,
                 .distinct()
 
                 // remove any that are within loaded chunks that aren't actually what we want
-                .filter(pos -> ctx.world().getChunk(pos) instanceof EmptyChunk || mining.contains(ctx.getBlock(pos.getX(), pos.getY(), pos.getZ())) || dropped.contains(pos))
+
+                .filter(pos -> !ctx.bsi().isLoaded(pos.getX(), pos.getZ()) || mining.contains(ctx.getBlock(pos.getX(), pos.getY(), pos.getZ())) || dropped.contains(pos))
 
                 // remove any that are implausible to mine (encased in bedrock, or touching lava)
                 .filter(pos -> MineProcess.plausibleToBreak(ctx.bsi(), pos))

File: src/api/java/baritone/api/event/events/BlockInteractEvent.java
Patch:
@@ -20,7 +20,7 @@
 import net.minecraft.util.math.BlockPos;
 
 /**
- * Called when the local player interacts with a block, can be either {@link Type#BREAK} or {@link Type#USE}.
+ * Called when the local player interacts with a block, can be either {@link Type#START_BREAK} or {@link Type#USE}.
  *
  * @author Brady
  * @since 8/22/2018
@@ -59,9 +59,9 @@ public final Type getType() {
     public enum Type {
 
         /**
-         * We're breaking the target block.
+         * We're starting to break the target block.
          */
-        BREAK,
+        START_BREAK,
 
         /**
          * We're right clicking on the target block. Either placing or interacting with.

File: src/launch/java/baritone/launch/mixins/MixinMinecraft.java
Patch:
@@ -164,7 +164,7 @@ private boolean isAllowUserInput(GuiScreen screen) {
     )
     private void onBlockBreak(CallbackInfo ci, BlockPos pos) {
         // clickMouse is only for the main player
-        BaritoneAPI.getProvider().getPrimaryBaritone().getGameEventHandler().onBlockInteract(new BlockInteractEvent(pos, BlockInteractEvent.Type.BREAK));
+        BaritoneAPI.getProvider().getPrimaryBaritone().getGameEventHandler().onBlockInteract(new BlockInteractEvent(pos, BlockInteractEvent.Type.START_BREAK));
     }
 
     @Inject(

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -63,6 +63,9 @@ public static void cost(CalculationContext context, int x, int y, int z, EnumFac
         if (!context.allowParkour()) {
             return;
         }
+        if (y == 256 && !context.allowJumpAt256()) {
+            return;
+        }
 
         int xDiff = dir.getXOffset();
         int zDiff = dir.getZOffset();

File: src/main/java/baritone/utils/pathing/PathBase.java
Patch:
@@ -47,7 +47,7 @@ public PathBase staticCutoff(Goal destination) {
             return this;
         }
         double factor = BaritoneAPI.getSettings().pathCutoffFactor.get();
-        int newLength = (int) ((length() - 1 - min) * factor) + min;
+        int newLength = (int) ((length() - min) * factor) + min - 1;
         return new CutoffPath(this, newLength);
     }
 }

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -357,7 +357,7 @@ public boolean snipsnapifpossible() {
             return false;
         } else {
             // we are either onGround or in liquid
-            if (ctx.player().motionY < 0) {
+            if (ctx.player().motionY < -0.1) {
                 // if we are strictly moving downwards (not stationary)
                 // we could be falling through water, which could be unsafe to splice
                 return false; // so don't

File: src/main/java/baritone/pathing/calc/AStarPathFinder.java
Patch:
@@ -121,7 +121,7 @@ protected Optional<IPath> calculate0(long primaryTimeout, long failureTimeout) {
                 if (actionCost >= ActionCosts.COST_INF) {
                     continue;
                 }
-                if (actionCost <= 0) {
+                if (actionCost <= 0 || Double.isNaN(actionCost)) {
                     throw new IllegalStateException(moves + " calculated implausible cost " + actionCost);
                 }
                 if (moves.dynamicXZ && !worldBorder.entirelyContains(res.x, res.z)) { // see issue #218

File: src/main/java/baritone/pathing/calc/PathNode.java
Patch:
@@ -73,6 +73,9 @@ public PathNode(int x, int y, int z, Goal goal) {
         this.previous = null;
         this.cost = ActionCosts.COST_INF;
         this.estimatedCostToGoal = goal.heuristic(x, y, z);
+        if (Double.isNaN(estimatedCostToGoal)) {
+            throw new IllegalStateException(goal + " calculated implausible heuristic");
+        }
         this.isOpen = false;
         this.x = x;
         this.y = y;

File: src/main/java/baritone/pathing/movement/movements/MovementDescend.java
Patch:
@@ -17,7 +17,6 @@
 
 package baritone.pathing.movement.movements;
 
-import baritone.Baritone;
 import baritone.api.IBaritone;
 import baritone.api.pathing.movement.MovementStatus;
 import baritone.api.utils.BetterBlockPos;
@@ -138,7 +137,7 @@ public static void dynamicFallCost(CalculationContext context, int x, int y, int
             if (ontoBlock.getBlock() == Blocks.WATER && !MovementHelper.isFlowing(ontoBlock) && context.getBlock(destX, newY + 1, destZ) != Blocks.WATERLILY) { // TODO flowing check required here?
                 // lilypads are canWalkThrough, but we can't end a fall that should be broken by water if it's covered by a lilypad
                 // however, don't return impossible in the lilypad scenario, because we could still jump right on it (water that's below a lilypad is canWalkOn so it works)
-                if (Baritone.settings().assumeWalkOnWater.get()) {
+                if (context.assumeWalkOnWater()) {
                     return; // TODO fix
                 }
                 // found a fall into water

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -103,7 +103,7 @@ public static double cost(CalculationContext context, int x, int y, int z, int d
             if (srcDown == Blocks.LADDER || srcDown == Blocks.VINE) {
                 return COST_INF;
             }
-            if (destOn.getBlock().equals(Blocks.AIR) || MovementHelper.isReplacable(destX, y - 1, destZ, destOn, context.world())) {
+            if (MovementHelper.isReplacable(destX, y - 1, destZ, destOn, context.bsi())) {
                 boolean throughWater = MovementHelper.isWater(pb0.getBlock()) || MovementHelper.isWater(pb1.getBlock());
                 if (MovementHelper.isWater(destOn.getBlock()) && throughWater) {
                     // this happens when assume walk on water is true and this is a traverse in water, which isn't allowed

File: src/main/java/baritone/cache/ContainerMemory.java
Patch:
@@ -62,6 +62,7 @@ private void read(byte[] bytes) throws IOException {
             RememberedInventory rem = new RememberedInventory();
             rem.items.addAll(readItemStacks(in));
             rem.size = rem.items.size();
+            rem.windowId = -1;
             if (rem.items.isEmpty()) {
                 continue; // this only happens if the list has no elements, not if the list has elements that are all empty item stacks
             }

File: src/api/java/baritone/api/cache/ICachedRegion.java
Patch:
@@ -37,12 +37,12 @@ public interface ICachedRegion extends IBlockTypeAccess {
     boolean isCached(int blockX, int blockZ);
 
     /**
-     * The X coordinate of this region
+     * @return The X coordinate of this region
      */
     int getX();
 
     /**
-     * The Z coordinate of this region
+     * @return The Z coordinate of this region
      */
     int getZ();
 }

File: src/api/java/baritone/api/cache/IWorldData.java
Patch:
@@ -27,12 +27,12 @@ public interface IWorldData {
      * Returns the cached world for this world. A cached world is a simplified format
      * of a regular world, intended for use on multiplayer servers where chunks are not
      * traditionally stored to disk, allowing for long distance pathing with minimal disk usage.
+     *
+     * @return The cached world for this world
      */
     ICachedWorld getCachedWorld();
 
     /**
-     * Returns the waypoint collection for this world.
-     *
      * @return The waypoint collection for this world
      */
     IWaypointCollection getWaypoints();

File: src/api/java/baritone/api/pathing/calc/IPathFinder.java
Patch:
@@ -34,6 +34,9 @@ public interface IPathFinder {
     /**
      * Calculate the path in full. Will take several seconds.
      *
+     * @param primaryTimeout If a path is found, the path finder will stop after this amount of time
+     * @param failureTimeout If a path isn't found, the path finder will continue for this amount of time
+     *
      * @return The final path
      */
     PathCalculationResult calculate(long primaryTimeout, long failureTimeout);

File: src/api/java/baritone/api/utils/RayTraceUtils.java
Patch:
@@ -34,7 +34,9 @@ private RayTraceUtils() {}
      * any entity collisions can be ignored, because this method will not recognize if an
      * entity is in the way or not. The local player's block reach distance will be used.
      *
-     * @param rotation The rotation to raytrace towards
+     * @param entity             The entity representing the raytrace source
+     * @param rotation           The rotation to raytrace towards
+     * @param blockReachDistance The block reach distance of the entity
      * @return The calculated raytrace result
      */
     public static RayTraceResult rayTraceTowards(Entity entity, Rotation rotation, double blockReachDistance) {

File: src/api/java/baritone/api/utils/VecUtils.java
Patch:
@@ -36,7 +36,8 @@ private VecUtils() {}
     /**
      * Calculates the center of the block at the specified position's bounding box
      *
-     * @param pos The block position
+     * @param world The world that the block is in, used to provide the bounding box
+     * @param pos   The block position
      * @return The center of the block's bounding box
      * @see #getBlockPosCenter(BlockPos)
      */

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -347,6 +347,8 @@ private boolean possiblyOffPath(Tuple<Double, BlockPos> status, double leniency)
 
     /**
      * Regardless of current path position, snap to the current player feet if possible
+     *
+     * @return Whether or not it was possible to snap to the current player feet
      */
     public boolean snipsnapifpossible() {
         if (!ctx.player().onGround) {

File: src/main/java/baritone/utils/Helper.java
Patch:
@@ -47,7 +47,7 @@ public interface Helper {
     /**
      * Send a message to chat only if chatDebug is on
      *
-     * @param message
+     * @param message The message to display in chat
      */
     default void logDebug(String message) {
         if (!Baritone.settings().chatDebug.get()) {
@@ -61,7 +61,7 @@ default void logDebug(String message) {
     /**
      * Send a message to chat regardless of chatDebug (should only be used for critically important messages, or as a direct response to a chat command)
      *
-     * @param message
+     * @param message The message to display in chat
      */
     default void logDirect(String message) {
         ITextComponent component = MESSAGE_PREFIX.createCopy();

File: src/main/java/baritone/cache/ContainerMemory.java
Patch:
@@ -60,7 +60,7 @@ public final synchronized Map<BlockPos, IRememberedInventory> getRememberedInven
     /**
      * An inventory that we are aware of.
      * <p>
-     * Associated with a {@link BlockPos} in {@link WorldDataContainer#rememberedInventories}.
+     * Associated with a {@link BlockPos} in {@link ContainerMemory#inventories}.
      */
     public static class RememberedInventory implements IRememberedInventory {
 

File: src/main/java/baritone/utils/pathing/PathBase.java
Patch:
@@ -47,7 +47,7 @@ public PathBase staticCutoff(Goal destination) {
             return this;
         }
         double factor = BaritoneAPI.getSettings().pathCutoffFactor.get();
-        int newLength = (int) ((length() - 1) * factor) + min;
+        int newLength = (int) ((length() - 1 - min) * factor) + min;
         return new CutoffPath(this, newLength);
     }
 }

File: src/api/java/baritone/api/utils/Rotation.java
Patch:
@@ -142,7 +142,7 @@ public static float normalizeYaw(float yaw) {
         if (newYaw < -180F) {
             newYaw += 360F;
         }
-        if (newYaw >= 180F) {
+        if (newYaw > 180F) {
             newYaw -= 360F;
         }
         return newYaw;

File: src/main/java/baritone/behavior/PathingBehavior.java
Patch:
@@ -420,7 +420,7 @@ private void findPathInNewThread(final BlockPos start, final boolean talkAboutIt
         }
         CalculationContext context = new CalculationContext(baritone, true); // not safe to create on the other thread, it looks up a lot of stuff in minecraft
         AbstractNodeCostSearch pathfinder = createPathfinder(start, goal, current == null ? null : current.getPath(), context);
-        if (!Objects.equals(pathfinder.getGoal(), goal)) {
+        if (!Objects.equals(pathfinder.getGoal(), goal)) { // will return the exact same object if simplification didn't happen
             logDebug("Simplifying " + goal.getClass() + " to GoalXZ due to distance");
         }
         inProgress = pathfinder;

File: src/main/java/baritone/pathing/path/SplicedPath.java
Patch:
@@ -71,7 +71,7 @@ public static Optional<SplicedPath> trySplice(IPath first, IPath second, boolean
         if (second == null || first == null) {
             return Optional.empty();
         }
-        if (!Objects.equals(first.getGoal(), second.getGoal())) {
+        if (!first.getGoal().toString().equals(second.getGoal().toString())) {
             return Optional.empty();
         }
         if (!first.getDest().equals(second.getSrc())) {

File: src/main/java/baritone/process/CustomGoalProcess.java
Patch:
@@ -74,7 +74,7 @@ public boolean isActive() {
     public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
         switch (this.state) {
             case GOAL_SET:
-                if (!baritone.getPathingBehavior().isPathing() && Objects.equals(baritone.getPathingBehavior().getGoal(), this.goal)) {
+                if (!baritone.getPathingBehavior().isPathing() && Objects.equals(baritone.getPathingBehavior().getGoal() + "", this.goal + "")) {
                     this.state = State.NONE;
                 }
                 return new PathingCommand(this.goal, PathingCommandType.CANCEL_AND_SET_GOAL);

File: src/main/java/baritone/utils/pathing/PathBase.java
Patch:
@@ -39,15 +39,14 @@ public PathBase cutoffAtLoadedChunks(Object bsi0) {
 
     @Override
     public PathBase staticCutoff(Goal destination) {
-        int min = BaritoneAPI.getSettings().pathCutoffMinimumLength.get();
-        if (length() < min) {
+        if (length() < BaritoneAPI.getSettings().pathCutoffMinimumLength.get()) {
             return this;
         }
         if (destination == null || destination.isInGoal(getDest())) {
             return this;
         }
         double factor = BaritoneAPI.getSettings().pathCutoffFactor.get();
-        int newLength = (int) ((length() - 1 - min) * factor) + min;
+        int newLength = (int) ((length() - 1) * factor);
         return new CutoffPath(this, newLength);
     }
 }

File: src/main/java/baritone/utils/Helper.java
Patch:
@@ -67,6 +67,6 @@ default void logDirect(String message) {
         ITextComponent component = MESSAGE_PREFIX.createCopy();
         component.getStyle().setColor(TextFormatting.GRAY);
         component.appendSibling(new TextComponentString(" " + message));
-        Baritone.settings().logger.get().accept(component);
+        Minecraft.getMinecraft().addScheduledTask(() -> Baritone.settings().logger.get().accept(component));
     }
 }

File: src/main/java/baritone/cache/CachedChunk.java
Patch:
@@ -35,7 +35,7 @@ public final class CachedChunk {
 
     static {
         HashSet<Block> temp = new HashSet<>();
-        temp.add(Blocks.DIAMOND_ORE);
+        //temp.add(Blocks.DIAMOND_ORE);
         temp.add(Blocks.DIAMOND_BLOCK);
         //temp.add(Blocks.COAL_ORE);
         temp.add(Blocks.COAL_BLOCK);

File: src/main/java/baritone/process/MineProcess.java
Patch:
@@ -210,7 +210,7 @@ public static List<BlockPos> searchWorld(CalculationContext ctx, List<Block> min
         //long b = System.currentTimeMillis();
         for (Block m : mining) {
             if (CachedChunk.BLOCKS_TO_KEEP_TRACK_OF.contains(m)) {
-                locs.addAll(ctx.worldData().getCachedWorld().getLocationsOf(ChunkPacker.blockToString(m), 1, ctx.getBaritone().getPlayerContext().playerFeet().getX(), ctx.getBaritone().getPlayerContext().playerFeet().getZ(), 1));
+                locs.addAll(ctx.worldData().getCachedWorld().getLocationsOf(ChunkPacker.blockToString(m), 1, ctx.getBaritone().getPlayerContext().playerFeet().getX(), ctx.getBaritone().getPlayerContext().playerFeet().getZ(), 2));
             } else {
                 uninteresting.add(m);
             }

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -151,9 +151,10 @@ protected boolean prepared(MovementState state) {
                 somethingInTheWay = true;
                 Optional<Rotation> reachable = RotationUtils.reachable(ctx.player(), blockPos, ctx.playerController().getBlockReachDistance());
                 if (reachable.isPresent()) {
+                    Rotation rotTowardsBlock = reachable.get();
                     MovementHelper.switchToBestToolFor(ctx, BlockStateInterface.get(ctx, blockPos));
-                    state.setTarget(new MovementState.MovementTarget(reachable.get(), true));
-                    if (Objects.equals(ctx.getSelectedBlock().orElse(null), blockPos)) {
+                    state.setTarget(new MovementState.MovementTarget(rotTowardsBlock, true));
+                    if (Objects.equals(ctx.getSelectedBlock().orElse(null), blockPos) || ctx.playerRotations().isReallyCloseTo(rotTowardsBlock)) {
                         state.setInput(Input.CLICK_LEFT, true);
                     }
                     return false;

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -70,7 +70,7 @@ static boolean canWalkThrough(BlockStateInterface bsi, int x, int y, int z, IBlo
         if (block == Blocks.AIR) { // early return for most common case
             return true;
         }
-        if (block == Blocks.FIRE || block == Blocks.TRIPWIRE || block == Blocks.WEB || block == Blocks.END_PORTAL) {
+        if (block == Blocks.FIRE || block == Blocks.TRIPWIRE || block == Blocks.WEB || block == Blocks.END_PORTAL || block == Blocks.COCOA) {
             return false;
         }
         if (block instanceof BlockDoor || block instanceof BlockFenceGate) {
@@ -139,6 +139,7 @@ static boolean fullyPassable(IBlockState state) {
                 || block == Blocks.WEB
                 || block == Blocks.VINE
                 || block == Blocks.LADDER
+                || block == Blocks.COCOA
                 || block instanceof BlockDoor
                 || block instanceof BlockFenceGate
                 || block instanceof BlockSnow

File: src/main/java/baritone/utils/BlockStateInterface.java
Patch:
@@ -23,6 +23,7 @@
 import baritone.cache.WorldData;
 import baritone.utils.accessor.IChunkProviderClient;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import net.minecraft.block.Block;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
@@ -53,7 +54,7 @@ public BlockStateInterface(IPlayerContext ctx) {
 
     public BlockStateInterface(World world, WorldData worldData) {
         this.worldData = worldData;
-        this.loadedChunks = ((IChunkProviderClient) world.getChunkProvider()).loadedChunks();
+        this.loadedChunks = new Long2ObjectOpenHashMap<>(((IChunkProviderClient) world.getChunkProvider()).loadedChunks()); // make a copy that we can safely access from another thread
         if (!Minecraft.getMinecraft().isCallingFromMinecraftThread()) {
             throw new IllegalStateException();
         }

File: src/main/java/baritone/pathing/path/SplicedPath.java
Patch:
@@ -77,6 +77,7 @@ public static Optional<SplicedPath> trySplice(IPath first, IPath second, boolean
         for (int i = 0; i < first.length() - 1; i++) { // overlap in the very last element is fine (and required) so only go up to first.length() - 1
             if (secondPos.contains(first.positions().get(i))) {
                 firstPositionInSecond = i;
+                break;
             }
         }
         if (firstPositionInSecond != -1) {
@@ -94,7 +95,7 @@ public static Optional<SplicedPath> trySplice(IPath first, IPath second, boolean
         List<IMovement> movements = new ArrayList<>();
         positions.addAll(first.positions().subList(0, firstPositionInSecond + 1));
         movements.addAll(first.movements().subList(0, firstPositionInSecond));
-        
+
         positions.addAll(second.positions().subList(positionInSecond + 1, second.length()));
         movements.addAll(second.movements().subList(positionInSecond, second.length() - 1));
         return Optional.of(new SplicedPath(positions, movements, first.getNumNodesConsidered() + second.getNumNodesConsidered(), first.getGoal()));

File: src/main/java/baritone/pathing/calc/Path.java
Patch:
@@ -129,7 +129,7 @@ private boolean assembleMovements() {
 
     private Movement runBackwards(BetterBlockPos src, BetterBlockPos dest, double cost) {
         for (Moves moves : Moves.values()) {
-            Movement move = moves.apply0(context.getBaritone(), src);
+            Movement move = moves.apply0(context, src);
             if (move.getDest().equals(dest)) {
                 // have to calculate the cost at calculation time so we can accurately judge whether a cost increase happened between cached calculation and real execution
                 move.override(cost);

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -57,11 +57,11 @@ private MovementParkour(IBaritone baritone, BetterBlockPos src, int dist, EnumFa
         this.dist = dist;
     }
 
-    public static MovementParkour cost(IBaritone baritone, BetterBlockPos src, EnumFacing direction) {
+    public static MovementParkour cost(CalculationContext context, BetterBlockPos src, EnumFacing direction) {
         MutableMoveResult res = new MutableMoveResult();
-        cost(new CalculationContext(baritone), src.x, src.y, src.z, direction, res);
+        cost(context, src.x, src.y, src.z, direction, res);
         int dist = Math.abs(res.x - src.x) + Math.abs(res.z - src.z);
-        return new MovementParkour(baritone, src, dist, direction);
+        return new MovementParkour(context.getBaritone(), src, dist, direction);
     }
 
     public static void cost(CalculationContext context, int x, int y, int z, EnumFacing dir, MutableMoveResult res) {

File: src/main/java/baritone/utils/ExampleBaritoneControl.java
Patch:
@@ -28,6 +28,7 @@
 import baritone.behavior.PathingBehavior;
 import baritone.cache.ChunkPacker;
 import baritone.cache.Waypoint;
+import baritone.pathing.movement.CalculationContext;
 import baritone.pathing.movement.Movement;
 import baritone.pathing.movement.Moves;
 import baritone.process.CustomGoalProcess;
@@ -446,7 +447,7 @@ public boolean isInGoal(int x, int y, int z) {
             return true;
         }
         if (msg.equals("costs")) {
-            List<Movement> moves = Stream.of(Moves.values()).map(x -> x.apply0(baritone, ctx.playerFeet())).collect(Collectors.toCollection(ArrayList::new));
+            List<Movement> moves = Stream.of(Moves.values()).map(x -> x.apply0(new CalculationContext(baritone), ctx.playerFeet())).collect(Collectors.toCollection(ArrayList::new));
             while (moves.contains(null)) {
                 moves.remove(null);
             }

File: src/main/java/baritone/pathing/movement/movements/MovementPillar.java
Patch:
@@ -194,12 +194,13 @@ public MovementState updateState(MovementState state) {
             }
 
 
-            state.setInput(Input.SNEAK, ctx.player().posY > dest.getY()); // delay placement by 1 tick for ncp compatibility
+            state.setInput(Input.SNEAK, ctx.player().posY > dest.getY() || ctx.player().posY < src.getY() + 0.5D); // delay placement by 1 tick for ncp compatibility
             // since (lower down) we only right click once player.isSneaking, and that happens the tick after we request to sneak
 
             double diffX = ctx.player().posX - (dest.getX() + 0.5);
             double diffZ = ctx.player().posZ - (dest.getZ() + 0.5);
             double dist = Math.sqrt(diffX * diffX + diffZ * diffZ);
+            double flatMotion = Math.sqrt(ctx.player().motionX * ctx.player().motionX + ctx.player().motionZ * ctx.player().motionZ);
             if (dist > 0.17) {//why 0.17? because it seemed like a good number, that's why
                 //[explanation added after baritone port lol] also because it needs to be less than 0.2 because of the 0.3 sneak limit
                 //and 0.17 is reasonably less than 0.2
@@ -209,7 +210,7 @@ public MovementState updateState(MovementState state) {
 
                 // revise our target to both yaw and pitch if we're going to be moving forward
                 state.setTarget(new MovementState.MovementTarget(rotation, true));
-            } else {
+            } else if (flatMotion < 0.05) {
                 // If our Y coordinate is above our goal, stop jumping
                 state.setInput(Input.JUMP, ctx.player().posY < dest.getY());
             }

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -200,7 +200,7 @@ static boolean isGatePassable(IPlayerContext ctx, BlockPos gatePos, BlockPos pla
             return true;
         }
 
-        return isHorizontalBlockPassable(gatePos, state, playerPos, BlockFenceGate.OPEN);
+        return state.getValue(BlockFenceGate.OPEN);
     }
 
     static boolean isHorizontalBlockPassable(BlockPos blockPos, IBlockState blockState, BlockPos playerPos, PropertyBool propertyOpen) {

File: src/main/java/baritone/pathing/movement/movements/MovementDescend.java
Patch:
@@ -196,8 +196,8 @@ public MovementState updateState(MovementState state) {
             }*/
         }
         if (safeMode()) {
-            double destX = (src.getX() + 0.5) * 0.25 + (dest.getX() + 0.5) * 0.75;
-            double destZ = (src.getZ() + 0.5) * 0.25 + (dest.getZ() + 0.5) * 0.75;
+            double destX = (src.getX() + 0.5) * 0.19 + (dest.getX() + 0.5) * 0.81;
+            double destZ = (src.getZ() + 0.5) * 0.19 + (dest.getZ() + 0.5) * 0.81;
             EntityPlayerSP player = ctx.player();
             state.setTarget(new MovementState.MovementTarget(
                     new Rotation(RotationUtils.calcRotationFromVec3d(player.getPositionEyes(1.0F),

File: src/main/java/baritone/cache/ChunkPacker.java
Patch:
@@ -124,7 +124,7 @@ public static Block stringToBlock(String name) {
 
     private static PathingBlockType getPathingBlockType(IBlockState state) {
         Block block = state.getBlock();
-        if (block.equals(Blocks.WATER)) {
+        if (block.equals(Blocks.WATER) && !MovementHelper.isFlowing(state)) {
             // only water source blocks are plausibly usable, flowing water should be avoid
             return PathingBlockType.WATER;
         }

File: src/main/java/baritone/pathing/calc/AbstractNodeCostSearch.java
Patch:
@@ -193,7 +193,7 @@ protected int mapSize() {
 
     @Override
     public Optional<IPath> bestPathSoFar() {
-        if (startNode == null || bestSoFar[0] == null) {
+        if (startNode == null || bestSoFar == null || bestSoFar[0] == null) {
             return Optional.empty();
         }
         for (int i = 0; i < bestSoFar.length; i++) {

File: src/main/java/baritone/Baritone.java
Patch:
@@ -107,6 +107,9 @@ public synchronized void init() {
             return;
         }
 
+        // Define this before behaviors try and get it, or else it will be null and the builds will fail!
+        this.playerContext = LocalPlayerContext.INSTANCE;
+
         this.behaviors = new ArrayList<>();
         {
             // the Behavior constructor calls baritone.registerBehavior(this) so this populates the behaviors arraylist
@@ -125,7 +128,6 @@ public synchronized void init() {
             getToBlockProcess = new GetToBlockProcess(this);
         }
 
-        this.playerContext = LocalPlayerContext.INSTANCE;
         this.worldProvider = new WorldProvider();
 
         if (BaritoneAutoTest.ENABLE_AUTO_TEST) {

File: src/main/java/baritone/behavior/LookBehavior.java
Patch:
@@ -23,9 +23,8 @@
 import baritone.api.event.events.PlayerUpdateEvent;
 import baritone.api.event.events.RotationMoveEvent;
 import baritone.api.utils.Rotation;
-import baritone.utils.Helper;
 
-public final class LookBehavior extends Behavior implements ILookBehavior, Helper {
+public final class LookBehavior extends Behavior implements ILookBehavior {
 
     /**
      * Target's values are as follows:

File: src/main/java/baritone/behavior/MemoryBehavior.java
Patch:
@@ -27,7 +27,6 @@
 import baritone.api.event.events.type.EventState;
 import baritone.cache.Waypoint;
 import baritone.utils.BlockStateInterface;
-import baritone.utils.Helper;
 import net.minecraft.block.BlockBed;
 import net.minecraft.item.ItemStack;
 import net.minecraft.network.Packet;
@@ -45,7 +44,7 @@
  * @author Brady
  * @since 8/6/2018 9:47 PM
  */
-public final class MemoryBehavior extends Behavior implements IMemoryBehavior, Helper {
+public final class MemoryBehavior extends Behavior implements IMemoryBehavior {
 
     private final Map<IWorldData, WorldDataContainer> worldDataContainers = new HashMap<>();
 

File: src/main/java/baritone/cache/CachedChunk.java
Patch:
@@ -17,7 +17,6 @@
 
 package baritone.cache;
 
-import baritone.utils.Helper;
 import baritone.utils.pathing.PathingBlockType;
 import net.minecraft.block.Block;
 import net.minecraft.block.state.IBlockState;
@@ -30,7 +29,7 @@
  * @author Brady
  * @since 8/3/2018 1:04 AM
  */
-public final class CachedChunk implements Helper {
+public final class CachedChunk {
 
     public static final Set<Block> BLOCKS_TO_KEEP_TRACK_OF;
 

File: src/main/java/baritone/cache/ChunkPacker.java
Patch:
@@ -18,7 +18,6 @@
 package baritone.cache;
 
 import baritone.pathing.movement.MovementHelper;
-import baritone.utils.Helper;
 import baritone.utils.pathing.PathingBlockType;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockDoublePlant;
@@ -38,7 +37,7 @@
  * @author Brady
  * @since 8/3/2018 1:09 AM
  */
-public final class ChunkPacker implements Helper {
+public final class ChunkPacker {
 
     private ChunkPacker() {}
 

File: src/main/java/baritone/cache/WorldScanner.java
Patch:
@@ -19,7 +19,6 @@
 
 import baritone.api.cache.IWorldScanner;
 import baritone.api.utils.IPlayerContext;
-import baritone.utils.Helper;
 import net.minecraft.block.Block;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.multiplayer.ChunkProviderClient;
@@ -31,7 +30,7 @@
 import java.util.LinkedList;
 import java.util.List;
 
-public enum WorldScanner implements IWorldScanner, Helper {
+public enum WorldScanner implements IWorldScanner {
 
     INSTANCE;
 

File: src/main/java/baritone/pathing/movement/CalculationContext.java
Patch:
@@ -88,7 +88,7 @@ public CalculationContext(IBaritone baritone) {
     }
 
     public final IBaritone getBaritone() {
-        return this.baritone;
+        return baritone;
     }
 
     public IBlockState get(int x, int y, int z) {

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -23,7 +23,6 @@
 import baritone.api.utils.*;
 import baritone.api.utils.input.Input;
 import baritone.utils.BlockStateInterface;
-import baritone.utils.Helper;
 import net.minecraft.block.BlockLiquid;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.math.BlockPos;
@@ -34,7 +33,7 @@
 import java.util.Objects;
 import java.util.Optional;
 
-public abstract class Movement implements IMovement, Helper, MovementHelper {
+public abstract class Movement implements IMovement, MovementHelper {
 
     protected static final EnumFacing[] HORIZONTALS = {EnumFacing.NORTH, EnumFacing.SOUTH, EnumFacing.EAST, EnumFacing.WEST};
 

File: src/main/java/baritone/utils/BlockStateInterface.java
Patch:
@@ -35,7 +35,7 @@
  *
  * @author leijurv
  */
-public class BlockStateInterface implements Helper {
+public class BlockStateInterface {
 
     private final World world;
     private final WorldData worldData;

File: src/main/java/baritone/utils/player/LocalPlayerContext.java
Patch:
@@ -31,7 +31,7 @@
  * @author Brady
  * @since 11/12/2018
  */
-public final class LocalPlayerContext extends AbstractPlayerContext {
+public final class LocalPlayerContext implements IPlayerContext {
 
     private static final Minecraft mc = Minecraft.getMinecraft();
 

File: src/api/java/baritone/api/pathing/goals/GoalRunAway.java
Patch:
@@ -75,7 +75,7 @@ public double heuristic(int x, int y, int z) {//mostly copied from GoalBlock
         }
         min = -min;
         if (maintainY.isPresent()) {
-            min = min * 0.5 + GoalYLevel.calculate(maintainY.get(), y);
+            min = min * 0.6 + GoalYLevel.calculate(maintainY.get(), y) * 1.5;
         }
         return min;
     }

File: src/main/java/baritone/process/GetToBlockProcess.java
Patch:
@@ -29,6 +29,7 @@
 import net.minecraft.util.math.BlockPos;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 public class GetToBlockProcess extends BaritoneProcessHelper implements IGetToBlockProcess {
@@ -96,7 +97,6 @@ public String displayName() {
     }
 
     private void rescan(List<BlockPos> known) {
-        // TODO-yeet
-//        knownLocations = MineProcess.searchWorld(ctx, Collections.singletonList(gettingTo), 64, baritone.getWorldProvider(), known);
+        knownLocations = MineProcess.searchWorld(baritone, Collections.singletonList(gettingTo), 64, known);
     }
 }
\ No newline at end of file

File: src/api/java/baritone/api/cache/ICachedWorld.java
Patch:
@@ -63,10 +63,12 @@ public interface ICachedWorld {
      *
      * @param block               The special block to search for
      * @param maximum             The maximum number of position results to receive
+     * @param centerX             The x block coordinate center of the search
+     * @param centerZ             The z block coordinate center of the search
      * @param maxRegionDistanceSq The maximum region distance, squared
      * @return The locations found that match the special block
      */
-    LinkedList<BlockPos> getLocationsOf(String block, int maximum, int maxRegionDistanceSq);
+    LinkedList<BlockPos> getLocationsOf(String block, int maximum, int centerX, int centerZ, int maxRegionDistanceSq);
 
     /**
      * Reloads all of the cached regions in this world from disk. Anything that is not saved

File: src/api/java/baritone/api/pathing/movement/IMovement.java
Patch:
@@ -18,6 +18,7 @@
 package baritone.api.pathing.movement;
 
 import baritone.api.utils.BetterBlockPos;
+import baritone.api.utils.IPlayerContext;
 import net.minecraft.util.math.BlockPos;
 
 import java.util.List;

File: src/main/java/baritone/behavior/Behavior.java
Patch:
@@ -19,6 +19,7 @@
 
 import baritone.Baritone;
 import baritone.api.behavior.IBehavior;
+import baritone.api.utils.IPlayerContext;
 
 /**
  * A type of game event listener that is given {@link Baritone} instance context.
@@ -29,9 +30,11 @@
 public class Behavior implements IBehavior {
 
     public final Baritone baritone;
+    public final IPlayerContext ctx;
 
     protected Behavior(Baritone baritone) {
         this.baritone = baritone;
+        this.ctx = baritone.getPlayerContext();
         baritone.registerBehavior(this);
     }
 }

File: src/main/java/baritone/pathing/calc/Path.java
Patch:
@@ -129,7 +129,7 @@ private boolean assembleMovements() {
 
     private Movement runBackwards(BetterBlockPos src, BetterBlockPos dest, double cost) {
         for (Moves moves : Moves.values()) {
-            Movement move = moves.apply0(context, src);
+            Movement move = moves.apply0(context.getBaritone(), src);
             if (move.getDest().equals(dest)) {
                 // have to calculate the cost at calculation time so we can accurately judge whether a cost increase happened between cached calculation and real execution
                 move.override(cost);

File: src/main/java/baritone/pathing/movement/MovementState.java
Patch:
@@ -19,7 +19,7 @@
 
 import baritone.api.pathing.movement.MovementStatus;
 import baritone.api.utils.Rotation;
-import baritone.utils.InputOverrideHandler.Input;
+import baritone.api.utils.input.Input;
 import net.minecraft.util.math.Vec3d;
 
 import java.util.HashMap;

File: src/main/java/baritone/process/CustomGoalProcess.java
Patch:
@@ -86,7 +86,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
                 if (calcFailed) {
                     onLostControl();
                 }
-                if (this.goal == null || this.goal.isInGoal(playerFeet())) {
+                if (this.goal == null || this.goal.isInGoal(ctx.playerFeet())) {
                     onLostControl(); // we're there xd
                 }
                 return new PathingCommand(this.goal, PathingCommandType.SET_GOAL_AND_PATH);

File: src/main/java/baritone/process/FollowProcess.java
Patch:
@@ -76,17 +76,17 @@ private boolean followable(Entity entity) {
         if (entity.isDead) {
             return false;
         }
-        if (entity.equals(player())) {
+        if (entity.equals(ctx.player())) {
             return false;
         }
-        if (!world().loadedEntityList.contains(entity) && !world().playerEntities.contains(entity)) {
+        if (!ctx.world().loadedEntityList.contains(entity) && !ctx.world().playerEntities.contains(entity)) {
             return false;
         }
         return true;
     }
 
     private void scanWorld() {
-        cache = Stream.of(world().loadedEntityList, world().playerEntities).flatMap(List::stream).filter(this::followable).filter(this.filter).distinct().collect(Collectors.toCollection(ArrayList::new));
+        cache = Stream.of(ctx.world().loadedEntityList, ctx.world().playerEntities).flatMap(List::stream).filter(this::followable).filter(this.filter).distinct().collect(Collectors.toCollection(ArrayList::new));
     }
 
     @Override

File: src/main/java/baritone/process/GetToBlockProcess.java
Patch:
@@ -29,7 +29,6 @@
 import net.minecraft.util.math.BlockPos;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 public class GetToBlockProcess extends BaritoneProcessHelper implements IGetToBlockProcess {
@@ -79,7 +78,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
             Baritone.getExecutor().execute(() -> rescan(current));
         }
         Goal goal = new GoalComposite(knownLocations.stream().map(GoalGetToBlock::new).toArray(Goal[]::new));
-        if (goal.isInGoal(playerFeet())) {
+        if (goal.isInGoal(ctx.playerFeet())) {
             onLostControl();
         }
         return new PathingCommand(goal, PathingCommandType.REVALIDATE_GOAL_AND_PATH);
@@ -97,6 +96,7 @@ public String displayName() {
     }
 
     private void rescan(List<BlockPos> known) {
-        knownLocations = MineProcess.searchWorld(Collections.singletonList(gettingTo), 64, baritone.getWorldProvider(), world(), known);
+        // TODO-yeet
+//        knownLocations = MineProcess.searchWorld(ctx, Collections.singletonList(gettingTo), 64, baritone.getWorldProvider(), known);
     }
 }
\ No newline at end of file

File: src/main/java/baritone/utils/BlockStateInterface.java
Patch:
@@ -38,7 +38,6 @@ public class BlockStateInterface implements Helper {
     private final World world;
     private final WorldData worldData;
 
-
     private Chunk prev = null;
     private CachedRegion prevCached = null;
 
@@ -54,7 +53,7 @@ public static Block getBlock(BlockPos pos) { // won't be called from the pathing
     }
 
     public static IBlockState get(BlockPos pos) {
-        return new CalculationContext().get(pos); // immense iq
+        return new CalculationContext(Baritone.INSTANCE).get(pos); // immense iq
         // can't just do world().get because that doesn't work for out of bounds
         // and toBreak and stuff fails when the movement is instantiated out of load range but it's not able to BlockStateInterface.get what it's going to walk on
     }

File: src/main/java/baritone/event/GameEventHandler.java
Patch:
@@ -22,7 +22,6 @@
 import baritone.api.event.events.type.EventState;
 import baritone.api.event.listener.IGameEventListener;
 import baritone.cache.WorldProvider;
-import baritone.utils.BlockStateInterface;
 import baritone.utils.Helper;
 import net.minecraft.world.chunk.Chunk;
 
@@ -98,8 +97,6 @@ public final void onRenderPass(RenderEvent event) {
     public final void onWorldEvent(WorldEvent event) {
         WorldProvider cache = baritone.getWorldProvider();
 
-        BlockStateInterface.clearCachedChunk();
-
         if (event.getState() == EventState.POST) {
             cache.closeWorld();
             if (event.getWorld() != null) {

File: src/main/java/baritone/pathing/calc/AStarPathFinder.java
Patch:
@@ -25,7 +25,6 @@
 import baritone.pathing.calc.openset.BinaryHeapOpenSet;
 import baritone.pathing.movement.CalculationContext;
 import baritone.pathing.movement.Moves;
-import baritone.utils.BlockStateInterface;
 import baritone.utils.Helper;
 import baritone.utils.pathing.BetterWorldBorder;
 import baritone.utils.pathing.MutableMoveResult;
@@ -66,7 +65,6 @@ protected Optional<IPath> calculate0(long timeout) {
         MutableMoveResult res = new MutableMoveResult();
         HashSet<Long> favored = favoredPositions.orElse(null);
         BetterWorldBorder worldBorder = new BetterWorldBorder(calcContext.world().getWorldBorder());
-        BlockStateInterface.clearCachedChunk();
         long startTime = System.nanoTime() / 1000000L;
         boolean slowPath = Baritone.settings().slowPath.get();
         if (slowPath) {
@@ -100,7 +98,7 @@ protected Optional<IPath> calculate0(long timeout) {
             for (Moves moves : Moves.values()) {
                 int newX = currentNode.x + moves.xOffset;
                 int newZ = currentNode.z + moves.zOffset;
-                if ((newX >> 4 != currentNode.x >> 4 || newZ >> 4 != currentNode.z >> 4) && !BlockStateInterface.isLoaded(calcContext, newX, newZ)) {
+                if ((newX >> 4 != currentNode.x >> 4 || newZ >> 4 != currentNode.z >> 4) && !calcContext.isLoaded(newX, newZ)) {
                     // only need to check if the destination is a loaded chunk if it's in a different chunk than the start of the movement
                     if (!moves.dynamicXZ) { // only increment the counter if the movement would have gone out of bounds guaranteed
                         numEmptyChunk++;

File: src/main/java/baritone/pathing/movement/movements/MovementFall.java
Patch:
@@ -21,14 +21,14 @@
 import baritone.api.pathing.movement.MovementStatus;
 import baritone.api.utils.BetterBlockPos;
 import baritone.api.utils.Rotation;
+import baritone.api.utils.RotationUtils;
 import baritone.api.utils.VecUtils;
 import baritone.pathing.movement.CalculationContext;
 import baritone.pathing.movement.Movement;
 import baritone.pathing.movement.MovementHelper;
 import baritone.pathing.movement.MovementState;
 import baritone.pathing.movement.MovementState.MovementTarget;
 import baritone.utils.InputOverrideHandler;
-import baritone.api.utils.RotationUtils;
 import baritone.utils.pathing.MutableMoveResult;
 import net.minecraft.entity.player.InventoryPlayer;
 import net.minecraft.init.Items;
@@ -76,7 +76,7 @@ public MovementState updateState(MovementState state) {
                 targetRotation = new Rotation(player().rotationYaw, 90.0F);
 
                 RayTraceResult trace = mc.objectMouseOver;
-                if (trace != null && trace.typeOfHit == RayTraceResult.Type.BLOCK) {
+                if (trace != null && trace.typeOfHit == RayTraceResult.Type.BLOCK && player().rotationPitch > 89.0F) {
                     state.setInput(InputOverrideHandler.Input.CLICK_RIGHT, true);
                 }
             }

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -312,17 +312,17 @@ public class Settings {
     /**
      * Ignore depth when rendering the goal
      */
-    public Setting<Boolean> renderGoalIgnoreDepth = new Setting<>(false);
+    public Setting<Boolean> renderGoalIgnoreDepth = new Setting<>(true);
 
     /**
      * Ignore depth when rendering the selection boxes (to break, to place, to walk into)
      */
-    public Setting<Boolean> renderSelectionBoxesIgnoreDepth = new Setting<>(false);
+    public Setting<Boolean> renderSelectionBoxesIgnoreDepth = new Setting<>(true);
 
     /**
      * Ignore depth when rendering the path
      */
-    public Setting<Boolean> renderPathIgnoreDepth = new Setting<>(false);
+    public Setting<Boolean> renderPathIgnoreDepth = new Setting<>(true);
 
     /**
      * Line width of the path when rendered, in pixels

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -21,9 +21,7 @@
 import baritone.api.pathing.movement.IMovement;
 import baritone.api.pathing.movement.MovementStatus;
 import baritone.api.utils.*;
-import baritone.utils.BlockStateInterface;
-import baritone.utils.Helper;
-import baritone.utils.InputOverrideHandler;
+import baritone.utils.*;
 import net.minecraft.block.BlockLiquid;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.math.BlockPos;

File: src/main/java/baritone/pathing/movement/movements/MovementAscend.java
Patch:
@@ -20,8 +20,8 @@
 import baritone.Baritone;
 import baritone.api.pathing.movement.MovementStatus;
 import baritone.api.utils.BetterBlockPos;
-import baritone.api.utils.RayTraceUtils;
-import baritone.api.utils.RotationUtils;
+import baritone.utils.RayTraceUtils;
+import baritone.utils.RotationUtils;
 import baritone.pathing.movement.CalculationContext;
 import baritone.pathing.movement.Movement;
 import baritone.pathing.movement.MovementHelper;

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -20,9 +20,9 @@
 import baritone.Baritone;
 import baritone.api.pathing.movement.MovementStatus;
 import baritone.api.utils.BetterBlockPos;
-import baritone.api.utils.RayTraceUtils;
+import baritone.utils.RayTraceUtils;
 import baritone.api.utils.Rotation;
-import baritone.api.utils.RotationUtils;
+import baritone.utils.RotationUtils;
 import baritone.pathing.movement.CalculationContext;
 import baritone.pathing.movement.Movement;
 import baritone.pathing.movement.MovementHelper;

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -26,6 +26,8 @@
 import baritone.pathing.movement.MovementState;
 import baritone.utils.BlockStateInterface;
 import baritone.utils.InputOverrideHandler;
+import baritone.utils.RayTraceUtils;
+import baritone.utils.RotationUtils;
 import net.minecraft.block.*;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;

File: src/main/java/baritone/process/MineProcess.java
Patch:
@@ -22,7 +22,7 @@
 import baritone.api.process.IMineProcess;
 import baritone.api.process.PathingCommand;
 import baritone.api.process.PathingCommandType;
-import baritone.api.utils.RotationUtils;
+import baritone.utils.RotationUtils;
 import baritone.cache.CachedChunk;
 import baritone.cache.ChunkPacker;
 import baritone.cache.WorldProvider;

File: src/main/java/baritone/utils/ExampleBaritoneControl.java
Patch:
@@ -23,7 +23,6 @@
 import baritone.api.event.events.ChatEvent;
 import baritone.api.pathing.goals.*;
 import baritone.api.pathing.movement.ActionCosts;
-import baritone.api.utils.RayTraceUtils;
 import baritone.api.utils.SettingsUtil;
 import baritone.behavior.Behavior;
 import baritone.behavior.PathingBehavior;

File: src/main/java/baritone/process/MineProcess.java
Patch:
@@ -241,6 +241,7 @@ public static List<BlockPos> searchWorld(List<Block> mining, int max, World worl
     }
 
     public void addNearby() {
+        knownOreLocations.addAll(droppedItemsScan(mining, world()));
         BlockPos playerFeet = playerFeet();
         int searchDist = 4;//why four? idk
         for (int x = playerFeet.getX() - searchDist; x <= playerFeet.getX() + searchDist; x++) {
@@ -260,6 +261,7 @@ public static List<BlockPos> prune(List<BlockPos> locs2, List<Block> mining, int
         List<BlockPos> dropped = droppedItemsScan(mining, world);
         List<BlockPos> locs = locs2
                 .stream()
+                .distinct()
 
                 // remove any that are within loaded chunks that aren't actually what we want
                 .filter(pos -> world.getChunk(pos) instanceof EmptyChunk || mining.contains(BlockStateInterface.get(pos).getBlock()) || dropped.contains(pos))

File: src/api/java/baritone/api/Settings.java
Patch:
@@ -411,7 +411,7 @@ public class Settings {
      * <p>
      * Also on cosmic prisons this should be set to true since you don't actually mine the ore it just gets replaced with stone.
      */
-    public Setting<Boolean> cancelOnGoalInvalidation = new Setting<>(false);
+    public Setting<Boolean> cancelOnGoalInvalidation = new Setting<>(true);
 
     /**
      * The "axis" command (aka GoalAxis) will go to a axis, or diagonal axis, at this Y level.

File: src/api/java/baritone/api/pathing/calc/IPathFinder.java
Patch:
@@ -18,6 +18,7 @@
 package baritone.api.pathing.calc;
 
 import baritone.api.pathing.goals.Goal;
+import baritone.api.utils.PathCalculationResult;
 
 import java.util.Optional;
 
@@ -35,7 +36,7 @@ public interface IPathFinder {
      *
      * @return The final path
      */
-    Optional<IPath> calculate(long timeout);
+    PathCalculationResult calculate(long timeout);
 
     /**
      * Intended to be called concurrently with calculatePath from a different thread to tell if it's finished yet

File: src/api/java/baritone/api/process/PathingCommandType.java
Patch:
@@ -49,7 +49,7 @@ public enum PathingCommandType {
     /**
      * Set the goal and path.
      * <p>
-     * Revalidate the current goal, and cancel if it's no longer valid, or if the new goal is {@code null}.
+     * Cancel the current path if the goals are not equal
      */
     FORCE_REVALIDATE_GOAL_AND_PATH
 }

File: src/main/java/baritone/process/GetToBlockProcess.java
Patch:
@@ -94,6 +94,6 @@ public String displayName() {
     }
 
     private void rescan() {
-        knownLocations = MineProcess.searchWorld(Collections.singletonList(gettingTo), 64);
+        knownLocations = MineProcess.searchWorld(Collections.singletonList(gettingTo), 64, world());
     }
 }
\ No newline at end of file

File: src/main/java/baritone/process/CustomGoalProcess.java
Patch:
@@ -57,9 +57,6 @@ public void setGoal(Goal goal) {
 
     @Override
     public void path() {
-        if (this.goal == null) {
-            this.goal = baritone.getPathingBehavior().getGoal();
-        }
         this.state = State.PATH_REQUESTED;
     }
 

File: src/main/java/baritone/behavior/PathingBehavior.java
Patch:
@@ -87,6 +87,7 @@ public void onTick(TickEvent event) {
         dispatchEvents();
         if (event.getType() == TickEvent.Type.OUT) {
             secretInternalSegmentCancel();
+            baritone.getPathingControlManager().cancelEverything();
             return;
         }
         tickPath();

File: src/main/java/baritone/process/CustomGoalProcess.java
Patch:
@@ -82,7 +82,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
                 if (calcFailed) {
                     onLostControl();
                 }
-                if (goal.isInGoal(playerFeet())) {
+                if (goal == null || goal.isInGoal(playerFeet())) {
                     onLostControl(); // we're there xd
                 }
                 return new PathingCommand(goal, PathingCommandType.SET_GOAL_AND_PATH);

File: src/api/java/baritone/api/process/PathingCommand.java
Patch:
@@ -26,5 +26,8 @@ public class PathingCommand {
     public PathingCommand(Goal goal, PathingCommandType commandType) {
         this.goal = goal;
         this.commandType = commandType;
+        if (commandType == null) {
+            throw new IllegalArgumentException();
+        }
     }
 }

File: src/api/java/baritone/api/behavior/IPathingBehavior.java
Patch:
@@ -53,8 +53,10 @@ public interface IPathingBehavior extends IBehavior {
      * Cancels the pathing behavior or the current path calculation. Also cancels all processes that could be controlling path.
      * <p>
      * Basically, "MAKE IT STOP".
+     *
+     * @return whether or not the pathing behavior was canceled. All processes are guaranteed to be canceled, but the PathingBehavior might be in the middle of an uncancelable action like a parkour jump
      */
-    void cancelEverything();
+    boolean cancelEverything();
 
     /**
      * Returns the current path, from the current path executor, if there is one.

File: src/main/java/baritone/process/GetToBlockProcess.java
Patch:
@@ -79,7 +79,7 @@ public PathingCommand onTick(boolean calcFailed, boolean isSafeToCancel) {
         if (goal.isInGoal(playerFeet())) {
             onLostControl();
         }
-        return new PathingCommand(goal, PathingCommandType.SET_GOAL_AND_PATH);
+        return new PathingCommand(goal, PathingCommandType.REVALIDATE_GOAL_AND_PATH);
     }
 
     @Override

File: src/main/java/baritone/utils/PathingControlManager.java
Patch:
@@ -86,7 +86,9 @@ public void doTheThingWithTheStuff() {
                 if (cmd.goal != null) {
                     baritone.getPathingBehavior().secretInternalSetGoalAndPath(cmd.goal);
                 }
-                // breaks are for wusses!!!!
+                break;
+            default:
+                throw new IllegalStateException();
         }
     }
 

File: src/main/java/baritone/behavior/MineBehavior.java
Patch:
@@ -94,7 +94,7 @@ private void updateGoal() {
             List<BlockPos> locs2 = prune(new ArrayList<>(locs), mining, 64);
             // can't reassign locs, gotta make a new var locs2, because we use it in a lambda right here, and variables you use in a lambda must be effectively final
             baritone.getPathingBehavior().setGoalAndPath(new GoalComposite(locs2.stream().map(loc -> coalesce(loc, locs2)).toArray(Goal[]::new)));
-            knownOreLocations = locs;
+            knownOreLocations = locs2;
             return;
         }
         // we don't know any ore locations at the moment

File: src/main/java/baritone/pathing/calc/AStarPathFinder.java
Patch:
@@ -131,7 +131,7 @@ protected Optional<IPath> calculate0(long timeout) {
                     throw new IllegalStateException(moves + " " + res.x + " " + newX + " " + res.z + " " + newZ);
                 }
                 if (!moves.dynamicY && res.y != currentNode.y + moves.yOffset) {
-                    throw new IllegalStateException(moves + " " + res.x + " " + newX + " " + res.z + " " + newZ);
+                    throw new IllegalStateException(moves + " " + res.y + " " + (currentNode.y + moves.yOffset));
                 }
                 long hashCode = BetterBlockPos.longHash(res.x, res.y, res.z);
                 if (favoring && favored.contains(hashCode)) {

File: src/main/java/baritone/Baritone.java
Patch:
@@ -95,7 +95,6 @@ public synchronized void init() {
             pathingBehavior = new PathingBehavior(this);
             lookBehavior = new LookBehavior(this);
             memoryBehavior = new MemoryBehavior(this);
-            new LocationTrackingBehavior(this);
             followBehavior = new FollowBehavior(this);
             mineBehavior = new MineBehavior(this);
             new ExampleBaritoneControl(this);

File: src/main/java/baritone/behavior/PathingBehavior.java
Patch:
@@ -83,7 +83,6 @@ public void onTick(TickEvent event) {
             cancel();
             return;
         }
-        mc.playerController.setPlayerCapabilities(mc.player);
         tickPath();
         dispatchEvents();
     }

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -114,7 +114,7 @@ public double calculateCostWithoutCaching() {
      */
     @Override
     public MovementStatus update() {
-        player().capabilities.allowFlying = false;
+        player().capabilities.isFlying = false;
         MovementState latestState = updateState(currentState);
         if (BlockStateInterface.isLiquid(playerFeet())) {
             latestState.setInput(Input.JUMP, true);

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -400,7 +400,7 @@ static void switchToBestToolFor(IBlockState b) {
      * @param ts previously calculated ToolSet
      */
     static void switchToBestToolFor(IBlockState b, ToolSet ts) {
-        mc.player.inventory.currentItem = ts.getBestSlot(b);
+        mc.player.inventory.currentItem = ts.getBestSlot(b.getBlock());
     }
 
     static boolean throwaway(boolean select) {

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -400,7 +400,7 @@ static void switchToBestToolFor(IBlockState b) {
      * @param ts previously calculated ToolSet
      */
     static void switchToBestToolFor(IBlockState b, ToolSet ts) {
-        mc.player.inventory.currentItem = ts.getBestSlot(b);
+        mc.player.inventory.currentItem = ts.getBestSlot(b.getBlock());
     }
 
     static boolean throwaway(boolean select) {

File: buildSrc/src/main/java/baritone/gradle/util/Determinizer.java
Patch:
@@ -32,7 +32,7 @@
 import java.util.stream.Collectors;
 
 /**
- * Make a .jar file deterministic by sorting all entries by name, and setting all the last modified times to 0.
+ * Make a .jar file deterministic by sorting all entries by name, and setting all the last modified times to 42069.
  * This makes the build 100% reproducible since the timestamp when you built it no longer affects the final file.
  *
  * @author leijurv

File: buildSrc/src/main/java/baritone/gradle/util/Determinizer.java
Patch:
@@ -32,7 +32,7 @@
 import java.util.stream.Collectors;
 
 /**
- * Make a .jar file deterministic by sorting all entries by name, and setting all the last modified times to 0.
+ * Make a .jar file deterministic by sorting all entries by name, and setting all the last modified times to 42069.
  * This makes the build 100% reproducible since the timestamp when you built it no longer affects the final file.
  *
  * @author leijurv

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -202,7 +202,7 @@ public MovementState updateState(MovementState state) {
         } else if (!playerFeet().equals(src)) {
             if (playerFeet().equals(src.offset(direction)) || player().posY - playerFeet().getY() > 0.0001) {
 
-                if (!MovementHelper.canWalkOn(dest.down())) {
+                if (!MovementHelper.canWalkOn(dest.down()) && !player().onGround) {
                     BlockPos positionToPlace = dest.down();
                     for (int i = 0; i < 5; i++) {
                         BlockPos against1 = positionToPlace.offset(HORIZONTALS_BUT_ALSO_DOWN____SO_EVERY_DIRECTION_EXCEPT_UP[i]);

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -179,7 +179,7 @@ static boolean isReplacable(int x, int y, int z, IBlockState state) {
             BlockDoublePlant.EnumPlantType kek = state.getValue(BlockDoublePlant.VARIANT);
             return kek == BlockDoublePlant.EnumPlantType.FERN || kek == BlockDoublePlant.EnumPlantType.GRASS;
         }
-        return state.getBlock().isReplaceable(null, null);
+        return state.getMaterial().isReplaceable();
     }
 
     static boolean isDoorPassable(BlockPos doorPos, BlockPos playerPos) {

File: src/main/java/baritone/behavior/MineBehavior.java
Patch:
@@ -153,7 +153,7 @@ public List<BlockPos> scanFor(List<Block> mining, int max) {
         }
         if (!uninteresting.isEmpty()) {
             //long before = System.currentTimeMillis();
-            locs.addAll(WorldScanner.INSTANCE.scanLoadedChunks(uninteresting, max, 10, 26));
+            locs.addAll(WorldScanner.INSTANCE.scanChunkRadius(uninteresting, max, 10, 26));
             //System.out.println("Scan of loaded chunks took " + (System.currentTimeMillis() - before) + "ms");
         }
         return prune(locs, mining, max);

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -99,7 +99,9 @@ static boolean canWalkThrough(int x, int y, int z, IBlockState state) {
                 return true;
             }
             if (snow) {
-                return state.getValue(BlockSnow.LAYERS) < 5; // see BlockSnow.isPassable
+                // the check in BlockSnow.isPassable is layers < 5
+                // while actually, we want < 3 because 3 or greater makes it impassable in a 2 high ceiling
+                return state.getValue(BlockSnow.LAYERS) < 3;
             }
             if (trapdoor) {
                 return !state.getValue(BlockTrapDoor.OPEN); // see BlockTrapDoor.isPassable

File: src/main/java/baritone/pathing/movement/movements/MovementAscend.java
Patch:
@@ -72,7 +72,7 @@ public static double cost(CalculationContext context, int x, int y, int z, int d
         }
         boolean hasToPlace = false;
         if (!MovementHelper.canWalkOn(destX, y, destZ, toPlace)) {
-            if (!context.hasThrowaway()) {
+            if (!context.canPlaceThrowawayAt(destX, y, destZ)) {
                 return COST_INF;
             }
             if (toPlace.getBlock() != Blocks.AIR && !BlockStateInterface.isWater(toPlace.getBlock()) && !MovementHelper.isReplacable(destX, y, destZ, toPlace)) {

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -118,7 +118,7 @@ public static void cost(CalculationContext context, int x, int y, int z, EnumFac
         int destX = x + 4 * xDiff;
         int destZ = z + 4 * zDiff;
         IBlockState toPlace = BlockStateInterface.get(destX, y - 1, destZ);
-        if (!context.hasThrowaway()) {
+        if (!context.canPlaceThrowawayAt(destX, y - 1, destZ)) {
             return;
         }
         if (toPlace.getBlock() != Blocks.AIR && !BlockStateInterface.isWater(toPlace.getBlock()) && !MovementHelper.isReplacable(destX, y - 1, destZ, toPlace)) {
@@ -225,7 +225,7 @@ public MovementState updateState(MovementState state) {
                 }
 
                 state.setInput(InputOverrideHandler.Input.JUMP, true);
-            } else if(!playerFeet().equals(dest.offset(direction, -1))) {
+            } else if (!playerFeet().equals(dest.offset(direction, -1))) {
                 state.setInput(InputOverrideHandler.Input.SPRINT, false);
                 if (playerFeet().equals(src.offset(direction, -1))) {
                     MovementHelper.moveTowards(state, src);

File: src/main/java/baritone/pathing/movement/movements/MovementPillar.java
Patch:
@@ -76,7 +76,7 @@ public static double cost(CalculationContext context, int x, int y, int z) {
                 return LADDER_UP_ONE_COST;
             }
         }
-        if (!context.hasThrowaway() && !ladder) {
+        if (!ladder && !context.canPlaceThrowawayAt(x, y, z)) {
             return COST_INF;
         }
         double hardness = MovementHelper.getMiningDurationTicks(context, x, y + 2, z, toBreak, true);

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -108,7 +108,7 @@ public static double cost(CalculationContext context, int x, int y, int z, int d
                 if (BlockStateInterface.isWater(destOn.getBlock()) && throughWater) {
                     return COST_INF;
                 }
-                if (!context.hasThrowaway()) {
+                if (!context.canPlaceThrowawayAt(destX, y - 1, destZ)) {
                     return COST_INF;
                 }
                 double hardness1 = MovementHelper.getMiningDurationTicks(context, destX, y, destZ, pb0, false);

File: src/main/java/baritone/pathing/calc/AStarPathFinder.java
Patch:
@@ -111,6 +111,9 @@ protected Optional<IPath> calculate0(long timeout) {
                 if (!moves.dynamicXZ && !worldBorder.entirelyContains(newX, newZ)) {
                     continue;
                 }
+                if ((currentNode.y == 256 && moves.yOffset > 0) || (currentNode.y == 0 && moves.yOffset < 0)) {
+                    continue;
+                }
                 res.reset();
                 moves.apply(calcContext, currentNode.x, currentNode.y, currentNode.z, res);
                 numMovementsConsidered++;

File: src/launch/java/baritone/launch/mixins/MixinMinecraft.java
Patch:
@@ -147,7 +147,7 @@ private void postLoadWorld(WorldClient world, String loadingMessage, CallbackInf
             )
     )
     private boolean isAllowUserInput(GuiScreen screen) {
-        return (PathingBehavior.INSTANCE.getCurrent() != null && player != null) || screen.allowUserInput;
+        return (PathingBehavior.INSTANCE.getCurrent() != null && PathingBehavior.INSTANCE.isEnabled() && player != null) || screen.allowUserInput;
     }
 
     @Inject(

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -116,6 +116,9 @@ public MovementStatus update() {
         if (BlockStateInterface.isLiquid(playerFeet())) {
             latestState.setInput(Input.JUMP, true);
         }
+        if (player().isEntityInsideOpaqueBlock()) {
+            latestState.setInput(Input.CLICK_LEFT, true);
+        }
 
         // If the movement target has to force the new rotations, or we aren't using silent move, then force the rotations
         latestState.getTarget().getRotation().ifPresent(rotation ->

File: src/main/java/baritone/pathing/movement/movements/MovementPillar.java
Patch:
@@ -209,7 +209,7 @@ public MovementState updateState(MovementState state) {
                 // If it's been more than forty ticks of trying to jump and we aren't done yet, go forward, maybe we are stuck
                 state.setInput(InputOverrideHandler.Input.MOVE_FORWARD, true);
             }
-            
+
 
             if (!blockIsThere) {
                 Block fr = BlockStateInterface.get(src).getBlock();

File: src/main/java/baritone/behavior/PathingBehavior.java
Patch:
@@ -101,6 +101,7 @@ public void onTick(TickEvent event) {
                     dispatchPathEvent(PathEvent.CONTINUING_ONTO_PLANNED_NEXT);
                     current = next;
                     next = null;
+                    current.onTick(event);
                     return;
                 }
                 // at this point, current just ended, but we aren't in the goal and have no plan for the future

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -224,7 +224,7 @@ public MovementState updateState(MovementState state) {
                 }
 
                 state.setInput(InputOverrideHandler.Input.JUMP, true);
-            } else {
+            } else if(!playerFeet().equals(dest.offset(direction, -1))) {
                 state.setInput(InputOverrideHandler.Input.SPRINT, false);
                 if (playerFeet().equals(src.offset(direction, -1))) {
                     MovementHelper.moveTowards(state, src);

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -114,7 +114,8 @@ public boolean onTick(TickEvent event) {
                         return false;
                     }
                 }
-                for (int i = pathPosition + 2; i < path.length(); i++) { //dont check pathPosition+1. the movement tells us when it's done (e.g. sneak placing)
+                for (int i = pathPosition + 3; i < path.length(); i++) { //dont check pathPosition+1. the movement tells us when it's done (e.g. sneak placing)
+                    // also don't check pathPosition+2 because reasons
                     if (whereAmI.equals(path.positions().get(i))) {
                         if (i - pathPosition > 2) {
                             logDebug("Skipping forward " + (i - pathPosition) + " steps, to " + i);

File: src/main/java/baritone/pathing/calc/Path.java
Patch:
@@ -139,11 +139,12 @@ private static Movement runBackwards(BetterBlockPos src, BetterBlockPos dest) {
         for (Moves moves : Moves.values()) {
             Movement move = moves.apply0(src);
             if (move.getDest().equals(dest)) {
+                // TODO instead of recalculating here, could we take pathNode.cost - pathNode.prevNode.cost to get the cost as-calculated?
                 move.recalculateCost(); // have to calculate the cost at calculation time so we can accurately judge whether a cost increase happened between cached calculation and real execution
                 return move;
             }
         }
-        // leave this as IllegalStateException; it's caught in AbstractNodeCostSearch
+        // this is no longer called from bestPathSoFar, now it's in postprocessing
         throw new IllegalStateException("Movement became impossible during calculation " + src + " " + dest + " " + dest.subtract(src));
     }
 

File: src/main/java/baritone/pathing/movement/movements/MovementFall.java
Patch:
@@ -114,7 +114,9 @@ public MovementState updateState(MovementState state) {
 
     @Override
     public boolean safeToCancel(MovementState state) {
-        return state.getStatus() != MovementStatus.RUNNING;
+        // if we haven't started walking off the edge yet, or if we're in the process of breaking blocks before doing the fall
+        // then it's safe to cancel this
+        return playerFeet().equals(src) || state.getStatus() != MovementStatus.RUNNING;
     }
 
     private static BetterBlockPos[] buildPositionsToBreak(BetterBlockPos src, BetterBlockPos dest) {

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -192,7 +192,7 @@ public boolean safeToCancel() {
     }
 
     protected boolean safeToCancel(MovementState currentState) {
-        return false;
+        return true;
     }
 
     public boolean isFinished() {

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -50,7 +50,7 @@ public class MovementParkour extends Movement {
     private final int dist;
 
     private MovementParkour(BetterBlockPos src, int dist, EnumFacing dir) {
-        super(src, src.offset(dir, dist), EMPTY);
+        super(src, src.offset(dir, dist), EMPTY, src.offset(dir, dist).down());
         this.direction = dir;
         this.dist = dist;
     }

File: src/main/java/baritone/pathing/movement/movements/MovementDescend.java
Patch:
@@ -127,7 +127,9 @@ public static MoveResult dynamicFallCost(CalculationContext context, int x, int
             }
             IBlockState ontoBlock = BlockStateInterface.get(destX, newY, destZ);
             double tentativeCost = WALK_OFF_BLOCK_COST + FALL_N_BLOCKS_COST[fallHeight] + frontBreak;
-            if (ontoBlock.getBlock() == Blocks.WATER && !BlockStateInterface.isFlowing(ontoBlock)) { // TODO flowing check required here?
+            if (ontoBlock.getBlock() == Blocks.WATER && !BlockStateInterface.isFlowing(ontoBlock) && BlockStateInterface.getBlock(destX, newY + 1, destZ) != Blocks.WATERLILY) { // TODO flowing check required here?
+                // lilypads are canWalkThrough, but we can't end a fall that should be broken by water if it's covered by a lilypad
+                // however, don't return impossible in the lilypad scenario, because we could still jump right on it (water that's below a lilypad is canWalkOn so it works)
                 if (Baritone.settings().assumeWalkOnWater.get()) {
                     return IMPOSSIBLE; // TODO fix
                 }

File: src/main/java/baritone/pathing/movement/movements/MovementAscend.java
Patch:
@@ -71,7 +71,7 @@ public static double cost(CalculationContext context, int x, int y, int z, int d
             return COST_INF;// the only thing we can ascend onto from a bottom slab is another bottom slab
         }
         boolean hasToPlace = false;
-        if (!MovementHelper.canWalkOn(destX, y, z, toPlace)) {
+        if (!MovementHelper.canWalkOn(destX, y, destZ, toPlace)) {
             if (!context.hasThrowaway()) {
                 return COST_INF;
             }

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -162,7 +162,7 @@ public MovementState updateState(MovementState state) {
         }
         MovementHelper.moveTowards(state, dest);
         if (playerFeet().equals(dest)) {
-            if (player().posY - playerFeet().getY() < 0.01) {
+            if (player().posY - playerFeet().getY() < 0.094) { // lilypads
                 state.setStatus(MovementState.MovementStatus.SUCCESS);
             }
         } else if (!playerFeet().equals(src)) {

File: src/main/java/baritone/behavior/PathingBehavior.java
Patch:
@@ -341,7 +341,6 @@ private Optional<IPath> findPath(BlockPos start, Optional<IPath> previous) {
                 pos = ((IGoalRenderPos) goal).getGoalPos();
             }
 
-            // TODO simplify each individual goal in a GoalComposite
             if (pos != null && world().getChunk(pos) instanceof EmptyChunk) {
                 logDebug("Simplifying " + goal.toString().split("\\{")[0] + " to GoalXZ due to distance");
                 goal = new GoalXZ(pos.getX(), pos.getZ());

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -122,7 +122,7 @@ public static MoveResult cost(CalculationContext context, int x, int y, int z, E
                 continue;
             }
             if (MovementHelper.canPlaceAgainst(againstX, y - 1, againstZ)) {
-                return new MoveResult(destX, y, destZ, costFromJumpDistance(i) + context.placeBlockCost());
+                return new MoveResult(destX, y, destZ, costFromJumpDistance(4) + context.placeBlockCost());
             }
         }
         return IMPOSSIBLE;
@@ -137,7 +137,7 @@ private static double costFromJumpDistance(int dist) {
             case 4:
                 return SPRINT_ONE_BLOCK_COST * 4;
             default:
-                throw new IllegalStateException("LOL");
+                throw new IllegalStateException("LOL " + dist);
         }
     }
 

File: src/main/java/baritone/utils/BaritoneAutoTest.java
Patch:
@@ -41,7 +41,7 @@ private BaritoneAutoTest() {}
     private static final long TEST_SEED = -928872506371745L;
     private static final BlockPos STARTING_POSITION = new BlockPos(0, 65, 0);
     private static final Goal GOAL = new GoalBlock(69, 121, 420);
-    private static final int MAX_TICKS = 4000;
+    private static final int MAX_TICKS = 3500;
 
     /**
      * Called right after the {@link GameSettings} object is created in the {@link Minecraft} instance.

File: src/main/java/baritone/pathing/movement/movements/MovementDiagonal.java
Patch:
@@ -122,7 +122,7 @@ public static double cost(CalculationContext context, int x, int y, int z, int d
             // Ignore previous multiplier
             // Whatever we were walking on (possibly soul sand) doesn't matter as we're actually floating on water
             // Not even touching the blocks below
-            multiplier = WALK_ONE_IN_WATER_COST;
+            multiplier = context.waterWalkSpeed();
             water = true;
         }
         if (optionA != 0 || optionB != 0) {

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -69,7 +69,7 @@ public static double cost(CalculationContext context, int x, int y, int z, int d
             double WC = WALK_ONE_BLOCK_COST;
             boolean water = false;
             if (BlockStateInterface.isWater(pb0.getBlock()) || BlockStateInterface.isWater(pb1.getBlock())) {
-                WC = WALK_ONE_IN_WATER_COST;
+                WC = context.waterWalkSpeed();
                 water = true;
             } else {
                 if (destOn.getBlock() == Blocks.SOUL_SAND) {
@@ -116,7 +116,7 @@ public static double cost(CalculationContext context, int x, int y, int z, int d
                 }
                 double hardness2 = MovementHelper.getMiningDurationTicks(context, destX, y + 1, destZ, pb1, true);
 
-                double WC = throughWater ? WALK_ONE_IN_WATER_COST : WALK_ONE_BLOCK_COST;
+                double WC = throughWater ? context.waterWalkSpeed() : WALK_ONE_BLOCK_COST;
                 for (int i = 0; i < 4; i++) {
                     int againstX = destX + HORIZONTALS[i].getXOffset();
                     int againstZ = destZ + HORIZONTALS[i].getZOffset();

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -336,6 +336,7 @@ private void sprintIfRequested() {
             if (canSprintInto(current, next)) {
                 if (playerFeet().equals(current.getDest())) {
                     pathPosition++;
+                    clearKeys();
                 }
                 if (!player().isSprinting()) {
                     player().setSprinting(true);

File: src/main/java/baritone/cache/CachedWorld.java
Patch:
@@ -142,6 +142,7 @@ private void updateCachedChunk(CachedChunk chunk) {
     public final void save() {
         if (!Baritone.settings().chunkCaching.get()) {
             System.out.println("Not saving to disk; chunk caching is disabled.");
+            allRegions().forEach(CachedRegion::removeExpired); // even if we aren't saving to disk, still delete expired old chunks from RAM
             return;
         }
         long start = System.nanoTime() / 1000000L;

File: src/main/java/baritone/cache/ChunkPacker.java
Patch:
@@ -106,7 +106,7 @@ public static CachedChunk pack(Chunk chunk) {
                 blocks[z << 4 | x] = Blocks.AIR.getDefaultState();
             }
         }
-        return new CachedChunk(chunk.x, chunk.z, bitSet, blocks, specialBlocks);
+        return new CachedChunk(chunk.x, chunk.z, bitSet, blocks, specialBlocks, System.currentTimeMillis());
     }
 
     public static String blockToString(Block block) {

File: src/main/java/baritone/pathing/movement/movements/MovementPillar.java
Patch:
@@ -65,9 +65,6 @@ public static double cost(CalculationContext context, int x, int y, int z) {
                 }
             }
         }
-        if (!context.hasThrowaway() && !ladder) {
-            return COST_INF;
-        }
         if (fromDown instanceof BlockVine) {
             if (!hasAgainst(x, y, z)) {
                 return COST_INF;
@@ -85,6 +82,9 @@ public static double cost(CalculationContext context, int x, int y, int z) {
                 return LADDER_UP_ONE_COST;
             }
         }
+        if (!context.hasThrowaway() && !ladder) {
+            return COST_INF;
+        }
         double hardness = MovementHelper.getMiningDurationTicks(context, x, y + 2, z, toBreak, true);
         if (hardness >= COST_INF) {
             return COST_INF;

File: src/test/java/baritone/pathing/movement/ActionCostsButOnlyTheOnesThatMakeMickeyDieInsideTest.java
Patch:
@@ -19,7 +19,7 @@
 
 import org.junit.Test;
 
-import static baritone.api.pathing.movement.ActionCostsButOnlyTheOnesThatMakeMickeyDieInside.*;
+import static baritone.api.pathing.movement.ActionCosts.*;
 import static org.junit.Assert.assertEquals;
 
 public class ActionCostsButOnlyTheOnesThatMakeMickeyDieInsideTest {

File: src/main/java/baritone/behavior/PathingBehavior.java
Patch:
@@ -31,6 +31,7 @@
 import baritone.pathing.movement.MovementHelper;
 import baritone.pathing.path.IPath;
 import baritone.pathing.path.PathExecutor;
+import baritone.utils.BlockBreakHelper;
 import baritone.utils.BlockStateInterface;
 import baritone.utils.Helper;
 import baritone.utils.PathRenderer;
@@ -40,7 +41,6 @@
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.world.chunk.EmptyChunk;
 
-import java.awt.*;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
@@ -218,6 +218,7 @@ public void cancel() {
         next = null;
         Baritone.INSTANCE.getInputOverrideHandler().clearAllKeys();
         AbstractNodeCostSearch.getCurrentlyRunning().ifPresent(AbstractNodeCostSearch::cancel);
+        BlockBreakHelper.stopBreakingBlock();
     }
 
     public void forceCancel() { // NOT exposed on public api

File: src/main/java/baritone/cache/CachedWorld.java
Patch:
@@ -116,7 +116,9 @@ public final LinkedList<BlockPos> getLocationsOf(String block, int minimum, int
                     int regionZ = zoff + playerRegionZ;
                     CachedRegion region = getOrCreateRegion(regionX, regionZ);
                     if (region != null) {
-                        res.addAll(region.getLocationsOf(block));
+                        for (BlockPos pos : region.getLocationsOf(block)) {
+                            res.add(pos);
+                        }
                     }
                 }
             }

File: src/main/java/baritone/cache/WorldProvider.java
Patch:
@@ -49,7 +49,7 @@ public enum WorldProvider implements IWorldProvider, Helper {
     private WorldData currentWorld;
 
     @Override
-    public final IWorldData getCurrentWorld() {
+    public final WorldData getCurrentWorld() {
         return this.currentWorld;
     }
 

File: src/main/java/baritone/pathing/calc/AbstractNodeCostSearch.java
Patch:
@@ -18,7 +18,6 @@
 package baritone.pathing.calc;
 
 import baritone.api.pathing.goals.Goal;
-import baritone.behavior.PathingBehavior;
 import baritone.pathing.path.IPath;
 import baritone.utils.pathing.BetterBlockPos;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
@@ -159,7 +158,6 @@ public static long posHash(int x, int y, int z) {
     }
 
     public static void forceCancel() {
-        PathingBehavior.INSTANCE.cancel();
         currentlyRunning = null;
     }
 

File: src/api/java/baritone/api/utils/Rotation.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.utils;
+package baritone.api.utils;
 
 import net.minecraft.util.Tuple;
 

File: src/main/java/baritone/behavior/LookBehaviorUtils.java
Patch:
@@ -17,6 +17,7 @@
 
 package baritone.behavior;
 
+import baritone.api.utils.Rotation;
 import baritone.utils.*;
 import net.minecraft.block.BlockFire;
 import net.minecraft.block.state.IBlockState;

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -18,6 +18,7 @@
 package baritone.pathing.movement;
 
 import baritone.Baritone;
+import baritone.api.utils.Rotation;
 import baritone.behavior.LookBehavior;
 import baritone.behavior.LookBehaviorUtils;
 import baritone.pathing.movement.MovementState.MovementStatus;

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -18,6 +18,7 @@
 package baritone.pathing.movement;
 
 import baritone.Baritone;
+import baritone.api.utils.Rotation;
 import baritone.behavior.LookBehaviorUtils;
 import baritone.pathing.movement.MovementState.MovementTarget;
 import baritone.utils.*;

File: src/main/java/baritone/pathing/movement/MovementState.java
Patch:
@@ -18,7 +18,7 @@
 package baritone.pathing.movement;
 
 import baritone.utils.InputOverrideHandler.Input;
-import baritone.utils.Rotation;
+import baritone.api.utils.Rotation;
 import net.minecraft.util.math.Vec3d;
 
 import java.util.HashMap;

File: src/main/java/baritone/pathing/movement/movements/MovementFall.java
Patch:
@@ -18,6 +18,7 @@
 package baritone.pathing.movement.movements;
 
 import baritone.Baritone;
+import baritone.api.utils.Rotation;
 import baritone.pathing.movement.CalculationContext;
 import baritone.pathing.movement.Movement;
 import baritone.pathing.movement.MovementHelper;

File: src/main/java/baritone/pathing/movement/movements/MovementPillar.java
Patch:
@@ -23,7 +23,7 @@
 import baritone.pathing.movement.MovementState;
 import baritone.utils.BlockStateInterface;
 import baritone.utils.InputOverrideHandler;
-import baritone.utils.Rotation;
+import baritone.api.utils.Rotation;
 import baritone.utils.Utils;
 import baritone.utils.pathing.BetterBlockPos;
 import net.minecraft.block.*;

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -25,7 +25,7 @@
 import baritone.pathing.movement.MovementState;
 import baritone.utils.BlockStateInterface;
 import baritone.utils.InputOverrideHandler;
-import baritone.utils.Rotation;
+import baritone.api.utils.Rotation;
 import baritone.utils.Utils;
 import baritone.utils.pathing.BetterBlockPos;
 import net.minecraft.block.*;

File: src/main/java/baritone/utils/ExampleBaritoneControl.java
Patch:
@@ -368,7 +368,7 @@ public boolean isInGoal(BlockPos pos) {
                     logDirect("No locations for " + mining + " known, cancelling");
                     return;
                 }
-                List<BlockPos> locs = MineBehavior.scanFor(Collections.singletonList(block), 64);
+                List<BlockPos> locs = MineBehavior.INSTANCE.scanFor(Collections.singletonList(block), 64);
                 if (locs.isEmpty()) {
                     logDirect("No locations for " + mining + " known, cancelling");
                     return;

File: src/main/java/baritone/utils/Helper.java
Patch:
@@ -18,6 +18,7 @@
 package baritone.utils;
 
 import baritone.Baritone;
+import baritone.api.utils.Rotation;
 import baritone.utils.pathing.BetterBlockPos;
 import net.minecraft.block.BlockSlab;
 import net.minecraft.client.Minecraft;

File: src/main/java/baritone/utils/RayTraceUtils.java
Patch:
@@ -17,6 +17,7 @@
 
 package baritone.utils;
 
+import baritone.api.utils.Rotation;
 import net.minecraft.util.math.RayTraceResult;
 import net.minecraft.util.math.Vec3d;
 

File: src/main/java/baritone/utils/Utils.java
Patch:
@@ -17,6 +17,7 @@
 
 package baritone.utils;
 
+import baritone.api.utils.Rotation;
 import net.minecraft.block.BlockFire;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.entity.EntityPlayerSP;

File: src/main/java/baritone/behavior/FollowBehavior.java
Patch:
@@ -42,6 +42,7 @@ private FollowBehavior() {}
     @Override
     public void onTick(TickEvent event) {
         if (event.getType() == TickEvent.Type.OUT) {
+            following = null;
             return;
         }
         if (following == null) {

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -23,6 +23,7 @@
 import baritone.pathing.movement.MovementState.MovementStatus;
 import baritone.utils.*;
 import baritone.utils.pathing.BetterBlockPos;
+import net.minecraft.block.BlockLiquid;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.RayTraceResult;
@@ -158,7 +159,7 @@ protected boolean prepared(MovementState state) {
         }
         boolean somethingInTheWay = false;
         for (BetterBlockPos blockPos : positionsToBreak) {
-            if (!MovementHelper.canWalkThrough(blockPos)) {
+            if (!MovementHelper.canWalkThrough(blockPos) && !(BlockStateInterface.getBlock(blockPos) instanceof BlockLiquid)) { // can't break liquid, so don't try
                 somethingInTheWay = true;
                 Optional<Rotation> reachable = LookBehaviorUtils.reachable(blockPos);
                 if (reachable.isPresent()) {
@@ -216,7 +217,7 @@ public void cancel() {
     public void reset() {
         currentState = new MovementState().setStatus(MovementStatus.PREPPING);
     }
-    
+
     /**
      * Calculate latest movement state.
      * Gets called once a tick.

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -360,6 +360,9 @@ static double getMiningDurationTicks(CalculationContext context, int x, int y, i
             if (avoidBreaking(x, y, z, state)) {
                 return COST_INF;
             }
+            if (block instanceof BlockLiquid) {
+                return COST_INF;
+            }
             double m = Blocks.CRAFTING_TABLE.equals(block) ? 10 : 1; // TODO see if this is still necessary. it's from MineBot when we wanted to penalize breaking its crafting table
             double strVsBlock = context.getToolSet().getStrVsBlock(state);
             if (strVsBlock <= 0) {

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -94,6 +94,7 @@ public boolean onTick(TickEvent event) {
 
             if (pathPosition == 0 && whereAmI.equals(whereShouldIBe.up()) && Math.abs(player().motionY) < 0.1 && !(path.movements().get(0) instanceof MovementAscend) && !(path.movements().get(0) instanceof MovementPillar)) {
                 // avoid the Wrong Y coordinate bug
+                // TODO add a timer here
                 new MovementDownward(whereAmI, whereShouldIBe).update();
                 return false;
             }

File: src/main/java/baritone/utils/BlockStateInterface.java
Patch:
@@ -98,6 +98,9 @@ public static Block getBlock(BlockPos pos) {
         return get(pos).getBlock();
     }
 
+    public static Block getBlock(int x, int y, int z) {
+        return get(x, y, z).getBlock();
+    }
 
     /**
      * Returns whether or not the specified block is

File: src/main/java/baritone/pathing/calc/AStarPathFinder.java
Patch:
@@ -90,6 +90,7 @@ protected Optional<IPath> calculate0(long timeout) {
         int pathingMaxChunkBorderFetch = Baritone.settings().pathingMaxChunkBorderFetch.get(); // grab all settings beforehand so that changing settings during pathing doesn't cause a crash or unpredictable behavior
         double favorCoeff = Baritone.settings().backtrackCostFavoringCoefficient.get();
         boolean minimumImprovementRepropagation = Baritone.settings().minimumImprovementRepropagation.get();
+        loopBegin();
         while (!openSet.isEmpty() && numEmptyChunk < pathingMaxChunkBorderFetch && System.nanoTime() / 1000000L - timeoutTime < 0 && !cancelRequested) {
             if (slowPath) {
                 try {
@@ -180,6 +181,7 @@ protected Optional<IPath> calculate0(long timeout) {
         }
         System.out.println(numMovementsConsidered + " movements considered");
         System.out.println("Open set size: " + openSet.size());
+        System.out.println("PathNode map size: " + mapSize());
         System.out.println((int) (numNodes * 1.0 / ((System.nanoTime() / 1000000L - startTime) / 1000F)) + " nodes per second");
         double bestDist = 0;
         for (int i = 0; i < bestSoFar.length; i++) {

File: src/main/java/baritone/behavior/MineBehavior.java
Patch:
@@ -119,11 +119,11 @@ public static GoalComposite coalesce(List<BlockPos> locs) {
                 if (noDown) {
                     return new GoalTwoBlocks(loc);
                 } else {
-                    return new GoalBlock(loc.down());
+                    return new GoalBlock(loc);
                 }
             } else {
                 if (noDown) {
-                    return new GoalBlock(loc);
+                    return new GoalBlock(loc.down());
                 } else {
                     return new GoalTwoBlocks(loc);
                 }

File: src/main/java/baritone/behavior/MineBehavior.java
Patch:
@@ -148,7 +148,7 @@ public static List<BlockPos> scanFor(List<Block> mining, int max) {
         }
         if (!uninteresting.isEmpty()) {
             //long before = System.currentTimeMillis();
-            locs.addAll(WorldScanner.INSTANCE.scanLoadedChunks(uninteresting, max, 10));
+            locs.addAll(WorldScanner.INSTANCE.scanLoadedChunks(uninteresting, max, 10, 26));
             //System.out.println("Scan of loaded chunks took " + (System.currentTimeMillis() - before) + "ms");
         }
         return prune(locs, mining, max);

File: src/main/java/baritone/cache/WorldScanner.java
Patch:
@@ -50,12 +50,14 @@ public List<BlockPos> scanLoadedChunks(List<Block> blocks, int max) {
         boolean foundWithinY = false;
         while (true) {
             boolean allUnloaded = true;
+            boolean foundChunks = false;
             for (int xoff = -searchRadiusSq; xoff <= searchRadiusSq; xoff++) {
                 for (int zoff = -searchRadiusSq; zoff <= searchRadiusSq; zoff++) {
                     int distance = xoff * xoff + zoff * zoff;
                     if (distance != searchRadiusSq) {
                         continue;
                     }
+                    foundChunks = true;
                     int chunkX = xoff + playerChunkX;
                     int chunkZ = zoff + playerChunkZ;
                     Chunk chunk = chunkProvider.getLoadedChunk(chunkX, chunkZ);
@@ -92,7 +94,7 @@ public List<BlockPos> scanLoadedChunks(List<Block> blocks, int max) {
                     }
                 }
             }
-            if (allUnloaded) {
+            if (allUnloaded && foundChunks) {
                 return res;
             }
             if (res.size() >= max && (searchRadiusSq > 26 || (searchRadiusSq > 1 && foundWithinY))) {

File: src/main/java/baritone/pathing/calc/AStarPathFinder.java
Patch:
@@ -68,7 +68,8 @@ protected Optional<IPath> calculate0(long timeout) {
         bestSoFar = new PathNode[COEFFICIENTS.length];//keep track of the best node by the metric of (estimatedCostToGoal + cost / COEFFICIENTS[i])
         double[] bestHeuristicSoFar = new double[COEFFICIENTS.length];
         for (int i = 0; i < bestHeuristicSoFar.length; i++) {
-            bestHeuristicSoFar[i] = Double.MAX_VALUE;
+            bestHeuristicSoFar[i] = startNode.estimatedCostToGoal;
+            bestSoFar[i] = startNode;
         }
         CalculationContext calcContext = new CalculationContext();
         HashSet<BetterBlockPos> favored = favoredPositions.orElse(null);

File: src/main/java/baritone/behavior/LookBehavior.java
Patch:
@@ -92,6 +92,7 @@ public void onPlayerUpdate(PlayerUpdateEvent event) {
             default:
                 break;
         }
+        new Thread().start();
     }
 
     @Override
@@ -111,6 +112,8 @@ public void onPlayerRotationMove(RotationMoveEvent event) {
                         this.target = null;
                     }
                     break;
+                default:
+                    break;
             }
         }
     }

File: src/main/java/baritone/behavior/LookBehavior.java
Patch:
@@ -19,9 +19,9 @@
 
 import baritone.Baritone;
 import baritone.Settings;
+import baritone.api.behavior.Behavior;
 import baritone.api.event.events.PlayerUpdateEvent;
 import baritone.api.event.events.RotationMoveEvent;
-import baritone.api.behavior.Behavior;
 import baritone.utils.Helper;
 import baritone.utils.Rotation;
 
@@ -89,6 +89,8 @@ public void onPlayerUpdate(PlayerUpdateEvent event) {
                 }
                 break;
             }
+            default:
+                break;
         }
     }
 

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -130,8 +130,9 @@ private static double costFromJumpDistance(int dist) {
                 return WALK_ONE_BLOCK_COST * 3;
             case 4:
                 return SPRINT_ONE_BLOCK_COST * 4;
+            default:
+                throw new IllegalStateException("LOL");
         }
-        throw new IllegalStateException("LOL");
     }
 
 

File: src/main/java/baritone/cache/ChunkPacker.java
Patch:
@@ -156,13 +156,11 @@ public static IBlockState pathingTypeToBlock(PathingBlockType type) {
                     case -1:
                         return Blocks.NETHERRACK.getDefaultState();
                     case 0:
+                    default: // The fallback solid type
                         return Blocks.STONE.getDefaultState();
                     case 1:
                         return Blocks.END_STONE.getDefaultState();
                 }
-
-                // The fallback solid type
-                return Blocks.STONE.getDefaultState();
             default:
                 return null;
         }

File: src/main/java/baritone/pathing/goals/GoalBlock.java
Patch:
@@ -77,7 +77,7 @@ public double heuristic(BlockPos pos) {
 
     @Override
     public String toString() {
-        return "Goal{x=" + x + ",y=" + y + ",z=" + z + "}";
+        return "GoalBlock{x=" + x + ",y=" + y + ",z=" + z + "}";
     }
 
     /**
@@ -92,7 +92,7 @@ public static double calculate(double xDiff, int yDiff, double zDiff) {
 
         // if yDiff is 1 that means that pos.getY()-this.y==1 which means that we're 1 block below where we should be
         // therefore going from 0,0,0 to a GoalYLevel of pos.getY()-this.y is accurate
-        heuristic += new GoalYLevel(yDiff).heuristic(new BlockPos(0, 0, 0));
+        heuristic += GoalYLevel.calculate(yDiff, 0);
 
         //use the pythagorean and manhattan mixture from GoalXZ
         heuristic += GoalXZ.calculate(xDiff, zDiff);

File: src/main/java/baritone/pathing/goals/GoalXZ.java
Patch:
@@ -61,7 +61,7 @@ public double heuristic(BlockPos pos) {//mostly copied from GoalBlock
 
     @Override
     public String toString() {
-        return "Goal{x=" + x + ",z=" + z + "}";
+        return "GoalXZ{x=" + x + ",z=" + z + "}";
     }
 
     public static double calculate(double xDiff, double zDiff) {

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -264,7 +264,7 @@ private boolean possiblyOffPath(Tuple<Double, BlockPos> status, double leniency)
             // when we're midair in the middle of a fall, we're very far from both the beginning and the end, but we aren't actually off path
             if (path.movements().get(pathPosition) instanceof MovementFall) {
                 BlockPos fallDest = path.positions().get(pathPosition + 1); // .get(pathPosition) is the block we fell off of
-                if (Utils.playerFlatDistanceToCenter(fallDest) < 0.5) {
+                if (Utils.playerFlatDistanceToCenter(fallDest) < leniency) { // ignore Y by using flat distance
                     return false;
                 }
                 return true;

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -83,7 +83,7 @@ public boolean onTick(TickEvent event) {
         BetterBlockPos whereAmI = playerFeet();
         if (!whereShouldIBe.equals(whereAmI)) {
 
-            if (pathPosition == 0 && whereAmI.equals(whereShouldIBe.up()) && Math.abs(player().motionY) < 0.1) {
+            if (pathPosition == 0 && whereAmI.equals(whereShouldIBe.up()) && Math.abs(player().motionY) < 0.1 && !(path.movements().get(0) instanceof MovementAscend) && !(path.movements().get(0) instanceof MovementPillar)) {
                 // avoid the Wrong Y coordinate bug
                 new MovementDownward(whereAmI, whereShouldIBe).update();
                 return false;

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -250,7 +250,7 @@ static boolean canWalkOn(BlockPos pos, IBlockState state) {
             if (up instanceof BlockLilyPad) {
                 return true;
             }
-            if (BlockStateInterface.isFlowing(state)) {
+            if (BlockStateInterface.isFlowing(state) || block == Blocks.FLOWING_WATER) {
                 // the only scenario in which we can walk on flowing water is if it's under still water with jesus off
                 return BlockStateInterface.isWater(up) && !Baritone.settings().assumeWalkOnWater.get();
             }

File: src/main/java/baritone/pathing/calc/AbstractNodeCostSearch.java
Patch:
@@ -83,6 +83,7 @@ public synchronized Optional<IPath> calculate(long timeout) {
         this.cancelRequested = false;
         try {
             Optional<IPath> path = calculate0(timeout);
+            path.ifPresent(IPath::postprocess);
             isFinished = true;
             return path;
         } catch (Exception e) {

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -236,7 +236,7 @@ public boolean onTick(TickEvent event) {
             Baritone.INSTANCE.getInputOverrideHandler().clearAllKeys();
             return true;
         }
-        if (currentCost - currentMovementInitialCostEstimate > Baritone.settings().maxCostIncrease.get()) {
+        if (!movement.calculatedWhileLoaded() && currentCost - currentMovementInitialCostEstimate > Baritone.settings().maxCostIncrease.get()) {
             logDebug("Original cost " + currentMovementInitialCostEstimate + " current cost " + currentCost + ". Cancelling.");
             pathPosition = path.length() + 3;
             failed = true;

File: src/main/java/baritone/cache/CachedChunk.java
Patch:
@@ -128,6 +128,9 @@ public final IBlockState getBlock(int x, int y, int z) {
             return state;
         }
         PathingBlockType type = getType(x, y, z);
+        if (type == PathingBlockType.SOLID && y == 128 && mc.player.dimension == -1) {
+            return Blocks.BEDROCK.getDefaultState();
+        }
         return ChunkPacker.pathingTypeToBlock(type);
     }
 

File: src/launch/java/baritone/launch/mixins/MixinMinecraft.java
Patch:
@@ -22,7 +22,7 @@
 import baritone.api.event.events.TickEvent;
 import baritone.api.event.events.WorldEvent;
 import baritone.api.event.events.type.EventState;
-import baritone.behavior.impl.PathingBehavior;
+import baritone.behavior.PathingBehavior;
 import baritone.utils.ExampleBaritoneControl;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.entity.EntityPlayerSP;

File: src/main/java/baritone/Baritone.java
Patch:
@@ -19,7 +19,7 @@
 
 import baritone.api.event.listener.IGameEventListener;
 import baritone.api.behavior.Behavior;
-import baritone.behavior.impl.*;
+import baritone.behavior.*;
 import baritone.event.GameEventHandler;
 import baritone.utils.InputOverrideHandler;
 import net.minecraft.client.Minecraft;

File: src/main/java/baritone/behavior/FollowBehavior.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.behavior.impl;
+package baritone.behavior;
 
 import baritone.api.event.events.TickEvent;
 import baritone.api.behavior.Behavior;
@@ -28,14 +28,14 @@
  *
  * @author leijurv
  */
-public class FollowBehavior extends Behavior {
+public final class FollowBehavior extends Behavior {
 
     public static final FollowBehavior INSTANCE = new FollowBehavior();
 
     private FollowBehavior() {
     }
 
-    Entity following;
+    private Entity following;
 
     @Override
     public void onTick(TickEvent event) {

File: src/main/java/baritone/behavior/LocationTrackingBehavior.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.behavior.impl;
+package baritone.behavior;
 
 import baritone.api.behavior.Behavior;
 import baritone.cache.Waypoint;

File: src/main/java/baritone/behavior/LookBehavior.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.behavior.impl;
+package baritone.behavior;
 
 import baritone.Baritone;
 import baritone.Settings;
@@ -25,7 +25,7 @@
 import baritone.utils.Helper;
 import baritone.utils.Rotation;
 
-public class LookBehavior extends Behavior implements Helper {
+public final class LookBehavior extends Behavior implements Helper {
 
     public static final LookBehavior INSTANCE = new LookBehavior();
 

File: src/main/java/baritone/behavior/LookBehaviorUtils.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.behavior.impl;
+package baritone.behavior;
 
 import baritone.utils.*;
 import net.minecraft.block.BlockFire;

File: src/main/java/baritone/behavior/MineBehavior.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.behavior.impl;
+package baritone.behavior;
 
 import baritone.api.event.events.PathEvent;
 import baritone.api.behavior.Behavior;
@@ -43,7 +43,7 @@
  *
  * @author leijurv
  */
-public class MineBehavior extends Behavior implements Helper {
+public final class MineBehavior extends Behavior implements Helper {
 
     public static final MineBehavior INSTANCE = new MineBehavior();
 

File: src/main/java/baritone/behavior/PathingBehavior.java
Patch:
@@ -15,7 +15,7 @@
  * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-package baritone.behavior.impl;
+package baritone.behavior;
 
 import baritone.Baritone;
 import baritone.api.event.events.PathEvent;

File: src/main/java/baritone/pathing/calc/AbstractNodeCostSearch.java
Patch:
@@ -17,7 +17,7 @@
 
 package baritone.pathing.calc;
 
-import baritone.behavior.impl.PathingBehavior;
+import baritone.behavior.PathingBehavior;
 import baritone.pathing.goals.Goal;
 import baritone.pathing.path.IPath;
 import baritone.utils.pathing.BetterBlockPos;

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -18,8 +18,8 @@
 package baritone.pathing.movement;
 
 import baritone.Baritone;
-import baritone.behavior.impl.LookBehavior;
-import baritone.behavior.impl.LookBehaviorUtils;
+import baritone.behavior.LookBehavior;
+import baritone.behavior.LookBehaviorUtils;
 import baritone.pathing.movement.MovementState.MovementStatus;
 import baritone.utils.*;
 import baritone.utils.pathing.BetterBlockPos;

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -18,7 +18,7 @@
 package baritone.pathing.movement;
 
 import baritone.Baritone;
-import baritone.behavior.impl.LookBehaviorUtils;
+import baritone.behavior.LookBehaviorUtils;
 import baritone.pathing.movement.MovementState.MovementTarget;
 import baritone.pathing.movement.movements.MovementDescend;
 import baritone.pathing.movement.movements.MovementFall;

File: src/main/java/baritone/pathing/movement/movements/MovementAscend.java
Patch:
@@ -18,7 +18,7 @@
 package baritone.pathing.movement.movements;
 
 import baritone.Baritone;
-import baritone.behavior.impl.LookBehaviorUtils;
+import baritone.behavior.LookBehaviorUtils;
 import baritone.pathing.movement.CalculationContext;
 import baritone.pathing.movement.Movement;
 import baritone.pathing.movement.MovementHelper;

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -18,7 +18,7 @@
 package baritone.pathing.movement.movements;
 
 import baritone.Baritone;
-import baritone.behavior.impl.LookBehaviorUtils;
+import baritone.behavior.LookBehaviorUtils;
 import baritone.pathing.movement.CalculationContext;
 import baritone.pathing.movement.Movement;
 import baritone.pathing.movement.MovementHelper;

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -18,7 +18,7 @@
 package baritone.pathing.movement.movements;
 
 import baritone.Baritone;
-import baritone.behavior.impl.LookBehaviorUtils;
+import baritone.behavior.LookBehaviorUtils;
 import baritone.pathing.movement.CalculationContext;
 import baritone.pathing.movement.Movement;
 import baritone.pathing.movement.MovementHelper;

File: src/main/java/baritone/utils/ExampleBaritoneControl.java
Patch:
@@ -21,9 +21,9 @@
 import baritone.Settings;
 import baritone.api.event.events.ChatEvent;
 import baritone.api.behavior.Behavior;
-import baritone.behavior.impl.FollowBehavior;
-import baritone.behavior.impl.MineBehavior;
-import baritone.behavior.impl.PathingBehavior;
+import baritone.behavior.FollowBehavior;
+import baritone.behavior.MineBehavior;
+import baritone.behavior.PathingBehavior;
 import baritone.cache.ChunkPacker;
 import baritone.cache.Waypoint;
 import baritone.cache.WorldProvider;

File: src/main/java/baritone/utils/RayTraceUtils.java
Patch:
@@ -20,7 +20,7 @@
 import net.minecraft.util.math.RayTraceResult;
 import net.minecraft.util.math.Vec3d;
 
-import static baritone.behavior.impl.LookBehaviorUtils.calcVec3dFromRotation;
+import static baritone.behavior.LookBehaviorUtils.calcVec3dFromRotation;
 
 /**
  * @author Brady

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -115,6 +115,9 @@ protected double calculateCost(CalculationContext context) {
                 if (srcDown == Blocks.SOUL_SAND || (srcDown instanceof BlockSlab && !((BlockSlab) srcDown).isDouble())) {
                     return COST_INF; // can't sneak and backplace against soul sand or half slabs =/
                 }
+                if (srcDown == Blocks.FLOWING_WATER || srcDown == Blocks.WATER) {
+                    return COST_INF; // this is obviously impossible
+                }
                 WC = WC * SNEAK_ONE_BLOCK_COST / WALK_ONE_BLOCK_COST;//since we are placing, we are sneaking
                 return WC + context.placeBlockCost() + getTotalHardnessOfBlocksToBreak(context);
             }

File: src/main/java/baritone/cache/ChunkPacker.java
Patch:
@@ -152,7 +152,7 @@ private static PathingBlockType getPathingBlockType(IBlockState state) {
             return PathingBlockType.WATER;
         }
 
-        if (MovementHelper.avoidWalkingInto(block) || block.equals(Blocks.FLOWING_WATER) || MovementHelper.isBottomSlab(state)) {
+        if (MovementHelper.avoidWalkingInto(block) || block == Blocks.FLOWING_WATER || MovementHelper.isBottomSlab(state)) {
             return PathingBlockType.AVOID;
         }
         // We used to do an AABB check here

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -209,7 +209,8 @@ static boolean isHorizontalBlockPassable(BlockPos blockPos, IBlockState blockSta
     }
 
     static boolean avoidWalkingInto(Block block) {
-        return BlockStateInterface.isLava(block)
+        return block instanceof BlockLiquid
+                || block instanceof BlockDynamicLiquid
                 || block == Blocks.MAGMA
                 || block == Blocks.CACTUS
                 || block == Blocks.FIRE

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -52,7 +52,7 @@ public static MovementParkour generate(BetterBlockPos src, EnumFacing dir) {
         }
         BlockPos adjBlock = src.down().offset(dir);
         IBlockState adj = BlockStateInterface.get(adjBlock);
-        if (MovementHelper.avoidWalkingInto(adj.getBlock())) { // magma sucks
+        if (MovementHelper.avoidWalkingInto(adj.getBlock()) && adj.getBlock() != Blocks.WATER && adj.getBlock() != Blocks.FLOWING_WATER) { // magma sucks
             return null;
         }
         if (MovementHelper.canWalkOn(adjBlock, adj)) { // don't parkour if we could just traverse (for now)

File: src/main/java/baritone/behavior/impl/PathingBehavior.java
Patch:
@@ -196,6 +196,7 @@ public void cancel() {
         next = null;
         Baritone.INSTANCE.getInputOverrideHandler().clearAllKeys();
         AbstractNodeCostSearch.getCurrentlyRunning().ifPresent(AbstractNodeCostSearch::cancel);
+        mc.playerController.setPlayerCapabilities(mc.player);
     }
 
     /**

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -236,6 +236,7 @@ public boolean onTick(TickEvent event) {
             Baritone.INSTANCE.getInputOverrideHandler().clearAllKeys();
             return true;
         }
+        player().capabilities.allowFlying = false;
         MovementState.MovementStatus movementStatus = movement.update();
         if (movementStatus == UNREACHABLE || movementStatus == FAILED) {
             logDebug("Movement returns status " + movementStatus);

File: src/main/java/baritone/behavior/impl/MineBehavior.java
Patch:
@@ -60,7 +60,7 @@ public void updateGoal() {
         }
         List<BlockPos> locs = scanFor(mining, 64);
         if (locs.isEmpty()) {
-            displayChatMessageRaw("No locations for " + mining + " known, cancelling");
+            logDebug("No locations for " + mining + " known, cancelling");
             cancel();
             return;
         }

File: src/main/java/baritone/pathing/movement/movements/MovementPillar.java
Patch:
@@ -139,7 +139,7 @@ public MovementState updateState(MovementState state) {
         if (ladder) {
             BlockPos against = vine ? getAgainst(src) : src.offset(fromDown.getValue(BlockLadder.FACING).getOpposite());
             if (against == null) {
-                displayChatMessageRaw("Unable to climb vines");
+                logDebug("Unable to climb vines");
                 return state.setStatus(MovementState.MovementStatus.UNREACHABLE);
             }
 

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -171,7 +171,7 @@ public MovementState updateState(MovementState state) {
         boolean isTheBridgeBlockThere = MovementHelper.canWalkOn(positionToPlace) || ladder;
         BlockPos whereAmI = playerFeet();
         if (whereAmI.getY() != dest.getY() && !ladder) {
-            displayChatMessageRaw("Wrong Y coordinate");
+            logDebug("Wrong Y coordinate");
             if (whereAmI.getY() < dest.getY()) {
                 state.setInput(InputOverrideHandler.Input.JUMP, true);
             }
@@ -203,7 +203,7 @@ public MovementState updateState(MovementState state) {
                 against1 = against1.down();
                 if (MovementHelper.canPlaceAgainst(against1)) {
                     if (!MovementHelper.throwaway(true)) { // get ready to place a throwaway block
-                        displayChatMessageRaw("bb pls get me some blocks. dirt or cobble");
+                        logDebug("bb pls get me some blocks. dirt or cobble");
                         return state.setStatus(MovementState.MovementStatus.UNREACHABLE);
                     }
                     state.setInput(InputOverrideHandler.Input.SNEAK, true);
@@ -240,7 +240,7 @@ public MovementState updateState(MovementState state) {
                 // If we are in the block that we are trying to get to, we are sneaking over air and we need to place a block beneath us against the one we just walked off of
                 // Out.log(from + " " + to + " " + faceX + "," + faceY + "," + faceZ + " " + whereAmI);
                 if (!MovementHelper.throwaway(true)) {// get ready to place a throwaway block
-                    displayChatMessageRaw("bb pls get me some blocks. dirt or cobble");
+                    logDebug("bb pls get me some blocks. dirt or cobble");
                     return state.setStatus(MovementState.MovementStatus.UNREACHABLE);
                 }
                 double faceX = (dest.getX() + src.getX() + 1.0D) * 0.5D;

File: src/main/java/baritone/pathing/movement/movements/MovementParkour.java
Patch:
@@ -109,7 +109,7 @@ protected double calculateCost(CalculationContext context) {
         }
         for (int i = 1; i <= 4; i++) {
             BlockPos d = src.offset(direction, i);
-            for (int y = 0; y < 4; y++) {
+            for (int y = 0; y < (i == 1 ? 3 : 4); y++) {
                 if (!MovementHelper.fullyPassable(d.up(y))) {
                     return COST_INF;
                 }

File: src/launch/java/baritone/launch/mixins/MixinEntity.java
Patch:
@@ -18,7 +18,7 @@
 package baritone.launch.mixins;
 
 import baritone.Baritone;
-import baritone.api.event.events.RelativeMoveEvent;
+import baritone.api.event.events.RotationMoveEvent;
 import baritone.api.event.events.type.EventState;
 import net.minecraft.client.Minecraft;
 import net.minecraft.entity.Entity;
@@ -41,7 +41,7 @@ public class MixinEntity {
     private void preMoveRelative(float strafe, float up, float forward, float friction, CallbackInfo ci) {
         Entity _this = (Entity) (Object) this;
         if (_this == Minecraft.getMinecraft().player)
-            Baritone.INSTANCE.getGameEventHandler().onPlayerRelativeMove(new RelativeMoveEvent(EventState.PRE));
+            Baritone.INSTANCE.getGameEventHandler().onPlayerRotationMove(new RotationMoveEvent(EventState.PRE, RotationMoveEvent.Type.MOTION_UPDATE));
     }
 
     @Inject(
@@ -51,6 +51,6 @@ private void preMoveRelative(float strafe, float up, float forward, float fricti
     private void postMoveRelative(float strafe, float up, float forward, float friction, CallbackInfo ci) {
         Entity _this = (Entity) (Object) this;
         if (_this == Minecraft.getMinecraft().player)
-            Baritone.INSTANCE.getGameEventHandler().onPlayerRelativeMove(new RelativeMoveEvent(EventState.POST));
+            Baritone.INSTANCE.getGameEventHandler().onPlayerRotationMove(new RotationMoveEvent(EventState.POST, RotationMoveEvent.Type.MOTION_UPDATE));
     }
 }

File: src/main/java/baritone/api/event/GameEventHandler.java
Patch:
@@ -190,10 +190,10 @@ public final void onReceivePacket(PacketEvent event) {
     }
 
     @Override
-    public void onPlayerRelativeMove(RelativeMoveEvent event) {
+    public void onPlayerRotationMove(RotationMoveEvent event) {
         listeners.forEach(l -> {
             if (canDispatch(l)) {
-                l.onPlayerRelativeMove(event);
+                l.onPlayerRotationMove(event);
             }
         });
     }

File: src/main/java/baritone/api/event/listener/AbstractGameEventListener.java
Patch:
@@ -75,7 +75,7 @@ default void onSendPacket(PacketEvent event) {}
     default void onReceivePacket(PacketEvent event) {}
 
     @Override
-    default void onPlayerRelativeMove(RelativeMoveEvent event) {}
+    default void onPlayerRotationMove(RotationMoveEvent event) {}
 
     @Override
     default void onBlockInteract(BlockInteractEvent event) {}

File: src/main/java/baritone/api/event/GameEventHandler.java
Patch:
@@ -48,15 +48,14 @@
 import org.lwjgl.input.Keyboard;
 
 import java.util.ArrayList;
-import java.util.List;
 
 /**
  * @author Brady
  * @since 7/31/2018 11:04 PM
  */
 public final class GameEventHandler implements IGameEventListener, Helper {
 
-    private final List<IGameEventListener> listeners = new ArrayList<>();
+    private final ArrayList<IGameEventListener> listeners = new ArrayList<>();
 
     @Override
     public final void onTick(TickEvent event) {

File: src/main/java/baritone/Settings.java
Patch:
@@ -85,8 +85,10 @@ public class Settings {
 
     /**
      * You know what it is
+     * <p>
+     * But it's very unreliable and falls off when cornering like all the time so.
      */
-    public Setting<Boolean> allowParkour = new Setting<>(true); // disable in release because its sketchy af lol
+    public Setting<Boolean> allowParkour = new Setting<>(false);
 
     /**
      * For example, if you have Mining Fatigue or Haste, adjust the costs of breaking blocks accordingly.

File: src/main/java/baritone/pathing/goals/GoalBlock.java
Patch:
@@ -17,14 +17,15 @@
 
 package baritone.pathing.goals;
 
+import baritone.utils.interfaces.IGoalRenderPos;
 import net.minecraft.util.math.BlockPos;
 
 /**
  * A specific BlockPos goal
  *
  * @author leijurv
  */
-public class GoalBlock implements Goal {
+public class GoalBlock implements Goal, IGoalRenderPos {
 
     /**
      * The X block position of this goal

File: src/main/java/baritone/pathing/goals/GoalGetToBlock.java
Patch:
@@ -17,6 +17,7 @@
 
 package baritone.pathing.goals;
 
+import baritone.utils.interfaces.IGoalRenderPos;
 import baritone.utils.pathing.BetterBlockPos;
 import net.minecraft.util.math.BlockPos;
 
@@ -26,7 +27,7 @@
  *
  * @author avecowa
  */
-public class GoalGetToBlock implements Goal {
+public class GoalGetToBlock implements Goal, IGoalRenderPos {
 
     private final int x;
     private final int y;

File: src/main/java/baritone/pathing/goals/GoalNear.java
Patch:
@@ -17,9 +17,10 @@
 
 package baritone.pathing.goals;
 
+import baritone.utils.interfaces.IGoalRenderPos;
 import net.minecraft.util.math.BlockPos;
 
-public class GoalNear implements Goal {
+public class GoalNear implements Goal, IGoalRenderPos {
     final int x;
     final int y;
     final int z;

File: src/main/java/baritone/pathing/goals/GoalTwoBlocks.java
Patch:
@@ -17,6 +17,7 @@
 
 package baritone.pathing.goals;
 
+import baritone.utils.interfaces.IGoalRenderPos;
 import net.minecraft.util.math.BlockPos;
 
 /**
@@ -25,7 +26,7 @@
  *
  * @author leijurv
  */
-public class GoalTwoBlocks implements Goal {
+public class GoalTwoBlocks implements Goal, IGoalRenderPos {
 
     /**
      * The X block position of this goal
@@ -69,7 +70,7 @@ public double heuristic(BlockPos pos) {
     }
 
     public BlockPos getGoalPos() {
-        return new BlockPos(x, y, z);
+        return new BlockPos(x, y - 1, z);
     }
 
     @Override

File: src/main/java/baritone/pathing/goals/GoalBlock.java
Patch:
@@ -17,14 +17,15 @@
 
 package baritone.pathing.goals;
 
+import baritone.utils.interfaces.IGoalRenderPos;
 import net.minecraft.util.math.BlockPos;
 
 /**
  * A specific BlockPos goal
  *
  * @author leijurv
  */
-public class GoalBlock implements Goal {
+public class GoalBlock implements Goal, IGoalRenderPos {
 
     /**
      * The X block position of this goal

File: src/main/java/baritone/pathing/goals/GoalGetToBlock.java
Patch:
@@ -17,6 +17,7 @@
 
 package baritone.pathing.goals;
 
+import baritone.utils.interfaces.IGoalRenderPos;
 import baritone.utils.pathing.BetterBlockPos;
 import net.minecraft.util.math.BlockPos;
 
@@ -26,7 +27,7 @@
  *
  * @author avecowa
  */
-public class GoalGetToBlock implements Goal {
+public class GoalGetToBlock implements Goal, IGoalRenderPos {
 
     private final int x;
     private final int y;

File: src/main/java/baritone/pathing/goals/GoalNear.java
Patch:
@@ -17,9 +17,10 @@
 
 package baritone.pathing.goals;
 
+import baritone.utils.interfaces.IGoalRenderPos;
 import net.minecraft.util.math.BlockPos;
 
-public class GoalNear implements Goal {
+public class GoalNear implements Goal, IGoalRenderPos {
     final int x;
     final int y;
     final int z;

File: src/main/java/baritone/pathing/goals/GoalTwoBlocks.java
Patch:
@@ -17,6 +17,7 @@
 
 package baritone.pathing.goals;
 
+import baritone.utils.interfaces.IGoalRenderPos;
 import net.minecraft.util.math.BlockPos;
 
 /**
@@ -25,7 +26,7 @@
  *
  * @author leijurv
  */
-public class GoalTwoBlocks implements Goal {
+public class GoalTwoBlocks implements Goal, IGoalRenderPos {
 
     /**
      * The X block position of this goal
@@ -69,7 +70,7 @@ public double heuristic(BlockPos pos) {
     }
 
     public BlockPos getGoalPos() {
-        return new BlockPos(x, y, z);
+        return new BlockPos(x, y - 1, z);
     }
 
     @Override

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -124,6 +124,7 @@ static boolean fullyPassable(BlockPos pos, IBlockState state) {
         if (block == Blocks.AIR) {
             return true;
         }
+        // exceptions - blocks that are isPassasble true, but we can't actually jump through
         if (block == Blocks.FIRE
                 || block == Blocks.TRIPWIRE
                 || block == Blocks.WEB

File: src/main/java/baritone/pathing/movement/movements/MovementDiagonal.java
Patch:
@@ -47,7 +47,7 @@ public MovementDiagonal(BlockPos start, BlockPos dir1, BlockPos dir2, EnumFacing
     }
 
     public MovementDiagonal(BlockPos start, BlockPos end, BlockPos dir1, BlockPos dir2) {
-        super(start, end, new BlockPos[]{dir1, dir1.up(), dir2, dir2.up(), end, end.up()}, new BlockPos[]{end.down()});
+        super(start, end, new BlockPos[]{dir1, dir1.up(), dir2, dir2.up(), end, end.up()});
     }
 
     @Override

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -55,9 +55,7 @@ static boolean avoidBreaking(BlockPos pos, IBlockState state) {
                 || BlockStateInterface.isLiquid(new BlockPos(pos.getX() + 1, pos.getY(), pos.getZ()))
                 || BlockStateInterface.isLiquid(new BlockPos(pos.getX() - 1, pos.getY(), pos.getZ()))
                 || BlockStateInterface.isLiquid(new BlockPos(pos.getX(), pos.getY(), pos.getZ() + 1))
-                || BlockStateInterface.isLiquid(new BlockPos(pos.getX(), pos.getY(), pos.getZ() - 1))
-                || (!(b instanceof BlockLilyPad && BlockStateInterface.isWater(below)) && below instanceof BlockLiquid);//if it's a lilypad above water, it's ok to break, otherwise don't break if its liquid
-        // TODO revisit this. why is it not okay to break non-lilypads that are right above water?
+                || BlockStateInterface.isLiquid(new BlockPos(pos.getX(), pos.getY(), pos.getZ() - 1));
     }
 
     /**

File: src/main/java/baritone/Baritone.java
Patch:
@@ -21,7 +21,6 @@
 import baritone.behavior.Behavior;
 import baritone.behavior.impl.*;
 import baritone.utils.InputOverrideHandler;
-import baritone.utils.ToolSet;
 import net.minecraft.client.Minecraft;
 
 import java.io.File;
@@ -82,7 +81,6 @@ public synchronized void init() {
             registerBehavior(LocationTrackingBehavior.INSTANCE);
             registerBehavior(FollowBehavior.INSTANCE);
             registerBehavior(MineBehavior.INSTANCE);
-            this.gameEventHandler.registerEventListener(ToolSet.INTERNAL_EVENT_LISTENER);
         }
         this.dir = new File(Minecraft.getMinecraft().gameDir, "baritone");
         if (!Files.exists(dir.toPath())) {

File: src/main/java/baritone/api/event/listener/AbstractGameEventListener.java
Patch:
@@ -74,9 +74,6 @@ default void onSendPacket(PacketEvent event) {}
     @Override
     default void onReceivePacket(PacketEvent event) {}
 
-    @Override
-    default void onQueryItemSlotForBlocks(ItemSlotEvent event) {}
-
     @Override
     default void onPlayerRelativeMove(RelativeMoveEvent event) {}
 

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -149,7 +149,7 @@ protected boolean prepared(MovementState state) {
                 somethingInTheWay = true;
                 Optional<Rotation> reachable = LookBehaviorUtils.reachable(blockPos);
                 if (reachable.isPresent()) {
-                    player().inventory.currentItem = new ToolSet().getBestSlot(BlockStateInterface.get(blockPos));
+                    MovementHelper.switchToBestToolFor(BlockStateInterface.get(blockPos));
                     state.setTarget(new MovementState.MovementTarget(reachable.get(), true)).setInput(Input.CLICK_LEFT, true);
                     return false;
                 }

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -261,7 +261,7 @@ static double getMiningDurationTicks(CalculationContext context, BlockPos positi
                 return COST_INF;
             }
             double m = Blocks.CRAFTING_TABLE.equals(block) ? 10 : 1; // TODO see if this is still necessary. it's from MineBot when we wanted to penalize breaking its crafting table
-            double result = m / context.getToolSet().getStrVsBlock(state, position);
+            double result = m / context.getToolSet().getStrVsBlock(state);
             if (includeFalling) {
                 BlockPos up = position.up();
                 IBlockState above = BlockStateInterface.get(up);

File: src/main/java/baritone/behavior/impl/MineBehavior.java
Patch:
@@ -80,11 +80,11 @@ public void onTick(TickEvent event) {
     }
 
     public void mine(String... mining) {
-        this.mining = mining == null ? null : new ArrayList<>(Arrays.asList(mining));
+        this.mining = mining == null || mining.length == 0 ? null : new ArrayList<>(Arrays.asList(mining));
     }
 
     public void cancel() {
         PathingBehavior.INSTANCE.cancel();
-        mine(null);
+        mine();
     }
 }

File: src/main/java/baritone/Baritone.java
Patch:
@@ -21,6 +21,7 @@
 import baritone.behavior.Behavior;
 import baritone.behavior.impl.*;
 import baritone.utils.InputOverrideHandler;
+import baritone.utils.ToolSet;
 import net.minecraft.client.Minecraft;
 
 import java.io.File;
@@ -81,6 +82,7 @@ public synchronized void init() {
             registerBehavior(LocationTrackingBehavior.INSTANCE);
             registerBehavior(FollowBehavior.INSTANCE);
             registerBehavior(MineBehavior.INSTANCE);
+            this.gameEventHandler.registerEventListener(ToolSet.INTERNAL_EVENT_LISTENER);
         }
         this.dir = new File(Minecraft.getMinecraft().gameDir, "baritone");
         if (!Files.exists(dir.toPath())) {

File: src/main/java/baritone/utils/ExampleBaritoneControl.java
Patch:
@@ -189,8 +189,8 @@ public boolean isInGoal(BlockPos pos) {
         }
         if (msg.toLowerCase().startsWith("mine")) {
             String blockType = msg.toLowerCase().substring(4).trim();
-            MineBehavior.INSTANCE.mine(blockType);
-            displayChatMessageRaw("Started mining blocks of type " + blockType);
+            MineBehavior.INSTANCE.mine(blockType.split(" "));
+            displayChatMessageRaw("Started mining blocks of type " + Arrays.toString(blockType.split(" ")));
             event.cancel();
             return;
         }

File: src/main/java/baritone/pathing/calc/AStarPathFinder.java
Patch:
@@ -200,7 +200,7 @@ protected Optional<IPath> calculate0(long timeout) {
                 return Optional.of(new Path(startNode, bestSoFar[i], numNodes));
             }
         }
-        displayChatMessageRaw("Even with a cost coefficient of " + COEFFICIENTS[COEFFICIENTS.length - 1] + ", I couldn't get more than " + bestDist + " blocks");
+        displayChatMessageRaw("Even with a cost coefficient of " + COEFFICIENTS[COEFFICIENTS.length - 1] + ", I couldn't get more than " + Math.sqrt(bestDist) + " blocks");
         displayChatMessageRaw("No path found =(");
         currentlyRunning = null;
         return Optional.empty();

File: src/main/java/baritone/pathing/movement/movements/MovementFall.java
Patch:
@@ -26,6 +26,7 @@
 import baritone.pathing.movement.MovementState.MovementTarget;
 import baritone.utils.*;
 import net.minecraft.block.BlockFalling;
+import net.minecraft.entity.player.InventoryPlayer;
 import net.minecraft.init.Items;
 import net.minecraft.item.ItemStack;
 import net.minecraft.util.math.BlockPos;
@@ -96,7 +97,7 @@ public MovementState updateState(MovementState state) {
         BlockPos playerFeet = playerFeet();
         Rotation targetRotation = null;
         if (!BlockStateInterface.isWater(dest) && src.getY() - dest.getY() > Baritone.settings().maxFallHeightNoWater.get() && !playerFeet.equals(dest)) {
-            if (!player().inventory.hasItemStack(STACK_BUCKET_WATER) || world().provider.isNether()) {
+            if (!InventoryPlayer.isHotbar(player().inventory.getSlotFor(STACK_BUCKET_WATER)) || world().provider.isNether()) {
                 state.setStatus(MovementStatus.UNREACHABLE);
                 return state;
             }
@@ -119,7 +120,7 @@ public MovementState updateState(MovementState state) {
         }
         if (playerFeet.equals(dest) && (player().posY - playerFeet.getY() < 0.094 // lilypads
                 || BlockStateInterface.isWater(dest))) {
-            if (BlockStateInterface.isWater(dest) && player().inventory.hasItemStack(STACK_BUCKET_EMPTY)) {
+            if (BlockStateInterface.isWater(dest) && InventoryPlayer.isHotbar(player().inventory.getSlotFor(STACK_BUCKET_EMPTY))) {
                 player().inventory.currentItem = player().inventory.getSlotFor(STACK_BUCKET_EMPTY);
                 if (player().motionY >= 0) {
                     return state.setInput(InputOverrideHandler.Input.CLICK_RIGHT, true);

File: src/main/java/baritone/pathing/calc/openset/BinaryHeapOpenSet.java
Patch:
@@ -101,7 +101,7 @@ public final PathNode removeLowest() {
         array[size] = null;
         size--;
         result.heapPosition = -1;
-        if (size < 3) {
+        if (size < 2) {
             return result;
         }
         int index = 1;

File: src/main/java/baritone/pathing/calc/openset/BinaryHeapOpenSet.java
Patch:
@@ -101,7 +101,7 @@ public final PathNode removeLowest() {
         array[size] = null;
         size--;
         result.heapPosition = -1;
-        if (size < 2) {
+        if (size < 3) {
             return result;
         }
         int index = 1;

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -219,9 +219,10 @@ public boolean onTick(TickEvent event) {
         Movement movement = path.movements().get(pathPosition);
         if (costEstimateIndex == null || costEstimateIndex != pathPosition) {
             costEstimateIndex = pathPosition;
-            currentMovementInitialCostEstimate = movement.getCost(null); // do this only once, when the movement starts
+            // do this only once, when the movement starts, and deliberately get the cost as cached when this path was calculated, not the cost as it is right now
+            currentMovementInitialCostEstimate = movement.getCost(null);
             for (int i = 1; i < Baritone.settings().costVerificationLookahead.get() && pathPosition + i < path.length() - 1; i++) {
-                if (path.movements().get(pathPosition + i).recalculateCost() >= ActionCosts.COST_INF) {
+                if (path.movements().get(pathPosition + i).calculateCostWithoutCaching() >= ActionCosts.COST_INF) {
                     displayChatMessageRaw("Something has changed in the world and a future movement has become impossible. Cancelling.");
                     pathPosition = path.length() + 3;
                     failed = true;

File: src/main/java/baritone/utils/ExampleBaritoneControl.java
Patch:
@@ -57,7 +57,9 @@ public void initAndRegister() {
     @Override
     public void onSendChatMessage(ChatEvent event) {
         if (!Baritone.settings().chatControl.get()) {
-            return;
+            if (!Baritone.settings().removePrefix.get()) {
+                return;
+            }
         }
         String msg = event.getMessage();
         if (Baritone.settings().prefix.get()) {

File: src/main/java/baritone/Settings.java
Patch:
@@ -122,8 +122,9 @@ public class Settings {
     /**
      * After calculating a path (potentially through cached chunks), artificially cut it off to just the part that is
      * entirely within currently loaded chunks. Improves path safety because cached chunks are heavily simplified.
+     * See issue #114 for why this is disabled.
      */
-    public Setting<Boolean> cutoffAtLoadBoundary = new Setting<>(true);
+    public Setting<Boolean> cutoffAtLoadBoundary = new Setting<>(false);
 
     /**
      * Stop 5 movements before anything that made the path COST_INF.

File: src/main/java/baritone/api/event/GameEventHandler.java
Patch:
@@ -39,6 +39,7 @@
 import baritone.api.event.events.type.EventState;
 import baritone.api.event.listener.IGameEventListener;
 import baritone.chunk.WorldProvider;
+import baritone.utils.BlockStateInterface;
 import baritone.utils.Helper;
 import baritone.utils.InputOverrideHandler;
 import baritone.utils.interfaces.Toggleable;
@@ -133,6 +134,8 @@ public final void onRenderPass(RenderEvent event) {
     public final void onWorldEvent(WorldEvent event) {
         WorldProvider cache = WorldProvider.INSTANCE;
 
+        BlockStateInterface.clearCachedChunk();
+
         switch (event.getState()) {
             case PRE:
                 break;

File: src/main/java/baritone/pathing/calc/AStarPathFinder.java
Patch:
@@ -169,6 +169,9 @@ protected Optional<IPath> calculate0() {
                     for (int i = 0; i < bestSoFar.length; i++) {
                         double heuristic = neighbor.estimatedCostToGoal + neighbor.cost / COEFFICIENTS[i];
                         if (heuristic < bestHeuristicSoFar[i]) {
+                            if (bestHeuristicSoFar[i] - heuristic < 0.01 && minimumImprovementRepropagation) {
+                                continue;
+                            }
                             bestHeuristicSoFar[i] = heuristic;
                             bestSoFar[i] = neighbor;
                         }

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -136,7 +136,7 @@ public boolean onTick(TickEvent event) {
         }
         if (distanceFromPath > MAX_MAX_DIST_FROM_PATH) {
             if (!(path.movements().get(pathPosition) instanceof MovementFall)) { // might be midair
-                if (pathPosition > 0 || !(path.movements().get(pathPosition - 1) instanceof MovementFall)) { // might have overshot the landing
+                if (pathPosition == 0 || !(path.movements().get(pathPosition - 1) instanceof MovementFall)) { // might have overshot the landing
                     displayChatMessageRaw("too far from path");
                     pathPosition = path.length() + 3;
                     Baritone.INSTANCE.getInputOverrideHandler().clearAllKeys();

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -21,6 +21,7 @@
 import baritone.api.event.events.TickEvent;
 import baritone.pathing.movement.ActionCosts;
 import baritone.pathing.movement.Movement;
+import baritone.pathing.movement.MovementHelper;
 import baritone.pathing.movement.MovementState;
 import baritone.pathing.movement.movements.MovementDescend;
 import baritone.pathing.movement.movements.MovementDiagonal;
@@ -285,7 +286,7 @@ private void sprintIfRequested() {
                 }
             }
             if (next instanceof MovementTraverse) {
-                if (next.getDirection().down().equals(movement.getDirection())) {
+                if (next.getDirection().down().equals(movement.getDirection()) && MovementHelper.canWalkOn(next.getDest().down())) {
                     if (playerFeet().equals(movement.getDest())) {
                         pathPosition++;
                         Baritone.INSTANCE.getInputOverrideHandler().clearAllKeys();

File: src/main/java/baritone/Settings.java
Patch:
@@ -65,11 +65,11 @@ public class Settings {
     /**
      * Blocks that Baritone is allowed to place (as throwaway, for sneak bridging, pillaring, etc.)
      */
-    public Setting<List<Item>> acceptableThrowawayItems = new Setting<>(Arrays.asList(
+    public Setting<List<Item>> acceptableThrowawayItems = new Setting<>(new ArrayList<>(Arrays.asList(
             Item.getItemFromBlock(Blocks.DIRT),
             Item.getItemFromBlock(Blocks.COBBLESTONE),
             Item.getItemFromBlock(Blocks.NETHERRACK)
-    ));
+    )));
 
     /**
      * Enables some more advanced vine features. They're honestly just gimmicks and won't ever be needed in real

File: src/main/java/baritone/pathing/movement/ActionCosts.java
Patch:
@@ -24,7 +24,7 @@ public interface ActionCosts extends ActionCostsButOnlyTheOnesThatMakeMickeyDieI
      */
     double WALK_ONE_BLOCK_COST = 20 / 4.317; // 4.633
     double WALK_ONE_IN_WATER_COST = 20 / 2.2;
-    double WALK_ONE_OVER_SOUL_SAND_COST = WALK_ONE_IN_WATER_COST; // TODO issue #7
+    double WALK_ONE_OVER_SOUL_SAND_COST = WALK_ONE_BLOCK_COST * 0.5; // 0.4 in BlockSoulSand but effectively about half
     double LADDER_UP_ONE_COST = 20 / 2.35;
     double LADDER_DOWN_ONE_COST = 20 / 3.0;
     double SNEAK_ONE_BLOCK_COST = 20 / 1.3;

File: src/main/java/baritone/utils/PathRenderer.java
Patch:
@@ -34,6 +34,7 @@
 import net.minecraft.init.Blocks;
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.MathHelper;
 
 import java.awt.*;
 import java.util.Collection;
@@ -188,7 +189,7 @@ public static void drawLitDankGoalBox(EntityPlayer player, Goal goal, float part
             maxX = goalPos.getX() + 1 - 0.002 - renderPosX;
             minZ = goalPos.getZ() + 0.002 - renderPosZ;
             maxZ = goalPos.getZ() + 1 - 0.002 - renderPosZ;
-            double y = Math.sin(((float) (System.nanoTime() / 1000000L) % 2000L) / 2000F * Math.PI * 2);
+            double y = MathHelper.sin((float) (((float) (System.nanoTime() / 1000000L) % 2000L) / 2000F * Math.PI * 2));
             y1 = 1 + y + goalPos.getY() - renderPosY;
             y2 = 1 - y + goalPos.getY() - renderPosY;
             minY = goalPos.getY() - renderPosY;

File: src/main/java/baritone/utils/Utils.java
Patch:
@@ -54,9 +54,9 @@ public static Rotation calcRotationFromCoords(BlockPos orig, BlockPos dest) {
      */
     public static Rotation calcRotationFromVec3d(Vec3d orig, Vec3d dest) {
         double[] delta = {orig.x - dest.x, orig.y - dest.y, orig.z - dest.z};
-        double yaw = Math.atan2(delta[0], -delta[2]);
+        double yaw = MathHelper.atan2(delta[0], -delta[2]);
         double dist = Math.sqrt(delta[0] * delta[0] + delta[2] * delta[2]);
-        double pitch = Math.atan2(delta[1], dist);
+        double pitch = MathHelper.atan2(delta[1], dist);
         return new Rotation(
                 (float) radToDeg(yaw),
                 (float) radToDeg(pitch)

File: src/main/java/baritone/behavior/impl/MemoryBehavior.java
Patch:
@@ -59,7 +59,7 @@ public void onSendPacket(PacketEvent event) {
                         TileEntityLockable lockable = (TileEntityLockable) tileEntity;
                         int size = lockable.getSizeInventory();
 
-                        this.futureInventories.add(new FutureInventory(System.currentTimeMillis(), size, lockable.getGuiID(), tileEntity.getPos()));
+                        this.futureInventories.add(new FutureInventory(System.nanoTime() / 1000000L, size, lockable.getGuiID(), tileEntity.getPos()));
                     }
                 }
 
@@ -81,7 +81,7 @@ public void onReceivePacket(PacketEvent event) {
                     SPacketOpenWindow packet = event.cast();
 
                     // Remove any entries that were created over a second ago, this should make up for INSANE latency
-                    this.futureInventories.removeIf(i -> System.currentTimeMillis() - i.time > 1000);
+                    this.futureInventories.removeIf(i -> System.nanoTime() / 1000000L - i.time > 1000);
 
                     this.futureInventories.stream()
                             .filter(i -> i.type.equals(packet.getGuiId()) && i.slots == packet.getSlotCount())

File: src/main/java/baritone/chunk/CachedRegion.java
Patch:
@@ -183,7 +183,7 @@ public synchronized void load(String directory) {
                 return;
 
             System.out.println("Loading region " + x + "," + z + " from disk " + path);
-            long start = System.currentTimeMillis();
+            long start = System.nanoTime() / 1000000L;
 
             try (
                     FileInputStream fileIn = new FileInputStream(regionFile.toFile());
@@ -266,7 +266,7 @@ public synchronized void load(String directory) {
                 }
             }
             hasUnsavedChanges = false;
-            long end = System.currentTimeMillis();
+            long end = System.nanoTime() / 1000000L;
             System.out.println("Loaded region successfully in " + (end - start) + "ms");
         } catch (IOException ex) {
             ex.printStackTrace();

File: src/main/java/baritone/chunk/ChunkPacker.java
Patch:
@@ -39,7 +39,7 @@ public final class ChunkPacker implements Helper {
     private ChunkPacker() {}
 
     public static CachedChunk pack(Chunk chunk) {
-        long start = System.currentTimeMillis();
+        long start = System.nanoTime() / 1000000L;
 
         Map<String, List<BlockPos>> specialBlocks = new HashMap<>();
         BitSet bitSet = new BitSet(CachedChunk.SIZE);
@@ -63,7 +63,7 @@ public static CachedChunk pack(Chunk chunk) {
             e.printStackTrace();
         }
         //System.out.println("Packed special blocks: " + specialBlocks);
-        long end = System.currentTimeMillis();
+        long end = System.nanoTime() / 1000000L;
         //System.out.println("Chunk packing took " + (end - start) + "ms for " + chunk.x + "," + chunk.z);
         String[] blockNames = new String[256];
         for (int z = 0; z < 16; z++) {

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -163,7 +163,7 @@ public boolean onTick(TickEvent event) {
                 }
             }
         }*/
-        long start = System.currentTimeMillis();
+        long start = System.nanoTime() / 1000000L;
         for (int i = pathPosition - 10; i < pathPosition + 10; i++) {
             if (i >= 0 && i < path.movements().size()) {
                 Movement m = path.movements().get(i);
@@ -198,7 +198,7 @@ public boolean onTick(TickEvent event) {
             toWalkInto = newWalkInto;
             recalcBP = false;
         }
-        long end = System.currentTimeMillis();
+        long end = System.nanoTime() / 1000000L;
         if (end - start > 0) {
             //displayChatMessageRaw("Recalculating break and place took " + (end - start) + "ms");
         }

File: src/main/java/baritone/utils/PathRenderer.java
Patch:
@@ -188,7 +188,7 @@ public static void drawLitDankGoalBox(EntityPlayer player, Goal goal, float part
             maxX = goalPos.getX() + 1 - 0.002 - renderPosX;
             minZ = goalPos.getZ() + 0.002 - renderPosZ;
             maxZ = goalPos.getZ() + 1 - 0.002 - renderPosZ;
-            double y = Math.sin((System.currentTimeMillis() % 2000L) / 2000F * Math.PI * 2);
+            double y = Math.sin(((float) (System.nanoTime() / 1000000L) % 2000L) / 2000F * Math.PI * 2);
             y1 = 1 + y + goalPos.getY() - renderPosY;
             y2 = 1 - y + goalPos.getY() - renderPosY;
             minY = goalPos.getY() - renderPosY;

File: src/main/java/baritone/pathing/calc/AStarPathFinder.java
Patch:
@@ -101,6 +101,7 @@ protected Optional<IPath> calculate0() {
             }
             if (goal.isInGoal(currentNodePos)) {
                 currentlyRunning = null;
+                displayChatMessageRaw("Took " + (System.currentTimeMillis() - startTime) + "ms, " + numMovementsConsidered + " movements considered");
                 return Optional.of(new Path(startNode, currentNode, numNodes));
             }
             //long constructStart = System.nanoTime();
@@ -193,7 +194,7 @@ protected Optional<IPath> calculate0() {
                 bestDist = dist;
             }
             if (dist > MIN_DIST_PATH * MIN_DIST_PATH) { // square the comparison since distFromStartSq is squared
-                displayChatMessageRaw("Took " + (System.currentTimeMillis() - startTime) + "ms, A* cost coefficient " + COEFFICIENTS[i]);
+                displayChatMessageRaw("Took " + (System.currentTimeMillis() - startTime) + "ms, A* cost coefficient " + COEFFICIENTS[i] + ", " + numMovementsConsidered + " movements considered");
                 if (COEFFICIENTS[i] >= 3) {
                     System.out.println("Warning: cost coefficient is greater than three! Probably means that");
                     System.out.println("the path I found is pretty terrible (like sneak-bridging for dozens of blocks)");

File: src/main/java/baritone/pathing/calc/AStarPathFinder.java
Patch:
@@ -183,13 +183,14 @@ protected Optional<IPath> calculate0() {
                 bestDist = dist;
             }
             if (dist > MIN_DIST_PATH * MIN_DIST_PATH) { // square the comparison since distFromStartSq is squared
+                System.out.println((int) (numNodes * 1.0 / ((System.currentTimeMillis() - startTime) / 1000F)) + " nodes per second");
                 displayChatMessageRaw("Took " + (System.currentTimeMillis() - startTime) + "ms, A* cost coefficient " + COEFFICIENTS[i]);
                 if (COEFFICIENTS[i] >= 3) {
                     System.out.println("Warning: cost coefficient is greater than three! Probably means that");
                     System.out.println("the path I found is pretty terrible (like sneak-bridging for dozens of blocks)");
                     System.out.println("But I'm going to do it anyway, because yolo");
                 }
-                System.out.println("Path goes for " + dist + " blocks");
+                System.out.println("Path goes for " + Math.sqrt(dist) + " blocks");
                 currentlyRunning = null;
                 return Optional.of(new Path(startNode, bestSoFar[i], numNodes));
             }

File: src/main/java/baritone/api/event/GameEventHandler.java
Patch:
@@ -35,10 +35,10 @@
 package baritone.api.event;
 
 import baritone.Baritone;
-import baritone.chunk.WorldProvider;
 import baritone.api.event.events.*;
 import baritone.api.event.events.type.EventState;
 import baritone.api.event.listener.IGameEventListener;
+import baritone.chunk.WorldProvider;
 import baritone.utils.Helper;
 import baritone.utils.InputOverrideHandler;
 import baritone.utils.interfaces.Toggleable;
@@ -135,7 +135,6 @@ public final void onWorldEvent(WorldEvent event) {
 
         switch (event.getState()) {
             case PRE:
-                cache.closeWorld();
                 break;
             case POST:
                 cache.closeWorld();

File: src/main/java/baritone/chunk/ChunkPacker.java
Patch:
@@ -71,7 +71,7 @@ public static CachedChunk pack(Chunk chunk) {
             for (int x = 0; x < 16; x++) {
                 for (int y = 255; y >= 0; y--) {
                     int index = CachedChunk.getPositionIndex(x, y, z);
-                    if (!bitSet.get(index) && !bitSet.get(index + 1)) {
+                    if (bitSet.get(index) || bitSet.get(index + 1)) {
                         String name = blockToString(chunk.getBlockState(x, y, z).getBlock());
                         blockNames[z << 4 | x] = name;
                         continue outerLoop;

File: src/main/java/baritone/pathing/path/PathExecutor.java
Patch:
@@ -46,7 +46,7 @@
  */
 public class PathExecutor implements Helper {
     private static final double MAX_DIST_FROM_PATH = 2;
-    private static final double MAX_TICKS_AWAY = 200; // ten seconds
+    private static final double MAX_TICKS_AWAY = 200; // ten seconds. ok to decrease this, but it must be at least 110, see issue #102
     private final IPath path;
     private int pathPosition;
     private int ticksAway;

File: src/main/java/baritone/Settings.java
Patch:
@@ -323,7 +323,7 @@ public String toString() {
     }
 
     @SuppressWarnings("unchecked")
-    public <T> List<Setting<T>> getByValueType(Class<T> klass) {
+    public <T> List<Setting<T>> getAllValuesByType(Class<T> klass) {
         List<Setting<T>> result = new ArrayList<>();
         for (Setting<?> setting : allSettings) {
             if (setting.klass.equals(klass)) {

File: src/main/java/baritone/utils/ExampleBaritoneControl.java
Patch:
@@ -286,7 +286,7 @@ public boolean isInGoal(BlockPos pos) {
             event.cancel();
             return;
         }
-        List<Settings.Setting<Boolean>> toggleable = Baritone.settings().getByValueType(Boolean.class);
+        List<Settings.Setting<Boolean>> toggleable = Baritone.settings().getAllValuesByType(Boolean.class);
         for (Settings.Setting<Boolean> setting : toggleable) {
             if (msg.equalsIgnoreCase(setting.getName())) {
                 setting.value ^= true;

File: src/main/java/baritone/pathing/movement/MovementHelper.java
Patch:
@@ -158,7 +158,7 @@ static boolean isHorizontalBlockPassable(BlockPos blockPos, IBlockState blockSta
             return true;
         }
 
-        return (facing == playerFacing) == open;
+        return facing == playerFacing == open;
     }
 
     static boolean avoidWalkingInto(Block block) {

File: src/main/java/baritone/pathing/movement/movements/MovementDiagonal.java
Patch:
@@ -17,12 +17,12 @@
 
 package baritone.pathing.movement.movements;
 
-import baritone.Baritone;
 import baritone.pathing.movement.CalculationContext;
 import baritone.pathing.movement.Movement;
 import baritone.pathing.movement.MovementHelper;
 import baritone.pathing.movement.MovementState;
 import baritone.utils.BlockStateInterface;
+import baritone.utils.InputOverrideHandler;
 import net.minecraft.block.BlockMagma;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.init.Blocks;
@@ -65,8 +65,8 @@ public MovementState updateState(MovementState state) {
             state.setStatus(MovementState.MovementStatus.SUCCESS);
             return state;
         }
-        if (!BlockStateInterface.isLiquid(playerFeet()) && Baritone.settings().allowSprint.get()) {
-            player().setSprinting(true);
+        if (!BlockStateInterface.isLiquid(playerFeet())) {
+            state.setInput(InputOverrideHandler.Input.SPRINT, true);
         }
         MovementHelper.moveTowards(state, dest);
         return state;

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -17,7 +17,6 @@
 
 package baritone.pathing.movement.movements;
 
-import baritone.Baritone;
 import baritone.behavior.impl.LookBehaviorUtils;
 import baritone.pathing.movement.CalculationContext;
 import baritone.pathing.movement.Movement;
@@ -190,8 +189,8 @@ public MovementState updateState(MovementState state) {
                 state.setStatus(MovementState.MovementStatus.SUCCESS);
                 return state;
             }
-            if (wasTheBridgeBlockAlwaysThere && !BlockStateInterface.isLiquid(playerFeet()) && Baritone.settings().allowSprint.get()) {
-                player().setSprinting(true);
+            if (wasTheBridgeBlockAlwaysThere && !BlockStateInterface.isLiquid(playerFeet())) {
+                state.setInput(InputOverrideHandler.Input.SPRINT, true);
             }
             Block destDown = BlockStateInterface.get(dest.down()).getBlock();
             if (ladder && (destDown instanceof BlockVine || destDown instanceof BlockLadder)) {

File: src/main/java/baritone/Settings.java
Patch:
@@ -310,7 +310,7 @@ public String toString() {
 
     @SuppressWarnings("unchecked")
     public <T> List<Setting<T>> getByValueType(Class<T> klass) {
-        ArrayList<Setting<T>> result = new ArrayList<>();
+        List<Setting<T>> result = new ArrayList<>();
         for (Setting<?> setting : allSettings) {
             if (setting.klass.equals(klass)) {
                 result.add((Setting<T>) setting);

File: src/main/java/baritone/chunk/CachedRegion.java
Patch:
@@ -235,7 +235,7 @@ public synchronized void load(String directory) {
                             short numSpecialBlockTypes = in.readShort();
                             for (int i = 0; i < numSpecialBlockTypes; i++) {
                                 String blockName = in.readUTF();
-                                ArrayList<BlockPos> locs = new ArrayList<>();
+                                List<BlockPos> locs = new ArrayList<>();
                                 location[x][z].put(blockName, locs);
                                 short numLocations = in.readShort();
                                 for (int j = 0; j < numLocations; j++) {

File: src/main/java/baritone/pathing/movement/movements/MovementDiagonal.java
Patch:
@@ -145,7 +145,7 @@ public List<BlockPos> toBreak() {
         if (toBreakCached != null) {
             return toBreakCached;
         }
-        ArrayList<BlockPos> result = new ArrayList<>();
+        List<BlockPos> result = new ArrayList<>();
         for (int i = 4; i < 6; i++) {
             if (!MovementHelper.canWalkThrough(positionsToBreak[i])) {
                 result.add(positionsToBreak[i]);

File: src/main/java/baritone/utils/ExampleBaritoneControl.java
Patch:
@@ -272,7 +272,7 @@ public boolean isInGoal(BlockPos pos) {
         }
         if (msg.toLowerCase().equals("costs")) {
             Movement[] movements = AStarPathFinder.getConnectedPositions(new BetterBlockPos(playerFeet()), new CalculationContext());
-            ArrayList<Movement> moves = new ArrayList<>(Arrays.asList(movements));
+            List<Movement> moves = new ArrayList<>(Arrays.asList(movements));
             moves.sort(Comparator.comparingDouble(movement -> movement.getCost(new CalculationContext())));
             for (Movement move : moves) {
                 String[] parts = move.getClass().toString().split("\\.");

File: src/main/java/baritone/chunk/ChunkPacker.java
Patch:
@@ -112,7 +112,6 @@ private static PathingBlockType getPathingBlockType(Block block) {
         if (MovementHelper.avoidWalkingInto(block)) {
             return PathingBlockType.AVOID;
         }
-
         // We used to do an AABB check here
         // however, this failed in the nether when you were near a nether fortress
         // because fences check their adjacent blocks in the world for their fence connection status to determine AABB shape

File: src/main/java/baritone/pathing/movement/movements/MovementAscend.java
Patch:
@@ -74,11 +74,10 @@ public void reset() {
     protected double calculateCost(CalculationContext context) {
         IBlockState toPlace = BlockStateInterface.get(positionsToPlace[0]);
         if (!MovementHelper.canWalkOn(positionsToPlace[0], toPlace)) {
-            if (!BlockStateInterface.isAir(toPlace) && !BlockStateInterface.isWater(toPlace.getBlock())) {
-                // TODO replace this check with isReplacable or similar
+            if (!context.hasThrowaway()) {
                 return COST_INF;
             }
-            if (!context.hasThrowaway()) {
+            if (!BlockStateInterface.isAir(toPlace) && !BlockStateInterface.isWater(toPlace.getBlock()) && !MovementHelper.isReplacable(positionsToPlace[0], toPlace)) {
                 return COST_INF;
             }
             for (BlockPos against1 : against) {

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -107,7 +107,7 @@ protected double calculateCost(CalculationContext context) {
                 return COST_INF;
             }
             IBlockState pp0 = BlockStateInterface.get(positionsToPlace[0]);
-            if (pp0.getBlock().equals(Blocks.AIR) || (!BlockStateInterface.isWater(pp0.getBlock()) && pp0.getBlock().isReplaceable(Minecraft.getMinecraft().world, positionsToPlace[0]))) {
+            if (pp0.getBlock().equals(Blocks.AIR) || (!BlockStateInterface.isWater(pp0.getBlock()) && MovementHelper.isReplacable(positionsToPlace[0], pp0))) {
                 if (!context.hasThrowaway()) {
                     return COST_INF;
                 }

File: src/main/java/baritone/chunk/WorldProvider.java
Patch:
@@ -61,7 +61,8 @@ public final void initWorld(WorldClient world) {
             IAnvilChunkLoader loader = (IAnvilChunkLoader) provider.getChunkLoader();
             directory = loader.getChunkSaveLocation();
 
-            if (!directory.getParentFile().getName().equals("saves")) {
+            // In the case of any dimension that isn't the overworld, we'll see a number other than 2 (likely 3)
+            if (directory.toPath().relativize(mc.gameDir.toPath()).getNameCount() != 2) {
                 // subdirectory of the main save directory for this world
                 directory = directory.getParentFile();
             }

File: src/main/java/baritone/utils/ExampleBaritoneControl.java
Patch:
@@ -55,7 +55,7 @@ public void onSendChatMessage(ChatEvent event) {
             return;
         }
         String msg = event.getMessage();
-        if (!msg.startsWith("#"))
+        if (Baritone.settings().prefix.get() && !msg.startsWith("#"))
             return;
 
         msg = msg.substring(1);

File: src/main/java/baritone/chunk/Waypoint.java
Patch:
@@ -55,12 +55,12 @@ public boolean equals(Object o) {
             return false;
         }
         Waypoint w = (Waypoint) o;
-        return name.equals(w.name) && tag == w.tag && creationTimestamp == w.creationTimestamp && location.equals(w.location);
+        return name.equals(w.name) && tag == w.tag && location.equals(w.location);
     }
 
     @Override
     public int hashCode() {
-        return name.hashCode() + tag.hashCode() + (int) creationTimestamp + location.hashCode(); //lol
+        return name.hashCode() + tag.hashCode() + location.hashCode(); //lol
     }
 
     public long creationTimestamp() {

File: src/main/java/baritone/behavior/impl/LocationTrackingBehavior.java
Patch:
@@ -41,7 +41,7 @@ private LocationTrackingBehavior() {}
 
     @Override
     public void onBlockInteract(BlockInteractEvent event) {
-        if (event.getType() == BlockInteractEvent.Type.USE && BlockStateInterface.get(event.getPos()) instanceof BlockBed) {
+        if (event.getType() == BlockInteractEvent.Type.USE && BlockStateInterface.getBlock(event.getPos()) instanceof BlockBed) {
             createWaypointAtPlayer("bed", Waypoint.Tag.BED);
         }
     }

File: src/main/java/baritone/launch/mixins/MixinNetHandlerPlayClient.java
Patch:
@@ -77,6 +77,5 @@ private void postHandleChunkData(SPacketChunkData packetIn, CallbackInfo ci) {
     )
     private void onPlayerDeath(SPacketCombatEvent packetIn, CallbackInfo ci) {
         Baritone.INSTANCE.getGameEventHandler().onPlayerDeath();
-        System.out.println("DIED");
     }
 }

File: src/main/java/baritone/launch/mixins/MixinMinecraft.java
Patch:
@@ -25,6 +25,7 @@
 import baritone.event.events.type.EventState;
 import baritone.utils.ExampleBaritoneControl;
 import net.minecraft.client.Minecraft;
+import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.client.gui.GuiScreen;
 import net.minecraft.client.multiplayer.WorldClient;
 import net.minecraft.item.ItemStack;
@@ -48,6 +49,7 @@
 public class MixinMinecraft {
 
     @Shadow private int leftClickCounter;
+    @Shadow public EntityPlayerSP player;
     @Shadow public WorldClient world;
 
     @Inject(
@@ -160,7 +162,7 @@ private void postLoadWorld(WorldClient world, String loadingMessage, CallbackInf
             )
     )
     private boolean isAllowUserInput(GuiScreen screen) {
-        return PathingBehavior.INSTANCE.getCurrent() != null || screen.allowUserInput;
+        return (PathingBehavior.INSTANCE.getCurrent() != null && player != null) || screen.allowUserInput;
     }
 
     @Inject(

File: src/main/java/baritone/launch/mixins/MixinGameSettings.java
Patch:
@@ -34,7 +34,8 @@ public class MixinGameSettings {
             method = "isKeyDown",
             at = @At(
                     value = "INVOKE",
-                    target = "org/lwjgl/input/Keyboard.isKeyDown(I)Z"
+                    target = "org/lwjgl/input/Keyboard.isKeyDown(I)Z",
+                    remap = false
             )
     )
     private static boolean isKeyDown(int keyCode) {

File: src/main/java/baritone/launch/mixins/MixinGuiContainer.java
Patch:
@@ -37,7 +37,8 @@ public class MixinGuiContainer {
             },
             at = @At(
                     value = "INVOKE",
-                    target = "org/lwjgl/input/Keyboard.isKeyDown(I)Z"
+                    target = "org/lwjgl/input/Keyboard.isKeyDown(I)Z",
+                    remap = false
             )
     )
     private boolean isKeyDown(int keyCode) {

File: src/main/java/baritone/launch/mixins/MixinGuiScreen.java
Patch:
@@ -38,7 +38,8 @@ public class MixinGuiScreen {
             },
             at = @At(
                     value = "INVOKE",
-                    target = "org/lwjgl/input/Keyboard.isKeyDown(I)Z"
+                    target = "org/lwjgl/input/Keyboard.isKeyDown(I)Z",
+                    remap = false
             )
     )
     private static boolean isKeyDown(int keyCode) {

File: src/main/java/baritone/launch/mixins/MixinMinecraft.java
Patch:
@@ -84,7 +84,8 @@ private void runTick(CallbackInfo ci) {
             method = "runTickKeyboard",
             at = @At(
                     value = "INVOKE",
-                    target = "org/lwjgl/input/Keyboard.isKeyDown(I)Z"
+                    target = "org/lwjgl/input/Keyboard.isKeyDown(I)Z",
+                    remap = false
             )
     )
     private boolean Keyboard$isKeyDown(int keyCode) {

File: src/main/java/baritone/pathing/movement/Movement.java
Patch:
@@ -187,6 +187,9 @@ public void cancel() {
         currentState.setStatus(MovementStatus.CANCELED);
     }
 
+    public void reset() {
+        currentState = new MovementState().setStatus(MovementStatus.PREPPING);
+    }
 
     public double getTotalHardnessOfBlocksToBreak(CalculationContext ctx) {
         /*

File: src/main/java/baritone/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -196,10 +196,12 @@ public MovementState updateState(MovementState state) {
                     if (Objects.equals(LookBehaviorUtils.getSelectedBlock().orElse(null), against1) && Minecraft.getMinecraft().player.isSneaking()) {
                         if (LookBehaviorUtils.getSelectedBlock().get().offset(side).equals(positionsToPlace[0])) {
                             state.setInput(InputOverrideHandler.Input.CLICK_RIGHT, true);
+                            return state;
                         } else {
                             // Out.gui("Wrong. " + side + " " + LookBehaviorUtils.getSelectedBlock().get().offset(side) + " " + positionsToPlace[0], Out.Mode.Debug);
                         }
                     }
+                    state.setInput(InputOverrideHandler.Input.CLICK_LEFT, true);
                     System.out.println("Trying to look at " + against1 + ", actually looking at" + LookBehaviorUtils.getSelectedBlock());
                     return state;
                 }

File: src/main/java/baritone/launch/mixins/MixinGuiGameOver.java
Patch:
@@ -19,9 +19,11 @@
 
 import baritone.Baritone;
 import net.minecraft.client.gui.GuiGameOver;
+import net.minecraft.util.text.ITextComponent;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
 /**
  * @author Brady
@@ -31,7 +33,7 @@
 public class MixinGuiGameOver {
 
     @Inject(method = "<init>", at = @At("RETURN"))
-    private void onInit() {
+    private void onInit(ITextComponent causeOfDeathIn, CallbackInfo ci) {
         Baritone.INSTANCE.getGameEventHandler().onPlayerDeath();
     }
 }

File: src/main/java/baritone/Baritone.java
Patch:
@@ -21,6 +21,7 @@
 import baritone.behavior.impl.LookBehavior;
 import baritone.behavior.impl.MemoryBehavior;
 import baritone.behavior.impl.PathingBehavior;
+import baritone.behavior.impl.LocationTrackingBehavior;
 import baritone.event.GameEventHandler;
 import baritone.utils.InputOverrideHandler;
 import net.minecraft.client.Minecraft;
@@ -70,6 +71,7 @@ public synchronized void init() {
             registerBehavior(PathingBehavior.INSTANCE);
             registerBehavior(LookBehavior.INSTANCE);
             registerBehavior(MemoryBehavior.INSTANCE);
+            registerBehavior(LocationTrackingBehavior.INSTANCE);
         }
         this.dir = new File(Minecraft.getMinecraft().gameDir, "baritone");
         if (!Files.exists(dir.toPath())) {

File: src/main/java/baritone/event/listener/AbstractGameEventListener.java
Patch:
@@ -83,4 +83,7 @@ default void onPlayerRelativeMove(RelativeMoveEvent event) {}
 
     @Override
     default void onBlockInteract(BlockInteractEvent event) {}
+
+    @Override
+    default void onPlayerDeath() {}
 }

File: src/main/java/baritone/chunk/Waypoints.java
Patch:
@@ -61,7 +61,7 @@ private synchronized void load(Waypoint.Tag tag) {
         try (
                 FileInputStream fileIn = new FileInputStream(fileName.toFile());
                 BufferedInputStream bufIn = new BufferedInputStream(fileIn);
-                DataInputStream in = new DataInputStream(bufIn);
+                DataInputStream in = new DataInputStream(bufIn)
         ) {
             while (true) {
                 String name = in.readUTF();
@@ -71,7 +71,7 @@ private synchronized void load(Waypoint.Tag tag) {
                 int z = in.readInt();
                 waypoints.get(tag).add(new Waypoint(name, tag, new BlockPos(x, y, z), creationTimestamp));
             }
-        } catch (IOException ex) { }
+        } catch (IOException ignored) {}
     }
 
     private synchronized void save(Waypoint.Tag tag) {

File: src/main/java/baritone/event/listener/AbstractGameEventListener.java
Patch:
@@ -80,4 +80,7 @@ default void onQueryItemSlotForBlocks(ItemSlotEvent event) {}
 
     @Override
     default void onPlayerRelativeMove(RelativeMoveEvent event) {}
+
+    @Override
+    default void onBlockInteract(BlockInteractEvent event) {}
 }

File: src/main/java/baritone/bot/chunk/CachedWorld.java
Patch:
@@ -36,7 +36,7 @@ public final class CachedWorld implements IBlockTypeAccess {
     /**
      * The maximum number of regions in any direction from (0,0)
      */
-    private static final int REGION_MAX = 117188;
+    private static final int REGION_MAX = 58594;
 
     /**
      * A map of all of the cached regions.

File: src/main/java/baritone/launch/mixins/MixinEntity.java
Patch:
@@ -20,7 +20,7 @@
 import baritone.bot.Baritone;
 import baritone.bot.event.events.RelativeMoveEvent;
 import baritone.bot.event.events.type.EventState;
-import baritone.bot.utils.Helper;
+import net.minecraft.client.Minecraft;
 import net.minecraft.entity.Entity;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
@@ -40,7 +40,7 @@ public class MixinEntity {
     )
     private void preMoveRelative(float strafe, float up, float forward, float friction, CallbackInfo ci) {
         Entity _this = (Entity) (Object) this;
-        if (_this == Helper.mc.player)
+        if (_this == Minecraft.getMinecraft().player)
             Baritone.INSTANCE.getGameEventHandler().onPlayerRelativeMove(new RelativeMoveEvent(EventState.PRE));
     }
 
@@ -50,7 +50,7 @@ private void preMoveRelative(float strafe, float up, float forward, float fricti
     )
     private void postMoveRelative(float strafe, float up, float forward, float friction, CallbackInfo ci) {
         Entity _this = (Entity) (Object) this;
-        if (_this == Helper.mc.player)
+        if (_this == Minecraft.getMinecraft().player)
             Baritone.INSTANCE.getGameEventHandler().onPlayerRelativeMove(new RelativeMoveEvent(EventState.POST));
     }
 }

File: src/main/java/baritone/bot/pathing/movement/MovementHelper.java
Patch:
@@ -299,7 +299,7 @@ static Movement generateMovementFallOrDescend(BlockPos pos, BlockPos dest, Calcu
                 continue;
             }
             if (canWalkOn(onto, ontoBlock)) {
-                if (calcContext.hasWaterBucket() || fallHeight <= 4) {
+                if ((calcContext.hasWaterBucket() && fallHeight <= calcContext.maxFallHeightBucket() + 1) || fallHeight <= calcContext.maxFallHeightNoWater() + 1) {
                     // fallHeight = 4 means onto.up() is 3 blocks down, which is the max
                     return new MovementFall(pos, onto.up());
                 } else {

File: src/main/java/baritone/bot/pathing/movement/movements/MovementFall.java
Patch:
@@ -103,7 +103,7 @@ public MovementState updateState(MovementState state) {
             state.setInput(InputOverrideHandler.Input.CLICK_RIGHT, true)
                     .setTarget(new MovementTarget(targetRotation.get(), true));
         } else {
-            state.setTarget(new MovementTarget(Utils.calcRotationFromVec3d(playerHead(), Utils.getBlockPosCenter(dest)), true));
+            state.setTarget(new MovementTarget(Utils.calcRotationFromVec3d(playerHead(), Utils.getBlockPosCenter(dest)), false));
         }
         if (playerFeet.equals(dest) && (player().posY - playerFeet.getY() < 0.094 // lilypads
                 || BlockStateInterface.isWater(dest))) {

File: src/main/java/baritone/bot/pathing/goals/GoalYLevel.java
Patch:
@@ -44,11 +44,11 @@ public boolean isInGoal(BlockPos pos) {
     public double heuristic(BlockPos pos) {
         if (pos.getY() > level) {
             // need to descend
-            return FALL_N_BLOCKS_COST[1] * (pos.getY() - level);
+            return FALL_N_BLOCKS_COST[2] / 2 * (pos.getY() - level);
         }
         if (pos.getY() < level) {
             // need to ascend
-            return (level - pos.getY()) * JUMP_ONE_BLOCK_COST;
+            return (level - pos.getY()) * JUMP_ONE_BLOCK_COST * 0.9;
         }
         return 0;
     }

File: src/main/java/baritone/bot/event/GameEventHandler.java
Patch:
@@ -69,8 +69,8 @@ public final void onTick(TickEvent event) {
     }
 
     @Override
-    public final void onPlayerUpdate() {
-        dispatch(IGameEventListener::onPlayerUpdate);
+    public final void onPlayerUpdate(PlayerUpdateEvent event) {
+        dispatch(listener -> listener.onPlayerUpdate(event));
     }
 
     @Override

File: src/main/java/baritone/bot/event/listener/AbstractGameEventListener.java
Patch:
@@ -52,7 +52,7 @@ public interface AbstractGameEventListener extends IGameEventListener {
     default void onTick(TickEvent event) {}
 
     @Override
-    default void onPlayerUpdate() {}
+    default void onPlayerUpdate(PlayerUpdateEvent event) {}
 
     @Override
     default void onProcessKeyBinds() {}

File: src/main/java/baritone/bot/event/listener/IGameEventListener.java
Patch:
@@ -63,7 +63,7 @@ public interface IGameEventListener {
      * Run once per game tick from before the player rotation is sent to the server.
      * @see EntityPlayerSP#onUpdate()
      */
-    void onPlayerUpdate();
+    void onPlayerUpdate(PlayerUpdateEvent event);
 
     /**
      * Run once per game tick from before keybinds are processed.

File: src/main/java/baritone/bot/Settings.java
Patch:
@@ -157,7 +157,7 @@ public class Settings {
     /**
      * The big one. Download all chunks in simplified 2-bit format and save them for better very-long-distance pathing.
      */
-    public Setting<Boolean> chuckCaching = new Setting<>(false);
+    public Setting<Boolean> chunkCaching = new Setting<>(true);
 
     /**
      * Print all the debug messages to chat

File: src/main/java/baritone/bot/event/GameEventHandler.java
Patch:
@@ -108,7 +108,7 @@ public void onChunkEvent(ChunkEvent event) {
                 && type == ChunkEvent.Type.UNLOAD
                 && mc.world.getChunkProvider().isChunkGeneratedAt(event.getX(), event.getZ());
 
-        if (Baritone.settings().chuckCaching.get()) {
+        if (Baritone.settings().chunkCaching.get()) {
             if (isPostPopulate || isPreUnload) {
                 CachedWorldProvider.INSTANCE.ifWorldLoaded(world ->
                         world.updateCachedChunk(event.getX(), event.getZ(),
@@ -132,7 +132,7 @@ public void onRenderPass(RenderEvent event) {
 
     @Override
     public void onWorldEvent(WorldEvent event) {
-        if (Baritone.settings().chuckCaching.get()) {
+        if (Baritone.settings().chunkCaching.get()) {
             CachedWorldProvider cache = CachedWorldProvider.INSTANCE;
 
             switch (event.getState()) {

File: src/main/java/baritone/bot/pathing/calc/AStarPathFinder.java
Patch:
@@ -94,7 +94,7 @@ protected Optional<IPath> calculate0() {
         int numNodes = 0;
         int numEmptyChunk = 0;
         boolean favoring = favoredPositions.isPresent();
-        boolean cache = Baritone.settings().chuckCaching.get(); // grab all settings beforehand so that changing settings during pathing doesn't cause a crash or unpredictable behavior
+        boolean cache = Baritone.settings().chunkCaching.get(); // grab all settings beforehand so that changing settings during pathing doesn't cause a crash or unpredictable behavior
         int pathingMaxChunkBorderFetch = Baritone.settings().pathingMaxChunkBorderFetch.get();
         double favorCoeff = Baritone.settings().backtrackCostFavoringCoefficient.get();
         boolean minimumImprovementRepropagation = Baritone.settings().minimumImprovementRepropagation.get();

File: src/main/java/baritone/bot/utils/BlockStateInterface.java
Patch:
@@ -41,7 +41,7 @@ public static IBlockState get(BlockPos pos) { // wrappers for future chunk cachi
         if (chunk.isLoaded()) {
             return chunk.getBlockState(pos);
         }
-        if (Baritone.settings().chuckCaching.get()) {
+        if (Baritone.settings().chunkCaching.get()) {
             CachedWorld world = CachedWorldProvider.INSTANCE.getCurrentWorld();
             if (world != null) {
                 PathingBlockType type = world.getBlockType(pos);

File: src/main/java/baritone/bot/chunk/CachedRegion.java
Patch:
@@ -107,6 +107,7 @@ public final void save(String directory) {
             if (!Files.exists(path))
                 Files.createDirectories(path);
 
+            System.out.println("Saving region " + x + "," + z + " to disk");
             Path regionFile = getRegionFile(path, this.x, this.z);
             if (!Files.exists(regionFile))
                 Files.createFile(regionFile);
@@ -139,6 +140,8 @@ public void load(String directory) {
             if (!Files.exists(regionFile))
                 return;
 
+            System.out.println("Loading region " + x + "," + z + " from disk");
+
             byte[] decompressed;
             try (FileInputStream in = new FileInputStream(regionFile.toFile())) {
                 decompressed = GZIPUtils.decompress(in);

File: src/main/java/baritone/bot/event/listener/AbstractGameEventListener.java
Patch:
@@ -74,4 +74,7 @@ default void onSendPacket(PacketEvent event) {}
 
     @Override
     default void onReceivePacket(PacketEvent event) {}
+
+    @Override
+    default void onQueryItemSlotForBlocks(ItemSlotEvent event) {}
 }

File: src/main/java/baritone/bot/pathing/movement/movements/MovementDescend.java
Patch:
@@ -69,7 +69,7 @@ public MovementState updateState(MovementState state) {
         }
         BlockPos playerFeet = playerFeet();
         if (playerFeet.equals(dest)) {
-            if (BlockStateInterface.isLiquid(dest) || player().posY - playerFeet.getY() < 0.01) {
+            if (BlockStateInterface.isLiquid(dest) || player().posY - playerFeet.getY() < 0.094) {
                 // Wait until we're actually on the ground before saying we're done because sometimes we continue to fall if the next action starts immediately
                 state.setStatus(MovementStatus.SUCCESS);
                 return state;

File: src/main/java/baritone/bot/pathing/movement/movements/MovementFall.java
Patch:
@@ -105,7 +105,7 @@ public MovementState updateState(MovementState state) {
         } else {
             state.setTarget(new MovementTarget(Utils.calcRotationFromVec3d(playerHead(), Utils.getBlockPosCenter(dest))));
         }
-        if (playerFeet.equals(dest) && (player().posY - playerFeet.getY() < 0.01
+        if (playerFeet.equals(dest) && (player().posY - playerFeet.getY() < 0.094
                 || BlockStateInterface.isWater(dest))) {
             if (BlockStateInterface.isWater(dest) && player().inventory.hasItemStack(STACK_BUCKET_EMPTY)) {
                 player().inventory.currentItem = player().inventory.getSlotFor(STACK_BUCKET_EMPTY);

File: src/main/java/baritone/bot/pathing/movement/MovementHelper.java
Patch:
@@ -284,6 +284,8 @@ static Movement generateMovementFallOrDescend(BlockPos pos, BlockPos dest, Calcu
         for (int fallHeight = 3; true; fallHeight++) {
             BlockPos onto = dest.down(fallHeight);
             if (onto.getY() < 0) {
+                // when pathing in the end, where you could plausibly fall into the void
+                // this check prevents it from getting the block at y=-1 and crashing
                 break;
             }
             IBlockState ontoBlock = BlockStateInterface.get(onto);

File: src/main/java/baritone/bot/pathing/movement/movements/MovementFall.java
Patch:
@@ -17,6 +17,7 @@
 
 package baritone.bot.pathing.movement.movements;
 
+import baritone.bot.Baritone;
 import baritone.bot.behavior.impl.LookBehaviorUtils;
 import baritone.bot.pathing.movement.CalculationContext;
 import baritone.bot.pathing.movement.Movement;
@@ -51,7 +52,7 @@ protected double calculateCost(CalculationContext context) {
             return COST_INF;
         }
         double placeBucketCost = 0.0;
-        if (!BlockStateInterface.isWater(dest) && src.getY() - dest.getY() > 3) {
+        if (!BlockStateInterface.isWater(dest) && src.getY() - dest.getY() > context.maxFallHeight()) {
             if (!context.hasWaterBucket()) {
                 return COST_INF;
             }
@@ -88,7 +89,7 @@ public MovementState updateState(MovementState state) {
         }
         BlockPos playerFeet = playerFeet();
         Optional<Rotation> targetRotation = Optional.empty();
-        if (!BlockStateInterface.isWater(dest) && src.getY() - dest.getY() > 3 && !playerFeet.equals(dest)) {
+        if (!BlockStateInterface.isWater(dest) && src.getY() - dest.getY() > Baritone.settings().maxFallHeight.get() && !playerFeet.equals(dest)) {
             if (!player().inventory.hasItemStack(STACK_BUCKET_WATER) || world().provider.isNether()) { // TODO check if water bucket is on hotbar or main inventory
                 state.setStatus(MovementStatus.UNREACHABLE);
                 return state;

File: src/main/java/baritone/bot/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -83,7 +83,7 @@ protected double calculateCost(CalculationContext context) {
                     WC += (WALK_ONE_OVER_SOUL_SAND_COST - WALK_ONE_BLOCK_COST) / 2;
                 }
             }
-            if (MovementHelper.canWalkThrough(positionsToBreak[0]) && MovementHelper.canWalkThrough(positionsToBreak[1])) {
+            if (MovementHelper.canWalkThrough(positionsToBreak[0], pb0) && MovementHelper.canWalkThrough(positionsToBreak[1], pb1)) {
                 if (WC == WALK_ONE_BLOCK_COST && context.canSprint()) {
                     // if there's nothing in the way, and this isn't water or soul sand, and we aren't sneak placing
                     // we can sprint =D

File: src/main/java/baritone/bot/pathing/movement/Movement.java
Patch:
@@ -124,9 +124,6 @@ public MovementStatus update() {
     }
 
     protected boolean prepared(MovementState state) {
-        if (state.getStatus() == MovementStatus.WAITING)
-            return true;
-
         boolean somethingInTheWay = false;
         for (BlockPos blockPos : positionsToBreak) {
             if (!MovementHelper.canWalkThrough(blockPos)) {

File: src/main/java/baritone/bot/pathing/movement/MovementHelper.java
Patch:
@@ -47,13 +47,14 @@ static boolean avoidBreaking(BlockPos pos, IBlockState state) {
         Block b = state.getBlock();
         BlockPos below = new BlockPos(pos.getX(), pos.getY() - 1, pos.getZ());
         return Blocks.ICE.equals(b) // ice becomes water, and water can mess up the path
-                || b instanceof BlockSilverfish
+                || b instanceof BlockSilverfish // obvious reasons
                 || BlockStateInterface.isLiquid(new BlockPos(pos.getX(), pos.getY() + 1, pos.getZ()))//don't break anything touching liquid on any side
                 || BlockStateInterface.isLiquid(new BlockPos(pos.getX() + 1, pos.getY(), pos.getZ()))
                 || BlockStateInterface.isLiquid(new BlockPos(pos.getX() - 1, pos.getY(), pos.getZ()))
                 || BlockStateInterface.isLiquid(new BlockPos(pos.getX(), pos.getY(), pos.getZ() + 1))
                 || BlockStateInterface.isLiquid(new BlockPos(pos.getX(), pos.getY(), pos.getZ() - 1))
                 || (!(b instanceof BlockLilyPad && BlockStateInterface.isWater(below)) && BlockStateInterface.isLiquid(below));//if it's a lilypad above water, it's ok to break, otherwise don't break if its liquid
+        // TODO revisit this. why is it not okay to break non-lilypads that are right above water?
     }
 
     /**
@@ -78,7 +79,7 @@ static boolean canWalkThrough(BlockPos pos, IBlockState state) {
         if (BlockStateInterface.isFlowing(state) || BlockStateInterface.isLiquid(pos.up())) {
             return false; // Don't walk through flowing liquids
         }
-        if (block instanceof BlockDoor) {
+        if (block instanceof BlockDoor && !Blocks.IRON_DOOR.equals(block)) {
             return true; // we can just open the door
         }
         return block.isPassable(mc.world, pos);

File: src/main/java/baritone/bot/pathing/goals/GoalYLevel.java
Patch:
@@ -44,7 +44,7 @@ public boolean isInGoal(BlockPos pos) {
     public double heuristic(BlockPos pos) {
         if (pos.getY() > level) {
             // need to descend
-            return FALL_N_BLOCKS_COST[pos.getY() - level];
+            return FALL_N_BLOCKS_COST[1] * (pos.getY() - level);
         }
         if (pos.getY() < level) {
             // need to ascend

File: src/main/java/baritone/bot/Settings.java
Patch:
@@ -31,6 +31,7 @@
 public class Settings {
     public Setting<Boolean> allowBreak = new Setting<>(true);
     public Setting<Boolean> allowPlaceThrowaway = new Setting<>(true);
+    public Setting<Boolean> allowSprint = new Setting<>(true);
     public Setting<Double> costHeuristic = new <Double>Setting<Double>(4D);
     public Setting<Boolean> chuckCaching = new Setting<>(false);
     public Setting<Boolean> allowWaterBucketFall = new Setting<>(true);

File: src/main/java/baritone/bot/pathing/movement/movements/MovementDiagonal.java
Patch:
@@ -116,7 +116,7 @@ protected double calculateCost(CalculationContext context) {
         if (BlockStateInterface.isWater(src) || BlockStateInterface.isWater(dest)) {
             multiplier *= WALK_ONE_IN_WATER_COST / WALK_ONE_BLOCK_COST;
         }
-        if (multiplier == WALK_ONE_BLOCK_COST) {
+        if (multiplier == WALK_ONE_BLOCK_COST && context.canSprint()) {
             // if we aren't edging around anything, and we aren't in water or soul sand
             // we can sprint =D
             multiplier = SPRINT_ONE_BLOCK_COST;

File: src/main/java/baritone/bot/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -77,7 +77,7 @@ protected double calculateCost(CalculationContext context) {
                 WC *= WALK_ONE_IN_WATER_COST / WALK_ONE_BLOCK_COST;
             }
             if (MovementHelper.canWalkThrough(positionsToBreak[0]) && MovementHelper.canWalkThrough(positionsToBreak[1])) {
-                if (WC == WALK_ONE_BLOCK_COST) {
+                if (WC == WALK_ONE_BLOCK_COST && context.canSprint()) {
                     // if there's nothing in the way, and this isn't water or soul sand, and we aren't sneak placing
                     // we can sprint =D
                     WC = SPRINT_ONE_BLOCK_COST;

File: src/main/java/baritone/bot/utils/pathing/BetterBlockPos.java
Patch:
@@ -62,6 +62,9 @@ public int hashCode() {
 
     @Override
     public boolean equals(Object o) {
+        if (o == null) {
+            return false;
+        }
         if (o instanceof BetterBlockPos) {
             BetterBlockPos oth = (BetterBlockPos) o;
             if (oth.hashCode != hashCode) {

File: src/main/java/baritone/bot/pathing/calc/AbstractNodeCostSearch.java
Patch:
@@ -57,7 +57,7 @@ public abstract class AbstractNodeCostSearch implements IPathFinder {
      *
      * @see <a href="https://docs.google.com/document/d/1WVHHXKXFdCR1Oz__KtK8sFqyvSwJN_H4lftkHFgmzlc/edit"></a>
      */
-    protected static final double[] COEFFICIENTS = {1.5, 2, 2.5, 3, 4, 5, 10};
+    protected static final double[] COEFFICIENTS = {1, 1.5, 2, 2.5, 3, 4, 5, 10};
     /**
      * If a path goes less than 5 blocks and doesn't make it to its goal, it's not worth considering.
      */

File: src/main/java/baritone/bot/pathing/goals/GoalXZ.java
Patch:
@@ -23,6 +23,7 @@
 
 /**
  * Useful for long-range goals that don't have a specific Y level.
+ *
  * @author leijurv
  */
 public class GoalXZ implements Goal {
@@ -97,7 +98,7 @@ public static double calculate(double xDiff, double zDiff, double pythaDist) {
             diagonal = z;
         }
         diagonal *= SQRT_2;
-        return (diagonal + straight) * WALK_ONE_BLOCK_COST;
+        return (diagonal + straight) * 4;
     }
 
     public static GoalXZ fromDirection(Vec3d origin, float yaw, double distance) {

File: src/main/java/baritone/bot/pathing/movement/ActionCosts.java
Patch:
@@ -22,13 +22,13 @@ public interface ActionCosts extends ActionCostsButOnlyTheOnesThatMakeMickeyDieI
     /**
      * These costs are measured roughly in ticks btw
      */
-    double WALK_ONE_BLOCK_COST = 20 / 4.317;
+    double WALK_ONE_BLOCK_COST = 20 / 4.317; // // 4.633
     double WALK_ONE_IN_WATER_COST = 20 / 2.2;
     double JUMP_ONE_BLOCK_COST = 5.72854;//see below calculation for fall. 1.25 blocks
     double LADDER_UP_ONE_COST = 20 / 2.35;
     double LADDER_DOWN_ONE_COST = 20 / 3.0;
     double SNEAK_ONE_BLOCK_COST = 20 / 1.3;
-    double SPRINT_ONE_BLOCK_COST = 20 / 5.612;
+    double SPRINT_ONE_BLOCK_COST = 20 / 5.612; // 3.564
     /**
      * To walk off an edge you need to walk 0.5 to the edge then 0.3 to start falling off
      */

File: src/main/java/baritone/bot/pathing/path/PathExecutor.java
Patch:
@@ -91,6 +91,7 @@ public boolean onTick(TickEvent event) {
                     if (whereAmI.equals(path.positions().get(i))) {
                         displayChatMessageRaw("Skipping back " + (pathPosition - i) + " steps, to " + i);
                         pathPosition = Math.max(i - 1, 0); // previous step might not actually be done
+                        Baritone.INSTANCE.getInputOverrideHandler().clearAllKeys();
                         return false;
                     }
                 }
@@ -100,6 +101,7 @@ public boolean onTick(TickEvent event) {
                             displayChatMessageRaw("Skipping forward " + (i - pathPosition) + " steps, to " + i);
                         }
                         pathPosition = i - 1;
+                        Baritone.INSTANCE.getInputOverrideHandler().clearAllKeys();
                         return false;
                     }
                 }

File: src/main/java/baritone/bot/behavior/impl/PathingBehavior.java
Patch:
@@ -45,6 +45,7 @@ public class PathingBehavior extends Behavior {
     private PathingBehavior() {}
 
     private PathExecutor current;
+    private PathExecutor next;
 
     private Goal goal;
 

File: src/main/java/baritone/bot/behavior/impl/LookBehaviorUtils.java
Patch:
@@ -58,7 +58,7 @@ public static Vec3d calcVec3dFromRotation(Rotation rotation) {
 
     public static Optional<Rotation> reachable(BlockPos pos) {
         if (pos.equals(getSelectedBlock().orElse(null))) {
-            return Optional.of(new Rotation(mc.player.rotationYaw, mc.player.rotationPitch + 0.000001f));
+            return Optional.of(new Rotation(mc.player.rotationYaw, mc.player.rotationPitch + 0.0001f));
         }
         Optional<Rotation> possibleRotation = reachableCenter(pos);
         if (possibleRotation.isPresent())

File: src/main/java/baritone/bot/pathing/movement/movements/MovementDescend.java
Patch:
@@ -48,6 +48,8 @@ protected double calculateCost(CalculationContext context) {
         return WALK_ONE_BLOCK_COST * 0.8 + Math.max(FALL_N_BLOCKS_COST[1], WALK_ONE_BLOCK_COST * 0.2) + getTotalHardnessOfBlocksToBreak(context.getToolSet());
     }
 
+    int numTicks = 0;
+
     @Override
     public MovementState updateState(MovementState state) {
         super.updateState(state);
@@ -75,7 +77,7 @@ public MovementState updateState(MovementState state) {
                     double diffZ2 = player().posZ - (fakeDest.getZ() + 0.5);
                     double d = Math.sqrt(diffX2 * diffX2 + diffZ2 * diffZ2);
                     MovementHelper.moveTowards(state, fakeDest);
-                    if (d <= ab) {
+                    if (d <= ab && numTicks++ < 10) {
                         state.setInput(InputOverrideHandler.Input.MOVE_FORWARD, false);
                         state.setInput(InputOverrideHandler.Input.MOVE_BACK, true);
                     }

File: src/main/java/baritone/bot/pathing/movement/ActionCosts.java
Patch:
@@ -26,7 +26,7 @@ public interface ActionCosts extends ActionCostsButOnlyTheOnesThatMakeMickeyDieI
     double WALK_ONE_IN_WATER_COST = 20 / 2.2;
     double JUMP_ONE_BLOCK_COST = 5.72854;//see below calculation for fall. 1.25 blocks
     double LADDER_UP_ONE_COST = 20 / 2.35;
-    double LADDER_DOWN_ONE_COST = 20 / 3;
+    double LADDER_DOWN_ONE_COST = 20 / 3.0;
     double SNEAK_ONE_BLOCK_COST = 20 / 1.3;
     double SPRINT_ONE_BLOCK_COST = 20 / 5.612;
     /**

File: src/main/java/baritone/bot/behavior/impl/LookBehaviorUtils.java
Patch:
@@ -33,7 +33,7 @@ public final class LookBehaviorUtils implements Helper {
     /**
      * Offsets from the root block position to the center of each side.
      */
-    private static final Vec3d[] BLOCK_SIDE_MULTIPLIERS = new Vec3d[] {
+    private static final Vec3d[] BLOCK_SIDE_MULTIPLIERS = new Vec3d[]{
             new Vec3d(0.5, 0, 0.5), // Down
             new Vec3d(0.5, 1, 0.5), // Up
             new Vec3d(0.5, 0.5, 0), // North
@@ -58,7 +58,7 @@ public static Vec3d calcVec3dFromRotation(Rotation rotation) {
 
     public static Optional<Rotation> reachable(BlockPos pos) {
         if (pos.equals(getSelectedBlock().orElse(null))) {
-            return Optional.of(new Rotation(mc.player.rotationYaw, mc.player.rotationPitch));
+            return Optional.of(new Rotation(mc.player.rotationYaw, mc.player.rotationPitch + 0.000001f));
         }
         Optional<Rotation> possibleRotation = reachableCenter(pos);
         if (possibleRotation.isPresent())

File: src/main/java/baritone/bot/pathing/calc/AStarPathFinder.java
Patch:
@@ -175,7 +175,7 @@ protected Optional<IPath> calculate0() {
                 bestDist = dist;
             }
             if (dist > MIN_DIST_PATH * MIN_DIST_PATH) { // square the comparison since distFromStartSq is squared
-                System.out.println("A* cost coefficient " + COEFFICIENTS[i]);
+                displayChatMessageRaw("A* cost coefficient " + COEFFICIENTS[i]);
                 if (COEFFICIENTS[i] >= 3) {
                     System.out.println("Warning: cost coefficient is greater than three! Probably means that");
                     System.out.println("the path I found is pretty terrible (like sneak-bridging for dozens of blocks)");
@@ -186,7 +186,7 @@ protected Optional<IPath> calculate0() {
                 return Optional.of(new Path(startNode, bestSoFar[i], goal, numNodes));
             }
         }
-        System.out.println("Even with a cost coefficient of " + COEFFICIENTS[COEFFICIENTS.length - 1] + ", I couldn't get more than " + bestDist + " blocks =(");
+        displayChatMessageRaw("Even with a cost coefficient of " + COEFFICIENTS[COEFFICIENTS.length - 1] + ", I couldn't get more than " + bestDist + " blocks =(");
         displayChatMessageRaw("No path found =(");
         currentlyRunning = null;
         return Optional.empty();

File: src/main/java/baritone/bot/behavior/impl/PathingBehavior.java
Patch:
@@ -67,6 +67,9 @@ public void onSendChatMessage(ChatEvent event) {
         if (msg.toLowerCase().startsWith("goal")) {
             event.cancel();
             String[] params = msg.toLowerCase().substring(4).trim().split(" ");
+            if (params[0].equals("")) {
+                params = new String[]{};
+            }
             try {
                 switch (params.length) {
                     case 0:

File: src/main/java/baritone/bot/utils/Rotation.java
Patch:
@@ -21,7 +21,7 @@
 
 public class Rotation extends Tuple<Float, Float> {
 
-    public Rotation(float yaw, float pitch) {
+    public Rotation(Float yaw, Float pitch) {
         super(yaw, pitch);
     }
 }

File: src/main/java/baritone/bot/behavior/impl/PathingBehavior.java
Patch:
@@ -281,7 +281,7 @@ public static void drawSelectionBox(EntityPlayer player, BlockPos blockpos, floa
         double d0 = player.lastTickPosX + (player.posX - player.lastTickPosX) * (double) partialTicks;
         double d1 = player.lastTickPosY + (player.posY - player.lastTickPosY) * (double) partialTicks;
         double d2 = player.lastTickPosZ + (player.posZ - player.lastTickPosZ) * (double) partialTicks;
-        AxisAlignedBB toDraw = block.getSelectedBoundingBox(state, Minecraft.getMinecraft().world, blockpos).expand(0.0020000000949949026D, 0.0020000000949949026D, 0.0020000000949949026D).offset(-d0, -d1, -d2);
+        AxisAlignedBB toDraw = state.getSelectedBoundingBox(Minecraft.getMinecraft().world, blockpos).expand(0.0020000000949949026D, 0.0020000000949949026D, 0.0020000000949949026D).offset(-d0, -d1, -d2);
         Tessellator tessellator = Tessellator.getInstance();
         BufferBuilder buffer = tessellator.getBuffer();
         buffer.begin(3, DefaultVertexFormats.POSITION);

File: src/main/java/baritone/bot/pathing/movement/MovementHelper.java
Patch:
@@ -223,7 +223,7 @@ static Movement generateMovementFallOrDescend(BlockPos pos, EnumFacing direction
         // let's see how far we can fall
         for (int fallHeight = 3; true; fallHeight++) {
             BlockPos onto = dest.down(fallHeight);
-            if (onto.getY() <= 0) {
+            if (onto.getY() < 0) {
                 break;
             }
             IBlockState ontoBlock = BlockStateInterface.get(onto);

File: src/main/java/baritone/bot/Baritone.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/GameActionHandler.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/GameEventHandler.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/HookStateManager.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/InputOverrideHandler.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/Memory.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/behavior/Behavior.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/behavior/impl/LookBehavior.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/behavior/impl/LookBehaviorUtils.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/behavior/impl/PathingBehavior.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/chunk/CachedChunk.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/chunk/CachedRegion.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/chunk/CachedWorld.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/chunk/CachedWorldProvider.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/chunk/ChunkPacker.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/chunk/ICachedChunkAccess.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/event/AbstractGameEventListener.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/event/IGameEventListener.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/event/events/ChatEvent.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/event/events/ChunkEvent.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/event/events/PacketEvent.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/event/events/RenderEvent.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/event/events/TickEvent.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/event/events/WorldEvent.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/event/events/type/Cancellable.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/event/events/type/EventState.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/calc/AStarPathFinder.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
@@ -23,7 +23,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/calc/AbstractNodeCostSearch.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/calc/IPathFinder.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/calc/Path.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/calc/PathNode.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/calc/openset/BinaryHeapOpenSet.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/calc/openset/FibonacciHeapOpenSet.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/calc/openset/IOpenSet.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/calc/openset/LinkedListOpenSet.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/goals/Goal.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/goals/GoalBlock.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/goals/GoalComposite.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/goals/GoalGetToBlock.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/goals/GoalRunAway.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/goals/GoalTwoBlocks.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/goals/GoalXZ.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/goals/GoalYLevel.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/movement/ActionCosts.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/movement/ActionCostsButOnlyTheOnesThatMakeMickeyDieInside.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/movement/CalculationContext.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/movement/Movement.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/movement/MovementHelper.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/movement/MovementState.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/movement/movements/MovementAscend.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/movement/movements/MovementDescend.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/movement/movements/MovementDiagonal.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/movement/movements/MovementDownward.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/movement/movements/MovementFall.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/path/IPath.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/path/PathExecutor.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/util/FibonacciHeap.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/util/IBlockTypeAccess.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/util/PathingBlockType.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/utils/BlockStateInterface.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/utils/GZIPUtils.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/utils/Helper.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/utils/Rotation.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/utils/ToolSet.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/utils/Utils.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/launch/BaritoneTweaker.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/launch/BaritoneTweakerForge.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/launch/BaritoneTweakerOptifine.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/launch/mixins/MixinEntityPlayerSP.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/launch/mixins/MixinEntityRenderer.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/launch/mixins/MixinGameSettings.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/launch/mixins/MixinGuiContainer.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/launch/mixins/MixinGuiOverlayDebug.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/launch/mixins/MixinGuiScreen.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/launch/mixins/MixinKeyBinding.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/launch/mixins/MixinMain.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/launch/mixins/MixinMinecraft.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/launch/mixins/MixinNetHandlerPlayClient.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/launch/mixins/MixinNetworkManager.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/launch/mixins/MixinWorldClient.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/launch/mixins/accessor/IAnvilChunkLoader.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/launch/mixins/accessor/IChunkProviderServer.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/test/java/baritone/bot/pathing/calc/openset/OpenSetsTest.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/test/java/baritone/bot/pathing/movement/ActionCostsButOnlyTheOnesThatMakeMickeyDieInsideTest.java
Patch:
@@ -6,7 +6,7 @@
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
- * Foobar is distributed in the hope that it will be useful,
+ * Baritone is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

File: src/main/java/baritone/bot/pathing/movement/movements/MovementFall.java
Patch:
@@ -69,6 +69,7 @@ public MovementState updateState(MovementState state) {
                 if (!BlockStateInterface.isWater(dest) && src.getY() - dest.getY() > 3) {
                     if (!player().inventory.hasItemStack(new ItemStack(new ItemBucket(Blocks.WATER)))) {
                         state.setStatus(MovementStatus.UNREACHABLE);
+                        return state;
                     }
                     player().inventory.currentItem = player().inventory.getSlotFor(new ItemStack(new ItemBucket(Blocks.WATER)));
                     LookBehaviorUtils.reachable(dest).ifPresent(rotation ->

File: src/main/java/baritone/bot/pathing/path/PathExecutor.java
Patch:
@@ -141,6 +141,7 @@ public void onTick(TickEvent event) {
             System.out.println("Movement done, next path");
             pathPosition++;
             ticksOnCurrent = 0;
+            onTick(event);
         } else {
             ticksOnCurrent++;
             if (ticksOnCurrent > movement.recalculateCost() + 100) {

File: src/main/java/baritone/bot/pathing/movement/movements/MovementDiagonal.java
Patch:
@@ -40,7 +40,7 @@ public MovementState updateState(MovementState state) {
             state.setStatus(MovementState.MovementStatus.SUCCESS);
             return state;
         }
-        moveTowards(positionsToBreak[0]);
+        moveTowards(dest);
         return state;
     }
 

File: src/main/java/baritone/bot/pathing/movement/movements/MovementFall.java
Patch:
@@ -67,13 +67,13 @@ public MovementState updateState(MovementState state) {
             case RUNNING:
                 BlockPos playerFeet = playerFeet();
                 if (!BlockStateInterface.isWater(dest) && src.getY() - dest.getY() > 3) {
-                    if(!player().inventory.hasItemStack(new ItemStack(new ItemBucket(Blocks.WATER)))) {
+                    if (!player().inventory.hasItemStack(new ItemStack(new ItemBucket(Blocks.WATER)))) {
                         state.setStatus(MovementStatus.UNREACHABLE);
                     }
                     player().inventory.currentItem = player().inventory.getSlotFor(new ItemStack(new ItemBucket(Blocks.WATER)));
                     LookBehaviorUtils.reachable(dest).ifPresent(rotation ->
-                                state.setInput(InputOverrideHandler.Input.CLICK_RIGHT, true)
-                                        .setTarget(new MovementTarget(rotation))
+                            state.setInput(InputOverrideHandler.Input.CLICK_RIGHT, true)
+                                    .setTarget(new MovementTarget(rotation))
                     );
                 } else {
                     Rotation rotationToBlock = Utils.calcRotationFromVec3d(playerHead(), Utils.calcCenterFromCoords(dest, world()));

File: src/main/java/baritone/bot/chunk/CachedChunk.java
Patch:
@@ -46,7 +46,7 @@ public final class CachedChunk implements IBlockTypeAccess {
     private final BitSet data;
 
     CachedChunk(int x, int z, BitSet data) {
-        if (data.size() != SIZE)
+        if (data.size() > SIZE)
             throw new IllegalArgumentException("BitSet of invalid length provided");
 
         this.x = x;

File: src/main/java/baritone/bot/chunk/CachedRegion.java
Patch:
@@ -43,7 +43,7 @@ public final class CachedRegion implements ICachedChunkAccess {
     public final PathingBlockType getBlockType(int x, int y, int z) {
         CachedChunk chunk = this.getChunk(x >> 4, z >> 4);
         if (chunk != null) {
-            return chunk.getBlockType(x, y, z);
+            return chunk.getBlockType(x & 15, y, z & 15);
         }
         return null;
     }

File: src/main/java/baritone/bot/chunk/CachedWorld.java
Patch:
@@ -37,7 +37,7 @@ public CachedWorld(String directory) {
     public final PathingBlockType getBlockType(int x, int y, int z) {
         CachedRegion region = getRegion(x >> 9, z >> 9);
         if (region != null) {
-            return region.getBlockType(x, y, z);
+            return region.getBlockType(x & 511, y, z & 511);
         }
         return null;
     }

File: src/main/java/baritone/bot/pathing/movement/Movement.java
Patch:
@@ -91,7 +91,7 @@ private boolean prepared(MovementState state) {
             return true;
 
         for (BlockPos blockPos : positionsToBreak) {
-            if (!MovementHelper.canWalkThrough(blockPos, BlockStateInterface.get(blockPos))) {
+            if (!MovementHelper.canWalkThrough(blockPos)) {
                 Optional<Rotation> reachable = LookBehaviorUtils.reachable(blockPos);
                 if (reachable.isPresent()) {
                     state.setTarget(new MovementState.MovementTarget(reachable.get())).setInput(Input.CLICK_LEFT, true);
@@ -163,7 +163,7 @@ public double getTotalHardnessOfBlocksToBreak(ToolSet ts) {
         //^ the above implementation properly deals with falling blocks, TODO integrate
         double sum = 0;
         for (BlockPos pos : positionsToBreak) {
-            sum += MovementHelper.getMiningDurationTicks(ts, BlockStateInterface.get(pos), pos);
+            sum += MovementHelper.getMiningDurationTicks(ts, pos);
             if (sum >= COST_INF) {
                 return COST_INF;
             }
@@ -196,7 +196,7 @@ public ArrayList<BlockPos> toBreak() {
         }
         ArrayList<BlockPos> result = new ArrayList<>();
         for (BlockPos positionToBreak : positionsToBreak) {
-            if (!MovementHelper.canWalkThrough(positionToBreak, BlockStateInterface.get(positionToBreak))) {
+            if (!MovementHelper.canWalkThrough(positionToBreak)) {
                 result.add(positionToBreak);
             }
         }

File: src/main/java/baritone/bot/pathing/movement/movements/MovementAscend.java
Patch:
@@ -41,7 +41,7 @@ public MovementAscend(BlockPos src, BlockPos dest) {
 
     @Override
     protected double calculateCost(ToolSet ts) {
-        if (!MovementHelper.canWalkOn(positionsToPlace[0], BlockStateInterface.get(positionsToPlace[0]))) {
+        if (!MovementHelper.canWalkOn(positionsToPlace[0])) {
             if (!BlockStateInterface.isAir(positionsToPlace[0]) && !BlockStateInterface.isWater(positionsToPlace[0])) {
                 return COST_INF;
             }

File: src/main/java/baritone/bot/pathing/movement/movements/MovementDescend.java
Patch:
@@ -18,7 +18,7 @@ public MovementDescend(BlockPos start, BlockPos end) {
 
     @Override
     protected double calculateCost(ToolSet ts) {
-        if (!MovementHelper.canWalkOn(positionsToPlace[0], BlockStateInterface.get(positionsToPlace[0]))) {
+        if (!MovementHelper.canWalkOn(positionsToPlace[0])) {
             return COST_INF;
         }
         Block tmp1 = BlockStateInterface.get(dest).getBlock();

File: src/main/java/baritone/bot/pathing/movement/movements/MovementDownward.java
Patch:
@@ -44,7 +44,7 @@ public MovementState updateState(MovementState state) {
 
     @Override
     protected double calculateCost(ToolSet ts) {
-        if (!MovementHelper.canWalkOn(dest.down(), BlockStateInterface.get(dest.down()))) {
+        if (!MovementHelper.canWalkOn(dest.down())) {
             return COST_INF;
         }
         Block td = BlockStateInterface.get(dest).getBlock();

File: src/main/java/baritone/bot/pathing/movement/movements/MovementFall.java
Patch:
@@ -39,7 +39,7 @@ public MovementFall(BlockPos src, BlockPos dest) {
 
     @Override
     protected double calculateCost(ToolSet ts) {
-        if(!MovementHelper.canWalkOn(positionsToPlace[0], BlockStateInterface.get(positionsToPlace[0]))) {
+        if(!MovementHelper.canWalkOn(positionsToPlace[0])) {
             return COST_INF;
         }
         double placeBucketCost = 0.0;

File: src/main/java/baritone/bot/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -51,8 +51,8 @@ protected double calculateCost(ToolSet ts) {
         IBlockState pb0 = BlockStateInterface.get(positionsToBreak[0]);
         IBlockState pb1 = BlockStateInterface.get(positionsToBreak[1]);
         double WC = BlockStateInterface.isWater(pb0.getBlock()) || BlockStateInterface.isWater(pb1.getBlock()) ? WALK_ONE_IN_WATER_COST : WALK_ONE_BLOCK_COST;
-        if (MovementHelper.canWalkOn(positionsToPlace[0], BlockStateInterface.get(positionsToPlace[0]))) {//this is a walk, not a bridge
-            if (MovementHelper.canWalkThrough(positionsToBreak[0], pb0) && MovementHelper.canWalkThrough(positionsToBreak[1], pb1)) {
+        if (MovementHelper.canWalkOn(positionsToPlace[0])) {//this is a walk, not a bridge
+            if (MovementHelper.canWalkThrough(positionsToBreak[0]) && MovementHelper.canWalkThrough(positionsToBreak[1])) {
                 return WC;
             }
             //double hardness1 = blocksToBreak[0].getBlockHardness(Minecraft.getMinecraft().world, positionsToBreak[0]);

File: src/main/java/baritone/bot/pathing/movement/movements/MovementAscend.java
Patch:
@@ -50,15 +50,15 @@ protected double calculateCost(ToolSet ts) {
             }
             for (BlockPos against1 : against) {
                 if (BlockStateInterface.get(against1).isBlockNormalCube()) {
-                    return JUMP_ONE_BLOCK_COST + WALK_ONE_BLOCK_COST + PLACE_ONE_BLOCK_COST + MovementHelper.getTotalHardnessOfBlocksToBreak(ts, positionsToBreak);
+                    return JUMP_ONE_BLOCK_COST + WALK_ONE_BLOCK_COST + PLACE_ONE_BLOCK_COST + getTotalHardnessOfBlocksToBreak(ts    );
                 }
             }
             return COST_INF;
         }
         if (BlockStateInterface.get(src.up(3)).getBlock() instanceof BlockFalling) {//it would fall on us and possibly suffocate us
             return COST_INF;
         }
-        return WALK_ONE_BLOCK_COST / 2 + Math.max(JUMP_ONE_BLOCK_COST, WALK_ONE_BLOCK_COST / 2) + MovementHelper.getTotalHardnessOfBlocksToBreak(ts, positionsToBreak);//we walk half the block to get to the edge, then we walk the other half while simultaneously jumping (math.max because of how it's in parallel)
+        return WALK_ONE_BLOCK_COST / 2 + Math.max(JUMP_ONE_BLOCK_COST, WALK_ONE_BLOCK_COST / 2) + getTotalHardnessOfBlocksToBreak(ts);//we walk half the block to get to the edge, then we walk the other half while simultaneously jumping (math.max because of how it's in parallel)
     }
 
     @Override

File: src/main/java/baritone/bot/pathing/movement/movements/MovementDescend.java
Patch:
@@ -25,13 +25,12 @@ protected double calculateCost(ToolSet ts) {
         if (tmp1 instanceof BlockLadder || tmp1 instanceof BlockVine) {
             return COST_INF;
         }
-        return WALK_ONE_BLOCK_COST * 0.8 + Math.max(FALL_N_BLOCKS_COST[1], WALK_ONE_BLOCK_COST * 0.2) + MovementHelper.getTotalHardnessOfBlocksToBreak(ts, positionsToBreak);//we walk half the block plus 0.3 to get to the edge, then we walk the other 0.2 while simultaneously falling (math.max because of how it's in parallel)
+        return WALK_ONE_BLOCK_COST * 0.8 + Math.max(FALL_N_BLOCKS_COST[1], WALK_ONE_BLOCK_COST * 0.2) + getTotalHardnessOfBlocksToBreak(ts);//we walk half the block plus 0.3 to get to the edge, then we walk the other 0.2 while simultaneously falling (math.max because of how it's in parallel)
     }
 
     @Override
     public MovementState updateState(MovementState state) {
         super.updateState(state);
-        System.out.println("Ticking with state " + state.getStatus());
         switch (state.getStatus()) {
             case PREPPING:
             case UNREACHABLE:

File: src/main/java/baritone/bot/pathing/movement/movements/MovementDownward.java
Patch:
@@ -52,7 +52,7 @@ protected double calculateCost(ToolSet ts) {
         if (ladder) {
             return LADDER_DOWN_ONE_COST;
         } else {
-            return FALL_N_BLOCKS_COST[1] + MovementHelper.getTotalHardnessOfBlocksToBreak(ts, positionsToBreak);
+            return FALL_N_BLOCKS_COST[1] + getTotalHardnessOfBlocksToBreak(ts);
         }
     }
 }

File: src/main/java/baritone/bot/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -58,7 +58,7 @@ protected double calculateCost(ToolSet ts) {
             //double hardness1 = blocksToBreak[0].getBlockHardness(Minecraft.getMinecraft().world, positionsToBreak[0]);
             //double hardness2 = blocksToBreak[1].getBlockHardness(Minecraft.getMinecraft().world, positionsToBreak[1]);
             //Out.log("Can't walk through " + blocksToBreak[0] + " (hardness" + hardness1 + ") or " + blocksToBreak[1] + " (hardness " + hardness2 + ")");
-            return WC + MovementHelper.getTotalHardnessOfBlocksToBreak(ts, positionsToBreak);
+            return WC + getTotalHardnessOfBlocksToBreak(ts);
         } else {//this is a bridge, so we need to place a block
             //return 1000000;
             Block f = BlockStateInterface.get(src.down()).getBlock();
@@ -69,11 +69,11 @@ protected double calculateCost(ToolSet ts) {
             if (pp0.getBlock().equals(Blocks.AIR) || (!BlockStateInterface.isWater(pp0.getBlock()) && pp0.getBlock().isReplaceable(Minecraft.getMinecraft().world, positionsToPlace[0]))) {
                 for (BlockPos against1 : against) {
                     if (BlockStateInterface.get(against1).isBlockNormalCube()) {
-                        return WC + PLACE_ONE_BLOCK_COST + MovementHelper.getTotalHardnessOfBlocksToBreak(ts, positionsToBreak);
+                        return WC + PLACE_ONE_BLOCK_COST + getTotalHardnessOfBlocksToBreak(ts);
                     }
                 }
                 WC = WC * SNEAK_ONE_BLOCK_COST / WALK_ONE_BLOCK_COST;//since we are placing, we are sneaking
-                return WC + PLACE_ONE_BLOCK_COST + MovementHelper.getTotalHardnessOfBlocksToBreak(ts, positionsToBreak);
+                return WC + PLACE_ONE_BLOCK_COST + getTotalHardnessOfBlocksToBreak(ts);
             }
             return COST_INF;
             //Out.log("Can't walk on " + Baritone.get(positionsToPlace[0]).getBlock());

File: src/main/java/baritone/bot/utils/BlockStateInterface.java
Patch:
@@ -40,7 +40,7 @@ public static boolean isWater(Block b) {
      * @return Whether or not the block is water
      */
     public static boolean isWater(BlockPos bp) {
-        return isWater(BlockStateInterface.get(bp).getBlock());
+        return isWater(BlockStateInterface.getBlock(bp));
     }
 
     public static boolean isLava(Block b) {
@@ -58,7 +58,7 @@ public static boolean isLiquid(Block b) {
     }
 
     public static boolean isLiquid(BlockPos p) {
-        return isLiquid(BlockStateInterface.get(p).getBlock());
+        return isLiquid(BlockStateInterface.getBlock(p));
     }
 
     public static boolean isFlowing(IBlockState state) {
@@ -68,7 +68,7 @@ public static boolean isFlowing(IBlockState state) {
     }
 
     public static boolean isAir(BlockPos pos) {
-        return BlockStateInterface.get(pos).getBlock().equals(Blocks.AIR);
+        return BlockStateInterface.getBlock(pos).equals(Blocks.AIR);
     }
 
 }

File: src/main/java/baritone/bot/pathing/path/PathExecutor.java
Patch:
@@ -35,7 +35,9 @@ public PathExecutor(IPath path) {
 
     @Override
     public void onTick(TickEvent event) {
-        if(event.)
+        if(event.getType() == TickEvent.Type.OUT) {
+            return;
+        }
         if (pathPosition >= path.length()) {
             //stop bugging me, I'm done
             //TODO Baritone.INSTANCE.behaviors.remove(this)

File: src/main/java/baritone/bot/behavior/impl/PathingBehavior.java
Patch:
@@ -42,8 +42,7 @@ private PathingBehavior() {}
 
     @Override
     public void onTick(TickEvent event) {
-        // System.out.println("Ticking");
-        if (current == null) {
+        if(event.getType() == TickEvent.Type.OUT || current == null) {
             return;
         }
         current.onTick(event);

File: src/main/java/baritone/bot/pathing/path/PathExecutor.java
Patch:
@@ -35,6 +35,7 @@ public PathExecutor(IPath path) {
 
     @Override
     public void onTick(TickEvent event) {
+        if(event.)
         if (pathPosition >= path.length()) {
             //stop bugging me, I'm done
             //TODO Baritone.INSTANCE.behaviors.remove(this)

File: src/main/java/baritone/bot/pathing/calc/AStarPathFinder.java
Patch:
@@ -67,7 +67,7 @@ protected Optional<IPath> calculate0() {
             }
             if (goal.isInGoal(currentNodePos)) {
                 currentlyRunning = null;
-                return Optional.of(new Path(startNode, currentNode, goal));
+                return Optional.of(new Path(startNode, currentNode, goal, numNodes));
             }
             //long constructStart = System.nanoTime();
             Movement[] possibleMovements = getConnectedPositions(currentNodePos);//movement that we could take that start at myPos, in random order
@@ -128,7 +128,7 @@ protected Optional<IPath> calculate0() {
                 }
                 System.out.println("Path goes for " + dist + " blocks");
                 currentlyRunning = null;
-                return Optional.of(new Path(startNode, bestSoFar[i], goal));
+                return Optional.of(new Path(startNode, bestSoFar[i], goal, numNodes));
             }
         }
         System.out.println("Even with a cost coefficient of " + COEFFICIENTS[COEFFICIENTS.length - 1] + ", I couldn't get more than " + bestDist + " blocks =(");

File: src/main/java/baritone/bot/pathing/calc/AbstractNodeCostSearch.java
Patch:
@@ -103,15 +103,15 @@ protected PathNode getNodeAtPosition(BlockPos pos) {
 
     @Override
     public Optional<IPath> pathToMostRecentNodeConsidered() {
-        return Optional.ofNullable(mostRecentConsidered).map(node -> new Path(startNode, node, goal));
+        return Optional.ofNullable(mostRecentConsidered).map(node -> new Path(startNode, node, goal, 0));
     }
 
     @Override
     public Optional<IPath> bestPathSoFar() {
         if (startNode == null || bestSoFar[0] == null)
             return Optional.empty();
 
-        return Optional.of(new Path(startNode, bestSoFar[0], goal));
+        return Optional.of(new Path(startNode, bestSoFar[0], goal, 0));
     }
 
     @Override

File: src/main/java/baritone/bot/pathing/path/IPath.java
Patch:
@@ -104,4 +104,6 @@ default BlockPos getDest() {
      * @return an unordered collection of positions
      */
     Collection<BlockPos> getBlocksToPlace();
+
+    int getNumNodesConsidered();
 }

File: src/main/java/baritone/bot/pathing/movement/MovementState.java
Patch:
@@ -57,11 +57,11 @@ public MovementTarget(Vec3d position, Rotation rotation) {
         }
 
         public final Optional<Vec3d> getPosition() {
-            return Optional.of(this.position);
+            return Optional.ofNullable(this.position);
         }
 
         public final Optional<Rotation> getRotation() {
-            return Optional.of(this.rotation);
+            return Optional.ofNullable(this.rotation);
         }
     }
 

File: src/main/java/baritone/bot/chunk/CachedRegion.java
Patch:
@@ -20,9 +20,7 @@
 public final class CachedRegion implements ICachedChunkAccess {
 
     /**
-     * All of the chunks in this region. A 16x16 array of them.
-     * <p>
-     * I would make these 32x32 regions to be in line with the Anvil format, but 16 is a nice number.
+     * All of the chunks in this region: A 32x32 array of them.
      */
     private final CachedChunk[][] chunks = new CachedChunk[32][32];
 

File: src/main/java/baritone/bot/pathing/movement/MovementState.java
Patch:
@@ -73,6 +73,6 @@ public boolean getInput(Input input) {
     }
 
     public enum MovementStatus {
-        PREPPING, WAITING, RUNNING, SUCCESS, UNREACHABLE, FAILED, FINISHING;
+        PREPPING, WAITING, RUNNING, SUCCESS, UNREACHABLE, FAILED, CANCELED;
     }
 }

File: src/main/java/baritone/bot/pathing/movement/movements/MovementAscend.java
Patch:
@@ -78,7 +78,7 @@ public MovementState updateState(MovementState state) {
                     state.setStatus(MovementStatus.SUCCESS);
                     return state;
                 }
-                
+
                 state.setTarget(new MovementState.MovementTarget(Optional.empty(), Optional.of(Utils.calcRotationFromVec3d(new Vec3d(player().posX, player().posY + 1.62, player().posZ), Utils.calcCenterFromCoords(positionsToBreak[0], world())))));
                 state.setInput(InputOverrideHandler.Input.JUMP, true).setInput(InputOverrideHandler.Input.MOVE_FORWARD, true);
                 return state;

File: src/main/java/baritone/bot/pathing/path/PathExecutor.java
Patch:
@@ -135,6 +135,7 @@ public void onTick(TickEvent event) {
             ticksOnCurrent++;
             if (ticksOnCurrent > movement.recalculateCost() + 100) {
                 System.out.println("This movement has taken too long (" + ticksOnCurrent + " ticks, expected " + movement.getCost(null) + "). Cancelling.");
+                movement.cancel();
                 pathPosition = path.length() + 3;
                 failed = true;
                 return;

File: src/main/java/baritone/bot/pathing/movement/movements/MovementAscend.java
Patch:
@@ -78,7 +78,7 @@ public MovementState updateState(MovementState state) {
                     state.setStatus(MovementStatus.SUCCESS);
                     return state;
                 }
-
+                
                 state.setTarget(new MovementState.MovementTarget(Optional.empty(), Optional.of(Utils.calcRotationFromVec3d(new Vec3d(player().posX, player().posY + 1.62, player().posZ), Utils.calcCenterFromCoords(positionsToBreak[0], world())))));
                 state.setInput(InputOverrideHandler.Input.JUMP, true).setInput(InputOverrideHandler.Input.MOVE_FORWARD, true);
                 return state;

File: src/main/java/baritone/bot/pathing/movement/movements/MovementAscend.java
Patch:
@@ -79,7 +79,7 @@ public MovementState updateState(MovementState state) {
                     return state;
                 }
 
-                state.setTarget(new MovementState.MovementTarget(Optional.empty(), Optional.of(Utils.calcRotationFromVec3d(new Vec3d(player().posX, player().posY + 1.62, player().posZ), Utils.calcCenterFromCoords(positionsToBreak[1], world())))));
+                state.setTarget(new MovementState.MovementTarget(Optional.empty(), Optional.of(Utils.calcRotationFromVec3d(new Vec3d(player().posX, player().posY + 1.62, player().posZ), Utils.calcCenterFromCoords(positionsToBreak[0], world())))));
                 state.setInput(InputOverrideHandler.Input.JUMP, true).setInput(InputOverrideHandler.Input.MOVE_FORWARD, true);
                 return state;
             default:

File: src/main/java/baritone/bot/pathing/movement/movements/MovementAscend.java
Patch:
@@ -79,7 +79,7 @@ public MovementState updateState(MovementState state) {
                     return state;
                 }
 
-                state.setTarget(new MovementState.MovementTarget(Optional.empty(), Optional.of(Utils.calcRotationFromVec3d(new Vec3d(player().posX, player().posY, player().posZ), Utils.calcCenterFromCoords(positionsToBreak[1], world())))));
+                state.setTarget(new MovementState.MovementTarget(Optional.empty(), Optional.of(Utils.calcRotationFromVec3d(new Vec3d(player().posX, player().posY + 1.62, player().posZ), Utils.calcCenterFromCoords(positionsToBreak[1], world())))));
                 state.setInput(InputOverrideHandler.Input.JUMP, true).setInput(InputOverrideHandler.Input.MOVE_FORWARD, true);
                 return state;
             default:

File: src/main/java/baritone/bot/pathing/movement/movements/MovementTraverse.java
Patch:
@@ -98,7 +98,7 @@ public MovementState updateState(MovementState state) {
                     state.setStatus(MovementState.MovementStatus.SUCCESS);
                     return state;
                 }
-                state.setTarget(new MovementState.MovementTarget(Optional.empty(), Optional.of(Utils.calcRotationFromVec3d(new Vec3d(player().posX, player().posY, player().posZ), Utils.calcCenterFromCoords(positionsToBreak[0], world()))))).setInput(InputOverrideHandler.Input.MOVE_FORWARD, true);
+                state.setTarget(new MovementState.MovementTarget(Optional.empty(), Optional.of(Utils.calcRotationFromVec3d(new Vec3d(player().posX, player().posY + 1.62, player().posZ), Utils.calcCenterFromCoords(positionsToBreak[0], world()))))).setInput(InputOverrideHandler.Input.MOVE_FORWARD, true);
                 return state;
 
             default:

File: src/main/java/baritone/bot/pathing/movement/movements/MovementAscend.java
Patch:
@@ -78,7 +78,7 @@ public MovementState updateState(MovementState state) {
                     return state;
                 }
 
-                state.setTarget(new MovementState.MovementTarget(Optional.empty(), Optional.of(Utils.calcRotationFromCoords(playerFeet(), positionsToBreak[0]))));
+                state.setTarget(new MovementState.MovementTarget(Optional.empty(), Optional.of(Utils.calcRotationFromCoords(playerFeet(), positionsToBreak[1]))));
                 state.setInput(InputOverrideHandler.Input.JUMP, true).setInput(InputOverrideHandler.Input.MOVE_FORWARD, true);
                 return state;
             default:

File: src/main/java/baritone/bot/pathing/movement/MovementState.java
Patch:
@@ -39,9 +39,9 @@ public static class MovementTarget {
          */
         public Optional<Rotation> rotation;
 
-        public MovementTarget(Vec3d position, Rotation rotation) {
-            this.position = Optional.of(position);
-            this.rotation = Optional.of(rotation);
+        public MovementTarget(Optional<Vec3d> position, Optional<Rotation> rotation) {
+            this.position = position;
+            this.rotation = rotation;
         }
     }
 

File: src/main/java/baritone/bot/utils/Utils.java
Patch:
@@ -25,11 +25,11 @@ public static Tuple<Float, Float> calcRotationFromCoords(BlockPos orig, BlockPos
      * @param dest
      * @return Rotation Tuple {@link LookBehavior#target}
      */
-    public static Tuple<Float, Float> calcRotationFromVec3d(Vec3d orig, Vec3d dest) {
+    public static Rotation calcRotationFromVec3d(Vec3d orig, Vec3d dest) {
         double yaw = Math.atan2(orig.x - dest.x, -orig.z + dest.z);
         double dist = Math.sqrt((orig.x - dest.x) * (orig.x - dest.x) + (-orig.z + dest.z) * (-orig.z + dest.z));
         double pitch = Math.atan2(orig.y - dest.y, dist);
-        return new Tuple<>((float) (yaw * 180 / Math.PI),
+        return new Rotation((float) (yaw * 180 / Math.PI),
                 (float) (pitch * 180 / Math.PI));
     }
 

File: src/main/java/baritone/bot/behavior/Behavior.java
Patch:
@@ -47,7 +47,7 @@ public final boolean setEnabled(boolean enabled) {
     /**
      * Function to determine what the new enabled state of this
      * {@link Behavior} should be given the old state, and the
-     * proposed state. Intended to be overriden by behaviors
+     * proposed state. Intended to be overridden by behaviors
      * that should always be active, given that the bot itself is
      * active.
      *

File: src/main/java/baritone/bot/behavior/impl/PathingBehavior.java
Patch:
@@ -3,6 +3,7 @@
 import baritone.bot.behavior.Behavior;
 import baritone.bot.event.events.ChatEvent;
 import baritone.bot.event.events.RenderEvent;
+import baritone.bot.event.events.TickEvent;
 import baritone.bot.pathing.calc.AStarPathFinder;
 import baritone.bot.pathing.calc.IPathFinder;
 import baritone.bot.pathing.goals.Goal;
@@ -34,7 +35,7 @@ private PathingBehavior() {}
     private Goal goal;
 
     @Override
-    public void onTick() {
+    public void onTick(TickEvent event) {
         // System.out.println("Ticking");
         if (current == null) {
             return;

File: src/main/java/baritone/bot/event/AbstractGameEventListener.java
Patch:
@@ -7,7 +7,7 @@
 
 /**
  * An implementation of {@link IGameEventListener} that has all methods
- * overriden with empty bodies, allowing inheritors of this class to choose
+ * overridden with empty bodies, allowing inheritors of this class to choose
  * which events they would like to listen in on.
  *
  * Has no implementors at the moment, but will likely be used with the

File: src/main/java/baritone/bot/behavior/impl/PathingBehavior.java
Patch:
@@ -28,6 +28,9 @@ public PathExecutor getExecutor() {
     }
 
     public IPath getPath() {
+        if (current == null) {
+            return null;
+        }
         return current.getPath();
     }
 }

File: src/main/java/baritone/bot/behavior/impl/LookBehavior.java
Patch:
@@ -2,5 +2,5 @@
 
 import baritone.bot.behavior.Behavior;
 
-public class MovementBehavior extends Behavior {
+public class LookBehavior extends Behavior {
 }

File: src/main/java/baritone/bot/event/IGameEventListener.java
Patch:
@@ -35,7 +35,7 @@ public interface IGameEventListener {
 
 
     /**
-     * Runs before and after whenever a chunk is either loaded or unloaded.
+     * Runs before and after whenever a chunk is either loaded, unloaded, or populated.
      *
      * @see WorldClient#doPreChunk(int, int, boolean)
      */

File: src/main/java/baritone/bot/pathing/action/ActionWorldHelper.java
Patch:
@@ -128,7 +128,7 @@ static double getHardness(ToolSet ts, IBlockState block, BlockPos position) {
             //if (!Baritone.allowBreakOrPlace) {
             //    return COST_INF;
             //}
-            double m = Block.getBlockFromName("minecraft:crafting_table").equals(block) ? 10 : 1;
+            double m = Blocks.CRAFTING_TABLE.equals(block) ? 10 : 1;
             return m / ts.getStrVsBlock(block, position) + BREAK_ONE_BLOCK_ADD;
         }
         return 0;

File: src/main/java/baritone/bot/pathing/action/ActionWorldHelper.java
Patch:
@@ -55,7 +55,7 @@ static boolean isLiquid(BlockPos p) {
     static boolean avoidBreaking(BlockPos pos) {
         Block b = BlockStateInterface.get(pos).getBlock();
         Block below = BlockStateInterface.get(new BlockPos(pos.getX(), pos.getY() - 1, pos.getZ())).getBlock();
-        return Block.getBlockFromName("minecraft:ice").equals(b)//ice becomes water, and water can mess up the path
+        return Blocks.ICE.equals(b) // ice becomes water, and water can mess up the path
                 || isLiquid(new BlockPos(pos.getX(), pos.getY() + 1, pos.getZ()))//don't break anything touching liquid on any side
                 || isLiquid(new BlockPos(pos.getX() + 1, pos.getY(), pos.getZ()))
                 || isLiquid(new BlockPos(pos.getX() - 1, pos.getY(), pos.getZ()))

File: src/main/java/baritone/bot/pathing/actions/ActionAscend.java
Patch:
@@ -7,8 +7,8 @@
 
 public class ActionAscend extends Action {
 
-    public ActionAscend(BlockPos destination) {
-
+    ActionAscend(BlockPos dest) {
+        super(dest);
     }
 
     @Override

File: src/main/java/baritone/bot/Baritone.java
Patch:
@@ -3,6 +3,7 @@
 import baritone.bot.behavior.Behavior;
 import org.reflections.Reflections;
 
+import java.util.ArrayList;
 import java.util.List;
 
 /**
@@ -39,6 +40,7 @@ public void init() {
         this.actionHandler = new GameActionHandler();
         this.gameEventHandler = new GameEventHandler();
         this.inputOverrideHandler = new InputOverrideHandler();
+        this.behaviors = new ArrayList<>();
 
         this.active = true;
         this.initialized = true;

File: src/main/java/baritone/bot/InputOverrideHandler.java
Patch:
@@ -25,7 +25,7 @@ public final class InputOverrideHandler implements Helper {
     private final Map<KeyBinding, Boolean> inputForceStateMap = new HashMap<>();
 
     /**
-     * Maps keycodes to whether or not we are forcing their state down
+     * Maps keycodes to whether or not we are forcing their state down.
      */
     private final Map<Integer, Boolean> keyCodeForceStateMap = new HashMap<>();
 
@@ -52,7 +52,7 @@ public final void setInputForceState(Input input, boolean forced) {
     /**
      * A redirection in multiple places of {@link Keyboard#isKeyDown}.
      *
-     * @return Whether or not the specified key is down or overriden.
+     * @return Whether or not the specified key is down or overridden.
      */
     public boolean isKeyDown(int keyCode) {
         return Keyboard.isKeyDown(keyCode) || keyCodeForceStateMap.computeIfAbsent(keyCode, k -> false);

File: src/main/java/baritone/bot/utils/Utils.java
Patch:
@@ -9,7 +9,8 @@
 public final class Utils {
 
     public static void ifConditionThen(Supplier<Boolean> condition, Runnable runnable) {
-        if (condition.get())
+        if (condition.get()) {
             runnable.run();
+        }
     }
 }

File: src/main/java/baritone/pathfinding/actions/Action.java
Patch:
@@ -5,6 +5,7 @@
  */
 package baritone.pathfinding.actions;
 
+import baritone.Baritone;
 import baritone.util.Out;
 import baritone.util.ToolSet;
 import net.minecraft.block.Block;

