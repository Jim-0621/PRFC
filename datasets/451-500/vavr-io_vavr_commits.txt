File: vavr/src/main/java/io/vavr/collection/CharSeq.java
Patch:
@@ -2347,7 +2347,7 @@ public CharSeq replace(CharSequence target, CharSequence replacement) {
      * <p>
      * The string {@code "boo:and:foo"}, for example, yields the following results with these expressions:
      * <blockquote>
-     * <table cellpadding=1 cellspacing=0>
+     * <table style="border-spacing: 0; padding: 1px;">
      * <caption>Split examples showing regex and result</caption>
      * <tr>
      * <th>Regex</th>
@@ -2402,7 +2402,7 @@ public Seq<CharSeq> split(String regex) {
      * <p>
      * The string {@code "boo:and:foo"}, for example, yields the
      * following results with these parameters:
-     * <blockquote><table cellpadding=1 cellspacing=0>
+     * <blockquote><table style="border-spacing: 0; padding: 1px;">
      * <caption>Split example showing regex, limit, and result</caption>
      * <tr>
      * <th>Regex</th>

File: vavr/src/main/java/io/vavr/collection/package-info.java
Patch:
@@ -2,7 +2,7 @@
  * Purely functional collections based on {@linkplain io.vavr.collection.Traversable}.
  *
  * <h2>Performance Characteristics of Vavr Collections</h2>
- * <table cellpadding="5" cellspacing="0" border="1" style="border-collapse: collapse">
+ * <table style="border-collapse: collapse; border: 1px solid; padding: 5px;">
  * <caption>Time Complexity of Sequential Operations</caption>
  * <thead>
  * <tr>
@@ -27,7 +27,7 @@
  * </tbody>
  * </table>
  * <br>
- * <table cellpadding="5" cellspacing="0" border="1" style="border-collapse: collapse">
+ * <table style="border-collapse: collapse; border: 1px solid; padding: 5px;">
  * <caption>Time Complexity of Map/Set Operations</caption>
  * <thead>
  * <tr>

File: vavr/src-gen/main/java/io/vavr/API.java
Patch:
@@ -48,7 +48,7 @@
  * import static io.vavr.API.*;
  * </code></pre>
  *
- * <h3>For-comprehension</h3>
+ * <h2>For-comprehension</h2>
  * <p>
  * The {@code For}-comprehension is syntactic sugar for nested for-loops. We write
  *

File: vavr/src/main/java/io/vavr/concurrent/Promise.java
Patch:
@@ -35,7 +35,7 @@
  * The underlying {@code Executor} is used to execute asynchronous handlers, e.g. via
  * {@code promise.future().onComplete(...)}.
  *
- * <h3>Creation</h3>
+ * <h2>Creation</h2>
  * <p>
  * Promise offers static factory methods to create new promises which hasn't been fulfilled yet:
  * <ul>

File: vavr/src-gen/main/java/io/vavr/API.java
Patch:
@@ -5654,4 +5654,4 @@ public boolean isDefinedAt(T obj) {
             }
         }
     }
-}
+}
\ No newline at end of file

File: vavr/src/main/java/io/vavr/collection/Array.java
Patch:
@@ -45,6 +45,7 @@ public final class Array<T> implements IndexedSeq<T>, Serializable {
 
     private static final Array<?> EMPTY = new Array<>(new Object[0]);
 
+    @SuppressWarnings("serial") // Conditionally serializable
     private final Object[] delegate;
 
     private Array(Object[] delegate) {

File: vavr/src/main/java/io/vavr/collection/BitMappedTrie.java
Patch:
@@ -60,6 +60,7 @@ final class BitMappedTrie<T> implements Serializable {
     static <T> BitMappedTrie<T> empty() { return (BitMappedTrie<T>) EMPTY; }
 
     final ArrayType<T> type;
+    @SuppressWarnings("serial") // Conditionally serializable
     private final Object array;
     private final int offset, length;
     private final int depthShift;

File: vavr/src/main/java/io/vavr/collection/Tree.java
Patch:
@@ -866,6 +866,7 @@ final class Node<T> implements Tree<T>, Serializable {
 
         private static final long serialVersionUID = 1L;
 
+        @SuppressWarnings("serial") // Conditionally serializable
         private final T value;
         private final io.vavr.collection.List<Node<T>> children;
 

File: vavr/src/main/java/io/vavr/collection/TreeMap.java
Patch:
@@ -1562,6 +1562,7 @@ final class Specific<K, V> implements EntryComparator<K, V> {
 
             private static final long serialVersionUID = 1L;
 
+            @SuppressWarnings("serial") // Conditionally serializable
             private final Comparator<K> keyComparator;
 
             @SuppressWarnings("unchecked")

File: vavr/src/test/java/io/vavr/collection/BitSetTest.java
Patch:
@@ -572,7 +572,9 @@ private static final class Mapper<T> implements Serializable {
 
         private static final long serialVersionUID = 1L;
 
+        @SuppressWarnings("serial") // Conditionally serializable
         private final java.util.Map<Integer, T> fromIntMap = new java.util.HashMap<>();
+        @SuppressWarnings("serial") // Conditionally serializable
         private final java.util.Map<T, Integer> toIntMap = new java.util.HashMap<>();
         private int nextValue = 0;
 

File: vavr/src/test/java/io/vavr/collection/BitSetTest.java
Patch:
@@ -569,7 +569,7 @@ public void shouldReturnTailOfNonEmptyHavingReversedOrder() {
 
     // -- classes
 
-    private static class Mapper<T> implements Serializable {
+    private static final class Mapper<T> implements Serializable {
 
         private static final long serialVersionUID = 1L;
 

File: vavr/src/test/java/io/vavr/collection/HashArrayMappedTrieTest.java
Patch:
@@ -191,7 +191,7 @@ public int compareTo(WeakInteger other) {
         }
     }
 
-    private class Comparator<K, V> {
+    private final class Comparator<K, V> {
         private final java.util.Map<K, V> classic = new java.util.HashMap<>();
         private Map<K, V> hamt = HashMap.empty();
 

File: vavr/src/test/java/io/vavr/collection/euler/Euler17Test.java
Patch:
@@ -121,7 +121,7 @@ default int letterCount(Seq<Integer> range) {
     /**
      * Solution using Vavr Pattern Matching.
      */
-    private static class SolutionA implements SolutionProblem17 {
+    private static final class SolutionA implements SolutionProblem17 {
         @Override
         public int letterCount(int num) {
             return Match(num).of( /*@formatter:off*/
@@ -143,7 +143,7 @@ private static int length(int number) {
     /**
      * A more general solution using functionality of the Vavr Collections.
      */
-    private static class SolutionB implements SolutionProblem17 {
+    private static final class SolutionB implements SolutionProblem17 {
         @Override
         public int letterCount(int number) {
             return asText(number).length();

File: vavr/src/main/java/io/vavr/collection/LinkedHashMap.java
Patch:
@@ -956,7 +956,7 @@ public LinkedHashMap<K, V> tail() {
         if (isEmpty()) {
             throw new UnsupportedOperationException("tail of empty LinkedHashMap");
         } else {
-            return LinkedHashMap.ofEntries(list.tail());
+            return wrap(list.tail(), map.remove(list.head()._1()));
         }
     }
 

File: vavr/src/main/java/io/vavr/collection/Array.java
Patch:
@@ -621,7 +621,7 @@ public Array<T> appendAll(Iterable<? extends T> elements) {
         if (source.length == 0) {
             return this;
         } else {
-            final Object[] arr = copyOf(delegate, delegate.length + source.length);
+            final Object[] arr = copyOf(delegate, delegate.length + source.length, Object[].class);
             System.arraycopy(source, 0, arr, delegate.length, source.length);
             return wrap(arr);
         }

File: vavr/src/main/java/io/vavr/collection/package-info.java
Patch:
@@ -16,7 +16,7 @@
  * </tr>
  * </thead>
  * <tbody>
- * <tr><td>{@linkplain io.vavr.collection.Array}</td><td><small>const</small></td><td><small>linear</small></td><td><small>const</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
+ * <tr><td>{@linkplain io.vavr.collection.Array}</td><td><small>const</small></td><td><small>linear</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
  * <tr><td>{@linkplain io.vavr.collection.CharSeq}</td><td><small>const</small></td><td><small>linear</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
  * <tr><td><em>{@linkplain io.vavr.collection.Iterator}</em></td><td><small>const</small></td><td><small>const</small></td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td></tr>
  * <tr><td>{@linkplain io.vavr.collection.List}</td><td><small>const</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>const</small></td><td><small>linear</small></td></tr>

File: vavr/src/main/java/io/vavr/collection/BitSet.java
Patch:
@@ -815,8 +815,7 @@ public BitSet<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> oper
 
         @Override
         public Tuple2<BitSet<T>, BitSet<T>> partition(Predicate<? super T> predicate) {
-            Objects.requireNonNull(predicate, "predicate is null");
-            return iterator().partition(predicate).map(this::createFromAll, this::createFromAll);
+            return Collections.partition(this, this::createFromAll, predicate);
         }
 
         @Override

File: vavr/src/main/java/io/vavr/collection/LinkedHashSet.java
Patch:
@@ -754,9 +754,7 @@ public LinkedHashSet<T> orElse(Supplier<? extends Iterable<? extends T>> supplie
 
     @Override
     public Tuple2<LinkedHashSet<T>, LinkedHashSet<T>> partition(Predicate<? super T> predicate) {
-        Objects.requireNonNull(predicate, "predicate is null");
-        final Tuple2<Iterator<T>, Iterator<T>> p = iterator().partition(predicate);
-        return Tuple.of(LinkedHashSet.ofAll(p._1), LinkedHashSet.ofAll(p._2));
+        return Collections.partition(this, LinkedHashSet::ofAll, predicate);
     }
 
     @Override

File: vavr/src/main/java/io/vavr/collection/TreeSet.java
Patch:
@@ -801,9 +801,7 @@ public TreeSet<T> orElse(Supplier<? extends Iterable<? extends T>> supplier) {
 
     @Override
     public Tuple2<TreeSet<T>, TreeSet<T>> partition(Predicate<? super T> predicate) {
-        Objects.requireNonNull(predicate, "predicate is null");
-        return iterator().partition(predicate).map(i1 -> TreeSet.ofAll(tree.comparator(), i1),
-                i2 -> TreeSet.ofAll(tree.comparator(), i2));
+        return Collections.partition(this, values -> TreeSet.ofAll(tree.comparator(), values), predicate);
     }
 
     @Override

File: vavr/src/test/java/io/vavr/MatchTest.java
Patch:
@@ -188,7 +188,7 @@ public void shouldMatchIntUsingPredicates() {
 
     @Test
     public void shouldComputeUpperBoundOfReturnValue() {
-        final Number num = Match(3).of(
+        final Number num = Match(3).<Number> of(
                 Case($(is(1)), 1),
                 Case($(is(2)), 2.0),
                 Case($(), i -> new BigDecimal("" + i))

File: vavr/src/main/java/io/vavr/collection/CharSeq.java
Patch:
@@ -45,7 +45,7 @@
  *
  * @author Ruslan Sennov, Daniel Dietrich
  */
-public final class CharSeq implements CharSequence, IndexedSeq<Character>, Serializable {
+public final class CharSeq implements CharSequence, IndexedSeq<Character>, Serializable, Comparable<CharSeq> {
 
     private static final long serialVersionUID = 1L;
 
@@ -2356,7 +2356,7 @@ public CharSeq replace(CharSequence target, CharSequence replacement) {
      * </tr>
      * </table>
      * </blockquote>
-     * 
+     *
      * @param regex the delimiting regular expression
      * @return the Seq of strings computed by splitting this string around matches of the given regular expression
      * @throws PatternSyntaxException if the regular expression's syntax is invalid
@@ -2430,7 +2430,7 @@ public Seq<CharSeq> split(String regex) {
      * Pattern#split(CharSequence, int) split}(<i>str</i>,&nbsp;<i>n</i>)
      * </code>
      * </blockquote>
-     * 
+     *
      * @param regex the delimiting regular expression
      * @param limit the result threshold, as described above
      * @return the Seq of strings computed by splitting this string around matches of the given regular expression

File: vavr/src-gen/main/java/io/vavr/CheckedFunction0.java
Patch:
@@ -143,7 +143,7 @@ static <R> CheckedFunction0<R> narrow(CheckedFunction0<? extends R> f) {
 
     /**
      * Returns the number of function arguments.
-     * @return an int value >= 0
+     * @return an int value &gt;= 0
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     default int arity() {

File: vavr/src-gen/main/java/io/vavr/CheckedFunction1.java
Patch:
@@ -160,7 +160,7 @@ static <T> CheckedFunction1<T, T> identity() {
 
     /**
      * Returns the number of function arguments.
-     * @return an int value >= 0
+     * @return an int value &gt;= 0
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     default int arity() {

File: vavr/src-gen/main/java/io/vavr/CheckedFunction2.java
Patch:
@@ -168,7 +168,7 @@ default CheckedFunction1<T2, R> apply(T1 t1) {
 
     /**
      * Returns the number of function arguments.
-     * @return an int value >= 0
+     * @return an int value &gt;= 0
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     default int arity() {

File: vavr/src-gen/main/java/io/vavr/CheckedFunction3.java
Patch:
@@ -185,7 +185,7 @@ default CheckedFunction1<T3, R> apply(T1 t1, T2 t2) {
 
     /**
      * Returns the number of function arguments.
-     * @return an int value >= 0
+     * @return an int value &gt;= 0
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     default int arity() {

File: vavr/src-gen/main/java/io/vavr/CheckedFunction4.java
Patch:
@@ -204,7 +204,7 @@ default CheckedFunction1<T4, R> apply(T1 t1, T2 t2, T3 t3) {
 
     /**
      * Returns the number of function arguments.
-     * @return an int value >= 0
+     * @return an int value &gt;= 0
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     default int arity() {

File: vavr/src-gen/main/java/io/vavr/CheckedFunction5.java
Patch:
@@ -224,7 +224,7 @@ default CheckedFunction1<T5, R> apply(T1 t1, T2 t2, T3 t3, T4 t4) {
 
     /**
      * Returns the number of function arguments.
-     * @return an int value >= 0
+     * @return an int value &gt;= 0
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     default int arity() {

File: vavr/src-gen/main/java/io/vavr/CheckedFunction6.java
Patch:
@@ -245,7 +245,7 @@ default CheckedFunction1<T6, R> apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) {
 
     /**
      * Returns the number of function arguments.
-     * @return an int value >= 0
+     * @return an int value &gt;= 0
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     default int arity() {

File: vavr/src-gen/main/java/io/vavr/CheckedFunction7.java
Patch:
@@ -267,7 +267,7 @@ default CheckedFunction1<T7, R> apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6)
 
     /**
      * Returns the number of function arguments.
-     * @return an int value >= 0
+     * @return an int value &gt;= 0
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     default int arity() {

File: vavr/src-gen/main/java/io/vavr/CheckedFunction8.java
Patch:
@@ -290,7 +290,7 @@ default CheckedFunction1<T8, R> apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6,
 
     /**
      * Returns the number of function arguments.
-     * @return an int value >= 0
+     * @return an int value &gt;= 0
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     default int arity() {

File: vavr/src-gen/main/java/io/vavr/Function0.java
Patch:
@@ -151,7 +151,7 @@ default R get() {
 
     /**
      * Returns the number of function arguments.
-     * @return an int value >= 0
+     * @return an int value &gt;= 0
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     default int arity() {

File: vavr/src-gen/main/java/io/vavr/Function1.java
Patch:
@@ -159,7 +159,7 @@ static <T> Function1<T, T> identity() {
 
     /**
      * Returns the number of function arguments.
-     * @return an int value >= 0
+     * @return an int value &gt;= 0
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     default int arity() {

File: vavr/src-gen/main/java/io/vavr/Function2.java
Patch:
@@ -166,7 +166,7 @@ default Function1<T2, R> apply(T1 t1) {
 
     /**
      * Returns the number of function arguments.
-     * @return an int value >= 0
+     * @return an int value &gt;= 0
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     default int arity() {

File: vavr/src-gen/main/java/io/vavr/Function3.java
Patch:
@@ -183,7 +183,7 @@ default Function1<T3, R> apply(T1 t1, T2 t2) {
 
     /**
      * Returns the number of function arguments.
-     * @return an int value >= 0
+     * @return an int value &gt;= 0
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     default int arity() {

File: vavr/src-gen/main/java/io/vavr/Function4.java
Patch:
@@ -202,7 +202,7 @@ default Function1<T4, R> apply(T1 t1, T2 t2, T3 t3) {
 
     /**
      * Returns the number of function arguments.
-     * @return an int value >= 0
+     * @return an int value &gt;= 0
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     default int arity() {

File: vavr/src-gen/main/java/io/vavr/Function5.java
Patch:
@@ -222,7 +222,7 @@ default Function1<T5, R> apply(T1 t1, T2 t2, T3 t3, T4 t4) {
 
     /**
      * Returns the number of function arguments.
-     * @return an int value >= 0
+     * @return an int value &gt;= 0
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     default int arity() {

File: vavr/src-gen/main/java/io/vavr/Function6.java
Patch:
@@ -243,7 +243,7 @@ default Function1<T6, R> apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) {
 
     /**
      * Returns the number of function arguments.
-     * @return an int value >= 0
+     * @return an int value &gt;= 0
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     default int arity() {

File: vavr/src-gen/main/java/io/vavr/Function7.java
Patch:
@@ -265,7 +265,7 @@ default Function1<T7, R> apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) {
 
     /**
      * Returns the number of function arguments.
-     * @return an int value >= 0
+     * @return an int value &gt;= 0
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     default int arity() {

File: vavr/src-gen/main/java/io/vavr/Function8.java
Patch:
@@ -288,7 +288,7 @@ default Function1<T8, R> apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7)
 
     /**
      * Returns the number of function arguments.
-     * @return an int value >= 0
+     * @return an int value &gt;= 0
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     default int arity() {

File: vavr/src/main/java/io/vavr/control/Either.java
Patch:
@@ -453,7 +453,6 @@ default Option<Either<L, R>> filter(Predicate<? super R> predicate) {
      * If the {@code Either} is a {@code Right} and the predicate doesn't match, the
      * {@code Either} will be turned into a {@code Left} with contents computed by applying
      * the filterVal function to the {@code Either} value.
-     * <p>
      *
      * <pre>{@code
      * import static io.vavr.API.*;
@@ -466,11 +465,11 @@ default Option<Either<L, R>> filter(Predicate<? super R> predicate) {
      * }</pre>
      *
      * @param predicate A predicate
+     * @param zero      A function that turns a right value into a left value if the right value does not make it through the filter.
      * @return an {@code Either} instance
      * @throws NullPointerException if {@code predicate} is null
      */
-    default Either<L,R> filterOrElse(Predicate<? super R> predicate,
-                                     Function<? super R, ? extends L> zero) {
+    default Either<L,R> filterOrElse(Predicate<? super R> predicate, Function<? super R, ? extends L> zero) {
         Objects.requireNonNull(predicate, "predicate is null");
         Objects.requireNonNull(zero, "zero is null");
         if (isLeft() || predicate.test(get())) {

File: vavr/src/main/java/io/vavr/package-info.java
Patch:
@@ -1,4 +1,4 @@
 /**
- * The io.vavr package contains core types like {@linkplain io.vavr.Lambda}, {@linkplain io.vavr.Lazy} and {@linkplain io.vavr.Tuple}.
+ * Beside {@link io.vavr.API} the io.vavr package contains core types like (Checked)Functions and Tuples.
  */
 package io.vavr;

File: vavr/src/main/java/io/vavr/collection/package-info.java
Patch:
@@ -41,8 +41,8 @@
  * <tbody>
  * <tr><td>{@linkplain io.vavr.collection.HashMap}</td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td></tr>
  * <tr><td>{@linkplain io.vavr.collection.HashSet}</td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td></tr>
- * <tr><td>{@linkplain io.vavr.collection.LinkedHashMap}</td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
- * <tr><td>{@linkplain io.vavr.collection.LinkedHashSet}</td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
+ * <tr><td>{@linkplain io.vavr.collection.LinkedHashMap}</td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
+ * <tr><td>{@linkplain io.vavr.collection.LinkedHashSet}</td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
  * <tr><td><em>{@linkplain io.vavr.collection.Tree}</em></td><td><small>log</small></td><td><small>log</small></td><td><small>log</small></td><td><small>log</small></td></tr>
  * <tr><td>{@linkplain io.vavr.collection.TreeMap}</td><td><small>log</small></td><td><small>log</small></td><td><small>log</small></td><td><small>log</small></td></tr>
  * <tr><td>{@linkplain io.vavr.collection.TreeSet}</td><td><small>log</small></td><td><small>log</small></td><td><small>log</small></td><td><small>log</small></td></tr>

File: vavr/src/main/java/io/vavr/PartialFunction.java
Patch:
@@ -21,6 +21,8 @@
 
 import io.vavr.control.Option;
 
+import java.util.function.Function;
+
 /**
  * Represents a partial function T -&gt; R that is not necessarily defined for all input values of type T.
  * The caller is responsible for calling the method isDefinedAt() before this function is applied to the value.
@@ -51,7 +53,7 @@ public interface PartialFunction<T, R> extends Function1<T, R> {
      * @param <R> type of the function output, called <em>codomain</em> of the function
      * @return a partial function that is not necessarily defined for all input values of type T.
      */
-    static <T, R> PartialFunction<T, R> unlift(Function1<? super T, ? extends Option<? extends R>> totalFunction) {
+    static <T, R> PartialFunction<T, R> unlift(Function<? super T, ? extends Option<? extends R>> totalFunction) {
         return new PartialFunction<T, R>() {
 
             private static final long serialVersionUID = 1L;

File: vavr/src/test/java/io/vavr/collection/JavaConvertersTest.java
Patch:
@@ -2221,13 +2221,13 @@ public void shouldConvertNonEmptyToArray() {
 
     @Test
     public void shouldThrowNPEWhenCallingToArrayNullWhenEmpty() {
-        assertThatThrownBy(() -> empty().toArray(null))
+        assertThatThrownBy(() -> empty().toArray((Object[]) null))
                 .isInstanceOf(NullPointerException.class);
     }
 
     @Test
     public void shouldThrowNPEWhenCallingToArrayNullWhenNotEmpty() {
-        assertThatThrownBy(() -> of('1').toArray(null))
+        assertThatThrownBy(() -> of('1').toArray((Object[]) null))
                 .isInstanceOf(NullPointerException.class);
     }
 

File: vavr-benchmark/src/test/java/io/vavr/collection/MapBenchmark.java
Patch:
@@ -78,7 +78,7 @@ public static class Base {
         public void setup() {
             ELEMENTS = getRandomValues(CONTAINER_SIZE, 0);
             sampleTreeMap = index(ELEMENTS);
-            KEYS = predicableShuffle(sampleTreeMap.keySet().toJavaArray(Integer.class));
+            KEYS = predicableShuffle(sampleTreeMap.keySet().toJavaArray(Integer[]::new));
             REMOVAL = predicableShuffle(KEYS.clone());
             EXPECTED_AGGREGATE = sampleTreeMap.values().reduce(JmhRunner::aggregate);
 

File: vavr-benchmark/src/test/java/io/vavr/control/LazyBenchmark.java
Patch:
@@ -54,7 +54,7 @@ public static class Base {
         @Setup
         @SuppressWarnings({ "unchecked", "rawtypes" })
         public void setup() {
-            EAGERS = Iterator.range(0, SIZE).toJavaArray(Integer.class);
+            EAGERS = Iterator.range(0, SIZE).toJavaArray(Integer[]::new);
             INITED_LAZIES = Iterator.of(EAGERS).map(i -> {
                 final Lazy<Integer> lazy = Lazy.of(() -> i);
                 lazy.get();

File: vavr-test/src/main/java/io/vavr/test/Gen.java
Patch:
@@ -181,7 +181,7 @@ static Gen<Character> choose(char min, char max) {
      */
     static Gen<Character> choose(char... characters) {
         Objects.requireNonNull(characters, "characters is null");
-        final Character[] validCharacters = List.ofAll(characters).toJavaArray(Character.class);
+        final Character[] validCharacters = List.ofAll(characters).toJavaArray(Character[]::new);
         return choose(validCharacters);
     }
 
@@ -345,7 +345,7 @@ static <T> Gen<T> oneOf(Iterable<Gen<T>> generators) {
             throw new IllegalArgumentException("generators is empty");
         }
         @SuppressWarnings("unchecked")
-        final Gen<T>[] array = stream.toJavaArray((Class<Gen<T>>) (Object) Gen.class);
+        final Gen<T>[] array = stream.toJavaArray(Gen[]::new);
         return oneOf(array);
     }
 

File: vavr/src/test/java/io/vavr/collection/AbstractTraversableTest.java
Patch:
@@ -2481,18 +2481,18 @@ public void shouldZipNonNilWithIndexWithMapper() {
         assertThat(actual).isEqualTo(expected);
     }
 
-    // -- toJavaArray(Class)
+    // -- toJavaArray(IntFunction)
 
     @Test
     public void shouldConvertNilToJavaArray() {
-        final Integer[] actual = List.<Integer> empty().toJavaArray(Integer.class);
+        final Integer[] actual = List.<Integer> empty().toJavaArray(Integer[]::new);
         final Integer[] expected = new Integer[] {};
         assertThat(actual).isEqualTo(expected);
     }
 
     @Test
     public void shouldConvertNonNilToJavaArray() {
-        final Integer[] array = of(1, 2).toJavaArray(Integer.class);
+        final Integer[] array = of(1, 2).toJavaArray(Integer[]::new);
         final Integer[] expected = new Integer[] { 1, 2 };
         assertThat(array).isEqualTo(expected);
     }

File: vavr/src/test/java/io/vavr/collection/CharSeqTest.java
Patch:
@@ -1929,14 +1929,14 @@ public void shouldHaveOverloadedToJavaArray() {
 
     @Test
     public void shouldConvertNilToJavaArray() {
-        final Character[] actual = CharSeq.empty().toJavaArray(Character.class);
+        final Character[] actual = CharSeq.empty().toJavaArray(Character[]::new);
         final Character[] expected = new Character[] {};
         assertThat(actual).isEqualTo(expected);
     }
 
     @Test
     public void shouldConvertNonNilToJavaArray() {
-        final Character[] array = CharSeq.of('1', '2').toJavaArray(Character.class);
+        final Character[] array = CharSeq.of('1', '2').toJavaArray(Character[]::new);
         final Character[] expected = new Character[] { '1', '2' };
         assertThat(array).isEqualTo(expected);
     }

File: vavr/src-gen/main/java/io/vavr/Tuple.java
Patch:
@@ -27,7 +27,7 @@
 import java.util.Objects;
 
 /**
- * The base interface of all tuples.
+ * The API entry point of {@code Tuple}.
  *
  * @author Daniel Dietrich
  */

File: vavr/src/main/java/io/vavr/Lambda.java
Patch:
@@ -90,7 +90,7 @@ default boolean isMemoized() {
      * Zero Abstract Method (ZAM) interface for marking functions as memoized using intersection types.
      */
     interface Memoized {
-        static <T extends Tuple, R> R of(Map<T, R> cache, T key, Function1<T, R> tupled) {
+        static <T, R> R of(Map<T, R> cache, T key, Function1<T, R> tupled) {
             synchronized (cache) {
                 if (cache.containsKey(key)) {
                     return cache.get(key);

File: vavr/src/main/java/io/vavr/collection/Seq.java
Patch:
@@ -929,23 +929,23 @@ default int prefixLength(Predicate<? super T> predicate) {
      * {@code Tuple.of(take(n), drop(n))}.
      *
      * @param n An index.
-     * @return A {@link Tuple} containing the first n and the remaining elements.
+     * @return A {@link Tuple2} containing the first n and the remaining elements.
      */
     Tuple2<? extends Seq<T>, ? extends Seq<T>> splitAt(int n);
 
     /**
      * Splits a sequence at the first element which satisfies the {@link Predicate}, e.g. Tuple(init, element+tail).
      *
      * @param predicate An predicate
-     * @return A {@link Tuple} containing divided sequences
+     * @return A {@link Tuple2} containing divided sequences
      */
     Tuple2<? extends Seq<T>, ? extends Seq<T>> splitAt(Predicate<? super T> predicate);
 
     /**
      * Splits a sequence at the first element which satisfies the {@link Predicate}, e.g. Tuple(init+element, tail).
      *
      * @param predicate An predicate
-     * @return A {@link Tuple} containing divided sequences
+     * @return A {@link Tuple2} containing divided sequences
      */
     Tuple2<? extends Seq<T>, ? extends Seq<T>> splitAtInclusive(Predicate<? super T> predicate);
 

File: vavr/src/test/java/io/vavr/collection/CharSeqTest.java
Patch:
@@ -3655,7 +3655,7 @@ public void shouldUnfoldRightToEmpty() {
 
     @Test
     public void shouldUnfoldRightSimpleCharSeq() {
-        assertThat(
+        this.<CharSeq> assertThat(
                 CharSeq.unfoldRight('j', x -> x == 'a'
                                               ? Option.none()
                                               : Option.of(new Tuple2<>(x, (char) (x - 1)))))
@@ -3669,7 +3669,7 @@ public void shouldUnfoldLeftToEmpty() {
 
     @Test
     public void shouldUnfoldLeftSimpleCharSeq() {
-        assertThat(
+        this.<CharSeq> assertThat(
                 CharSeq.unfoldLeft('j', x -> x == 'a'
                                              ? Option.none()
                                              : Option.of(new Tuple2<>((char) (x - 1), x))))

File: vavr/src/main/java/io/vavr/collection/TreeSet.java
Patch:
@@ -192,7 +192,6 @@ public static <T extends Comparable<? super T>> TreeSet<T> fill(int n, Supplier<
         return fill(Comparators.naturalComparator(), n, s);
     }
 
-    @SuppressWarnings("unchecked")
     public static <T extends Comparable<? super T>> TreeSet<T> ofAll(Iterable<? extends T> values) {
         return ofAll(Comparators.naturalComparator(), values);
     }
@@ -201,10 +200,10 @@ public static <T extends Comparable<? super T>> TreeSet<T> ofAll(Iterable<? exte
     public static <T> TreeSet<T> ofAll(Comparator<? super T> comparator, Iterable<? extends T> values) {
         Objects.requireNonNull(comparator, "comparator is null");
         Objects.requireNonNull(values, "values is null");
-        if (values instanceof TreeSet && ((TreeSet) values).comparator() == comparator) {
+        if (values instanceof TreeSet && ((TreeSet<?>) values).comparator() == comparator) {
             return (TreeSet<T>) values;
         } else {
-            return values.iterator().hasNext() ? new TreeSet<>(RedBlackTree.ofAll(comparator, values)) : (TreeSet<T>) empty();
+            return values.iterator().hasNext() ? new TreeSet<>(RedBlackTree.ofAll(comparator, values)) : empty(comparator);
         }
     }
 

File: vavr-benchmark/src/test/java/io/vavr/collection/VectorBenchmark.java
Patch:
@@ -541,7 +541,7 @@ public Object ecollections_persistent() {
 
         @Benchmark
         public Object scala_persistent() {
-            final scala.collection.immutable.Vector<Integer> values = (scala.collection.immutable.Vector<Integer>) ((scala.collection.Traversable<Integer>) scalaPersistent).map(Map::mapper, canBuildFrom);
+            final scala.collection.immutable.Vector<Integer> values = (scala.collection.immutable.Vector<Integer>) scalaPersistent.map(Map::mapper, canBuildFrom);
             assert areEqual(asJavaCollection(values), Array.of(ELEMENTS).map(Map::mapper));
             return values;
         }
@@ -845,7 +845,7 @@ public static class GroupBy extends Base {
         public Object java_mutable() { return javaMutable.stream().collect(groupingBy(Integer::bitCount)); }
 
         @Benchmark
-        public Object scala_persistent() { return ((scala.collection.Seq<Integer>) scalaPersistent).groupBy(Integer::bitCount); }
+        public Object scala_persistent() { return scalaPersistent.groupBy(Integer::bitCount); }
 
         @Benchmark
         public Object vavr_persistent() { return vavrPersistent.groupBy(Integer::bitCount); }

File: vavr/src/main/java/io/vavr/collection/HashMap.java
Patch:
@@ -428,7 +428,7 @@ public static <K, V> HashMap<K, V> tabulate(int n, Function<? super Integer, ? e
     }
 
     /**
-     * Returns an HashMap containing {@code n} values supplied by a given Supplier {@code s}.
+     * Returns a HashMap containing tuples returned by {@code n} calls to a given Supplier {@code s}.
      *
      * @param <K> The key type
      * @param <V> The value type

File: vavr/src/main/java/io/vavr/collection/HashSet.java
Patch:
@@ -132,7 +132,7 @@ public static <T> HashSet<T> tabulate(int n, Function<? super Integer, ? extends
     }
 
     /**
-     * Returns an HashSet containing {@code n} values supplied by a given Supplier {@code s}.
+     * Returns a HashSet containing tuples returned by {@code n} calls to a given Supplier {@code s}.
      *
      * @param <T> Component type of the HashSet
      * @param n   The number of elements in the HashSet

File: vavr/src/main/java/io/vavr/collection/LinkedHashMap.java
Patch:
@@ -451,7 +451,7 @@ public static <K, V> LinkedHashMap<K, V> tabulate(int n, Function<? super Intege
     }
 
     /**
-     * Returns a LinkedHashMap containing {@code n} values supplied by a given Supplier {@code s}.
+     * Returns a LinkedHashMap containing tuples returned by {@code n} calls to a given Supplier {@code s}.
      *
      * @param <K> The key type
      * @param <V> The value type

File: vavr/src/main/java/io/vavr/collection/LinkedHashSet.java
Patch:
@@ -136,7 +136,7 @@ public static <T> LinkedHashSet<T> tabulate(int n, Function<? super Integer, ? e
     }
 
     /**
-     * Returns a LinkedHashSet containing {@code n} values supplied by a given Supplier {@code s}.
+     * Returns a LinkedHashSet containing tuples returned by {@code n} calls to a given Supplier {@code s}.
      *
      * @param <T> Component type of the LinkedHashSet
      * @param n   The number of elements in the LinkedHashSet

File: vavr/src/main/java/io/vavr/collection/TreeMap.java
Patch:
@@ -807,7 +807,7 @@ public static <K extends Comparable<? super K>, V> TreeMap<K, V> tabulate(int n,
     }
 
     /**
-     * Returns a TreeMap containing {@code n} values supplied by a given Supplier {@code s}.
+     * Returns a TreeMap containing tuples returned by {@code n} calls to a given Supplier {@code s}.
      *
      * @param <K>           The key type
      * @param <V>           The value type
@@ -824,7 +824,7 @@ public static <K, V> TreeMap<K, V> fill(Comparator<? super K> keyComparator, int
     }
 
     /**
-     * Returns a TreeMap containing {@code n} values supplied by a given Supplier {@code s}.
+     * Returns a TreeMap containing tuples returned by {@code n} calls to a given Supplier {@code s}.
      * The underlying key comparator is the natural comparator of K.
      *
      * @param <K> The key type

File: vavr/src/main/java/io/vavr/collection/TreeSet.java
Patch:
@@ -162,7 +162,7 @@ public static <T extends Comparable<? super T>> TreeSet<T> tabulate(int n, Funct
     }
 
     /**
-     * Returns a TreeSet containing {@code n} values supplied by a given Supplier {@code s}.
+     * Returns a TreeSet containing tuples returned by {@code n} calls to a given Supplier {@code s}.
      *
      * @param <T>        Component type of the TreeSet
      * @param comparator The comparator used to sort the elements
@@ -178,7 +178,7 @@ public static <T> TreeSet<T> fill(Comparator<? super T> comparator, int n, Suppl
     }
 
     /**
-     * Returns a TreeSet containing {@code n} values supplied by a given Supplier {@code s}.
+     * Returns a TreeSet containing tuples returned by {@code n} calls to a given Supplier {@code s}.
      * The underlying comparator is the natural comparator of T.
      *
      * @param <T> Component type of the TreeSet

File: vavr/src/test/java/io/vavr/collection/AbstractTraversableTest.java
Patch:
@@ -2784,6 +2784,8 @@ public void shouldTabulateTheSeqWith0ElementsWhenNIsNegative() {
         assertThat(tabulate(-1, i -> i)).isEqualTo(empty());
     }
 
+    // -- fill(int, Supplier)
+
     @Test
     public void shouldFillTheSeqCallingTheSupplierInTheRightOrder() {
         final java.util.LinkedList<Integer> ints = new java.util.LinkedList<>(asList(0, 1));

File: vavr/src-gen/main/java/io/vavr/Tuple8.java
Patch:
@@ -23,7 +23,6 @@
    G E N E R A T O R   C R A F T E D
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
-import io.vavr.collection.Iterator;
 import io.vavr.collection.List;
 import io.vavr.collection.Seq;
 import io.vavr.control.HashCodes;

File: vavr/src/main/java/io/vavr/concurrent/Future.java
Patch:
@@ -483,7 +483,7 @@ static <T> Future<T> reduce(Executor executor, Iterable<? extends Future<? exten
         if (!futures.iterator().hasNext()) {
             throw new NoSuchElementException("Future.reduce on empty futures");
         } else {
-            return Future.sequence(futures).map(seq -> seq.reduceLeft(f));
+            return Future.<T> sequence(futures).map(seq -> seq.reduceLeft(f));
         }
     }
 

File: vavr/src/main/java/io/vavr/control/Validation.java
Patch:
@@ -182,7 +182,7 @@ static <E, T> Validation<E, T> fromEither(Either<E, T> either) {
     }
 
     /**
-     * Creates a {@code Validation} of an {@code Either}.
+     * Creates a {@code Validation} of an {@code Try}.
      *
      * @param t   A {@code Try}
      * @param <T> type of the valid value

File: vavr/src/test/java/io/vavr/MatchTest.java
Patch:
@@ -29,7 +29,6 @@
 
 import java.math.BigDecimal;
 import java.time.Year;
-import java.util.function.BiFunction;
 import java.util.function.Predicate;
 
 import static io.vavr.API.$;
@@ -325,7 +324,7 @@ public void shouldDecomposeListOfTuple3() {
     @SuppressWarnings("UnnecessaryLocalVariable")
     @Test
     public void shouldDecomposeListWithNonEmptyTail() {
-        final List<Option<Number>> numberOptionList = List.of(Option.some(1), Option.some(2.0));
+        final List<Option<? extends Number>> numberOptionList = List.of(Option.some(1), Option.some(2.0));
         final String actual = Match(numberOptionList).of(
                 Case($Cons($Some($(1)), $Cons($Some($(2.0)), $())),  (x, xs) -> {
                     final Some<Number> head = x;

File: vavr/src/test/java/io/vavr/control/EitherTest.java
Patch:
@@ -392,7 +392,7 @@ public void shouldConvertToValidValidation() {
     public void shouldConvertToInvalidValidation() {
         final Validation<String, ?> validation = Either.left("vavr").toValidation();
         assertThat(validation.isInvalid()).isTrue();
-        assertThat(validation.getError()).isEqualTo("vavr");
+        assertThat(validation.getErrors()).isEqualTo(List.of("vavr"));
     }
 
     // hashCode

File: vavr/src/test/java/io/vavr/control/OptionTest.java
Patch:
@@ -429,17 +429,17 @@ public void shouldMakeLeftOnNoneToEitherSupplier() {
 
     @Test
     public void shouldMakeValidOnSomeToValidation() {
-        assertThat(API.Some(5).toValidation("bad")).isEqualTo(API.Valid(5));
+        assertThat(API.Some(5).toValid("bad")).isEqualTo(API.Valid(5));
     }
 
     @Test
     public void shouldMakeLeftOnNoneToValidation() {
-        assertThat(API.None().toValidation("bad")).isEqualTo(API.Invalid("bad"));
+        assertThat(API.None().toValid("bad")).isEqualTo(API.Invalid("bad"));
     }
 
     @Test
     public void shouldMakeLeftOnNoneToValidationSupplier() {
-        assertThat(API.None().toValidation(() -> "bad")).isEqualTo(API.Invalid("bad"));
+        assertThat(API.None().toValid(() -> "bad")).isEqualTo(API.Invalid("bad"));
     }
 
     // -- peek

File: vavr-benchmark/src/test/java/io/vavr/JmhRunner.java
Patch:
@@ -52,6 +52,7 @@ public static void main(String[] args) {
                 CharSeqBenchmark.class,
                 HashSetBenchmark.class,
                 ListBenchmark.class,
+                MapBenchmark.class,
                 PriorityQueueBenchmark.class,
                 VectorBenchmark.class,
 
@@ -168,7 +169,7 @@ private enum Assertions {
 
     private enum PrintInlining {
         ENABLE,
-        DISABLE;
+        DISABLE
     }
 
     /* Helper methods */

File: vavr-benchmark/src/test/java/io/vavr/collection/BitSetBenchmark.java
Patch:
@@ -46,7 +46,7 @@ public static void main(String... args) {
 
     @State(Scope.Benchmark)
     public static class Base {
-        @Param({ "10", "100", "1000" })
+        @Param({"10", "100", "1000", "2500"})
         public int CONTAINER_SIZE;
 
         int EXPECTED_AGGREGATE;
@@ -80,7 +80,7 @@ public Object scala_persistent() {
             for (int element : ELEMENTS) {
                 values = values.$plus(element);
             }
-            assert ((scala.collection.immutable.SortedSet) values).equals(scalaPersistent);
+            assert values.equals(scalaPersistent);
             return values;
         }
 

File: vavr-benchmark/src/test/java/io/vavr/collection/CharSeqBenchmark.java
Patch:
@@ -54,7 +54,7 @@ public static void main(java.lang.String... args) {
 
     @State(Scope.Benchmark)
     public static class Base {
-        @Param({ "10", "100", "1000" })
+        @Param({"10", "100", "1000", "2500"})
         public int CONTAINER_SIZE;
 
         int EXPECTED_AGGREGATE;

File: vavr-benchmark/src/test/java/io/vavr/collection/IteratorBenchmark.java
Patch:
@@ -48,7 +48,7 @@ public static void main(String... args) {
 
     @State(Scope.Benchmark)
     public static class Base {
-        @Param({ "10", "100", "1000" })
+        @Param({"10", "100", "1000", "2500"})
         public int CONTAINER_SIZE;
 
         Integer[] ELEMENTS;

File: vavr-benchmark/src/test/java/io/vavr/collection/ListBenchmark.java
Patch:
@@ -58,7 +58,7 @@ public static void main(String... args) {
 
     @State(Scope.Benchmark)
     public static class Base {
-        @Param({ "10", "100", "1000" })
+        @Param({"10", "100", "1000", "2500"})
         public int CONTAINER_SIZE;
 
         int EXPECTED_AGGREGATE;

File: vavr-benchmark/src/test/java/io/vavr/collection/PriorityQueueBenchmark.java
Patch:
@@ -60,7 +60,7 @@ public static class Base {
         static final Ordering<Integer> SCALA_ORDERING = Ordering$.MODULE$.comparatorToOrdering(Integer::compareTo);
         static final Order<Integer> SCALAZ_ORDER = Order$.MODULE$.fromScalaOrdering(SCALA_ORDERING);
 
-        @Param({ "10", "100", "1000" })
+        @Param({"10", "100", "1000", "2500"})
         public int CONTAINER_SIZE;
 
         int EXPECTED_AGGREGATE;

File: vavr-benchmark/src/test/java/io/vavr/collection/VectorBenchmark.java
Patch:
@@ -20,7 +20,6 @@
 package io.vavr.collection;
 
 import io.vavr.JmhRunner;
-import org.eclipse.collections.api.list.MutableList;
 import org.junit.Test;
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.infra.Blackhole;
@@ -73,7 +72,7 @@ public static void main(String... args) {
 
     @State(Scope.Benchmark)
     public static class Base {
-        @Param({ "10", "100", "1026" })
+        @Param({"10", "100", "1000", "1026", "2500"})
         public int CONTAINER_SIZE;
 
         int EXPECTED_AGGREGATE;
@@ -462,7 +461,7 @@ public Object pcollections_persistent() {
         public Object ecollections_persistent() {
             org.eclipse.collections.api.list.ImmutableList<Integer> values = eCollectionsPersistent;
             for (int i : RANDOMIZED_INDICES) {
-                final MutableList<Integer> copy = values.toList();
+                final org.eclipse.collections.api.list.MutableList<Integer> copy = values.toList();
                 copy.set(i, 0);
                 values = copy.toImmutable();
             }

File: vavr/src-gen/main/java/io/vavr/Tuple1.java
Patch:
@@ -26,6 +26,7 @@
 import io.vavr.collection.Iterator;
 import io.vavr.collection.List;
 import io.vavr.collection.Seq;
+import io.vavr.control.HashCodes;
 import java.io.Serializable;
 import java.util.Comparator;
 import java.util.Objects;
@@ -155,10 +156,9 @@ public boolean equals(Object o) {
         }
     }
 
-    // if _1 == null, hashCode() returns Objects.hash(new T1[] { null }) = 31 instead of 0 = Objects.hash(null)
     @Override
     public int hashCode() {
-        return Objects.hash(_1);
+        return HashCodes.hash(_1);
     }
 
     @Override

File: vavr/src-gen/main/java/io/vavr/Tuple2.java
Patch:
@@ -26,6 +26,7 @@
 import io.vavr.collection.Iterator;
 import io.vavr.collection.List;
 import io.vavr.collection.Seq;
+import io.vavr.control.HashCodes;
 import java.io.Serializable;
 import java.util.AbstractMap;
 import java.util.Comparator;
@@ -261,7 +262,7 @@ public boolean equals(Object o) {
 
     @Override
     public int hashCode() {
-        return Objects.hash(_1, _2);
+        return HashCodes.hash(_1, _2);
     }
 
     @Override

File: vavr/src-gen/main/java/io/vavr/Tuple3.java
Patch:
@@ -26,6 +26,7 @@
 import io.vavr.collection.Iterator;
 import io.vavr.collection.List;
 import io.vavr.collection.Seq;
+import io.vavr.control.HashCodes;
 import java.io.Serializable;
 import java.util.Comparator;
 import java.util.Objects;
@@ -293,7 +294,7 @@ public boolean equals(Object o) {
 
     @Override
     public int hashCode() {
-        return Objects.hash(_1, _2, _3);
+        return HashCodes.hash(_1, _2, _3);
     }
 
     @Override

File: vavr/src-gen/main/java/io/vavr/Tuple4.java
Patch:
@@ -26,6 +26,7 @@
 import io.vavr.collection.Iterator;
 import io.vavr.collection.List;
 import io.vavr.collection.Seq;
+import io.vavr.control.HashCodes;
 import java.io.Serializable;
 import java.util.Comparator;
 import java.util.Objects;
@@ -348,7 +349,7 @@ public boolean equals(Object o) {
 
     @Override
     public int hashCode() {
-        return Objects.hash(_1, _2, _3, _4);
+        return HashCodes.hash(_1, _2, _3, _4);
     }
 
     @Override

File: vavr/src-gen/main/java/io/vavr/Tuple5.java
Patch:
@@ -26,6 +26,7 @@
 import io.vavr.collection.Iterator;
 import io.vavr.collection.List;
 import io.vavr.collection.Seq;
+import io.vavr.control.HashCodes;
 import java.io.Serializable;
 import java.util.Comparator;
 import java.util.Objects;
@@ -403,7 +404,7 @@ public boolean equals(Object o) {
 
     @Override
     public int hashCode() {
-        return Objects.hash(_1, _2, _3, _4, _5);
+        return HashCodes.hash(_1, _2, _3, _4, _5);
     }
 
     @Override

File: vavr/src-gen/main/java/io/vavr/Tuple6.java
Patch:
@@ -26,6 +26,7 @@
 import io.vavr.collection.Iterator;
 import io.vavr.collection.List;
 import io.vavr.collection.Seq;
+import io.vavr.control.HashCodes;
 import java.io.Serializable;
 import java.util.Comparator;
 import java.util.Objects;
@@ -458,7 +459,7 @@ public boolean equals(Object o) {
 
     @Override
     public int hashCode() {
-        return Objects.hash(_1, _2, _3, _4, _5, _6);
+        return HashCodes.hash(_1, _2, _3, _4, _5, _6);
     }
 
     @Override

File: vavr/src-gen/main/java/io/vavr/Tuple7.java
Patch:
@@ -26,6 +26,7 @@
 import io.vavr.collection.Iterator;
 import io.vavr.collection.List;
 import io.vavr.collection.Seq;
+import io.vavr.control.HashCodes;
 import java.io.Serializable;
 import java.util.Comparator;
 import java.util.Objects;
@@ -513,7 +514,7 @@ public boolean equals(Object o) {
 
     @Override
     public int hashCode() {
-        return Objects.hash(_1, _2, _3, _4, _5, _6, _7);
+        return HashCodes.hash(_1, _2, _3, _4, _5, _6, _7);
     }
 
     @Override

File: vavr/src-gen/main/java/io/vavr/Tuple8.java
Patch:
@@ -26,6 +26,7 @@
 import io.vavr.collection.Iterator;
 import io.vavr.collection.List;
 import io.vavr.collection.Seq;
+import io.vavr.control.HashCodes;
 import java.io.Serializable;
 import java.util.Comparator;
 import java.util.Objects;
@@ -568,7 +569,7 @@ public boolean equals(Object o) {
 
     @Override
     public int hashCode() {
-        return Objects.hash(_1, _2, _3, _4, _5, _6, _7, _8);
+        return HashCodes.hash(_1, _2, _3, _4, _5, _6, _7, _8);
     }
 
     @Override

File: vavr/src-gen/test/java/io/vavr/Tuple1Test.java
Patch:
@@ -133,7 +133,7 @@ public void shouldRecognizeNonEqualityPerComponent() {
     @Test
     public void shouldComputeCorrectHashCode() {
         final int actual = createTuple().hashCode();
-        final int expected = Objects.hash(new Object[] { null });
+        final int expected = Objects.hashCode(null);
         assertThat(actual).isEqualTo(expected);
     }
 

File: vavr/src/main/java/io/vavr/Lazy.java
Patch:
@@ -22,6 +22,7 @@
 import io.vavr.collection.Iterator;
 import io.vavr.collection.Seq;
 import io.vavr.collection.Vector;
+import io.vavr.control.HashCodes;
 import io.vavr.control.Option;
 
 import java.io.IOException;
@@ -275,7 +276,7 @@ public boolean equals(Object o) {
 
     @Override
     public int hashCode() {
-        return Objects.hash(get());
+        return HashCodes.hash(get());
     }
 
     @Override

File: vavr/src/main/java/io/vavr/collection/Collections.java
Patch:
@@ -21,6 +21,7 @@
 
 import io.vavr.collection.JavaConverters.ChangePolicy;
 import io.vavr.collection.JavaConverters.ListView;
+import io.vavr.control.HashCodes;
 import io.vavr.control.Option;
 
 import java.util.*;
@@ -212,7 +213,7 @@ private static int hash(Iterable<?> iterable, IntBinaryOperator accumulator) {
         } else {
             int hashCode = 1;
             for (Object o : iterable) {
-                hashCode = accumulator.applyAsInt(hashCode, Objects.hashCode(o));
+                hashCode = accumulator.applyAsInt(hashCode, HashCodes.hash(o));
             }
             return hashCode;
         }

File: vavr/src/main/java/io/vavr/collection/Tree.java
Patch:
@@ -25,6 +25,7 @@
 import io.vavr.Tuple3;
 import io.vavr.collection.List.Nil;
 import io.vavr.collection.Tree.*;
+import io.vavr.control.HashCodes;
 import io.vavr.control.Option;
 
 import java.io.*;
@@ -919,7 +920,7 @@ public boolean equals(Object o) {
 
         @Override
         public int hashCode() {
-            return Objects.hash(value, children);
+            return HashCodes.hash(value, children);
         }
 
         @Override

File: vavr/src/main/java/io/vavr/control/Either.java
Patch:
@@ -1059,7 +1059,7 @@ public boolean equals(Object obj) {
 
         @Override
         public int hashCode() {
-            return Objects.hashCode(value);
+            return HashCodes.hash(value);
         }
 
         @Override
@@ -1122,7 +1122,7 @@ public boolean equals(Object obj) {
 
         @Override
         public int hashCode() {
-            return Objects.hashCode(value);
+            return HashCodes.hash(value);
         }
 
         @Override

File: vavr/src/main/java/io/vavr/control/Option.java
Patch:
@@ -467,7 +467,7 @@ public boolean equals(Object obj) {
 
         @Override
         public int hashCode() {
-            return Objects.hashCode(value);
+            return HashCodes.hash(value);
         }
 
         @Override

File: vavr/src/main/java/io/vavr/control/Try.java
Patch:
@@ -1108,7 +1108,7 @@ public boolean equals(Object obj) {
 
         @Override
         public int hashCode() {
-            return Objects.hashCode(value);
+            return HashCodes.hash(value);
         }
 
         @Override

File: vavr/src/main/java/io/vavr/control/Validation.java
Patch:
@@ -700,7 +700,7 @@ public boolean equals(Object obj) {
 
         @Override
         public int hashCode() {
-            return Objects.hashCode(value);
+            return HashCodes.hash(value);
         }
 
         @Override
@@ -763,7 +763,7 @@ public boolean equals(Object obj) {
 
         @Override
         public int hashCode() {
-            return Objects.hashCode(error);
+            return HashCodes.hash(error);
         }
 
         @Override

File: vavr/src/test/java/io/vavr/TupleTest.java
Patch:
@@ -20,6 +20,7 @@
 package io.vavr;
 
 import io.vavr.collection.List;
+import io.vavr.control.HashCodes;
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
 
@@ -108,7 +109,7 @@ public void shouldCreateSingle() {
     @Test
     public void shouldHashTuple1() {
         final Tuple1<?> t = tuple1();
-        assertThat(t.hashCode()).isEqualTo(Objects.hash(t._1));
+        assertThat(t.hashCode()).isEqualTo(HashCodes.hash(t._1));
     }
 
     @Test

File: vavr/src/test/java/io/vavr/collection/BitSetTest.java
Patch:
@@ -464,7 +464,7 @@ public void shouldSerializeDeserializeEnumBitSet() {
     @Test
     public void shouldBehaveExactlyLikeAnotherBitSet() {
         for (int i = 0; i < 10; i++) {
-            final Random random = getRandom(-1);
+            final Random random = getRandom(123456789);
 
             final java.util.BitSet mutableBitSet = new java.util.BitSet();
             BitSet<Integer> functionalBitSet = BitSet.empty();

File: vavr/src/test/java/io/vavr/collection/PriorityQueueTest.java
Patch:
@@ -254,7 +254,7 @@ public void shouldKeepInstanceOfPriorityQueue() {
     @Test
     public void shouldBehaveExactlyLikeAnotherPriorityQueue() {
         for (int i = 0; i < 10; i++) {
-            final Random random = getRandom(-1);
+            final Random random = getRandom(987654321);
 
             final java.util.PriorityQueue<Integer> mutablePriorityQueue = new java.util.PriorityQueue<>();
             PriorityQueue<Integer> functionalPriorityQueue = PriorityQueue.empty();

File: vavr/src/test/java/io/vavr/control/TryTest.java
Patch:
@@ -1260,7 +1260,8 @@ public void shouldSerializeDeserializeFailure() {
 
     @Test
     public void shouldDetectSuccessOfRunnable() {
-        assertThat(Try.run(() -> System.out.println("side-effect")).isSuccess()).isTrue();
+        //noinspection ResultOfMethodCallIgnored
+        assertThat(Try.run(() -> String.valueOf("side-effect")).isSuccess()).isTrue();
     }
 
     @Test

File: vavr-benchmark/src/test/java/io/vavr/JmhRunner.java
Patch:
@@ -71,6 +71,7 @@ public enum Includes {
         FUNCTIONAL_JAVA("fjava"),
         PCOLLECTIONS("pcollections"),
         ECOLLECTIONS("ecollections"),
+        CAPSULE("capsule"),
         CLOJURE("clojure"),
         SCALAZ("scalaz"),
         SCALA("scala"),

File: vavr-benchmark/src/test/java/io/vavr/MemoryUsage.java
Patch:
@@ -72,7 +72,8 @@ static void storeMemoryUsages(int elementCount, Object target) {
             Tuple.of("^scalaz\\.Heap", "Scalaz persistent @ "),
             Tuple.of("^scala\\.collection.immutable", "Scala persistent @ "),
             Tuple.of("^scala\\.collection.mutable", "Scala mutable @ "),
-            Tuple.of("^io.vavr\\.", "Vavr persistent @ ")
+            Tuple.of("^io\\.usethesource", "Capsule persistent @ "),
+            Tuple.of("^io\\.vavr\\.", "Vavr persistent @ ")
     ).mapKeys(r -> Pattern.compile(r).asPredicate());
     private static String toHumanReadableName(Object target) {
         final Class<?> type = target.getClass();

File: vavr-benchmark/src/test/java/io/vavr/collection/HashSetBenchmark.java
Patch:
@@ -23,6 +23,7 @@
 import org.junit.Test;
 import org.openjdk.jmh.annotations.*;
 
+import static io.vavr.JmhRunner.Includes.*;
 import static io.vavr.JmhRunner.create;
 import static io.vavr.JmhRunner.getRandomValues;
 import static scala.collection.JavaConverters.asScalaBuffer;
@@ -39,7 +40,7 @@ public void testAsserts() {
     }
 
     public static void main(String... args) {
-        JmhRunner.runNormalNoAsserts(CLASSES);
+        JmhRunner.runNormalNoAsserts(CLASSES, SCALA, CAPSULE, PCOLLECTIONS, VAVR);
     }
 
     @State(Scope.Benchmark)

File: vavr/src/main/java/io/vavr/Value.java
Patch:
@@ -1383,6 +1383,9 @@ default Tree<T> toTree() {
     /**
      * Converts this to a {@link Tree} using a {@code idMapper} and {@code parentMapper}.
      *
+     * @param <ID> Id type
+     * @param idMapper     A mapper from source item to unique identifier of that item
+     * @param parentMapper A mapper from source item to unique identifier of parent item. Need return null for root items
      * @return A new {@link Tree}.
      * @see Tree#build(Iterable, Function, Function)
      */

File: vavr/src/test/java/io/vavr/LazyTest.java
Patch:
@@ -160,8 +160,8 @@ public void shouldMapOverLazyValue() {
     @Test
     public void shouldFilterOverLazyValue() {
         final Lazy<Integer> testee = Lazy.of(() -> 42);
-        final Option<Integer> expectedPositive = Option.some(42);
-        final Option<Integer> expectedNegative = Option.none();
+        final Lazy<Option<Integer>> expectedPositive = Lazy.of(() -> Option.some(42));
+        final Lazy<Option<Integer>> expectedNegative = Lazy.of(Option::none);
 
         assertThat(testee.filter(i -> i % 2 == 0)).isEqualTo(expectedPositive);
         assertThat(testee.filter(i -> i % 2 != 0)).isEqualTo(expectedNegative);

File: vavr/src/main/java/io/vavr/collection/Traversable.java
Patch:
@@ -1029,7 +1029,7 @@ default boolean nonEmpty() {
     Traversable<T> orElse(Supplier<? extends Iterable<? extends T>> supplier);
 
     /**
-     * Creates a partition of this {@code Traversable} by splitting this elements in two in distinct tarversables
+     * Creates a partition of this {@code Traversable} by splitting this elements in two in distinct traversables
      * according to a predicate.
      *
      * @param predicate A predicate which classifies an element if it is in the first or the second traversable.

File: vavr/src/test/java/io/vavr/collection/AbstractMapTest.java
Patch:
@@ -595,7 +595,7 @@ public static String toHexString(byte[] bytes) {
     }
 
     @Test
-    public void shouldReturnModifiedKeysMapWithNonUniqueMapperAndMergedValus() {
+    public void shouldReturnModifiedKeysMapWithNonUniqueMapperAndMergedValues() {
         final Map<Integer, String> actual = emptyIntString()
                 .put(1, "1").put(2, "2").put(3, "3")
                 .mapKeys(k -> k * 118).mapKeys(Integer::toHexString).mapKeys(AbstractMapTest::md5)//Unique key mappers

File: vavr/src/test/java/io/vavr/collection/AbstractTraversableTest.java
Patch:
@@ -257,7 +257,7 @@ public void shouldComputeAverageOfBigDecimal() {
     }
 
     @Test
-    public void shouldComputeAvergageAndCompensateErrors() {
+    public void shouldComputeAverageAndCompensateErrors() {
         // Kahan's summation algorithm (used by DoubleStream.average()) returns 0.0 (false)
         // Neumaier's modification of Kahan's algorithm returns 0.75 (correct)
         assertThat(of(1.0, +10e100, 2.0, -10e100).average().get()).isEqualTo(0.75);

File: vavr/src/test/java/io/vavr/collection/CharSeqTest.java
Patch:
@@ -853,7 +853,7 @@ public void shouldFlatMapElementsToSequentialValuesInTheRightOrder() {
     // -- flatMapChars()
 
     @Test
-    public void sholdFlatMapChars() {
+    public void shouldFlatMapChars() {
         assertThat(CharSeq.empty().flatMapChars(c -> "X")).isEqualTo(CharSeq.empty());
         assertThat(CharSeq.of('1', '2', '3').flatMapChars(c -> c == '1' ? "*" : "-")).isEqualTo(CharSeq.of("*--"));
     }
@@ -2570,7 +2570,7 @@ public void shouldThrowWhenInsertingNull() {
     // -- insertAll
 
     @Test
-    public void shouldInserAlltIntoNil() {
+    public void shouldInsertAllIntoNil() {
         final CharSeq actual = CharSeq.empty().insertAll(0, CharSeq.of('1', '2', '3'));
         final CharSeq expected = CharSeq.of('1', '2', '3');
         assertThat(actual).isEqualTo(expected);
@@ -2875,7 +2875,7 @@ public void shouldNotRemoveAllNonExistingElementsFromNonNil() {
     }
 
     @Test
-    public void shouldRemoveAllInterableContainingNull() {
+    public void shouldRemoveAllIterableContainingNull() {
         final CharSeq charSeq = CharSeq.of('a');
         assertThat(charSeq.removeAll(List.of((Character) null))).isSameAs(charSeq);
     }

File: vavr/src/test/java/io/vavr/collection/ComparatorsTest.java
Patch:
@@ -12,7 +12,7 @@ public class ComparatorsTest {
     // -- naturalComparator()
 
     @Test
-    public void shouldCompareTwoIntegersUsingNaturealOrder() {
+    public void shouldCompareTwoIntegersUsingNaturalOrder() {
         final Comparator<Integer> comparator = naturalComparator();
         assertThat(comparator.compare(0, 1)).isEqualTo(-1);
         assertThat(comparator.compare(2, -1)).isEqualTo(1);

File: vavr/src/test/java/io/vavr/collection/IteratorTest.java
Patch:
@@ -281,7 +281,7 @@ public void shouldConcatNonEmptyArrayIterable() {
     }
 
     @Test
-    public void shouldConcatNetedConcatIterators() {
+    public void shouldConcatNestedConcatIterators() {
         assertThat(concat(List.of(1, 2), List.of(3), concat(List.of(4, 5)))).isEqualTo(Iterator.of(1, 2, 3, 4, 5));
         assertThat(concat(concat(List.of(4, 5)), List.of(1, 2), List.of(3))).isEqualTo(Iterator.of(4, 5, 1, 2, 3));
     }

File: vavr/src/test/java/io/vavr/collection/RedBlackTreeTest.java
Patch:
@@ -159,7 +159,7 @@ public void shouldInsertNonNullIntoEmptyTree() {
     }
 
     @Test
-    public void shouldReturnTheSameInstanceWhenInsertingAnAlreadyContainedELement() {
+    public void shouldReturnTheSameInstanceWhenInsertingAnAlreadyContainedElement() {
         final RedBlackTree<Integer> testee = of(1, 2, 3);
         final RedBlackTree<Integer> actual = testee.insert(2);
         assertThat(actual).isEqualTo(testee);

File: vavr/src/test/java/io/vavr/collection/StreamTest.java
Patch:
@@ -618,7 +618,7 @@ public void shouldNotEvaluateHeadOfTailWhenCallingIteratorHasNext() {
     // -- take
 
     @Test
-    public void shouldNotEvaluateNplusOneWhenTakeN() {
+    public void shouldNotEvaluateNPlusOneWhenTakeN() {
         final Predicate<Integer> hiddenThrow = i -> {
             if (i == 0) {
                 return true;

File: vavr/src/test/java/io/vavr/collection/euler/Euler26Test.java
Patch:
@@ -70,10 +70,10 @@ public void shouldSolveProblem26() {
         assertThat(recurringCycleLengthForDivisionOf1(8)._2).isEqualTo(0);
         assertThat(recurringCycleLengthForDivisionOf1(9)._2).isEqualTo(1);
         assertThat(recurringCycleLengthForDivisionOf1(10)._2).isEqualTo(0);
-        assertThat(deonominatorBelow1000WithTheLongetsRecurringCycleOfDecimalFractions()).isEqualTo(983);
+        assertThat(denominatorBelow1000WithTheLongetsRecurringCycleOfDecimalFractions()).isEqualTo(983);
     }
 
-    private static int deonominatorBelow1000WithTheLongetsRecurringCycleOfDecimalFractions() {
+    private static int denominatorBelow1000WithTheLongetsRecurringCycleOfDecimalFractions() {
         return List.range(2, 1000)
                 .map(Euler26Test::recurringCycleLengthForDivisionOf1)
                 .maxBy(Tuple2::_2)
@@ -122,7 +122,7 @@ private static Function1<Stream<Character>, Stream<String>> createCandidateCycle
         return reversedDecimalFractionPart -> reversedDecimalFractionPart
                 .map(String::valueOf)
                 .scan("", String::concat)
-                .drop(1); // Drop the first emtpy string created by scan
+                .drop(1); // Drop the first empty string created by scan
     }
 
     private static Function1<Stream<String>, Stream<String>> removeCandidatesLongerThanHalfTheFullString(String decimalFractionPart) {

File: vavr/src/test/java/io/vavr/collection/euler/Euler34Test.java
Patch:
@@ -49,7 +49,7 @@ public void shouldSolveProblem34() {
     }
 
     private static int sumOfOfAllNumbersWhichAreEqualToSumOfDigitFactorial() {
-        return Stream.rangeClosed(3, 2_540_160) // 9! * 7 = 2 540 160 is a seven digit number, as is 9! * 8, therefor 9! * 7 is the difinitive upper limit we have to investigate.
+        return Stream.rangeClosed(3, 2_540_160) // 9! * 7 = 2 540 160 is a seven digit number, as is 9! * 8, therefor 9! * 7 is the definitive upper limit we have to investigate.
                 .filter(i -> i == sumOfDigitFactorial(i))
                 .sum().intValue();
     }

File: vavr/src/test/java/io/vavr/collection/euler/Euler38Test.java
Patch:
@@ -57,10 +57,10 @@ public void shouldSolveProblem38() {
         assertThat(isPandigitalMultiple(CharSeq.of("192384576"))).isTrue();
         assertThat(isPandigitalMultiple(CharSeq.of("918273645"))).isTrue();
 
-        assertThat(largets1To9PandigitalMultiple().mkString()).isEqualTo("932718654");
+        assertThat(largest1To9PandigitalMultiple().mkString()).isEqualTo("932718654");
     }
 
-    private static CharSeq largets1To9PandigitalMultiple() {
+    private static CharSeq largest1To9PandigitalMultiple() {
         return CharSeq.of("87654321")
                 .permutations()
                 .map(CharSeq::mkString)

File: vavr/src/main/java/io/vavr/concurrent/Future.java
Patch:
@@ -643,7 +643,7 @@ static <T, U> Future<Seq<U>> traverse(ExecutorService executorService, Iterable<
         Objects.requireNonNull(executorService, "executorService is null");
         Objects.requireNonNull(values, "values is null");
         Objects.requireNonNull(mapper, "mapper is null");
-        return sequence(Iterator.ofAll(values).map(mapper));
+        return sequence(executorService, Iterator.ofAll(values).map(mapper));
     }
 
     // -- non-static Future API

File: vavr/src/main/java/io/vavr/concurrent/Future.java
Patch:
@@ -694,6 +694,8 @@ default Future<T> andThen(Consumer<? super Try<T>> action) {
      * <p>
      * If the deadline wasn't met, a failed {@code Future} is returned containing a {@link TimeoutException}.
      *
+     * @param timeout the maximum time to wait
+     * @param unit the time unit of the timeout argument
      * @return this {@code Future} instance
      * @throws IllegalArgumentException if {@code timeout} is negative
      * @throws NullPointerException if {@code unit} is null

File: vavr/src/main/java/io/vavr/Lazy.java
Patch:
@@ -112,9 +112,10 @@ public static <T> Lazy<T> of(Supplier<? extends T> supplier) {
      * @return A lazy sequence of values.
      * @throws NullPointerException if values is null
      */
+    @SuppressWarnings("Convert2MethodRef") // TODO should be fixed in JDK 9 and Idea
     public static <T> Lazy<Seq<T>> sequence(Iterable<? extends Lazy<? extends T>> values) {
         Objects.requireNonNull(values, "values is null");
-        return Lazy.of(() -> Vector.ofAll(values).map(Lazy::get));
+        return Lazy.of(() -> Vector.ofAll(values).map(lazy -> lazy.get()));
     }
 
     /**

File: vavr/src/test/java/io/vavr/AssertionsExtensions.java
Patch:
@@ -40,10 +40,10 @@ public static class ClassAssert {
             this.clazz = clazz;
         }
 
+        @SuppressWarnings("deprecation")
         public void isNotInstantiable() {
-            final Constructor<?> cons;
             try {
-                cons = clazz.getDeclaredConstructor();
+                final Constructor<?> cons = clazz.getDeclaredConstructor();
                 Assertions.assertThat(cons.isAccessible()).isFalse();
             } catch (NoSuchMethodException e) {
                 throw new AssertionError("no default constructor found");

File: vavr/src/main/java/io/vavr/Value.java
Patch:
@@ -38,7 +38,6 @@
 import io.vavr.collection.TreeMap;
 import io.vavr.collection.TreeSet;
 import io.vavr.collection.Vector;
-import io.vavr.concurrent.Future;
 import io.vavr.control.Either;
 import io.vavr.control.Option;
 import io.vavr.control.Try;
@@ -1353,8 +1352,6 @@ default Stream<T> toStream() {
     default Try<T> toTry() {
         if (this instanceof Try) {
             return (Try<T>) this;
-        } else if (this instanceof Future) {
-            return ((Future<T>) this).await().getValue().get();
         } else {
             return Try.of(this::get);
         }

File: vavr/src-gen/main/java/io/vavr/Function0.java
Patch:
@@ -121,14 +121,14 @@ static <R> Function0<Try<R>> liftTry(Supplier<? extends R> partialFunction) {
     }
 
     /**
-     * Narrows the given {@code Supplier<? extends R>} to {@code Function0<R>}
+     * Narrows the given {@code Function0<? extends R>} to {@code Function0<R>}
      *
      * @param f A {@code Function0}
      * @param <R> return type
      * @return the given {@code f} instance as narrowed type {@code Function0<R>}
      */
     @SuppressWarnings("unchecked")
-    static <R> Function0<R> narrow(Supplier<? extends R> f) {
+    static <R> Function0<R> narrow(Function0<? extends R> f) {
         return (Function0<R>) f;
     }
 

File: vavr/src-gen/main/java/io/vavr/Function1.java
Patch:
@@ -127,15 +127,15 @@ static <T1, R> Function1<T1, Try<R>> liftTry(Function<? super T1, ? extends R> p
     }
 
     /**
-     * Narrows the given {@code Function<? super T1, ? extends R>} to {@code Function1<T1, R>}
+     * Narrows the given {@code Function1<? super T1, ? extends R>} to {@code Function1<T1, R>}
      *
      * @param f A {@code Function1}
      * @param <R> return type
      * @param <T1> 1st argument
      * @return the given {@code f} instance as narrowed type {@code Function1<T1, R>}
      */
     @SuppressWarnings("unchecked")
-    static <T1, R> Function1<T1, R> narrow(Function<? super T1, ? extends R> f) {
+    static <T1, R> Function1<T1, R> narrow(Function1<? super T1, ? extends R> f) {
         return (Function1<T1, R>) f;
     }
 

File: vavr/src-gen/main/java/io/vavr/Function2.java
Patch:
@@ -132,7 +132,7 @@ static <T1, T2, R> Function2<T1, T2, Try<R>> liftTry(BiFunction<? super T1, ? su
     }
 
     /**
-     * Narrows the given {@code BiFunction<? super T1, ? super T2, ? extends R>} to {@code Function2<T1, T2, R>}
+     * Narrows the given {@code Function2<? super T1, ? super T2, ? extends R>} to {@code Function2<T1, T2, R>}
      *
      * @param f A {@code Function2}
      * @param <R> return type
@@ -141,7 +141,7 @@ static <T1, T2, R> Function2<T1, T2, Try<R>> liftTry(BiFunction<? super T1, ? su
      * @return the given {@code f} instance as narrowed type {@code Function2<T1, T2, R>}
      */
     @SuppressWarnings("unchecked")
-    static <T1, T2, R> Function2<T1, T2, R> narrow(BiFunction<? super T1, ? super T2, ? extends R> f) {
+    static <T1, T2, R> Function2<T1, T2, R> narrow(Function2<? super T1, ? super T2, ? extends R> f) {
         return (Function2<T1, T2, R>) f;
     }
 

File: vavr/src/main/java/io/vavr/Value.java
Patch:
@@ -878,7 +878,7 @@ default Optional<T> toJavaOptional() {
 
     /**
      * Converts this to a mutable {@link java.util.Set}.
-     * Elements are added by calling {@link java.util.Set#add(Object}.
+     * Elements are added by calling {@link java.util.Set#add(Object)}.
      *
      * <pre>{@code
      * // = []
@@ -902,7 +902,7 @@ default java.util.Set<T> toJavaSet() {
 
     /**
      * Converts this to a specific {@link java.util.Set}.
-     * Elements are added by calling {@link java.util.Set#add(Object}.
+     * Elements are added by calling {@link java.util.Set#add(Object)}.
      *
      * <pre>{@code
      * // = []

File: vavr/src/main/java/io/vavr/Predicates.java
Patch:
@@ -248,7 +248,7 @@ public static <T> Predicate<T> noneOf(Predicate<T>... predicates) {
      * @param predicate A {@code Predicate} that tests elements of type {@code T}
      * @param <T>       tested object type
      * @return A new {@code Predicate}
-     * @throws NullPointerException if {@code values} is predicate
+     * @throws NullPointerException if {@code predicate} is null
      */
     @SuppressWarnings("unchecked")
     public static <T> Predicate<T> not(Predicate<? super T> predicate) {

File: vavr/src/main/java/io/vavr/collection/HashMultimap.java
Patch:
@@ -37,7 +37,7 @@ public static <V> Builder<V> withSet() {
         return new Builder<>(ContainerType.SET, HashSet::empty);
     }
 
-    public static <V extends Comparable<? super V>> Builder<V> withSortedSet() {
+    public static <V extends Comparable<?>> Builder<V> withSortedSet() {
         return new Builder<>(ContainerType.SORTED_SET, TreeSet::empty);
     }
 

File: vavr/src/main/java/io/vavr/collection/LinkedHashMultimap.java
Patch:
@@ -37,7 +37,7 @@ public static <V> Builder<V> withSet() {
         return new Builder<>(ContainerType.SET, HashSet::empty);
     }
 
-    public static <V extends Comparable<? super V>> Builder<V> withSortedSet() {
+    public static <V extends Comparable<?>> Builder<V> withSortedSet() {
         return new Builder<>(ContainerType.SORTED_SET, TreeSet::empty);
     }
 

File: vavr/src/main/java/io/vavr/collection/TreeMultimap.java
Patch:
@@ -38,7 +38,7 @@ public static <V> Builder<V> withSet() {
         return new Builder<>(ContainerType.SET, HashSet::empty);
     }
 
-    public static <V extends Comparable<? super V>> Builder<V> withSortedSet() {
+    public static <V extends Comparable<?>> Builder<V> withSortedSet() {
         return new Builder<>(ContainerType.SORTED_SET, TreeSet::empty);
     }
 

File: vavr/src/main/java/io/vavr/collection/Map.java
Patch:
@@ -80,7 +80,7 @@
  * @param <V> Value type
  * @author Daniel Dietrich, Ruslan Sennov
  */
-public interface Map<K, V> extends Traversable<Tuple2<K, V>>, Function1<K, V>, PartialFunction<K, V>, Serializable {
+public interface Map<K, V> extends Traversable<Tuple2<K, V>>, PartialFunction<K, V>, Serializable {
 
     long serialVersionUID = 1L;
 

File: vavr/src/main/java/io/vavr/collection/Multimap.java
Patch:
@@ -74,7 +74,7 @@
  * @param <V> Value type
  * @author Ruslan Sennov
  */
-public interface Multimap<K, V> extends Traversable<Tuple2<K, V>>, Function1<K, Traversable<V>>, PartialFunction<K, Traversable<V>>, Serializable {
+public interface Multimap<K, V> extends Traversable<Tuple2<K, V>>, PartialFunction<K, Traversable<V>>, Serializable {
 
     long serialVersionUID = 1L;
 

File: vavr/src/main/java/io/vavr/collection/Seq.java
Patch:
@@ -93,7 +93,7 @@
  * @param <T> Component type
  * @author Daniel Dietrich
  */
-public interface Seq<T> extends Traversable<T>, Function1<Integer, T>, Serializable {
+public interface Seq<T> extends Traversable<T>, PartialFunction<Integer, T>, Serializable {
 
     long serialVersionUID = 1L;
 

File: vavr/src/test/java/io/vavr/collection/IntMap.java
Patch:
@@ -81,6 +81,7 @@ public String toString() {
     public <R> Seq<R> collect(PartialFunction<? super T, ? extends R> partialFunction) {
         Objects.requireNonNull(partialFunction, "partialFunction is null");
         final PartialFunction<Tuple2<Integer, T>, R> pf = new PartialFunction<Tuple2<Integer, T>, R>() {
+            private static final long serialVersionUID = 1L;
             @Override
             public R apply(Tuple2<Integer, T> entry) {
                 return partialFunction.apply(entry._2);

File: vavr/src/test/java/io/vavr/collection/IntMultimap.java
Patch:
@@ -82,6 +82,7 @@ public String toString() {
     public <R> Seq<R> collect(PartialFunction<? super T, ? extends R> partialFunction) {
         Objects.requireNonNull(partialFunction, "partialFunction is null");
         final PartialFunction<Tuple2<Integer, T>, R> pf = new PartialFunction<Tuple2<Integer, T>, R>() {
+            private static final long serialVersionUID = 1L;
             @Override
             public R apply(Tuple2<Integer, T> entry) {
                 return partialFunction.apply(entry._2);

File: vavr/src/main/java/io/vavr/Predicates.java
Patch:
@@ -33,6 +33,7 @@ private Predicates() {
      * @throws NullPointerException if {@code type} is null
      */
     // DEV-NOTE: We need Class<? extends T> instead of Class<T>, see {@link TryTest#shouldRecoverSuccessUsingCase()}
+    @GwtIncompatible
     public static <T> Predicate<T> instanceOf(Class<? extends T> type) {
         Objects.requireNonNull(type, "type is null");
         return obj -> obj != null && type.isAssignableFrom(obj.getClass());

File: vavr/src/main/java/io/vavr/collection/Collections.java
Patch:
@@ -34,6 +34,7 @@ static boolean areEqual(Iterable<?> iterable1, Iterable<?> iterable2) {
         return iter1.hasNext() == iter2.hasNext();
     }
 
+    @GwtIncompatible
     static <T, C extends Seq<T>> C asJava(C source, Consumer<? super java.util.List<T>> action, ChangePolicy changePolicy) {
         Objects.requireNonNull(action, "action is null");
         final ListView<T, C> view = JavaConverters.asJava(source, changePolicy);

File: vavr/src/main/java/io/vavr/collection/IndexedSeq.java
Patch:
@@ -50,9 +50,11 @@ static <T> IndexedSeq<T> narrow(IndexedSeq<? extends T> indexedSeq) {
     @Override
     IndexedSeq<T> appendAll(Iterable<? extends T> elements);
 
+    @GwtIncompatible
     @Override
     IndexedSeq<T> asJava(Consumer<? super java.util.List<T>> action);
 
+    @GwtIncompatible
     @Override
     IndexedSeq<T> asJavaMutable(Consumer<? super java.util.List<T>> action);
 

File: vavr/src/main/java/io/vavr/collection/JavaConverters.java
Patch:
@@ -24,6 +24,7 @@ class JavaConverters {
     private JavaConverters() {
     }
 
+    @GwtIncompatible
     static <T, C extends Seq<T>> ListView<T, C> asJava(C seq, ChangePolicy changePolicy) {
         return new ListView<>(seq, changePolicy.isMutable());
     }
@@ -87,6 +88,7 @@ protected void ensureMutable() {
         }
     }
 
+    @GwtIncompatible("reflection is not supported")
     static class ListView<T, C extends Seq<T>> extends HasDelegate<C> implements java.util.List<T> {
 
         private static final long serialVersionUID = 1L;
@@ -242,7 +244,6 @@ public Object[] toArray() {
             return getDelegate().toJavaArray();
         }
 
-        @GwtIncompatible("reflection is not supported")
         @SuppressWarnings("unchecked")
         @Override
         public <U> U[] toArray(U[] array) {

File: vavr/src/main/java/io/vavr/collection/LinearSeq.java
Patch:
@@ -49,9 +49,11 @@ static <T> LinearSeq<T> narrow(LinearSeq<? extends T> linearSeq) {
     @Override
     LinearSeq<T> appendAll(Iterable<? extends T> elements);
 
+    @GwtIncompatible
     @Override
     LinearSeq<T> asJava(Consumer<? super java.util.List<T>> action);
 
+    @GwtIncompatible
     @Override
     LinearSeq<T> asJavaMutable(Consumer<? super java.util.List<T>> action);
 

File: vavr-benchmark/src/test/java/io/vavr/BenchmarkPerformanceReporter.java
Patch:
@@ -36,7 +36,7 @@ public class BenchmarkPerformanceReporter {
     private final double outlierHighPct;
 
     public static BenchmarkPerformanceReporter of(Array<String> includeNames, Array<String> benchmarkClasses, Array<RunResult> runResults) {
-        return of(includeNames, benchmarkClasses, runResults, "slang", 0.3, 0.05);
+        return of(includeNames, benchmarkClasses, runResults, "vavr", 0.3, 0.05);
     }
 
     public static BenchmarkPerformanceReporter of(Array<String> includeNames, Array<String> benchmarkClasses, Array<RunResult> runResults, String targetImplementation, double outlierLowPct, double outlierHighPct) {
@@ -50,7 +50,7 @@ public static BenchmarkPerformanceReporter of(Array<String> includeNames, Array<
      * @param benchmarkClasses     The benchmarked source class names
      * @param runResults           The results
      * @param targetImplementation The target implementation we want to focus on in the Ratio report.
-     *                             It is case insensitive. If we enter "slang", it will match "JavaSlang" and "java_slang".
+     *                             It is case insensitive. If we enter "vavr", it will match "VaVr" and "va_vr".
      * @param outlierLowPct        The percentage of samples on the lower end that will be ignored from the statistics
      * @param outlierHighPct       The percentage of samples on the higher end that will be ignored from the statistics
      */
@@ -78,7 +78,7 @@ public void print() {
      * <ul>
      * <li>Group</li>
      * <li>Test Name</li>
-     * <li>Implementation - tests can have different implementations, e.g. Scala, Java, JavaSlang</li>
+     * <li>Implementation - tests can have different implementations, e.g. Scala, Java, Vavr</li>
      * <li>Parameters</li>
      * <li>Score</li>
      * <li>Error - 99% confidence interval expressed in % of the Score</li>

File: vavr-benchmark/src/test/java/io/vavr/JmhRunner.java
Patch:
@@ -61,7 +61,7 @@ public enum Includes {
         CLOJURE("clojure"),
         SCALAZ("scalaz"),
         SCALA("scala"),
-        JAVASLANG("slang");
+        VAVR("vavr");
 
         private final String name;
 

File: vavr-benchmark/src/test/java/io/vavr/collection/IteratorBenchmark.java
Patch:
@@ -28,7 +28,7 @@ public class IteratorBenchmark {
 
     public static void main(String... args) {
         JmhRunner.runDebugWithAsserts(CLASSES);
-        JmhRunner.runNormalNoAsserts(CLASSES, JAVA, SCALA, JAVASLANG);
+        JmhRunner.runNormalNoAsserts(CLASSES, JAVA, SCALA, VAVR);
     }
 
     @State(Scope.Benchmark)

File: vavr-benchmark/src/test/java/io/vavr/collection/VectorBenchmark.java
Patch:
@@ -55,7 +55,7 @@ public class VectorBenchmark {
 
     public static void main(String... args) {
         JmhRunner.runDebugWithAsserts(CLASSES);
-        JmhRunner.runNormalNoAsserts(CLASSES, JAVA, FUNCTIONAL_JAVA, PCOLLECTIONS, ECOLLECTIONS, CLOJURE, SCALA, JAVASLANG);
+        JmhRunner.runNormalNoAsserts(CLASSES, JAVA, FUNCTIONAL_JAVA, PCOLLECTIONS, ECOLLECTIONS, CLOJURE, SCALA, VAVR);
     }
 
     @State(Scope.Benchmark)

File: vavr-benchmark/src/test/java/io/vavr/control/LazyBenchmark.java
Patch:
@@ -16,7 +16,7 @@
 
 import static io.vavr.API.Array;
 import static io.vavr.JmhRunner.Includes.JAVA;
-import static io.vavr.JmhRunner.Includes.JAVASLANG;
+import static io.vavr.JmhRunner.Includes.VAVR;
 
 public class LazyBenchmark {
     static final Array<Class<?>> CLASSES = Array(
@@ -27,8 +27,8 @@ public class LazyBenchmark {
     public void testAsserts() { JmhRunner.runDebugWithAsserts(CLASSES); }
 
     public static void main(String... args) {
-        JmhRunner.runDebugWithAsserts(CLASSES, JAVA, JAVASLANG);
-        JmhRunner.runSlowNoAsserts(CLASSES, JAVA, JAVASLANG);
+        JmhRunner.runDebugWithAsserts(CLASSES, JAVA, VAVR);
+        JmhRunner.runSlowNoAsserts(CLASSES, JAVA, VAVR);
     }
 
     @State(Scope.Benchmark)

File: vavr/src/main/java/io/vavr/collection/Seq.java
Patch:
@@ -149,7 +149,7 @@ default T apply(Integer index) {
      *
      * <ul>
      * <li>A view is created in O(1) (constant time) whereas conversion takes O(n) (linear time), with n = collection size.</li>
-     * <li>The operations on a view have the same performance characteristics than the underlying persistent Javaslang collection whereas the performance characteristics of a converted collection are those of the Java standard collections.</li>
+     * <li>The operations on a view have the same performance characteristics than the underlying persistent Vavr collection whereas the performance characteristics of a converted collection are those of the Java standard collections.</li>
      * </ul>
      *
      * Please note that our immutable {@code java.util.List} view throws {@code UnsupportedOperationException} before

File: vavr/src/test/java/io/vavr/PredicatesTest.java
Patch:
@@ -152,7 +152,7 @@ public void shouldCheckExistsByLiftingPredicateInContravariantPositionToPredicat
         final List<Integer> list = List(1, 2, 3);
         final Predicate<Number> p = n -> n.intValue() % 2 == 0;
         final boolean actual = Match(list).of(
-                Case(exists(p), true),
+                Case($(exists(p)), true),
                 Case($(), false)
         );
         assertThat(actual).isTrue();
@@ -175,7 +175,7 @@ public void shouldCheckForAllByLiftingPredicateInContravariantPositionToPredicat
         final List<Integer> list = List(1, 2, 3);
         final Predicate<Number> p = n -> n.intValue() > 0;
         final boolean actual = Match(list).of(
-                Case(forAll(p), true),
+                Case($(forAll(p)), true),
                 Case($(), false)
         );
         assertThat(actual).isTrue();

File: vavr/src/test/java/io/vavr/collection/euler/Utils.java
Patch:
@@ -50,9 +50,9 @@ static Stream<Long> divisors(long l) {
 
     static boolean isPrime(long val) {
         return API.Match(val).of(
-                API.Case(API.$(n -> n < 2L), false),
-                API.Case(API.$(2L), true),
-                API.Case(API.$(), n -> {
+                API.Case($(n -> n < 2L), false),
+                API.Case($(2L), true),
+                API.Case($(), n -> {
                     final double upperLimitToCheck = Math.sqrt(n);
                     return !PrimeNumbers.primes().takeWhile(d -> d <= upperLimitToCheck).exists(d -> n % d == 0);
                 })

File: vavr/src/test/java/io/vavr/control/TryTest.java
Patch:
@@ -1067,7 +1067,7 @@ public void shouldChainFailureWithMap() {
     public void shouldMapFailureWhenSuccess() {
         final Try<Integer> testee = Success(1);
         final Try<Integer> actual = testee.mapFailure(
-                Case(instanceOf(RuntimeException.class), (Function<RuntimeException, Error>) Error::new)
+                Case($(instanceOf(RuntimeException.class)), (Function<RuntimeException, Error>) Error::new)
         );
         assertThat(actual).isSameAs(testee);
     }
@@ -1077,7 +1077,7 @@ public void shouldMapFailureWhenSuccess() {
     public void shouldMapFailureWhenFailureAndMatches() {
         final Try<Integer> testee = Failure(new IOException());
         final Try<Integer> actual = testee.mapFailure(
-                Case(instanceOf(IOException.class), (Function<IOException, Error>) Error::new)
+                Case($(instanceOf(IOException.class)), (Function<IOException, Error>) Error::new)
         );
         assertThat(actual.getCause()).isInstanceOf(Error.class);
     }
@@ -1087,7 +1087,7 @@ public void shouldMapFailureWhenFailureAndMatches() {
     public void shouldMapFailureWhenFailureButDoesNotMatch() {
         final Try<Integer> testee = Failure(new IOException());
         final Try<Integer> actual = testee.mapFailure(
-                Case(instanceOf(RuntimeException.class), (Function<RuntimeException, Error>) Error::new)
+                Case($(instanceOf(RuntimeException.class)), (Function<RuntimeException, Error>) Error::new)
         );
         assertThat(actual).isSameAs(testee);
     }

File: vavr/src/main/java/io/vavr/Value.java
Patch:
@@ -44,7 +44,7 @@
  * <li>{@link #getOrElse(Object)}</li>
  * <li>{@link #getOrElse(Supplier)}</li>
  * <li>{@link #getOrElseThrow(Supplier)}</li>
- * <li>{@link #getOrElseTry(Try.CheckedSupplier)}</li>
+ * <li>{@link #getOrElseTry(CheckedFunction0)}</li>
  * <li>{@link #getOrNull()}</li>
  * <li>{@link #map(Function)}</li>
  * <li>{@link #stringPrefix()}</li>
@@ -382,7 +382,7 @@ default <X extends Throwable> T getOrElseThrow(Supplier<X> supplier) throws X {
      * @throws NullPointerException  if supplier is null
      * @throws Try.NonFatalException containing the original exception if this Value was empty and the Try failed.
      */
-    default T getOrElseTry(Try.CheckedSupplier<? extends T> supplier) {
+    default T getOrElseTry(CheckedFunction0<? extends T> supplier) {
         Objects.requireNonNull(supplier, "supplier is null");
         return isEmpty() ? Try.of(supplier).get() : get();
     }

File: vavr/src/test/java/io/vavr/concurrent/Concurrent.java
Patch:
@@ -6,6 +6,7 @@
  */
 package io.vavr.concurrent;
 
+import io.vavr.CheckedFunction0;
 import io.vavr.control.Try;
 
 import java.util.Random;
@@ -51,14 +52,14 @@ static void zZz() {
         Try.run(() -> Thread.sleep(RND.nextInt(SLEEP_MAX_MILLIS)));
     }
 
-    static <T> Try.CheckedSupplier<T> zZz(T value) {
+    static <T> CheckedFunction0<T> zZz(T value) {
         return () -> {
             zZz();
             return value;
         };
     }
 
-    static <T, X extends Throwable> Try.CheckedSupplier<T> zZz(X exception) {
+    static <T, X extends Throwable> CheckedFunction0<T> zZz(X exception) {
         return () -> {
             zZz();
             throw exception;

File: vavr-match/src/main/java/io/vavr/match/PatternsProcessor.java
Patch:
@@ -40,7 +40,6 @@
  * See <a href="https://bugs.openjdk.java.net/browse/JDK-6999068">JDK-6999068 bug</a>.
  *
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 // See Difference between Element, Type and Mirror: http://stackoverflow.com/a/2127320/1110815
 public class PatternsProcessor extends AbstractProcessor {

File: vavr-match/src/main/java/io/vavr/match/UnapplyChecker.java
Patch:
@@ -21,7 +21,6 @@
  * Checks if an {@link javax.lang.model.element.ExecutableElement} is a valid {@code @Unapply} method.
  *
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 class UnapplyChecker {
 

File: vavr-match/src/main/java/io/vavr/match/annotation/Patterns.java
Patch:
@@ -15,7 +15,6 @@
  * Structural pattern matching annotation for pattern declarations.
  *
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.CLASS)

File: vavr-match/src/main/java/io/vavr/match/annotation/Unapply.java
Patch:
@@ -15,7 +15,6 @@
  * Structural pattern matching annotation for unapply methods.
  *
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 @Target(ElementType.METHOD)
 @Retention(RetentionPolicy.CLASS)

File: vavr-match/src/main/java/io/vavr/match/generator/Generator.java
Patch:
@@ -24,7 +24,6 @@
  * Code generator for structural pattern matching patterns.
  *
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 public class Generator {
 

File: vavr-match/src/main/java/io/vavr/match/generator/ImportManager.java
Patch:
@@ -16,7 +16,6 @@
  * A <em>stateful</em> ImportManager which generates an import section of a Java class file.
  *
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 class ImportManager {
 

File: vavr-match/src/main/java/io/vavr/match/model/ClassModel.java
Patch:
@@ -18,7 +18,6 @@
  * Representation of a class.
  *
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 public class ClassModel {
 

File: vavr-match/src/main/java/io/vavr/match/model/MethodModel.java
Patch:
@@ -19,7 +19,6 @@
  * Representation of a method.
  *
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 public class MethodModel {
 

File: vavr-match/src/main/java/io/vavr/match/model/ParameterModel.java
Patch:
@@ -14,7 +14,6 @@
  * Representation of a method parameter.
  *
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 public class ParameterModel {
 

File: vavr-match/src/main/java/io/vavr/match/model/TypeParameterModel.java
Patch:
@@ -18,7 +18,6 @@
  * Representation of a generic type parameter.
  *
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 public class TypeParameterModel {
 

File: vavr-test/src/main/java/io/vavr/test/Arbitrary.java
Patch:
@@ -23,7 +23,6 @@
  *
  * @param <T> The type of the arbitrary object.
  * @author Daniel Dietrich
- * @since 1.2.0
  */
 @FunctionalInterface
 public interface Arbitrary<T> {

File: vavr-test/src/main/java/io/vavr/test/Checkable.java
Patch:
@@ -14,7 +14,6 @@
  * Interface for checkable properties, allowing composition via {@linkplain #and(Checkable)} and {@linkplain #or(Checkable)}.
  *
  * @author Daniel Dietrich
- * @since 1.2.0
  */
 @FunctionalInterface
 public interface Checkable {

File: vavr-test/src/main/java/io/vavr/test/Gen.java
Patch:
@@ -34,7 +34,6 @@
  * @param <T> type of generated objects
  * @author Daniel Dietrich
  * @see Arbitrary
- * @since 1.2.0
  */
 @FunctionalInterface
 public interface Gen<T> {

File: vavr-test/src/main/java/io/vavr/test/package-info.java
Patch:
@@ -1,6 +1,4 @@
 /**
  * A property check framework built around {@linkplain io.vavr.test.Property} which integrates well with unit test frameworks like junit.
- *
- * @since 1.2.0
  */
 package io.vavr.test;

File: vavr/src-gen/main/java/io/vavr/API.java
Patch:
@@ -86,7 +86,6 @@
  * As with all Vavr Values, the result of a For-comprehension can be converted
  * to standard Java library and Vavr types.
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 public final class API {
 

File: vavr/src-gen/main/java/io/vavr/CheckedFunction0.java
Patch:
@@ -21,7 +21,6 @@
  *
  * @param <R> return type of the function
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 @FunctionalInterface

File: vavr/src-gen/main/java/io/vavr/CheckedFunction1.java
Patch:
@@ -23,7 +23,6 @@
  * @param <T1> argument 1 of the function
  * @param <R> return type of the function
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 @FunctionalInterface

File: vavr/src-gen/main/java/io/vavr/CheckedFunction2.java
Patch:
@@ -25,7 +25,6 @@
  * @param <T2> argument 2 of the function
  * @param <R> return type of the function
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 @FunctionalInterface

File: vavr/src-gen/main/java/io/vavr/CheckedFunction3.java
Patch:
@@ -25,7 +25,6 @@
  * @param <T3> argument 3 of the function
  * @param <R> return type of the function
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 @FunctionalInterface

File: vavr/src-gen/main/java/io/vavr/CheckedFunction4.java
Patch:
@@ -26,7 +26,6 @@
  * @param <T4> argument 4 of the function
  * @param <R> return type of the function
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 @FunctionalInterface

File: vavr/src-gen/main/java/io/vavr/CheckedFunction5.java
Patch:
@@ -27,7 +27,6 @@
  * @param <T5> argument 5 of the function
  * @param <R> return type of the function
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 @FunctionalInterface

File: vavr/src-gen/main/java/io/vavr/CheckedFunction6.java
Patch:
@@ -28,7 +28,6 @@
  * @param <T6> argument 6 of the function
  * @param <R> return type of the function
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 @FunctionalInterface

File: vavr/src-gen/main/java/io/vavr/CheckedFunction7.java
Patch:
@@ -29,7 +29,6 @@
  * @param <T7> argument 7 of the function
  * @param <R> return type of the function
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 @FunctionalInterface

File: vavr/src-gen/main/java/io/vavr/CheckedFunction8.java
Patch:
@@ -30,7 +30,6 @@
  * @param <T8> argument 8 of the function
  * @param <R> return type of the function
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 @FunctionalInterface

File: vavr/src-gen/main/java/io/vavr/Function0.java
Patch:
@@ -21,7 +21,6 @@
  *
  * @param <R> return type of the function
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 @FunctionalInterface

File: vavr/src-gen/main/java/io/vavr/Function1.java
Patch:
@@ -24,7 +24,6 @@
  * @param <T1> argument 1 of the function
  * @param <R> return type of the function
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 @FunctionalInterface

File: vavr/src-gen/main/java/io/vavr/Function2.java
Patch:
@@ -25,7 +25,6 @@
  * @param <T2> argument 2 of the function
  * @param <R> return type of the function
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 @FunctionalInterface

File: vavr/src-gen/main/java/io/vavr/Function3.java
Patch:
@@ -25,7 +25,6 @@
  * @param <T3> argument 3 of the function
  * @param <R> return type of the function
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 @FunctionalInterface

File: vavr/src-gen/main/java/io/vavr/Function4.java
Patch:
@@ -26,7 +26,6 @@
  * @param <T4> argument 4 of the function
  * @param <R> return type of the function
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 @FunctionalInterface

File: vavr/src-gen/main/java/io/vavr/Function5.java
Patch:
@@ -27,7 +27,6 @@
  * @param <T5> argument 5 of the function
  * @param <R> return type of the function
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 @FunctionalInterface

File: vavr/src-gen/main/java/io/vavr/Function6.java
Patch:
@@ -28,7 +28,6 @@
  * @param <T6> argument 6 of the function
  * @param <R> return type of the function
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 @FunctionalInterface

File: vavr/src-gen/main/java/io/vavr/Function7.java
Patch:
@@ -29,7 +29,6 @@
  * @param <T7> argument 7 of the function
  * @param <R> return type of the function
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 @FunctionalInterface

File: vavr/src-gen/main/java/io/vavr/Function8.java
Patch:
@@ -30,7 +30,6 @@
  * @param <T8> argument 8 of the function
  * @param <R> return type of the function
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 @FunctionalInterface

File: vavr/src-gen/main/java/io/vavr/Tuple.java
Patch:
@@ -19,7 +19,6 @@
  * The base interface of all tuples.
  *
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 public interface Tuple {
 

File: vavr/src-gen/main/java/io/vavr/Tuple0.java
Patch:
@@ -22,7 +22,6 @@
  * A tuple of no elements which can be seen as cartesian product of no components.
  *
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 public final class Tuple0 implements Tuple, Comparable<Tuple0>, Serializable {
 
@@ -81,13 +80,13 @@ public <U> U apply(Supplier<? extends U> f) {
     /**
      * Transforms this tuple to an object of type U.
      *
-     * @deprecated Use {@link #apply(Supplier)} instead, will be removed in 3.0.0
+     * @deprecated Use {@link #apply(Supplier)} instead, will be removed in 0.9.0
      * @param f Transformation which creates a new object of type U based on this tuple's contents.
      * @param <U> type of the transformation result
      * @return An object of type U
      * @throws NullPointerException if {@code f} is null
      */
-    @Deprecated(/* Use apply instead, will be removed in 3.0.0 */)
+    @Deprecated(/* Use apply instead, will be removed in 0.9.0 */)
     public <U> U transform(Supplier<? extends U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.get();

File: vavr/src-gen/main/java/io/vavr/Tuple1.java
Patch:
@@ -23,7 +23,6 @@
  *
  * @param <T1> type of the 1st element
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 public final class Tuple1<T1> implements Tuple, Comparable<Tuple1<T1>>, Serializable {
 
@@ -127,13 +126,13 @@ public <U> U apply(Function<? super T1, ? extends U> f) {
     /**
      * Transforms this tuple to an object of type U.
      *
-     * @deprecated Use {@link #apply(Function)} instead, will be removed in 3.0.0
+     * @deprecated Use {@link #apply(Function)} instead, will be removed in 0.9.0
      * @param f Transformation which creates a new object of type U based on this tuple's contents.
      * @param <U> type of the transformation result
      * @return An object of type U
      * @throws NullPointerException if {@code f} is null
      */
-    @Deprecated(/* Use apply instead, will be removed in 3.0.0 */)
+    @Deprecated(/* Use apply instead, will be removed in 0.9.0 */)
     public <U> U transform(Function<? super T1, ? extends U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(_1);

File: vavr/src-gen/main/java/io/vavr/Tuple2.java
Patch:
@@ -27,7 +27,6 @@
  * @param <T1> type of the 1st element
  * @param <T2> type of the 2nd element
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 public final class Tuple2<T1, T2> implements Tuple, Comparable<Tuple2<T1, T2>>, Serializable {
 
@@ -230,13 +229,13 @@ public <U> U apply(BiFunction<? super T1, ? super T2, ? extends U> f) {
     /**
      * Transforms this tuple to an object of type U.
      *
-     * @deprecated Use {@link #apply(BiFunction)} instead, will be removed in 3.0.0
+     * @deprecated Use {@link #apply(BiFunction)} instead, will be removed in 0.9.0
      * @param f Transformation which creates a new object of type U based on this tuple's contents.
      * @param <U> type of the transformation result
      * @return An object of type U
      * @throws NullPointerException if {@code f} is null
      */
-    @Deprecated(/* Use apply instead, will be removed in 3.0.0 */)
+    @Deprecated(/* Use apply instead, will be removed in 0.9.0 */)
     public <U> U transform(BiFunction<? super T1, ? super T2, ? extends U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(_1, _2);

File: vavr/src-gen/main/java/io/vavr/Tuple3.java
Patch:
@@ -25,7 +25,6 @@
  * @param <T2> type of the 2nd element
  * @param <T3> type of the 3rd element
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 public final class Tuple3<T1, T2, T3> implements Tuple, Comparable<Tuple3<T1, T2, T3>>, Serializable {
 
@@ -261,13 +260,13 @@ public <U> U apply(Function3<? super T1, ? super T2, ? super T3, ? extends U> f)
     /**
      * Transforms this tuple to an object of type U.
      *
-     * @deprecated Use {@link #apply(Function3)} instead, will be removed in 3.0.0
+     * @deprecated Use {@link #apply(Function3)} instead, will be removed in 0.9.0
      * @param f Transformation which creates a new object of type U based on this tuple's contents.
      * @param <U> type of the transformation result
      * @return An object of type U
      * @throws NullPointerException if {@code f} is null
      */
-    @Deprecated(/* Use apply instead, will be removed in 3.0.0 */)
+    @Deprecated(/* Use apply instead, will be removed in 0.9.0 */)
     public <U> U transform(Function3<? super T1, ? super T2, ? super T3, ? extends U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(_1, _2, _3);

File: vavr/src-gen/main/java/io/vavr/Tuple4.java
Patch:
@@ -26,7 +26,6 @@
  * @param <T3> type of the 3rd element
  * @param <T4> type of the 4th element
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 public final class Tuple4<T1, T2, T3, T4> implements Tuple, Comparable<Tuple4<T1, T2, T3, T4>>, Serializable {
 
@@ -315,13 +314,13 @@ public <U> U apply(Function4<? super T1, ? super T2, ? super T3, ? super T4, ? e
     /**
      * Transforms this tuple to an object of type U.
      *
-     * @deprecated Use {@link #apply(Function4)} instead, will be removed in 3.0.0
+     * @deprecated Use {@link #apply(Function4)} instead, will be removed in 0.9.0
      * @param f Transformation which creates a new object of type U based on this tuple's contents.
      * @param <U> type of the transformation result
      * @return An object of type U
      * @throws NullPointerException if {@code f} is null
      */
-    @Deprecated(/* Use apply instead, will be removed in 3.0.0 */)
+    @Deprecated(/* Use apply instead, will be removed in 0.9.0 */)
     public <U> U transform(Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(_1, _2, _3, _4);

File: vavr/src-gen/main/java/io/vavr/Tuple5.java
Patch:
@@ -27,7 +27,6 @@
  * @param <T4> type of the 4th element
  * @param <T5> type of the 5th element
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 public final class Tuple5<T1, T2, T3, T4, T5> implements Tuple, Comparable<Tuple5<T1, T2, T3, T4, T5>>, Serializable {
 
@@ -369,13 +368,13 @@ public <U> U apply(Function5<? super T1, ? super T2, ? super T3, ? super T4, ? s
     /**
      * Transforms this tuple to an object of type U.
      *
-     * @deprecated Use {@link #apply(Function5)} instead, will be removed in 3.0.0
+     * @deprecated Use {@link #apply(Function5)} instead, will be removed in 0.9.0
      * @param f Transformation which creates a new object of type U based on this tuple's contents.
      * @param <U> type of the transformation result
      * @return An object of type U
      * @throws NullPointerException if {@code f} is null
      */
-    @Deprecated(/* Use apply instead, will be removed in 3.0.0 */)
+    @Deprecated(/* Use apply instead, will be removed in 0.9.0 */)
     public <U> U transform(Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(_1, _2, _3, _4, _5);

File: vavr/src-gen/main/java/io/vavr/Tuple6.java
Patch:
@@ -28,7 +28,6 @@
  * @param <T5> type of the 5th element
  * @param <T6> type of the 6th element
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 public final class Tuple6<T1, T2, T3, T4, T5, T6> implements Tuple, Comparable<Tuple6<T1, T2, T3, T4, T5, T6>>, Serializable {
 
@@ -423,13 +422,13 @@ public <U> U apply(Function6<? super T1, ? super T2, ? super T3, ? super T4, ? s
     /**
      * Transforms this tuple to an object of type U.
      *
-     * @deprecated Use {@link #apply(Function6)} instead, will be removed in 3.0.0
+     * @deprecated Use {@link #apply(Function6)} instead, will be removed in 0.9.0
      * @param f Transformation which creates a new object of type U based on this tuple's contents.
      * @param <U> type of the transformation result
      * @return An object of type U
      * @throws NullPointerException if {@code f} is null
      */
-    @Deprecated(/* Use apply instead, will be removed in 3.0.0 */)
+    @Deprecated(/* Use apply instead, will be removed in 0.9.0 */)
     public <U> U transform(Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(_1, _2, _3, _4, _5, _6);

File: vavr/src-gen/main/java/io/vavr/Tuple7.java
Patch:
@@ -29,7 +29,6 @@
  * @param <T6> type of the 6th element
  * @param <T7> type of the 7th element
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 public final class Tuple7<T1, T2, T3, T4, T5, T6, T7> implements Tuple, Comparable<Tuple7<T1, T2, T3, T4, T5, T6, T7>>, Serializable {
 
@@ -477,13 +476,13 @@ public <U> U apply(Function7<? super T1, ? super T2, ? super T3, ? super T4, ? s
     /**
      * Transforms this tuple to an object of type U.
      *
-     * @deprecated Use {@link #apply(Function7)} instead, will be removed in 3.0.0
+     * @deprecated Use {@link #apply(Function7)} instead, will be removed in 0.9.0
      * @param f Transformation which creates a new object of type U based on this tuple's contents.
      * @param <U> type of the transformation result
      * @return An object of type U
      * @throws NullPointerException if {@code f} is null
      */
-    @Deprecated(/* Use apply instead, will be removed in 3.0.0 */)
+    @Deprecated(/* Use apply instead, will be removed in 0.9.0 */)
     public <U> U transform(Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(_1, _2, _3, _4, _5, _6, _7);

File: vavr/src-gen/main/java/io/vavr/Tuple8.java
Patch:
@@ -30,7 +30,6 @@
  * @param <T7> type of the 7th element
  * @param <T8> type of the 8th element
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 public final class Tuple8<T1, T2, T3, T4, T5, T6, T7, T8> implements Tuple, Comparable<Tuple8<T1, T2, T3, T4, T5, T6, T7, T8>>, Serializable {
 
@@ -531,13 +530,13 @@ public <U> U apply(Function8<? super T1, ? super T2, ? super T3, ? super T4, ? s
     /**
      * Transforms this tuple to an object of type U.
      *
-     * @deprecated Use {@link #apply(Function8)} instead, will be removed in 3.0.0
+     * @deprecated Use {@link #apply(Function8)} instead, will be removed in 0.9.0
      * @param f Transformation which creates a new object of type U based on this tuple's contents.
      * @param <U> type of the transformation result
      * @return An object of type U
      * @throws NullPointerException if {@code f} is null
      */
-    @Deprecated(/* Use apply instead, will be removed in 3.0.0 */)
+    @Deprecated(/* Use apply instead, will be removed in 0.9.0 */)
     public <U> U transform(Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(_1, _2, _3, _4, _5, _6, _7, _8);

File: vavr/src-gen/main/java/io/vavr/collection/ArrayType.java
Patch:
@@ -18,7 +18,6 @@
  * Helper to replace reflective array access.
  *
  * @author Pap Lrinc
- * @since 2.1.0
  */
 interface ArrayType<T> {
     @SuppressWarnings("unchecked")

File: vavr/src/main/java/io/vavr/$.java
Patch:
@@ -18,7 +18,7 @@
 
 /**
  * <strong>INTERNAL TYPE - turned to io.vavr.Patterns by vavr-match annotation processor.</strong>
- * @deprecated Will be removed in 3.0.0
+ * @deprecated Will be removed in 0.9.0
  */
 @Deprecated
 @Patterns

File: vavr/src/main/java/io/vavr/Lazy.java
Patch:
@@ -37,12 +37,11 @@
  * </code>
  * </pre>
  *
- * Since 2.0.0 you may also create a <em>real</em> lazy value (works only with interfaces):
+ * Example of creating a <em>real</em> lazy value (works only with interfaces):
  *
  * <pre><code>final CharSequence chars = Lazy.val(() -&gt; "Yay!", CharSequence.class);</code></pre>
  *
  * @author Daniel Dietrich
- * @since 1.2.1
  */
 // DEV-NOTE: No flatMap and orElse because this more like a Functor than a Monad.
 //           It represents a value rather than capturing a specific state.

File: vavr/src/main/java/io/vavr/MatchError.java
Patch:
@@ -12,7 +12,6 @@
  * A {@link API.Match} throws a MatchError if no case matches the applied object.
  *
  * @author Daniel Dietrich
- * @since 1.0.0
  */
 public class MatchError extends NoSuchElementException {
 

File: vavr/src/main/java/io/vavr/PartialFunction.java
Patch:
@@ -18,7 +18,6 @@
  * @param <T> type of the function input, called <em>domain</em> of the function
  * @param <R> type of the function output, called <em>codomain</em> of the function
  * @author Daniel Dietrich
- * @since 2.1.0
  */
 public interface PartialFunction<T, R> {
 

File: vavr/src/main/java/io/vavr/Predicates.java
Patch:
@@ -17,7 +17,6 @@
  * {@link API.Match}.
  *
  * @author Daniel Dietrich, Grzegorz Piwowarek
- * @since 2.0.0
  */
 public final class Predicates {
 

File: vavr/src/main/java/io/vavr/Value.java
Patch:
@@ -148,7 +148,6 @@
  *
  * @param <T> The type of the wrapped value.
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 @SuppressWarnings("deprecation")
 public interface Value<T> extends Iterable<T> {

File: vavr/src/main/java/io/vavr/collection/AbstractIterator.java
Patch:
@@ -16,7 +16,6 @@
  *
  * @param <T> Component type
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 public abstract class AbstractIterator<T> implements Iterator<T> {
 

File: vavr/src/main/java/io/vavr/collection/AbstractMultimap.java
Patch:
@@ -25,7 +25,6 @@
  * @param <V> Value type
  * @param <M> Multimap type
  * @author Ruslan Sennov
- * @since 2.1.0
  */
 abstract class AbstractMultimap<K, V, M extends Multimap<K, V>> implements Multimap<K, V> {
 

File: vavr/src/main/java/io/vavr/collection/AbstractQueue.java
Patch:
@@ -17,7 +17,6 @@
 
 /**
  * @author Pap Lrinc, Daniel Dietrich
- * @since 2.1.0
  */
 abstract class AbstractQueue<T, Q extends AbstractQueue<T, Q>> implements Traversable<T> {
 

File: vavr/src/main/java/io/vavr/collection/Array.java
Patch:
@@ -25,7 +25,6 @@
  *
  * @param <T> Component type
  * @author Ruslan Sennov, Daniel Dietrich
- * @since 2.0.0
  */
 @SuppressWarnings("deprecation")
 public final class Array<T> implements IndexedSeq<T>, Serializable {

File: vavr/src/main/java/io/vavr/collection/BitMappedTrie.java
Patch:
@@ -28,7 +28,6 @@
  * `Slice` is done by trimming the path from the root and discarding any `leading`/`trailing` values in effectively constant time (without memory leak, as in `Java`/`Clojure`).
  *
  * @author Pap Lrinc
- * @since 2.1.0
  */
 final class BitMappedTrie<T> implements Serializable {
 

File: vavr/src/main/java/io/vavr/collection/BitSet.java
Patch:
@@ -24,7 +24,6 @@
  * An immutable {@code BitSet} implementation.
  *
  * @author Ruslan Sennov
- * @since 2.1.0
  */
 public interface BitSet<T> extends SortedSet<T> {
 

File: vavr/src/main/java/io/vavr/collection/Collections.java
Patch:
@@ -19,7 +19,6 @@
  * Internal class, containing helpers.
  *
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 final class Collections {
 

File: vavr/src/main/java/io/vavr/collection/Comparators.java
Patch:
@@ -13,7 +13,6 @@
  * INTERNAL: Common {@code Comparator} related functions (not intended to be public).
  *
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 final class Comparators {
 

File: vavr/src/main/java/io/vavr/collection/Foldable.java
Patch:
@@ -24,7 +24,6 @@
  *
  * @param <T> Component type of this foldable
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 public interface Foldable<T> {
 

File: vavr/src/main/java/io/vavr/collection/HashArrayMappedTrie.java
Patch:
@@ -23,7 +23,6 @@
  * An immutable <a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">Hash array mapped trie (HAMT)</a>.
  *
  * @author Ruslan Sennov
- * @since 2.0.0
  */
 interface HashArrayMappedTrie<K, V> extends Iterable<Tuple2<K, V>> {
 

File: vavr/src/main/java/io/vavr/collection/HashMap.java
Patch:
@@ -23,7 +23,6 @@
  * <a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">Hash array mapped trie (HAMT)</a>.
  *
  * @author Ruslan Sennov, Patryk Najda, Daniel Dietrich
- * @since 2.0.0
  */
 @SuppressWarnings("deprecation")
 public final class HashMap<K, V> implements Map<K, V>, Serializable {

File: vavr/src/main/java/io/vavr/collection/HashMultimap.java
Patch:
@@ -24,7 +24,6 @@
  * @param <K> Key type
  * @param <V> Value type
  * @author Ruslan Sennov
- * @since 2.1.0
  */
 public final class HashMultimap<K, V> extends AbstractMultimap<K, V, HashMultimap<K, V>> implements Serializable {
 

File: vavr/src/main/java/io/vavr/collection/HashSet.java
Patch:
@@ -22,7 +22,6 @@
  *
  * @param <T> Component type
  * @author Ruslan Sennov, Patryk Najda, Daniel Dietrich
- * @since 2.0.0
  */
 @SuppressWarnings("deprecation")
 public final class HashSet<T> implements Set<T>, Serializable {

File: vavr/src/main/java/io/vavr/collection/IndexedSeq.java
Patch:
@@ -23,7 +23,6 @@
  *
  * @param <T> component type
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 public interface IndexedSeq<T> extends Seq<T> {
 

File: vavr/src/main/java/io/vavr/collection/Iterator.java
Patch:
@@ -46,7 +46,6 @@
  *
  * @param <T> Component type
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 public interface Iterator<T> extends java.util.Iterator<T>, Traversable<T> {
     // DEV-NOTE: we prefer returning empty() over this if !hasNext() == true in order to free memory.
@@ -56,7 +55,7 @@ public interface Iterator<T> extends java.util.Iterator<T>, Traversable<T> {
      *
      * @deprecated Will be removed because class loading may cause a deadlock under certain circumstances (see #1773 and https://bugs.openjdk.java.net/browse/JDK-8037567)
      */
-    @Deprecated(/* Not used any more, will be removed in 3.0.0 */)
+    @Deprecated(/* Not used any more, will be removed in 0.9.0 */)
     Iterator<Object> EMPTY = EmptyIterator.INSTANCE;
 
     /**

File: vavr/src/main/java/io/vavr/collection/JavaConverters.java
Patch:
@@ -18,7 +18,6 @@
  * The view creation and back conversion take O(1).
  *
  * @author Daniel Dietrich
- * @since 2.1.0
  */
 class JavaConverters {
 

File: vavr/src/main/java/io/vavr/collection/LinearSeq.java
Patch:
@@ -22,7 +22,6 @@
  *
  * @param <T> component type
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 public interface LinearSeq<T> extends Seq<T> {
 

File: vavr/src/main/java/io/vavr/collection/LinkedHashMap.java
Patch:
@@ -21,7 +21,6 @@
  * An immutable {@code LinkedHashMap} implementation.
  *
  * @author Ruslan Sennov
- * @since 2.0.0
  */
 @SuppressWarnings("deprecation")
 public final class LinkedHashMap<K, V> implements Map<K, V>, Serializable {

File: vavr/src/main/java/io/vavr/collection/LinkedHashMultimap.java
Patch:
@@ -24,7 +24,6 @@
  * @param <K> Key type
  * @param <V> Value type
  * @author Ruslan Sennov
- * @since 2.1.0
  */
 public final class LinkedHashMultimap<K, V> extends AbstractMultimap<K, V, LinkedHashMultimap<K, V>> implements Serializable {
 

File: vavr/src/main/java/io/vavr/collection/LinkedHashSet.java
Patch:
@@ -22,7 +22,6 @@
  *
  * @param <T> Component type
  * @author Ruslan Sennov, Patryk Najda, Daniel Dietrich
- * @since 2.0.0
  */
 @SuppressWarnings("deprecation")
 public final class LinkedHashSet<T> implements Set<T>, Serializable {

File: vavr/src/main/java/io/vavr/collection/List.java
Patch:
@@ -92,7 +92,6 @@
  *
  * @param <T> Component type of the List
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 public interface List<T> extends LinearSeq<T>, Stack<T> {
@@ -1595,7 +1594,6 @@ default <U> List<U> zipWithIndex(BiFunction<? super T, ? super Integer, ? extend
      * Representation of the singleton empty {@code List}.
      *
      * @param <T> Component type of the List.
-     * @since 1.1.0
      */
     final class Nil<T> implements List<T>, Serializable {
 
@@ -1668,7 +1666,6 @@ private Object readResolve() {
      * Non-empty {@code List}, consisting of a {@code head} and a {@code tail}.
      *
      * @param <T> Component type of the List.
-     * @since 1.1.0
      */
     // DEV NOTE: class declared final because of serialization proxy pattern (see Effective Java, 2nd ed., p. 315)
     final class Cons<T> implements List<T>, Serializable {

File: vavr/src/main/java/io/vavr/collection/Map.java
Patch:
@@ -79,7 +79,6 @@
  * @param <K> Key type
  * @param <V> Value type
  * @author Daniel Dietrich, Ruslan Sennov
- * @since 2.0.0
  */
 public interface Map<K, V> extends Traversable<Tuple2<K, V>>, Function1<K, V>, Serializable {
 
@@ -556,7 +555,7 @@ default <U> U transform(Function<? super Map<K, V>, ? extends U> f) {
      * @param mapper A function that maps (key, value) pairs to elements of type U
      * @param <U> The type of the resulting elements
      * @return A new sequence containing the mapped elements.
-     * @deprecated will be replaced by iterator(BiFunction) in 3.0.0
+     * @deprecated will be replaced by iterator(BiFunction) in 0.9.0
      */
     @Deprecated
     default <U> Seq<U> traverse(BiFunction<K, V, ? extends U> mapper) {

File: vavr/src/main/java/io/vavr/collection/Maps.java
Patch:
@@ -20,7 +20,6 @@
  * INTERNAL: Common {@code Map} functions (not intended to be public).
  *
  * @author Ruslan Sennov, Daniel Dietrich
- * @since 2.0.0
  */
 final class Maps {
 

File: vavr/src/main/java/io/vavr/collection/Multimap.java
Patch:
@@ -73,7 +73,6 @@
  * @param <K> Key type
  * @param <V> Value type
  * @author Ruslan Sennov
- * @since 2.1.0
  */
 @SuppressWarnings("deprecation")
 public interface Multimap<K, V> extends Traversable<Tuple2<K, V>>, Function1<K, Traversable<V>>, Serializable {
@@ -465,7 +464,7 @@ default <U> U transform(Function<? super Multimap<K, V>, ? extends U> f) {
      * @param mapper A function that maps (key, value) pairs to elements of type U
      * @param <U> The type of the resulting elements
      * @return A new sequence containing the mapped elements.
-     * @deprecated will be replaced by iterator(BiFunction) in 3.0.0     */
+     * @deprecated will be replaced by iterator(BiFunction) in 0.9.0     */
     @Deprecated
     default <U> Seq<U> traverse(BiFunction<K, V, ? extends U> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");

File: vavr/src/main/java/io/vavr/collection/Multimaps.java
Patch:
@@ -15,7 +15,6 @@
  * INTERNAL: Common {@code Multimap} functions (not intended to be public).
  *
  * @author Ruslan Sennov, Daniel Dietrich
- * @since 2.1.0
  */
 class Multimaps {
 

File: vavr/src/main/java/io/vavr/collection/Ordered.java
Patch:
@@ -13,7 +13,6 @@
  *
  * @param <T> Component type
  * @author Ruslan Sennov, Daniel Dietrich
- * @since 2.1.0
  */
 public interface Ordered<T> {
 

File: vavr/src/main/java/io/vavr/collection/PriorityQueue.java
Patch:
@@ -20,7 +20,6 @@
  * A PriorityQueue.
  *
  * @author Pap Lrinc
- * @since 2.1.0
  */
 @SuppressWarnings("deprecation")
 public final class PriorityQueue<T> extends io.vavr.collection.AbstractQueue<T, PriorityQueue<T>> implements Serializable, Ordered<T> {

File: vavr/src/main/java/io/vavr/collection/Queue.java
Patch:
@@ -41,7 +41,6 @@
  *
  * @param <T> Component type of the Queue
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 @SuppressWarnings("deprecation")
 public final class Queue<T> extends AbstractQueue<T, Queue<T>> implements LinearSeq<T> {

File: vavr/src/main/java/io/vavr/collection/RedBlackTree.java
Patch:
@@ -32,7 +32,6 @@
  *
  * @param <T> Component type
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 @SuppressWarnings("deprecation")
 interface RedBlackTree<T> extends Iterable<T> {

File: vavr/src/main/java/io/vavr/collection/Seq.java
Patch:
@@ -93,7 +93,6 @@
  *
  * @param <T> Component type
  * @author Daniel Dietrich
- * @since 1.1.0
  */
 public interface Seq<T> extends Traversable<T>, Function1<Integer, T>, Serializable {
 
@@ -1027,7 +1026,7 @@ default boolean startsWith(Iterable<? extends T> that, int offset) {
      * @param elements The elements to be wrapped in an instance of this Seq type
      * @param <U> element type
      * @return An instance of this Seq type
-     * @deprecated This method is meant to be used internally only. It will be removed from the public API with 3.0.0.
+     * @deprecated This method is meant to be used internally only. It will be removed from the public API with 0.9.0.
      */
     @Deprecated
     <U> Seq<U> unit(Iterable<? extends U> elements);

File: vavr/src/main/java/io/vavr/collection/Set.java
Patch:
@@ -68,7 +68,6 @@
  *
  * @param <T> Component type
  * @author Daniel Dietrich, Ruslan Sennov
- * @since 2.0.0
  */
 public interface Set<T> extends Traversable<T>, Function1<T, Boolean>, Serializable {
 

File: vavr/src/main/java/io/vavr/collection/SortedMap.java
Patch:
@@ -19,7 +19,6 @@
  * @param <K> Key type
  * @param <V> Value type
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 public interface SortedMap<K, V> extends Map<K, V>, Ordered<K> {
 

File: vavr/src/main/java/io/vavr/collection/SortedMultimap.java
Patch:
@@ -19,7 +19,6 @@
  * @param <K> Key type
  * @param <V> Value type
  * @author Ruslan Sennov
- * @since 2.1.0
  */
 public interface SortedMultimap<K, V> extends Multimap<K, V>, Ordered<K> {
 

File: vavr/src/main/java/io/vavr/collection/SortedSet.java
Patch:
@@ -29,7 +29,6 @@
  *
  * @param <T> Component type
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 public interface SortedSet<T> extends Set<T>, Ordered<T> {
 

File: vavr/src/main/java/io/vavr/collection/Stack.java
Patch:
@@ -32,8 +32,7 @@
  *
  * @param <T> component type
  * @author Daniel Dietrich
- * @since 2.0.0
- * @deprecated Will be removed in 3.0.0
+ * @deprecated Will be removed in 0.9.0
  */
 @Deprecated
 public interface Stack<T> {

File: vavr/src/main/java/io/vavr/collection/Stream.java
Patch:
@@ -98,7 +98,6 @@
  *
  * @param <T> component type of this Stream
  * @author Daniel Dietrich, Jrgen Andersson, Ruslan Sennov
- * @since 1.1.0
  */
 @SuppressWarnings("deprecation")
 public interface Stream<T> extends LinearSeq<T> {
@@ -1719,7 +1718,6 @@ public boolean hasNext() {
      * This is a singleton, i.e. not Cloneable.
      *
      * @param <T> Component type of the Stream.
-     * @since 1.1.0
      */
     final class Empty<T> implements Stream<T>, Serializable {
 
@@ -1792,7 +1790,6 @@ private Object readResolve() {
      * Non-empty {@code Stream}, consisting of a {@code head}, and {@code tail}.
      *
      * @param <T> Component type of the Stream.
-     * @since 1.1.0
      */
     abstract class Cons<T> implements Stream<T> {
 

File: vavr/src/main/java/io/vavr/collection/Traversable.java
Patch:
@@ -143,7 +143,6 @@
  *
  * @param <T> Component type
  * @author Daniel Dietrich and others
- * @since 1.1.0
  */
 public interface Traversable<T> extends Foldable<T>, Value<T> {
 
@@ -153,9 +152,9 @@ public interface Traversable<T> extends Foldable<T>, Value<T> {
      * @param objects An Iterable instance containing zero or more objects.
      * @param <T>     Component type
      * @return The hashcode
-     * @deprecated Will be removed in 3.0.0.
+     * @deprecated Will be removed in 0.9.0.
      */
-    @Deprecated(/* Will be removed in 3.0.0 */)
+    @Deprecated(/* Will be removed in 0.9.0 */)
     static <T> int hash(Iterable<? extends T> objects) {
         int hashCode = 1;
         for (Object o : objects) {

File: vavr/src/main/java/io/vavr/collection/Tree.java
Patch:
@@ -27,7 +27,6 @@
  *
  * @param <T> component type of this Tree
  * @author Daniel Dietrich, Grzegorz Piwowarek
- * @since 1.1.0
  */
 public interface Tree<T> extends Traversable<T>, Serializable {
 
@@ -203,7 +202,7 @@ default <R> Tree<R> collect(PartialFunction<? super T, ? extends R> partialFunct
      *
      * @return The value of this tree.
      * @throws java.lang.UnsupportedOperationException if this tree is empty
-     * @deprecated Will be removed in 3.0.0. Use get() instead.
+     * @deprecated Will be removed in 0.9.0. Use get() instead.
      */
     @Deprecated
     T getValue();

File: vavr/src/main/java/io/vavr/collection/TreeMap.java
Patch:
@@ -24,7 +24,6 @@
  * @param <K> Key type
  * @param <V> Value type
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 // DEV-NOTE: use entries.min().get() in favor of iterator().next(), it is faster!
 @SuppressWarnings("deprecation")

File: vavr/src/main/java/io/vavr/collection/TreeMultimap.java
Patch:
@@ -25,7 +25,6 @@
  * @param <K> Key type
  * @param <V> Value type
  * @author Ruslan Sennov
- * @since 2.1.0
  */
 public final class TreeMultimap<K, V> extends AbstractMultimap<K, V, TreeMultimap<K, V>> implements Serializable, SortedMultimap<K, V> {
 

File: vavr/src/main/java/io/vavr/collection/TreeSet.java
Patch:
@@ -22,7 +22,6 @@
  *
  * @param <T> Component type
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 // DEV-NOTE: it is not possible to create an EMPTY TreeSet without a Comparator type in scope
 @SuppressWarnings("deprecation")

File: vavr/src/main/java/io/vavr/collection/Vector.java
Patch:
@@ -27,7 +27,6 @@
  *
  * @param <T> Component type of the Vector.
  * @author Ruslan Sennov, Pap Lrinc
- * @since 2.0.0
  */
 @SuppressWarnings("deprecation")
 public final class Vector<T> implements IndexedSeq<T>, Serializable {

File: vavr/src/main/java/io/vavr/collection/package-info.java
Patch:
@@ -57,7 +57,5 @@
  * <li><small>log</small>&nbsp;&middot;&nbsp;logarithmic time</li>
  * <li><small>linear</small>&nbsp;&middot;&nbsp;linear time</li>
  * </ul>
- *
- * @since 1.1.0
  */
 package io.vavr.collection;

File: vavr/src/main/java/io/vavr/concurrent/Future.java
Patch:
@@ -44,7 +44,6 @@
  *
  * @param <T> Type of the computation result.
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 public interface Future<T> extends Value<T> {
 

File: vavr/src/main/java/io/vavr/concurrent/FutureImpl.java
Patch:
@@ -54,7 +54,6 @@
  *
  * @param <T> Result of the computation.
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 final class FutureImpl<T> implements Future<T> {
 

File: vavr/src/main/java/io/vavr/concurrent/GuardedBy.java
Patch:
@@ -23,7 +23,6 @@
  * See also <a href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a>
  *
  * @author Daniel Dietrich
- * @since 2.1.0
  */
 @Documented
 @Target(value = { FIELD, METHOD })

File: vavr/src/main/java/io/vavr/concurrent/Promise.java
Patch:
@@ -61,7 +61,6 @@
  *
  * @param <T> The result type of the underlying {@code Future}.
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 public interface Promise<T> {
 
@@ -299,7 +298,6 @@ default boolean tryFailure(Throwable exception) {
  *
  * @param <T> result type
  * @author Daniel Dietrich
- * @since 2.0.0
  */
 final class PromiseImpl<T> implements Promise<T> {
 

File: vavr/src/main/java/io/vavr/concurrent/package-info.java
Patch:
@@ -9,6 +9,5 @@
  * While Futures are concurrent read-only tasks, a {@linkplain io.vavr.concurrent.Promise} creates a writable-once
  * Future. The {@code Promise} is used to complete its contained {@code Future}.
  *
- * @since 2.0.0
  */
 package io.vavr.concurrent;

File: vavr/src/main/java/io/vavr/control/Validation.java
Patch:
@@ -60,7 +60,6 @@
  * @param <T> value type in the case of valid
  * @author Eric Nelson
  * @see <a href="https://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/Validation.scala">Validation</a>
- * @since 2.0.0
  */
 public interface Validation<E, T> extends Value<T>, Serializable {
 
@@ -529,9 +528,9 @@ default <E2, T2> Validation<E2, T2> bimap(Function<? super E, ? extends E2> erro
      * @param f   a function that maps the error in this Invalid
      * @return an instance of Validation&lt;U,T&gt;
      * @throws NullPointerException if mapping operation f is null
-     * @deprecated replaced by {@link #mapError(Function)}, will be removed in 3.0.0
+     * @deprecated replaced by {@link #mapError(Function)}, will be removed in 0.9.0
      */
-    @Deprecated(/* Use mapError instead. Will be removed in 3.0.0 */)
+    @Deprecated(/* Use mapError instead. Will be removed in 0.9.0 */)
     default <U> Validation<U, T> leftMap(Function<? super E, ? extends U> f) {
         return mapError(f);
     }

File: vavr/src/main/java/io/vavr/control/package-info.java
Patch:
@@ -27,7 +27,5 @@
  * A Cause is unchecked, i.e. a RuntimeException, and is Fatal or NonFatal.
  * Fatal exceptions cannot be handled and are thrown without further processing.
  * NonFatal exceptions are wrapped in a Failure.
- *
- * @since 1.0.0
  */
 package io.vavr.control;

File: vavr/src/main/java/io/vavr/package-info.java
Patch:
@@ -1,6 +1,4 @@
 /**
  * The io.vavr package contains core types like {@linkplain io.vavr.}, {@linkplain io.vavr.Lazy} and {@linkplain io.vavr.Tuple}.
- *
- * @since 1.0.0
  */
 package io.vavr;

File: vavr/src/main/java/io/vavr/.java
Patch:
@@ -17,8 +17,7 @@
  *
  * @param <R> Return type of the function.
  * @author Daniel Dietrich
- * @since 1.0.0
- * @deprecated Will be removed from the public API (an internally renamed to Lambda) in 3.0.0
+ * @deprecated Will be removed from the public API (an internally renamed to Lambda) in 0.9.0
  */
 @Deprecated
 public interface <R> extends Serializable {
@@ -76,7 +75,7 @@ default boolean isMemoized() {
 
     /**
      * Zero Abstract Method (ZAM) interface for marking functions as memoized using intersection types.
-     * @deprecated Will be removed (from the public API) in 3.0.0
+     * @deprecated Will be removed (from the public API) in 0.9.0
      */
     @Deprecated
     interface Memoized {

File: vavr/src/main/java/io/vavr/collection/Array.java
Patch:
@@ -1225,9 +1225,8 @@ public Array<T> subSequence(int beginIndex) {
 
     @Override
     public Array<T> subSequence(int beginIndex, int endIndex) {
-        if (beginIndex < 0 || beginIndex > endIndex || endIndex > length()) {
-            throw new IndexOutOfBoundsException("subSequence(" + beginIndex + ", " + endIndex + ") on Array of length " + length());
-        } else if (beginIndex == endIndex) {
+        Collections.subSequenceRangeCheck(beginIndex, endIndex, length());
+        if (beginIndex == endIndex) {
             return empty();
         } else if (beginIndex == 0 && endIndex == length()) {
             return this;

File: vavr/src/main/java/io/vavr/collection/CharSeq.java
Patch:
@@ -1686,7 +1686,7 @@ public CharSeq subSequence(int beginIndex, int endIndex) {
         }
         final int subLen = endIndex - beginIndex;
         if (subLen < 0) {
-            throw new IndexOutOfBoundsException("beginIndex " + beginIndex + " > endIndex " + endIndex);
+            throw new IllegalArgumentException("beginIndex " + beginIndex + " > endIndex " + endIndex);
         }
         if (beginIndex == 0 && endIndex == length()) {
             return this;

File: vavr/src/main/java/io/vavr/collection/List.java
Patch:
@@ -1369,9 +1369,8 @@ default List<T> subSequence(int beginIndex) {
 
     @Override
     default List<T> subSequence(int beginIndex, int endIndex) {
-        if (beginIndex < 0 || beginIndex > endIndex || endIndex > length()) {
-            throw new IndexOutOfBoundsException("subSequence(" + beginIndex + ", " + endIndex + ") on List of length " + length());
-        } else if (beginIndex == endIndex) {
+        Collections.subSequenceRangeCheck(beginIndex, endIndex, length());
+        if (beginIndex == endIndex) {
             return empty();
         } else if (beginIndex == 0 && endIndex == length()) {
             return this;

File: vavr/src/main/java/io/vavr/collection/Queue.java
Patch:
@@ -1128,9 +1128,8 @@ public Queue<T> subSequence(int beginIndex) {
 
     @Override
     public Queue<T> subSequence(int beginIndex, int endIndex) {
-        if (beginIndex < 0 || beginIndex > endIndex || endIndex > length()) {
-            throw new IndexOutOfBoundsException("subSequence(" + beginIndex + ", " + endIndex + ") on Queue of length " + length());
-        } else if (beginIndex == endIndex) {
+        Collections.subSequenceRangeCheck(beginIndex, endIndex, length());
+        if (beginIndex == endIndex) {
             return empty();
         } else if (beginIndex == 0 && endIndex == length()) {
             return this;

File: vavr/src/main/java/io/vavr/collection/Seq.java
Patch:
@@ -959,9 +959,9 @@ default boolean startsWith(Iterable<? extends T> that, int offset) {
      * @param beginIndex the beginning index, inclusive
      * @param endIndex   the end index, exclusive
      * @return the specified subsequence
-     * @throws IndexOutOfBoundsException if {@code beginIndex} or {@code endIndex} is negative,
-     *                                   if {@code endIndex} is greater than {@code length()},
-     *                                   or if {@code beginIndex} is greater than {@code endIndex}
+     * @throws IndexOutOfBoundsException if {@code beginIndex} or {@code endIndex} is negative or
+     *                                   if {@code endIndex} is greater than {@code length()}
+     * @throws IllegalArgumentException  if {@code beginIndex} is greater than {@code endIndex}
      */
     Seq<T> subSequence(int beginIndex, int endIndex);
 

File: vavr/src/test/java/io/vavr/collection/AbstractSeqTest.java
Patch:
@@ -1822,12 +1822,12 @@ public void shouldReturnNilWhenOnSubSequenceIndicesBothAreUpperBound() {
         assertThat(actual).isEmpty();
     }
 
-    @Test(expected = IndexOutOfBoundsException.class)
+    @Test(expected = IllegalArgumentException.class)
     public void shouldThrowOnSubSequenceOnNonNilWhenBeginIndexIsGreaterThanEndIndex() {
         of(1, 2, 3).subSequence(1, 0);
     }
 
-    @Test(expected = IndexOutOfBoundsException.class)
+    @Test(expected = IllegalArgumentException.class)
     public void shouldThrowOnSubSequenceOnNilWhenBeginIndexIsGreaterThanEndIndex() {
         empty().subSequence(1, 0);
     }
@@ -1852,7 +1852,7 @@ public void shouldThrowOnSubSequenceWhenEndIndexExceedsUpperBound() {
         of(1, 2, 3).subSequence(1, 4).mkString(); // force computation of last element, e.g. because Stream is lazy
     }
 
-    @Test(expected = IndexOutOfBoundsException.class)
+    @Test(expected = IllegalArgumentException.class)
     public void shouldThrowOnSubSequenceWhenBeginIndexIsGreaterThanEndIndex() {
         of(1, 2, 3).subSequence(2, 1).mkString(); // force computation of last element, e.g. because Stream is lazy
     }

File: vavr/src/main/java/io/vavr/collection/List.java
Patch:
@@ -1566,7 +1566,7 @@ private Nil() {
         }
 
         /**
-         * Returns the singleton instance of the liked list.
+         * Returns the singleton instance of the linked list.
          *
          * @param <T> Component type of the List
          * @return the singleton instance of the linked list.

File: vavr/src/main/java/io/vavr/collection/CharSeq.java
Patch:
@@ -112,7 +112,7 @@ public static CharSeq of(char... characters) {
      *
      * @param elements An Iterable of elements.
      * @return A string containing the given elements in the same order.
-     * @throws NullPointerException if {@code elements} is null
+     * @throws NullPointerException if {@code elements} is null or {@code elements} contains null
      */
     public static CharSeq ofAll(Iterable<? extends Character> elements) {
         Objects.requireNonNull(elements, "elements is null");
@@ -121,7 +121,7 @@ public static CharSeq ofAll(Iterable<? extends Character> elements) {
         }
         final StringBuilder sb = new StringBuilder();
         for (Character character : elements) {
-            sb.append(character);
+            sb.append(character.charValue());
         }
         return sb.length() == 0 ? EMPTY : of(sb);
     }

File: vavr/src/main/java/io/vavr/concurrent/Future.java
Patch:
@@ -687,9 +687,8 @@ default boolean cancel() {
 
     /**
      * Collects value that is in the domain of the given {@code partialFunction} by mapping the value to type {@code R}.
-     * <p>
      *
-     * <pre><{@code
+     * <pre>{@code
      * partialFunction.isDefinedAt(value)
      * }</pre>
      *

File: vavr/src/main/java/io/vavr/control/Option.java
Patch:
@@ -170,9 +170,8 @@ static <T> Option<T> ofOptional(Optional<? extends T> optional) {
 
     /**
      * Collects value that is in the domain of the given {@code partialFunction} by mapping the value to type {@code R}.
-     * <p>
      *
-     * <pre><{@code
+     * <pre>{@code
      * partialFunction.isDefinedAt(value)
      * }</pre>
      *

File: vavr/src/main/java/io/vavr/control/Try.java
Patch:
@@ -271,9 +271,8 @@ default Try<T> andThenTry(CheckedRunnable runnable) {
 
     /**
      * Collects value that is in the domain of the given {@code partialFunction} by mapping the value to type {@code R}.
-     * <p>
      *
-     * <pre><{@code
+     * <pre>{@code
      * partialFunction.isDefinedAt(value)
      * }</pre>
      *

File: vavr-benchmark/src/test/java/io/vavr/MemoryUsage.java
Patch:
@@ -59,7 +59,7 @@ static void storeMemoryUsages(int elementCount, Object target) {
             Tuple.of("^scalaz\\.Heap", "Scalaz persistent @ "),
             Tuple.of("^scala\\.collection.immutable", "Scala persistent @ "),
             Tuple.of("^scala\\.collection.mutable", "Scala mutable @ "),
-            Tuple.of("^vavr\\.", "Vavr persistent @ ")
+            Tuple.of("^io.vavr\\.", "Vavr persistent @ ")
     ).mapKeys(r -> Pattern.compile(r).asPredicate());
     private static String toHumanReadableName(Object target) {
         final Class<?> type = target.getClass();

File: vavr-benchmark/src/test/java/io/vavr/control/LazyBenchmark.java
Patch:
@@ -72,15 +72,15 @@ public void java_eager(Blackhole bh) {
         }
 
         @Benchmark
-        public void slang_inited_lazy(Blackhole bh) {
+        public void vavr_inited_lazy(Blackhole bh) {
             for (int i = 0; i < SIZE; i++) {
                 assert INITED_LAZIES[i].isEvaluated();
                 bh.consume(INITED_LAZIES[i].get());
             }
         }
 
         @Benchmark
-        public void slang_lazy(Initialized state, Blackhole bh) {
+        public void vavr_lazy(Initialized state, Blackhole bh) {
             for (int i = 0; i < SIZE; i++) {
                 assert !state.LAZIES[i].isEvaluated();
                 bh.consume(state.LAZIES[i].get());

File: vavr-benchmark/src/test/java/io/vavr/idiom/ForBenchmark.java
Patch:
@@ -79,7 +79,7 @@ public Object java_for() {
         }
 
         @Benchmark
-        public Object slang_for() {
+        public Object vavr_for() {
             final List<Integer> result = For(ELEMENTS, ELEMENTS).yield(AGGREGATOR).collect(toList());
             assert Array(result).sum().intValue() == AGGREGATE;
             return result;

File: vavr-benchmark/src/test/java/io/vavr/idiom/TryBenchmark.java
Patch:
@@ -55,7 +55,7 @@ public void java_try(Blackhole bh) {
         }
 
         @Benchmark
-        public void slang_try(Blackhole bh) {
+        public void vavr_try(Blackhole bh) {
             for (int i = 0; i <= 1; i++) {
                 int i2 = i;
                 final int result = Try(() -> inverse(i2))

File: vavr-benchmark/src/test/java/io/vavr/idiom/TupleBenchmark.java
Patch:
@@ -41,22 +41,22 @@ public static class Tuple2Benchmark {
         public Object java_tuple() { return new Integer[] { 0, 1 }; }
 
         @Benchmark
-        public Object slang_tuple() { return Tuple.of(0, 1); }
+        public Object vavr_tuple() { return Tuple.of(0, 1); }
     }
 
     public static class Tuple4Benchmark {
         @Benchmark
         public Object java_tuple() { return new Integer[] { 0, 1, 2 }; }
 
         @Benchmark
-        public Object slang_tuple() { return Tuple.of(0, 1, 2, 3); }
+        public Object vavr_tuple() { return Tuple.of(0, 1, 2, 3); }
     }
 
     public static class Tuple8Benchmark {
         @Benchmark
         public Object java_tuple() { return new Integer[] { 0, 1, 2, 3, 4, 5, 6, 7 }; }
 
         @Benchmark
-        public Object slang_tuple() { return Tuple.of(0, 1, 2, 3, 4, 5, 6, 7); }
+        public Object vavr_tuple() { return Tuple.of(0, 1, 2, 3, 4, 5, 6, 7); }
     }
 }

File: javaslang/src/main/java/javaslang/PartialFunction.java
Patch:
@@ -6,7 +6,7 @@
 package javaslang;
 
 /**
- * Represents a partial function T -> R that is not necessarily defined for all input values of type T.
+ * Represents a partial function T -&gt; R that is not necessarily defined for all input values of type T.
  * The caller is responsible for calling the method isDefinedAt() before this function is applied to the value.
  * <p>
  * If the function <em>is not defined</em> for a specific value, apply() may produce an arbitrary result.

File: javaslang/src/main/java/javaslang/collection/Iterator.java
Patch:
@@ -18,7 +18,6 @@
 import static java.lang.Double.NEGATIVE_INFINITY;
 import static java.lang.Double.POSITIVE_INFINITY;
 import static java.math.RoundingMode.HALF_UP;
-import static javaslang.API.*;
 import static javaslang.collection.IteratorModule.BigDecimalHelper.areEqual;
 import static javaslang.collection.IteratorModule.BigDecimalHelper.asDecimal;
 import static javaslang.collection.IteratorModule.EmptyIterator;

File: javaslang/src/main/java/javaslang/collection/RedBlackTree.java
Patch:
@@ -465,7 +465,7 @@ public boolean equals(Object o) {
         public int hashCode() {
             // DEV-NOTE: Using `Objects.hash(this.value, this.left, this.right)` would leak the tree structure to the outside.
             //           We just want to hash the values in the right order.
-            return Collections.hash(this);
+            return Collections.hashOrdered(this);
         }
 
         @Override

File: javaslang/src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -678,10 +678,10 @@ default Option<T> lastOption() {
      */
     @SuppressWarnings("unchecked")
     default Option<T> max() {
-        final Traversable<T> ts = isTraversableAgain() ? this : toStream();
         if (isEmpty()) {
             return Option.none();
         } else {
+            final Traversable<T> ts = isTraversableAgain() ? this : toStream();
             return ts.maxBy(Comparators.naturalComparator());
         }
     }
@@ -740,10 +740,10 @@ default <U extends Comparable<? super U>> Option<T> maxBy(Function<? super T, ?
      */
     @SuppressWarnings("unchecked")
     default Option<T> min() {
-        final Traversable<T> ts = isTraversableAgain() ? this : toStream();
         if (isEmpty()) {
             return Option.none();
         } else {
+            final Traversable<T> ts = isTraversableAgain() ? this : toStream();
             return ts.minBy(Comparators.naturalComparator());
         }
     }

File: javaslang/src/main/java/javaslang/control/Try.java
Patch:
@@ -499,6 +499,7 @@ default <U> Try<U> map(Function<? super T, ? extends U> mapper) {
      * @param cases A not necessarily exhaustive sequence of cases that will be matched against a cause.
      * @return A new {@code Try} if this is a {@code Failure}, otherwise this.
      */
+    @GwtIncompatible
     @SuppressWarnings({ "unchecked", "varargs" })
     default Try<T> mapFailure(Match.Case<? extends Throwable, ? extends Throwable>... cases) {
         if (isSuccess()) {

File: javaslang/src/test/java/javaslang/collection/AbstractLinearSeqTest.java
Patch:
@@ -8,6 +8,7 @@
 import org.junit.Test;
 
 import java.math.BigDecimal;
+import java.util.Spliterator;
 
 public abstract class AbstractLinearSeqTest extends AbstractSeqTest {
 

File: javaslang/src/main/java/javaslang/collection/CharSeq.java
Patch:
@@ -3342,6 +3342,7 @@ public Short toShort(int radix) {
 
     // -- conversion overrides
 
+    @GwtIncompatible
     @Override
     public Character[] toJavaArray() {
         return toJavaArray(Character.class);

File: javaslang/src/main/java/javaslang/collection/Map.java
Patch:
@@ -11,6 +11,7 @@
 import javaslang.Tuple3;
 import javaslang.control.Option;
 
+import java.io.Serializable;
 import java.util.*;
 import java.util.function.*;
 
@@ -82,7 +83,7 @@
  * @author Daniel Dietrich, Ruslan Sennov
  * @since 2.0.0
  */
-public interface Map<K, V> extends Traversable<Tuple2<K, V>>, Function1<K, V> {
+public interface Map<K, V> extends Traversable<Tuple2<K, V>>, Function1<K, V>, Serializable {
 
     long serialVersionUID = 1L;
 

File: javaslang/src/main/java/javaslang/collection/Multimap.java
Patch:
@@ -8,6 +8,7 @@
 import javaslang.*;
 import javaslang.control.Option;
 
+import java.io.Serializable;
 import java.util.*;
 import java.util.function.*;
 
@@ -73,7 +74,7 @@
  * @author Ruslan Sennov
  * @since 2.1.0
  */
-public interface Multimap<K, V> extends Traversable<Tuple2<K, V>>, Function1<K, Traversable<V>>, Kind2<Multimap<?, ?>, K, V> {
+public interface Multimap<K, V> extends Traversable<Tuple2<K, V>>, Function1<K, Traversable<V>>, Kind2<Multimap<?, ?>, K, V>, Serializable {
 
     long serialVersionUID = 1L;
 

File: javaslang/src/main/java/javaslang/collection/Seq.java
Patch:
@@ -11,6 +11,7 @@
 import javaslang.Tuple3;
 import javaslang.control.Option;
 
+import java.io.Serializable;
 import java.util.Comparator;
 import java.util.Objects;
 import java.util.function.*;
@@ -87,7 +88,7 @@
  * @author Daniel Dietrich
  * @since 1.1.0
  */
-public interface Seq<T> extends Traversable<T>, Function1<Integer, T> {
+public interface Seq<T> extends Traversable<T>, Function1<Integer, T>, Serializable {
 
     long serialVersionUID = 1L;
 

File: javaslang/src/main/java/javaslang/collection/Set.java
Patch:
@@ -10,6 +10,7 @@
 import javaslang.Tuple3;
 import javaslang.control.Option;
 
+import java.io.Serializable;
 import java.util.Comparator;
 import java.util.Spliterator;
 import java.util.Spliterators;
@@ -69,7 +70,7 @@
  * @author Daniel Dietrich, Ruslan Sennov
  * @since 2.0.0
  */
-public interface Set<T> extends Traversable<T>, Function1<T, Boolean> {
+public interface Set<T> extends Traversable<T>, Function1<T, Boolean>, Serializable {
 
     long serialVersionUID = 1L;
 

File: javaslang/src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -10,6 +10,7 @@
 import javaslang.Value;
 import javaslang.control.Option;
 
+import java.io.Serializable;
 import java.math.BigInteger;
 import java.util.Comparator;
 import java.util.NoSuchElementException;

File: javaslang/src/main/java/javaslang/collection/Tree.java
Patch:
@@ -27,7 +27,9 @@
  * @author Daniel Dietrich, Grzegorz Piwowarek
  * @since 1.1.0
  */
-public interface Tree<T> extends Traversable<T> {
+public interface Tree<T> extends Traversable<T>, Serializable {
+
+    long serialVersionUID = 1L;
 
     /**
      * Returns a {@link java.util.stream.Collector} which may be used in conjunction with

File: javaslang/src/main/java/javaslang/control/Either.java
Patch:
@@ -42,7 +42,9 @@
  * @author Daniel Dietrich
  * @since 1.0.0
  */
-public interface Either<L, R> extends Value<R> {
+public interface Either<L, R> extends Value<R>, Serializable {
+
+    long serialVersionUID = 1L;
 
     /**
      * Constructs a {@link Right}

File: javaslang/src/main/java/javaslang/control/Option.java
Patch:
@@ -34,7 +34,9 @@
  * @author Daniel Dietrich
  * @since 1.0.0
  */
-public interface Option<T> extends Value<T> {
+public interface Option<T> extends Value<T>, Serializable {
+
+    long serialVersionUID = 1L;
 
     /**
      * Creates a new {@code Option} of a given value.

File: javaslang/src/main/java/javaslang/control/Try.java
Patch:
@@ -28,7 +28,9 @@
  * @author Daniel Dietrich
  * @since 1.0.0
  */
-public interface Try<T> extends Value<T> {
+public interface Try<T> extends Value<T>, Serializable {
+
+    long serialVersionUID = 1L;
 
     /**
      * Creates a Try of a CheckedSupplier.

File: javaslang/src/test/java/javaslang/control/ValidationTest.java
Patch:
@@ -40,7 +40,7 @@ protected final <T> Value<T> of(T... elements) {
 
     @Override
     protected boolean useIsEqualToInsteadOfIsSameAs() {
-        return false;
+        return true;
     }
 
     @Override

File: javaslang/src/main/java/javaslang/Predicates.java
Patch:
@@ -102,7 +102,7 @@ public static <T> Predicate<T> isNotNull() {
     // JDK fails here without "unchecked", Eclipse complains that it is unnecessary
     @SuppressWarnings({ "unchecked", "varargs" })
     @SafeVarargs
-    public static <T> Predicate<T> allOf(Predicate<? super T>... predicates) {
+    public static <T> Predicate<T> allOf(Predicate<T>... predicates) {
         Objects.requireNonNull(predicates, "predicates is null");
         return t -> List.of(predicates).foldLeft(true, (bool, pred) -> bool && pred.test(t));
     }
@@ -117,7 +117,7 @@ public static <T> Predicate<T> allOf(Predicate<? super T>... predicates) {
     // JDK fails here without "unchecked", Eclipse complains that it is unnecessary
     @SuppressWarnings({ "unchecked", "varargs" })
     @SafeVarargs
-    public static <T> Predicate<T> anyOf(Predicate<? super T>... predicates) {
+    public static <T> Predicate<T> anyOf(Predicate<T>... predicates) {
         Objects.requireNonNull(predicates, "predicates is null");
         return t -> List.of(predicates).find(pred -> pred.test(t)).isDefined();
     }
@@ -134,7 +134,7 @@ public static <T> Predicate<T> anyOf(Predicate<? super T>... predicates) {
     // JDK fails here without "unchecked", Eclipse complains that it is unnecessary
     @SuppressWarnings({ "unchecked", "varargs" })
     @SafeVarargs
-    public static <T> Predicate<T> noneOf(Predicate<? super T>... predicates) {
+    public static <T> Predicate<T> noneOf(Predicate<T>... predicates) {
         Objects.requireNonNull(predicates, "predicates is null");
         return anyOf(predicates).negate();
     }

File: javaslang/src/main/java/javaslang/collection/BitMappedTrie.java
Patch:
@@ -270,7 +270,7 @@ private Object getLeafGeneral(int index) {
     }
 
     Iterator<T> iterator() {
-        return new Iterator<T>() {
+        return new AbstractIterator<T>() {
             private final int globalLength = BitMappedTrie.this.length;
             private int globalIndex = 0;
 
@@ -282,7 +282,7 @@ Iterator<T> iterator() {
             public boolean hasNext() { return globalIndex < globalLength; }
 
             @Override
-            public T next() {
+            public T getNext() {
                 if (index == length) { setCurrentArray(); }
                 final T next = type.getAt(leaf, index);
 

File: javaslang/src/main/java/javaslang/collection/Array.java
Patch:
@@ -593,7 +593,7 @@ public Array<T> appendAll(Iterable<? extends T> elements) {
             return wrap(arr);
         }
     }
-
+    
     @Override
     public boolean hasDefiniteSize() {
         return true;

File: javaslang/src/main/java/javaslang/collection/Iterator.java
Patch:
@@ -1234,6 +1234,7 @@ static <T> Iterator<T> unfold(T seed, Function<? super T, Option<Tuple2<? extend
      * @throws NullPointerException if {@code f} is null
      */
     static <T, U> Iterator<U> unfoldLeft(T seed, Function<? super T, Option<Tuple2<? extends T, ? extends U>>> f) {
+        Objects.requireNonNull(f, "f is null");
         return Stream.<U> ofAll(
                 unfoldRight(seed, f.andThen(tupleOpt -> tupleOpt.map(t -> Tuple.of(t._2, t._1)))))
                 .reverse().iterator();

File: javaslang/src/main/java/javaslang/collection/List.java
Patch:
@@ -573,6 +573,7 @@ static List<Long> rangeClosedBy(long from, long toInclusive, long step) {
     /**
      * Transposes the rows and columns of a {@link List} matrix.
      *
+     * @param <T> matrix element type
      * @param matrix to be transposed.
      * @return a transposed {@link List} matrix.
      * @throws IllegalArgumentException if the row lengths of {@code matrix} differ.

File: javaslang/src/main/java/javaslang/collection/Queue.java
Patch:
@@ -479,6 +479,7 @@ public static Queue<Long> rangeClosed(long from, long toInclusive) {
     /**
      * Transposes the rows and columns of a {@link Queue} matrix.
      *
+     * @param <T> matrix element type
      * @param matrix to be transposed.
      * @return a transposed {@link Queue} matrix.
      * @throws IllegalArgumentException if the row lengths of {@code matrix} differ.

File: javaslang/src/main/java/javaslang/collection/Stream.java
Patch:
@@ -666,6 +666,7 @@ static Stream<Long> rangeClosedBy(long from, long toInclusive, long step) {
     /**
      * Transposes the rows and columns of a {@link Stream} matrix.
      *
+     * @param <T> matrix element type
      * @param matrix to be transposed.
      * @return a transposed {@link Stream} matrix.
      * @throws IllegalArgumentException if the row lengths of {@code matrix} differ.
@@ -821,7 +822,7 @@ default Stream<T> appendSelf(Function<? super Stream<T>, ? extends Stream<T>> ma
         Objects.requireNonNull(mapper, "mapper is null");
         return isEmpty() ? this : new AppendSelf<>((Cons<T>) this, mapper).stream();
     }
-
+    
     @Override
     default Stream<Stream<T>> combinations() {
         return Stream.rangeClosed(0, length()).map(this::combinations).flatMap(Function.identity());

File: javaslang/src/test/java/javaslang/TestComparators.java
Patch:
@@ -16,7 +16,7 @@ private TestComparators() {
     }
 
     public static Comparator<Object> toStringComparator() {
-        return (Comparator<Object> & Serializable) comparing(String::valueOf);
+        return comparing(String::valueOf);
     }
 
 }

File: javaslang/src/test/java/javaslang/collection/HashMultimapTest.java
Patch:
@@ -27,14 +27,14 @@ <T1, T2> java.util.Map<T1, T2> javaEmptyMap() {
     }
 
     @Override
-    protected <T1 extends Comparable<T1>, T2> HashMultimap<T1, T2> emptyMap() {
+    protected <T1 extends Comparable<T1>, T2> HashMultimap<T1, T2> emptyMap(Comparator<? super T2> comparator) {
         switch (containerType) {
             case SEQ:
                 return HashMultimap.withSeq().empty();
             case SET:
                 return HashMultimap.withSet().empty();
             case SORTED_SET:
-                return HashMultimap.withSortedSet(naturalComparator()).empty();
+                return HashMultimap.withSortedSet(comparator).empty();
             default:
                 throw new RuntimeException();
         }
@@ -287,7 +287,7 @@ public void shouldCreateSortedMapFrom10Pairs() {
 
     @Test
     public void shouldNarrowMap() {
-        final HashMultimap<Integer, Number> int2doubleMap = this.<Integer, Number> emptyMap().put(1, 1.0d);
+        final HashMultimap<Integer, Number> int2doubleMap = (HashMultimap<Integer, Number>) this.<Integer, Number> emptyMap().put(1, 1.0d);
         final HashMultimap<Number, Number> number2numberMap = HashMultimap.narrow(int2doubleMap);
         final int actual = number2numberMap.put(new BigDecimal("2"), new BigDecimal("2.0")).values().sum().intValue();
         assertThat(actual).isEqualTo(3);

File: javaslang/src/test/java/javaslang/collection/LinkedHashMultimapTest.java
Patch:
@@ -27,14 +27,14 @@ <T1, T2> java.util.Map<T1, T2> javaEmptyMap() {
     }
 
     @Override
-    protected <T1 extends Comparable<T1>, T2> LinkedHashMultimap<T1, T2> emptyMap() {
+    protected <T1 extends Comparable<T1>, T2> LinkedHashMultimap<T1, T2> emptyMap(Comparator<? super T2> comparator) {
         switch (containerType) {
             case SEQ:
                 return LinkedHashMultimap.withSeq().empty();
             case SET:
                 return LinkedHashMultimap.withSet().empty();
             case SORTED_SET:
-                return LinkedHashMultimap.withSortedSet(naturalComparator()).empty();
+                return LinkedHashMultimap.withSortedSet(comparator).empty();
             default:
                 throw new RuntimeException();
         }
@@ -287,7 +287,7 @@ public void shouldCreateSortedMapFrom10Pairs() {
 
     @Test
     public void shouldNarrowMap() {
-        final LinkedHashMultimap<Integer, Number> int2doubleMap = this.<Integer, Number> emptyMap().put(1, 1.0d);
+        final LinkedHashMultimap<Integer, Number> int2doubleMap = (LinkedHashMultimap<Integer, Number>) this.<Integer, Number> emptyMap().put(1, 1.0d);
         final LinkedHashMultimap<Number, Number> number2numberMap = LinkedHashMultimap.narrow(int2doubleMap);
         final int actual = number2numberMap.put(new BigDecimal("2"), new BigDecimal("2.0")).values().sum().intValue();
         assertThat(actual).isEqualTo(3);

File: javaslang/src/test/java/javaslang/collection/TreeMultimapTest.java
Patch:
@@ -27,14 +27,14 @@ <T1, T2> java.util.Map<T1, T2> javaEmptyMap() {
     }
 
     @Override
-    protected <T1 extends Comparable<T1>, T2> TreeMultimap<T1, T2> emptyMap() {
+    protected <T1 extends Comparable<T1>, T2> TreeMultimap<T1, T2> emptyMap(Comparator<? super T2> comparator) {
         switch (containerType) {
             case SEQ:
                 return TreeMultimap.withSeq().empty();
             case SET:
                 return TreeMultimap.withSet().empty();
             case SORTED_SET:
-                return TreeMultimap.withSortedSet(naturalComparator()).empty();
+                return TreeMultimap.withSortedSet(comparator).empty();
             default:
                 throw new RuntimeException();
         }
@@ -287,7 +287,7 @@ public void shouldCreateSortedMapFrom10Pairs() {
 
     @Test
     public void shouldNarrowMap() {
-        final TreeMultimap<Integer, Number> int2doubleMap = this.<Integer, Number> emptyMap().put(1, 1.0d);
+        final TreeMultimap<Integer, Number> int2doubleMap = (TreeMultimap<Integer, Number>) this.<Integer, Number> emptyMap().put(1, 1.0d);
         final TreeMultimap<Number, Number> number2numberMap = TreeMultimap.narrow(int2doubleMap);
         final int actual = number2numberMap.put(2, new BigDecimal("2.0")).values().sum().intValue();
         assertThat(actual).isEqualTo(3);

File: javaslang/src/main/java/javaslang/collection/PriorityQueue.java
Patch:
@@ -56,7 +56,8 @@ public PriorityQueue<T> enqueue(T element) {
     }
 
     /**
-     * Enqueues the given elements.
+     * Enqueues the given elements. A queue has FIFO order, i.e. the first of the given elements is
+     * the first which will be retrieved.
      *
      * @param elements An {@link PriorityQueue} of elements, may be empty
      * @return a new {@link PriorityQueue} instance, containing the new elements

File: javaslang/src/main/java/javaslang/collection/CharSeq.java
Patch:
@@ -991,6 +991,7 @@ public <U> U transform(Function<? super CharSeq, ? extends U> f) {
         return f.apply(this);
     }
 
+    @SuppressWarnings("deprecation")
     @Override
     public <U> IndexedSeq<U> unit(Iterable<? extends U> iterable) {
         return Vector.ofAll(iterable);

File: javaslang/src/main/java/javaslang/collection/IndexedSeq.java
Patch:
@@ -344,6 +344,7 @@ default boolean startsWith(Iterable<? extends T> that, int offset) {
     @Override
     IndexedSeq<T> takeWhile(Predicate<? super T> predicate);
 
+    @SuppressWarnings("deprecation")
     @Override
     <U> IndexedSeq<U> unit(Iterable<? extends U> iterable);
 

File: javaslang/src/main/java/javaslang/collection/LinearSeq.java
Patch:
@@ -284,6 +284,7 @@ default int segmentLength(Predicate<? super T> predicate, int from) {
     @Override
     LinearSeq<T> takeWhile(Predicate<? super T> predicate);
 
+    @SuppressWarnings("deprecation")
     @Override
     <U> LinearSeq<U> unit(Iterable<? extends U> iterable);
 

File: javaslang/src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -108,8 +108,8 @@
  * <ul>
  * <li>{@link #existsUnique(Predicate)}</li>
  * <li>{@link #hasDefiniteSize()}</li>
- * <li>{@link #isDistinct}</li>
- * <li>{@link #isOrdered}</li>
+ * <li>{@link #isDistinct()}</li>
+ * <li>{@link #isOrdered()}</li>
  * <li>{@link #isTraversableAgain()}</li>
  * </ul>
  *

File: javaslang/src/test/java/javaslang/collection/AbstractMapTest.java
Patch:
@@ -215,7 +215,7 @@ protected <T> IntMap<T> ofAll(Iterable<? extends T> elements) {
     }
 
     @Override
-    protected <T> IntMap<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream) {
+    protected <T extends Comparable<? super T>> IntMap<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream) {
         return ofAll(Iterator.ofAll(javaStream.iterator()));
     }
 

File: javaslang/src/test/java/javaslang/collection/AbstractMultimapTest.java
Patch:
@@ -209,7 +209,7 @@ protected <T> IntMultimap<T> ofAll(Iterable<? extends T> elements) {
     }
 
     @Override
-    protected <T> IntMultimap<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream) {
+    protected <T extends Comparable<? super T>> IntMultimap<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream) {
         return ofAll(Iterator.ofAll(javaStream.iterator()));
     }
 

File: javaslang/src/test/java/javaslang/collection/AbstractTraversableTest.java
Patch:
@@ -53,7 +53,7 @@ protected boolean emptyShouldBeSingleton() {
 
     protected abstract <T> Traversable<T> ofAll(Iterable<? extends T> elements);
 
-    protected abstract <T> Traversable<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream);
+    protected abstract <T extends Comparable<? super T>> Traversable<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream);
 
     protected abstract Traversable<Boolean> ofAll(boolean... elements);
 

File: javaslang/src/test/java/javaslang/collection/ArrayTest.java
Patch:
@@ -15,7 +15,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Collector;
-import java.util.stream.Stream;
 
 public class ArrayTest extends AbstractIndexedSeqTest {
 
@@ -52,7 +51,7 @@ protected <T> Array<T> ofAll(Iterable<? extends T> elements) {
     }
 
     @Override
-    protected <T> Array<T> ofJavaStream(Stream<? extends T> javaStream) {
+    protected <T extends Comparable<? super T>> Array<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream) {
         return Array.ofAll(javaStream);
     }
 

File: javaslang/src/test/java/javaslang/collection/BitSetTest.java
Patch:
@@ -14,7 +14,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Collector;
-import java.util.stream.Stream;
 
 import static java.util.stream.Collectors.toList;
 import static javaslang.Serializables.deserialize;
@@ -135,7 +134,7 @@ protected <T> BitSet<T> ofAll(Iterable<? extends T> elements) {
     }
 
     @Override
-    protected <T> BitSet<T> ofJavaStream(Stream<? extends T> javaStream) {
+    protected <T extends Comparable<? super T>> BitSet<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream) {
         return this.<T> bsBuilder().ofAll(javaStream);
     }
 

File: javaslang/src/test/java/javaslang/collection/HashSetTest.java
Patch:
@@ -16,7 +16,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Collector;
-import java.util.stream.Stream;
 
 import static org.junit.Assert.assertTrue;
 
@@ -120,7 +119,7 @@ protected <T> HashSet<T> ofAll(Iterable<? extends T> elements) {
     }
 
     @Override
-    protected <T> HashSet<T> ofJavaStream(Stream<? extends T> javaStream) {
+    protected <T extends Comparable<? super T>> HashSet<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream) {
         return HashSet.ofAll(javaStream);
     }
 

File: javaslang/src/test/java/javaslang/collection/IteratorTest.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Collector;
-import java.util.stream.Stream;
 
 import static javaslang.collection.Iterator.*;
 
@@ -129,7 +128,7 @@ protected <T> Iterator<T> ofAll(Iterable<? extends T> elements) {
     }
 
     @Override
-    protected <T> Iterator<T> ofJavaStream(Stream<? extends T> javaStream) {
+    protected <T extends Comparable<? super T>> Iterator<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream) {
         return Iterator.ofAll(javaStream.iterator());
     }
 

File: javaslang/src/test/java/javaslang/collection/LinkedHashSetTest.java
Patch:
@@ -9,7 +9,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Collector;
-import java.util.stream.Stream;
 
 public class LinkedHashSetTest extends AbstractSetTest {
 
@@ -61,7 +60,7 @@ protected <T> LinkedHashSet<T> ofAll(Iterable<? extends T> elements) {
     }
 
     @Override
-    protected <T> LinkedHashSet<T> ofJavaStream(Stream<? extends T> javaStream) {
+    protected <T extends Comparable<? super T>> LinkedHashSet<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream) {
         return LinkedHashSet.ofAll(javaStream);
     }
 

File: javaslang/src/test/java/javaslang/collection/ListTest.java
Patch:
@@ -19,7 +19,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Collector;
-import java.util.stream.Stream;
 
 public class ListTest extends AbstractLinearSeqTest {
 
@@ -58,7 +57,7 @@ protected <T> List<T> ofAll(Iterable<? extends T> elements) {
     }
 
     @Override
-    protected <T> List<T> ofJavaStream(Stream<? extends T> javaStream) {
+    protected <T extends Comparable<? super T>> List<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream) {
         return List.ofAll(javaStream);
     }
 

File: javaslang/src/test/java/javaslang/collection/PriorityQueueTest.java
Patch:
@@ -13,7 +13,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Collector;
-import java.util.stream.Stream;
 
 import static java.util.Comparator.comparingInt;
 import static java.util.stream.Collectors.toList;
@@ -55,7 +54,7 @@ protected <T> PriorityQueue<T> ofAll(Iterable<? extends T> elements) {
     }
 
     @Override
-    protected <T> Traversable<T> ofJavaStream(Stream<? extends T> javaStream) {
+    protected <T extends Comparable<? super T>> Traversable<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream) {
         return PriorityQueue.ofAll(naturalComparator(), javaStream);
     }
 

File: javaslang/src/test/java/javaslang/collection/QueueTest.java
Patch:
@@ -17,7 +17,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Collector;
-import java.util.stream.Stream;
 
 public class QueueTest extends AbstractLinearSeqTest {
 
@@ -56,7 +55,7 @@ protected <T> Queue<T> ofAll(Iterable<? extends T> elements) {
     }
 
     @Override
-    protected <T> Queue<T> ofJavaStream(Stream<? extends T> javaStream) {
+    protected <T extends Comparable<? super T>> Queue<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream) {
         return Queue.ofAll(javaStream);
     }
 

File: javaslang/src/test/java/javaslang/collection/StreamTest.java
Patch:
@@ -59,7 +59,7 @@ protected <T> Stream<T> ofAll(Iterable<? extends T> elements) {
     }
 
     @Override
-    protected <T> Stream<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream) {
+    protected <T extends Comparable<? super T>> Stream<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream) {
         return Stream.ofAll(javaStream);
     }
 

File: javaslang/src/test/java/javaslang/collection/TreeTest.java
Patch:
@@ -129,7 +129,7 @@ protected <T> Tree<T> ofAll(Iterable<? extends T> elements) {
     }
 
     @Override
-    protected <T> Tree<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream) {
+    protected <T extends Comparable<? super T>> Tree<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream) {
         return Tree.ofAll(javaStream);
     }
 

File: javaslang/src/test/java/javaslang/collection/VectorTest.java
Patch:
@@ -17,7 +17,6 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Collector;
-import java.util.stream.Stream;
 
 public class VectorTest extends AbstractIndexedSeqTest {
     @Override
@@ -53,7 +52,7 @@ protected <T> Vector<T> ofAll(Iterable<? extends T> elements) {
     }
 
     @Override
-    protected <T> Vector<T> ofJavaStream(Stream<? extends T> javaStream) {
+    protected <T extends Comparable<? super T>> Vector<T> ofJavaStream(java.util.stream.Stream<? extends T> javaStream) {
         return Vector.ofAll(javaStream);
     }
 

File: javaslang/src/test/java/javaslang/collection/AbstractMultimapTest.java
Patch:
@@ -201,8 +201,9 @@ protected <T> IntMultimap<T> of(T... elements) {
     @Override
     protected <T> IntMultimap<T> ofAll(Iterable<? extends T> elements) {
         Multimap<Integer, T> map = emptyMap();
+        int i = 0;
         for (T element : elements) {
-            map = map.put(map.size(), element);
+            map = map.put(i++, element);
         }
         return IntMultimap.of(map);
     }

File: javaslang/src/test/java/javaslang/collection/AbstractMultimapTest.java
Patch:
@@ -201,8 +201,9 @@ protected <T> IntMultimap<T> of(T... elements) {
     @Override
     protected <T> IntMultimap<T> ofAll(Iterable<? extends T> elements) {
         Multimap<Integer, T> map = emptyMap();
+        int i = 0;
         for (T element : elements) {
-            map = map.put(map.size(), element);
+            map = map.put(i++, element);
         }
         return IntMultimap.of(map);
     }

File: javaslang/src/main/java/javaslang/collection/HashArrayMappedTrie.java
Patch:
@@ -572,7 +572,7 @@ public LeafNode<K, V> getNext() {
 
         @Override
         public int hashCode() {
-            return Objects.hash(hash, value, tail);
+            return Objects.hash(hash, value) + tail.hashCode();
         }
 
         @Override

File: javaslang/src/test/java/javaslang/collection/HashArrayMappedTrieTest.java
Patch:
@@ -146,6 +146,7 @@ public void shouldRecognizeNonEqualityOfHAMTOfDifferentSize() {
     public void shouldEqualsIgnoreOrder() {
         HashArrayMappedTrie<String, Integer> map = HashArrayMappedTrie.<String, Integer> empty().put("Aa", 1).put("BB", 2);
         HashArrayMappedTrie<String, Integer> map2 = HashArrayMappedTrie.<String, Integer> empty().put("BB", 2).put("Aa", 1);
+        assertThat(map.hashCode()).isEqualTo(map2.hashCode());
         assertThat(map).isEqualTo(map2);
     }
 

File: javaslang/src/main/java/javaslang/collection/HashArrayMappedTrie.java
Patch:
@@ -303,7 +303,7 @@ public Iterator<LeafNode<K, V>> nodes() {
 
         @Override
         public int hashCode() {
-            return 0;
+            return 1;
         }
 
         /**

File: javaslang/src/main/java/javaslang/collection/List.java
Patch:
@@ -1651,7 +1651,7 @@ public boolean equals(Object o) {
 
         @Override
         public int hashCode() {
-            return Objects.hash(head, tail);
+            return Collections.hash(this);
         }
 
         @Override

File: javaslang/src/test/java/javaslang/AbstractValueTest.java
Patch:
@@ -1020,4 +1020,5 @@ public void shouldRecognizeUnequalObjects() {
         final Value<Integer> v2 = of(2);
         assertThat(v1.equals(v2)).isFalse();
     }
+
 }

File: javaslang/src/test/java/javaslang/collection/HashArrayMappedTrieTest.java
Patch:
@@ -154,7 +154,7 @@ public void shouldCheckHashCodeInLeafList() {
 
     @Test
     public void shouldCalculateHashCodeOfNil() {
-        assertThat(empty().hashCode()).isEqualTo(0);
+        assertThat(empty().hashCode()).isEqualTo(1);
     }
 
     @Test

File: javaslang/src/main/java/javaslang/collection/List.java
Patch:
@@ -1660,7 +1660,7 @@ public String toString() {
          * The presence of this method causes the serialization system to emit a SerializationProxy instance instead of
          * an instance of the enclosing class.
          *
-         * @return A SerialiationProxy for this enclosing class.
+         * @return A SerializationProxy for this enclosing class.
          */
         @GwtIncompatible("The Java serialization protocol is explicitly not supported")
         private Object writeReplace() {

File: javaslang/src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -1083,7 +1083,7 @@ default int size() {
      * {@code predicate} and the second element is the remainder.
      *
      * @param predicate A predicate.
-     * @return a Tuple containing the longest prefix of elements that satisfy p and the remainder.
+     * @return a {@code Tuple} containing the longest prefix of elements that satisfy p and the remainder.
      * @throws NullPointerException if {@code predicate} is null
      */
     Tuple2<? extends Traversable<T>, ? extends Traversable<T>> span(Predicate<? super T> predicate);

File: javaslang/src/main/java/javaslang/control/Validation.java
Patch:
@@ -309,7 +309,7 @@ static <E, T1, T2, T3, T4, T5, T6, T7> Builder7<E, T1, T2, T3, T4, T5, T6, T7> c
      * @param validation5 fifth validation
      * @param validation6 sixth validation
      * @param validation7 seventh validation
-     * @param validation8 eigth validation
+     * @param validation8 eighth validation
      * @return an instance of Builder3&lt;E,T1,T2,T3,T4,T5,T6,T7,T8&gt;
      * @throws NullPointerException if validation1, validation2, validation3, validation4, validation5, validation6, validation7 or validation8 is null
      */

File: javaslang/src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -479,7 +479,7 @@ default T single() {
      * <p>
      * This method should be implemented by classes only, i.e. not by interfaces.
      *
-     * @return true, if this Traversable is known to hafe a finite size, false otherwise.
+     * @return true, if this Traversable is known to have a finite size, false otherwise.
      */
     boolean hasDefiniteSize();
 
@@ -610,7 +610,7 @@ default T last() {
     }
 
     /**
-     * Dual of {@linkplain #headOption()}, returning the last element as {@code Opiton}.
+     * Dual of {@linkplain #headOption()}, returning the last element as {@code Option}.
      *
      * @return {@code Some(element)} or {@code None} if this is empty.
      */

File: javaslang/src/main/java/javaslang/collection/Tree.java
Patch:
@@ -829,7 +829,7 @@ private static String toLispString(Tree<?> tree) {
          * The presence of this method causes the serialization system to emit a SerializationProxy instance instead of
          * an instance of the enclosing class.
          *
-         * @return A SerialiationProxy for this enclosing class.
+         * @return A SerializationProxy for this enclosing class.
          */
         @GwtIncompatible("The Java serialization protocol is explicitly not supported")
         private Object writeReplace() {

File: javaslang/src/main/java/javaslang/collection/LinkedHashSet.java
Patch:
@@ -921,7 +921,7 @@ private static <T> LinkedHashMap<T, T> addAll(LinkedHashMap<T, T> initial,
      * The presence of this method causes the serialization system to emit a SerializationProxy instance instead of
      * an instance of the enclosing class.
      *
-     * @return A SerialiationProxy for this enclosing class.
+     * @return A SerializationProxy for this enclosing class.
      */
     @GwtIncompatible("The Java serialization protocol is explicitly not supported")
     private Object writeReplace() {

File: javaslang/src/main/java/javaslang/collection/Seq.java
Patch:
@@ -861,7 +861,7 @@ default int prefixLength(Predicate<? super T> predicate) {
      * {@code Tuple.of(take(n), drop(n))}.
      *
      * @param n An index.
-     * @return A Tuple containing the first n and the remaining elements.
+     * @return A {@link Tuple} containing the first n and the remaining elements.
      */
     Tuple2<? extends Seq<T>, ? extends Seq<T>> splitAt(int n);
 

File: javaslang/src/main/java/javaslang/collection/List.java
Patch:
@@ -45,7 +45,7 @@
  * </code>
  * </pre>
  *
- * Note: A {@code List} is primary a {@code Seq} and extends {@code Stack} for technical reasons (so {@code Stack} does not need to wrap {@code List}).
+ * Note: A {@code List} is primarily a {@code Seq} and extends {@code Stack} for technical reasons (so {@code Stack} does not need to wrap {@code List}).
  * <p>
  * If operating on a {@code List}, please prefer
  *

File: javaslang/src/main/java/javaslang/collection/package-info.java
Patch:
@@ -51,7 +51,7 @@
  * <br>
  * <ul>
  * <li><small>const</small>&nbsp;&middot;&nbsp;constant time</li>
- * <li><small>const<sup>a</sup></small>&nbsp;&middot;&nbsp;amotized constant time, few operations may take longer</li>
+ * <li><small>const<sup>a</sup></small>&nbsp;&middot;&nbsp;amortized constant time, few operations may take longer</li>
  * <li><small>const<sup>eff</sup></small>&nbsp;&middot;&nbsp;effectively constant time, depending on assumptions like distribution of hash keys</li>
  * <li><small>const<sup>lazy</sup></small>&nbsp;&middot;&nbsp;lazy constant time, the operation is deferred</li>
  * <li><small>log</small>&nbsp;&middot;&nbsp;logarithmic time</li>

File: javaslang/src/main/java/javaslang/collection/HashSet.java
Patch:
@@ -923,7 +923,7 @@ private static <T> HashArrayMappedTrie<T, T> addAll(HashArrayMappedTrie<T, T> in
      * The presence of this method causes the serialization system to emit a SerializationProxy instance instead of
      * an instance of the enclosing class.
      *
-     * @return A SerialiationProxy for this enclosing class.
+     * @return A SerializationProxy for this enclosing class.
      */
     @GwtIncompatible("The Java serialization protocol is explicitly not supported")
     private Object writeReplace() {

File: javaslang/src/main/java/javaslang/collection/Stream.java
Patch:
@@ -139,7 +139,7 @@ static <T> Stream<T> concat(Iterable<? extends T>... iterables) {
      * @return A new {@code Stream}
      */
     static <T> Stream<T> concat(Iterable<? extends Iterable<? extends T>> iterables) {
-        return Iterator.concat(iterables).toStream();
+        return Iterator.<T>concat(iterables).toStream();
     }
 
     /**

File: javaslang/src/main/java/javaslang/Value.java
Patch:
@@ -525,7 +525,7 @@ default CharSeq toCharSeq() {
      *
      * @return A new {@link CompletableFuture} containing the value
      */
-     default <U extends T> CompletableFuture<T> toCompletableFuture() {
+     default CompletableFuture<T> toCompletableFuture() {
          final CompletableFuture<T> completableFuture = new CompletableFuture<>();
          try {
              completableFuture.complete(get());

File: javaslang/src/main/java/javaslang/concurrent/Future.java
Patch:
@@ -499,7 +499,7 @@ static <T> Future<T> successful(ExecutorService executorService, T result) {
     }
 
     @Override
-    default <U extends T> CompletableFuture<T> toCompletableFuture() {
+    default CompletableFuture<T> toCompletableFuture() {
         final CompletableFuture<T> future = new CompletableFuture<>();
         onSuccess(future::complete);
         onFailure(future::completeExceptionally);

File: javaslang/src/main/java/javaslang/Value.java
Patch:
@@ -525,7 +525,7 @@ default CharSeq toCharSeq() {
      *
      * @return A new {@link CompletableFuture} containing the value
      */
-     default <U extends T> CompletableFuture<T> toCompletableFuture() {
+     default CompletableFuture<T> toCompletableFuture() {
          final CompletableFuture<T> completableFuture = new CompletableFuture<>();
          try {
              completableFuture.complete(get());

File: javaslang/src/main/java/javaslang/concurrent/Future.java
Patch:
@@ -499,7 +499,7 @@ static <T> Future<T> successful(ExecutorService executorService, T result) {
     }
 
     @Override
-    default <U extends T> CompletableFuture<T> toCompletableFuture() {
+    default CompletableFuture<T> toCompletableFuture() {
         final CompletableFuture<T> future = new CompletableFuture<>();
         onSuccess(future::complete);
         onFailure(future::completeExceptionally);

File: javaslang/src/main/java/javaslang/collection/Stream.java
Patch:
@@ -139,7 +139,7 @@ static <T> Stream<T> concat(Iterable<? extends T>... iterables) {
      * @return A new {@code Stream}
      */
     static <T> Stream<T> concat(Iterable<? extends Iterable<? extends T>> iterables) {
-        return Iterator.concat(iterables).toStream();
+        return Iterator.<T>concat(iterables).toStream();
     }
 
     /**

File: javaslang/src/test/java/javaslang/collection/VectorPropertyTest.java
Patch:
@@ -16,7 +16,6 @@
 import java.util.function.Predicate;
 
 import static javaslang.API.Tuple;
-import static javaslang.API.Vector;
 import static javaslang.collection.BitMappedTrie.BRANCHING_FACTOR;
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -229,7 +228,7 @@ public void shouldBehaveLikeArray() {
                 Seq<Tuple2<Seq<Object>, Vector<Object>>> history = Array.empty();
 
                 if (percent(random) < 20) {
-                    expected = Array.ofAll(Vector(randomValues(random, 100)).filter(v -> ((Object) v) instanceof Integer));
+                    expected = Array.ofAll(Vector.ofAll(randomValues(random, 100)).filter(v -> v instanceof Integer));
                     actual = (percent(random) < 30) ? Vector.narrow(Vector.ofAll(ArrayType.<int[]> asPrimitives(int.class, expected))) : Vector.ofAll(expected);
                     assertAreEqual(expected, actual);
                     history = history.append(Tuple(expected, actual));

File: javaslang/src/test/java/javaslang/collection/VectorPropertyTest.java
Patch:
@@ -16,7 +16,6 @@
 import java.util.function.Predicate;
 
 import static javaslang.API.Tuple;
-import static javaslang.API.Vector;
 import static javaslang.collection.BitMappedTrie.BRANCHING_FACTOR;
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -229,7 +228,7 @@ public void shouldBehaveLikeArray() {
                 Seq<Tuple2<Seq<Object>, Vector<Object>>> history = Array.empty();
 
                 if (percent(random) < 20) {
-                    expected = Array.ofAll(Vector(randomValues(random, 100)).filter(v -> ((Object) v) instanceof Integer));
+                    expected = Array.ofAll(Vector.ofAll(randomValues(random, 100)).filter(v -> v instanceof Integer));
                     actual = (percent(random) < 30) ? Vector.narrow(Vector.ofAll(ArrayType.<int[]> asPrimitives(int.class, expected))) : Vector.ofAll(expected);
                     assertAreEqual(expected, actual);
                     history = history.append(Tuple(expected, actual));

File: javaslang/src/main/java/javaslang/collection/Collections.java
Patch:
@@ -15,8 +15,6 @@
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 
-import static javaslang.API.Array;
-import static javaslang.API.List;
 import static javaslang.collection.ArrayType.asArray;
 
 /**
@@ -252,7 +250,7 @@ static <T> IterableWithSize<T> withSize(Iterable<? extends T> iterable) {
         } else if (isTraversableAgain(iterable)) {
             return new IterableWithSize<>(iterable, ((Traversable<?>) iterable).size());
         } else {
-            final List<? extends T> list = List(iterable);
+            final List<? extends T> list = List.ofAll(iterable);
             return new IterableWithSize<>(list, list.size());
         }
     }

File: javaslang/src/test/java/javaslang/collection/VectorPropertyTest.java
Patch:
@@ -229,7 +229,7 @@ public void shouldBehaveLikeArray() {
                 Seq<Tuple2<Seq<Object>, Vector<Object>>> history = Array.empty();
 
                 if (percent(random) < 20) {
-                    expected = Array.ofAll(Vector(randomValues(random, 100)).filter(v -> v instanceof Integer));
+                    expected = Array.ofAll(Vector(randomValues(random, 100)).filter(v -> ((Object) v) instanceof Integer));
                     actual = (percent(random) < 30) ? Vector.narrow(Vector.ofAll(ArrayType.<int[]> asPrimitives(int.class, expected))) : Vector.ofAll(expected);
                     assertAreEqual(expected, actual);
                     history = history.append(Tuple(expected, actual));

File: javaslang/src/main/java/javaslang/collection/Collections.java
Patch:
@@ -15,8 +15,6 @@
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 
-import static javaslang.API.Array;
-import static javaslang.API.List;
 import static javaslang.collection.ArrayType.asArray;
 
 /**
@@ -252,7 +250,7 @@ static <T> IterableWithSize<T> withSize(Iterable<? extends T> iterable) {
         } else if (isTraversableAgain(iterable)) {
             return new IterableWithSize<>(iterable, ((Traversable<?>) iterable).size());
         } else {
-            final List<? extends T> list = List(iterable);
+            final List<? extends T> list = List.ofAll(iterable);
             return new IterableWithSize<>(list, list.size());
         }
     }

File: javaslang/src/test/java/javaslang/collection/VectorPropertyTest.java
Patch:
@@ -229,7 +229,7 @@ public void shouldBehaveLikeArray() {
                 Seq<Tuple2<Seq<Object>, Vector<Object>>> history = Array.empty();
 
                 if (percent(random) < 20) {
-                    expected = Array.ofAll(Vector(randomValues(random, 100)).filter(v -> v instanceof Integer));
+                    expected = Array.ofAll(Vector(randomValues(random, 100)).filter(v -> ((Object) v) instanceof Integer));
                     actual = (percent(random) < 30) ? Vector.narrow(Vector.ofAll(ArrayType.<int[]> asPrimitives(int.class, expected))) : Vector.ofAll(expected);
                     assertAreEqual(expected, actual);
                     history = history.append(Tuple(expected, actual));

File: javaslang/src/main/java/javaslang/collection/Collections.java
Patch:
@@ -64,7 +64,7 @@ static <C extends Traversable<T>, T> C fill(int n, Supplier<? extends T> s, C em
     static <T, C, R extends Iterable<T>> Map<C, R> groupBy(Traversable<T> source, Function<? super T, ? extends C> classifier, Function<? super Iterable<T>, R> mapper) {
         Objects.requireNonNull(classifier, "classifier is null");
         Objects.requireNonNull(mapper, "mapper is null");
-        final java.util.Map<C, Collection<T>> mutableResults = new java.util.LinkedHashMap<>();
+        final java.util.Map<C, Collection<T>> mutableResults = new java.util.LinkedHashMap<>(source.isTraversableAgain() ? source.size() : 16);
         for (T value : source) {
             final C key = classifier.apply(value);
             mutableResults.computeIfAbsent(key, k -> new ArrayList<>()).add(value);

File: javaslang/src/main/java/javaslang/collection/IndexedSeq.java
Patch:
@@ -255,6 +255,9 @@ default int segmentLength(Predicate<? super T> predicate, int from) {
         return i - from;
     }
 
+    @Override
+    IndexedSeq<T> shuffle();
+
     @Override
     IndexedSeq<T> slice(int beginIndex, int endIndex);
 

File: javaslang/src/main/java/javaslang/collection/LinearSeq.java
Patch:
@@ -203,6 +203,9 @@ default Iterator<T> reverseIterator() {
         return reverse().iterator();
     }
 
+    @Override
+    LinearSeq<T> shuffle();
+
     @Override
     LinearSeq<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation);
 

File: javaslang-test/src/main/java/javaslang/test/Gen.java
Patch:
@@ -212,12 +212,12 @@ static <T> Gen<T> choose(T... values) {
      */
     static <T> Gen<T> choose(Iterable<T> values) {
         Objects.requireNonNull(values, "values is null");
-        final Stream<T> stream = Stream.ofAll(values);
-        if (stream.isEmpty()) {
+        final Iterator<T> iterator = Iterator.ofAll(values);
+        if (!iterator.hasNext()) {
             throw new IllegalArgumentException("Empty iterable");
         }
         @SuppressWarnings("unchecked")
-        final T[] array = stream.toJavaArray((Class<T>) stream.head().getClass());
+        final T[] array = (T[]) iterator.toJavaArray();
         return choose(array);
     }
 

File: javaslang/src/main/java/javaslang/collection/Collections.java
Patch:
@@ -221,7 +221,7 @@ static <T> Iterator<T> reverseIterator(Iterable<T> iterable) {
         } else if (iterable instanceof Seq) {
             return ((Seq<T>) iterable).reverseIterator();
         } else {
-            return Iterator.ofAll(iterable).foldLeft(List.<T> empty(), List::prepend).iterator();
+            return Iterator.ofAll(iterable).foldLeft(List.<T>empty(), List::prepend).iterator();
         }
     }
 }

File: javaslang/src/main/java/javaslang/collection/TreeSet.java
Patch:
@@ -779,7 +779,7 @@ public TreeSet<T> retainAll(Iterable<? extends T> elements) {
     @Override
     public TreeSet<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation) {
         Objects.requireNonNull(operation, "operation is null");
-        return Collections.scanLeft(this, zero, operation, it -> TreeSet.ofAll(comparator(), it) );
+        return Collections.scanLeft(this, zero, operation, it -> TreeSet.ofAll(comparator(), it));
     }
 
     @Override

File: javaslang/src/test/java/javaslang/collection/AbstractTraversableTest.java
Patch:
@@ -970,12 +970,12 @@ public void shouldComputeMaxOfBigDecimal() {
 
     @Test(expected = NullPointerException.class)
     public void shouldThrowNPEWhenMaxOfNullAndInt() {
-        System.out.println(of(null, 1).max());
+        of(null, 1).max();
     }
 
     @Test(expected = NullPointerException.class)
     public void shouldThrowNPEWhenMaxOfIntAndNull() {
-        System.out.println(of(1, null).max());
+        of(1, null).max();
     }
 
     // -- maxBy(Comparator)
@@ -1101,7 +1101,7 @@ public void shouldThrowNPEWhenMinOfNullAndInt() {
 
     @Test(expected = NullPointerException.class)
     public void shouldThrowNPEWhenMinOfIntAndNull() {
-        System.out.println(of(1, null).min());
+        of(1, null).min();
     }
 
     // -- minBy(Comparator)

File: javaslang/src/test/java/javaslang/collection/PriorityQueueTest.java
Patch:
@@ -155,7 +155,7 @@ public void shouldScanWithNonComparable() {
 
     @SuppressWarnings("unchecked")
     @Test
-    public final void shouldNarrowPriorityQueue() {
+    public void shouldNarrowPriorityQueue() {
         final PriorityQueue<Double> doubles = PriorityQueue.of(toStringComparator(), 1.0d);
         final PriorityQueue<Number> numbers = PriorityQueue.narrow(doubles);
         final int actual = numbers.enqueue(new BigDecimal("2.0")).sum().intValue();

File: javaslang/src-gen/main/java/javaslang/API.java
Patch:
@@ -781,7 +781,7 @@ public static <L, R> Either<L, R> Left(L left) {
     }
 
     /**
-     * Alias for {@link Future#of(CheckedSupplier)}
+     * Alias for {@link Future#of(Try.CheckedSupplier)}
      *
      * @param <T>         Type of the computation result.
      * @param computation A computation.
@@ -793,7 +793,7 @@ public static <T> Future<T> Future(CheckedSupplier<? extends T> computation) {
     }
 
     /**
-     * Alias for {@link Future#of(ExecutorService, CheckedSupplier)}
+     * Alias for {@link Future#of(ExecutorService, Try.CheckedSupplier)}
      *
      * @param <T>             Type of the computation result.
      * @param executorService An executor service.

File: javaslang/src/main/java/javaslang/control/Validation.java
Patch:
@@ -522,7 +522,7 @@ default <E2, T2> Validation<E2, T2> bimap(Function<? super E, ? extends E2> erro
      * Applies a function f to the error of this Validation if this is an Invalid. Otherwise does nothing
      * if this is a Valid.
      *
-     * @deprecated  replaced by {@link #mapError()}
+     * @deprecated  replaced by {@link #mapError(Function)}
      * @param <U> type of the error resulting from the mapping
      * @param f   a function that maps the error in this Invalid
      * @return an instance of Validation&lt;U,T&gt;

File: javaslang/src/test/java/javaslang/AbstractValueTest.java
Patch:
@@ -240,7 +240,8 @@ public void shouldConvertToArray() {
     public void shouldConvertToCharSeq() {
         final Value<Integer> value = of(1, 2, 3);
         final CharSeq charSeq = value.toCharSeq();
-        assertThat(charSeq).isEqualTo(CharSeq.of(value.toString()));
+        final CharSeq expected = CharSeq.of(of(1, 2, 3).iterator().mkString());
+        assertThat(charSeq).isEqualTo(expected);
     }
 
     @Test

File: javaslang/src/test/java/javaslang/AbstractValueTest.java
Patch:
@@ -239,7 +239,8 @@ public void shouldConvertToArray() {
     public void shouldConvertToCharSeq() {
         final Value<Integer> value = of(1, 2, 3);
         final CharSeq charSeq = value.toCharSeq();
-        assertThat(charSeq).isEqualTo(CharSeq.of(value.toString()));
+        final CharSeq expected = CharSeq.of(of(1, 2, 3).iterator().mkString());
+        assertThat(charSeq).isEqualTo(expected);
     }
 
     @Test

File: javaslang/src-gen/main/java/javaslang/API.java
Patch:
@@ -781,7 +781,7 @@ public static <L, R> Either<L, R> Left(L left) {
     }
 
     /**
-     * Alias for {@link Future#of(CheckedSupplier)}
+     * Alias for {@link Future#of(Try.CheckedSupplier)}
      *
      * @param <T>         Type of the computation result.
      * @param computation A computation.
@@ -793,7 +793,7 @@ public static <T> Future<T> Future(CheckedSupplier<? extends T> computation) {
     }
 
     /**
-     * Alias for {@link Future#of(ExecutorService, CheckedSupplier)}
+     * Alias for {@link Future#of(ExecutorService, Try.CheckedSupplier)}
      *
      * @param <T>             Type of the computation result.
      * @param executorService An executor service.

File: javaslang/src/main/java/javaslang/control/Validation.java
Patch:
@@ -522,7 +522,7 @@ default <E2, T2> Validation<E2, T2> bimap(Function<? super E, ? extends E2> erro
      * Applies a function f to the error of this Validation if this is an Invalid. Otherwise does nothing
      * if this is a Valid.
      *
-     * @deprecated  replaced by {@link #mapError()}
+     * @deprecated  replaced by {@link #mapError(Function)}
      * @param <U> type of the error resulting from the mapping
      * @param f   a function that maps the error in this Invalid
      * @return an instance of Validation&lt;U,T&gt;

File: javaslang/src/main/java/javaslang/collection/AbstractMultimap.java
Patch:
@@ -28,9 +28,6 @@
  */
 abstract class AbstractMultimap<K, V, M extends Multimap<K, V>> implements Multimap<K, V> {
 
-    interface SerializableSupplier<T> extends Supplier<T>, Serializable {
-    }
-
     private static final long serialVersionUID = 1L;
 
     protected final Map<K, Traversable<V>> back;
@@ -509,4 +506,7 @@ public java.util.Map<K, Collection<V>> toJavaMap() {
         }
         return javaMap;
     }
+
+    interface SerializableSupplier<T> extends Supplier<T>, Serializable {
+    }
 }

File: javaslang/src/main/java/javaslang/Value.java
Patch:
@@ -907,7 +907,7 @@ default <L> Either<L, T> toEither(Supplier<? extends L> leftSupplier) {
      */
     default <L> Validation<L, T> toValidation(L invalid) {
         if (this instanceof Validation) {
-            return ((Validation<?, T>) this).leftMap(ignored -> invalid);
+            return ((Validation<?, T>) this).mapError(ignored -> invalid);
         } else {
             return isEmpty() ? Invalid(invalid) : Valid(get());
         }
@@ -922,7 +922,7 @@ default <L> Validation<L, T> toValidation(L invalid) {
     default <L> Validation<L, T> toValidation(Supplier<? extends L> invalidSupplier) {
         Objects.requireNonNull(invalidSupplier, "invalidSupplier is null");
         if (this instanceof Validation) {
-            return ((Validation<?, T>) this).leftMap(ignored -> invalidSupplier.get());
+            return ((Validation<?, T>) this).mapError(ignored -> invalidSupplier.get());
         } else {
             return isEmpty() ? Invalid(invalidSupplier.get()) : Valid(get());
         }

File: javaslang/src/main/java/javaslang/collection/AbstractMultimap.java
Patch:
@@ -323,7 +323,7 @@ public M merge(Multimap<? extends K, ? extends V> that) {
         } else if (that.isEmpty()) {
             return (M) this;
         } else {
-            return that.foldLeft((M) this, (map, entry) -> !map.contains((Tuple2<K, V>) entry) ? (M) map.put(entry) : map);
+            return that.foldLeft((M) this, (map, entry) -> (M) map.put(entry));
         }
     }
 

File: javaslang/src/main/java/javaslang/collection/Multimap.java
Patch:
@@ -147,7 +147,7 @@ default Traversable<V> apply(K key) {
 
     @Override
     default boolean contains(Tuple2<K, V> element) {
-        return get(element._1).map(v -> Objects.equals(v, element._2)).getOrElse(false);
+        return get(element._1).map(v -> v.contains(element._2)).getOrElse(false);
     }
 
     /**

File: javaslang/src/test/java/javaslang/collection/AbstractMultimapTest.java
Patch:
@@ -354,13 +354,13 @@ public void shouldFindValue() {
 
     @Test
     public void shouldRecognizeNotContainedKeyValuePair() {
-        final TreeMap<String, Integer> testee = TreeMap.of(Tuple.of("one", 1));
+        final Multimap<String, Integer> testee = mapOf("one", 1);
         assertThat(testee.contains(Tuple.of("one", 0))).isFalse();
     }
 
     @Test
     public void shouldRecognizeContainedKeyValuePair() {
-        final TreeMap<String, Integer> testee = TreeMap.of(Tuple.of("one", 1));
+        final Multimap<String, Integer> testee = mapOf("one", 1);
         assertThat(testee.contains(Tuple.of("one", 1))).isTrue();
     }
 

File: javaslang/src/main/java/javaslang/Value.java
Patch:
@@ -907,7 +907,7 @@ default <L> Either<L, T> toEither(Supplier<? extends L> leftSupplier) {
      */
     default <L> Validation<L, T> toValidation(L invalid) {
         if (this instanceof Validation) {
-            return ((Validation<?, T>) this).leftMap(ignored -> invalid);
+            return ((Validation<?, T>) this).mapError(ignored -> invalid);
         } else {
             return isEmpty() ? Invalid(invalid) : Valid(get());
         }
@@ -922,7 +922,7 @@ default <L> Validation<L, T> toValidation(L invalid) {
     default <L> Validation<L, T> toValidation(Supplier<? extends L> invalidSupplier) {
         Objects.requireNonNull(invalidSupplier, "invalidSupplier is null");
         if (this instanceof Validation) {
-            return ((Validation<?, T>) this).leftMap(ignored -> invalidSupplier.get());
+            return ((Validation<?, T>) this).mapError(ignored -> invalidSupplier.get());
         } else {
             return isEmpty() ? Invalid(invalidSupplier.get()) : Valid(get());
         }

File: javaslang/src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -945,7 +945,7 @@ default Option<T> reduceRightOption(BiFunction<? super T, ? super T, ? extends T
      *
      * @param currentElement An element to be substituted.
      * @param newElement     A replacement for currentElement.
-     * @return a Traversable containing all elements of this where the first occurrence of currentElement is replaced with newELement.
+     * @return a Traversable containing all elements of this where the first occurrence of currentElement is replaced with newElement.
      */
     Traversable<T> replace(T currentElement, T newElement);
 
@@ -954,7 +954,7 @@ default Option<T> reduceRightOption(BiFunction<? super T, ? super T, ? extends T
      *
      * @param currentElement An element to be substituted.
      * @param newElement     A replacement for currentElement.
-     * @return a Traversable containing all elements of this where all occurrences of currentElement are replaced with newELement.
+     * @return a Traversable containing all elements of this where all occurrences of currentElement are replaced with newElement.
      */
     Traversable<T> replaceAll(T currentElement, T newElement);
 

File: javaslang/src/main/java/javaslang/collection/Map.java
Patch:
@@ -543,7 +543,7 @@ default <U> U transform(Function<? super Map<K, V>, ? extends U> f) {
 
     default <U> Seq<U> traverse(BiFunction<K, V, ? extends U> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
-        return foldLeft(List.empty(), (acc, entry) -> acc.append(mapper.apply(entry._1, entry._2)));
+        return foldLeft(Vector.empty(), (acc, entry) -> acc.append(mapper.apply(entry._1, entry._2)));
     }
 
     default Tuple2<Seq<K>, Seq<V>> unzip() {

File: javaslang/src/main/java/javaslang/collection/Multimap.java
Patch:
@@ -455,7 +455,7 @@ default <U> U transform(Function<? super Multimap<K, V>, ? extends U> f) {
 
     default <U> Seq<U> traverse(BiFunction<K, V, ? extends U> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
-        return foldLeft(List.empty(), (acc, entry) -> acc.append(mapper.apply(entry._1, entry._2)));
+        return foldLeft(Vector.empty(), (acc, entry) -> acc.append(mapper.apply(entry._1, entry._2)));
     }
 
     default <T1, T2> Tuple2<Seq<T1>, Seq<T2>> unzip(BiFunction<? super K, ? super V, Tuple2<? extends T1, ? extends T2>> unzipper) {

File: javaslang/src/test/java/javaslang/LazyTest.java
Patch:
@@ -51,14 +51,14 @@ public void shouldMemoizeValues() {
     public void shouldSequenceEmpty() {
         final List<Lazy<Integer>> testee = List.empty();
         final Lazy<Seq<Integer>> sequence = Lazy.sequence(testee);
-        assertThat(sequence.get()).isEqualTo(Stream.empty());
+        assertThat(sequence.get()).isEqualTo(Vector.empty());
     }
 
     @Test
     public void shouldSequenceNonEmptyLazy() {
         final List<Lazy<Integer>> testee = List.of(1, 2, 3).map(i -> Lazy.of(() -> i));
         final Lazy<Seq<Integer>> sequence = Lazy.sequence(testee);
-        assertThat(sequence.get()).isEqualTo(Stream.of(1, 2, 3));
+        assertThat(sequence.get()).isEqualTo(Vector.of(1, 2, 3));
     }
 
     @Test

File: javaslang/src/main/java/javaslang/collection/LinkedHashMap.java
Patch:
@@ -609,7 +609,7 @@ public java.util.LinkedHashMap<K, V> toJavaMap() {
 
     @Override
     public Seq<V> values() {
-        return map.values();
+        return map(t -> t._2);
     }
 
     @Override

File: javaslang/src/main/java/javaslang/collection/LinkedHashMap.java
Patch:
@@ -609,7 +609,7 @@ public java.util.LinkedHashMap<K, V> toJavaMap() {
 
     @Override
     public Seq<V> values() {
-        return map.values();
+        return map(t -> t._2);
     }
 
     @Override

File: javaslang/src/main/java/javaslang/collection/ArrayType.java
Patch:
@@ -12,7 +12,7 @@
  * @author Pap Lrinc
  * @since 2.1.0
  */
-final class Arrays {
+final class ArrayType {
     private static final Object[] EMPTY = {};
     static Object[] empty() { return EMPTY; }
 

File: javaslang/src/main/java/javaslang/collection/Vector.java
Patch:
@@ -14,7 +14,7 @@
 import java.util.function.*;
 import java.util.stream.Collector;
 
-import static javaslang.collection.Arrays.asArray;
+import static javaslang.collection.ArrayType.asArray;
 import static javaslang.collection.Collections.areEqual;
 import static javaslang.collection.Collections.seq;
 

File: javaslang/src/test/java/javaslang/collection/CharSeqTest.java
Patch:
@@ -1238,7 +1238,7 @@ public void shouldSlideNonNilBySize1() {
                 .isEqualTo(List.of(of('1'), of('2'), of('3')));
     }
 
-    @Test // #201
+    @Test
     public void shouldSlideNonNilBySize2() {
         assertThat(of('1', '2', '3', '4', '5').sliding(2).toList())
                 .isEqualTo(List.of(of('1', '2'), of('2', '3'), of('3', '4'), of('4', '5')));

File: javaslang/src/test/java/javaslang/collection/CharSeqTest.java
Patch:
@@ -1238,7 +1238,7 @@ public void shouldSlideNonNilBySize1() {
                 .isEqualTo(List.of(of('1'), of('2'), of('3')));
     }
 
-    @Test // #201
+    @Test
     public void shouldSlideNonNilBySize2() {
         assertThat(of('1', '2', '3', '4', '5').sliding(2).toList())
                 .isEqualTo(List.of(of('1', '2'), of('2', '3'), of('3', '4'), of('4', '5')));

File: javaslang-gwt/src/test/java/client/CollectionsTestGwt.java
Patch:
@@ -60,7 +60,8 @@ public void testCompileTreeSet() {
         applyCollection(chars -> TreeSet.ofAll(Iterator.ofAll(chars)));
     }
 
+    @SuppressWarnings("Convert2MethodRef")
     public void testCompileVector() {
-        applyCollection(Vector::ofAll);
+        applyCollection(chars -> Vector.ofAll(chars));
     }
 }
\ No newline at end of file

File: javaslang-gwt/src/test/java/client/GwtJavaslangTestSuite.java
Patch:
@@ -9,7 +9,7 @@
 import junit.framework.Test;
 import junit.framework.TestCase;
 
-public class JavaslangGwtTestSuite extends TestCase {
+public class GwtJavaslangTestSuite extends TestCase {
 
     public static Test suite() {
         GWTTestSuite suite = new GWTTestSuite("Javaslang test suite.");

File: javaslang-gwt/src/test/java/client/CollectionsTestGwt.java
Patch:
@@ -6,7 +6,7 @@
 import javaslang.Tuple1;
 import javaslang.collection.*;
 
-public class GwtTestCollections extends GWTTestCase {
+public class CollectionsTestGwt extends GWTTestCase {
 
     @Override
     public String getModuleName() {

File: javaslang-gwt/src/test/java/client/ConcurrentTestGwt.java
Patch:
@@ -12,7 +12,7 @@
 
 import java.util.concurrent.atomic.AtomicBoolean;
 
-public class GwtTestConcurrent extends GWTTestCase {
+public class ConcurrentTestGwt extends GWTTestCase {
 
     @Override public String getModuleName()  {
         return "TestModule";

File: javaslang/src/main/java/javaslang/concurrent/Future.java
Patch:
@@ -306,7 +306,7 @@ static <T> Future<T> of(CheckedSupplier<? extends T> computation) {
      * @param computation     A computation.
      * @param <T>             Type of the computation result.
      * @return A new Future instance.
-     * @throws NullPointerException if one of executorService of computation is null.
+     * @throws NullPointerException if one of executorService or computation is null.
      */
     static <T> Future<T> of(ExecutorService executorService, CheckedSupplier<? extends T> computation) {
         Objects.requireNonNull(executorService, "executorService is null");
@@ -373,7 +373,7 @@ static Future<Void> run(CheckedRunnable unit) {
      * @param executorService An executor service.
      * @param unit            A unit of work.
      * @return A new Future instance which results in nothing.
-     * @throws NullPointerException if one of executorService of unit is null.
+     * @throws NullPointerException if one of executorService or unit is null.
      */
     static Future<Void> run(ExecutorService executorService, CheckedRunnable unit) {
         Objects.requireNonNull(executorService, "executorService is null");

File: javaslang/src/main/java/javaslang/concurrent/Future.java
Patch:
@@ -306,7 +306,7 @@ static <T> Future<T> of(CheckedSupplier<? extends T> computation) {
      * @param computation     A computation.
      * @param <T>             Type of the computation result.
      * @return A new Future instance.
-     * @throws NullPointerException if one of executorService of computation is null.
+     * @throws NullPointerException if one of executorService or computation is null.
      */
     static <T> Future<T> of(ExecutorService executorService, CheckedSupplier<? extends T> computation) {
         Objects.requireNonNull(executorService, "executorService is null");
@@ -373,7 +373,7 @@ static Future<Void> run(CheckedRunnable unit) {
      * @param executorService An executor service.
      * @param unit            A unit of work.
      * @return A new Future instance which results in nothing.
-     * @throws NullPointerException if one of executorService of unit is null.
+     * @throws NullPointerException if one of executorService or unit is null.
      */
     static Future<Void> run(ExecutorService executorService, CheckedRunnable unit) {
         Objects.requireNonNull(executorService, "executorService is null");

File: javaslang-test/src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -88,6 +88,7 @@ default Arbitrary<T> distinctBy(Comparator<? super T> comparator) {
     /**
      * Returns an Arbitrary based on this Arbitrary which produces unique values based on the given function.
      *
+     * @param <U>          key type
      * @param keyExtractor A function
      * @return A new generator
      */

File: javaslang/src-gen/main/java/javaslang/Function0.java
Patch:
@@ -119,6 +119,8 @@ default int arity() {
      * Returns a function that always returns the constant
      * value that you give in parameter.
      *
+
+     * @param <R> the result type
      * @param value the value to be returned
      * @return a function always returning the given value
      */

File: javaslang/src-gen/main/java/javaslang/Function1.java
Patch:
@@ -125,6 +125,8 @@ default int arity() {
      * Returns a function that always returns the constant
      * value that you give in parameter.
      *
+     * @param <T1> generic parameter type 1 of the resulting function
+     * @param <R> the result type
      * @param value the value to be returned
      * @return a function always returning the given value
      */

File: javaslang/src-gen/main/java/javaslang/Function2.java
Patch:
@@ -131,6 +131,9 @@ default int arity() {
      * Returns a function that always returns the constant
      * value that you give in parameter.
      *
+     * @param <T1> generic parameter type 1 of the resulting function
+     * @param <T2> generic parameter type 2 of the resulting function
+     * @param <R> the result type
      * @param value the value to be returned
      * @return a function always returning the given value
      */

File: javaslang/src-gen/main/java/javaslang/Tuple1.java
Patch:
@@ -90,6 +90,7 @@ public T1 _1() {
     /**
      * Sets the 1st element of this tuple to the given {@code value}.
      *
+     * @param value the new value
      * @return a copy of this tuple with a new value for the 1st element of this Tuple.
      */
     public Tuple1<T1> update1(T1 value) {

File: javaslang/src-gen/main/java/javaslang/Tuple2.java
Patch:
@@ -111,6 +111,7 @@ public T1 _1() {
     /**
      * Sets the 1st element of this tuple to the given {@code value}.
      *
+     * @param value the new value
      * @return a copy of this tuple with a new value for the 1st element of this Tuple.
      */
     public Tuple2<T1, T2> update1(T1 value) {
@@ -129,6 +130,7 @@ public T2 _2() {
     /**
      * Sets the 2nd element of this tuple to the given {@code value}.
      *
+     * @param value the new value
      * @return a copy of this tuple with a new value for the 2nd element of this Tuple.
      */
     public Tuple2<T1, T2> update2(T2 value) {

File: javaslang/src-gen/main/java/javaslang/Tuple3.java
Patch:
@@ -126,6 +126,7 @@ public T1 _1() {
     /**
      * Sets the 1st element of this tuple to the given {@code value}.
      *
+     * @param value the new value
      * @return a copy of this tuple with a new value for the 1st element of this Tuple.
      */
     public Tuple3<T1, T2, T3> update1(T1 value) {
@@ -144,6 +145,7 @@ public T2 _2() {
     /**
      * Sets the 2nd element of this tuple to the given {@code value}.
      *
+     * @param value the new value
      * @return a copy of this tuple with a new value for the 2nd element of this Tuple.
      */
     public Tuple3<T1, T2, T3> update2(T2 value) {
@@ -162,6 +164,7 @@ public T3 _3() {
     /**
      * Sets the 3rd element of this tuple to the given {@code value}.
      *
+     * @param value the new value
      * @return a copy of this tuple with a new value for the 3rd element of this Tuple.
      */
     public Tuple3<T1, T2, T3> update3(T3 value) {

File: javaslang/src/main/java/javaslang/Lazy.java
Patch:
@@ -25,7 +25,7 @@
 /**
  * Represents a lazy evaluated value. Compared to a Supplier, Lazy is memoizing, i.e. it evaluates only once and
  * therefore is referential transparent.
- * <p>
+ *
  * <pre>
  * <code>
  * final Lazy&lt;Double&gt; l = Lazy.of(Math::random);
@@ -35,9 +35,9 @@
  * l.get();         // = 0.123 (memoized)
  * </code>
  * </pre>
- * <p>
+ *
  * Since 2.0.0 you may also create a <em>real</em> lazy value (works only with interfaces):
- * <p>
+ *
  * <pre><code>final CharSequence chars = Lazy.val(() -&gt; "Yay!", CharSequence.class);</code></pre>
  *
  * @author Daniel Dietrich

File: javaslang/src/main/java/javaslang/collection/Foldable.java
Patch:
@@ -14,7 +14,7 @@
  * Interface of foldable data structures.
  * <p>
  * <strong>Example:</strong>
- * <p>
+ *
  * <pre><code>
  * // = "123"
  * Stream.of("1", "2", "3").fold("", (a1, a2) -&gt; a1 + a2);

File: javaslang/src/main/java/javaslang/collection/HashSet.java
Patch:
@@ -88,7 +88,7 @@ public static <T> HashSet<T> of(T element) {
 
     /**
      * Creates a HashSet of the given elements.
-     * <p>
+     *
      * <pre><code>HashSet.of(1, 2, 3, 4)</code></pre>
      *
      * @param <T>      Component type of the HashSet.

File: javaslang/src/main/java/javaslang/collection/LinkedHashSet.java
Patch:
@@ -88,7 +88,7 @@ public static <T> LinkedHashSet<T> of(T element) {
 
     /**
      * Creates a LinkedHashSet of the given elements.
-     * <p>
+     *
      * <pre><code>LinkedHashSet.of(1, 2, 3, 4)</code></pre>
      *
      * @param <T>      Component type of the LinkedHashSet.

File: javaslang/src/main/java/javaslang/collection/PriorityQueue.java
Patch:
@@ -565,7 +565,7 @@ protected static <T> Node<T> of(T value, int rank, Seq<Node<T>> children) {
                 return new Node<>(value, rank, children);
             }
 
-            /**
+            /*
              * fun link (t1 as Node (x1,r1,c1), t2 as Node (x2,r2,c2)) = ( r1 = r2 )
              * *  if Elem.leq (x1,x2) then Node (x1,r1+1,t2 :: c1)
              * *  else                     Node (x2,r2+1,t1 :: c2
@@ -578,12 +578,12 @@ protected Node<T> link(SerializableComparator<? super T> comparator, Node<T> tre
                         : of(tree.root, tree.rank + 1, this.appendTo(tree.children));
             }
 
-            /**
+            /*
              * fun skewLink (t0 as Node (x0,r0, _), t1 as Node (x1,r1,c1), t2 as Node (x2,r2,c2)) =
              * *  if Elem.leq (x1,x0) andalso Elem.leq (x1,x2) then      Node (x1,r1+1,t0 :: t2 :: c1)
              * *  else if Elem.leq (x2,x0) andalso Elem.leq (x2,x1) then Node (x2,r2+1,t0 :: t1 :: c2)
              * *  else                                                   Node (x0,r1+1,[t1, t2])
-             **/
+             */
             protected Node<T> skewLink(SerializableComparator<? super T> comparator, Node<T> left, Node<T> right) {
                 assert rank == 0 && left.rank == right.rank;
 

File: javaslang-test/src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -88,6 +88,7 @@ default Arbitrary<T> distinctBy(Comparator<? super T> comparator) {
     /**
      * Returns an Arbitrary based on this Arbitrary which produces unique values based on the given function.
      *
+     * @param <U>          key type
      * @param keyExtractor A function
      * @return A new generator
      */

File: javaslang/src-gen/main/java/javaslang/Function0.java
Patch:
@@ -119,6 +119,8 @@ default int arity() {
      * Returns a function that always returns the constant
      * value that you give in parameter.
      *
+
+     * @param <R> the result type
      * @param value the value to be returned
      * @return a function always returning the given value
      */

File: javaslang/src-gen/main/java/javaslang/Function1.java
Patch:
@@ -125,6 +125,8 @@ default int arity() {
      * Returns a function that always returns the constant
      * value that you give in parameter.
      *
+     * @param <T1> generic parameter type 1 of the resulting function
+     * @param <R> the result type
      * @param value the value to be returned
      * @return a function always returning the given value
      */

File: javaslang/src-gen/main/java/javaslang/Function2.java
Patch:
@@ -131,6 +131,9 @@ default int arity() {
      * Returns a function that always returns the constant
      * value that you give in parameter.
      *
+     * @param <T1> generic parameter type 1 of the resulting function
+     * @param <T2> generic parameter type 2 of the resulting function
+     * @param <R> the result type
      * @param value the value to be returned
      * @return a function always returning the given value
      */

File: javaslang/src-gen/main/java/javaslang/Tuple1.java
Patch:
@@ -90,6 +90,7 @@ public T1 _1() {
     /**
      * Sets the 1st element of this tuple to the given {@code value}.
      *
+     * @param value the new value
      * @return a copy of this tuple with a new value for the 1st element of this Tuple.
      */
     public Tuple1<T1> update1(T1 value) {

File: javaslang/src-gen/main/java/javaslang/Tuple2.java
Patch:
@@ -111,6 +111,7 @@ public T1 _1() {
     /**
      * Sets the 1st element of this tuple to the given {@code value}.
      *
+     * @param value the new value
      * @return a copy of this tuple with a new value for the 1st element of this Tuple.
      */
     public Tuple2<T1, T2> update1(T1 value) {
@@ -129,6 +130,7 @@ public T2 _2() {
     /**
      * Sets the 2nd element of this tuple to the given {@code value}.
      *
+     * @param value the new value
      * @return a copy of this tuple with a new value for the 2nd element of this Tuple.
      */
     public Tuple2<T1, T2> update2(T2 value) {

File: javaslang/src-gen/main/java/javaslang/Tuple3.java
Patch:
@@ -126,6 +126,7 @@ public T1 _1() {
     /**
      * Sets the 1st element of this tuple to the given {@code value}.
      *
+     * @param value the new value
      * @return a copy of this tuple with a new value for the 1st element of this Tuple.
      */
     public Tuple3<T1, T2, T3> update1(T1 value) {
@@ -144,6 +145,7 @@ public T2 _2() {
     /**
      * Sets the 2nd element of this tuple to the given {@code value}.
      *
+     * @param value the new value
      * @return a copy of this tuple with a new value for the 2nd element of this Tuple.
      */
     public Tuple3<T1, T2, T3> update2(T2 value) {
@@ -162,6 +164,7 @@ public T3 _3() {
     /**
      * Sets the 3rd element of this tuple to the given {@code value}.
      *
+     * @param value the new value
      * @return a copy of this tuple with a new value for the 3rd element of this Tuple.
      */
     public Tuple3<T1, T2, T3> update3(T3 value) {

File: javaslang/src/main/java/javaslang/Lazy.java
Patch:
@@ -25,7 +25,7 @@
 /**
  * Represents a lazy evaluated value. Compared to a Supplier, Lazy is memoizing, i.e. it evaluates only once and
  * therefore is referential transparent.
- * <p>
+ *
  * <pre>
  * <code>
  * final Lazy&lt;Double&gt; l = Lazy.of(Math::random);
@@ -35,9 +35,9 @@
  * l.get();         // = 0.123 (memoized)
  * </code>
  * </pre>
- * <p>
+ *
  * Since 2.0.0 you may also create a <em>real</em> lazy value (works only with interfaces):
- * <p>
+ *
  * <pre><code>final CharSequence chars = Lazy.val(() -&gt; "Yay!", CharSequence.class);</code></pre>
  *
  * @author Daniel Dietrich

File: javaslang/src/main/java/javaslang/collection/Foldable.java
Patch:
@@ -14,7 +14,7 @@
  * Interface of foldable data structures.
  * <p>
  * <strong>Example:</strong>
- * <p>
+ *
  * <pre><code>
  * // = "123"
  * Stream.of("1", "2", "3").fold("", (a1, a2) -&gt; a1 + a2);

File: javaslang/src/main/java/javaslang/collection/HashSet.java
Patch:
@@ -88,7 +88,7 @@ public static <T> HashSet<T> of(T element) {
 
     /**
      * Creates a HashSet of the given elements.
-     * <p>
+     *
      * <pre><code>HashSet.of(1, 2, 3, 4)</code></pre>
      *
      * @param <T>      Component type of the HashSet.

File: javaslang/src/main/java/javaslang/collection/LinkedHashSet.java
Patch:
@@ -88,7 +88,7 @@ public static <T> LinkedHashSet<T> of(T element) {
 
     /**
      * Creates a LinkedHashSet of the given elements.
-     * <p>
+     *
      * <pre><code>LinkedHashSet.of(1, 2, 3, 4)</code></pre>
      *
      * @param <T>      Component type of the LinkedHashSet.

File: javaslang/src/main/java/javaslang/collection/PriorityQueue.java
Patch:
@@ -565,7 +565,7 @@ protected static <T> Node<T> of(T value, int rank, Seq<Node<T>> children) {
                 return new Node<>(value, rank, children);
             }
 
-            /**
+            /*
              * fun link (t1 as Node (x1,r1,c1), t2 as Node (x2,r2,c2)) = ( r1 = r2 )
              * *  if Elem.leq (x1,x2) then Node (x1,r1+1,t2 :: c1)
              * *  else                     Node (x2,r2+1,t1 :: c2
@@ -578,12 +578,12 @@ protected Node<T> link(SerializableComparator<? super T> comparator, Node<T> tre
                         : of(tree.root, tree.rank + 1, this.appendTo(tree.children));
             }
 
-            /**
+            /*
              * fun skewLink (t0 as Node (x0,r0, _), t1 as Node (x1,r1,c1), t2 as Node (x2,r2,c2)) =
              * *  if Elem.leq (x1,x0) andalso Elem.leq (x1,x2) then      Node (x1,r1+1,t0 :: t2 :: c1)
              * *  else if Elem.leq (x2,x0) andalso Elem.leq (x2,x1) then Node (x2,r2+1,t0 :: t1 :: c2)
              * *  else                                                   Node (x0,r1+1,[t1, t2])
-             **/
+             */
             protected Node<T> skewLink(SerializableComparator<? super T> comparator, Node<T> left, Node<T> right) {
                 assert rank == 0 && left.rank == right.rank;
 

File: javaslang/src/main/java/javaslang/collection/Array.java
Patch:
@@ -742,7 +742,7 @@ public int indexOf(T element, int from) {
     @Override
     public Array<T> init() {
         if (isEmpty()) {
-            throw new UnsupportedOperationException("init of empty vector");
+            throw new UnsupportedOperationException("init of empty Array");
         }
         return dropRight(1);
     }
@@ -764,7 +764,7 @@ private Object readResolve() {
     @Override
     public Array<T> insert(int index, T element) {
         if (index < 0 || index > length()) {
-            throw new IndexOutOfBoundsException("insert(" + index + ", e) on Vector of length " + length());
+            throw new IndexOutOfBoundsException("insert(" + index + ", e) on Array of length " + length());
         }
         final Object[] arr = new Object[delegate.length + 1];
         System.arraycopy(delegate, 0, arr, 0, index);

File: javaslang/src/main/java/javaslang/collection/Array.java
Patch:
@@ -742,7 +742,7 @@ public int indexOf(T element, int from) {
     @Override
     public Array<T> init() {
         if (isEmpty()) {
-            throw new UnsupportedOperationException("init of empty vector");
+            throw new UnsupportedOperationException("init of empty Array");
         }
         return dropRight(1);
     }
@@ -764,7 +764,7 @@ private Object readResolve() {
     @Override
     public Array<T> insert(int index, T element) {
         if (index < 0 || index > length()) {
-            throw new IndexOutOfBoundsException("insert(" + index + ", e) on Vector of length " + length());
+            throw new IndexOutOfBoundsException("insert(" + index + ", e) on Array of length " + length());
         }
         final Object[] arr = new Object[delegate.length + 1];
         System.arraycopy(delegate, 0, arr, 0, index);

File: javaslang-gwt/src/test/java/client/GwtTestCollections.java
Patch:
@@ -15,6 +15,7 @@ public String getModuleName() {
 
     public void testTuple() {
         Tuple1<Integer> t = Tuple.of(1);
+        assertEquals((int) t._1, 1);
         assertEquals((int) t._1(), 1);
     }
 

File: javaslang/src-gen/test/java/javaslang/Tuple1Test.java
Patch:
@@ -34,13 +34,13 @@ public void shouldGetArity() {
     @Test
     public void shouldReturnElements() {
         final Tuple1<Integer> tuple = createIntTuple(1);
-        assertThat(tuple._1()).isEqualTo(1);
+        assertThat(tuple._1).isEqualTo(1);
     }
 
     @Test
     public void shouldUpdate1() {
       final Tuple1<Integer> tuple = createIntTuple(1).update1(42);
-      assertThat(tuple._1()).isEqualTo(42);
+      assertThat(tuple._1).isEqualTo(42);
     }
 
     @Test

File: javaslang/src/main/java/javaslang/collection/Collections.java
Patch:
@@ -73,7 +73,7 @@ public static <K, V, K2, U extends Map<K2, V>> U mapKeys(Map<K, V> source, U zer
         Objects.requireNonNull(keyMapper, "keyMapper is null");
         Objects.requireNonNull(valueMerge, "valueMerge is null");
         return source.foldLeft(zero, (acc, entry) -> {
-            final K2 k2 = keyMapper.apply(entry._1());
+            final K2 k2 = keyMapper.apply(entry._1);
             final V v2 = entry._2;
             final Option<V> v1 = acc.get(k2);
             final V v = v1.isDefined() ? valueMerge.apply(v1.get(), v2) : v2;

File: javaslang/src/main/java/javaslang/collection/LinkedHashMap.java
Patch:
@@ -427,7 +427,7 @@ public LinkedHashMap<K, V> put(K key, V value) {
         Queue<Tuple2<K, V>> newList = list;
         HashMap<K, V> newMap = map;
         if (containsKey(key)) {
-            newList = newList.filter(t -> !t._1.equals(key));
+            newList = newList.filter(t -> !Objects.equals(t._1, key));
             newMap = newMap.remove(key);
         }
         newList = newList.append(Tuple.of(key, value));
@@ -449,7 +449,7 @@ public <U extends V> LinkedHashMap<K, V> put(Tuple2<? extends K, U> entry,
     @Override
     public LinkedHashMap<K, V> remove(K key) {
         if (containsKey(key)) {
-            final Queue<Tuple2<K, V>> newList = list.removeFirst(t -> t._1.equals(key));
+            final Queue<Tuple2<K, V>> newList = list.removeFirst(t -> Objects.equals(t._1, key));
             final HashMap<K, V> newMap = map.remove(key);
             return wrap(newList, newMap);
         } else {

File: javaslang-gwt/src/test/java/client/GwtTestCollections.java
Patch:
@@ -15,6 +15,7 @@ public String getModuleName() {
 
     public void testTuple() {
         Tuple1<Integer> t = Tuple.of(1);
+        assertEquals((int) t._1, 1);
         assertEquals((int) t._1(), 1);
     }
 

File: javaslang/src-gen/test/java/javaslang/Tuple1Test.java
Patch:
@@ -34,13 +34,13 @@ public void shouldGetArity() {
     @Test
     public void shouldReturnElements() {
         final Tuple1<Integer> tuple = createIntTuple(1);
-        assertThat(tuple._1()).isEqualTo(1);
+        assertThat(tuple._1).isEqualTo(1);
     }
 
     @Test
     public void shouldUpdate1() {
       final Tuple1<Integer> tuple = createIntTuple(1).update1(42);
-      assertThat(tuple._1()).isEqualTo(42);
+      assertThat(tuple._1).isEqualTo(42);
     }
 
     @Test

File: javaslang/src/main/java/javaslang/collection/Collections.java
Patch:
@@ -73,7 +73,7 @@ public static <K, V, K2, U extends Map<K2, V>> U mapKeys(Map<K, V> source, U zer
         Objects.requireNonNull(keyMapper, "keyMapper is null");
         Objects.requireNonNull(valueMerge, "valueMerge is null");
         return source.foldLeft(zero, (acc, entry) -> {
-            final K2 k2 = keyMapper.apply(entry._1());
+            final K2 k2 = keyMapper.apply(entry._1);
             final V v2 = entry._2;
             final Option<V> v1 = acc.get(k2);
             final V v = v1.isDefined() ? valueMerge.apply(v1.get(), v2) : v2;

File: javaslang/src/main/java/javaslang/collection/LinkedHashMap.java
Patch:
@@ -427,7 +427,7 @@ public LinkedHashMap<K, V> put(K key, V value) {
         Queue<Tuple2<K, V>> newList = list;
         HashMap<K, V> newMap = map;
         if (containsKey(key)) {
-            newList = newList.filter(t -> !t._1.equals(key));
+            newList = newList.filter(t -> !Objects.equals(t._1, key));
             newMap = newMap.remove(key);
         }
         newList = newList.append(Tuple.of(key, value));
@@ -449,7 +449,7 @@ public <U extends V> LinkedHashMap<K, V> put(Tuple2<? extends K, U> entry,
     @Override
     public LinkedHashMap<K, V> remove(K key) {
         if (containsKey(key)) {
-            final Queue<Tuple2<K, V>> newList = list.removeFirst(t -> t._1.equals(key));
+            final Queue<Tuple2<K, V>> newList = list.removeFirst(t -> Objects.equals(t._1, key));
             final HashMap<K, V> newMap = map.remove(key);
             return wrap(newList, newMap);
         } else {

File: javaslang/src/main/java/javaslang/control/Try.java
Patch:
@@ -942,7 +942,7 @@ private NonFatalException(Throwable exception) {
          * @throws Error                if the given exception is fatal, i.e. not recoverable
          * @throws NullPointerException if exception is null
          */
-        public static NonFatalException of(Throwable exception) {
+        static NonFatalException of(Throwable exception) {
             Objects.requireNonNull(exception, "exception is null");
             if (exception instanceof NonFatalException) {
                 return (NonFatalException) exception;

File: javaslang/src/main/java/javaslang/collection/List.java
Patch:
@@ -1039,7 +1039,7 @@ default List<T> remove(T element) {
         boolean found = false;
         while (!found && !result.isEmpty()) {
             final T head = result.head();
-            if (head.equals(element)) {
+            if (Objects.equals(head, element)) {
                 found = true;
             } else {
                 preceding.addFirst(head);

File: javaslang/src/main/java/javaslang/control/Validation.java
Patch:
@@ -70,10 +70,8 @@ public interface Validation<E, T> extends Value<T> {
      * @param <T>   type of the given {@code value}
      * @param value A value
      * @return {@code Valid(value)}
-     * @throws NullPointerException if value is null
      */
     static <E, T> Validation<E, T> valid(T value) {
-        Objects.requireNonNull(value, "value is null");
         return new Valid<>(value);
     }
 

File: javaslang/src-gen/main/java/javaslang/Tuple2.java
Patch:
@@ -152,7 +152,7 @@ public Tuple2<T2, T1> swap() {
      * element is the value.
      */
     public Map.Entry<T1, T2> toEntry() {
-         return new AbstractMap.SimpleEntry<>(_1, _2);
+        return new AbstractMap.SimpleEntry<>(_1, _2);
     }
 
     /**

File: javaslang/src-gen/test/java/javaslang/Tuple2Test.java
Patch:
@@ -94,7 +94,7 @@ public void shouldSwap() {
 
     @Test
     public void shouldConvertToEntry() {
-        Tuple2<Integer, Integer> tuple= createIntTuple(1,2);
+        Tuple2<Integer, Integer> tuple = createIntTuple(1,2);
         Map.Entry<Integer, Integer> entry = new AbstractMap.SimpleEntry<>(1, 2);
         assertThat(tuple.toEntry().equals(entry));
     }

File: javaslang/src/main/java/javaslang/concurrent/Future.java
Patch:
@@ -50,7 +50,7 @@ public interface Future<T> extends Value<T> {
 
     /**
      * The default executor service is {@link Executors#newCachedThreadPool()}.
-     * Please note that it may prevent the VM from shutdown.}
+     * Please note that it may prevent the VM from shutdown.
      */
     ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();
 

File: javaslang/src/main/java/javaslang/concurrent/Future.java
Patch:
@@ -50,7 +50,7 @@ public interface Future<T> extends Value<T> {
 
     /**
      * The default executor service is {@link Executors#newCachedThreadPool()}.
-     * Please note that it may prevent the VM from shutdown.}
+     * Please note that it may prevent the VM from shutdown.
      */
     ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();
 

File: javaslang/src/main/java/javaslang/Lazy.java
Patch:
@@ -53,7 +53,7 @@ private Lazy(Supplier<? extends T> supplier) {
 
     /**
      * Narrows a widened {@code Lazy<? extends T>} to {@code Lazy<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param lazy A {@code Lazy}.

File: javaslang/src/main/java/javaslang/Value.java
Patch:
@@ -128,7 +128,7 @@ public interface Value<T> extends Iterable<T> {
 
     /**
      * Narrows a widened {@code Value<? extends T>} to {@code Value<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param value A {@code Value}.

File: javaslang/src/main/java/javaslang/collection/Array.java
Patch:
@@ -66,7 +66,7 @@ public static <T> Array<T> empty() {
 
     /**
      * Narrows a widened {@code Array<? extends T>} to {@code Array<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param array An {@code Array}.

File: javaslang/src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -63,7 +63,7 @@ public static <K, V> HashMap<K, V> empty() {
 
     /**
      * Narrows a widened {@code HashMap<? extends K, ? extends V>} to {@code HashMap<K, V>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param hashMap A {@code HashMap}.

File: javaslang/src/main/java/javaslang/collection/HashSet.java
Patch:
@@ -63,7 +63,7 @@ public static <T> Collector<T, ArrayList<T>, HashSet<T>> collector() {
 
     /**
      * Narrows a widened {@code HashSet<? extends T>} to {@code HashSet<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param hashSet A {@code HashSet}.

File: javaslang/src/main/java/javaslang/collection/IndexedSeq.java
Patch:
@@ -29,7 +29,7 @@ public interface IndexedSeq<T> extends Seq<T> {
 
     /**
      * Narrows a widened {@code IndexedSeq<? extends T>} to {@code IndexedSeq<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param indexedSeq An {@code IndexedSeq}.

File: javaslang/src/main/java/javaslang/collection/Iterator.java
Patch:
@@ -114,7 +114,7 @@ static <T> Iterator<T> empty() {
 
     /**
      * Narrows a widened {@code Iterator<? extends T>} to {@code Iterator<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param iterator An {@code Iterator}.

File: javaslang/src/main/java/javaslang/collection/LinearSeq.java
Patch:
@@ -28,7 +28,7 @@ public interface LinearSeq<T> extends Seq<T> {
 
     /**
      * Narrows a widened {@code LinearSeq<? extends T>} to {@code LinearSeq<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param linearSeq A {@code LinearSeq}.

File: javaslang/src/main/java/javaslang/collection/LinkedHashMap.java
Patch:
@@ -63,7 +63,7 @@ public static <K, V> LinkedHashMap<K, V> empty() {
 
     /**
      * Narrows a widened {@code LinkedHashMap<? extends K, ? extends V>} to {@code LinkedHashMap<K, V>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param linkedHashMap A {@code LinkedHashMap}.

File: javaslang/src/main/java/javaslang/collection/LinkedHashSet.java
Patch:
@@ -63,7 +63,7 @@ public static <T> Collector<T, ArrayList<T>, LinkedHashSet<T>> collector() {
 
     /**
      * Narrows a widened {@code LinkedHashSet<? extends T>} to {@code LinkedHashSet<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param linkedHashSet A {@code LinkedHashSet}.

File: javaslang/src/main/java/javaslang/collection/List.java
Patch:
@@ -126,7 +126,7 @@ static <T> List<T> empty() {
 
     /**
      * Narrows a widened {@code List<? extends T>} to {@code List<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param list A {@code List}.

File: javaslang/src/main/java/javaslang/collection/PriorityQueue.java
Patch:
@@ -149,7 +149,7 @@ public static <T> Collector<T, ArrayList<T>, PriorityQueue<T>> collector() {
 
     /**
      * Narrows a widened {@code PriorityQueue<? extends T>} to {@code PriorityQueue<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param queue An {@code PriorityQueue}.

File: javaslang/src/main/java/javaslang/collection/Queue.java
Patch:
@@ -95,7 +95,7 @@ public static <T> Queue<T> empty() {
 
     /**
      * Narrows a widened {@code Queue<? extends T>} to {@code Queue<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param queue An {@code Queue}.

File: javaslang/src/main/java/javaslang/collection/Set.java
Patch:
@@ -31,7 +31,7 @@ public interface Set<T> extends Traversable<T>, Function1<T, Boolean> {
 
     /**
      * Narrows a widened {@code Set<? extends T>} to {@code Set<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param set A {@code Set}.

File: javaslang/src/main/java/javaslang/collection/SortedMap.java
Patch:
@@ -26,7 +26,7 @@ public interface SortedMap<K, V> extends Map<K, V> {
 
     /**
      * Narrows a widened {@code SortedMap<? extends K, ? extends V>} to {@code SortedMap<K, V>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      * <p>
      * CAUTION: If {@code K} is narrowed, the underlying {@code Comparator} might fail!

File: javaslang/src/main/java/javaslang/collection/SortedSet.java
Patch:
@@ -29,7 +29,7 @@ public interface SortedSet<T> extends Set<T> {
 
     /**
      * Narrows a widened {@code SortedSet<? extends T>} to {@code SortedSet<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      * <p>
      * CAUTION: The underlying {@code Comparator} might fail!

File: javaslang/src/main/java/javaslang/collection/Stack.java
Patch:
@@ -37,7 +37,7 @@ public interface Stack<T> {
 
     /**
      * Narrows a widened {@code Stack<? extends T>} to {@code Stack<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param stack A {@code Stack}.

File: javaslang/src/main/java/javaslang/collection/Stream.java
Patch:
@@ -220,7 +220,7 @@ static <T> Stream<T> empty() {
 
     /**
      * Narrows a widened {@code Stream<? extends T>} to {@code Stream<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param stream A {@code Stream}.

File: javaslang/src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -139,7 +139,7 @@ public interface Traversable<T> extends Foldable<T>, Value<T> {
 
     /**
      * Narrows a widened {@code Traversable<? extends T>} to {@code Traversable<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param traversable An {@code Traversable}.

File: javaslang/src/main/java/javaslang/collection/Tree.java
Patch:
@@ -61,7 +61,7 @@ static <T> Empty<T> empty() {
 
     /**
      * Narrows a widened {@code Tree<? extends T>} to {@code Tree<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param tree An {@code Tree}.

File: javaslang/src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -102,7 +102,7 @@ public static <K, V> TreeMap<K, V> empty(Comparator<? super K> keyComparator) {
 
     /**
      * Narrows a widened {@code TreeMap<? extends K, ? extends V>} to {@code TreeMap<K, V>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      * <p>
      * CAUTION: If {@code K} is narrowed, the underlying {@code Comparator} might fail!

File: javaslang/src/main/java/javaslang/collection/TreeSet.java
Patch:
@@ -83,7 +83,7 @@ public static <T> TreeSet<T> empty(Comparator<? super T> comparator) {
 
     /**
      * Narrows a widened {@code TreeSet<? extends T>} to {@code TreeSet<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      * <p>
      * CAUTION: The underlying {@code Comparator} might fail!

File: javaslang/src/main/java/javaslang/collection/Vector.java
Patch:
@@ -81,7 +81,7 @@ public static <T> Collector<T, ArrayList<T>, Vector<T>> collector() {
 
     /**
      * Narrows a widened {@code Vector<? extends T>} to {@code Vector<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param vector An {@code Vector}.

File: javaslang/src/main/java/javaslang/concurrent/Future.java
Patch:
@@ -275,7 +275,7 @@ static <T> Future<T> fromTry(ExecutorService executorService, Try<? extends T> r
 
     /**
      * Narrows a widened {@code Future<? extends T>} to {@code Future<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param future A {@code Future}.

File: javaslang/src/main/java/javaslang/concurrent/Promise.java
Patch:
@@ -145,7 +145,7 @@ static <T> Promise<T> make(ExecutorService executorService) {
 
     /**
      * Narrows a widened {@code Promise<? extends T>} to {@code Promise<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param promise A {@code Promise}.

File: javaslang/src/main/java/javaslang/control/Either.java
Patch:
@@ -70,7 +70,7 @@ static <L, R> Either<L, R> left(L left) {
 
     /**
      * Narrows a widened {@code Either<? extends L, ? extends R>} to {@code Either<L, R>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param either A {@code Either}.

File: javaslang/src/main/java/javaslang/control/Option.java
Patch:
@@ -106,7 +106,7 @@ static Option<Void> nothing() {
 
     /**
      * Narrows a widened {@code Option<? extends T>} to {@code Option<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param option A {@code Option}.
@@ -151,12 +151,12 @@ static <T> Option<T> when(boolean condition, T value) {
      * @param <T>      type of the value
      * @return {@code Some(optional.get())} if value is Java {@code Optional} is present, {@code None} otherwise
      */
+    @SuppressWarnings("OptionalUsedAsFieldOrParameterType")
     static <T> Option<T> ofOptional(Optional<? extends T> optional) {
         Objects.requireNonNull(optional, "optional is null");
         return optional.isPresent() ? of(optional.get()) : none();
     }
 
-
     /**
      * Returns true, if this is {@code None}, otherwise false, if this is {@code Some}.
      *

File: javaslang/src/main/java/javaslang/control/Try.java
Patch:
@@ -102,7 +102,7 @@ static <T> Try<T> failure(Throwable exception) {
 
     /**
      * Narrows a widened {@code Try<? extends T>} to {@code Try<T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param t   A {@code Try}.

File: javaslang/src/main/java/javaslang/control/Validation.java
Patch:
@@ -132,7 +132,7 @@ static <E, T> Validation<List<E>, Seq<T>> sequence(Iterable<? extends Validation
 
     /**
      * Narrows a widened {@code Validation<? extends E, ? extends T>} to {@code Validation<E, T>}
-     * by performing a type safe-cast. This is eligible because immutable/read-only
+     * by performing a type-safe cast. This is eligible because immutable/read-only
      * collections are covariant.
      *
      * @param validation A {@code Validation}.

File: javaslang/src/test/java/javaslang/concurrent/PromiseTest.java
Patch:
@@ -9,6 +9,7 @@
 import org.junit.Test;
 
 import static javaslang.concurrent.Concurrent.zZz;
+import static javaslang.concurrent.ExecutorServices.trivialExecutorService;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class PromiseTest {
@@ -68,7 +69,7 @@ public void shouldConvertToString() {
 
     @Test
     public void shouldCompletePromiseWithItsOwnFuture() {
-        final Promise<String> promise = Promise.make(TrivialExecutorService.instance());
+        final Promise<String> promise = Promise.make(trivialExecutorService());
         promise.completeWith(promise.future());
         assertThat(promise.isCompleted()).isFalse();
         assertThat(promise.success("ok").isCompleted()).isTrue();

File: javaslang/src-gen/test/java/javaslang/Tuple8Test.java
Patch:
@@ -215,12 +215,12 @@ public void shouldMap8thComponent() {
       assertThat(actual).isEqualTo(expected);
     }
 
-    @Test(expected = RuntimeException.class)
+    @Test(expected = UnsupportedOperationException.class)
     public void shouldAppendTuple8() {
         Tuple.of(1, 2, 3, 4, 5, 6, 7, 8).append(42);
     }
 
-    @Test(expected = RuntimeException.class)
+    @Test(expected = UnsupportedOperationException.class)
     public void shouldPrependTuple8() {
         Tuple.of(1, 2, 3, 4, 5, 6, 7, 8).prepend(42);
     }

File: javaslang/src/main/java/javaslang/concurrent/FutureImpl.java
Patch:
@@ -9,6 +9,7 @@
 import javaslang.control.*;
 import javaslang.control.Try.CheckedSupplier;
 
+import java.io.Serializable;
 import java.util.Objects;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutorService;

File: javaslang/src/main/java/javaslang/collection/AbstractMultimap.java
Patch:
@@ -363,7 +363,7 @@ public M peek(Consumer<? super Tuple2<K, V>> action) {
     public M replace(Tuple2<K, V> currentElement, Tuple2<K, V> newElement) {
         Objects.requireNonNull(currentElement, "currentElement is null");
         Objects.requireNonNull(newElement, "newElement is null");
-        return (M) (containsKey(currentElement._1) ? remove(currentElement._1).put(newElement) : this);
+        return (M) (containsKey(currentElement._1) ? remove(currentElement._1, currentElement._2).put(newElement) : this);
     }
 
     @Override

File: javaslang/src/main/java/javaslang/collection/AbstractMultimap.java
Patch:
@@ -363,7 +363,7 @@ public M peek(Consumer<? super Tuple2<K, V>> action) {
     public M replace(Tuple2<K, V> currentElement, Tuple2<K, V> newElement) {
         Objects.requireNonNull(currentElement, "currentElement is null");
         Objects.requireNonNull(newElement, "newElement is null");
-        return (M) (containsKey(currentElement._1) ? remove(currentElement._1).put(newElement) : this);
+        return (M) (containsKey(currentElement._1) ? remove(currentElement._1, currentElement._2).put(newElement) : this);
     }
 
     @Override

File: javaslang/src/test/java/javaslang/collection/euler/Utils.java
Patch:
@@ -17,6 +17,7 @@
 import static javaslang.API.$;
 import static javaslang.API.Case;
 import javaslang.Function1;
+import static javaslang.collection.euler.PrimeNumbers.primes;
 
 public final class Utils {
 
@@ -48,9 +49,7 @@ public static Stream<Long> divisors(long l) {
     public static boolean isPrime(long val) {
         return API.Match(val).of(
                 Case($(2L), true),
-                Case($(3L), true),
-                Case($(n -> n > 3), n -> !Stream.rangeClosedBy(3, Math.sqrt(n), 2).exists(d -> n % d == 0)),
-                Case($(), false)
+                Case($(), n -> !primes().takeWhile(d -> d <= Math.sqrt(n)).exists(d -> n % d == 0))
         );
     }
 

File: javaslang/src/main/java/javaslang/Value.java
Patch:
@@ -784,7 +784,9 @@ default <K, V> SortedMap<K, V> toSortedMap(Comparator<? super K> comparator, Fun
      */
     default <K, V> SortedMap<K, V> toSortedMap(Comparator<? super K> comparator, Function<? super T, ? extends Tuple2<? extends K, ? extends V>> f) {
         Objects.requireNonNull(f, "f is null");
-        return ValueModule.toMap(this, TreeMap.empty(comparator), t -> TreeMap.of(comparator, t), t -> TreeMap.ofEntries(comparator, t), f);
+        final Function<Tuple2<? extends K, ? extends V>, SortedMap<K, V>> ofElement = t -> TreeMap.of(comparator, t);
+        final Function<Iterable<Tuple2<? extends K, ? extends V>>, SortedMap<K, V>> ofAll = t -> TreeMap.ofEntries(comparator, t);
+        return ValueModule.toMap(this, TreeMap.empty(comparator), ofElement, ofAll, f);
     }
 
     /**

File: javaslang/src/main/java/javaslang/collection/LinkedHashSet.java
Patch:
@@ -307,6 +307,7 @@ public static LinkedHashSet<Character> rangeBy(char from, char toExclusive, int
         return LinkedHashSet.ofAll(Iterator.rangeBy(from, toExclusive, step));
     }
 
+    @GwtIncompatible
     public static LinkedHashSet<Double> rangeBy(double from, double toExclusive, double step) {
         return LinkedHashSet.ofAll(Iterator.rangeBy(from, toExclusive, step));
     }
@@ -411,6 +412,7 @@ public static LinkedHashSet<Character> rangeClosedBy(char from, char toInclusive
         return LinkedHashSet.ofAll(Iterator.rangeClosedBy(from, toInclusive, step));
     }
 
+    @GwtIncompatible
     public static LinkedHashSet<Double> rangeClosedBy(double from, double toInclusive, double step) {
         return LinkedHashSet.ofAll(Iterator.rangeClosedBy(from, toInclusive, step));
     }

File: javaslang/src/test/java/javaslang/collection/euler/Euler02Test.java
Patch:
@@ -5,6 +5,7 @@
  */
 package javaslang.collection.euler;
 
+import java.math.BigInteger;
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -31,6 +32,7 @@ public void shouldSolveProblem2() {
 
     private static long sumOfEvenFibonacciValuesNotExceeding(final int max) {
         return Utils.fibonacci()
+                .map(BigInteger::longValue)
                 .takeWhile(f -> f <= max)
                 .filter(f -> f % 2 == 0)
                 .sum().longValue();

File: javaslang/src/test/java/javaslang/collection/euler/Utils.java
Patch:
@@ -19,8 +19,8 @@ public final class Utils {
     private Utils() {
     }
 
-    public static Stream<Integer> fibonacci() {
-        return Stream.of(1, 1).appendSelf(self -> self.zip(self.tail()).map(t -> t._1 + t._2));
+    public static Stream<BigInteger> fibonacci() {
+        return Stream.of(BigInteger.ZERO, BigInteger.ONE).appendSelf(self -> self.zip(self.tail()).map(t -> t._1.add(t._2)));
     }
 
     public static BigInteger factorial(int n) {

File: javaslang/src/test/java/javaslang/collection/euler/Euler02Test.java
Patch:
@@ -5,6 +5,7 @@
  */
 package javaslang.collection.euler;
 
+import java.math.BigInteger;
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -31,6 +32,7 @@ public void shouldSolveProblem2() {
 
     private static long sumOfEvenFibonacciValuesNotExceeding(final int max) {
         return Utils.fibonacci()
+                .map(BigInteger::longValue)
                 .takeWhile(f -> f <= max)
                 .filter(f -> f % 2 == 0)
                 .sum().longValue();

File: javaslang/src/test/java/javaslang/collection/euler/Utils.java
Patch:
@@ -19,8 +19,8 @@ public final class Utils {
     private Utils() {
     }
 
-    public static Stream<Integer> fibonacci() {
-        return Stream.of(1, 1).appendSelf(self -> self.zip(self.tail()).map(t -> t._1 + t._2));
+    public static Stream<BigInteger> fibonacci() {
+        return Stream.of(BigInteger.ZERO, BigInteger.ONE).appendSelf(self -> self.zip(self.tail()).map(t -> t._1.add(t._2)));
     }
 
     public static BigInteger factorial(int n) {

File: javaslang/src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -167,7 +167,7 @@ public static <K, V> TreeMap<K, V> of(Comparator<? super K> keyComparator, Objec
      */
     public static <K extends Comparable<? super K>, V> TreeMap<K, V> ofAll(java.util.Map<? extends K, ? extends V> map) {
         Objects.requireNonNull(map, "map is null");
-        RedBlackTree<Tuple2<K, V>> result = RedBlackTree.empty();
+        RedBlackTree<Tuple2<K, V>> result = RedBlackTree.empty(new EntryComparator<>((Comparator<? super K> & Serializable) K::compareTo));
         for (java.util.Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {
             result = result.insert(Tuple.of(entry.getKey(), entry.getValue()));
         }

File: javaslang-benchmark/src/test/java/javaslang/collection/PriorityQueueBenchmark.java
Patch:
@@ -5,6 +5,7 @@
 import org.junit.Test;
 import org.openjdk.jmh.annotations.*;
 import org.openjdk.jmh.annotations.State;
+import org.openjdk.jmh.runner.options.VerboseMode;
 import scala.math.Ordering;
 import scala.math.Ordering$;
 import scalaz.*;
@@ -22,7 +23,7 @@ public class PriorityQueueBenchmark {
 
     @Test
     public void testAsserts() {
-        JmhRunner.runAndReport(CLASSES, 0, 1, 1, 1, PrintGc.Disable, Assertions.Enable); // runDebug fails with stack overflow for Scalaz, because it cannot update the jvm args, if not forked
+        JmhRunner.runAndReport(CLASSES, 0, 1, 1, 1, VerboseMode.SILENT, Assertions.Enable); // runDebug fails with stack overflow for Scalaz, because it cannot update the jvm args, if not forked
     }
 
     public static void main(String... args) {

File: javaslang-benchmark/src/test/java/javaslang/BenchmarkPerformanceReporter.java
Patch:
@@ -255,9 +255,9 @@ public RatioPerformanceReport(Array<TestExecution> results, String targetImpleme
 
             alternativeImplementations = results.map(TestExecution::getImplementation).distinct().sorted();
             targetImplementations = alternativeImplementations.filter(i -> i.toLowerCase().contains(targetImplementation.toLowerCase()));
-            alternativeImplSize = Math.max(alternativeImplementations.map(String::length).max().get(), 10);
+            alternativeImplSize = Math.max(alternativeImplementations.map(String::length).max().getOrElse(0), 10);
 
-            final int targetImplSize = Math.max(targetImplementations.map(String::length).max().get(), 10);
+            final int targetImplSize = Math.max(targetImplementations.map(String::length).max().getOrElse(0), 10);
             ratioSize = Math.max(targetImplSize + 1 + alternativeImplSize, 10);
         }
 

File: javaslang-benchmark/src/test/java/javaslang/collection/HashSetBenchmark.java
Patch:
@@ -66,7 +66,7 @@ public Object pcollections_persistent() {
         }
 
         @Benchmark
-        public Object scala_immutable() {
+        public Object scala_persistent() {
             scala.collection.immutable.HashSet<Integer> values = new scala.collection.immutable.HashSet<>();
             for (Integer element : ELEMENTS) {
                 values = values.$plus(element);

File: javaslang-benchmark/src/test/java/javaslang/collection/PriorityQueueBenchmark.java
Patch:
@@ -274,7 +274,7 @@ public Object scalaz_persistent() {
 
         @Benchmark
         @SuppressWarnings("ManualArrayToCollectionCopy")
-        public Object java_treeset() {
+        public Object java_treeset_mutable() {
             javaslang.collection.TreeMap<Integer, javaslang.collection.List<Integer>> values = javaslang.collection.TreeMap.empty();
             for (Integer element : ELEMENTS) {
                 final javaslang.collection.List<Integer> vs = values.get(element).getOrElse(javaslang.collection.List.empty()).prepend(element);

File: javaslang-benchmark/src/test/java/javaslang/MicroBenchmark.java
Patch:
@@ -1,4 +1,4 @@
-package javaslang.benchmark;
+package javaslang;
 
 import javaslang.collection.*;
 import org.junit.Test;

File: javaslang/src/main/java/javaslang/collection/AbstractMap.java
Patch:
@@ -145,19 +145,19 @@ public M filterValues(Predicate<? super V> predicate) {
     }
 
     @Override
-    public Map<K, V> removeAll(BiPredicate<? super K, ? super V> predicate) {
+    public M removeAll(BiPredicate<? super K, ? super V> predicate) {
         Objects.requireNonNull(predicate, "predicate is null");
         return filter(predicate.negate());
     }
 
     @Override
-    public Map<K, V> removeKeys(Predicate<? super K> predicate) {
+    public M removeKeys(Predicate<? super K> predicate) {
         Objects.requireNonNull(predicate, "predicate is null");
         return filterKeys(predicate.negate());
     }
 
     @Override
-    public Map<K, V> removeValues(Predicate<? super V> predicate) {
+    public M removeValues(Predicate<? super V> predicate) {
         Objects.requireNonNull(predicate, "predicate is null");
         return filterValues(predicate.negate());
     }

File: javaslang-match/src/main/java/javaslang/match/generator/Generator.java
Patch:
@@ -68,7 +68,7 @@ private static void generate(ImportManager im, ClassModel classModel, MethodMode
             body = pattern(im, 0) + ".of(" + paramTypeName + ".class)";
         } else {
             final String args = IntStream.rangeClosed(1, arity).mapToObj(i -> "p" + i).collect(joining(", "));
-            final String unapplyRef = classModel.getClassName() + "::" + name;
+            final String unapplyRef = classModel.getFullQualifiedName() + "::" + name;
             body = String.format("%s.of(%s, %s, %s)", pattern(im, arity), paramTypeName + ".class", args, unapplyRef);
         }
         final List<String> typeArgs = methodModel.getTypeParameters().stream()

File: javaslang-match/src/main/java/javaslang/match/generator/Generator.java
Patch:
@@ -68,7 +68,7 @@ private static void generate(ImportManager im, ClassModel classModel, MethodMode
             body = pattern(im, 0) + ".of(" + paramTypeName + ".class)";
         } else {
             final String args = IntStream.rangeClosed(1, arity).mapToObj(i -> "p" + i).collect(joining(", "));
-            final String unapplyRef = classModel.getClassName() + "::" + name;
+            final String unapplyRef = classModel.getFullQualifiedName() + "::" + name;
             body = String.format("%s.of(%s, %s, %s)", pattern(im, arity), paramTypeName + ".class", args, unapplyRef);
         }
         final List<String> typeArgs = methodModel.getTypeParameters().stream()

File: javaslang/src/main/java/javaslang/collection/Array.java
Patch:
@@ -496,7 +496,7 @@ public static Array<Long> rangeClosedBy(long from, long toInclusive, long step)
      * @return an Array with the values built up by the iteration
      * @throws IllegalArgumentException if {@code f} is null
      */
-    static <T,U> Array<U> unfoldRight(T seed, Function1<T,Option<Tuple2<U,T>>> f) {
+    static <T,U> Array<U> unfoldRight(T seed, Function<? super T,Option<Tuple2<? extends U, ? extends T>>> f) {
         return Iterator.unfoldRight(seed, f).toArray();
     }
 
@@ -523,7 +523,7 @@ static <T,U> Array<U> unfoldRight(T seed, Function1<T,Option<Tuple2<U,T>>> f) {
      * @return an Array with the values built up by the iteration
      * @throws IllegalArgumentException if {@code f} is null
      */
-    static <T,U> Array<U> unfoldLeft(T seed, Function<T,Option<Tuple2<T,U>>> f) {
+    static <T,U> Array<U> unfoldLeft(T seed, Function<? super T,Option<Tuple2<? extends T, ? extends U>>> f) {
         return Iterator.unfoldLeft(seed, f).toArray();
     }
 

File: javaslang/src/main/java/javaslang/collection/CharSeq.java
Patch:
@@ -239,7 +239,7 @@ public static CharSeq rangeClosedBy(char from, char toInclusive, int step) {
      * @return a CharSeq with the values built up by the iteration
      * @throws IllegalArgumentException if {@code f} is null
      */
-    static <T> CharSeq unfoldRight(T seed, Function<T,Option<Tuple2<Character, T>>> f) {
+    static <T> CharSeq unfoldRight(T seed, Function<? super T,Option<Tuple2<? extends Character, ? extends T>>> f) {
         return CharSeq.ofAll(Iterator.unfoldRight(seed, f));
     }
 
@@ -266,7 +266,7 @@ static <T> CharSeq unfoldRight(T seed, Function<T,Option<Tuple2<Character, T>>>
      * @return a CharSeq with the values built up by the iteration
      * @throws IllegalArgumentException if {@code f} is null
      */
-    static <T> CharSeq unfoldLeft(T seed, Function<T,Option<Tuple2<T,Character>>> f) {
+    static <T> CharSeq unfoldLeft(T seed, Function<? super T,Option<Tuple2<? extends T,? extends Character>>> f) {
         return CharSeq.ofAll(Iterator.unfoldLeft(seed, f));
     }
 

File: javaslang/src/main/java/javaslang/collection/Iterator.java
Patch:
@@ -1179,7 +1179,7 @@ default <T1, T2, T3> Tuple3<Iterator<T1>, Iterator<T2>, Iterator<T3>> unzip3(
      * @return a list with the values built up by the iteration
      * @throws IllegalArgumentException if {@code f} is null
      */
-    static <T,U> Iterator<U> unfoldLeft(T seed, Function<T,Option<Tuple2<T,U>>> f) {
+    static <T,U> Iterator<U> unfoldLeft(T seed, Function<? super T,Option<Tuple2<? extends T, ? extends U>>> f) {
         return Stream.ofAll(
             unfoldRight(seed, f.andThen(tupleOpt -> tupleOpt.map(t -> Tuple.of(t._2, t._1)))))
             .reverse().iterator();
@@ -1208,10 +1208,10 @@ static <T,U> Iterator<U> unfoldLeft(T seed, Function<T,Option<Tuple2<T,U>>> f) {
      * @return a list with the values built up by the iteration
      * @throws IllegalArgumentException if {@code f} is null
      */
-    static <T,U> Iterator<U> unfoldRight(T seed, Function<T,Option<Tuple2<U,T>>> f) {
+    static <T,U> Iterator<U> unfoldRight(T seed, Function<? super T,Option<Tuple2<? extends U, ? extends T>>> f) {
         Objects.requireNonNull(f, "the unfold iterating function is null");
         return new AbstractIterator<U>() {
-            private Option<Tuple2<U,T>> nextVal = f.apply(seed);
+            private Option<Tuple2<? extends U, ? extends T>> nextVal = f.apply(seed);
 
             @Override
             public boolean hasNext() {

File: javaslang/src/main/java/javaslang/collection/List.java
Patch:
@@ -578,7 +578,7 @@ static List<Long> rangeClosedBy(long from, long toInclusive, long step) {
      * @return a list with the values built up by the iteration
      * @throws IllegalArgumentException if {@code f} is null
      */
-    static <T,U> List<U> unfoldRight(T seed, Function<T,Option<Tuple2<U,T>>> f) {
+    static <T,U> List<U> unfoldRight(T seed, Function<? super T,Option<Tuple2<? extends U, ? extends T>>> f) {
         return Iterator.unfoldRight(seed, f).toList();
     }
 
@@ -605,7 +605,7 @@ static <T,U> List<U> unfoldRight(T seed, Function<T,Option<Tuple2<U,T>>> f) {
      * @return a list with the values built up by the iteration
      * @throws IllegalArgumentException if {@code f} is null
      */
-    static <T,U> List<U> unfoldLeft(T seed, Function<T,Option<Tuple2<T,U>>> f) {
+    static <T,U> List<U> unfoldLeft(T seed, Function<? super T,Option<Tuple2<? extends T, ? extends U>>> f) {
         return Iterator.unfoldLeft(seed, f).toList();
     }
 

File: javaslang/src/main/java/javaslang/collection/Queue.java
Patch:
@@ -523,7 +523,7 @@ public static Queue<Long> rangeClosedBy(long from, long toInclusive, long step)
      * @return a Queue with the values built up by the iteration
      * @throws IllegalArgumentException if {@code f} is null
      */
-    static <T,U> Queue<U> unfoldRight(T seed, Function1<T,Option<Tuple2<U,T>>> f) {
+    static <T,U> Queue<U> unfoldRight(T seed, Function<? super T,Option<Tuple2<? extends U, ? extends T>>> f) {
         return Iterator.unfoldRight(seed, f).toQueue();
     }
 
@@ -550,7 +550,7 @@ static <T,U> Queue<U> unfoldRight(T seed, Function1<T,Option<Tuple2<U,T>>> f) {
      * @return a Queue with the values built up by the iteration
      * @throws IllegalArgumentException if {@code f} is null
      */
-    static <T,U> Queue<U> unfoldLeft(T seed, Function<T,Option<Tuple2<T,U>>> f) {
+    static <T,U> Queue<U> unfoldLeft(T seed, Function<? super T,Option<Tuple2<? extends T, ? extends U>>> f) {
         return Iterator.unfoldLeft(seed, f).toQueue();
     }
 

File: javaslang/src/main/java/javaslang/collection/Stream.java
Patch:
@@ -649,7 +649,7 @@ static Stream<Long> rangeClosedBy(long from, long toInclusive, long step) {
      * @return a Stream with the values built up by the iteration
      * @throws IllegalArgumentException if {@code f} is null
      */
-    static <T,U> Stream<U> unfoldRight(T seed, Function1<T,Option<Tuple2<U,T>>> f) {
+    static <T,U> Stream<U> unfoldRight(T seed, Function<? super T,Option<Tuple2<? extends U, ? extends T>>> f) {
         return Iterator.unfoldRight(seed, f).toStream();
     }
 
@@ -676,7 +676,7 @@ static <T,U> Stream<U> unfoldRight(T seed, Function1<T,Option<Tuple2<U,T>>> f) {
      * @return a Stream with the values built up by the iteration
      * @throws IllegalArgumentException if {@code f} is null
      */
-    static <T,U> Stream<U> unfoldLeft(T seed, Function<T,Option<Tuple2<T,U>>> f) {
+    static <T,U> Stream<U> unfoldLeft(T seed, Function<? super T,Option<Tuple2<? extends T, ? extends U>>> f) {
         return Iterator.unfoldLeft(seed, f).toStream();
     }
 

File: javaslang/src/main/java/javaslang/collection/Vector.java
Patch:
@@ -497,7 +497,7 @@ public static Vector<Long> rangeClosedBy(long from, long toInclusive, long step)
      * @return a Vector with the values built up by the iteration
      * @throws IllegalArgumentException if {@code f} is null
      */
-    static <T,U> Vector<U> unfoldRight(T seed, Function1<T,Option<Tuple2<U,T>>> f) {
+    static <T,U> Vector<U> unfoldRight(T seed, Function<? super T,Option<Tuple2<? extends U, ? extends T>>> f) {
         return Iterator.unfoldRight(seed, f).toVector();
     }
 
@@ -524,7 +524,7 @@ static <T,U> Vector<U> unfoldRight(T seed, Function1<T,Option<Tuple2<U,T>>> f) {
      * @return a Vector with the values built up by the iteration
      * @throws IllegalArgumentException if {@code f} is null
      */
-    static <T,U> Vector<U> unfoldLeft(T seed, Function<T,Option<Tuple2<T,U>>> f) {
+    static <T,U> Vector<U> unfoldLeft(T seed, Function<? super T,Option<Tuple2<? extends T, ? extends U>>> f) {
         return Iterator.unfoldLeft(seed, f).toVector();
     }
 

File: javaslang/src-gen/main/java/javaslang/Function0.java
Patch:
@@ -87,8 +87,8 @@ static <R> Function0<Option<R>> lift(Function0<R> partialFunction) {
      * @return a function that applies arguments to the given {@code partialFunction} and returns {@code Success(result)}
      *         if the function is defined for the given arguments, and {@code Failure(throwable)} otherwise.
      */
-    static <R> Function0<Try<R>> liftTry(Function0<R> partialFunction) {
-        return () -> Try.of(partialFunction::apply);
+    static <R> Function0<Try<R>> liftTry(Supplier<R> partialFunction) {
+        return () -> Try.of(partialFunction::get);
     }
 
     /**

File: javaslang/src-gen/main/java/javaslang/Function1.java
Patch:
@@ -92,7 +92,7 @@ static <T1, R> Function1<T1, Option<R>> lift(Function1<T1, R> partialFunction) {
      * @return a function that applies arguments to the given {@code partialFunction} and returns {@code Success(result)}
      *         if the function is defined for the given arguments, and {@code Failure(throwable)} otherwise.
      */
-    static <T1, R> Function1<T1, Try<R>> liftTry(Function1<T1, R> partialFunction) {
+    static <T1, R> Function1<T1, Try<R>> liftTry(Function<T1, R> partialFunction) {
         return t1 -> Try.of(() -> partialFunction.apply(t1));
     }
 

File: javaslang/src-gen/main/java/javaslang/Function2.java
Patch:
@@ -97,7 +97,7 @@ static <T1, T2, R> Function2<T1, T2, Option<R>> lift(Function2<T1, T2, R> partia
      * @return a function that applies arguments to the given {@code partialFunction} and returns {@code Success(result)}
      *         if the function is defined for the given arguments, and {@code Failure(throwable)} otherwise.
      */
-    static <T1, T2, R> Function2<T1, T2, Try<R>> liftTry(Function2<T1, T2, R> partialFunction) {
+    static <T1, T2, R> Function2<T1, T2, Try<R>> liftTry(BiFunction<T1, T2, R> partialFunction) {
         return (t1, t2) -> Try.of(() -> partialFunction.apply(t1, t2));
     }
 

File: javaslang/src-gen/main/java/javaslang/CheckedFunction1.java
Patch:
@@ -158,13 +158,13 @@ default CheckedFunction1<T1, R> memoized() {
      * @return a function composed of this and recover
      * @throws NullPointerException if recover is null
      */
-    default Function1<T1, R> recover(Function<? super Throwable, ? extends Function1<T1, R>> recover) {
+    default Function1<T1, R> recover(Function<? super Throwable, ? extends Function<T1, R>> recover) {
         Objects.requireNonNull(recover, "recover is null");
         return (t1) -> {
             try {
                 return this.apply(t1);
             } catch (Throwable throwable) {
-                final Function1<T1, R> func = recover.apply(throwable);
+                final Function<T1, R> func = recover.apply(throwable);
                 Objects.requireNonNull(func, () -> String.format("recover return null for %s: %s", throwable.getClass(), throwable.getMessage()));
                 return func.apply(t1);
             }
@@ -177,7 +177,7 @@ default Function1<T1, R> recover(Function<? super Throwable, ? extends Function1
      *
      * @param exceptionMapper the function that convert function {@link Throwable} into subclass of {@link RuntimeException}
      */
-    default Function1<T1, R> unchecked(Function1<? super Throwable, ? extends RuntimeException> exceptionMapper) {
+    default Function1<T1, R> unchecked(Function<? super Throwable, ? extends RuntimeException> exceptionMapper) {
         return recover(throwable -> {
             throw exceptionMapper.apply(throwable);
         });

File: javaslang/src-gen/main/java/javaslang/CheckedFunction3.java
Patch:
@@ -199,7 +199,7 @@ default Function3<T1, T2, T3, R> recover(Function<? super Throwable, ? extends F
      *
      * @param exceptionMapper the function that convert function {@link Throwable} into subclass of {@link RuntimeException}
      */
-    default Function3<T1, T2, T3, R> unchecked(Function1<? super Throwable, ? extends RuntimeException> exceptionMapper) {
+    default Function3<T1, T2, T3, R> unchecked(Function<? super Throwable, ? extends RuntimeException> exceptionMapper) {
         return recover(throwable -> {
             throw exceptionMapper.apply(throwable);
         });

File: javaslang/src-gen/main/java/javaslang/CheckedFunction4.java
Patch:
@@ -216,7 +216,7 @@ default Function4<T1, T2, T3, T4, R> recover(Function<? super Throwable, ? exten
      *
      * @param exceptionMapper the function that convert function {@link Throwable} into subclass of {@link RuntimeException}
      */
-    default Function4<T1, T2, T3, T4, R> unchecked(Function1<? super Throwable, ? extends RuntimeException> exceptionMapper) {
+    default Function4<T1, T2, T3, T4, R> unchecked(Function<? super Throwable, ? extends RuntimeException> exceptionMapper) {
         return recover(throwable -> {
             throw exceptionMapper.apply(throwable);
         });

File: javaslang/src-gen/main/java/javaslang/CheckedFunction5.java
Patch:
@@ -234,7 +234,7 @@ default Function5<T1, T2, T3, T4, T5, R> recover(Function<? super Throwable, ? e
      *
      * @param exceptionMapper the function that convert function {@link Throwable} into subclass of {@link RuntimeException}
      */
-    default Function5<T1, T2, T3, T4, T5, R> unchecked(Function1<? super Throwable, ? extends RuntimeException> exceptionMapper) {
+    default Function5<T1, T2, T3, T4, T5, R> unchecked(Function<? super Throwable, ? extends RuntimeException> exceptionMapper) {
         return recover(throwable -> {
             throw exceptionMapper.apply(throwable);
         });

File: javaslang/src-gen/main/java/javaslang/CheckedFunction6.java
Patch:
@@ -253,7 +253,7 @@ default Function6<T1, T2, T3, T4, T5, T6, R> recover(Function<? super Throwable,
      *
      * @param exceptionMapper the function that convert function {@link Throwable} into subclass of {@link RuntimeException}
      */
-    default Function6<T1, T2, T3, T4, T5, T6, R> unchecked(Function1<? super Throwable, ? extends RuntimeException> exceptionMapper) {
+    default Function6<T1, T2, T3, T4, T5, T6, R> unchecked(Function<? super Throwable, ? extends RuntimeException> exceptionMapper) {
         return recover(throwable -> {
             throw exceptionMapper.apply(throwable);
         });

File: javaslang/src-gen/main/java/javaslang/CheckedFunction7.java
Patch:
@@ -273,7 +273,7 @@ default Function7<T1, T2, T3, T4, T5, T6, T7, R> recover(Function<? super Throwa
      *
      * @param exceptionMapper the function that convert function {@link Throwable} into subclass of {@link RuntimeException}
      */
-    default Function7<T1, T2, T3, T4, T5, T6, T7, R> unchecked(Function1<? super Throwable, ? extends RuntimeException> exceptionMapper) {
+    default Function7<T1, T2, T3, T4, T5, T6, T7, R> unchecked(Function<? super Throwable, ? extends RuntimeException> exceptionMapper) {
         return recover(throwable -> {
             throw exceptionMapper.apply(throwable);
         });

File: javaslang/src-gen/main/java/javaslang/CheckedFunction8.java
Patch:
@@ -294,7 +294,7 @@ default Function8<T1, T2, T3, T4, T5, T6, T7, T8, R> recover(Function<? super Th
      *
      * @param exceptionMapper the function that convert function {@link Throwable} into subclass of {@link RuntimeException}
      */
-    default Function8<T1, T2, T3, T4, T5, T6, T7, T8, R> unchecked(Function1<? super Throwable, ? extends RuntimeException> exceptionMapper) {
+    default Function8<T1, T2, T3, T4, T5, T6, T7, T8, R> unchecked(Function<? super Throwable, ? extends RuntimeException> exceptionMapper) {
         return recover(throwable -> {
             throw exceptionMapper.apply(throwable);
         });

File: javaslang/src/main/java/javaslang/collection/SortedMap.java
Patch:
@@ -146,6 +146,9 @@ default Tuple2<K, V> last() {
     @Override
     <K2, V2> SortedMap<K2, V2> map(BiFunction<? super K, ? super V, Tuple2<K2, V2>> mapper);
 
+    @Override
+    <K2> SortedMap<K2, V> mapKeys(Function<? super K, ? extends K2> keyMapper);
+
     @Override
     <V2> SortedMap<K, V2> mapValues(Function<? super V, ? extends V2> valueMapper);
 

File: javaslang/src/main/java/javaslang/collection/Map.java
Patch:
@@ -185,7 +185,7 @@ default boolean containsValue(V value) {
      * @param merge function taking the old and new values and merging them.
      * @return A new Map containing these elements and that entry.
      */
-    Map<K, V> putWith(K key, V value, BiFunction<? super V, ? super V, ? extends V> merge);
+    <U extends V> Map<K, V> putWith(K key, U value, BiFunction<? super V, ? super U, ? extends V> merge);
 
     /**
      * Convenience method for {@code putOrUpdate(entry._1, entry._2)}.
@@ -194,8 +194,7 @@ default boolean containsValue(V value) {
      * @param merge function taking the old and new values and merging them.
      * @return A new Map containing these elements and that entry.
      */
-    Map<K, V> putWith(Tuple2<? extends K, ? extends V> entry,
-                      BiFunction<? super V, ? super V, ? extends V> merge);
+    <U extends V> Map<K, V> putWith(Tuple2<? extends K, U> entry, BiFunction<? super V, ? super U, ? extends V> merge);
 
     /**
      * Removes the mapping for a key from this map if it is present.

File: javaslang/src/main/java/javaslang/collection/Seq.java
Patch:
@@ -712,7 +712,7 @@ default int prefixLength(Predicate<? super T> predicate) {
     Seq<T> removeAll(Iterable<? extends T> elements);
 
     /**
-     * Returns a new Seq consisting of all elements which not satisfy the given predicate.
+     * Returns a new Seq consisting of all elements which do not satisfy the given predicate.
      *
      * @param predicate A predicate
      * @return a new Seq

File: javaslang/src/test/java/javaslang/collection/AbstractSeqTest.java
Patch:
@@ -1075,6 +1075,9 @@ public void shouldRemoveExistingElements() {
         if (useIsEqualToInsteadOfIsSameAs()) {
             assertThat(of(1, 2, 3).removeAll(ignore -> true)).isEmpty();
             assertThat(of(1, 2, 3).removeAll(ignore -> false)).isEqualTo(of(1, 2, 3));
+        } else {
+            Seq<Integer> seq = of(1, 2, 3);
+            assertThat(seq.removeAll(ignore -> false)).isSameAs(seq);
         }
     }
 

File: javaslang/src/main/java/javaslang/collection/IndexedSeq.java
Patch:
@@ -207,6 +207,9 @@ default int lastIndexWhere(Predicate<? super T> predicate, int end) {
     @Override
     IndexedSeq<T> removeAll(Iterable<? extends T> elements);
 
+    @Override
+    IndexedSeq<T> removeAll(Predicate<? super T> predicate);
+
     @Override
     IndexedSeq<T> replace(T currentElement, T newElement);
 

File: javaslang/src/main/java/javaslang/collection/LinearSeq.java
Patch:
@@ -187,6 +187,9 @@ default int lastIndexWhere(Predicate<? super T> predicate, int end) {
     @Override
     LinearSeq<T> removeAll(Iterable<? extends T> elements);
 
+    @Override
+    LinearSeq<T> removeAll(Predicate<? super T> predicate);
+
     @Override
     LinearSeq<T> replace(T currentElement, T newElement);
 

File: javaslang/src/test/java/javaslang/collection/BitSetTest.java
Patch:
@@ -96,7 +96,7 @@ public ObjectAssert<T> isEqualTo(Object expected) {
 
     private <T> BitSet.Builder<T> bsBuilder() {
         Mapper<T> mapper = new Mapper<>();
-        return BitSet.withRelations(mapper::fromInt, mapper::toInt);
+        return BitSet.withRelations((Function<Integer, T> & Serializable) mapper::fromInt, (Function<T, Integer> & Serializable) mapper::toInt);
     }
 
     @Override

File: javaslang-benchmark/src/test/java/javaslang/benchmark/collection/ArrayBenchmark.java
Patch:
@@ -20,7 +20,7 @@ public static void main(String... args) { /* main is more reliable than a test *
 
     @State(Scope.Benchmark)
     public static class Base {
-        @Param({ "10", "100", "1000" })
+        @Param({ "10", "100", "1000", "10000"})
         public int CONTAINER_SIZE;
 
         public Integer[] ELEMENTS;

File: javaslang-benchmark/src/test/java/javaslang/benchmark/collection/ListBenchmark.java
Patch:
@@ -22,7 +22,7 @@ public static void main(String... args) { /* main is more reliable than a test *
 
     @State(Scope.Benchmark)
     public static class Base {
-        @Param({ "10", "100", "1000"})
+        @Param({ "10", "100", "1000", "10000"})
         public int CONTAINER_SIZE;
 
         public Integer[] ELEMENTS;

File: javaslang-benchmark/src/test/java/javaslang/benchmark/collection/PriorityQueueBenchmark.java
Patch:
@@ -31,7 +31,7 @@ public static class Base {
         protected static final Ordering<Integer> SCALA_ORDERING = Ordering$.MODULE$.comparatorToOrdering(Integer::compareTo);
         protected static final Order<Integer> SCALAZ_ORDER = Order$.MODULE$.fromScalaOrdering(SCALA_ORDERING);
 
-        @Param({ "10", "1000", "100000" })
+        @Param({ "10", "100", "1000", "10000"})
         public int CONTAINER_SIZE;
 
         public Integer[] ELEMENTS;

File: javaslang/src/main/java/javaslang/control/Try.java
Patch:
@@ -238,15 +238,16 @@ default Try<Throwable> failed() {
     }
 
     /**
-     * Shortcut for {@code filterTry(predicate::test, throwableSupplier)}, see {@link #filterTry(CheckedPredicate)}}.
+     * Shortcut for {@code filterTry(predicate::test, throwableSupplier)}, see
+     * {@link #filterTry(CheckedPredicate, Supplier)}}.
      *
      * @param predicate A predicate
      * @return a {@code Try} instance
      * @throws NullPointerException if {@code predicate} or {@code throwableSupplier} is null
      */
     default Try<T> filter(Predicate<? super T> predicate, Supplier<? extends Throwable> throwableSupplier) {
         Objects.requireNonNull(predicate, "predicate is null");
-        Objects.requireNonNull(predicate, "throwableSupplier is null");
+        Objects.requireNonNull(throwableSupplier, "throwableSupplier is null");
         return filterTry(predicate::test, throwableSupplier);
     }
 

File: javaslang/src/main/java/javaslang/control/Option.java
Patch:
@@ -134,7 +134,7 @@ static <T> Option<T> narrow(Option<? extends T> option) {
      */
     static <T> Option<T> when(boolean condition, Supplier<? extends T> supplier) {
         Objects.requireNonNull(supplier, "supplier is null");
-        return condition ? of(supplier.get()) : none();
+        return condition ? some(supplier.get()) : none();
     }
 
     /**

File: javaslang/src/test/java/javaslang/control/OptionTest.java
Patch:
@@ -71,7 +71,7 @@ public void shouldCreateNothing() {
 
     @Test
     public void shouldWrapIfTrue() {
-        assertThat(Option.of(null)).isEqualTo(Option.when(true, () -> null));
+        assertThat(Option.some(null)).isEqualTo(Option.when(true, () -> null));
     }
 
     @Test

File: javaslang/src/test/java/javaslang/collection/StringTest.java
Patch:
@@ -199,12 +199,12 @@ public void replace() {
 
     @Test
     public void split() {
-        assertThat(CharSeq.of("123").split("2")).isEqualTo(new CharSeq[] { CharSeq.of("1"), CharSeq.of("3") });
+        assertThat(CharSeq.of("123").split("2")).isEqualTo(Vector.of(CharSeq.of("1"), CharSeq.of("3")));
     }
 
     @Test
     public void splitLim() {
-        assertThat(CharSeq.of("123").split("2", 2)).isEqualTo(new CharSeq[] { CharSeq.of("1"), CharSeq.of("3") });
+        assertThat(CharSeq.of("123").split("2", 2)).isEqualTo(Vector.of(CharSeq.of("1"), CharSeq.of("3")));
     }
 
     @Test

File: javaslang-test/src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -173,8 +173,8 @@ default <U> U transform(Function<? super Arbitrary<T>, ? extends U> f) {
      */
     @SafeVarargs
     @SuppressWarnings("varargs")
-    static <U> Arbitrary<U> fixed(U... values) {
-        return forAll(Gen.choose(values));
+    static <U> Arbitrary<U> of(U... values) {
+        return ofAll(Gen.choose(values));
     }
 
     /**
@@ -183,7 +183,7 @@ static <U> Arbitrary<U> fixed(U... values) {
      * @param <U> Type of generator value
      * @return A new generator
      */
-    static <U> Arbitrary<U> forAll(Gen<U> generator) {
+    static <U> Arbitrary<U> ofAll(Gen<U> generator) {
       return size -> generator;
     }
 

File: javaslang-test/src/test/java/javaslang/test/ArbitraryTest.java
Patch:
@@ -97,7 +97,7 @@ public void shouldCreateArbitraryStream() {
 
     @Test
     public void shouldCreateFixedContentArbitrary() {
-        final Gen<String> arbitrary = Arbitrary.fixed("test", "content").apply(10);
+        final Gen<String> arbitrary = Arbitrary.of("test", "content").apply(10);
         for (int i = 0; i < 100; i++) {
             assertThat(arbitrary.apply(RANDOM)).isIn("test", "content");
         }
@@ -149,8 +149,8 @@ public void shouldCreateDistinctByArbitrary() {
 
     @Test
     public void shouldCreateInterspersedFixedContentArbitrary() {
-        final Gen<String> arbitrary = Arbitrary.fixed("test")
-                                               .intersperse(Arbitrary.fixed("content"))
+        final Gen<String> arbitrary = Arbitrary.of("test")
+                                               .intersperse(Arbitrary.of("content"))
                                                .apply(10);
 
         for (int i = 0; i < 100; i++) {

File: javaslang/src/main/java/javaslang/collection/Stream.java
Patch:
@@ -973,7 +973,7 @@ default Stream<T> padTo(int length, T element) {
         if (length <= 0) {
             return this;
         } else if (isEmpty()) {
-            return Stream.ofAll(Iterator.continually(element).take(length));
+            return Stream.continually(element).take(length);
         } else {
             return cons(head(), () -> tail().padTo(length - 1, element));
         }
@@ -984,7 +984,7 @@ default Stream<T> leftPadTo(int length, T element) {
         if (length <= actualLength) {
             return this;
         } else {
-            return Stream.ofAll(Iterator.continually(element).take(length - actualLength)).appendAll(this);
+            return Stream.continually(element).take(length - actualLength).appendAll(this);
         }
     }
 

File: javaslang/src-gen/main/java/javaslang/API.java
Patch:
@@ -92,9 +92,9 @@ private API() {
      * e.g. by {@code Match}:
      *
      * <pre><code>Match(i).of(
-     *     Case(is(0), i -> run(() -&gt; System.out.println("zero"))),
-     *     Case(is(1), i -> run(() -&gt; System.out.println("one"))),
-     *     Case($(), o -> run(() -&gt; System.out.println("many")))
+     *     Case(is(0), i -&gt; run(() -&gt; System.out.println("zero"))),
+     *     Case(is(1), i -&gt; run(() -&gt; System.out.println("one"))),
+     *     Case($(), o -&gt; run(() -&gt; System.out.println("many")))
      * )</code></pre>
      *
      * @param unit A block of code to be run.

File: javaslang/src-gen/main/java/javaslang/API.java
Patch:
@@ -92,9 +92,9 @@ private API() {
      * e.g. by {@code Match}:
      *
      * <pre><code>Match(i).of(
-     *     Case(is(0), i -> run(() -&gt; System.out.println("zero"))),
-     *     Case(is(1), i -> run(() -&gt; System.out.println("one"))),
-     *     Case($(), o -> run(() -&gt; System.out.println("many")))
+     *     Case(is(0), i -&gt; run(() -&gt; System.out.println("zero"))),
+     *     Case(is(1), i -&gt; run(() -&gt; System.out.println("one"))),
+     *     Case($(), o -&gt; run(() -&gt; System.out.println("many")))
      * )</code></pre>
      *
      * @param unit A block of code to be run.

File: javaslang/src/main/java/javaslang/collection/LinkedHashMultimap.java
Patch:
@@ -25,7 +25,7 @@
  * @author Ruslan Sennov
  * @since 2.0.0
  */
-public class LinkedHashMultimap<K, V> extends AbstractMultimap<K, V, LinkedHashMultimap<K, V>> implements Serializable {
+public final class LinkedHashMultimap<K, V> extends AbstractMultimap<K, V, LinkedHashMultimap<K, V>> implements Serializable {
 
     private static final long serialVersionUID = 1L;
 

File: javaslang/src/main/java/javaslang/collection/TreeMultimap.java
Patch:
@@ -25,7 +25,7 @@
  * @author Ruslan Sennov
  * @since 2.0.0
  */
-public class TreeMultimap<K, V> extends AbstractMultimap<K, V, TreeMultimap<K, V>> implements Serializable {
+public final class TreeMultimap<K, V> extends AbstractMultimap<K, V, TreeMultimap<K, V>> implements Serializable {
 
     private static final long serialVersionUID = 1L;
 

File: javaslang/src/test/java/javaslang/collection/HashArrayMappedTrieTest.java
Patch:
@@ -66,7 +66,7 @@ public void testBigDataWeakHashCode() {
         testBigData(5000, t -> Tuple.of(new WeakInteger(t._1), t._2));
     }
 
-    private <K extends Comparable<K>, V> void testBigData(int count, Function<Tuple2<Integer, Integer>, Tuple2<K, V>> mapper) {
+    private <K extends Comparable<? super K>, V> void testBigData(int count, Function<Tuple2<Integer, Integer>, Tuple2<K, V>> mapper) {
         Comparator<K, V> cmp = new Comparator<>();
         java.util.Map<K, V> rnd = rnd(count, mapper);
         for (java.util.Map.Entry<K, V> e : rnd.entrySet()) {

File: javaslang/src/test/java/javaslang/collection/HashMultimapTest.java
Patch:
@@ -14,7 +14,7 @@ public class HashMultimapTest extends AbstractMultimapTest {
 
     @Override
     protected String className() {
-        return "Multimap[HashMap," + containerName() + "]";
+        return "HashMultimap[" + containerName() + "]";
     }
 
     @Override

File: javaslang/src/test/java/javaslang/collection/LinkedHashMultimapTest.java
Patch:
@@ -14,7 +14,7 @@ public class LinkedHashMultimapTest extends AbstractMultimapTest {
 
     @Override
     protected String className() {
-        return "Multimap[LinkedHashMap," + containerName() + "]";
+        return "LinkedHashMultimap[" + containerName() + "]";
     }
 
     @Override

File: javaslang/src/test/java/javaslang/collection/TreeMultimapTest.java
Patch:
@@ -16,7 +16,7 @@ public class TreeMultimapTest extends AbstractMultimapTest {
 
     @Override
     protected String className() {
-        return "Multimap[TreeMap," + containerName() + "]";
+        return "TreeMultimap[" + containerName() + "]";
     }
 
     @Override

File: javaslang/src/test/java/javaslang/collection/HashMultimapTest.java
Patch:
@@ -14,7 +14,7 @@ public class HashMultimapTest extends AbstractMultimapTest {
 
     @Override
     protected String className() {
-        return "Multimap[HashMap," + containerName() + "]";
+        return "HashMultimap[" + containerName() + "]";
     }
 
     @Override

File: javaslang/src/test/java/javaslang/collection/LinkedHashMultimapTest.java
Patch:
@@ -14,7 +14,7 @@ public class LinkedHashMultimapTest extends AbstractMultimapTest {
 
     @Override
     protected String className() {
-        return "Multimap[LinkedHashMap," + containerName() + "]";
+        return "LinkedHashMultimap[" + containerName() + "]";
     }
 
     @Override

File: javaslang/src/test/java/javaslang/collection/TreeMultimapTest.java
Patch:
@@ -16,7 +16,7 @@ public class TreeMultimapTest extends AbstractMultimapTest {
 
     @Override
     protected String className() {
-        return "Multimap[TreeMap," + containerName() + "]";
+        return "TreeMultimap[" + containerName() + "]";
     }
 
     @Override

File: javaslang/src/main/java/javaslang/collection/LinkedHashMultimap.java
Patch:
@@ -25,7 +25,7 @@
  * @author Ruslan Sennov
  * @since 2.0.0
  */
-public class LinkedHashMultimap<K, V> extends AbstractMultimap<K, V, LinkedHashMultimap<K, V>> implements Serializable {
+public final class LinkedHashMultimap<K, V> extends AbstractMultimap<K, V, LinkedHashMultimap<K, V>> implements Serializable {
 
     private static final long serialVersionUID = 1L;
 

File: javaslang/src/main/java/javaslang/collection/TreeMultimap.java
Patch:
@@ -25,7 +25,7 @@
  * @author Ruslan Sennov
  * @since 2.0.0
  */
-public class TreeMultimap<K, V> extends AbstractMultimap<K, V, TreeMultimap<K, V>> implements Serializable {
+public final class TreeMultimap<K, V> extends AbstractMultimap<K, V, TreeMultimap<K, V>> implements Serializable {
 
     private static final long serialVersionUID = 1L;
 

File: javaslang/src/test/java/javaslang/collection/HashArrayMappedTrieTest.java
Patch:
@@ -66,7 +66,7 @@ public void testBigDataWeakHashCode() {
         testBigData(5000, t -> Tuple.of(new WeakInteger(t._1), t._2));
     }
 
-    private <K extends Comparable<K>, V> void testBigData(int count, Function<Tuple2<Integer, Integer>, Tuple2<K, V>> mapper) {
+    private <K extends Comparable<? super K>, V> void testBigData(int count, Function<Tuple2<Integer, Integer>, Tuple2<K, V>> mapper) {
         Comparator<K, V> cmp = new Comparator<>();
         java.util.Map<K, V> rnd = rnd(count, mapper);
         for (java.util.Map.Entry<K, V> e : rnd.entrySet()) {

File: javaslang/src/main/java/javaslang/collection/LinkedHashSet.java
Patch:
@@ -681,6 +681,7 @@ public LinkedHashSet<T> removeAll(Iterable<? extends T> elements) {
         return (that == map) ? this : new LinkedHashSet<>(that);
     }
 
+    // DEV-NOTE: replace does not preserve the order, the new element may already be in the set
     @Override
     public LinkedHashSet<T> replace(T currentElement, T newElement) {
         if (map.containsKey(currentElement)) {
@@ -725,7 +726,7 @@ public <U> LinkedHashSet<U> scanLeft(U zero, BiFunction<? super U, ? super T, ?
     @Override
     public <U> LinkedHashSet<U> scanRight(U zero, BiFunction<? super T, ? super U, ? extends U> operation) {
         Objects.requireNonNull(operation, "operation is null");
-        return Collections.scanRight(this, zero, operation, LinkedHashSet.empty(), LinkedHashSet::add, Function.identity());
+        return Collections.scanRight(this, zero, operation, List.empty(), List::prepend, LinkedHashSet::ofAll);
     }
 
     @Override

File: javaslang/src/main/java/javaslang/collection/Vector.java
Patch:
@@ -1292,7 +1292,7 @@ public boolean equals(Object o) {
             return true;
         } else if (o instanceof Vector) {
             final Vector<?> that = (Vector<?>) o;
-            return Collections.equals(this, that);
+            return (this.size() == that.size()) && Collections.equals(this, that);
         } else {
             return false;
         }

File: javaslang/src/main/java/javaslang/collection/Vector.java
Patch:
@@ -1095,7 +1095,7 @@ public Tuple2<Vector<T>, Vector<T>> splitAtInclusive(Predicate<? super T> predic
             init = init.put(init.size(), t);
             if (predicate.test(t)) {
                 if (init.size() == length()) {
-                    Tuple.of(this, empty());
+                    return Tuple.of(this, empty());
                 } else {
                     return Tuple.of(new Vector<>(init), drop(init.size()));
                 }

File: javaslang/src/main/java/javaslang/collection/Vector.java
Patch:
@@ -1095,7 +1095,7 @@ public Tuple2<Vector<T>, Vector<T>> splitAtInclusive(Predicate<? super T> predic
             init = init.put(init.size(), t);
             if (predicate.test(t)) {
                 if (init.size() == length()) {
-                    Tuple.of(this, empty());
+                    return Tuple.of(this, empty());
                 } else {
                     return Tuple.of(new Vector<>(init), drop(init.size()));
                 }

File: javaslang/src/main/java/javaslang/control/Either.java
Patch:
@@ -36,7 +36,7 @@
  * </pre>
  *
  * If the result of compute() is Right(1), the value is Right(2).<br>
- * If the result of compute() is Left("error), the value is Left("error").
+ * If the result of compute() is Left("error"), the value is Left("error").
  *
  * @param <L> The type of the Left value of an Either.
  * @param <R> The type of the Right value of an Either.

File: javaslang/src/main/java/javaslang/collection/Tree.java
Patch:
@@ -210,13 +210,13 @@ default boolean isBranch() {
     }
 
     /**
-     * Traverses this tree in a specific {@link javaslang.collection.Tree.Order}.
+     * Traverses this tree values in a specific {@link javaslang.collection.Tree.Order}.
      *
      * @param order A traversal order
      * @return A new Iterator
      */
-    default Iterator<Node<T>> iterator(Order order) {
-        return traverse(order).iterator();
+    default Iterator<T> iterator(Order order) {
+        return values(order).iterator();
     }
 
     /**

File: javaslang/src/main/java/javaslang/collection/Tree.java
Patch:
@@ -210,13 +210,13 @@ default boolean isBranch() {
     }
 
     /**
-     * Traverses this tree in a specific {@link javaslang.collection.Tree.Order}.
+     * Traverses this tree values in a specific {@link javaslang.collection.Tree.Order}.
      *
      * @param order A traversal order
      * @return A new Iterator
      */
-    default Iterator<Node<T>> iterator(Order order) {
-        return traverse(order).iterator();
+    default Iterator<T> iterator(Order order) {
+        return values(order).iterator();
     }
 
     /**

File: javaslang/src/main/java/javaslang/$.java
Patch:
@@ -15,8 +15,7 @@
 import javaslang.match.annotation.Unapply;
 import javaslang.match.annotation.Patterns;
 
-@Patterns
-class $ {
+@Patterns class $ {
 
     // -- javaslang
 

File: javaslang-match/src/main/java/javaslang/match/PatternsProcessor.java
Patch:
@@ -77,7 +77,6 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
                 }
             }
         }
-        // TODO: ensure we only process @Patterns
         return true;
     }
 
@@ -86,7 +85,7 @@ private Set<ClassModel> transform(Set<TypeElement> typeElements) {
         final Set<ClassModel> classModels = new HashSet<>();
         final javax.lang.model.util.Elements elementUtils = processingEnv.getElementUtils();
         final Messager messager = processingEnv.getMessager();
-        typeElements.stream().filter(typeElement -> PatternsChecker.isValid(typeElement, messager)).forEach(typeElement -> {
+        for (TypeElement typeElement : typeElements) {
             final ClassModel classModel = ClassModel.of(elementUtils, typeElement);
             final List<MethodModel> methodModels = classModel.getMethods().stream()
                     .filter(method -> method.isAnnotatedWith(Unapply.class))
@@ -99,7 +98,7 @@ private Set<ClassModel> transform(Set<TypeElement> typeElements) {
                     classModels.add(classModel);
                 }
             }
-        });
+        }
         return classModels;
     }
 

File: javaslang/src/test/java/javaslang/MatchTest.java
Patch:
@@ -223,7 +223,7 @@ static final class Developer implements Person {
 //    }
 
     @javaslang.match.annotation.Patterns
-    static class Person_ {
+    protected static class Person_<T extends Number> {
 
         @Unapply
         static Tuple3<String, Boolean, Option<Number>> Developer(Developer dev) {

File: javaslang-match/src/main/java/javaslang/match/PatternsChecker.java
Patch:
@@ -18,7 +18,8 @@ class PatternsChecker extends BaseChecker<PatternsChecker, TypeElement> {
 
     static boolean isValid(TypeElement typeElement, Messager messager) {
         final PatternsChecker typeChecker = new PatternsChecker(typeElement, messager);
-        return typeChecker.ensure(e -> !e.isNested(), () -> "Patterns need to be defined in top-level classes.");
+        return typeChecker.ensure(e -> !e.isNested(), () -> "Patterns need to be defined in top-level classes.") &&
+                typeChecker.ensure(e -> e.elem.getTypeParameters().isEmpty(), () -> "A patterns class must not have type parameters.");
     }
 
     private PatternsChecker(TypeElement elem, Messager messager) {

File: javaslang-match/src/main/java/javaslang/match/generator/Generator.java
Patch:
@@ -39,7 +39,7 @@ public static String generate(String derivedClassName, ClassModel classModel) {
                 .filter(method -> method.isAnnotatedWith(Unapply.class))
                 .collect(toList());
         final String _package = classModel.getPackageName();
-        final ImportManager im = ImportManager.forClass(classModel);
+        final ImportManager im = ImportManager.forClass(classModel, "javaslang.API.Match");
         final String methods = generate(im, classModel, methodModels);
         return (_package.isEmpty() ? "" : "package " + _package + ";\n\n") +
                 im.getImports() +

File: javaslang-match/src/main/java/javaslang/match/generator/Generator.java
Patch:
@@ -39,7 +39,7 @@ public static String generate(String derivedClassName, ClassModel classModel) {
                 .filter(method -> method.isAnnotatedWith(Unapply.class))
                 .collect(toList());
         final String _package = classModel.getPackageName();
-        final ImportManager im = ImportManager.forClass(classModel);
+        final ImportManager im = ImportManager.forClass(classModel, "javaslang.API.Match");
         final String methods = generate(im, classModel, methodModels);
         return (_package.isEmpty() ? "" : "package " + _package + ";\n\n") +
                 im.getImports() +

File: javaslang-match/src/main/java/javaslang/match/generator/UnapplyChecker.java
Patch:
@@ -7,6 +7,7 @@
 
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeKind;
 
 import static javax.lang.model.element.Modifier.*;
 
@@ -24,7 +25,7 @@ static boolean isValid(ExecutableElement executableElement, Messager messager) {
                 methodChecker.ensure(e -> !e.elem.isDefault(), () -> "@" + "Unapply method needs to be declared in a class, not an interface.") &&
                 methodChecker.ensure(e -> !e.elem.isVarArgs(), () -> "@" + "Unapply method has varargs.") &&
                 methodChecker.ensure(e -> e.elem.getParameters().size() == 1, () -> "Unapply method must have exactly one parameter of the object to be deconstructed.") &&
-                // TODO: methodChecker.ensure(e -> e.elem.getParameters().get(0).asType().getKind() != TypeKind.DECLARED, () -> "Unapply method parameter must be a declared type.") &&
+                methodChecker.ensure(e -> e.elem.getParameters().get(0).asType().getKind() == TypeKind.DECLARED, () -> "Unapply method parameter must be a declared type.") &&
                 methodChecker.ensure(e -> e.elem.getReturnType().toString().startsWith("javaslang.Tuple"), () -> "Return type of unapply method must be a Tuple.") &&
                 methodChecker.ensure(e -> !e.elem.getReturnType().toString().endsWith("Tuple"), () -> "Return type is no Tuple implementation.") &&
                 methodChecker.ensure(e -> e.hasAll(STATIC), () -> "Unapply method needs to be static.") &&

File: javaslang-pure/src/test/java/javaslang/algebra/MonoidTest.java
Patch:
@@ -28,7 +28,8 @@ public void shouldCombineMonoids() {
 
     @Test
     public void shouldFoldMultipleElements() {
-        assertThat(Monoid.fold(Monoid.of(0, (a, b) -> a + b), List.of(1, 2, 3))).isEqualTo(6);
+        // DEV note:  generic is required for Windows compiler (1.8.0_45)
+        assertThat(Monoid.fold(Monoid.<Integer>of(0, (a, b) -> a + b), List.of(1, 2, 3))).isEqualTo(6);
     }
 
     // -- foldLeft

File: javaslang-pure/src/test/java/javaslang/algebra/MonoidTest.java
Patch:
@@ -28,7 +28,8 @@ public void shouldCombineMonoids() {
 
     @Test
     public void shouldFoldMultipleElements() {
-        assertThat(Monoid.fold(Monoid.of(0, (a, b) -> a + b), List.of(1, 2, 3))).isEqualTo(6);
+        // DEV note:  generic is required for Windows compiler (1.8.0_45)
+        assertThat(Monoid.fold(Monoid.<Integer>of(0, (a, b) -> a + b), List.of(1, 2, 3))).isEqualTo(6);
     }
 
     // -- foldLeft

File: javaslang/src/test/java/javaslang/control/ValidationTest.java
Patch:
@@ -549,8 +549,8 @@ public Validation<List<String>, Person> validatePerson(String name, int age) {
 
         private Validation<String, String> validateName(String name) {
             return CharSeq.of(name).replaceAll(validNameChars, "").transform(seq ->
-                    seq.isEmpty() ? Validation.valid(name)
-                            : Validation.invalid("Name contains invalid characters: '" + seq.distinct().sorted() + "'"));
+                    seq.isEmpty() ? Validation.<String, String>valid(name)
+                            : Validation.<String, String>invalid("Name contains invalid characters: '" + seq.distinct().sorted() + "'"));
         }
 
         private Validation<String, Integer> validateAge(int age) {

File: javaslang/src/test/java/javaslang/control/ValidationTest.java
Patch:
@@ -549,8 +549,8 @@ public Validation<List<String>, Person> validatePerson(String name, int age) {
 
         private Validation<String, String> validateName(String name) {
             return CharSeq.of(name).replaceAll(validNameChars, "").transform(seq ->
-                    seq.isEmpty() ? Validation.valid(name)
-                            : Validation.invalid("Name contains invalid characters: '" + seq.distinct().sorted() + "'"));
+                    seq.isEmpty() ? Validation.<String, String>valid(name)
+                            : Validation.<String, String>invalid("Name contains invalid characters: '" + seq.distinct().sorted() + "'"));
         }
 
         private Validation<String, Integer> validateAge(int age) {

File: javaslang/src-gen/test/java/javaslang/APITest.java
Patch:
@@ -22,6 +22,7 @@ public class APITest {
     @Test
     public void shouldRunUnitAndReturnVoid() {
         int[] i = { 0 };
+        @SuppressWarnings("unused")
         Void nothing = run(() -> i[0]++);
         assertThat(i[0]).isEqualTo(1);
     }

File: javaslang/src/main/java/javaslang/collection/AbstractMap.java
Patch:
@@ -242,7 +242,6 @@ public M replaceAll(Tuple2<K, V> currentElement, Tuple2<K, V> newElement) {
         return replace(currentElement, newElement);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
     public M scan(Tuple2<K, V> zero, BiFunction<? super Tuple2<K, V>, ? super Tuple2<K, V>, ? extends Tuple2<K, V>> operation) {
         Objects.requireNonNull(operation, "operation is null");

File: javaslang/src/main/java/javaslang/collection/IndexedSeq.java
Patch:
@@ -280,7 +280,6 @@ default int segmentLength(Predicate<? super T> predicate, int from) {
     @Override
     Tuple2<? extends IndexedSeq<T>, ? extends IndexedSeq<T>> span(Predicate<? super T> predicate);
 
-    @SuppressWarnings("unchecked")
     @Override
     default boolean startsWith(Iterable<? extends T> that, int offset) {
         Objects.requireNonNull(that, "that is null");

File: javaslang/src/main/java/javaslang/control/Try.java
Patch:
@@ -374,7 +374,6 @@ default Iterator<T> iterator() {
      * @return a {@code Try}
      * @throws NullPointerException if {@code mapper} is null
      */
-    @SuppressWarnings("unchecked")
     @Override
     default <U> Try<U> map(Function<? super T, ? extends U> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");

File: javaslang/src/test/java/javaslang/collection/AbstractLinearSeqTest.java
Patch:
@@ -9,8 +9,6 @@
 
 import java.math.BigDecimal;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 public abstract class AbstractLinearSeqTest extends AbstractSeqTest {
 
     @Override

File: javaslang/src/test/java/javaslang/collection/AbstractMapTest.java
Patch:
@@ -22,7 +22,6 @@
 
 import static javaslang.Serializables.deserialize;
 import static javaslang.Serializables.serialize;
-import static org.assertj.core.api.Assertions.assertThat;
 
 public abstract class AbstractMapTest extends AbstractTraversableTest {
 

File: javaslang/src-gen/test/java/javaslang/APITest.java
Patch:
@@ -22,6 +22,7 @@ public class APITest {
     @Test
     public void shouldRunUnitAndReturnVoid() {
         int[] i = { 0 };
+        @SuppressWarnings("unused")
         Void nothing = run(() -> i[0]++);
         assertThat(i[0]).isEqualTo(1);
     }

File: javaslang/src/main/java/javaslang/collection/AbstractMap.java
Patch:
@@ -242,7 +242,6 @@ public M replaceAll(Tuple2<K, V> currentElement, Tuple2<K, V> newElement) {
         return replace(currentElement, newElement);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
     public M scan(Tuple2<K, V> zero, BiFunction<? super Tuple2<K, V>, ? super Tuple2<K, V>, ? extends Tuple2<K, V>> operation) {
         Objects.requireNonNull(operation, "operation is null");

File: javaslang/src/main/java/javaslang/collection/IndexedSeq.java
Patch:
@@ -280,7 +280,6 @@ default int segmentLength(Predicate<? super T> predicate, int from) {
     @Override
     Tuple2<? extends IndexedSeq<T>, ? extends IndexedSeq<T>> span(Predicate<? super T> predicate);
 
-    @SuppressWarnings("unchecked")
     @Override
     default boolean startsWith(Iterable<? extends T> that, int offset) {
         Objects.requireNonNull(that, "that is null");

File: javaslang/src/main/java/javaslang/control/Try.java
Patch:
@@ -374,7 +374,6 @@ default Iterator<T> iterator() {
      * @return a {@code Try}
      * @throws NullPointerException if {@code mapper} is null
      */
-    @SuppressWarnings("unchecked")
     @Override
     default <U> Try<U> map(Function<? super T, ? extends U> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");

File: javaslang/src/test/java/javaslang/collection/AbstractLinearSeqTest.java
Patch:
@@ -9,8 +9,6 @@
 
 import java.math.BigDecimal;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 public abstract class AbstractLinearSeqTest extends AbstractSeqTest {
 
     @Override

File: javaslang/src/test/java/javaslang/collection/AbstractMapTest.java
Patch:
@@ -22,7 +22,6 @@
 
 import static javaslang.Serializables.deserialize;
 import static javaslang.Serializables.serialize;
-import static org.assertj.core.api.Assertions.assertThat;
 
 public abstract class AbstractMapTest extends AbstractTraversableTest {
 

File: javaslang-match/src/main/java/javaslang/match/Generator.java
Patch:
@@ -1,6 +1,6 @@
 /*     / \____  _    _  ____   ______  / \ ____  __    _______
  *    /  /    \/ \  / \/    \ /  /\__\/  //    \/  \  //  /\__\   JVSLNG
- *  _/  /  /\  \  \/  /  /\  \\__\\  \  //  /\  \ /\\/ \ /__\ \   Copyright 2014-2016 Javaslang contributors
+ *  _/  /  /\  \  \/  /  /\  \\__\\  \  //  /\  \ /\\/ \ /__\ \   Copyright 2014-2016 Javaslang, http://javaslang.io
  * /___/\_/  \_/\____/\_/  \_/\__\/__/\__\_/  \_//  \__/\_____/   Licensed under the Apache License, Version 2.0
  */
 package javaslang.match;

File: javaslang-test/src/main/java/javaslang/test/Gen.java
Patch:
@@ -177,7 +177,7 @@ static <E extends Enum<E>> Gen<E> choose(Class<E> clazz) {
      */
     static <E> Gen<E> choose(E[] values) {
         if(values.length == 0)
-            return Gen.fail("Emtpy array");
+            return Gen.fail("Empty array");
         else
             return random -> Gen.choose(0, values.length - 1).map(i -> values[i]).apply(random);
     }

File: javaslang/src/main/java/javaslang/collection/Stream.java
Patch:
@@ -711,7 +711,7 @@ default Stream<T> cycle() {
      */
     default Stream<T> cycle(int count) {
         if (count <= 0 || isEmpty()) {
-            return this;
+            return empty();
         } else {
             final Stream<T> self = this;
             return Stream.ofAll(new Iterator<T>() {

File: javaslang/src/test/java/javaslang/collection/StreamTest.java
Patch:
@@ -414,6 +414,9 @@ public void shouldCycleTimesEmptyStream() {
 
     @Test
     public void shouldCycleTimesNonEmptyStream() {
+        assertThat(of(1, 2, 3).cycle(-1)).isEqualTo(empty());
+        assertThat(of(1, 2, 3).cycle(0)).isEqualTo(empty());
+        assertThat(of(1, 2, 3).cycle(1)).isEqualTo(of(1, 2, 3));
         assertThat(of(1, 2, 3).cycle(3)).isEqualTo(of(1, 2, 3, 1, 2, 3, 1, 2, 3));
     }
 

File: javaslang/src/main/java/javaslang/collection/Stream.java
Patch:
@@ -711,7 +711,7 @@ default Stream<T> cycle() {
      */
     default Stream<T> cycle(int count) {
         if (count <= 0 || isEmpty()) {
-            return this;
+            return empty();
         } else {
             final Stream<T> self = this;
             return Stream.ofAll(new Iterator<T>() {

File: javaslang/src/test/java/javaslang/collection/StreamTest.java
Patch:
@@ -414,6 +414,9 @@ public void shouldCycleTimesEmptyStream() {
 
     @Test
     public void shouldCycleTimesNonEmptyStream() {
+        assertThat(of(1, 2, 3).cycle(-1)).isEqualTo(empty());
+        assertThat(of(1, 2, 3).cycle(0)).isEqualTo(empty());
+        assertThat(of(1, 2, 3).cycle(1)).isEqualTo(of(1, 2, 3));
         assertThat(of(1, 2, 3).cycle(3)).isEqualTo(of(1, 2, 3, 1, 2, 3, 1, 2, 3));
     }
 

File: javaslang/src-gen/main/java/javaslang/API.java
Patch:
@@ -740,7 +740,8 @@ public final <R> Option<R> option(Case<? extends T, ? extends R>... cases) {
 
         // -- CASES
 
-        public interface Case<T, R> extends Function<T, Option<R>> {
+        // does not compile if interfaces are not fully qualified - wtf!?
+        public interface Case<T, R> extends java.util.function.Function<T, javaslang.control.Option<R>> {
         }
 
         public static final class Case0<T, R> implements Case<T, R> {

File: javaslang/src-gen/main/java/javaslang/API.java
Patch:
@@ -23,7 +23,7 @@
  *
  * <h3>For-comprehension</h3>
  * <p>
- * The {@code For}-comprehension is syntactic sugar for nested for loops. We write
+ * The {@code For}-comprehension is syntactic sugar for nested for-loops. We write
  *
  * <pre><code>
  * // lazily evaluated
@@ -39,15 +39,15 @@
  *         for (TN vN : iterableN) {
  *             R result = f.apply(v1, v2, ..., VN);
  *             //
- *             // We are forced to perform side effects to do s.th. meaningful with the result :-/
+ *             // We are forced to perform side effects to do s.th. meaningful with the result.
  *             //
  *         }
  *     }
  * }
  * </code></pre>
  *
  * Given a suitable function
- * f {@code (v1, v2, ..., vN) -&gt; ...} and 1 &lt;= N &lt;= 8 iterables, the result is a Stream of the
+ * f {@code (v1, v2, ..., vN) -> ...} and 1 &lt;= N &lt;= 8 iterables, the result is a Stream of the
  * mapped cross product elements.
  *
  * <pre><code>

File: javaslang/src-gen/main/java/javaslang/API.java
Patch:
@@ -23,7 +23,7 @@
  *
  * <h3>For-comprehension</h3>
  * <p>
- * The {@code For}-comprehension is syntactic sugar for nested for loops. We write
+ * The {@code For}-comprehension is syntactic sugar for nested for-loops. We write
  *
  * <pre><code>
  * // lazily evaluated
@@ -39,15 +39,15 @@
  *         for (TN vN : iterableN) {
  *             R result = f.apply(v1, v2, ..., VN);
  *             //
- *             // We are forced to perform side effects to do s.th. meaningful with the result :-/
+ *             // We are forced to perform side effects to do s.th. meaningful with the result.
  *             //
  *         }
  *     }
  * }
  * </code></pre>
  *
  * Given a suitable function
- * f {@code (v1, v2, ..., vN) -&gt; ...} and 1 &lt;= N &lt;= 8 iterables, the result is a Stream of the
+ * f {@code (v1, v2, ..., vN) -> ...} and 1 &lt;= N &lt;= 8 iterables, the result is a Stream of the
  * mapped cross product elements.
  *
  * <pre><code>

File: javaslang/src/main/java/javaslang/collection/Iterator.java
Patch:
@@ -963,7 +963,7 @@ public T getNext() {
     // -- Additional methods of Iterator
 
     // DEV-NOTE: cannot use arg Iterable, it would be ambiguous
-    default Iterator<T> concat(java.util.Iterator<T> that) {
+    default Iterator<T> concat(java.util.Iterator<? extends T> that) {
         Objects.requireNonNull(that, "that is null");
         if (!that.hasNext()) {
             return this;

File: javaslang/src/main/java/javaslang/collection/Stream.java
Patch:
@@ -609,7 +609,7 @@ default Stream<T> append(T element) {
     @Override
     default Stream<T> appendAll(Iterable<? extends T> elements) {
         Objects.requireNonNull(elements, "elements is null");
-        return isEmpty() ? Stream.ofAll(elements) : new AppendElements<>(head(), Queue.ofAll(elements), this::tail);
+        return Stream.ofAll(isEmpty() ? elements : Iterator.concat(this, elements));
     }
 
     /**

File: javaslang/src/main/java/javaslang/collection/Iterator.java
Patch:
@@ -963,7 +963,7 @@ public T getNext() {
     // -- Additional methods of Iterator
 
     // DEV-NOTE: cannot use arg Iterable, it would be ambiguous
-    default Iterator<T> concat(java.util.Iterator<T> that) {
+    default Iterator<T> concat(java.util.Iterator<? extends T> that) {
         Objects.requireNonNull(that, "that is null");
         if (!that.hasNext()) {
             return this;

File: javaslang/src/main/java/javaslang/collection/Stream.java
Patch:
@@ -609,7 +609,7 @@ default Stream<T> append(T element) {
     @Override
     default Stream<T> appendAll(Iterable<? extends T> elements) {
         Objects.requireNonNull(elements, "elements is null");
-        return isEmpty() ? Stream.ofAll(elements) : new AppendElements<>(head(), Queue.ofAll(elements), this::tail);
+        return Stream.ofAll(isEmpty() ? elements : Iterator.concat(this, elements));
     }
 
     /**

File: javaslang-test/src/test/java/javaslang/test/GenTest.java
Patch:
@@ -57,7 +57,7 @@ public int nextInt(int bound) {
         };
         final Gen<Integer> gen = Gen.choose(1, 2);
         final Number actual = Stream.gen(() -> gen.apply(rng)).take(10).sum();
-        assertThat(actual).isEqualTo(10);
+        assertThat(actual).isEqualTo(10L);
     }
 
     // -- choose(int, int)

File: javaslang/src/test/java/javaslang/collection/euler/Euler08Test.java
Patch:
@@ -49,7 +49,7 @@ public class Euler08Test {
     @Test
     public void shouldSolveProblem8() {
         assertThat(largestProductOfConsecutives(4, _1000_DIGITS_NUMBER)).isEqualTo(5_832);
-        assertThat(largestProductOfConsecutives(13, _1000_DIGITS_NUMBER)).isEqualTo(2_091_059_712);
+        assertThat(largestProductOfConsecutives(13, _1000_DIGITS_NUMBER)).isEqualTo(23_514_624_000L);
     }
 
     private static long largestProductOfConsecutives(int sizeOfConsecutive, String num) {

File: javaslang/src/main/java/javaslang/Lazy.java
Patch:
@@ -40,7 +40,7 @@
  *
  * Since 2.0.0 you may also create a <em>real</em> lazy value (works only with interfaces):
  *
- * <pre><code>final CharSequence chars = Lazy.of(() -&gt; "Yay!", CharSequence.class);</code></pre>
+ * <pre><code>final CharSequence chars = Lazy.val(() -&gt; "Yay!", CharSequence.class);</code></pre>
  *
  * @author Daniel Dietrich
  * @since 1.2.1

File: javaslang/src-gen/main/java/javaslang/Patterns.java
Patch:
@@ -44,7 +44,7 @@ public static <__ extends javaslang.control.Option.Some<T>, T, T1, T2, T3, T4, T
         return Pattern8.create(javaslang.control.Option.Some.class, t -> $.Some(t).transform(t1 -> p1.apply(t1)));
     }
 
-    public static Pattern0 None = Pattern0.create(javaslang.control.Option.None.class);
+    public static final Pattern0 None = Pattern0.create(javaslang.control.Option.None.class);
 
     public static <__ extends javaslang.collection.List.Cons<T>, T> Pattern0 Cons(T p1, javaslang.collection.List<T> p2) {
         return Pattern0.<javaslang.collection.List.Cons<T>>create(javaslang.collection.List.Cons.class, t -> $.Cons(t).transform((t1, t2) -> Pattern0.equals(t1, p1).flatMap(_1 -> Pattern0.equals(t2, p2))));
@@ -296,6 +296,6 @@ public static <__ extends javaslang.collection.List.Cons<T>, T, T1, T2, T3, T4,
         return Pattern8.create(javaslang.collection.List.Cons.class, t -> $.Cons(t).transform((t1, t2) -> p1.apply(t1).flatMap(v1 -> p2.apply(t2).map(_1 -> v1))));
     }
 
-    public static Pattern0 Nil = Pattern0.create(javaslang.collection.List.Nil.class);
+    public static final Pattern0 Nil = Pattern0.create(javaslang.collection.List.Nil.class);
 
 }

File: javaslang-match/src/main/java/javaslang/match/PatternsProcessor.java
Patch:
@@ -181,7 +181,7 @@ private static int[] getMaxArity(String[] types) {
         int i = 0;
         for (String type : types) {
             // TODO: Class.forName(type).isAssignableFrom(any of ATOMICS) ? 1 : ARITY
-            maxArity[i] = ATOMICS.contains(type) ? 1 : ARITY;
+            maxArity[i++] = ATOMICS.contains(type) ? 1 : ARITY;
         }
         return maxArity;
     }

File: javaslang/src/main/java/javaslang/collection/Stream.java
Patch:
@@ -1218,6 +1218,8 @@ default Option<Stream<T>> tailOption() {
     default Stream<T> take(long n) {
         if (n < 1 || isEmpty()) {
             return Empty.instance();
+        } else if (n == 1) {
+            return cons(head(), Stream::empty);
         } else {
             return cons(head(), () -> tail().take(n - 1));
         }

File: javaslang/src/main/java/javaslang/collection/Stream.java
Patch:
@@ -1475,7 +1475,7 @@ public String toString() {
                 final Cons<T> cons = (Cons<T>) stream;
                 builder.append(cons.head);
                 if (cons.tail.isEvaluated()) {
-                    stream = cons.tail.get();
+                    stream = stream.tail();
                     if (!stream.isEmpty()) {
                         builder.append(", ");
                     }
@@ -1544,10 +1544,10 @@ public Stream<T> tail() {
             } else {
                 if(t instanceof ConsImpl) {
                     ConsImpl<T> c = (ConsImpl<T>) t;
-                    return new AppendElements<>(t.head(), queue, c.tail);
+                    return new AppendElements<>(c.head(), queue, c.tail);
                 } else {
                     AppendElements<T> a = (AppendElements<T>) t;
-                    return new AppendElements<>(t.head(), queue, a.tail);
+                    return new AppendElements<>(a.head(), a.queue.appendAll(queue), a.tail);
                 }
             }
         }

File: javaslang/src/main/java/javaslang/collection/Stream.java
Patch:
@@ -1475,7 +1475,7 @@ public String toString() {
                 final Cons<T> cons = (Cons<T>) stream;
                 builder.append(cons.head);
                 if (cons.tail.isEvaluated()) {
-                    stream = cons.tail.get();
+                    stream = stream.tail();
                     if (!stream.isEmpty()) {
                         builder.append(", ");
                     }
@@ -1544,10 +1544,10 @@ public Stream<T> tail() {
             } else {
                 if(t instanceof ConsImpl) {
                     ConsImpl<T> c = (ConsImpl<T>) t;
-                    return new AppendElements<>(t.head(), queue, c.tail);
+                    return new AppendElements<>(c.head(), queue, c.tail);
                 } else {
                     AppendElements<T> a = (AppendElements<T>) t;
-                    return new AppendElements<>(t.head(), queue, a.tail);
+                    return new AppendElements<>(a.head(), a.queue.appendAll(queue), a.tail);
                 }
             }
         }

File: javaslang/src/main/java/javaslang/collection/IndexedSeq.java
Patch:
@@ -374,7 +374,7 @@ default boolean startsWith(Iterable<? extends T> that, int offset) {
      * <i>insertion point</i> is defined as the point at which the
      * element would be inserted into the sequence. Note that this guarantees that
      * the return value will be &gt;= 0 if and only if the element is found.
-     * @throws ClassCastException if T cannot be cast to `Comparable<T>`
+     * @throws ClassCastException if T cannot be cast to {@code Comparable<? super T>}
      */
     @SuppressWarnings("unchecked")
     default int search(T element) {

File: javaslang/src/main/java/javaslang/collection/LinearSeq.java
Patch:
@@ -310,7 +310,7 @@ default int segmentLength(Predicate<? super T> predicate, int from) {
      *         <i>insertion point</i> is defined as the point at which the
      *         element would be inserted into the sequence. Note that this guarantees that
      *         the return value will be &gt;= 0 if and only if the element is found.
-     * @throws ClassCastException if T cannot be cast to `Comparable<T>`
+     * @throws ClassCastException if T cannot be cast to {@code Comparable<? super T>}
      */
     @SuppressWarnings("unchecked")
     default int search(T element) {

File: javaslang/src/main/java/javaslang/collection/Seq.java
Patch:
@@ -825,7 +825,7 @@ default <U> U transform(Function<? super Seq<? super T>, ? extends U> f) {
      *         <i>insertion point</i> is defined as the point at which the
      *         element would be inserted into the sequence. Note that this guarantees that
      *         the return value will be &gt;= 0 if and only if the element is found.
-     * @throws ClassCastException if T cannot be cast to `Comparable<T>`
+     * @throws ClassCastException if T cannot be cast to {@code Comparable<? super T>}
      */
     int search(T element);
 

File: javaslang/src/test/java/javaslang/collection/AbstractSeqTest.java
Patch:
@@ -1506,14 +1506,14 @@ public void shouldSearchNegatedInsertionPointMinusOneForAbsentElementsUsingCompa
     // -- IndexedSeq special cases
 
     @Test
-    public void shouldTestIdexedSeqStartsWithNonIndexedSeq() {
+    public void shouldTestIndexedSeqStartsWithNonIndexedSeq() {
         assertThat(of(1, 3, 4).startsWith(Stream.of(1, 3))).isTrue();
         assertThat(of(1, 2, 3, 4).startsWith(Stream.of(1, 2, 4))).isFalse();
         assertThat(of(1, 2).startsWith(Stream.of(1, 2, 4))).isFalse();
     }
 
     @Test
-    public void shouldTestIdexedSeqEndsWithNonIndexedSeq() {
+    public void shouldTestIndexedSeqEndsWithNonIndexedSeq() {
         assertThat(of(1, 3, 4).endsWith(Stream.of(3, 4))).isTrue();
         assertThat(of(1, 2, 3, 4).endsWith(Stream.of(2, 3, 5))).isFalse();
     }

File: javaslang/src/test/java/javaslang/collection/AbstractSeqTest.java
Patch:
@@ -1506,14 +1506,14 @@ public void shouldSearchNegatedInsertionPointMinusOneForAbsentElementsUsingCompa
     // -- IndexedSeq special cases
 
     @Test
-    public void shouldTestIdexedSeqStartsWithNonIndexedSeq() {
+    public void shouldTestIndexedSeqStartsWithNonIndexedSeq() {
         assertThat(of(1, 3, 4).startsWith(Stream.of(1, 3))).isTrue();
         assertThat(of(1, 2, 3, 4).startsWith(Stream.of(1, 2, 4))).isFalse();
         assertThat(of(1, 2).startsWith(Stream.of(1, 2, 4))).isFalse();
     }
 
     @Test
-    public void shouldTestIdexedSeqEndsWithNonIndexedSeq() {
+    public void shouldTestIndexedSeqEndsWithNonIndexedSeq() {
         assertThat(of(1, 3, 4).endsWith(Stream.of(3, 4))).isTrue();
         assertThat(of(1, 2, 3, 4).endsWith(Stream.of(2, 3, 5))).isFalse();
     }

File: javaslang/src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -88,6 +88,8 @@ public static <K, V> TreeMap<K, V> empty(Comparator<? super K> keyComparator) {
      * Narrows a widened {@code TreeMap<? extends K, ? extends V>} to {@code TreeMap<K, V>}
      * by performing a type safe-cast. This is eligible because immutable/read-only
      * collections are covariant.
+     * <p>
+     * CAUTION: If {@code K} is narrowed, the underlying {@code Comparator} might fail!
      *
      * @param treeMap A {@code TreeMap}.
      * @param <K>     Key type

File: javaslang/src/main/java/javaslang/collection/TreeSet.java
Patch:
@@ -70,6 +70,8 @@ public static <T> TreeSet<T> empty(Comparator<? super T> comparator) {
      * Narrows a widened {@code TreeSet<? extends T>} to {@code TreeSet<T>}
      * by performing a type safe-cast. This is eligible because immutable/read-only
      * collections are covariant.
+     * <p>
+     * CAUTION: The underlying {@code Comparator} might fail!
      *
      * @param treeSet A {@code TreeSet}.
      * @param <T>     Component type of the {@code TreeSet}.

File: javaslang/src/test/java/javaslang/collection/AbstractTraversableTest.java
Patch:
@@ -83,7 +83,7 @@ public void shouldCreateNil() {
     public void shouldNarrowTraversable() {
         final Traversable<Double> doubles = of(1.0d);
         final Traversable<Number> numbers = Traversable.narrow(doubles);
-        final boolean actual = numbers.contains(new BigDecimal("1.0"));
+        final boolean actual = numbers.contains(new BigDecimal("2.0"));
         assertThat(actual).isFalse();
     }
 

File: javaslang/src/test/java/javaslang/collection/TreeMapTest.java
Patch:
@@ -21,7 +21,7 @@
 
 import static javaslang.collection.Comparators.naturalComparator;
 
-public class TreeMapTest extends AbstractMapTest {
+public class TreeMapTest extends AbstractSortedMapTest {
 
     @Override
     protected String className() {
@@ -87,8 +87,8 @@ protected <K, V> TreeMap<K, V> mapFill(int n, Supplier<? extends Tuple2<? extend
     @Test
     public void shouldNarrowTreeMap() {
         final TreeMap<Integer, Double> int2doubleMap = mapOf(1, 1.0d);
-        final TreeMap<Number, Number> number2numberMap = TreeMap.narrow(int2doubleMap);
-        final int actual = number2numberMap.put(new BigDecimal("2"), new BigDecimal("2.0")).values().sum().intValue();
+        final TreeMap<Integer, Number> number2numberMap = TreeMap.narrow(int2doubleMap);
+        final int actual = number2numberMap.put(2, new BigDecimal("2.0")).values().sum().intValue();
         assertThat(actual).isEqualTo(3);
     }
 

File: javaslang/src/main/java/javaslang/concurrent/Future.java
Patch:
@@ -618,7 +618,7 @@ default Future<T> fallbackTo(Future<? extends T> that) {
     }
 
     /**
-     * Shortcut for {@code filterTry(predicate::test}, see {@link #filterTry(CheckedPredicate)}.
+     * Shortcut for {@code filterTry(predicate::test}.
      *
      * @param predicate A predicate
      * @return A new {@code Future}

File: javaslang/src/main/java/javaslang/concurrent/Future.java
Patch:
@@ -618,7 +618,7 @@ default Future<T> fallbackTo(Future<? extends T> that) {
     }
 
     /**
-     * Shortcut for {@code filterTry(predicate::test}, see {@link #filterTry(CheckedPredicate)}.
+     * Shortcut for {@code filterTry(predicate::test}.
      *
      * @param predicate A predicate
      * @return A new {@code Future}

File: src/main/java/javaslang/Lazy.java
Patch:
@@ -5,7 +5,6 @@
  */
 package javaslang;
 
-import javaslang.algebra.Monad;
 import javaslang.collection.Iterator;
 import javaslang.collection.List;
 import javaslang.collection.Seq;

File: src/main/java/javaslang/concurrent/Future.java
Patch:
@@ -269,7 +269,7 @@ static <T> Future<T> fromTry(Try<? extends T> result) {
     static <T> Future<T> fromTry(ExecutorService executorService, Try<? extends T> result) {
         Objects.requireNonNull(executorService, "executorService is null");
         Objects.requireNonNull(result, "result is null");
-        return Promise.fromTry(executorService, result).future();
+        return Promise.<T> fromTry(executorService, result).future();
     }
 
     /**
@@ -337,7 +337,7 @@ static <T> Future<T> reduce(ExecutorService executorService, Iterable<? extends
         if (!futures.iterator().hasNext()) {
             throw new NoSuchElementException("Future.reduce on empty futures");
         } else {
-            return Future.sequence(futures).map(seq -> seq.reduceLeft(f));
+            return Future.<T> sequence(futures).map(seq -> seq.reduceLeft(f));
         }
     }
 

File: src/main/java/javaslang/control/Either.java
Patch:
@@ -366,7 +366,7 @@ private LeftProjection(Either<L, R> either) {
         }
 
         public <L2, R2> LeftProjection<L2, R2> bimap(Function<? super L, ? extends L2> leftMapper, Function<? super R, ? extends R2> rightMapper) {
-            return either.bimap(leftMapper, rightMapper).left();
+            return either.<L2, R2> bimap(leftMapper, rightMapper).left();
         }
 
         @Override
@@ -597,7 +597,7 @@ private RightProjection(Either<L, R> either) {
         }
 
         public <L2, R2> RightProjection<L2, R2> bimap(Function<? super L, ? extends L2> leftMapper, Function<? super R, ? extends R2> rightMapper) {
-            return either.bimap(leftMapper, rightMapper).right();
+            return either.<L2, R2> bimap(leftMapper, rightMapper).right();
         }
 
         @Override

File: src/main/java/javaslang/control/Validation.java
Patch:
@@ -450,9 +450,8 @@ default <U> Validation<U, T> leftMap(Function<? super E, ? extends U> f) {
         }
     }
 
-    @SuppressWarnings("unchecked")
     default <U> Validation<List<E>, U> ap(Validation<List<E>, ? extends Function<? super T, ? extends U>> validation) {
-        Objects.requireNonNull(validation, "kind is null");
+        Objects.requireNonNull(validation, "validation is null");
         if (isValid() && validation.isValid()) {
             Function<? super T, ? extends U> f = validation.get();
             U u = f.apply(this.get());

File: src/test/java/javaslang/collection/AbstractMapTest.java
Patch:
@@ -727,7 +727,6 @@ public void mapOfEntriesShouldReturnTheSingletonEmpty() {
         assertThat(mapOfEntries()).isSameAs(emptyMap());
     }
 
-    @SuppressWarnings("unchecked")
     @Test
     public void mapOfPairsShouldReturnTheSingletonEmpty() {
         if (!emptyMapShouldBeSingleton()) return;

File: src/test/java/javaslang/control/ValidationTest.java
Patch:
@@ -66,14 +66,14 @@ public void shouldCreateFailureWhenCallingValidationFailure() {
     @Test
     public void shouldConvertSuccessToU() {
         Validation<List<String>, String> validValidation = valid();
-        Integer result = validValidation.bifold(List::length, String::length);
+        Integer result = validValidation.fold(List::length, String::length);
         assertThat(result).isEqualTo(2);
     }
 
     @Test
     public void shouldConvertFailureToU() {
         Validation<List<String>, String> invalidValidation = invalid();
-        Integer result = invalidValidation.bifold(List::length, String::length);
+        Integer result = invalidValidation.fold(List::length, String::length);
         assertThat(result).isEqualTo(3);
     }
 

File: src/main/java/javaslang/control/Validation.java
Patch:
@@ -521,7 +521,7 @@ default <U> Validation<E, U> flatMap(Function<? super T, ? extends Iterable<? ex
                 return value.isEmpty() ? /*TODO(#1034)*/invalid(null) : valid(value.get());
             } else {
                 final java.util.Iterator<? extends U> iterator = iterable.iterator();
-                return iterator.hasNext() ? /*TODO(#1034)*/invalid(null) : valid(iterator.next());
+                return iterator.hasNext() ? valid(iterator.next()) : /*TODO(#1034)*/invalid(null);
             }
         }
     }

File: src/main/java/javaslang/control/Validation.java
Patch:
@@ -521,7 +521,7 @@ default <U> Validation<E, U> flatMap(Function<? super T, ? extends Iterable<? ex
                 return value.isEmpty() ? /*TODO(#1034)*/invalid(null) : valid(value.get());
             } else {
                 final java.util.Iterator<? extends U> iterator = iterable.iterator();
-                return iterator.hasNext() ? /*TODO(#1034)*/invalid(null) : valid(iterator.next());
+                return iterator.hasNext() ? valid(iterator.next()) : /*TODO(#1034)*/invalid(null);
             }
         }
     }

File: src/test/java/javaslang/control/ValidationTest.java
Patch:
@@ -38,14 +38,14 @@ public void shouldCreateFailureWhenCallingValidationFailure() {
     @Test
     public void shouldConvertSuccessToU() {
         Validation<List<String>, String> validValidation = valid();
-        Integer result = validValidation.fold(List::length, String::length);
+        Integer result = validValidation.bifold(List::length, String::length);
         assertThat(result).isEqualTo(2);
     }
 
     @Test
     public void shouldConvertFailureToU() {
         Validation<List<String>, String> invalidValidation = invalid();
-        Integer result = invalidValidation.fold(List::length, String::length);
+        Integer result = invalidValidation.bifold(List::length, String::length);
         assertThat(result).isEqualTo(3);
     }
 

File: src/main/java/javaslang/Value.java
Patch:
@@ -253,7 +253,7 @@ default boolean exists(Predicate<? super T> predicate) {
      * Filters this {@code Value} by testing a predicate.
      * <p>
      * The semantics may vary from class to class, e.g. for single-valued types (like {@code Option})
-     * and multi-valued types (like {@link Traversable).
+     * and multi-valued types (like {@link Traversable}).
      * The commonality is that filtered.isEmpty() will return true, if no element satisfied the given predicate.
      *
      * @param predicate A predicate

File: src/main/java/javaslang/algebra/Kind2.java
Patch:
@@ -7,8 +7,6 @@
 
 /**
  * Recursive self type representing {@code TYPE<T1, T2>}, which allows similar behavior to higher-kinded types.
- * <p>
- * For a general info on how to use Kind types see {@link Kind1}.
  *
  * @param <TYPE> The recursive type described by {@code Kind2}
  * @param <T1>   The first type, described by {@code Kind2}

File: src/main/java/javaslang/algebra/Foldable.java
Patch:
@@ -78,7 +78,7 @@ default T foldLeft(Monoid<? extends T> monoid) {
     /**
      * Folds this elements from the left, starting with {@code zero} and successively calling {@code combine}.
      *
-     * @param <U>     the type of the folded value
+     * @param <U>     the type to fold over
      * @param zero    A zero element to start with.
      * @param combine A function which combines elements.
      * @return a folded value
@@ -148,7 +148,7 @@ default T reduce(BiFunction<? super T, ? super T, ? extends T> op) {
      * The order of element iteration is undetermined.
      *
      * @param op A BiFunction of type T
-     * @return Some of reduced value or None.
+     * @return Some of reduced value or None if the Foldable is empty.
      * @throws NullPointerException if {@code op} is null
      */
     default Option<T> reduceOption(BiFunction<? super T, ? super T, ? extends T> op) {
@@ -170,7 +170,7 @@ default Option<T> reduceOption(BiFunction<? super T, ? super T, ? extends T> op)
      * Accumulates the elements of this Foldable by successively calling the given operation {@code op} from the left.
      *
      * @param op A BiFunction of type T
-     * @return Some of reduced value or None.
+     * @return Some of reduced value or None if the Foldable is empty.
      * @throws NullPointerException if {@code op} is null
      */
     Option<T> reduceLeftOption(BiFunction<? super T, ? super T, ? extends T> op);

File: src/main/java/javaslang/algebra/Kind2.java
Patch:
@@ -7,6 +7,8 @@
 
 /**
  * Recursive self type representing {@code TYPE<T1, T2>}, which allows similar behavior to higher-kinded types.
+ * <p>
+ * For a general example how to use Kind* see {@link Kind}.
  *
  * @param <TYPE> The recursive type described by {@code Kind2}
  * @param <T1>   The first type, described by {@code Kind2}
@@ -15,5 +17,4 @@
  * @since 2.0.0
  */
 public interface Kind2<TYPE extends Kind2<TYPE, ?, ?>, T1, T2> {
-
 }

File: src/test/java/javaslang/control/OptionTest.java
Patch:
@@ -201,7 +201,7 @@ public void shouldReduceRightNonNil() {
     // -- reduceRightOption
 
     @Test
-    public void shouldThrowWhenReduceRightOptionNil() {
+    public void shouldReduceRightOptionNil() {
         assertThat(Option.none().reduceRightOption((a, b) -> a)).isSameAs(Option.none());
     }
 

File: src-gen/main/java/javaslang/algebra/Monad.java
Patch:
@@ -241,7 +241,7 @@ public interface Monad<M extends Kind1<M, ?>, T> extends Kind1<M, T>, Functor<T>
      * @return a mapped {@code Monad}
      * @throws NullPointerException if {@code mapper} is null
      */
-    <U> Monad<M, U> flatMapM(Function<? super T, ? extends Kind1<M, U>> mapper);
+    <U> Monad<M, U> flatMapM(Function<? super T, ? extends Kind1<? extends M, ? extends U>> mapper);
 
     // -- adjusting return types of super interface methods
 

File: src-gen/main/java/javaslang/algebra/Monad.java
Patch:
@@ -68,8 +68,8 @@
  * </ul>
  *
  * The {@code select} functioned mentioned is not explicitly defined. Monad implementations are responsible for
- * implementing the correct behavior of {@code flatMap}. For single-valued types {@link javaslang.Value#get(Iterable)}
- * may be used.
+ * implementing the correct behavior of {@code flatMap}. For single-valued types
+ * {@link javaslang.Value#getOption(Iterable)} may be used.
  * <p>
  * To read further about monads in Java please refer to
  * <a href="http://java.dzone.com/articles/whats-wrong-java-8-part-iv">What's Wrong in Java 8, Part IV: Monads</a>.

File: src/main/java/javaslang/Value.java
Patch:
@@ -32,7 +32,7 @@
  * Static methods:
  *
  * <ul>
- * <li>{@link #get(Iterable)}</li>
+ * <li>{@link #getOption(Iterable)}</li>
  * </ul>
  *
  * Basic operations:

File: src-gen/main/java/javaslang/algebra/Monad.java
Patch:
@@ -68,8 +68,8 @@
  * </ul>
  *
  * The {@code select} functioned mentioned is not explicitly defined. Monad implementations are responsible for
- * implementing the correct behavior of {@code flatMap}. For single-valued types {@link javaslang.Value#get(Iterable)}
- * may be used.
+ * implementing the correct behavior of {@code flatMap}. For single-valued types
+ * {@link javaslang.Value#getOption(Iterable)} may be used.
  * <p>
  * To read further about monads in Java please refer to
  * <a href="http://java.dzone.com/articles/whats-wrong-java-8-part-iv">What's Wrong in Java 8, Part IV: Monads</a>.

File: src/main/java/javaslang/Value.java
Patch:
@@ -32,7 +32,7 @@
  * Static methods:
  *
  * <ul>
- * <li>{@link #get(Iterable)}</li>
+ * <li>{@link #getOption(Iterable)}</li>
  * </ul>
  *
  * Basic operations:

File: src/main/java/javaslang/collection/Array.java
Patch:
@@ -75,7 +75,6 @@ public static <T> Array<T> empty() {
      * @param <T>     The component type
      * @return A new Array instance containing the given element
      */
-    @SuppressWarnings("unchecked")
     public static <T> Array<T> of(T element) {
         return wrap(new Object[] { element });
     }

File: src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -306,7 +306,6 @@ public static <K, V> TreeMap<K, V> ofEntries(Comparator<? super K> keyComparator
      * @param keyComparator A key comparator
      * @return A new TreeMap containing the given entries.
      */
-    @SuppressWarnings("unchecked")
     @SafeVarargs
     public static <K, V> TreeMap<K, V> ofEntries(Comparator<? super K> keyComparator, java.util.Map.Entry<? extends K, ? extends V>... entries) {
         Objects.requireNonNull(keyComparator, "keyComparator is null");

File: src/main/java/javaslang/control/Either.java
Patch:
@@ -267,7 +267,7 @@ default <U> Either<L, U> flatMap(Function<? super R, ? extends Iterable<? extend
         Objects.requireNonNull(mapper, "mapper is null");
         if (isRight()) {
             // DEV-NOTE: Scala has an implicit converter (R -> L) in case mapper result is empty, we use null
-            return Value.getOption(mapper.apply(get())).toRight(null);
+            return (Either<L, U>) Value.getOption(mapper.apply(get())).toRight(null);
         } else {
             return (Either<L, U>) this;
         }

File: src/main/java/javaslang/collection/Array.java
Patch:
@@ -75,7 +75,6 @@ public static <T> Array<T> empty() {
      * @param <T>     The component type
      * @return A new Array instance containing the given element
      */
-    @SuppressWarnings("unchecked")
     public static <T> Array<T> of(T element) {
         return wrap(new Object[] { element });
     }

File: src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -306,7 +306,6 @@ public static <K, V> TreeMap<K, V> ofEntries(Comparator<? super K> keyComparator
      * @param keyComparator A key comparator
      * @return A new TreeMap containing the given entries.
      */
-    @SuppressWarnings("unchecked")
     @SafeVarargs
     public static <K, V> TreeMap<K, V> ofEntries(Comparator<? super K> keyComparator, java.util.Map.Entry<? extends K, ? extends V>... entries) {
         Objects.requireNonNull(keyComparator, "keyComparator is null");

File: src/main/java/javaslang/Value.java
Patch:
@@ -354,9 +354,7 @@ default Option<T> reduceRightOption(BiFunction<? super T, ? super T, ? extends T
     // -- Convertible implementation
 
     @Override
-    default Match.MatchMonad.Of<? extends Value<T>> match() {
-        return Match.of(this);
-    }
+    Match.MatchMonad.Of<? extends Value<T>> match();
 
     @Override
     default Array<T> toArray() {

File: src/main/java/javaslang/Value.java
Patch:
@@ -354,9 +354,7 @@ default Option<T> reduceRightOption(BiFunction<? super T, ? super T, ? extends T
     // -- Convertible implementation
 
     @Override
-    default Match.MatchMonad.Of<? extends Value<T>> match() {
-        return Match.of(this);
-    }
+    Match.MatchMonad.Of<? extends Value<T>> match();
 
     @Override
     default Array<T> toArray() {

File: src/main/java/javaslang/Kind2.java
Patch:
@@ -1,5 +1,5 @@
 package javaslang;
 
-public interface Kind2<TYPE extends Kind2<TYPE, ?, ?>, E, T> {
+public interface Kind2<TYPE extends Kind2<TYPE, ?, ?>, T1, T2> {
 
 }

File: src/main/java/javaslang/algebra/Applicative.java
Patch:
@@ -10,11 +10,11 @@
 
 import java.util.function.Function;
 
-public interface Applicative<TYPE extends Kind2<TYPE, ?, ?>, E, T> extends Functor<T> {
+public interface Applicative<TYPE extends Kind2<TYPE, ?, ?>, T1, T2> extends Functor<T2> {
 
-    <U> Applicative<TYPE, List<E>, U> ap(Kind2<TYPE, List<E>, ? extends Function<? super T, ? extends U>> f);
+    <U> Applicative<TYPE, List<T1>, U> ap(Kind2<TYPE, List<T1>, ? extends Function<? super T2, ? extends U>> f);
 
     @Override
-    <U> Applicative<TYPE, E, U> map(Function<? super T, ? extends U> f);
+    <U> Applicative<TYPE, T1, U> map(Function<? super T2, ? extends U> f);
 
 }

File: src/main/java/javaslang/collection/CharSeq.java
Patch:
@@ -129,7 +129,7 @@ public static CharSeq ofAll(Iterable<? extends Character> elements) {
      * @return A CharSeq consisting of elements {@code f(0),f(1), ..., f(n - 1)}
      * @throws NullPointerException if {@code f} is null
      */
-    public static CharSeq tabulate(int n, Function<? super Integer, Character> f) {
+    public static CharSeq tabulate(int n, Function<? super Integer, ? extends Character> f) {
         Objects.requireNonNull(f, "f is null");
         StringBuilder sb = new StringBuilder();
         for (int i = 0; i < n; i++) {
@@ -146,7 +146,7 @@ public static CharSeq tabulate(int n, Function<? super Integer, Character> f) {
      * @return A CharSeq of size {@code n}, where each element contains the result supplied by {@code s}.
      * @throws NullPointerException if {@code s} is null
      */
-    public static CharSeq fill(int n, Supplier<Character> s) {
+    public static CharSeq fill(int n, Supplier<? extends Character> s) {
         return tabulate(n, anything -> s.get());
     }
 

File: src/main/java/javaslang/collection/Array.java
Patch:
@@ -213,7 +213,7 @@ public static Array<Short> ofAll(short[] array) {
      * @return An Array consisting of elements {@code f(0),f(1), ..., f(n - 1)}
      * @throws NullPointerException if {@code f} is null
      */
-    public static <T> Array<T> tabulate(int n, Function<Integer, ? extends T> f) {
+    public static <T> Array<T> tabulate(int n, Function<? super Integer, ? extends T> f) {
         Objects.requireNonNull(f, "f is null");
         int nOrZero = java.lang.Math.max(n, 0);
         @SuppressWarnings("unchecked")

File: src/main/java/javaslang/collection/CharSeq.java
Patch:
@@ -129,7 +129,7 @@ public static CharSeq ofAll(Iterable<? extends Character> elements) {
      * @return A CharSeq consisting of elements {@code f(0),f(1), ..., f(n - 1)}
      * @throws NullPointerException if {@code f} is null
      */
-    public static CharSeq tabulate(int n, Function<Integer, Character> f) {
+    public static CharSeq tabulate(int n, Function<? super Integer, Character> f) {
         Objects.requireNonNull(f, "f is null");
         StringBuilder sb = new StringBuilder();
         for (int i = 0; i < n; i++) {

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -288,7 +288,7 @@ static List<Short> ofAll(short[] array) {
      * @return A List consisting of elements {@code f(0),f(1), ..., f(n - 1)}
      * @throws NullPointerException if {@code f} is null
      */
-    static <T> List<T> tabulate(int n, Function<Integer, ? extends T> f) {
+    static <T> List<T> tabulate(int n, Function<? super Integer, ? extends T> f) {
         Objects.requireNonNull(f, "f is null");
         int nOrZero = java.lang.Math.max(n, 0);
         @SuppressWarnings("unchecked")

File: src/main/java/javaslang/collection/Queue.java
Patch:
@@ -248,7 +248,7 @@ public static Queue<Short> ofAll(short[] array) {
      * @return A Queue consisting of elements {@code f(0),f(1), ..., f(n - 1)}
      * @throws NullPointerException if {@code f} is null
      */
-    public static <T> Queue<T> tabulate(int n, Function<Integer, ? extends T> f) {
+    public static <T> Queue<T> tabulate(int n, Function<? super Integer, ? extends T> f) {
         Objects.requireNonNull(f, "f is null");
         return new Queue<>(List.tabulate(n, f), List.empty());
     }

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -127,7 +127,7 @@ static <T> Seq<T> ofAll(Iterable<? extends T> elements) {
      * @return A Seq consisting of elements {@code f(0),f(1), ..., f(n - 1)}
      * @throws NullPointerException if {@code f} is null
      */
-    static <T> Seq<T> tabulate(int n, Function<Integer, ? extends T> f) {
+    static <T> Seq<T> tabulate(int n, Function<? super Integer, ? extends T> f) {
         Objects.requireNonNull(f, "f is null");
         return List.tabulate(n, f);
     }

File: src/main/java/javaslang/collection/Stack.java
Patch:
@@ -212,7 +212,7 @@ static Stack<Short> ofAll(short[] array) {
      * @return A Stack consisting of elements {@code f(0),f(1), ..., f(n - 1)}
      * @throws NullPointerException if {@code f} is null
      */
-    static <T> Stack<T> tabulate(int n, Function<Integer, ? extends T> f) {
+    static <T> Stack<T> tabulate(int n, Function<? super Integer, ? extends T> f) {
         Objects.requireNonNull(f, "f is null");
         return List.tabulate(n, f);
     }

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -242,7 +242,7 @@ public T next() {
      * @return A Stream consisting of elements {@code f(0),f(1), ..., f(n - 1)}
      * @throws NullPointerException if {@code f} is null
      */
-    static <T> Stream<T> tabulate(int n, Function<Integer, ? extends T> f) {
+    static <T> Stream<T> tabulate(int n, Function<? super Integer, ? extends T> f) {
         Objects.requireNonNull(f, "f is null");
         int nOrZero = java.lang.Math.max(n, 0);
         @SuppressWarnings("unchecked")

File: src/main/java/javaslang/collection/Vector.java
Patch:
@@ -109,7 +109,7 @@ public static <T> Vector<T> of(T... elements) {
      * @return A Vector consisting of elements {@code f(0),f(1), ..., f(n - 1)}
      * @throws NullPointerException if {@code f} is null
      */
-    public static <T> Vector<T> tabulate(int n, Function<Integer, ? extends T> f) {
+    public static <T> Vector<T> tabulate(int n, Function<? super Integer, ? extends T> f) {
         Objects.requireNonNull(f, "f is null");
         HashArrayMappedTrie<Integer, T> trie = HashArrayMappedTrie.empty();
         for (int i = 0; i <n; i++) {

File: src/test/java/javaslang/collection/ArrayTest.java
Patch:
@@ -82,7 +82,7 @@ protected Array<Short> ofAll(short[] array) {
     }
 
     @Override
-    protected <T> Array<T> tabulate(int n, Function<Integer, ? extends T> f) {
+    protected <T> Array<T> tabulate(int n, Function<? super Integer, ? extends T> f) {
         return Array.tabulate(n, f);
     }
 

File: src/test/java/javaslang/collection/CharSeqTest.java
Patch:
@@ -3006,7 +3006,7 @@ public void shouldCreateListOfIterable() {
 
     @Test
     public void shouldTabulateTheCharSeq() {
-        Function<Integer, Character> f = i -> i.toString().charAt(0);
+        Function<Number, Character> f = i -> i.toString().charAt(0);
         CharSeq actual = CharSeq.tabulate(3, f);
         assertThat(actual).isEqualTo(CharSeq.of('0', '1', '2'));
     }

File: src/test/java/javaslang/collection/ListTest.java
Patch:
@@ -89,7 +89,7 @@ protected List<Short> ofAll(short[] array) {
     }
 
     @Override
-    protected <T> List<T> tabulate(int n, Function<Integer, ? extends T> f) {
+    protected <T> List<T> tabulate(int n, Function<? super Integer, ? extends T> f) {
         return List.tabulate(n, f);
     }
 

File: src/test/java/javaslang/collection/QueueTest.java
Patch:
@@ -87,7 +87,7 @@ protected Queue<Short> ofAll(short[] array) {
     }
 
     @Override
-    protected <T> Queue<T> tabulate(int n, Function<Integer, ? extends T> f) {
+    protected <T> Queue<T> tabulate(int n, Function<? super Integer, ? extends T> f) {
         return Queue.tabulate(n, f);
     }
 

File: src/test/java/javaslang/collection/StackTest.java
Patch:
@@ -82,7 +82,7 @@ protected Stack<Short> ofAll(short[] array) {
     }
 
     @Override
-    protected <T> Stack<T> tabulate(int n, Function<Integer, ? extends T> f) {
+    protected <T> Stack<T> tabulate(int n, Function<? super Integer, ? extends T> f) {
         return Stack.tabulate(n, f);
     }
 

File: src/test/java/javaslang/collection/StreamTest.java
Patch:
@@ -88,7 +88,7 @@ protected Stream<Short> ofAll(short[] array) {
     }
 
     @Override
-    protected <T> Stream<T> tabulate(int n, Function<Integer, ? extends T> f) {
+    protected <T> Stream<T> tabulate(int n, Function<? super Integer, ? extends T> f) {
         return Stream.tabulate(n, f);
     }
 

File: src/test/java/javaslang/collection/VectorTest.java
Patch:
@@ -83,7 +83,7 @@ protected Vector<Short> ofAll(short[] array) {
     }
 
     @Override
-    protected <T> Vector<T> tabulate(int n, Function<Integer, ? extends T> f) {
+    protected <T> Vector<T> tabulate(int n, Function<? super Integer, ? extends T> f) {
         return Vector.tabulate(n, f);
     }
 

File: src/test/java/javaslang/collection/AbstractSeqTest.java
Patch:
@@ -62,9 +62,9 @@ public abstract class AbstractSeqTest extends AbstractTraversableRangeTest {
     @Override
     abstract protected Seq<Short> ofAll(short[] array);
 
-    abstract protected <T> Seq<T> tabulate(Integer n, Function<Integer, ? extends T> f);
+    abstract protected <T> Seq<T> tabulate(int n, Function<Integer, ? extends T> f);
 
-    abstract protected <T> Seq<T> fill(Integer n, Supplier<? extends T> s);
+    abstract protected <T> Seq<T> fill(int n, Supplier<? extends T> s);
 
     @Override
     abstract protected Seq<Character> range(char from, char toExclusive);

File: src/test/java/javaslang/collection/ArrayTest.java
Patch:
@@ -82,12 +82,12 @@ protected Array<Short> ofAll(short[] array) {
     }
 
     @Override
-    protected <T> Array<T> tabulate(Integer n, Function<Integer, ? extends T> f) {
+    protected <T> Array<T> tabulate(int n, Function<Integer, ? extends T> f) {
         return Array.tabulate(n, f);
     }
 
     @Override
-    protected <T> Array<T> fill(Integer n, Supplier<? extends T> s) {
+    protected <T> Array<T> fill(int n, Supplier<? extends T> s) {
         return Array.fill(n, s);
     }
 

File: src/test/java/javaslang/collection/ListTest.java
Patch:
@@ -89,12 +89,12 @@ protected List<Short> ofAll(short[] array) {
     }
 
     @Override
-    protected <T> List<T> tabulate(Integer n, Function<Integer, ? extends T> f) {
+    protected <T> List<T> tabulate(int n, Function<Integer, ? extends T> f) {
         return List.tabulate(n, f);
     }
 
     @Override
-    protected <T> List<T> fill(Integer n, Supplier<? extends T> s) {
+    protected <T> List<T> fill(int n, Supplier<? extends T> s) {
         return List.fill(n, s);
     }
 

File: src/test/java/javaslang/collection/QueueTest.java
Patch:
@@ -87,12 +87,12 @@ protected Queue<Short> ofAll(short[] array) {
     }
 
     @Override
-    protected <T> Queue<T> tabulate(Integer n, Function<Integer, ? extends T> f) {
+    protected <T> Queue<T> tabulate(int n, Function<Integer, ? extends T> f) {
         return Queue.tabulate(n, f);
     }
 
     @Override
-    protected <T> Queue<T> fill(Integer n, Supplier<? extends T> s) {
+    protected <T> Queue<T> fill(int n, Supplier<? extends T> s) {
         return Queue.fill(n, s);
     }
 

File: src/test/java/javaslang/collection/StackTest.java
Patch:
@@ -82,12 +82,12 @@ protected Stack<Short> ofAll(short[] array) {
     }
 
     @Override
-    protected <T> Stack<T> tabulate(Integer n, Function<Integer, ? extends T> f) {
+    protected <T> Stack<T> tabulate(int n, Function<Integer, ? extends T> f) {
         return Stack.tabulate(n, f);
     }
 
     @Override
-    protected <T> Stack<T> fill(Integer n, Supplier<? extends T> s) {
+    protected <T> Stack<T> fill(int n, Supplier<? extends T> s) {
         return Stack.fill(n, s);
     }
 

File: src/test/java/javaslang/collection/StreamTest.java
Patch:
@@ -88,12 +88,12 @@ protected Stream<Short> ofAll(short[] array) {
     }
 
     @Override
-    protected <T> Stream<T> tabulate(Integer n, Function<Integer, ? extends T> f) {
+    protected <T> Stream<T> tabulate(int n, Function<Integer, ? extends T> f) {
         return Stream.tabulate(n, f);
     }
 
     @Override
-    protected <T> Stream<T> fill(Integer n, Supplier<? extends T> s) {
+    protected <T> Stream<T> fill(int n, Supplier<? extends T> s) {
         return Stream.fill(n, s);
     }
 

File: src/test/java/javaslang/collection/VectorTest.java
Patch:
@@ -83,12 +83,12 @@ protected Vector<Short> ofAll(short[] array) {
     }
 
     @Override
-    protected <T> Vector<T> tabulate(Integer n, Function<Integer, ? extends T> f) {
+    protected <T> Vector<T> tabulate(int n, Function<Integer, ? extends T> f) {
         return Vector.tabulate(n, f);
     }
 
     @Override
-    protected <T> Vector<T> fill(Integer n, Supplier<? extends T> s) {
+    protected <T> Vector<T> fill(int n, Supplier<? extends T> s) {
         return Vector.fill(n, s);
     }
 

File: src-gen/main/java/javaslang/Function0.java
Patch:
@@ -10,6 +10,7 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
+import java.util.function.Function;
 import java.util.function.Supplier;
 import javaslang.Function0Module.Memoized;
 import javaslang.control.Option;
@@ -133,14 +134,14 @@ default boolean isMemoized() {
 
     /**
      * Returns a composed function that first applies this Function0 to the given argument and then applies
-     * {@linkplain Function1} {@code after} to the result.
+     * {@linkplain Function} {@code after} to the result.
      *
      * @param <V> return type of after
      * @param after the function applied after this
      * @return a function composed of this and after
      * @throws NullPointerException if after is null
      */
-    default <V> Function0<V> andThen(Function1<? super R, ? extends V> after) {
+    default <V> Function0<V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after, "after is null");
         return () -> after.apply(apply());
     }

File: src-gen/main/java/javaslang/Function2.java
Patch:
@@ -13,6 +13,7 @@
 import java.util.Map;
 import java.util.Objects;
 import java.util.function.BiFunction;
+import java.util.function.Function;
 import javaslang.Function2Module.Memoized;
 import javaslang.control.Option;
 import javaslang.control.Try;
@@ -153,14 +154,14 @@ default boolean isMemoized() {
 
     /**
      * Returns a composed function that first applies this Function2 to the given argument and then applies
-     * {@linkplain Function1} {@code after} to the result.
+     * {@linkplain Function} {@code after} to the result.
      *
      * @param <V> return type of after
      * @param after the function applied after this
      * @return a function composed of this and after
      * @throws NullPointerException if after is null
      */
-    default <V> Function2<T1, T2, V> andThen(Function1<? super R, ? extends V> after) {
+    default <V> Function2<T1, T2, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after, "after is null");
         return (t1, t2) -> after.apply(apply(t1, t2));
     }

File: src-gen/main/java/javaslang/Function3.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
+import java.util.function.Function;
 import javaslang.Function3Module.Memoized;
 import javaslang.control.Option;
 import javaslang.control.Try;
@@ -168,14 +169,14 @@ default boolean isMemoized() {
 
     /**
      * Returns a composed function that first applies this Function3 to the given argument and then applies
-     * {@linkplain Function1} {@code after} to the result.
+     * {@linkplain Function} {@code after} to the result.
      *
      * @param <V> return type of after
      * @param after the function applied after this
      * @return a function composed of this and after
      * @throws NullPointerException if after is null
      */
-    default <V> Function3<T1, T2, T3, V> andThen(Function1<? super R, ? extends V> after) {
+    default <V> Function3<T1, T2, T3, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3) -> after.apply(apply(t1, t2, t3));
     }

File: src-gen/main/java/javaslang/Function4.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
+import java.util.function.Function;
 import javaslang.Function4Module.Memoized;
 import javaslang.control.Option;
 import javaslang.control.Try;
@@ -185,14 +186,14 @@ default boolean isMemoized() {
 
     /**
      * Returns a composed function that first applies this Function4 to the given argument and then applies
-     * {@linkplain Function1} {@code after} to the result.
+     * {@linkplain Function} {@code after} to the result.
      *
      * @param <V> return type of after
      * @param after the function applied after this
      * @return a function composed of this and after
      * @throws NullPointerException if after is null
      */
-    default <V> Function4<T1, T2, T3, T4, V> andThen(Function1<? super R, ? extends V> after) {
+    default <V> Function4<T1, T2, T3, T4, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4) -> after.apply(apply(t1, t2, t3, t4));
     }

File: src-gen/main/java/javaslang/Function5.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
+import java.util.function.Function;
 import javaslang.Function5Module.Memoized;
 import javaslang.control.Option;
 import javaslang.control.Try;
@@ -203,14 +204,14 @@ default boolean isMemoized() {
 
     /**
      * Returns a composed function that first applies this Function5 to the given argument and then applies
-     * {@linkplain Function1} {@code after} to the result.
+     * {@linkplain Function} {@code after} to the result.
      *
      * @param <V> return type of after
      * @param after the function applied after this
      * @return a function composed of this and after
      * @throws NullPointerException if after is null
      */
-    default <V> Function5<T1, T2, T3, T4, T5, V> andThen(Function1<? super R, ? extends V> after) {
+    default <V> Function5<T1, T2, T3, T4, T5, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5) -> after.apply(apply(t1, t2, t3, t4, t5));
     }

File: src-gen/main/java/javaslang/Function6.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
+import java.util.function.Function;
 import javaslang.Function6Module.Memoized;
 import javaslang.control.Option;
 import javaslang.control.Try;
@@ -222,14 +223,14 @@ default boolean isMemoized() {
 
     /**
      * Returns a composed function that first applies this Function6 to the given argument and then applies
-     * {@linkplain Function1} {@code after} to the result.
+     * {@linkplain Function} {@code after} to the result.
      *
      * @param <V> return type of after
      * @param after the function applied after this
      * @return a function composed of this and after
      * @throws NullPointerException if after is null
      */
-    default <V> Function6<T1, T2, T3, T4, T5, T6, V> andThen(Function1<? super R, ? extends V> after) {
+    default <V> Function6<T1, T2, T3, T4, T5, T6, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6) -> after.apply(apply(t1, t2, t3, t4, t5, t6));
     }

File: src-gen/main/java/javaslang/Function7.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
+import java.util.function.Function;
 import javaslang.Function7Module.Memoized;
 import javaslang.control.Option;
 import javaslang.control.Try;
@@ -242,14 +243,14 @@ default boolean isMemoized() {
 
     /**
      * Returns a composed function that first applies this Function7 to the given argument and then applies
-     * {@linkplain Function1} {@code after} to the result.
+     * {@linkplain Function} {@code after} to the result.
      *
      * @param <V> return type of after
      * @param after the function applied after this
      * @return a function composed of this and after
      * @throws NullPointerException if after is null
      */
-    default <V> Function7<T1, T2, T3, T4, T5, T6, T7, V> andThen(Function1<? super R, ? extends V> after) {
+    default <V> Function7<T1, T2, T3, T4, T5, T6, T7, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7));
     }

File: src-gen/main/java/javaslang/Function8.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
+import java.util.function.Function;
 import javaslang.Function8Module.Memoized;
 import javaslang.control.Option;
 import javaslang.control.Try;
@@ -263,14 +264,14 @@ default boolean isMemoized() {
 
     /**
      * Returns a composed function that first applies this Function8 to the given argument and then applies
-     * {@linkplain Function1} {@code after} to the result.
+     * {@linkplain Function} {@code after} to the result.
      *
      * @param <V> return type of after
      * @param after the function applied after this
      * @return a function composed of this and after
      * @throws NullPointerException if after is null
      */
-    default <V> Function8<T1, T2, T3, T4, T5, T6, T7, T8, V> andThen(Function1<? super R, ? extends V> after) {
+    default <V> Function8<T1, T2, T3, T4, T5, T6, T7, T8, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8));
     }

File: src-gen/main/java/javaslang/Function0.java
Patch:
@@ -10,6 +10,7 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
+import java.util.function.Function;
 import java.util.function.Supplier;
 import javaslang.Function0Module.Memoized;
 import javaslang.control.Option;
@@ -133,14 +134,14 @@ default boolean isMemoized() {
 
     /**
      * Returns a composed function that first applies this Function0 to the given argument and then applies
-     * {@linkplain Function1} {@code after} to the result.
+     * {@linkplain Function} {@code after} to the result.
      *
      * @param <V> return type of after
      * @param after the function applied after this
      * @return a function composed of this and after
      * @throws NullPointerException if after is null
      */
-    default <V> Function0<V> andThen(Function1<? super R, ? extends V> after) {
+    default <V> Function0<V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after, "after is null");
         return () -> after.apply(apply());
     }

File: src-gen/main/java/javaslang/Function2.java
Patch:
@@ -13,6 +13,7 @@
 import java.util.Map;
 import java.util.Objects;
 import java.util.function.BiFunction;
+import java.util.function.Function;
 import javaslang.Function2Module.Memoized;
 import javaslang.control.Option;
 import javaslang.control.Try;
@@ -153,14 +154,14 @@ default boolean isMemoized() {
 
     /**
      * Returns a composed function that first applies this Function2 to the given argument and then applies
-     * {@linkplain Function1} {@code after} to the result.
+     * {@linkplain Function} {@code after} to the result.
      *
      * @param <V> return type of after
      * @param after the function applied after this
      * @return a function composed of this and after
      * @throws NullPointerException if after is null
      */
-    default <V> Function2<T1, T2, V> andThen(Function1<? super R, ? extends V> after) {
+    default <V> Function2<T1, T2, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after, "after is null");
         return (t1, t2) -> after.apply(apply(t1, t2));
     }

File: src-gen/main/java/javaslang/Function3.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
+import java.util.function.Function;
 import javaslang.Function3Module.Memoized;
 import javaslang.control.Option;
 import javaslang.control.Try;
@@ -168,14 +169,14 @@ default boolean isMemoized() {
 
     /**
      * Returns a composed function that first applies this Function3 to the given argument and then applies
-     * {@linkplain Function1} {@code after} to the result.
+     * {@linkplain Function} {@code after} to the result.
      *
      * @param <V> return type of after
      * @param after the function applied after this
      * @return a function composed of this and after
      * @throws NullPointerException if after is null
      */
-    default <V> Function3<T1, T2, T3, V> andThen(Function1<? super R, ? extends V> after) {
+    default <V> Function3<T1, T2, T3, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3) -> after.apply(apply(t1, t2, t3));
     }

File: src-gen/main/java/javaslang/Function4.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
+import java.util.function.Function;
 import javaslang.Function4Module.Memoized;
 import javaslang.control.Option;
 import javaslang.control.Try;
@@ -185,14 +186,14 @@ default boolean isMemoized() {
 
     /**
      * Returns a composed function that first applies this Function4 to the given argument and then applies
-     * {@linkplain Function1} {@code after} to the result.
+     * {@linkplain Function} {@code after} to the result.
      *
      * @param <V> return type of after
      * @param after the function applied after this
      * @return a function composed of this and after
      * @throws NullPointerException if after is null
      */
-    default <V> Function4<T1, T2, T3, T4, V> andThen(Function1<? super R, ? extends V> after) {
+    default <V> Function4<T1, T2, T3, T4, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4) -> after.apply(apply(t1, t2, t3, t4));
     }

File: src-gen/main/java/javaslang/Function5.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
+import java.util.function.Function;
 import javaslang.Function5Module.Memoized;
 import javaslang.control.Option;
 import javaslang.control.Try;
@@ -203,14 +204,14 @@ default boolean isMemoized() {
 
     /**
      * Returns a composed function that first applies this Function5 to the given argument and then applies
-     * {@linkplain Function1} {@code after} to the result.
+     * {@linkplain Function} {@code after} to the result.
      *
      * @param <V> return type of after
      * @param after the function applied after this
      * @return a function composed of this and after
      * @throws NullPointerException if after is null
      */
-    default <V> Function5<T1, T2, T3, T4, T5, V> andThen(Function1<? super R, ? extends V> after) {
+    default <V> Function5<T1, T2, T3, T4, T5, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5) -> after.apply(apply(t1, t2, t3, t4, t5));
     }

File: src-gen/main/java/javaslang/Function6.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
+import java.util.function.Function;
 import javaslang.Function6Module.Memoized;
 import javaslang.control.Option;
 import javaslang.control.Try;
@@ -222,14 +223,14 @@ default boolean isMemoized() {
 
     /**
      * Returns a composed function that first applies this Function6 to the given argument and then applies
-     * {@linkplain Function1} {@code after} to the result.
+     * {@linkplain Function} {@code after} to the result.
      *
      * @param <V> return type of after
      * @param after the function applied after this
      * @return a function composed of this and after
      * @throws NullPointerException if after is null
      */
-    default <V> Function6<T1, T2, T3, T4, T5, T6, V> andThen(Function1<? super R, ? extends V> after) {
+    default <V> Function6<T1, T2, T3, T4, T5, T6, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6) -> after.apply(apply(t1, t2, t3, t4, t5, t6));
     }

File: src-gen/main/java/javaslang/Function7.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
+import java.util.function.Function;
 import javaslang.Function7Module.Memoized;
 import javaslang.control.Option;
 import javaslang.control.Try;
@@ -242,14 +243,14 @@ default boolean isMemoized() {
 
     /**
      * Returns a composed function that first applies this Function7 to the given argument and then applies
-     * {@linkplain Function1} {@code after} to the result.
+     * {@linkplain Function} {@code after} to the result.
      *
      * @param <V> return type of after
      * @param after the function applied after this
      * @return a function composed of this and after
      * @throws NullPointerException if after is null
      */
-    default <V> Function7<T1, T2, T3, T4, T5, T6, T7, V> andThen(Function1<? super R, ? extends V> after) {
+    default <V> Function7<T1, T2, T3, T4, T5, T6, T7, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7));
     }

File: src-gen/main/java/javaslang/Function8.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
+import java.util.function.Function;
 import javaslang.Function8Module.Memoized;
 import javaslang.control.Option;
 import javaslang.control.Try;
@@ -263,14 +264,14 @@ default boolean isMemoized() {
 
     /**
      * Returns a composed function that first applies this Function8 to the given argument and then applies
-     * {@linkplain Function1} {@code after} to the result.
+     * {@linkplain Function} {@code after} to the result.
      *
      * @param <V> return type of after
      * @param after the function applied after this
      * @return a function composed of this and after
      * @throws NullPointerException if after is null
      */
-    default <V> Function8<T1, T2, T3, T4, T5, T6, T7, T8, V> andThen(Function1<? super R, ? extends V> after) {
+    default <V> Function8<T1, T2, T3, T4, T5, T6, T7, T8, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8));
     }

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -455,7 +455,8 @@ public HashMap<K, V> put(Tuple2<? extends K, ? extends V> entry) {
 
     @Override
     public HashMap<K, V> remove(K key) {
-        return new HashMap<>(trie.remove(key));
+        final HashArrayMappedTrie<K, V> result = trie.remove(key);
+        return result.size() == trie.size() ? this : new HashMap<>(result);
     }
 
     @Override
@@ -465,7 +466,7 @@ public HashMap<K, V> removeAll(Iterable<? extends K> keys) {
         for (K key : keys) {
             result = result.remove(key);
         }
-        return result.isEmpty() ? empty() : new HashMap<>(result);
+        return result.isEmpty() ? empty() : result.size() == trie.size() ? this : new HashMap<>(result);
     }
 
     @Override

File: src/main/java/javaslang/collection/HashSet.java
Patch:
@@ -665,7 +665,7 @@ public HashSet<T> retainAll(Iterable<? extends T> elements) {
                 that = that.put(element, element);
             }
         }
-        return new HashSet<>(that);
+        return that.isEmpty() ? empty() : that.size() == size() ? this : new HashSet<>(that);
     }
 
     @Override

File: src/main/java/javaslang/collection/LinkedHashMap.java
Patch:
@@ -269,7 +269,7 @@ public LinkedHashMap<K, V> removeAll(Iterable<? extends K> keys) {
         final HashSet<K> toRemove = HashSet.ofAll(keys);
         final Queue<Tuple2<K, V>> newList = list.filter(t -> !toRemove.contains(t._1));
         final HashMap<K, V> newMap = map.filter(t -> !toRemove.contains(t._1));
-        return newList.isEmpty() ? empty() : new LinkedHashMap<>(newList, newMap);
+        return newList.isEmpty() ? empty() : newList.size() == size() ? this : new LinkedHashMap<>(newList, newMap);
     }
 
     @Override

File: src/main/java/javaslang/collection/LinkedHashSet.java
Patch:
@@ -675,7 +675,7 @@ public LinkedHashSet<T> retainAll(Iterable<? extends T> elements) {
                 that = that.put(element, element);
             }
         }
-        return new LinkedHashSet<>(that);
+        return that.isEmpty() ? empty() : that.size() == size() ? this : new LinkedHashSet<>(that);
     }
 
     @Override

File: src/main/java/javaslang/collection/TreeSet.java
Patch:
@@ -688,7 +688,8 @@ public TreeSet<T> retainAll(Iterable<? extends T> elements) {
             return this;
         } else {
             final RedBlackTree<T> kept = RedBlackTree.ofAll(tree.comparator(), elements);
-            return new TreeSet<>(tree.intersection(kept));
+            final RedBlackTree<T> newTree = tree.intersection(kept);
+            return newTree.size() == tree.size() ? this : new TreeSet<>(tree.intersection(kept));
         }
     }
 

File: src/main/java/javaslang/collection/Vector.java
Patch:
@@ -969,7 +969,7 @@ public Vector<T> retainAll(Iterable<? extends T> elements) {
                 result = result.put(result.size(), element);
             }
         }
-        return result.isEmpty() ? empty() : new Vector<>(result);
+        return result.isEmpty() ? empty() : result.size() == trie.size() ? this : new Vector<>(result);
     }
 
     @Override

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -455,7 +455,8 @@ public HashMap<K, V> put(Tuple2<? extends K, ? extends V> entry) {
 
     @Override
     public HashMap<K, V> remove(K key) {
-        return new HashMap<>(trie.remove(key));
+        final HashArrayMappedTrie<K, V> result = trie.remove(key);
+        return result.size() == trie.size() ? this : new HashMap<>(result);
     }
 
     @Override
@@ -465,7 +466,7 @@ public HashMap<K, V> removeAll(Iterable<? extends K> keys) {
         for (K key : keys) {
             result = result.remove(key);
         }
-        return result.isEmpty() ? empty() : new HashMap<>(result);
+        return result.isEmpty() ? empty() : result.size() == trie.size() ? this : new HashMap<>(result);
     }
 
     @Override

File: src/main/java/javaslang/collection/HashSet.java
Patch:
@@ -665,7 +665,7 @@ public HashSet<T> retainAll(Iterable<? extends T> elements) {
                 that = that.put(element, element);
             }
         }
-        return new HashSet<>(that);
+        return that.isEmpty() ? empty() : that.size() == size() ? this : new HashSet<>(that);
     }
 
     @Override

File: src/main/java/javaslang/collection/LinkedHashMap.java
Patch:
@@ -269,7 +269,7 @@ public LinkedHashMap<K, V> removeAll(Iterable<? extends K> keys) {
         final HashSet<K> toRemove = HashSet.ofAll(keys);
         final Queue<Tuple2<K, V>> newList = list.filter(t -> !toRemove.contains(t._1));
         final HashMap<K, V> newMap = map.filter(t -> !toRemove.contains(t._1));
-        return newList.isEmpty() ? empty() : new LinkedHashMap<>(newList, newMap);
+        return newList.isEmpty() ? empty() : newList.size() == size() ? this : new LinkedHashMap<>(newList, newMap);
     }
 
     @Override

File: src/main/java/javaslang/collection/LinkedHashSet.java
Patch:
@@ -675,7 +675,7 @@ public LinkedHashSet<T> retainAll(Iterable<? extends T> elements) {
                 that = that.put(element, element);
             }
         }
-        return new LinkedHashSet<>(that);
+        return that.isEmpty() ? empty() : that.size() == size() ? this : new LinkedHashSet<>(that);
     }
 
     @Override

File: src/main/java/javaslang/collection/TreeSet.java
Patch:
@@ -688,7 +688,8 @@ public TreeSet<T> retainAll(Iterable<? extends T> elements) {
             return this;
         } else {
             final RedBlackTree<T> kept = RedBlackTree.ofAll(tree.comparator(), elements);
-            return new TreeSet<>(tree.intersection(kept));
+            final RedBlackTree<T> newTree = tree.intersection(kept);
+            return newTree.size() == tree.size() ? this : new TreeSet<>(tree.intersection(kept));
         }
     }
 

File: src/main/java/javaslang/collection/Vector.java
Patch:
@@ -969,7 +969,7 @@ public Vector<T> retainAll(Iterable<? extends T> elements) {
                 result = result.put(result.size(), element);
             }
         }
-        return result.isEmpty() ? empty() : new Vector<>(result);
+        return result.isEmpty() ? empty() : result.size() == trie.size() ? this : new Vector<>(result);
     }
 
     @Override

File: src/main/java/javaslang/collection/Queue.java
Patch:
@@ -739,7 +739,7 @@ public Queue<T> insert(int index, T element) {
             final int rearIndex = index - length;
             final int rearLength = rear.length();
             if (rearIndex <= rearLength) {
-                final int reverseRearIndex = rearLength - rearIndex - 1;
+                final int reverseRearIndex = rearLength - rearIndex;
                 return new Queue<>(front, rear.insert(reverseRearIndex, element));
             } else {
                 throw new IndexOutOfBoundsException(
@@ -761,8 +761,8 @@ public Queue<T> insertAll(int index, Iterable<? extends T> elements) {
             final int rearIndex = index - length;
             final int rearLength = rear.length();
             if (rearIndex <= rearLength) {
-                final int reverseRearIndex = rearLength - rearIndex - 1;
-                return new Queue<>(front, rear.insertAll(reverseRearIndex, elements));
+                final int reverseRearIndex = rearLength - rearIndex;
+                return new Queue<>(front, rear.insertAll(reverseRearIndex, List.ofAll(elements).reverse()));
             } else {
                 throw new IndexOutOfBoundsException(
                         String.format("insertAll(%s, e) on Queue of length %s", index, length()));

File: src-gen/main/java/javaslang/test/Property.java
Patch:
@@ -14,7 +14,6 @@
 import javaslang.*;
 import javaslang.control.Option;
 import javaslang.control.Try;
-import javaslang.control.Try.FatalException;
 import javaslang.control.Try.NonFatalException;
 
 /**

File: src/test/java/javaslang/control/MatchFunctionTest.java
Patch:
@@ -8,7 +8,6 @@
 import javaslang.Function1;
 import org.junit.Test;
 
-import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Supplier;
 

File: src/test/java/javaslang/control/MatchMonadTest.java
Patch:
@@ -9,7 +9,6 @@
 
 import java.util.Iterator;
 import java.util.NoSuchElementException;
-import java.util.function.Consumer;
 import java.util.function.Function;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: src-gen/main/java/javaslang/test/Property.java
Patch:
@@ -14,7 +14,6 @@
 import javaslang.*;
 import javaslang.control.Option;
 import javaslang.control.Try;
-import javaslang.control.Try.FatalException;
 import javaslang.control.Try.NonFatalException;
 
 /**

File: src/test/java/javaslang/control/MatchFunctionTest.java
Patch:
@@ -8,7 +8,6 @@
 import javaslang.Function1;
 import org.junit.Test;
 
-import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Supplier;
 

File: src/test/java/javaslang/control/MatchMonadTest.java
Patch:
@@ -9,7 +9,6 @@
 
 import java.util.Iterator;
 import java.util.NoSuchElementException;
-import java.util.function.Consumer;
 import java.util.function.Function;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: src/main/java/javaslang/collection/Tree.java
Patch:
@@ -1108,7 +1108,7 @@ static <T, U> Tree<Tuple2<T, U>> apply(Node<T> node, java.util.Iterator<U> that,
                 final Tuple2<T, U> value = Tuple.of(node.getValue(), that.next());
                 final List<Node<Tuple2<T, U>>> children = (List<Node<Tuple2<T, U>>>) (Object) node
                         .getChildren()
-                        .map(child -> Zip.apply(child, that))
+                        .map(child -> ZipAll.apply(child, that, thatElem))
                         .filter(Tree::isDefined);
                 return new Node<>(value, children);
             }

File: src/main/java/javaslang/collection/Tree.java
Patch:
@@ -1108,7 +1108,7 @@ static <T, U> Tree<Tuple2<T, U>> apply(Node<T> node, java.util.Iterator<U> that,
                 final Tuple2<T, U> value = Tuple.of(node.getValue(), that.next());
                 final List<Node<Tuple2<T, U>>> children = (List<Node<Tuple2<T, U>>>) (Object) node
                         .getChildren()
-                        .map(child -> Zip.apply(child, that))
+                        .map(child -> ZipAll.apply(child, that, thatElem))
                         .filter(Tree::isDefined);
                 return new Node<>(value, children);
             }

File: src/main/java/javaslang/collection/AbstractIterator.java
Patch:
@@ -21,7 +21,7 @@ abstract class AbstractIterator<T> implements Iterator<T> {
 
     @Override
     public String toString() {
-        return (isEmpty() ? "" : "non-") + "empty iterator";
+        return stringPrefix() + "(" + (isEmpty() ? "" : "?") + ")";
     }
 
     protected abstract T getNext();

File: src/main/java/javaslang/concurrent/FutureImpl.java
Patch:
@@ -233,6 +233,6 @@ private void perform(Consumer<? super Try<T>> action) {
 
     @Override
     public String toString() {
-        return "Future(" + value.map(String::valueOf).orElse("?") + ")";
+        return stringPrefix() + "(" + value.map(String::valueOf).orElse("?") + ")";
     }
 }

File: src/test/java/javaslang/control/MatchMonadTest.java
Patch:
@@ -654,7 +654,7 @@ public void shouldMapOtherwise() {
         assertThat(actual).isEqualTo(0);
     }
 
-    // TraversableOnce operations
+    // Traversable operations
 
     @Test
     public void shouldGetIteratorOfMatched() {

File: src/main/java/javaslang/collection/AbstractIterator.java
Patch:
@@ -19,7 +19,7 @@ abstract class AbstractIterator<T> implements Iterator<T> {
 
     @Override
     public String toString() {
-        return (isEmpty() ? "" : "non-") + "empty iterator";
+        return stringPrefix() + "(" + (isEmpty() ? "" : "?") + ")";
     }
 
 }

File: src/main/java/javaslang/concurrent/FutureImpl.java
Patch:
@@ -233,6 +233,6 @@ private void perform(Consumer<? super Try<T>> action) {
 
     @Override
     public String toString() {
-        return "Future(" + value.map(String::valueOf).orElse("?") + ")";
+        return stringPrefix() + "(" + value.map(String::valueOf).orElse("?") + ")";
     }
 }

File: src/test/java/javaslang/control/MatchMonadTest.java
Patch:
@@ -654,7 +654,7 @@ public void shouldMapOtherwise() {
         assertThat(actual).isEqualTo(0);
     }
 
-    // TraversableOnce operations
+    // Traversable operations
 
     @Test
     public void shouldGetIteratorOfMatched() {

File: src/main/java/javaslang/collection/LinkedHashMap.java
Patch:
@@ -110,7 +110,6 @@ public static <K, V> LinkedHashMap<K, V> of(Object... pairs) {
      * @param <V> The value type
      * @return A new Map containing the given map
      */
-    @SuppressWarnings("unchecked")
     public static <K, V> LinkedHashMap<K, V> ofAll(java.util.Map<? extends K, ? extends V> map) {
         Objects.requireNonNull(map, "map is null");
         LinkedHashMap<K, V> result = LinkedHashMap.empty();

File: src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -127,7 +127,6 @@ public static <K, V> TreeMap<K, V> of(Object... pairs) {
      * @param <V>   The value type
      * @return A new Map containing the given map
      */
-    @SuppressWarnings("unchecked")
     public static <K extends Comparable<? super K>, V> TreeMap<K, V> ofAll(java.util.Map<? extends K, ? extends V> map) {
         Objects.requireNonNull(map, "map is null");
         RedBlackTree<Tuple2<K, V>> result = RedBlackTree.empty();

File: src/test/java/javaslang/collection/HashMapTest.java
Patch:
@@ -42,7 +42,6 @@ protected final <K, V> Map<K, V> mapOf(java.util.Map.Entry<? extends K, ? extend
         return HashMap.ofEntries(entries);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
     protected <K, V> Map<K, V> mapOfPairs(Object... pairs) {
         return HashMap.of(pairs);

File: src/test/java/javaslang/collection/LinkedHashMapTest.java
Patch:
@@ -38,7 +38,6 @@ protected final <K, V> Map<K, V> mapOf(java.util.Map.Entry<? extends K, ? extend
         return LinkedHashMap.ofEntries(entries);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
     protected <K, V> Map<K, V> mapOfPairs(Object... pairs) {
         return LinkedHashMap.of(pairs);

File: src/test/java/javaslang/collection/TreeMapTest.java
Patch:
@@ -47,7 +47,6 @@ protected final <K, V> Map<K, V> mapOf(java.util.Map.Entry<? extends K, ? extend
         return TreeMap.ofEntries(naturalComparator(), entries);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
     protected <K, V> Map<K, V> mapOfPairs(Object... pairs) {
         return TreeMap.of(pairs);

File: src/test/java/javaslang/concurrent/PromiseTest.java
Patch:
@@ -7,7 +7,6 @@
 
 import org.junit.Test;
 
-import static javaslang.concurrent.Concurrent.waitUntil;
 import static javaslang.concurrent.Concurrent.zZz;
 import static org.assertj.core.api.Assertions.assertThat;
 

File: src/main/java/javaslang/collection/LinkedHashMap.java
Patch:
@@ -110,7 +110,6 @@ public static <K, V> LinkedHashMap<K, V> of(Object... pairs) {
      * @param <V> The value type
      * @return A new Map containing the given map
      */
-    @SuppressWarnings("unchecked")
     public static <K, V> LinkedHashMap<K, V> ofAll(java.util.Map<? extends K, ? extends V> map) {
         Objects.requireNonNull(map, "map is null");
         LinkedHashMap<K, V> result = LinkedHashMap.empty();

File: src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -127,7 +127,6 @@ public static <K, V> TreeMap<K, V> of(Object... pairs) {
      * @param <V>   The value type
      * @return A new Map containing the given map
      */
-    @SuppressWarnings("unchecked")
     public static <K extends Comparable<? super K>, V> TreeMap<K, V> ofAll(java.util.Map<? extends K, ? extends V> map) {
         Objects.requireNonNull(map, "map is null");
         RedBlackTree<Tuple2<K, V>> result = RedBlackTree.empty();

File: src/test/java/javaslang/collection/HashMapTest.java
Patch:
@@ -35,7 +35,6 @@ protected final <K, V> Map<K, V> mapOf(Tuple2<? extends K, ? extends V>... entri
         return HashMap.ofAll(entries);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
     protected <K, V> Map<K, V> mapOfPairs(Object... pairs) {
         return HashMap.of(pairs);

File: src/test/java/javaslang/collection/LinkedHashMapTest.java
Patch:
@@ -31,7 +31,6 @@ protected final <K, V> Map<K, V> mapOf(Tuple2<? extends K, ? extends V>... entri
         return LinkedHashMap.ofAll(entries);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
     protected <K, V> Map<K, V> mapOfPairs(Object... pairs) {
         return LinkedHashMap.of(pairs);

File: src/test/java/javaslang/collection/TreeMapTest.java
Patch:
@@ -40,7 +40,6 @@ protected final <K, V> Map<K, V> mapOf(Tuple2<? extends K, ? extends V>... entri
         return TreeMap.ofAll(naturalComparator(), entries);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
     protected <K, V> Map<K, V> mapOfPairs(Object... pairs) {
         return TreeMap.of(pairs);

File: src/test/java/javaslang/concurrent/PromiseTest.java
Patch:
@@ -7,7 +7,6 @@
 
 import org.junit.Test;
 
-import static javaslang.concurrent.Concurrent.waitUntil;
 import static javaslang.concurrent.Concurrent.zZz;
 import static org.assertj.core.api.Assertions.assertThat;
 

File: src/main/java/javaslang/concurrent/Future.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.NoSuchElementException;
 import java.util.Objects;
 import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 import java.util.concurrent.ForkJoinPool;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BiFunction;
@@ -49,9 +50,9 @@
 public interface Future<T> extends Value<T> {
 
     /**
-     * The default executor service is {@link ForkJoinPool#commonPool()}.
+     * The default executor service is {@link Executors#newCachedThreadPool()}.
      */
-    ExecutorService DEFAULT_EXECUTOR_SERVICE = ForkJoinPool.commonPool();
+    ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();
 
     /**
      * Creates a failed {@code Future} with the given {@code exception}, backed by the {@link #DEFAULT_EXECUTOR_SERVICE}.

File: src/test/java/javaslang/collection/AbstractMapTest.java
Patch:
@@ -292,7 +292,7 @@ public void shouldReturnModifiedValuesMap() {
 
     @Test
     public void shouldReturnListWithMappedValues() {
-        assertThat(emptyIntInt().put(1, 1).put(2, 2).flatten((a, b) -> a + b)).isEqualTo(List.of(2, 4));
+        assertThat(emptyIntInt().put(1, 1).put(2, 2).traverse((a, b) -> a + b)).isEqualTo(List.of(2, 4));
     }
 
     // -- merge

File: src/test/java/javaslang/collection/HashMapTest.java
Patch:
@@ -40,7 +40,7 @@ public void shouldWrapMap() {
         java.util.Map<Integer, Integer> source = new java.util.HashMap<>();
         source.put(1, 2);
         source.put(3, 4);
-        assertThat(HashMap.of(source)).isEqualTo(emptyIntInt().put(1, 2).put(3, 4));
+        assertThat(HashMap.ofAll(source)).isEqualTo(emptyIntInt().put(1, 2).put(3, 4));
     }
 
     @Override

File: src/test/java/javaslang/collection/LinkedHashMapTest.java
Patch:
@@ -97,6 +97,6 @@ public void shouldWrapMap() {
         java.util.Map<Integer, Integer> source = new java.util.HashMap<>();
         source.put(1, 2);
         source.put(3, 4);
-        assertThat(LinkedHashMap.of(source)).isEqualTo(emptyIntInt().put(1, 2).put(3, 4));
+        assertThat(LinkedHashMap.ofAll(source)).isEqualTo(emptyIntInt().put(1, 2).put(3, 4));
     }
 }

File: src/test/java/javaslang/collection/TreeMapTest.java
Patch:
@@ -71,7 +71,7 @@ public void shouldWrapMap() {
         java.util.Map<Integer, Integer> source = new HashMap<>();
         source.put(1, 2);
         source.put(3, 4);
-        assertThat(TreeMap.of(source)).isEqualTo(emptyIntInt().put(1, 2).put(3, 4));
+        assertThat(TreeMap.ofAll(source)).isEqualTo(emptyIntInt().put(1, 2).put(3, 4));
     }
 
     // -- obsolete tests

File: src/main/java/javaslang/concurrent/Promise.java
Patch:
@@ -40,7 +40,7 @@
  * <h3>One-shot API</h3>
  * <p>
  * The main purpose of a {@code Promise} is to complete its underlying {@code Future}. When only a single {@code Thread}
- * will eventually complete the {@code Promise}, we use on of these methods. Calls will throw if the {@code Promise} is already
+ * will eventually complete the {@code Promise}, we use one of these methods. Calls will throw if the {@code Promise} is already
  * completed.
  * <ul>
  * <li>{@link #complete(Try)}</li>

File: src/main/java/javaslang/concurrent/Promise.java
Patch:
@@ -40,7 +40,7 @@
  * <h3>One-shot API</h3>
  * <p>
  * The main purpose of a {@code Promise} is to complete its underlying {@code Future}. When only a single {@code Thread}
- * will eventually complete the {@code Promise}, we use on of these methods. Calls will throw if the {@code Promise} is already
+ * will eventually complete the {@code Promise}, we use one of these methods. Calls will throw if the {@code Promise} is already
  * completed.
  * <ul>
  * <li>{@link #complete(Try)}</li>

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -494,6 +494,7 @@ default int lastIndexOfSlice(java.lang.Iterable<? extends T> that) {
      */
     default int lastIndexOfSlice(java.lang.Iterable<? extends T> that, int end) {
         Objects.requireNonNull(that, "that is null");
+        // TODO rewrite this without recurrence
         class Util {
             int lastIndexOfSlice(Seq<T> t, Seq<T> slice, int end) {
                 if (end < 0) {
@@ -511,7 +512,7 @@ int lastIndexOfSlice(Seq<T> t, Seq<T> slice, int end) {
                     return -1;
                 }
                 if (r._2 <= end) {
-                    int idx = lastIndexOfSlice(r._1.tail(), slice, end - r._2);
+                    int idx = lastIndexOfSlice(r._1.tail(), slice, end - r._2 - 1);
                     return idx >= 0 ? idx + 1 + r._2 : r._2;
                 } else {
                     return -1;

File: src/test/java/javaslang/collection/AbstractSeqTest.java
Patch:
@@ -403,6 +403,7 @@ public void shouldFindLastIndexOfSlice() {
         assertThat(of(1, 2, 3, 1, 2).lastIndexOfSlice(empty())).isEqualTo(5);
         assertThat(of(1, 2, 3, 1, 2).lastIndexOfSlice(of(2))).isEqualTo(4);
         assertThat(of(1, 2, 3, 1, 2, 3, 4).lastIndexOfSlice(of(2, 3))).isEqualTo(4);
+        assertThat(of(1, 2, 3, 1, 2, 3).lastIndexOfSlice(of(1, 2, 3))).isEqualTo(3);
     }
 
     @Test
@@ -411,6 +412,7 @@ public void shouldFindLastIndexOfSliceWithEnd() {
         assertThat(of(1, 2, 3, 1, 2, 3).lastIndexOfSlice(of(2), 2)).isEqualTo(1);
         assertThat(of(1, 2, 3, 1, 2, 3).lastIndexOfSlice(of(2, 3), 2)).isEqualTo(1);
         assertThat(of(1, 2, 3, 1, 2, 3, 4).lastIndexOfSlice(of(2, 3), 2)).isEqualTo(1);
+        assertThat(of(1, 2, 3, 1, 2, 3).lastIndexOfSlice(of(1, 2, 3), 2)).isEqualTo(0);
     }
 
     // -- insert

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -494,6 +494,7 @@ default int lastIndexOfSlice(java.lang.Iterable<? extends T> that) {
      */
     default int lastIndexOfSlice(java.lang.Iterable<? extends T> that, int end) {
         Objects.requireNonNull(that, "that is null");
+        // TODO rewrite this without recurrence
         class Util {
             int lastIndexOfSlice(Seq<T> t, Seq<T> slice, int end) {
                 if (end < 0) {
@@ -511,7 +512,7 @@ int lastIndexOfSlice(Seq<T> t, Seq<T> slice, int end) {
                     return -1;
                 }
                 if (r._2 <= end) {
-                    int idx = lastIndexOfSlice(r._1.tail(), slice, end - r._2);
+                    int idx = lastIndexOfSlice(r._1.tail(), slice, end - r._2 - 1);
                     return idx >= 0 ? idx + 1 + r._2 : r._2;
                 } else {
                     return -1;

File: src/test/java/javaslang/collection/AbstractSeqTest.java
Patch:
@@ -403,6 +403,7 @@ public void shouldFindLastIndexOfSlice() {
         assertThat(of(1, 2, 3, 1, 2).lastIndexOfSlice(empty())).isEqualTo(5);
         assertThat(of(1, 2, 3, 1, 2).lastIndexOfSlice(of(2))).isEqualTo(4);
         assertThat(of(1, 2, 3, 1, 2, 3, 4).lastIndexOfSlice(of(2, 3))).isEqualTo(4);
+        assertThat(of(1, 2, 3, 1, 2, 3).lastIndexOfSlice(of(1, 2, 3))).isEqualTo(3);
     }
 
     @Test
@@ -411,6 +412,7 @@ public void shouldFindLastIndexOfSliceWithEnd() {
         assertThat(of(1, 2, 3, 1, 2, 3).lastIndexOfSlice(of(2), 2)).isEqualTo(1);
         assertThat(of(1, 2, 3, 1, 2, 3).lastIndexOfSlice(of(2, 3), 2)).isEqualTo(1);
         assertThat(of(1, 2, 3, 1, 2, 3, 4).lastIndexOfSlice(of(2, 3), 2)).isEqualTo(1);
+        assertThat(of(1, 2, 3, 1, 2, 3).lastIndexOfSlice(of(1, 2, 3), 2)).isEqualTo(0);
     }
 
     // -- insert

File: src/main/java/javaslang/control/package-info.java
Patch:
@@ -21,7 +21,6 @@
  * {@linkplain javaslang.control.Some} value or {@linkplain javaslang.control.None}.
  * In contrast to Optional, Option supports null values, i.e. it is possible to call {@code new Some(null)}.
  * However, {@code Option.of(null)} results in None.
- * See also <a href="http://blog.rocketscience.io/your-codebase-looks-like-this/">3 ways to deal with null</a>.
  * <p>
  * <strong>Try</strong>
  * <p>

File: src/main/java/javaslang/control/package-info.java
Patch:
@@ -21,7 +21,6 @@
  * {@linkplain javaslang.control.Some} value or {@linkplain javaslang.control.None}.
  * In contrast to Optional, Option supports null values, i.e. it is possible to call {@code new Some(null)}.
  * However, {@code Option.of(null)} results in None.
- * See also <a href="http://blog.rocketscience.io/your-codebase-looks-like-this/">3 ways to deal with null</a>.
  * <p>
  * <strong>Try</strong>
  * <p>

File: src/test/java/javaslang/collection/euler/Sieve.java
Patch:
@@ -12,13 +12,13 @@
 
 public class Sieve {
 
-    final static List<Function2<Integer, Integer, Option<Integer>>> rules = List.ofAll(
+    final static List<Function2<Integer, Integer, Option<Integer>>> rules = List.of(
             (x, y) -> Option.of((4 * x * x) + (y * y)).filter(n -> n % 12 == 1 || n % 12 == 5),
             (x, y) -> Option.of((3 * x * x) + (y * y)).filter(n -> n % 12 == 7),
             (x, y) -> Option.of((3 * x * x) - (y * y)).filter(n -> x > y && n % 12 == 11)
     );
 
-    final static List<Function3<Set<Integer>, Integer, Integer, Set<Integer>>> steps = List.ofAll(
+    final static List<Function3<Set<Integer>, Integer, Integer, Set<Integer>>> steps = List.of(
             (sieve, limit, root) -> Stream.rangeClosed(1, root).crossProduct()
                     .foldLeft(sieve, (xs, xy) ->
                             rules.foldLeft(xs, (ss, r) -> r.apply(xy._1, xy._2)

File: src/test/java/javaslang/collection/euler/Sieve.java
Patch:
@@ -12,13 +12,13 @@
 
 public class Sieve {
 
-    final static List<Function2<Integer, Integer, Option<Integer>>> rules = List.ofAll(
+    final static List<Function2<Integer, Integer, Option<Integer>>> rules = List.of(
             (x, y) -> Option.of((4 * x * x) + (y * y)).filter(n -> n % 12 == 1 || n % 12 == 5),
             (x, y) -> Option.of((3 * x * x) + (y * y)).filter(n -> n % 12 == 7),
             (x, y) -> Option.of((3 * x * x) - (y * y)).filter(n -> x > y && n % 12 == 11)
     );
 
-    final static List<Function3<Set<Integer>, Integer, Integer, Set<Integer>>> steps = List.ofAll(
+    final static List<Function3<Set<Integer>, Integer, Integer, Set<Integer>>> steps = List.of(
             (sieve, limit, root) -> Stream.rangeClosed(1, root).crossProduct()
                     .foldLeft(sieve, (xs, xy) ->
                             rules.foldLeft(xs, (ss, r) -> r.apply(xy._1, xy._2)

File: src/test/java/javaslang/collection/VectorTest.java
Patch:
@@ -169,7 +169,7 @@ public void shouldStringifyNil() {
 
     @Test
     public void shouldStringifyNonNil() {
-        assertThat(ofAll(1, 2, 3).toString()).isEqualTo("Vector(1, 2, 3)");
+        assertThat(ofAll(null, 1, 2, 3).toString()).isEqualTo("Vector(null, 1, 2, 3)");
     }
 
     // -- Cons test

File: src/main/java/javaslang/control/Option.java
Patch:
@@ -49,7 +49,7 @@ static <T> Option<T> of(T value) {
      * @param <T> component type
      * @return the single instance of {@code None}
      */
-    static <T> None<T> none() {
+    static <T> Option<T> none() {
         return None.instance();
     }
 

File: src/main/java/javaslang/control/Option.java
Patch:
@@ -49,7 +49,7 @@ static <T> Option<T> of(T value) {
      * @param <T> component type
      * @return the single instance of {@code None}
      */
-    static <T> None<T> none() {
+    static <T> Option<T> none() {
         return None.instance();
     }
 

File: src/test/java/benchmark/collection/AlphabeticSequenceBench.java
Patch:
@@ -14,7 +14,7 @@ public class AlphabeticSequenceBench {
     private static final int COUNT = 4;
     private static final int WARMUP = 2;
 
-    private static final Seq<Character> ALPHABET = CharSeq.rangeClosed('A', 'Z').toStream();
+    private static final Stream<Character> ALPHABET = CharSeq.rangeClosed('A', 'Z').toStream();
 
     public static void main(String[] args) {
         benchAlphabeticSequenceUsingCartesianPower();
@@ -33,7 +33,7 @@ private static List<String> cartesianPower(int n) {
         return Stream
                 .from(1)
                 .flatMap(ALPHABET::crossProduct)
-                .map(IndexedSeq::mkString)
+                .map(Seq::mkString)
                 .takeWhile(s -> s.length() <= n)
                 .toList();
     }
@@ -43,7 +43,7 @@ private static List<String> appendSelf(int n) {
                 .sliding(1)
                 .toStream()
                 .appendSelf(stream -> stream.flatMap(product -> ALPHABET.map(product::append)))
-                .map(IndexedSeq::mkString)
+                .map(Seq::mkString)
                 .takeWhile(s -> s.length() <= n)
                 .toList();
     }

File: src/test/java/javaslang/collection/euler/Euler08Test.java
Patch:
@@ -5,8 +5,8 @@
  */
 package javaslang.collection.euler;
 
-import javaslang.collection.IndexedSeq;
 import javaslang.collection.List;
+import javaslang.collection.Seq;
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -55,7 +55,7 @@ public void shouldSolveProblem8() {
     private static long largestProductOfConsecutives(int sizeOfConsecutive, String num) {
         return digits(num)
                 .sliding(sizeOfConsecutive)
-                .map(IndexedSeq::product)
+                .map(Seq::product)
                 .max().get().longValue();
     }
 

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -49,10 +49,12 @@
  *
  * Iteration:
  *
+ * <ul>
  * <li>{@link #grouped(int)}</li>
  * <li>{@link #iterator()}</li>
  * <li>{@link #sliding(int)}</li>
  * <li>{@link #sliding(int, int)}</li>
+ * </ul>
  *
  * Numeric operations:
  *
@@ -104,7 +106,6 @@
  * <ul>
  * <li>{@link #existsUnique(Predicate)}</li>
  * <li>{@link #hasDefiniteSize()}</li>
- * <li>{@link #isSingletonType()}</li>
  * <li>{@link #isTraversableAgain()}</li>
  * </ul>
  *

File: src/test/java/javaslang/collection/IntMap.java
Patch:
@@ -234,7 +234,7 @@ public Iterator<IntMap<T>> sliding(int size) {
 
     @Override
     public Iterator<IntMap<T>> sliding(int size, int step) {
-        return original.sliding(size, size).map(IntMap::of);
+        return original.sliding(size, step).map(IntMap::of);
     }
 
     @Override

File: src/test/java/benchmark/collection/AlphabeticSequenceBench.java
Patch:
@@ -14,7 +14,7 @@ public class AlphabeticSequenceBench {
     private static final int COUNT = 4;
     private static final int WARMUP = 2;
 
-    private static final Seq<Character> ALPHABET = CharSeq.rangeClosed('A', 'Z').toStream();
+    private static final Stream<Character> ALPHABET = CharSeq.rangeClosed('A', 'Z').toStream();
 
     public static void main(String[] args) {
         benchAlphabeticSequenceUsingCartesianPower();
@@ -33,7 +33,7 @@ private static List<String> cartesianPower(int n) {
         return Stream
                 .from(1)
                 .flatMap(ALPHABET::crossProduct)
-                .map(IndexedSeq::mkString)
+                .map(Seq::mkString)
                 .takeWhile(s -> s.length() <= n)
                 .toList();
     }
@@ -43,7 +43,7 @@ private static List<String> appendSelf(int n) {
                 .sliding(1)
                 .toStream()
                 .appendSelf(stream -> stream.flatMap(product -> ALPHABET.map(product::append)))
-                .map(IndexedSeq::mkString)
+                .map(Seq::mkString)
                 .takeWhile(s -> s.length() <= n)
                 .toList();
     }

File: src/test/java/javaslang/collection/AbstractTraversableTest.java
Patch:
@@ -1209,7 +1209,7 @@ public void shouldSpanNonNil() {
     public void shouldSplitNil() {
         final java.util.List<Integer> actual = new java.util.ArrayList<>();
         this.<Integer> empty().spliterator().forEachRemaining(actual::add);
-        assertThat(actual).isEqualTo(Collections.emptyList());
+        assertThat(actual).isEmpty();
     }
 
     @Test

File: src/test/java/javaslang/collection/euler/Euler08Test.java
Patch:
@@ -5,8 +5,8 @@
  */
 package javaslang.collection.euler;
 
-import javaslang.collection.IndexedSeq;
 import javaslang.collection.List;
+import javaslang.collection.Seq;
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -55,7 +55,7 @@ public void shouldSolveProblem8() {
     private static long largestProductOfConsecutives(int sizeOfConsecutive, String num) {
         return digits(num)
                 .sliding(sizeOfConsecutive)
-                .map(IndexedSeq::product)
+                .map(Seq::product)
                 .max().get().longValue();
     }
 

File: src/main/java/javaslang/Lazy.java
Patch:
@@ -196,7 +196,7 @@ public <U> Lazy<U> flatMap(Function<? super T, ? extends java.lang.Iterable<? ex
     public <U> Lazy<U> flatten() {
         try {
             return ((Lazy<? extends java.lang.Iterable<U>>) this).flatMap(Function.identity());
-        } catch(ClassCastException x) {
+        } catch (ClassCastException x) {
             throw new UnsupportedOperationException("flatten of non-iterable elements");
         }
     }

File: src/main/java/javaslang/algebra/Foldable.java
Patch:
@@ -75,7 +75,7 @@ default T foldLeft(Monoid<? extends T> monoid) {
     /**
      * Folds this elements from the left, starting with {@code zero} and successively calling {@code combine}.
      *
-     * @param <U> the type of the folded value
+     * @param <U>     the type of the folded value
      * @param zero    A zero element to start with.
      * @param combine A function which combines elements.
      * @return a folded value
@@ -118,7 +118,7 @@ default T foldRight(Monoid<? extends T> monoid) {
     /**
      * Folds this elements from the right, starting with {@code zero} and successively calling {@code combine}.
      *
-     * @param <U> the type of the folded value
+     * @param <U>     the type of the folded value
      * @param zero    A zero element to start with.
      * @param combine A function which combines elements.
      * @return a folded value

File: src/main/java/javaslang/collection/SortedSet.java
Patch:
@@ -133,7 +133,7 @@ default T last() {
     SortedSet<T> replaceAll(T currentElement, T newElement);
 
     @Override
-    SortedSet <T> retainAll(java.lang.Iterable<? extends T> elements);
+    SortedSet<T> retainAll(java.lang.Iterable<? extends T> elements);
 
     @Override
     SortedSet<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation);
@@ -145,7 +145,7 @@ default T last() {
     // DEV-NOTE: The return type is either Set or SortedSet, depending whether U is Comparable
     @Override
     <U> Set<U> scanRight(U zero, BiFunction<? super T, ? super U, ? extends U> operation);
-    
+
     @Override
     Tuple2<? extends SortedSet<T>, ? extends SortedSet<T>> span(Predicate<? super T> predicate);
 

File: src/main/java/javaslang/collection/Traversables.java
Patch:
@@ -36,7 +36,7 @@ static <T, U, C extends Iterable<U>, R extends Traversable<U>> R scanRight(
             Iterable<? extends T> elements,
             U zero, BiFunction<? super T, ? super U, ? extends U> operation,
             C cumulativeResult, BiFunction<C, U, C> combiner, Function<C, R> finisher) {
-        final Iterable<T> reversedElements = Seq.ofAll(elements).reverseIterator();
+        final Iterator<? extends T> reversedElements = Seq.ofAll(elements).reverseIterator();
         return scanLeft(reversedElements, zero, (u, t) -> operation.apply(t, u), cumulativeResult, combiner, finisher);
     }
 }

File: src/main/java/javaslang/collection/TreeSet.java
Patch:
@@ -693,7 +693,6 @@ public TreeSet<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> ope
         return Traversables.scanLeft(this, zero, operation, TreeSet.empty(comparator()), TreeSet::add, Function.identity());
     }
 
-    @SuppressWarnings({ "unchecked", "rawtypes" })
     @Override
     public <U> Set<U> scanLeft(U zero, BiFunction<? super U, ? super T, ? extends U> operation) {
         Objects.requireNonNull(operation, "operation is null");
@@ -708,7 +707,6 @@ public <U> Set<U> scanLeft(U zero, BiFunction<? super U, ? super T, ? extends U>
         }
     }
 
-    @SuppressWarnings({ "unchecked", "rawtypes" })
     @Override
     public <U> Set<U> scanRight(U zero, BiFunction<? super T, ? super U, ? extends U> operation) {
         Objects.requireNonNull(operation, "operation is null");

File: src/main/java/javaslang/control/Match.java
Patch:
@@ -399,7 +399,7 @@ interface MatchMonad<R> extends Value<R> {
         default <U> MatchMonad<U> flatten() {
             try {
                 return ((MatchMonad<? extends Iterable<U>>) this).flatMap(Function.identity());
-            } catch(ClassCastException x) {
+            } catch (ClassCastException x) {
                 throw new UnsupportedOperationException("flatten of non-iterable elements");
             }
         }

File: src/main/java/javaslang/control/Try.java
Patch:
@@ -205,7 +205,7 @@ default <U> Try<U> flatMapTry(CheckedFunction<? super T, ? extends java.lang.Ite
     default <U> Try<U> flatten() {
         try {
             return ((Try<? extends Iterable<U>>) this).flatMap(Function.identity());
-        } catch(ClassCastException x) {
+        } catch (ClassCastException x) {
             throw new UnsupportedOperationException("flatten of non-iterable elements");
         }
     }
@@ -413,7 +413,7 @@ default Try<T> recover(Function<? super Throwable, ? extends T> f) {
      * @return a new Try
      */
     @SuppressWarnings("unchecked")
-    default Try<T> recoverWith(Function<? super Throwable, ? extends Try< ? extends T>> f) {
+    default Try<T> recoverWith(Function<? super Throwable, ? extends Try<? extends T>> f) {
         if (isFailure()) {
             try {
                 return (Try<T>) f.apply(getCause());

File: src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -102,7 +102,7 @@ default <U> Arbitrary<U> flatMap(Function<? super T, ? extends java.lang.Iterabl
     default <U> Arbitrary<U> flatten() {
         try {
             return ((Arbitrary<? extends Iterable<U>>) this).flatMap(Function.identity());
-        } catch(ClassCastException x) {
+        } catch (ClassCastException x) {
             throw new UnsupportedOperationException("flatten of non-iterable elements");
         }
     }

File: src/main/java/javaslang/test/Gen.java
Patch:
@@ -328,7 +328,7 @@ default <U> Gen<U> flatMap(Function<? super T, ? extends java.lang.Iterable<? ex
     default <U> Gen<U> flatten() {
         try {
             return ((Gen<? extends Iterable<U>>) this).flatMap(Function.identity());
-        } catch(ClassCastException x) {
+        } catch (ClassCastException x) {
             throw new UnsupportedOperationException("flatten of non-iterable elements");
         }
     }

File: src/main/java/javaslang/.java
Patch:
@@ -5,8 +5,6 @@
  */
 package javaslang;
 
-import javaslang.collection.Array;
-import javaslang.collection.Iterator;
 import javaslang.collection.List;
 import javaslang.control.Try;
 import javaslang.Module.ReflectionUtil;

File: src/test/java/javaslang/collection/AbstractSetTest.java
Patch:
@@ -5,11 +5,8 @@
  */
 package javaslang.collection;
 
-import org.junit.Assert;
 import org.junit.Test;
 
-import java.util.Objects;
-
 public abstract class AbstractSetTest extends AbstractTraversableRangeTest {
 
     @Override

File: src/test/java/javaslang/collection/IteratorTest.java
Patch:
@@ -311,7 +311,6 @@ public void shouldCalculateDifferentHashCodesForDifferentTraversables() {
     // -- groupBy
 
     @Override
-    @SuppressWarnings("unchecked")
     public void shouldNonNilGroupByIdentity() {
         // we can't compare iterators, should map it to sequences
         final Seq<?> actual = ofAll('a', 'b', 'c').groupBy(Function.identity()).map(e -> Tuple.of(e._1, List.ofAll(e._2)));
@@ -324,7 +323,6 @@ public void shouldNonNilGroupByIdentity() {
     }
 
     @Override
-    @SuppressWarnings("unchecked")
     public void shouldNonNilGroupByEqual() {
         // we can't compare iterators, should map it to sequences
         final Seq<?> actual = ofAll('a', 'b', 'c').groupBy(c -> 1).map(e -> Tuple.of(e._1, List.ofAll(e._2)));

File: src/test/java/javaslang/collection/LinkedHashSetTest.java
Patch:
@@ -156,7 +156,7 @@ protected LinkedHashSet<Long> rangeClosedBy(long from, long toInclusive, long st
 
     @Test
     public void shouldKeepOrder() {
-        List<Integer> actual = LinkedHashSet.<Integer>empty().add(3).add(2).add(1).toList();
+        List<Integer> actual = LinkedHashSet.<Integer> empty().add(3).add(2).add(1).toList();
         assertThat(actual).isEqualTo(List.ofAll(3, 2, 1));
     }
 }

File: src/test/java/javaslang/collection/ListTest.java
Patch:
@@ -181,7 +181,7 @@ public void shouldNotSerializeEnclosingClass() throws Throwable {
     public void shouldNotDeserializeListWithSizeLessThanOne() throws Throwable {
         try {
             /*
-			 * This implementation is stable regarding jvm impl changes ofAll object serialization. The index ofAll the number
+             * This implementation is stable regarding jvm impl changes ofAll object serialization. The index ofAll the number
 			 * ofAll List elements is gathered dynamically.
 			 */
             final byte[] listWithOneElement = Serializables.serialize(List.of(0));

File: src/test/java/javaslang/collection/VectorTest.java
Patch:
@@ -183,7 +183,7 @@ public void shouldNotSerializeEnclosingClass() throws Throwable {
     public void shouldNotDeserializeListWithSizeLessThanOne() throws Throwable {
         try {
             /*
-			 * This implementation is stable regarding jvm impl changes ofAll object serialization. The index ofAll the number
+             * This implementation is stable regarding jvm impl changes ofAll object serialization. The index ofAll the number
 			 * ofAll List elements is gathered dynamically.
 			 */
             final byte[] listWithOneElement = Serializables.serialize(List.of(0));

File: src/test/java/javaslang/collection/euler/Euler14Test.java
Patch:
@@ -48,7 +48,7 @@ public void shouldSolveProblem14() {
     }
 
     private final static Function1<Long, Long> collatzRecursive = n -> {
-        if(n == 1) {
+        if (n == 1) {
             return 1L;
         } else {
             if (n % 2 == 0) {

File: src/test/java/javaslang/collection/euler/Euler67Test.java
Patch:
@@ -57,7 +57,7 @@ private static int solve(String fileName) {
     static Vector<Vector<Integer>> loadTriangle(String fileName) {
         return Vector.ofAll(
                 Utils.readLines(Utils.file(fileName)).map(line ->
-                                Arrays.asList(line.split("\\s")).stream().map(Integer::parseInt)
+                        Arrays.asList(line.split("\\s")).stream().map(Integer::parseInt)
                 ).map(s -> Vector.ofAll(s::iterator))
         );
     }

File: src/main/java/javaslang/collection/SortedMap.java
Patch:
@@ -108,6 +108,9 @@ default Tuple2<K, V> last() {
     @Override
     <U, W> SortedMap<U, W> map(BiFunction<? super K, ? super V, ? extends Tuple2<? extends U, ? extends W>> mapper);
 
+    @Override
+    <W> SortedMap<K, W> mapValues(Function<V, ? extends W> mapper);
+
     @Override
     SortedMap<K, V> merge(Map<? extends K, ? extends V> that);
 

File: src/main/java/javaslang/Lazy.java
Patch:
@@ -196,7 +196,7 @@ public <U> Lazy<U> flatMap(Function<? super T, ? extends java.lang.Iterable<? ex
     public <U> Lazy<U> flatten() {
         try {
             return ((Lazy<? extends java.lang.Iterable<U>>) this).flatMap(Function.identity());
-        } catch(ClassCastException x) {
+        } catch (ClassCastException x) {
             throw new UnsupportedOperationException("flatten of non-iterable elements");
         }
     }

File: src/main/java/javaslang/algebra/Foldable.java
Patch:
@@ -75,7 +75,7 @@ default T foldLeft(Monoid<? extends T> monoid) {
     /**
      * Folds this elements from the left, starting with {@code zero} and successively calling {@code combine}.
      *
-     * @param <U> the type of the folded value
+     * @param <U>     the type of the folded value
      * @param zero    A zero element to start with.
      * @param combine A function which combines elements.
      * @return a folded value
@@ -118,7 +118,7 @@ default T foldRight(Monoid<? extends T> monoid) {
     /**
      * Folds this elements from the right, starting with {@code zero} and successively calling {@code combine}.
      *
-     * @param <U> the type of the folded value
+     * @param <U>     the type of the folded value
      * @param zero    A zero element to start with.
      * @param combine A function which combines elements.
      * @return a folded value

File: src/main/java/javaslang/collection/SortedSet.java
Patch:
@@ -133,7 +133,7 @@ default T last() {
     SortedSet<T> replaceAll(T currentElement, T newElement);
 
     @Override
-    SortedSet <T> retainAll(java.lang.Iterable<? extends T> elements);
+    SortedSet<T> retainAll(java.lang.Iterable<? extends T> elements);
 
     @Override
     SortedSet<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation);
@@ -145,7 +145,7 @@ default T last() {
     // DEV-NOTE: The return type is either Set or SortedSet, depending whether U is Comparable
     @Override
     <U> Set<U> scanRight(U zero, BiFunction<? super T, ? super U, ? extends U> operation);
-    
+
     @Override
     Tuple2<? extends SortedSet<T>, ? extends SortedSet<T>> span(Predicate<? super T> predicate);
 

File: src/main/java/javaslang/collection/Traversables.java
Patch:
@@ -36,7 +36,7 @@ static <T, U, C extends Iterable<U>, R extends Traversable<U>> R scanRight(
             Iterable<? extends T> elements,
             U zero, BiFunction<? super T, ? super U, ? extends U> operation,
             C cumulativeResult, BiFunction<C, U, C> combiner, Function<C, R> finisher) {
-        final Iterable<T> reversedElements = Seq.ofAll(elements).reverseIterator();
+        final Iterator<? extends T> reversedElements = Seq.ofAll(elements).reverseIterator();
         return scanLeft(reversedElements, zero, (u, t) -> operation.apply(t, u), cumulativeResult, combiner, finisher);
     }
 }

File: src/main/java/javaslang/collection/TreeSet.java
Patch:
@@ -693,7 +693,6 @@ public TreeSet<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> ope
         return Traversables.scanLeft(this, zero, operation, TreeSet.empty(comparator()), TreeSet::add, Function.identity());
     }
 
-    @SuppressWarnings({ "unchecked", "rawtypes" })
     @Override
     public <U> Set<U> scanLeft(U zero, BiFunction<? super U, ? super T, ? extends U> operation) {
         Objects.requireNonNull(operation, "operation is null");
@@ -708,7 +707,6 @@ public <U> Set<U> scanLeft(U zero, BiFunction<? super U, ? super T, ? extends U>
         }
     }
 
-    @SuppressWarnings({ "unchecked", "rawtypes" })
     @Override
     public <U> Set<U> scanRight(U zero, BiFunction<? super T, ? super U, ? extends U> operation) {
         Objects.requireNonNull(operation, "operation is null");

File: src/main/java/javaslang/control/Match.java
Patch:
@@ -399,7 +399,7 @@ interface MatchMonad<R> extends Value<R> {
         default <U> MatchMonad<U> flatten() {
             try {
                 return ((MatchMonad<? extends Iterable<U>>) this).flatMap(Function.identity());
-            } catch(ClassCastException x) {
+            } catch (ClassCastException x) {
                 throw new UnsupportedOperationException("flatten of non-iterable elements");
             }
         }

File: src/main/java/javaslang/control/Try.java
Patch:
@@ -205,7 +205,7 @@ default <U> Try<U> flatMapTry(CheckedFunction<? super T, ? extends java.lang.Ite
     default <U> Try<U> flatten() {
         try {
             return ((Try<? extends Iterable<U>>) this).flatMap(Function.identity());
-        } catch(ClassCastException x) {
+        } catch (ClassCastException x) {
             throw new UnsupportedOperationException("flatten of non-iterable elements");
         }
     }
@@ -413,7 +413,7 @@ default Try<T> recover(Function<? super Throwable, ? extends T> f) {
      * @return a new Try
      */
     @SuppressWarnings("unchecked")
-    default Try<T> recoverWith(Function<? super Throwable, ? extends Try< ? extends T>> f) {
+    default Try<T> recoverWith(Function<? super Throwable, ? extends Try<? extends T>> f) {
         if (isFailure()) {
             try {
                 return (Try<T>) f.apply(getCause());

File: src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -102,7 +102,7 @@ default <U> Arbitrary<U> flatMap(Function<? super T, ? extends java.lang.Iterabl
     default <U> Arbitrary<U> flatten() {
         try {
             return ((Arbitrary<? extends Iterable<U>>) this).flatMap(Function.identity());
-        } catch(ClassCastException x) {
+        } catch (ClassCastException x) {
             throw new UnsupportedOperationException("flatten of non-iterable elements");
         }
     }

File: src/main/java/javaslang/test/Gen.java
Patch:
@@ -328,7 +328,7 @@ default <U> Gen<U> flatMap(Function<? super T, ? extends java.lang.Iterable<? ex
     default <U> Gen<U> flatten() {
         try {
             return ((Gen<? extends Iterable<U>>) this).flatMap(Function.identity());
-        } catch(ClassCastException x) {
+        } catch (ClassCastException x) {
             throw new UnsupportedOperationException("flatten of non-iterable elements");
         }
     }

File: src/main/java/javaslang/.java
Patch:
@@ -5,8 +5,6 @@
  */
 package javaslang;
 
-import javaslang.collection.Array;
-import javaslang.collection.Iterator;
 import javaslang.collection.List;
 import javaslang.control.Try;
 import javaslang.Module.ReflectionUtil;

File: src/test/java/javaslang/collection/AbstractSetTest.java
Patch:
@@ -5,11 +5,8 @@
  */
 package javaslang.collection;
 
-import org.junit.Assert;
 import org.junit.Test;
 
-import java.util.Objects;
-
 public abstract class AbstractSetTest extends AbstractTraversableRangeTest {
 
     @Override

File: src/test/java/javaslang/collection/AbstractValueTest.java
Patch:
@@ -235,9 +235,9 @@ public void shouldNotDetectWrongReturnTypeOnFlattenButWhenReadingFlattenedElemen
         try {
             final String s = unsafe.get();
             throw new AssertionError("Expected ClassCastException but got " + s);
-        } catch(ClassCastException x) {
+        } catch (ClassCastException x) {
             // ok!
-        } catch(Exception x) {
+        } catch (Exception x) {
             throw new AssertionError("Unexpected exception:" + x);
         }
     }

File: src/test/java/javaslang/collection/IteratorTest.java
Patch:
@@ -311,7 +311,6 @@ public void shouldCalculateDifferentHashCodesForDifferentTraversables() {
     // -- groupBy
 
     @Override
-    @SuppressWarnings("unchecked")
     public void shouldNonNilGroupByIdentity() {
         // we can't compare iterators, should map it to sequences
         final Seq<?> actual = ofAll('a', 'b', 'c').groupBy(Function.identity()).map(e -> Tuple.of(e._1, List.ofAll(e._2)));
@@ -324,7 +323,6 @@ public void shouldNonNilGroupByIdentity() {
     }
 
     @Override
-    @SuppressWarnings("unchecked")
     public void shouldNonNilGroupByEqual() {
         // we can't compare iterators, should map it to sequences
         final Seq<?> actual = ofAll('a', 'b', 'c').groupBy(c -> 1).map(e -> Tuple.of(e._1, List.ofAll(e._2)));

File: src/test/java/javaslang/collection/LinkedHashSetTest.java
Patch:
@@ -156,7 +156,7 @@ protected LinkedHashSet<Long> rangeClosedBy(long from, long toInclusive, long st
 
     @Test
     public void shouldKeepOrder() {
-        List<Integer> actual = LinkedHashSet.<Integer>empty().add(3).add(2).add(1).toList();
+        List<Integer> actual = LinkedHashSet.<Integer> empty().add(3).add(2).add(1).toList();
         assertThat(actual).isEqualTo(List.ofAll(3, 2, 1));
     }
 }

File: src/test/java/javaslang/collection/ListTest.java
Patch:
@@ -181,7 +181,7 @@ public void shouldNotSerializeEnclosingClass() throws Throwable {
     public void shouldNotDeserializeListWithSizeLessThanOne() throws Throwable {
         try {
             /*
-			 * This implementation is stable regarding jvm impl changes ofAll object serialization. The index ofAll the number
+             * This implementation is stable regarding jvm impl changes ofAll object serialization. The index ofAll the number
 			 * ofAll List elements is gathered dynamically.
 			 */
             final byte[] listWithOneElement = Serializables.serialize(List.of(0));

File: src/test/java/javaslang/collection/VectorTest.java
Patch:
@@ -183,7 +183,7 @@ public void shouldNotSerializeEnclosingClass() throws Throwable {
     public void shouldNotDeserializeListWithSizeLessThanOne() throws Throwable {
         try {
             /*
-			 * This implementation is stable regarding jvm impl changes ofAll object serialization. The index ofAll the number
+             * This implementation is stable regarding jvm impl changes ofAll object serialization. The index ofAll the number
 			 * ofAll List elements is gathered dynamically.
 			 */
             final byte[] listWithOneElement = Serializables.serialize(List.of(0));

File: src/test/java/javaslang/collection/euler/Euler14Test.java
Patch:
@@ -48,7 +48,7 @@ public void shouldSolveProblem14() {
     }
 
     private final static Function1<Long, Long> collatzRecursive = n -> {
-        if(n == 1) {
+        if (n == 1) {
             return 1L;
         } else {
             if (n % 2 == 0) {

File: src/test/java/javaslang/collection/euler/Euler67Test.java
Patch:
@@ -57,7 +57,7 @@ private static int solve(String fileName) {
     static Vector<Vector<Integer>> loadTriangle(String fileName) {
         return Vector.ofAll(
                 Utils.readLines(Utils.file(fileName)).map(line ->
-                                Arrays.asList(line.split("\\s")).stream().map(Integer::parseInt)
+                        Arrays.asList(line.split("\\s")).stream().map(Integer::parseInt)
                 ).map(s -> Vector.ofAll(s::iterator))
         );
     }

File: src/main/java/javaslang/Lazy.java
Patch:
@@ -196,7 +196,7 @@ public <U> Lazy<U> flatMap(Function<? super T, ? extends java.lang.Iterable<? ex
     public <U> Lazy<U> flatten() {
         try {
             return ((Lazy<? extends java.lang.Iterable<U>>) this).flatMap(Function.identity());
-        } catch(ClassCastException x) {
+        } catch (ClassCastException x) {
             throw new UnsupportedOperationException("flatten of non-iterable elements");
         }
     }

File: src/main/java/javaslang/algebra/Foldable.java
Patch:
@@ -75,7 +75,7 @@ default T foldLeft(Monoid<? extends T> monoid) {
     /**
      * Folds this elements from the left, starting with {@code zero} and successively calling {@code combine}.
      *
-     * @param <U> the type of the folded value
+     * @param <U>     the type of the folded value
      * @param zero    A zero element to start with.
      * @param combine A function which combines elements.
      * @return a folded value
@@ -118,7 +118,7 @@ default T foldRight(Monoid<? extends T> monoid) {
     /**
      * Folds this elements from the right, starting with {@code zero} and successively calling {@code combine}.
      *
-     * @param <U> the type of the folded value
+     * @param <U>     the type of the folded value
      * @param zero    A zero element to start with.
      * @param combine A function which combines elements.
      * @return a folded value

File: src/main/java/javaslang/collection/SortedSet.java
Patch:
@@ -133,7 +133,7 @@ default T last() {
     SortedSet<T> replaceAll(T currentElement, T newElement);
 
     @Override
-    SortedSet <T> retainAll(java.lang.Iterable<? extends T> elements);
+    SortedSet<T> retainAll(java.lang.Iterable<? extends T> elements);
 
     @Override
     SortedSet<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation);
@@ -145,7 +145,7 @@ default T last() {
     // DEV-NOTE: The return type is either Set or SortedSet, depending whether U is Comparable
     @Override
     <U> Set<U> scanRight(U zero, BiFunction<? super T, ? super U, ? extends U> operation);
-    
+
     @Override
     Tuple2<? extends SortedSet<T>, ? extends SortedSet<T>> span(Predicate<? super T> predicate);
 

File: src/main/java/javaslang/collection/Traversables.java
Patch:
@@ -36,7 +36,7 @@ static <T, U, C extends Iterable<U>, R extends Traversable<U>> R scanRight(
             Iterable<? extends T> elements,
             U zero, BiFunction<? super T, ? super U, ? extends U> operation,
             C cumulativeResult, BiFunction<C, U, C> combiner, Function<C, R> finisher) {
-        final Iterable<T> reversedElements = Seq.ofAll(elements).reverseIterator();
+        final Iterator<? extends T> reversedElements = Seq.ofAll(elements).reverseIterator();
         return scanLeft(reversedElements, zero, (u, t) -> operation.apply(t, u), cumulativeResult, combiner, finisher);
     }
 }

File: src/main/java/javaslang/collection/TreeSet.java
Patch:
@@ -693,7 +693,6 @@ public TreeSet<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> ope
         return Traversables.scanLeft(this, zero, operation, TreeSet.empty(comparator()), TreeSet::add, Function.identity());
     }
 
-    @SuppressWarnings({ "unchecked", "rawtypes" })
     @Override
     public <U> Set<U> scanLeft(U zero, BiFunction<? super U, ? super T, ? extends U> operation) {
         Objects.requireNonNull(operation, "operation is null");
@@ -708,7 +707,6 @@ public <U> Set<U> scanLeft(U zero, BiFunction<? super U, ? super T, ? extends U>
         }
     }
 
-    @SuppressWarnings({ "unchecked", "rawtypes" })
     @Override
     public <U> Set<U> scanRight(U zero, BiFunction<? super T, ? super U, ? extends U> operation) {
         Objects.requireNonNull(operation, "operation is null");

File: src/main/java/javaslang/control/Match.java
Patch:
@@ -399,7 +399,7 @@ interface MatchMonad<R> extends Value<R> {
         default <U> MatchMonad<U> flatten() {
             try {
                 return ((MatchMonad<? extends Iterable<U>>) this).flatMap(Function.identity());
-            } catch(ClassCastException x) {
+            } catch (ClassCastException x) {
                 throw new UnsupportedOperationException("flatten of non-iterable elements");
             }
         }

File: src/main/java/javaslang/control/Try.java
Patch:
@@ -205,7 +205,7 @@ default <U> Try<U> flatMapTry(CheckedFunction<? super T, ? extends java.lang.Ite
     default <U> Try<U> flatten() {
         try {
             return ((Try<? extends Iterable<U>>) this).flatMap(Function.identity());
-        } catch(ClassCastException x) {
+        } catch (ClassCastException x) {
             throw new UnsupportedOperationException("flatten of non-iterable elements");
         }
     }
@@ -413,7 +413,7 @@ default Try<T> recover(Function<? super Throwable, ? extends T> f) {
      * @return a new Try
      */
     @SuppressWarnings("unchecked")
-    default Try<T> recoverWith(Function<? super Throwable, ? extends Try< ? extends T>> f) {
+    default Try<T> recoverWith(Function<? super Throwable, ? extends Try<? extends T>> f) {
         if (isFailure()) {
             try {
                 return (Try<T>) f.apply(getCause());

File: src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -102,7 +102,7 @@ default <U> Arbitrary<U> flatMap(Function<? super T, ? extends java.lang.Iterabl
     default <U> Arbitrary<U> flatten() {
         try {
             return ((Arbitrary<? extends Iterable<U>>) this).flatMap(Function.identity());
-        } catch(ClassCastException x) {
+        } catch (ClassCastException x) {
             throw new UnsupportedOperationException("flatten of non-iterable elements");
         }
     }

File: src/main/java/javaslang/test/Gen.java
Patch:
@@ -328,7 +328,7 @@ default <U> Gen<U> flatMap(Function<? super T, ? extends java.lang.Iterable<? ex
     default <U> Gen<U> flatten() {
         try {
             return ((Gen<? extends Iterable<U>>) this).flatMap(Function.identity());
-        } catch(ClassCastException x) {
+        } catch (ClassCastException x) {
             throw new UnsupportedOperationException("flatten of non-iterable elements");
         }
     }

File: src/main/java/javaslang/.java
Patch:
@@ -5,8 +5,6 @@
  */
 package javaslang;
 
-import javaslang.collection.Array;
-import javaslang.collection.Iterator;
 import javaslang.collection.List;
 import javaslang.control.Try;
 import javaslang.Module.ReflectionUtil;

File: src/test/java/javaslang/collection/AbstractSetTest.java
Patch:
@@ -5,11 +5,8 @@
  */
 package javaslang.collection;
 
-import org.junit.Assert;
 import org.junit.Test;
 
-import java.util.Objects;
-
 public abstract class AbstractSetTest extends AbstractTraversableRangeTest {
 
     @Override

File: src/test/java/javaslang/collection/AbstractValueTest.java
Patch:
@@ -235,9 +235,9 @@ public void shouldNotDetectWrongReturnTypeOnFlattenButWhenReadingFlattenedElemen
         try {
             final String s = unsafe.get();
             throw new AssertionError("Expected ClassCastException but got " + s);
-        } catch(ClassCastException x) {
+        } catch (ClassCastException x) {
             // ok!
-        } catch(Exception x) {
+        } catch (Exception x) {
             throw new AssertionError("Unexpected exception:" + x);
         }
     }

File: src/test/java/javaslang/collection/IteratorTest.java
Patch:
@@ -230,7 +230,6 @@ public void shouldCalculateDifferentHashCodesForDifferentTraversables() {
     // -- groupBy
 
     @Override
-    @SuppressWarnings("unchecked")
     public void shouldNonNilGroupByIdentity() {
         // we can't compare iterators, should map it to sequences
         final Seq<?> actual = ofAll('a', 'b', 'c').groupBy(Function.identity()).map(e -> Tuple.of(e._1, List.ofAll(e._2)));
@@ -243,7 +242,6 @@ public void shouldNonNilGroupByIdentity() {
     }
 
     @Override
-    @SuppressWarnings("unchecked")
     public void shouldNonNilGroupByEqual() {
         // we can't compare iterators, should map it to sequences
         final Seq<?> actual = ofAll('a', 'b', 'c').groupBy(c -> 1).map(e -> Tuple.of(e._1, List.ofAll(e._2)));

File: src/test/java/javaslang/collection/LinkedHashSetTest.java
Patch:
@@ -156,7 +156,7 @@ protected LinkedHashSet<Long> rangeClosedBy(long from, long toInclusive, long st
 
     @Test
     public void shouldKeepOrder() {
-        List<Integer> actual = LinkedHashSet.<Integer>empty().add(3).add(2).add(1).toList();
+        List<Integer> actual = LinkedHashSet.<Integer> empty().add(3).add(2).add(1).toList();
         assertThat(actual).isEqualTo(List.ofAll(3, 2, 1));
     }
 }

File: src/test/java/javaslang/collection/ListTest.java
Patch:
@@ -181,7 +181,7 @@ public void shouldNotSerializeEnclosingClass() throws Throwable {
     public void shouldNotDeserializeListWithSizeLessThanOne() throws Throwable {
         try {
             /*
-			 * This implementation is stable regarding jvm impl changes ofAll object serialization. The index ofAll the number
+             * This implementation is stable regarding jvm impl changes ofAll object serialization. The index ofAll the number
 			 * ofAll List elements is gathered dynamically.
 			 */
             final byte[] listWithOneElement = Serializables.serialize(List.of(0));

File: src/test/java/javaslang/collection/VectorTest.java
Patch:
@@ -183,7 +183,7 @@ public void shouldNotSerializeEnclosingClass() throws Throwable {
     public void shouldNotDeserializeListWithSizeLessThanOne() throws Throwable {
         try {
             /*
-			 * This implementation is stable regarding jvm impl changes ofAll object serialization. The index ofAll the number
+             * This implementation is stable regarding jvm impl changes ofAll object serialization. The index ofAll the number
 			 * ofAll List elements is gathered dynamically.
 			 */
             final byte[] listWithOneElement = Serializables.serialize(List.of(0));

File: src/test/java/javaslang/collection/euler/Euler14Test.java
Patch:
@@ -48,7 +48,7 @@ public void shouldSolveProblem14() {
     }
 
     private final static Function1<Long, Long> collatzRecursive = n -> {
-        if(n == 1) {
+        if (n == 1) {
             return 1L;
         } else {
             if (n % 2 == 0) {

File: src/test/java/javaslang/collection/euler/Euler67Test.java
Patch:
@@ -57,7 +57,7 @@ private static int solve(String fileName) {
     static Vector<Vector<Integer>> loadTriangle(String fileName) {
         return Vector.ofAll(
                 Utils.readLines(Utils.file(fileName)).map(line ->
-                                Arrays.asList(line.split("\\s")).stream().map(Integer::parseInt)
+                        Arrays.asList(line.split("\\s")).stream().map(Integer::parseInt)
                 ).map(s -> Vector.ofAll(s::iterator))
         );
     }

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -507,7 +507,7 @@ public HashMap<K, V> takeWhile(Predicate<? super Tuple2<K, V>> predicate) {
 
     @Override
     public Seq<V> values() {
-        return map(Tuple2::_2).toStream();
+        return map(Tuple2::_2);
     }
 
     @Override

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -107,6 +107,7 @@ public interface Seq<T> extends Traversable<T>, IntFunction<T> {
      */
     @SuppressWarnings("unchecked")
     static <T> Seq<T> ofAll(Iterable<? extends T> elements) {
+        Objects.requireNonNull(elements, "elements is null");
         if (elements instanceof Seq) {
             return (Seq<T>) elements;
         } else {

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -1037,11 +1037,11 @@ default <U> Stream<U> scanLeft(U zero, BiFunction<? super U, ? super T, ? extend
         return Stream.ofAll(iterator().scanLeft(zero, operation));
     }
 
+    // not lazy!
     @Override
     default <U> Stream<U> scanRight(U zero, BiFunction<? super T, ? super U, ? extends U> operation) {
         Objects.requireNonNull(operation, "operation is null");
-        // lazily streams the elements of an iterator
-        return Stream.ofAll(iterator().scanRight(zero, operation));
+        return Traversables.scanRight(this, zero, operation, Stream.empty(), Stream::prepend, Function.identity());
     }
 
     @Override

File: src/test/java/javaslang/collection/IntMap.java
Patch:
@@ -216,12 +216,12 @@ public Traversable<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T>
     
     @Override
     public <U> Traversable<U> scanLeft(U zero, BiFunction<? super U, ? super T, ? extends U> operation) {
-        return iterator().scanLeft(zero, operation);
+        return original.values().scanLeft(zero, operation);
     }
     
     @Override
     public <U> Traversable<U> scanRight(U zero, BiFunction<? super T, ? super U, ? extends U> operation) {
-        return iterator().scanRight(zero, operation);
+        return original.values().scanRight(zero, operation);
     }
     
     @Override

File: src/test/java/javaslang/collection/LinkedHashMapTest.java
Patch:
@@ -52,7 +52,6 @@ public void shouldScan() {
                 .put(Tuple.of(3, "c"))
                 .put(Tuple.of(4, "d"));
         final Map<Integer, String> result = map.scan(Tuple.of(0, "x"), (t1, t2) -> Tuple.of(t1._1 + t2._1, t1._2 + t2._2));
-        System.out.println(result);
         assertThat(result).isEqualTo(LinkedHashMap.empty()
                 .put(0, "x")
                 .put(1, "xa")
@@ -69,7 +68,6 @@ public void shouldScanLeft() {
                 .put(Tuple.of(3, "c"))
                 .put(Tuple.of(4, "d"));
         final Seq<Tuple2<Integer, String>> result = map.scanLeft(Tuple.of(0, "x"), (t1, t2) -> Tuple.of(t1._1 + t2._1, t1._2 + t2._2));
-        System.out.println(result);
         assertThat(result).isEqualTo(List.ofAll(
                 Tuple.of(0, "x"),
                 Tuple.of(1, "xa"),

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -507,7 +507,7 @@ public HashMap<K, V> takeWhile(Predicate<? super Tuple2<K, V>> predicate) {
 
     @Override
     public Seq<V> values() {
-        return map(Tuple2::_2).toStream();
+        return map(Tuple2::_2);
     }
 
     @Override

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -1037,11 +1037,11 @@ default <U> Stream<U> scanLeft(U zero, BiFunction<? super U, ? super T, ? extend
         return Stream.ofAll(iterator().scanLeft(zero, operation));
     }
 
+    // not lazy!
     @Override
     default <U> Stream<U> scanRight(U zero, BiFunction<? super T, ? super U, ? extends U> operation) {
         Objects.requireNonNull(operation, "operation is null");
-        // lazily streams the elements of an iterator
-        return Stream.ofAll(iterator().scanRight(zero, operation));
+        return Traversables.scanRight(this, zero, operation, Stream.empty(), Stream::prepend, Function.identity());
     }
 
     @Override

File: src/test/java/javaslang/collection/IntMap.java
Patch:
@@ -216,12 +216,12 @@ public Traversable<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T>
     
     @Override
     public <U> Traversable<U> scanLeft(U zero, BiFunction<? super U, ? super T, ? extends U> operation) {
-        return iterator().scanLeft(zero, operation);
+        return original.values().scanLeft(zero, operation);
     }
     
     @Override
     public <U> Traversable<U> scanRight(U zero, BiFunction<? super T, ? super U, ? extends U> operation) {
-        return iterator().scanRight(zero, operation);
+        return original.values().scanRight(zero, operation);
     }
     
     @Override

File: src/main/java/javaslang/collection/IndexedSeq.java
Patch:
@@ -206,7 +206,7 @@ default int lastIndexWhere(Predicate<? super T> predicate, int end) {
     @Override
     default Iterator<T> reverseIterator() {
         return new AbstractIterator<T>() {
-            private int i = length();
+            private int i = IndexedSeq.this.length();
 
             @Override
             public boolean hasNext() {

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -1041,8 +1041,7 @@ default List<T> reverse() {
 
     @Override
     default List<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation) {
-        Objects.requireNonNull(operation, "operation is null");
-        return Traversables.scan(this, zero, operation, List.empty(), List::prepend, List::reverse);
+        return scanLeft(zero, operation);
     }
     
     @Override

File: src/main/java/javaslang/collection/IndexedSeq.java
Patch:
@@ -206,7 +206,7 @@ default int lastIndexWhere(Predicate<? super T> predicate, int end) {
     @Override
     default Iterator<T> reverseIterator() {
         return new AbstractIterator<T>() {
-            private int i = length();
+            private int i = IndexedSeq.this.length();
 
             @Override
             public boolean hasNext() {

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -1041,8 +1041,7 @@ default List<T> reverse() {
 
     @Override
     default List<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation) {
-        Objects.requireNonNull(operation, "operation is null");
-        return Traversables.scan(this, zero, operation, List.empty(), List::prepend, List::reverse);
+        return scanLeft(zero, operation);
     }
     
     @Override

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -1042,19 +1042,19 @@ default List<T> reverse() {
     @Override
     default List<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation) {
         Objects.requireNonNull(operation, "operation is null");
-        return Scanner.scan(this, zero, operation, List.empty(), List::prepend, List::reverse);
+        return Traversables.scan(this, zero, operation, List.empty(), List::prepend, List::reverse);
     }
     
     @Override
     default <U> List<U> scanLeft(U zero, BiFunction<? super U, ? super T, ? extends U> operation) {
         Objects.requireNonNull(operation, "operation is null");
-        return Scanner.scanLeft(this, zero, operation, List.empty(), List::prepend, List::reverse);
+        return Traversables.scanLeft(this, zero, operation, List.empty(), List::prepend, List::reverse);
     }
     
     @Override
     default <U> List<U> scanRight(U zero, BiFunction<? super T, ? super U, ? extends U> operation) {
         Objects.requireNonNull(operation, "operation is null");
-        return Scanner.scanRight(this, zero, operation, List.empty(), List::prepend, Function.identity());
+        return Traversables.scanRight(this, zero, operation, List.empty(), List::prepend, Function.identity());
     }
     
     @Override

File: src/main/java/javaslang/collection/SortedSet.java
Patch:
@@ -136,7 +136,7 @@ default T last() {
     SortedSet <T> retainAll(java.lang.Iterable<? extends T> elements);
 
     @Override
-    SortedSet<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation);
+    Set<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation);
     
     @Override
     <U> Set<U> scanLeft(U zero, BiFunction<? super U, ? super T, ? extends U> operation);

File: src/main/java/javaslang/collection/TreeSet.java
Patch:
@@ -694,8 +694,8 @@ public TreeSet<T> retainAll(java.lang.Iterable<? extends T> elements) {
     }
 
     @Override
-    public TreeSet<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation) {
-        return (TreeSet<T>) scanLeft(zero, operation);
+    public Set<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation) {
+        return scanLeft(zero, operation);
     }
     
     @SuppressWarnings({ "unchecked", "rawtypes" })

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -1042,19 +1042,19 @@ default List<T> reverse() {
     @Override
     default List<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation) {
         Objects.requireNonNull(operation, "operation is null");
-        return Scanner.scan(this, zero, operation, List.empty(), List::prepend, List::reverse);
+        return Traversables.scan(this, zero, operation, List.empty(), List::prepend, List::reverse);
     }
     
     @Override
     default <U> List<U> scanLeft(U zero, BiFunction<? super U, ? super T, ? extends U> operation) {
         Objects.requireNonNull(operation, "operation is null");
-        return Scanner.scanLeft(this, zero, operation, List.empty(), List::prepend, List::reverse);
+        return Traversables.scanLeft(this, zero, operation, List.empty(), List::prepend, List::reverse);
     }
     
     @Override
     default <U> List<U> scanRight(U zero, BiFunction<? super T, ? super U, ? extends U> operation) {
         Objects.requireNonNull(operation, "operation is null");
-        return Scanner.scanRight(this, zero, operation, List.empty(), List::prepend, Function.identity());
+        return Traversables.scanRight(this, zero, operation, List.empty(), List::prepend, Function.identity());
     }
     
     @Override

File: src/main/java/javaslang/collection/SortedSet.java
Patch:
@@ -136,7 +136,7 @@ default T last() {
     SortedSet <T> retainAll(java.lang.Iterable<? extends T> elements);
 
     @Override
-    SortedSet<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation);
+    Set<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation);
     
     @Override
     <U> Set<U> scanLeft(U zero, BiFunction<? super U, ? super T, ? extends U> operation);

File: src/main/java/javaslang/collection/TreeSet.java
Patch:
@@ -694,8 +694,8 @@ public TreeSet<T> retainAll(java.lang.Iterable<? extends T> elements) {
     }
 
     @Override
-    public TreeSet<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation) {
-        return (TreeSet<T>) scanLeft(zero, operation);
+    public Set<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation) {
+        return scanLeft(zero, operation);
     }
     
     @SuppressWarnings({ "unchecked", "rawtypes" })

File: src/main/java/javaslang/collection/CharSeq.java
Patch:
@@ -742,7 +742,7 @@ public CharSeq reverse() {
     @Override
     public Vector<Character> scan(Character zero,
             BiFunction<? super Character, ? super Character, ? extends Character> operation) {
-        return scan(zero, operation);
+        return scanLeft(zero, operation);
     }
     
     @Override

File: src/main/java/javaslang/collection/Vector.java
Patch:
@@ -993,7 +993,7 @@ public Vector<T> reverse() {
 
     @Override
     public Vector<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation) {
-        return scan(zero, operation);
+        return scanLeft(zero, operation);
     }
     
     @Override

File: src/main/java/javaslang/collection/CharSeq.java
Patch:
@@ -742,7 +742,7 @@ public CharSeq reverse() {
     @Override
     public Vector<Character> scan(Character zero,
             BiFunction<? super Character, ? super Character, ? extends Character> operation) {
-        return scan(zero, operation);
+        return scanLeft(zero, operation);
     }
     
     @Override

File: src/main/java/javaslang/collection/Vector.java
Patch:
@@ -993,7 +993,7 @@ public Vector<T> reverse() {
 
     @Override
     public Vector<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation) {
-        return scan(zero, operation);
+        return scanLeft(zero, operation);
     }
     
     @Override

File: src/main/java/javaslang/collection/Map.java
Patch:
@@ -80,7 +80,9 @@ default <T1, T2, T3> Tuple3<Seq<T1>, Seq<T2>, Seq<T3>> unzip3(BiFunction<? super
     Map<K, V> clear();
 
     @Override
-    boolean contains(Tuple2<K, V> element);
+    default boolean contains(Tuple2<K, V> element) {
+        return get(element._1).map(v -> Objects.equals(v, element._2)).orElse(false);
+    }
 
     @Override
     Map<K, V> distinct();

File: src/main/java/javaslang/collection/Map.java
Patch:
@@ -80,7 +80,9 @@ default <T1, T2, T3> Tuple3<Seq<T1>, Seq<T2>, Seq<T3>> unzip3(BiFunction<? super
     Map<K, V> clear();
 
     @Override
-    boolean contains(Tuple2<K, V> element);
+    default boolean contains(Tuple2<K, V> element) {
+        return get(element._1).map(v -> Objects.equals(v, element._2)).orElse(false);
+    }
 
     @Override
     Map<K, V> distinct();

File: src/main/java/javaslang/collection/SortedSet.java
Patch:
@@ -139,10 +139,10 @@ default T last() {
     SortedSet<T> scan(T zero, BiFunction<? super T, ? super T, ? extends T> operation);
     
     @Override
-    <U> SortedSet<U> scanLeft(U zero, BiFunction<? super U, ? super T, ? extends U> operation);
+    <U> Set<U> scanLeft(U zero, BiFunction<? super U, ? super T, ? extends U> operation);
     
     @Override
-    <U> SortedSet<U> scanRight(U zero, BiFunction<? super T, ? super U, ? extends U> operation);
+    <U> Set<U> scanRight(U zero, BiFunction<? super T, ? super U, ? extends U> operation);
     
     @Override
     Tuple2<? extends SortedSet<T>, ? extends SortedSet<T>> span(Predicate<? super T> predicate);

File: src/main/java/javaslang/Iterable.java
Patch:
@@ -74,7 +74,7 @@ default <U> boolean corresponds(java.lang.Iterable<U> that, BiPredicate<? super
 
     /**
      * A <em>smoothing</em> replacement for {@code equals}. It is similar to Scala's {@code ==} but better in the way
-     * that it is not limited to collection types, e.g. `Some(1) eq List(1)`, `None eq Failure(x)` etc.
+     * that it is not limited to collection types, e.g. {@code Some(1) eq List(1)}, {@code None eq Failure(x)} etc.
      * <p>
      * In a nutshell: eq checks <strong>congruence of structures</strong> and <strong>equality of contained values</strong>.
      * <p>

File: src/main/java/javaslang/collection/Tree.java
Patch:
@@ -891,7 +891,7 @@ enum Order {
 }
 
 /**
- * Because the empty tree `Empty` cannot be a child of an existing tree, method implementations distinguish between the
+ * Because the empty tree {@code Empty} cannot be a child of an existing tree, method implementations distinguish between the
  * empty and non-empty case. Because the structure of trees is recursive, often we have commands in the form of module
  * classes with one static method.
  */

File: src/main/java/javaslang/.java
Patch:
@@ -68,7 +68,7 @@ public interface <R> extends Serializable {
      * Returns a memoizing version of this function, which computes the return value for given arguments only one time.
      * On subsequent calls given the same arguments the memoized value is returned.
      * <p>
-     * Please note that memoizing functions do not permit `null` as single argument or return value.
+     * Please note that memoizing functions do not permit {@code null} as single argument or return value.
      *
      * @return a memoizing function equivalent to this.
      */

File: src/main/java/javaslang/Iterable.java
Patch:
@@ -74,7 +74,7 @@ default <U> boolean corresponds(java.lang.Iterable<U> that, BiPredicate<? super
 
     /**
      * A <em>smoothing</em> replacement for {@code equals}. It is similar to Scala's {@code ==} but better in the way
-     * that it is not limited to collection types, e.g. `Some(1) eq List(1)`, `None eq Failure(x)` etc.
+     * that it is not limited to collection types, e.g. {@code Some(1) eq List(1)}, {@code None eq Failure(x)} etc.
      * <p>
      * In a nutshell: eq checks <strong>congruence of structures</strong> and <strong>equality of contained values</strong>.
      * <p>

File: src/main/java/javaslang/collection/Tree.java
Patch:
@@ -891,7 +891,7 @@ enum Order {
 }
 
 /**
- * Because the empty tree `Empty` cannot be a child of an existing tree, method implementations distinguish between the
+ * Because the empty tree {@code Empty} cannot be a child of an existing tree, method implementations distinguish between the
  * empty and non-empty case. Because the structure of trees is recursive, often we have commands in the form of module
  * classes with one static method.
  */

File: src/main/java/javaslang/.java
Patch:
@@ -68,7 +68,7 @@ public interface <R> extends Serializable {
      * Returns a memoizing version of this function, which computes the return value for given arguments only one time.
      * On subsequent calls given the same arguments the memoized value is returned.
      * <p>
-     * Please note that memoizing functions do not permit `null` as single argument or return value.
+     * Please note that memoizing functions do not permit {@code null} as single argument or return value.
      *
      * @return a memoizing function equivalent to this.
      */

File: src/main/java/javaslang/collection/LinkedHashMap.java
Patch:
@@ -287,7 +287,8 @@ public LinkedHashMap<K, V> filter(Predicate<? super Tuple2<K, V>> predicate) {
     @Override
     public <U> Seq<U> flatMap(Function<? super Tuple2<K, V>, ? extends java.lang.Iterable<? extends U>> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
-        return list.flatMap(mapper).toStream();
+        // don't remove cast, doesn't compile in Eclipse without it
+        return (Seq<U>) list.flatMap(mapper).toStream();
     }
 
     @SuppressWarnings("unchecked")

File: src/test/java/javaslang/collection/StreamTest.java
Patch:
@@ -369,7 +369,7 @@ protected boolean useIsEqualToInsteadOfIsSameAs() {
     public void shouldNotProduceStackOverflow() {
         Stream.range(0, 1_000_000)
                 .map(String::valueOf)
-                .foldLeft(Stream.empty(), Stream::append)
+                .foldLeft(Stream.<String>empty(), Stream::append)
                 .mkString();
     }
 

File: src/main/java/javaslang/collection/LinkedHashMap.java
Patch:
@@ -84,7 +84,7 @@ public static <K, V> LinkedHashMap<K, V> of(Tuple2<? extends K, ? extends V> ent
     }
 
     /**
-     * Returns a singleton {@code HashMap}, i.e. a {@code HashMap} of one element.
+     * Returns a singleton {@code LinkedHashMap}, i.e. a {@code LinkedHashMap} of one element.
      *
      * @param key A singleton map key.
      * @param value A singleton map value.

File: src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -120,7 +120,7 @@ public static <K, V> TreeMap<K, V> of(Comparator<? super K> keyComparator, Tuple
     }
 
     /**
-     * Returns a singleton {@code HashMap}, i.e. a {@code HashMap} of one element.
+     * Returns a singleton {@code TreeMap}, i.e. a {@code TreeMap} of one element.
      *
      * @param key A singleton map key.
      * @param value A singleton map value.
@@ -133,7 +133,7 @@ public static <K extends Comparable<? super K>, V> TreeMap<K, V> of(K key, V val
     }
 
     /**
-     * Returns a singleton {@code HashMap}, i.e. a {@code HashMap} of one element.
+     * Returns a singleton {@code TreeMap}, i.e. a {@code TreeMap} of one element.
      *
      * @param key A singleton map key.
      * @param value A singleton map value.

File: src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -144,8 +144,6 @@ public static <K extends Comparable<? super K>, V> TreeMap<K, V> of(K key, V val
      */
     public static <K extends Comparable<? super K>, V> TreeMap<K, V> of(Comparator<? super K> keyComparator, K key, V value) {
         Objects.requireNonNull(keyComparator, "keyComparator is null");
-        Objects.requireNonNull(key, "key is null");
-        Objects.requireNonNull(value, "value is null");
         return TreeMap.<K, V>empty(keyComparator).put(key, value);
     }
 

File: src/main/java/javaslang/collection/LinkedHashMap.java
Patch:
@@ -80,7 +80,7 @@ public static <K, V> LinkedHashMap<K, V> empty() {
     public static <K, V> LinkedHashMap<K, V> of(Tuple2<? extends K, ? extends V> entry) {
         final HashMap<K, V> map = HashMap.of(entry);
         final Queue<Tuple2<K, V>> list = Queue.of((Tuple2<K, V>) entry);
-        return list.isEmpty() ? empty() : new LinkedHashMap<>(list, map);
+        return new LinkedHashMap<>(list, map);
     }
 
     /**
@@ -95,7 +95,7 @@ public static <K, V> LinkedHashMap<K, V> of(Tuple2<? extends K, ? extends V> ent
     public static <K, V> LinkedHashMap<K, V> of(K key, V value) {
         final HashMap<K, V> map = HashMap.of(key, value);
         final Queue<Tuple2<K, V>> list = Queue.of(Tuple.of(key, value));
-        return list.isEmpty() ? empty() : new LinkedHashMap<>(list, map);
+        return new LinkedHashMap<>(list, map);
     }
 
     /**
@@ -287,7 +287,7 @@ public LinkedHashMap<K, V> filter(Predicate<? super Tuple2<K, V>> predicate) {
     @Override
     public <U> Seq<U> flatMap(Function<? super Tuple2<K, V>, ? extends java.lang.Iterable<? extends U>> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
-        return (Seq<U>) list.flatMap(mapper).toStream();
+        return list.flatMap(mapper).toStream();
     }
 
     @SuppressWarnings("unchecked")

File: src-gen/main/java/javaslang/test/Property.java
Patch:
@@ -72,7 +72,7 @@ private static void log(String msg) {
      *
      * @param position The position of the argument within the argument list of the property, starting with 1.
      * @param size     The size hint passed to the {@linkplain Arbitrary} which caused the error.
-     * @param cause    The error which occured when the {@linkplain Arbitrary} tried to obtain the generator {@linkplain Gen}.
+     * @param cause    The error which occurred when the {@linkplain Arbitrary} tried to obtain the generator {@linkplain Gen}.
      * @return a new Error instance.
      */
     private static Error arbitraryError(int position, int size, Throwable cause) {
@@ -84,7 +84,7 @@ private static Error arbitraryError(int position, int size, Throwable cause) {
      *
      * @param position The position of the argument within the argument list of the property, starting with 1.
      * @param size     The size hint of the arbitrary which called the generator {@linkplain Gen} which caused the error.
-     * @param cause    The error which occured when the {@linkplain Gen} tried to generate a random value.
+     * @param cause    The error which occurred when the {@linkplain Gen} tried to generate a random value.
      * @return a new Error instance.
      */
     private static Error genError(int position, int size, Throwable cause) {
@@ -94,7 +94,7 @@ private static Error genError(int position, int size, Throwable cause) {
     /**
      * Creates an Error caused by an exception when testing a Predicate.
      *
-     * @param cause The error which occured when applying the {@linkplain java.util.function.Predicate}.
+     * @param cause The error which occurred when applying the {@linkplain java.util.function.Predicate}.
      * @return a new Error instance.
      */
     private static Error predicateError(Throwable cause) {

File: src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -59,7 +59,7 @@ public interface Arbitrary<T> extends Value<T> {
      * </code>
      * </pre>
      *
-     * @param size A (not necessarily positive) size parameter which may be interpreted idividually and is constant for all arbitrary objects regarding one property check.
+     * @param size A (not necessarily positive) size parameter which may be interpreted individually and is constant for all arbitrary objects regarding one property check.
      * @return A generator for objects of type T.
      */
     Gen<T> apply(int size);

File: src/main/java/javaslang/test/CheckResult.java
Patch:
@@ -19,7 +19,7 @@
  * <ul>
  * <li>{@code Satisfied}, if all tests satisfied the given property</li>
  * <li>{@code Falsified}, if a counter-example could be discovered that falsified the given property</li>
- * <li>{@code Erroneous}, if an exception occured executing the property check</li>
+ * <li>{@code Erroneous}, if an exception occurred executing the property check</li>
  * </ul>
  *
  * Please note that a {@code Satisfied} property check may be {@code Exhausted}, if the property is an implication

File: src-gen/main/java/javaslang/test/Property.java
Patch:
@@ -72,7 +72,7 @@ private static void log(String msg) {
      *
      * @param position The position of the argument within the argument list of the property, starting with 1.
      * @param size     The size hint passed to the {@linkplain Arbitrary} which caused the error.
-     * @param cause    The error which occured when the {@linkplain Arbitrary} tried to obtain the generator {@linkplain Gen}.
+     * @param cause    The error which occurred when the {@linkplain Arbitrary} tried to obtain the generator {@linkplain Gen}.
      * @return a new Error instance.
      */
     private static Error arbitraryError(int position, int size, Throwable cause) {
@@ -84,7 +84,7 @@ private static Error arbitraryError(int position, int size, Throwable cause) {
      *
      * @param position The position of the argument within the argument list of the property, starting with 1.
      * @param size     The size hint of the arbitrary which called the generator {@linkplain Gen} which caused the error.
-     * @param cause    The error which occured when the {@linkplain Gen} tried to generate a random value.
+     * @param cause    The error which occurred when the {@linkplain Gen} tried to generate a random value.
      * @return a new Error instance.
      */
     private static Error genError(int position, int size, Throwable cause) {
@@ -94,7 +94,7 @@ private static Error genError(int position, int size, Throwable cause) {
     /**
      * Creates an Error caused by an exception when testing a Predicate.
      *
-     * @param cause The error which occured when applying the {@linkplain java.util.function.Predicate}.
+     * @param cause The error which occurred when applying the {@linkplain java.util.function.Predicate}.
      * @return a new Error instance.
      */
     private static Error predicateError(Throwable cause) {

File: src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -59,7 +59,7 @@ public interface Arbitrary<T> extends Value<T> {
      * </code>
      * </pre>
      *
-     * @param size A (not necessarily positive) size parameter which may be interpreted idividually and is constant for all arbitrary objects regarding one property check.
+     * @param size A (not necessarily positive) size parameter which may be interpreted individually and is constant for all arbitrary objects regarding one property check.
      * @return A generator for objects of type T.
      */
     Gen<T> apply(int size);

File: src/main/java/javaslang/test/CheckResult.java
Patch:
@@ -19,7 +19,7 @@
  * <ul>
  * <li>{@code Satisfied}, if all tests satisfied the given property</li>
  * <li>{@code Falsified}, if a counter-example could be discovered that falsified the given property</li>
- * <li>{@code Erroneous}, if an exception occured executing the property check</li>
+ * <li>{@code Erroneous}, if an exception occurred executing the property check</li>
  * </ul>
  *
  * Please note that a {@code Satisfied} property check may be {@code Exhausted}, if the property is an implication

File: src/main/java/javaslang/control/Option.java
Patch:
@@ -72,7 +72,7 @@ static <T> Option<T> when(boolean condition, Supplier<? extends T> supplier) {
      * @param <T> type of the value
      * @return {@code Some(optional.get())} if value is Java {@code Optional} is present, {@code None} otherwise
      */
-    static <T> Option<T> wrap(Optional<T> optional) {
+    static <T> Option<T> ofOptional(Optional<? extends T> optional) {
         Objects.requireNonNull(optional, "optional is null");
         return optional.isPresent() ? of(optional.get()) : none();
     }

File: src/test/java/javaslang/control/OptionTest.java
Patch:
@@ -65,17 +65,17 @@ public void shouldThrowExceptionOnNull() {
 
     @Test
     public void shouldWrapEmptyOptional() {
-        assertThat(Option.none()).isEqualTo(Option.wrap(Optional.empty()));
+        assertThat(Option.none()).isEqualTo(Option.ofOptional(Optional.empty()));
     }
 
     @Test
     public void shouldWrapSomeOptional() {
-        assertThat(Option.of(1)).isEqualTo(Option.wrap(Optional.of(1)));
+        assertThat(Option.of(1)).isEqualTo(Option.ofOptional(Optional.of(1)));
     }
 
     @Test(expected = NullPointerException.class)
     public void shouldThrowExceptionOnNullOptional() {
-        assertThat(Option.none()).isEqualTo(Option.wrap(null));
+        assertThat(Option.none()).isEqualTo(Option.ofOptional(null));
     }
 
     // -- get

File: src/main/java/javaslang/collection/Queue.java
Patch:
@@ -627,7 +627,7 @@ public Queue<T> dropRight(int n) {
         if (n <= 0) {
             return this;
         }
-        return new Queue<>(front.dropRight(n), rear.drop(n - front.length()));
+        return new Queue<>(front.dropRight(n - rear.length()), rear.drop(n));
     }
 
     @Override

File: src/main/java/javaslang/collection/package-info.java
Patch:
@@ -40,8 +40,8 @@
  * <tbody>
  * <tr><td>{@linkplain javaslang.collection.HashMap}</td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td></tr>
  * <tr><td>{@linkplain javaslang.collection.HashSet}</td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td></tr>
- * <tr><td>{@linkplain javaslang.collection.LinkedHashMap}</td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
- * <tr><td>{@linkplain javaslang.collection.LinkedHashSet}</td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
+ * <tr><td>{@linkplain javaslang.collection.LinkedHashMap}</td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
+ * <tr><td>{@linkplain javaslang.collection.LinkedHashSet}</td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
  * <tr><td><em>{@linkplain javaslang.collection.Tree}</em></td><td><small>log</small></td><td><small>log</small></td><td><small>log</small></td><td><small>log</small></td></tr>
  * <tr><td>{@linkplain javaslang.collection.TreeMap}</td><td><small>log</small></td><td><small>log</small></td><td><small>log</small></td><td><small>log</small></td></tr>
  * <tr><td>{@linkplain javaslang.collection.TreeSet}</td><td><small>log</small></td><td><small>log</small></td><td><small>log</small></td><td><small>log</small></td></tr>

File: src/main/java/javaslang/collection/Queue.java
Patch:
@@ -627,7 +627,7 @@ public Queue<T> dropRight(int n) {
         if (n <= 0) {
             return this;
         }
-        return new Queue<>(front.dropRight(n), rear.drop(n - front.length()));
+        return new Queue<>(front.dropRight(n - rear.length()), rear.drop(n));
     }
 
     @Override

File: src/main/java/javaslang/collection/package-info.java
Patch:
@@ -40,8 +40,8 @@
  * <tbody>
  * <tr><td>{@linkplain javaslang.collection.HashMap}</td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td></tr>
  * <tr><td>{@linkplain javaslang.collection.HashSet}</td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td></tr>
- * <tr><td>{@linkplain javaslang.collection.LinkedHashMap}</td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
- * <tr><td>{@linkplain javaslang.collection.LinkedHashSet}</td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
+ * <tr><td>{@linkplain javaslang.collection.LinkedHashMap}</td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
+ * <tr><td>{@linkplain javaslang.collection.LinkedHashSet}</td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
  * <tr><td><em>{@linkplain javaslang.collection.Tree}</em></td><td><small>log</small></td><td><small>log</small></td><td><small>log</small></td><td><small>log</small></td></tr>
  * <tr><td>{@linkplain javaslang.collection.TreeMap}</td><td><small>log</small></td><td><small>log</small></td><td><small>log</small></td><td><small>log</small></td></tr>
  * <tr><td>{@linkplain javaslang.collection.TreeSet}</td><td><small>log</small></td><td><small>log</small></td><td><small>log</small></td><td><small>log</small></td></tr>

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -398,7 +398,7 @@ public HashMap<K, V> removeAll(java.lang.Iterable<? extends K> keys) {
     public HashMap<K, V> replace(Tuple2<K, V> currentElement, Tuple2<K, V> newElement) {
         Objects.requireNonNull(currentElement, "currentElement is null");
         Objects.requireNonNull(newElement, "newElement is null");
-        return containsKey(currentElement._1) ? put(newElement) : this;
+        return containsKey(currentElement._1) ? remove(currentElement._1).put(newElement) : this;
     }
 
     @Override

File: src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -494,7 +494,7 @@ public TreeMap<K, V> removeAll(Iterable<? extends K> keys) {
     public TreeMap<K, V> replace(Tuple2<K, V> currentElement, Tuple2<K, V> newElement) {
         Objects.requireNonNull(currentElement, "currentElement is null");
         Objects.requireNonNull(newElement, "newElement is null");
-        return containsKey(currentElement._1) ? put(newElement) : this;
+        return containsKey(currentElement._1) ? remove(currentElement._1).put(newElement) : this;
     }
 
     @Override

File: src/test/java/javaslang/collection/IntMap.java
Patch:
@@ -192,7 +192,7 @@ public IntMap<T> replace(T currentElement, T newElement) {
         final Option<Tuple2<Integer, T>> currentEntryOpt = original.findFirst(e -> e._2.equals(currentElement));
         if (currentEntryOpt.isDefined()) {
             final Tuple2<Integer, T> currentEntry = currentEntryOpt.get();
-            return IntMap.of(original.replace(currentEntry, Tuple.of(currentEntry._1, newElement)));
+            return IntMap.of(original.replace(currentEntry, Tuple.of(original.size() + 1, newElement)));
         } else {
             return this;
         }

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -398,7 +398,7 @@ public HashMap<K, V> removeAll(java.lang.Iterable<? extends K> keys) {
     public HashMap<K, V> replace(Tuple2<K, V> currentElement, Tuple2<K, V> newElement) {
         Objects.requireNonNull(currentElement, "currentElement is null");
         Objects.requireNonNull(newElement, "newElement is null");
-        return containsKey(currentElement._1) ? put(newElement) : this;
+        return containsKey(currentElement._1) ? remove(currentElement._1).put(newElement) : this;
     }
 
     @Override

File: src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -494,7 +494,7 @@ public TreeMap<K, V> removeAll(Iterable<? extends K> keys) {
     public TreeMap<K, V> replace(Tuple2<K, V> currentElement, Tuple2<K, V> newElement) {
         Objects.requireNonNull(currentElement, "currentElement is null");
         Objects.requireNonNull(newElement, "newElement is null");
-        return containsKey(currentElement._1) ? put(newElement) : this;
+        return containsKey(currentElement._1) ? remove(currentElement._1).put(newElement) : this;
     }
 
     @Override

File: src/test/java/javaslang/collection/IntMap.java
Patch:
@@ -192,7 +192,7 @@ public IntMap<T> replace(T currentElement, T newElement) {
         final Option<Tuple2<Integer, T>> currentEntryOpt = original.findFirst(e -> e._2.equals(currentElement));
         if (currentEntryOpt.isDefined()) {
             final Tuple2<Integer, T> currentEntry = currentEntryOpt.get();
-            return IntMap.of(original.replace(currentEntry, Tuple.of(currentEntry._1, newElement)));
+            return IntMap.of(original.replace(currentEntry, Tuple.of(original.size() + 1, newElement)));
         } else {
             return this;
         }

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -398,7 +398,7 @@ public HashMap<K, V> removeAll(java.lang.Iterable<? extends K> keys) {
     public HashMap<K, V> replace(Tuple2<K, V> currentElement, Tuple2<K, V> newElement) {
         Objects.requireNonNull(currentElement, "currentElement is null");
         Objects.requireNonNull(newElement, "newElement is null");
-        return containsKey(currentElement._1) ? put(newElement) : this;
+        return containsKey(currentElement._1) ? remove(currentElement._1).put(newElement) : this;
     }
 
     @Override

File: src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -494,7 +494,7 @@ public TreeMap<K, V> removeAll(Iterable<? extends K> keys) {
     public TreeMap<K, V> replace(Tuple2<K, V> currentElement, Tuple2<K, V> newElement) {
         Objects.requireNonNull(currentElement, "currentElement is null");
         Objects.requireNonNull(newElement, "newElement is null");
-        return containsKey(currentElement._1) ? put(newElement) : this;
+        return containsKey(currentElement._1) ? remove(currentElement._1).put(newElement) : this;
     }
 
     @Override

File: src/test/java/javaslang/collection/IntMap.java
Patch:
@@ -192,7 +192,7 @@ public IntMap<T> replace(T currentElement, T newElement) {
         final Option<Tuple2<Integer, T>> currentEntryOpt = original.findFirst(e -> e._2.equals(currentElement));
         if (currentEntryOpt.isDefined()) {
             final Tuple2<Integer, T> currentEntry = currentEntryOpt.get();
-            return IntMap.of(original.replace(currentEntry, Tuple.of(currentEntry._1, newElement)));
+            return IntMap.of(original.replace(currentEntry, Tuple.of(original.size() + 1, newElement)));
         } else {
             return this;
         }

File: src/main/java/javaslang/collection/CharSeq.java
Patch:
@@ -567,7 +567,7 @@ public Vector<CharSeq> permutations() {
                 Vector<CharSeq> result = Vector.empty();
                 for (Character t : distinct()) {
                     for (CharSeq ts : remove(t).permutations()) {
-                        result = result.append(ts);
+                        result = result.append(CharSeq.of(t).appendAll(ts));
                     }
                 }
                 return result;

File: src/test/java/javaslang/collection/AbstractTraversableOnceTest.java
Patch:
@@ -488,7 +488,7 @@ public void shouldGetInitOfNonNil() {
 
     @Test
     public void shouldNilGroupBy() {
-        assertThat(HashMap.empty().groupBy(Function.identity())).isEqualTo(HashMap.empty());
+        assertThat(empty().groupBy(Function.identity())).isEqualTo(HashMap.empty());
     }
 
     @Test

File: src/main/java/javaslang/collection/CharSeq.java
Patch:
@@ -567,7 +567,7 @@ public Vector<CharSeq> permutations() {
                 Vector<CharSeq> result = Vector.empty();
                 for (Character t : distinct()) {
                     for (CharSeq ts : remove(t).permutations()) {
-                        result = result.append(ts);
+                        result = result.append(CharSeq.of(t).appendAll(ts));
                     }
                 }
                 return result;

File: src/test/java/javaslang/collection/AbstractTraversableOnceTest.java
Patch:
@@ -488,7 +488,7 @@ public void shouldGetInitOfNonNil() {
 
     @Test
     public void shouldNilGroupBy() {
-        assertThat(HashMap.empty().groupBy(Function.identity())).isEqualTo(HashMap.empty());
+        assertThat(empty().groupBy(Function.identity())).isEqualTo(HashMap.empty());
     }
 
     @Test

File: src/main/java/javaslang/collection/Array.java
Patch:
@@ -1219,7 +1219,7 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return mkString(", ", "Array(", ")");
+        return mkString("Array(", ", ", ")");
     }
 
     private static <T> Object[] create(java.lang.Iterable<T> elements) {

File: src/main/java/javaslang/collection/HashArrayMappedTrie.java
Patch:
@@ -139,7 +139,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return iterator().map(t -> t._1 + " -> " + t._2).mkString(", ", "HashArrayMappedTrie(", ")");
+            return iterator().map(t -> t._1 + " -> " + t._2).mkString("HashArrayMappedTrie(", ", ", ")");
         }
     }
 

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -528,6 +528,6 @@ private Object readResolve() {
 
     @Override
     public String toString() {
-        return mkString(", ", "HashMap(", ")");
+        return mkString("HashMap(", ", ", ")");
     }
 }

File: src/main/java/javaslang/collection/HashSet.java
Patch:
@@ -604,8 +604,8 @@ public <U> HashSet<U> map(Function<? super T, ? extends U> mapper) {
     }
 
     @Override
-    public String mkString(CharSequence delimiter, CharSequence prefix, CharSequence suffix) {
-        return iterator().mkString(delimiter, prefix, suffix);
+    public String mkString(CharSequence prefix, CharSequence delimiter, CharSequence suffix) {
+        return iterator().mkString(prefix, delimiter, suffix);
     }
 
     @Override

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -1440,7 +1440,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return mkString(", ", "List(", ")");
+            return mkString("List(", ", ", ")");
         }
 
         /**

File: src/main/java/javaslang/collection/Queue.java
Patch:
@@ -1097,6 +1097,6 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return mkString(", ", "Queue(", ")");
+        return mkString("Queue(", ", ", ")");
     }
 }

File: src/main/java/javaslang/collection/TraversableOnce.java
Patch:
@@ -672,20 +672,20 @@ default String mkString() {
      * @return A new String
      */
     default String mkString(CharSequence delimiter) {
-        return mkString(delimiter, "", "");
+        return mkString("", delimiter, "");
     }
 
     /**
      * Joins the string representations of this elements using a specific delimiter, prefix and suffix.
      * <p>
      * Example: {@code List.of("a", "b", "c").mkString(", ", "Chars(", ")") = "Chars(a, b, c)"}
      *
-     * @param delimiter A delimiter string put between string representations of elements of this
      * @param prefix    prefix of the resulting string
+     * @param delimiter A delimiter string put between string representations of elements of this
      * @param suffix    suffix of the resulting string
      * @return a new String
      */
-    default String mkString(CharSequence delimiter, CharSequence prefix, CharSequence suffix) {
+    default String mkString(CharSequence prefix, CharSequence delimiter, CharSequence suffix) {
         final StringBuilder builder = new StringBuilder(prefix);
         iterator().map(String::valueOf).intersperse(String.valueOf(delimiter)).forEach(builder::append);
         return builder.append(suffix).toString();

File: src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -648,6 +648,6 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return mkString(", ", "TreeMap(", ")");
+        return mkString("TreeMap(", ", ", ")");
     }
 }

File: src/main/java/javaslang/collection/TreeSet.java
Patch:
@@ -821,6 +821,6 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return mkString(", ", "TreeSet(", ")");
+        return mkString("TreeSet(", ", ", ")");
     }
 }

File: src/main/java/javaslang/collection/Vector.java
Patch:
@@ -1241,7 +1241,7 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return mkString(", ", "Vector(", ")");
+        return mkString("Vector(", ", ", ")");
     }
 }
 

File: src/main/java/javaslang/.java
Patch:
@@ -144,7 +144,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return List.of(parameterTypes).map(Class::getName).mkString(", ", "(", ")") + " -> " + returnType.getName();
+            return List.of(parameterTypes).map(Class::getName).mkString("(", ", ", ")") + " -> " + returnType.getName();
         }
     }
 }

File: src/test/java/javaslang/collection/CharSeqTest.java
Patch:
@@ -808,12 +808,12 @@ public void shouldMkStringWithDelimiterNonNil() {
 
     @Test
     public void shouldMkStringWithDelimiterAndPrefixAndSuffixNil() {
-        assertThat(empty().mkString(",", "[", "]")).isEqualTo("[]");
+        assertThat(empty().mkString("[", ",", "]")).isEqualTo("[]");
     }
 
     @Test
     public void shouldMkStringWithDelimiterAndPrefixAndSuffixNonNil() {
-        assertThat(CharSeq.of('a', 'b', 'c').mkString(",", "[", "]")).isEqualTo("[a,b,c]");
+        assertThat(CharSeq.of('a', 'b', 'c').mkString("[", ",", "]")).isEqualTo("[a,b,c]");
     }
 
     // -- last

File: src/test/java/javaslang/collection/HashSetTest.java
Patch:
@@ -297,8 +297,8 @@ public void shouldMkStringWithDelimiterNonNil() {
 
     @Override
     public void shouldMkStringWithDelimiterAndPrefixAndSuffixNonNil() {
-        final String actual = of('a', 'b', 'c').mkString(",", "[", "]");
-        final List<String> expected = List.of('a', 'b', 'c').permutations().map(l -> l.mkString(",", "[", "]"));
+        final String actual = of('a', 'b', 'c').mkString("[", ",", "]");
+        final List<String> expected = List.of('a', 'b', 'c').permutations().map(l -> l.mkString("[", ",", "]"));
         assertThat(actual).isIn(expected);
     }
 

File: src/main/java/javaslang/collection/Array.java
Patch:
@@ -1219,7 +1219,7 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return mkString(", ", "Array(", ")");
+        return mkString("Array(", ", ", ")");
     }
 
     private static <T> Object[] create(java.lang.Iterable<T> elements) {

File: src/main/java/javaslang/collection/HashArrayMappedTrie.java
Patch:
@@ -139,7 +139,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return iterator().map(t -> t._1 + " -> " + t._2).mkString(", ", "HashArrayMappedTrie(", ")");
+            return iterator().map(t -> t._1 + " -> " + t._2).mkString("HashArrayMappedTrie(", ", ", ")");
         }
     }
 

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -528,6 +528,6 @@ private Object readResolve() {
 
     @Override
     public String toString() {
-        return mkString(", ", "HashMap(", ")");
+        return mkString("HashMap(", ", ", ")");
     }
 }

File: src/main/java/javaslang/collection/HashSet.java
Patch:
@@ -604,8 +604,8 @@ public <U> HashSet<U> map(Function<? super T, ? extends U> mapper) {
     }
 
     @Override
-    public String mkString(CharSequence delimiter, CharSequence prefix, CharSequence suffix) {
-        return iterator().mkString(delimiter, prefix, suffix);
+    public String mkString(CharSequence prefix, CharSequence delimiter, CharSequence suffix) {
+        return iterator().mkString(prefix, delimiter, suffix);
     }
 
     @Override

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -1440,7 +1440,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return mkString(", ", "List(", ")");
+            return mkString("List(", ", ", ")");
         }
 
         /**

File: src/main/java/javaslang/collection/Queue.java
Patch:
@@ -1097,6 +1097,6 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return mkString(", ", "Queue(", ")");
+        return mkString("Queue(", ", ", ")");
     }
 }

File: src/main/java/javaslang/collection/TraversableOnce.java
Patch:
@@ -649,20 +649,20 @@ default String mkString() {
      * @return A new String
      */
     default String mkString(CharSequence delimiter) {
-        return mkString(delimiter, "", "");
+        return mkString("", delimiter, "");
     }
 
     /**
      * Joins the string representations of this elements using a specific delimiter, prefix and suffix.
      * <p>
      * Example: {@code List.of("a", "b", "c").mkString(", ", "Chars(", ")") = "Chars(a, b, c)"}
      *
-     * @param delimiter A delimiter string put between string representations of elements of this
      * @param prefix    prefix of the resulting string
+     * @param delimiter A delimiter string put between string representations of elements of this
      * @param suffix    suffix of the resulting string
      * @return a new String
      */
-    default String mkString(CharSequence delimiter, CharSequence prefix, CharSequence suffix) {
+    default String mkString(CharSequence prefix, CharSequence delimiter, CharSequence suffix) {
         final StringBuilder builder = new StringBuilder(prefix);
         iterator().map(String::valueOf).intersperse(String.valueOf(delimiter)).forEach(builder::append);
         return builder.append(suffix).toString();

File: src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -648,6 +648,6 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return mkString(", ", "TreeMap(", ")");
+        return mkString("TreeMap(", ", ", ")");
     }
 }

File: src/main/java/javaslang/collection/TreeSet.java
Patch:
@@ -821,6 +821,6 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return mkString(", ", "TreeSet(", ")");
+        return mkString("TreeSet(", ", ", ")");
     }
 }

File: src/main/java/javaslang/collection/Vector.java
Patch:
@@ -1241,7 +1241,7 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return mkString(", ", "Vector(", ")");
+        return mkString("Vector(", ", ", ")");
     }
 }
 

File: src/main/java/javaslang/.java
Patch:
@@ -144,7 +144,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return List.of(parameterTypes).map(Class::getName).mkString(", ", "(", ")") + " -> " + returnType.getName();
+            return List.of(parameterTypes).map(Class::getName).mkString("(", ", ", ")") + " -> " + returnType.getName();
         }
     }
 }

File: src/test/java/javaslang/collection/CharSeqTest.java
Patch:
@@ -808,12 +808,12 @@ public void shouldMkStringWithDelimiterNonNil() {
 
     @Test
     public void shouldMkStringWithDelimiterAndPrefixAndSuffixNil() {
-        assertThat(empty().mkString(",", "[", "]")).isEqualTo("[]");
+        assertThat(empty().mkString("[", ",", "]")).isEqualTo("[]");
     }
 
     @Test
     public void shouldMkStringWithDelimiterAndPrefixAndSuffixNonNil() {
-        assertThat(CharSeq.of('a', 'b', 'c').mkString(",", "[", "]")).isEqualTo("[a,b,c]");
+        assertThat(CharSeq.of('a', 'b', 'c').mkString("[", ",", "]")).isEqualTo("[a,b,c]");
     }
 
     // -- last

File: src/test/java/javaslang/collection/HashSetTest.java
Patch:
@@ -297,8 +297,8 @@ public void shouldMkStringWithDelimiterNonNil() {
 
     @Override
     public void shouldMkStringWithDelimiterAndPrefixAndSuffixNonNil() {
-        final String actual = of('a', 'b', 'c').mkString(",", "[", "]");
-        final List<String> expected = List.of('a', 'b', 'c').permutations().map(l -> l.mkString(",", "[", "]"));
+        final String actual = of('a', 'b', 'c').mkString("[", ",", "]");
+        final List<String> expected = List.of('a', 'b', 'c').permutations().map(l -> l.mkString("[", ",", "]"));
         assertThat(actual).isIn(expected);
     }
 

File: src-gen/test/java/javaslang/CheckedFunction0Test.java
Patch:
@@ -24,7 +24,7 @@ Object methodReference() {
             }
         }
         final Type type = new Type();
-        assertThat(CheckedFunction0.lift(type::methodReference)).isNotNull();
+        assertThat(CheckedFunction0.of(type::methodReference)).isNotNull();
     }
 
     @Test

File: src-gen/test/java/javaslang/CheckedFunction1Test.java
Patch:
@@ -24,7 +24,7 @@ Object methodReference(Object o1) {
             }
         }
         final Type type = new Type();
-        assertThat(CheckedFunction1.lift(type::methodReference)).isNotNull();
+        assertThat(CheckedFunction1.of(type::methodReference)).isNotNull();
     }
 
     @Test

File: src-gen/test/java/javaslang/CheckedFunction2Test.java
Patch:
@@ -24,7 +24,7 @@ Object methodReference(Object o1, Object o2) {
             }
         }
         final Type type = new Type();
-        assertThat(CheckedFunction2.lift(type::methodReference)).isNotNull();
+        assertThat(CheckedFunction2.of(type::methodReference)).isNotNull();
     }
 
     @Test

File: src-gen/test/java/javaslang/CheckedFunction3Test.java
Patch:
@@ -24,7 +24,7 @@ Object methodReference(Object o1, Object o2, Object o3) {
             }
         }
         final Type type = new Type();
-        assertThat(CheckedFunction3.lift(type::methodReference)).isNotNull();
+        assertThat(CheckedFunction3.of(type::methodReference)).isNotNull();
     }
 
     @Test

File: src-gen/test/java/javaslang/CheckedFunction4Test.java
Patch:
@@ -24,7 +24,7 @@ Object methodReference(Object o1, Object o2, Object o3, Object o4) {
             }
         }
         final Type type = new Type();
-        assertThat(CheckedFunction4.lift(type::methodReference)).isNotNull();
+        assertThat(CheckedFunction4.of(type::methodReference)).isNotNull();
     }
 
     @Test

File: src-gen/test/java/javaslang/CheckedFunction5Test.java
Patch:
@@ -24,7 +24,7 @@ Object methodReference(Object o1, Object o2, Object o3, Object o4, Object o5) {
             }
         }
         final Type type = new Type();
-        assertThat(CheckedFunction5.lift(type::methodReference)).isNotNull();
+        assertThat(CheckedFunction5.of(type::methodReference)).isNotNull();
     }
 
     @Test

File: src-gen/test/java/javaslang/CheckedFunction6Test.java
Patch:
@@ -24,7 +24,7 @@ Object methodReference(Object o1, Object o2, Object o3, Object o4, Object o5, Ob
             }
         }
         final Type type = new Type();
-        assertThat(CheckedFunction6.lift(type::methodReference)).isNotNull();
+        assertThat(CheckedFunction6.of(type::methodReference)).isNotNull();
     }
 
     @Test

File: src-gen/test/java/javaslang/CheckedFunction7Test.java
Patch:
@@ -24,7 +24,7 @@ Object methodReference(Object o1, Object o2, Object o3, Object o4, Object o5, Ob
             }
         }
         final Type type = new Type();
-        assertThat(CheckedFunction7.lift(type::methodReference)).isNotNull();
+        assertThat(CheckedFunction7.of(type::methodReference)).isNotNull();
     }
 
     @Test

File: src-gen/test/java/javaslang/CheckedFunction8Test.java
Patch:
@@ -24,7 +24,7 @@ Object methodReference(Object o1, Object o2, Object o3, Object o4, Object o5, Ob
             }
         }
         final Type type = new Type();
-        assertThat(CheckedFunction8.lift(type::methodReference)).isNotNull();
+        assertThat(CheckedFunction8.of(type::methodReference)).isNotNull();
     }
 
     @Test

File: src-gen/test/java/javaslang/Function0Test.java
Patch:
@@ -24,7 +24,7 @@ Object methodReference() {
             }
         }
         final Type type = new Type();
-        assertThat(Function0.lift(type::methodReference)).isNotNull();
+        assertThat(Function0.of(type::methodReference)).isNotNull();
     }
 
     @Test

File: src-gen/test/java/javaslang/Function1Test.java
Patch:
@@ -24,7 +24,7 @@ Object methodReference(Object o1) {
             }
         }
         final Type type = new Type();
-        assertThat(Function1.lift(type::methodReference)).isNotNull();
+        assertThat(Function1.of(type::methodReference)).isNotNull();
     }
 
     @Test

File: src-gen/test/java/javaslang/Function2Test.java
Patch:
@@ -24,7 +24,7 @@ Object methodReference(Object o1, Object o2) {
             }
         }
         final Type type = new Type();
-        assertThat(Function2.lift(type::methodReference)).isNotNull();
+        assertThat(Function2.of(type::methodReference)).isNotNull();
     }
 
     @Test

File: src-gen/test/java/javaslang/Function3Test.java
Patch:
@@ -24,7 +24,7 @@ Object methodReference(Object o1, Object o2, Object o3) {
             }
         }
         final Type type = new Type();
-        assertThat(Function3.lift(type::methodReference)).isNotNull();
+        assertThat(Function3.of(type::methodReference)).isNotNull();
     }
 
     @Test

File: src-gen/test/java/javaslang/Function4Test.java
Patch:
@@ -24,7 +24,7 @@ Object methodReference(Object o1, Object o2, Object o3, Object o4) {
             }
         }
         final Type type = new Type();
-        assertThat(Function4.lift(type::methodReference)).isNotNull();
+        assertThat(Function4.of(type::methodReference)).isNotNull();
     }
 
     @Test

File: src-gen/test/java/javaslang/Function5Test.java
Patch:
@@ -24,7 +24,7 @@ Object methodReference(Object o1, Object o2, Object o3, Object o4, Object o5) {
             }
         }
         final Type type = new Type();
-        assertThat(Function5.lift(type::methodReference)).isNotNull();
+        assertThat(Function5.of(type::methodReference)).isNotNull();
     }
 
     @Test

File: src-gen/test/java/javaslang/Function6Test.java
Patch:
@@ -24,7 +24,7 @@ Object methodReference(Object o1, Object o2, Object o3, Object o4, Object o5, Ob
             }
         }
         final Type type = new Type();
-        assertThat(Function6.lift(type::methodReference)).isNotNull();
+        assertThat(Function6.of(type::methodReference)).isNotNull();
     }
 
     @Test

File: src-gen/test/java/javaslang/Function7Test.java
Patch:
@@ -24,7 +24,7 @@ Object methodReference(Object o1, Object o2, Object o3, Object o4, Object o5, Ob
             }
         }
         final Type type = new Type();
-        assertThat(Function7.lift(type::methodReference)).isNotNull();
+        assertThat(Function7.of(type::methodReference)).isNotNull();
     }
 
     @Test

File: src-gen/test/java/javaslang/Function8Test.java
Patch:
@@ -24,7 +24,7 @@ Object methodReference(Object o1, Object o2, Object o3, Object o4, Object o5, Ob
             }
         }
         final Type type = new Type();
-        assertThat(Function8.lift(type::methodReference)).isNotNull();
+        assertThat(Function8.of(type::methodReference)).isNotNull();
     }
 
     @Test

File: src/test/java/benchmark/collection/MapSetBench.java
Patch:
@@ -31,7 +31,7 @@ public class MapSetBench {
     });
 
     private static final Function<Integer, TreeSet<Integer>> treeCache = Function1
-            .lift((Integer i) -> treeGen.get())
+            .of((Integer i) -> treeGen.get())
             .memoized();
 
     private static final Iterator<TreeSet<Integer>> trees = new Iterator<TreeSet<Integer>>() {

File: src/test/java/javaslang/FunctionsTest.java
Patch:
@@ -23,7 +23,7 @@ public void shouldRecognizeLambdaSignature() {
 
     @Test
     public void shouldRecognizeLiftedLambdaSignature() {
-        final Function1<Integer, Integer> f = Function1.lift(i -> i + 1);
+        final Function1<Integer, Integer> f = Function1.of(i -> i + 1);
         assertThat(f.getType().toString()).isEqualTo("(java.lang.Integer) -> java.lang.Integer");
     }
 
@@ -49,7 +49,7 @@ public void shouldRecognizeLambdaCallSignature() {
     @Test
     public void shouldRecognizeLiftedLambdaCallSignature() {
         final Function<Integer, Integer> f1 = i -> i + 1;
-        final Function1<Integer, Integer> f2 = Function1.lift(i -> f1.apply(i));
+        final Function1<Integer, Integer> f2 = Function1.of(i -> f1.apply(i));
         assertThat(f2.getType().toString()).isEqualTo("(java.lang.Integer) -> java.lang.Integer");
     }
 
@@ -63,7 +63,7 @@ public void shouldRecognizeMethodReferenceSignature() {
     @Test
     public void shouldRecognizeLiftedMethodReferenceSignature() {
         final Function<Integer, Integer> f1 = i -> i + 1;
-        final Function1<Integer, Integer> f2 = Function1.lift(f1::apply);
+        final Function1<Integer, Integer> f2 = Function1.of(f1::apply);
         assertThat(f2.getType().toString()).isEqualTo("(java.lang.Integer) -> java.lang.Integer");
     }
 

File: src/test/java/javaslang/collection/euler/Euler18Test.java
Patch:
@@ -43,7 +43,7 @@ private static int solve(String fileName) {
         return naive.apply(Euler67Test.loadTriangle(fileName), 0, 0);
     }
 
-    private final static Function3<Vector<Vector<Integer>>, Integer, Integer, Integer> naive = Function3.lift(
+    private final static Function3<Vector<Vector<Integer>>, Integer, Integer, Integer> naive = Function3.of(
             (Vector<Vector<Integer>> tr, Integer row, Integer col) -> {
                 int value = tr.get(row).get(col);
                 if (row == tr.length() - 1) {

File: src/test/java/javaslang/collection/euler/Euler67Test.java
Patch:
@@ -43,7 +43,7 @@ private static int solve(String fileName) {
         return smart.apply(loadTriangle(fileName), 0, 0);
     }
 
-    private final static Function3<Vector<Vector<Integer>>, Integer, Integer, Integer> smart = Function3.lift(
+    private final static Function3<Vector<Vector<Integer>>, Integer, Integer, Integer> smart = Function3.of(
             (Vector<Vector<Integer>> tr, Integer row, Integer col) -> {
                 int value = tr.get(row).get(col);
                 if (row == tr.length() - 1) {

File: src/main/java/javaslang/collection/Iterator.java
Patch:
@@ -1328,7 +1328,7 @@ public U next() {
      * <p>
      * <strong>Caution:</strong> Because {@code Iterator} is lazy, there is no way to detect non-iterable elements on
      * {@code flatten()}. A possible {@code ClassCastException} is therefore deferred until elemnts are accessed with
-     * {@link #next()} }.
+     * {@link #next()}.
      *
      * @param <U> the nested component type
      * @return An Iterator of flattened elements.

File: src/main/java/javaslang/concurrent/Promise.java
Patch:
@@ -21,7 +21,7 @@
  * <p>
  * The underlying {@code ExecutorService} is used to execute asynchronous handlers, e.g. via
  * {@code promise.future().onComplete(...)}.
- * <p>
+ *
  * <h3>Creation</h3>
  * <p>
  * Promise offers static factory methods to create new promises which hasn't been fulfilled yet:
@@ -36,7 +36,7 @@
  * </ul>
  * All the static factory methods mentioned above have additional versions which take an {@link ExecutorService} as
  * argument. This gives us more control over thread creation and thread pool sizes.
- * <p>
+ *
  * <h3>One-shot API</h3>
  * <p>
  * The main purpose of a {@code Promise} is to complete its underlying {@code Future}. When only a single {@code Thread}
@@ -48,7 +48,7 @@
  * <li>{@link #failure(Throwable)}</li>
  * <li>{@link #success(Object)}</li>
  * </ul>
- * <p>
+ *
  * <h3>API for competing threads</h3>
  * <p>
  * When multiple {@code Thread}s may complete our {@code Promise}, we typically use one of these methods. Calls will

File: src/test/java/javaslang/concurrent/FutureTest.java
Patch:
@@ -308,14 +308,14 @@ public void shouldPerformActionAfterFutureCompleted() {
     public void shouldMapTheHappyPath() {
         final Future<String> testee = Future.of(zZz(1)).map(Object::toString);
         waitUntil(testee::isCompleted);
-        System.out.println(testee);
+        assertCompleted(testee, "1");
     }
 
     @Test
     public void shouldMapWhenCrashing() {
-        final Future<String> testee = Future.of(zZz(new Error())).map(Object::toString);
+        final Future<String> testee = Future.of(zZz(1)).map(i -> { throw new IllegalStateException(); });
         waitUntil(testee::isCompleted);
-        System.out.println(testee);
+        assertFailed(testee, IllegalStateException.class);
     }
 
     // -- (helpers)

File: src/main/java/javaslang/concurrent/Future.java
Patch:
@@ -236,7 +236,7 @@ static <T> Future<T> fromTry(Try<? extends T> result) {
     static <T> Future<T> fromTry(ExecutorService executorService, Try<? extends T> result) {
         Objects.requireNonNull(executorService, "executorService is null");
         Objects.requireNonNull(result, "result is null");
-        return Promise.fromTry(executorService, result).future();
+        return Promise.<T> fromTry(executorService, result).future();
     }
 
     /**
@@ -301,7 +301,7 @@ static <T> Future<T> reduce(ExecutorService executorService, Iterable<? extends
         if (!futures.iterator().hasNext()) {
             throw new NoSuchElementException("Future.reduce on empty futures");
         } else {
-            return sequence(futures).map(seq -> seq.reduceLeft(f));
+            return Future.<T> sequence(futures).map(seq -> seq.reduceLeft(f));
         }
     }
 

File: src/test/java/javaslang/collection/AbstractMapTest.java
Patch:
@@ -105,12 +105,12 @@ private Map<Integer, Integer> emptyIntInt() {
     abstract protected <K, V> Map<K, V> mapOf(Entry<? extends K, ? extends V>... entries);
 
     @Override
-    boolean useIsEqualToInsteadOfIsSameAs() {
+    protected boolean useIsEqualToInsteadOfIsSameAs() {
         return true;
     }
 
     @Override
-    int getPeekNonNilPerformingAnAction() {
+    protected int getPeekNonNilPerformingAnAction() {
         return 1;
     }
 

File: src/test/java/javaslang/collection/ArrayTest.java
Patch:
@@ -150,12 +150,12 @@ protected Array<Long> rangeClosedBy(long from, long toInclusive, long step) {
     }
 
     @Override
-    int getPeekNonNilPerformingAnAction() {
+    protected int getPeekNonNilPerformingAnAction() {
         return 1;
     }
 
     @Override
-    boolean useIsEqualToInsteadOfIsSameAs() {
+    protected boolean useIsEqualToInsteadOfIsSameAs() {
         return false;
     }
 

File: src/test/java/javaslang/collection/HashSetTest.java
Patch:
@@ -145,7 +145,7 @@ protected HashSet<Short> ofAll(short[] array) {
     }
 
     @Override
-    int getPeekNonNilPerformingAnAction() {
+    protected int getPeekNonNilPerformingAnAction() {
         return 1;
     }
 
@@ -334,7 +334,7 @@ public void shouldBeEqual() {
     }
 
     @Override
-    boolean useIsEqualToInsteadOfIsSameAs() {
+    protected boolean useIsEqualToInsteadOfIsSameAs() {
         return false;
     }
 

File: src/test/java/javaslang/collection/IteratorTest.java
Patch:
@@ -129,12 +129,12 @@ protected Iterator<Short> ofAll(short[] array) {
     }
 
     @Override
-    boolean useIsEqualToInsteadOfIsSameAs() {
+    protected boolean useIsEqualToInsteadOfIsSameAs() {
         return true;
     }
 
     @Override
-    int getPeekNonNilPerformingAnAction() {
+    protected int getPeekNonNilPerformingAnAction() {
         return 3;
     }
 

File: src/test/java/javaslang/collection/ListTest.java
Patch:
@@ -154,7 +154,7 @@ protected List<Long> rangeClosedBy(long from, long toInclusive, long step) {
     }
 
     @Override
-    int getPeekNonNilPerformingAnAction() {
+    protected int getPeekNonNilPerformingAnAction() {
         return 1;
     }
 
@@ -212,7 +212,7 @@ public void shouldNotDeserializeListWithSizeLessThanOne() throws Throwable {
     }
 
     @Override
-    boolean useIsEqualToInsteadOfIsSameAs() {
+    protected boolean useIsEqualToInsteadOfIsSameAs() {
         return false;
     }
 

File: src/test/java/javaslang/collection/QueueTest.java
Patch:
@@ -196,12 +196,12 @@ public void shouldFindLastIndexOfElementWithEndEnc() {
     // -- other
 
     @Override
-    int getPeekNonNilPerformingAnAction() {
+    protected int getPeekNonNilPerformingAnAction() {
         return 1;
     }
 
     @Override
-    boolean useIsEqualToInsteadOfIsSameAs() {
+    protected boolean useIsEqualToInsteadOfIsSameAs() {
         return false;
     }
 

File: src/test/java/javaslang/collection/StackTest.java
Patch:
@@ -152,12 +152,12 @@ protected Stack<Long> rangeClosedBy(long from, long toInclusive, long step) {
     // -- other
 
     @Override
-    int getPeekNonNilPerformingAnAction() {
+    protected int getPeekNonNilPerformingAnAction() {
         return 1;
     }
 
     @Override
-    boolean useIsEqualToInsteadOfIsSameAs() {
+    protected boolean useIsEqualToInsteadOfIsSameAs() {
         return false;
     }
 

File: src/test/java/javaslang/collection/StreamTest.java
Patch:
@@ -240,7 +240,7 @@ public void shouldFlatMapInfiniteTraversable() {
     // -- peek
 
     @Override
-    int getPeekNonNilPerformingAnAction() {
+    protected int getPeekNonNilPerformingAnAction() {
         return 3;
     }
 
@@ -359,7 +359,7 @@ public void shouldNotDeserializeStreamWithSizeLessThanOne() throws Throwable {
     }
 
     @Override
-    boolean useIsEqualToInsteadOfIsSameAs() {
+    protected boolean useIsEqualToInsteadOfIsSameAs() {
         return true;
     }
 

File: src/test/java/javaslang/collection/TreeSetTest.java
Patch:
@@ -96,12 +96,12 @@ protected TreeSet<Short> ofAll(short[] array) {
     }
 
     @Override
-    boolean useIsEqualToInsteadOfIsSameAs() {
+    protected boolean useIsEqualToInsteadOfIsSameAs() {
         return false;
     }
 
     @Override
-    int getPeekNonNilPerformingAnAction() {
+    protected int getPeekNonNilPerformingAnAction() {
         return 1;
     }
 

File: src/test/java/javaslang/collection/TreeTest.java
Patch:
@@ -164,12 +164,12 @@ protected Tree<Short> ofAll(short[] array) {
     }
 
     @Override
-    boolean useIsEqualToInsteadOfIsSameAs() {
+    protected boolean useIsEqualToInsteadOfIsSameAs() {
         return true;
     }
 
     @Override
-    int getPeekNonNilPerformingAnAction() {
+    protected int getPeekNonNilPerformingAnAction() {
         return 1;
     }
 

File: src/test/java/javaslang/collection/VectorTest.java
Patch:
@@ -96,12 +96,12 @@ protected Vector<Double> rangeBy(double from, double toExclusive, double step) {
     }
 
     @Override
-    int getPeekNonNilPerformingAnAction() {
+    protected int getPeekNonNilPerformingAnAction() {
         return 1;
     }
 
     @Override
-    boolean useIsEqualToInsteadOfIsSameAs() {
+    protected boolean useIsEqualToInsteadOfIsSameAs() {
         return false;
     }
 

File: src/main/java/javaslang/Iterable.java
Patch:
@@ -61,7 +61,7 @@ public interface Iterable<T> extends java.lang.Iterable<T> {
      * is {@code true} for all corresponding elements {@code x} of this iterable and {@code y} of {@code that},
      * otherwise {@code false}.
      */
-    default <U> boolean corresponds(java.lang.Iterable<U> that, BiPredicate<T, U> predicate) {
+    default <U> boolean corresponds(java.lang.Iterable<U> that, BiPredicate<? super T, ? super U> predicate) {
         final java.util.Iterator<T> it1 = iterator();
         final java.util.Iterator<U> it2 = that.iterator();
         while (it1.hasNext() && it2.hasNext()) {

File: src/main/java/javaslang/control/Try.java
Patch:
@@ -32,7 +32,7 @@ public interface Try<T> extends Value<T> {
      * @return {@code Success(supplier.get())} if no exception occurs, otherwise {@code Failure(throwable)} if an
      * exception occurs calling {@code supplier.get()}.
      */
-    static <T> Try<T> of(CheckedSupplier<T> supplier) {
+    static <T> Try<T> of(CheckedSupplier<? extends T> supplier) {
         try {
             return new Success<>(supplier.get());
         } catch (Throwable t) {

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -209,7 +209,7 @@ public Option<Entry<K, V>> findLast(Predicate<? super Entry<K, V>> predicate) {
     @Override
     public <U> Seq<U> flatMap(Function<? super Entry<K, V>, ? extends java.lang.Iterable<? extends U>> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
-        return iterator().flatMap(mapper).toStream();
+        return (Seq<U>) iterator().flatMap(mapper).toStream();
     }
 
     @Override
@@ -339,7 +339,7 @@ public int length() {
     @Override
     public <U> Seq<U> map(Function<? super Entry<K, V>, ? extends U> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
-        return iterator().map(mapper).toStream();
+        return (Seq<U>) iterator().map(mapper).toStream();
     }
 
     @Override

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -209,7 +209,7 @@ public Option<Entry<K, V>> findLast(Predicate<? super Entry<K, V>> predicate) {
     @Override
     public <U> Seq<U> flatMap(Function<? super Entry<K, V>, ? extends java.lang.Iterable<? extends U>> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
-        return iterator().flatMap(mapper).toStream();
+        return (Seq<U>) iterator().flatMap(mapper).toStream();
     }
 
     @Override
@@ -339,7 +339,7 @@ public int length() {
     @Override
     public <U> Seq<U> map(Function<? super Entry<K, V>, ? extends U> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
-        return iterator().map(mapper).toStream();
+        return (Seq<U>) iterator().map(mapper).toStream();
     }
 
     @Override

File: src/test/java/javaslang/collection/AbstractMapTest.java
Patch:
@@ -256,7 +256,6 @@ public void shouldFlattenTraversableOfTraversablesAndPlainElements() {
         assertThat(actual).isEqualTo(of(1, 2, 3, 4, 5).original());
     }
 
-    @SuppressWarnings("unchecked")
     @Override
     public void shouldFlattenDifferentElementTypes() {
         Map<?,?> actual = emptyMap()

File: src/test/java/javaslang/collection/AbstractValueTest.java
Patch:
@@ -17,7 +17,6 @@
 import java.util.NoSuchElementException;
 import java.util.Optional;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Supplier;
 
 public abstract class AbstractValueTest extends AbstractIterableTest {
 

File: src/test/java/javaslang/collection/CharSeqTest.java
Patch:
@@ -1674,7 +1674,6 @@ public void shouldComputeCombinationsOfEmptyList() {
         assertThat(empty().combinations()).isEqualTo(Vector.of(empty()));
     }
 
-    @SuppressWarnings("unchecked")
     @Test
     public void shouldComputeCombinationsOfNonEmptyList() {
         assertThat(CharSeq.of("123").combinations()).isEqualTo(Vector.of(empty(), CharSeq.of("1"), CharSeq.of("2"), CharSeq.of("3"), CharSeq.of("12"), CharSeq.of("13"), CharSeq.of("23"), CharSeq.of("123")));
@@ -1687,7 +1686,6 @@ public void shouldComputeKCombinationsOfEmptyList() {
         assertThat(empty().combinations(1)).isEmpty();
     }
 
-    @SuppressWarnings("unchecked")
     @Test
     public void shouldComputeKCombinationsOfNonEmptyList() {
         assertThat(CharSeq.of("123").combinations(2)).isEqualTo(Vector.of(CharSeq.of("12"), CharSeq.of("13"), CharSeq.of("23")));

File: src/test/java/javaslang/collection/IntMap.java
Patch:
@@ -5,7 +5,6 @@
  */
 package javaslang.collection;
 
-import javaslang.Tuple;
 import javaslang.Tuple2;
 import javaslang.control.Option;
 

File: src/test/java/javaslang/collection/TreeTest.java
Patch:
@@ -61,7 +61,7 @@ public IterableAssert<T> isEqualTo(Object expected) {
                     final Map<?,?> map2 = (Map<?,?>) expected;
                     Assertions.assertThat(convMap(map1)).isEqualTo(convMap(map2));
                 } else if(expected instanceof Tree) {
-                    assertThat(Stream.ofAll(actual)).isEqualTo(Stream.ofAll((Tree) expected));
+                    assertThat(Stream.ofAll(actual)).isEqualTo(Stream.ofAll((Tree<?>) expected));
                 } else {
                     Assertions.assertThat(actual).isEqualTo((Iterable<T>) expected);
                 }

File: src/test/java/javaslang/collection/euler/Euler14Test.java
Patch:
@@ -6,7 +6,6 @@
 package javaslang.collection.euler;
 
 import javaslang.Function1;
-import javaslang.Function2;
 import javaslang.collection.Stream;
 import org.junit.Test;
 

File: src/test/java/javaslang/collection/AbstractMapTest.java
Patch:
@@ -256,7 +256,6 @@ public void shouldFlattenTraversableOfTraversablesAndPlainElements() {
         assertThat(actual).isEqualTo(of(1, 2, 3, 4, 5).original());
     }
 
-    @SuppressWarnings("unchecked")
     @Override
     public void shouldFlattenDifferentElementTypes() {
         Map<?,?> actual = emptyMap()

File: src/test/java/javaslang/collection/AbstractValueTest.java
Patch:
@@ -17,7 +17,6 @@
 import java.util.NoSuchElementException;
 import java.util.Optional;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Supplier;
 
 public abstract class AbstractValueTest extends AbstractIterableTest {
 

File: src/test/java/javaslang/collection/CharSeqTest.java
Patch:
@@ -1674,7 +1674,6 @@ public void shouldComputeCombinationsOfEmptyList() {
         assertThat(empty().combinations()).isEqualTo(Vector.of(empty()));
     }
 
-    @SuppressWarnings("unchecked")
     @Test
     public void shouldComputeCombinationsOfNonEmptyList() {
         assertThat(CharSeq.of("123").combinations()).isEqualTo(Vector.of(empty(), CharSeq.of("1"), CharSeq.of("2"), CharSeq.of("3"), CharSeq.of("12"), CharSeq.of("13"), CharSeq.of("23"), CharSeq.of("123")));
@@ -1687,7 +1686,6 @@ public void shouldComputeKCombinationsOfEmptyList() {
         assertThat(empty().combinations(1)).isEmpty();
     }
 
-    @SuppressWarnings("unchecked")
     @Test
     public void shouldComputeKCombinationsOfNonEmptyList() {
         assertThat(CharSeq.of("123").combinations(2)).isEqualTo(Vector.of(CharSeq.of("12"), CharSeq.of("13"), CharSeq.of("23")));

File: src/test/java/javaslang/collection/IntMap.java
Patch:
@@ -5,7 +5,6 @@
  */
 package javaslang.collection;
 
-import javaslang.Tuple;
 import javaslang.Tuple2;
 import javaslang.control.Option;
 

File: src/test/java/javaslang/collection/TreeTest.java
Patch:
@@ -61,7 +61,7 @@ public IterableAssert<T> isEqualTo(Object expected) {
                     final Map<?,?> map2 = (Map<?,?>) expected;
                     Assertions.assertThat(convMap(map1)).isEqualTo(convMap(map2));
                 } else if(expected instanceof Tree) {
-                    assertThat(Stream.ofAll(actual)).isEqualTo(Stream.ofAll((Tree) expected));
+                    assertThat(Stream.ofAll(actual)).isEqualTo(Stream.ofAll((Tree<?>) expected));
                 } else {
                     Assertions.assertThat(actual).isEqualTo((Iterable<T>) expected);
                 }

File: src/test/java/javaslang/collection/euler/Euler14Test.java
Patch:
@@ -6,7 +6,6 @@
 package javaslang.collection.euler;
 
 import javaslang.Function1;
-import javaslang.Function2;
 import javaslang.collection.Stream;
 import org.junit.Test;
 

File: src/test/java/javaslang/concurrent/FutureTest.java
Patch:
@@ -39,7 +39,7 @@ public void shouldInterruptLockedFuture() {
     }
 
     // checks the invariant for cancelled state
-    void assertCancelled(Future future) {
+    void assertCancelled(Future<?> future) {
         assertThat(future.isCancelled()).isTrue();
         assertThat(future.isCompleted()).isFalse();
         assertThat(future.getValue()).isEqualTo(None.instance());

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -237,7 +237,9 @@ public <U, W> HashMap<U, W> flatMap(
     @Override
     public HashMap<Object, Object> flatten() {
         return flatMap((key, value) -> {
-            if (value instanceof java.lang.Iterable) {
+            if (value instanceof Map) {
+                return ((Map<?,?>) value).flatten();
+            } else if (value instanceof java.lang.Iterable) {
                 final Iterator<?> entries = Iterator
                         .ofAll((java.lang.Iterable<?>) value)
                         .flatten()

File: src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -292,7 +292,9 @@ public <U> Seq<U> flatMap(Function<? super Entry<K, V>, ? extends Iterable<? ext
     @Override
     public TreeMap<Object, Object> flatten() {
         return flatMap((key, value) -> {
-            if (value instanceof java.lang.Iterable) {
+            if (value instanceof Map) {
+                return ((Map<?,?>) value).flatten();
+            } else if (value instanceof java.lang.Iterable) {
                 final Iterator<?> entries = Iterator
                         .ofAll((java.lang.Iterable<?>) value)
                         .flatten()

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -237,7 +237,9 @@ public <U, W> HashMap<U, W> flatMap(
     @Override
     public HashMap<Object, Object> flatten() {
         return flatMap((key, value) -> {
-            if (value instanceof java.lang.Iterable) {
+            if (value instanceof Map) {
+                return ((Map<?,?>) value).flatten();
+            } else if (value instanceof java.lang.Iterable) {
                 final Iterator<?> entries = Iterator
                         .ofAll((java.lang.Iterable<?>) value)
                         .flatten()

File: src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -292,7 +292,9 @@ public <U> Seq<U> flatMap(Function<? super Entry<K, V>, ? extends Iterable<? ext
     @Override
     public TreeMap<Object, Object> flatten() {
         return flatMap((key, value) -> {
-            if (value instanceof java.lang.Iterable) {
+            if (value instanceof Map) {
+                return ((Map<?,?>) value).flatten();
+            } else if (value instanceof java.lang.Iterable) {
                 final Iterator<?> entries = Iterator
                         .ofAll((java.lang.Iterable<?>) value)
                         .flatten()

File: src/main/java/javaslang/collection/Tree.java
Patch:
@@ -436,7 +436,7 @@ default Tree<T> peek(Consumer<? super T> action) {
     default T reduceRight(BiFunction<? super T, ? super T, ? extends T> op) {
         Objects.requireNonNull(op, "op is null");
         if (isEmpty()) {
-            throw new UnsupportedOperationException("reduceRight of empty Tree");
+            throw new NoSuchElementException("reduceRight of empty Tree");
         } else {
             return iterator().reduceRight(op);
         }

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -981,6 +981,7 @@ default List<T> removeAll(T removed) {
     @Override
     default List<T> removeAll(java.lang.Iterable<? extends T> elements) {
         Objects.requireNonNull(elements, "elements is null");
+        // TODO(Eclipse bug): remove cast + SuppressWarnings
         List<T> removed = (List<T>) (Object) List.ofAll(elements).distinct();
         List<T> result = Nil.instance();
         boolean found = false;
@@ -1028,6 +1029,7 @@ default List<T> replaceAll(T currentElement, T newElement) {
     @Override
     default List<T> retainAll(java.lang.Iterable<? extends T> elements) {
         Objects.requireNonNull(elements, "elements is null");
+        // TODO(Eclipse bug): remove cast + SuppressWarnings
         final List<T> kept = (List<T>) (Object) List.ofAll(elements).distinct();
         List<T> result = Nil.instance();
         for (T element : this) {

File: src/main/java/javaslang/collection/Vector.java
Patch:
@@ -954,6 +954,7 @@ public Vector<T> replaceAll(T currentElement, T newElement) {
     @Override
     public Vector<T> retainAll(java.lang.Iterable<? extends T> elements) {
         Objects.requireNonNull(elements, "elements is null");
+        // TODO(Eclipse bug): remove cast + SuppressWarnings
         final Vector<T> kept = (Vector<T>) (Object) Vector.ofAll(elements).distinct();
         HashArrayMappedTrie<Integer, T> result = HashArrayMappedTrie.empty();
         for (T element : this) {

File: src-gen/main/java/javaslang/CheckedFunction0.java
Patch:
@@ -134,12 +134,10 @@ default Type<R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(CheckedFunction0<R> ) {
             super();
         }

File: src-gen/main/java/javaslang/CheckedFunction1.java
Patch:
@@ -203,12 +203,10 @@ default Type<T1, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(CheckedFunction1<T1, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/CheckedFunction2.java
Patch:
@@ -195,12 +195,10 @@ default Type<T1, T2, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(CheckedFunction2<T1, T2, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/CheckedFunction3.java
Patch:
@@ -216,12 +216,10 @@ default Type<T1, T2, T3, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(CheckedFunction3<T1, T2, T3, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/CheckedFunction4.java
Patch:
@@ -238,12 +238,10 @@ default Type<T1, T2, T3, T4, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(CheckedFunction4<T1, T2, T3, T4, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/CheckedFunction5.java
Patch:
@@ -261,12 +261,10 @@ default Type<T1, T2, T3, T4, T5, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, T5, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(CheckedFunction5<T1, T2, T3, T4, T5, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/CheckedFunction6.java
Patch:
@@ -285,12 +285,10 @@ default Type<T1, T2, T3, T4, T5, T6, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, T5, T6, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(CheckedFunction6<T1, T2, T3, T4, T5, T6, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/CheckedFunction7.java
Patch:
@@ -310,12 +310,10 @@ default Type<T1, T2, T3, T4, T5, T6, T7, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, T5, T6, T7, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(CheckedFunction7<T1, T2, T3, T4, T5, T6, T7, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/CheckedFunction8.java
Patch:
@@ -336,12 +336,10 @@ default Type<T1, T2, T3, T4, T5, T6, T7, T8, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, T5, T6, T7, T8, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(CheckedFunction8<T1, T2, T3, T4, T5, T6, T7, T8, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Function0.java
Patch:
@@ -144,12 +144,10 @@ default Type<R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(Function0<R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Function1.java
Patch:
@@ -203,12 +203,10 @@ default Type<T1, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(Function1<T1, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Function2.java
Patch:
@@ -195,12 +195,10 @@ default Type<T1, T2, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(Function2<T1, T2, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Function3.java
Patch:
@@ -215,12 +215,10 @@ default Type<T1, T2, T3, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(Function3<T1, T2, T3, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Function4.java
Patch:
@@ -237,12 +237,10 @@ default Type<T1, T2, T3, T4, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(Function4<T1, T2, T3, T4, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Function5.java
Patch:
@@ -260,12 +260,10 @@ default Type<T1, T2, T3, T4, T5, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, T5, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(Function5<T1, T2, T3, T4, T5, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Function6.java
Patch:
@@ -284,12 +284,10 @@ default Type<T1, T2, T3, T4, T5, T6, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, T5, T6, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(Function6<T1, T2, T3, T4, T5, T6, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Function7.java
Patch:
@@ -309,12 +309,10 @@ default Type<T1, T2, T3, T4, T5, T6, T7, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, T5, T6, T7, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(Function7<T1, T2, T3, T4, T5, T6, T7, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Function8.java
Patch:
@@ -335,12 +335,10 @@ default Type<T1, T2, T3, T4, T5, T6, T7, T8, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, T5, T6, T7, T8, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(Function8<T1, T2, T3, T4, T5, T6, T7, T8, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Tuple1.java
Patch:
@@ -86,7 +86,6 @@ public <U1> Tuple1<U1> map(Function1<? super T1, ? extends U1> f) {
      * @param <U> New type
      * @return An object of type U
      */
-    @SuppressWarnings("unchecked")
     public <U> U transform(Function<? super Tuple1<T1>, U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(this);

File: src-gen/main/java/javaslang/Tuple2.java
Patch:
@@ -108,7 +108,6 @@ public <U1, U2> Tuple2<U1, U2> map(Function1<? super T1, ? extends U1> f1, Funct
      * @param <U> New type
      * @return An object of type U
      */
-    @SuppressWarnings("unchecked")
     public <U> U transform(Function<? super Tuple2<T1, T2>, U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(this);

File: src-gen/main/java/javaslang/Tuple3.java
Patch:
@@ -126,7 +126,6 @@ public <U1, U2, U3> Tuple3<U1, U2, U3> map(Function1<? super T1, ? extends U1> f
      * @param <U> New type
      * @return An object of type U
      */
-    @SuppressWarnings("unchecked")
     public <U> U transform(Function<? super Tuple3<T1, T2, T3>, U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(this);

File: src-gen/main/java/javaslang/Tuple4.java
Patch:
@@ -144,7 +144,6 @@ public <U1, U2, U3, U4> Tuple4<U1, U2, U3, U4> map(Function1<? super T1, ? exten
      * @param <U> New type
      * @return An object of type U
      */
-    @SuppressWarnings("unchecked")
     public <U> U transform(Function<? super Tuple4<T1, T2, T3, T4>, U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(this);

File: src-gen/main/java/javaslang/Tuple5.java
Patch:
@@ -162,7 +162,6 @@ public <U1, U2, U3, U4, U5> Tuple5<U1, U2, U3, U4, U5> map(Function1<? super T1,
      * @param <U> New type
      * @return An object of type U
      */
-    @SuppressWarnings("unchecked")
     public <U> U transform(Function<? super Tuple5<T1, T2, T3, T4, T5>, U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(this);

File: src-gen/main/java/javaslang/Tuple6.java
Patch:
@@ -180,7 +180,6 @@ public <U1, U2, U3, U4, U5, U6> Tuple6<U1, U2, U3, U4, U5, U6> map(Function1<? s
      * @param <U> New type
      * @return An object of type U
      */
-    @SuppressWarnings("unchecked")
     public <U> U transform(Function<? super Tuple6<T1, T2, T3, T4, T5, T6>, U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(this);

File: src-gen/main/java/javaslang/Tuple7.java
Patch:
@@ -198,7 +198,6 @@ public <U1, U2, U3, U4, U5, U6, U7> Tuple7<U1, U2, U3, U4, U5, U6, U7> map(Funct
      * @param <U> New type
      * @return An object of type U
      */
-    @SuppressWarnings("unchecked")
     public <U> U transform(Function<? super Tuple7<T1, T2, T3, T4, T5, T6, T7>, U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(this);

File: src-gen/main/java/javaslang/Tuple8.java
Patch:
@@ -216,7 +216,6 @@ public <U1, U2, U3, U4, U5, U6, U7, U8> Tuple8<U1, U2, U3, U4, U5, U6, U7, U8> m
      * @param <U> New type
      * @return An object of type U
      */
-    @SuppressWarnings("unchecked")
     public <U> U transform(Function<? super Tuple8<T1, T2, T3, T4, T5, T6, T7, T8>, U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(this);

File: src-gen/test/java/javaslang/CheckedFunction0Test.java
Patch:
@@ -81,7 +81,6 @@ public void shouldRecognizeMemoizedFunctions() {
     }
 
     private static CheckedFunction0<Integer> recurrent1 = () -> 11;
-    private static CheckedFunction0<Integer> recurrent2 = CheckedFunction0Test.recurrent1.memoized();
 
     @Test
     public void shouldCalculatedRecursively() throws Throwable {

File: src-gen/test/java/javaslang/Function0Test.java
Patch:
@@ -81,7 +81,6 @@ public void shouldRecognizeMemoizedFunctions() {
     }
 
     private static Function0<Integer> recurrent1 = () -> 11;
-    private static Function0<Integer> recurrent2 = Function0Test.recurrent1.memoized();
 
     @Test
     public void shouldCalculatedRecursively() {

File: src/main/java/javaslang/Lazy.java
Patch:
@@ -206,7 +206,7 @@ public Lazy<T> peek(Consumer<? super T> action) {
 
     @Override
     public boolean equals(Object o) {
-        return (o == this) || (o instanceof Lazy && Objects.equals(((Lazy) o).get(), get()));
+        return (o == this) || (o instanceof Lazy && Objects.equals(((Lazy<?>) o).get(), get()));
     }
 
     @Override

File: src/main/java/javaslang/Value.java
Patch:
@@ -117,7 +117,6 @@ public interface Value<T> extends javaslang.Iterable<T> {
      * @return An object of type T
      * @throws java.util.NoSuchElementException if the given iterable is empty
      */
-    @SuppressWarnings("unchecked")
     static <T> T get(java.lang.Iterable<? extends T> iterable) {
         Objects.requireNonNull(iterable, "iterable is null");
         if (iterable instanceof Value) {
@@ -461,7 +460,6 @@ default Vector<T> toVector() {
         return isEmpty() ? Vector.empty() : Vector.ofAll(this);
     }
 
-
     // -- Java types
 
     /**

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -597,7 +597,7 @@ private boolean checkPrefix(Traversable<T> t, Traversable<T> prefix) {
      * Sorts this elements by comparing the elements in a different domain, using the given {@code mapper}.
      *
      * @param mapper A mapper
-     * @param <U> The domain where elements are compared
+     * @param <U>    The domain where elements are compared
      * @return a sorted version of this
      */
     <U extends Comparable<? super U>> Seq<T> sortBy(Function<? super T, ? extends U> mapper);
@@ -606,8 +606,8 @@ private boolean checkPrefix(Traversable<T> t, Traversable<T> prefix) {
      * Sorts this elements by comparing the elements in a different domain, using the given {@code mapper}.
      *
      * @param comparator A comparator
-     * @param mapper A mapper
-     * @param <U> The domain where elements are compared
+     * @param mapper     A mapper
+     * @param <U>        The domain where elements are compared
      * @return a sorted version of this
      */
     <U> Seq<T> sortBy(Comparator<? super U> comparator, Function<? super T, ? extends U> mapper);

File: src/main/java/javaslang/collection/Stack.java
Patch:
@@ -87,7 +87,7 @@ static <T> Stack<T> of(T element) {
      * @return A stack containing the given elements in the same order.
      * @throws NullPointerException if {@code elements} is null
      */
-    @SuppressWarnings({ "unchecked", "varargs" })
+    @SuppressWarnings("varargs")
     @SafeVarargs
     static <T> Stack<T> of(T... elements) {
         Objects.requireNonNull(elements, "elements is null");
@@ -662,7 +662,8 @@ static Stack<Long> rangeClosedBy(long from, long toInclusive, long step) {
     <U> Stack<U> unit(java.lang.Iterable<? extends U> iterable);
 
     @Override
-    <T1, T2> Tuple2<? extends Stack<T1>, ? extends Stack<T2>> unzip(Function<? super T, Tuple2<? extends T1, ? extends T2>> unzipper);
+    <T1, T2> Tuple2<? extends Stack<T1>, ? extends Stack<T2>> unzip(
+            Function<? super T, Tuple2<? extends T1, ? extends T2>> unzipper);
 
     @Override
     Stack<T> update(int index, T element);

File: src/main/java/javaslang/control/Try.java
Patch:
@@ -75,7 +75,6 @@ static Try<Void> run(CheckedRunnable runnable) {
      * @param consumer A checked consumer taking a single argument.
      * @return a new {@code Try}
      */
-    @SuppressWarnings("unchecked")
     default Try<T> andThen(CheckedConsumer<? super T> consumer) {
         if (isFailure()) {
             return this;
@@ -141,6 +140,7 @@ default Try<Throwable> failed() {
      * @param predicate A predicate
      * @return a new Try
      */
+    @Override
     default Try<T> filter(Predicate<? super T> predicate) {
         if (isFailure()) {
             return this;

File: src/test/java/benchmark/collection/MapSetBench.java
Patch:
@@ -30,7 +30,9 @@ public class MapSetBench {
         return treeSet;
     });
 
-    private static final Function<Integer, TreeSet<Integer>> treeCache = Function1.lift((Integer i) -> treeGen.get()).memoized();
+    private static final Function<Integer, TreeSet<Integer>> treeCache = Function1
+            .lift((Integer i) -> treeGen.get())
+            .memoized();
 
     private static final Iterator<TreeSet<Integer>> trees = new Iterator<TreeSet<Integer>>() {
 

File: src/test/java/javaslang/AbstractIterableTest.java
Patch:
@@ -7,15 +7,15 @@
 
 import org.junit.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.StrictAssertions.assertThat;
 
 public abstract class AbstractIterableTest {
 
     abstract protected <T> Iterable<T> empty();
 
     abstract protected <T> Iterable<T> of(T element);
 
-    @SuppressWarnings({ "unchecked", "varargs" })
+    @SuppressWarnings("unchecked")
     abstract protected <T> Iterable<T> of(T... elements);
 
     // -- corresponds

File: src/test/java/javaslang/collection/AbstractTraversableTest.java
Patch:
@@ -20,7 +20,7 @@ public abstract class AbstractTraversableTest extends AbstractTraversableOnceTes
     @Override
     abstract protected <T> Traversable<T> of(T element);
 
-    @SuppressWarnings({ "unchecked", "varargs" })
+    @SuppressWarnings("unchecked")
     @Override
     abstract protected <T> Traversable<T> of(T... elements);
 

File: src/test/java/javaslang/collection/ArrayTest.java
Patch:
@@ -27,7 +27,7 @@ protected <T> Array<T> of(T element) {
         return Array.of(element);
     }
 
-    @SuppressWarnings({ "unchecked", "varargs" })
+    @SuppressWarnings("varargs")
     @SafeVarargs
     @Override
     protected final <T> Array<T> of(T... elements) {

File: src/test/java/javaslang/collection/HashMapTest.java
Patch:
@@ -25,7 +25,7 @@ protected <T1, T2> Map<T1, T2> emptyMap() {
         return HashMap.<Integer, T> collector();
     }
 
-    @SuppressWarnings({ "unchecked", "varargs" })
+    @SuppressWarnings("varargs")
     @SafeVarargs
     @Override
     protected final <K, V> Map<K, V> mapOf(Map.Entry<? extends K, ? extends V>... entries) {

File: src/test/java/javaslang/collection/QueueTest.java
Patch:
@@ -29,7 +29,7 @@ protected <T> Queue<T> of(T element) {
         return Queue.of(element);
     }
 
-    @SuppressWarnings({ "unchecked", "varargs" })
+    @SuppressWarnings("varargs")
     @SafeVarargs
     @Override
     protected final <T> Queue<T> of(T... elements) {

File: src/test/java/javaslang/collection/StackTest.java
Patch:
@@ -27,7 +27,7 @@ protected <T> Stack<T> of(T element) {
         return Stack.of(element);
     }
 
-    @SuppressWarnings({ "unchecked", "varargs" })
+    @SuppressWarnings("varargs")
     @SafeVarargs
     @Override
     protected final <T> Stack<T> of(T... elements) {

File: src/test/java/javaslang/collection/TreeMapTest.java
Patch:
@@ -29,7 +29,7 @@ protected <T1, T2> Map<T1, T2> emptyMap() {
         return TreeMap.<Integer, T> collector();
     }
 
-    @SuppressWarnings({ "unchecked", "varargs" })
+    @SuppressWarnings("varargs")
     @SafeVarargs
     @Override
     protected final <K, V> Map<K, V> mapOf(Entry<? extends K, ? extends V>... entries) {

File: src/test/java/javaslang/collection/TreeSetTest.java
Patch:
@@ -27,7 +27,7 @@ protected <T> TreeSet<T> of(T element) {
         return TreeSet.of(toStringComparator(), element);
     }
 
-    @SuppressWarnings({ "unchecked", "varargs" })
+    @SuppressWarnings("varargs")
     @SafeVarargs
     @Override
     protected final <T> TreeSet<T> of(T... elements) {
@@ -107,7 +107,6 @@ int getPeekNonNilPerformingAnAction() {
 
     // -- helpers
 
-    @SuppressWarnings("unchecked")
     private static Comparator<Object> toStringComparator() {
         return (Comparator<Object> & Serializable) (o1, o2) -> String.valueOf(o1).compareTo(String.valueOf(o2));
     }

File: src/test/java/javaslang/test/GenTest.java
Patch:
@@ -29,10 +29,10 @@ public class GenTest {
 
     @Test
     public void shouldUseCustomRandomNumberGenerator() {
-        @SuppressWarnings("SerializableInnerClassWithNonSerializableOuterClass")
         final Random rng = new Random() {
             private static final long serialVersionUID = 1L;
 
+            @Override
             public int nextInt(int bound) {
                 return 0;
             }

File: src-gen/main/java/javaslang/CheckedFunction0.java
Patch:
@@ -134,12 +134,10 @@ default Type<R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(CheckedFunction0<R> ) {
             super();
         }

File: src-gen/main/java/javaslang/CheckedFunction1.java
Patch:
@@ -203,12 +203,10 @@ default Type<T1, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(CheckedFunction1<T1, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/CheckedFunction2.java
Patch:
@@ -195,12 +195,10 @@ default Type<T1, T2, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(CheckedFunction2<T1, T2, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/CheckedFunction3.java
Patch:
@@ -216,12 +216,10 @@ default Type<T1, T2, T3, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(CheckedFunction3<T1, T2, T3, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/CheckedFunction4.java
Patch:
@@ -238,12 +238,10 @@ default Type<T1, T2, T3, T4, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(CheckedFunction4<T1, T2, T3, T4, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/CheckedFunction5.java
Patch:
@@ -261,12 +261,10 @@ default Type<T1, T2, T3, T4, T5, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, T5, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(CheckedFunction5<T1, T2, T3, T4, T5, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/CheckedFunction6.java
Patch:
@@ -285,12 +285,10 @@ default Type<T1, T2, T3, T4, T5, T6, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, T5, T6, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(CheckedFunction6<T1, T2, T3, T4, T5, T6, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/CheckedFunction7.java
Patch:
@@ -310,12 +310,10 @@ default Type<T1, T2, T3, T4, T5, T6, T7, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, T5, T6, T7, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(CheckedFunction7<T1, T2, T3, T4, T5, T6, T7, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/CheckedFunction8.java
Patch:
@@ -336,12 +336,10 @@ default Type<T1, T2, T3, T4, T5, T6, T7, T8, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, T5, T6, T7, T8, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(CheckedFunction8<T1, T2, T3, T4, T5, T6, T7, T8, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Function0.java
Patch:
@@ -144,12 +144,10 @@ default Type<R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(Function0<R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Function1.java
Patch:
@@ -203,12 +203,10 @@ default Type<T1, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(Function1<T1, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Function2.java
Patch:
@@ -195,12 +195,10 @@ default Type<T1, T2, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(Function2<T1, T2, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Function3.java
Patch:
@@ -215,12 +215,10 @@ default Type<T1, T2, T3, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(Function3<T1, T2, T3, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Function4.java
Patch:
@@ -237,12 +237,10 @@ default Type<T1, T2, T3, T4, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(Function4<T1, T2, T3, T4, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Function5.java
Patch:
@@ -260,12 +260,10 @@ default Type<T1, T2, T3, T4, T5, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, T5, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(Function5<T1, T2, T3, T4, T5, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Function6.java
Patch:
@@ -284,12 +284,10 @@ default Type<T1, T2, T3, T4, T5, T6, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, T5, T6, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(Function6<T1, T2, T3, T4, T5, T6, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Function7.java
Patch:
@@ -309,12 +309,10 @@ default Type<T1, T2, T3, T4, T5, T6, T7, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, T5, T6, T7, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(Function7<T1, T2, T3, T4, T5, T6, T7, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Function8.java
Patch:
@@ -335,12 +335,10 @@ default Type<T1, T2, T3, T4, T5, T6, T7, T8, R> getType() {
      * @author Daniel Dietrich
      * @since 2.0.0
      */
-    @SuppressWarnings("deprecation")
     final class Type<T1, T2, T3, T4, T5, T6, T7, T8, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 
-        @SuppressWarnings("deprecation")
         private Type(Function8<T1, T2, T3, T4, T5, T6, T7, T8, R> ) {
             super();
         }

File: src-gen/main/java/javaslang/Tuple1.java
Patch:
@@ -86,7 +86,6 @@ public <U1> Tuple1<U1> map(Function1<? super T1, ? extends U1> f) {
      * @param <U> New type
      * @return An object of type U
      */
-    @SuppressWarnings("unchecked")
     public <U> U transform(Function<? super Tuple1<T1>, U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(this);

File: src-gen/main/java/javaslang/Tuple2.java
Patch:
@@ -108,7 +108,6 @@ public <U1, U2> Tuple2<U1, U2> map(Function1<? super T1, ? extends U1> f1, Funct
      * @param <U> New type
      * @return An object of type U
      */
-    @SuppressWarnings("unchecked")
     public <U> U transform(Function<? super Tuple2<T1, T2>, U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(this);

File: src-gen/main/java/javaslang/Tuple3.java
Patch:
@@ -126,7 +126,6 @@ public <U1, U2, U3> Tuple3<U1, U2, U3> map(Function1<? super T1, ? extends U1> f
      * @param <U> New type
      * @return An object of type U
      */
-    @SuppressWarnings("unchecked")
     public <U> U transform(Function<? super Tuple3<T1, T2, T3>, U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(this);

File: src-gen/main/java/javaslang/Tuple4.java
Patch:
@@ -144,7 +144,6 @@ public <U1, U2, U3, U4> Tuple4<U1, U2, U3, U4> map(Function1<? super T1, ? exten
      * @param <U> New type
      * @return An object of type U
      */
-    @SuppressWarnings("unchecked")
     public <U> U transform(Function<? super Tuple4<T1, T2, T3, T4>, U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(this);

File: src-gen/main/java/javaslang/Tuple5.java
Patch:
@@ -162,7 +162,6 @@ public <U1, U2, U3, U4, U5> Tuple5<U1, U2, U3, U4, U5> map(Function1<? super T1,
      * @param <U> New type
      * @return An object of type U
      */
-    @SuppressWarnings("unchecked")
     public <U> U transform(Function<? super Tuple5<T1, T2, T3, T4, T5>, U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(this);

File: src-gen/main/java/javaslang/Tuple6.java
Patch:
@@ -180,7 +180,6 @@ public <U1, U2, U3, U4, U5, U6> Tuple6<U1, U2, U3, U4, U5, U6> map(Function1<? s
      * @param <U> New type
      * @return An object of type U
      */
-    @SuppressWarnings("unchecked")
     public <U> U transform(Function<? super Tuple6<T1, T2, T3, T4, T5, T6>, U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(this);

File: src-gen/main/java/javaslang/Tuple7.java
Patch:
@@ -198,7 +198,6 @@ public <U1, U2, U3, U4, U5, U6, U7> Tuple7<U1, U2, U3, U4, U5, U6, U7> map(Funct
      * @param <U> New type
      * @return An object of type U
      */
-    @SuppressWarnings("unchecked")
     public <U> U transform(Function<? super Tuple7<T1, T2, T3, T4, T5, T6, T7>, U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(this);

File: src-gen/main/java/javaslang/Tuple8.java
Patch:
@@ -216,7 +216,6 @@ public <U1, U2, U3, U4, U5, U6, U7, U8> Tuple8<U1, U2, U3, U4, U5, U6, U7, U8> m
      * @param <U> New type
      * @return An object of type U
      */
-    @SuppressWarnings("unchecked")
     public <U> U transform(Function<? super Tuple8<T1, T2, T3, T4, T5, T6, T7, T8>, U> f) {
         Objects.requireNonNull(f, "f is null");
         return f.apply(this);

File: src-gen/test/java/javaslang/CheckedFunction0Test.java
Patch:
@@ -81,7 +81,6 @@ public void shouldRecognizeMemoizedFunctions() {
     }
 
     private static CheckedFunction0<Integer> recurrent1 = () -> 11;
-    private static CheckedFunction0<Integer> recurrent2 = CheckedFunction0Test.recurrent1.memoized();
 
     @Test
     public void shouldCalculatedRecursively() throws Throwable {

File: src-gen/test/java/javaslang/Function0Test.java
Patch:
@@ -81,7 +81,6 @@ public void shouldRecognizeMemoizedFunctions() {
     }
 
     private static Function0<Integer> recurrent1 = () -> 11;
-    private static Function0<Integer> recurrent2 = Function0Test.recurrent1.memoized();
 
     @Test
     public void shouldCalculatedRecursively() {

File: src/main/java/javaslang/collection/package-info.java
Patch:
@@ -18,7 +18,7 @@
  * <tbody>
  * <tr><td>{@linkplain javaslang.collection.Array}</td><td><small>const</small></td><td><small>linear</small></td><td><small>const</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
  * <tr><td>{@linkplain javaslang.collection.CharSeq}</td><td><small>const</small></td><td><small>linear</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
- * <tr><td><em>{@linkplain javaslang.collection.Iterator}</em></td><td><small>const</small></td><td><small>const</small></td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td></tr>
+ * <tr><td><em>{@linkplain javaslang.collection.Iterator}</em></td><td><small>const</small></td><td><small>const</small></td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td></tr>
  * <tr><td>{@linkplain javaslang.collection.List}</td><td><small>const</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>const</small></td><td><small>linear</small></td></tr>
  * <tr><td>{@linkplain javaslang.collection.Queue}</td><td><small>const</small></td><td><small>const<sup>a</sup></small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>const</small></td><td><small>const</small></td></tr>
  * <tr><td>{@linkplain javaslang.collection.Stream}</td><td><small>const</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>const<sup>lazy</sup></small></td><td><small>const<sup>lazy</sup></small></td></tr>

File: src/main/java/javaslang/collection/package-info.java
Patch:
@@ -18,7 +18,7 @@
  * <tbody>
  * <tr><td>{@linkplain javaslang.collection.Array}</td><td><small>const</small></td><td><small>linear</small></td><td><small>const</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
  * <tr><td>{@linkplain javaslang.collection.CharSeq}</td><td><small>const</small></td><td><small>linear</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
- * <tr><td><em>{@linkplain javaslang.collection.Iterator}</em></td><td><small>const</small></td><td><small>const</small></td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td></tr>
+ * <tr><td><em>{@linkplain javaslang.collection.Iterator}</em></td><td><small>const</small></td><td><small>const</small></td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td></tr>
  * <tr><td>{@linkplain javaslang.collection.List}</td><td><small>const</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>const</small></td><td><small>linear</small></td></tr>
  * <tr><td>{@linkplain javaslang.collection.Queue}</td><td><small>const</small></td><td><small>const<sup>a</sup></small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>const</small></td><td><small>const</small></td></tr>
  * <tr><td>{@linkplain javaslang.collection.Stream}</td><td><small>const</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>const<sup>lazy</sup></small></td><td><small>const<sup>lazy</sup></small></td></tr>

File: src/test/java/javaslang/LazyTest.java
Patch:
@@ -6,6 +6,7 @@
 package javaslang;
 
 import javaslang.collection.List;
+import javaslang.control.Some;
 import org.junit.Test;
 
 import java.util.NoSuchElementException;
@@ -106,7 +107,7 @@ public void shouldThrowFilterEmptyLazy() {
 
     @Test
     public void shouldFilterNonEmptyLazy() {
-        assertThat(Lazy.of(() -> 1).filter(i -> true)).isEqualTo(Lazy.of(() -> 1));
+        assertThat(Lazy.of(() -> 1).filter(i -> true)).isEqualTo(new Some<>(1));
     }
 
     @Test(expected = NoSuchElementException.class)
@@ -116,7 +117,7 @@ public void shouldThrowEmptyFilterNonEmptyLazy() {
 
     @Test
     public void shouldNonEmptyFilterNonEmptyLazy() {
-        assertThat(Lazy.of(() -> 1).filter(i -> true)).isEqualTo(Lazy.of(() -> 1));
+        assertThat(Lazy.of(() -> 1).filter(i -> true)).isEqualTo(new Some<>(1));
     }
 
     // -- flatten()

File: src-gen/test/java/javaslang/CheckedFunction0Test.java
Patch:
@@ -117,7 +117,9 @@ public void testTypesEquals() {
         final CheckedFunction0<Integer> f2 = () -> null;
         final CheckedFunction0<String> f3 = () -> null;
 
-        assertThat(f1.getType()).isEqualTo(f1.getType());
+        final CheckedFunction0.Type<Integer> t1 = f1.getType();
+        assertThat(t1).isEqualTo(t1);
+        assertThat(t1).isNotEqualTo(11);
         assertThat(f1.getType()).isEqualTo(f2.getType());
         assertThat(f1.getType()).isNotEqualTo(f3.getType());
 

File: src-gen/test/java/javaslang/CheckedFunction1Test.java
Patch:
@@ -153,7 +153,9 @@ public void testTypesEquals() {
         final CheckedFunction1<Integer, Integer> f2 = (i1) -> null;
         final CheckedFunction1<Integer, String> f3 = (i1) -> null;
         final CheckedFunction1<String, Integer> f4 = (i1) -> null;
-        assertThat(f1.getType()).isEqualTo(f1.getType());
+        final CheckedFunction1.Type<Integer, Integer> t1 = f1.getType();
+        assertThat(t1).isEqualTo(t1);
+        assertThat(t1).isNotEqualTo(11);
         assertThat(f1.getType()).isEqualTo(f2.getType());
         assertThat(f1.getType()).isNotEqualTo(f3.getType());
         assertThat(f1.getType()).isNotEqualTo(f4.getType());

File: src-gen/test/java/javaslang/CheckedFunction2Test.java
Patch:
@@ -152,7 +152,9 @@ public void testTypesEquals() {
         final CheckedFunction2<Integer, Integer, Integer> f2 = (i1, i2) -> null;
         final CheckedFunction2<Integer, Integer, String> f3 = (i1, i2) -> null;
         final CheckedFunction2<String, Integer, Integer> f4 = (i1, i2) -> null;
-        assertThat(f1.getType()).isEqualTo(f1.getType());
+        final CheckedFunction2.Type<Integer, Integer, Integer> t1 = f1.getType();
+        assertThat(t1).isEqualTo(t1);
+        assertThat(t1).isNotEqualTo(11);
         assertThat(f1.getType()).isEqualTo(f2.getType());
         assertThat(f1.getType()).isNotEqualTo(f3.getType());
         assertThat(f1.getType()).isNotEqualTo(f4.getType());

File: src-gen/test/java/javaslang/CheckedFunction3Test.java
Patch:
@@ -159,7 +159,9 @@ public void testTypesEquals() {
         final CheckedFunction3<Integer, Integer, Integer, Integer> f2 = (i1, i2, i3) -> null;
         final CheckedFunction3<Integer, Integer, Integer, String> f3 = (i1, i2, i3) -> null;
         final CheckedFunction3<String, Integer, Integer, Integer> f4 = (i1, i2, i3) -> null;
-        assertThat(f1.getType()).isEqualTo(f1.getType());
+        final CheckedFunction3.Type<Integer, Integer, Integer, Integer> t1 = f1.getType();
+        assertThat(t1).isEqualTo(t1);
+        assertThat(t1).isNotEqualTo(11);
         assertThat(f1.getType()).isEqualTo(f2.getType());
         assertThat(f1.getType()).isNotEqualTo(f3.getType());
         assertThat(f1.getType()).isNotEqualTo(f4.getType());

File: src-gen/test/java/javaslang/CheckedFunction4Test.java
Patch:
@@ -166,7 +166,9 @@ public void testTypesEquals() {
         final CheckedFunction4<Integer, Integer, Integer, Integer, Integer> f2 = (i1, i2, i3, i4) -> null;
         final CheckedFunction4<Integer, Integer, Integer, Integer, String> f3 = (i1, i2, i3, i4) -> null;
         final CheckedFunction4<String, Integer, Integer, Integer, Integer> f4 = (i1, i2, i3, i4) -> null;
-        assertThat(f1.getType()).isEqualTo(f1.getType());
+        final CheckedFunction4.Type<Integer, Integer, Integer, Integer, Integer> t1 = f1.getType();
+        assertThat(t1).isEqualTo(t1);
+        assertThat(t1).isNotEqualTo(11);
         assertThat(f1.getType()).isEqualTo(f2.getType());
         assertThat(f1.getType()).isNotEqualTo(f3.getType());
         assertThat(f1.getType()).isNotEqualTo(f4.getType());

File: src-gen/test/java/javaslang/CheckedFunction5Test.java
Patch:
@@ -173,7 +173,9 @@ public void testTypesEquals() {
         final CheckedFunction5<Integer, Integer, Integer, Integer, Integer, Integer> f2 = (i1, i2, i3, i4, i5) -> null;
         final CheckedFunction5<Integer, Integer, Integer, Integer, Integer, String> f3 = (i1, i2, i3, i4, i5) -> null;
         final CheckedFunction5<String, Integer, Integer, Integer, Integer, Integer> f4 = (i1, i2, i3, i4, i5) -> null;
-        assertThat(f1.getType()).isEqualTo(f1.getType());
+        final CheckedFunction5.Type<Integer, Integer, Integer, Integer, Integer, Integer> t1 = f1.getType();
+        assertThat(t1).isEqualTo(t1);
+        assertThat(t1).isNotEqualTo(11);
         assertThat(f1.getType()).isEqualTo(f2.getType());
         assertThat(f1.getType()).isNotEqualTo(f3.getType());
         assertThat(f1.getType()).isNotEqualTo(f4.getType());

File: src-gen/test/java/javaslang/CheckedFunction6Test.java
Patch:
@@ -180,7 +180,9 @@ public void testTypesEquals() {
         final CheckedFunction6<Integer, Integer, Integer, Integer, Integer, Integer, Integer> f2 = (i1, i2, i3, i4, i5, i6) -> null;
         final CheckedFunction6<Integer, Integer, Integer, Integer, Integer, Integer, String> f3 = (i1, i2, i3, i4, i5, i6) -> null;
         final CheckedFunction6<String, Integer, Integer, Integer, Integer, Integer, Integer> f4 = (i1, i2, i3, i4, i5, i6) -> null;
-        assertThat(f1.getType()).isEqualTo(f1.getType());
+        final CheckedFunction6.Type<Integer, Integer, Integer, Integer, Integer, Integer, Integer> t1 = f1.getType();
+        assertThat(t1).isEqualTo(t1);
+        assertThat(t1).isNotEqualTo(11);
         assertThat(f1.getType()).isEqualTo(f2.getType());
         assertThat(f1.getType()).isNotEqualTo(f3.getType());
         assertThat(f1.getType()).isNotEqualTo(f4.getType());

File: src-gen/test/java/javaslang/CheckedFunction7Test.java
Patch:
@@ -187,7 +187,9 @@ public void testTypesEquals() {
         final CheckedFunction7<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer> f2 = (i1, i2, i3, i4, i5, i6, i7) -> null;
         final CheckedFunction7<Integer, Integer, Integer, Integer, Integer, Integer, Integer, String> f3 = (i1, i2, i3, i4, i5, i6, i7) -> null;
         final CheckedFunction7<String, Integer, Integer, Integer, Integer, Integer, Integer, Integer> f4 = (i1, i2, i3, i4, i5, i6, i7) -> null;
-        assertThat(f1.getType()).isEqualTo(f1.getType());
+        final CheckedFunction7.Type<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer> t1 = f1.getType();
+        assertThat(t1).isEqualTo(t1);
+        assertThat(t1).isNotEqualTo(11);
         assertThat(f1.getType()).isEqualTo(f2.getType());
         assertThat(f1.getType()).isNotEqualTo(f3.getType());
         assertThat(f1.getType()).isNotEqualTo(f4.getType());

File: src-gen/test/java/javaslang/CheckedFunction8Test.java
Patch:
@@ -194,7 +194,9 @@ public void testTypesEquals() {
         final CheckedFunction8<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer> f2 = (i1, i2, i3, i4, i5, i6, i7, i8) -> null;
         final CheckedFunction8<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, String> f3 = (i1, i2, i3, i4, i5, i6, i7, i8) -> null;
         final CheckedFunction8<String, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer> f4 = (i1, i2, i3, i4, i5, i6, i7, i8) -> null;
-        assertThat(f1.getType()).isEqualTo(f1.getType());
+        final CheckedFunction8.Type<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer> t1 = f1.getType();
+        assertThat(t1).isEqualTo(t1);
+        assertThat(t1).isNotEqualTo(11);
         assertThat(f1.getType()).isEqualTo(f2.getType());
         assertThat(f1.getType()).isNotEqualTo(f3.getType());
         assertThat(f1.getType()).isNotEqualTo(f4.getType());

File: src-gen/test/java/javaslang/Function0Test.java
Patch:
@@ -117,7 +117,9 @@ public void testTypesEquals() {
         final Function0<Integer> f2 = () -> null;
         final Function0<String> f3 = () -> null;
 
-        assertThat(f1.getType()).isEqualTo(f1.getType());
+        final Function0.Type<Integer> t1 = f1.getType();
+        assertThat(t1).isEqualTo(t1);
+        assertThat(t1).isNotEqualTo(11);
         assertThat(f1.getType()).isEqualTo(f2.getType());
         assertThat(f1.getType()).isNotEqualTo(f3.getType());
 

File: src-gen/test/java/javaslang/Function1Test.java
Patch:
@@ -153,7 +153,9 @@ public void testTypesEquals() {
         final Function1<Integer, Integer> f2 = (i1) -> null;
         final Function1<Integer, String> f3 = (i1) -> null;
         final Function1<String, Integer> f4 = (i1) -> null;
-        assertThat(f1.getType()).isEqualTo(f1.getType());
+        final Function1.Type<Integer, Integer> t1 = f1.getType();
+        assertThat(t1).isEqualTo(t1);
+        assertThat(t1).isNotEqualTo(11);
         assertThat(f1.getType()).isEqualTo(f2.getType());
         assertThat(f1.getType()).isNotEqualTo(f3.getType());
         assertThat(f1.getType()).isNotEqualTo(f4.getType());

File: src-gen/test/java/javaslang/Function2Test.java
Patch:
@@ -152,7 +152,9 @@ public void testTypesEquals() {
         final Function2<Integer, Integer, Integer> f2 = (i1, i2) -> null;
         final Function2<Integer, Integer, String> f3 = (i1, i2) -> null;
         final Function2<String, Integer, Integer> f4 = (i1, i2) -> null;
-        assertThat(f1.getType()).isEqualTo(f1.getType());
+        final Function2.Type<Integer, Integer, Integer> t1 = f1.getType();
+        assertThat(t1).isEqualTo(t1);
+        assertThat(t1).isNotEqualTo(11);
         assertThat(f1.getType()).isEqualTo(f2.getType());
         assertThat(f1.getType()).isNotEqualTo(f3.getType());
         assertThat(f1.getType()).isNotEqualTo(f4.getType());

File: src-gen/test/java/javaslang/Function3Test.java
Patch:
@@ -159,7 +159,9 @@ public void testTypesEquals() {
         final Function3<Integer, Integer, Integer, Integer> f2 = (i1, i2, i3) -> null;
         final Function3<Integer, Integer, Integer, String> f3 = (i1, i2, i3) -> null;
         final Function3<String, Integer, Integer, Integer> f4 = (i1, i2, i3) -> null;
-        assertThat(f1.getType()).isEqualTo(f1.getType());
+        final Function3.Type<Integer, Integer, Integer, Integer> t1 = f1.getType();
+        assertThat(t1).isEqualTo(t1);
+        assertThat(t1).isNotEqualTo(11);
         assertThat(f1.getType()).isEqualTo(f2.getType());
         assertThat(f1.getType()).isNotEqualTo(f3.getType());
         assertThat(f1.getType()).isNotEqualTo(f4.getType());

File: src-gen/test/java/javaslang/Function4Test.java
Patch:
@@ -166,7 +166,9 @@ public void testTypesEquals() {
         final Function4<Integer, Integer, Integer, Integer, Integer> f2 = (i1, i2, i3, i4) -> null;
         final Function4<Integer, Integer, Integer, Integer, String> f3 = (i1, i2, i3, i4) -> null;
         final Function4<String, Integer, Integer, Integer, Integer> f4 = (i1, i2, i3, i4) -> null;
-        assertThat(f1.getType()).isEqualTo(f1.getType());
+        final Function4.Type<Integer, Integer, Integer, Integer, Integer> t1 = f1.getType();
+        assertThat(t1).isEqualTo(t1);
+        assertThat(t1).isNotEqualTo(11);
         assertThat(f1.getType()).isEqualTo(f2.getType());
         assertThat(f1.getType()).isNotEqualTo(f3.getType());
         assertThat(f1.getType()).isNotEqualTo(f4.getType());

File: src-gen/test/java/javaslang/Function5Test.java
Patch:
@@ -173,7 +173,9 @@ public void testTypesEquals() {
         final Function5<Integer, Integer, Integer, Integer, Integer, Integer> f2 = (i1, i2, i3, i4, i5) -> null;
         final Function5<Integer, Integer, Integer, Integer, Integer, String> f3 = (i1, i2, i3, i4, i5) -> null;
         final Function5<String, Integer, Integer, Integer, Integer, Integer> f4 = (i1, i2, i3, i4, i5) -> null;
-        assertThat(f1.getType()).isEqualTo(f1.getType());
+        final Function5.Type<Integer, Integer, Integer, Integer, Integer, Integer> t1 = f1.getType();
+        assertThat(t1).isEqualTo(t1);
+        assertThat(t1).isNotEqualTo(11);
         assertThat(f1.getType()).isEqualTo(f2.getType());
         assertThat(f1.getType()).isNotEqualTo(f3.getType());
         assertThat(f1.getType()).isNotEqualTo(f4.getType());

File: src-gen/test/java/javaslang/Function6Test.java
Patch:
@@ -180,7 +180,9 @@ public void testTypesEquals() {
         final Function6<Integer, Integer, Integer, Integer, Integer, Integer, Integer> f2 = (i1, i2, i3, i4, i5, i6) -> null;
         final Function6<Integer, Integer, Integer, Integer, Integer, Integer, String> f3 = (i1, i2, i3, i4, i5, i6) -> null;
         final Function6<String, Integer, Integer, Integer, Integer, Integer, Integer> f4 = (i1, i2, i3, i4, i5, i6) -> null;
-        assertThat(f1.getType()).isEqualTo(f1.getType());
+        final Function6.Type<Integer, Integer, Integer, Integer, Integer, Integer, Integer> t1 = f1.getType();
+        assertThat(t1).isEqualTo(t1);
+        assertThat(t1).isNotEqualTo(11);
         assertThat(f1.getType()).isEqualTo(f2.getType());
         assertThat(f1.getType()).isNotEqualTo(f3.getType());
         assertThat(f1.getType()).isNotEqualTo(f4.getType());

File: src-gen/test/java/javaslang/Function7Test.java
Patch:
@@ -187,7 +187,9 @@ public void testTypesEquals() {
         final Function7<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer> f2 = (i1, i2, i3, i4, i5, i6, i7) -> null;
         final Function7<Integer, Integer, Integer, Integer, Integer, Integer, Integer, String> f3 = (i1, i2, i3, i4, i5, i6, i7) -> null;
         final Function7<String, Integer, Integer, Integer, Integer, Integer, Integer, Integer> f4 = (i1, i2, i3, i4, i5, i6, i7) -> null;
-        assertThat(f1.getType()).isEqualTo(f1.getType());
+        final Function7.Type<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer> t1 = f1.getType();
+        assertThat(t1).isEqualTo(t1);
+        assertThat(t1).isNotEqualTo(11);
         assertThat(f1.getType()).isEqualTo(f2.getType());
         assertThat(f1.getType()).isNotEqualTo(f3.getType());
         assertThat(f1.getType()).isNotEqualTo(f4.getType());

File: src-gen/test/java/javaslang/Function8Test.java
Patch:
@@ -194,7 +194,9 @@ public void testTypesEquals() {
         final Function8<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer> f2 = (i1, i2, i3, i4, i5, i6, i7, i8) -> null;
         final Function8<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, String> f3 = (i1, i2, i3, i4, i5, i6, i7, i8) -> null;
         final Function8<String, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer> f4 = (i1, i2, i3, i4, i5, i6, i7, i8) -> null;
-        assertThat(f1.getType()).isEqualTo(f1.getType());
+        final Function8.Type<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer> t1 = f1.getType();
+        assertThat(t1).isEqualTo(t1);
+        assertThat(t1).isNotEqualTo(11);
         assertThat(f1.getType()).isEqualTo(f2.getType());
         assertThat(f1.getType()).isNotEqualTo(f3.getType());
         assertThat(f1.getType()).isNotEqualTo(f4.getType());

File: src/main/java/javaslang/collection/RedBlackTree.java
Patch:
@@ -743,15 +743,15 @@ private static <T> Node<T> mergeEQ(Node<T> n1, Node<T> n2) {
             final T m = Node.minimum(n2);
             final RedBlackTree<T> t2 = Node.deleteMin(n2)._1;
             final int h2 = t2.isEmpty() ? 0 : ((Node<T>) t2).blackHeight;
-            final RedBlackTree<T> rl = ((Node<T>) n1.right).left;
-            final T rx = ((Node<T>) n1.right).value;
-            final RedBlackTree<T> rr = ((Node<T>) n1.right).right;
             if (n1.blackHeight == h2) {
                 return new Node<>(RED, n1.blackHeight + 1, n1, m, t2, n1.empty);
             } else if (isRed(n1.left)) {
                 final Node<T> node = new Node<>(BLACK, n1.blackHeight, n1.right, m, t2, n1.empty);
                 return new Node<>(RED, n1.blackHeight, Node.color(n1.left, BLACK), n1.value, node, n1.empty);
             } else if (isRed(n1.right)) {
+                final RedBlackTree<T> rl = ((Node<T>) n1.right).left;
+                final T rx = ((Node<T>) n1.right).value;
+                final RedBlackTree<T> rr = ((Node<T>) n1.right).right;
                 final Node<T> left = new Node<>(RED, n1.blackHeight, n1.left, n1.value, rl, n1.empty);
                 final Node<T> right = new Node<>(RED, n1.blackHeight, rr, m, t2, n1.empty);
                 return new Node<>(BLACK, n1.blackHeight, left, rx, right, n1.empty);

File: src/main/java/javaslang/collection/RedBlackTree.java
Patch:
@@ -743,15 +743,15 @@ private static <T> Node<T> mergeEQ(Node<T> n1, Node<T> n2) {
             final T m = Node.minimum(n2);
             final RedBlackTree<T> t2 = Node.deleteMin(n2)._1;
             final int h2 = t2.isEmpty() ? 0 : ((Node<T>) t2).blackHeight;
-            final RedBlackTree<T> rl = ((Node<T>) n1.right).left;
-            final T rx = ((Node<T>) n1.right).value;
-            final RedBlackTree<T> rr = ((Node<T>) n1.right).right;
             if (n1.blackHeight == h2) {
                 return new Node<>(RED, n1.blackHeight + 1, n1, m, t2, n1.empty);
             } else if (isRed(n1.left)) {
                 final Node<T> node = new Node<>(BLACK, n1.blackHeight, n1.right, m, t2, n1.empty);
                 return new Node<>(RED, n1.blackHeight, Node.color(n1.left, BLACK), n1.value, node, n1.empty);
             } else if (isRed(n1.right)) {
+                final RedBlackTree<T> rl = ((Node<T>) n1.right).left;
+                final T rx = ((Node<T>) n1.right).value;
+                final RedBlackTree<T> rr = ((Node<T>) n1.right).right;
                 final Node<T> left = new Node<>(RED, n1.blackHeight, n1.left, n1.value, rl, n1.empty);
                 final Node<T> right = new Node<>(RED, n1.blackHeight, rr, m, t2, n1.empty);
                 return new Node<>(BLACK, n1.blackHeight, left, rx, right, n1.empty);

File: src/main/java/javaslang/collection/TraversableOnce.java
Patch:
@@ -436,7 +436,7 @@ default T get() {
     /**
      * Checks if this TraversableOnce is empty.
      *
-     * @return true, if this TraversableOnce contains no elements, falso otherwise.
+     * @return true, if this TraversableOnce contains no elements, false otherwise.
      */
     @Override
     boolean isEmpty();

File: src/main/java/javaslang/collection/TraversableOnce.java
Patch:
@@ -436,7 +436,7 @@ default T get() {
     /**
      * Checks if this TraversableOnce is empty.
      *
-     * @return true, if this TraversableOnce contains no elements, falso otherwise.
+     * @return true, if this TraversableOnce contains no elements, false otherwise.
      */
     @Override
     boolean isEmpty();

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -1227,8 +1227,7 @@ default <U> List<U> unit(java.lang.Iterable<? extends U> iterable) {
     }
 
     @Override
-    default <T1, T2> Tuple2<List<T1>, List<T2>> unzip(
-            Function<? super T, Tuple2<? extends T1, ? extends T2>> unzipper) {
+    default <T1, T2> Tuple2<List<T1>, List<T2>> unzip(Function<? super T, Tuple2<? extends T1, ? extends T2>> unzipper) {
         Objects.requireNonNull(unzipper, "unzipper is null");
         List<T1> xs = Nil.instance();
         List<T2> ys = Nil.instance();

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -1227,8 +1227,7 @@ default <U> List<U> unit(java.lang.Iterable<? extends U> iterable) {
     }
 
     @Override
-    default <T1, T2> Tuple2<List<T1>, List<T2>> unzip(
-            Function<? super T, Tuple2<? extends T1, ? extends T2>> unzipper) {
+    default <T1, T2> Tuple2<List<T1>, List<T2>> unzip(Function<? super T, Tuple2<? extends T1, ? extends T2>> unzipper) {
         Objects.requireNonNull(unzipper, "unzipper is null");
         List<T1> xs = Nil.instance();
         List<T2> ys = Nil.instance();

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -528,6 +528,7 @@ public <K1, V1, K2, V2> Tuple2<HashMap<K1, V1>, HashMap<K2, V2>> unzip(Function<
         return Tuple.of(HashMap.of(trie1), HashMap.of(trie2));
     }
 
+    @SuppressWarnings("unchecked")
     @Override
     public <K1, V1, K2, V2> Tuple2<HashMap<K1, V1>, HashMap<K2, V2>> unzip(BiFunction<? super K, ? super V, Tuple2<? extends Entry<? extends K1, ? extends V1>, ? extends Entry<? extends K2, ? extends V2>>> unzipper) {
         Objects.requireNonNull(unzipper, "unzipper is null");

File: src/main/java/javaslang/Value.java
Patch:
@@ -230,7 +230,8 @@ default <X extends Throwable> T orElseThrow(Supplier<X> supplier) throws X {
      *
      * @return A flattened version of this {@code Value}.
      */
-    Value<Object> flatten();
+    // DEV_NOTE: needs to be <? extends Object> because of Map.flatten() of type Map<Object, Object>.
+    Value<? extends Object> flatten();
 
     /**
      * FlatMaps this value to a new value with different component type.

File: src/main/java/javaslang/collection/Map.java
Patch:
@@ -108,10 +108,10 @@ default V apply(K key) {
     Map<K, V> filter(Predicate<? super Entry<K, V>> predicate);
 
     @Override
-    <U> Set<U> flatMap(Function<? super Entry<K, V>, ? extends java.lang.Iterable<? extends U>> mapper);
+    <U> Seq<U> flatMap(Function<? super Entry<K, V>, ? extends java.lang.Iterable<? extends U>> mapper);
 
     @Override
-    Set<Object> flatten();
+    Map<Object, Object> flatten();
 
     @Override
     <C> Map<C, ? extends Map<K, V>> groupBy(Function<? super Entry<K, V>, ? extends C> classifier);

File: src/main/java/javaslang/collection/SortedMap.java
Patch:
@@ -49,13 +49,13 @@ public interface SortedMap<K, V> extends Map<K, V> {
     SortedMap<K, V> filter(Predicate<? super Entry<K, V>> predicate);
 
     @Override
-    <U> Set<U> flatMap(Function<? super Entry<K, V>, ? extends java.lang.Iterable<? extends U>> mapper);
+    <U> Seq<U> flatMap(Function<? super Entry<K, V>, ? extends java.lang.Iterable<? extends U>> mapper);
 
     @Override
     <U, W> SortedMap<U, W> flatMap(BiFunction<? super K, ? super V, ? extends java.lang.Iterable<? extends Entry<? extends U, ? extends W>>> mapper);
 
     @Override
-    Set<Object> flatten();
+    SortedMap<Object, Object> flatten();
 
     @Override
     <C> Map<C, ? extends SortedMap<K, V>> groupBy(Function<? super Entry<K, V>, ? extends C> classifier);

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -113,7 +113,7 @@ static <T> int hash(java.lang.Iterable<? extends T> objects) {
     <U> Traversable<U> flatMap(Function<? super T, ? extends java.lang.Iterable<? extends U>> mapper);
 
     @Override
-    Traversable<Object> flatten();
+    Traversable<? extends Object> flatten();
 
     @Override
     <C> Map<C, ? extends Traversable<T>> groupBy(Function<? super T, ? extends C> classifier);

File: src/main/java/javaslang/collection/TraversableOnce.java
Patch:
@@ -321,7 +321,7 @@ default Option<T> findFirst(Predicate<? super T> predicate) {
     <U> TraversableOnce<U> flatMap(Function<? super T, ? extends java.lang.Iterable<? extends U>> mapper);
 
     @Override
-    TraversableOnce<Object> flatten();
+    TraversableOnce<? extends Object> flatten();
 
     /**
      * <p>

File: src/main/java/javaslang/Value.java
Patch:
@@ -230,7 +230,8 @@ default <X extends Throwable> T orElseThrow(Supplier<X> supplier) throws X {
      *
      * @return A flattened version of this {@code Value}.
      */
-    Value<Object> flatten();
+    // DEV_NOTE: needs to be <? extends Object> because of Map.flatten() of type Map<Object, Object>.
+    Value<? extends Object> flatten();
 
     /**
      * FlatMaps this value to a new value with different component type.

File: src/main/java/javaslang/collection/Map.java
Patch:
@@ -108,10 +108,10 @@ default V apply(K key) {
     Map<K, V> filter(Predicate<? super Entry<K, V>> predicate);
 
     @Override
-    <U> Set<U> flatMap(Function<? super Entry<K, V>, ? extends java.lang.Iterable<? extends U>> mapper);
+    <U> Seq<U> flatMap(Function<? super Entry<K, V>, ? extends java.lang.Iterable<? extends U>> mapper);
 
     @Override
-    Set<Object> flatten();
+    Map<Object, Object> flatten();
 
     @Override
     <C> Map<C, ? extends Map<K, V>> groupBy(Function<? super Entry<K, V>, ? extends C> classifier);

File: src/main/java/javaslang/collection/SortedMap.java
Patch:
@@ -49,13 +49,13 @@ public interface SortedMap<K, V> extends Map<K, V> {
     SortedMap<K, V> filter(Predicate<? super Entry<K, V>> predicate);
 
     @Override
-    <U> Set<U> flatMap(Function<? super Entry<K, V>, ? extends java.lang.Iterable<? extends U>> mapper);
+    <U> Seq<U> flatMap(Function<? super Entry<K, V>, ? extends java.lang.Iterable<? extends U>> mapper);
 
     @Override
     <U, W> SortedMap<U, W> flatMap(BiFunction<? super K, ? super V, ? extends java.lang.Iterable<? extends Entry<? extends U, ? extends W>>> mapper);
 
     @Override
-    Set<Object> flatten();
+    SortedMap<Object, Object> flatten();
 
     @Override
     <C> Map<C, ? extends SortedMap<K, V>> groupBy(Function<? super Entry<K, V>, ? extends C> classifier);

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -113,7 +113,7 @@ static <T> int hash(java.lang.Iterable<? extends T> objects) {
     <U> Traversable<U> flatMap(Function<? super T, ? extends java.lang.Iterable<? extends U>> mapper);
 
     @Override
-    Traversable<Object> flatten();
+    Traversable<? extends Object> flatten();
 
     @Override
     <C> Map<C, ? extends Traversable<T>> groupBy(Function<? super T, ? extends C> classifier);

File: src/main/java/javaslang/collection/TraversableOnce.java
Patch:
@@ -321,7 +321,7 @@ default Option<T> findFirst(Predicate<? super T> predicate) {
     <U> TraversableOnce<U> flatMap(Function<? super T, ? extends java.lang.Iterable<? extends U>> mapper);
 
     @Override
-    TraversableOnce<Object> flatten();
+    TraversableOnce<? extends Object> flatten();
 
     /**
      * <p>

File: src/main/java/javaslang/collection/Iterator.java
Patch:
@@ -25,7 +25,6 @@
  * <strong>Note:</strong> Iterators encapsulate mutable state.
  * They are not meant to be used concurrently by different threads. Do not reuse Iterators, e.g. after passing to
  * {@linkplain List#ofAll(Iterable)}.
- * so d
  * <p>
  * There are two abstract methods: {@code hasNext} for checking if there is a next element available,
  * and {@code next} which removes the next element from the iterator and returns it. They can be called

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -313,7 +313,7 @@ public Iterator<Entry<K, V>> iterator() {
 
     @Override
     public Set<K> keySet() {
-        return map(entry -> entry.key);
+        return entrySet().map(Entry::key);
     }
 
     @Override
@@ -322,9 +322,9 @@ public int length() {
     }
 
     @Override
-    public <U> Set<U> map(Function<? super Entry<K, V>, ? extends U> mapper) {
+    public <U> Seq<U> map(Function<? super Entry<K, V>, ? extends U> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
-        return foldLeft(HashSet.empty(), (acc, entry) -> acc.add(mapper.apply(entry)));
+        return foldLeft(Vector.empty(), (acc, entry) -> acc.append(mapper.apply(entry)));
     }
 
     @Override

File: src/main/java/javaslang/collection/Map.java
Patch:
@@ -128,7 +128,7 @@ default V apply(K key) {
     int length();
 
     @Override
-    <U> Set<U> map(Function<? super Entry<K, V>, ? extends U> mapper);
+    <U> Seq<U> map(Function<? super Entry<K, V>, ? extends U> mapper);
 
     /**
      * Creates a new map which by merging the entries of {@code this} map and {@code that} map.

File: src/main/java/javaslang/collection/SortedMap.java
Patch:
@@ -73,7 +73,7 @@ public interface SortedMap<K, V> extends Map<K, V> {
     SortedSet<K> keySet();
 
     @Override
-    <U> Set<U> map(Function<? super Entry<K, V>, ? extends U> mapper);
+    <U> Seq<U> map(Function<? super Entry<K, V>, ? extends U> mapper);
 
     @Override
     <U, W> SortedMap<U, W> map(BiFunction<? super K, ? super V, ? extends Entry<? extends U, ? extends W>> mapper);

File: src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -335,7 +335,7 @@ public SortedSet<K> keySet() {
     }
 
     @Override
-    public <U> Set<U> map(Function<? super Entry<K, V>, ? extends U> mapper) {
+    public <U> Seq<U> map(Function<? super Entry<K, V>, ? extends U> mapper) {
         throw new UnsupportedOperationException("TODO"); // TODO
     }
 

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -313,7 +313,7 @@ public Iterator<Entry<K, V>> iterator() {
 
     @Override
     public Set<K> keySet() {
-        return map(entry -> entry.key);
+        return entrySet().map(Entry::key);
     }
 
     @Override
@@ -322,9 +322,9 @@ public int length() {
     }
 
     @Override
-    public <U> Set<U> map(Function<? super Entry<K, V>, ? extends U> mapper) {
+    public <U> Seq<U> map(Function<? super Entry<K, V>, ? extends U> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
-        return foldLeft(HashSet.empty(), (acc, entry) -> acc.add(mapper.apply(entry)));
+        return foldLeft(Vector.empty(), (acc, entry) -> acc.append(mapper.apply(entry)));
     }
 
     @Override

File: src/main/java/javaslang/collection/Map.java
Patch:
@@ -128,7 +128,7 @@ default V apply(K key) {
     int length();
 
     @Override
-    <U> Set<U> map(Function<? super Entry<K, V>, ? extends U> mapper);
+    <U> Seq<U> map(Function<? super Entry<K, V>, ? extends U> mapper);
 
     /**
      * Creates a new map which by merging the entries of {@code this} map and {@code that} map.

File: src/main/java/javaslang/collection/SortedMap.java
Patch:
@@ -73,7 +73,7 @@ public interface SortedMap<K, V> extends Map<K, V> {
     SortedSet<K> keySet();
 
     @Override
-    <U> Set<U> map(Function<? super Entry<K, V>, ? extends U> mapper);
+    <U> Seq<U> map(Function<? super Entry<K, V>, ? extends U> mapper);
 
     @Override
     <U, W> SortedMap<U, W> map(BiFunction<? super K, ? super V, ? extends Entry<? extends U, ? extends W>> mapper);

File: src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -335,7 +335,7 @@ public SortedSet<K> keySet() {
     }
 
     @Override
-    public <U> Set<U> map(Function<? super Entry<K, V>, ? extends U> mapper) {
+    public <U> Seq<U> map(Function<? super Entry<K, V>, ? extends U> mapper) {
         throw new UnsupportedOperationException("TODO"); // TODO
     }
 

File: src/main/java/javaslang/package-info.java
Patch:
@@ -3,4 +3,4 @@
  *
  * @since 1.0.0
  */
-package javaslang;
+package javaslang;
\ No newline at end of file

File: src/main/java/javaslang/package-info.java
Patch:
@@ -3,4 +3,4 @@
  *
  * @since 1.0.0
  */
-package javaslang;
+package javaslang;
\ No newline at end of file

File: src/main/java/javaslang/.java
Patch:
@@ -84,13 +84,13 @@ public interface <R> extends Serializable {
      */
     Type<R> getType();
 
-    /**
     /**
      * Represents the type of a function which consists of <em>parameter types</em> and a <em>return type</em>.
      *
      * @param <R> the return type of the function
      * @since 2.0.0
      */
+    // DEV-NOTE: implicitly static and therefore not leaking implicit this reference of enclosing instance
     abstract class Type<R> implements Serializable {
 
         private static final long serialVersionUID = 1L;

File: src/test/java/javaslang/control/TryTest.java
Patch:
@@ -164,7 +164,7 @@ public void shouldSubsequentlyHandOverCause() {
     // -- Failure.NonFatal
 
     @Test
-    public void shouldReturnAndNotThrowOnNonFatal(){
+    public void shouldReturnAndNotThrowOnNonFatal() {
         final NonFatal cause = NonFatal.of(new Exception());
         assertThat(NonFatal.of(cause) instanceof NonFatal).isTrue();
     }
@@ -177,7 +177,7 @@ public void shouldReturnToStringOnNonFatal() {
     }
 
     @Test
-    public void shouldReturnHasCodeOnNonFatal(){
+    public void shouldReturnHasCodeOnNonFatal() {
         final Exception exception = new java.lang.Exception();
         final NonFatal cause = NonFatal.of(exception);
         assertThat(cause.hashCode()).isEqualTo(Objects.hashCode(exception));
@@ -315,7 +315,7 @@ public void shouldFlatMapWithExceptionOnFailure() {
     }
 
     @Test
-    public void shouldFlatMapTryOnFailure(){
+    public void shouldFlatMapTryOnFailure() {
         final Try<String> actual = failure();
         assertThat(actual.flatMapTry(s -> Try.of(() -> s + "!"))).isEqualTo(actual);
     }

File: src/main/java/javaslang/collection/IndexedSeq.java
Patch:
@@ -154,9 +154,6 @@ public interface IndexedSeq<T> extends Seq<T> {
     @Override
     IndexedSeq<T> reverse();
 
-    @Override
-    IndexedSeq<T> slice(int beginIndex);
-
     @Override
     IndexedSeq<T> slice(int beginIndex, int endIndex);
 

File: src/main/java/javaslang/collection/LinearSeq.java
Patch:
@@ -154,9 +154,6 @@ public interface LinearSeq<T> extends Seq<T> {
     @Override
     LinearSeq<T> reverse();
 
-    @Override
-    LinearSeq<T> slice(int beginIndex);
-
     @Override
     LinearSeq<T> slice(int beginIndex, int endIndex);
 

File: src-gen/main/java/javaslang/CheckedFunction0.java
Patch:
@@ -17,6 +17,7 @@
  * Represents a function with no arguments.
  *
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -130,6 +131,7 @@ default Type<R> getType() {
      *
      *
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/CheckedFunction1.java
Patch:
@@ -20,6 +20,7 @@
  *
  * @param <T1> argument 1 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -199,6 +200,7 @@ default Type<T1, R> getType() {
      *
      * @param <T1> the 1st parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/CheckedFunction2.java
Patch:
@@ -21,6 +21,7 @@
  * @param <T1> argument 1 of the function
  * @param <T2> argument 2 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -191,6 +192,7 @@ default Type<T1, T2, R> getType() {
      * @param <T1> the 1st parameter type of the function
      * @param <T2> the 2nd parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/CheckedFunction3.java
Patch:
@@ -22,6 +22,7 @@
  * @param <T2> argument 2 of the function
  * @param <T3> argument 3 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -212,6 +213,7 @@ default Type<T1, T2, T3, R> getType() {
      * @param <T2> the 2nd parameter type of the function
      * @param <T3> the 3rd parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/CheckedFunction4.java
Patch:
@@ -23,6 +23,7 @@
  * @param <T3> argument 3 of the function
  * @param <T4> argument 4 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -234,6 +235,7 @@ default Type<T1, T2, T3, T4, R> getType() {
      * @param <T3> the 3rd parameter type of the function
      * @param <T4> the 4th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/CheckedFunction5.java
Patch:
@@ -24,6 +24,7 @@
  * @param <T4> argument 4 of the function
  * @param <T5> argument 5 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -257,6 +258,7 @@ default Type<T1, T2, T3, T4, T5, R> getType() {
      * @param <T4> the 4th parameter type of the function
      * @param <T5> the 5th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/CheckedFunction6.java
Patch:
@@ -25,6 +25,7 @@
  * @param <T5> argument 5 of the function
  * @param <T6> argument 6 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -281,6 +282,7 @@ default Type<T1, T2, T3, T4, T5, T6, R> getType() {
      * @param <T5> the 5th parameter type of the function
      * @param <T6> the 6th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/CheckedFunction7.java
Patch:
@@ -26,6 +26,7 @@
  * @param <T6> argument 6 of the function
  * @param <T7> argument 7 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -306,6 +307,7 @@ default Type<T1, T2, T3, T4, T5, T6, T7, R> getType() {
      * @param <T6> the 6th parameter type of the function
      * @param <T7> the 7th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/CheckedFunction8.java
Patch:
@@ -27,6 +27,7 @@
  * @param <T7> argument 7 of the function
  * @param <T8> argument 8 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -332,6 +333,7 @@ default Type<T1, T2, T3, T4, T5, T6, T7, T8, R> getType() {
      * @param <T7> the 7th parameter type of the function
      * @param <T8> the 8th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Function0.java
Patch:
@@ -17,6 +17,7 @@
  * Represents a function with no arguments.
  *
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -140,6 +141,7 @@ default Type<R> getType() {
      *
      *
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Function1.java
Patch:
@@ -20,6 +20,7 @@
  *
  * @param <T1> argument 1 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -199,6 +200,7 @@ default Type<T1, R> getType() {
      *
      * @param <T1> the 1st parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Function2.java
Patch:
@@ -21,6 +21,7 @@
  * @param <T1> argument 1 of the function
  * @param <T2> argument 2 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -191,6 +192,7 @@ default Type<T1, T2, R> getType() {
      * @param <T1> the 1st parameter type of the function
      * @param <T2> the 2nd parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Function3.java
Patch:
@@ -21,6 +21,7 @@
  * @param <T2> argument 2 of the function
  * @param <T3> argument 3 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -211,6 +212,7 @@ default Type<T1, T2, T3, R> getType() {
      * @param <T2> the 2nd parameter type of the function
      * @param <T3> the 3rd parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Function4.java
Patch:
@@ -22,6 +22,7 @@
  * @param <T3> argument 3 of the function
  * @param <T4> argument 4 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -233,6 +234,7 @@ default Type<T1, T2, T3, T4, R> getType() {
      * @param <T3> the 3rd parameter type of the function
      * @param <T4> the 4th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Function5.java
Patch:
@@ -23,6 +23,7 @@
  * @param <T4> argument 4 of the function
  * @param <T5> argument 5 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -256,6 +257,7 @@ default Type<T1, T2, T3, T4, T5, R> getType() {
      * @param <T4> the 4th parameter type of the function
      * @param <T5> the 5th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Function6.java
Patch:
@@ -24,6 +24,7 @@
  * @param <T5> argument 5 of the function
  * @param <T6> argument 6 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -280,6 +281,7 @@ default Type<T1, T2, T3, T4, T5, T6, R> getType() {
      * @param <T5> the 5th parameter type of the function
      * @param <T6> the 6th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Function7.java
Patch:
@@ -25,6 +25,7 @@
  * @param <T6> argument 6 of the function
  * @param <T7> argument 7 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -305,6 +306,7 @@ default Type<T1, T2, T3, T4, T5, T6, T7, R> getType() {
      * @param <T6> the 6th parameter type of the function
      * @param <T7> the 7th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Function8.java
Patch:
@@ -26,6 +26,7 @@
  * @param <T7> argument 7 of the function
  * @param <T8> argument 8 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -331,6 +332,7 @@ default Type<T1, T2, T3, T4, T5, T6, T7, T8, R> getType() {
      * @param <T7> the 7th parameter type of the function
      * @param <T8> the 8th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Tuple.java
Patch:
@@ -11,6 +11,8 @@
 
 /**
  * The base interface of all tuples.
+ *
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public interface Tuple {

File: src-gen/main/java/javaslang/Tuple1.java
Patch:
@@ -16,6 +16,7 @@
  * A tuple of one element which can be seen as cartesian product of one component.
  *
  * @param <T1> type of the 1st element
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public final class Tuple1<T1> implements Tuple, Serializable {

File: src-gen/main/java/javaslang/Tuple2.java
Patch:
@@ -17,6 +17,7 @@
  *
  * @param <T1> type of the 1st element
  * @param <T2> type of the 2nd element
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public final class Tuple2<T1, T2> implements Tuple, Serializable {

File: src-gen/main/java/javaslang/Tuple3.java
Patch:
@@ -18,6 +18,7 @@
  * @param <T1> type of the 1st element
  * @param <T2> type of the 2nd element
  * @param <T3> type of the 3rd element
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public final class Tuple3<T1, T2, T3> implements Tuple, Serializable {

File: src-gen/main/java/javaslang/Tuple4.java
Patch:
@@ -19,6 +19,7 @@
  * @param <T2> type of the 2nd element
  * @param <T3> type of the 3rd element
  * @param <T4> type of the 4th element
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public final class Tuple4<T1, T2, T3, T4> implements Tuple, Serializable {

File: src-gen/main/java/javaslang/Tuple5.java
Patch:
@@ -20,6 +20,7 @@
  * @param <T3> type of the 3rd element
  * @param <T4> type of the 4th element
  * @param <T5> type of the 5th element
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public final class Tuple5<T1, T2, T3, T4, T5> implements Tuple, Serializable {

File: src-gen/main/java/javaslang/Tuple6.java
Patch:
@@ -21,6 +21,7 @@
  * @param <T4> type of the 4th element
  * @param <T5> type of the 5th element
  * @param <T6> type of the 6th element
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public final class Tuple6<T1, T2, T3, T4, T5, T6> implements Tuple, Serializable {

File: src-gen/main/java/javaslang/Tuple7.java
Patch:
@@ -22,6 +22,7 @@
  * @param <T5> type of the 5th element
  * @param <T6> type of the 6th element
  * @param <T7> type of the 7th element
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public final class Tuple7<T1, T2, T3, T4, T5, T6, T7> implements Tuple, Serializable {

File: src-gen/main/java/javaslang/Tuple8.java
Patch:
@@ -23,6 +23,7 @@
  * @param <T6> type of the 6th element
  * @param <T7> type of the 7th element
  * @param <T8> type of the 8th element
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public final class Tuple8<T1, T2, T3, T4, T5, T6, T7, T8> implements Tuple, Serializable {

File: src/main/java/javaslang/Iterable.java
Patch:
@@ -17,6 +17,8 @@
  * A rich extension of {@code java.lang.Iterable} and basis of all {@link Value} types, e.g. controls, collections et al.
  *
  * @param <T> Component type
+ * @author Daniel Dietrich
+ * @since 2.0.0
  */
 public interface Iterable<T> extends java.lang.Iterable<T> {
 

File: src/main/java/javaslang/Lazy.java
Patch:
@@ -37,6 +37,7 @@
  *
  * <pre><code>final CharSequence chars = Lazy.of(() -&gt; "Yay!", CharSequence.class);</code></pre>
  *
+ * @author Daniel Dietrich
  * @since 1.2.1
  */
 public final class Lazy<T> implements Supplier<T>, Value<T>, Serializable {

File: src/main/java/javaslang/Tuple0.java
Patch:
@@ -14,6 +14,7 @@
  * Please use {@linkplain Tuple0#instance()} or {@linkplain Tuple#empty()} to obtain the single instance.
  * </p>
  *
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public final class Tuple0 implements Tuple, Serializable {

File: src/main/java/javaslang/Value.java
Patch:
@@ -52,6 +52,7 @@
  * </ul>
  *
  * @param <T> The type of the wrapped value.
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public interface Value<T> extends javaslang.Iterable<T> {

File: src/main/java/javaslang/collection/AbstractIterator.java
Patch:
@@ -12,6 +12,8 @@
  * from being evaluated. In other words, (identity-)equals and hashCode are implemented by Object.
  *
  * @param <T> Component type
+ * @author Daniel Dietrich
+ * @since 2.0.0
  */
 public abstract class AbstractIterator<T> implements Iterator<T> {
 

File: src/main/java/javaslang/collection/CharSeq.java
Patch:
@@ -22,6 +22,9 @@
 
 /**
  * TODO javadoc
+ *
+ * @author Ruslan Sennov, Daniel Dietrich
+ * @since 2.0.0
  */
 public final class CharSeq implements CharSequence, IndexedSeq<Character>, Serializable {
 

File: src/main/java/javaslang/collection/HashArrayMappedTrie.java
Patch:
@@ -19,6 +19,7 @@
 /**
  * An immutable <a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">Hash array mapped trie (HAMT)</a>.
  *
+ * @author Ruslan Sennov
  * @since 2.0.0
  */
 public interface HashArrayMappedTrie<K, V> extends java.lang.Iterable<Tuple2<K, V>> {

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -24,6 +24,7 @@
  * An immutable {@code HashMap} implementation based on a
  * <a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">Hash array mapped trie (HAMT)</a>.
  *
+ * @author Ruslan Sennov, Patryk Najda, Daniel Dietrich
  * @since 2.0.0
  */
 public final class HashMap<K, V> implements Map<K, V>, Serializable {

File: src/main/java/javaslang/collection/IndexedSeq.java
Patch:
@@ -21,6 +21,7 @@
  * Efficient random access is characteristic for indexed sequences.
  *
  * @param <T> component type
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public interface IndexedSeq<T> extends Seq<T> {

File: src/main/java/javaslang/collection/Iterator.java
Patch:
@@ -37,6 +37,7 @@
  * itself.
  *
  * @param <T> Component type
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public interface Iterator<T> extends java.util.Iterator<T>, TraversableOnce<T> {

File: src/main/java/javaslang/collection/LinearSeq.java
Patch:
@@ -21,6 +21,7 @@
  * Efficient {@code head()}, {@code tail()}, and {@code isEmpty()} methods are characteristic for linear sequences.
  *
  * @param <T> component type
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public interface LinearSeq<T> extends Seq<T> {

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -81,6 +81,7 @@
  * See Okasaki, Chris: <em>Purely Functional Data Structures</em> (p. 7 ff.). Cambridge, 2003.
  *
  * @param <T> Component type of the List
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public interface List<T> extends LinearSeq<T>, Stack<T> {

File: src/main/java/javaslang/collection/Map.java
Patch:
@@ -17,6 +17,7 @@
  *
  * @param <K> Key type
  * @param <V> Value type
+ * @author Daniel Dietrich, Ruslan Sennov
  * @since 2.0.0
  */
 public interface Map<K, V> extends Traversable<Map.Entry<K, V>>, Function<K, V> {

File: src/main/java/javaslang/collection/Queue.java
Patch:
@@ -41,6 +41,7 @@
  * See Okasaki, Chris: <em>Purely Functional Data Structures</em> (p. 42 ff.). Cambridge, 2003.
  *
  * @param <T> Component type of the Queue
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public class Queue<T> implements LinearSeq<T>, Serializable {

File: src/main/java/javaslang/collection/RedBlackTree.java
Patch:
@@ -33,6 +33,7 @@
  * </ul>
  *
  * @param <T> Component type
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public interface RedBlackTree<T> extends java.lang.Iterable<T> {

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -87,6 +87,7 @@
  * </ul>
  *
  * @param <T> Component type
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public interface Seq<T> extends Traversable<T>, IntFunction<T> {

File: src/main/java/javaslang/collection/Set.java
Patch:
@@ -20,6 +20,7 @@
  * An immutable {@code Set} interface.
  *
  * @param <T> Component type
+ * @author Daniel Dietrich, Ruslan Sennov
  * @since 2.0.0
  */
 public interface Set<T> extends Traversable<T> {

File: src/main/java/javaslang/collection/SortedMap.java
Patch:
@@ -16,6 +16,7 @@
  *
  * @param <K> Key type
  * @param <V> Value type
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public interface SortedMap<K, V> extends Map<K, V> {

File: src/main/java/javaslang/collection/SortedSet.java
Patch:
@@ -18,6 +18,7 @@
  * An immutable {@code SortedSet} interface.
  *
  * @param <T> Component type
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public interface SortedSet<T> extends Set<T> {

File: src/main/java/javaslang/collection/Stack.java
Patch:
@@ -34,6 +34,7 @@
  * See Okasaki, Chris: <em>Purely Functional Data Structures</em> (p. 7 ff.). Cambridge, 2003.
  *
  * @param <T> component type
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public interface Stack<T> extends LinearSeq<T> {

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -95,6 +95,7 @@
  * See Okasaki, Chris: <em>Purely Functional Data Structures</em> (p. 34 ff.). Cambridge, 2003.
  *
  * @param <T> component type of this Stream
+ * @author Daniel Dietrich, Jrgen Andersson, Ruslan Sennov
  * @since 1.1.0
  */
 public interface Stream<T> extends LinearSeq<T> {

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -29,6 +29,7 @@
  * </ul>
  *
  * @param <T> Component type
+ * @author Daniel Dietrich and others
  * @since 1.1.0
  */
 public interface Traversable<T> extends TraversableOnce<T> {

File: src/main/java/javaslang/collection/TraversableOnce.java
Patch:
@@ -114,6 +114,7 @@
  * </ul>
  *
  * @param <T> Component type
+ * @author Daniel Dietrich and others
  * @since 2.0.0
  */
 public interface TraversableOnce<T> extends Value<T> {

File: src/main/java/javaslang/collection/Tree.java
Patch:
@@ -22,6 +22,7 @@
  * <p>A general Tree interface.</p>
  *
  * @param <T> component type of this Tree
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public interface Tree<T> extends Traversable<T> {

File: src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -9,7 +9,10 @@
  * SortedMap implementation, backed by a Red/Black Tree.
  *
  * @param <T> Component type
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public class TreeMap<T> {
+
+    // TODO
 }

File: src/main/java/javaslang/collection/TreeSet.java
Patch:
@@ -23,6 +23,7 @@
  * SortedSet implementation, backed by a Red/Black Tree.
  *
  * @param <T> Component type
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 // DEV-NOTE: it is not possible to create an EMPTY TreeSet without a Comparator type in scope

File: src/main/java/javaslang/collection/Vector.java
Patch:
@@ -21,6 +21,8 @@
  * TODO javadoc
  *
  * @param <T> Component type of the Vector.
+ * @author Ruslan Sennov
+ * @since 2.0.0
  */
 public final class Vector<T> implements IndexedSeq<T>, Serializable {
 

File: src/main/java/javaslang/concurrent/Future.java
Patch:
@@ -23,6 +23,7 @@
  * See {@link Promise} if you want Futures that can be success by some other method.
  *
  * @param <T> The type of this Future's eventual value.
+ * @author Dillon Jett Callis, Daniel Dietrich
  * @since 2.0.0
  */
 public class Future<T> {

File: src/main/java/javaslang/concurrent/Promise.java
Patch:
@@ -17,7 +17,7 @@
  * The Future can be obtained with {@link #future()} and success with {@link #success(Object)} or {@link #failure(Throwable)}.
  *
  * @param <T> The type of this Promise and Future's return type.
- *
+ * @author Dillon Jett Callis, Daniel Dietrich
  * @since 2.0.0
  */
 public class Promise<T> {

File: src/main/java/javaslang/control/Either.java
Patch:
@@ -37,6 +37,7 @@
  *
  * @param <L> The type of the Left value of an Either.
  * @param <R> The type of the Right value of an Either.
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public interface Either<L, R> {

File: src/main/java/javaslang/control/Failure.java
Patch:
@@ -13,6 +13,7 @@
  * A failed Try.
  *
  * @param <T> component type of this Failure
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public final class Failure<T> implements Try<T>, Serializable {

File: src/main/java/javaslang/control/Left.java
Patch:
@@ -14,6 +14,7 @@
  *
  * @param <L> left component type
  * @param <R> right component type
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public final class Left<L, R> implements Either<L, R>, Serializable {

File: src/main/java/javaslang/control/Match.java
Patch:
@@ -62,6 +62,7 @@
  * </code></pre>
  *
  * @param <R> The result type of the {@code Match}.
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public interface Match<R> extends Function<Object, R> {

File: src/main/java/javaslang/control/MatchError.java
Patch:
@@ -8,6 +8,7 @@
 /**
  * A {@link Match} throws a MatchError if no case matches the applied object.
  *
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public class MatchError extends RuntimeException {

File: src/main/java/javaslang/control/None.java
Patch:
@@ -17,6 +17,7 @@
  * calling {@link #instance()}.
  *
  * @param <T> The type of the optional value.
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public final class None<T> implements Option<T>, Serializable {

File: src/main/java/javaslang/control/Option.java
Patch:
@@ -28,6 +28,7 @@
  * href="http://www.scala-lang.org/api/current/#scala.Option">Scala</a>.
  *
  * @param <T> The type of the optional value.
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public interface Option<T> extends Value<T> {

File: src/main/java/javaslang/control/Right.java
Patch:
@@ -14,6 +14,7 @@
  *
  * @param <L> left component type
  * @param <R> right component type
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public final class Right<L, R> implements Either<L, R>, Serializable {

File: src/main/java/javaslang/control/Some.java
Patch:
@@ -20,6 +20,7 @@
  * {@link Option#of(Object)} is sufficient.
  *
  * @param <T> The type of the optional value.
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public final class Some<T> implements Option<T>, Serializable {

File: src/main/java/javaslang/control/Success.java
Patch:
@@ -19,6 +19,7 @@
  * A succeeded Try.
  *
  * @param <T> component type of this Success
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public final class Success<T> implements Try<T>, Serializable {

File: src/main/java/javaslang/control/Try.java
Patch:
@@ -19,6 +19,8 @@
  * An implementation similar to Scala's Try control.
  *
  * @param <T> Value type in the case of success.
+ * @author Daniel Dietrich
+ * @since 1.0.0
  */
 public interface Try<T> extends Value<T> {
 

File: src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -20,6 +20,7 @@
  * Represents an arbitrary object of type T.
  *
  * @param <T> The type of the arbitrary object.
+ * @author Daniel Dietrich
  * @since 1.2.0
  */
 @FunctionalInterface

File: src/main/java/javaslang/test/CheckResult.java
Patch:
@@ -26,6 +26,7 @@
  * and no sample could be found that satisfied the pre-condition. In this case the post-condition is satisfied by
  * definition (see <a href="http://en.wikipedia.org/wiki/Principle_of_explosion">ex falso quodlibet</a>).
  *
+ * @author Daniel Dietrich
  * @since 1.2.0
  */
 public interface CheckResult {

File: src/main/java/javaslang/test/Checkable.java
Patch:
@@ -12,6 +12,7 @@
 /**
  * Interface for checkable properties, allowing composition via {@linkplain #and(Checkable)} and {@linkplain #or(Checkable)}.
  *
+ * @author Daniel Dietrich
  * @since 1.2.0
  */
 @FunctionalInterface

File: src/main/java/javaslang/test/Errors.java
Patch:
@@ -8,6 +8,7 @@
 /**
  * Error messages used internally within {@code Property.check}.
  *
+ * @author Daniel Dietrich
  * @since 1.2.0
  */
 interface Errors {

File: src/main/java/javaslang/test/Gen.java
Patch:
@@ -28,6 +28,7 @@
  *
  * @param <T> type of generated objects
  * @see javaslang.test.Arbitrary
+ * @author Daniel Dietrich
  * @since 1.2.0
  */
 @FunctionalInterface

File: src/main/java/javaslang/.java
Patch:
@@ -21,6 +21,7 @@
  * because Java cannot calculate type bounds on function composition.
  *
  * @param <R> Return type of the function.
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public interface <R> extends Serializable {

File: src-gen/main/java/javaslang/CheckedFunction0.java
Patch:
@@ -17,6 +17,7 @@
  * Represents a function with no arguments.
  *
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -130,6 +131,7 @@ default Type<R> getType() {
      *
      *
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/CheckedFunction1.java
Patch:
@@ -20,6 +20,7 @@
  *
  * @param <T1> argument 1 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -199,6 +200,7 @@ default Type<T1, R> getType() {
      *
      * @param <T1> the 1st parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/CheckedFunction2.java
Patch:
@@ -21,6 +21,7 @@
  * @param <T1> argument 1 of the function
  * @param <T2> argument 2 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -191,6 +192,7 @@ default Type<T1, T2, R> getType() {
      * @param <T1> the 1st parameter type of the function
      * @param <T2> the 2nd parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/CheckedFunction3.java
Patch:
@@ -22,6 +22,7 @@
  * @param <T2> argument 2 of the function
  * @param <T3> argument 3 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -212,6 +213,7 @@ default Type<T1, T2, T3, R> getType() {
      * @param <T2> the 2nd parameter type of the function
      * @param <T3> the 3rd parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/CheckedFunction4.java
Patch:
@@ -23,6 +23,7 @@
  * @param <T3> argument 3 of the function
  * @param <T4> argument 4 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -234,6 +235,7 @@ default Type<T1, T2, T3, T4, R> getType() {
      * @param <T3> the 3rd parameter type of the function
      * @param <T4> the 4th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/CheckedFunction5.java
Patch:
@@ -24,6 +24,7 @@
  * @param <T4> argument 4 of the function
  * @param <T5> argument 5 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -257,6 +258,7 @@ default Type<T1, T2, T3, T4, T5, R> getType() {
      * @param <T4> the 4th parameter type of the function
      * @param <T5> the 5th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/CheckedFunction6.java
Patch:
@@ -25,6 +25,7 @@
  * @param <T5> argument 5 of the function
  * @param <T6> argument 6 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -281,6 +282,7 @@ default Type<T1, T2, T3, T4, T5, T6, R> getType() {
      * @param <T5> the 5th parameter type of the function
      * @param <T6> the 6th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/CheckedFunction7.java
Patch:
@@ -26,6 +26,7 @@
  * @param <T6> argument 6 of the function
  * @param <T7> argument 7 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -306,6 +307,7 @@ default Type<T1, T2, T3, T4, T5, T6, T7, R> getType() {
      * @param <T6> the 6th parameter type of the function
      * @param <T7> the 7th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/CheckedFunction8.java
Patch:
@@ -27,6 +27,7 @@
  * @param <T7> argument 7 of the function
  * @param <T8> argument 8 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -332,6 +333,7 @@ default Type<T1, T2, T3, T4, T5, T6, T7, T8, R> getType() {
      * @param <T7> the 7th parameter type of the function
      * @param <T8> the 8th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Function0.java
Patch:
@@ -17,6 +17,7 @@
  * Represents a function with no arguments.
  *
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -140,6 +141,7 @@ default Type<R> getType() {
      *
      *
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Function1.java
Patch:
@@ -20,6 +20,7 @@
  *
  * @param <T1> argument 1 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -199,6 +200,7 @@ default Type<T1, R> getType() {
      *
      * @param <T1> the 1st parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Function2.java
Patch:
@@ -21,6 +21,7 @@
  * @param <T1> argument 1 of the function
  * @param <T2> argument 2 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -191,6 +192,7 @@ default Type<T1, T2, R> getType() {
      * @param <T1> the 1st parameter type of the function
      * @param <T2> the 2nd parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Function3.java
Patch:
@@ -21,6 +21,7 @@
  * @param <T2> argument 2 of the function
  * @param <T3> argument 3 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -211,6 +212,7 @@ default Type<T1, T2, T3, R> getType() {
      * @param <T2> the 2nd parameter type of the function
      * @param <T3> the 3rd parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Function4.java
Patch:
@@ -22,6 +22,7 @@
  * @param <T3> argument 3 of the function
  * @param <T4> argument 4 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -233,6 +234,7 @@ default Type<T1, T2, T3, T4, R> getType() {
      * @param <T3> the 3rd parameter type of the function
      * @param <T4> the 4th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Function5.java
Patch:
@@ -23,6 +23,7 @@
  * @param <T4> argument 4 of the function
  * @param <T5> argument 5 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -256,6 +257,7 @@ default Type<T1, T2, T3, T4, T5, R> getType() {
      * @param <T4> the 4th parameter type of the function
      * @param <T5> the 5th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Function6.java
Patch:
@@ -24,6 +24,7 @@
  * @param <T5> argument 5 of the function
  * @param <T6> argument 6 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -280,6 +281,7 @@ default Type<T1, T2, T3, T4, T5, T6, R> getType() {
      * @param <T5> the 5th parameter type of the function
      * @param <T6> the 6th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Function7.java
Patch:
@@ -25,6 +25,7 @@
  * @param <T6> argument 6 of the function
  * @param <T7> argument 7 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -305,6 +306,7 @@ default Type<T1, T2, T3, T4, T5, T6, T7, R> getType() {
      * @param <T6> the 6th parameter type of the function
      * @param <T7> the 7th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Function8.java
Patch:
@@ -26,6 +26,7 @@
  * @param <T7> argument 7 of the function
  * @param <T8> argument 8 of the function
  * @param <R> return type of the function
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 @FunctionalInterface
@@ -331,6 +332,7 @@ default Type<T1, T2, T3, T4, T5, T6, T7, T8, R> getType() {
      * @param <T7> the 7th parameter type of the function
      * @param <T8> the 8th parameter type of the function
      * @param <R> the return type of the function
+     * @author Daniel Dietrich
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")

File: src-gen/main/java/javaslang/Tuple.java
Patch:
@@ -11,6 +11,8 @@
 
 /**
  * The base interface of all tuples.
+ *
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public interface Tuple {

File: src-gen/main/java/javaslang/Tuple1.java
Patch:
@@ -16,6 +16,7 @@
  * A tuple of one element which can be seen as cartesian product of one component.
  *
  * @param <T1> type of the 1st element
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public final class Tuple1<T1> implements Tuple, Serializable {

File: src-gen/main/java/javaslang/Tuple2.java
Patch:
@@ -17,6 +17,7 @@
  *
  * @param <T1> type of the 1st element
  * @param <T2> type of the 2nd element
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public final class Tuple2<T1, T2> implements Tuple, Serializable {

File: src-gen/main/java/javaslang/Tuple3.java
Patch:
@@ -18,6 +18,7 @@
  * @param <T1> type of the 1st element
  * @param <T2> type of the 2nd element
  * @param <T3> type of the 3rd element
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public final class Tuple3<T1, T2, T3> implements Tuple, Serializable {

File: src-gen/main/java/javaslang/Tuple4.java
Patch:
@@ -19,6 +19,7 @@
  * @param <T2> type of the 2nd element
  * @param <T3> type of the 3rd element
  * @param <T4> type of the 4th element
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public final class Tuple4<T1, T2, T3, T4> implements Tuple, Serializable {

File: src-gen/main/java/javaslang/Tuple5.java
Patch:
@@ -20,6 +20,7 @@
  * @param <T3> type of the 3rd element
  * @param <T4> type of the 4th element
  * @param <T5> type of the 5th element
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public final class Tuple5<T1, T2, T3, T4, T5> implements Tuple, Serializable {

File: src-gen/main/java/javaslang/Tuple6.java
Patch:
@@ -21,6 +21,7 @@
  * @param <T4> type of the 4th element
  * @param <T5> type of the 5th element
  * @param <T6> type of the 6th element
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public final class Tuple6<T1, T2, T3, T4, T5, T6> implements Tuple, Serializable {

File: src-gen/main/java/javaslang/Tuple7.java
Patch:
@@ -22,6 +22,7 @@
  * @param <T5> type of the 5th element
  * @param <T6> type of the 6th element
  * @param <T7> type of the 7th element
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public final class Tuple7<T1, T2, T3, T4, T5, T6, T7> implements Tuple, Serializable {

File: src-gen/main/java/javaslang/Tuple8.java
Patch:
@@ -23,6 +23,7 @@
  * @param <T6> type of the 6th element
  * @param <T7> type of the 7th element
  * @param <T8> type of the 8th element
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public final class Tuple8<T1, T2, T3, T4, T5, T6, T7, T8> implements Tuple, Serializable {

File: src/main/java/javaslang/Iterable.java
Patch:
@@ -17,6 +17,8 @@
  * A rich extension of {@code java.lang.Iterable} and basis of all {@link Value} types, e.g. controls, collections et al.
  *
  * @param <T> Component type
+ * @author Daniel Dietrich
+ * @since 2.0.0
  */
 public interface Iterable<T> extends java.lang.Iterable<T> {
 

File: src/main/java/javaslang/Lazy.java
Patch:
@@ -37,6 +37,7 @@
  *
  * <pre><code>final CharSequence chars = Lazy.of(() -&gt; "Yay!", CharSequence.class);</code></pre>
  *
+ * @author Daniel Dietrich
  * @since 1.2.1
  */
 public final class Lazy<T> implements Supplier<T>, Value<T>, Serializable {

File: src/main/java/javaslang/Tuple0.java
Patch:
@@ -14,6 +14,7 @@
  * Please use {@linkplain Tuple0#instance()} or {@linkplain Tuple#empty()} to obtain the single instance.
  * </p>
  *
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public final class Tuple0 implements Tuple, Serializable {

File: src/main/java/javaslang/Value.java
Patch:
@@ -52,6 +52,7 @@
  * </ul>
  *
  * @param <T> The type of the wrapped value.
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public interface Value<T> extends javaslang.Iterable<T> {

File: src/main/java/javaslang/collection/AbstractIterator.java
Patch:
@@ -12,6 +12,8 @@
  * from being evaluated. In other words, (identity-)equals and hashCode are implemented by Object.
  *
  * @param <T> Component type
+ * @author Daniel Dietrich
+ * @since 2.0.0
  */
 public abstract class AbstractIterator<T> implements Iterator<T> {
 

File: src/main/java/javaslang/collection/CharSeq.java
Patch:
@@ -22,6 +22,9 @@
 
 /**
  * TODO javadoc
+ *
+ * @author Ruslan Sennov, Daniel Dietrich
+ * @since 2.0.0
  */
 public final class CharSeq implements CharSequence, IndexedSeq<Character>, Serializable {
 

File: src/main/java/javaslang/collection/HashArrayMappedTrie.java
Patch:
@@ -19,6 +19,7 @@
 /**
  * An immutable <a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">Hash array mapped trie (HAMT)</a>.
  *
+ * @author Ruslan Sennov
  * @since 2.0.0
  */
 public interface HashArrayMappedTrie<K, V> extends java.lang.Iterable<Tuple2<K, V>> {

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -24,6 +24,7 @@
  * An immutable {@code HashMap} implementation based on a
  * <a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">Hash array mapped trie (HAMT)</a>.
  *
+ * @author Ruslan Sennov, Patryk Najda, Daniel Dietrich
  * @since 2.0.0
  */
 public final class HashMap<K, V> implements Map<K, V>, Serializable {

File: src/main/java/javaslang/collection/IndexedSeq.java
Patch:
@@ -21,6 +21,7 @@
  * Efficient random access is characteristic for indexed sequences.
  *
  * @param <T> component type
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public interface IndexedSeq<T> extends Seq<T> {

File: src/main/java/javaslang/collection/Iterator.java
Patch:
@@ -37,6 +37,7 @@
  * itself.
  *
  * @param <T> Component type
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public interface Iterator<T> extends java.util.Iterator<T>, TraversableOnce<T> {

File: src/main/java/javaslang/collection/LinearSeq.java
Patch:
@@ -21,6 +21,7 @@
  * Efficient {@code head()}, {@code tail()}, and {@code isEmpty()} methods are characteristic for linear sequences.
  *
  * @param <T> component type
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public interface LinearSeq<T> extends Seq<T> {

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -81,6 +81,7 @@
  * See Okasaki, Chris: <em>Purely Functional Data Structures</em> (p. 7 ff.). Cambridge, 2003.
  *
  * @param <T> Component type of the List
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public interface List<T> extends LinearSeq<T>, Stack<T> {

File: src/main/java/javaslang/collection/Map.java
Patch:
@@ -17,6 +17,7 @@
  *
  * @param <K> Key type
  * @param <V> Value type
+ * @author Daniel Dietrich, Ruslan Sennov
  * @since 2.0.0
  */
 public interface Map<K, V> extends Traversable<Map.Entry<K, V>>, Function<K, V> {

File: src/main/java/javaslang/collection/Queue.java
Patch:
@@ -41,6 +41,7 @@
  * See Okasaki, Chris: <em>Purely Functional Data Structures</em> (p. 42 ff.). Cambridge, 2003.
  *
  * @param <T> Component type of the Queue
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public class Queue<T> implements LinearSeq<T>, Serializable {

File: src/main/java/javaslang/collection/RedBlackTree.java
Patch:
@@ -33,6 +33,7 @@
  * </ul>
  *
  * @param <T> Component type
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public interface RedBlackTree<T> extends java.lang.Iterable<T> {

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -87,6 +87,7 @@
  * </ul>
  *
  * @param <T> Component type
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public interface Seq<T> extends Traversable<T>, IntFunction<T> {

File: src/main/java/javaslang/collection/Set.java
Patch:
@@ -20,6 +20,7 @@
  * An immutable {@code Set} interface.
  *
  * @param <T> Component type
+ * @author Daniel Dietrich, Ruslan Sennov
  * @since 2.0.0
  */
 public interface Set<T> extends Traversable<T> {

File: src/main/java/javaslang/collection/SortedMap.java
Patch:
@@ -16,6 +16,7 @@
  *
  * @param <K> Key type
  * @param <V> Value type
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public interface SortedMap<K, V> extends Map<K, V> {

File: src/main/java/javaslang/collection/SortedSet.java
Patch:
@@ -18,6 +18,7 @@
  * An immutable {@code SortedSet} interface.
  *
  * @param <T> Component type
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public interface SortedSet<T> extends Set<T> {

File: src/main/java/javaslang/collection/Stack.java
Patch:
@@ -34,6 +34,7 @@
  * See Okasaki, Chris: <em>Purely Functional Data Structures</em> (p. 7 ff.). Cambridge, 2003.
  *
  * @param <T> component type
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public interface Stack<T> extends LinearSeq<T> {

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -95,6 +95,7 @@
  * See Okasaki, Chris: <em>Purely Functional Data Structures</em> (p. 34 ff.). Cambridge, 2003.
  *
  * @param <T> component type of this Stream
+ * @author Daniel Dietrich, Jrgen Andersson, Ruslan Sennov
  * @since 1.1.0
  */
 public interface Stream<T> extends LinearSeq<T> {

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -29,6 +29,7 @@
  * </ul>
  *
  * @param <T> Component type
+ * @author Daniel Dietrich and others
  * @since 1.1.0
  */
 public interface Traversable<T> extends TraversableOnce<T> {

File: src/main/java/javaslang/collection/TraversableOnce.java
Patch:
@@ -114,6 +114,7 @@
  * </ul>
  *
  * @param <T> Component type
+ * @author Daniel Dietrich and others
  * @since 2.0.0
  */
 public interface TraversableOnce<T> extends Value<T> {

File: src/main/java/javaslang/collection/Tree.java
Patch:
@@ -22,6 +22,7 @@
  * <p>A general Tree interface.</p>
  *
  * @param <T> component type of this Tree
+ * @author Daniel Dietrich
  * @since 1.1.0
  */
 public interface Tree<T> extends Traversable<T> {

File: src/main/java/javaslang/collection/TreeMap.java
Patch:
@@ -9,7 +9,10 @@
  * SortedMap implementation, backed by a Red/Black Tree.
  *
  * @param <T> Component type
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 public class TreeMap<T> {
+
+    // TODO
 }

File: src/main/java/javaslang/collection/TreeSet.java
Patch:
@@ -23,6 +23,7 @@
  * SortedSet implementation, backed by a Red/Black Tree.
  *
  * @param <T> Component type
+ * @author Daniel Dietrich
  * @since 2.0.0
  */
 // DEV-NOTE: it is not possible to create an EMPTY TreeSet without a Comparator type in scope

File: src/main/java/javaslang/collection/Vector.java
Patch:
@@ -21,6 +21,8 @@
  * TODO javadoc
  *
  * @param <T> Component type of the Vector.
+ * @author Ruslan Sennov
+ * @since 2.0.0
  */
 public final class Vector<T> implements IndexedSeq<T>, Serializable {
 

File: src/main/java/javaslang/concurrent/Future.java
Patch:
@@ -23,6 +23,7 @@
  * See {@link Promise} if you want Futures that can be success by some other method.
  *
  * @param <T> The type of this Future's eventual value.
+ * @author Dillon Jett Callis, Daniel Dietrich
  * @since 2.0.0
  */
 public class Future<T> {

File: src/main/java/javaslang/concurrent/Promise.java
Patch:
@@ -17,7 +17,7 @@
  * The Future can be obtained with {@link #future()} and success with {@link #success(Object)} or {@link #failure(Throwable)}.
  *
  * @param <T> The type of this Promise and Future's return type.
- *
+ * @author Dillon Jett Callis, Daniel Dietrich
  * @since 2.0.0
  */
 public class Promise<T> {

File: src/main/java/javaslang/control/Either.java
Patch:
@@ -37,6 +37,7 @@
  *
  * @param <L> The type of the Left value of an Either.
  * @param <R> The type of the Right value of an Either.
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public interface Either<L, R> {

File: src/main/java/javaslang/control/Failure.java
Patch:
@@ -13,6 +13,7 @@
  * A failed Try.
  *
  * @param <T> component type of this Failure
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public final class Failure<T> implements Try<T>, Serializable {

File: src/main/java/javaslang/control/Left.java
Patch:
@@ -14,6 +14,7 @@
  *
  * @param <L> left component type
  * @param <R> right component type
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public final class Left<L, R> implements Either<L, R>, Serializable {

File: src/main/java/javaslang/control/Match.java
Patch:
@@ -62,6 +62,7 @@
  * </code></pre>
  *
  * @param <R> The result type of the {@code Match}.
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public interface Match<R> extends Function<Object, R> {

File: src/main/java/javaslang/control/MatchError.java
Patch:
@@ -8,6 +8,7 @@
 /**
  * A {@link Match} throws a MatchError if no case matches the applied object.
  *
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public class MatchError extends RuntimeException {

File: src/main/java/javaslang/control/None.java
Patch:
@@ -17,6 +17,7 @@
  * calling {@link #instance()}.
  *
  * @param <T> The type of the optional value.
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public final class None<T> implements Option<T>, Serializable {

File: src/main/java/javaslang/control/Option.java
Patch:
@@ -28,6 +28,7 @@
  * href="http://www.scala-lang.org/api/current/#scala.Option">Scala</a>.
  *
  * @param <T> The type of the optional value.
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public interface Option<T> extends Value<T> {

File: src/main/java/javaslang/control/Right.java
Patch:
@@ -14,6 +14,7 @@
  *
  * @param <L> left component type
  * @param <R> right component type
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public final class Right<L, R> implements Either<L, R>, Serializable {

File: src/main/java/javaslang/control/Some.java
Patch:
@@ -20,6 +20,7 @@
  * {@link Option#of(Object)} is sufficient.
  *
  * @param <T> The type of the optional value.
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public final class Some<T> implements Option<T>, Serializable {

File: src/main/java/javaslang/control/Success.java
Patch:
@@ -19,6 +19,7 @@
  * A succeeded Try.
  *
  * @param <T> component type of this Success
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public final class Success<T> implements Try<T>, Serializable {

File: src/main/java/javaslang/control/Try.java
Patch:
@@ -19,6 +19,8 @@
  * An implementation similar to Scala's Try control.
  *
  * @param <T> Value type in the case of success.
+ * @author Daniel Dietrich
+ * @since 1.0.0
  */
 public interface Try<T> extends Value<T> {
 

File: src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -20,6 +20,7 @@
  * Represents an arbitrary object of type T.
  *
  * @param <T> The type of the arbitrary object.
+ * @author Daniel Dietrich
  * @since 1.2.0
  */
 @FunctionalInterface

File: src/main/java/javaslang/test/CheckResult.java
Patch:
@@ -26,6 +26,7 @@
  * and no sample could be found that satisfied the pre-condition. In this case the post-condition is satisfied by
  * definition (see <a href="http://en.wikipedia.org/wiki/Principle_of_explosion">ex falso quodlibet</a>).
  *
+ * @author Daniel Dietrich
  * @since 1.2.0
  */
 public interface CheckResult {

File: src/main/java/javaslang/test/Checkable.java
Patch:
@@ -12,6 +12,7 @@
 /**
  * Interface for checkable properties, allowing composition via {@linkplain #and(Checkable)} and {@linkplain #or(Checkable)}.
  *
+ * @author Daniel Dietrich
  * @since 1.2.0
  */
 @FunctionalInterface

File: src/main/java/javaslang/test/Errors.java
Patch:
@@ -8,6 +8,7 @@
 /**
  * Error messages used internally within {@code Property.check}.
  *
+ * @author Daniel Dietrich
  * @since 1.2.0
  */
 interface Errors {

File: src/main/java/javaslang/test/Gen.java
Patch:
@@ -28,6 +28,7 @@
  *
  * @param <T> type of generated objects
  * @see javaslang.test.Arbitrary
+ * @author Daniel Dietrich
  * @since 1.2.0
  */
 @FunctionalInterface

File: src/main/java/javaslang/.java
Patch:
@@ -21,6 +21,7 @@
  * because Java cannot calculate type bounds on function composition.
  *
  * @param <R> Return type of the function.
+ * @author Daniel Dietrich
  * @since 1.0.0
  */
 public interface <R> extends Serializable {

File: src/main/java/javaslang/collection/Tree.java
Patch:
@@ -8,6 +8,7 @@
 import javaslang.Lazy;
 import javaslang.Tuple;
 import javaslang.Tuple2;
+import javaslang.collection.List.Nil;
 import javaslang.control.Match;
 import javaslang.control.None;
 import javaslang.control.Option;

File: src/main/java/javaslang/collection/Tree.java
Patch:
@@ -8,6 +8,7 @@
 import javaslang.Lazy;
 import javaslang.Tuple;
 import javaslang.Tuple2;
+import javaslang.collection.List.Nil;
 import javaslang.control.Match;
 import javaslang.control.None;
 import javaslang.control.Option;

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -54,7 +54,7 @@ public interface Traversable<T> extends TraversableOnce<T> {
      *
      * <strong>Note:</strong> In the case of an empty collection, such as {@code Nil} it is recommended to
      * directly return {@code Traversable.hash(this)} instead of asking a {@code Lazy} value:
-     * <pre>ype
+     * <pre>
      * <code>
      * interface List&lt;T&gt; {
      *

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -52,9 +52,9 @@ public interface Traversable<T> extends TraversableOnce<T> {
      * </code>
      * </pre>
      *
-     * <strong>Note:</strong> In the case of an empty collection, such as {@code List.Nil} it is recommended to
+     * <strong>Note:</strong> In the case of an empty collection, such as {@code Nil} it is recommended to
      * directly return {@code Traversable.hash(this)} instead of asking a {@code Lazy} value:
-     * <pre>
+     * <pre>ype
      * <code>
      * interface List&lt;T&gt; {
      *

File: src/main/java/javaslang/Value.java
Patch:
@@ -531,7 +531,7 @@ default void out(PrintStream out) {
      * Sends the string representations of this value to the {@link PrintWriter}.
      * If this value consists of multiple elements, each element is displayed in a new line.
      *
-     * @param out The PrintWriter to write to
+     * @param writer The PrintWriter to write to
      * @throws IllegalStateException if {@code PrintWriter.checkError()} is true after writing to writer.
      */
     default void out(PrintWriter writer) {

File: src/main/java/javaslang/Value.java
Patch:
@@ -515,6 +515,7 @@ default void stdout() {
      * Sends the string representations of this value to the {@link PrintStream}.
      * If this value consists of multiple elements, each element is displayed in a new line.
      *
+     * @param out The PrintStream to write to
      * @throws IllegalStateException if {@code PrintStream.checkError()} is true after writing to stream.
      */
     default void out(PrintStream out) {
@@ -530,6 +531,7 @@ default void out(PrintStream out) {
      * Sends the string representations of this value to the {@link PrintWriter}.
      * If this value consists of multiple elements, each element is displayed in a new line.
      *
+     * @param out The PrintWriter to write to
      * @throws IllegalStateException if {@code PrintWriter.checkError()} is true after writing to writer.
      */
     default void out(PrintWriter writer) {

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -602,7 +602,7 @@ private boolean checkPrefix(Traversable<T> t, Traversable<T> prefix) {
      * Tests whether this list starts with the given sequence.
      *
      * @param that the sequence to test
-     * @return true if this collection has that as a prefix, false otherwise.
+     * @return true if that is empty or that is prefix of this collection, false otherwise.
      */
     default boolean startsWith(java.lang.Iterable<? extends T> that) {
         return startsWith(that, 0);
@@ -615,9 +615,9 @@ default boolean startsWith(java.lang.Iterable<? extends T> that) {
      *
      * @param that the sequence to test
      * @param offset the index where the sequence is searched.
-     * @return true if the sequence that is contained in this list at index offset, otherwise false.
+     * @return true if that is empty or that is prefix of this collection starting from the given offset, false otherwise.
      */
-    boolean startsWith(java.lang.Iterable<? extends T> that, int offset);
+    boolean startsWith(Iterable<? extends T> that, int offset);
 
     /**
      * Creates an instance of this type of an {@code java.lang.Iterable}.

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -602,7 +602,7 @@ private boolean checkPrefix(Traversable<T> t, Traversable<T> prefix) {
      * Tests whether this list starts with the given sequence.
      *
      * @param that the sequence to test
-     * @return true if this collection has that as a prefix, false otherwise.
+     * @return true if that is empty or that is prefix of this collection, false otherwise.
      */
     default boolean startsWith(java.lang.Iterable<? extends T> that) {
         return startsWith(that, 0);
@@ -615,9 +615,9 @@ default boolean startsWith(java.lang.Iterable<? extends T> that) {
      *
      * @param that the sequence to test
      * @param offset the index where the sequence is searched.
-     * @return true if the sequence that is contained in this list at index offset, otherwise false.
+     * @return true if that is empty or that is prefix of this collection starting from the given offset, false otherwise.
      */
-    boolean startsWith(java.lang.Iterable<? extends T> that, int offset);
+    boolean startsWith(Iterable<? extends T> that, int offset);
 
     /**
      * Creates an instance of this type of an {@code java.lang.Iterable}.

File: src/main/java/javaslang/collection/Array.java
Patch:
@@ -26,7 +26,7 @@ public final class Array<T> implements IndexedSeq<T>, Serializable {
 
     /**
      * Returns a {@link java.util.stream.Collector} which may be used in conjunction with
-     * {@link java.util.stream.Stream#collect(java.util.stream.Collector)} to obtain a {@link javaslang.collection.Array}s.
+     * {@link java.util.stream.Stream#collect(java.util.stream.Collector)} to obtain a {@link javaslang.collection.Array}.
      *
      * @param <T> Component type of the Vector.
      * @return A {@link javaslang.collection.Array} Collector.

File: src/main/java/javaslang/collection/CharSeq.java
Patch:
@@ -41,7 +41,7 @@ public static CharSeq empty() {
 
     /**
      * Returns a {@link java.util.stream.Collector} which may be used in conjunction with
-     * {@link java.util.stream.Stream#collect(java.util.stream.Collector)} to obtain a {@link CharSeq}s.
+     * {@link java.util.stream.Stream#collect(java.util.stream.Collector)} to obtain a {@link CharSeq}.
      *
      * @return A {@code CharSeq} Collector.
      */

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -84,7 +84,7 @@ public interface List<T> extends LinearSeq<T>, Stack<T> {
 
     /**
      * Returns a {@link java.util.stream.Collector} which may be used in conjunction with
-     * {@link java.util.stream.Stream#collect(java.util.stream.Collector)} to obtain a {@link javaslang.collection.List}s.
+     * {@link java.util.stream.Stream#collect(java.util.stream.Collector)} to obtain a {@link javaslang.collection.List}.
      *
      * @param <T> Component type of the List.
      * @return A javaslang.collection.List Collector.

File: src/main/java/javaslang/collection/RedBlackTree.java
Patch:
@@ -793,5 +793,6 @@ public int hashCode() {
         public String toString() {
             return "()";
         }
+
     }
 }

File: src/main/java/javaslang/collection/Vector.java
Patch:
@@ -48,7 +48,7 @@ public static <T> Vector<T> empty() {
 
     /**
      * Returns a {@link java.util.stream.Collector} which may be used in conjunction with
-     * {@link java.util.stream.Stream#collect(java.util.stream.Collector)} to obtain a {@link javaslang.collection.Vector}s.
+     * {@link java.util.stream.Stream#collect(java.util.stream.Collector)} to obtain a {@link javaslang.collection.Vector}.
      *
      * @param <T> Component type of the Vector.
      * @return A javaslang.collection.List Collector.

File: src/test/java/javaslang/collection/AbstractValueTest.java
Patch:
@@ -65,7 +65,7 @@ protected StringAssert assertThat(String actual) {
     @SuppressWarnings("unchecked")
     abstract protected <T> Value<T> of(T... elements);
 
-    abstract boolean isThisLazyJavaslangObject();
+    abstract boolean useIsEqualToInsteadOfIsSameAs();
 
     // returns the peek result of the specific Traversable implementation
     abstract int getPeekNonNilPerformingAnAction();
@@ -198,7 +198,7 @@ public void shouldFilterNonEmptyTraversable() {
 
     @Test
     public void shouldFilterNonEmptyTraversableAllMatch() {
-        if(isThisLazyJavaslangObject()) {
+        if(useIsEqualToInsteadOfIsSameAs()) {
             final Value<Integer> v1 = of(1, 2, 3, 4);
             final Value<Integer> v2 = of(1, 2, 3, 4);
             assertThat(v1.filter(i -> true)).isEqualTo(v2);

File: src/test/java/javaslang/collection/ArrayTest.java
Patch:
@@ -79,7 +79,7 @@ int getPeekNonNilPerformingAnAction() {
     }
 
     @Override
-    boolean isThisLazyJavaslangObject() {
+    boolean useIsEqualToInsteadOfIsSameAs() {
         return false;
     }
 

File: src/test/java/javaslang/collection/IteratorTest.java
Patch:
@@ -123,7 +123,7 @@ protected Iterator<Short> ofAll(short[] array) {
     }
 
     @Override
-    boolean isThisLazyJavaslangObject() {
+    boolean useIsEqualToInsteadOfIsSameAs() {
         return true;
     }
 

File: src/test/java/javaslang/collection/ListTest.java
Patch:
@@ -181,7 +181,7 @@ public void shouldNotDeserializeListWithSizeLessThanOne() throws Throwable {
     }
 
     @Override
-    boolean isThisLazyJavaslangObject() {
+    boolean useIsEqualToInsteadOfIsSameAs() {
         return false;
     }
 

File: src/test/java/javaslang/collection/QueueTest.java
Patch:
@@ -171,7 +171,7 @@ int getPeekNonNilPerformingAnAction() {
     }
 
     @Override
-    boolean isThisLazyJavaslangObject() {
+    boolean useIsEqualToInsteadOfIsSameAs() {
         return false;
     }
 

File: src/test/java/javaslang/collection/StackTest.java
Patch:
@@ -127,7 +127,7 @@ int getPeekNonNilPerformingAnAction() {
     }
 
     @Override
-    boolean isThisLazyJavaslangObject() {
+    boolean useIsEqualToInsteadOfIsSameAs() {
         return false;
     }
 

File: src/test/java/javaslang/collection/StreamTest.java
Patch:
@@ -326,7 +326,7 @@ public void shouldNotDeserializeStreamWithSizeLessThanOne() throws Throwable {
     }
 
     @Override
-    boolean isThisLazyJavaslangObject() {
+    boolean useIsEqualToInsteadOfIsSameAs() {
         return true;
     }
 

File: src/test/java/javaslang/collection/VectorTest.java
Patch:
@@ -85,7 +85,7 @@ int getPeekNonNilPerformingAnAction() {
     }
 
     @Override
-    boolean isThisLazyJavaslangObject() {
+    boolean useIsEqualToInsteadOfIsSameAs() {
         return false;
     }
 

File: src/main/java/javaslang/collection/TreeSet.java
Patch:
@@ -807,7 +807,7 @@ private static <T, U> Comparator<Tuple2<T, U>> tuple2Comparator(Comparator<? sup
      * Please note that this will lead to runtime exceptions, if U is not Comparable.
      *
      * @param <U> The type
-     * @return
+     * @return The natural Comparator of type U
      */
     @SuppressWarnings("unchecked")
     private static <U> Comparator<? super U> naturalComparator() {

File: src/main/java/javaslang/collection/package-info.java
Patch:
@@ -23,7 +23,7 @@
  *         <tr><td>{@linkplain javaslang.collection.List}</td><td><small>const</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
  *         <tr><td>{@linkplain javaslang.collection.Queue}</td><td><small>const</small></td><td><small>const<sup>a</sup></small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>const</small></td><td><small>const</small></td><td><small>linear</small></td></tr>
  *         <tr><td>{@linkplain javaslang.collection.Stream}</td><td><small>const</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>const<sup>lazy</sup></small></td><td><small>const<sup>lazy</sup></small></td><td><small>linear</small></td></tr>
- *         <tr><td>{@linkplain javaslang.collection.Vector}</td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td></tr>
+ *         <tr><td>{@linkplain javaslang.collection.Vector}</td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td></tr>
  *     </tbody>
  * </table>
  * <br>

File: src/main/java/javaslang/collection/package-info.java
Patch:
@@ -23,7 +23,7 @@
  *         <tr><td>{@linkplain javaslang.collection.List}</td><td><small>const</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
  *         <tr><td>{@linkplain javaslang.collection.Queue}</td><td><small>const</small></td><td><small>const<sup>a</sup></small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>const</small></td><td><small>const</small></td><td><small>linear</small></td></tr>
  *         <tr><td>{@linkplain javaslang.collection.Stream}</td><td><small>const</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>const<sup>lazy</sup></small></td><td><small>const<sup>lazy</sup></small></td><td><small>linear</small></td></tr>
- *         <tr><td>{@linkplain javaslang.collection.Vector}</td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td></tr>
+ *         <tr><td>{@linkplain javaslang.collection.Vector}</td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td></tr>
  *     </tbody>
  * </table>
  * <br>

File: src/main/java/javaslang/collection/package-info.java
Patch:
@@ -23,7 +23,7 @@
  *         <tr><td>{@linkplain javaslang.collection.List}</td><td><small>const</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td></tr>
  *         <tr><td>{@linkplain javaslang.collection.Queue}</td><td><small>const</small></td><td><small>const<sup>a</sup></small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>const</small></td><td><small>const</small></td><td><small>linear</small></td></tr>
  *         <tr><td>{@linkplain javaslang.collection.Stream}</td><td><small>const</small></td><td><small>const</small></td><td><small>linear</small></td><td><small>linear</small></td><td><small>const<sup>lazy</sup></small></td><td><small>const<sup>lazy</sup></small></td><td><small>linear</small></td></tr>
- *         <tr><td>{@linkplain javaslang.collection.Vector}</td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td></tr>
+ *         <tr><td>{@linkplain javaslang.collection.Vector}</td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td><td><small>const<sup>eff</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</sup></small></td><td><small>const<sup>eff</sup></small></td><td><small>linear</small></td></tr>
  *     </tbody>
  * </table>
  * <br>

File: src/main/java/javaslang/Iterable.java
Patch:
@@ -60,7 +60,7 @@ default <U> boolean corresponds(java.lang.Iterable<U> that, BiPredicate<T, U> pr
      * Example:
      *
      * <pre><code>
-     * // ((1, 2), ((3))) => structure: (()(())) values: 1, 2, 3
+     * // ((1, 2), ((3))) =&gt; structure: (()(())) values: 1, 2, 3
      * final Iterable&lt;?&gt; i1 = List.of(List.of(1, 2), Arrays.asList(List.of(3)));
      * final Iterable&lt;?&gt; i2 = Queue.of(Stream.of(1, 2), List.of(Lazy.of(() -> 3)));
      * assertThat(i1.eq(i2)).isTrue();

File: src/test/java/javaslang/collection/IteratorTest.java
Patch:
@@ -3,7 +3,6 @@
 import javaslang.Tuple;
 import javaslang.Tuple2;
 import javaslang.control.Option;
-import javaslang.control.Some;
 import org.assertj.core.api.Assertions;
 import org.assertj.core.api.IterableAssert;
 import org.assertj.core.api.ObjectAssert;
@@ -29,6 +28,7 @@ public IterableAssert<T> isEqualTo(Object expected) {
                 }
             }
 
+            @SuppressWarnings("unchecked")
             private Option<?> wrapIterator(Option<?> option) {
                 return option.map(o -> (o instanceof Iterator) ? List.ofAll((Iterator) o) : o);
             }

File: src/main/java/javaslang/Iterable.java
Patch:
@@ -33,6 +33,7 @@ public interface Iterable<T> extends java.lang.Iterable<T> {
      * Tests whether every element of this iterable relates to the corresponding element of another iterable by
      * satisfying a test predicate.
      *
+     * @param <U> Component type of that iterable
      * @param that      the other iterable
      * @param predicate the test predicate, which relates elements from both iterables
      * @return {@code true} if both iterables have the same length and {@code predicate(x, y)}
@@ -53,7 +54,7 @@ default <U> boolean corresponds(java.lang.Iterable<U> that, BiPredicate<T, U> pr
     /**
      * A <em>smoothing</em> replacement for {@code equals}. It is similar to Scala's {@code ==} but better in the way
      * that it is not limited to collection types, e.g. `Some(1) eq List(1)`, `None eq Failure(x)` etc.
-     * <p>
+     *
      * <pre><code>
      * o == this                       : true
      * o instanceof javaslang.Iterable : all iterable elements (this or that) are eq, all non-iterable elements are equal

File: src/main/java/javaslang/collection/RedBlackTree.java
Patch:
@@ -189,7 +189,7 @@ default RedBlackTree<T> union(RedBlackTree<T> tree) {
      *     2   6
      *    / \ / \
      *   1  3 5  7
-     * </code></post>
+     * </code></pre>
      *
      * Iteration order: 1, 2, 3, 4, 5, 6, 7
      * <p>

File: src/test/java/javaslang/LazyTest.java
Patch:
@@ -5,6 +5,7 @@
  */
 package javaslang;
 
+import javaslang.collection.AbstractValueTest;
 import javaslang.collection.List;
 import org.junit.Test;
 

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -443,7 +443,7 @@ public boolean equals(Object o) {
             return true;
         } else if (o instanceof HashMap) {
             final HashMap<?,?> that = (HashMap<?,?>) o;
-            return this.iterator().equals(that.iterator());
+            return this.corresponds(that, Objects::equals);
         } else {
             return false;
         }

File: src/test/java/javaslang/collection/AbstractValueTest.java
Patch:
@@ -5,6 +5,7 @@
  */
 package javaslang.collection;
 
+import javaslang.AbstractIterableTest;
 import javaslang.Lazy;
 import javaslang.Tuple;
 import javaslang.Value;
@@ -22,7 +23,7 @@
 /**
  * Tests all methods defined in {@link Traversable}.
  */
-public abstract class AbstractValueTest {
+public abstract class AbstractValueTest extends AbstractIterableTest {
 
     protected <T> IterableAssert<T> assertThat(java.lang.Iterable<T> actual) {
         return new IterableAssert<T>(actual) {

File: src/main/java/javaslang/collection/Iterator.java
Patch:
@@ -1068,7 +1068,7 @@ default Iterator<Object> flatten() {
     @Override
     default <U> U foldRight(U zero, BiFunction<? super T, ? super U, ? extends U> f) {
         Objects.requireNonNull(f, "f is null");
-        return Stream.ofAll(this).reverse().foldRight(zero, f::apply);
+        return Stream.ofAll(this).foldRight(zero, f::apply);
     }
 
     @Override

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -726,8 +726,7 @@ default T reduceRight(BiFunction<? super T, ? super T, ? extends T> op) {
         if (isEmpty()) {
             throw new NoSuchElementException("reduceRight on Nil");
         } else {
-            final Seq<T> reversed = reverse();
-            return reversed.tail().foldLeft(reversed.head(), (xs, x) -> op.apply(x, xs));
+            return iterator().reduceRight(op);
         }
     }
 

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -726,8 +726,7 @@ default T reduceRight(BiFunction<? super T, ? super T, ? extends T> op) {
         if (isEmpty()) {
             throw new NoSuchElementException("reduceRight on Nil");
         } else {
-            final Seq<T> reversed = reverse();
-            return reversed.tail().foldLeft(reversed.head(), (xs, x) -> op.apply(x, xs));
+            return iterator().reduceRight(op);
         }
     }
 

File: src-gen/test/java/javaslang/CheckedFunction0Test.java
Patch:
@@ -101,6 +101,7 @@ public void shouldComposeWithAndThen() {
     public void shouldGetType() {
         final CheckedFunction0<Integer> f = () -> null;
         final CheckedFunction0.Type<Integer> type = f.getType();
+
         assertThat(type.toString()).isEqualTo("() -> java.lang.Integer");
     }
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction1Test.java
Patch:
@@ -137,6 +137,7 @@ public void shouldComposeWithCompose() {
     public void shouldGetType() {
         final CheckedFunction1<Integer, Integer> f = (i1) -> null;
         final CheckedFunction1.Type<Integer, Integer> type = f.getType();
+        assertThat(type.parameterType1()).isEqualTo(Integer.class);
         assertThat(type.toString()).isEqualTo("(java.lang.Integer) -> java.lang.Integer");
     }
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction2Test.java
Patch:
@@ -135,6 +135,8 @@ public void shouldComposeWithAndThen() {
     public void shouldGetType() {
         final CheckedFunction2<Integer, Integer, Integer> f = (i1, i2) -> null;
         final CheckedFunction2.Type<Integer, Integer, Integer> type = f.getType();
+        assertThat(type.parameterType1()).isEqualTo(Integer.class);
+        assertThat(type.parameterType2()).isEqualTo(Integer.class);
         assertThat(type.toString()).isEqualTo("(java.lang.Integer, java.lang.Integer) -> java.lang.Integer");
     }
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction3Test.java
Patch:
@@ -141,6 +141,9 @@ public void shouldComposeWithAndThen() {
     public void shouldGetType() {
         final CheckedFunction3<Integer, Integer, Integer, Integer> f = (i1, i2, i3) -> null;
         final CheckedFunction3.Type<Integer, Integer, Integer, Integer> type = f.getType();
+        assertThat(type.parameterType1()).isEqualTo(Integer.class);
+        assertThat(type.parameterType2()).isEqualTo(Integer.class);
+        assertThat(type.parameterType3()).isEqualTo(Integer.class);
         assertThat(type.toString()).isEqualTo("(java.lang.Integer, java.lang.Integer, java.lang.Integer) -> java.lang.Integer");
     }
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function0Test.java
Patch:
@@ -101,6 +101,7 @@ public void shouldComposeWithAndThen() {
     public void shouldGetType() {
         final Function0<Integer> f = () -> null;
         final Function0.Type<Integer> type = f.getType();
+
         assertThat(type.toString()).isEqualTo("() -> java.lang.Integer");
     }
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function1Test.java
Patch:
@@ -137,6 +137,7 @@ public void shouldComposeWithCompose() {
     public void shouldGetType() {
         final Function1<Integer, Integer> f = (i1) -> null;
         final Function1.Type<Integer, Integer> type = f.getType();
+        assertThat(type.parameterType1()).isEqualTo(Integer.class);
         assertThat(type.toString()).isEqualTo("(java.lang.Integer) -> java.lang.Integer");
     }
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function2Test.java
Patch:
@@ -135,6 +135,8 @@ public void shouldComposeWithAndThen() {
     public void shouldGetType() {
         final Function2<Integer, Integer, Integer> f = (i1, i2) -> null;
         final Function2.Type<Integer, Integer, Integer> type = f.getType();
+        assertThat(type.parameterType1()).isEqualTo(Integer.class);
+        assertThat(type.parameterType2()).isEqualTo(Integer.class);
         assertThat(type.toString()).isEqualTo("(java.lang.Integer, java.lang.Integer) -> java.lang.Integer");
     }
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function3Test.java
Patch:
@@ -141,6 +141,9 @@ public void shouldComposeWithAndThen() {
     public void shouldGetType() {
         final Function3<Integer, Integer, Integer, Integer> f = (i1, i2, i3) -> null;
         final Function3.Type<Integer, Integer, Integer, Integer> type = f.getType();
+        assertThat(type.parameterType1()).isEqualTo(Integer.class);
+        assertThat(type.parameterType2()).isEqualTo(Integer.class);
+        assertThat(type.parameterType3()).isEqualTo(Integer.class);
         assertThat(type.toString()).isEqualTo("(java.lang.Integer, java.lang.Integer, java.lang.Integer) -> java.lang.Integer");
     }
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction0Test.java
Patch:
@@ -101,6 +101,7 @@ public void shouldComposeWithAndThen() {
     public void shouldGetType() {
         final CheckedFunction0<Integer> f = () -> null;
         final CheckedFunction0.Type<Integer> type = f.getType();
+
         assertThat(type.toString()).isEqualTo("() -> java.lang.Integer");
     }
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction1Test.java
Patch:
@@ -137,6 +137,7 @@ public void shouldComposeWithCompose() {
     public void shouldGetType() {
         final CheckedFunction1<Integer, Integer> f = (i1) -> null;
         final CheckedFunction1.Type<Integer, Integer> type = f.getType();
+        assertThat(type.parameterType1()).isEqualTo(Integer.class);
         assertThat(type.toString()).isEqualTo("(java.lang.Integer) -> java.lang.Integer");
     }
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction2Test.java
Patch:
@@ -135,6 +135,8 @@ public void shouldComposeWithAndThen() {
     public void shouldGetType() {
         final CheckedFunction2<Integer, Integer, Integer> f = (i1, i2) -> null;
         final CheckedFunction2.Type<Integer, Integer, Integer> type = f.getType();
+        assertThat(type.parameterType1()).isEqualTo(Integer.class);
+        assertThat(type.parameterType2()).isEqualTo(Integer.class);
         assertThat(type.toString()).isEqualTo("(java.lang.Integer, java.lang.Integer) -> java.lang.Integer");
     }
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction3Test.java
Patch:
@@ -141,6 +141,9 @@ public void shouldComposeWithAndThen() {
     public void shouldGetType() {
         final CheckedFunction3<Integer, Integer, Integer, Integer> f = (i1, i2, i3) -> null;
         final CheckedFunction3.Type<Integer, Integer, Integer, Integer> type = f.getType();
+        assertThat(type.parameterType1()).isEqualTo(Integer.class);
+        assertThat(type.parameterType2()).isEqualTo(Integer.class);
+        assertThat(type.parameterType3()).isEqualTo(Integer.class);
         assertThat(type.toString()).isEqualTo("(java.lang.Integer, java.lang.Integer, java.lang.Integer) -> java.lang.Integer");
     }
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function0Test.java
Patch:
@@ -101,6 +101,7 @@ public void shouldComposeWithAndThen() {
     public void shouldGetType() {
         final Function0<Integer> f = () -> null;
         final Function0.Type<Integer> type = f.getType();
+
         assertThat(type.toString()).isEqualTo("() -> java.lang.Integer");
     }
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function1Test.java
Patch:
@@ -137,6 +137,7 @@ public void shouldComposeWithCompose() {
     public void shouldGetType() {
         final Function1<Integer, Integer> f = (i1) -> null;
         final Function1.Type<Integer, Integer> type = f.getType();
+        assertThat(type.parameterType1()).isEqualTo(Integer.class);
         assertThat(type.toString()).isEqualTo("(java.lang.Integer) -> java.lang.Integer");
     }
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function2Test.java
Patch:
@@ -135,6 +135,8 @@ public void shouldComposeWithAndThen() {
     public void shouldGetType() {
         final Function2<Integer, Integer, Integer> f = (i1, i2) -> null;
         final Function2.Type<Integer, Integer, Integer> type = f.getType();
+        assertThat(type.parameterType1()).isEqualTo(Integer.class);
+        assertThat(type.parameterType2()).isEqualTo(Integer.class);
         assertThat(type.toString()).isEqualTo("(java.lang.Integer, java.lang.Integer) -> java.lang.Integer");
     }
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function3Test.java
Patch:
@@ -141,6 +141,9 @@ public void shouldComposeWithAndThen() {
     public void shouldGetType() {
         final Function3<Integer, Integer, Integer, Integer> f = (i1, i2, i3) -> null;
         final Function3.Type<Integer, Integer, Integer, Integer> type = f.getType();
+        assertThat(type.parameterType1()).isEqualTo(Integer.class);
+        assertThat(type.parameterType2()).isEqualTo(Integer.class);
+        assertThat(type.parameterType3()).isEqualTo(Integer.class);
         assertThat(type.toString()).isEqualTo("(java.lang.Integer, java.lang.Integer, java.lang.Integer) -> java.lang.Integer");
     }
 }
\ No newline at end of file

File: src/main/java/javaslang/collection/CharSeq.java
Patch:
@@ -395,7 +395,7 @@ public CharSeq padTo(int length, Character element) {
     }
 
     @Override
-    public Seq<Character> patch(int from, java.lang.Iterable<? extends Character> that, int replaced) {
+    public CharSeq patch(int from, java.lang.Iterable<? extends Character> that, int replaced) {
         from = from < 0 ? 0 : from > length() ? length() : from;
         replaced = replaced < 0 ? 0 : replaced;
         final StringBuilder sb = new StringBuilder(back.substring(0, from));

File: src/main/java/javaslang/collection/IndexedSeq.java
Patch:
@@ -99,6 +99,9 @@ public interface IndexedSeq<T> extends Seq<T> {
     @Override
     IndexedSeq<T> padTo(int length, T element);
 
+    @Override
+    IndexedSeq<T> patch(int from, java.lang.Iterable<? extends T> that, int replaced);
+
     @Override
     Tuple2<? extends IndexedSeq<T>, ? extends IndexedSeq<T>> partition(Predicate<? super T> predicate);
 

File: src/main/java/javaslang/collection/LinearSeq.java
Patch:
@@ -98,6 +98,9 @@ public interface LinearSeq<T> extends Seq<T> {
     @Override
     LinearSeq<T> padTo(int length, T element);
 
+    @Override
+    LinearSeq<T> patch(int from, java.lang.Iterable<? extends T> that, int replaced);
+
     @Override
     Tuple2<? extends LinearSeq<T>, ? extends LinearSeq<T>> partition(Predicate<? super T> predicate);
 

File: src/main/java/javaslang/collection/Stack.java
Patch:
@@ -533,6 +533,9 @@ static Stack<Long> rangeClosedBy(long from, long toInclusive, long step) {
     @Override
     Stack<T> padTo(int length, T element);
 
+    @Override
+    Stack<T> patch(int from, java.lang.Iterable<? extends T> that, int replaced);
+
     @Override
     Tuple2<? extends Stack<T>, ? extends Stack<T>> partition(Predicate<? super T> predicate);
 

File: src/main/java/javaslang/Lazy.java
Patch:
@@ -7,7 +7,9 @@
 
 import javaslang.collection.Iterator;
 
-import java.io.*;
+import java.io.IOException;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Proxy;
 import java.util.NoSuchElementException;

File: src/main/java/javaslang/collection/Array.java
Patch:
@@ -5,7 +5,9 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Lazy;
+import javaslang.Tuple;
+import javaslang.Tuple2;
 import javaslang.control.None;
 import javaslang.control.Option;
 import javaslang.control.Some;

File: src/main/java/javaslang/collection/CharSeq.java
Patch:
@@ -5,14 +5,14 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Tuple;
+import javaslang.Tuple2;
 import javaslang.control.None;
 import javaslang.control.Option;
 import javaslang.control.Some;
 
 import java.io.Serializable;
 import java.io.UnsupportedEncodingException;
-import java.lang.Iterable;
 import java.nio.charset.Charset;
 import java.util.*;
 import java.util.HashSet;

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -5,7 +5,8 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Lazy;
+import javaslang.Tuple2;
 import javaslang.control.Option;
 
 import java.io.Serializable;

File: src/main/java/javaslang/collection/HashSet.java
Patch:
@@ -5,7 +5,9 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Lazy;
+import javaslang.Tuple;
+import javaslang.Tuple2;
 import javaslang.control.None;
 import javaslang.control.Option;
 import javaslang.control.Some;

File: src/main/java/javaslang/collection/IndexedSeq.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Tuple2;
 import javaslang.control.Option;
 
 import java.util.Comparator;

File: src/main/java/javaslang/collection/LinearSeq.java
Patch:
@@ -6,7 +6,6 @@
 package javaslang.collection;
 
 import javaslang.Tuple2;
-import javaslang.Value;
 import javaslang.control.Option;
 
 import java.util.Comparator;

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -8,7 +8,6 @@
 import javaslang.Lazy;
 import javaslang.Tuple;
 import javaslang.Tuple2;
-import javaslang.Value;
 import javaslang.control.None;
 import javaslang.control.Option;
 import javaslang.control.Some;

File: src/main/java/javaslang/collection/Map.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Tuple2;
 import javaslang.control.Option;
 
 import java.io.Serializable;

File: src/main/java/javaslang/collection/Queue.java
Patch:
@@ -5,13 +5,14 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Lazy;
+import javaslang.Tuple;
+import javaslang.Tuple2;
 import javaslang.control.None;
 import javaslang.control.Option;
 import javaslang.control.Some;
 
 import java.io.Serializable;
-import java.lang.Iterable;
 import java.util.*;
 import java.util.function.*;
 import java.util.stream.Collector;

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -5,7 +5,8 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Tuple;
+import javaslang.Tuple2;
 import javaslang.control.Option;
 
 import java.util.Comparator;

File: src/main/java/javaslang/collection/Set.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Tuple2;
 import javaslang.control.Option;
 
 import java.util.Comparator;

File: src/main/java/javaslang/collection/SortedMap.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Tuple2;
 import javaslang.control.Option;
 
 import java.util.Comparator;

File: src/main/java/javaslang/collection/SortedSet.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Tuple2;
 import javaslang.control.Option;
 
 import java.util.Comparator;

File: src/main/java/javaslang/collection/Stack.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Tuple2;
 import javaslang.control.Option;
 
 import java.util.ArrayList;

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -5,13 +5,14 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Lazy;
+import javaslang.Tuple;
+import javaslang.Tuple2;
 import javaslang.control.None;
 import javaslang.control.Option;
 import javaslang.control.Some;
 
 import java.io.*;
-import java.lang.Iterable;
 import java.util.*;
 import java.util.function.*;
 import java.util.stream.Collector;

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Tuple2;
 import javaslang.control.Option;
 
 import java.util.Comparator;

File: src/main/java/javaslang/collection/TraversableOnce.java
Patch:
@@ -5,7 +5,8 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Tuple2;
+import javaslang.Value;
 import javaslang.control.Match;
 import javaslang.control.None;
 import javaslang.control.Option;

File: src/main/java/javaslang/collection/Tree.java
Patch:
@@ -5,7 +5,9 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Lazy;
+import javaslang.Tuple;
+import javaslang.Tuple2;
 import javaslang.control.Match;
 import javaslang.control.None;
 import javaslang.control.Option;

File: src/main/java/javaslang/collection/TreeSet.java
Patch:
@@ -6,7 +6,6 @@
 package javaslang.collection;
 
 import javaslang.Tuple2;
-import javaslang.Value;
 import javaslang.control.Option;
 
 import java.io.Serializable;

File: src/main/java/javaslang/collection/Vector.java
Patch:
@@ -5,7 +5,9 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Lazy;
+import javaslang.Tuple;
+import javaslang.Tuple2;
 import javaslang.control.None;
 import javaslang.control.Option;
 import javaslang.control.Some;

File: src/main/java/javaslang/control/Failure.java
Patch:
@@ -6,7 +6,6 @@
 package javaslang.control;
 
 import javaslang.CheckedFunction1;
-import javaslang.Value;
 
 import java.io.Serializable;
 import java.util.Objects;

File: src/main/java/javaslang/control/None.java
Patch:
@@ -5,8 +5,6 @@
  */
 package javaslang.control;
 
-import javaslang.Value;
-
 import java.io.Serializable;
 import java.util.NoSuchElementException;
 import java.util.Objects;

File: src/test/java/javaslang/collection/AbstractSeqTest.java
Patch:
@@ -5,7 +5,8 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Tuple;
+import javaslang.Tuple2;
 import org.junit.Test;
 
 import java.util.ArrayList;

File: src/test/java/javaslang/collection/AbstractTraversableTest.java
Patch:
@@ -5,7 +5,8 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Tuple;
+import javaslang.Value;
 import javaslang.control.None;
 import javaslang.control.Option;
 import javaslang.control.Some;

File: src/test/java/javaslang/collection/CharSeqTest.java
Patch:
@@ -1,6 +1,7 @@
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Tuple;
+import javaslang.Tuple2;
 import javaslang.control.None;
 import javaslang.control.Option;
 import javaslang.control.Some;

File: src/test/java/javaslang/collection/ListTest.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Serializables;
 import org.junit.Test;
 
 import java.io.InvalidObjectException;

File: src/test/java/javaslang/collection/StreamTest.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Serializables;
 import javaslang.collection.Stream.Cons;
 import javaslang.collection.Stream.Nil;
 import org.junit.Test;
@@ -15,8 +15,6 @@
 import java.util.function.Function;
 import java.util.stream.Collector;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 public class StreamTest extends AbstractSeqTest {
 
     // -- construction

File: src/test/java/javaslang/collection/StringTest.java
Patch:
@@ -8,7 +8,6 @@
 import org.junit.Test;
 
 import java.io.UnsupportedEncodingException;
-import java.lang.Iterable;
 import java.nio.charset.Charset;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: src/test/java/javaslang/collection/VectorTest.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.collection;
 
-import javaslang.*;
+import javaslang.Serializables;
 import org.junit.Test;
 
 import java.io.InvalidObjectException;

File: src/main/java/javaslang/collection/CharSeq.java
Patch:
@@ -863,7 +863,7 @@ public Tuple2<CharSeq, CharSeq> splitAtInclusive(Predicate<? super Character> pr
     }
 
     @Override
-    public boolean startsWidth(Iterable<? extends Character> that, int offset) {
+    public boolean startsWith(Iterable<? extends Character> that, int offset) {
         return startsWith(CharSeq.ofAll(that), offset);
     }
 

File: src/main/java/javaslang/collection/IndexedSeq.java
Patch:
@@ -166,7 +166,7 @@ public interface IndexedSeq<T> extends Seq<T> {
     Tuple2<? extends IndexedSeq<T>, ? extends IndexedSeq<T>> span(Predicate<? super T> predicate);
 
     @Override
-    default boolean startsWidth(java.lang.Iterable<? extends T> that, int offset) {
+    default boolean startsWith(java.lang.Iterable<? extends T> that, int offset) {
         if (offset > length()) {
             return false;
         }

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -1387,12 +1387,12 @@ public Tuple2<List<T>, List<T>> splitAtInclusive(Predicate<? super T> predicate)
         }
 
         @Override
-        public boolean startsWidth(Iterable<? extends T> that, int offset) {
+        public boolean startsWith(Iterable<? extends T> that, int offset) {
             if (offset > 0) {
                 if (offset > length()) {
                     return false;
                 } else {
-                    return drop(offset).startsWidth(that);
+                    return drop(offset).startsWith(that);
                 }
             }
             final java.util.Iterator<? extends T> it = that.iterator();
@@ -1688,7 +1688,7 @@ public Tuple2<List<T>, List<T>> splitAtInclusive(Predicate<? super T> predicate)
         }
 
         @Override
-        public boolean startsWidth(Iterable<? extends T> that, int offset) {
+        public boolean startsWith(Iterable<? extends T> that, int offset) {
             return offset == 0 && !that.iterator().hasNext();
         }
 

File: src/main/java/javaslang/collection/Queue.java
Patch:
@@ -919,8 +919,8 @@ public Tuple2<Queue<T>, Queue<T>> splitAtInclusive(Predicate<? super T> predicat
     }
 
     @Override
-    public boolean startsWidth(Iterable<? extends T> that, int offset) {
-        return toList().startsWidth(that, offset);
+    public boolean startsWith(Iterable<? extends T> that, int offset) {
+        return toList().startsWith(that, offset);
     }
 
     @Override

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -612,8 +612,8 @@ private boolean checkPrefix(Traversable<T> t, Traversable<T> prefix) {
      * @param that the sequence to test
      * @return true if this collection has that as a prefix, false otherwise.
      */
-    default boolean startsWidth(java.lang.Iterable<? extends T> that) {
-        return startsWidth(that, 0);
+    default boolean startsWith(java.lang.Iterable<? extends T> that) {
+        return startsWith(that, 0);
     }
 
     /**
@@ -625,7 +625,7 @@ default boolean startsWidth(java.lang.Iterable<? extends T> that) {
      * @param offset the index where the sequence is searched.
      * @return true if the sequence that is contained in this list at index offset, otherwise false.
      */
-    boolean startsWidth(java.lang.Iterable<? extends T> that, int offset);
+    boolean startsWith(java.lang.Iterable<? extends T> that, int offset);
 
     /**
      * Creates an instance of this type of an {@code java.lang.Iterable}.

File: src/main/java/javaslang/collection/CharSeq.java
Patch:
@@ -863,7 +863,7 @@ public Tuple2<CharSeq, CharSeq> splitAtInclusive(Predicate<? super Character> pr
     }
 
     @Override
-    public boolean startsWidth(Iterable<? extends Character> that, int offset) {
+    public boolean startsWith(Iterable<? extends Character> that, int offset) {
         return startsWith(CharSeq.ofAll(that), offset);
     }
 

File: src/main/java/javaslang/collection/IndexedSeq.java
Patch:
@@ -166,7 +166,7 @@ public interface IndexedSeq<T> extends Seq<T> {
     Tuple2<? extends IndexedSeq<T>, ? extends IndexedSeq<T>> span(Predicate<? super T> predicate);
 
     @Override
-    default boolean startsWidth(java.lang.Iterable<? extends T> that, int offset) {
+    default boolean startsWith(java.lang.Iterable<? extends T> that, int offset) {
         if (offset > length()) {
             return false;
         }

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -1387,12 +1387,12 @@ public Tuple2<List<T>, List<T>> splitAtInclusive(Predicate<? super T> predicate)
         }
 
         @Override
-        public boolean startsWidth(Iterable<? extends T> that, int offset) {
+        public boolean startsWith(Iterable<? extends T> that, int offset) {
             if (offset > 0) {
                 if (offset > length()) {
                     return false;
                 } else {
-                    return drop(offset).startsWidth(that);
+                    return drop(offset).startsWith(that);
                 }
             }
             final java.util.Iterator<? extends T> it = that.iterator();
@@ -1688,7 +1688,7 @@ public Tuple2<List<T>, List<T>> splitAtInclusive(Predicate<? super T> predicate)
         }
 
         @Override
-        public boolean startsWidth(Iterable<? extends T> that, int offset) {
+        public boolean startsWith(Iterable<? extends T> that, int offset) {
             return offset == 0 && !that.iterator().hasNext();
         }
 

File: src/main/java/javaslang/collection/Queue.java
Patch:
@@ -919,8 +919,8 @@ public Tuple2<Queue<T>, Queue<T>> splitAtInclusive(Predicate<? super T> predicat
     }
 
     @Override
-    public boolean startsWidth(Iterable<? extends T> that, int offset) {
-        return toList().startsWidth(that, offset);
+    public boolean startsWith(Iterable<? extends T> that, int offset) {
+        return toList().startsWith(that, offset);
     }
 
     @Override

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -612,8 +612,8 @@ private boolean checkPrefix(Traversable<T> t, Traversable<T> prefix) {
      * @param that the sequence to test
      * @return true if this collection has that as a prefix, false otherwise.
      */
-    default boolean startsWidth(java.lang.Iterable<? extends T> that) {
-        return startsWidth(that, 0);
+    default boolean startsWith(java.lang.Iterable<? extends T> that) {
+        return startsWith(that, 0);
     }
 
     /**
@@ -625,7 +625,7 @@ default boolean startsWidth(java.lang.Iterable<? extends T> that) {
      * @param offset the index where the sequence is searched.
      * @return true if the sequence that is contained in this list at index offset, otherwise false.
      */
-    boolean startsWidth(java.lang.Iterable<? extends T> that, int offset);
+    boolean startsWith(java.lang.Iterable<? extends T> that, int offset);
 
     /**
      * Creates an instance of this type of an {@code java.lang.Iterable}.

File: src/main/java/javaslang/collection/HashArrayMappedTrie.java
Patch:
@@ -20,7 +20,7 @@
  *
  * @since 2.0.0
  */
-public interface HashArrayMappedTrie<K, V> extends Iterable<Tuple2<K, V>> {
+public interface HashArrayMappedTrie<K, V> extends java.lang.Iterable<Tuple2<K, V>> {
 
     static <K, V> HashArrayMappedTrie<K, V> empty() {
         return EmptyNode.instance();

File: src/test/java/javaslang/collection/AbstractValueTest.java
Patch:
@@ -17,7 +17,7 @@
  */
 public abstract class AbstractValueTest {
 
-    protected <T> IterableAssert<T> assertThat(Iterable<T> actual) {
+    protected <T> IterableAssert<T> assertThat(java.lang.Iterable<T> actual) {
         return new IterableAssert<T>(actual) {
         };
     }
@@ -61,7 +61,7 @@ protected StringAssert assertThat(String actual) {
     @SuppressWarnings("unchecked")
     abstract protected <T> Value<T> of(T... elements);
 
-    abstract protected <T> Value<T> ofAll(Iterable<? extends T> elements);
+    abstract protected <T> Value<T> ofAll(java.lang.Iterable<? extends T> elements);
 
     abstract protected Value<Boolean> ofAll(boolean[] array);
 

File: src/test/java/javaslang/collection/IteratorTest.java
Patch:
@@ -9,12 +9,12 @@
 
 public class IteratorTest extends AbstractValueTest {
 
-    protected <T> IterableAssert<T> assertThat(Iterable<T> actual) {
+    protected <T> IterableAssert<T> assertThat(java.lang.Iterable<T> actual) {
         return new IterableAssert<T>(actual) {
             @Override
             public IterableAssert<T> isEqualTo(Object obj) {
                 @SuppressWarnings("unchecked")
-                Iterable<T> expected = (Iterable<T>) obj;
+                java.lang.Iterable<T> expected = (java.lang.Iterable<T>) obj;
                 Assertions.assertThat(List.ofAll(actual)).isEqualTo(List.ofAll(expected));
                 return this;
             }
@@ -61,7 +61,7 @@ protected <T> Iterator<T> of(T... elements) {
     }
 
     @Override
-    protected <T> Iterator<T> ofAll(Iterable<? extends T> elements) {
+    protected <T> Iterator<T> ofAll(java.lang.Iterable<? extends T> elements) {
         return Iterator.ofAll(elements);
     }
 

File: src/test/java/javaslang/collection/ListTest.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.collection;
 
-import javaslang.Serializables;
+import javaslang.*;
 import org.junit.Test;
 
 import java.io.InvalidObjectException;
@@ -38,7 +38,7 @@ protected <T> List<T> of(T... elements) {
     }
 
     @Override
-    protected <T> List<T> ofAll(Iterable<? extends T> elements) {
+    protected <T> List<T> ofAll(java.lang.Iterable<? extends T> elements) {
         return List.ofAll(elements);
     }
 

File: src/test/java/javaslang/collection/QueueTest.java
Patch:
@@ -42,7 +42,7 @@ protected final <T> Queue<T> of(T... elements) {
     }
 
     @Override
-    protected <T> Queue<T> ofAll(Iterable<? extends T> elements) {
+    protected <T> Queue<T> ofAll(java.lang.Iterable<? extends T> elements) {
         return Queue.ofAll(elements);
     }
 

File: src/test/java/javaslang/collection/StackTest.java
Patch:
@@ -35,7 +35,7 @@ protected final <T> Stack<T> of(T... elements) {
     }
 
     @Override
-    protected <T> Stack<T> ofAll(Iterable<? extends T> elements) {
+    protected <T> Stack<T> ofAll(java.lang.Iterable<? extends T> elements) {
         return Stack.ofAll(elements);
     }
 

File: src/test/java/javaslang/collection/VectorTest.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.collection;
 
-import javaslang.Serializables;
+import javaslang.*;
 import org.junit.Test;
 
 import java.io.InvalidObjectException;
@@ -35,7 +35,7 @@ protected <T> Vector<T> of(T... elements) {
     }
 
     @Override
-    protected <T> Vector<T> ofAll(Iterable<? extends T> elements) {
+    protected <T> Vector<T> ofAll(java.lang.Iterable<? extends T> elements) {
         return Vector.ofAll(elements);
     }
 

File: src/test/java/javaslang/collection/euler/Euler08Test.java
Patch:
@@ -5,6 +5,7 @@
  */
 package javaslang.collection.euler;
 
+import javaslang.collection.IndexedSeq;
 import javaslang.collection.List;
 import org.junit.Test;
 
@@ -54,7 +55,7 @@ public void shouldSolveProblem8() {
     private static long largestProductOfConsecutives(int sizeOfConsecutive, String num) {
         return digits(num)
                 .sliding(sizeOfConsecutive)
-                .map(List::product)
+                .map(IndexedSeq::product)
                 .max().get().longValue();
     }
 

File: src/main/java/javaslang/collection/TraversableOnce.java
Patch:
@@ -452,7 +452,7 @@ default T get() {
     @Override
     default Iterator<T> iterator() {
         final TraversableOnce<T> that = this;
-        return new Iterator<T>() {
+        return new Iterator.AbstractIterator<T>() {
 
             TraversableOnce<T> traversable = that;
 

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -685,7 +685,7 @@ default List<T> dropRight(int n) {
         if (n >= length()) {
             return empty();
         }
-        return reverse().drop(n).reverse();
+        return List.ofAll(iterator().dropRight(n));
     }
 
     @Override

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -685,7 +685,7 @@ default List<T> dropRight(int n) {
         if (n >= length()) {
             return empty();
         }
-        return reverse().drop(n).reverse();
+        return List.ofAll(iterator().dropRight(n));
     }
 
     @Override

File: src/main/java/javaslang/collection/TraversableOnce.java
Patch:
@@ -474,9 +474,10 @@ default T get() {
      */
     @Override
     default Iterator<T> iterator() {
+        final TraversableOnce<T> that = this;
         return new Iterator<T>() {
 
-            TraversableOnce<T> traversable = TraversableOnce.this;
+            TraversableOnce<T> traversable = that;
 
             @Override
             public boolean hasNext() {

File: src/test/java/javaslang/collection/HashMapTest.java
Patch:
@@ -46,7 +46,7 @@ public void shouldReturnEntrySetOfANonEmptyHashMap() {
                     Map.Entry.of(2, "2"))
                 .entrySet()).isEqualTo(
                 HashSet.of(
-                    Map.Entry.of(1, "2"),
-                    Map.Entry.of(2, "3")));
+                    Map.Entry.of(1, "1"),
+                    Map.Entry.of(2, "2")));
     }
 }

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -258,10 +258,10 @@ public int length() {
     public <U, W> Map<U, W> map(BiFunction<? super K, ? super V, ? extends Entry<? extends U, ? extends W>> mapper) {
         return null;
     }
-
     @Override
     public <U> Set<U> map(Function<? super Entry<K, V>, ? extends U> mapper) {
-        return null;
+        Objects.requireNonNull(mapper, "mapper is null");
+        return foldLeft(HashSet.empty(), (acc, entry) -> acc.add(mapper.apply(entry)));
     }
 
     @Override

File: src/main/java/javaslang/collection/HashSet.java
Patch:
@@ -480,13 +480,14 @@ public int hashCode() {
         return hash.get();
     }
 
+    @SuppressWarnings("unchecked")
     @Override
     public boolean equals(Object o) {
         if (o == this) {
             return true;
         } else if (o instanceof HashSet) {
             final HashSet<?> that = (HashSet<?>) o;
-            return this.iterator().equals(that.iterator());
+            return this.length() == that.length() && ((HashSet<Object>) this).containsAll(that);
         } else {
             return false;
         }

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -258,10 +258,10 @@ public int length() {
     public <U, W> Map<U, W> map(BiFunction<? super K, ? super V, ? extends Entry<? extends U, ? extends W>> mapper) {
         return null;
     }
-
     @Override
     public <U> Set<U> map(Function<? super Entry<K, V>, ? extends U> mapper) {
-        return null;
+        Objects.requireNonNull(mapper, "mapper is null");
+        return foldLeft(HashSet.empty(), (acc, entry) -> acc.add(mapper.apply(entry)));
     }
 
     @Override

File: src/main/java/javaslang/collection/HashSet.java
Patch:
@@ -481,11 +481,12 @@ public int hashCode() {
     }
 
     @Override
+    @SuppressWarnings("unchecked")
     public boolean equals(Object o) {
         if (o == this) {
             return true;
         } else if (o instanceof HashSet) {
-            final HashSet<?> that = (HashSet<?>) o;
+            final HashSet<T> that = (HashSet<T>) o;
             return this.iterator().equals(that.iterator());
         } else {
             return false;

File: src/main/java/javaslang/collection/Queue.java
Patch:
@@ -64,7 +64,7 @@ public class Queue<T> implements LinearSeq<T>, Serializable {
      * @param front A List of front elements, in correct order.
      * @param rear  A List of rear elements, in reverse order.
      */
-    public Queue(List<T> front, List<T> rear) {
+    private Queue(List<T> front, List<T> rear) {
         final boolean frontIsEmpty = front.isEmpty();
         this.front = frontIsEmpty ? rear.reverse() : front;
         this.rear = frontIsEmpty ? front : rear;

File: src/test/java/javaslang/TypeConsistencyTest.java
Patch:
@@ -46,8 +46,6 @@ public class TypeConsistencyTest {
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.failed()",
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.filter(java.util.function.Predicate)",
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.filterTry(javaslang.control.Try$CheckedPredicate)",
-            "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.filterOption(java.util.function.Predicate)",
-            "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.filterTryOption(javaslang.control.Try$CheckedPredicate)",
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.flatMap(java.util.function.Function)",
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.flatMapM(java.util.function.Function)",
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.flatMapTry(javaslang.control.Try$CheckedFunction)",
@@ -60,7 +58,6 @@ public class TypeConsistencyTest {
 
             // javaslang.control.Some
             "javaslang.control.Some//public abstract javaslang.control.Option javaslang.control.Option.filter(java.util.function.Predicate)",
-            "javaslang.control.Some//public abstract javaslang.control.Option javaslang.control.Option.filterOption(java.util.function.Predicate)",
             "javaslang.control.Some//public abstract javaslang.control.Option javaslang.control.Option.flatMap(java.util.function.Function)",
             "javaslang.control.Some//public abstract javaslang.control.Option javaslang.control.Option.flatMapM(java.util.function.Function)",
             "javaslang.control.Some//public abstract javaslang.control.Option javaslang.control.Option.flatten()",

File: src/main/java/javaslang/Value.java
Patch:
@@ -487,6 +487,7 @@ interface ConversionOps<T> {
     /**
      * Converts this instance to a Java array.
      *
+     * @param componentType Component type of the array
      * @return A new Java array.
      * @throws NullPointerException if componentType is null
      */

File: src/main/java/javaslang/Value.java
Patch:
@@ -487,6 +487,7 @@ interface ConversionOps<T> {
     /**
      * Converts this instance to a Java array.
      *
+     * @param componentType Component type of the array
      * @return A new Java array.
      * @throws NullPointerException if componentType is null
      */

File: src/test/java/javaslang/TypeConsistencyTest.java
Patch:
@@ -8,6 +8,7 @@
 import javaslang.collection.List;
 import javaslang.collection.Stream;
 import javaslang.control.Try;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.File;
@@ -76,6 +77,7 @@ public class TypeConsistencyTest {
      * are not recognized by this test because there is no runtime information available via reflection.
      */
     @Test
+    @Ignore
     public void shouldHaveAConsistentTypeSystem() {
 
         final Stream<Class<?>> relevantClasses = loadClasses("src-gen/main/java")

File: src/test/java/javaslang/collection/euler/Euler04Test.java
Patch:
@@ -30,7 +30,7 @@ public void shouldSolveProblem4() {
 
     private static int largestPalindromeOfProductsFromFactorsInRange(final int min, final int max) {
         return List.rangeClosed(min, max)
-                .cartesianProduct()
+                .crossProduct()
                 .filter(t -> t._1 <= t._2)
                 .map(t -> t._1 * t._2)
                 .filter(Utils::isPalindrome)

File: src/test/java/javaslang/collection/euler/Euler09Test.java
Patch:
@@ -33,7 +33,7 @@ public void shouldSolveProblem9() {
 
     public int abc(int sum) {
         return List.rangeClosed(1, sum)
-                .cartesianProduct()
+                .crossProduct()
                 .filter(t -> t._1 + t._2 < sum)
                 .map(t -> Tuple.of(t._1, t._2, sum - t._1 - t._2))
                 .filter(t -> t._1 * t._1 + t._2 * t._2 == t._3 * t._3)

File: src/test/java/javaslang/collection/euler/Euler11Test.java
Patch:
@@ -80,7 +80,7 @@ private static int maxProduct() {
     }
 
     private static int maxProduct(int dr, int dc) {
-        return range(dr).cartesianProduct(range(dc)).map(rc -> product(rc._1, rc._2, dr, dc)).max().get();
+        return range(dr).crossProduct(range(dc)).map(rc -> product(rc._1, rc._2, dr, dc)).max().get();
     }
 
     private static List<Integer> range(int d) {

File: src/test/java/javaslang/collection/euler/PrimeNumbers.java
Patch:
@@ -17,7 +17,7 @@ public final class PrimeNumbers {
                             .filter(i -> self.takeWhile(j -> j * j <= i).forAll(k -> i % k > 0))
             );
 
-    private static final Function<Integer, Long> MEMOIZED_PRIMES = Function1.lift(PRIMES::get).memoized();
+    private static final Function<Integer, Long> MEMOIZED_PRIMES = Function1.lift(PRIMES::apply).memoized();
 
     private PrimeNumbers() {
     }

File: src/main/java/javaslang/collection/Iterator.java
Patch:
@@ -268,7 +268,9 @@ public T next() {
                     if (!hasNext()) {
                         throw new NoSuchElementException();
                     }
-                    return next.get();
+                    T result = next.get();
+                    next = None.instance();
+                    return result;
                 }
             };
         }

File: src/main/java/javaslang/collection/Iterator.java
Patch:
@@ -268,7 +268,9 @@ public T next() {
                     if (!hasNext()) {
                         throw new NoSuchElementException();
                     }
-                    return next.get();
+                    T result = next.get();
+                    next = None.instance();
+                    return result;
                 }
             };
         }

File: src-gen/main/java/javaslang/CheckedFunction0.java
Patch:
@@ -127,7 +127,7 @@ default Type<R> getType() {
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")
-    final class Type<R> extends .AbstractType<R> {
+    final class Type<R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/CheckedFunction1.java
Patch:
@@ -187,7 +187,7 @@ default Type<T1, R> getType() {
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")
-    final class Type<T1, R> extends .AbstractType<R> {
+    final class Type<T1, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/CheckedFunction2.java
Patch:
@@ -183,7 +183,7 @@ default Type<T1, T2, R> getType() {
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")
-    final class Type<T1, T2, R> extends .AbstractType<R> {
+    final class Type<T1, T2, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/CheckedFunction3.java
Patch:
@@ -204,7 +204,7 @@ default Type<T1, T2, T3, R> getType() {
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")
-    final class Type<T1, T2, T3, R> extends .AbstractType<R> {
+    final class Type<T1, T2, T3, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/CheckedFunction4.java
Patch:
@@ -226,7 +226,7 @@ default Type<T1, T2, T3, T4, R> getType() {
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")
-    final class Type<T1, T2, T3, T4, R> extends .AbstractType<R> {
+    final class Type<T1, T2, T3, T4, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/CheckedFunction5.java
Patch:
@@ -249,7 +249,7 @@ default Type<T1, T2, T3, T4, T5, R> getType() {
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")
-    final class Type<T1, T2, T3, T4, T5, R> extends .AbstractType<R> {
+    final class Type<T1, T2, T3, T4, T5, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/CheckedFunction6.java
Patch:
@@ -273,7 +273,7 @@ default Type<T1, T2, T3, T4, T5, T6, R> getType() {
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")
-    final class Type<T1, T2, T3, T4, T5, T6, R> extends .AbstractType<R> {
+    final class Type<T1, T2, T3, T4, T5, T6, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/CheckedFunction7.java
Patch:
@@ -298,7 +298,7 @@ default Type<T1, T2, T3, T4, T5, T6, T7, R> getType() {
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")
-    final class Type<T1, T2, T3, T4, T5, T6, T7, R> extends .AbstractType<R> {
+    final class Type<T1, T2, T3, T4, T5, T6, T7, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/CheckedFunction8.java
Patch:
@@ -324,7 +324,7 @@ default Type<T1, T2, T3, T4, T5, T6, T7, T8, R> getType() {
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")
-    final class Type<T1, T2, T3, T4, T5, T6, T7, T8, R> extends .AbstractType<R> {
+    final class Type<T1, T2, T3, T4, T5, T6, T7, T8, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Function0.java
Patch:
@@ -137,7 +137,7 @@ default Type<R> getType() {
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")
-    final class Type<R> extends .AbstractType<R> {
+    final class Type<R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Function1.java
Patch:
@@ -187,7 +187,7 @@ default Type<T1, R> getType() {
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")
-    final class Type<T1, R> extends .AbstractType<R> {
+    final class Type<T1, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Function2.java
Patch:
@@ -183,7 +183,7 @@ default Type<T1, T2, R> getType() {
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")
-    final class Type<T1, T2, R> extends .AbstractType<R> {
+    final class Type<T1, T2, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Function3.java
Patch:
@@ -203,7 +203,7 @@ default Type<T1, T2, T3, R> getType() {
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")
-    final class Type<T1, T2, T3, R> extends .AbstractType<R> {
+    final class Type<T1, T2, T3, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Function4.java
Patch:
@@ -225,7 +225,7 @@ default Type<T1, T2, T3, T4, R> getType() {
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")
-    final class Type<T1, T2, T3, T4, R> extends .AbstractType<R> {
+    final class Type<T1, T2, T3, T4, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Function5.java
Patch:
@@ -248,7 +248,7 @@ default Type<T1, T2, T3, T4, T5, R> getType() {
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")
-    final class Type<T1, T2, T3, T4, T5, R> extends .AbstractType<R> {
+    final class Type<T1, T2, T3, T4, T5, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Function6.java
Patch:
@@ -272,7 +272,7 @@ default Type<T1, T2, T3, T4, T5, T6, R> getType() {
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")
-    final class Type<T1, T2, T3, T4, T5, T6, R> extends .AbstractType<R> {
+    final class Type<T1, T2, T3, T4, T5, T6, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Function7.java
Patch:
@@ -297,7 +297,7 @@ default Type<T1, T2, T3, T4, T5, T6, T7, R> getType() {
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")
-    final class Type<T1, T2, T3, T4, T5, T6, T7, R> extends .AbstractType<R> {
+    final class Type<T1, T2, T3, T4, T5, T6, T7, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Function8.java
Patch:
@@ -323,7 +323,7 @@ default Type<T1, T2, T3, T4, T5, T6, T7, T8, R> getType() {
      * @since 2.0.0
      */
     @SuppressWarnings("deprecation")
-    final class Type<T1, T2, T3, T4, T5, T6, T7, T8, R> extends .AbstractType<R> {
+    final class Type<T1, T2, T3, T4, T5, T6, T7, T8, R> extends .Type<R> {
 
         private static final long serialVersionUID = 1L;
 

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -37,8 +37,7 @@ static <K, V> HashMap<K, V> empty() {
      * @return A new Map containing the given entry
      */
     static <K, V> HashMap<K, V> of(Entry<? extends K, ? extends V> entry) {
-        final HashMap<K, V> map = HashMap.empty();
-        return map.put(entry.key, entry.value);
+        return HashMap.<K, V> empty().put(entry.key, entry.value);
     }
 
     /**
@@ -102,7 +101,7 @@ public V getOrDefault(K key, V defaultValue) {
 
     @Override
     public Iterator<Entry<K, V>> iterator() {
-        return tree.iterator().map(t -> new Entry<>(t._1, t._2));
+        return tree.iterator().map(Entry::of);
     }
 
     @Override

File: src/main/java/javaslang/collection/Set.java
Patch:
@@ -18,7 +18,7 @@
 /**
  * An immutable {@code Set} interface.
  *
- * @param <T>
+ * @param <T> Component type
  * @since 2.0.0
  */
 public interface Set<T> extends Traversable<T> {

File: src/main/java/javaslang/collection/Tree.java
Patch:
@@ -591,6 +591,7 @@ enum Order {
     /**
      * Counts the number of branches of this tree. The empty tree and a leaf have no branches.
      *
+     * @param tree the Tree
      * @return The number of branches of this tree.
      */
     static int branchCount(Tree<?> tree) {
@@ -604,6 +605,7 @@ static int branchCount(Tree<?> tree) {
     /**
      * Counts the number of leaves of this tree. The empty tree has no leaves.
      *
+     * @param tree the Tree
      * @return The number of leaves of this tree.
      */
     static int leafCount(Tree<?> tree) {
@@ -619,6 +621,7 @@ static int leafCount(Tree<?> tree) {
     /**
      * Counts the number of nodes (i.e. branches and leaves) of this tree. The empty tree has no nodes.
      *
+     * @param tree the Tree
      * @return The number of nodes of this tree.
      */
     static int nodeCount(Tree<?> tree) {

File: src/main/java/javaslang/concurrent/Promise.java
Patch:
@@ -14,7 +14,7 @@
 
 /**
  * Promise is a way of creating a {@link javaslang.concurrent.Future} that can be fulfilled with either a success or failure later.
- * The Future can be obtained with {@link #future()} and success with {@link #success(T t)} or {@link #failure(Throwable e}.
+ * The Future can be obtained with {@link #future()} and success with {@link #success(Object)} or {@link #failure(Throwable)}.
  *
  * @param <T> The type of this Promise and Future's return type.
  *

File: src/main/java/javaslang/collection/Set.java
Patch:
@@ -18,7 +18,7 @@
 /**
  * An immutable {@code Set} interface.
  *
- * @param <T>
+ * @param <T> Component type
  * @since 2.0.0
  */
 public interface Set<T> extends Traversable<T> {

File: src/main/java/javaslang/collection/Tree.java
Patch:
@@ -591,6 +591,7 @@ enum Order {
     /**
      * Counts the number of branches of this tree. The empty tree and a leaf have no branches.
      *
+     * @param tree the Tree
      * @return The number of branches of this tree.
      */
     static int branchCount(Tree<?> tree) {
@@ -604,6 +605,7 @@ static int branchCount(Tree<?> tree) {
     /**
      * Counts the number of leaves of this tree. The empty tree has no leaves.
      *
+     * @param tree the Tree
      * @return The number of leaves of this tree.
      */
     static int leafCount(Tree<?> tree) {
@@ -619,6 +621,7 @@ static int leafCount(Tree<?> tree) {
     /**
      * Counts the number of nodes (i.e. branches and leaves) of this tree. The empty tree has no nodes.
      *
+     * @param tree the Tree
      * @return The number of nodes of this tree.
      */
     static int nodeCount(Tree<?> tree) {

File: src/main/java/javaslang/concurrent/Promise.java
Patch:
@@ -14,7 +14,7 @@
 
 /**
  * Promise is a way of creating a {@link javaslang.concurrent.Future} that can be fulfilled with either a success or failure later.
- * The Future can be obtained with {@link #future()} and success with {@link #success(T t)} or {@link #failure(Throwable e}.
+ * The Future can be obtained with {@link #future()} and success with {@link #success(Object)} or {@link #failure(Throwable)}.
  *
  * @param <T> The type of this Promise and Future's return type.
  *

File: src/test/java/javaslang/test/ArbitraryTest.java
Patch:
@@ -135,8 +135,6 @@ public void shouldCreateArbitraryStream() {
      */
     static class ArbitraryBinaryTree implements Arbitrary<BinaryTree<Integer>> {
 
-        private static final long serialVersionUID = 1L;
-
         final int minValue;
         final int maxValue;
 

File: src/test/java/javaslang/test/ArbitraryTest.java
Patch:
@@ -135,8 +135,6 @@ public void shouldCreateArbitraryStream() {
      */
     static class ArbitraryBinaryTree implements Arbitrary<BinaryTree<Integer>> {
 
-        private static final long serialVersionUID = 1L;
-
         final int minValue;
         final int maxValue;
 

File: src/test/java/javaslang/collection/HashArrayMappedTrieTest.java
Patch:
@@ -14,7 +14,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class HashMapTest {
+public class HashArrayMappedTrieTest {
 
     @Test
     public void testGetExistingKey() {

File: src/test/java/javaslang/collection/HashArrayMappedTrieTest.java
Patch:
@@ -14,7 +14,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class HashMapTest {
+public class HashArrayMappedTrieTest {
 
     @Test
     public void testGetExistingKey() {

File: src/test/java/javaslang/TypeConsistencyTest.java
Patch:
@@ -24,7 +24,7 @@ public class TypeConsistencyTest {
 
     static final List<String> WHITELIST = List.of(
 
-            // javaslang.control.Map
+            // javaslang.collection.Map
             "javaslang.collection.Map//public default java.util.function.Function java.util.function.Function.andThen(java.util.function.Function)",
             "javaslang.collection.Map//public default java.util.function.Function java.util.function.Function.compose(java.util.function.Function)",
 

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -90,8 +90,7 @@ default V getOrDefault(K key, V defaultValue) {
     }
 
     default boolean containsKey(K key) {
-        // TODO: what if the stored value is null? the result is ambiguous
-        return get(key) != null;
+        return ((AbstractNode<K, V>) this).lookup(0, key).isDefined();
     }
 
     default HashMap<K, V> put(K key, V value) {

File: src/main/java/javaslang/collection/HashMap.java
Patch:
@@ -90,8 +90,7 @@ default V getOrDefault(K key, V defaultValue) {
     }
 
     default boolean containsKey(K key) {
-        // TODO: what if the stored value is null? the result is ambiguous
-        return get(key) != null;
+        return ((AbstractNode<K, V>) this).lookup(0, key).isDefined();
     }
 
     default HashMap<K, V> put(K key, V value) {

File: src/main/java/javaslang/Kind.java
Patch:
@@ -19,9 +19,6 @@
  * <ul>
  * <li>Once a type extends {@code Kind} with a concrete first generic parameter type, like {@code List} does, the
  * {@code Kind} is fixated. There is no way for subclasses to implement a more specific {@code Kind}.</li>
- * <li>We can construct illegal relationships, like {@code interface Option<T> extends FilterMonadic<List<?>, T>}.
- * The compiler will detect this, if {@code Kind} is also extended appropriately:
- * {@code interface Option<T> extends Kind<Option<?>, T>, FilterMonadic<Option<?>, T>}.</li>
  * </ul>
  * <p>
  * See also

File: src/test/java/javaslang/collection/AbstractTraversableTest.java
Patch:
@@ -1706,12 +1706,12 @@ public void shouldConvertNonNilToArrayList() {
 
     @Test
     public void shouldConvertNilToHashMap() {
-        assertThat(this.<Integer>empty().toJavaMap(x -> Tuple.of(x, x))).isEqualTo(new HashMap<>());
+        assertThat(this.<Integer>empty().toJavaMap(x -> Tuple.of(x, x))).isEqualTo(new java.util.HashMap<>());
     }
 
     @Test
     public void shouldConvertNonNilToHashMap() {
-        final java.util.Map<Integer, Integer> expected = new HashMap<>();
+        final java.util.Map<Integer, Integer> expected = new java.util.HashMap<>();
         expected.put(1, 1);
         expected.put(2, 2);
         assertThat(of(1, 2).toJavaMap(x -> Tuple.of(x, x))).isEqualTo(expected);
@@ -1721,7 +1721,7 @@ public void shouldConvertNonNilToHashMap() {
 
     @Test
     public void shouldConvertNilToHashSet() {
-        assertThat(this.<Integer>empty().toJavaMap(x -> Tuple.of(x, x))).isEqualTo(new HashMap<>());
+        assertThat(this.<Integer>empty().toJavaSet()).isEqualTo(new java.util.HashSet<>());
     }
 
     @Test

File: src/main/java/javaslang/control/Failure.java
Patch:
@@ -197,7 +197,7 @@ public static abstract class Cause extends RuntimeException implements Serializa
 
         private static final long serialVersionUID = 1L;
 
-        Cause(Throwable cause) {
+        protected Cause(Throwable cause) {
             super(cause);
         }
 
@@ -247,7 +247,7 @@ public static final class Fatal extends Cause {
 
         private static final long serialVersionUID = 1L;
 
-        Fatal(Throwable cause) {
+        public Fatal(Throwable cause) {
             super(cause);
         }
 
@@ -264,7 +264,7 @@ public static final class NonFatal extends Cause {
 
         private static final long serialVersionUID = 1L;
 
-        NonFatal(Throwable cause) {
+        public NonFatal(Throwable cause) {
             super(cause);
         }
 

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -425,7 +425,7 @@ default Option<T> findLast(Predicate<? super T> predicate) {
      * Accumulates the elements of this Traversable by successively calling the given operator {@code op}.
      * </p>
      * <p>
-     * Example: {@code List("a", "b", "c").fold("", (a, b) -> a + b) = "abc"}
+     * Example: {@code List("a", "b", "c").fold("", (xs, x) -> xs + x) = "abc"}
      * </p>
      *
      * @param zero Value to start the accumulation with.
@@ -579,7 +579,7 @@ default int indexOfSlice(Iterable<? extends T> that) {
      * Note: may not terminate for infinite-sized collections.
      * @param that the sequence to test
      * @param from the start index
-     * @return the first index >= from such that the elements of this sequence starting at this index match
+     * @return the first index &gt;= from such that the elements of this sequence starting at this index match
      * the elements of sequence that, or -1 of no such subsequence exists.
      * @throws NullPointerException if {@code that} is null.
      */

File: src/main/java/javaslang/control/Match.java
Patch:
@@ -229,7 +229,7 @@ public Then<R> thenThrow(Supplier<? extends RuntimeException> supplier) {
 
             @SuppressWarnings("unchecked")
             private static <T> Predicate<? super Object> of(Function1<? super T, ? extends Boolean> predicate) {
-                final Class<?> type = predicate.getType().parameterType(0);
+                final Class<? super T> type = predicate.getType().parameterType1();
                 return value -> (value == null || type.isAssignableFrom(value.getClass()))
                         && ((Function1<? super Object, ? extends Boolean>) predicate).apply(value);
             }

File: src-gen/main/java/javaslang/CheckedFunction2.java
Patch:
@@ -219,7 +219,9 @@ interface Type<T1, T2, R> extends .Type<R> {
         @SuppressWarnings("unchecked")
         default Class<T1> parameterType1() {
             return (Class<T1>) parameterArray()[0];
-        }@SuppressWarnings("unchecked")
+        }
+
+        @SuppressWarnings("unchecked")
         default Class<T2> parameterType2() {
             return (Class<T2>) parameterArray()[1];
         }

File: src-gen/main/java/javaslang/Function2.java
Patch:
@@ -219,7 +219,9 @@ interface Type<T1, T2, R> extends .Type<R> {
         @SuppressWarnings("unchecked")
         default Class<T1> parameterType1() {
             return (Class<T1>) parameterArray()[0];
-        }@SuppressWarnings("unchecked")
+        }
+
+        @SuppressWarnings("unchecked")
         default Class<T2> parameterType2() {
             return (Class<T2>) parameterArray()[1];
         }

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -579,7 +579,7 @@ default int indexOfSlice(Iterable<? extends T> that) {
      * Note: may not terminate for infinite-sized collections.
      * @param that the sequence to test
      * @param from the start index
-     * @return the first index >= from such that the elements of this sequence starting at this index match
+     * @return the first index &gt;= from such that the elements of this sequence starting at this index match
      * the elements of sequence that, or -1 of no such subsequence exists.
      * @throws NullPointerException if {@code that} is null.
      */

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -425,7 +425,7 @@ default Option<T> findLast(Predicate<? super T> predicate) {
      * Accumulates the elements of this Traversable by successively calling the given operator {@code op}.
      * </p>
      * <p>
-     * Example: {@code List("a", "b", "c").fold("", (a, b) -> a + b) = "abc"}
+     * Example: {@code List("a", "b", "c").fold("", (xs, x) -> xs + x) = "abc"}
      * </p>
      *
      * @param zero Value to start the accumulation with.

File: src/main/java/javaslang/control/Match.java
Patch:
@@ -229,7 +229,7 @@ public Then<R> thenThrow(Supplier<? extends RuntimeException> supplier) {
 
             @SuppressWarnings("unchecked")
             private static <T> Predicate<? super Object> of(Function1<? super T, ? extends Boolean> predicate) {
-                final Class<?> type = predicate.getType().parameterType(0);
+                final Class<? super T> type = predicate.getType().parameterType1();
                 return value -> (value == null || type.isAssignableFrom(value.getClass()))
                         && ((Function1<? super Object, ? extends Boolean>) predicate).apply(value);
             }

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -718,7 +718,7 @@ static Stream<Long> rangeClosedBy(long from, long toInclusive, long step) {
      * can be transformed to
      * <pre>
      * <code>
-     * Stream.of(0, 1).appendSelf(self -&lt; self.zip(self.tail()).map(t -&lt; t._1 + t._2));
+     * Stream.of(0, 1).appendSelf(self -&gt; self.zip(self.tail()).map(t -&gt; t._1 + t._2));
      * </code>
      * </pre>
      *

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -697,7 +697,7 @@ default List<T> findAll(Predicate<? super T> predicate) {
     }
 
     @Override
-    default <U> List<U> flatMap(Function<? super T, ? extends Iterable<U>> mapper) {
+    default <U> List<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
         if (isEmpty()) {
             return empty();
@@ -735,7 +735,7 @@ default <U> List<U> flatMap(Function<? super T, ? extends Iterable<U>> mapper) {
      * @throws NullPointerException if {@code f} is null
      */
     @Override
-    default <U> List<U> flatten(Function<? super T, ? extends Iterable<U>> f) {
+    default <U> List<U> flatten(Function<? super T, ? extends Iterable<? extends U>> f) {
         Objects.requireNonNull(f, "f is null");
         return isEmpty() ? Nil.instance() : foldRight(empty(), (t, xs) -> xs.prependAll(f.apply(t)));
     }

File: src/main/java/javaslang/collection/Queue.java
Patch:
@@ -591,13 +591,13 @@ public Queue<T> findAll(Predicate<? super T> predicate) {
     }
 
     @Override
-    public <U> Queue<U> flatMap(Function<? super T, ? extends Iterable<U>> mapper) {
+    public <U> Queue<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
         return new Queue<>(front.flatMap(mapper), rear.flatMap(mapper));
     }
 
     @Override
-    public <U> Queue<U> flatten(Function<? super T, ? extends Iterable<U>> f) {
+    public <U> Queue<U> flatten(Function<? super T, ? extends Iterable<? extends U>> f) {
         Objects.requireNonNull(f, "f is null");
         return new Queue<>(front.flatten(f), rear.flatten(f));
     }

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -302,10 +302,10 @@ default Iterator<T> iterator(int index) {
     Seq<T> findAll(Predicate<? super T> predicate);
 
     @Override
-    <U> Seq<U> flatMap(Function<? super T, ? extends Iterable<U>> mapper);
+    <U> Seq<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper);
 
     @Override
-    <U> Seq<U> flatten(Function<? super T, ? extends Iterable<U>> f);
+    <U> Seq<U> flatten(Function<? super T, ? extends Iterable<? extends U>> f);
 
     @Override
     Seq<? extends Seq<T>> grouped(int size);

File: src/main/java/javaslang/collection/Stack.java
Patch:
@@ -504,10 +504,10 @@ static Stack<Long> rangeClosedBy(long from, long toInclusive, long step) {
     Stack<T> findAll(Predicate<? super T> predicate);
 
     @Override
-    <U> Stack<U> flatMap(Function<? super T, ? extends Iterable<U>> mapper);
+    <U> Stack<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper);
 
     @Override
-    <U> Stack<U> flatten(Function<? super T, ? extends Iterable<U>> f);
+    <U> Stack<U> flatten(Function<? super T, ? extends Iterable<? extends U>> f);
 
     @Override
     Stack<? extends Stack<T>> grouped(int size);

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -813,7 +813,7 @@ default Stream<T> findAll(Predicate<? super T> predicate) {
     }
 
     @Override
-    default <U> Stream<U> flatMap(Function<? super T, ? extends Iterable<U>> mapper) {
+    default <U> Stream<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
         return isEmpty() ? Nil.instance() : map(mapper).flatten(Function.identity());
     }
@@ -842,7 +842,7 @@ default <U> Stream<U> flatMap(Function<? super T, ? extends Iterable<U>> mapper)
      */
     @SuppressWarnings("unchecked")
     @Override
-    default <U> Stream<U> flatten(Function<? super T, ? extends Iterable<U>> f) {
+    default <U> Stream<U> flatten(Function<? super T, ? extends Iterable<? extends U>> f) {
         Objects.requireNonNull(f, "f is null");
         return isEmpty() ? Nil.instance() : Stream.ofAll(() -> new Iterator<U>() {
 

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -391,7 +391,7 @@ default Option<T> findLast(Predicate<? super T> predicate) {
         return reverse().findFirst(predicate);
     }
 
-    <U> Traversable<U> flatMap(Function<? super T, ? extends Iterable<U>> mapper);
+    <U> Traversable<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper);
 
     /**
      * Flattens a {@code Traversable} using a function.
@@ -401,7 +401,7 @@ default Option<T> findLast(Predicate<? super T> predicate) {
      * @return a new {@code Traversable}
      * @throws NullPointerException if {@code f} is null
      */
-    <U> Traversable<U> flatten(Function<? super T, ? extends Iterable<U>> f);
+    <U> Traversable<U> flatten(Function<? super T, ? extends Iterable<? extends U>> f);
 
     /**
      * <p>

File: src/main/java/javaslang/control/Failure.java
Patch:
@@ -150,7 +150,7 @@ public <U> Failure<U> mapTry(CheckedFunction1<? super T, ? extends U> f) {
     }
 
     @SuppressWarnings("unchecked")
-    public <U> Failure<U> flatMap(Function<? super T, ? extends Try<U>> mapper) {
+    public <U> Failure<U> flatMap(Function<? super T, ? extends Try<? extends U>> mapper) {
         return (Failure<U>) this;
     }
 

File: src/main/java/javaslang/control/Success.java
Patch:
@@ -148,10 +148,11 @@ public <U> Try<U> mapTry(CheckedFunction1<? super T, ? extends U> f) {
         return flatMap(value -> Try.of(() -> f.apply(value)));
     }
 
+    @SuppressWarnings("unchecked")
     @Override
-    public <U> Try<U> flatMap(Function<? super T, ? extends Try<U>> mapper) {
+    public <U> Try<U> flatMap(Function<? super T, ? extends Try<? extends U>> mapper) {
         try {
-            return mapper.apply(value);
+            return (Try<U>) mapper.apply(value);
         } catch (Throwable t) {
             return new Failure<>(t);
         }

File: src/main/java/javaslang/control/Try.java
Patch:
@@ -145,13 +145,13 @@ static Try<Void> run(CheckedRunnable runnable) {
      * @throws NullPointerException if {@code f} is null
      */
     @SuppressWarnings("unchecked")
-    default <U> Try<U> flatten(Function<? super T, ? extends Try<U>> f) {
+    default <U> Try<U> flatten(Function<? super T, ? extends Try<? extends U>> f) {
         Objects.requireNonNull(f, "f is null");
         if (isFailure()) {
             return (Failure<U>) this;
         } else {
             try {
-                return f.apply(get());
+                return (Try<U>) f.apply(get());
             } catch (Throwable t) {
                 return new Failure<>(t);
             }
@@ -203,7 +203,7 @@ default <U> Try<U> flatten(Function<? super T, ? extends Try<U>> f) {
      * @param <U>    The new component type
      * @return a new Try
      */
-    <U> Try<U> flatMap(Function<? super T, ? extends Try<U>> mapper);
+    <U> Try<U> flatMap(Function<? super T, ? extends Try<? extends U>> mapper);
 
     @Override
     default Iterator<T> iterator() {

File: src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -85,7 +85,7 @@ default <U> Arbitrary<U> map(Function<? super T, ? extends U> mapper) {
      * @param <U>    New type of arbitrary objects
      * @return A new Arbitrary
      */
-    default <U> Arbitrary<U> flatMap(Function<? super T, ? extends Arbitrary<U>> mapper) {
+    default <U> Arbitrary<U> flatMap(Function<? super T, ? extends Arbitrary<? extends U>> mapper) {
         return n -> {
             final Gen<T> generator = apply(n);
             return random -> mapper.apply(generator.apply(random)).apply(n).apply(random);
@@ -102,10 +102,10 @@ default Arbitrary<T> filter(Predicate<? super T> predicate) {
         return n -> apply(n).filter(predicate);
     }
 
-    default <U> Arbitrary<U> flatten(Function<? super T, ? extends Arbitrary<U>> f) {
+    default <U> Arbitrary<U> flatten(Function<? super T, ? extends Arbitrary<? extends U>> f) {
         return size -> random -> {
             final Gen<T> gen = apply(size);
-            final Arbitrary<U> arbitrary = f.apply(gen.apply(random));
+            final Arbitrary<? extends U> arbitrary = f.apply(gen.apply(random));
             return arbitrary.apply(size).apply(random);
         };
     }

File: src/main/java/javaslang/test/Gen.java
Patch:
@@ -283,7 +283,7 @@ default <U> Gen<U> map(Function<? super T, ? extends U> mapper) {
      * @param <U>    Type of generated objects of the new generator
      * @return A new generator
      */
-    default <U> Gen<U> flatMap(Function<? super T, ? extends Gen<U>> mapper) {
+    default <U> Gen<U> flatMap(Function<? super T, ? extends Gen<? extends U>> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
         return random -> mapper.apply(apply(random)).apply(random);
     }
@@ -309,9 +309,9 @@ default Gen<T> filter(Predicate<? super T> predicate) {
         };
     }
 
-    default <U> Gen<U> flatten(Function<? super T, ? extends Gen<U>> f) {
+    default <U> Gen<U> flatten(Function<? super T, ? extends Gen<? extends U>> f) {
         return random -> {
-            final Gen<U> gen = f.apply(apply(random));
+            final Gen<? extends U> gen = f.apply(apply(random));
             return gen.apply(random);
         };
     }

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -697,7 +697,7 @@ default List<T> findAll(Predicate<? super T> predicate) {
     }
 
     @Override
-    default <U> List<U> flatMap(Function<? super T, ? extends Iterable<U>> mapper) {
+    default <U> List<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
         if (isEmpty()) {
             return empty();
@@ -735,7 +735,7 @@ default <U> List<U> flatMap(Function<? super T, ? extends Iterable<U>> mapper) {
      * @throws NullPointerException if {@code f} is null
      */
     @Override
-    default <U> List<U> flatten(Function<? super T, ? extends Iterable<U>> f) {
+    default <U> List<U> flatten(Function<? super T, ? extends Iterable<? extends U>> f) {
         Objects.requireNonNull(f, "f is null");
         return isEmpty() ? Nil.instance() : foldRight(empty(), (t, xs) -> xs.prependAll(f.apply(t)));
     }

File: src/main/java/javaslang/collection/Queue.java
Patch:
@@ -591,13 +591,13 @@ public Queue<T> findAll(Predicate<? super T> predicate) {
     }
 
     @Override
-    public <U> Queue<U> flatMap(Function<? super T, ? extends Iterable<U>> mapper) {
+    public <U> Queue<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
         return new Queue<>(front.flatMap(mapper), rear.flatMap(mapper));
     }
 
     @Override
-    public <U> Queue<U> flatten(Function<? super T, ? extends Iterable<U>> f) {
+    public <U> Queue<U> flatten(Function<? super T, ? extends Iterable<? extends U>> f) {
         Objects.requireNonNull(f, "f is null");
         return new Queue<>(front.flatten(f), rear.flatten(f));
     }

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -302,10 +302,10 @@ default Iterator<T> iterator(int index) {
     Seq<T> findAll(Predicate<? super T> predicate);
 
     @Override
-    <U> Seq<U> flatMap(Function<? super T, ? extends Iterable<U>> mapper);
+    <U> Seq<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper);
 
     @Override
-    <U> Seq<U> flatten(Function<? super T, ? extends Iterable<U>> f);
+    <U> Seq<U> flatten(Function<? super T, ? extends Iterable<? extends U>> f);
 
     @Override
     Seq<? extends Seq<T>> grouped(int size);

File: src/main/java/javaslang/collection/Stack.java
Patch:
@@ -504,10 +504,10 @@ static Stack<Long> rangeClosedBy(long from, long toInclusive, long step) {
     Stack<T> findAll(Predicate<? super T> predicate);
 
     @Override
-    <U> Stack<U> flatMap(Function<? super T, ? extends Iterable<U>> mapper);
+    <U> Stack<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper);
 
     @Override
-    <U> Stack<U> flatten(Function<? super T, ? extends Iterable<U>> f);
+    <U> Stack<U> flatten(Function<? super T, ? extends Iterable<? extends U>> f);
 
     @Override
     Stack<? extends Stack<T>> grouped(int size);

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -813,7 +813,7 @@ default Stream<T> findAll(Predicate<? super T> predicate) {
     }
 
     @Override
-    default <U> Stream<U> flatMap(Function<? super T, ? extends Iterable<U>> mapper) {
+    default <U> Stream<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
         return isEmpty() ? Nil.instance() : map(mapper).flatten(Function.identity());
     }
@@ -842,7 +842,7 @@ default <U> Stream<U> flatMap(Function<? super T, ? extends Iterable<U>> mapper)
      */
     @SuppressWarnings("unchecked")
     @Override
-    default <U> Stream<U> flatten(Function<? super T, ? extends Iterable<U>> f) {
+    default <U> Stream<U> flatten(Function<? super T, ? extends Iterable<? extends U>> f) {
         Objects.requireNonNull(f, "f is null");
         return isEmpty() ? Nil.instance() : Stream.ofAll(() -> new Iterator<U>() {
 

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -391,7 +391,7 @@ default Option<T> findLast(Predicate<? super T> predicate) {
         return reverse().findFirst(predicate);
     }
 
-    <U> Traversable<U> flatMap(Function<? super T, ? extends Iterable<U>> mapper);
+    <U> Traversable<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper);
 
     /**
      * Flattens a {@code Traversable} using a function.
@@ -401,7 +401,7 @@ default Option<T> findLast(Predicate<? super T> predicate) {
      * @return a new {@code Traversable}
      * @throws NullPointerException if {@code f} is null
      */
-    <U> Traversable<U> flatten(Function<? super T, ? extends Iterable<U>> f);
+    <U> Traversable<U> flatten(Function<? super T, ? extends Iterable<? extends U>> f);
 
     /**
      * <p>

File: src/main/java/javaslang/control/Failure.java
Patch:
@@ -150,7 +150,7 @@ public <U> Failure<U> mapTry(CheckedFunction1<? super T, ? extends U> f) {
     }
 
     @SuppressWarnings("unchecked")
-    public <U> Failure<U> flatMap(Function<? super T, ? extends Try<U>> mapper) {
+    public <U> Failure<U> flatMap(Function<? super T, ? extends Try<? extends U>> mapper) {
         return (Failure<U>) this;
     }
 

File: src/main/java/javaslang/control/Success.java
Patch:
@@ -148,10 +148,11 @@ public <U> Try<U> mapTry(CheckedFunction1<? super T, ? extends U> f) {
         return flatMap(value -> Try.of(() -> f.apply(value)));
     }
 
+    @SuppressWarnings("unchecked")
     @Override
-    public <U> Try<U> flatMap(Function<? super T, ? extends Try<U>> mapper) {
+    public <U> Try<U> flatMap(Function<? super T, ? extends Try<? extends U>> mapper) {
         try {
-            return mapper.apply(value);
+            return (Try<U>) mapper.apply(value);
         } catch (Throwable t) {
             return new Failure<>(t);
         }

File: src/main/java/javaslang/control/Try.java
Patch:
@@ -145,13 +145,13 @@ static Try<Void> run(CheckedRunnable runnable) {
      * @throws NullPointerException if {@code f} is null
      */
     @SuppressWarnings("unchecked")
-    default <U> Try<U> flatten(Function<? super T, ? extends Try<U>> f) {
+    default <U> Try<U> flatten(Function<? super T, ? extends Try<? extends U>> f) {
         Objects.requireNonNull(f, "f is null");
         if (isFailure()) {
             return (Failure<U>) this;
         } else {
             try {
-                return f.apply(get());
+                return (Try<U>) f.apply(get());
             } catch (Throwable t) {
                 return new Failure<>(t);
             }
@@ -203,7 +203,7 @@ default <U> Try<U> flatten(Function<? super T, ? extends Try<U>> f) {
      * @param <U>    The new component type
      * @return a new Try
      */
-    <U> Try<U> flatMap(Function<? super T, ? extends Try<U>> mapper);
+    <U> Try<U> flatMap(Function<? super T, ? extends Try<? extends U>> mapper);
 
     @Override
     default Iterator<T> iterator() {

File: src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -85,7 +85,7 @@ default <U> Arbitrary<U> map(Function<? super T, ? extends U> mapper) {
      * @param <U>    New type of arbitrary objects
      * @return A new Arbitrary
      */
-    default <U> Arbitrary<U> flatMap(Function<? super T, ? extends Arbitrary<U>> mapper) {
+    default <U> Arbitrary<U> flatMap(Function<? super T, ? extends Arbitrary<? extends U>> mapper) {
         return n -> {
             final Gen<T> generator = apply(n);
             return random -> mapper.apply(generator.apply(random)).apply(n).apply(random);
@@ -102,10 +102,10 @@ default Arbitrary<T> filter(Predicate<? super T> predicate) {
         return n -> apply(n).filter(predicate);
     }
 
-    default <U> Arbitrary<U> flatten(Function<? super T, ? extends Arbitrary<U>> f) {
+    default <U> Arbitrary<U> flatten(Function<? super T, ? extends Arbitrary<? extends U>> f) {
         return size -> random -> {
             final Gen<T> gen = apply(size);
-            final Arbitrary<U> arbitrary = f.apply(gen.apply(random));
+            final Arbitrary<? extends U> arbitrary = f.apply(gen.apply(random));
             return arbitrary.apply(size).apply(random);
         };
     }

File: src/main/java/javaslang/test/Gen.java
Patch:
@@ -283,7 +283,7 @@ default <U> Gen<U> map(Function<? super T, ? extends U> mapper) {
      * @param <U>    Type of generated objects of the new generator
      * @return A new generator
      */
-    default <U> Gen<U> flatMap(Function<? super T, ? extends Gen<U>> mapper) {
+    default <U> Gen<U> flatMap(Function<? super T, ? extends Gen<? extends U>> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
         return random -> mapper.apply(apply(random)).apply(random);
     }
@@ -309,9 +309,9 @@ default Gen<T> filter(Predicate<? super T> predicate) {
         };
     }
 
-    default <U> Gen<U> flatten(Function<? super T, ? extends Gen<U>> f) {
+    default <U> Gen<U> flatten(Function<? super T, ? extends Gen<? extends U>> f) {
         return random -> {
-            final Gen<U> gen = f.apply(apply(random));
+            final Gen<? extends U> gen = f.apply(apply(random));
             return gen.apply(random);
         };
     }

File: src/main/java/javaslang/Value.java
Patch:
@@ -100,7 +100,7 @@ default Option<T> toOption() {
     /**
      * Converts this value to an {@link java.util.Optional}.
      *
-     * @return An empty {@code Optional}, if no value is present <string>or the value is null</string>,
+     * @return An empty {@code Optional}, if no value is present <strong>or the value is null</strong>,
      * otherwise a non-empty {@code Option} containing the value.
      */
     default Optional<T> toJavaOptional() {

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -122,7 +122,7 @@
  *
  * <ul>
  * <li>{@link #cartesianProduct()}</li>
- * <li>{@link #cartesianProduct(Traversable)}</li>
+ * <li>{@link #cartesianProduct(Iterable)}</li>
  * <li>{@link #combinations()}</li>
  * <li>{@link #combinations(int)}</li>
  * <li>{@link #distinct()}</li>

File: src/test/java/javaslang/FunctionsTest.java
Patch:
@@ -362,14 +362,14 @@ public void shouldRecognizeLiftedLambdaCallSignature() {
     public void shouldRecognizeMethodReferenceSignature() {
         final Function<Integer, Integer> f1 = i -> i + 1;
         final Function1<Integer, Integer> f2 = f1::apply;
-        assertThat(f2.getType().toString()).isEqualTo("(Object)Object");
+        assertThat(f2.getType().toString()).isEqualTo("(Integer)Integer");
     }
 
     @Test
     public void shouldRecognizeLiftedMethodReferenceSignature() {
         final Function<Integer, Integer> f1 = i -> i + 1;
         final Function1<Integer, Integer> f2 = Function1.lift(f1::apply);
-        assertThat(f2.getType().toString()).isEqualTo("(Object)Object");
+        assertThat(f2.getType().toString()).isEqualTo("(Integer)Integer");
     }
 
     // -- more lambda reflection tests

File: src/test/java/javaslang/FunctionsTest.java
Patch:
@@ -362,14 +362,14 @@ public void shouldRecognizeLiftedLambdaCallSignature() {
     public void shouldRecognizeMethodReferenceSignature() {
         final Function<Integer, Integer> f1 = i -> i + 1;
         final Function1<Integer, Integer> f2 = f1::apply;
-        assertThat(f2.getType().toString()).isEqualTo("(Object)Object");
+        assertThat(f2.getType().toString()).isEqualTo("(Integer)Integer");
     }
 
     @Test
     public void shouldRecognizeLiftedMethodReferenceSignature() {
         final Function<Integer, Integer> f1 = i -> i + 1;
         final Function1<Integer, Integer> f2 = Function1.lift(f1::apply);
-        assertThat(f2.getType().toString()).isEqualTo("(Object)Object");
+        assertThat(f2.getType().toString()).isEqualTo("(Integer)Integer");
     }
 
     // -- more lambda reflection tests

File: src/test/java/javaslang/collection/euler/Euler04Test.java
Patch:
@@ -30,7 +30,7 @@ public void shouldSolveProblem4() {
 
     private static int largestPalindromeOfProductsFromFactorsInRange(final int min, final int max) {
         return Utils.cross(List.rangeClosed(min, max), List.rangeClosed(min, max))
-                .filter(t -> t._1 < t._2)
+                .filter(t -> t._1 <= t._2)
                 .map(t -> t._1 * t._2)
                 .filter(Euler04Test::isPalindrome)
                 .max().get();

File: src-gen/main/java/javaslang/Function0.java
Patch:
@@ -55,7 +55,7 @@ public interface Function0<R> extends <R>, Supplier<R> {
      * </code></pre>
      *
      * @param methodReference (typically) a method reference, e.g. {@code Type::method}
-     * @param <R>             return type
+     * @param <R> return type
      * @return a {@code Function0}
      */
     static <R> Function0<R> lift(Function0<R> methodReference) {
@@ -66,6 +66,7 @@ static <R> Function0<R> lift(Function0<R> methodReference) {
      * Applies this function to no arguments and returns the result.
      *
      * @return the result of function application
+     * 
      */
     R apply();
 
@@ -108,7 +109,7 @@ default Function0<R> memoized() {
      * Returns a composed function that first applies this Function0 to the given argument and then applies
      * {@linkplain Function1} {@code after} to the result.
      *
-     * @param <V>   return type of after
+     * @param <V> return type of after
      * @param after the function applied after this
      * @return a function composed of this and after
      * @throws NullPointerException if after is null

File: src-gen/test/java/javaslang/CheckedFunction0Test.java
Patch:
@@ -9,11 +9,10 @@
    G E N E R A T O R   C R A F T E D
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
-import org.junit.Test;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.concurrent.atomic.AtomicInteger;
-
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.Test;
 
 public class CheckedFunction0Test {
 

File: src-gen/test/java/javaslang/Function0Test.java
Patch:
@@ -9,11 +9,10 @@
    G E N E R A T O R   C R A F T E D
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
-import org.junit.Test;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.concurrent.atomic.AtomicInteger;
-
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.Test;
 
 public class Function0Test {
 

File: src-gen/test/java/javaslang/Tuple1Test.java
Patch:
@@ -9,11 +9,10 @@
    G E N E R A T O R   C R A F T E D
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
-import org.junit.Test;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.Objects;
-
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.Test;
 
 public class Tuple1Test {
 

File: src-gen/main/java/javaslang/CheckedFunction0.java
Patch:
@@ -34,13 +34,13 @@ public interface CheckedFunction0<R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/CheckedFunction1.java
Patch:
@@ -37,13 +37,13 @@ public interface CheckedFunction1<T1, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/CheckedFunction2.java
Patch:
@@ -38,13 +38,13 @@ public interface CheckedFunction2<T1, T2, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/CheckedFunction3.java
Patch:
@@ -39,13 +39,13 @@ public interface CheckedFunction3<T1, T2, T3, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/CheckedFunction4.java
Patch:
@@ -40,13 +40,13 @@ public interface CheckedFunction4<T1, T2, T3, T4, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/CheckedFunction5.java
Patch:
@@ -41,13 +41,13 @@ public interface CheckedFunction5<T1, T2, T3, T4, T5, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/CheckedFunction6.java
Patch:
@@ -42,13 +42,13 @@ public interface CheckedFunction6<T1, T2, T3, T4, T5, T6, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/CheckedFunction7.java
Patch:
@@ -43,13 +43,13 @@ public interface CheckedFunction7<T1, T2, T3, T4, T5, T6, T7, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/CheckedFunction8.java
Patch:
@@ -44,13 +44,13 @@ public interface CheckedFunction8<T1, T2, T3, T4, T5, T6, T7, T8, R> extends <
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/Function0.java
Patch:
@@ -34,13 +34,13 @@ public interface Function0<R> extends <R>, Supplier<R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/Function1.java
Patch:
@@ -37,13 +37,13 @@ public interface Function1<T1, R> extends <R>, Function<T1, R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/Function2.java
Patch:
@@ -38,13 +38,13 @@ public interface Function2<T1, T2, R> extends <R>, BiFunction<T1, T2, R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/Function3.java
Patch:
@@ -38,13 +38,13 @@ public interface Function3<T1, T2, T3, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/Function4.java
Patch:
@@ -39,13 +39,13 @@ public interface Function4<T1, T2, T3, T4, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/Function5.java
Patch:
@@ -40,13 +40,13 @@ public interface Function5<T1, T2, T3, T4, T5, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/Function6.java
Patch:
@@ -41,13 +41,13 @@ public interface Function6<T1, T2, T3, T4, T5, T6, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/Function7.java
Patch:
@@ -42,13 +42,13 @@ public interface Function7<T1, T2, T3, T4, T5, T6, T7, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/Function8.java
Patch:
@@ -43,13 +43,13 @@ public interface Function8<T1, T2, T3, T4, T5, T6, T7, T8, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src/main/java/javaslang/control/Match.java
Patch:
@@ -80,6 +80,7 @@ public interface Match<R> extends Function<Object, R> {
     /**
      * Creates a type-safe match by fixating the value to be matched.
      *
+     * @param <T>   type of the value to be matched
      * @param value the value to be matched
      * @return a new type-safe match builder
      */

File: src/test/java/javaslang/collection/euler/Euler01Test.java
Patch:
@@ -20,7 +20,7 @@
  * <p>
  * See also <a href="https://projecteuler.net/problem=1">projecteuler.net problem 1</a>.
  */
-public class Euler01 {
+public class Euler01Test {
 
     @Test
     public void shouldSolveProblem1() {
@@ -29,7 +29,7 @@ public void shouldSolveProblem1() {
     }
 
     private static int sumOfMultiplesOf3and5Below(int limit) {
-        return List.range(1, limit).filter(Euler01::isMultipleOf3or5).sum().intValue();
+        return List.range(1, limit).filter(Euler01Test::isMultipleOf3or5).sum().intValue();
     }
 
     private static boolean isMultipleOf3or5(int num) {

File: src/test/java/javaslang/collection/euler/Euler02Test.java
Patch:
@@ -10,7 +10,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class Euler02 {
+public class Euler02Test {
 
     /**
      * <strong>Problem 2: Even Fibonacci numbers</strong>

File: src/test/java/javaslang/collection/euler/Euler03Test.java
Patch:
@@ -9,7 +9,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class Euler03 {
+public class Euler03Test {
 
     /**
      * <strong>Problem 3: Largest prime factor</strong>

File: src/test/java/javaslang/collection/euler/Euler04Test.java
Patch:
@@ -10,7 +10,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class Euler04 {
+public class Euler04Test {
 
     /**
      * <strong>Problem 4: Largest palindrome product</strong>
@@ -31,7 +31,7 @@ public void shouldSolveProblem4() {
     private static int largestPalindromeOfProductsFromFactorsInRange(final int min, final int max) {
         return Stream.rangeClosed(min, max)
                 .flatMap(i -> Stream.rangeClosed(i, max).map(j -> i * j))
-                .filter(Euler04::isPalindrome)
+                .filter(Euler04Test::isPalindrome)
                 .max().get();
     }
 

File: src/test/java/javaslang/collection/euler/Euler05Test.java
Patch:
@@ -10,7 +10,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class Euler05 {
+public class Euler05Test {
 
     /**
      * <strong>Problem 5: Smallest multiple</strong>

File: src/test/java/javaslang/collection/euler/Euler06Test.java
Patch:
@@ -10,7 +10,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class Euler06 {
+public class Euler06Test {
 
     /**
      * <strong>Problem 6: Sum square difference</strong>

File: src/test/java/javaslang/collection/euler/Euler07Test.java
Patch:
@@ -10,7 +10,7 @@
 import static javaslang.collection.euler.PrimeNumbers.prime;
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class Euler07 {
+public class Euler07Test {
 
     /**
      * <strong>Problem 7: 10001st prime</strong>

File: src-gen/main/java/javaslang/CheckedFunction0.java
Patch:
@@ -34,13 +34,13 @@ public interface CheckedFunction0<R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/CheckedFunction1.java
Patch:
@@ -37,13 +37,13 @@ public interface CheckedFunction1<T1, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/CheckedFunction2.java
Patch:
@@ -38,13 +38,13 @@ public interface CheckedFunction2<T1, T2, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/CheckedFunction3.java
Patch:
@@ -39,13 +39,13 @@ public interface CheckedFunction3<T1, T2, T3, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/CheckedFunction4.java
Patch:
@@ -40,13 +40,13 @@ public interface CheckedFunction4<T1, T2, T3, T4, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/CheckedFunction5.java
Patch:
@@ -41,13 +41,13 @@ public interface CheckedFunction5<T1, T2, T3, T4, T5, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/CheckedFunction6.java
Patch:
@@ -42,13 +42,13 @@ public interface CheckedFunction6<T1, T2, T3, T4, T5, T6, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/CheckedFunction7.java
Patch:
@@ -43,13 +43,13 @@ public interface CheckedFunction7<T1, T2, T3, T4, T5, T6, T7, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/CheckedFunction8.java
Patch:
@@ -44,13 +44,13 @@ public interface CheckedFunction8<T1, T2, T3, T4, T5, T6, T7, T8, R> extends <
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/Function0.java
Patch:
@@ -34,13 +34,13 @@ public interface Function0<R> extends <R>, Supplier<R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/Function1.java
Patch:
@@ -37,13 +37,13 @@ public interface Function1<T1, R> extends <R>, Function<T1, R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/Function2.java
Patch:
@@ -38,13 +38,13 @@ public interface Function2<T1, T2, R> extends <R>, BiFunction<T1, T2, R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/Function3.java
Patch:
@@ -38,13 +38,13 @@ public interface Function3<T1, T2, T3, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/Function4.java
Patch:
@@ -39,13 +39,13 @@ public interface Function4<T1, T2, T3, T4, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/Function5.java
Patch:
@@ -40,13 +40,13 @@ public interface Function5<T1, T2, T3, T4, T5, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/Function6.java
Patch:
@@ -41,13 +41,13 @@ public interface Function6<T1, T2, T3, T4, T5, T6, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/Function7.java
Patch:
@@ -42,13 +42,13 @@ public interface Function7<T1, T2, T3, T4, T5, T6, T7, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src-gen/main/java/javaslang/Function8.java
Patch:
@@ -43,13 +43,13 @@ public interface Function8<T1, T2, T3, T4, T5, T6, T7, T8, R> extends <R> {
      * <p>
      * Examples (w.l.o.g. referring to Function1):
      * <pre><code>// lifting a lambda expression
-     * Function1<Integer, Integer> add1 = Function1.lift(i -> i + 1);
+     * Function1&lt;Integer, Integer&gt; add1 = Function1.lift(i -&gt; i + 1);
      *
      * // lifting a method reference (, e.g. Integer method(Integer i) { return i + 1; })
-     * Function1<Integer, Integer> add2 = Function1.lift(this::method);
+     * Function1&lt;Integer, Integer&gt; add2 = Function1.lift(this::method);
      *
      * // lifting a lambda reference
-     * Function1<Integer, Integer> add3 = Function1.lift(add1::apply);
+     * Function1&lt;Integer, Integer&gt; add3 = Function1.lift(add1::apply);
      * </code></pre>
      * <p>
      * <strong>Caution:</strong> Reflection loses type information of lifted lambda reference.

File: src/main/java/javaslang/control/Match.java
Patch:
@@ -80,6 +80,7 @@ public interface Match<R> extends Function<Object, R> {
     /**
      * Creates a type-safe match by fixating the value to be matched.
      *
+     * @param <T>   type of the value to be matched
      * @param value the value to be matched
      * @return a new type-safe match builder
      */

File: src/test/java/javaslang/collection/euler/Euler01Test.java
Patch:
@@ -20,7 +20,7 @@
  * <p>
  * See also <a href="https://projecteuler.net/problem=1">projecteuler.net problem 1</a>.
  */
-public class Euler01 {
+public class Euler01Test {
 
     @Test
     public void shouldSolveProblem1() {
@@ -29,7 +29,7 @@ public void shouldSolveProblem1() {
     }
 
     private static int sumOfMultiplesOf3and5Below(int limit) {
-        return List.range(1, limit).filter(Euler01::isMultipleOf3or5).sum().intValue();
+        return List.range(1, limit).filter(Euler01Test::isMultipleOf3or5).sum().intValue();
     }
 
     private static boolean isMultipleOf3or5(int num) {

File: src/test/java/javaslang/collection/euler/Euler02Test.java
Patch:
@@ -10,7 +10,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class Euler02 {
+public class Euler02Test {
 
     /**
      * <strong>Problem 2: Even Fibonacci numbers</strong>

File: src/test/java/javaslang/collection/euler/Euler03Test.java
Patch:
@@ -9,7 +9,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class Euler03 {
+public class Euler03Test {
 
     /**
      * <strong>Problem 3: Largest prime factor</strong>

File: src/test/java/javaslang/collection/euler/Euler04Test.java
Patch:
@@ -10,7 +10,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class Euler04 {
+public class Euler04Test {
 
     /**
      * <strong>Problem 4: Largest palindrome product</strong>
@@ -31,7 +31,7 @@ public void shouldSolveProblem4() {
     private static int largestPalindromeOfProductsFromFactorsInRange(final int min, final int max) {
         return Stream.rangeClosed(min, max)
                 .flatMap(i -> Stream.rangeClosed(i, max).map(j -> i * j))
-                .filter(Euler04::isPalindrome)
+                .filter(Euler04Test::isPalindrome)
                 .max().get();
     }
 

File: src/test/java/javaslang/collection/euler/Euler05Test.java
Patch:
@@ -10,7 +10,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class Euler05 {
+public class Euler05Test {
 
     /**
      * <strong>Problem 5: Smallest multiple</strong>

File: src/test/java/javaslang/collection/euler/Euler06Test.java
Patch:
@@ -10,7 +10,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class Euler06 {
+public class Euler06Test {
 
     /**
      * <strong>Problem 6: Sum square difference</strong>

File: src/test/java/javaslang/collection/euler/Euler07Test.java
Patch:
@@ -10,7 +10,7 @@
 import static javaslang.collection.euler.PrimeNumbers.prime;
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class Euler07 {
+public class Euler07Test {
 
     /**
      * <strong>Problem 7: 10001st prime</strong>

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -391,15 +391,15 @@ static Stream<Long> rangeClosedBy(long from, long toInclusive, int step) {
         if (step > 0) {
             if(from > toInclusive) {
                 return Nil.instance();
-            } else if (from > Integer.MAX_VALUE - step) {
+            } else if (from > Long.MAX_VALUE - step) {
                 return Stream.of(from);
             } else {
                 return new Cons<>(() -> from, () -> rangeClosedBy(from + step, toInclusive, step));
             }
         } else {
             if(from < toInclusive) {
                 return Nil.instance();
-            } else if (from < Integer.MIN_VALUE - step) {
+            } else if (from < Long.MIN_VALUE - step) {
                 return Stream.of(from);
             } else {
                 return new Cons<>(() -> from, () -> rangeClosedBy(from + step, toInclusive, step));

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -391,15 +391,15 @@ static Stream<Long> rangeClosedBy(long from, long toInclusive, int step) {
         if (step > 0) {
             if(from > toInclusive) {
                 return Nil.instance();
-            } else if (from > Integer.MAX_VALUE - step) {
+            } else if (from > Long.MAX_VALUE - step) {
                 return Stream.of(from);
             } else {
                 return new Cons<>(() -> from, () -> rangeClosedBy(from + step, toInclusive, step));
             }
         } else {
             if(from < toInclusive) {
                 return Nil.instance();
-            } else if (from < Integer.MIN_VALUE - step) {
+            } else if (from < Long.MIN_VALUE - step) {
                 return Stream.of(from);
             } else {
                 return new Cons<>(() -> from, () -> rangeClosedBy(from + step, toInclusive, step));

File: src/main/java/javaslang/collection/Queue.java
Patch:
@@ -40,7 +40,7 @@
  * See Okasaki, Chris: <em>Purely Functional Data Structures</em> (p. 42 ff.). Cambridge, 2003.
  *
  * @param <T> Component type of the Queue
- * @since 1.3.0
+ * @since 2.0.0
  */
 public class Queue<T> implements Seq<T>, Serializable {
 

File: src/main/java/javaslang/collection/Stack.java
Patch:
@@ -34,7 +34,7 @@
  * See Okasaki, Chris: <em>Purely Functional Data Structures</em> (p. 7 ff.). Cambridge, 2003.
  *
  * @param <T> component type
- * @since 1.3.0
+ * @since 2.0.0
  */
 public interface Stack<T> extends Seq<T> {
 

File: src/main/java/javaslang/collection/TraversableOnce.java
Patch:
@@ -13,7 +13,7 @@
  * Interface to reduce code duplication of Iterables and Traversables.
  *
  * @param <T> element type of Iterable
- * @since 1.3.0
+ * @since 2.0.0
  */
 public interface TraversableOnce<T> extends Iterable<T> {
 

File: src/main/java/javaslang/control/Option.java
Patch:
@@ -5,6 +5,7 @@
  */
 package javaslang.control;
 
+import javaslang.Value;
 import javaslang.collection.TraversableOnce;
 
 import java.util.Collections;
@@ -32,7 +33,7 @@
  * @param <T> The type of the optional value.
  * @since 1.0.0
  */
-public interface Option<T> extends TraversableOnce<T> {
+public interface Option<T> extends TraversableOnce<T>, Value<T> {
 
     /**
      * Creates a new Option of a given value.

File: src/test/java/javaslang/control/OptionTest.java
Patch:
@@ -157,8 +157,8 @@ public void shouldReturnNoneOnFilterWhenValueIsNotPresentAndPredicateNotMatches(
     // -- flatten(Function)
 
     static final Match<Option<Integer>> MATCH = Match
-        .when((Option<Integer> o) -> o)
-        .when((Integer i) -> new Some<>(i));
+        .whenApplicable((Option<Integer> o) -> o).thenApply()
+        .whenApplicable((Integer i) -> new Some<>(i)).thenApply();
 
     @Test
     public void shouldFlattenUnnestedSomeWithFunction() {

File: src/test/java/javaslang/control/TryTest.java
Patch:
@@ -26,8 +26,8 @@ public class TryTest {
     // -- flatten(Function)
 
     static final Match<Try<Integer>> MATCH = Match
-        .when((Try<Integer> o) -> o)
-        .when((Integer i) -> new Success<>(i));
+        .whenApplicable((Try<Integer> o) -> o).thenApply()
+        .whenType(Integer.class).then(Success::new);
 
     @Test
     public void shouldFlattenUnnestedSuccessWithFunction() {

File: src/test/java/javaslang/control/MatchTest.java
Patch:
@@ -265,7 +265,7 @@ public void shouldMatchLambdaConsideringTypeHierarchy() {
         final SpecialFunction lambda = String::valueOf;
         final String actual = Match
                 .whenType(SameSignatureAsSpecialFunction.class).then(f -> f.apply(1))
-                .whenIsApplicable((Function1<Integer, String> f) -> f.apply(2)).thenApply()
+                .whenApplicable((Function1<Integer, String> f) -> f.apply(2)).thenApply()
                 .apply(lambda);
         assertThat(actual).isEqualTo("2");
     }

File: src/test/java/javaslang/control/OptionTest.java
Patch:
@@ -157,8 +157,8 @@ public void shouldReturnNoneOnFilterWhenValueIsNotPresentAndPredicateNotMatches(
     // -- flatten(Function)
 
     static final Match<Option<Integer>> MATCH = Match
-        .whenIsApplicable((Option<Integer> o) -> o).thenApply()
-        .whenIsApplicable((Integer i) -> new Some<>(i)).thenApply();
+        .whenApplicable((Option<Integer> o) -> o).thenApply()
+        .whenApplicable((Integer i) -> new Some<>(i)).thenApply();
 
     @Test
     public void shouldFlattenUnnestedSomeWithFunction() {

File: src/test/java/javaslang/control/TryTest.java
Patch:
@@ -26,7 +26,7 @@ public class TryTest {
     // -- flatten(Function)
 
     static final Match<Try<Integer>> MATCH = Match
-        .whenIsApplicable((Try<Integer> o) -> o).thenApply()
+        .whenApplicable((Try<Integer> o) -> o).thenApply()
         .whenType(Integer.class).then(Success::new);
 
     @Test

File: src/test/java/javaslang/control/TryTest.java
Patch:
@@ -26,8 +26,8 @@ public class TryTest {
     // -- flatten(Function)
 
     static final Match<Try<Integer>> MATCH = Match
-        .when((Try<Integer> o) -> o)
-        .when((Integer i) -> new Success<>(i));
+        .whenType(Try.class).<Try<Integer>> then(o -> o)
+        .whenType(Integer.class).then(Success::new);
 
     @Test
     public void shouldFlattenUnnestedSuccessWithFunction() {

File: src/test/java/javaslang/control/MatchTest.java
Patch:
@@ -20,8 +20,8 @@ public class MatchTest {
     @Test
     public void shouldSpecifyMatchExpressionType() {
         final Match<Number> toNumber = Match.as(Number.class)
-                .when((Integer i) -> i)
-                .when((String s) -> new BigDecimal(s));
+                .whenType(Integer.class).then(i -> i)
+                .whenType(String.class).then(BigDecimal::new);
         assertThat(toNumber.apply("1")).isNotNull();
     }
 

File: src/main/java/javaslang/collection/Queue.java
Patch:
@@ -40,7 +40,7 @@
  * See Okasaki, Chris: <em>Purely Functional Data Structures</em> (p. 42 ff.). Cambridge, 2003.
  *
  * @param <T> Component type of the Queue
- * @since 1.3.0
+ * @since 1.9.9
  */
 public class Queue<T> implements Seq<T>, Serializable {
 

File: src/main/java/javaslang/collection/Stack.java
Patch:
@@ -34,7 +34,7 @@
  * See Okasaki, Chris: <em>Purely Functional Data Structures</em> (p. 7 ff.). Cambridge, 2003.
  *
  * @param <T> component type
- * @since 1.3.0
+ * @since 1.9.9
  */
 public interface Stack<T> extends Seq<T> {
 

File: src/main/java/javaslang/collection/TraversableOnce.java
Patch:
@@ -13,7 +13,7 @@
  * Interface to reduce code duplication of Iterables and Traversables.
  *
  * @param <T> element type of Iterable
- * @since 1.3.0
+ * @since 1.9.9
  */
 public interface TraversableOnce<T> extends Iterable<T> {
 

File: src/main/java/javaslang/control/Option.java
Patch:
@@ -5,6 +5,7 @@
  */
 package javaslang.control;
 
+import javaslang.Value;
 import javaslang.collection.TraversableOnce;
 
 import java.util.Collections;
@@ -32,7 +33,7 @@
  * @param <T> The type of the optional value.
  * @since 1.0.0
  */
-public interface Option<T> extends TraversableOnce<T> {
+public interface Option<T> extends TraversableOnce<T>, Value<T> {
 
     /**
      * Creates a new Option of a given value.

File: src/test/java/javaslang/collection/StreamTest.java
Patch:
@@ -85,7 +85,7 @@ public void shouldGenerateInfiniteStreamBasedOnSupplierWithAccessToPreviousValue
     // -- static gen(T, Supplier)
     @Test
     public void shouldBuildStreamBasedOnHeadAndTailSupplierWithAccessToHead() {
-        assertThat(Stream.gen(1, () -> Stream.gen(2, () -> Stream.nil()))).isEqualTo(Stream.of(1, 2));
+        assertThat(Stream.gen(1, () -> Stream.gen(2, Stream::nil))).isEqualTo(Stream.of(1, 2));
     }
 
     // -- static nil()
@@ -107,7 +107,7 @@ public void shouldCreateStreamOfStreamUsingCons() {
     @Test
     public void shouldCreateStreamOfElements() {
         final Stream<Integer> actual = Stream.of(1, 2);
-        final Stream<Integer> expected = new Cons<>(1, () -> new Cons<>(2, Nil::instance));
+        final Stream<Integer> expected = new Cons<>(() -> 1, () -> new Cons<>(() -> 2, Nil::instance));
         assertThat(actual).isEqualTo(expected);
     }
 
@@ -252,7 +252,7 @@ public void shouldStringifyNonNilEvaluatingFirstTail() {
 
     @Test(expected = InvalidObjectException.class)
     public void shouldNotSerializeEnclosingClassOfCons() throws Throwable {
-        Serializables.callReadObject(new Cons<>(1, Nil::instance));
+        Serializables.callReadObject(new Cons<>(() -> 1, Nil::instance));
     }
 
     @Test(expected = InvalidObjectException.class)

File: src/test/java/javaslang/collection/StreamTest.java
Patch:
@@ -85,7 +85,7 @@ public void shouldGenerateInfiniteStreamBasedOnSupplierWithAccessToPreviousValue
     // -- static gen(T, Supplier)
     @Test
     public void shouldBuildStreamBasedOnHeadAndTailSupplierWithAccessToHead() {
-        assertThat(Stream.gen(1, () -> Stream.gen(2, () -> Stream.nil()))).isEqualTo(Stream.of(1, 2));
+        assertThat(Stream.gen(1, () -> Stream.gen(2, Stream::nil))).isEqualTo(Stream.of(1, 2));
     }
 
     // -- static nil()
@@ -107,7 +107,7 @@ public void shouldCreateStreamOfStreamUsingCons() {
     @Test
     public void shouldCreateStreamOfElements() {
         final Stream<Integer> actual = Stream.of(1, 2);
-        final Stream<Integer> expected = new Cons<>(1, () -> new Cons<>(2, Nil::instance));
+        final Stream<Integer> expected = new Cons<>(() -> 1, () -> new Cons<>(() -> 2, Nil::instance));
         assertThat(actual).isEqualTo(expected);
     }
 
@@ -252,7 +252,7 @@ public void shouldStringifyNonNilEvaluatingFirstTail() {
 
     @Test(expected = InvalidObjectException.class)
     public void shouldNotSerializeEnclosingClassOfCons() throws Throwable {
-        Serializables.callReadObject(new Cons<>(1, Nil::instance));
+        Serializables.callReadObject(new Cons<>(() -> 1, Nil::instance));
     }
 
     @Test(expected = InvalidObjectException.class)

File: src/main/java/javaslang/control/Try.java
Patch:
@@ -261,7 +261,7 @@ default Try<Void> andThen(CheckedRunnable runnable) {
      * Runs the given checked consumer if this is a {@code Success},
      * passing the result of the current expression to it.
      * If this expression is a {@code Failure} then it'll return a new
-     * {@code Failure} of type Void with the original exception.
+     * {@code Failure} of type T with the original exception.
      *
      * The main use case is chaining checked functions using method references:
      *

File: src/test/java/javaslang/TypeConsistencyTest.java
Patch:
@@ -44,6 +44,7 @@ public class TypeConsistencyTest {
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.map(java.util.function.Function)",
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.peek(java.util.function.Consumer)",
             "javaslang.control.Success//public default javaslang.control.Try javaslang.control.Try.andThen(javaslang.control.Try$CheckedRunnable)",
+            "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.andThen(javaslang.control.Try$CheckedConsumer)",
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.mapTry(javaslang.CheckedFunction1)",
 
             // control.None

File: src/main/java/javaslang/control/Option.java
Patch:
@@ -205,10 +205,10 @@ default <U> Option<U> flatMap(Function<? super T, ? extends Option<U>> mapper) {
 
     @Override
     default Iterator<T> iterator() {
-        if (isDefined()) {
-            return Collections.singleton(get()).iterator();
-        } else {
+        if (isEmpty()) {
             return Collections.emptyIterator();
+        } else {
+            return Collections.singleton(get()).iterator();
         }
     }
 

File: src/main/java/javaslang/concurrent/Future.java
Patch:
@@ -181,6 +181,8 @@ synchronized void complete(Try<T> result) {
 //
 //            assert callBacks.isEmpty();
         }
+	    else
+	        throw new IllegalStateException("This Future has already been completed!");
         //TODO: else throw exception maybe?
     }
 

File: src/main/java/javaslang/concurrent/Promise.java
Patch:
@@ -83,7 +83,6 @@ public void completeWith(Future<T> source) {
 		    throw new IllegalArgumentException("Can't complete a Future with itself!");
 
 	    if(!completed){
-		    completed = true;
             source.onCompletedTry(this::complete);
 	    } else
 		    throw new IllegalStateException("This Promise has already been completed!");

File: src/main/java/javaslang/.java
Patch:
@@ -104,7 +104,7 @@ static MethodType getLambdaSignature(Serializable lambda) {
      * Returns a memoizing version of this function, which computes the return value for given arguments only one time.
      * On subsequent calls given the same arguments the memoized value is returned.
      * <p>
-     * Please not that memoizing functions do not permit `null` as single argument or return value.
+     * Please note that memoizing functions do not permit `null` as single argument or return value.
      *
      * @return a memoizing function equivalent to this.
      */

File: src/main/java/javaslang/.java
Patch:
@@ -104,7 +104,7 @@ static MethodType getLambdaSignature(Serializable lambda) {
      * Returns a memoizing version of this function, which computes the return value for given arguments only one time.
      * On subsequent calls given the same arguments the memoized value is returned.
      * <p>
-     * Please not that memoizing functions do not permit `null` as single argument or return value.
+     * Please note that memoizing functions do not permit `null` as single argument or return value.
      *
      * @return a memoizing function equivalent to this.
      */

File: src/test/java/javaslang/TypeConsistencyTest.java
Patch:
@@ -44,6 +44,7 @@ public class TypeConsistencyTest {
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.map(java.util.function.Function)",
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.peek(java.util.function.Consumer)",
             "javaslang.control.Success//public default javaslang.control.Try javaslang.control.Try.andThen(javaslang.control.Try$CheckedRunnable)",
+            "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.andThen(javaslang.CheckedFunction1)",
 
             // control.None
             "javaslang.control.None//public default javaslang.control.Option javaslang.control.Option.filter(java.util.function.Predicate)",

File: src/test/java/javaslang/control/TryTest.java
Patch:
@@ -349,10 +349,10 @@ public void shouldChainSuccessWithAndThen() {
     public void shouldChainFailureWithAndThen() {
         final Try<Integer> actual = Try.of(() -> 100)
                 .andThen(x -> x + 100)
-                .andThen(x -> x / 0)   //Div by zero, throws exception.
-                .andThen(x -> x + 50);
+                .andThen(x -> Integer.parseInt("aaa") + x)   //Throws exception.
+                .andThen(x -> x / 2);
 
-        final Try<Integer> expected = new Failure<>(new ArithmeticException("/ by zero"));
+        final Try<Integer> expected = new Failure<>(new NumberFormatException("For input string: \"aaa\""));
         assertThat(actual).isEqualTo(expected);
     }
 

File: src/main/java/javaslang/collection/Stack.java
Patch:
@@ -19,10 +19,11 @@
  *
  * <ul>
  * <li>{@link #peek()}</li>
+ * <li>{@link #peekOption()}</li>
  * <li>{@link #pop()}</li>
  * <li>{@link #popOption()}</li>
- * <li>{@link #peek()}</li>
- * <li>{@link #peekOption()}</li>
+ * <li>{@link #pop2()}</li>
+ * <li>{@link #pop2Option()}</li>
  * <li>{@link #push(Object)}</li>
  * </ul>
  *

File: src/test/java/javaslang/control/TryTest.java
Patch:
@@ -151,7 +151,7 @@ public void shouldDetectFatalException() throws Exception {
 
     @Test
     public void shouldDetectNonFatalException() throws Exception {
-        final Failure.Cause cause = Failure.Cause.of(new StackOverflowError());
+        final Failure.Cause cause = Failure.Cause.of(new Exception());
         assertThat(cause.isFatal()).isFalse();
     }
 

File: src/test/java/javaslang/control/TryTest.java
Patch:
@@ -151,7 +151,7 @@ public void shouldDetectFatalException() throws Exception {
 
     @Test
     public void shouldDetectNonFatalException() throws Exception {
-        final Failure.Cause cause = Failure.Cause.of(new StackOverflowError());
+        final Failure.Cause cause = Failure.Cause.of(new Exception());
         assertThat(cause.isFatal()).isFalse();
     }
 

File: src/main/java/javaslang/control/Failure.java
Patch:
@@ -199,7 +199,7 @@ public static abstract class Cause extends RuntimeException implements Serializa
          * <li>InterruptedException</li>
          * <li>LinkageError</li>
          * <li>ThreadDeath</li>
-         * <li>VirtualMachineError (i.e. OutOfMemoryError)</li>
+         * <li>VirtualMachineError (i.e. OutOfMemoryError or StackOverflowError)</li>
          * </ul>
          *
          * However, StackOverflowError is considered as a non-fatal.
@@ -213,7 +213,7 @@ public static Cause of(Throwable t) {
             if (t instanceof Cause) {
                 return (Cause) t;
             }
-            final boolean isFatal = (t instanceof VirtualMachineError && !(t instanceof StackOverflowError))
+            final boolean isFatal = t instanceof VirtualMachineError
                     || t instanceof ThreadDeath
                     || t instanceof InterruptedException
                     || t instanceof LinkageError;

File: src/main/java/javaslang/control/Failure.java
Patch:
@@ -199,7 +199,7 @@ public static abstract class Cause extends RuntimeException implements Serializa
          * <li>InterruptedException</li>
          * <li>LinkageError</li>
          * <li>ThreadDeath</li>
-         * <li>VirtualMachineError (i.e. OutOfMemoryError)</li>
+         * <li>VirtualMachineError (i.e. OutOfMemoryError or StackOverflowError)</li>
          * </ul>
          *
          * However, StackOverflowError is considered as a non-fatal.
@@ -213,7 +213,7 @@ public static Cause of(Throwable t) {
             if (t instanceof Cause) {
                 return (Cause) t;
             }
-            final boolean isFatal = (t instanceof VirtualMachineError && !(t instanceof StackOverflowError))
+            final boolean isFatal = t instanceof VirtualMachineError
                     || t instanceof ThreadDeath
                     || t instanceof InterruptedException
                     || t instanceof LinkageError;

File: src-gen/main/java/javaslang/CheckedFunction0.java
Patch:
@@ -68,8 +68,7 @@ default CheckedFunction0<R> reversed() {
 
     @Override
     default CheckedFunction0<R> memoized() {
-        final Lazy<R> cache = Lazy.of(() -> Try.of(this::apply).get());
-        return cache::get;
+        return Lazy.of(() -> Try.of(this::apply).get())::get;
     }
 
     /**

File: src-gen/main/java/javaslang/CheckedFunction1.java
Patch:
@@ -83,9 +83,8 @@ default CheckedFunction1<T1, R> reversed() {
 
     @Override
     default CheckedFunction1<T1, R> memoized() {
-        final Map<Tuple1<T1>, R> cache = new ConcurrentHashMap<>();
-        final CheckedFunction1<Tuple1<T1>, R> tupled = tupled();
-        return (t1) -> cache.computeIfAbsent(Tuple.of(t1), t -> Try.of(() -> tupled.apply(t)).get());
+        final Map<T1, R> cache = new ConcurrentHashMap<>();
+        return t1 -> cache.computeIfAbsent(t1, t -> Try.of(() -> this.apply(t)).get());
     }
 
     /**

File: src-gen/main/java/javaslang/Function2.java
Patch:
@@ -13,7 +13,6 @@
 import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.BiFunction;
-import javaslang.control.Try;
 
 /**
  * Represents a function with two arguments.

File: src-gen/main/java/javaslang/Function3.java
Patch:
@@ -12,7 +12,6 @@
 import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
-import javaslang.control.Try;
 
 /**
  * Represents a function with three arguments.

File: src-gen/main/java/javaslang/Function4.java
Patch:
@@ -12,7 +12,6 @@
 import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
-import javaslang.control.Try;
 
 /**
  * Represents a function with 4 arguments.

File: src-gen/main/java/javaslang/Function5.java
Patch:
@@ -12,7 +12,6 @@
 import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
-import javaslang.control.Try;
 
 /**
  * Represents a function with 5 arguments.

File: src-gen/main/java/javaslang/Function6.java
Patch:
@@ -12,7 +12,6 @@
 import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
-import javaslang.control.Try;
 
 /**
  * Represents a function with 6 arguments.

File: src-gen/main/java/javaslang/Function7.java
Patch:
@@ -12,7 +12,6 @@
 import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
-import javaslang.control.Try;
 
 /**
  * Represents a function with 7 arguments.

File: src-gen/main/java/javaslang/Function8.java
Patch:
@@ -12,7 +12,6 @@
 import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
-import javaslang.control.Try;
 
 /**
  * Represents a function with 8 arguments.

File: src/main/java/javaslang/.java
Patch:
@@ -103,6 +103,8 @@ static MethodType getLambdaSignature(Serializable lambda) {
     /**
      * Returns a memoizing version of this function, which computes the return value for given arguments only one time.
      * On subsequent calls given the same arguments the memoized value is returned.
+     * <p>
+     * Please not that memoizing functions do not permit `null` as single argument or return value.
      *
      * @return a memoizing function equivalent to this.
      */

File: src-gen/main/java/javaslang/CheckedFunction0.java
Patch:
@@ -43,6 +43,7 @@ static <R> CheckedFunction0<R> lift(CheckedFunction0<R> methodReference) {
      * On subsequent calls given the same arguments the memoized value is returned.
      *
      * @param <R> return type
+     * @param f a function
      * @return a memoizing function
      */
     static <R> CheckedFunction0<R> memoize(CheckedFunction0<R> f) {

File: src-gen/main/java/javaslang/CheckedFunction1.java
Patch:
@@ -58,6 +58,7 @@ static <T> CheckedFunction1<T, T> identity() {
      *
      * @param <R> return type
      * @param <T1> 1st argument
+     * @param f a function
      * @return a memoizing function
      */
     static <T1, R> CheckedFunction1<T1, R> memoize(CheckedFunction1<T1, R> f) {

File: src-gen/main/java/javaslang/CheckedFunction2.java
Patch:
@@ -51,6 +51,7 @@ static <T1, T2, R> CheckedFunction2<T1, T2, R> lift(CheckedFunction2<T1, T2, R>
      * @param <R> return type
      * @param <T1> 1st argument
      * @param <T2> 2nd argument
+     * @param f a function
      * @return a memoizing function
      */
     static <T1, T2, R> CheckedFunction2<T1, T2, R> memoize(CheckedFunction2<T1, T2, R> f) {

File: src-gen/main/java/javaslang/CheckedFunction3.java
Patch:
@@ -54,6 +54,7 @@ static <T1, T2, T3, R> CheckedFunction3<T1, T2, T3, R> lift(CheckedFunction3<T1,
      * @param <T1> 1st argument
      * @param <T2> 2nd argument
      * @param <T3> 3rd argument
+     * @param f a function
      * @return a memoizing function
      */
     static <T1, T2, T3, R> CheckedFunction3<T1, T2, T3, R> memoize(CheckedFunction3<T1, T2, T3, R> f) {

File: src-gen/main/java/javaslang/CheckedFunction4.java
Patch:
@@ -57,6 +57,7 @@ static <T1, T2, T3, T4, R> CheckedFunction4<T1, T2, T3, T4, R> lift(CheckedFunct
      * @param <T2> 2nd argument
      * @param <T3> 3rd argument
      * @param <T4> 4th argument
+     * @param f a function
      * @return a memoizing function
      */
     static <T1, T2, T3, T4, R> CheckedFunction4<T1, T2, T3, T4, R> memoize(CheckedFunction4<T1, T2, T3, T4, R> f) {

File: src-gen/main/java/javaslang/CheckedFunction5.java
Patch:
@@ -60,6 +60,7 @@ static <T1, T2, T3, T4, T5, R> CheckedFunction5<T1, T2, T3, T4, T5, R> lift(Chec
      * @param <T3> 3rd argument
      * @param <T4> 4th argument
      * @param <T5> 5th argument
+     * @param f a function
      * @return a memoizing function
      */
     static <T1, T2, T3, T4, T5, R> CheckedFunction5<T1, T2, T3, T4, T5, R> memoize(CheckedFunction5<T1, T2, T3, T4, T5, R> f) {

File: src-gen/main/java/javaslang/CheckedFunction6.java
Patch:
@@ -63,6 +63,7 @@ static <T1, T2, T3, T4, T5, T6, R> CheckedFunction6<T1, T2, T3, T4, T5, T6, R> l
      * @param <T4> 4th argument
      * @param <T5> 5th argument
      * @param <T6> 6th argument
+     * @param f a function
      * @return a memoizing function
      */
     static <T1, T2, T3, T4, T5, T6, R> CheckedFunction6<T1, T2, T3, T4, T5, T6, R> memoize(CheckedFunction6<T1, T2, T3, T4, T5, T6, R> f) {

File: src-gen/main/java/javaslang/CheckedFunction7.java
Patch:
@@ -66,6 +66,7 @@ static <T1, T2, T3, T4, T5, T6, T7, R> CheckedFunction7<T1, T2, T3, T4, T5, T6,
      * @param <T5> 5th argument
      * @param <T6> 6th argument
      * @param <T7> 7th argument
+     * @param f a function
      * @return a memoizing function
      */
     static <T1, T2, T3, T4, T5, T6, T7, R> CheckedFunction7<T1, T2, T3, T4, T5, T6, T7, R> memoize(CheckedFunction7<T1, T2, T3, T4, T5, T6, T7, R> f) {

File: src-gen/main/java/javaslang/CheckedFunction8.java
Patch:
@@ -69,6 +69,7 @@ static <T1, T2, T3, T4, T5, T6, T7, T8, R> CheckedFunction8<T1, T2, T3, T4, T5,
      * @param <T6> 6th argument
      * @param <T7> 7th argument
      * @param <T8> 8th argument
+     * @param f a function
      * @return a memoizing function
      */
     static <T1, T2, T3, T4, T5, T6, T7, T8, R> CheckedFunction8<T1, T2, T3, T4, T5, T6, T7, T8, R> memoize(CheckedFunction8<T1, T2, T3, T4, T5, T6, T7, T8, R> f) {

File: src-gen/main/java/javaslang/Function0.java
Patch:
@@ -43,6 +43,7 @@ static <R> Function0<R> lift(Function0<R> methodReference) {
      * On subsequent calls given the same arguments the memoized value is returned.
      *
      * @param <R> return type
+     * @param f a function
      * @return a memoizing function
      */
     static <R> Function0<R> memoize(Function0<R> f) {

File: src-gen/main/java/javaslang/Function1.java
Patch:
@@ -58,6 +58,7 @@ static <T> Function1<T, T> identity() {
      *
      * @param <R> return type
      * @param <T1> 1st argument
+     * @param f a function
      * @return a memoizing function
      */
     static <T1, R> Function1<T1, R> memoize(Function1<T1, R> f) {

File: src-gen/main/java/javaslang/Function2.java
Patch:
@@ -51,6 +51,7 @@ static <T1, T2, R> Function2<T1, T2, R> lift(Function2<T1, T2, R> methodReferenc
      * @param <R> return type
      * @param <T1> 1st argument
      * @param <T2> 2nd argument
+     * @param f a function
      * @return a memoizing function
      */
     static <T1, T2, R> Function2<T1, T2, R> memoize(Function2<T1, T2, R> f) {

File: src-gen/main/java/javaslang/Function3.java
Patch:
@@ -54,6 +54,7 @@ static <T1, T2, T3, R> Function3<T1, T2, T3, R> lift(Function3<T1, T2, T3, R> me
      * @param <T1> 1st argument
      * @param <T2> 2nd argument
      * @param <T3> 3rd argument
+     * @param f a function
      * @return a memoizing function
      */
     static <T1, T2, T3, R> Function3<T1, T2, T3, R> memoize(Function3<T1, T2, T3, R> f) {

File: src-gen/main/java/javaslang/Function4.java
Patch:
@@ -57,6 +57,7 @@ static <T1, T2, T3, T4, R> Function4<T1, T2, T3, T4, R> lift(Function4<T1, T2, T
      * @param <T2> 2nd argument
      * @param <T3> 3rd argument
      * @param <T4> 4th argument
+     * @param f a function
      * @return a memoizing function
      */
     static <T1, T2, T3, T4, R> Function4<T1, T2, T3, T4, R> memoize(Function4<T1, T2, T3, T4, R> f) {

File: src-gen/main/java/javaslang/Function5.java
Patch:
@@ -60,6 +60,7 @@ static <T1, T2, T3, T4, T5, R> Function5<T1, T2, T3, T4, T5, R> lift(Function5<T
      * @param <T3> 3rd argument
      * @param <T4> 4th argument
      * @param <T5> 5th argument
+     * @param f a function
      * @return a memoizing function
      */
     static <T1, T2, T3, T4, T5, R> Function5<T1, T2, T3, T4, T5, R> memoize(Function5<T1, T2, T3, T4, T5, R> f) {

File: src-gen/main/java/javaslang/Function6.java
Patch:
@@ -63,6 +63,7 @@ static <T1, T2, T3, T4, T5, T6, R> Function6<T1, T2, T3, T4, T5, T6, R> lift(Fun
      * @param <T4> 4th argument
      * @param <T5> 5th argument
      * @param <T6> 6th argument
+     * @param f a function
      * @return a memoizing function
      */
     static <T1, T2, T3, T4, T5, T6, R> Function6<T1, T2, T3, T4, T5, T6, R> memoize(Function6<T1, T2, T3, T4, T5, T6, R> f) {

File: src-gen/main/java/javaslang/Function7.java
Patch:
@@ -66,6 +66,7 @@ static <T1, T2, T3, T4, T5, T6, T7, R> Function7<T1, T2, T3, T4, T5, T6, T7, R>
      * @param <T5> 5th argument
      * @param <T6> 6th argument
      * @param <T7> 7th argument
+     * @param f a function
      * @return a memoizing function
      */
     static <T1, T2, T3, T4, T5, T6, T7, R> Function7<T1, T2, T3, T4, T5, T6, T7, R> memoize(Function7<T1, T2, T3, T4, T5, T6, T7, R> f) {

File: src-gen/main/java/javaslang/Function8.java
Patch:
@@ -69,6 +69,7 @@ static <T1, T2, T3, T4, T5, T6, T7, T8, R> Function8<T1, T2, T3, T4, T5, T6, T7,
      * @param <T6> 6th argument
      * @param <T7> 7th argument
      * @param <T8> 8th argument
+     * @param f a function
      * @return a memoizing function
      */
     static <T1, T2, T3, T4, T5, T6, T7, T8, R> Function8<T1, T2, T3, T4, T5, T6, T7, T8, R> memoize(Function8<T1, T2, T3, T4, T5, T6, T7, T8, R> f) {

File: src/main/java/javaslang/collection/Tree.java
Patch:
@@ -5,7 +5,6 @@
  */
 package javaslang.collection;
 
-import javaslang.algebra.Functor;
 import javaslang.control.Match;
 
 import java.util.*;
@@ -17,7 +16,7 @@
  * @param <T> component type of this Tree
  * @since 1.1.0
  */
-public interface Tree<T> extends Functor<T>, Iterable<T> {
+public interface Tree<T> extends Iterable<T> {
 
     /**
      * Gets the value of this tree.
@@ -198,7 +197,6 @@ List<T> levelOrder(Tree<T> tree) {
         }
     }
 
-    @Override
     <U> Tree<U> map(Function<? super T, ? extends U> mapper);
 
     /**

File: src/main/java/javaslang/control/Success.java
Patch:
@@ -5,8 +5,6 @@
  */
 package javaslang.control;
 
-import javaslang.Kind;
-
 import java.io.Serializable;
 import java.util.NoSuchElementException;
 import java.util.Objects;
@@ -144,7 +142,7 @@ public <U> Try<U> map(CheckedFunction<? super T, ? extends U> mapper) {
 
     @SuppressWarnings("unchecked")
     @Override
-    public <U> Try<U> flatMap(CheckedFunction<? super T, ? extends Kind<Try<?>, U>> mapper) {
+    public <U> Try<U> flatMap(CheckedFunction<? super T, ? extends Try<U>> mapper) {
         try {
             return (Try<U>) mapper.apply(value);
         } catch (Throwable t) {

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -363,6 +363,9 @@ default Iterator<T> iterator(int index) {
     @Override
     Seq<M, T> takeWhile(Predicate<? super T> predicate);
 
+    @Override
+    <U> Seq<M, U> transform(Function<? super Kind<M, T>, ? extends Kind<M, U>> f);
+
     @Override
     <T1, T2> Tuple2<? extends Seq<M, T1>, ? extends Seq<M, T2>> unzip(Function<? super T, Tuple2<? extends T1, ? extends T2>> unzipper);
 

File: src/main/java/javaslang/Lazy.java
Patch:
@@ -59,7 +59,7 @@ public boolean isDefined() {
     }
 
     /**
-     * Evaluates this lazy value and caches it, when called the first type.
+     * Evaluates this lazy value and caches it, when called the first time.
      * On subsequent calls, returns the cached value.
      *
      * @return the lazy evaluated value

File: src/main/java/javaslang/collection/BinaryTree.java
Patch:
@@ -14,7 +14,7 @@
 /**
  * A binary tree implementation where each node keeps a value.
  * <p>
- * A binary tree consists of branches (nodes with children) and leafs (nodes without children).
+ * A binary tree consists of branches (nodes with children) and leaves (nodes without children).
  * A branch has a left and a right child, at least one child is not Nil. The empty tree is represented by Nil.
  * <pre>
  *     <code>BinaryTree = Nil | Leaf(value) | Branch(BinaryTree left, value, BinaryTree right)</code>

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -71,7 +71,7 @@ static <T> Collector<T, ArrayList<T>, List<T>> collector() {
      * Returns the single instance of Nil. Convenience method for {@code Nil.instance()} .
      * <p>
      * Note: this method intentionally returns type {@code List} and not {@code Nil}. This comes handy when folding.
-     * If you explicitely need type {@code Nil} use {@linkplain Nil#instance()}.
+     * If you explicitly need type {@code Nil} use {@linkplain Nil#instance()}.
      *
      * @param <T> Component type of Nil, determined by type inference in the particular context.
      * @return The empty list.

File: src/main/java/javaslang/collection/RoseTree.java
Patch:
@@ -20,7 +20,7 @@
 public interface RoseTree<T> extends Tree<T> {
 
     /**
-     * Creates a either a rose tree branch or a leaf, depending on the child count.
+     * Creates either a rose tree branch or a leaf, depending on the child count.
      * By definition, a node with no children is a leaf.
      *
      * @param value    The value of the node.
@@ -52,7 +52,7 @@ static <T> NonNil<T> of(T value, NonNil<T>... children) {
     @SafeVarargs
     @SuppressWarnings("varargs")
     static <T> Branch<T> branch(T value, NonNil<T> child1, NonNil<T>... children) {
-        Objects.requireNonNull(children, "child1 is null");
+        Objects.requireNonNull(child1, "child1 is null");
         Objects.requireNonNull(children, "children is null");
         final List<NonNil<T>> list = List.of(children).prepend(child1);
         return new Branch<>(value, list);

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -40,7 +40,7 @@
  * <li>{@link #sort(Comparator)}</li>
  * <li>{@link #splitAt(int)}</li>
  * </ul>
- * <p>Traversion:</p>
+ * <p>Traversal:</p>
  * <ul>
  * <li>{@link #iterator(int)}</li>
  * </ul>

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -102,7 +102,7 @@ static <T> Stream<T> gen(Supplier<T> supplier) {
      * Returns the single instance of Nil. Convenience method for {@code Nil.instance()}.
      * <p>
      * Note: this method intentionally returns type {@code Stream} and not {@code Nil}. This comes handy when folding.
-     * If you explicitely need type {@code Nil} use {@linkplain Nil#instance()}.
+     * If you explicitly need type {@code Nil} use {@linkplain Nil#instance()}.
      *
      * @param <T> Component type of Nil, determined by type inference in the particular context.
      * @return The empty list.

File: src/main/java/javaslang/.java
Patch:
@@ -54,7 +54,7 @@ static SerializedLambda getSerializedLambda(Serializable lambda) {
 
     /**
      * <p>
-     * Gets the runtime method signature of the given lambda instance. Especially this function is handy when the
+     * Gets the runtime method signature of the given lambda instance. This function is especially handy when the
      * functional interface is generic and the parameter and/or return types cannot be determined directly.
      * </p>
      * <p>
@@ -72,7 +72,7 @@ static MethodType getLambdaSignature(Serializable lambda) {
     }
 
     /**
-     * @return the numper of function arguments.
+     * @return the number of function arguments.
      * @see <a href="http://en.wikipedia.org/wiki/Arity">Arity</a>
      */
     int arity();

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -363,6 +363,9 @@ default Iterator<T> iterator(int index) {
     @Override
     Seq<M, T> takeWhile(Predicate<? super T> predicate);
 
+    @Override
+    <U> Seq<M, U> transform(Function<? super Kind<M, T>, ? extends Kind<M, U>> f);
+
     @Override
     <T1, T2> Tuple2<? extends Seq<M, T1>, ? extends Seq<M, T2>> unzip(Function<? super T, Tuple2<? extends T1, ? extends T2>> unzipper);
 

File: src/test/java/javaslang/collection/AbstractTraversableTest.java
Patch:
@@ -470,12 +470,12 @@ public void shouldFoldRightNonNil() {
 
     @Test
     public void shouldBeAwareOfPropertyThatHoldsForAll() {
-        assertThat(List.of(2, 4).forAll(i -> i % 2 == 0)).isTrue();
+        assertThat(of(2, 4).forAll(i -> i % 2 == 0)).isTrue();
     }
 
     @Test
     public void shouldBeAwareOfPropertyThatNotHoldsForAll() {
-        assertThat(List.of(2, 3).forAll(i -> i % 2 == 0)).isFalse();
+        assertThat(of(2, 3).forAll(i -> i % 2 == 0)).isFalse();
     }
 
     // -- grouped
@@ -1458,7 +1458,7 @@ public void shouldConvertNilToJavaArray() {
 
     @Test
     public void shouldConvertNonNilToJavaArray() {
-        final Integer[] array = List.of(1, 2).toJavaArray(Integer.class);
+        final Integer[] array = of(1, 2).toJavaArray(Integer.class);
         final Integer[] expected = new Integer[]{1, 2};
         assertThat(array).isEqualTo(expected);
     }

File: src/main/java/javaslang/algebra/package-info.java
Patch:
@@ -1,6 +1,6 @@
 /**
  * <p>Algebraic interfaces used to describe inherent class properties like {@linkplain javaslang.algebra.Monad}.</p>
- * <p>Interfaces like {@linkplain javaslang.algebra.HigherKinded} are needed to enhance API design and are mainly used
+ * <p>Interfaces like {@linkplain javaslang.Kind} are needed to enhance API design and are mainly used
  * internally by Javaslang. An example for {@linkplain javaslang.algebra.Monoid} usage is
  * {@link javaslang.collection.Traversable#foldMap(javaslang.algebra.Monoid, java.util.function.Function)}.</p>
  *

File: src/main/java/javaslang/control/Failure.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.control;
 
-import javaslang.algebra.HigherKinded;
+import javaslang.Kind;
 
 import java.io.Serializable;
 import java.util.Objects;
@@ -144,7 +144,7 @@ public <U> Failure<U> map(CheckedFunction<? super T, ? extends U> mapper) {
 
     @SuppressWarnings("unchecked")
     @Override
-    public <U, TRY extends HigherKinded<U, Try<?>>> Failure<U> flatMap(CheckedFunction<? super T, ? extends TRY> mapper) {
+    public <U> Failure<U> flatMap(CheckedFunction<? super T, ? extends Kind<Try<?>, U>> mapper) {
         return (Failure<U>) this;
     }
 

File: src/main/java/javaslang/control/Success.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.control;
 
-import javaslang.algebra.HigherKinded;
+import javaslang.Kind;
 
 import java.io.Serializable;
 import java.util.NoSuchElementException;
@@ -144,7 +144,7 @@ public <U> Try<U> map(CheckedFunction<? super T, ? extends U> mapper) {
 
     @SuppressWarnings("unchecked")
     @Override
-    public <U, TRY extends HigherKinded<U, Try<?>>> Try<U> flatMap(CheckedFunction<? super T, ? extends TRY> mapper) {
+    public <U> Try<U> flatMap(CheckedFunction<? super T, ? extends Kind<Try<?>, U>> mapper) {
         try {
             return (Try<U>) mapper.apply(value);
         } catch (Throwable t) {

File: src/test/java/javaslang/control/OptionTest.java
Patch:
@@ -418,7 +418,7 @@ public void shouldSatisfyFunctorComposition() {
     @Test
     @Override
     public void shouldSatisfyMonadLeftIdentity() {
-        final Arbitrary<Function<? super Integer, ? extends Monad<String, Option<?>>>> mappers =
+        final Arbitrary<Function<? super Integer, ? extends Monad<Option<?>, String>>> mappers =
                 size -> random -> i -> Option.of(i).map(String::valueOf);
         final CheckResult result = checkMonadLeftIdentity(Option::of, INTEGERS, mappers);
         CheckResultAssertions.assertThat(result).isSatisfiedWithExhaustion(false);
@@ -434,9 +434,9 @@ public void shouldSatisfyMonadRightIdentity() {
     @Test
     @Override
     public void shouldSatisfyMonadAssociativity() {
-        final Arbitrary<Function<? super Integer, ? extends Monad<Double, Option<?>>>> before =
+        final Arbitrary<Function<? super Integer, ? extends Monad<Option<?>, Double>>> before =
                 size -> random -> i -> Option.of(i).map(Double::valueOf);
-        final Arbitrary<Function<? super Double, ? extends Monad<String, Option<?>>>> after =
+        final Arbitrary<Function<? super Double, ? extends Monad<Option<?>, String>>> after =
                 size -> random -> d -> Option.of(d).map(String::valueOf);
         final CheckResult result = checkMonadAssociativity(OPTIONS, before, after);
         CheckResultAssertions.assertThat(result).isSatisfiedWithExhaustion(false);

File: src/main/java/javaslang/algebra/package-info.java
Patch:
@@ -1,6 +1,6 @@
 /**
  * <p>Algebraic interfaces used to describe inherent class properties like {@linkplain javaslang.algebra.Monad}.</p>
- * <p>Interfaces like {@linkplain javaslang.algebra.HigherKinded} are needed to enhance API design and are mainly used
+ * <p>Interfaces like {@linkplain javaslang.algebra.Kind} are needed to enhance API design and are mainly used
  * internally by Javaslang. An example for {@linkplain javaslang.algebra.Monoid} usage is
  * {@link javaslang.collection.Traversable#foldMap(javaslang.algebra.Monoid, java.util.function.Function)}.</p>
  *

File: src/main/java/javaslang/control/Failure.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.control;
 
-import javaslang.algebra.HigherKinded;
+import javaslang.algebra.Kind;
 
 import java.io.Serializable;
 import java.util.Objects;
@@ -144,7 +144,7 @@ public <U> Failure<U> map(CheckedFunction<? super T, ? extends U> mapper) {
 
     @SuppressWarnings("unchecked")
     @Override
-    public <U, TRY extends HigherKinded<U, Try<?>>> Failure<U> flatMap(CheckedFunction<? super T, ? extends TRY> mapper) {
+    public <U> Failure<U> flatMap(CheckedFunction<? super T, ? extends Kind<Try<?>, U>> mapper) {
         return (Failure<U>) this;
     }
 

File: src/main/java/javaslang/control/Success.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.control;
 
-import javaslang.algebra.HigherKinded;
+import javaslang.algebra.Kind;
 
 import java.io.Serializable;
 import java.util.NoSuchElementException;
@@ -144,7 +144,7 @@ public <U> Try<U> map(CheckedFunction<? super T, ? extends U> mapper) {
 
     @SuppressWarnings("unchecked")
     @Override
-    public <U, TRY extends HigherKinded<U, Try<?>>> Try<U> flatMap(CheckedFunction<? super T, ? extends TRY> mapper) {
+    public <U> Try<U> flatMap(CheckedFunction<? super T, ? extends Kind<Try<?>, U>> mapper) {
         try {
             return (Try<U>) mapper.apply(value);
         } catch (Throwable t) {

File: src/test/java/javaslang/control/OptionTest.java
Patch:
@@ -418,7 +418,7 @@ public void shouldSatisfyFunctorComposition() {
     @Test
     @Override
     public void shouldSatisfyMonadLeftIdentity() {
-        final Arbitrary<Function<? super Integer, ? extends Monad<String, Option<?>>>> mappers =
+        final Arbitrary<Function<? super Integer, ? extends Monad<Option<?>, String>>> mappers =
                 size -> random -> i -> Option.of(i).map(String::valueOf);
         final CheckResult result = checkMonadLeftIdentity(Option::of, INTEGERS, mappers);
         CheckResultAssertions.assertThat(result).isSatisfiedWithExhaustion(false);
@@ -434,9 +434,9 @@ public void shouldSatisfyMonadRightIdentity() {
     @Test
     @Override
     public void shouldSatisfyMonadAssociativity() {
-        final Arbitrary<Function<? super Integer, ? extends Monad<Double, Option<?>>>> before =
+        final Arbitrary<Function<? super Integer, ? extends Monad<Option<?>, Double>>> before =
                 size -> random -> i -> Option.of(i).map(Double::valueOf);
-        final Arbitrary<Function<? super Double, ? extends Monad<String, Option<?>>>> after =
+        final Arbitrary<Function<? super Double, ? extends Monad<Option<?>, String>>> after =
                 size -> random -> d -> Option.of(d).map(String::valueOf);
         final CheckResult result = checkMonadAssociativity(OPTIONS, before, after);
         CheckResultAssertions.assertThat(result).isSatisfiedWithExhaustion(false);

File: src/main/java/javaslang/package-info.java
Patch:
@@ -1,6 +1,5 @@
 /**
- * <p>The javaslang package contains core types like {@linkplain javaslang.}, {@linkplain javaslang.Tuple} and
- * {@linkplain javaslang.ValueObject}.</p>
+ * <p>The javaslang package contains core types like {@linkplain javaslang.}, {@linkplain javaslang.Lazy} and {@linkplain javaslang.Tuple}.</p>
  *
  * @since 1.0.0
  */

File: src/main/java/javaslang/test/CheckResultAssertions.java
Patch:
@@ -8,7 +8,7 @@
 import java.util.Objects;
 
 /**
- * Assertions targerting on unit tests.
+ * Assertions targeting on unit tests.
  *
  * @since 1.2.0
  */

File: src/main/java/javaslang/package-info.java
Patch:
@@ -1,6 +1,5 @@
 /**
- * <p>The javaslang package contains core types like {@linkplain javaslang.}, {@linkplain javaslang.Tuple} and
- * {@linkplain javaslang.ValueObject}.</p>
+ * <p>The javaslang package contains core types like {@linkplain javaslang.}, {@linkplain javaslang.Lazy} and {@linkplain javaslang.Tuple}.</p>
  *
  * @since 1.0.0
  */

File: src/main/java/javaslang/test/CheckResultAssertions.java
Patch:
@@ -8,7 +8,7 @@
 import java.util.Objects;
 
 /**
- * Assertions targerting on unit tests.
+ * Assertions targeting on unit tests.
  *
  * @since 1.2.0
  */

File: src-gen/test/java/javaslang/test/PropertyTest.java
Patch:
@@ -14,7 +14,7 @@
 import java.util.Random;
 import javaslang.CheckedFunction1;
 import javaslang.Tuple;
-import javaslang.collection.JList;
+import javaslang.collection.List;
 import org.junit.Test;
 
 public class PropertyTest {
@@ -85,8 +85,8 @@ public void shouldCheckPythagoras() {
     @Test
     public void shouldCheckZipAndThenUnzipIsIdempotentForListsOfSameLength() {
         // is,ss: length(is) = length(ss)  unzip(zip(is, ss)) = (is, ss)
-        final Arbitrary<JList<Integer>> ints = Arbitrary.list(size -> Gen.choose(0, size));
-        final Arbitrary<JList<String>> strings = Arbitrary.list(
+        final Arbitrary<List<Integer>> ints = Arbitrary.list(size -> Gen.choose(0, size));
+        final Arbitrary<List<String>> strings = Arbitrary.list(
                 Arbitrary.string(
                     Gen.frequency(
                         Tuple.of(1, Gen.choose('A', 'Z')),

File: src/main/java/javaslang/algebra/package-info.java
Patch:
@@ -2,7 +2,7 @@
  * <p>Algebraic interfaces used to describe inherent class properties like {@linkplain javaslang.algebra.Monad}.</p>
  * <p>Interfaces like {@linkplain javaslang.algebra.HigherKinded} are needed to enhance API design and are mainly used
  * internally by Javaslang. An example for {@linkplain javaslang.algebra.Monoid} usage is
- * {@link javaslang.collection.JTraversable#foldMap(javaslang.algebra.Monoid, java.util.function.Function)}.</p>
+ * {@link javaslang.collection.Traversable#foldMap(javaslang.algebra.Monoid, java.util.function.Function)}.</p>
  *
  * @since 1.1.0
  */

File: src/main/java/javaslang/collection/package-info.java
Patch:
@@ -1,6 +1,6 @@
 /**
- * <p>Immutable collections based on {@linkplain javaslang.collection.JTraversable} like the linked list
- * {@linkplain javaslang.collection.JList} and the lazy linked list {@linkplain javaslang.collection.JStream}.</p>
+ * <p>Immutable collections based on {@linkplain javaslang.collection.Traversable} like the linked list
+ * {@linkplain javaslang.collection.List} and the lazy linked list {@linkplain javaslang.collection.Stream}.</p>
  *
  * @since 1.1.0
  */

File: src/test/java/javaslang/collection/euler/ProjectEulerTest.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.collection.euler;
 
-import javaslang.collection.JList;
+import javaslang.collection.List;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -26,7 +26,7 @@ public class ProjectEulerTest {
      */
     @Test
     public void shouldSolveProblem1() {
-        final Number actual = JList.range(1, 10).filter(n -> n % 3 == 0 || n % 5 == 0).sum();
+        final Number actual = List.range(1, 10).filter(n -> n % 3 == 0 || n % 5 == 0).sum();
         assertThat(actual).isEqualTo(23);
     }
 

File: src-gen/test/java/javaslang/test/PropertyTest.java
Patch:
@@ -14,7 +14,7 @@
 import java.util.Random;
 import javaslang.CheckedFunction1;
 import javaslang.Tuple;
-import javaslang.collection.JList;
+import javaslang.collection.List;
 import org.junit.Test;
 
 public class PropertyTest {
@@ -85,8 +85,8 @@ public void shouldCheckPythagoras() {
     @Test
     public void shouldCheckZipAndThenUnzipIsIdempotentForListsOfSameLength() {
         // is,ss: length(is) = length(ss)  unzip(zip(is, ss)) = (is, ss)
-        final Arbitrary<JList<Integer>> ints = Arbitrary.list(size -> Gen.choose(0, size));
-        final Arbitrary<JList<String>> strings = Arbitrary.list(
+        final Arbitrary<List<Integer>> ints = Arbitrary.list(size -> Gen.choose(0, size));
+        final Arbitrary<List<String>> strings = Arbitrary.list(
                 Arbitrary.string(
                     Gen.frequency(
                         Tuple.of(1, Gen.choose('A', 'Z')),

File: src/main/java/javaslang/algebra/package-info.java
Patch:
@@ -2,7 +2,7 @@
  * <p>Algebraic interfaces used to describe inherent class properties like {@linkplain javaslang.algebra.Monad}.</p>
  * <p>Interfaces like {@linkplain javaslang.algebra.HigherKinded} are needed to enhance API design and are mainly used
  * internally by Javaslang. An example for {@linkplain javaslang.algebra.Monoid} usage is
- * {@link javaslang.collection.JTraversable#foldMap(javaslang.algebra.Monoid, java.util.function.Function)}.</p>
+ * {@link javaslang.collection.Traversable#foldMap(javaslang.algebra.Monoid, java.util.function.Function)}.</p>
  *
  * @since 1.1.0
  */

File: src/main/java/javaslang/collection/package-info.java
Patch:
@@ -1,6 +1,6 @@
 /**
- * <p>Immutable collections based on {@linkplain javaslang.collection.JTraversable} like the linked list
- * {@linkplain javaslang.collection.JList} and the lazy linked list {@linkplain javaslang.collection.JStream}.</p>
+ * <p>Immutable collections based on {@linkplain javaslang.collection.Traversable} like the linked list
+ * {@linkplain javaslang.collection.List} and the lazy linked list {@linkplain javaslang.collection.Stream}.</p>
  *
  * @since 1.1.0
  */

File: src/test/java/javaslang/collection/euler/ProjectEulerTest.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.collection.euler;
 
-import javaslang.collection.JList;
+import javaslang.collection.List;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -26,7 +26,7 @@ public class ProjectEulerTest {
      */
     @Test
     public void shouldSolveProblem1() {
-        final Number actual = JList.range(1, 10).filter(n -> n % 3 == 0 || n % 5 == 0).sum();
+        final Number actual = List.range(1, 10).filter(n -> n % 3 == 0 || n % 5 == 0).sum();
         assertThat(actual).isEqualTo(23);
     }
 

File: src-gen/test/java/javaslang/test/PropertyTest.java
Patch:
@@ -14,7 +14,7 @@
 import java.util.Random;
 import javaslang.CheckedFunction1;
 import javaslang.Tuple;
-import javaslang.collection.List;
+import javaslang.collection.JList;
 import org.junit.Test;
 
 public class PropertyTest {
@@ -85,8 +85,8 @@ public void shouldCheckPythagoras() {
     @Test
     public void shouldCheckZipAndThenUnzipIsIdempotentForListsOfSameLength() {
         // is,ss: length(is) = length(ss)  unzip(zip(is, ss)) = (is, ss)
-        final Arbitrary<List<Integer>> ints = Arbitrary.list(size -> Gen.choose(0, size));
-        final Arbitrary<List<String>> strings = Arbitrary.list(
+        final Arbitrary<JList<Integer>> ints = Arbitrary.list(size -> Gen.choose(0, size));
+        final Arbitrary<JList<String>> strings = Arbitrary.list(
                 Arbitrary.string(
                     Gen.frequency(
                         Tuple.of(1, Gen.choose('A', 'Z')),

File: src/main/java/javaslang/algebra/package-info.java
Patch:
@@ -2,7 +2,7 @@
  * <p>Algebraic interfaces used to describe inherent class properties like {@linkplain javaslang.algebra.Monad}.</p>
  * <p>Interfaces like {@linkplain javaslang.algebra.HigherKinded} are needed to enhance API design and are mainly used
  * internally by Javaslang. An example for {@linkplain javaslang.algebra.Monoid} usage is
- * {@link javaslang.collection.Traversable#foldMap(javaslang.algebra.Monoid, java.util.function.Function)}.</p>
+ * {@link javaslang.collection.JTraversable#foldMap(javaslang.algebra.Monoid, java.util.function.Function)}.</p>
  *
  * @since 1.1.0
  */

File: src/main/java/javaslang/collection/package-info.java
Patch:
@@ -1,6 +1,6 @@
 /**
- * <p>Immutable collections based on {@linkplain javaslang.collection.Traversable} like the linked list
- * {@linkplain javaslang.collection.List} and the lazy linked list {@linkplain javaslang.collection.Stream}.</p>
+ * <p>Immutable collections based on {@linkplain javaslang.collection.JTraversable} like the linked list
+ * {@linkplain javaslang.collection.JList} and the lazy linked list {@linkplain javaslang.collection.JStream}.</p>
  *
  * @since 1.1.0
  */

File: src/test/java/javaslang/collection/euler/ProjectEulerTest.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.collection.euler;
 
-import javaslang.collection.List;
+import javaslang.collection.JList;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -26,7 +26,7 @@ public class ProjectEulerTest {
      */
     @Test
     public void shouldSolveProblem1() {
-        final Number actual = List.range(1, 10).filter(n -> n % 3 == 0 || n % 5 == 0).sum();
+        final Number actual = JList.range(1, 10).filter(n -> n % 3 == 0 || n % 5 == 0).sum();
         assertThat(actual).isEqualTo(23);
     }
 

File: src/main/java/javaslang/collection/JList.java
Patch:
@@ -1031,7 +1031,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return map(String::valueOf).join(", ", "List(", ")");
+            return map(String::valueOf).join(", ", "JList(", ")");
         }
     }
 }

File: src/main/java/javaslang/collection/JStream.java
Patch:
@@ -1054,7 +1054,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            final StringBuilder builder = new StringBuilder("Stream(");
+            final StringBuilder builder = new StringBuilder("JStream(");
             JStream<T> stream = this;
             while (stream != null && !stream.isEmpty()) {
                 final Cons<T> cons = (Cons<T>) stream;

File: src/test/java/javaslang/collection/JBinaryTreeTest.java
Patch:
@@ -132,11 +132,11 @@ public void shouldBeAwareThatHashCodeOfLeafIsGreaterThanOne() {
 
     @Test
     public void shouldReturnStringRepresentationOfNil() {
-        assertThat(nil().toString()).isEqualTo("BinaryTree()");
+        assertThat(nil().toString()).isEqualTo("JBinaryTree()");
     }
 
     @Test
     public void shouldReturnStringRepresentationOfBranch() {
-        assertThat(tree().toString()).isEqualTo("BinaryTree(1 (2 (4 7) 5) (3 (6 8 9)))");
+        assertThat(tree().toString()).isEqualTo("JBinaryTree(1 (2 (4 7) 5) (3 (6 8 9)))");
     }
 }

File: src/test/java/javaslang/collection/JListTest.java
Patch:
@@ -73,7 +73,7 @@ public void shouldCreateNil() {
 
     @Test
     public void shouldCreateListOfListUsingCons() {
-        assertThat(JList.of(JList.nil()).toString()).isEqualTo("List(List())");
+        assertThat(JList.of(JList.nil()).toString()).isEqualTo("JList(JList())");
     }
 
     // -- static of(T...)
@@ -201,12 +201,12 @@ public void shouldUnapplyCons() {
 
     @Test
     public void shouldStringifyNil() {
-        assertThat(this.nil().toString()).isEqualTo("List()");
+        assertThat(this.nil().toString()).isEqualTo("JList()");
     }
 
     @Test
     public void shouldStringifyNonNil() {
-        assertThat(this.of(1, 2, 3).toString()).isEqualTo("List(1, 2, 3)");
+        assertThat(this.of(1, 2, 3).toString()).isEqualTo("JList(1, 2, 3)");
     }
 
     // -- Cons test

File: src/test/java/javaslang/collection/JRoseTreeTest.java
Patch:
@@ -116,11 +116,11 @@ public void shouldBeAwareThatHashCodeOfLeafIsGreaterThanOne() {
 
     @Test
     public void shouldReturnStringRepresentationOfNil() {
-        assertThat(nil().toString()).isEqualTo("RoseTree()");
+        assertThat(nil().toString()).isEqualTo("JRoseTree()");
     }
 
     @Test
     public void shouldReturnStringRepresentationOfBranch() {
-        assertThat(tree().toString()).isEqualTo("RoseTree(1 (2 (4 7) 5) (3 (6 8 9)))");
+        assertThat(tree().toString()).isEqualTo("JRoseTree(1 (2 (4 7) 5) (3 (6 8 9)))");
     }
 }

File: src-gen/test/java/javaslang/test/PropertyTest.java
Patch:
@@ -14,7 +14,7 @@
 import java.util.Random;
 import javaslang.CheckedFunction1;
 import javaslang.Tuple;
-import javaslang.collection.List;
+import javaslang.collection.JList;
 import org.junit.Test;
 
 public class PropertyTest {
@@ -85,8 +85,8 @@ public void shouldCheckPythagoras() {
     @Test
     public void shouldCheckZipAndThenUnzipIsIdempotentForListsOfSameLength() {
         // is,ss: length(is) = length(ss)  unzip(zip(is, ss)) = (is, ss)
-        final Arbitrary<List<Integer>> ints = Arbitrary.list(size -> Gen.choose(0, size));
-        final Arbitrary<List<String>> strings = Arbitrary.list(
+        final Arbitrary<JList<Integer>> ints = Arbitrary.list(size -> Gen.choose(0, size));
+        final Arbitrary<JList<String>> strings = Arbitrary.list(
                 Arbitrary.string(
                     Gen.frequency(
                         Tuple.of(1, Gen.choose('A', 'Z')),

File: src/main/java/javaslang/algebra/package-info.java
Patch:
@@ -2,7 +2,7 @@
  * <p>Algebraic interfaces used to describe inherent class properties like {@linkplain javaslang.algebra.Monad}.</p>
  * <p>Interfaces like {@linkplain javaslang.algebra.HigherKinded} are needed to enhance API design and are mainly used
  * internally by Javaslang. An example for {@linkplain javaslang.algebra.Monoid} usage is
- * {@link javaslang.collection.Traversable#foldMap(javaslang.algebra.Monoid, java.util.function.Function)}.</p>
+ * {@link javaslang.collection.JTraversable#foldMap(javaslang.algebra.Monoid, java.util.function.Function)}.</p>
  *
  * @since 1.1.0
  */

File: src/main/java/javaslang/collection/package-info.java
Patch:
@@ -1,6 +1,6 @@
 /**
- * <p>Immutable collections based on {@linkplain javaslang.collection.Traversable} like the linked list
- * {@linkplain javaslang.collection.List} and the lazy linked list {@linkplain javaslang.collection.Stream}.</p>
+ * <p>Immutable collections based on {@linkplain javaslang.collection.JTraversable} like the linked list
+ * {@linkplain javaslang.collection.JList} and the lazy linked list {@linkplain javaslang.collection.JStream}.</p>
  *
  * @since 1.1.0
  */

File: src/test/java/javaslang/collection/euler/ProjectEulerTest.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.collection.euler;
 
-import javaslang.collection.List;
+import javaslang.collection.JList;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -26,7 +26,7 @@ public class ProjectEulerTest {
      */
     @Test
     public void shouldSolveProblem1() {
-        final Number actual = List.range(1, 10).filter(n -> n % 3 == 0 || n % 5 == 0).sum();
+        final Number actual = JList.range(1, 10).filter(n -> n % 3 == 0 || n % 5 == 0).sum();
         assertThat(actual).isEqualTo(23);
     }
 

File: src-gen/main/java/javaslang/algebra/CheckedMonad.java
Patch:
@@ -59,8 +59,8 @@ public interface CheckedMonad<T, M extends HigherKinded<?, M>> extends CheckedFu
      * <code>
      * // given a monad M&lt;T&gt;
      * [a,[b,c],d].flatten( Match
-     *    .caze((M m) -&gt; m)
-     *    .caze((T t) -&gt; new M(t))
+     *    .when((M m) -&gt; m)
+     *    .when((T t) -&gt; new M(t))
      * ) = [a,b,c,d]
      * </code>
      * </pre>

File: src-gen/main/java/javaslang/algebra/Monad.java
Patch:
@@ -58,8 +58,8 @@ public interface Monad<T, M extends HigherKinded<?, M>> extends Functor<T>, High
      * <code>
      * // given a monad M&lt;T&gt;
      * [a,[b,c],d].flatten( Match
-     *    .caze((M m) -&gt; m)
-     *    .caze((T t) -&gt; new M(t))
+     *    .when((M m) -&gt; m)
+     *    .when((T t) -&gt; new M(t))
      * ) = [a,b,c,d]
      * </code>
      * </pre>

File: src/main/java/javaslang/control/Either.java
Patch:
@@ -280,6 +280,7 @@ public LeftProjection<Option<L>, Option<R>> filter(Predicate<? super L> predicat
          *
          * @param f a function which maps elements of this LeftProjection to LeftProjections
          * @return a {@code LeftProjection}
+         * @throws NullPointerException if {@code f} is null
          */
         @SuppressWarnings("unchecked")
         @Override
@@ -560,6 +561,7 @@ public RightProjection<Option<L>, Option<R>> filter(Predicate<? super R> predica
          *
          * @param f a function which maps elements of this RightProjection to RightProjections
          * @return a {@code RightProjection}
+         * @throws NullPointerException if {@code f} is null
          */
         @SuppressWarnings("unchecked")
         @Override

File: src/test/java/javaslang/control/OptionTest.java
Patch:
@@ -9,7 +9,6 @@
 import javaslang.Tuple;
 import javaslang.algebra.Monad;
 import javaslang.algebra.MonadLaws;
-import javaslang.collection.List;
 import javaslang.test.Arbitrary;
 import javaslang.test.CheckResult;
 import javaslang.test.CheckResultAssertions;
@@ -180,8 +179,8 @@ public void shouldReturnNoneOnFilterWhenValueIsNotPresentAndPredicateNotMatches(
     // -- flatten(Function)
 
     static final Match<Option<Integer>> MATCH = Match
-        .caze((Option<Integer> o) -> o)
-        .caze((Integer i) -> new Some<>(i));
+        .when((Option<Integer> o) -> o)
+        .when((Integer i) -> new Some<>(i));
 
     @Test
     public void shouldFlattenUnnestedSomeWithFunction() {

File: src/test/java/javaslang/control/TryTest.java
Patch:
@@ -32,8 +32,8 @@ public class TryTest implements CheckedMonadLaws<Try<?>> {
     // -- flatten(Function)
 
     static final Match<Try<Integer>> MATCH = Match
-        .caze((Try<Integer> o) -> o)
-        .caze((Integer i) -> new Success<>(i));
+        .when((Try<Integer> o) -> o)
+        .when((Integer i) -> new Success<>(i));
 
     @Test
     public void shouldFlattenUnnestedSuccessWithFunction() {

File: src-gen/main/java/javaslang/algebra/CheckedMonad.java
Patch:
@@ -59,8 +59,8 @@ public interface CheckedMonad<T, M extends HigherKinded<?, M>> extends CheckedFu
      * <code>
      * // given a monad M&lt;T&gt;
      * [a,[b,c],d].flatten( Match
-     *    .caze((M m) -&gt; m)
-     *    .caze((T t) -&gt; new M(t))
+     *    .when((M m) -&gt; m)
+     *    .when((T t) -&gt; new M(t))
      * ) = [a,b,c,d]
      * </code>
      * </pre>

File: src-gen/main/java/javaslang/algebra/Monad.java
Patch:
@@ -58,8 +58,8 @@ public interface Monad<T, M extends HigherKinded<?, M>> extends Functor<T>, High
      * <code>
      * // given a monad M&lt;T&gt;
      * [a,[b,c],d].flatten( Match
-     *    .caze((M m) -&gt; m)
-     *    .caze((T t) -&gt; new M(t))
+     *    .when((M m) -&gt; m)
+     *    .when((T t) -&gt; new M(t))
      * ) = [a,b,c,d]
      * </code>
      * </pre>

File: src/test/java/javaslang/control/OptionTest.java
Patch:
@@ -9,7 +9,6 @@
 import javaslang.Tuple;
 import javaslang.algebra.Monad;
 import javaslang.algebra.MonadLaws;
-import javaslang.collection.List;
 import javaslang.test.Arbitrary;
 import javaslang.test.CheckResult;
 import javaslang.test.CheckResultAssertions;
@@ -180,8 +179,8 @@ public void shouldReturnNoneOnFilterWhenValueIsNotPresentAndPredicateNotMatches(
     // -- flatten(Function)
 
     static final Match<Option<Integer>> MATCH = Match
-        .caze((Option<Integer> o) -> o)
-        .caze((Integer i) -> new Some<>(i));
+        .when((Option<Integer> o) -> o)
+        .when((Integer i) -> new Some<>(i));
 
     @Test
     public void shouldFlattenUnnestedSomeWithFunction() {

File: src/test/java/javaslang/control/TryTest.java
Patch:
@@ -32,8 +32,8 @@ public class TryTest implements CheckedMonadLaws<Try<?>> {
     // -- flatten(Function)
 
     static final Match<Try<Integer>> MATCH = Match
-        .caze((Try<Integer> o) -> o)
-        .caze((Integer i) -> new Success<>(i));
+        .when((Try<Integer> o) -> o)
+        .when((Integer i) -> new Success<>(i));
 
     @Test
     public void shouldFlattenUnnestedSuccessWithFunction() {

File: src-gen/main/java/javaslang/algebra/CheckedMonad.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.function.Consumer;
-import javaslang.control.Match;
 import javaslang.control.Try.CheckedConsumer;
 import javaslang.control.Try.CheckedFunction;
 import javaslang.control.Try.CheckedPredicate;

File: src-gen/main/java/javaslang/algebra/Monad.java
Patch:
@@ -12,7 +12,6 @@
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
-import javaslang.control.Match;
 
 /**
  * Defines a Monad by generalizing the flatMap function.

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -19,6 +19,7 @@
 import java.math.BigInteger;
 import java.util.*;
 import java.util.function.*;
+import java.util.stream.StreamSupport;
 
 /**
  * <p>An interface for inherently recursive data structures. The order of elements is determined by
@@ -1170,7 +1171,7 @@ default java.util.Set<T> toJavaSet() {
      * @return a new {@linkplain java.util.stream.Stream} containing this elements
      */
     default java.util.stream.Stream<T> toJavaStream() {
-        return toJavaList().stream();
+        return StreamSupport.stream(spliterator(), false);
     }
 
     /**

File: src-gen/main/java/javaslang/algebra/CheckedMonad.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.function.Consumer;
-import javaslang.control.Match;
 import javaslang.control.Try.CheckedConsumer;
 import javaslang.control.Try.CheckedFunction;
 import javaslang.control.Try.CheckedPredicate;

File: src-gen/main/java/javaslang/algebra/Monad.java
Patch:
@@ -12,7 +12,6 @@
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
-import javaslang.control.Match;
 
 /**
  * Defines a Monad by generalizing the flatMap function.

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -19,6 +19,7 @@
 import java.math.BigInteger;
 import java.util.*;
 import java.util.function.*;
+import java.util.stream.StreamSupport;
 
 /**
  * <p>An interface for inherently recursive data structures. The order of elements is determined by
@@ -1170,7 +1171,7 @@ default java.util.Set<T> toJavaSet() {
      * @return a new {@linkplain java.util.stream.Stream} containing this elements
      */
     default java.util.stream.Stream<T> toJavaStream() {
-        return toJavaList().stream();
+        return StreamSupport.stream(spliterator(), false);
     }
 
     /**

File: src/main/java/javaslang/test/Gen.java
Patch:
@@ -215,7 +215,7 @@ Gen<T> gen(int n, Stream<Tuple2<Integer, Gen<T>>> stream) {
                 return (n <= k) ? stream.head()._2 : gen(n - k, stream.tail());
             }
         }
-        final int size = stream.foldLeft(0, (i, t) -> i + t._1);
+        final int size = stream.map(t -> t._1).sum().intValue();
         return choose(1, size).flatMap(n -> new Frequency().gen(n, stream));
     }
 

File: src/test/java/javaslang/collection/euler/ProjectEulerTest.java
Patch:
@@ -26,7 +26,7 @@ public class ProjectEulerTest {
      */
     @Test
     public void shouldSolveProblem1() {
-        final double actual = List.range(1, 10).filter(n -> n % 3 == 0 || n % 5 == 0).sum();
+        final Number actual = List.range(1, 10).filter(n -> n % 3 == 0 || n % 5 == 0).sum();
         assertThat(actual).isEqualTo(23);
     }
 

File: src/test/java/javaslang/test/GenTest.java
Patch:
@@ -40,7 +40,7 @@ public int nextInt(int bound) {
             }
         };
         final Gen<Integer> gen = Gen.choose(1, 2);
-        final double actual = Stream.gen(() -> gen.apply(rng)).take(10).sum();
+        final Number actual = Stream.gen(() -> gen.apply(rng)).take(10).sum();
         assertThat(actual).isEqualTo(10);
     }
 

File: src/main/java/javaslang/test/Gen.java
Patch:
@@ -215,7 +215,7 @@ Gen<T> gen(int n, Stream<Tuple2<Integer, Gen<T>>> stream) {
                 return (n <= k) ? stream.head()._2 : gen(n - k, stream.tail());
             }
         }
-        final int size = stream.foldLeft(0, (i, t) -> i + t._1);
+        final int size = stream.map(t -> t._1).sum().intValue();
         return choose(1, size).flatMap(n -> new Frequency().gen(n, stream));
     }
 

File: src/test/java/javaslang/collection/euler/ProjectEulerTest.java
Patch:
@@ -26,7 +26,7 @@ public class ProjectEulerTest {
      */
     @Test
     public void shouldSolveProblem1() {
-        final double actual = List.range(1, 10).filter(n -> n % 3 == 0 || n % 5 == 0).sum();
+        final Number actual = List.range(1, 10).filter(n -> n % 3 == 0 || n % 5 == 0).sum();
         assertThat(actual).isEqualTo(23);
     }
 

File: src/test/java/javaslang/test/GenTest.java
Patch:
@@ -40,7 +40,7 @@ public int nextInt(int bound) {
             }
         };
         final Gen<Integer> gen = Gen.choose(1, 2);
-        final double actual = Stream.gen(() -> gen.apply(rng)).take(10).sum();
+        final Number actual = Stream.gen(() -> gen.apply(rng)).take(10).sum();
         assertThat(actual).isEqualTo(10);
     }
 

File: src/main/java/javaslang/test/Gen.java
Patch:
@@ -215,7 +215,7 @@ Gen<T> gen(int n, Stream<Tuple2<Integer, Gen<T>>> stream) {
                 return (n <= k) ? stream.head()._2 : gen(n - k, stream.tail());
             }
         }
-        final int size = stream.map(t -> t._1).sum();
+        final int size = stream.foldLeft(0, (i, t) -> i + t._1);
         return choose(1, size).flatMap(n -> new Frequency().gen(n, stream));
     }
 

File: src/test/java/javaslang/collection/euler/ProjectEulerTest.java
Patch:
@@ -26,7 +26,7 @@ public class ProjectEulerTest {
      */
     @Test
     public void shouldSolveProblem1() {
-        final int actual = List.range(1, 10).filter(n -> n % 3 == 0 || n % 5 == 0).sum();
+        final double actual = List.range(1, 10).filter(n -> n % 3 == 0 || n % 5 == 0).sum();
         assertThat(actual).isEqualTo(23);
     }
 

File: src/main/java/javaslang/test/Gen.java
Patch:
@@ -215,7 +215,7 @@ Gen<T> gen(int n, Stream<Tuple2<Integer, Gen<T>>> stream) {
                 return (n <= k) ? stream.head()._2 : gen(n - k, stream.tail());
             }
         }
-        final int size = stream.map(t -> t._1).sum();
+        final int size = stream.foldLeft(0, (i, t) -> i + t._1);
         return choose(1, size).flatMap(n -> new Frequency().gen(n, stream));
     }
 

File: src/test/java/javaslang/collection/euler/ProjectEulerTest.java
Patch:
@@ -26,7 +26,7 @@ public class ProjectEulerTest {
      */
     @Test
     public void shouldSolveProblem1() {
-        final int actual = List.range(1, 10).filter(n -> n % 3 == 0 || n % 5 == 0).sum();
+        final double actual = List.range(1, 10).filter(n -> n % 3 == 0 || n % 5 == 0).sum();
         assertThat(actual).isEqualTo(23);
     }
 

File: src/test/java/javaslang/test/GenTest.java
Patch:
@@ -40,7 +40,7 @@ public int nextInt(int bound) {
             }
         };
         final Gen<Integer> gen = Gen.choose(1, 2);
-        final int actual = Stream.gen(() -> gen.apply(rng)).take(10).sum();
+        final double actual = Stream.gen(() -> gen.apply(rng)).take(10).sum();
         assertThat(actual).isEqualTo(10);
     }
 

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -314,6 +314,9 @@ default Iterator<T> iterator(int index) {
     @Override
     <U> Seq<U> map(Function<? super T, ? extends U> mapper);
 
+    @Override
+    Tuple2<? extends Seq<T>, ? extends Seq<T>> partition(Predicate<? super T> predicate);
+
     @Override
     Seq<T> peek(Consumer<? super T> action);
 

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -314,6 +314,9 @@ default Iterator<T> iterator(int index) {
     @Override
     <U> Seq<U> map(Function<? super T, ? extends U> mapper);
 
+    @Override
+    Tuple2<? extends Seq<T>, ? extends Seq<T>> partition(Predicate<? super T> predicate);
+
     @Override
     Seq<T> peek(Consumer<? super T> action);
 

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -637,7 +637,8 @@ default Stream<Stream<T>> sliding(int size, int step) {
         if (isEmpty()) {
             return Nil.instance();
         } else {
-            return new Cons<>(take(size), () -> drop(step).sliding(size, step));
+            final Tuple2<Stream<T>, Stream<T>> split = splitAt(size);
+            return new Cons<>(split._1, () -> split._2.isEmpty() ? Nil.instance() : drop(step).sliding(size, step));
         }
     }
 

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -637,7 +637,8 @@ default Stream<Stream<T>> sliding(int size, int step) {
         if (isEmpty()) {
             return Nil.instance();
         } else {
-            return new Cons<>(take(size), () -> drop(step).sliding(size, step));
+            final Tuple2<Stream<T>, Stream<T>> split = splitAt(size);
+            return new Cons<>(split._1, () -> split._2.isEmpty() ? Nil.instance() : drop(step).sliding(size, step));
         }
     }
 

File: src/test/java/javaslang/control/EitherTest.java
Patch:
@@ -7,13 +7,11 @@
 
 import javaslang.Serializables;
 import javaslang.Tuple;
-import javaslang.collection.*;
 import javaslang.control.Either.LeftProjection;
 import javaslang.control.Either.RightProjection;
 import org.junit.Test;
 
 import java.util.*;
-import java.util.List;
 import java.util.function.Function;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: src/test/java/javaslang/control/OptionTest.java
Patch:
@@ -10,7 +10,6 @@
 import javaslang.algebra.Monad;
 import javaslang.algebra.MonadLaws;
 import javaslang.collection.List;
-import javaslang.collection.Traversable;
 import javaslang.test.Arbitrary;
 import javaslang.test.CheckResult;
 import javaslang.test.CheckResultAssertions;

File: src/test/java/javaslang/control/TryTest.java
Patch:
@@ -16,7 +16,6 @@
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
 
-import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;

File: src/test/java/javaslang/control/EitherTest.java
Patch:
@@ -7,13 +7,11 @@
 
 import javaslang.Serializables;
 import javaslang.Tuple;
-import javaslang.collection.*;
 import javaslang.control.Either.LeftProjection;
 import javaslang.control.Either.RightProjection;
 import org.junit.Test;
 
 import java.util.*;
-import java.util.List;
 import java.util.function.Function;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: src/test/java/javaslang/control/OptionTest.java
Patch:
@@ -10,7 +10,6 @@
 import javaslang.algebra.Monad;
 import javaslang.algebra.MonadLaws;
 import javaslang.collection.List;
-import javaslang.collection.Traversable;
 import javaslang.test.Arbitrary;
 import javaslang.test.CheckResult;
 import javaslang.test.CheckResultAssertions;

File: src/test/java/javaslang/control/TryTest.java
Patch:
@@ -16,7 +16,6 @@
 import org.assertj.core.api.Assertions;
 import org.junit.Test;
 
-import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;

File: src/main/java/javaslang/collection/BinaryTree.java
Patch:
@@ -106,7 +106,7 @@ static <T> Nil<T> nil() {
      * @return A balanced tree containing all elements of the given iterable.
      */
     static <T> BinaryTree<T> balance(Iterable<T> iterable) {
-        final List<T> list = List.of(iterable);
+        final List<T> list = List.ofAll(iterable);
         if (list.isEmpty()) {
             return Nil.instance();
         } else {

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -247,7 +247,7 @@ default boolean contains(T element) {
      */
     default boolean containsAll(Iterable<? extends T> elements) {
         Objects.requireNonNull(elements, "elements is null");
-        return List.of(elements)
+        return List.ofAll(elements)
                 .distinct()
                 .findFirst(e -> !this.contains(e))
                 .isEmpty();

File: src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -249,7 +249,7 @@ static <T> Arbitrary<List<T>> list(Arbitrary<T> arbitraryT) {
     static <T> Arbitrary<Stream<T>> stream(Arbitrary<T> arbitraryT) {
         return size -> {
             final Gen<T> genT = arbitraryT.apply(size);
-            return random -> Gen.choose(0, size).map(i -> Stream.of(() -> new Iterator<T>() {
+            return random -> Gen.choose(0, size).map(i -> Stream.ofAll(() -> new Iterator<T>() {
 
                 int count = i;
 

File: src/main/java/javaslang/test/Gen.java
Patch:
@@ -201,7 +201,7 @@ static <T> Gen<T> frequency(Tuple2<Integer, Gen<T>>... generators) {
      */
     static <T> Gen<T> frequency(Iterable<Tuple2<Integer, Gen<T>>> generators) {
         Objects.requireNonNull(generators, "generators is null");
-        final Stream<Tuple2<Integer, Gen<T>>> stream = Stream.of(generators);
+        final Stream<Tuple2<Integer, Gen<T>>> stream = Stream.ofAll(generators);
         if (stream.isEmpty()) {
             throw new IllegalArgumentException("generators is empty");
         }
@@ -247,7 +247,7 @@ static <T> Gen<T> oneOf(Gen<T>... generators) {
      */
     static <T> Gen<T> oneOf(Iterable<Gen<T>> generators) {
         Objects.requireNonNull(generators, "generators is null");
-        final Stream<Gen<T>> stream = Stream.of(generators);
+        final Stream<Gen<T>> stream = Stream.ofAll(generators);
         if (stream.isEmpty()) {
             throw new IllegalArgumentException("generators is empty");
         }

File: src/test/java/javaslang/TypeConsistencyTest.java
Patch:
@@ -155,7 +155,7 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IO
                         return FileVisitResult.CONTINUE;
                     }
                 }));
-        return Stream.of(classes);
+        return Stream.ofAll(classes);
     }
 
     static class ComparableMethod implements Comparable<ComparableMethod> {

File: src/main/java/javaslang/collection/BinaryTree.java
Patch:
@@ -106,7 +106,7 @@ static <T> Nil<T> nil() {
      * @return A balanced tree containing all elements of the given iterable.
      */
     static <T> BinaryTree<T> balance(Iterable<T> iterable) {
-        final List<T> list = List.of(iterable);
+        final List<T> list = List.ofAll(iterable);
         if (list.isEmpty()) {
             return Nil.instance();
         } else {

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -247,7 +247,7 @@ default boolean contains(T element) {
      */
     default boolean containsAll(Iterable<? extends T> elements) {
         Objects.requireNonNull(elements, "elements is null");
-        return List.of(elements)
+        return List.ofAll(elements)
                 .distinct()
                 .findFirst(e -> !this.contains(e))
                 .isEmpty();

File: src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -249,7 +249,7 @@ static <T> Arbitrary<List<T>> list(Arbitrary<T> arbitraryT) {
     static <T> Arbitrary<Stream<T>> stream(Arbitrary<T> arbitraryT) {
         return size -> {
             final Gen<T> genT = arbitraryT.apply(size);
-            return random -> Gen.choose(0, size).map(i -> Stream.of(() -> new Iterator<T>() {
+            return random -> Gen.choose(0, size).map(i -> Stream.ofAll(() -> new Iterator<T>() {
 
                 int count = i;
 

File: src/main/java/javaslang/test/Gen.java
Patch:
@@ -201,7 +201,7 @@ static <T> Gen<T> frequency(Tuple2<Integer, Gen<T>>... generators) {
      */
     static <T> Gen<T> frequency(Iterable<Tuple2<Integer, Gen<T>>> generators) {
         Objects.requireNonNull(generators, "generators is null");
-        final Stream<Tuple2<Integer, Gen<T>>> stream = Stream.of(generators);
+        final Stream<Tuple2<Integer, Gen<T>>> stream = Stream.ofAll(generators);
         if (stream.isEmpty()) {
             throw new IllegalArgumentException("generators is empty");
         }
@@ -247,7 +247,7 @@ static <T> Gen<T> oneOf(Gen<T>... generators) {
      */
     static <T> Gen<T> oneOf(Iterable<Gen<T>> generators) {
         Objects.requireNonNull(generators, "generators is null");
-        final Stream<Gen<T>> stream = Stream.of(generators);
+        final Stream<Gen<T>> stream = Stream.ofAll(generators);
         if (stream.isEmpty()) {
             throw new IllegalArgumentException("generators is empty");
         }

File: src/test/java/javaslang/TypeConsistencyTest.java
Patch:
@@ -155,7 +155,7 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IO
                         return FileVisitResult.CONTINUE;
                     }
                 }));
-        return Stream.of(classes);
+        return Stream.ofAll(classes);
     }
 
     static class ComparableMethod implements Comparable<ComparableMethod> {

File: src-gen/main/java/javaslang/algebra/CheckedMonad.java
Patch:
@@ -9,6 +9,7 @@
    G E N E R A T O R   C R A F T E D
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
+import java.util.Objects;
 import java.util.function.Consumer;
 import javaslang.control.Match;
 import javaslang.control.Try;
@@ -65,7 +66,8 @@ public interface CheckedMonad<T, M extends HigherKinded<?, M>> extends CheckedFu
      */
     @SuppressWarnings("unchecked")
     @unsafe
-    default <U, Z> CheckedMonad<Z, M> treeMap(CheckedFunction<U, Object> mapper) {
+    default <U, Z> CheckedMonad<Z, M> treeMap(CheckedFunction<? super U, ? extends Object> mapper) {
+        Objects.requireNonNull(mapper, "mapper is null");
         final Match<?> match = Match.ofType(Object.class)
                 .caze((Monad<?, ?> m) -> m.treeMap((U u) -> Try.of(() -> mapper.apply(u)).get()))
                 .caze((CheckedMonad<?, ?> m) -> m.treeMap(mapper))

File: src-gen/main/java/javaslang/algebra/Monad.java
Patch:
@@ -9,6 +9,7 @@
    G E N E R A T O R   C R A F T E D
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
+import java.util.Objects;
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
@@ -63,7 +64,8 @@ public interface Monad<T, M extends HigherKinded<?, M>> extends Functor<T>, High
      */
     @SuppressWarnings("unchecked")
     @unsafe
-    default <U, Z> Monad<Z, M> treeMap(Function<U, Object> mapper) {
+    default <U, Z> Monad<Z, M> treeMap(Function<? super U, ? extends Object> mapper) {
+        Objects.requireNonNull(mapper, "mapper is null");
         return (Monad<Z, M>) map(Match.ofType(Object.class)
                 .caze((Monad<?, ?> m) -> m.treeMap(mapper))
                 .caze((CheckedMonad<?, ?> m) -> m.treeMap(mapper::apply))

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -718,7 +718,7 @@ default List<T> takeWhile(Predicate<? super T> predicate) {
     @SuppressWarnings("unchecked")
     @Override
     @unsafe
-    default <U, Z> List<Z> treeMap(Function<U, Object> mapper) {
+    default <U, Z> List<Z> treeMap(Function<? super U, ? extends Object> mapper) {
         return (List<Z>) Seq.super.treeMap(mapper);
     }
 

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -351,7 +351,7 @@ default Iterator<T> iterator(int index) {
     @SuppressWarnings("unchecked")
     @Override
     @unsafe
-    default <U, Z> Seq<Z> treeMap(Function<U, Object> mapper) {
+    default <U, Z> Seq<Z> treeMap(Function<? super U, ? extends Object> mapper) {
         return (Seq<Z>) Traversable.super.treeMap(mapper);
     }
 

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -745,7 +745,7 @@ default Stream<T> takeWhile(Predicate<? super T> predicate) {
     @SuppressWarnings("unchecked")
     @Override
     @unsafe
-    default <U, Z> Stream<Z> treeMap(Function<U, Object> mapper) {
+    default <U, Z> Stream<Z> treeMap(Function<? super U, ? extends Object> mapper) {
         return (Stream<Z>) Seq.super.treeMap(mapper);
     }
 

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -1003,7 +1003,7 @@ default T reduceRight(BiFunction<? super T, ? super T, ? extends T> op) {
     @SuppressWarnings("unchecked")
     @Override
     @unsafe
-    default <U, Z> Traversable<Z> treeMap(Function<U, Object> mapper) {
+    default <U, Z> Traversable<Z> treeMap(Function<? super U, ? extends Object> mapper) {
         return (Traversable<Z>) (Object) Monad.super.treeMap(mapper);
     }
 

File: src/main/java/javaslang/control/Either.java
Patch:
@@ -396,7 +396,7 @@ public <U, LEFT_PROJECTION extends HigherKinded<U, LeftProjection<?, R>>> LeftPr
         @SuppressWarnings("unchecked")
         @Override
         @unsafe
-        public <U, Z> LeftProjection<Z, R> treeMap(Function<U, Object> mapper) {
+        public <U, Z> LeftProjection<Z, R> treeMap(Function<? super U, ? extends Object> mapper) {
             return (LeftProjection<Z, R>) (Object) Monad.super.treeMap(mapper);
         }
 
@@ -707,7 +707,7 @@ public <U> RightProjection<L, U> map(Function<? super R, ? extends U> mapper) {
         @SuppressWarnings("unchecked")
         @Override
         @unsafe
-        public <U, Z> RightProjection<L, Z> treeMap(Function<U, Object> mapper) {
+        public <U, Z> RightProjection<L, Z> treeMap(Function<? super U, ? extends Object> mapper) {
             return (RightProjection<L, Z>) (Object) Monad.super.treeMap(mapper);
         }
 

File: src/main/java/javaslang/control/Failure.java
Patch:
@@ -152,7 +152,8 @@ public <U, TRY extends HigherKinded<U, Try<?>>> Failure<U> flatMap(CheckedFuncti
 
     @SuppressWarnings("unchecked")
     @Override
-    public <U, Z> Failure<Z> treeMap(CheckedFunction<U, Object> mapper) {
+    public <U, Z> Failure<Z> treeMap(CheckedFunction<? super U, ? extends Object> mapper) {
+        Objects.requireNonNull(mapper, "mapper is null");
         return (Failure<Z>) this;
     }
 

File: src/main/java/javaslang/control/None.java
Patch:
@@ -76,7 +76,7 @@ public <U> None<U> map(Function<? super T, ? extends U> mapper) {
     }
 
     @Override
-    public <U, Z> None<Z> treeMap(Function<U, Object> mapper) {
+    public <U, Z> None<Z> treeMap(Function<? super U, ? extends Object> mapper) {
         Objects.requireNonNull(mapper, "mapper is null");
         return None.instance();
     }

File: src/main/java/javaslang/control/Option.java
Patch:
@@ -262,7 +262,7 @@ default <U, OPTION extends HigherKinded<U, Option<?>>> Option<U> flatMap(Functio
     @SuppressWarnings("unchecked")
     @Override
     @unsafe
-    default <U, Z> Option<Z> treeMap(Function<U, Object> mapper) {
+    default <U, Z> Option<Z> treeMap(Function<? super U, ? extends Object> mapper) {
         return (Option<Z>) (Object) Monad.super.treeMap(mapper);
     }
 

File: src/main/java/javaslang/control/Some.java
Patch:
@@ -63,8 +63,8 @@ public <U> Some<U> map(Function<? super T, ? extends U> mapper) {
     @SuppressWarnings("unchecked")
     @Override
     @unsafe
-    public <U, Z> Some<Z> treeMap(Function<U, Object> mapper) {
-        return (Some<Z>) (Object) Option.super.treeMap(mapper);
+    public <U, Z> Some<Z> treeMap(Function<? super U, ? extends Object> mapper) {
+        return (Some<Z>) Option.super.treeMap(mapper);
     }
 
     @Override

File: src/main/java/javaslang/control/Success.java
Patch:
@@ -157,7 +157,7 @@ public <U, TRY extends HigherKinded<U, Try<?>>> Try<U> flatMap(CheckedFunction<?
     @SuppressWarnings("unchecked")
     @Override
     @unsafe
-    public <U, Z> Success<Z> treeMap(CheckedFunction<U, Object> mapper) {
+    public <U, Z> Success<Z> treeMap(CheckedFunction<? super U, ? extends Object> mapper) {
         return (Success<Z>) Try.super.treeMap(mapper);
     }
 

File: src/main/java/javaslang/control/Try.java
Patch:
@@ -240,7 +240,7 @@ default boolean forAll(CheckedPredicate<? super T> predicate) {
     @SuppressWarnings("unchecked")
     @Override
     @unsafe
-    default <U, Z> Try<Z> treeMap(CheckedFunction<U, Object> mapper) {
+    default <U, Z> Try<Z> treeMap(CheckedFunction<? super U, ? extends Object> mapper) {
         return (Try<Z>) (Object) CheckedMonad.super.treeMap(mapper);
     }
 

File: src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -97,10 +97,11 @@ default <U, ARBITRARY extends HigherKinded<U, Arbitrary<?>>> Arbitrary<U> flatMa
         };
     }
 
+    @SuppressWarnings("unchecked")
     @Override
     @unsafe
-    default <U, Z> Arbitrary<Z> treeMap(Function<U, Object> mapper) {
-        throw new UnsupportedOperationException("not implemented");
+    default <U, Z> Arbitrary<Z> treeMap(Function<? super U, ? extends Object> mapper) {
+        return (Arbitrary<Z>) (Object) Monad.super.treeMap(mapper);
     }
 
     /**

File: src/main/java/javaslang/test/Gen.java
Patch:
@@ -293,10 +293,11 @@ default <U, GEN extends HigherKinded<U, Gen<?>>> Gen<U> flatMap(Function<? super
         return random -> ((Gen<U>) mapper.apply(apply(random))).apply(random);
     }
 
+    @SuppressWarnings("unchecked")
     @Override
     @unsafe
-    default <U, Z> Gen<Z> treeMap(Function<U, Object> mapper) {
-        throw new UnsupportedOperationException("not implemented");
+    default <U, Z> Gen<Z> treeMap(Function<? super U, ? extends Object> mapper) {
+        return (Gen<Z>) (Object) Monad.super.treeMap(mapper);
     }
 
     /**

File: src-gen/main/java/javaslang/control/Match.java
Patch:
@@ -330,7 +330,7 @@ private Case(List<Function<Object, Option<R>>> cases) {
             this.match = Lazy.of(() -> new Expression<>(cases.reverse(), None.instance()));
         }
 
-        private static <T, R> Case<R> of(T prototype, Function1<?, R> function) {
+        private static <T, R> Case<R> of(T prototype, Function1<T, R> function) {
             return new Case<>(List.of(Case.caze(new Some<>(prototype), function)));
         }
 
@@ -463,14 +463,14 @@ public Expression<R> orElse(Supplier<R> defaultSupplier) {
             return new Expression<>(cases.reverse(), new Some<>(Lazy.of(defaultSupplier)));
         }
 
-        private static <R> Function<Object, Option<R>> caze(Option<?> prototype, Function1<?, R> function) {
+        private static <T, R> Function<Object, Option<R>> caze(Option<T> prototype, Function1<T, R> function) {
             final MethodType type = function.getType();
             // the compiler may add additional parameters to the lambda, our parameter is the last one
             final Class<?> parameterType = type.parameterType(type.parameterCount() - 1);
             return caze(prototype, function, parameterType);
         }
 
-        private static <R> Function<Object, Option<R>> caze(Option<?> prototype, Function1<?, R> function, Class<?> parameterType) {
+        private static <T, R> Function<Object, Option<R>> caze(Option<T> prototype, Function1<T, R> function, Class<?> parameterType) {
             final Predicate<Object> applicable = obj -> {
                 final boolean isCompatible = obj == null || parameterType.isAssignableFrom(obj.getClass());
                 return isCompatible

File: src/main/java/javaslang/Lazy.java
Patch:
@@ -29,10 +29,10 @@ public final class Lazy<T> implements Supplier<T>, ValueObject {
     private static final long serialVersionUID = 1L;
 
     // read http://javarevisited.blogspot.de/2014/05/double-checked-locking-on-singleton-in-java.html
-    private volatile Supplier<T> supplier;
+    private volatile Supplier<? extends T> supplier;
     private volatile T value = null;
 
-    private Lazy(Supplier<T> supplier) {
+    private Lazy(Supplier<? extends T> supplier) {
         this.supplier = Objects.requireNonNull(supplier, "supplier is null");
     }
 
@@ -44,7 +44,7 @@ private Lazy(Supplier<T> supplier) {
      * @param supplier A supplier
      * @return A new instance of Lazy
      */
-    public static <T> Lazy<T> of(Supplier<T> supplier) {
+    public static <T> Lazy<T> of(Supplier<? extends T> supplier) {
         return new Lazy<>(supplier);
     }
 

File: src/test/java/javaslang/control/OptionTest.java
Patch:
@@ -202,8 +202,7 @@ public void shouldFlattenNone() {
 
     static final Match<Option<Integer>> MATCH = Match
         .caze((Option<Integer> o) -> o)
-        .caze((Integer i) -> new Some<>(i))
-        .build();
+        .caze((Integer i) -> new Some<>(i));
 
     @Test
     public void shouldFlattenUnnestedSomeWithFunction() {

File: src/test/java/javaslang/control/TryTest.java
Patch:
@@ -55,8 +55,7 @@ public void shouldFlattenFailure() {
 
     static final Match<Try<Integer>> MATCH = Match
         .caze((Try<Integer> o) -> o)
-        .caze((Integer i) -> new Success<>(i))
-        .build();
+        .caze((Integer i) -> new Success<>(i));
 
     @Test
     public void shouldFlattenUnnestedSuccessWithFunction() {

File: src-gen/main/java/javaslang/algebra/CheckedMonad.java
Patch:
@@ -13,6 +13,7 @@
 import javaslang.control.Try.CheckedConsumer;
 import javaslang.control.Try.CheckedFunction;
 import javaslang.control.Try.CheckedPredicate;
+import javaslang.unsafe;
 
 /**
  * Defines a CheckedMonad by generalizing the flatMap function.
@@ -65,6 +66,7 @@ public interface CheckedMonad<T, M extends HigherKinded<?, M>> extends CheckedFu
      * @param <U> component type of the resulting {@code Monad}
      * @return A monadic structure containing flattened elements.
      */
+    @unsafe
     <U> CheckedMonad<U, M> flatten();
 
     /**

File: src-gen/main/java/javaslang/algebra/Monad.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
+import javaslang.unsafe;
 
 /**
  * Defines a Monad by generalizing the flatMap function.
@@ -64,6 +65,7 @@ public interface Monad<T, M extends HigherKinded<?, M>> extends Functor<T>, High
      * @param <U> component type of the resulting {@code Monad}
      * @return A monadic structure containing flattened elements.
      */
+    @unsafe
     <U> Monad<U, M> flatten();
 
     /**

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -7,6 +7,7 @@
 
 import javaslang.Tuple2;
 import javaslang.algebra.HigherKinded;
+import javaslang.unsafe;
 
 import java.util.Comparator;
 import java.util.Iterator;
@@ -281,6 +282,7 @@ default Iterator<T> iterator(int index) {
     <U, TRAVERSABLE extends HigherKinded<U, Traversable<?>>> Seq<U> flatMap(Function<? super T, ? extends TRAVERSABLE> mapper);
 
     @Override
+    @unsafe
     <U> Seq<U> flatten();
 
     @Override

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -335,6 +335,7 @@ default <U, TRAVERSABLE extends HigherKinded<U, Traversable<?>>> Stream<U> flatM
      */
     @SuppressWarnings("unchecked")
     @Override
+    @unsafe
     default <U> Stream<U> flatten() {
         return isEmpty() ? Nil.instance() : ((Stream<? extends Stream<U>>) this).flatten(Function.identity());
     }

File: src/main/java/javaslang/control/Either.java
Patch:
@@ -9,6 +9,7 @@
 import javaslang.algebra.HigherKinded;
 import javaslang.algebra.Monad;
 import javaslang.control.Valences.Bivalent;
+import javaslang.unsafe;
 
 import java.util.*;
 import java.util.function.Consumer;
@@ -294,6 +295,7 @@ public LeftProjection<Option<L>, Option<R>> filter(Predicate<? super L> predicat
          */
         @SuppressWarnings("unchecked")
         @Override
+        @unsafe
         public <U> LeftProjection<U, R> flatten() {
             return ((LeftProjection<? extends LeftProjection<U, R>, R>) this).flatten(Function.identity());
         }
@@ -597,6 +599,7 @@ public RightProjection<Option<L>, Option<R>> filter(Predicate<? super R> predica
          */
         @SuppressWarnings("unchecked")
         @Override
+        @unsafe
         public <U> RightProjection<L, U> flatten() {
             return ((RightProjection<L, ? extends RightProjection<L, U>>) this).flatten(Function.identity());
         }

File: src/main/java/javaslang/control/Option.java
Patch:
@@ -9,6 +9,7 @@
 import javaslang.algebra.HigherKinded;
 import javaslang.algebra.Monad;
 import javaslang.control.Valences.Univalent;
+import javaslang.unsafe;
 
 import java.util.Collections;
 import java.util.Iterator;
@@ -158,6 +159,7 @@ default Option<T> filter(Predicate<? super T> predicate) {
      */
     @SuppressWarnings("unchecked")
     @Override
+    @unsafe
     default <U> Option<U> flatten() {
         return ((Option<? extends Option<U>>) this).flatten(Function.identity());
     }

File: src/main/java/javaslang/control/Try.java
Patch:
@@ -9,6 +9,7 @@
 import javaslang.algebra.CheckedMonad;
 import javaslang.algebra.HigherKinded;
 import javaslang.control.Valences.Bivalent;
+import javaslang.unsafe;
 
 import java.util.Collections;
 import java.util.Iterator;
@@ -137,6 +138,7 @@ static Try<Void> run(CheckedRunnable runnable) {
      */
     @SuppressWarnings("unchecked")
     @Override
+    @unsafe
     default <U> Try<U> flatten() {
         return ((Try<? extends Try<U>>) this).flatten(CheckedFunction.identity());
     }

File: src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -9,6 +9,7 @@
 import javaslang.algebra.Monad;
 import javaslang.collection.List;
 import javaslang.collection.Stream;
+import javaslang.unsafe;
 
 import java.util.Iterator;
 import java.util.Objects;
@@ -108,6 +109,7 @@ default Arbitrary<T> filter(Predicate<? super T> predicate) {
 
     @SuppressWarnings("unchecked")
     @Override
+    @unsafe
     default <U> Arbitrary<U> flatten() {
         return ((Arbitrary<? extends Arbitrary<U>>) this).flatten(Function.identity());
     }

File: src/main/java/javaslang/test/Gen.java
Patch:
@@ -9,6 +9,7 @@
 import javaslang.algebra.HigherKinded;
 import javaslang.algebra.Monad;
 import javaslang.collection.Stream;
+import javaslang.unsafe;
 
 import java.util.Objects;
 import java.util.Random;
@@ -315,6 +316,7 @@ default Gen<T> filter(Predicate<? super T> predicate) {
 
     @SuppressWarnings("unchecked")
     @Override
+    @unsafe
     default <U> Gen<U> flatten() {
         return ((Gen<? extends Gen<U>>) this).flatten(Function.identity());
     }

File: src-gen/main/java/javaslang/algebra/CheckedMonad.java
Patch:
@@ -13,6 +13,7 @@
 import javaslang.control.Try.CheckedConsumer;
 import javaslang.control.Try.CheckedFunction;
 import javaslang.control.Try.CheckedPredicate;
+import javaslang.unsafe;
 
 /**
  * Defines a CheckedMonad by generalizing the flatMap function.
@@ -65,6 +66,7 @@ public interface CheckedMonad<T, M extends HigherKinded<?, M>> extends CheckedFu
      * @param <U> component type of the resulting {@code Monad}
      * @return A monadic structure containing flattened elements.
      */
+    @unsafe
     <U> CheckedMonad<U, M> flatten();
 
     /**

File: src-gen/main/java/javaslang/algebra/Monad.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
+import javaslang.unsafe;
 
 /**
  * Defines a Monad by generalizing the flatMap function.
@@ -64,6 +65,7 @@ public interface Monad<T, M extends HigherKinded<?, M>> extends Functor<T>, High
      * @param <U> component type of the resulting {@code Monad}
      * @return A monadic structure containing flattened elements.
      */
+    @unsafe
     <U> Monad<U, M> flatten();
 
     /**

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -7,6 +7,7 @@
 
 import javaslang.Tuple2;
 import javaslang.algebra.HigherKinded;
+import javaslang.unsafe;
 
 import java.util.Comparator;
 import java.util.Iterator;
@@ -281,6 +282,7 @@ default Iterator<T> iterator(int index) {
     <U, TRAVERSABLE extends HigherKinded<U, Traversable<?>>> Seq<U> flatMap(Function<? super T, ? extends TRAVERSABLE> mapper);
 
     @Override
+    @unsafe
     <U> Seq<U> flatten();
 
     @Override

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -335,6 +335,7 @@ default <U, TRAVERSABLE extends HigherKinded<U, Traversable<?>>> Stream<U> flatM
      */
     @SuppressWarnings("unchecked")
     @Override
+    @unsafe
     default <U> Stream<U> flatten() {
         return isEmpty() ? Nil.instance() : ((Stream<? extends Stream<U>>) this).flatten(Function.identity());
     }

File: src/main/java/javaslang/control/Either.java
Patch:
@@ -9,6 +9,7 @@
 import javaslang.algebra.HigherKinded;
 import javaslang.algebra.Monad;
 import javaslang.control.Valences.Bivalent;
+import javaslang.unsafe;
 
 import java.util.*;
 import java.util.function.Consumer;
@@ -294,6 +295,7 @@ public LeftProjection<Option<L>, Option<R>> filter(Predicate<? super L> predicat
          */
         @SuppressWarnings("unchecked")
         @Override
+        @unsafe
         public <U> LeftProjection<U, R> flatten() {
             return ((LeftProjection<? extends LeftProjection<U, R>, R>) this).flatten(Function.identity());
         }
@@ -597,6 +599,7 @@ public RightProjection<Option<L>, Option<R>> filter(Predicate<? super R> predica
          */
         @SuppressWarnings("unchecked")
         @Override
+        @unsafe
         public <U> RightProjection<L, U> flatten() {
             return ((RightProjection<L, ? extends RightProjection<L, U>>) this).flatten(Function.identity());
         }

File: src/main/java/javaslang/control/Option.java
Patch:
@@ -9,6 +9,7 @@
 import javaslang.algebra.HigherKinded;
 import javaslang.algebra.Monad;
 import javaslang.control.Valences.Univalent;
+import javaslang.unsafe;
 
 import java.util.Collections;
 import java.util.Iterator;
@@ -158,6 +159,7 @@ default Option<T> filter(Predicate<? super T> predicate) {
      */
     @SuppressWarnings("unchecked")
     @Override
+    @unsafe
     default <U> Option<U> flatten() {
         return ((Option<? extends Option<U>>) this).flatten(Function.identity());
     }

File: src/main/java/javaslang/control/Try.java
Patch:
@@ -9,6 +9,7 @@
 import javaslang.algebra.CheckedMonad;
 import javaslang.algebra.HigherKinded;
 import javaslang.control.Valences.Bivalent;
+import javaslang.unsafe;
 
 import java.util.Collections;
 import java.util.Iterator;
@@ -137,6 +138,7 @@ static Try<Void> run(CheckedRunnable runnable) {
      */
     @SuppressWarnings("unchecked")
     @Override
+    @unsafe
     default <U> Try<U> flatten() {
         return ((Try<? extends Try<U>>) this).flatten(CheckedFunction.identity());
     }

File: src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -9,6 +9,7 @@
 import javaslang.algebra.Monad;
 import javaslang.collection.List;
 import javaslang.collection.Stream;
+import javaslang.unsafe;
 
 import java.util.Iterator;
 import java.util.Objects;
@@ -108,6 +109,7 @@ default Arbitrary<T> filter(Predicate<? super T> predicate) {
 
     @SuppressWarnings("unchecked")
     @Override
+    @unsafe
     default <U> Arbitrary<U> flatten() {
         return ((Arbitrary<? extends Arbitrary<U>>) this).flatten(Function.identity());
     }

File: src/main/java/javaslang/test/Gen.java
Patch:
@@ -9,6 +9,7 @@
 import javaslang.algebra.HigherKinded;
 import javaslang.algebra.Monad;
 import javaslang.collection.Stream;
+import javaslang.unsafe;
 
 import java.util.Objects;
 import java.util.Random;
@@ -315,6 +316,7 @@ default Gen<T> filter(Predicate<? super T> predicate) {
 
     @SuppressWarnings("unchecked")
     @Override
+    @unsafe
     default <U> Gen<U> flatten() {
         return ((Gen<? extends Gen<U>>) this).flatten(Function.identity());
     }

File: src/test/java/javaslang/collection/StreamTest.java
Patch:
@@ -74,7 +74,7 @@ public void shouldGenerateIntStream() {
 
     @Test
     public void shouldGenerateTerminatingIntStream() {
-        assertThat(Stream.from(Integer.MAX_VALUE).take(2)).isEqualTo(Stream.of(Integer.MAX_VALUE));
+        assertThat(Stream.from(Integer.MAX_VALUE).take(2)).isEqualTo(Stream.of(Integer.MAX_VALUE, Integer.MAX_VALUE + 1));
     }
 
     // -- static gen(Supplier)

File: src/test/java/javaslang/collection/StreamTest.java
Patch:
@@ -74,7 +74,7 @@ public void shouldGenerateIntStream() {
 
     @Test
     public void shouldGenerateTerminatingIntStream() {
-        assertThat(Stream.from(Integer.MAX_VALUE).take(2)).isEqualTo(Stream.of(Integer.MAX_VALUE));
+        assertThat(Stream.from(Integer.MAX_VALUE).take(2)).isEqualTo(Stream.of(Integer.MAX_VALUE, Integer.MAX_VALUE + 1));
     }
 
     // -- static gen(Supplier)

File: src-gen/main/java/javaslang/algebra/CheckedFunctor.java
Patch:
@@ -33,6 +33,7 @@ public interface CheckedFunctor<T> {
      * @param <U> type of the component of the resulting CheckedFunctor
      * @param f a CheckedFunction which maps the component of this CheckedFunctor
      * @return a new CheckedFunctor
+     * @throws NullPointerException if {@code f} is null
      */
     <U> CheckedFunctor<U> map(CheckedFunction<? super T, ? extends U> f);
 }
\ No newline at end of file

File: src-gen/main/java/javaslang/algebra/Functor.java
Patch:
@@ -33,6 +33,7 @@ public interface Functor<T> {
      * @param <U> type of the component of the resulting Functor
      * @param f a Function which maps the component of this Functor
      * @return a new Functor
+     * @throws NullPointerException if {@code f} is null
      */
     <U> Functor<U> map(Function<? super T, ? extends U> f);
 }
\ No newline at end of file

File: src/main/java/javaslang/algebra/Monoid.java
Patch:
@@ -5,6 +5,7 @@
  */
 package javaslang.algebra;
 
+import java.util.Objects;
 import java.util.function.Function;
 
 /**
@@ -51,8 +52,10 @@ static <A> Monoid<Function<A, A>> endoMonoid() {
      * @param semigroup The associative binary operation of the Monoid. Please note that
      *                  {@linkplain javaslang.algebra.Semigroup} is a {@linkplain java.lang.FunctionalInterface}.
      * @return a new Monoid on type A
+     * @throws NullPointerException if {@code semigroup} is null
      */
     static <A> Monoid<A> of(A zero, Semigroup<A> semigroup) {
+        Objects.requireNonNull(semigroup, "semigroup is null");
         return new Monoid<A>() {
             @Override
             public A combine(A a1, A a2) {

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -65,6 +65,7 @@ public interface Seq<T> extends Traversable<T> {
      *
      * @param elements An Iterable of elements
      * @return A new Seq containing the given elements appended to this elements
+     * @throws NullPointerException if {@code elements} is null
      */
     Seq<T> appendAll(Iterable<? extends T> elements);
 
@@ -187,11 +188,10 @@ default Iterator<T> iterator(int index) {
      * Sorts this elements according to the provided {@code Comparator}. If this elements are not
      * {@code Comparable}, a {@code java.lang.ClassCastException} may be thrown.
      *
-     * @param c A comparator
+     * @param comparator A comparator
      * @return a sorted version of this
-     * @throws ClassCastException if this elements are not {@code Comparable}
      */
-    Seq<T> sort(Comparator<? super T> c);
+    Seq<T> sort(Comparator<? super T> comparator);
 
     /**
      * Splits a Seq at the specified index. The result of {@code splitAt(n)} is equivalent to

File: src-gen/main/java/javaslang/algebra/CheckedFunctor.java
Patch:
@@ -33,6 +33,7 @@ public interface CheckedFunctor<T> {
      * @param <U> type of the component of the resulting CheckedFunctor
      * @param f a CheckedFunction which maps the component of this CheckedFunctor
      * @return a new CheckedFunctor
+     * @throws NullPointerException if {@code f} is null
      */
     <U> CheckedFunctor<U> map(CheckedFunction<? super T, ? extends U> f);
 }
\ No newline at end of file

File: src-gen/main/java/javaslang/algebra/Functor.java
Patch:
@@ -33,6 +33,7 @@ public interface Functor<T> {
      * @param <U> type of the component of the resulting Functor
      * @param f a Function which maps the component of this Functor
      * @return a new Functor
+     * @throws NullPointerException if {@code f} is null
      */
     <U> Functor<U> map(Function<? super T, ? extends U> f);
 }
\ No newline at end of file

File: src/main/java/javaslang/algebra/Monoid.java
Patch:
@@ -5,6 +5,7 @@
  */
 package javaslang.algebra;
 
+import java.util.Objects;
 import java.util.function.Function;
 
 /**
@@ -51,8 +52,10 @@ static <A> Monoid<Function<A, A>> endoMonoid() {
      * @param semigroup The associative binary operation of the Monoid. Please note that
      *                  {@linkplain javaslang.algebra.Semigroup} is a {@linkplain java.lang.FunctionalInterface}.
      * @return a new Monoid on type A
+     * @throws NullPointerException if {@code semigroup} is null
      */
     static <A> Monoid<A> of(A zero, Semigroup<A> semigroup) {
+        Objects.requireNonNull(semigroup, "semigroup is null");
         return new Monoid<A>() {
             @Override
             public A combine(A a1, A a2) {

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -65,6 +65,7 @@ public interface Seq<T> extends Traversable<T> {
      *
      * @param elements An Iterable of elements
      * @return A new Seq containing the given elements appended to this elements
+     * @throws NullPointerException if {@code elements} is null
      */
     Seq<T> appendAll(Iterable<? extends T> elements);
 
@@ -187,11 +188,10 @@ default Iterator<T> iterator(int index) {
      * Sorts this elements according to the provided {@code Comparator}. If this elements are not
      * {@code Comparable}, a {@code java.lang.ClassCastException} may be thrown.
      *
-     * @param c A comparator
+     * @param comparator A comparator
      * @return a sorted version of this
-     * @throws ClassCastException if this elements are not {@code Comparable}
      */
-    Seq<T> sort(Comparator<? super T> c);
+    Seq<T> sort(Comparator<? super T> comparator);
 
     /**
      * Splits a Seq at the specified index. The result of {@code splitAt(n)} is equivalent to

File: src/main/java/javaslang/control/Try.java
Patch:
@@ -245,7 +245,7 @@ default Iterator<T> iterator() {
     }
 
     /**
-     * Runs the given runnable if this is a Success, otherwise returns this Failure.
+     * Runs the given runnable if this is a {@code Success}, otherwise returns this {@code Failure}.
      * Shorthand for {@code flatMap(ignored -> Try.run(runnable))}.
      * The main use case is chaining runnables using method references:
      *
@@ -272,7 +272,7 @@ default Iterator<T> iterator() {
      * </pre>
      *
      * @param runnable A checked runnable
-     * @return a new Try
+     * @return a new {@code Try}
      */
     default Try<Void> andThen(CheckedRunnable runnable) {
         return flatMap(ignored -> Try.run(runnable));

File: src/test/java/javaslang/collection/AbstractTraversableTest.java
Patch:
@@ -566,7 +566,7 @@ public void shouldGroupedWhenTraversableLengthIsSmallerThanBlockSize() {
 
     // -- head
 
-    @Test(expected = UnsupportedOperationException.class)
+    @Test(expected = NoSuchElementException.class)
     public void shouldThrowWhenHeadOnNil() {
         nil().head();
     }

File: src/test/java/javaslang/collection/euler/Primes.java
Patch:
@@ -15,7 +15,7 @@ private Primes() {
     }
 
     public static Stream<Integer> asStream() {
-        return sieve(Stream.gen(2));
+        return sieve(Stream.from(2));
     }
 
     // TODO: prevent stack overflow

File: src/test/java/javaslang/collection/AbstractTraversableTest.java
Patch:
@@ -566,7 +566,7 @@ public void shouldGroupedWhenTraversableLengthIsSmallerThanBlockSize() {
 
     // -- head
 
-    @Test(expected = UnsupportedOperationException.class)
+    @Test(expected = NoSuchElementException.class)
     public void shouldThrowWhenHeadOnNil() {
         nil().head();
     }

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -253,6 +253,9 @@ default Iterator<T> iterator(int index) {
     @Override
     Seq<T> distinct();
 
+    @Override
+    <U> Seq<T> distinct(Function<? super T, ? extends U> keyExtractor);
+
     @Override
     Seq<T> drop(int n);
 

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -253,6 +253,9 @@ default Iterator<T> iterator(int index) {
     @Override
     Seq<T> distinct();
 
+    @Override
+    <U> Seq<T> distinct(Function<? super T, ? extends U> keyExtractor);
+
     @Override
     Seq<T> drop(int n);
 

File: src/main/java/javaslang/control/Either.java
Patch:
@@ -261,6 +261,7 @@ public Optional<L> toJavaOptional() {
          * is a {@code Left} and the left value does <em>not</em> satisfy the given predicate</li>
          * <li>{@code LeftProjection(Right(Some(value)))} otherwise, i.e. if the underlying {@code Either} of this
          * projection is a {@code Right}</li>
+         * </ul>
          *
          * @param predicate A predicate
          * @return a LeftProjection of an {@code Either} with an optional value
@@ -563,6 +564,7 @@ public Optional<R> toJavaOptional() {
          * is a {@code Right} and the right value does <em>not</em> satisfy the given predicate</li>
          * <li>{@code RightProjection(Left(Some(value)))} otherwise, i.e. if the underlying {@code Either} of this
          * projection is a {@code Left}</li>
+         *</ul>
          *
          * @param predicate A predicate
          * @return a RightProjection of an {@code Either} with an optional value

File: src/main/java/javaslang/control/Left.java
Patch:
@@ -45,6 +45,8 @@ public boolean isRight() {
 
     @Override
     public <X, Y> Left<X, Y> bimap(Function<? super L, ? extends X> leftMapper, Function<? super R, ? extends Y> rightMapper) {
+        Objects.requireNonNull(leftMapper, "leftMapper is null");
+        Objects.requireNonNull(rightMapper, "rightMapper is null");
         return new Left<>(leftMapper.apply(value));
     }
 

File: src/main/java/javaslang/control/None.java
Patch:
@@ -65,11 +65,13 @@ public boolean isEmpty() {
 
     @Override
     public None<T> peek(Consumer<? super T> action) {
+        Objects.requireNonNull(action, "action is null");
         return this;
     }
 
     @Override
     public <U> None<U> map(Function<? super T, ? extends U> mapper) {
+        Objects.requireNonNull(mapper, "mapper is null");
         return None.instance();
     }
 

File: src/main/java/javaslang/control/Right.java
Patch:
@@ -45,6 +45,8 @@ public boolean isRight() {
 
     @Override
     public <X, Y> Right<X, Y> bimap(Function<? super L, ? extends X> leftMapper, Function<? super R, ? extends Y> rightMapper) {
+        Objects.requireNonNull(leftMapper, "leftMapper is null");
+        Objects.requireNonNull(rightMapper, "rightMapper is null");
         return new Right<>(rightMapper.apply(value));
     }
 

File: src/main/java/javaslang/control/Some.java
Patch:
@@ -48,12 +48,14 @@ public boolean isEmpty() {
 
     @Override
     public Some<T> peek(Consumer<? super T> action) {
+        Objects.requireNonNull(action, "action is null");
         action.accept(get());
         return this;
     }
 
     @Override
     public <U> Some<U> map(Function<? super T, ? extends U> mapper) {
+        Objects.requireNonNull(mapper, "mapper is null");
         return new Some<>(mapper.apply(get()));
     }
 

File: src/main/java/javaslang/control/Left.java
Patch:
@@ -45,6 +45,8 @@ public boolean isRight() {
 
     @Override
     public <X, Y> Left<X, Y> bimap(Function<? super L, ? extends X> leftMapper, Function<? super R, ? extends Y> rightMapper) {
+        Objects.requireNonNull(leftMapper, "leftMapper is null");
+        Objects.requireNonNull(rightMapper, "rightMapper is null");
         return new Left<>(leftMapper.apply(value));
     }
 

File: src/main/java/javaslang/control/None.java
Patch:
@@ -65,11 +65,13 @@ public boolean isEmpty() {
 
     @Override
     public None<T> peek(Consumer<? super T> action) {
+        Objects.requireNonNull(action, "action is null");
         return this;
     }
 
     @Override
     public <U> None<U> map(Function<? super T, ? extends U> mapper) {
+        Objects.requireNonNull(mapper, "mapper is null");
         return None.instance();
     }
 

File: src/main/java/javaslang/control/Right.java
Patch:
@@ -45,6 +45,8 @@ public boolean isRight() {
 
     @Override
     public <X, Y> Right<X, Y> bimap(Function<? super L, ? extends X> leftMapper, Function<? super R, ? extends Y> rightMapper) {
+        Objects.requireNonNull(leftMapper, "leftMapper is null");
+        Objects.requireNonNull(rightMapper, "rightMapper is null");
         return new Right<>(rightMapper.apply(value));
     }
 

File: src/main/java/javaslang/control/Some.java
Patch:
@@ -48,12 +48,14 @@ public boolean isEmpty() {
 
     @Override
     public Some<T> peek(Consumer<? super T> action) {
+        Objects.requireNonNull(action, "action is null");
         action.accept(get());
         return this;
     }
 
     @Override
     public <U> Some<U> map(Function<? super T, ? extends U> mapper) {
+        Objects.requireNonNull(mapper, "mapper is null");
         return new Some<>(mapper.apply(get()));
     }
 

File: src/main/java/javaslang/control/Failure.java
Patch:
@@ -115,7 +115,7 @@ public Optional<T> toJavaOptional() {
 
     @Override
     public Left<Throwable, T> toEither() {
-        return Left.of(cause.getCause());
+        return new Left<>(cause.getCause());
     }
 
     @Override

File: src/main/java/javaslang/control/Option.java
Patch:
@@ -126,7 +126,6 @@ default <X extends Throwable> T orElseThrow(Supplier<X> exceptionSupplier) throw
      * @param predicate A predicate which is used to test an optional value
      * @return {@code Some(value)} or {@code None} as specified
      */
-    @Override
     default Option<T> filter(Predicate<? super T> predicate) {
         if (isEmpty() || predicate.test(get())) {
             return this;

File: src/main/java/javaslang/control/Success.java
Patch:
@@ -93,7 +93,7 @@ public Some<T> toOption() {
 
     @Override
     public Right<Throwable, T> toEither() {
-        return Right.of(value);
+        return new Right<>(value);
     }
 
     @Override

File: src/main/java/javaslang/control/Try.java
Patch:
@@ -115,7 +115,6 @@ static Try<Void> run(CheckedRunnable runnable) {
      * @param predicate A predicate
      * @return a new Try
      */
-    @Override
     Try<T> filter(CheckedPredicate<? super T> predicate);
 
     /**

File: src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -102,7 +102,6 @@ default <U, ARBITRARY extends HigherKinded<U, Arbitrary<?>>> Arbitrary<U> flatMa
      * @param predicate A predicate
      * @return A new generator
      */
-    @Override
     default Arbitrary<T> filter(Predicate<? super T> predicate) {
         return n -> apply(n).filter(predicate);
     }

File: src/main/java/javaslang/test/Gen.java
Patch:
@@ -299,7 +299,6 @@ default <U, GEN extends HigherKinded<U, Gen<?>>> Gen<U> flatMap(Function<? super
      * @param predicate A predicate
      * @return A new generator
      */
-    @Override
     default Gen<T> filter(Predicate<? super T> predicate) {
         Objects.requireNonNull(predicate, "predicate is null");
         return random -> {

File: src/main/java/javaslang/control/Failure.java
Patch:
@@ -115,7 +115,7 @@ public Optional<T> toJavaOptional() {
 
     @Override
     public Left<Throwable, T> toEither() {
-        return Left.of(cause.getCause());
+        return new Left<>(cause.getCause());
     }
 
     @Override

File: src/main/java/javaslang/control/Option.java
Patch:
@@ -126,7 +126,6 @@ default <X extends Throwable> T orElseThrow(Supplier<X> exceptionSupplier) throw
      * @param predicate A predicate which is used to test an optional value
      * @return {@code Some(value)} or {@code None} as specified
      */
-    @Override
     default Option<T> filter(Predicate<? super T> predicate) {
         if (isEmpty() || predicate.test(get())) {
             return this;

File: src/main/java/javaslang/control/Success.java
Patch:
@@ -93,7 +93,7 @@ public Some<T> toOption() {
 
     @Override
     public Right<Throwable, T> toEither() {
-        return Right.of(value);
+        return new Right<>(value);
     }
 
     @Override

File: src/main/java/javaslang/control/Try.java
Patch:
@@ -115,7 +115,6 @@ static Try<Void> run(CheckedRunnable runnable) {
      * @param predicate A predicate
      * @return a new Try
      */
-    @Override
     Try<T> filter(CheckedPredicate<? super T> predicate);
 
     /**

File: src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -102,7 +102,6 @@ default <U, ARBITRARY extends HigherKinded<U, Arbitrary<?>>> Arbitrary<U> flatMa
      * @param predicate A predicate
      * @return A new generator
      */
-    @Override
     default Arbitrary<T> filter(Predicate<? super T> predicate) {
         return n -> apply(n).filter(predicate);
     }

File: src/main/java/javaslang/test/Gen.java
Patch:
@@ -299,7 +299,6 @@ default <U, GEN extends HigherKinded<U, Gen<?>>> Gen<U> flatMap(Function<? super
      * @param predicate A predicate
      * @return A new generator
      */
-    @Override
     default Gen<T> filter(Predicate<? super T> predicate) {
         Objects.requireNonNull(predicate, "predicate is null");
         return random -> {

File: src/main/java/javaslang/Tuple0.java
Patch:
@@ -5,8 +5,6 @@
  */
 package javaslang;
 
-import java.util.Objects;
-
 /**
  * <p>Implementation of an empty tuple, a tuple containing no elements.</p>
  * <p>
@@ -54,7 +52,7 @@ public boolean equals(Object o) {
 
     @Override
     public int hashCode() {
-        return Objects.hash();
+        return 1;
     }
 
     @Override

File: src/main/java/javaslang/collection/BinaryTree.java
Patch:
@@ -507,9 +507,7 @@ public int hashCode() {
             if (isEmpty()) {
                 return 1;
             } else {
-                // need cast because of jdk 1.8.0_25/_31 compiler bug
-                //noinspection RedundantCast
-                return (int) getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
+                return getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
             }
         }
 

File: src/main/java/javaslang/collection/RoseTree.java
Patch:
@@ -423,9 +423,7 @@ public int hashCode() {
             if (isEmpty()) {
                 return 1;
             } else {
-                // need cast because of jdk 1.8.0_25/_31 compiler bug
-                //noinspection RedundantCast
-                return (int) getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
+                return getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
             }
         }
 

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -635,10 +635,8 @@ default T last() {
      *
      * @return the number of elements
      */
-    @SuppressWarnings("RedundantCast")
     default int length() {
-        // cast because of jdk 1.8.0_25 compiler error
-        return (int) foldLeft(0, (n, ignored) -> n + 1);
+        return foldLeft(0, (n, ignored) -> n + 1);
     }
 
     /**

File: src/main/java/javaslang/control/None.java
Patch:
@@ -95,7 +95,7 @@ public boolean equals(Object o) {
 
     @Override
     public int hashCode() {
-        return Objects.hash();
+        return 1;
     }
 
     @Override

File: src/main/java/javaslang/algebra/HigherKinded.java
Patch:
@@ -7,7 +7,7 @@
 
 /**
  * <p>The <em>HigherKinded</em> type declares a generic type constructor, which consists of
- * on component type and one container type.</p>
+ * on component type and one container type. Subtypes of HigherKinded are expected to be of type {@code TYPE}.</p>
  * <p>HigherKinded is used to approximately simulate higher-kinded/higher-order types, which cannot be
  * expressed with Java.</p>
  *

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -269,13 +269,13 @@ default Iterator<T> iterator(int index) {
     Seq<T> findAll(Predicate<? super T> predicate);
 
     @Override
-    <U, TRAVERSABLE extends HigherKinded<U, Traversable<?>>> Seq<U> flatMap(Function<? super T, TRAVERSABLE> mapper);
+    <U, TRAVERSABLE extends HigherKinded<U, Traversable<?>>> Seq<U> flatMap(Function<? super T, ? extends TRAVERSABLE> mapper);
 
     @Override
     <U> Seq<U> flatten();
 
     @Override
-    <U> Seq<U> flatten(Function<T, ? extends Iterable<? extends U>> f);
+    <U, TRAVERSABLE extends HigherKinded<U, Traversable<?>>> Seq<U> flatten(Function<? super T, ? extends TRAVERSABLE> f);
 
     @Override
     Seq<? extends Seq<T>> grouped(int size);

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -321,7 +321,7 @@ default Option<T> findLast(Predicate<? super T> predicate) {
     }
 
     @Override
-    <U, TRAVERSABLE extends HigherKinded<U, Traversable<?>>> Traversable<U> flatMap(Function<? super T, TRAVERSABLE> mapper);
+    <U, TRAVERSABLE extends HigherKinded<U, Traversable<?>>> Traversable<U> flatMap(Function<? super T, ? extends TRAVERSABLE> mapper);
 
     /**
      * <p>Flattens this Traversable, i.e. unboxes iterable elements. If this Traversable contains elements and
@@ -358,7 +358,7 @@ default Option<T> findLast(Predicate<? super T> predicate) {
      * @param f   An unboxing function that maps elements T to Iterables of elements U that will be unboxed.
      * @return a flattened version of this traversable
      */
-    <U> Traversable<U> flatten(Function<T, ? extends Iterable<? extends U>> f);
+    <U, TRAVERSABLE extends HigherKinded<U, Traversable<?>>> Traversable<U> flatten(Function<? super T, ? extends TRAVERSABLE> f);
 
     /**
      * <p>

File: src/main/java/javaslang/control/Match.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
+import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 
@@ -53,7 +54,7 @@
  * @param <R> The result type of the Match expression.
  * @since 1.0.0
  */
-public final class Match<R> {
+public final class Match<R> implements Function<Object, R> {
 
     private final List<Function1<Object, Option<R>>> cases;
     private final Option<Supplier<R>> defaultOption;
@@ -193,6 +194,7 @@ public static <R> Match.Builder<R> caze(ShortFunction<R> function) {
      * @throws MatchError                         if no Match case matches the given object and no default is defined via orElse().
      * @throws javaslang.control.Failure.NonFatal if an error occurs executing the matched case.
      */
+    @Override
     public R apply(Object obj) {
         for (Function1<Object, Option<R>> caze : cases) {
             final Option<R> result = caze.apply(obj);

File: src/main/java/javaslang/control/Success.java
Patch:
@@ -93,7 +93,7 @@ public Some<T> toOption() {
 
     @Override
     public Right<Throwable, T> toEither() {
-        return new Right<>(value);
+        return Right.of(value);
     }
 
     @Override
@@ -145,7 +145,7 @@ public <U> Try<U> map(CheckedFunction<? super T, ? extends U> mapper) {
 
     @SuppressWarnings("unchecked")
     @Override
-    public <U, TRY extends HigherKinded<U, Try<?>>> Try<U> flatMap(CheckedFunction<? super T, TRY> mapper) {
+    public <U, TRY extends HigherKinded<U, Try<?>>> Try<U> flatMap(CheckedFunction<? super T, ? extends TRY> mapper) {
         try {
             return (Try<U>) mapper.apply(value);
         } catch (Throwable t) {

File: src/main/java/javaslang/algebra/HigherKinded.java
Patch:
@@ -7,7 +7,7 @@
 
 /**
  * <p>The <em>HigherKinded</em> type declares a generic type constructor, which consists of
- * on component type and one container type.</p>
+ * on component type and one container type. Subtypes of HigherKinded are expected to be of type {@code TYPE}.</p>
  * <p>HigherKinded is used to approximately simulate higher-kinded/higher-order types, which cannot be
  * expressed with Java.</p>
  *

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -269,13 +269,13 @@ default Iterator<T> iterator(int index) {
     Seq<T> findAll(Predicate<? super T> predicate);
 
     @Override
-    <U, TRAVERSABLE extends HigherKinded<U, Traversable<?>>> Seq<U> flatMap(Function<? super T, TRAVERSABLE> mapper);
+    <U, TRAVERSABLE extends HigherKinded<U, Traversable<?>>> Seq<U> flatMap(Function<? super T, ? extends TRAVERSABLE> mapper);
 
     @Override
     <U> Seq<U> flatten();
 
     @Override
-    <U> Seq<U> flatten(Function<T, ? extends Iterable<? extends U>> f);
+    <U, TRAVERSABLE extends HigherKinded<U, Traversable<?>>> Seq<U> flatten(Function<? super T, ? extends TRAVERSABLE> f);
 
     @Override
     Seq<? extends Seq<T>> grouped(int size);

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -321,7 +321,7 @@ default Option<T> findLast(Predicate<? super T> predicate) {
     }
 
     @Override
-    <U, TRAVERSABLE extends HigherKinded<U, Traversable<?>>> Traversable<U> flatMap(Function<? super T, TRAVERSABLE> mapper);
+    <U, TRAVERSABLE extends HigherKinded<U, Traversable<?>>> Traversable<U> flatMap(Function<? super T, ? extends TRAVERSABLE> mapper);
 
     /**
      * <p>Flattens this Traversable, i.e. unboxes iterable elements. If this Traversable contains elements and
@@ -358,7 +358,7 @@ default Option<T> findLast(Predicate<? super T> predicate) {
      * @param f   An unboxing function that maps elements T to Iterables of elements U that will be unboxed.
      * @return a flattened version of this traversable
      */
-    <U> Traversable<U> flatten(Function<T, ? extends Iterable<? extends U>> f);
+    <U, TRAVERSABLE extends HigherKinded<U, Traversable<?>>> Traversable<U> flatten(Function<? super T, ? extends TRAVERSABLE> f);
 
     /**
      * <p>

File: src/main/java/javaslang/control/Match.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
+import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 
@@ -53,7 +54,7 @@
  * @param <R> The result type of the Match expression.
  * @since 1.0.0
  */
-public final class Match<R> {
+public final class Match<R> implements Function<Object, R> {
 
     private final List<Function1<Object, Option<R>>> cases;
     private final Option<Supplier<R>> defaultOption;
@@ -193,6 +194,7 @@ public static <R> Match.Builder<R> caze(ShortFunction<R> function) {
      * @throws MatchError                         if no Match case matches the given object and no default is defined via orElse().
      * @throws javaslang.control.Failure.NonFatal if an error occurs executing the matched case.
      */
+    @Override
     public R apply(Object obj) {
         for (Function1<Object, Option<R>> caze : cases) {
             final Option<R> result = caze.apply(obj);

File: src/main/java/javaslang/control/Success.java
Patch:
@@ -93,7 +93,7 @@ public Some<T> toOption() {
 
     @Override
     public Right<Throwable, T> toEither() {
-        return new Right<>(value);
+        return Right.of(value);
     }
 
     @Override
@@ -145,7 +145,7 @@ public <U> Try<U> map(CheckedFunction<? super T, ? extends U> mapper) {
 
     @SuppressWarnings("unchecked")
     @Override
-    public <U, TRY extends HigherKinded<U, Try<?>>> Try<U> flatMap(CheckedFunction<? super T, TRY> mapper) {
+    public <U, TRY extends HigherKinded<U, Try<?>>> Try<U> flatMap(CheckedFunction<? super T, ? extends TRY> mapper) {
         try {
             return (Try<U>) mapper.apply(value);
         } catch (Throwable t) {

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -911,7 +911,7 @@ default T reduceRight(BiFunction<? super T, ? super T, ? extends T> op) {
     Traversable<? extends Traversable<T>> sliding(int size);
 
     /**
-     * Slides a window of specific {@code size} and {@code step} size over this {@code Traversable}.
+     * Slides a window of a specific {@code size} and {@code step} size over this {@code Traversable}.
      * <p>
      * Examples:
      * <pre>
@@ -927,7 +927,7 @@ default T reduceRight(BiFunction<? super T, ? super T, ? extends T> op) {
      * @param size a positive window size
      * @param step a positive step size
      * @return a new Traversable of windows of a specific size using a specific step size
-     * @throws IllegalArgumentException if size is negative or zero
+     * @throws IllegalArgumentException if size or step are negative or zero
      */
     Traversable<? extends Traversable<T>> sliding(int size, int step);
 

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -911,7 +911,7 @@ default T reduceRight(BiFunction<? super T, ? super T, ? extends T> op) {
     Traversable<? extends Traversable<T>> sliding(int size);
 
     /**
-     * Slides a window of specific {@code size} and {@code step} size over this {@code Traversable}.
+     * Slides a window of a specific {@code size} and {@code step} size over this {@code Traversable}.
      * <p>
      * Examples:
      * <pre>
@@ -927,7 +927,7 @@ default T reduceRight(BiFunction<? super T, ? super T, ? extends T> op) {
      * @param size a positive window size
      * @param step a positive step size
      * @return a new Traversable of windows of a specific size using a specific step size
-     * @throws IllegalArgumentException if size is negative or zero
+     * @throws IllegalArgumentException if size or step are negative or zero
      */
     Traversable<? extends Traversable<T>> sliding(int size, int step);
 

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -803,7 +803,7 @@ default Stream<Stream<T>> sliding(int size, int step) {
         if (isEmpty()) {
             return Nil.instance();
         } else {
-            return new Cons<>(take(size), () -> drop(step).grouped(size));
+            return new Cons<>(take(size), () -> drop(step).sliding(size, step));
         }
     }
 

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -659,7 +659,7 @@ default T max() {
      * @throws java.lang.NullPointerException if comparator is null
      * @throws java.lang.UnsupportedOperationException if no elements are present
      */
-    default T maxBy(Comparator<T> comparator) {
+    default T maxBy(Comparator<? super T> comparator) {
         Objects.requireNonNull(comparator, "comparator is null");
         if (isEmpty()) {
             throw new UnsupportedOperationException("maxBy of nothing");
@@ -707,7 +707,7 @@ default T min() {
      * @throws java.lang.NullPointerException if comparator is null
      * @throws java.lang.UnsupportedOperationException if no elements are present
      */
-    default T minBy(Comparator<T> comparator) {
+    default T minBy(Comparator<? super T> comparator) {
         Objects.requireNonNull(comparator, "comparator is null");
         if (isEmpty()) {
             throw new UnsupportedOperationException("minBy of nothing");

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -659,7 +659,7 @@ default T max() {
      * @throws java.lang.NullPointerException if comparator is null
      * @throws java.lang.UnsupportedOperationException if no elements are present
      */
-    default T maxBy(Comparator<T> comparator) {
+    default T maxBy(Comparator<? super T> comparator) {
         Objects.requireNonNull(comparator, "comparator is null");
         if (isEmpty()) {
             throw new UnsupportedOperationException("maxBy of nothing");
@@ -707,7 +707,7 @@ default T min() {
      * @throws java.lang.NullPointerException if comparator is null
      * @throws java.lang.UnsupportedOperationException if no elements are present
      */
-    default T minBy(Comparator<T> comparator) {
+    default T minBy(Comparator<? super T> comparator) {
         Objects.requireNonNull(comparator, "comparator is null");
         if (isEmpty()) {
             throw new UnsupportedOperationException("minBy of nothing");

File: src/main/java/javaslang/collection/BinaryTree.java
Patch:
@@ -507,7 +507,9 @@ public int hashCode() {
             if (isEmpty()) {
                 return 1;
             } else {
-                return getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
+                // need cast because of jdk 1.8.0_25/_31 compiler bug
+                //noinspection RedundantCast
+                return (int) getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
             }
         }
 

File: src/main/java/javaslang/collection/RoseTree.java
Patch:
@@ -423,7 +423,9 @@ public int hashCode() {
             if (isEmpty()) {
                 return 1;
             } else {
-                return getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
+                // need cast because of jdk 1.8.0_25/_31 compiler bug
+                //noinspection RedundantCast
+                return (int) getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
             }
         }
 

File: src/main/java/javaslang/collection/BinaryTree.java
Patch:
@@ -507,7 +507,9 @@ public int hashCode() {
             if (isEmpty()) {
                 return 1;
             } else {
-                return getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
+                // need cast because of jdk 1.8.0_25/_31 compiler bug
+                //noinspection RedundantCast
+                return (int) getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
             }
         }
 

File: src/main/java/javaslang/collection/RoseTree.java
Patch:
@@ -423,7 +423,9 @@ public int hashCode() {
             if (isEmpty()) {
                 return 1;
             } else {
-                return getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
+                // need cast because of jdk 1.8.0_25/_31 compiler bug
+                //noinspection RedundantCast
+                return (int) getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
             }
         }
 

File: src-gen/main/java/javaslang/Tuple1.java
Patch:
@@ -17,7 +17,7 @@
  * @param <T1> type of the 1st element
  * @since 1.1.0
  */
-public class Tuple1<T1> implements Tuple {
+public final class Tuple1<T1> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple10.java
Patch:
@@ -26,7 +26,7 @@
  * @param <T10> type of the 10th element
  * @since 1.1.0
  */
-public class Tuple10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> implements Tuple {
+public final class Tuple10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple11.java
Patch:
@@ -27,7 +27,7 @@
  * @param <T11> type of the 11th element
  * @since 1.1.0
  */
-public class Tuple11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> implements Tuple {
+public final class Tuple11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple12.java
Patch:
@@ -28,7 +28,7 @@
  * @param <T12> type of the 12th element
  * @since 1.1.0
  */
-public class Tuple12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> implements Tuple {
+public final class Tuple12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple13.java
Patch:
@@ -29,7 +29,7 @@
  * @param <T13> type of the 13th element
  * @since 1.1.0
  */
-public class Tuple13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> implements Tuple {
+public final class Tuple13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple14.java
Patch:
@@ -30,7 +30,7 @@
  * @param <T14> type of the 14th element
  * @since 1.1.0
  */
-public class Tuple14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> implements Tuple {
+public final class Tuple14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple15.java
Patch:
@@ -31,7 +31,7 @@
  * @param <T15> type of the 15th element
  * @since 1.1.0
  */
-public class Tuple15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> implements Tuple {
+public final class Tuple15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple16.java
Patch:
@@ -32,7 +32,7 @@
  * @param <T16> type of the 16th element
  * @since 1.1.0
  */
-public class Tuple16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> implements Tuple {
+public final class Tuple16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple17.java
Patch:
@@ -33,7 +33,7 @@
  * @param <T17> type of the 17th element
  * @since 1.1.0
  */
-public class Tuple17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> implements Tuple {
+public final class Tuple17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple18.java
Patch:
@@ -34,7 +34,7 @@
  * @param <T18> type of the 18th element
  * @since 1.1.0
  */
-public class Tuple18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> implements Tuple {
+public final class Tuple18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple19.java
Patch:
@@ -35,7 +35,7 @@
  * @param <T19> type of the 19th element
  * @since 1.1.0
  */
-public class Tuple19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> implements Tuple {
+public final class Tuple19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple2.java
Patch:
@@ -18,7 +18,7 @@
  * @param <T2> type of the 2nd element
  * @since 1.1.0
  */
-public class Tuple2<T1, T2> implements Tuple {
+public final class Tuple2<T1, T2> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple20.java
Patch:
@@ -36,7 +36,7 @@
  * @param <T20> type of the 20th element
  * @since 1.1.0
  */
-public class Tuple20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> implements Tuple {
+public final class Tuple20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple21.java
Patch:
@@ -37,7 +37,7 @@
  * @param <T21> type of the 1st element
  * @since 1.1.0
  */
-public class Tuple21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> implements Tuple {
+public final class Tuple21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple22.java
Patch:
@@ -38,7 +38,7 @@
  * @param <T22> type of the 2nd element
  * @since 1.1.0
  */
-public class Tuple22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> implements Tuple {
+public final class Tuple22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple23.java
Patch:
@@ -39,7 +39,7 @@
  * @param <T23> type of the 3rd element
  * @since 1.1.0
  */
-public class Tuple23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> implements Tuple {
+public final class Tuple23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple24.java
Patch:
@@ -40,7 +40,7 @@
  * @param <T24> type of the 24th element
  * @since 1.1.0
  */
-public class Tuple24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> implements Tuple {
+public final class Tuple24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple25.java
Patch:
@@ -41,7 +41,7 @@
  * @param <T25> type of the 25th element
  * @since 1.1.0
  */
-public class Tuple25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> implements Tuple {
+public final class Tuple25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple26.java
Patch:
@@ -42,7 +42,7 @@
  * @param <T26> type of the 26th element
  * @since 1.1.0
  */
-public class Tuple26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> implements Tuple {
+public final class Tuple26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple3.java
Patch:
@@ -19,7 +19,7 @@
  * @param <T3> type of the 3rd element
  * @since 1.1.0
  */
-public class Tuple3<T1, T2, T3> implements Tuple {
+public final class Tuple3<T1, T2, T3> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple4.java
Patch:
@@ -20,7 +20,7 @@
  * @param <T4> type of the 4th element
  * @since 1.1.0
  */
-public class Tuple4<T1, T2, T3, T4> implements Tuple {
+public final class Tuple4<T1, T2, T3, T4> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple5.java
Patch:
@@ -21,7 +21,7 @@
  * @param <T5> type of the 5th element
  * @since 1.1.0
  */
-public class Tuple5<T1, T2, T3, T4, T5> implements Tuple {
+public final class Tuple5<T1, T2, T3, T4, T5> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple6.java
Patch:
@@ -22,7 +22,7 @@
  * @param <T6> type of the 6th element
  * @since 1.1.0
  */
-public class Tuple6<T1, T2, T3, T4, T5, T6> implements Tuple {
+public final class Tuple6<T1, T2, T3, T4, T5, T6> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple7.java
Patch:
@@ -23,7 +23,7 @@
  * @param <T7> type of the 7th element
  * @since 1.1.0
  */
-public class Tuple7<T1, T2, T3, T4, T5, T6, T7> implements Tuple {
+public final class Tuple7<T1, T2, T3, T4, T5, T6, T7> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple8.java
Patch:
@@ -24,7 +24,7 @@
  * @param <T8> type of the 8th element
  * @since 1.1.0
  */
-public class Tuple8<T1, T2, T3, T4, T5, T6, T7, T8> implements Tuple {
+public final class Tuple8<T1, T2, T3, T4, T5, T6, T7, T8> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple9.java
Patch:
@@ -25,7 +25,7 @@
  * @param <T9> type of the 9th element
  * @since 1.1.0
  */
-public class Tuple9<T1, T2, T3, T4, T5, T6, T7, T8, T9> implements Tuple {
+public final class Tuple9<T1, T2, T3, T4, T5, T6, T7, T8, T9> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple1.java
Patch:
@@ -17,7 +17,7 @@
  * @param <T1> type of the 1st element
  * @since 1.1.0
  */
-public class Tuple1<T1> implements Tuple {
+public final class Tuple1<T1> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple10.java
Patch:
@@ -26,7 +26,7 @@
  * @param <T10> type of the 10th element
  * @since 1.1.0
  */
-public class Tuple10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> implements Tuple {
+public final class Tuple10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple11.java
Patch:
@@ -27,7 +27,7 @@
  * @param <T11> type of the 11th element
  * @since 1.1.0
  */
-public class Tuple11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> implements Tuple {
+public final class Tuple11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple12.java
Patch:
@@ -28,7 +28,7 @@
  * @param <T12> type of the 12th element
  * @since 1.1.0
  */
-public class Tuple12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> implements Tuple {
+public final class Tuple12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple13.java
Patch:
@@ -29,7 +29,7 @@
  * @param <T13> type of the 13th element
  * @since 1.1.0
  */
-public class Tuple13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> implements Tuple {
+public final class Tuple13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple14.java
Patch:
@@ -30,7 +30,7 @@
  * @param <T14> type of the 14th element
  * @since 1.1.0
  */
-public class Tuple14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> implements Tuple {
+public final class Tuple14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple15.java
Patch:
@@ -31,7 +31,7 @@
  * @param <T15> type of the 15th element
  * @since 1.1.0
  */
-public class Tuple15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> implements Tuple {
+public final class Tuple15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple16.java
Patch:
@@ -32,7 +32,7 @@
  * @param <T16> type of the 16th element
  * @since 1.1.0
  */
-public class Tuple16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> implements Tuple {
+public final class Tuple16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple17.java
Patch:
@@ -33,7 +33,7 @@
  * @param <T17> type of the 17th element
  * @since 1.1.0
  */
-public class Tuple17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> implements Tuple {
+public final class Tuple17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple18.java
Patch:
@@ -34,7 +34,7 @@
  * @param <T18> type of the 18th element
  * @since 1.1.0
  */
-public class Tuple18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> implements Tuple {
+public final class Tuple18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple19.java
Patch:
@@ -35,7 +35,7 @@
  * @param <T19> type of the 19th element
  * @since 1.1.0
  */
-public class Tuple19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> implements Tuple {
+public final class Tuple19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple2.java
Patch:
@@ -18,7 +18,7 @@
  * @param <T2> type of the 2nd element
  * @since 1.1.0
  */
-public class Tuple2<T1, T2> implements Tuple {
+public final class Tuple2<T1, T2> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple20.java
Patch:
@@ -36,7 +36,7 @@
  * @param <T20> type of the 20th element
  * @since 1.1.0
  */
-public class Tuple20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> implements Tuple {
+public final class Tuple20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple21.java
Patch:
@@ -37,7 +37,7 @@
  * @param <T21> type of the 1st element
  * @since 1.1.0
  */
-public class Tuple21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> implements Tuple {
+public final class Tuple21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple22.java
Patch:
@@ -38,7 +38,7 @@
  * @param <T22> type of the 2nd element
  * @since 1.1.0
  */
-public class Tuple22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> implements Tuple {
+public final class Tuple22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple23.java
Patch:
@@ -39,7 +39,7 @@
  * @param <T23> type of the 3rd element
  * @since 1.1.0
  */
-public class Tuple23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> implements Tuple {
+public final class Tuple23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple24.java
Patch:
@@ -40,7 +40,7 @@
  * @param <T24> type of the 24th element
  * @since 1.1.0
  */
-public class Tuple24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> implements Tuple {
+public final class Tuple24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple25.java
Patch:
@@ -41,7 +41,7 @@
  * @param <T25> type of the 25th element
  * @since 1.1.0
  */
-public class Tuple25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> implements Tuple {
+public final class Tuple25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple26.java
Patch:
@@ -42,7 +42,7 @@
  * @param <T26> type of the 26th element
  * @since 1.1.0
  */
-public class Tuple26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> implements Tuple {
+public final class Tuple26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple3.java
Patch:
@@ -19,7 +19,7 @@
  * @param <T3> type of the 3rd element
  * @since 1.1.0
  */
-public class Tuple3<T1, T2, T3> implements Tuple {
+public final class Tuple3<T1, T2, T3> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple4.java
Patch:
@@ -20,7 +20,7 @@
  * @param <T4> type of the 4th element
  * @since 1.1.0
  */
-public class Tuple4<T1, T2, T3, T4> implements Tuple {
+public final class Tuple4<T1, T2, T3, T4> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple5.java
Patch:
@@ -21,7 +21,7 @@
  * @param <T5> type of the 5th element
  * @since 1.1.0
  */
-public class Tuple5<T1, T2, T3, T4, T5> implements Tuple {
+public final class Tuple5<T1, T2, T3, T4, T5> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple6.java
Patch:
@@ -22,7 +22,7 @@
  * @param <T6> type of the 6th element
  * @since 1.1.0
  */
-public class Tuple6<T1, T2, T3, T4, T5, T6> implements Tuple {
+public final class Tuple6<T1, T2, T3, T4, T5, T6> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple7.java
Patch:
@@ -23,7 +23,7 @@
  * @param <T7> type of the 7th element
  * @since 1.1.0
  */
-public class Tuple7<T1, T2, T3, T4, T5, T6, T7> implements Tuple {
+public final class Tuple7<T1, T2, T3, T4, T5, T6, T7> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple8.java
Patch:
@@ -24,7 +24,7 @@
  * @param <T8> type of the 8th element
  * @since 1.1.0
  */
-public class Tuple8<T1, T2, T3, T4, T5, T6, T7, T8> implements Tuple {
+public final class Tuple8<T1, T2, T3, T4, T5, T6, T7, T8> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src-gen/main/java/javaslang/Tuple9.java
Patch:
@@ -25,7 +25,7 @@
  * @param <T9> type of the 9th element
  * @since 1.1.0
  */
-public class Tuple9<T1, T2, T3, T4, T5, T6, T7, T8, T9> implements Tuple {
+public final class Tuple9<T1, T2, T3, T4, T5, T6, T7, T8, T9> implements Tuple {
 
     private static final long serialVersionUID = 1L;
 

File: src/main/java/javaslang/collection/BinaryTree.java
Patch:
@@ -507,9 +507,7 @@ public int hashCode() {
             if (isEmpty()) {
                 return 1;
             } else {
-                // need cast because of jdk 1.8.0_25/_31 compiler bug
-                //noinspection RedundantCast
-                return (int) getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
+                return getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
             }
         }
 

File: src/main/java/javaslang/collection/RoseTree.java
Patch:
@@ -423,9 +423,7 @@ public int hashCode() {
             if (isEmpty()) {
                 return 1;
             } else {
-                // need cast because of jdk 1.8.0_25/_31 compiler bug
-                //noinspection RedundantCast
-                return (int) getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
+                return getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
             }
         }
 

File: src/main/java/javaslang/collection/BinaryTree.java
Patch:
@@ -507,9 +507,7 @@ public int hashCode() {
             if (isEmpty()) {
                 return 1;
             } else {
-                // need cast because of jdk 1.8.0_25/_31 compiler bug
-                //noinspection RedundantCast
-                return (int) getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
+                return getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
             }
         }
 

File: src/main/java/javaslang/collection/RoseTree.java
Patch:
@@ -423,9 +423,7 @@ public int hashCode() {
             if (isEmpty()) {
                 return 1;
             } else {
-                // need cast because of jdk 1.8.0_25/_31 compiler bug
-                //noinspection RedundantCast
-                return (int) getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
+                return getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
             }
         }
 

File: src-gen/main/java/javaslang/CheckedFunction10.java
Patch:
@@ -83,7 +83,7 @@ default CheckedFunction10<T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R> reversed()
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction11.java
Patch:
@@ -85,7 +85,7 @@ default CheckedFunction11<T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R> rever
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction12.java
Patch:
@@ -87,7 +87,7 @@ default CheckedFunction12<T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R>
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction13.java
Patch:
@@ -89,7 +89,7 @@ default CheckedFunction13<T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction14.java
Patch:
@@ -91,7 +91,7 @@ default CheckedFunction14<T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction15.java
Patch:
@@ -93,7 +93,7 @@ default CheckedFunction15<T15, T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T4,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction16.java
Patch:
@@ -95,7 +95,7 @@ default CheckedFunction16<T16, T15, T14, T13, T12, T11, T10, T9, T8, T7, T6, T5,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction17.java
Patch:
@@ -97,7 +97,7 @@ default CheckedFunction17<T17, T16, T15, T14, T13, T12, T11, T10, T9, T8, T7, T6
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction18.java
Patch:
@@ -99,7 +99,7 @@ default CheckedFunction18<T18, T17, T16, T15, T14, T13, T12, T11, T10, T9, T8, T
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction19.java
Patch:
@@ -101,7 +101,7 @@ default CheckedFunction19<T19, T18, T17, T16, T15, T14, T13, T12, T11, T10, T9,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction2.java
Patch:
@@ -67,7 +67,7 @@ default CheckedFunction2<T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction2<T1, T2, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2) -> after.apply(apply(t1, t2));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction20.java
Patch:
@@ -103,7 +103,7 @@ default CheckedFunction20<T20, T19, T18, T17, T16, T15, T14, T13, T12, T11, T10,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction21.java
Patch:
@@ -105,7 +105,7 @@ default CheckedFunction21<T21, T20, T19, T18, T17, T16, T15, T14, T13, T12, T11,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction22.java
Patch:
@@ -107,7 +107,7 @@ default CheckedFunction22<T22, T21, T20, T19, T18, T17, T16, T15, T14, T13, T12,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction23.java
Patch:
@@ -109,7 +109,7 @@ default CheckedFunction23<T23, T22, T21, T20, T19, T18, T17, T16, T15, T14, T13,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction24.java
Patch:
@@ -111,7 +111,7 @@ default CheckedFunction24<T24, T23, T22, T21, T20, T19, T18, T17, T16, T15, T14,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction25.java
Patch:
@@ -113,7 +113,7 @@ default CheckedFunction25<T25, T24, T23, T22, T21, T20, T19, T18, T17, T16, T15,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction26.java
Patch:
@@ -115,7 +115,7 @@ default CheckedFunction26<T26, T25, T24, T23, T22, T21, T20, T19, T18, T17, T16,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction3.java
Patch:
@@ -69,7 +69,7 @@ default CheckedFunction3<T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction3<T1, T2, T3, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3) -> after.apply(apply(t1, t2, t3));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction4.java
Patch:
@@ -71,7 +71,7 @@ default CheckedFunction4<T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction4<T1, T2, T3, T4, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4) -> after.apply(apply(t1, t2, t3, t4));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction5.java
Patch:
@@ -73,7 +73,7 @@ default CheckedFunction5<T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction5<T1, T2, T3, T4, T5, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5) -> after.apply(apply(t1, t2, t3, t4, t5));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction6.java
Patch:
@@ -75,7 +75,7 @@ default CheckedFunction6<T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction6<T1, T2, T3, T4, T5, T6, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6) -> after.apply(apply(t1, t2, t3, t4, t5, t6));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction7.java
Patch:
@@ -77,7 +77,7 @@ default CheckedFunction7<T7, T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction7<T1, T2, T3, T4, T5, T6, T7, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction8.java
Patch:
@@ -79,7 +79,7 @@ default CheckedFunction8<T8, T7, T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction8<T1, T2, T3, T4, T5, T6, T7, T8, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction9.java
Patch:
@@ -81,7 +81,7 @@ default CheckedFunction9<T9, T8, T7, T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction9<T1, T2, T3, T4, T5, T6, T7, T8, T9, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9));
     }
 

File: src-gen/main/java/javaslang/Function10.java
Patch:
@@ -83,7 +83,7 @@ default Function10<T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10));
     }
 

File: src-gen/main/java/javaslang/Function11.java
Patch:
@@ -85,7 +85,7 @@ default Function11<T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11));
     }
 

File: src-gen/main/java/javaslang/Function12.java
Patch:
@@ -87,7 +87,7 @@ default Function12<T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R> reverse
      * @throws NullPointerException if after is null
      */
     default <V> Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12));
     }
 

File: src-gen/main/java/javaslang/Function13.java
Patch:
@@ -89,7 +89,7 @@ default Function13<T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R> re
      * @throws NullPointerException if after is null
      */
     default <V> Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13));
     }
 

File: src-gen/main/java/javaslang/Function14.java
Patch:
@@ -91,7 +91,7 @@ default Function14<T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1,
      * @throws NullPointerException if after is null
      */
     default <V> Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14));
     }
 

File: src-gen/main/java/javaslang/Function15.java
Patch:
@@ -93,7 +93,7 @@ default Function15<T15, T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2,
      * @throws NullPointerException if after is null
      */
     default <V> Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15));
     }
 

File: src-gen/main/java/javaslang/Function16.java
Patch:
@@ -95,7 +95,7 @@ default Function16<T16, T15, T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3
      * @throws NullPointerException if after is null
      */
     default <V> Function16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16));
     }
 

File: src-gen/main/java/javaslang/Function17.java
Patch:
@@ -97,7 +97,7 @@ default Function17<T17, T16, T15, T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T
      * @throws NullPointerException if after is null
      */
     default <V> Function17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17));
     }
 

File: src-gen/main/java/javaslang/Function18.java
Patch:
@@ -99,7 +99,7 @@ default Function18<T18, T17, T16, T15, T14, T13, T12, T11, T10, T9, T8, T7, T6,
      * @throws NullPointerException if after is null
      */
     default <V> Function18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18));
     }
 

File: src-gen/main/java/javaslang/Function19.java
Patch:
@@ -101,7 +101,7 @@ default Function19<T19, T18, T17, T16, T15, T14, T13, T12, T11, T10, T9, T8, T7,
      * @throws NullPointerException if after is null
      */
     default <V> Function19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19));
     }
 

File: src-gen/main/java/javaslang/Function2.java
Patch:
@@ -67,7 +67,7 @@ default Function2<T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function2<T1, T2, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2) -> after.apply(apply(t1, t2));
     }
 

File: src-gen/main/java/javaslang/Function20.java
Patch:
@@ -103,7 +103,7 @@ default Function20<T20, T19, T18, T17, T16, T15, T14, T13, T12, T11, T10, T9, T8
      * @throws NullPointerException if after is null
      */
     default <V> Function20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20));
     }
 

File: src-gen/main/java/javaslang/Function21.java
Patch:
@@ -105,7 +105,7 @@ default Function21<T21, T20, T19, T18, T17, T16, T15, T14, T13, T12, T11, T10, T
      * @throws NullPointerException if after is null
      */
     default <V> Function21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21));
     }
 

File: src-gen/main/java/javaslang/Function22.java
Patch:
@@ -107,7 +107,7 @@ default Function22<T22, T21, T20, T19, T18, T17, T16, T15, T14, T13, T12, T11, T
      * @throws NullPointerException if after is null
      */
     default <V> Function22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22));
     }
 

File: src-gen/main/java/javaslang/Function23.java
Patch:
@@ -109,7 +109,7 @@ default Function23<T23, T22, T21, T20, T19, T18, T17, T16, T15, T14, T13, T12, T
      * @throws NullPointerException if after is null
      */
     default <V> Function23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23));
     }
 

File: src-gen/main/java/javaslang/Function24.java
Patch:
@@ -111,7 +111,7 @@ default Function24<T24, T23, T22, T21, T20, T19, T18, T17, T16, T15, T14, T13, T
      * @throws NullPointerException if after is null
      */
     default <V> Function24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24));
     }
 

File: src-gen/main/java/javaslang/Function25.java
Patch:
@@ -113,7 +113,7 @@ default Function25<T25, T24, T23, T22, T21, T20, T19, T18, T17, T16, T15, T14, T
      * @throws NullPointerException if after is null
      */
     default <V> Function25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25));
     }
 

File: src-gen/main/java/javaslang/Function26.java
Patch:
@@ -115,7 +115,7 @@ default Function26<T26, T25, T24, T23, T22, T21, T20, T19, T18, T17, T16, T15, T
      * @throws NullPointerException if after is null
      */
     default <V> Function26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26));
     }
 

File: src-gen/main/java/javaslang/Function3.java
Patch:
@@ -69,7 +69,7 @@ default Function3<T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function3<T1, T2, T3, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3) -> after.apply(apply(t1, t2, t3));
     }
 

File: src-gen/main/java/javaslang/Function4.java
Patch:
@@ -71,7 +71,7 @@ default Function4<T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function4<T1, T2, T3, T4, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4) -> after.apply(apply(t1, t2, t3, t4));
     }
 

File: src-gen/main/java/javaslang/Function5.java
Patch:
@@ -73,7 +73,7 @@ default Function5<T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function5<T1, T2, T3, T4, T5, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5) -> after.apply(apply(t1, t2, t3, t4, t5));
     }
 

File: src-gen/main/java/javaslang/Function6.java
Patch:
@@ -75,7 +75,7 @@ default Function6<T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function6<T1, T2, T3, T4, T5, T6, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6) -> after.apply(apply(t1, t2, t3, t4, t5, t6));
     }
 

File: src-gen/main/java/javaslang/Function7.java
Patch:
@@ -77,7 +77,7 @@ default Function7<T7, T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function7<T1, T2, T3, T4, T5, T6, T7, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7));
     }
 

File: src-gen/main/java/javaslang/Function8.java
Patch:
@@ -79,7 +79,7 @@ default Function8<T8, T7, T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function8<T1, T2, T3, T4, T5, T6, T7, T8, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8));
     }
 

File: src-gen/main/java/javaslang/Function9.java
Patch:
@@ -81,7 +81,7 @@ default Function9<T9, T8, T7, T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9));
     }
 

File: src-gen/test/java/javaslang/CheckedFunction0Test.java
Patch:
@@ -24,7 +24,7 @@ public void shouldGetArity() {
     @Test
     public void shouldCurry() {
         final CheckedFunction0<Object> f = () -> null;
-        final CheckedFunction1<Void, Object> curried = f.curried();
+        final CheckedFunction0<Object> curried = f.curried();
         assertThat(curried).isNotNull();
     }
 
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction0<Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction10Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction10<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction11Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction11<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction12Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction12<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction13Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction13<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction14Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction14<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction15Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction15<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction16Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction16<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction17Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction17<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction18Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction18<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction19Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction19<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction20Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction20<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction21Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction21<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction22Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction22<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction23Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction23<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction24Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction24<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction25Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction25<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction26Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction26<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction2Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction2<Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction3Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction3<Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction4Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction4<Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction5Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction5<Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction6Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction6<Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction7Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction7<Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction8Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction8<Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction9Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction9<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function0Test.java
Patch:
@@ -24,7 +24,7 @@ public void shouldGetArity() {
     @Test
     public void shouldCurry() {
         final Function0<Object> f = () -> null;
-        final Function1<Void, Object> curried = f.curried();
+        final Function0<Object> curried = f.curried();
         assertThat(curried).isNotNull();
     }
 
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function0<Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function10Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function10<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function11Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function11<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function12Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function12<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function13Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function13<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function14Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function14<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function15Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function15<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function16Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function16<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function17Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function17<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function18Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function18<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function19Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function19<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function20Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function20<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function21Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function21<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function22Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function22<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function23Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function23<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function24Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function24<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function25Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function25<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function26Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function26<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function2Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function2<Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function3Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function3<Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function4Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function4<Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function5Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function5<Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function6Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function6<Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function7Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function7<Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function8Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function8<Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function9Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function9<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/main/java/javaslang/CheckedFunction10.java
Patch:
@@ -83,7 +83,7 @@ default CheckedFunction10<T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R> reversed()
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction11.java
Patch:
@@ -85,7 +85,7 @@ default CheckedFunction11<T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R> rever
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction12.java
Patch:
@@ -87,7 +87,7 @@ default CheckedFunction12<T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R>
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction13.java
Patch:
@@ -89,7 +89,7 @@ default CheckedFunction13<T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction14.java
Patch:
@@ -91,7 +91,7 @@ default CheckedFunction14<T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction15.java
Patch:
@@ -93,7 +93,7 @@ default CheckedFunction15<T15, T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T4,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction16.java
Patch:
@@ -95,7 +95,7 @@ default CheckedFunction16<T16, T15, T14, T13, T12, T11, T10, T9, T8, T7, T6, T5,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction17.java
Patch:
@@ -97,7 +97,7 @@ default CheckedFunction17<T17, T16, T15, T14, T13, T12, T11, T10, T9, T8, T7, T6
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction18.java
Patch:
@@ -99,7 +99,7 @@ default CheckedFunction18<T18, T17, T16, T15, T14, T13, T12, T11, T10, T9, T8, T
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction19.java
Patch:
@@ -101,7 +101,7 @@ default CheckedFunction19<T19, T18, T17, T16, T15, T14, T13, T12, T11, T10, T9,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction2.java
Patch:
@@ -67,7 +67,7 @@ default CheckedFunction2<T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction2<T1, T2, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2) -> after.apply(apply(t1, t2));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction20.java
Patch:
@@ -103,7 +103,7 @@ default CheckedFunction20<T20, T19, T18, T17, T16, T15, T14, T13, T12, T11, T10,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction21.java
Patch:
@@ -105,7 +105,7 @@ default CheckedFunction21<T21, T20, T19, T18, T17, T16, T15, T14, T13, T12, T11,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction22.java
Patch:
@@ -107,7 +107,7 @@ default CheckedFunction22<T22, T21, T20, T19, T18, T17, T16, T15, T14, T13, T12,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction23.java
Patch:
@@ -109,7 +109,7 @@ default CheckedFunction23<T23, T22, T21, T20, T19, T18, T17, T16, T15, T14, T13,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction24.java
Patch:
@@ -111,7 +111,7 @@ default CheckedFunction24<T24, T23, T22, T21, T20, T19, T18, T17, T16, T15, T14,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction25.java
Patch:
@@ -113,7 +113,7 @@ default CheckedFunction25<T25, T24, T23, T22, T21, T20, T19, T18, T17, T16, T15,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction26.java
Patch:
@@ -115,7 +115,7 @@ default CheckedFunction26<T26, T25, T24, T23, T22, T21, T20, T19, T18, T17, T16,
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction3.java
Patch:
@@ -69,7 +69,7 @@ default CheckedFunction3<T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction3<T1, T2, T3, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3) -> after.apply(apply(t1, t2, t3));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction4.java
Patch:
@@ -71,7 +71,7 @@ default CheckedFunction4<T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction4<T1, T2, T3, T4, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4) -> after.apply(apply(t1, t2, t3, t4));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction5.java
Patch:
@@ -73,7 +73,7 @@ default CheckedFunction5<T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction5<T1, T2, T3, T4, T5, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5) -> after.apply(apply(t1, t2, t3, t4, t5));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction6.java
Patch:
@@ -75,7 +75,7 @@ default CheckedFunction6<T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction6<T1, T2, T3, T4, T5, T6, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6) -> after.apply(apply(t1, t2, t3, t4, t5, t6));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction7.java
Patch:
@@ -77,7 +77,7 @@ default CheckedFunction7<T7, T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction7<T1, T2, T3, T4, T5, T6, T7, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction8.java
Patch:
@@ -79,7 +79,7 @@ default CheckedFunction8<T8, T7, T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction8<T1, T2, T3, T4, T5, T6, T7, T8, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8));
     }
 

File: src-gen/main/java/javaslang/CheckedFunction9.java
Patch:
@@ -81,7 +81,7 @@ default CheckedFunction9<T9, T8, T7, T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> CheckedFunction9<T1, T2, T3, T4, T5, T6, T7, T8, T9, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9));
     }
 

File: src-gen/main/java/javaslang/Function10.java
Patch:
@@ -83,7 +83,7 @@ default Function10<T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10));
     }
 

File: src-gen/main/java/javaslang/Function11.java
Patch:
@@ -85,7 +85,7 @@ default Function11<T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11));
     }
 

File: src-gen/main/java/javaslang/Function12.java
Patch:
@@ -87,7 +87,7 @@ default Function12<T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R> reverse
      * @throws NullPointerException if after is null
      */
     default <V> Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12));
     }
 

File: src-gen/main/java/javaslang/Function13.java
Patch:
@@ -89,7 +89,7 @@ default Function13<T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R> re
      * @throws NullPointerException if after is null
      */
     default <V> Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13));
     }
 

File: src-gen/main/java/javaslang/Function14.java
Patch:
@@ -91,7 +91,7 @@ default Function14<T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1,
      * @throws NullPointerException if after is null
      */
     default <V> Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14));
     }
 

File: src-gen/main/java/javaslang/Function15.java
Patch:
@@ -93,7 +93,7 @@ default Function15<T15, T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2,
      * @throws NullPointerException if after is null
      */
     default <V> Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15));
     }
 

File: src-gen/main/java/javaslang/Function16.java
Patch:
@@ -95,7 +95,7 @@ default Function16<T16, T15, T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3
      * @throws NullPointerException if after is null
      */
     default <V> Function16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16));
     }
 

File: src-gen/main/java/javaslang/Function17.java
Patch:
@@ -97,7 +97,7 @@ default Function17<T17, T16, T15, T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T
      * @throws NullPointerException if after is null
      */
     default <V> Function17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17));
     }
 

File: src-gen/main/java/javaslang/Function18.java
Patch:
@@ -99,7 +99,7 @@ default Function18<T18, T17, T16, T15, T14, T13, T12, T11, T10, T9, T8, T7, T6,
      * @throws NullPointerException if after is null
      */
     default <V> Function18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18));
     }
 

File: src-gen/main/java/javaslang/Function19.java
Patch:
@@ -101,7 +101,7 @@ default Function19<T19, T18, T17, T16, T15, T14, T13, T12, T11, T10, T9, T8, T7,
      * @throws NullPointerException if after is null
      */
     default <V> Function19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19));
     }
 

File: src-gen/main/java/javaslang/Function2.java
Patch:
@@ -67,7 +67,7 @@ default Function2<T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function2<T1, T2, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2) -> after.apply(apply(t1, t2));
     }
 

File: src-gen/main/java/javaslang/Function20.java
Patch:
@@ -103,7 +103,7 @@ default Function20<T20, T19, T18, T17, T16, T15, T14, T13, T12, T11, T10, T9, T8
      * @throws NullPointerException if after is null
      */
     default <V> Function20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20));
     }
 

File: src-gen/main/java/javaslang/Function21.java
Patch:
@@ -105,7 +105,7 @@ default Function21<T21, T20, T19, T18, T17, T16, T15, T14, T13, T12, T11, T10, T
      * @throws NullPointerException if after is null
      */
     default <V> Function21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21));
     }
 

File: src-gen/main/java/javaslang/Function22.java
Patch:
@@ -107,7 +107,7 @@ default Function22<T22, T21, T20, T19, T18, T17, T16, T15, T14, T13, T12, T11, T
      * @throws NullPointerException if after is null
      */
     default <V> Function22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22));
     }
 

File: src-gen/main/java/javaslang/Function23.java
Patch:
@@ -109,7 +109,7 @@ default Function23<T23, T22, T21, T20, T19, T18, T17, T16, T15, T14, T13, T12, T
      * @throws NullPointerException if after is null
      */
     default <V> Function23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23));
     }
 

File: src-gen/main/java/javaslang/Function24.java
Patch:
@@ -111,7 +111,7 @@ default Function24<T24, T23, T22, T21, T20, T19, T18, T17, T16, T15, T14, T13, T
      * @throws NullPointerException if after is null
      */
     default <V> Function24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24));
     }
 

File: src-gen/main/java/javaslang/Function25.java
Patch:
@@ -113,7 +113,7 @@ default Function25<T25, T24, T23, T22, T21, T20, T19, T18, T17, T16, T15, T14, T
      * @throws NullPointerException if after is null
      */
     default <V> Function25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25));
     }
 

File: src-gen/main/java/javaslang/Function26.java
Patch:
@@ -115,7 +115,7 @@ default Function26<T26, T25, T24, T23, T22, T21, T20, T19, T18, T17, T16, T15, T
      * @throws NullPointerException if after is null
      */
     default <V> Function26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26));
     }
 

File: src-gen/main/java/javaslang/Function3.java
Patch:
@@ -69,7 +69,7 @@ default Function3<T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function3<T1, T2, T3, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3) -> after.apply(apply(t1, t2, t3));
     }
 

File: src-gen/main/java/javaslang/Function4.java
Patch:
@@ -71,7 +71,7 @@ default Function4<T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function4<T1, T2, T3, T4, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4) -> after.apply(apply(t1, t2, t3, t4));
     }
 

File: src-gen/main/java/javaslang/Function5.java
Patch:
@@ -73,7 +73,7 @@ default Function5<T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function5<T1, T2, T3, T4, T5, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5) -> after.apply(apply(t1, t2, t3, t4, t5));
     }
 

File: src-gen/main/java/javaslang/Function6.java
Patch:
@@ -75,7 +75,7 @@ default Function6<T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function6<T1, T2, T3, T4, T5, T6, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6) -> after.apply(apply(t1, t2, t3, t4, t5, t6));
     }
 

File: src-gen/main/java/javaslang/Function7.java
Patch:
@@ -77,7 +77,7 @@ default Function7<T7, T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function7<T1, T2, T3, T4, T5, T6, T7, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7));
     }
 

File: src-gen/main/java/javaslang/Function8.java
Patch:
@@ -79,7 +79,7 @@ default Function8<T8, T7, T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function8<T1, T2, T3, T4, T5, T6, T7, T8, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8));
     }
 

File: src-gen/main/java/javaslang/Function9.java
Patch:
@@ -81,7 +81,7 @@ default Function9<T9, T8, T7, T6, T5, T4, T3, T2, T1, R> reversed() {
      * @throws NullPointerException if after is null
      */
     default <V> Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, V> andThen(Function1<? super R, ? extends V> after) {
-        Objects.requireNonNull(after);
+        Objects.requireNonNull(after, "after is null");
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9));
     }
 

File: src-gen/test/java/javaslang/CheckedFunction0Test.java
Patch:
@@ -24,7 +24,7 @@ public void shouldGetArity() {
     @Test
     public void shouldCurry() {
         final CheckedFunction0<Object> f = () -> null;
-        final CheckedFunction1<Void, Object> curried = f.curried();
+        final CheckedFunction0<Object> curried = f.curried();
         assertThat(curried).isNotNull();
     }
 
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction0<Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction10Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction10<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction11Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction11<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction12Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction12<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction13Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction13<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction14Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction14<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction15Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction15<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction16Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction16<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction17Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction17<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction18Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction18<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction19Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction19<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction20Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction20<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction21Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction21<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction22Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction22<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction23Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction23<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction24Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction24<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction25Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction25<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction26Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction26<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction2Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction2<Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction3Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction3<Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction4Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction4<Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction5Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction5<Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction6Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction6<Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction7Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction7<Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction8Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction8<Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/CheckedFunction9Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final CheckedFunction9<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function0Test.java
Patch:
@@ -24,7 +24,7 @@ public void shouldGetArity() {
     @Test
     public void shouldCurry() {
         final Function0<Object> f = () -> null;
-        final Function1<Void, Object> curried = f.curried();
+        final Function0<Object> curried = f.curried();
         assertThat(curried).isNotNull();
     }
 
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function0<Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function10Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function10<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function11Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function11<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function12Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function12<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function13Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function13<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function14Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function14<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function15Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function15<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function16Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function16<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function17Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function17<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function18Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function18<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function19Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function19<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function20Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function20<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function21Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function21<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function22Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function22<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function23Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function23<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function24Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function24<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function25Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function25<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function26Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function26<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function2Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function2<Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function3Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function3<Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function4Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function4<Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function5Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function5<Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function6Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function6<Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function7Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function7<Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function8Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function8<Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/test/java/javaslang/Function9Test.java
Patch:
@@ -48,4 +48,5 @@ public void shouldComposeWithAndThen() {
         final Function9<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }
+
 }
\ No newline at end of file

File: src-gen/main/java/javaslang/algebra/Monad1.java
Patch:
@@ -12,9 +12,9 @@
 import javaslang.Function1;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 1-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad1 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -44,7 +44,7 @@ public interface Monad1<T1, M extends HigherKinded1<?, M>> extends Functor1<T1>,
      * @param <U1> 1st component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T1 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U1 and container type M
+     * @return a new Monad1 instance of component types U1,,U1 and container type M
      */
     <U1, MONAD extends HigherKinded1<U1, M>> Monad1<U1, M> flatMap(Function1<? super T1, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad10.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple10;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 10-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad10 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -64,7 +64,7 @@ public interface Monad10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, M extends High
      * @param <U10> 10th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T10 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U10 and container type M
+     * @return a new Monad10 instance of component types U1,,U10 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, MONAD extends HigherKinded10<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, M>> Monad10<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, M> flatMap(Function10<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad11.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple11;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 11-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad11 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -66,7 +66,7 @@ public interface Monad11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, M extends
      * @param <U11> 11th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T11 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U11 and container type M
+     * @return a new Monad11 instance of component types U1,,U11 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, MONAD extends HigherKinded11<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, M>> Monad11<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, M> flatMap(Function11<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad12.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple12;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 12-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad12 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -68,7 +68,7 @@ public interface Monad12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, M ex
      * @param <U12> 12th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T12 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U12 and container type M
+     * @return a new Monad12 instance of component types U1,,U12 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, MONAD extends HigherKinded12<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, M>> Monad12<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, M> flatMap(Function12<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad13.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple13;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 13-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad13 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -70,7 +70,7 @@ public interface Monad13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U13> 13th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T13 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U13 and container type M
+     * @return a new Monad13 instance of component types U1,,U13 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, MONAD extends HigherKinded13<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, M>> Monad13<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, M> flatMap(Function13<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad14.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple14;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 14-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad14 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -72,7 +72,7 @@ public interface Monad14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U14> 14th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T14 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U14 and container type M
+     * @return a new Monad14 instance of component types U1,,U14 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, MONAD extends HigherKinded14<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, M>> Monad14<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, M> flatMap(Function14<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad15.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple15;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 15-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad15 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -74,7 +74,7 @@ public interface Monad15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U15> 15th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T15 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U15 and container type M
+     * @return a new Monad15 instance of component types U1,,U15 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, MONAD extends HigherKinded15<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, M>> Monad15<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, M> flatMap(Function15<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad16.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple16;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 16-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad16 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -76,7 +76,7 @@ public interface Monad16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U16> 16th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T16 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U16 and container type M
+     * @return a new Monad16 instance of component types U1,,U16 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, MONAD extends HigherKinded16<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, M>> Monad16<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, M> flatMap(Function16<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad17.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple17;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 17-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad17 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -78,7 +78,7 @@ public interface Monad17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U17> 17th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T17 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U17 and container type M
+     * @return a new Monad17 instance of component types U1,,U17 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, MONAD extends HigherKinded17<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, M>> Monad17<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, M> flatMap(Function17<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad18.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple18;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 18-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad18 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -80,7 +80,7 @@ public interface Monad18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U18> 18th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T18 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U18 and container type M
+     * @return a new Monad18 instance of component types U1,,U18 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, MONAD extends HigherKinded18<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, M>> Monad18<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, M> flatMap(Function18<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, ? super T18, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad19.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple19;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 19-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad19 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -82,7 +82,7 @@ public interface Monad19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U19> 19th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T19 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U19 and container type M
+     * @return a new Monad19 instance of component types U1,,U19 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, MONAD extends HigherKinded19<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, M>> Monad19<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, M> flatMap(Function19<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, ? super T18, ? super T19, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad2.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple2;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 2-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad2 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -48,7 +48,7 @@ public interface Monad2<T1, T2, M extends HigherKinded2<?, ?, M>> extends Functo
      * @param <U2> 2nd component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T2 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U2 and container type M
+     * @return a new Monad2 instance of component types U1,,U2 and container type M
      */
     <U1, U2, MONAD extends HigherKinded2<U1, U2, M>> Monad2<U1, U2, M> flatMap(Function2<? super T1, ? super T2, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad20.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple20;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 20-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad20 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -84,7 +84,7 @@ public interface Monad20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U20> 20th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T20 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U20 and container type M
+     * @return a new Monad20 instance of component types U1,,U20 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, MONAD extends HigherKinded20<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, M>> Monad20<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, M> flatMap(Function20<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, ? super T18, ? super T19, ? super T20, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad21.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple21;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 21-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad21 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -86,7 +86,7 @@ public interface Monad21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U21> 1st component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T21 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U21 and container type M
+     * @return a new Monad21 instance of component types U1,,U21 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, MONAD extends HigherKinded21<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, M>> Monad21<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, M> flatMap(Function21<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, ? super T18, ? super T19, ? super T20, ? super T21, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad22.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple22;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 22-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad22 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -88,7 +88,7 @@ public interface Monad22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U22> 2nd component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T22 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U22 and container type M
+     * @return a new Monad22 instance of component types U1,,U22 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, MONAD extends HigherKinded22<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, M>> Monad22<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, M> flatMap(Function22<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, ? super T18, ? super T19, ? super T20, ? super T21, ? super T22, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad23.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple23;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 23-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad23 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -90,7 +90,7 @@ public interface Monad23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U23> 3rd component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T23 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U23 and container type M
+     * @return a new Monad23 instance of component types U1,,U23 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, MONAD extends HigherKinded23<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, M>> Monad23<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, M> flatMap(Function23<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, ? super T18, ? super T19, ? super T20, ? super T21, ? super T22, ? super T23, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad24.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple24;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 24-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad24 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -92,7 +92,7 @@ public interface Monad24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U24> 24th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T24 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U24 and container type M
+     * @return a new Monad24 instance of component types U1,,U24 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, U24, MONAD extends HigherKinded24<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, U24, M>> Monad24<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, U24, M> flatMap(Function24<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, ? super T18, ? super T19, ? super T20, ? super T21, ? super T22, ? super T23, ? super T24, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad25.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple25;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 25-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad25 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -94,7 +94,7 @@ public interface Monad25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U25> 25th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T25 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U25 and container type M
+     * @return a new Monad25 instance of component types U1,,U25 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, U24, U25, MONAD extends HigherKinded25<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, U24, U25, M>> Monad25<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, U24, U25, M> flatMap(Function25<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, ? super T18, ? super T19, ? super T20, ? super T21, ? super T22, ? super T23, ? super T24, ? super T25, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad26.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple26;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 26-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad26 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -96,7 +96,7 @@ public interface Monad26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U26> 26th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T26 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U26 and container type M
+     * @return a new Monad26 instance of component types U1,,U26 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, U24, U25, U26, MONAD extends HigherKinded26<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, U24, U25, U26, M>> Monad26<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, U24, U25, U26, M> flatMap(Function26<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, ? super T18, ? super T19, ? super T20, ? super T21, ? super T22, ? super T23, ? super T24, ? super T25, ? super T26, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad3.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple3;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 3-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad3 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -50,7 +50,7 @@ public interface Monad3<T1, T2, T3, M extends HigherKinded3<?, ?, ?, M>> extends
      * @param <U3> 3rd component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T3 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U3 and container type M
+     * @return a new Monad3 instance of component types U1,,U3 and container type M
      */
     <U1, U2, U3, MONAD extends HigherKinded3<U1, U2, U3, M>> Monad3<U1, U2, U3, M> flatMap(Function3<? super T1, ? super T2, ? super T3, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad4.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple4;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 4-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad4 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -52,7 +52,7 @@ public interface Monad4<T1, T2, T3, T4, M extends HigherKinded4<?, ?, ?, ?, M>>
      * @param <U4> 4th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T4 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U4 and container type M
+     * @return a new Monad4 instance of component types U1,,U4 and container type M
      */
     <U1, U2, U3, U4, MONAD extends HigherKinded4<U1, U2, U3, U4, M>> Monad4<U1, U2, U3, U4, M> flatMap(Function4<? super T1, ? super T2, ? super T3, ? super T4, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad5.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple5;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 5-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad5 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -54,7 +54,7 @@ public interface Monad5<T1, T2, T3, T4, T5, M extends HigherKinded5<?, ?, ?, ?,
      * @param <U5> 5th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T5 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U5 and container type M
+     * @return a new Monad5 instance of component types U1,,U5 and container type M
      */
     <U1, U2, U3, U4, U5, MONAD extends HigherKinded5<U1, U2, U3, U4, U5, M>> Monad5<U1, U2, U3, U4, U5, M> flatMap(Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad6.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple6;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 6-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad6 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -56,7 +56,7 @@ public interface Monad6<T1, T2, T3, T4, T5, T6, M extends HigherKinded6<?, ?, ?,
      * @param <U6> 6th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T6 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U6 and container type M
+     * @return a new Monad6 instance of component types U1,,U6 and container type M
      */
     <U1, U2, U3, U4, U5, U6, MONAD extends HigherKinded6<U1, U2, U3, U4, U5, U6, M>> Monad6<U1, U2, U3, U4, U5, U6, M> flatMap(Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad7.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple7;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 7-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad7 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -58,7 +58,7 @@ public interface Monad7<T1, T2, T3, T4, T5, T6, T7, M extends HigherKinded7<?, ?
      * @param <U7> 7th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T7 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U7 and container type M
+     * @return a new Monad7 instance of component types U1,,U7 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, MONAD extends HigherKinded7<U1, U2, U3, U4, U5, U6, U7, M>> Monad7<U1, U2, U3, U4, U5, U6, U7, M> flatMap(Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad8.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple8;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 8-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad8 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -60,7 +60,7 @@ public interface Monad8<T1, T2, T3, T4, T5, T6, T7, T8, M extends HigherKinded8<
      * @param <U8> 8th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T8 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U8 and container type M
+     * @return a new Monad8 instance of component types U1,,U8 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, MONAD extends HigherKinded8<U1, U2, U3, U4, U5, U6, U7, U8, M>> Monad8<U1, U2, U3, U4, U5, U6, U7, U8, M> flatMap(Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad9.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple9;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 9-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad9 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -62,7 +62,7 @@ public interface Monad9<T1, T2, T3, T4, T5, T6, T7, T8, T9, M extends HigherKind
      * @param <U9> 9th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T9 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U9 and container type M
+     * @return a new Monad9 instance of component types U1,,U9 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, MONAD extends HigherKinded9<U1, U2, U3, U4, U5, U6, U7, U8, U9, M>> Monad9<U1, U2, U3, U4, U5, U6, U7, U8, U9, M> flatMap(Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, MONAD> f);
 

File: src/main/java/javaslang/control/Failure.java
Patch:
@@ -131,14 +131,14 @@ public void forEach(Consumer<? super T> action) {
     }
 
     @Override
-    public <U> Failure<U> map(Function1<? super T, ? extends U> mapper) {
+    public <U> Failure<U> map(CheckedFunction1<? super T, ? extends U> mapper) {
         @SuppressWarnings("unchecked")
         final Failure<U> result = (Failure<U>) this;
         return result;
     }
 
     @Override
-    public <U, TRY extends HigherKinded1<U, Try<?>>> Failure<U> flatMap(Function1<? super T, TRY> mapper) {
+    public <U, TRY extends HigherKinded1<U, Try<?>>> Failure<U> flatMap(CheckedFunction1<? super T, TRY> mapper) {
         @SuppressWarnings("unchecked")
         final Failure<U> result = (Failure<U>) this;
         return result;

File: src/main/java/javaslang/control/Success.java
Patch:
@@ -126,7 +126,7 @@ public void forEach(Consumer<? super T> action) {
     }
 
     @Override
-    public <U> Try<U> map(Function1<? super T, ? extends U> mapper) {
+    public <U> Try<U> map(CheckedFunction1<? super T, ? extends U> mapper) {
         try {
             return new Success<>(mapper.apply(value));
         } catch (Throwable t) {
@@ -136,7 +136,7 @@ public <U> Try<U> map(Function1<? super T, ? extends U> mapper) {
 
     @SuppressWarnings("unchecked")
     @Override
-    public <U, TRY extends HigherKinded1<U, Try<?>>> Try<U> flatMap(Function1<? super T, TRY> mapper) {
+    public <U, TRY extends HigherKinded1<U, Try<?>>> Try<U> flatMap(CheckedFunction1<? super T, TRY> mapper) {
         try {
             return (Try<U>) mapper.apply(value);
         } catch (Throwable t) {

File: src/test/java/javaslang/TypeConsistencyTest.java
Patch:
@@ -32,8 +32,8 @@ public class TypeConsistencyTest {
 
             // control.Success
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.filter(javaslang.control.Try$CheckedPredicate)",
-            "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.map(javaslang.Function1)",
-            "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.flatMap(javaslang.Function1)",
+            "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.map(javaslang.CheckedFunction1)",
+            "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.flatMap(javaslang.CheckedFunction1)",
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.failed()",
             "javaslang.control.Success//public default javaslang.control.Try javaslang.control.Try.andThen(javaslang.control.Try$CheckedRunnable)",
 

File: src-gen/main/java/javaslang/algebra/Monad1.java
Patch:
@@ -12,9 +12,9 @@
 import javaslang.Function1;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 1-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad1 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -44,7 +44,7 @@ public interface Monad1<T1, M extends HigherKinded1<?, M>> extends Functor1<T1>,
      * @param <U1> 1st component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T1 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U1 and container type M
+     * @return a new Monad1 instance of component types U1,,U1 and container type M
      */
     <U1, MONAD extends HigherKinded1<U1, M>> Monad1<U1, M> flatMap(Function1<? super T1, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad10.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple10;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 10-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad10 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -64,7 +64,7 @@ public interface Monad10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, M extends High
      * @param <U10> 10th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T10 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U10 and container type M
+     * @return a new Monad10 instance of component types U1,,U10 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, MONAD extends HigherKinded10<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, M>> Monad10<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, M> flatMap(Function10<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad11.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple11;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 11-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad11 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -66,7 +66,7 @@ public interface Monad11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, M extends
      * @param <U11> 11th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T11 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U11 and container type M
+     * @return a new Monad11 instance of component types U1,,U11 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, MONAD extends HigherKinded11<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, M>> Monad11<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, M> flatMap(Function11<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad12.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple12;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 12-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad12 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -68,7 +68,7 @@ public interface Monad12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, M ex
      * @param <U12> 12th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T12 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U12 and container type M
+     * @return a new Monad12 instance of component types U1,,U12 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, MONAD extends HigherKinded12<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, M>> Monad12<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, M> flatMap(Function12<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad13.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple13;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 13-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad13 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -70,7 +70,7 @@ public interface Monad13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U13> 13th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T13 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U13 and container type M
+     * @return a new Monad13 instance of component types U1,,U13 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, MONAD extends HigherKinded13<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, M>> Monad13<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, M> flatMap(Function13<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad14.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple14;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 14-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad14 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -72,7 +72,7 @@ public interface Monad14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U14> 14th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T14 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U14 and container type M
+     * @return a new Monad14 instance of component types U1,,U14 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, MONAD extends HigherKinded14<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, M>> Monad14<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, M> flatMap(Function14<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad15.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple15;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 15-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad15 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -74,7 +74,7 @@ public interface Monad15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U15> 15th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T15 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U15 and container type M
+     * @return a new Monad15 instance of component types U1,,U15 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, MONAD extends HigherKinded15<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, M>> Monad15<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, M> flatMap(Function15<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad16.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple16;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 16-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad16 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -76,7 +76,7 @@ public interface Monad16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U16> 16th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T16 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U16 and container type M
+     * @return a new Monad16 instance of component types U1,,U16 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, MONAD extends HigherKinded16<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, M>> Monad16<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, M> flatMap(Function16<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad17.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple17;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 17-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad17 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -78,7 +78,7 @@ public interface Monad17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U17> 17th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T17 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U17 and container type M
+     * @return a new Monad17 instance of component types U1,,U17 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, MONAD extends HigherKinded17<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, M>> Monad17<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, M> flatMap(Function17<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad18.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple18;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 18-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad18 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -80,7 +80,7 @@ public interface Monad18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U18> 18th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T18 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U18 and container type M
+     * @return a new Monad18 instance of component types U1,,U18 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, MONAD extends HigherKinded18<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, M>> Monad18<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, M> flatMap(Function18<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, ? super T18, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad19.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple19;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 19-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad19 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -82,7 +82,7 @@ public interface Monad19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U19> 19th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T19 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U19 and container type M
+     * @return a new Monad19 instance of component types U1,,U19 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, MONAD extends HigherKinded19<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, M>> Monad19<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, M> flatMap(Function19<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, ? super T18, ? super T19, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad2.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple2;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 2-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad2 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -48,7 +48,7 @@ public interface Monad2<T1, T2, M extends HigherKinded2<?, ?, M>> extends Functo
      * @param <U2> 2nd component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T2 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U2 and container type M
+     * @return a new Monad2 instance of component types U1,,U2 and container type M
      */
     <U1, U2, MONAD extends HigherKinded2<U1, U2, M>> Monad2<U1, U2, M> flatMap(Function2<? super T1, ? super T2, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad20.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple20;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 20-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad20 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -84,7 +84,7 @@ public interface Monad20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U20> 20th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T20 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U20 and container type M
+     * @return a new Monad20 instance of component types U1,,U20 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, MONAD extends HigherKinded20<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, M>> Monad20<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, M> flatMap(Function20<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, ? super T18, ? super T19, ? super T20, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad21.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple21;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 21-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad21 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -86,7 +86,7 @@ public interface Monad21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U21> 1st component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T21 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U21 and container type M
+     * @return a new Monad21 instance of component types U1,,U21 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, MONAD extends HigherKinded21<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, M>> Monad21<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, M> flatMap(Function21<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, ? super T18, ? super T19, ? super T20, ? super T21, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad22.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple22;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 22-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad22 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -88,7 +88,7 @@ public interface Monad22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U22> 2nd component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T22 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U22 and container type M
+     * @return a new Monad22 instance of component types U1,,U22 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, MONAD extends HigherKinded22<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, M>> Monad22<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, M> flatMap(Function22<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, ? super T18, ? super T19, ? super T20, ? super T21, ? super T22, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad23.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple23;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 23-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad23 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -90,7 +90,7 @@ public interface Monad23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U23> 3rd component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T23 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U23 and container type M
+     * @return a new Monad23 instance of component types U1,,U23 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, MONAD extends HigherKinded23<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, M>> Monad23<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, M> flatMap(Function23<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, ? super T18, ? super T19, ? super T20, ? super T21, ? super T22, ? super T23, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad24.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple24;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 24-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad24 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -92,7 +92,7 @@ public interface Monad24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U24> 24th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T24 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U24 and container type M
+     * @return a new Monad24 instance of component types U1,,U24 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, U24, MONAD extends HigherKinded24<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, U24, M>> Monad24<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, U24, M> flatMap(Function24<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, ? super T18, ? super T19, ? super T20, ? super T21, ? super T22, ? super T23, ? super T24, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad25.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple25;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 25-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad25 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -94,7 +94,7 @@ public interface Monad25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U25> 25th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T25 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U25 and container type M
+     * @return a new Monad25 instance of component types U1,,U25 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, U24, U25, MONAD extends HigherKinded25<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, U24, U25, M>> Monad25<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, U24, U25, M> flatMap(Function25<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, ? super T18, ? super T19, ? super T20, ? super T21, ? super T22, ? super T23, ? super T24, ? super T25, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad26.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple26;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 26-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad26 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -96,7 +96,7 @@ public interface Monad26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      * @param <U26> 26th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T26 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U26 and container type M
+     * @return a new Monad26 instance of component types U1,,U26 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, U24, U25, U26, MONAD extends HigherKinded26<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, U24, U25, U26, M>> Monad26<U1, U2, U3, U4, U5, U6, U7, U8, U9, U10, U11, U12, U13, U14, U15, U16, U17, U18, U19, U20, U21, U22, U23, U24, U25, U26, M> flatMap(Function26<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? super T10, ? super T11, ? super T12, ? super T13, ? super T14, ? super T15, ? super T16, ? super T17, ? super T18, ? super T19, ? super T20, ? super T21, ? super T22, ? super T23, ? super T24, ? super T25, ? super T26, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad3.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple3;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 3-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad3 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -50,7 +50,7 @@ public interface Monad3<T1, T2, T3, M extends HigherKinded3<?, ?, ?, M>> extends
      * @param <U3> 3rd component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T3 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U3 and container type M
+     * @return a new Monad3 instance of component types U1,,U3 and container type M
      */
     <U1, U2, U3, MONAD extends HigherKinded3<U1, U2, U3, M>> Monad3<U1, U2, U3, M> flatMap(Function3<? super T1, ? super T2, ? super T3, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad4.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple4;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 4-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad4 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -52,7 +52,7 @@ public interface Monad4<T1, T2, T3, T4, M extends HigherKinded4<?, ?, ?, ?, M>>
      * @param <U4> 4th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T4 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U4 and container type M
+     * @return a new Monad4 instance of component types U1,,U4 and container type M
      */
     <U1, U2, U3, U4, MONAD extends HigherKinded4<U1, U2, U3, U4, M>> Monad4<U1, U2, U3, U4, M> flatMap(Function4<? super T1, ? super T2, ? super T3, ? super T4, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad5.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple5;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 5-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad5 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -54,7 +54,7 @@ public interface Monad5<T1, T2, T3, T4, T5, M extends HigherKinded5<?, ?, ?, ?,
      * @param <U5> 5th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T5 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U5 and container type M
+     * @return a new Monad5 instance of component types U1,,U5 and container type M
      */
     <U1, U2, U3, U4, U5, MONAD extends HigherKinded5<U1, U2, U3, U4, U5, M>> Monad5<U1, U2, U3, U4, U5, M> flatMap(Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad6.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple6;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 6-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad6 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -56,7 +56,7 @@ public interface Monad6<T1, T2, T3, T4, T5, T6, M extends HigherKinded6<?, ?, ?,
      * @param <U6> 6th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T6 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U6 and container type M
+     * @return a new Monad6 instance of component types U1,,U6 and container type M
      */
     <U1, U2, U3, U4, U5, U6, MONAD extends HigherKinded6<U1, U2, U3, U4, U5, U6, M>> Monad6<U1, U2, U3, U4, U5, U6, M> flatMap(Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad7.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple7;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 7-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad7 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -58,7 +58,7 @@ public interface Monad7<T1, T2, T3, T4, T5, T6, T7, M extends HigherKinded7<?, ?
      * @param <U7> 7th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T7 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U7 and container type M
+     * @return a new Monad7 instance of component types U1,,U7 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, MONAD extends HigherKinded7<U1, U2, U3, U4, U5, U6, U7, M>> Monad7<U1, U2, U3, U4, U5, U6, U7, M> flatMap(Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad8.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple8;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 8-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad8 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -60,7 +60,7 @@ public interface Monad8<T1, T2, T3, T4, T5, T6, T7, T8, M extends HigherKinded8<
      * @param <U8> 8th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T8 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U8 and container type M
+     * @return a new Monad8 instance of component types U1,,U8 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, MONAD extends HigherKinded8<U1, U2, U3, U4, U5, U6, U7, U8, M>> Monad8<U1, U2, U3, U4, U5, U6, U7, U8, M> flatMap(Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, MONAD> f);
 

File: src-gen/main/java/javaslang/algebra/Monad9.java
Patch:
@@ -14,9 +14,9 @@
 import javaslang.Tuple9;
 
 /**
- * Defines a Monad by generalizing the flatMap function.
+ * Defines a 9-ary Monad by generalizing the flatMap function.
  * <p>
- * All instances of the Monad interface should obey the three control laws:
+ * All instances of the Monad9 interface should obey the three control laws:
  * <ul>
  *     <li><strong>Left identity:</strong> {@code unit(a).flatMap(f)  f a}</li>
  *     <li><strong>Right identity:</strong> {@code m.flatMap(unit)  m}</li>
@@ -62,7 +62,7 @@ public interface Monad9<T1, T2, T3, T4, T5, T6, T7, T8, T9, M extends HigherKind
      * @param <U9> 9th component type of this monad
      * @param <MONAD> placeholder for the monad type of component types T1,,T9 and container type M
      * @param f a function that maps the monad values to a new monad instance
-     * @return a new monad instance of component types U1,,U9 and container type M
+     * @return a new Monad9 instance of component types U1,,U9 and container type M
      */
     <U1, U2, U3, U4, U5, U6, U7, U8, U9, MONAD extends HigherKinded9<U1, U2, U3, U4, U5, U6, U7, U8, U9, M>> Monad9<U1, U2, U3, U4, U5, U6, U7, U8, U9, M> flatMap(Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, MONAD> f);
 

File: src/main/java/javaslang/control/Failure.java
Patch:
@@ -131,14 +131,14 @@ public void forEach(Consumer<? super T> action) {
     }
 
     @Override
-    public <U> Failure<U> map(Function1<? super T, ? extends U> mapper) {
+    public <U> Failure<U> map(CheckedFunction1<? super T, ? extends U> mapper) {
         @SuppressWarnings("unchecked")
         final Failure<U> result = (Failure<U>) this;
         return result;
     }
 
     @Override
-    public <U, TRY extends HigherKinded1<U, Try<?>>> Failure<U> flatMap(Function1<? super T, TRY> mapper) {
+    public <U, TRY extends HigherKinded1<U, Try<?>>> Failure<U> flatMap(CheckedFunction1<? super T, TRY> mapper) {
         @SuppressWarnings("unchecked")
         final Failure<U> result = (Failure<U>) this;
         return result;

File: src/main/java/javaslang/control/Success.java
Patch:
@@ -126,7 +126,7 @@ public void forEach(Consumer<? super T> action) {
     }
 
     @Override
-    public <U> Try<U> map(Function1<? super T, ? extends U> mapper) {
+    public <U> Try<U> map(CheckedFunction1<? super T, ? extends U> mapper) {
         try {
             return new Success<>(mapper.apply(value));
         } catch (Throwable t) {
@@ -136,7 +136,7 @@ public <U> Try<U> map(Function1<? super T, ? extends U> mapper) {
 
     @SuppressWarnings("unchecked")
     @Override
-    public <U, TRY extends HigherKinded1<U, Try<?>>> Try<U> flatMap(Function1<? super T, TRY> mapper) {
+    public <U, TRY extends HigherKinded1<U, Try<?>>> Try<U> flatMap(CheckedFunction1<? super T, TRY> mapper) {
         try {
             return (Try<U>) mapper.apply(value);
         } catch (Throwable t) {

File: src/test/java/javaslang/TypeConsistencyTest.java
Patch:
@@ -32,8 +32,8 @@ public class TypeConsistencyTest {
 
             // control.Success
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.filter(javaslang.control.Try$CheckedPredicate)",
-            "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.map(javaslang.Function1)",
-            "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.flatMap(javaslang.Function1)",
+            "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.map(javaslang.CheckedFunction1)",
+            "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.flatMap(javaslang.CheckedFunction1)",
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.failed()",
             "javaslang.control.Success//public default javaslang.control.Try javaslang.control.Try.andThen(javaslang.control.Try$CheckedRunnable)",
 

File: src/main/java/javaslang/Lazy.java
Patch:
@@ -21,6 +21,7 @@
  * lazyDouble.get() // returns the memoized value, e.g. 0.123
  * </code>
  * </pre>
+ *
  * @since 1.3.0
  */
 public final class Lazy<T> implements Supplier<T>, ValueObject {
@@ -39,7 +40,7 @@ private Lazy(Supplier<T> supplier) {
     /**
      * Creates a Lazy, because it is easier to write {@code Lazy.of(xxx)} than {@code new Lazy<>(xxx)}.
      *
-     * @param <T> type of the lazy value
+     * @param <T>      type of the lazy value
      * @param supplier A supplier
      * @return A new instance of Lazy
      */

File: src/main/java/javaslang/ValueObject.java
Patch:
@@ -25,6 +25,7 @@
  * "[...] , it doesnt make sense for immutable classes to support object copying, because copies would be virtually indistinguishable from the original."
  * </blockquote>
  * <em>(see Effective Java, 2nd ed., p. 61)</em>.
+ *
  * @since 1.1.0
  */
 public interface ValueObject extends Serializable {

File: src/main/java/javaslang/control/Failure.java
Patch:
@@ -11,7 +11,6 @@
 import java.util.Objects;
 import java.util.Optional;
 import java.util.function.Consumer;
-import java.util.function.Predicate;
 
 /**
  * A failed Try.

File: src/main/java/javaslang/control/None.java
Patch:
@@ -8,7 +8,6 @@
 import javaslang.Function1;
 import javaslang.Tuple;
 import javaslang.Tuple0;
-import javaslang.algebra.Monad1;
 
 import java.util.NoSuchElementException;
 import java.util.Objects;

File: src/main/java/javaslang/control/Success.java
Patch:
@@ -15,7 +15,6 @@
 import java.util.Objects;
 import java.util.Optional;
 import java.util.function.Consumer;
-import java.util.function.Predicate;
 
 /**
  * A succeeded Try.

File: src/main/java/javaslang/control/Valences.java
Patch:
@@ -13,6 +13,7 @@
 
 /**
  * This class is not intended to be extended nor it is intended to be public API.
+ *
  * @since 1.1.0
  */
 final class Valences {

File: src/main/java/javaslang/control/package-info.java
Patch:
@@ -11,7 +11,7 @@
  * If a Right is projected to a Left, the Left control operations have no effect on the Right value.
  * If a Left is projected to a Right, the Right control operations have no effect on the Left value.
  * </p>
- * 
+ *
  * <strong>Option</strong>
  * <p>
  * The Option control is a replacement for {@linkplain java.util.Optional}. An Option is either
@@ -20,7 +20,7 @@
  * However, {@code Option.of(null)} results in None.
  * See also <a href="http://blog.rocketscience.io/your-codebase-looks-like-this/">3 ways to deal with null</a>.
  * </p>
- * 
+ *
  * <strong>Try</strong>
  * <p>
  * Exceptions are handled with the {@linkplain javaslang.control.Try} control which is either a

File: src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -107,6 +107,7 @@ default Arbitrary<T> filter(Predicate<T> predicate) {
 
     /**
      * <p>Generates arbitrary integer values.</p>
+     *
      * @return A new Arbitrary of Integer
      */
     static Arbitrary<Integer> integer() {
@@ -149,7 +150,7 @@ static Arbitrary<String> string(Gen<Character> gen) {
      * </pre>
      *
      * @param arbitraryT Arbitrary elements of type T
-     * @param <T> Component type of the List
+     * @param <T>        Component type of the List
      * @return a new Arbitrary of List&lt;T&gt;
      */
     static <T> Arbitrary<List<T>> list(Arbitrary<T> arbitraryT) {
@@ -176,7 +177,7 @@ static <T> Arbitrary<List<T>> list(Arbitrary<T> arbitraryT) {
      * </pre>
      *
      * @param arbitraryT Arbitrary elements of type T
-     * @param <T> Component type of the Stream
+     * @param <T>        Component type of the Stream
      * @return a new Arbitrary of Stream&lt;T&gt;
      */
     static <T> Arbitrary<Stream<T>> stream(Arbitrary<T> arbitraryT) {

File: src/main/java/javaslang/test/CheckResult.java
Patch:
@@ -354,8 +354,8 @@ && deepEquals(this.error, that.error)
         boolean deepEquals(Throwable t1, Throwable t2) {
             return (t1 == null && t2 == null) || (
                     t1 != null && t2 != null
-                    && Objects.equals(t1.getMessage(), t2.getMessage())
-                    && deepEquals(t1.getCause(), t2.getCause())
+                            && Objects.equals(t1.getMessage(), t2.getMessage())
+                            && deepEquals(t1.getCause(), t2.getCause())
             );
         }
 

File: src/main/java/javaslang/test/CheckResultAssertions.java
Patch:
@@ -9,6 +9,7 @@
 
 /**
  * Assertions targerting on unit tests.
+ *
  * @since 1.2.0
  */
 public interface CheckResultAssertions {

File: src/main/java/javaslang/test/Checkable.java
Patch:
@@ -11,6 +11,7 @@
 
 /**
  * Interface for checkable properties, allowing composition via {@linkplain #and(Checkable)} and {@linkplain #or(Checkable)}.
+ *
  * @since 1.2.0
  */
 @FunctionalInterface

File: src/test/java/javaslang/LazyTest.java
Patch:
@@ -5,12 +5,12 @@
  */
 package javaslang;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 import org.junit.Test;
 
 import java.util.Objects;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 public class LazyTest {
 
     @Test

File: src/test/java/javaslang/collection/RoseTreeTest.java
Patch:
@@ -5,14 +5,14 @@
  */
 package javaslang.collection;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 import javaslang.Serializables;
 import javaslang.Tuple;
 import org.junit.Test;
 
 import java.io.InvalidObjectException;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 public class RoseTreeTest extends AbstractTreeTest {
 
     final RoseTree<Integer> tree = RoseTree.branch(1, RoseTree.branch(2, RoseTree.branch(4, RoseTree.leaf(7)), RoseTree.leaf(5)), RoseTree.branch(3, RoseTree.branch(6, RoseTree.leaf(8), RoseTree.leaf(9))));

File: src/test/java/javaslang/collection/StreamTest.java
Patch:
@@ -425,7 +425,7 @@ static class OneElement extends InputStream {
 
         @Override
         public int read() throws IOException {
-            if (count-->-1) {
+            if (count-- > -1) {
                 return '\n';
             } else {
                 throw new IOException("end of stream");

File: src/test/java/javaslang/test/CheckResultTest.java
Patch:
@@ -5,15 +5,15 @@
  */
 package javaslang.test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 import javaslang.Tuple;
 import javaslang.control.None;
 import javaslang.control.Option;
 import org.junit.Test;
 
 import java.util.Objects;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 public class CheckResultTest {
 
     static final CheckResult.Satisfied SATISFIED = new CheckResult.Satisfied("test", 0, false);

File: src/test/java/javaslang/test/GenTest.java
Patch:
@@ -32,6 +32,7 @@ public void shouldUseCustomRandomNumberGenerator() {
         @SuppressWarnings("SerializableInnerClassWithNonSerializableOuterClass")
         final Random rng = new Random() {
             private static final long serialVersionUID = 1L;
+
             public int nextInt(int bound) {
                 return 0;
             }

File: src/main/java/javaslang/Lazy.java
Patch:
@@ -21,6 +21,7 @@
  * lazyDouble.get() // returns the memoized value, e.g. 0.123
  * </code>
  * </pre>
+ *
  * @since 1.3.0
  */
 public final class Lazy<T> implements Supplier<T>, ValueObject {
@@ -39,7 +40,7 @@ private Lazy(Supplier<T> supplier) {
     /**
      * Creates a Lazy, because it is easier to write {@code Lazy.of(xxx)} than {@code new Lazy<>(xxx)}.
      *
-     * @param <T> type of the lazy value
+     * @param <T>      type of the lazy value
      * @param supplier A supplier
      * @return A new instance of Lazy
      */

File: src/main/java/javaslang/ValueObject.java
Patch:
@@ -25,6 +25,7 @@
  * "[...] , it doesnt make sense for immutable classes to support object copying, because copies would be virtually indistinguishable from the original."
  * </blockquote>
  * <em>(see Effective Java, 2nd ed., p. 61)</em>.
+ *
  * @since 1.1.0
  */
 public interface ValueObject extends Serializable {

File: src/main/java/javaslang/control/Failure.java
Patch:
@@ -11,7 +11,6 @@
 import java.util.Objects;
 import java.util.Optional;
 import java.util.function.Consumer;
-import java.util.function.Predicate;
 
 /**
  * A failed Try.

File: src/main/java/javaslang/control/None.java
Patch:
@@ -8,7 +8,6 @@
 import javaslang.Function1;
 import javaslang.Tuple;
 import javaslang.Tuple0;
-import javaslang.algebra.Monad1;
 
 import java.util.NoSuchElementException;
 import java.util.Objects;

File: src/main/java/javaslang/control/Success.java
Patch:
@@ -15,7 +15,6 @@
 import java.util.Objects;
 import java.util.Optional;
 import java.util.function.Consumer;
-import java.util.function.Predicate;
 
 /**
  * A succeeded Try.

File: src/main/java/javaslang/control/Valences.java
Patch:
@@ -13,6 +13,7 @@
 
 /**
  * This class is not intended to be extended nor it is intended to be public API.
+ *
  * @since 1.1.0
  */
 final class Valences {

File: src/main/java/javaslang/control/package-info.java
Patch:
@@ -11,7 +11,7 @@
  * If a Right is projected to a Left, the Left control operations have no effect on the Right value.
  * If a Left is projected to a Right, the Right control operations have no effect on the Left value.
  * </p>
- * 
+ *
  * <strong>Option</strong>
  * <p>
  * The Option control is a replacement for {@linkplain java.util.Optional}. An Option is either
@@ -20,7 +20,7 @@
  * However, {@code Option.of(null)} results in None.
  * See also <a href="http://blog.rocketscience.io/your-codebase-looks-like-this/">3 ways to deal with null</a>.
  * </p>
- * 
+ *
  * <strong>Try</strong>
  * <p>
  * Exceptions are handled with the {@linkplain javaslang.control.Try} control which is either a

File: src/main/java/javaslang/test/Arbitrary.java
Patch:
@@ -107,6 +107,7 @@ default Arbitrary<T> filter(Predicate<T> predicate) {
 
     /**
      * <p>Generates arbitrary integer values.</p>
+     *
      * @return A new Arbitrary of Integer
      */
     static Arbitrary<Integer> integer() {
@@ -149,7 +150,7 @@ static Arbitrary<String> string(Gen<Character> gen) {
      * </pre>
      *
      * @param arbitraryT Arbitrary elements of type T
-     * @param <T> Component type of the List
+     * @param <T>        Component type of the List
      * @return a new Arbitrary of List&lt;T&gt;
      */
     static <T> Arbitrary<List<T>> list(Arbitrary<T> arbitraryT) {
@@ -176,7 +177,7 @@ static <T> Arbitrary<List<T>> list(Arbitrary<T> arbitraryT) {
      * </pre>
      *
      * @param arbitraryT Arbitrary elements of type T
-     * @param <T> Component type of the Stream
+     * @param <T>        Component type of the Stream
      * @return a new Arbitrary of Stream&lt;T&gt;
      */
     static <T> Arbitrary<Stream<T>> stream(Arbitrary<T> arbitraryT) {

File: src/main/java/javaslang/test/CheckResult.java
Patch:
@@ -354,8 +354,8 @@ && deepEquals(this.error, that.error)
         boolean deepEquals(Throwable t1, Throwable t2) {
             return (t1 == null && t2 == null) || (
                     t1 != null && t2 != null
-                    && Objects.equals(t1.getMessage(), t2.getMessage())
-                    && deepEquals(t1.getCause(), t2.getCause())
+                            && Objects.equals(t1.getMessage(), t2.getMessage())
+                            && deepEquals(t1.getCause(), t2.getCause())
             );
         }
 

File: src/main/java/javaslang/test/CheckResultAssertions.java
Patch:
@@ -9,6 +9,7 @@
 
 /**
  * Assertions targerting on unit tests.
+ *
  * @since 1.2.0
  */
 public interface CheckResultAssertions {

File: src/main/java/javaslang/test/Checkable.java
Patch:
@@ -11,6 +11,7 @@
 
 /**
  * Interface for checkable properties, allowing composition via {@linkplain #and(Checkable)} and {@linkplain #or(Checkable)}.
+ *
  * @since 1.2.0
  */
 @FunctionalInterface

File: src/test/java/javaslang/LazyTest.java
Patch:
@@ -5,12 +5,12 @@
  */
 package javaslang;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 import org.junit.Test;
 
 import java.util.Objects;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 public class LazyTest {
 
     @Test

File: src/test/java/javaslang/collection/RoseTreeTest.java
Patch:
@@ -5,14 +5,14 @@
  */
 package javaslang.collection;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 import javaslang.Serializables;
 import javaslang.Tuple;
 import org.junit.Test;
 
 import java.io.InvalidObjectException;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 public class RoseTreeTest extends AbstractTreeTest {
 
     final RoseTree<Integer> tree = RoseTree.branch(1, RoseTree.branch(2, RoseTree.branch(4, RoseTree.leaf(7)), RoseTree.leaf(5)), RoseTree.branch(3, RoseTree.branch(6, RoseTree.leaf(8), RoseTree.leaf(9))));

File: src/test/java/javaslang/collection/StreamTest.java
Patch:
@@ -425,7 +425,7 @@ static class OneElement extends InputStream {
 
         @Override
         public int read() throws IOException {
-            if (count-->-1) {
+            if (count-- > -1) {
                 return '\n';
             } else {
                 throw new IOException("end of stream");

File: src/test/java/javaslang/test/CheckResultTest.java
Patch:
@@ -5,15 +5,15 @@
  */
 package javaslang.test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 import javaslang.Tuple;
 import javaslang.control.None;
 import javaslang.control.Option;
 import org.junit.Test;
 
 import java.util.Objects;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 public class CheckResultTest {
 
     static final CheckResult.Satisfied SATISFIED = new CheckResult.Satisfied("test", 0, false);

File: src/test/java/javaslang/test/GenTest.java
Patch:
@@ -32,6 +32,7 @@ public void shouldUseCustomRandomNumberGenerator() {
         @SuppressWarnings("SerializableInnerClassWithNonSerializableOuterClass")
         final Random rng = new Random() {
             private static final long serialVersionUID = 1L;
+
             public int nextInt(int bound) {
                 return 0;
             }

File: src/test/java/javaslang/TypeConsistencyTest.java
Patch:
@@ -28,12 +28,14 @@ public class TypeConsistencyTest {
             "javaslang.control.Failure//public abstract javaslang.control.Try javaslang.control.Try.recover(javaslang.CheckedFunction1)",
             "javaslang.control.Failure//public abstract javaslang.control.Try javaslang.control.Try.recoverWith(javaslang.CheckedFunction1)",
             "javaslang.control.Failure//public abstract javaslang.control.Try javaslang.control.Try.failed()",
+            "javaslang.control.Failure//public default javaslang.control.Try javaslang.control.Try.andThen(javaslang.control.Try$CheckedRunnable)",
 
             // control.Success
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.filter(javaslang.control.Try$CheckedPredicate)",
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.map(javaslang.Function1)",
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.flatMap(javaslang.Function1)",
             "javaslang.control.Success//public abstract javaslang.control.Try javaslang.control.Try.failed()",
+            "javaslang.control.Success//public default javaslang.control.Try javaslang.control.Try.andThen(javaslang.control.Try$CheckedRunnable)",
 
             // control.None
             "javaslang.control.None//public default javaslang.control.Option javaslang.control.Option.filter(java.util.function.Predicate)",

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -8,6 +8,7 @@
 import javaslang.*;
 import javaslang.algebra.HigherKinded1;
 import javaslang.algebra.Monad1;
+import javaslang.Lazy;
 import javaslang.control.Match;
 import javaslang.control.Try;
 
@@ -173,7 +174,7 @@ static Stream<String> lines(InputStream in, Charset charset) {
 
             @Override
             public boolean hasNext() {
-                final boolean hasNext = (next = Try.<String>of(reader::readLine).orElse(null)) != null;
+                final boolean hasNext = (next = Try.of(reader::readLine).orElse(null)) != null;
                 if (!hasNext) {
                     Try.run(reader::close);
                 }

File: src/main/java/javaslang/control/Some.java
Patch:
@@ -18,6 +18,7 @@
  * {@link Option#of(Object)} is sufficient.
  *
  * @param <T> The type of the optional value.
+ * @since 1.0.0
  */
 public final class Some<T> implements Option<T> {
 

File: src-gen/main/java/javaslang/algebra/Monad1.java
Patch:
@@ -30,4 +30,5 @@ public interface Monad1<T1, M extends HigherKinded1<?, M>> extends Functor1<T1>,
 
     @Override
     <U1> Monad1<U1, M> map(Function1<? super T1, ? extends U1> f);
+
 }
\ No newline at end of file

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -112,7 +112,7 @@ default Iterator<T> iterator(int index) {
      * @param n An index.
      * @return A Tuple containing the first n and the remaining elements.
      */
-    Tuple2<? extends Traversable<T>, ? extends Traversable<T>> splitAt(int n);
+    Tuple2<? extends Seq<T>, ? extends Seq<T>> splitAt(int n);
 
     Seq<T> subsequence(int beginIndex);
 

File: src-gen/main/java/javaslang/CheckedFunction0.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction1.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction10.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction11.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction12.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction13.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction14.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction15.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction16.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction17.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction18.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction19.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction2.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction20.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction21.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction22.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction23.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction24.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction25.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction26.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction3.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction4.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction5.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction6.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction7.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction8.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/CheckedFunction9.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function0.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function1.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function10.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function11.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function12.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function13.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function14.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function15.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function16.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function17.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function18.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function19.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function2.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function20.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function21.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function22.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function23.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function24.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function25.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function26.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function3.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function4.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function5.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function6.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function7.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function8.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Function9.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple0.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple1.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple10.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple11.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple12.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple13.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple14.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple15.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple16.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple17.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple18.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple19.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple2.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple20.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple21.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple22.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple23.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple24.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple25.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple26.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple3.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple4.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple5.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple6.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple7.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple8.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/Tuple9.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor1.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor10.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor11.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor12.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor13.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor14.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor15.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor16.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor17.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor18.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor19.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor2.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor20.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor21.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor22.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor23.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor24.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor25.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor26.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor3.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor4.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor5.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor6.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor7.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor8.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Functor9.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded1.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded10.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded11.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded12.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded13.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded14.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded15.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded16.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded17.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded18.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded19.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded2.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded20.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded21.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded22.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded23.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded24.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded25.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded26.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded3.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded4.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded5.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded6.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded7.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded8.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/HigherKinded9.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad1.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad10.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad11.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad12.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad13.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad14.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad15.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad16.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad17.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad18.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad19.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad2.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad20.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad21.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad22.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad23.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad24.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad25.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad26.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad3.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad4.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad5.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad6.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad7.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad8.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/algebra/Monad9.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/main/java/javaslang/test/Property.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction0Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction10Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction11Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction12Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction13Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction14Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction15Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction16Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction17Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction18Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction19Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction1Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction20Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction21Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction22Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction23Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction24Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction25Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction26Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction2Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction3Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction4Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction5Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction6Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction7Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction8Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/CheckedFunction9Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function0Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function10Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function11Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function12Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function13Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function14Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function15Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function16Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function17Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function18Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function19Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function1Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function20Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function21Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function22Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function23Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function24Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function25Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function26Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function2Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function3Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function4Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function5Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function6Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function7Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function8Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Function9Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple10Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple11Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple12Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple13Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple14Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple15Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple16Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple17Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple18Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple19Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple1Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple20Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple21Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple22Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple23Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple24Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple25Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple26Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple2Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple3Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple4Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple5Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple6Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple7Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple8Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/Tuple9Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor10Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor11Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor12Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor13Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor14Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor15Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor16Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor17Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor18Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor19Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor20Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor21Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor22Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor23Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor24Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor25Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor26Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor2Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor3Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor4Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor5Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor6Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor7Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor8Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/algebra/Functor9Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck10Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck11Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck12Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck13Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck14Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck15Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck16Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck17Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck18Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck19Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck1Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck20Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck21Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck22Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck23Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck24Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck25Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck26Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck2Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck3Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck4Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck5Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck6Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck7Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck8Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyCheck9Test.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src-gen/test/java/javaslang/test/PropertyTest.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src/main/java/javaslang/ValueObject.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src/main/java/javaslang/algebra/Monoid.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src/main/java/javaslang/algebra/Semigroup.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src/main/java/javaslang/collection/BinaryTree.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src/main/java/javaslang/collection/Lazy.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -1,4 +1,4 @@
-/**    / \____  _    ______   _____ / \____   ____  _____
+/*     / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0

File: src/test/java/javaslang/collection/ListTest.java
Patch:
@@ -146,7 +146,7 @@ public void shouldComputeCombinationsOfEmptyList() {
 
     @Test
     public void shouldComputeCombinationsOfNonEmptyList() {
-        assertThat(List.of(1, 2, 3).combinations(2)).isEqualTo(List.of(List.of(1, 3), List.of(1, 2), List.of(2, 3)));
+        assertThat(List.of(1, 2, 3).combinations(2)).isEqualTo(List.of(List.of(1, 2), List.of(1, 3), List.of(2, 3)));
     }
 
     @Test

File: src/test/java/javaslang/collection/StreamTest.java
Patch:
@@ -275,7 +275,7 @@ public void shouldCreateStreamOfUntilWhereFromEqualsToEqualsInteger_MIN_VALUE()
     // -- combinations
 
     @Test
-    public void shouldComputeCombinationsOfEmptyList() {
+    public void shouldComputeCombinationsOfEmptyStream() {
         assertThat(Stream.nil().combinations(1)).isEqualTo(Stream.nil());
     }
 

File: src-gen/main/java/javaslang/algebra/Monad1.java
Patch:
@@ -27,4 +27,7 @@
 public interface Monad1<T1, M extends HigherKinded1<?, M>> extends Functor1<T1>, HigherKinded1<T1, M> {
 
     <U1, MONAD extends HigherKinded1<U1, M>> Monad1<U1, M> flatMap(Function<? super T1, MONAD> f);
+
+    @Override
+    <U1> Monad1<U1, M> map(Function<? super T1, ? extends U1> f);
 }
\ No newline at end of file

File: src/main/java/javaslang/collection/BinaryTree.java
Patch:
@@ -430,7 +430,9 @@ public int hashCode() {
             if (isEmpty()) {
                 return 1;
             } else {
-                return getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
+                // need cast because of jdk 1.8.0_25/_31 compiler bug
+                //noinspection RedundantCast
+                return (int) getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
             }
         }
 

File: src/main/java/javaslang/collection/RoseTree.java
Patch:
@@ -336,7 +336,7 @@ public int hashCode() {
             if (isEmpty()) {
                 return 1;
             } else {
-                // need cast because of jdk 1.8.0_25 compiler error
+                // need cast because of jdk 1.8.0_25/_31 compiler bug
                 //noinspection RedundantCast
                 return (int) getChildren().map(Objects::hashCode).foldLeft(31 + Objects.hashCode(getValue()), (i, j) -> i * 31 + j);
             }

File: src/main/java/javaslang/control/Try.java
Patch:
@@ -9,9 +9,9 @@
 import javaslang.algebra.HigherKinded1;
 import javaslang.algebra.Monad1;
 import javaslang.control.Valences.Bivalent;
+
 import javax.lang.CheckedRunnable;
 import javax.util.function.CheckedSupplier;
-
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Predicate;

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -177,7 +177,7 @@ List<List<T>> combinations(List<T> elements, int k) {
                                 combinations(elements.drop(t._2 + 1), (k - 1)).map(c -> c.prepend(t._1)));
             }
         }
-        return new Recursion().combinations(this, k);
+        return new Recursion().combinations(this, Math.max(k, 0));
     }
 
     @Override

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -341,7 +341,7 @@ Stream<Stream<T>> combinations(Stream<T> elements, int k) {
                                 combinations(elements.drop(t._2 + 1), (k - 1)).map(c -> c.prepend(t._1)));
             }
         }
-        return new Recursion().combinations(this, k);
+        return new Recursion().combinations(this, Math.max(k, 0));
     }
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction0.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction0<R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction0<R> reversed() {
         return () -> apply();
     }
 
-    @Override
-    default <V> CheckedFunction0<V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction0<V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return () -> after.apply(apply());
     }

File: src-gen/main/java/javaslang/CheckedFunction10.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction10<T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R> reversed()
         return (t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10);
     }
 
-    @Override
-    default <V> CheckedFunction10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10));
     }

File: src-gen/main/java/javaslang/CheckedFunction11.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction11<T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R> rever
         return (t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11);
     }
 
-    @Override
-    default <V> CheckedFunction11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11));
     }

File: src-gen/main/java/javaslang/CheckedFunction12.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction12<T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R>
         return (t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12);
     }
 
-    @Override
-    default <V> CheckedFunction12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12));
     }

File: src-gen/main/java/javaslang/CheckedFunction13.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction13<T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1
         return (t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13);
     }
 
-    @Override
-    default <V> CheckedFunction13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13));
     }

File: src-gen/main/java/javaslang/CheckedFunction14.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction14<T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T
         return (t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14);
     }
 
-    @Override
-    default <V> CheckedFunction14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14));
     }

File: src-gen/main/java/javaslang/CheckedFunction15.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction15<T15, T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T4,
         return (t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15);
     }
 
-    @Override
-    default <V> CheckedFunction15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15));
     }

File: src-gen/main/java/javaslang/CheckedFunction16.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction16<T16, T15, T14, T13, T12, T11, T10, T9, T8, T7, T6, T5,
         return (t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16);
     }
 
-    @Override
-    default <V> CheckedFunction16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16));
     }

File: src-gen/main/java/javaslang/CheckedFunction17.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction17<T17, T16, T15, T14, T13, T12, T11, T10, T9, T8, T7, T6
         return (t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17);
     }
 
-    @Override
-    default <V> CheckedFunction17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17));
     }

File: src-gen/main/java/javaslang/CheckedFunction18.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction18<T18, T17, T16, T15, T14, T13, T12, T11, T10, T9, T8, T
         return (t18, t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18);
     }
 
-    @Override
-    default <V> CheckedFunction18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18));
     }

File: src-gen/main/java/javaslang/CheckedFunction19.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction19<T19, T18, T17, T16, T15, T14, T13, T12, T11, T10, T9,
         return (t19, t18, t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19);
     }
 
-    @Override
-    default <V> CheckedFunction19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19));
     }

File: src-gen/main/java/javaslang/CheckedFunction2.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction2<T1, T2, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction2<T2, T1, R> reversed() {
         return (t2, t1) -> apply(t1, t2);
     }
 
-    @Override
-    default <V> CheckedFunction2<T1, T2, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction2<T1, T2, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2) -> after.apply(apply(t1, t2));
     }

File: src-gen/main/java/javaslang/CheckedFunction20.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction20<T20, T19, T18, T17, T16, T15, T14, T13, T12, T11, T10,
         return (t20, t19, t18, t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20);
     }
 
-    @Override
-    default <V> CheckedFunction20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20));
     }

File: src-gen/main/java/javaslang/CheckedFunction21.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction21<T21, T20, T19, T18, T17, T16, T15, T14, T13, T12, T11,
         return (t21, t20, t19, t18, t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21);
     }
 
-    @Override
-    default <V> CheckedFunction21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21));
     }

File: src-gen/main/java/javaslang/CheckedFunction22.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction22<T22, T21, T20, T19, T18, T17, T16, T15, T14, T13, T12,
         return (t22, t21, t20, t19, t18, t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22);
     }
 
-    @Override
-    default <V> CheckedFunction22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22));
     }

File: src-gen/main/java/javaslang/CheckedFunction23.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction23<T23, T22, T21, T20, T19, T18, T17, T16, T15, T14, T13,
         return (t23, t22, t21, t20, t19, t18, t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23);
     }
 
-    @Override
-    default <V> CheckedFunction23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23));
     }

File: src-gen/main/java/javaslang/CheckedFunction24.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction24<T24, T23, T22, T21, T20, T19, T18, T17, T16, T15, T14,
         return (t24, t23, t22, t21, t20, t19, t18, t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24);
     }
 
-    @Override
-    default <V> CheckedFunction24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24));
     }

File: src-gen/main/java/javaslang/CheckedFunction25.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction25<T25, T24, T23, T22, T21, T20, T19, T18, T17, T16, T15,
         return (t25, t24, t23, t22, t21, t20, t19, t18, t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25);
     }
 
-    @Override
-    default <V> CheckedFunction25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25));
     }

File: src-gen/main/java/javaslang/CheckedFunction26.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction26<T26, T25, T24, T23, T22, T21, T20, T19, T18, T17, T16,
         return (t26, t25, t24, t23, t22, t21, t20, t19, t18, t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26);
     }
 
-    @Override
-    default <V> CheckedFunction26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26));
     }

File: src-gen/main/java/javaslang/CheckedFunction3.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction3<T1, T2, T3, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction3<T3, T2, T1, R> reversed() {
         return (t3, t2, t1) -> apply(t1, t2, t3);
     }
 
-    @Override
-    default <V> CheckedFunction3<T1, T2, T3, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction3<T1, T2, T3, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3) -> after.apply(apply(t1, t2, t3));
     }

File: src-gen/main/java/javaslang/CheckedFunction4.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction4<T1, T2, T3, T4, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction4<T4, T3, T2, T1, R> reversed() {
         return (t4, t3, t2, t1) -> apply(t1, t2, t3, t4);
     }
 
-    @Override
-    default <V> CheckedFunction4<T1, T2, T3, T4, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction4<T1, T2, T3, T4, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4) -> after.apply(apply(t1, t2, t3, t4));
     }

File: src-gen/main/java/javaslang/CheckedFunction5.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction5<T1, T2, T3, T4, T5, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction5<T5, T4, T3, T2, T1, R> reversed() {
         return (t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5);
     }
 
-    @Override
-    default <V> CheckedFunction5<T1, T2, T3, T4, T5, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction5<T1, T2, T3, T4, T5, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5) -> after.apply(apply(t1, t2, t3, t4, t5));
     }

File: src-gen/main/java/javaslang/CheckedFunction6.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction6<T1, T2, T3, T4, T5, T6, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction6<T6, T5, T4, T3, T2, T1, R> reversed() {
         return (t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6);
     }
 
-    @Override
-    default <V> CheckedFunction6<T1, T2, T3, T4, T5, T6, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction6<T1, T2, T3, T4, T5, T6, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6) -> after.apply(apply(t1, t2, t3, t4, t5, t6));
     }

File: src-gen/main/java/javaslang/CheckedFunction7.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction7<T1, T2, T3, T4, T5, T6, T7, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction7<T7, T6, T5, T4, T3, T2, T1, R> reversed() {
         return (t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7);
     }
 
-    @Override
-    default <V> CheckedFunction7<T1, T2, T3, T4, T5, T6, T7, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction7<T1, T2, T3, T4, T5, T6, T7, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7));
     }

File: src-gen/main/java/javaslang/CheckedFunction8.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction8<T1, T2, T3, T4, T5, T6, T7, T8, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction8<T8, T7, T6, T5, T4, T3, T2, T1, R> reversed() {
         return (t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8);
     }
 
-    @Override
-    default <V> CheckedFunction8<T1, T2, T3, T4, T5, T6, T7, T8, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction8<T1, T2, T3, T4, T5, T6, T7, T8, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8));
     }

File: src-gen/main/java/javaslang/CheckedFunction9.java
Patch:
@@ -10,7 +10,6 @@
 \*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
-import java.util.function.Function;
 
 @FunctionalInterface
 public interface CheckedFunction9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> extends <R> {
@@ -39,8 +38,7 @@ default CheckedFunction9<T9, T8, T7, T6, T5, T4, T3, T2, T1, R> reversed() {
         return (t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9);
     }
 
-    @Override
-    default <V> CheckedFunction9<T1, T2, T3, T4, T5, T6, T7, T8, T9, V> andThen(Function<? super R, ? extends V> after) {
+    default <V> CheckedFunction9<T1, T2, T3, T4, T5, T6, T7, T8, T9, V> andThen(CheckedFunction1<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9));
     }

File: src-gen/main/java/javaslang/Function0.java
Patch:
@@ -45,7 +45,6 @@ default Function0<R> reversed() {
         return () -> apply();
     }
 
-    @Override
     default <V> Function0<V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return () -> after.apply(apply());

File: src-gen/main/java/javaslang/Function1.java
Patch:
@@ -44,7 +44,6 @@ default Function1<T1, R> reversed() {
         return (t1) -> apply(t1);
     }
 
-    @Override
     default <V> Function1<T1, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1) -> after.apply(apply(t1));

File: src-gen/main/java/javaslang/Function10.java
Patch:
@@ -39,7 +39,6 @@ default Function10<T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R> reversed() {
         return (t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10);
     }
 
-    @Override
     default <V> Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10));

File: src-gen/main/java/javaslang/Function11.java
Patch:
@@ -39,7 +39,6 @@ default Function11<T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R> reversed() {
         return (t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11);
     }
 
-    @Override
     default <V> Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11));

File: src-gen/main/java/javaslang/Function12.java
Patch:
@@ -39,7 +39,6 @@ default Function12<T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R> reverse
         return (t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12);
     }
 
-    @Override
     default <V> Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12));

File: src-gen/main/java/javaslang/Function13.java
Patch:
@@ -39,7 +39,6 @@ default Function13<T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, R> re
         return (t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13);
     }
 
-    @Override
     default <V> Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13));

File: src-gen/main/java/javaslang/Function14.java
Patch:
@@ -39,7 +39,6 @@ default Function14<T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1,
         return (t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14);
     }
 
-    @Override
     default <V> Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14));

File: src-gen/main/java/javaslang/Function15.java
Patch:
@@ -39,7 +39,6 @@ default Function15<T15, T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2,
         return (t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15);
     }
 
-    @Override
     default <V> Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15));

File: src-gen/main/java/javaslang/Function16.java
Patch:
@@ -39,7 +39,6 @@ default Function16<T16, T15, T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3
         return (t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16);
     }
 
-    @Override
     default <V> Function16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16));

File: src-gen/main/java/javaslang/Function17.java
Patch:
@@ -39,7 +39,6 @@ default Function17<T17, T16, T15, T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T
         return (t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17);
     }
 
-    @Override
     default <V> Function17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17));

File: src-gen/main/java/javaslang/Function18.java
Patch:
@@ -39,7 +39,6 @@ default Function18<T18, T17, T16, T15, T14, T13, T12, T11, T10, T9, T8, T7, T6,
         return (t18, t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18);
     }
 
-    @Override
     default <V> Function18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18));

File: src-gen/main/java/javaslang/Function19.java
Patch:
@@ -39,7 +39,6 @@ default Function19<T19, T18, T17, T16, T15, T14, T13, T12, T11, T10, T9, T8, T7,
         return (t19, t18, t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19);
     }
 
-    @Override
     default <V> Function19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19));

File: src-gen/main/java/javaslang/Function2.java
Patch:
@@ -41,7 +41,6 @@ default Function2<T2, T1, R> reversed() {
         return (t2, t1) -> apply(t1, t2);
     }
 
-    @Override
     default <V> Function2<T1, T2, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2) -> after.apply(apply(t1, t2));

File: src-gen/main/java/javaslang/Function20.java
Patch:
@@ -39,7 +39,6 @@ default Function20<T20, T19, T18, T17, T16, T15, T14, T13, T12, T11, T10, T9, T8
         return (t20, t19, t18, t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20);
     }
 
-    @Override
     default <V> Function20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20));

File: src-gen/main/java/javaslang/Function21.java
Patch:
@@ -39,7 +39,6 @@ default Function21<T21, T20, T19, T18, T17, T16, T15, T14, T13, T12, T11, T10, T
         return (t21, t20, t19, t18, t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21);
     }
 
-    @Override
     default <V> Function21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21));

File: src-gen/main/java/javaslang/Function22.java
Patch:
@@ -39,7 +39,6 @@ default Function22<T22, T21, T20, T19, T18, T17, T16, T15, T14, T13, T12, T11, T
         return (t22, t21, t20, t19, t18, t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22);
     }
 
-    @Override
     default <V> Function22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22));

File: src-gen/main/java/javaslang/Function23.java
Patch:
@@ -39,7 +39,6 @@ default Function23<T23, T22, T21, T20, T19, T18, T17, T16, T15, T14, T13, T12, T
         return (t23, t22, t21, t20, t19, t18, t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23);
     }
 
-    @Override
     default <V> Function23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23));

File: src-gen/main/java/javaslang/Function24.java
Patch:
@@ -39,7 +39,6 @@ default Function24<T24, T23, T22, T21, T20, T19, T18, T17, T16, T15, T14, T13, T
         return (t24, t23, t22, t21, t20, t19, t18, t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24);
     }
 
-    @Override
     default <V> Function24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24));

File: src-gen/main/java/javaslang/Function25.java
Patch:
@@ -39,7 +39,6 @@ default Function25<T25, T24, T23, T22, T21, T20, T19, T18, T17, T16, T15, T14, T
         return (t25, t24, t23, t22, t21, t20, t19, t18, t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25);
     }
 
-    @Override
     default <V> Function25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25));

File: src-gen/main/java/javaslang/Function26.java
Patch:
@@ -39,7 +39,6 @@ default Function26<T26, T25, T24, T23, T22, T21, T20, T19, T18, T17, T16, T15, T
         return (t26, t25, t24, t23, t22, t21, t20, t19, t18, t17, t16, t15, t14, t13, t12, t11, t10, t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26);
     }
 
-    @Override
     default <V> Function26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26));

File: src-gen/main/java/javaslang/Function3.java
Patch:
@@ -39,7 +39,6 @@ default Function3<T3, T2, T1, R> reversed() {
         return (t3, t2, t1) -> apply(t1, t2, t3);
     }
 
-    @Override
     default <V> Function3<T1, T2, T3, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3) -> after.apply(apply(t1, t2, t3));

File: src-gen/main/java/javaslang/Function4.java
Patch:
@@ -39,7 +39,6 @@ default Function4<T4, T3, T2, T1, R> reversed() {
         return (t4, t3, t2, t1) -> apply(t1, t2, t3, t4);
     }
 
-    @Override
     default <V> Function4<T1, T2, T3, T4, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4) -> after.apply(apply(t1, t2, t3, t4));

File: src-gen/main/java/javaslang/Function5.java
Patch:
@@ -39,7 +39,6 @@ default Function5<T5, T4, T3, T2, T1, R> reversed() {
         return (t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5);
     }
 
-    @Override
     default <V> Function5<T1, T2, T3, T4, T5, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5) -> after.apply(apply(t1, t2, t3, t4, t5));

File: src-gen/main/java/javaslang/Function6.java
Patch:
@@ -39,7 +39,6 @@ default Function6<T6, T5, T4, T3, T2, T1, R> reversed() {
         return (t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6);
     }
 
-    @Override
     default <V> Function6<T1, T2, T3, T4, T5, T6, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6) -> after.apply(apply(t1, t2, t3, t4, t5, t6));

File: src-gen/main/java/javaslang/Function7.java
Patch:
@@ -39,7 +39,6 @@ default Function7<T7, T6, T5, T4, T3, T2, T1, R> reversed() {
         return (t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7);
     }
 
-    @Override
     default <V> Function7<T1, T2, T3, T4, T5, T6, T7, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7));

File: src-gen/main/java/javaslang/Function8.java
Patch:
@@ -39,7 +39,6 @@ default Function8<T8, T7, T6, T5, T4, T3, T2, T1, R> reversed() {
         return (t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8);
     }
 
-    @Override
     default <V> Function8<T1, T2, T3, T4, T5, T6, T7, T8, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8));

File: src-gen/main/java/javaslang/Function9.java
Patch:
@@ -39,7 +39,6 @@ default Function9<T9, T8, T7, T6, T5, T4, T3, T2, T1, R> reversed() {
         return (t9, t8, t7, t6, t5, t4, t3, t2, t1) -> apply(t1, t2, t3, t4, t5, t6, t7, t8, t9);
     }
 
-    @Override
     default <V> Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, V> andThen(Function<? super R, ? extends V> after) {
         Objects.requireNonNull(after);
         return (t1, t2, t3, t4, t5, t6, t7, t8, t9) -> after.apply(apply(t1, t2, t3, t4, t5, t6, t7, t8, t9));

File: src-gen/test/java/javaslang/CheckedFunction0Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction0Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction0<Object> f = () -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction0<Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction10Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction10Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction10<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction10<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction11Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction11Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction11<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction11<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction12Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction12Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction12<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction12<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction13Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction13Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction13<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction13<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction14Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction14Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction14<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction14<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction15Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction15Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction15<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction15<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction16Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction16Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction16<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction16<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction17Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction17Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction17<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction17<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction18Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction18Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction18<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction18<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction19Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction19Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction19<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18, o19) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction19<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction1Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction1Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction1<Object, Object> f = (o1) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction1<Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction20Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction20Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction20<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18, o19, o20) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction20<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction21Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction21Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction21<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18, o19, o20, o21) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction21<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction22Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction22Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction22<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18, o19, o20, o21, o22) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction22<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction23Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction23Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction23<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18, o19, o20, o21, o22, o23) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction23<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction24Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction24Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction24<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18, o19, o20, o21, o22, o23, o24) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction24<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction25Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction25Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction25<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18, o19, o20, o21, o22, o23, o24, o25) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction25<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction26Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction26Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction26<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18, o19, o20, o21, o22, o23, o24, o25, o26) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction26<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction2Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction2Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction2<Object, Object, Object> f = (o1, o2) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction2<Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction3Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction3Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction3<Object, Object, Object, Object> f = (o1, o2, o3) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction3<Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction4Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction4Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction4<Object, Object, Object, Object, Object> f = (o1, o2, o3, o4) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction4<Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction5Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction5Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction5<Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction5<Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction6Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction6Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction6<Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction6<Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction7Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction7Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction7<Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction7<Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction8Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction8Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction8<Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction8<Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/CheckedFunction9Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class CheckedFunction9Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final CheckedFunction9<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9) -> null;
-        final Function<Object, Object> after = o -> null;
+        final CheckedFunction1<Object, Object> after = o -> null;
         final CheckedFunction9<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function0Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function0Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function0<Object> f = () -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function0<Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function10Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function10Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function10<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function10<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function11Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function11Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function11<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function11<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function12Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function12Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function12<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function12<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function13Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function13Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function13<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function13<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function14Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function14Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function14<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function14<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function15Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function15Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function15<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function15<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function16Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function16Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function16<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function16<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function17Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function17Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function17<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function17<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function18Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function18Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function18<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function18<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function19Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function19Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function19<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18, o19) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function19<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function1Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function1Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function1<Object, Object> f = (o1) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function1<Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function20Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function20Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function20<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18, o19, o20) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function20<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function21Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function21Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function21<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18, o19, o20, o21) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function21<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function22Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function22Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function22<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18, o19, o20, o21, o22) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function22<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function23Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function23Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function23<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18, o19, o20, o21, o22, o23) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function23<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function24Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function24Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function24<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18, o19, o20, o21, o22, o23, o24) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function24<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function25Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function25Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function25<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18, o19, o20, o21, o22, o23, o24, o25) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function25<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function26Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function26Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function26<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o17, o18, o19, o20, o21, o22, o23, o24, o25, o26) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function26<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function2Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function2Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function2<Object, Object, Object> f = (o1, o2) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function2<Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function3Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function3Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function3<Object, Object, Object, Object> f = (o1, o2, o3) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function3<Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function4Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function4Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function4<Object, Object, Object, Object, Object> f = (o1, o2, o3, o4) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function4<Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function5Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function5Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function5<Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function5<Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function6Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function6Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function6<Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function6<Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function7Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function7Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function7<Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function7<Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function8Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function8Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function8<Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function8<Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src-gen/test/java/javaslang/Function9Test.java
Patch:
@@ -11,7 +11,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.function.Function;
 import org.junit.Test;
 
 public class Function9Test {
@@ -45,7 +44,7 @@ public void shouldReverse() {
     @Test
     public void shouldComposeWithAndThen() {
         final Function9<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> f = (o1, o2, o3, o4, o5, o6, o7, o8, o9) -> null;
-        final Function<Object, Object> after = o -> null;
+        final Function1<Object, Object> after = o -> null;
         final Function9<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object> composed = f.andThen(after);
         assertThat(composed).isNotNull();
     }

File: src/main/java/javax/util/function/CheckedBiFunction.java
Patch:
@@ -9,7 +9,6 @@
 
 /**
  * Checked version of java.util.function.BiFunction.
- * Essentially the same as {@code CheckedFunction2<T, U, R>}.
  *
  * @param <T> First argument type
  * @param <U> Second argument type

File: src/main/java/javax/util/function/CheckedBinaryOperator.java
Patch:
@@ -7,7 +7,6 @@
 
 /**
  * Checked version of java.util.function.BinaryOperator.
- * Essentially the same as {@code CheckedFunction2<T, T, T>}.
  *
  * @param <T> Operand type
  */

File: src/main/java/javax/util/function/CheckedFunction.java
Patch:
@@ -9,7 +9,6 @@
 
 /**
  * Checked version of java.util.function.Function.
- * Essentially the same as {@code CheckedFunction1<T, R>}.
  *
  * @param <T> Argument type
  * @param <R> Return value type

File: src/main/java/javax/util/function/CheckedUnaryOperator.java
Patch:
@@ -9,7 +9,6 @@
 
 /**
  * Checked version of java.util.function.UnaryOperator.
- * Essentially the same as {@code CheckedFunction1<T, T>}.
  *
  * @param <T> Operand type
  */

File: src/test/java/javax/util/function/CheckedConsumerTest.java
Patch:
@@ -19,7 +19,7 @@ public void shouldChainCheckedConsumersWithAndThen() {
         final CheckedConsumer<Object> cc1 = o -> results[i[0]++] = 1;
         final CheckedConsumer<Object> cc2 = o -> results[i[0]++] = 2;
         try {
-            cc1.andThen(cc2).accept(null);
+            cc1.andThen(cc2).apply(null);
             assertThat(results).isEqualTo(new byte[]{1, 2});
         } catch (Throwable x) {
             fail("Exception occurred", x);

File: src/test/java/javax/util/function/CheckedDoubleUnaryOperatorTest.java
Patch:
@@ -17,7 +17,7 @@ public void shouldComposeTwoCheckedDoubleUnaryOperatorsWithCompose() {
         final CheckedDoubleUnaryOperator cduo1 = d -> d + 1;
         final CheckedDoubleUnaryOperator cduo2 = d -> d * 2;
         try {
-            final double actual = cduo1.compose(cduo2).applyAsDouble(0d);
+            final double actual = cduo1.compose(cduo2).apply(0d);
             assertThat(actual).isEqualTo(1d);
         } catch (Throwable x) {
             fail("Exception occurred", x);
@@ -29,7 +29,7 @@ public void shouldComposeTwoCheckedDoubleUnaryOperatorsWithAndThen() {
         final CheckedDoubleUnaryOperator cduo1 = d -> d + 1;
         final CheckedDoubleUnaryOperator cduo2 = d -> d * 2;
         try {
-            final double actual = cduo1.andThen(cduo2).applyAsDouble(0d);
+            final double actual = cduo1.andThen(cduo2).apply(0d);
             assertThat(actual).isEqualTo(2d);
         } catch (Throwable x) {
             fail("Exception occurred", x);

File: src/test/java/javax/util/function/CheckedIntUnaryOperatorTest.java
Patch:
@@ -17,7 +17,7 @@ public void shouldComposeTwoCheckedIntUnaryOperatorsWithCompose() {
         final CheckedIntUnaryOperator ciuo1 = i -> i + 1;
         final CheckedIntUnaryOperator ciuo2 = i -> i * 2;
         try {
-            final double actual = ciuo1.compose(ciuo2).applyAsInt(0);
+            final double actual = ciuo1.compose(ciuo2).apply(0);
             assertThat(actual).isEqualTo(1);
         } catch (Throwable x) {
             fail("Exception occurred", x);
@@ -29,7 +29,7 @@ public void shouldComposeTwoCheckedIntUnaryOperatorsWithAndThen() {
         final CheckedIntUnaryOperator ciuo1 = i -> i + 1;
         final CheckedIntUnaryOperator ciuo2 = i -> i * 2;
         try {
-            final double actual = ciuo1.andThen(ciuo2).applyAsInt(0);
+            final double actual = ciuo1.andThen(ciuo2).apply(0);
             assertThat(actual).isEqualTo(2);
         } catch (Throwable x) {
             fail("Exception occurred", x);

File: src/test/java/javax/util/function/CheckedLongUnaryOperatorTest.java
Patch:
@@ -17,7 +17,7 @@ public void shouldComposeTwoCheckedLongUnaryOperatorsWithCompose() {
         final CheckedLongUnaryOperator cluo1 = l -> l + 1;
         final CheckedLongUnaryOperator cluo2 = l -> l * 2;
         try {
-            final double actual = cluo1.compose(cluo2).applyAsLong(0L);
+            final double actual = cluo1.compose(cluo2).apply(0L);
             assertThat(actual).isEqualTo(1L);
         } catch (Throwable x) {
             fail("Exception occurred", x);
@@ -29,7 +29,7 @@ public void shouldComposeTwoCheckedLongUnaryOperatorsWithAndThen() {
         final CheckedLongUnaryOperator cluo1 = l -> l + 1;
         final CheckedLongUnaryOperator cluo2 = l -> l * 2;
         try {
-            final double actual = cluo1.andThen(cluo2).applyAsLong(0L);
+            final double actual = cluo1.andThen(cluo2).apply(0L);
             assertThat(actual).isEqualTo(2L);
         } catch (Throwable x) {
             fail("Exception occurred", x);

File: src/main/java/javax/util/function/BooleanFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Unchecked boolean to R function.
- * Essentially the same as {@code Function1<Boolean, R>}, or short {@code 1<Boolean, R>}.
+ * Essentially the same as {@code Function1<Boolean, R>}.
  *
  * @param <R> Return value type
  */

File: src/main/java/javax/util/function/ByteFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Unchecked byte to R function.
- * Essentially the same as {@code Function1<Byte, R>}, or short {@code 1<Byte, R>}.
+ * Essentially the same as {@code Function1<Byte, R>}.
  *
  * @param <R> Return value type
  */

File: src/main/java/javax/util/function/CharFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Unchecked char to R function.
- * Essentially the same as {@code Function1<Character, R>}, or short {@code 1<Character, R>}.
+ * Essentially the same as {@code Function1<Character, R>}.
  *
  * @param <R> Return value type
  */

File: src/main/java/javax/util/function/CheckedBiConsumer.java
Patch:
@@ -10,7 +10,7 @@
 
 /**
  * Checked version of java.util.function.BiConsumer.
- * Essentially the same as {@code CheckedFunction2<T, U, Void>}, or short {@code X2<T, U, Void>}.
+ * Essentially the same as {@code CheckedFunction2<T, U, Void>}.
  *
  * @param <T> First argument type
  * @param <U> Second argument type

File: src/main/java/javax/util/function/CheckedBiFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.BiFunction.
- * Essentially the same as {@code CheckedFunction2<T, U, R>}, or short {@code X2<T, U, R>}.
+ * Essentially the same as {@code CheckedFunction2<T, U, R>}.
  *
  * @param <T> First argument type
  * @param <U> Second argument type

File: src/main/java/javax/util/function/CheckedBiPredicate.java
Patch:
@@ -10,7 +10,7 @@
 
 /**
  * Checked version of java.util.function.BiPredicate.
- * Essentially the same as {@code CheckedFunction2<T, U, Boolean>}, or short {@code X2<T, U, Boolean>}.
+ * Essentially the same as {@code CheckedFunction2<T, U, Boolean>}.
  *
  * @param <T> First argument type
  * @param <U> Second argument type

File: src/main/java/javax/util/function/CheckedBinaryOperator.java
Patch:
@@ -7,7 +7,7 @@
 
 /**
  * Checked version of java.util.function.BinaryOperator.
- * Essentially the same as {@code CheckedFunction2<T, T, T>}, or short {@code X2<T, T, T>}.
+ * Essentially the same as {@code CheckedFunction2<T, T, T>}.
  *
  * @param <T> Operand type
  */

File: src/main/java/javax/util/function/CheckedBooleanFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of BooleanFunction.
- * Essentially the same as {@code CheckedFunction1<Boolean, R>}, or short {@code X1<Boolean, R>}.
+ * Essentially the same as {@code CheckedFunction1<Boolean, R>}.
  *
  * @param <R> Return value type
  */

File: src/main/java/javax/util/function/CheckedBooleanSupplier.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.BooleanSupplier.
- * Essentially the same as {@code CheckedFunction0<Boolean>}, or short {@code X0<Boolean>}.
+ * Essentially the same as {@code CheckedFunction0<Boolean>}.
  */
 @FunctionalInterface
 public interface CheckedBooleanSupplier extends Serializable {

File: src/main/java/javax/util/function/CheckedByteFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of ByteFunction.
- * Essentially the same as {@code CheckedFunction1<Byte, R>}, or short {@code X1<Byte, R>}.
+ * Essentially the same as {@code CheckedFunction1<Byte, R>}.
  *
  * @param <R> Return value type
  */

File: src/main/java/javax/util/function/CheckedCharFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of CharFunction.
- * Essentially the same as {@code CheckedFunction1<Character, R>}, or short {@code X1<Character, R>}.
+ * Essentially the same as {@code CheckedFunction1<Character, R>}.
  *
  * @param <R> Return value type
  */

File: src/main/java/javax/util/function/CheckedConsumer.java
Patch:
@@ -10,7 +10,7 @@
 
 /**
  * Checked version of java.util.function.Consumer.
- * Essentially the same as {@code CheckedFunction1<T, Void>}, or short {@code X1<T, Void>}.
+ * Essentially the same as {@code CheckedFunction1<T, Void>}.
  *
  * @param <T> Argument type
  */

File: src/main/java/javax/util/function/CheckedDoubleBinaryOperator.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.DoubleBinaryOperator.
- * Essentially the same as {@code CheckedFunction2<Double, Double, Double>}, or short {@code X2<Double, Double, Double>}.
+ * Essentially the same as {@code CheckedFunction2<Double, Double, Double>}.
  */
 @FunctionalInterface
 public interface CheckedDoubleBinaryOperator extends Serializable {

File: src/main/java/javax/util/function/CheckedDoubleConsumer.java
Patch:
@@ -10,7 +10,7 @@
 
 /**
  * Checked version of java.util.function.DoubleConsumer.
- * Essentially the same as {@code CheckedFunction1<Double, Void>}, or short {@code X1<Double, Void>}.
+ * Essentially the same as {@code CheckedFunction1<Double, Void>}.
  */
 @FunctionalInterface
 public interface CheckedDoubleConsumer extends Serializable {

File: src/main/java/javax/util/function/CheckedDoubleFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.DoubleFunction.
- * Essentially the same as {@code CheckedFunction1<Double, R>}, or short {@code X1<Double, R>}.
+ * Essentially the same as {@code CheckedFunction1<Double, R>}.
  *
  * @param <R> Return value type
  */

File: src/main/java/javax/util/function/CheckedDoublePredicate.java
Patch:
@@ -10,7 +10,7 @@
 
 /**
  * Checked version of java.util.function.DoublePredicate.
- * Essentially the same as {@code CheckedFunction1<Double, Boolean>}, or short {@code X1<Double, Boolean>}.
+ * Essentially the same as {@code CheckedFunction1<Double, Boolean>}.
  */
 @FunctionalInterface
 public interface CheckedDoublePredicate extends Serializable {

File: src/main/java/javax/util/function/CheckedDoubleSupplier.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.DoubleSupplier.
- * Essentially the same as {@code CheckedFunction0<Double>}, or short {@code X0<Double>}.
+ * Essentially the same as {@code CheckedFunction0<Double>}.
  */
 @FunctionalInterface
 public interface CheckedDoubleSupplier extends Serializable {

File: src/main/java/javax/util/function/CheckedDoubleToIntFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.DoubleToIntFunction.
- * Essentially the same as {@code CheckedFunction1<Double, Integer>}, or short {@code X1<Double, Integer>}.
+ * Essentially the same as {@code CheckedFunction1<Double, Integer>}.
  */
 @FunctionalInterface
 public interface CheckedDoubleToIntFunction extends Serializable {

File: src/main/java/javax/util/function/CheckedDoubleToLongFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.DoubleToLongFunction.
- * Essentially the same as {@code CheckedFunction1<Double, Long>}, or short {@code X1<Double, Long>}.
+ * Essentially the same as {@code CheckedFunction1<Double, Long>}.
  */
 @FunctionalInterface
 public interface CheckedDoubleToLongFunction extends Serializable {

File: src/main/java/javax/util/function/CheckedDoubleUnaryOperator.java
Patch:
@@ -10,7 +10,7 @@
 
 /**
  * Checked version of java.util.function.DoubleUnaryOperator.
- * Essentially the same as {@code CheckedFunction1<Double, Double>}, or short {@code X1<Double, Double>}.
+ * Essentially the same as {@code CheckedFunction1<Double, Double>}.
  */
 @FunctionalInterface
 public interface CheckedDoubleUnaryOperator extends Serializable {

File: src/main/java/javax/util/function/CheckedFloatFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of FloatFunction.
- * Essentially the same as {@code CheckedFunction1<Float, R>}, or short {@code X1<Float, R>}.
+ * Essentially the same as {@code CheckedFunction1<Float, R>}.
  *
  * @param <R> Return value type
  */

File: src/main/java/javax/util/function/CheckedFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.Function.
- * Essentially the same as {@code CheckedFunction1<T, R>}, or short {@code X1<T, R>}.
+ * Essentially the same as {@code CheckedFunction1<T, R>}.
  *
  * @param <T> Argument type
  * @param <R> Return value type

File: src/main/java/javax/util/function/CheckedIntBinaryOperator.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.IntBinaryOperator.
- * Essentially the same as {@code CheckedFunction2<Integer, Integer, Integer>}, or short {@code X2<Integer, Integer, Integer>}.
+ * Essentially the same as {@code CheckedFunction2<Integer, Integer, Integer>}.
  */
 @FunctionalInterface
 public interface CheckedIntBinaryOperator extends Serializable {

File: src/main/java/javax/util/function/CheckedIntConsumer.java
Patch:
@@ -10,7 +10,7 @@
 
 /**
  * Checked version of java.util.function.IntConsumer.
- * Essentially the same as {@code CheckedFunction1<Integer, Void>}, or short {@code X1<Integer, Void>}.
+ * Essentially the same as {@code CheckedFunction1<Integer, Void>}.
  */
 @FunctionalInterface
 public interface CheckedIntConsumer extends Serializable {

File: src/main/java/javax/util/function/CheckedIntFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.IntFunction.
- * Essentially the same as {@code CheckedFunction1<Integer, R>}, or short {@code X1<Integer, R>}.
+ * Essentially the same as {@code CheckedFunction1<Integer, R>}.
  *
  * @param <R> Return value type
  */

File: src/main/java/javax/util/function/CheckedIntPredicate.java
Patch:
@@ -10,7 +10,7 @@
 
 /**
  * Checked version of java.util.function.IntPredicate.
- * Essentially the same as {@code CheckedFunction1<Integer, Boolean>}, or short {@code X1<Integer, Boolean>}.
+ * Essentially the same as {@code CheckedFunction1<Integer, Boolean>}.
  */
 @FunctionalInterface
 public interface CheckedIntPredicate extends Serializable {

File: src/main/java/javax/util/function/CheckedIntSupplier.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.IntSupplier.
- * Essentially the same as {@code CheckedFunction0<Integer>}, or short {@code X0<Integer>}.
+ * Essentially the same as {@code CheckedFunction0<Integer>}.
  */
 @FunctionalInterface
 public interface CheckedIntSupplier extends Serializable {

File: src/main/java/javax/util/function/CheckedIntToDoubleFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.IntToDoubleFunction.
- * Essentially the same as {@code CheckedFunction1<Integer, Double>}, or short {@code X1<Integer, Double>}.
+ * Essentially the same as {@code CheckedFunction1<Integer, Double>}.
  */
 @FunctionalInterface
 public interface CheckedIntToDoubleFunction extends Serializable {

File: src/main/java/javax/util/function/CheckedIntToLongFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.IntToLongFunction.
- * Essentially the same as {@code CheckedFunction1<Integer, Long>}, or short {@code X1<Integer, Long>}.
+ * Essentially the same as {@code CheckedFunction1<Integer, Long>}.
  */
 @FunctionalInterface
 public interface CheckedIntToLongFunction extends Serializable {

File: src/main/java/javax/util/function/CheckedIntUnaryOperator.java
Patch:
@@ -10,7 +10,7 @@
 
 /**
  * Checked version of java.util.function.IntUnaryOperator.
- * Essentially the same as {@code CheckedFunction1<Integer, Integer>}, or short {@code X1<Integer, Integer>}.
+ * Essentially the same as {@code CheckedFunction1<Integer, Integer>}.
  */
 @FunctionalInterface
 public interface CheckedIntUnaryOperator extends Serializable {

File: src/main/java/javax/util/function/CheckedLongBinaryOperator.java
Patch:
@@ -9,10 +9,10 @@
 
 /**
  * Checked version of java.util.function.LongBinaryOperator.
- * Essentially the same as {@code CheckedFunction2<Long, Long, Long>}, or short {@code X2<Long, Long, Long>}.
+ * Essentially the same as {@code CheckedFunction2<Long, Long, Long>}.
  */
 @FunctionalInterface
 public interface CheckedLongBinaryOperator extends Serializable {
 
-    long applyAsInt(long left, long right) throws Throwable;
+    long applyAsLong(long left, long right) throws Throwable;
 }

File: src/main/java/javax/util/function/CheckedLongConsumer.java
Patch:
@@ -10,7 +10,7 @@
 
 /**
  * Checked version of java.util.function.LongConsumer.
- * Essentially the same as {@code CheckedFunction1<Long, Void>}, or short {@code X1<Long, Void>}.
+ * Essentially the same as {@code CheckedFunction1<Long, Void>}.
  */
 @FunctionalInterface
 public interface CheckedLongConsumer extends Serializable {

File: src/main/java/javax/util/function/CheckedLongFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.LongFunction.
- * Essentially the same as {@code CheckedFunction1<Long, R>}, or short {@code X1<Long, R>}.
+ * Essentially the same as {@code CheckedFunction1<Long, R>}.
  *
  * @param <R> Return value type
  */

File: src/main/java/javax/util/function/CheckedLongPredicate.java
Patch:
@@ -10,7 +10,7 @@
 
 /**
  * Checked version of java.util.function.LongPredicate.
- * Essentially the same as {@code CheckedFunction1<Long, Boolean>}, or short {@code X1<Long, Boolean>}.
+ * Essentially the same as {@code CheckedFunction1<Long, Boolean>}.
  */
 @FunctionalInterface
 public interface CheckedLongPredicate extends Serializable {

File: src/main/java/javax/util/function/CheckedLongSupplier.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.LongSupplier.
- * Essentially the same as {@code CheckedFunction0<Long>}, or short {@code X0<Long>}.
+ * Essentially the same as {@code CheckedFunction0<Long>}.
  */
 @FunctionalInterface
 public interface CheckedLongSupplier extends Serializable {

File: src/main/java/javax/util/function/CheckedLongToDoubleFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.LongToDoubleFunction.
- * Essentially the same as {@code CheckedFunction1<Long, Double>}, or short {@code X1<Long, Double>}.
+ * Essentially the same as {@code CheckedFunction1<Long, Double>}.
  */
 @FunctionalInterface
 public interface CheckedLongToDoubleFunction extends Serializable {

File: src/main/java/javax/util/function/CheckedLongToIntFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.LongToIntFunction.
- * Essentially the same as {@code CheckedFunction1<Long, Integer>}, or short {@code X1<Long, Integer>}.
+ * Essentially the same as {@code CheckedFunction1<Long, Integer>}.
  */
 @FunctionalInterface
 public interface CheckedLongToIntFunction extends Serializable {

File: src/main/java/javax/util/function/CheckedLongUnaryOperator.java
Patch:
@@ -10,7 +10,7 @@
 
 /**
  * Checked version of java.util.function.LongUnaryOperator.
- * Essentially the same as {@code CheckedFunction1<Long, Long>}, or short {@code X1<Long, Long>}.
+ * Essentially the same as {@code CheckedFunction1<Long, Long>}.
  */
 @FunctionalInterface
 public interface CheckedLongUnaryOperator extends Serializable {

File: src/main/java/javax/util/function/CheckedObjDoubleConsumer.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.ObjDoubleConsumer.
- * Essentially the same as {@code CheckedFunction2<T, Double, Void>}, or short {@code X2<T, Double, Void>}.
+ * Essentially the same as {@code CheckedFunction2<T, Double, Void>}.
  *
  * @param <T> Argument type
  */

File: src/main/java/javax/util/function/CheckedObjIntConsumer.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.ObjIntConsumer.
- * Essentially the same as {@code CheckedFunction2<T, Integer, Void>}, or short {@code X2<T, Integer, Void>}.
+ * Essentially the same as {@code CheckedFunction2<T, Integer, Void>}.
  *
  * @param <T> Argument type
  */

File: src/main/java/javax/util/function/CheckedObjLongConsumer.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.ObjLongConsumer.
- * Essentially the same as {@code CheckedFunction2<T, Long, Void>}, or short {@code X2<T, Long, Void>}.
+ * Essentially the same as {@code CheckedFunction2<T, Long, Void>}.
  *
  * @param <T> Argument type
  */

File: src/main/java/javax/util/function/CheckedPredicate.java
Patch:
@@ -10,7 +10,7 @@
 
 /**
  * Checked version of java.util.function.Predicate.
- * Essentially the same as {@code CheckedFunction1<T, Boolean>}, or short {@code X1<T, Boolean>}.
+ * Essentially the same as {@code CheckedFunction1<T, Boolean>}.
  *
  * @param <T> Argument type
  */

File: src/main/java/javax/util/function/CheckedShortFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of ShortFunction.
- * Essentially the same as {@code CheckedFunction1<Short, R>}, or short {@code X1<Short, R>}.
+ * Essentially the same as {@code CheckedFunction1<Short, R>}.
  *
  * @param <R> Return value type
  */

File: src/main/java/javax/util/function/CheckedSupplier.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.Supplier.
- * Essentially the same as {@code CheckedFunction0<R>}, or short {@code X0<R>}.
+ * Essentially the same as {@code CheckedFunction0<R>}.
  *
  * @param <R> Return type
  */

File: src/main/java/javax/util/function/CheckedToDoubleBiFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.ToDoubleBiFunction.
- * Essentially the same as {@code CheckedFunction2<T, U, Double>}, or short {@code X2<T, U, Double>}.
+ * Essentially the same as {@code CheckedFunction2<T, U, Double>}.
  *
  * @param <T> First argument type
  * @param <U> Second argument type

File: src/main/java/javax/util/function/CheckedToDoubleFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.ToDoubleFunction.
- * Essentially the same as {@code CheckedFunction1<T, Double>}, or short {@code X1<T, Double>}.
+ * Essentially the same as {@code CheckedFunction1<T, Double>}.
  *
  * @param <T> Argument type
  */

File: src/main/java/javax/util/function/CheckedToIntBiFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.ToIntBiFunction.
- * Essentially the same as {@code CheckedFunction2<T, U, Integer>}, or short {@code X2<T, U, Integer>}.
+ * Essentially the same as {@code CheckedFunction2<T, U, Integer>}.
  *
  * @param <T> First argument type
  * @param <U> Second argument type

File: src/main/java/javax/util/function/CheckedToIntFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.ToIntFunction.
- * Essentially the same as {@code CheckedFunction1<T, Integer>}, or short {@code X1<T, Integer>}.
+ * Essentially the same as {@code CheckedFunction1<T, Integer>}.
  *
  * @param <T> Argument type
  */

File: src/main/java/javax/util/function/CheckedToLongBiFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.ToLongBiFunction.
- * Essentially the same as {@code CheckedFunction2<T, U, Long>}, or short {@code X2<T, U, Long>}.
+ * Essentially the same as {@code CheckedFunction2<T, U, Long>}.
  *
  * @param <T> First argument type
  * @param <U> Second argument type

File: src/main/java/javax/util/function/CheckedToLongFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.ToLongFunction.
- * Essentially the same as {@code CheckedFunction1<T, Long>}, or short {@code X1<T, Long>}.
+ * Essentially the same as {@code CheckedFunction1<T, Long>}.
  *
  * @param <T> Argument type
  */

File: src/main/java/javax/util/function/CheckedUnaryOperator.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Checked version of java.util.function.UnaryOperator.
- * Essentially the same as {@code CheckedFunction1<T, T>}, or short {@code X1<T, T>}.
+ * Essentially the same as {@code CheckedFunction1<T, T>}.
  *
  * @param <T> Operand type
  */

File: src/main/java/javax/util/function/FloatFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Unchecked float to R function.
- * Essentially the same as {@code Function1<Float, R>}, or short {@code 1<Float, R>}.
+ * Essentially the same as {@code Function1<Float, R>}.
  *
  * @param <R> Return value type
  */

File: src/main/java/javax/util/function/ShortFunction.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Unchecked short to R function.
- * Essentially the same as {@code Function1<Short, R>}, or short {@code 1<Short, R>}.
+ * Essentially the same as {@code Function1<Short, R>}.
  *
  * @param <R> Return value type
  */

File: src-gen/main/java/javaslang/CheckedFunction0.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction0<R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply() throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction1.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction1<T1, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     static <T> CheckedFunction1<T, T> identity() {
         return t -> t;
     }

File: src-gen/main/java/javaslang/CheckedFunction10.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction11.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction12.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction13.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction14.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction15.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction16.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction17.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction18.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction19.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction2.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction2<T1, T2, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction20.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction21.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20, T21 t21) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction22.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20, T21 t21, T22 t22) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction23.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20, T21 t21, T22 t22, T23 t23) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction24.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20, T21 t21, T22 t22, T23 t23, T24 t24) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction25.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20, T21 t21, T22 t22, T23 t23, T24 t24, T25 t25) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction26.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20, T21 t21, T22 t22, T23 t23, T24 t24, T25 t25, T26 t26) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction3.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction3<T1, T2, T3, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction4.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction4<T1, T2, T3, T4, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction5.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction5<T1, T2, T3, T4, T5, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction6.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction6<T1, T2, T3, T4, T5, T6, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction7.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction7<T1, T2, T3, T4, T5, T6, T7, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction8.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction8<T1, T2, T3, T4, T5, T6, T7, T8, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/CheckedFunction9.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedFunction9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9) throws Throwable;
 
     @Override

File: src-gen/main/java/javaslang/Function0.java
Patch:
@@ -16,6 +16,8 @@
 @FunctionalInterface
 public interface Function0<R> extends <R>, Supplier<R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply();
 
     @Override

File: src-gen/main/java/javaslang/Function1.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function1<T1, R> extends <R>, Function<T1, R> {
 
+    static final long serialVersionUID = 1L;
+
     static <T> Function1<T, T> identity() {
         return t -> t;
     }

File: src-gen/main/java/javaslang/Function10.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10);
 
     @Override

File: src-gen/main/java/javaslang/Function11.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11);
 
     @Override

File: src-gen/main/java/javaslang/Function12.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12);
 
     @Override

File: src-gen/main/java/javaslang/Function13.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13);
 
     @Override

File: src-gen/main/java/javaslang/Function14.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14);
 
     @Override

File: src-gen/main/java/javaslang/Function15.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15);
 
     @Override

File: src-gen/main/java/javaslang/Function16.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16);
 
     @Override

File: src-gen/main/java/javaslang/Function17.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17);
 
     @Override

File: src-gen/main/java/javaslang/Function18.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18);
 
     @Override

File: src-gen/main/java/javaslang/Function19.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19);
 
     @Override

File: src-gen/main/java/javaslang/Function2.java
Patch:
@@ -16,6 +16,8 @@
 @FunctionalInterface
 public interface Function2<T1, T2, R> extends <R>, BiFunction<T1, T2, R> {
 
+    static final long serialVersionUID = 1L;
+
     @Override
     R apply(T1 t1, T2 t2);
 

File: src-gen/main/java/javaslang/Function20.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20);
 
     @Override

File: src-gen/main/java/javaslang/Function21.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20, T21 t21);
 
     @Override

File: src-gen/main/java/javaslang/Function22.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20, T21 t21, T22 t22);
 
     @Override

File: src-gen/main/java/javaslang/Function23.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20, T21 t21, T22 t22, T23 t23);
 
     @Override

File: src-gen/main/java/javaslang/Function24.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20, T21 t21, T22 t22, T23 t23, T24 t24);
 
     @Override

File: src-gen/main/java/javaslang/Function25.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20, T21 t21, T22 t22, T23 t23, T24 t24, T25 t25);
 
     @Override

File: src-gen/main/java/javaslang/Function26.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20, T21 t21, T22 t22, T23 t23, T24 t24, T25 t25, T26 t26);
 
     @Override

File: src-gen/main/java/javaslang/Function3.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function3<T1, T2, T3, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3);
 
     @Override

File: src-gen/main/java/javaslang/Function4.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function4<T1, T2, T3, T4, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4);
 
     @Override

File: src-gen/main/java/javaslang/Function5.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function5<T1, T2, T3, T4, T5, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
 
     @Override

File: src-gen/main/java/javaslang/Function6.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function6<T1, T2, T3, T4, T5, T6, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6);
 
     @Override

File: src-gen/main/java/javaslang/Function7.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function7<T1, T2, T3, T4, T5, T6, T7, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7);
 
     @Override

File: src-gen/main/java/javaslang/Function8.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function8<T1, T2, T3, T4, T5, T6, T7, T8, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8);
 
     @Override

File: src-gen/main/java/javaslang/Function9.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> extends <R> {
 
+    static final long serialVersionUID = 1L;
+
     R apply(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9);
 
     @Override

File: src-gen/main/java/javaslang/Tuple.java
Patch:
@@ -11,6 +11,8 @@
 
 public interface Tuple extends ValueObject {
 
+    static final long serialVersionUID = 1L;
+
     /**
      * Returns the number of elements of this tuple.
      *

File: src-gen/main/java/javaslang/Tuple1.java
Patch:
@@ -55,12 +55,12 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple1)) {
             return false;
         } else {
-            final Tuple1 that = (Tuple1) o;
+            final Tuple1<?> that = (Tuple1<?>) o;
             return Objects.equals(this._1, that._1);
         }
     }
 
-    // if this._1 == null hashCode(_1) returns Objects.hash(new T1[] { null }) = 31 instead of 0 = Objects.hash(null)
+    // if _1 == null, hashCode() returns Objects.hash(new T1[] { null }) = 31 instead of 0 = Objects.hash(null)
     @Override
     public int hashCode() {
         return Objects.hash(_1);

File: src-gen/main/java/javaslang/Tuple10.java
Patch:
@@ -74,7 +74,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple10)) {
             return false;
         } else {
-            final Tuple10 that = (Tuple10) o;
+            final Tuple10<?, ?, ?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple10<?, ?, ?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple11.java
Patch:
@@ -76,7 +76,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple11)) {
             return false;
         } else {
-            final Tuple11 that = (Tuple11) o;
+            final Tuple11<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple11<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple12.java
Patch:
@@ -78,7 +78,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple12)) {
             return false;
         } else {
-            final Tuple12 that = (Tuple12) o;
+            final Tuple12<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple12<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple13.java
Patch:
@@ -80,7 +80,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple13)) {
             return false;
         } else {
-            final Tuple13 that = (Tuple13) o;
+            final Tuple13<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple13<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple14.java
Patch:
@@ -82,7 +82,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple14)) {
             return false;
         } else {
-            final Tuple14 that = (Tuple14) o;
+            final Tuple14<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple14<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple15.java
Patch:
@@ -84,7 +84,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple15)) {
             return false;
         } else {
-            final Tuple15 that = (Tuple15) o;
+            final Tuple15<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple15<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple16.java
Patch:
@@ -86,7 +86,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple16)) {
             return false;
         } else {
-            final Tuple16 that = (Tuple16) o;
+            final Tuple16<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple16<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple17.java
Patch:
@@ -88,7 +88,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple17)) {
             return false;
         } else {
-            final Tuple17 that = (Tuple17) o;
+            final Tuple17<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple17<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple18.java
Patch:
@@ -90,7 +90,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple18)) {
             return false;
         } else {
-            final Tuple18 that = (Tuple18) o;
+            final Tuple18<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple18<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple19.java
Patch:
@@ -92,7 +92,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple19)) {
             return false;
         } else {
-            final Tuple19 that = (Tuple19) o;
+            final Tuple19<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple19<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple2.java
Patch:
@@ -59,7 +59,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple2)) {
             return false;
         } else {
-            final Tuple2 that = (Tuple2) o;
+            final Tuple2<?, ?> that = (Tuple2<?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2);
         }

File: src-gen/main/java/javaslang/Tuple20.java
Patch:
@@ -94,7 +94,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple20)) {
             return false;
         } else {
-            final Tuple20 that = (Tuple20) o;
+            final Tuple20<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple20<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple21.java
Patch:
@@ -96,7 +96,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple21)) {
             return false;
         } else {
-            final Tuple21 that = (Tuple21) o;
+            final Tuple21<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple21<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple22.java
Patch:
@@ -98,7 +98,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple22)) {
             return false;
         } else {
-            final Tuple22 that = (Tuple22) o;
+            final Tuple22<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple22<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple23.java
Patch:
@@ -100,7 +100,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple23)) {
             return false;
         } else {
-            final Tuple23 that = (Tuple23) o;
+            final Tuple23<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple23<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple24.java
Patch:
@@ -102,7 +102,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple24)) {
             return false;
         } else {
-            final Tuple24 that = (Tuple24) o;
+            final Tuple24<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple24<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple25.java
Patch:
@@ -104,7 +104,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple25)) {
             return false;
         } else {
-            final Tuple25 that = (Tuple25) o;
+            final Tuple25<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple25<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple26.java
Patch:
@@ -106,7 +106,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple26)) {
             return false;
         } else {
-            final Tuple26 that = (Tuple26) o;
+            final Tuple26<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple26<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple3.java
Patch:
@@ -60,7 +60,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple3)) {
             return false;
         } else {
-            final Tuple3 that = (Tuple3) o;
+            final Tuple3<?, ?, ?> that = (Tuple3<?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3);

File: src-gen/main/java/javaslang/Tuple4.java
Patch:
@@ -62,7 +62,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple4)) {
             return false;
         } else {
-            final Tuple4 that = (Tuple4) o;
+            final Tuple4<?, ?, ?, ?> that = (Tuple4<?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple5.java
Patch:
@@ -64,7 +64,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple5)) {
             return false;
         } else {
-            final Tuple5 that = (Tuple5) o;
+            final Tuple5<?, ?, ?, ?, ?> that = (Tuple5<?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple6.java
Patch:
@@ -66,7 +66,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple6)) {
             return false;
         } else {
-            final Tuple6 that = (Tuple6) o;
+            final Tuple6<?, ?, ?, ?, ?, ?> that = (Tuple6<?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple7.java
Patch:
@@ -68,7 +68,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple7)) {
             return false;
         } else {
-            final Tuple7 that = (Tuple7) o;
+            final Tuple7<?, ?, ?, ?, ?, ?, ?> that = (Tuple7<?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple8.java
Patch:
@@ -70,7 +70,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple8)) {
             return false;
         } else {
-            final Tuple8 that = (Tuple8) o;
+            final Tuple8<?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple8<?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src-gen/main/java/javaslang/Tuple9.java
Patch:
@@ -72,7 +72,7 @@ public boolean equals(Object o) {
         } else if (!(o instanceof Tuple9)) {
             return false;
         } else {
-            final Tuple9 that = (Tuple9) o;
+            final Tuple9<?, ?, ?, ?, ?, ?, ?, ?, ?> that = (Tuple9<?, ?, ?, ?, ?, ?, ?, ?, ?>) o;
             return Objects.equals(this._1, that._1)
                     && Objects.equals(this._2, that._2)
                     && Objects.equals(this._3, that._3)

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -37,6 +37,8 @@
  */
 public interface List<T> extends Seq<T>, Monad1<T, Traversable<?>>, ValueObject {
 
+    static final long serialVersionUID = 1L;
+
     /**
      * Returns a {@link java.util.stream.Collector} which may be used in conjunction with
      * {@link java.util.stream.Stream#collect(java.util.stream.Collector)} to obtain a {@link javaslang.collection.List}.

File: src/main/java/javaslang/collection/Tree.java
Patch:
@@ -17,6 +17,8 @@
 
 public interface Tree<T> extends Functor1<T>, ValueObject {
 
+    static final long serialVersionUID = 1L;
+
     /**
      * Gets the value of this tree.
      *

File: src/main/java/javaslang/control/Either.java
Patch:
@@ -44,6 +44,8 @@
 // DEV-NOTE: Either is no Monad and no Functor in the sense of javaslang.Algebra.*
 public interface Either<L, R> extends ValueObject {
 
+    static final long serialVersionUID = 1L;
+
 	boolean isLeft();
 
 	boolean isRight();

File: src/main/java/javaslang/control/Option.java
Patch:
@@ -31,6 +31,8 @@
  */
 public interface Option<T> extends Monad1<T, Option<?>>, ValueObject, Univalent<T> {
 
+    static final long serialVersionUID = 1L;
+
     static <T> Option<T> of(T value) {
         return (value == null) ? None.instance() : new Some<>(value);
     }

File: src/main/java/javaslang/control/Try.java
Patch:
@@ -23,6 +23,8 @@
  */
 public interface Try<T> extends Monad1<T, Try<?>>, ValueObject, Bivalent<T, Throwable> {
 
+    static final long serialVersionUID = 1L;
+
 	static <T> Try<T> of(CheckedSupplier<T> supplier) {
 		try {
 			return new Success<>(supplier.get());

File: src/main/java/javaslang/control/Valences.java
Patch:
@@ -51,6 +51,6 @@ static interface Bivalent<T, U> {
         Option<T> toOption();
 
         // order of generic parameters may vary (see Either.LeftProjection, Either.RightProjection)
-        Either toEither();
+        Either<?, ?> toEither();
     }
 }

File: src/main/java/javax/util/function/CheckedBiConsumer.java
Patch:
@@ -18,6 +18,8 @@
 @FunctionalInterface
 public interface CheckedBiConsumer<T, U> extends Serializable {
 
+    static final long serialVersionUID = 1L;
+
     void accept(T t, U u) throws Throwable;
 
     default CheckedBiConsumer<T,U>	andThen(CheckedBiConsumer<? super T,? super U> after) {

File: src/main/java/javax/util/function/CheckedBiPredicate.java
Patch:
@@ -18,6 +18,8 @@
 @FunctionalInterface
 public interface CheckedBiPredicate<T, U> extends Serializable {
 
+    static final long serialVersionUID = 1L;
+
     boolean test(T t, U u) throws Throwable;
 
     default CheckedBiPredicate<T, U> and(CheckedBiPredicate<? super T, ? super U> other) {

File: src/main/java/javax/util/function/CheckedConsumer.java
Patch:
@@ -17,6 +17,8 @@
 @FunctionalInterface
 public interface CheckedConsumer<T> extends Serializable {
 
+    static final long serialVersionUID = 1L;
+
     void accept(T t) throws Throwable;
 
     default CheckedConsumer<T> andThen(CheckedConsumer<? super T> after) {

File: src/main/java/javax/util/function/CheckedDoubleConsumer.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedDoubleConsumer extends Serializable {
 
+    static final long serialVersionUID = 1L;
+
     void accept(double value) throws Throwable;
 
     default CheckedDoubleConsumer andThen(CheckedDoubleConsumer after) {

File: src/main/java/javax/util/function/CheckedDoublePredicate.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedDoublePredicate extends Serializable {
 
+    static final long serialVersionUID = 1L;
+
     boolean test(double value) throws Throwable;
 
     default CheckedDoublePredicate and(CheckedDoublePredicate other) {

File: src/main/java/javax/util/function/CheckedDoubleUnaryOperator.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedDoubleUnaryOperator extends Serializable {
 
+    static final long serialVersionUID = 1L;
+
     double applyAsDouble(double operand) throws Throwable;
 
     default CheckedDoubleUnaryOperator compose(CheckedDoubleUnaryOperator before) {

File: src/main/java/javax/util/function/CheckedFunction.java
Patch:
@@ -17,6 +17,8 @@
 @FunctionalInterface
 public interface CheckedFunction<T, R> extends CheckedFunction1<T, R> {
 
+    static final long serialVersionUID = 1L;
+
     static <T> CheckedFunction<T, T> identity() {
         return t -> t;
     }

File: src/main/java/javax/util/function/CheckedIntConsumer.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedIntConsumer extends Serializable {
 
+    static final long serialVersionUID = 1L;
+
     void accept(int value) throws Throwable;
 
     default CheckedIntConsumer andThen(CheckedIntConsumer after) {

File: src/main/java/javax/util/function/CheckedIntPredicate.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedIntPredicate extends Serializable {
 
+    static final long serialVersionUID = 1L;
+
     boolean test(int value) throws Throwable;
 
     default CheckedIntPredicate and(CheckedIntPredicate other) {

File: src/main/java/javax/util/function/CheckedIntUnaryOperator.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedIntUnaryOperator extends Serializable {
 
+    static final long serialVersionUID = 1L;
+
     int applyAsInt(int operand) throws Throwable;
 
     default CheckedIntUnaryOperator compose(CheckedIntUnaryOperator before) {

File: src/main/java/javax/util/function/CheckedLongConsumer.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedLongConsumer extends Serializable {
 
+    static final long serialVersionUID = 1L;
+
     void accept(long value) throws Throwable;
 
     default CheckedLongConsumer andThen(CheckedLongConsumer after) {

File: src/main/java/javax/util/function/CheckedLongPredicate.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedLongPredicate extends Serializable {
 
+    static final long serialVersionUID = 1L;
+
     boolean test(long value) throws Throwable;
 
     default CheckedLongPredicate and(CheckedLongPredicate other) {

File: src/main/java/javax/util/function/CheckedLongUnaryOperator.java
Patch:
@@ -15,6 +15,8 @@
 @FunctionalInterface
 public interface CheckedLongUnaryOperator extends Serializable {
 
+    static final long serialVersionUID = 1L;
+
     long applyAsLong(long operand) throws Throwable;
 
     default CheckedLongUnaryOperator compose(CheckedLongUnaryOperator before) {

File: src/main/java/javax/util/function/CheckedPredicate.java
Patch:
@@ -17,6 +17,8 @@
 @FunctionalInterface
 public interface CheckedPredicate<T> extends Serializable {
 
+    static final long serialVersionUID = 1L;
+
     static <T> CheckedPredicate<T> isEqual(Object targetRef) {
         return (null == targetRef)
                 ? Objects::isNull

File: src/main/java/javax/util/function/CheckedUnaryOperator.java
Patch:
@@ -16,6 +16,8 @@
 @FunctionalInterface
 public interface CheckedUnaryOperator<T> extends CheckedFunction1<T, T> {
 
+    static final long serialVersionUID = 1L;
+
     static <T> CheckedUnaryOperator<T> identity() {
         return t -> t;
     }

File: src/test/java/javaslang/test/GenTest.java
Patch:
@@ -16,8 +16,9 @@ public class GenTest {
 
     @Test
     public void shouldUseCustomRandomNumberGenerator() {
-        //noinspection serial
+        @SuppressWarnings("SerializableInnerClassWithNonSerializableOuterClass")
         final Random rng = new Random() {
+            private static final long serialVersionUID = 1L;
             public int nextInt(int bound) {
                 return 0;
             }

File: src-gen/main/java/javaslang/Tuple1.java
Patch:
@@ -60,6 +60,7 @@ public boolean equals(Object o) {
         }
     }
 
+    // if this._1 == null hashCode(_1) returns Objects.hash(new T1[] { null }) = 31 instead of 0 = Objects.hash(null)
     @Override
     public int hashCode() {
         return Objects.hash(_1);

File: src-gen/test/java/javaslang/Tuple10Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple10 tuple = createTuple();
         final Function10 mapper = (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple10 actual = tuple.flatMap(mapper);
+        final Tuple10 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple11Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple11 tuple = createTuple();
         final Function11 mapper = (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple11 actual = tuple.flatMap(mapper);
+        final Tuple11 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple12Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple12 tuple = createTuple();
         final Function12 mapper = (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple12 actual = tuple.flatMap(mapper);
+        final Tuple12 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple13Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple13 tuple = createTuple();
         final Function13 mapper = (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple13 actual = tuple.flatMap(mapper);
+        final Tuple13 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple14Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple14 tuple = createTuple();
         final Function14 mapper = (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple14 actual = tuple.flatMap(mapper);
+        final Tuple14 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple15Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple15 tuple = createTuple();
         final Function15 mapper = (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple15 actual = tuple.flatMap(mapper);
+        final Tuple15 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple16Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple16 tuple = createTuple();
         final Function16 mapper = (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple16 actual = tuple.flatMap(mapper);
+        final Tuple16 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple17Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple17 tuple = createTuple();
         final Function17 mapper = (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple17 actual = tuple.flatMap(mapper);
+        final Tuple17 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple18Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple18 tuple = createTuple();
         final Function18 mapper = (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple18 actual = tuple.flatMap(mapper);
+        final Tuple18 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple19Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple19 tuple = createTuple();
         final Function19 mapper = (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple19 actual = tuple.flatMap(mapper);
+        final Tuple19 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple1Test.java
Patch:
@@ -41,9 +41,9 @@ public void shouldFlatMap() {
     @Test
     public void shouldMap() {
         final Tuple1 tuple = createTuple();
-        final Function mapper = (t1) -> tuple;
+        final Function mapper = (t1) -> t1;
         @SuppressWarnings("unchecked")
-        final Tuple1 actual = tuple.flatMap(mapper);
+        final Tuple1 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple20Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple20 tuple = createTuple();
         final Function20 mapper = (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple20 actual = tuple.flatMap(mapper);
+        final Tuple20 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple21Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple21 tuple = createTuple();
         final Function21 mapper = (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple21 actual = tuple.flatMap(mapper);
+        final Tuple21 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple22Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple22 tuple = createTuple();
         final Function22 mapper = (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple22 actual = tuple.flatMap(mapper);
+        final Tuple22 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple23Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple23 tuple = createTuple();
         final Function23 mapper = (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple23 actual = tuple.flatMap(mapper);
+        final Tuple23 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple24Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple24 tuple = createTuple();
         final Function24 mapper = (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple24 actual = tuple.flatMap(mapper);
+        final Tuple24 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple25Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple25 tuple = createTuple();
         final Function25 mapper = (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple25 actual = tuple.flatMap(mapper);
+        final Tuple25 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple26Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple26 tuple = createTuple();
         final Function26 mapper = (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple26 actual = tuple.flatMap(mapper);
+        final Tuple26 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple2Test.java
Patch:
@@ -43,7 +43,7 @@ public void shouldMap() {
         final Tuple2 tuple = createTuple();
         final BiFunction mapper = (t1, t2) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple2 actual = tuple.flatMap(mapper);
+        final Tuple2 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple3Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple3 tuple = createTuple();
         final Function3 mapper = (t1, t2, t3) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple3 actual = tuple.flatMap(mapper);
+        final Tuple3 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple4Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple4 tuple = createTuple();
         final Function4 mapper = (t1, t2, t3, t4) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple4 actual = tuple.flatMap(mapper);
+        final Tuple4 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple5Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple5 tuple = createTuple();
         final Function5 mapper = (t1, t2, t3, t4, t5) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple5 actual = tuple.flatMap(mapper);
+        final Tuple5 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple6Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple6 tuple = createTuple();
         final Function6 mapper = (t1, t2, t3, t4, t5, t6) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple6 actual = tuple.flatMap(mapper);
+        final Tuple6 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple7Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple7 tuple = createTuple();
         final Function7 mapper = (t1, t2, t3, t4, t5, t6, t7) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple7 actual = tuple.flatMap(mapper);
+        final Tuple7 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple8Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple8 tuple = createTuple();
         final Function8 mapper = (t1, t2, t3, t4, t5, t6, t7, t8) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple8 actual = tuple.flatMap(mapper);
+        final Tuple8 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/test/java/javaslang/Tuple9Test.java
Patch:
@@ -42,7 +42,7 @@ public void shouldMap() {
         final Tuple9 tuple = createTuple();
         final Function9 mapper = (t1, t2, t3, t4, t5, t6, t7, t8, t9) -> tuple;
         @SuppressWarnings("unchecked")
-        final Tuple9 actual = tuple.flatMap(mapper);
+        final Tuple9 actual = tuple.map(mapper);
         assertThat(actual).isEqualTo(tuple);
     }
 

File: src-gen/main/java/javaslang/algebra/HigherKinded1.java
Patch:
@@ -24,7 +24,7 @@
  *
  * @param <T1> Component type of the type to be constructed.
  * @param <TYPE> Container type of the type to be constructed.
- */      
+ */
 public interface HigherKinded1<T1, TYPE extends HigherKinded1<?, TYPE>> {
 
     // used for type declaration only

File: src/main/java/javaslang/collection/Seq.java
Patch:
@@ -5,7 +5,6 @@
  */
 package javaslang.collection;
 
-import javaslang.Tuple;
 import javaslang.Tuple2;
 
 import java.util.Comparator;

File: src/main/java/javaslang/collection/Tree.java
Patch:
@@ -7,15 +7,15 @@
 
 import javaslang.Strings;
 import javaslang.ValueObject;
-import javaslang.algebra.Functor;
+import javaslang.algebra.Functor1;
 
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.Objects;
 import java.util.Queue;
 import java.util.function.Function;
 
-public interface Tree<T> extends Functor<T>, ValueObject {
+public interface Tree<T> extends Functor1<T>, ValueObject {
 
     /**
      * Gets the value of this tree.

File: src/main/java/javaslang/control/Failure.java
Patch:
@@ -8,7 +8,7 @@
 import javaslang.Tuple;
 import javaslang.Tuple1;
 import javaslang.ValueObject;
-import javaslang.algebra.HigherKinded;
+import javaslang.algebra.HigherKinded1;
 
 import java.util.Objects;
 import java.util.function.Consumer;
@@ -120,7 +120,7 @@ public <U> Try<U> map(Function<? super T, ? extends U> mapper) {
     }
 
     @Override
-    public <U, TRY extends HigherKinded<U, Try<?>>> Try<U> flatMap(Function<? super T, TRY> mapper) {
+    public <U, TRY extends HigherKinded1<U, Try<?>>> Try<U> flatMap(Function<? super T, TRY> mapper) {
         @SuppressWarnings("unchecked")
         final Try<U> result = (Try<U>) this;
         return result;

File: src/main/java/javaslang/control/None.java
Patch:
@@ -7,7 +7,7 @@
 
 import javaslang.Tuple;
 import javaslang.Tuple0;
-import javaslang.algebra.HigherKinded;
+import javaslang.algebra.HigherKinded1;
 
 import java.util.NoSuchElementException;
 import java.util.Objects;
@@ -106,7 +106,7 @@ public <U> Option<U> map(Function<? super T, ? extends U> mapper) {
     }
 
     @Override
-    public <U, OPTION extends HigherKinded<U, Option<?>>> Option<U> flatMap(Function<? super T, OPTION> mapper) {
+    public <U, OPTION extends HigherKinded1<U, Option<?>>> Option<U> flatMap(Function<? super T, OPTION> mapper) {
         return None.instance();
     }
 

File: src/main/java/javaslang/control/Some.java
Patch:
@@ -7,7 +7,7 @@
 
 import javaslang.Tuple;
 import javaslang.Tuple1;
-import javaslang.algebra.HigherKinded;
+import javaslang.algebra.HigherKinded1;
 
 import java.util.Objects;
 import java.util.function.Consumer;
@@ -88,7 +88,7 @@ public <U> Option<U> map(Function<? super T, ? extends U> mapper) {
 
     @SuppressWarnings("unchecked")
     @Override
-    public <U, OPTION extends HigherKinded<U, Option<?>>> Option<U> flatMap(Function<? super T, OPTION> mapper) {
+    public <U, OPTION extends HigherKinded1<U, Option<?>>> Option<U> flatMap(Function<? super T, OPTION> mapper) {
         return (Option<U>) mapper.apply(value);
     }
 

File: src/main/java/javaslang/control/Success.java
Patch:
@@ -7,7 +7,7 @@
 
 import javaslang.Tuple;
 import javaslang.Tuple1;
-import javaslang.algebra.HigherKinded;
+import javaslang.algebra.HigherKinded1;
 
 import java.util.NoSuchElementException;
 import java.util.Objects;
@@ -114,7 +114,7 @@ public <U> Try<U> map(Function<? super T, ? extends U> mapper) {
 
     @SuppressWarnings("unchecked")
     @Override
-    public <U, TRY extends HigherKinded<U, Try<?>>> Try<U> flatMap(Function<? super T, TRY> mapper) {
+    public <U, TRY extends HigherKinded1<U, Try<?>>> Try<U> flatMap(Function<? super T, TRY> mapper) {
         try {
             return (Try<U>) mapper.apply(value);
         } catch (Throwable t) {

File: src/main/java/javaslang/function/Lambda.java
Patch:
@@ -32,7 +32,7 @@ public interface Lambda<R> extends Serializable {
      * Serializes a lambda and returns the corresponding {@link java.lang.invoke.SerializedLambda}.
      *
      * @param lambda A serializable lambda
-     * @return The serialized lambda wrapped in a {@link javaslang.control.Try.Success}, or a {@link javaslang.control.Try.Failure}
+     * @return The serialized lambda wrapped in a {@link javaslang.control.Success}, or a {@link javaslang.control.Failure}
      * if an exception occurred.
      * @see <a
      * href="http://stackoverflow.com/questions/21860875/printing-debug-info-on-errors-with-java-8-lambda-expressions">printing

File: src-gen/main/java/javaslang/Tuple2.java
Patch:
@@ -45,7 +45,7 @@ public boolean equals(Object o) {
         } else {
             final Tuple2 that = (Tuple2) o;
             return Objects.equals(this._1, that._1)
-                    && Objects.equals(this._2, that._2);
+                  && Objects.equals(this._2, that._2);
         }
     }
 

File: src-gen/main/java/javaslang/Tuple3.java
Patch:
@@ -47,8 +47,8 @@ public boolean equals(Object o) {
         } else {
             final Tuple3 that = (Tuple3) o;
             return Objects.equals(this._1, that._1)
-                    && Objects.equals(this._2, that._2)
-                    && Objects.equals(this._3, that._3);
+                  && Objects.equals(this._2, that._2)
+                  && Objects.equals(this._3, that._3);
         }
     }
 

File: src-gen/main/java/javaslang/Tuple4.java
Patch:
@@ -49,9 +49,9 @@ public boolean equals(Object o) {
         } else {
             final Tuple4 that = (Tuple4) o;
             return Objects.equals(this._1, that._1)
-                    && Objects.equals(this._2, that._2)
-                    && Objects.equals(this._3, that._3)
-                    && Objects.equals(this._4, that._4);
+                  && Objects.equals(this._2, that._2)
+                  && Objects.equals(this._3, that._3)
+                  && Objects.equals(this._4, that._4);
         }
     }
 

File: src/test/java/javaslang/test/PropertyTest.java
Patch:
@@ -13,6 +13,7 @@
 public class PropertyTest {
 
     @Test
+    @Ignore
     public void shouldCheckPythagoras() {
 
         final Arbitrary<Double> real = n -> Gen.choose(0, (double) n).filter(d -> d > .0d);

File: src/test/java/javaslang/test/PropertyTest.java
Patch:
@@ -19,7 +19,8 @@ public void shouldCheckPythagoras() {
 
         // (a,b  + c  + : a+b=c)  (a,b  + : a+b  +)
         final Property property = Property.forAll(real, real).suchThat((a, b) -> a * a + b * b > .0d);
+        final CheckResult checkResult = property.check();
 
-        assertThat(property.test()).isTrue();
+        assertThat(checkResult.isSatisfied()).isTrue();
     }
 }

File: src-gen/main/java/javaslang/Tuple.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 public interface Tuple extends ValueObject {
 

File: src-gen/main/java/javaslang/Tuple0.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple1.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple10.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple11.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple12.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple13.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple14.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple15.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple16.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple17.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple18.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple19.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple2.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple20.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple21.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple22.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple23.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple24.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple25.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple26.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple3.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple4.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple5.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple6.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple7.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple8.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/Tuple9.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import java.util.Objects;
 

File: src-gen/main/java/javaslang/function/CheckedLambda0.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple0;
 

File: src-gen/main/java/javaslang/function/CheckedLambda1.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple1;
 

File: src-gen/main/java/javaslang/function/CheckedLambda10.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple10;
 

File: src-gen/main/java/javaslang/function/CheckedLambda11.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple11;
 

File: src-gen/main/java/javaslang/function/CheckedLambda12.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple12;
 

File: src-gen/main/java/javaslang/function/CheckedLambda13.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple13;
 

File: src-gen/main/java/javaslang/function/CheckedLambda14.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple14;
 

File: src-gen/main/java/javaslang/function/CheckedLambda15.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple15;
 

File: src-gen/main/java/javaslang/function/CheckedLambda16.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple16;
 

File: src-gen/main/java/javaslang/function/CheckedLambda17.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple17;
 

File: src-gen/main/java/javaslang/function/CheckedLambda18.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple18;
 

File: src-gen/main/java/javaslang/function/CheckedLambda19.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple19;
 

File: src-gen/main/java/javaslang/function/CheckedLambda2.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple2;
 

File: src-gen/main/java/javaslang/function/CheckedLambda20.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple20;
 

File: src-gen/main/java/javaslang/function/CheckedLambda21.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple21;
 

File: src-gen/main/java/javaslang/function/CheckedLambda22.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple22;
 

File: src-gen/main/java/javaslang/function/CheckedLambda23.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple23;
 

File: src-gen/main/java/javaslang/function/CheckedLambda24.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple24;
 

File: src-gen/main/java/javaslang/function/CheckedLambda25.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple25;
 

File: src-gen/main/java/javaslang/function/CheckedLambda26.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple26;
 

File: src-gen/main/java/javaslang/function/CheckedLambda3.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple3;
 

File: src-gen/main/java/javaslang/function/CheckedLambda4.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple4;
 

File: src-gen/main/java/javaslang/function/CheckedLambda5.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple5;
 

File: src-gen/main/java/javaslang/function/CheckedLambda6.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple6;
 

File: src-gen/main/java/javaslang/function/CheckedLambda7.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple7;
 

File: src-gen/main/java/javaslang/function/CheckedLambda8.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple8;
 

File: src-gen/main/java/javaslang/function/CheckedLambda9.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple9;
 

File: src-gen/main/java/javaslang/function/Lambda0.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple0;
 

File: src-gen/main/java/javaslang/function/Lambda1.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple1;
 

File: src-gen/main/java/javaslang/function/Lambda10.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple10;
 

File: src-gen/main/java/javaslang/function/Lambda11.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple11;
 

File: src-gen/main/java/javaslang/function/Lambda12.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple12;
 

File: src-gen/main/java/javaslang/function/Lambda13.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple13;
 

File: src-gen/main/java/javaslang/function/Lambda14.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple14;
 

File: src-gen/main/java/javaslang/function/Lambda15.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple15;
 

File: src-gen/main/java/javaslang/function/Lambda16.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple16;
 

File: src-gen/main/java/javaslang/function/Lambda17.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple17;
 

File: src-gen/main/java/javaslang/function/Lambda18.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple18;
 

File: src-gen/main/java/javaslang/function/Lambda19.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple19;
 

File: src-gen/main/java/javaslang/function/Lambda2.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple2;
 

File: src-gen/main/java/javaslang/function/Lambda20.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple20;
 

File: src-gen/main/java/javaslang/function/Lambda21.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple21;
 

File: src-gen/main/java/javaslang/function/Lambda22.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple22;
 

File: src-gen/main/java/javaslang/function/Lambda23.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple23;
 

File: src-gen/main/java/javaslang/function/Lambda24.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple24;
 

File: src-gen/main/java/javaslang/function/Lambda25.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple25;
 

File: src-gen/main/java/javaslang/function/Lambda26.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple26;
 

File: src-gen/main/java/javaslang/function/Lambda3.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple3;
 

File: src-gen/main/java/javaslang/function/Lambda4.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple4;
 

File: src-gen/main/java/javaslang/function/Lambda5.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple5;
 

File: src-gen/main/java/javaslang/function/Lambda6.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple6;
 

File: src-gen/main/java/javaslang/function/Lambda7.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple7;
 

File: src-gen/main/java/javaslang/function/Lambda8.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple8;
 

File: src-gen/main/java/javaslang/function/Lambda9.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple9;
 

File: src-gen/main/java/javaslang/function/0.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple0;
 

File: src-gen/main/java/javaslang/function/1.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple1;
 

File: src-gen/main/java/javaslang/function/10.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple10;
 

File: src-gen/main/java/javaslang/function/11.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple11;
 

File: src-gen/main/java/javaslang/function/12.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple12;
 

File: src-gen/main/java/javaslang/function/13.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple13;
 

File: src-gen/main/java/javaslang/function/14.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple14;
 

File: src-gen/main/java/javaslang/function/15.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple15;
 

File: src-gen/main/java/javaslang/function/16.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple16;
 

File: src-gen/main/java/javaslang/function/17.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple17;
 

File: src-gen/main/java/javaslang/function/18.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple18;
 

File: src-gen/main/java/javaslang/function/19.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple19;
 

File: src-gen/main/java/javaslang/function/2.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple2;
 

File: src-gen/main/java/javaslang/function/20.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple20;
 

File: src-gen/main/java/javaslang/function/21.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple21;
 

File: src-gen/main/java/javaslang/function/22.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple22;
 

File: src-gen/main/java/javaslang/function/23.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple23;
 

File: src-gen/main/java/javaslang/function/24.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple24;
 

File: src-gen/main/java/javaslang/function/25.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple25;
 

File: src-gen/main/java/javaslang/function/26.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple26;
 

File: src-gen/main/java/javaslang/function/3.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple3;
 

File: src-gen/main/java/javaslang/function/4.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple4;
 

File: src-gen/main/java/javaslang/function/5.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple5;
 

File: src-gen/main/java/javaslang/function/6.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple6;
 

File: src-gen/main/java/javaslang/function/7.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple7;
 

File: src-gen/main/java/javaslang/function/8.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple8;
 

File: src-gen/main/java/javaslang/function/9.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple9;
 

File: src-gen/main/java/javaslang/function/0.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple0;
 

File: src-gen/main/java/javaslang/function/1.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple1;
 

File: src-gen/main/java/javaslang/function/10.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple10;
 

File: src-gen/main/java/javaslang/function/11.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple11;
 

File: src-gen/main/java/javaslang/function/12.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple12;
 

File: src-gen/main/java/javaslang/function/13.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple13;
 

File: src-gen/main/java/javaslang/function/14.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple14;
 

File: src-gen/main/java/javaslang/function/15.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple15;
 

File: src-gen/main/java/javaslang/function/16.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple16;
 

File: src-gen/main/java/javaslang/function/17.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple17;
 

File: src-gen/main/java/javaslang/function/18.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple18;
 

File: src-gen/main/java/javaslang/function/19.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple19;
 

File: src-gen/main/java/javaslang/function/2.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple2;
 

File: src-gen/main/java/javaslang/function/20.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple20;
 

File: src-gen/main/java/javaslang/function/21.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple21;
 

File: src-gen/main/java/javaslang/function/22.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple22;
 

File: src-gen/main/java/javaslang/function/23.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple23;
 

File: src-gen/main/java/javaslang/function/24.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple24;
 

File: src-gen/main/java/javaslang/function/25.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple25;
 

File: src-gen/main/java/javaslang/function/26.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple26;
 

File: src-gen/main/java/javaslang/function/3.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple3;
 

File: src-gen/main/java/javaslang/function/4.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple4;
 

File: src-gen/main/java/javaslang/function/5.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple5;
 

File: src-gen/main/java/javaslang/function/6.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple6;
 

File: src-gen/main/java/javaslang/function/7.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple7;
 

File: src-gen/main/java/javaslang/function/8.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple8;
 

File: src-gen/main/java/javaslang/function/9.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.function;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.Tuple9;
 

File: src-gen/main/java/javaslang/test/Property.java
Patch:
@@ -5,9 +5,9 @@
  */
 package javaslang.test;
 
-/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
-     G E N E R A T O R   C R A F T E D
-\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
+/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
+   G E N E R A T O R   C R A F T E D
+\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 
 import javaslang.function.*;
 

File: src/main/java/javaslang/function/CheckedBiFunction.java
Patch:
@@ -14,5 +14,5 @@
  * @param <R> Return value type
  */
 @FunctionalInterface
-public interface CheckedBiFunction<T, U, R> extends CheckedFunction2<T, U, R> {
+public interface CheckedBiFunction<T, U, R> extends CheckedLambda2<T, U, R> {
 }

File: src/main/java/javaslang/function/CheckedFunction.java
Patch:
@@ -13,7 +13,7 @@
  * @param <R> Return value type
  */
 @FunctionalInterface
-public interface CheckedFunction<T, R> extends CheckedFunction1<T, R> {
+public interface CheckedFunction<T, R> extends CheckedLambda1<T, R> {
 
     static <T> CheckedFunction<T, T> identity() {
         return t -> t;

File: src/main/java/javaslang/function/CheckedUnaryOperator.java
Patch:
@@ -12,7 +12,7 @@
  * @param <T> Operand type
  */
 @FunctionalInterface
-public interface CheckedUnaryOperator<T> extends CheckedFunction1<T, T> {
+public interface CheckedUnaryOperator<T> extends CheckedLambda1<T, T> {
 
     static <T> CheckedUnaryOperator<T> identity() {
         return t -> t;

File: src/main/java/javaslang/test/Property.java
Patch:
@@ -74,7 +74,7 @@ public <T2> Property2<T1, T2> forAll(Arbitrary<T2> a2) {
             return new Property2<>(test1, Test.forAll(a2));
         }
 
-        public boolean suchThat(Function1<T1, Boolean> predicate) {
+        public boolean suchThat(Lambda1<T1, Boolean> predicate) {
             throw new UnsupportedOperationException("TODO");
         }
     }
@@ -101,7 +101,7 @@ public <T3> Property3<T1, T2, T3> forAll(Arbitrary<T3> a3) {
         }
 
 
-        public boolean suchThat(Function2<T1, T2, Boolean> predicate) {
+        public boolean suchThat(Lambda2<T1, T2, Boolean> predicate) {
             throw new UnsupportedOperationException("TODO");
         }
     }

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -64,7 +64,7 @@
  * <li>{@link #fold(Object, java.util.function.BiFunction)}</li>
  * <li>{@link #foldLeft(Object, java.util.function.BiFunction)}</li>
  * <li>{@link #foldRight(Object, java.util.function.BiFunction)}</li>
- * <li>{@link #foldMap(javaslang.Algebra.Monoid, java.util.function.Function)}</li>
+ * <li>{@link #foldMap(javaslang.algebra.Monoid, java.util.function.Function)}</li>
  * <li>{@link #join()}</li>
  * <li>{@link #join(CharSequence)}</li>
  * <li>{@link #join(CharSequence, CharSequence, CharSequence)}</li>
@@ -492,7 +492,7 @@ default int length() {
      * @param mapper A mapper.
      * @param <U>    Component type of the target Traversable
      * @return A mapped Traversable
-     * @see javaslang.Algebra.Monad#map(Function)
+     * @see javaslang.algebra.Monad#map(Function)
      */
     <U> Traversable<U> map(Function<? super T, ? extends U> mapper);
 

File: src/main/java/javaslang/match/Match.java
Patch:
@@ -15,7 +15,7 @@
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 
-import javaslang.Functions.*;
+import javaslang.function.*;
 import javaslang.monad.Option;
 import javaslang.monad.Option.None;
 import javaslang.monad.Option.Some;

File: src/main/java/javaslang/monad/Try.java
Patch:
@@ -10,10 +10,11 @@
 import java.util.function.*;
 
 import javaslang.Algebra.*;
-import javaslang.Functions.*;
 import javaslang.Tuple;
 import javaslang.Tuple.*;
 import javaslang.ValueObject;
+import javaslang.function.CheckedRunnable;
+import javaslang.function.CheckedSupplier;
 import javaslang.monad.Option.None;
 import javaslang.monad.Option.Some;
 import javaslang.monad.Valences.Bivalent;

File: src/test/java/javaslang/test/ArbitraryTest.java
Patch:
@@ -11,6 +11,8 @@
 
 public class ArbitraryTest {
 
+    // TODO: unit tests
+
     public static void main(String[] args) {
 
         // represents arbitrary binary trees of a certain depth n

File: src/main/java/javaslang/Functions.java
Patch:
@@ -54,7 +54,7 @@ private Functions() {
      * debug info on errors with java 8 lambda expressions</a>
      * @see <a href="http://www.slideshare.net/hendersk/method-handles-in-java">Method Handles in Java</a>
      */
-    public static SerializedLambda getSerializedFunction(Serializable lambda) {
+    public static SerializedLambda getSerializedLambda(Serializable lambda) {
         return Try.of(() -> {
             final Method method = lambda.getClass().getDeclaredMethod("writeReplace");
             method.setAccessible(true);
@@ -77,7 +77,7 @@ public static SerializedLambda getSerializedFunction(Serializable lambda) {
      * @return The signature of the lambda as {@linkplain java.lang.invoke.MethodType}.
      */
     public static MethodType getLambdaSignature(Serializable lambda) {
-        final String signature = getSerializedFunction(lambda).getImplMethodSignature();
+        final String signature = getSerializedLambda(lambda).getImplMethodSignature();
         return MethodType.fromMethodDescriptorString(signature, lambda.getClass().getClassLoader());
     }
 

File: src/main/java/javaslang/Memoizer.java
Patch:
@@ -17,7 +17,7 @@ static <T> Memoizer0<T> of(Supplier<T> supplier) {
     }
 
     // TODO: memory footprint vs. impl of ValueObject (=> use cases?)
-    static class Memoizer0<T> implements Lambda.0 {
+    static class Memoizer0<T> implements Function.Function0 {
 
         private static final long serialVersionUID = -8603286927231794237L;
 

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -13,6 +13,7 @@
 import java.io.*;
 import java.util.*;
 import java.util.function.*;
+import java.util.function.Function;
 import java.util.stream.Collector;
 
 /**

File: src/main/java/javaslang/match/Patterns.java
Patch:
@@ -8,7 +8,7 @@
 import java.lang.invoke.MethodType;
 
 import javaslang.Tuple;
-import javaslang.Lambda.1;
+import javaslang.Function.Function1;
 import javaslang.Tuple.Tuple1;
 import javaslang.Tuple.Tuple2;
 
@@ -40,9 +40,9 @@ private Patterns() {
 	 * @return A Pattern which matches functions by argument type and result type.
 	 */
 	@SuppressWarnings("unchecked")
-	public static <T, R> Pattern<1<T, R>, Tuple2<Class<?>, Class<?>>, Tuple2<Class<T>, Class<R>>> Function(
+	public static <T, R> Pattern<Function1<T, R>, Tuple2<Class<?>, Class<?>>, Tuple2<Class<T>, Class<R>>> Function(
 			Class<T> paramType, Class<R> returnType) {
-		return Pattern.of((1<T, R> f) -> {
+		return Pattern.of((Function1<T, R> f) -> {
 			final MethodType methodType = f.getType();
 			/* if lambda has captured argument, the last parameter is the method argument */
 			final int paramIndex = methodType.parameterCount() - 1;

File: src/main/java/javaslang/collection/Tree.java
Patch:
@@ -130,7 +130,7 @@ default Iterator<T> iterator() {
         } else {
             class Local {
                 Stream<T> preOrder(Tree<T> tree) {
-                    return new Stream.Cons<>(tree::getValue, () -> Stream.of(tree.getChildren()).flatMap(Local.this::preOrder));
+                    return new Stream.Cons<>(getValue(), () -> Stream.of(tree.getChildren()).flatMap(Local.this::preOrder));
                 }
             }
             return new Local().preOrder(this).iterator();

File: src/test/java/javaslang/collection/AbstractTraversableTest.java
Patch:
@@ -1063,7 +1063,6 @@ public void shouldPreserveSingletonInstanceOnDeserialization() {
     }
 
     @Test
-    @Ignore
     public void shouldSerializeDeserializeNonNil() {
         final Object actual = deserialize(serialize(this.of(1, 2, 3)));
         final Object expected = this.of(1, 2, 3);

File: src/test/java/javaslang/collection/ProjectEulerTest.java
Patch:
@@ -1,6 +1,6 @@
 /**    / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
- *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014 Daniel Dietrich
+ *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0
  */
 package javaslang.collection;

File: src/test/java/javaslang/collection/RoseTreeTest.java
Patch:
@@ -1,6 +1,6 @@
 /**    / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
- *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014 Daniel Dietrich
+ *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0
  */
 package javaslang.collection;

File: src/test/java/javaslang/collection/StreamTest.java
Patch:
@@ -1,6 +1,6 @@
 /**    / \____  _    ______   _____ / \____   ____  _____
  *    /  \__  \/ \  / \__  \ /  __//  \__  \ /    \/ __  \   Javaslang
- *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014 Daniel Dietrich
+ *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014-2015 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0
  */
 package javaslang.collection;

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -107,7 +107,7 @@ static <T> List<T> of(Iterable<? extends T> elements) {
         }
     }
 
-    static List<Integer> of(int from, int to) {
+    static List<Integer> range(int from, int to) {
         Require.isTrue(from <= to, String.format("from %s > to %s", from, to));
         List<Integer> result = Nil.instance();
         for (int i = to; i >= from; i--) {
@@ -848,7 +848,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return map(Strings::toString).join(", ", "List(", ")");
+            return List.class.getSimpleName() + join(", ", "(", ")");
         }
     }
 }

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -97,7 +97,7 @@ static <T> Stream<T> of(Iterable<? extends T> elements) {
         }
     }
 
-    static Stream<Integer> of(int from, int to) {
+    static Stream<Integer> range(int from, int to) {
         Require.isTrue(from <= to, String.format("from %s > to %s", from, to));
         return Stream.of(() -> new Iterator<Integer>() {
             int i = from;
@@ -825,7 +825,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return map(Strings::toString).join(", ", "Stream(", ")");
+            return Stream.class.getSimpleName() + join(", ", "(", ")");
         }
     }
 }

File: src/main/java/javaslang/collection/Traversable.java
Patch:
@@ -31,7 +31,6 @@
  * <li>{@link #clear()}</li>
  * <li>{@link #contains(Object)}</li>
  * <li>{@link #containsAll(Iterable)}</li>
- * <li>{@link #forEach(Consumer)}</li>
  * <li>{@link #head()}</li>
  * <li>{@link #init()}</li>
  * <li>{@link #isEmpty()}</li>
@@ -300,7 +299,7 @@ default String join(CharSequence delimiter,
                         CharSequence prefix,
                         CharSequence suffix) {
         final StringBuilder builder = new StringBuilder(prefix);
-        map(Strings::toString).intersperse(String.valueOf(delimiter)).forEach(builder::append);
+        map(String::valueOf).intersperse(String.valueOf(delimiter)).forEach(builder::append);
         return builder.append(suffix).toString();
     }
 

File: src/test/java/javaslang/collection/BinaryTreeTest.java
Patch:
@@ -61,8 +61,6 @@ public void shouldMapTree() {
     public void shouldZipWithIndex() {
         System.out.println(tree);
         System.out.println(tree.flatten());
-        System.out.println(tree.zipWithIndex());
-        System.out.println(tree.take(5));
         // broken: System.out.println(tree.flatMap(i -> leaf(i+10)));
     }
 }

File: src/main/java/javaslang/collection/Foldable.java
Patch:
@@ -143,7 +143,8 @@ default String join(CharSequence delimiter) {
     default String join(CharSequence delimiter,
                         CharSequence prefix,
                         CharSequence suffix) {
-        return prefix + map(Objects::toString).reduceLeft((s1,s2) -> s1 + delimiter + s2) + suffix;
+        final Foldable<String, ?, ?> mapped = map(Objects::toString);
+        return prefix + (mapped.isEmpty() ? "" : mapped.reduceLeft((s1,s2) -> s1 + delimiter + s2)) + suffix;
     }
 
     // -- creational operations

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -351,7 +351,7 @@ default Stream<E> remove(E element) {
      * @return A Stream containing all of this elements except the given elements.
      */
     default Stream<E> removeAll(Iterable<? extends E> elements) {
-        final Stream<? extends E> distinct = Stream.of(elements).distinct();
+        final Stream<E> distinct = Stream.of(elements).distinct();
         return filter(distinct::contains);
     }
 

File: src/main/java/javaslang/collection/Tree.java
Patch:
@@ -123,7 +123,7 @@ public boolean equals(Object o) {
             if (o == this) {
                 return true;
             }
-            if (o == null || getClass().isAssignableFrom(o.getClass())) {
+            if (o == null || !getClass().isAssignableFrom(o.getClass())) {
                 return false;
             } else {
                 final Tree<?, ?> that = (Tree<?, ?>) o;

File: src/main/java/javaslang/match/Match.java
Patch:
@@ -156,7 +156,7 @@ public static interface ShortFunction<R> {
 	public static class Builder<R> extends OrElseBuilder<R> {
 
 		private final List<Function<Object, Option<R>>> cases = new ArrayList<>();
-		private Option<Supplier<R>> defaultOption = Option.empty();
+		private Option<Supplier<R>> defaultOption = Option.none();
 
 		/**
 		 * Use this method to match by object type T. An object o matches this case, if

File: src/main/java/javaslang/match/Pattern.java
Patch:
@@ -88,7 +88,7 @@ public Option<Tuple2<T, R>> apply(Object obj) {
 		if (prototype.equals(components)) {
 			return Option.of(Tuple.of(t, components));
 		} else {
-			return Option.empty();
+			return Option.none();
 		}
 	}
 

File: src/test/java/javaslang/collection/FoldableTest.java
Patch:
@@ -602,9 +602,9 @@ public Seq<Tuple.Tuple2<T, Integer>> zipWithIndex() {
         }
 
         @Override
-        public <T1, T2> Tuple.Tuple2<Seq<T1>, Seq<T2>> unzip(Function<T, Tuple.Tuple2<T1, T2>> unzipper) {
+        public <T1, T2> Tuple.Tuple2<Seq<T1>, Seq<T2>> unzip(Function<? super T, Tuple.Tuple2<T1, T2>> unzipper) {
             //noinspection unchecked
-            return Foldable.super.unzip(unzipper);
+            return (Tuple.Tuple2<Seq<T1>, Seq<T2>>) Foldable.super.unzip(unzipper);
         }
 
         // -- equals, hashCode & toString

File: src/main/java/javaslang/Algebra.java
Patch:
@@ -102,14 +102,15 @@ static interface Functor<A> {
 	 * @param <A> Component type of this monad.
 	 * @param <M> Type of Monad implementation.
 	 */
-	static interface Monad<A, M extends Monad<?, M>> extends Functor<A> {
+	static interface Monad<A, M extends Monad<?, M>> extends Manifest<A, M>, Functor<A> {
 
 		<B> Monad<B, M> unit(B b);
 
-		<B, MONAD extends Monad<B, M>> Monad<B, M> flatMap(Function<? super A, MONAD> f);
+		<B, MONAD extends Manifest<B, M>> Monad<B, M> flatMap(Function<? super A, MONAD> f);
 
 		@Override
 		default <B> Monad<B, M> map(Function<? super A, ? extends B> f) {
+			//noinspection unchecked
 			return flatMap(a -> unit(f.apply(a)));
 		}
 

File: src/main/java/javaslang/Strings.java
Patch:
@@ -309,7 +309,7 @@ private static String toString(Object o, Set<Object> visited) {
         } else if (o.getClass().getName().startsWith("javaslang.")) {
             return o.toString();
         } else if (o instanceof Iterable) {
-            return toString(Stream.of((Iterable<?>) o), ", ", o.getClass().getSimpleName() + "(", ")", visited, o);
+            return toString(StreamSupport.stream(((Iterable<?>) o).spliterator(), false), ", ", o.getClass().getSimpleName() + "(", ")", visited, o);
         } else {
             return o.toString();
         }

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -58,7 +58,7 @@
  * 
  * @param <E> Component type of the List.
  */
-public interface List<E> extends Foldable<E,List<?>, List<E>> {
+public interface List<E> extends Foldable<E, List<?>, List<E>>, Algebra.Monad<E, List<?>>, Algebra.Monoid<List<E>> {
 
 	/**
 	 * Returns the first element of this List in O(1).

File: src/main/java/javaslang/Strings.java
Patch:
@@ -21,9 +21,8 @@
 import java.util.function.IntFunction;
 import java.util.stream.Collectors;
 
+import javaslang.Tuple.Tuple2;
 import javaslang.collection.Stream;
-import javaslang.collection.Tuple;
-import javaslang.collection.Tuple.Tuple2;
 import javaslang.match.Match;
 
 /**

File: src/main/java/javaslang/Tuple.java
Patch:
@@ -3,7 +3,7 @@
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0
  */
-package javaslang.collection;
+package javaslang;
 
 import java.io.Serializable;
 import java.util.Objects;

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -32,7 +32,8 @@
 
 import javaslang.Requirements.UnsatisfiedRequirementException;
 import javaslang.Strings;
-import javaslang.collection.Tuple.Tuple2;
+import javaslang.Tuple;
+import javaslang.Tuple.Tuple2;
 
 /**
  * An immutable List implementation, suitable for concurrent programming.
@@ -1313,6 +1314,5 @@ public int hashCode() {
 		public String toString() {
 			return stream().map(Strings::toString).collect(joining(", ", "List(", ")"));
 		}
-
 	}
 }

File: src/main/java/javaslang/collection/Stream.java
Patch:
@@ -31,7 +31,8 @@
 import java.util.stream.LongStream;
 import java.util.stream.StreamSupport;
 
-import javaslang.collection.Tuple.Tuple2;
+import javaslang.Tuple;
+import javaslang.Tuple.Tuple2;
 
 /**
  * IStream is an Iterable Stream implementation providing methods which require a guaranteed sequential order of

File: src/main/java/javaslang/collection/package-info.java
Patch:
@@ -1,5 +1,4 @@
 /**
- * Contains immutable implementations of List and Tree. Provides extension methods Set.
+ * TODO
  */
-package javaslang.collection;
-
+package javaslang.collection;
\ No newline at end of file

File: src/main/java/javaslang/lambda/package-info.java
Patch:
@@ -1,5 +1,4 @@
 /**
  * TODO
  */
-package javaslang.lambda;
-
+package javaslang.lambda;
\ No newline at end of file

File: src/main/java/javaslang/match/Decomposition.java
Patch:
@@ -5,7 +5,7 @@
  */
 package javaslang.match;
 
-import javaslang.collection.Tuple;
+import javaslang.Tuple;
 import javaslang.lambda.Reflective;
 
 /**

File: src/main/java/javaslang/match/Match.java
Patch:
@@ -17,12 +17,12 @@
 import java.util.function.Supplier;
 
 import javaslang.Requirements.UnsatisfiedRequirementException;
-import javaslang.collection.Tuple;
+import javaslang.Tuple;
 import javaslang.lambda.Lambda.1;
 import javaslang.lambda.Lambda.2;
-import javaslang.monad.None;
 import javaslang.monad.Option;
-import javaslang.monad.Some;
+import javaslang.monad.Option.None;
+import javaslang.monad.Option.Some;
 
 /**
  * A better switch for Java. A Match...

File: src/main/java/javaslang/match/Matchs.java
Patch:
@@ -9,7 +9,7 @@
 import java.util.function.IntFunction;
 import java.util.function.LongFunction;
 
-import javaslang.collection.Tuple;
+import javaslang.Tuple;
 import javaslang.lambda.Lambda.1;
 import javaslang.lambda.Lambda.2;
 import javaslang.match.Match.BooleanFunction;

File: src/main/java/javaslang/match/Patterns.java
Patch:
@@ -7,9 +7,9 @@
 
 import java.lang.invoke.MethodType;
 
-import javaslang.collection.Tuple;
-import javaslang.collection.Tuple.Tuple1;
-import javaslang.collection.Tuple.Tuple2;
+import javaslang.Tuple;
+import javaslang.Tuple.Tuple1;
+import javaslang.Tuple.Tuple2;
 import javaslang.lambda.Lambda.1;
 
 public final class Patterns {

File: src/test/java/javaslang/StringsTest.java
Patch:
@@ -10,7 +10,6 @@
 import java.util.Arrays;
 
 import javaslang.Requirements.UnsatisfiedRequirementException;
-import javaslang.collection.Tuple;
 
 import org.junit.Test;
 

File: src/test/java/javaslang/lambda/ReflectiveTest.java
Patch:
@@ -6,8 +6,8 @@
 package javaslang.lambda;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import javaslang.collection.Tuple;
-import javaslang.collection.Tuple.Tuple3;
+import javaslang.Tuple;
+import javaslang.Tuple.Tuple3;
 
 import org.junit.Test;
 

File: src/test/java/javaslang/match/MatchTest.java
Patch:
@@ -13,7 +13,7 @@
 
 import javaslang.AssertionsExtensions;
 import javaslang.lambda.Lambda.1;
-import javaslang.monad.Some;
+import javaslang.monad.Option.Some;
 
 import org.junit.Test;
 

File: src/test/java/javaslang/match/PatternTest.java
Patch:
@@ -10,8 +10,8 @@
 import java.util.function.Function;
 
 import javaslang.AssertionsExtensions;
-import javaslang.collection.Tuple;
-import javaslang.collection.Tuple.Tuple2;
+import javaslang.Tuple;
+import javaslang.Tuple.Tuple2;
 import javaslang.lambda.Lambda.1;
 
 import org.junit.Test;

File: src/test/java/javaslang/monad/EitherTest.java
Patch:
@@ -15,7 +15,9 @@
 
 import javaslang.AssertionsExtensions;
 import javaslang.AssertionsExtensions.CheckedRunnable;
+import javaslang.monad.Either.Left;
 import javaslang.monad.Either.LeftProjection;
+import javaslang.monad.Either.Right;
 import javaslang.monad.Either.RightProjection;
 
 import org.junit.Test;

File: src/test/java/javaslang/monad/OptionTest.java
Patch:
@@ -12,6 +12,8 @@
 
 import javaslang.AssertionsExtensions;
 import javaslang.Serializables;
+import javaslang.monad.Option.None;
+import javaslang.monad.Option.Some;
 
 import org.junit.Test;
 

File: src/main/java/javaslang/match/Decomposition.java
Patch:
@@ -5,9 +5,8 @@
  */
 package javaslang.match;
 
-import java.io.Serializable;
-
 import javaslang.collection.Tuple;
+import javaslang.lambda.Reflective;
 
 /**
  * Interface for object decomposition, simmilar to Scala's {@code unapply()}. A Tuple serves as container type for the
@@ -18,7 +17,7 @@
  */
 // DEV-NOTE: Serializable & @FunctionalInterface to be compatible with {@link javaslang.Lambdas#getLambdaSignature(Serializable)}
 @FunctionalInterface
-public interface Decomposition<T, R extends Tuple> extends Serializable {
+public interface Decomposition<T, R extends Tuple> extends Reflective {
 
 	/**
 	 * Performs the decomposition.

File: src/main/java/javaslang/match/Pattern.java
Patch:
@@ -23,7 +23,6 @@
 import javaslang.collection.Tuple.Tuple7;
 import javaslang.collection.Tuple.Tuple8;
 import javaslang.collection.Tuple.Tuple9;
-import javaslang.lambda.Lambdas;
 import javaslang.monad.Option;
 
 /**
@@ -181,7 +180,7 @@ private static <T, P extends Tuple, R extends Tuple> Pattern<T, P, R> create(Dec
 		requireNonNull(decomposition, "decomposition is null");
 		requireNonNull(prototype, "prototype is null");
 
-		final MethodType methodType = Lambdas.getLambdaSignature(decomposition).get();
+		final MethodType methodType = decomposition.getLambdaSignature();
 		@SuppressWarnings("unchecked")
 		final Class<T> type = (Class<T>) methodType.parameterType(methodType.parameterCount() - 1);
 

File: src/test/java/javaslang/match/MatchTest.java
Patch:
@@ -12,7 +12,7 @@
 import java.util.function.Function;
 
 import javaslang.AssertionsExtensions;
-import javaslang.lambda.Functions.Function1;
+import javaslang.lambda.Lambda.1;
 import javaslang.monad.Some;
 
 import org.junit.Test;
@@ -411,7 +411,7 @@ public void shouldMatchLambdaConsideringTypeHierarchy() {
 
 	@Test
 	public void shouldPatternMatchLambdaWithSameSignature() {
-		final Function1<Integer, String> lambda = i -> String.valueOf(i);
+		final 1<Integer, String> lambda = i -> String.valueOf(i);
 		final boolean actual = Matchs
 				.caze(Patterns.Function(Integer.class, String.class), (f, dF) -> true)
 				.orElse(() -> false)
@@ -421,7 +421,7 @@ public void shouldPatternMatchLambdaWithSameSignature() {
 
 	@Test
 	public void shouldNotPatternMatchLambdaWithDifferentSignature() {
-		final Function1<String, String> lambda = s -> s;
+		final 1<String, String> lambda = s -> s;
 		final boolean actual = Matchs
 				.caze(Patterns.Function(Integer.class, String.class), (f, dF) -> false)
 				.orElse(() -> true)

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -32,7 +32,7 @@
 
 import javaslang.Requirements.UnsatisfiedRequirementException;
 import javaslang.Strings;
-import javaslang.collection.Interfaces.Foldable;
+import javaslang.collection.Iterfaces.Foldable;
 import javaslang.collection.Tuple.Tuple2;
 
 /**

File: src/main/java/javaslang/collection/TreeLikeStructure.java
Patch:
@@ -134,7 +134,7 @@ default TREE detach(TREE tree) {
 	 * @param <T> value type of this tree structure
 	 * @param <TREE> type of the tree structure implementation
 	 */
-	static abstract class AbstractTreeLikeStructure<T, TREE extends AbstractTreeLikeStructure<T, ?>> implements
+	static abstract class AbstractTreeLikeStructure<T, TREE extends AbstractTreeLikeStructure<T, TREE>> implements
 			TreeLikeStructure<T, TREE> {
 
 		@Override
@@ -181,14 +181,14 @@ public String toLispString() {
 			return getClass().getSimpleName() + (isLeaf() ? "(" + string + ")" : string);
 		}
 
-		private String internalToLispString() {
+		protected String internalToLispString() {
 			final String value = Strings.toString(getValue()).replaceAll("\\s+", " ").trim();
 			if (isLeaf()) {
 				return value;
 			} else {
 				final String children = getChildren()
 						.stream()
-						.map(AbstractTreeLikeStructure::internalToLispString)
+						.map(child -> child.internalToLispString())
 						.collect(joining(" "));
 				return String.format("(%s %s)", value, children);
 			}

File: src/test/java/javaslang/lambda/FunctionsTest.java
Patch:
@@ -93,7 +93,7 @@ public void shouldGetMethodTypeOfTupledFunction1() {
 
 	@Test
 	public void shouldGetMethodTypeOfFunction2() {
-		final Function2<?, ?, ?> lambda = (o1, o2) -> o1;
+		final Function2<Object, Object, Object> lambda = (o1, o2) -> o1;
 		final MethodType actual = Lambdas.getLambdaSignature(lambda).get();
 		final MethodType expected = MethodType.fromMethodDescriptorString(
 				"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;", getClass().getClassLoader());
@@ -102,7 +102,7 @@ public void shouldGetMethodTypeOfFunction2() {
 
 	@Test
 	public void shouldGetMethodTypeOfCurriedFunction2() {
-		final Function2<?, ?, ?> lambda = (o1, o2) -> o1;
+		final Function2<Object, Object, Object> lambda = (o1, o2) -> o1;
 		final MethodType actual = Lambdas.getLambdaSignature(lambda.curried()).get();
 		final MethodType expected = MethodType.fromMethodDescriptorString(
 				"(Ljava/lang/Object;)Ljavaslang/lambda/Functions$Function1;", getClass().getClassLoader());
@@ -111,7 +111,7 @@ public void shouldGetMethodTypeOfCurriedFunction2() {
 
 	@Test
 	public void shouldGetMethodTypeOfTupledFunction2() {
-		final Function2<?, ?, ?> lambda = (o1, o2) -> o1;
+		final Function2<Object, Object, Object> lambda = (o1, o2) -> o1;
 		final MethodType actual = Lambdas.getLambdaSignature(lambda.tupled()).get();
 		final MethodType expected = MethodType.fromMethodDescriptorString(
 				"(Ljavaslang/collection/Tuple$Tuple2;)Ljava/lang/Object;", getClass().getClassLoader());

File: src/main/java/javaslang/Strings.java
Patch:
@@ -21,8 +21,9 @@
 import java.util.function.IntFunction;
 import java.util.stream.Collectors;
 
-import javaslang.Tuples.Tuple2;
 import javaslang.collection.Stream;
+import javaslang.collection.Tuple;
+import javaslang.collection.Tuple.Tuple2;
 import javaslang.match.Match;
 
 /**
@@ -159,7 +160,7 @@ public static Tuple2<Integer, Integer> lineAndColumn(String s, int index) {
 		final String text = requireNonNull(s, "s is null").substring(0, index);
 		final int line = ("$" + text + "$").split("\\r\\n|\\n|\\r").length;
 		final int column = text.length() - Math.max(text.lastIndexOf("\r"), text.lastIndexOf("\n"));
-		return Tuples.of(line, column);
+		return Tuple.of(line, column);
 	}
 
 	/**

File: src/main/java/javaslang/match/Decomposition.java
Patch:
@@ -7,7 +7,7 @@
 
 import java.io.Serializable;
 
-import javaslang.Tuples.Tuple;
+import javaslang.collection.Tuple;
 
 /**
  * Interface for object decomposition, simmilar to Scala's {@code unapply()}. A Tuple serves as container type for the

File: src/main/java/javaslang/match/Match.java
Patch:
@@ -17,7 +17,7 @@
 import java.util.function.Supplier;
 
 import javaslang.Requirements.UnsatisfiedRequirementException;
-import javaslang.Tuples.Tuple;
+import javaslang.collection.Tuple;
 import javaslang.lambda.Functions.Function1;
 import javaslang.lambda.Functions.Function2;
 import javaslang.lambda.Lambdas;

File: src/main/java/javaslang/match/Matchs.java
Patch:
@@ -9,7 +9,7 @@
 import java.util.function.IntFunction;
 import java.util.function.LongFunction;
 
-import javaslang.Tuples.Tuple;
+import javaslang.collection.Tuple;
 import javaslang.lambda.Functions.Function1;
 import javaslang.lambda.Functions.Function2;
 import javaslang.match.Match.BooleanFunction;

File: src/main/java/javaslang/parser/Token.java
Patch:
@@ -73,6 +73,6 @@ public int hashCode() {
 
 	@Override
 	public String toString() {
-		return (id != null) ? id : (length > 0) ? "'" + getValue() + "'" : "<EOF>";
+		return (id != null) ? id : (length > 0) ? "'" + getValue() + "'" : (index == text.length()) ? "<EOF>" : "";
 	}
 }

File: src/main/java/javaslang/parser/Parser.java
Patch:
@@ -106,7 +106,7 @@
  * <h3>Lexer rules</h3>
  * 
  * <ul>
- * <li>Lexer rules (short: token) are the leafs of a parse tree.</li>
+ * <li>Lexer rules (short: token) produce the leafs of a parse tree.</li>
  * <li>They consist of a (non-empty) sequence of characters.</li>
  * <li>There is one empty token, {@code EOF}.</li>
  * <li>The name of a tokens is not part of the parse tree.</li>
@@ -119,7 +119,7 @@
  * <h3>Parser rules</h3>
  * 
  * <ul>
- * <li>Parser rules (short: rule) are the inner nodes of a parse tree.</li>
+ * <li>Parser rules (short: rule) produce the inner nodes of a parse tree.</li>
  * <li>They have a name and a non-empty list of children.</li>
  * <li>The name of a rule and it's children are part of the parse tree.</li>
  * <li>A rule name starts with a lower case character.</li>

File: src/main/java/javaslang/parser/Parser.java
Patch:
@@ -567,7 +567,7 @@ static class Sequence implements RulePart, HasChildren {
 		@SafeVarargs
 		Sequence(RulePart... parsers) {
 			requireNonNull(parsers, "parsers is null");
-			require(parsers.length >= 2, "number of parsers < 2");
+			require(parsers.length > 0, "no parsers");
 			this.parsers = parsers;
 		}
 

File: src/test/java/javaslang/parser/GrammarTest.java
Patch:
@@ -168,6 +168,8 @@ public void shouldParseGroupsWithWhitespace() {
 	}
 
 	@Test
+	@Ignore
+	// TODO(#58): FIXME
 	public void shouldParseRichStringWithoutEatingUpWhitespace() {
 		final String actual = new RichStringGrammar().parse("\"\"\" test \"\"\"").get().toString();
 		final String expected = "Tree(richString '\"\"\"' ' test ' '\"\"\"')";

File: src/main/java/javaslang/parser/Parser.java
Patch:
@@ -14,7 +14,6 @@
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 import java.util.function.Predicate;
@@ -700,8 +699,7 @@ public String toString() {
 	// terminal token / leaf of the parse tree
 	static Either<Integer, ParseResult> token(String text, int index, int length) {
 		///* DEBUG */System.out.println(String.format("token(%s, %s): %s", index, index + length, text.substring(index, index + length)));
-		final List<Node<Token>> tokens = (length == 0) ? Collections.emptyList() : Arrays.asList(new Node<>(new Token(
-				null, text, index, length)));
+		final List<Node<Token>> tokens = Arrays.asList(new Node<>(new Token(null, text, index, length)));
 		final ParseResult parseResult = new ParseResult(tokens, index, index + length);
 		return new Right<>(parseResult);
 	}

File: src/main/java/javaslang/parser/Token.java
Patch:
@@ -73,6 +73,6 @@ public int hashCode() {
 
 	@Override
 	public String toString() {
-		return (id == null) ? "'" + getValue() + "'" : id;
+		return (id != null) ? id : (length > 0) ? "'" + getValue() + "'" : "<EOF>";
 	}
 }

File: src/test/java/javaslang/parser/ParserTest.java
Patch:
@@ -577,7 +577,7 @@ public void shouldParseFirstAlternativeUsingSubrule() {
 	@Test
 	public void shouldParseSecondAlternativeUsingSubrule() {
 		final Subrule subrule = new Subrule(Any.INSTANCE, EOF.INSTANCE);
-		assertThat(subrule.parse("", 0, false).toString()).isEqualTo("Right([])");
+		assertThat(subrule.parse("", 0, false).toString()).isEqualTo("Right([Node(<EOF>)])");
 	}
 
 	@Test

File: src/main/java/javaslang/parser/Parser.java
Patch:
@@ -296,7 +296,7 @@ public Either<Integer, ParseResult> parse(String text, int index, boolean lex, b
 
 		@Override
 		public String toString() {
-			return "~" + parser.toString();
+			return "!" + parser.toString();
 		}
 	}
 

File: src/test/java/javaslang/parser/GrammarTest.java
Patch:
@@ -135,7 +135,7 @@ public void shouldCreateQuantifierTimes() {
 
 	@Test
 	public void shouldCreateNegation() {
-		assertThat(Grammar.not(Grammar.ANY).toString()).isEqualTo("~.");
+		assertThat(Grammar.not(Grammar.ANY).toString()).isEqualTo("!.");
 	}
 
 	@Test

File: src/test/java/javaslang/parser/ParserTest.java
Patch:
@@ -225,7 +225,7 @@ public void shouldNotParseLiteralIfNotMatching() {
 
 	@Test
 	public void shouldConvertNegationToString() {
-		assertThat(new Negation(Any.INSTANCE).toString()).isEqualTo("~.");
+		assertThat(new Negation(Any.INSTANCE).toString()).isEqualTo("!.");
 	}
 
 	@Test

File: src/main/java/javaslang/collection/List.java
Patch:
@@ -1068,7 +1068,7 @@ public boolean equals(Object o) {
 			if (o == this) {
 				return true;
 			}
-			if (o == null || !(o instanceof List)) {
+			if (!(o instanceof List)) {
 				return false;
 			} else {
 				List<?> list1 = this;

File: src/main/java/javaslang/monad/Either.java
Patch:
@@ -183,7 +183,7 @@ public boolean equals(Object obj) {
 			if (obj == this) {
 				return true;
 			}
-			if (obj == null || !(obj instanceof LeftProjection)) {
+			if (!(obj instanceof LeftProjection)) {
 				return false;
 			}
 			final LeftProjection<?, ?> other = (LeftProjection<?, ?>) obj;
@@ -289,7 +289,7 @@ public boolean equals(Object obj) {
 			if (obj == this) {
 				return true;
 			}
-			if (obj == null || !(obj instanceof RightProjection)) {
+			if (!(obj instanceof RightProjection)) {
 				return false;
 			}
 			final RightProjection<?, ?> other = (RightProjection<?, ?>) obj;

File: src/main/java/javaslang/monad/Failure.java
Patch:
@@ -120,7 +120,7 @@ public boolean equals(Object obj) {
 		if (obj == this) {
 			return true;
 		}
-		if (obj == null || !(obj instanceof Failure)) {
+		if (!(obj instanceof Failure)) {
 			return false;
 		}
 		final Failure<?> failure = (Failure<?>) obj;

File: src/main/java/javaslang/monad/Left.java
Patch:
@@ -33,7 +33,7 @@ public boolean equals(Object obj) {
 		if (obj == this) {
 			return true;
 		}
-		if (obj == null || !(obj instanceof Left)) {
+		if (!(obj instanceof Left)) {
 			return false;
 		}
 		final Left<?, ?> other = (Left<?, ?>) obj;

File: src/main/java/javaslang/monad/Right.java
Patch:
@@ -33,7 +33,7 @@ public boolean equals(Object obj) {
 		if (obj == this) {
 			return true;
 		}
-		if (obj == null || !(obj instanceof Right)) {
+		if (!(obj instanceof Right)) {
 			return false;
 		}
 		final Right<?, ?> other = (Right<?, ?>) obj;

File: src/main/java/javaslang/monad/Some.java
Patch:
@@ -88,7 +88,7 @@ public boolean equals(Object obj) {
 		if (obj == this) {
 			return true;
 		}
-		if (obj == null || !(obj instanceof Some)) {
+		if (!(obj instanceof Some)) {
 			return false;
 		}
 		final Some<?> other = (Some<?>) obj;

File: src/main/java/javaslang/monad/Success.java
Patch:
@@ -113,7 +113,7 @@ public boolean equals(Object obj) {
 		if (obj == this) {
 			return true;
 		}
-		if (obj == null || !(obj instanceof Success)) {
+		if (!(obj instanceof Success)) {
 			return false;
 		}
 		final Success<?> success = (Success<?>) obj;

File: src/main/java/javaslang/parser/Parser.java
Patch:
@@ -523,7 +523,7 @@ public Either<Integer, ParseResult> parse(String text, int index, boolean lex) {
 		public boolean equals(Object o) {
 			if (o == this) {
 				return true;
-			} else if (o == null || !(o instanceof Rule)) {
+			} else if (!(o instanceof Rule)) {
 				return false;
 			} else {
 				final String thatName = ((Rule) o).name;
@@ -772,7 +772,7 @@ Either<Integer, ParseResult> combine() {
 		public boolean equals(Object o) {
 			if (o == this) {
 				return true;
-			} else if (o == null || !(o instanceof ParseResult)) {
+			} else if (!(o instanceof ParseResult)) {
 				return false;
 			} else {
 				final ParseResult that = (ParseResult) o;

File: src/main/java/javaslang/parser/Token.java
Patch:
@@ -58,7 +58,7 @@ public String getValue() {
 	public boolean equals(Object obj) {
 		if (this == obj) {
 			return true;
-		} else if (obj == null || !(obj instanceof Token)) {
+		} else if (!(obj instanceof Token)) {
 			return false;
 		} else {
 			final Token other = (Token) obj;

File: src/test/java/javaslang/parser/ParserTest.java
Patch:
@@ -372,7 +372,7 @@ public void shouldParseFirstAlternativeUsingSubrule() {
 	@Test
 	public void shouldParseSecondAlternativeUsingSubrule() {
 		final Parser.Subrule subrule = new Parser.Subrule(Parser.Any.INSTANCE, Parser.EOF.INSTANCE);
-		assertThat(subrule.parse("", 0, false).toString()).isEqualTo("Right([Node(EOF)])");
+		assertThat(subrule.parse("", 0, false).toString()).isEqualTo("Right([])");
 	}
 
 	@Test

File: src/test/java/javaslang/match/PatternTest.java
Patch:
@@ -25,8 +25,6 @@ public void shouldNotInstantiable() {
 
 	// -- pattern creation
 
-/* TODO: !!!DO NOT COMMIT!!!
-
 	@Test
 	public void shouldCreatePatternOfArity1() {
 		assertThat(Pattern.of(t -> null, Tuples.of(1))).isNotNull();
@@ -91,7 +89,6 @@ public void shouldCreatePatternOfArity12() {
 	public void shouldCreatePatternOfArity13() {
 		assertThat(Pattern.of(t -> null, Tuples.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).isNotNull();
 	}
-*/
 	
 	// -- pattern matching
 

File: src/main/java/javaslang/parser/Grammar.java
Patch:
@@ -138,6 +138,7 @@ public Grammar(Supplier<Parser.Rule> startRuleSupplier) {
 	 * @param text A text input to be parsed.
 	 * @return A concrete syntax tree of the text on parse success or a failure if a parse error occured.
 	 */
+	// TODO: return Either instead of Try, where Right is the CST/parse tree and Left is a detailed ParseFailure description
 	public Try<Tree<Token>> parse(String text) {
 		final Either<Integer, List<Node<Token>>> parseResult = startRule.parse(text, 0, false);
 		if (parseResult.isRight()) {

File: src/test/java/javaslang/parser/ParserTest.java
Patch:
@@ -178,7 +178,7 @@ public void shouldParseTextUsingSequence() {
 
 	@Test
 	public void shouldConvertTokenToString() {
-		assertThat(new Token("id", 0, 0).toString()).isEqualTo("id[0,0]");
+		assertThat(new Token("id", "", 0, 0).toString()).isEqualTo("id");
 	}
 
 	// -- parse helpers
@@ -188,7 +188,7 @@ private String parse(Parser parser, String text, boolean lexer) {
 				.parse(text, 0, lexer)
 				.orElseThrow(i -> new AssertionError("no match at index " + i))
 				.stream()
-				.map(node -> node.getValue().asSubstringOf(text))
+				.map(node -> node.getValue().value())
 				.collect(Collectors.joining(" "));
 	}
 }

File: src/main/java/javaslang/collection/Node.java
Patch:
@@ -112,12 +112,12 @@ public Node<T> subtree() {
 
 	public Tree<T> asTree() {
 		final List<Tree<T>> treeChildren = children.stream().map(child -> asTree(child)).collect(List.collector());
-		return new Tree<>(null, value, treeChildren, TreeTransformer::keepParent, TreeTransformer::updateChildren);
+		return new Tree<>(null, value, treeChildren, TreeTransformer::identity, TreeTransformer::updateChildren);
 	}
 
 	// DEV-NOTE: omits updating parent and child refs / builds Tree in O(n)
 	private Tree<T> asTree(Node<T> node) {
 		final List<Tree<T>> treeChildren = node.children.stream().map(child -> asTree(child)).collect(List.collector());
-		return new Tree<>(null, node.value, treeChildren, TreeTransformer::keepParent, TreeTransformer::keepChildren);
+		return new Tree<>(null, node.value, treeChildren, TreeTransformer::identity, TreeTransformer::identity);
 	}
 }

File: src/main/java/javaslang/Serializables.java
Patch:
@@ -43,9 +43,10 @@ public static byte[] serialize(Object obj) {
 	 * @return IllegalStateException if an IOException occurs when reading from the ObjectInputStream or the serialized
 	 *         class cannot be found.
 	 */
-	public static Object deserialize(byte[] objectData) {
+	@SuppressWarnings("unchecked")
+	public static <T> T deserialize(byte[] objectData) {
 		try (ObjectInputStream stream = new ObjectInputStream(new ByteArrayInputStream(objectData))) {
-			return stream.readObject();
+			return (T) stream.readObject();
 		} catch (IOException | ClassNotFoundException x) {
 			throw new IllegalStateException("Error deserializing object", x);
 		}

File: src/main/java/javaslang/collection/Tree.java
Patch:
@@ -131,8 +131,8 @@ public List<Tree<T>> getChildren() {
 
 	@Override
 	public Tree<T> setChildren(Iterable<Tree<T>> children) {
-		return new Tree<>(parent, value, List.of(children), TreeTransformer.updateParent(this),
-				TreeTransformer::updateChildren);
+		final List<Tree<T>> childList = List.of(children);
+		return new Tree<>(parent, value, childList, TreeTransformer.updateParent(this), TreeTransformer::updateChildren);
 	}
 
 	// -- operations

File: src/test/java/javaslang/IOTest.java
Patch:
@@ -45,7 +45,7 @@ public void shouldLoadSystemResourceUsingDefaultCharset() {
 
 	@Test
 	public void shouldLoadSystemResourceUsingSpecificCharset() {
-		final String actual = new String(IO.loadResource("javaslang/resource.txt").get(), Charset.forName("iso-8859-1"));
+		final String actual = IO.loadResource("javaslang/resource.txt", Charset.forName("iso-8859-1")).get();
 		final String expected = " \n( )\n/ \\";
 		assertThat(actual).isEqualTo(expected);
 	}

File: src/main/java/javaslang/Strings.java
Patch:
@@ -89,7 +89,7 @@ public static String repeat(char c, int n) {
 			return "";
 		} else {
 			final char[] buf = new char[n];
-			fill(buf, ' ');
+			fill(buf, c);
 			return String.valueOf(buf);
 		}
 	}

File: src/test/java/javaslang/RequirementsTest.java
Patch:
@@ -35,13 +35,13 @@ public void shouldPassOnRequireWithMessageWhenConditionIsTrue() {
 
 	@Test
 	public void shouldThrowOnRequireWithMessageSupplierWhenConditionIsFalse() {
-		assertThat(() -> Requirements.require(false, "false")).isThrowing(UnsatisfiedRequirementException.class,
+		assertThat(() -> Requirements.require(false, () -> "false")).isThrowing(UnsatisfiedRequirementException.class,
 				"false");
 	}
 
 	@Test
 	public void shouldPassOnRequireWithMessageSupplierWhenConditionIsTrue() {
-		Requirements.require(true, "");
+		Requirements.require(true, () -> "");
 	}
 
 	// -- requireNonNull(obj)

File: src/main/java/javaslang/exception/Failure.java
Patch:
@@ -69,12 +69,12 @@ public <X extends Throwable> T orElseThrow(Function<Throwable, X> exceptionProvi
 	}
 
 	@Override
-	public Try<T> recover(Function<? super Throwable, ? extends T> f) {
+	public Try<T> recover(Function<Throwable, ? extends T> f) {
 		return Try.of(() -> f.apply(cause.getCause()));
 	}
 
 	@Override
-	public Try<T> recoverWith(Function<? super Throwable, Try<T>> f) {
+	public Try<T> recoverWith(Function<Throwable, Try<T>> f) {
 		try {
 			return f.apply(cause.getCause());
 		} catch (Throwable t) {

File: src/main/java/javaslang/exception/Success.java
Patch:
@@ -56,12 +56,12 @@ public <X extends Throwable> T orElseThrow(Function<Throwable, X> exceptionProvi
 	}
 
 	@Override
-	public Try<T> recover(Function<? super Throwable, ? extends T> f) {
+	public Try<T> recover(Function<Throwable, ? extends T> f) {
 		return this;
 	}
 
 	@Override
-	public Try<T> recoverWith(Function<? super Throwable, Try<T>> f) {
+	public Try<T> recoverWith(Function<Throwable, Try<T>> f) {
 		return this;
 	}
 

File: src/main/java/javaslang/exception/Try.java
Patch:
@@ -38,9 +38,9 @@ static <T> Try<T> of(Try.CheckedSupplier<T> supplier) {
 
 	<X extends Throwable> T orElseThrow(Function<Throwable, X> exceptionProvider) throws X;
 
-	Try<T> recover(Function<? super Throwable, ? extends T> f);
+	Try<T> recover(Function<Throwable, ? extends T> f);
 
-	Try<T> recoverWith(Function<? super Throwable, Try<T>> f);
+	Try<T> recoverWith(Function<Throwable, Try<T>> f);
 
 	Option<T> toOption();
 

File: src/test/java/javaslang/Assertions.java
Patch:
@@ -66,8 +66,6 @@ public void isThrowing(Class<? extends Throwable> expectedException, String expe
 			try {
 				test.run();
 				throw new AssertionError(expectedException.getName() + " not thrown");
-			} catch (AssertionError x) {
-				throw x;
 			} catch (Throwable x) {
 				if (!expectedException.isAssignableFrom(x.getClass())) {
 					throw new AssertionError("Expected exception assignable to type "

File: src/main/java/javaslang/lambda/Lambdas.java
Patch:
@@ -49,8 +49,8 @@ public static Try<SerializedLambda> getSerializedLambda(Serializable lambda) {
 	 * functional interface is generic and the parameter and/or return types cannot be determined directly.
 	 * <p>
 	 * Uses internally the {@link java.lang.invoke.SerializedLambda#getImplMethodSignature()} by parsing the JVM field
-	 * types of the method signature. The result is a {@link LambdaSignature} which contains the return type and the
-	 * parameter types of the given lambda.
+	 * types of the method signature. The result is a {@link java.lang.invoke.MethodType} which contains the return type
+	 * and the parameter types of the given lambda.
 	 * 
 	 * @param lambda A serializable lambda.
 	 * @return The signature of the lambda wrapped in a {@link javaslang.exception.Success}, or a

File: src/main/java/javaslang/match/Patterns.java
Patch:
@@ -39,7 +39,7 @@ private Patterns() {
 	 * This Pattern matches by the signature of a given function. The signature consists of a param type and a return
 	 * type.
 	 * 
-	 * @param <P> Function's argument type.
+	 * @param <T> Function's argument type.
 	 * @param <R> Function's result type.
 	 * @param paramType Argument type of the function.
 	 * @param returnType Return type of the function.

File: src/main/java/javaslang/match/Match.java
Patch:
@@ -346,7 +346,7 @@ protected void setDefault(Option<Supplier<R>> defaultOption) {
 		}
 
 		private Function<Object, Option<R>> caze(Option<?> prototype, SerializableFunction<?, R> function) {
-			return caze(prototype, function, Lambdas.getLambdaSignature(function).getParameterType(0));
+			return caze(prototype, function, Lambdas.getLambdaSignature(function).get().parameterType(0));
 		}
 
 		/**

File: src/main/java/javaslang/match/Pattern.java
Patch:
@@ -103,7 +103,7 @@ public static <T, P1, R1> Pattern<T, Tuple1<P1>, Tuple1<R1>> of(Decomposition<T,
 		requireNonNull(prototype, "prototype is null");
 
 		@SuppressWarnings("unchecked")
-		final Class<T> type = (Class<T>) Lambdas.getLambdaSignature(decomposition).getParameterType(0);
+		final Class<T> type = (Class<T>) Lambdas.getLambdaSignature(decomposition).get().parameterType(0);
 
 		return new Pattern<>(type, o -> decomposition, prototype);
 	}
@@ -115,7 +115,7 @@ public static <T, P1, P2, R1, R2> Pattern<T, Tuple2<P1, P2>, Tuple2<R1, R2>> of(
 		requireNonNull(prototype, "prototype is null");
 
 		@SuppressWarnings("unchecked")
-		final Class<T> type = (Class<T>) Lambdas.getLambdaSignature(decomposition).getParameterType(0);
+		final Class<T> type = (Class<T>) Lambdas.getLambdaSignature(decomposition).get().parameterType(0);
 
 		return new Pattern<>(type, o -> decomposition, prototype);
 	}

File: src/test/java/javaslang/match/PatternTest.java
Patch:
@@ -30,5 +30,4 @@ public void shouldMatchFunctionBySignature() {
 		final Tuple2<Class<Integer>, Class<String>> decomposition = match._2;
 		assertThat(decomposition).isEqualTo(Tuples.of(Integer.class, String.class));
 	}
-
 }

File: src/main/java/javaslang/lambda/Lambdas.java
Patch:
@@ -3,7 +3,7 @@
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0
  */
-package javaslang;
+package javaslang.lambda;
 
 import static java.util.stream.Collectors.joining;
 
@@ -18,6 +18,8 @@
 import java.util.regex.Pattern;
 import java.util.stream.Stream;
 
+import javaslang.Strings;
+import javaslang.Tuples;
 import javaslang.Tuples.Tuple2;
 
 /**

File: src/main/java/javaslang/match/Matchs.java
Patch:
@@ -10,12 +10,12 @@
 import java.util.function.LongFunction;
 
 import javaslang.Tuples.Tuple;
+import javaslang.lambda.SerializableBiFunction;
+import javaslang.lambda.SerializableFunction;
 import javaslang.match.Match.BooleanFunction;
 import javaslang.match.Match.ByteFunction;
 import javaslang.match.Match.CharFunction;
 import javaslang.match.Match.FloatFunction;
-import javaslang.match.Match.SerializableBiFunction;
-import javaslang.match.Match.SerializableFunction;
 import javaslang.match.Match.ShortFunction;
 
 /**

File: src/test/java/javaslang/lambda/LambdasTest.java
Patch:
@@ -3,14 +3,16 @@
  *  _/  // _\  \  \/  / _\  \\_  \/  // _\  \  /\  \__/  /   Copyright 2014 Daniel Dietrich
  * /___/ \_____/\____/\_____/____/\___\_____/_/  \_/____/    Licensed under the Apache License, Version 2.0
  */
-package javaslang;
+package javaslang.lambda;
 
 import static javaslang.Assertions.assertThat;
 import static org.fest.assertions.api.Assertions.assertThat;
 
 import java.io.Serializable;
 
+import javaslang.Tuples;
 import javaslang.Tuples.Tuple3;
+import javaslang.lambda.Lambdas;
 
 import org.junit.Test;
 

File: src/main/java/javaslang/collection/Sets.java
Patch:
@@ -5,7 +5,6 @@
  */
 package javaslang.collection;
 
-import static javaslang.Assertions.assertThat;
 import static javaslang.Requirements.requireNonNull;
 
 import java.util.HashSet;
@@ -20,7 +19,7 @@ public final class Sets {
 	 * This class is not intended to be instantiated.
 	 */
 	private Sets() {
-		assertThat(Sets.class).isNotInstantiable();
+		throw new AssertionError(Sets.class.getName() + " is not intended to be instantiated.");
 	}
 
 	/**

File: src/main/java/javaslang/option/None.java
Patch:
@@ -82,7 +82,7 @@ public void ifPresent(Consumer<? super T> consumer) {
 
 	@Override
 	public Option<T> filter(Predicate<? super T> predicate) {
-		// semantically correct but structurally the same that <code>return this;</code>
+		// semantically correct but structurally the same as <code>return this;</code>
 		return None.instance();
 	}
 

File: src/main/java/javaslang/Tuples.java
Patch:
@@ -837,7 +837,7 @@ public final int hashCode() {
 		 */
 		private static <T> T decycle(ThreadLocal<Boolean> isLocked, Supplier<T> value,
 				Supplier<T> defaultValue) {
-			if (isLocked.get()) {
+			if (Boolean.TRUE.equals(isLocked.get())) {
 				return defaultValue.get();
 			} else {
 				try {

File: src/main/java/javaslang/collection/EmptyList.java
Patch:
@@ -12,7 +12,7 @@
  * 
  * @param <T> Component type of the List.
  */
-public final class EmptyList<T> implements List<T> {
+public final class EmptyList<T> extends AbstractList<T> {
 	
 	private static final EmptyList<?> INSTANCE = new EmptyList<>();
 	

File: src/main/java/javaslang/lang/Strings.java
Patch:
@@ -247,7 +247,7 @@ public static String join(String[] strings, char separator, char escape) {
 	}
 
 	/**
-	 * Convenience method that calls {@link #concat(String[], char, char)} by converting the given
+	 * Convenience method that calls {@link #join(String[], char, char)} by converting the given
 	 * Collection strings to a String array.
 	 * 
 	 * @param strings A Collection of Strings, not null.

File: src/main/java/javaslang/collection/CollectionExtensions.java
Patch:
@@ -11,13 +11,13 @@
 /**
  * Additions to {@link java.util.Collections}.
  */
-public final class Collections {
+public final class CollectionExtensions {
 
 	/**
 	 * This class is not intendet to be instantiated.
 	 */
-	private Collections() {
-		throw new AssertionError(Collections.class.getName() + " cannot be instantiated.");
+	private CollectionExtensions() {
+		throw new AssertionError(CollectionExtensions.class.getName() + " cannot be instantiated.");
 	}
 
 	/**

File: src/main/java/javaslang/collection/Sets.java
Patch:
@@ -14,7 +14,7 @@
 /**
  * Extension methods for {@link java.util.Set}.
  */
-public class Sets {
+public final class Sets {
 
 	/**
 	 * This class is not intendet to be instantiated.
@@ -45,7 +45,7 @@ private Sets() {
 	 * @return A Set containing the given elements.
 	 */
 	@SafeVarargs
-	public static <T> Set<T> newSet(T... elements) {
+	public static <T> Set<T> of(T... elements) {
 		final Set<T> result = new HashSet<>(elements.length);
 		for (T element : elements) {
 			result.add(element);

File: src/main/java/javaslang/lang/Invocations.java
Patch:
@@ -24,7 +24,7 @@
  */
 public final class Invocations {
 
-	private static final Pattern JVM_FIELD_TYPE = Pattern.compile("\\[*B|C|D|F|I|J|L.*;|S|V|Z");
+	private static final Pattern JVM_FIELD_TYPE = Pattern.compile("\\[*(B|C|D|F|I|J|(L.*;)|S|V|Z)");
 
 	/**
 	 * This class is not intendet to be instantiated.

File: src/main/java/javaslang/lang/RuntimeExtenions.java
Patch:
@@ -9,13 +9,13 @@
 /**
  * Additions to {@link java.lang.Runtime}.
  */
-public final class Runtimes {
+public final class RuntimeExtenions {
 
 	/**
 	 * This class is not intendet to be instantiated.
 	 */
-	private Runtimes() {
-		throw new AssertionError(Runtimes.class.getName() + " cannot be instantiated.");
+	private RuntimeExtenions() {
+		throw new AssertionError(RuntimeExtenions.class.getName() + " cannot be instantiated.");
 	}
 
 	/**

File: src/main/java/javaslang/match/Match.java
Patch:
@@ -198,7 +198,6 @@ public Match<R> caze(ShortFunction<R> function) {
 	 * @throws MatchError if no Match case matches the given object.
 	 * @throws NonFatal if an error occurs executing the matched case.
 	 */
-	// FIXME: match (primitive) array types
 	@Override
 	public R apply(Object obj) {
 		for (Case<R> caze : cases) {

File: src/main/java/javaslang/text/Sequence.java
Patch:
@@ -16,7 +16,7 @@
 
 import javaslang.either.Either;
 import javaslang.either.Right;
-import javaslang.lang.Arrays;
+import javaslang.lang.ArrayExtensions;
 
 public class Sequence extends Parser {
 
@@ -28,14 +28,14 @@ public class Sequence extends Parser {
 
 	@SafeVarargs
 	Sequence(Supplier<Parser>... parsers) {
-		require(!Arrays.isNullOrEmpty(parsers), "no parsers");
+		require(!ArrayExtensions.isNullOrEmpty(parsers), "no parsers");
 		this.name = null;
 		this.parsers = parsers;
 	}
 
 	@SafeVarargs
 	Sequence(String name, Supplier<Parser>... parsers) {
-		require(!Arrays.isNullOrEmpty(parsers), "no parsers");
+		require(!ArrayExtensions.isNullOrEmpty(parsers), "no parsers");
 		this.name = name;
 		this.parsers = parsers;
 	}

File: src/main/java/javaslang/match/Match.java
Patch:
@@ -198,6 +198,7 @@ public Match<R> caze(ShortFunction<R> function) {
 	 * @throws MatchError if no Match case matches the given object.
 	 * @throws NonFatal if an error occurs executing the matched case.
 	 */
+	// FIXME: match (primitive) array types
 	@Override
 	public R apply(Object obj) {
 		for (Case<R> caze : cases) {

File: src/main/java/javaslang/text/Sequence.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.function.Supplier;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import java.util.stream.Stream;
 
 import javaslang.either.Either;
 import javaslang.either.Right;
@@ -45,7 +46,7 @@ public Either<Integer, Tree<Token>> parse(String text, int index) {
 		final String id = (name == null) ? "<Sequence>".intern() : name;
 		final Either<Integer, Tree<Token>> initial = new Right<>(new Tree<>(id, new Token(text,
 				index, index)));
-		return Arrays.stream(parsers).reduce(initial, (tree, parser) -> {
+		return Stream.of(parsers).reduce(initial, (tree, parser) -> {
 			if (tree.isLeft()) {
 				// first failure returned
 				return tree;

File: src/main/java/javaslang/text/package-info.java
Patch:
@@ -1,4 +1,4 @@
-/**                       ___ __          ,                   ___                                
+/**                                
  * TODO
  */
 package javaslang.text;

File: src/main/java/javaslang/either/Either.java
Patch:
@@ -38,7 +38,7 @@
  * 
  * <pre>
  * <code>
- * Either&lt;String,Integer&gt; value = compute().right().map(i -> i * 2);
+ * Either&lt;String,Integer&gt; value = compute().right().map(i -&gt; i * 2);
  * </code>
  * </pre>
  * 

File: src/main/java/javaslang/exception/package-info.java
Patch:
@@ -7,5 +7,7 @@
  * A Cause is unchecked, i.e. a RuntimeException, and is Fatal or NonFatal.
  * Fatal exceptions cannot be handled and are thrown without further processing.
  * NonFatal exceptions are wrapped in a Failure.
+ * 
+ * TODO
  */
 package javaslang.exception;

File: src/main/java/javaslang/io/package-info.java
Patch:
@@ -1,4 +1,6 @@
 /**
  * The io package contains classes for performing IO operations.
+ * 
+ * TODO
  */
 package javaslang.io;

File: src/main/java/javaslang/lang/package-info.java
Patch:
@@ -1,5 +1,7 @@
 /**
  * Elementary Java extensions, like ensuring interface requirements at runtime,
- * better print methods and stopping the JVM (even in the presence of deadlocks). 
+ * better print methods and stopping the JVM (even in the presence of deadlocks).
+ * 
+ * TODO
  */
 package javaslang.lang;

File: src/main/java/javaslang/match/package-info.java
Patch:
@@ -4,5 +4,7 @@
  * Patterns are types or prototype objects.
  * A matcher is stateless and reusable.
  * It represents an expression, i.e. applying an object results in a value.
+ * 
+ * TODO
  */
 package javaslang.match;

File: src/main/java/javaslang/option/package-info.java
Patch:
@@ -2,5 +2,7 @@
  * A replacement for java.util.Optional. An Option is either Some(value) or None.
  * <p>
  * In contrast to Optional, Option supports null values, i.e. it is possible to call <code>new Some(null)</code>.
+ * 
+ * TODO
  */
 package javaslang.option;

File: src/main/java/javaslang/collection/Collections.java
Patch:
@@ -29,6 +29,7 @@ public static boolean isNullOrEmpty(Collection<?> c) {
 	/**
 	 * Returns the last element of the given list.
 	 * 
+	 * @param <T> type of list elements
 	 * @param list A List, may be null or empty.
 	 * @return The last element of the list or null, if the list is null, empty or the last
 	 *         element is null.

File: src/main/java/javaslang/collection/Sets.java
Patch:
@@ -24,6 +24,7 @@ public static <T> Set<T> newSet(T... elements) {
 	 * Relative complement of sets, subtracting elements <code>set1 - set2</code>. Returns a new set, does not modify
 	 * set1 and set2.
 	 * 
+	 * @param <T> type of Set elements
 	 * @param set1 Starting set.
 	 * @param set2 Elements to be removed from set1.
 	 * @return All element of set1 which are not in set2.
@@ -40,6 +41,7 @@ public static <T> Set<T> complement(Set<T> set1, Set<T> set2) {
 	/**
 	 * Intersection of sets <code>set1</code> and <code>set2</code>. Returns a new set, does not modify set1 and set2.
 	 * 
+	 * @param <T> type of Set elements
 	 * @param set1 A set.
 	 * @param set2 Another set.
 	 * @return All elements which are in both of the given sets, set1 and set2.
@@ -56,6 +58,7 @@ public static <T> Set<T> intersection(Set<T> set1, Set<T> set2) {
 	/**
 	 * Union of sets, adding <code>set1 + set2</code>. Returns a new set, does not modify set1 and set2.
 	 * 
+	 * @param <T> type of Set elements
 	 * @param set1 A set.
 	 * @param set2 Another set.
 	 * @return The union of the given sets.

File: src/main/java/javaslang/util/Timers.java
Patch:
@@ -13,7 +13,9 @@ private Timers() {
 	 * Syntactic sugar, allows to call
 	 * 
 	 * <pre>
-	 * <code>final Timer timer = Timers.schedule(() -> println("hi"), 1000)</code>
+	 * <code>
+	 * final Timer timer = Timers.schedule(() -&gt; println("hi"), 1000)
+	 * </code>
 	 * </pre>
 	 * 
 	 * instead of

File: src/main/java/io/rocketscience/java/lang/Cause.java
Patch:
@@ -50,7 +50,7 @@ public Throwable get() {
 	 */
 	public static Cause of(Throwable t) {
 		require(t != null, "throwable is null");
-		final boolean isFatal = t instanceof VirtualMachineError//
+		final boolean isFatal = (t instanceof VirtualMachineError && !(t instanceof StackOverflowError))//
 				|| t instanceof ThreadDeath//
 				|| t instanceof InterruptedException//
 				|| t instanceof LinkageError;

File: src/main/java/io/rocketscience/java/util/Objects.java
Patch:
@@ -4,14 +4,12 @@
 import static java.lang.Boolean.TRUE;
 import static java.math.BigDecimal.ZERO;
 import static java.util.stream.Collectors.joining;
-import io.rocketscience.internal.Experimental;
 
 import java.math.BigDecimal;
 import java.util.Collection;
 import java.util.List;
 import java.util.Optional;
 
-@Experimental(reason="too many types recognized in conversion")
 public final class Objects {
 	
 	private Objects() {

File: src/main/java/io/rocketscience/java/util/Tree.java
Patch:
@@ -1,7 +1,6 @@
-package io.rocketscience.java.collection;
+package io.rocketscience.java.util;
 
 import static io.rocketscience.java.lang.Lang.require;
-import io.rocketscience.java.util.Strings;
 
 import java.util.ArrayList;
 import java.util.Collections;

