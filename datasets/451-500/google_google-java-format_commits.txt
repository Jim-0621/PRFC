File: core/src/main/java/com/google/googlejavaformat/java/StringWrapper.java
Patch:
@@ -225,7 +225,9 @@ private void indentTextBlocks(
           }
           if (i == lines.size() - 1) {
             String withoutDelimiter =
-                trimmed.substring(0, trimmed.length() - TEXT_BLOCK_DELIMITER.length());
+                trimmed
+                    .substring(0, trimmed.length() - TEXT_BLOCK_DELIMITER.length())
+                    .stripTrailing();
             if (!withoutDelimiter.stripLeading().isEmpty()) {
               output.append(withoutDelimiter).append('\\').append(separator).append(prefix);
             }

File: core/src/main/java/com/google/googlejavaformat/java/StringWrapper.java
Patch:
@@ -219,7 +219,7 @@ private void indentTextBlocks(
         StringBuilder output = new StringBuilder(initialLines.get(0).stripLeading());
         for (int i = 0; i < lines.size(); i++) {
           String line = lines.get(i);
-          String trimmed = line.stripLeading().stripTrailing();
+          String trimmed = line.stripTrailing();
           output.append(separator);
           if (!trimmed.isEmpty()) {
             // Don't add incidental leading whitespace to empty lines
@@ -228,7 +228,7 @@ private void indentTextBlocks(
           if (i == lines.size() - 1) {
             String withoutDelimiter =
                 trimmed.substring(0, trimmed.length() - TEXT_BLOCK_DELIMITER.length());
-            if (!withoutDelimiter.isEmpty()) {
+            if (!withoutDelimiter.stripLeading().isEmpty()) {
               output.append(withoutDelimiter).append('\\').append(separator).append(prefix);
             }
             // If the trailing line is just """, indenting it more than the prefix of incidental

File: core/src/test/java/com/google/googlejavaformat/java/FormatterIntegrationTest.java
Patch:
@@ -57,7 +57,8 @@ public class FormatterIntegrationTest {
               "ExpressionSwitch",
               "I574",
               "I594",
-              "SwitchComment")
+              "SwitchComment",
+              "B380299722")
           .putAll(15, "I603")
           .putAll(16, "I588", "Sealed")
           .putAll(17, "I683", "I684", "I696")

File: core/src/main/java/com/google/googlejavaformat/java/StringWrapper.java
Patch:
@@ -207,7 +207,8 @@ private void indentTextBlocks(
         String stripped = stripIndent(initialLines.stream().skip(1).collect(joining(separator)));
         ImmutableList<String> lines = stripped.lines().collect(toImmutableList());
         int deindent =
-            initialLines.get(1).stripTrailing().length() - lines.get(0).stripTrailing().length();
+            getLast(initialLines).stripTrailing().length()
+                - getLast(lines).stripTrailing().length();
 
         String prefix =
             (deindent == 0

File: core/src/main/java/com/google/googlejavaformat/java/java21/Java21InputAstVisitor.java
Patch:
@@ -15,7 +15,7 @@
 package com.google.googlejavaformat.java.java21;
 
 import com.google.googlejavaformat.OpsBuilder;
-import com.google.googlejavaformat.java.java17.Java17InputAstVisitor;
+import com.google.googlejavaformat.java.JavaInputAstVisitor;
 import com.sun.source.tree.CaseTree;
 import com.sun.source.tree.ConstantCaseLabelTree;
 import com.sun.source.tree.DeconstructionPatternTree;
@@ -28,10 +28,10 @@
 import javax.lang.model.element.Name;
 
 /**
- * Extends {@link Java17InputAstVisitor} with support for AST nodes that were added or modified in
+ * Extends {@link JavaInputAstVisitor} with support for AST nodes that were added or modified in
  * Java 21.
  */
-public class Java21InputAstVisitor extends Java17InputAstVisitor {
+public class Java21InputAstVisitor extends JavaInputAstVisitor {
 
   public Java21InputAstVisitor(OpsBuilder builder, int indentMultiplier) {
     super(builder, indentMultiplier);

File: core/src/main/java/com/google/googlejavaformat/java/StringWrapper.java
Patch:
@@ -205,7 +205,8 @@ private void indentTextBlocks(
             initialLines.get(1).stripTrailing().length() - lines.get(0).stripTrailing().length();
 
         String prefix =
-            (deindent == 0 || lines.stream().anyMatch(x -> x.length() + startColumn > columnLimit))
+            (deindent == 0
+                    || lines.stream().anyMatch(x -> x.length() + startColumn - 1 > columnLimit))
                 ? ""
                 : " ".repeat(startColumn - 1);
 

File: core/src/main/java/com/google/googlejavaformat/FormatterDiagnostic.java
Patch:
@@ -49,7 +49,7 @@ public int line() {
   }
 
   /**
-   * Returns the 0-indexed column number on which the error occurred, or {@code -1} if the error
+   * Returns the 1-indexed column number on which the error occurred, or {@code -1} if the error
    * does not have a column.
    */
   public int column() {
@@ -61,14 +61,14 @@ public String message() {
     return message;
   }
 
+  @Override
   public String toString() {
     StringBuilder sb = new StringBuilder();
     if (lineNumber >= 0) {
       sb.append(lineNumber).append(':');
     }
     if (column >= 0) {
-      // internal column numbers are 0-based, but diagnostics use 1-based indexing by convention
-      sb.append(column + 1).append(':');
+      sb.append(column).append(':');
     }
     if (lineNumber >= 0 || column >= 0) {
       sb.append(' ');

File: core/src/main/java/com/google/googlejavaformat/java/FormatterException.java
Patch:
@@ -69,7 +69,7 @@ public String formatDiagnostics(String path, String input) {
       if (line != -1 && column != -1) {
         sb.append(CharMatcher.breakingWhitespace().trimTrailingFrom(lines.get(line - 1)))
             .append(System.lineSeparator());
-        sb.append(" ".repeat(column)).append('^').append(System.lineSeparator());
+        sb.append(" ".repeat(column - 1)).append('^').append(System.lineSeparator());
       }
     }
     return sb.toString();

File: core/src/test/java/com/google/googlejavaformat/java/FormatterIntegrationTest.java
Patch:
@@ -72,8 +72,6 @@ public class FormatterIntegrationTest {
               "I981",
               "I1020",
               "I1037")
-          // TODO: https://github.com/google/google-java-format/issues/1153
-          // .putAll(23, "I1153")
           .build();
 
   @Parameters(name = "{index}: {0}")

File: core/src/test/java/com/google/googlejavaformat/java/FormatterIntegrationTest.java
Patch:
@@ -72,6 +72,8 @@ public class FormatterIntegrationTest {
               "I981",
               "I1020",
               "I1037")
+          // TODO: https://github.com/google/google-java-format/issues/1153
+          // .putAll(23, "I1153")
           .build();
 
   @Parameters(name = "{index}: {0}")

File: idea_plugin/src/main/java/com/google/googlejavaformat/intellij/InitialConfigurationStartupActivity.java
Patch:
@@ -27,8 +27,6 @@
 final class InitialConfigurationStartupActivity implements StartupActivity.Background {
 
   private static final String NOTIFICATION_TITLE = "Enable google-java-format";
-  private static final NotificationGroup NOTIFICATION_GROUP =
-      NotificationGroupManager.getInstance().getNotificationGroup(NOTIFICATION_TITLE);
 
   @Override
   public void runActivity(@NotNull Project project) {
@@ -43,9 +41,11 @@ public void runActivity(@NotNull Project project) {
   }
 
   private void displayNewUserNotification(Project project, GoogleJavaFormatSettings settings) {
+    NotificationGroupManager groupManager = NotificationGroupManager.getInstance();
+    NotificationGroup group = groupManager.getNotificationGroup(NOTIFICATION_TITLE);
     Notification notification =
         new Notification(
-            NOTIFICATION_GROUP.getDisplayId(),
+            group.getDisplayId(),
             NOTIFICATION_TITLE,
             "The google-java-format plugin is disabled by default. "
                 + "<a href=\"enable\">Enable for this project</a>.",

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -1875,10 +1875,10 @@ public Void visitCase(CaseTree node, Void unused) {
     markForPartialFormat();
     builder.forcedBreak();
     if (node.getExpression() == null) {
-      token("default", plusTwo);
+      token("default", ZERO);
       token(":");
     } else {
-      token("case", plusTwo);
+      token("case", ZERO);
       builder.space();
       scan(node.getExpression(), null);
       token(":");

File: core/src/test/java/com/google/googlejavaformat/java/FormatterIntegrationTest.java
Patch:
@@ -50,7 +50,7 @@ public class FormatterIntegrationTest {
       ImmutableMultimap.<Integer, String>builder()
           .putAll(14, "I477", "Records", "RSLs", "Var", "ExpressionSwitch", "I574", "I594")
           .putAll(15, "I603")
-          .putAll(16, "I588")
+          .putAll(16, "I588", "Sealed")
           .putAll(17, "I683", "I684", "I696")
           .putAll(
               21,

File: core/src/test/java/com/google/googlejavaformat/java/FormatterIntegrationTest.java
Patch:
@@ -61,10 +61,8 @@ public class FormatterIntegrationTest {
               "I880",
               "Unnamed",
               "I981",
-              "StringTemplate",
               "I1020",
-              "I1037",
-              "TextBlockTemplates")
+              "I1037")
           .build();
 
   @Parameters(name = "{index}: {0}")

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -1667,9 +1667,6 @@ public Void visitMemberSelect(MemberSelectTree node, Void unused) {
   public Void visitLiteral(LiteralTree node, Void unused) {
     sync(node);
     String sourceForNode = getSourceForNode(node, getCurrentPath());
-    if (sourceForNode.startsWith("\"\"\"")) {
-      builder.forcedBreak();
-    }
     if (isUnaryMinusLiteral(sourceForNode)) {
       token("-");
       sourceForNode = sourceForNode.substring(1).trim();

File: core/src/test/java/com/google/googlejavaformat/java/FormatterIntegrationTest.java
Patch:
@@ -62,7 +62,8 @@ public class FormatterIntegrationTest {
               "Unnamed",
               "I981",
               "StringTemplate",
-              "I1020")
+              "I1020",
+              "I1037")
           .build();
 
   @Parameters(name = "{index}: {0}")

File: core/src/test/java/com/google/googlejavaformat/java/FormatterIntegrationTest.java
Patch:
@@ -104,10 +104,9 @@ public static Iterable<Object[]> data() throws IOException {
       String expectedOutput = outputs.get(fileName);
       Optional<Integer> version =
           VERSIONED_TESTS.inverse().get(fileName).stream().collect(toOptional());
-      if (Runtime.version().feature() < version.orElse(Integer.MAX_VALUE)) {
-        continue;
+      if (Runtime.version().feature() >= version.orElse(Integer.MIN_VALUE)) {
+        testInputs.add(new Object[] {fileName, input, expectedOutput});
       }
-      testInputs.add(new Object[] {fileName, input, expectedOutput});
     }
     return testInputs;
   }

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -3475,14 +3475,15 @@ private static boolean expressionsAreParallel(
 
   // General helper functions.
 
-  enum DeclarationKind {
+  /** Kind of declaration. */
+  protected enum DeclarationKind {
     NONE,
     FIELD,
     PARAMETER
   }
 
   /** Declare one variable or variable-like thing. */
-  int declareOne(
+  protected int declareOne(
       DeclarationKind kind,
       Direction annotationsDirection,
       Optional<ModifiersTree> modifiers,

File: core/src/test/java/com/google/googlejavaformat/java/FormatterIntegrationTest.java
Patch:
@@ -61,7 +61,8 @@ public class FormatterIntegrationTest {
               "I880",
               "Unnamed",
               "I981",
-              "StringTemplate")
+              "StringTemplate",
+              "I1020")
           .build();
 
   @Parameters(name = "{index}: {0}")

File: core/src/test/java/com/google/googlejavaformat/java/FormatterIntegrationTest.java
Patch:
@@ -59,7 +59,8 @@ public class FormatterIntegrationTest {
               "SwitchDouble",
               "SwitchUnderscore",
               "I880",
-              "Unnamed")
+              "Unnamed",
+              "I981")
           .build();
 
   @Parameters(name = "{index}: {0}")

File: core/src/test/java/com/google/googlejavaformat/java/FormatterIntegrationTest.java
Patch:
@@ -52,7 +52,8 @@ public class FormatterIntegrationTest {
           .putAll(15, "I603")
           .putAll(16, "I588")
           .putAll(17, "I683", "I684", "I696")
-          .putAll(21, "SwitchGuardClause")
+          .putAll(
+              21, "SwitchGuardClause", "SwitchRecord", "SwitchDouble", "SwitchUnderscore", "I880")
           .build();
 
   @Parameters(name = "{index}: {0}")
@@ -94,7 +95,7 @@ public static Iterable<Object[]> data() throws IOException {
       String expectedOutput = outputs.get(fileName);
       Optional<Integer> version =
           VERSIONED_TESTS.inverse().get(fileName).stream().collect(toOptional());
-      if (version.isPresent() && Runtime.version().feature() < version.get()) {
+      if (Runtime.version().feature() < version.orElse(Integer.MAX_VALUE)) {
         continue;
       }
       testInputs.add(new Object[] {fileName, input, expectedOutput});

File: core/src/test/java/com/google/googlejavaformat/java/FormatterIntegrationTest.java
Patch:
@@ -52,6 +52,7 @@ public class FormatterIntegrationTest {
           .putAll(15, "I603")
           .putAll(16, "I588")
           .putAll(17, "I683", "I684", "I696")
+          .putAll(21, "SwitchGuardClause")
           .build();
 
   @Parameters(name = "{index}: {0}")

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -930,7 +930,6 @@ public boolean visitEnumDeclaration(ClassTree node) {
 
   @Override
   public Void visitMemberReference(MemberReferenceTree node, Void unused) {
-    sync(node);
     builder.open(plusFour);
     scan(node.getQualifierExpression(), null);
     builder.breakOp();

File: core/src/main/java/com/google/googlejavaformat/Doc.java
Patch:
@@ -19,6 +19,7 @@
 import static java.lang.Math.max;
 
 import com.google.common.base.MoreObjects;
+import com.google.common.base.Supplier;
 import com.google.common.base.Suppliers;
 import com.google.common.collect.DiscreteDomain;
 import com.google.common.collect.Iterators;
@@ -27,7 +28,6 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Optional;
-import java.util.function.Supplier;
 
 /**
  * {@link com.google.googlejavaformat.java.JavaInputAstVisitor JavaInputAstVisitor} outputs a

File: idea_plugin/src/main/java/com/google/googlejavaformat/intellij/GoogleJavaFormatFormattingService.java
Patch:
@@ -74,7 +74,7 @@ private static Formatter createFormatter(Style style, boolean canChangeWhiteSpac
 
   @Override
   public @NotNull Set<Feature> getFeatures() {
-    return Set.of(Feature.AD_HOC_FORMATTING, Feature.FORMAT_FRAGMENTS, Feature.OPTIMIZE_IMPORTS);
+    return Set.of(Feature.FORMAT_FRAGMENTS, Feature.OPTIMIZE_IMPORTS);
   }
 
   @Override

File: idea_plugin/src/main/java/com/google/googlejavaformat/intellij/GoogleJavaFormatSettings.java
Patch:
@@ -18,7 +18,6 @@
 
 import com.google.googlejavaformat.java.JavaFormatterOptions;
 import com.intellij.openapi.components.PersistentStateComponent;
-import com.intellij.openapi.components.ServiceManager;
 import com.intellij.openapi.components.State;
 import com.intellij.openapi.components.Storage;
 import com.intellij.openapi.project.Project;
@@ -39,7 +38,7 @@ class GoogleJavaFormatSettings implements PersistentStateComponent<GoogleJavaFor
   }
 
   static GoogleJavaFormatSettings getInstance(Project project) {
-    return ServiceManager.getService(project, GoogleJavaFormatSettings.class);
+    return project.getService(GoogleJavaFormatSettings.class);
   }
 
   @Nullable

File: core/src/main/java/com/google/googlejavaformat/java/Main.java
Patch:
@@ -79,7 +79,8 @@ static int main(PrintWriter out, PrintWriter err, String... args) {
       return formatter.format(args);
     } catch (UsageException e) {
       err.print(e.getMessage());
-      return 0;
+      // We return exit code 2 to differentiate usage issues from code formatting issues.
+      return 2;
     } finally {
       err.flush();
       out.flush();

File: core/src/test/java/com/google/googlejavaformat/java/GoogleJavaFormatToolProviderTest.java
Patch:
@@ -46,7 +46,7 @@ public void testUsageOutputAfterLoadingViaToolName() {
 
     int result = format.run(new PrintWriter(out, true), new PrintWriter(err, true), "--help");
 
-    assertThat(result).isEqualTo(0);
+    assertThat(result).isEqualTo(2);
 
     String usage = err.toString();
 

File: core/src/test/java/com/google/googlejavaformat/java/MainTest.java
Patch:
@@ -132,7 +132,7 @@ public void testMain() throws Exception {
     process.waitFor();
     String err = new String(ByteStreams.toByteArray(process.getErrorStream()), UTF_8);
     assertThat(err).contains("Usage: google-java-format");
-    assertThat(process.exitValue()).isEqualTo(0);
+    assertThat(process.exitValue()).isEqualTo(2);
   }
 
   // end to end javadoc formatting test

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -285,8 +285,10 @@ private static ImmutableSetMultimap<String, String> typeAnnotations() {
     ImmutableSetMultimap.Builder<String, String> result = ImmutableSetMultimap.builder();
     for (String annotation :
         ImmutableList.of(
+            "org.jspecify.annotations.NonNull",
             "org.jspecify.annotations.Nullable",
             "org.jspecify.nullness.Nullable",
+            "org.checkerframework.checker.nullness.qual.NonNull",
             "org.checkerframework.checker.nullness.qual.Nullable")) {
       String simpleName = annotation.substring(annotation.lastIndexOf('.') + 1);
       result.put(simpleName, annotation);

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -285,6 +285,7 @@ private static ImmutableSetMultimap<String, String> typeAnnotations() {
     ImmutableSetMultimap.Builder<String, String> result = ImmutableSetMultimap.builder();
     for (String annotation :
         ImmutableList.of(
+            "org.jspecify.annotations.Nullable",
             "org.jspecify.nullness.Nullable",
             "org.checkerframework.checker.nullness.qual.Nullable")) {
       String simpleName = annotation.substring(annotation.lastIndexOf('.') + 1);

File: core/src/main/java/com/google/googlejavaformat/Doc.java
Patch:
@@ -15,6 +15,7 @@
 package com.google.googlejavaformat;
 
 import static com.google.common.collect.Iterables.getLast;
+import static com.google.googlejavaformat.CommentsHelper.reformatParameterComment;
 import static java.lang.Math.max;
 
 import com.google.common.base.MoreObjects;
@@ -727,7 +728,7 @@ float computeWidth() {
           // Account for line comments with missing spaces, see computeFlat.
           return tok.length() + 1;
         } else {
-          return tok.length();
+          return reformatParameterComment(tok).map(String::length).orElse(tok.length());
         }
       }
       return idx != -1 ? Float.POSITIVE_INFINITY : (float) tok.length();
@@ -741,7 +742,7 @@ String computeFlat() {
       if (tok.isSlashSlashComment() && !tok.getOriginalText().startsWith("// ")) {
         return "// " + tok.getOriginalText().substring("//".length());
       }
-      return tok.getOriginalText();
+      return reformatParameterComment(tok).orElse(tok.getOriginalText());
     }
 
     @Override

File: core/src/main/java/com/google/googlejavaformat/java/StringWrapper.java
Patch:
@@ -96,7 +96,9 @@ static String wrap(final int columnLimit, String input, Formatter formatter)
       if (!expected.equals(actual)) {
         throw new FormatterException(
             String.format(
-                "Something has gone terribly wrong. Please file a bug: "
+                "Something has gone terribly wrong. We planned to make the below formatting change,"
+                    + " but have aborted because it would unexpectedly change the AST.\n"
+                    + "Please file a bug: "
                     + "https://github.com/google/google-java-format/issues/new"
                     + "\n\n=== Actual: ===\n%s\n=== Expected: ===\n%s\n",
                 actual, expected));

File: idea_plugin/src/com/google/googlejavaformat/intellij/FormatterUtil.java
Patch:
@@ -50,8 +50,7 @@ static Map<TextRange, String> getReplacements(
   }
 
   private static Collection<Range<Integer>> toRanges(Collection<? extends TextRange> textRanges) {
-    return textRanges
-        .stream()
+    return textRanges.stream()
         .map(textRange -> Range.closedOpen(textRange.getStartOffset(), textRange.getEndOffset()))
         .collect(Collectors.toList());
   }

File: idea_plugin/src/com/google/googlejavaformat/intellij/InitialConfigurationProjectManagerListener.java
Patch:
@@ -17,8 +17,8 @@
 package com.google.googlejavaformat.intellij;
 
 import com.intellij.notification.Notification;
-import com.intellij.notification.NotificationDisplayType;
 import com.intellij.notification.NotificationGroup;
+import com.intellij.notification.NotificationGroupManager;
 import com.intellij.notification.NotificationType;
 import com.intellij.openapi.project.Project;
 import com.intellij.openapi.project.ProjectManagerListener;
@@ -28,11 +28,10 @@ final class InitialConfigurationProjectManagerListener implements ProjectManager
 
   private static final String NOTIFICATION_TITLE = "Enable google-java-format";
   private static final NotificationGroup NOTIFICATION_GROUP =
-      new NotificationGroup(NOTIFICATION_TITLE, NotificationDisplayType.STICKY_BALLOON, true);
+      NotificationGroupManager.getInstance().getNotificationGroup(NOTIFICATION_TITLE);
 
   @Override
   public void projectOpened(@NotNull Project project) {
-
     GoogleJavaFormatSettings settings = GoogleJavaFormatSettings.getInstance(project);
 
     if (settings.isUninitialized()) {

File: core/src/test/java/com/google/googlejavaformat/java/FormatterIntegrationTest.java
Patch:
@@ -51,7 +51,7 @@ public class FormatterIntegrationTest {
           .putAll(14, "I477", "Records", "RSLs", "Var", "ExpressionSwitch", "I574", "I594")
           .putAll(15, "I603")
           .putAll(16, "I588")
-          .putAll(17, "I683", "I684")
+          .putAll(17, "I683", "I684", "I696")
           .build();
 
   @Parameters(name = "{index}: {0}")

File: core/src/test/java/com/google/googlejavaformat/java/MainTest.java
Patch:
@@ -322,7 +322,7 @@ public void packageInfo() throws Exception {
       "@ParametersAreNonnullByDefault",
       "package com.google.common.labs.base;",
       "",
-      "import javax.annotation.CheckReturnValue;",
+      "import com.google.errorprone.annotations.CheckReturnValue;",
       "import javax.annotation.ParametersAreNonnullByDefault;",
       "",
     };

File: core/src/main/java/com/google/googlejavaformat/java/RemoveUnusedImports.java
Patch:
@@ -146,7 +146,9 @@ public Void visitIdentifier(com.sun.source.doctree.IdentifierTree node, Void aVo
       public Void visitReference(ReferenceTree referenceTree, Void unused) {
         DCReference reference = (DCReference) referenceTree;
         long basePos =
-            reference.getSourcePosition((DCTree.DCDocComment) getCurrentPath().getDocComment());
+            reference
+                .pos((DCTree.DCDocComment) getCurrentPath().getDocComment())
+                .getStartPosition();
         // the position of trees inside the reference node aren't stored, but the qualifier's
         // start position is the beginning of the reference node
         if (reference.qualifierExpression != null) {

File: core/src/main/java/com/google/googlejavaformat/java/javadoc/JavadocWriter.java
Patch:
@@ -27,7 +27,6 @@
 import static com.google.googlejavaformat.java.javadoc.Token.Type.LIST_ITEM_OPEN_TAG;
 import static com.google.googlejavaformat.java.javadoc.Token.Type.PARAGRAPH_OPEN_TAG;
 
-import com.google.common.base.Strings;
 import com.google.common.collect.ImmutableSet;
 import com.google.googlejavaformat.java.javadoc.Token.Type;
 
@@ -395,7 +394,7 @@ private int innerIndent() {
 
   // If this is a hotspot, keep a String of many spaces around, and call append(string, start, end).
   private void appendSpaces(int count) {
-    output.append(Strings.repeat(" ", count));
+    output.append(" ".repeat(count));
   }
 
   /**

File: core/src/main/java/com/google/googlejavaformat/java/JavaFormatterOptions.java
Patch:
@@ -60,7 +60,7 @@ public int indentationMultiplier() {
     return style.indentationMultiplier();
   }
 
-  boolean formatJavadoc() {
+  public boolean formatJavadoc() {
     return formatJavadoc;
   }
 
@@ -91,7 +91,7 @@ public Builder style(Style style) {
       return this;
     }
 
-    Builder formatJavadoc(boolean formatJavadoc) {
+    public Builder formatJavadoc(boolean formatJavadoc) {
       this.formatJavadoc = formatJavadoc;
       return this;
     }

File: core/src/main/java/com/google/googlejavaformat/java/java14/Java14InputAstVisitor.java
Patch:
@@ -251,7 +251,7 @@ public Void visitCase(CaseTree node, Void unused) {
       token("default", plusTwo);
     } else {
       token("case", plusTwo);
-      builder.open(plusFour);
+      builder.open(node.getExpressions().size() > 1 ? plusFour : ZERO);
       builder.space();
       boolean first = true;
       for (ExpressionTree expression : node.getExpressions()) {

File: core/src/main/java/com/google/googlejavaformat/Input.java
Patch:
@@ -63,7 +63,7 @@ public interface Tok {
     /** Is the {@code Tok} a "//" comment? */
     boolean isSlashSlashComment();
 
-    /** Is the {@code Tok} a "//" comment? */
+    /** Is the {@code Tok} a "/*" comment? */
     boolean isSlashStarComment();
 
     /** Is the {@code Tok} a javadoc comment? */

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -376,11 +376,14 @@ public Void visitCompilationUnit(CompilationUnitTree node, Void unused) {
       first = false;
       dropEmptyDeclarations();
     }
+    handleModule(first, node);
     // set a partial format marker at EOF to make sure we can format the entire file
     markForPartialFormat();
     return null;
   }
 
+  protected void handleModule(boolean first, CompilationUnitTree node) {}
+
   /** Skips over extra semi-colons at the top-level, or in a class member declaration lists. */
   protected void dropEmptyDeclarations() {
     if (builder.peekToken().equals(Optional.of(";"))) {

File: core/src/main/java/com/google/googlejavaformat/java/java14/Java14InputAstVisitor.java
Patch:
@@ -60,7 +60,7 @@ public Void visitBindingPattern(BindingPatternTree node, Void unused) {
     } catch (ReflectiveOperationException e1) {
       try {
         Tree type = (Tree) BindingPatternTree.class.getMethod("getType").invoke(node);
-        Name name = (Name) BindingPatternTree.class.getMethod("getName").invoke(node);
+        Name name = (Name) BindingPatternTree.class.getMethod("getBinding").invoke(node);
         visitBindingPattern(/* modifiers= */ null, type, name);
       } catch (ReflectiveOperationException e2) {
         e2.addSuppressed(e1);

File: core/src/test/java/com/google/googlejavaformat/java/FormatterIntegrationTest.java
Patch:
@@ -48,7 +48,7 @@
 public class FormatterIntegrationTest {
 
   private static final ImmutableSet<String> JAVA14_TESTS =
-      ImmutableSet.of("I477", "Records", "RSLs", "Var", "ExpressionSwitch", "I574");
+      ImmutableSet.of("I477", "Records", "RSLs", "Var", "ExpressionSwitch", "I574", "I594");
 
   private static final ImmutableSet<String> JAVA16_TESTS = ImmutableSet.of("I588");
 

File: core/src/test/java/com/google/googlejavaformat/java/FormatterIntegrationTest.java
Patch:
@@ -48,7 +48,7 @@
 public class FormatterIntegrationTest {
 
   private static final ImmutableSet<String> JAVA14_TESTS =
-      ImmutableSet.of("I477", "Records", "RSLs", "Var", "ExpressionSwitch");
+      ImmutableSet.of("I477", "Records", "RSLs", "Var", "ExpressionSwitch", "I574");
 
   private static final ImmutableSet<String> JAVA16_TESTS = ImmutableSet.of("I588");
 

File: idea_plugin/src/com/google/googlejavaformat/intellij/CodeStyleManagerDecorator.java
Patch:
@@ -89,7 +89,7 @@ public void reformatText(PsiFile file, int startOffset, int endOffset)
   }
 
   @Override
-  public void reformatText(PsiFile file, Collection<TextRange> ranges)
+  public void reformatText(PsiFile file, Collection<? extends TextRange> ranges)
       throws IncorrectOperationException {
     delegate.reformatText(file, ranges);
   }
@@ -101,7 +101,7 @@ public void reformatTextWithContext(PsiFile psiFile, ChangedRangesInfo changedRa
   }
 
   @Override
-  public void reformatTextWithContext(PsiFile file, Collection<TextRange> ranges)
+  public void reformatTextWithContext(PsiFile file, Collection<? extends TextRange> ranges)
       throws IncorrectOperationException {
     delegate.reformatTextWithContext(file, ranges);
   }

File: idea_plugin/src/com/google/googlejavaformat/intellij/FormatterUtil.java
Patch:
@@ -33,7 +33,7 @@ final class FormatterUtil {
   private FormatterUtil() {}
 
   static Map<TextRange, String> getReplacements(
-      Formatter formatter, String text, Collection<TextRange> ranges) {
+      Formatter formatter, String text, Collection<? extends TextRange> ranges) {
     try {
       ImmutableMap.Builder<TextRange, String> replacements = ImmutableMap.builder();
       formatter
@@ -49,7 +49,7 @@ static Map<TextRange, String> getReplacements(
     }
   }
 
-  private static Collection<Range<Integer>> toRanges(Collection<TextRange> textRanges) {
+  private static Collection<Range<Integer>> toRanges(Collection<? extends TextRange> textRanges) {
     return textRanges
         .stream()
         .map(textRange -> Range.closedOpen(textRange.getStartOffset(), textRange.getEndOffset()))

File: core/src/main/java/com/google/googlejavaformat/Input.java
Patch:
@@ -121,7 +121,7 @@ public interface Token {
   /**
    * Get the Token by index.
    *
-   * @param k the token index
+   * @param k the Tok index
    */
   public abstract Token getToken(int k);
 

File: core/src/main/java/com/google/googlejavaformat/java/JavaInput.java
Patch:
@@ -604,7 +604,7 @@ public int getkN() {
   /**
    * Get the Token by index.
    *
-   * @param k the token index
+   * @param k the Tok index
    */
   @Override
   public Token getToken(int k) {

File: core/src/test/java/com/google/googlejavaformat/java/FormatterIntegrationTest.java
Patch:
@@ -125,7 +125,9 @@ public FormatterIntegrationTest(String name, String input, String expected) {
   @Test
   public void format() {
     try {
-      String output = new Formatter().formatSource(input);
+      Formatter formatter = new Formatter();
+      String output = formatter.formatSource(input);
+      output = StringWrapper.wrap(output, formatter);
       assertEquals("bad output for " + name, expected, output);
     } catch (FormatterException e) {
       fail(String.format("Formatter crashed on %s: %s", name, e.getMessage()));

File: core/src/test/java/com/google/googlejavaformat/java/MainTest.java
Patch:
@@ -525,8 +525,8 @@ public void reflowLongStrings() throws Exception {
       "class T {",
       "  String s =",
       "      \"one long incredibly unbroken sentence moving from topic to topic so that no one had"
-          + " a\"",
-      "          + \" chance to interrupt\";",
+          + " a chance\"",
+      "          + \" to interrupt\";",
       "}",
       "",
     };

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -2366,7 +2366,7 @@ protected void visitFormals(
     builder.open(ZERO);
     boolean first = true;
     if (receiver.isPresent()) {
-      // TODO(jdd): Use builders.
+      // TODO(user): Use builders.
       declareOne(
           DeclarationKind.PARAMETER,
           Direction.HORIZONTAL,
@@ -2906,7 +2906,7 @@ private void dotExpressionUpToArgs(ExpressionTree expression, Optional<BreakTag>
         if (!methodInvocation.getTypeArguments().isEmpty()) {
           builder.open(plusFour);
           addTypeArguments(methodInvocation.getTypeArguments(), ZERO);
-          // TODO(jdd): Should indent the name -4.
+          // TODO(user): Should indent the name -4.
           builder.breakOp(Doc.FillMode.UNIFIED, "", ZERO, tyargTag);
           builder.close();
         }

File: core/src/main/java/com/google/googlejavaformat/java/JavaOutput.java
Patch:
@@ -89,7 +89,7 @@ public void markForPartialFormat(Token start, Token end) {
     partialFormatRanges.add(Range.closed(lo, hi));
   }
 
-  // TODO(jdd): Add invariant.
+  // TODO(user): Add invariant.
   @Override
   public void append(String text, Range<Integer> range) {
     if (!range.isEmpty()) {

File: core/src/main/java/com/google/googlejavaformat/java/javadoc/JavadocLexer.java
Patch:
@@ -507,9 +507,9 @@ private static boolean hasMultipleNewlines(String s) {
   // Match "@param <T>" specially in case the <T> is a <P> or other HTML tag we treat specially.
   private static final Pattern FOOTER_TAG_PATTERN = compile("^@(param\\s+<\\w+>|[a-z]\\w*)");
   private static final Pattern MOE_BEGIN_STRIP_COMMENT_PATTERN =
-      compile("^<!--\\s*MOE:begin_intracomment_strip\\s*-->");
+      compile("^<!--\\s*M" + "OE:begin_intracomment_strip\\s*-->");
   private static final Pattern MOE_END_STRIP_COMMENT_PATTERN =
-      compile("^<!--\\s*MOE:end_intracomment_strip\\s*-->");
+      compile("^<!--\\s*M" + "OE:end_intracomment_strip\\s*-->");
   private static final Pattern HTML_COMMENT_PATTERN = fullCommentPattern();
   private static final Pattern PRE_OPEN_PATTERN = openTagPattern("pre");
   private static final Pattern PRE_CLOSE_PATTERN = closeTagPattern("pre");

File: core/src/main/java/com/google/googlejavaformat/java/java14/Java14InputAstVisitor.java
Patch:
@@ -223,7 +223,7 @@ public Void visitCase(CaseTree node, Void unused) {
         token(">");
         builder.space();
         scan(node.getBody(), null);
-        token(";");
+        builder.guessToken(";");
         break;
       default:
         throw new AssertionError(node.getCaseKind());

File: core/src/test/java/com/google/googlejavaformat/java/FormatterIntegrationTest.java
Patch:
@@ -47,7 +47,7 @@
 @RunWith(Parameterized.class)
 public class FormatterIntegrationTest {
 
-  private static final ImmutableSet<String> JAVA14_TESTS = ImmutableSet.of("java14");
+  private static final ImmutableSet<String> JAVA14_TESTS = ImmutableSet.of("java14", "I477");
 
   @Parameters(name = "{index}: {0}")
   public static Iterable<Object[]> data() throws IOException {

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -2585,7 +2585,7 @@ private void visitToDeclare(
         typeWithDims);
   }
 
-  /** Does not omit the leading '<', which should be associated with the type name. */
+  /** Does not omit the leading {@code "<"}, which should be associated with the type name. */
   protected void typeParametersRest(
       List<? extends TypeParameterTree> typeParameters, Indent plusIndent) {
     builder.open(plusIndent);

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -3273,7 +3273,9 @@ int declareOne(
         visitAndBreakModifiers(
             modifiers.get(), annotationsDirection, Optional.of(verticalAnnotationBreak));
       }
-      boolean isVar = builder.peekToken().get().equals("var");
+      boolean isVar =
+          builder.peekToken().get().equals("var")
+              && (!name.contentEquals("var") || builder.peekToken(1).get().equals("var"));
       boolean hasType = type != null || isVar;
       builder.open(hasType ? plusFour : ZERO);
       {

File: core/src/main/java/com/google/googlejavaformat/java/RemoveUnusedImports.java
Patch:
@@ -40,7 +40,6 @@
 import com.sun.source.util.TreeScanner;
 import com.sun.tools.javac.api.JavacTrees;
 import com.sun.tools.javac.file.JavacFileManager;
-import com.sun.tools.javac.main.Option;
 import com.sun.tools.javac.parser.JavacParser;
 import com.sun.tools.javac.parser.ParserFactory;
 import com.sun.tools.javac.tree.DCTree;
@@ -186,8 +185,6 @@ public Void visitIdentifier(IdentifierTree node, Void aVoid) {
 
   public static String removeUnusedImports(final String contents) throws FormatterException {
     Context context = new Context();
-    // TODO(cushon): this should default to the latest supported source level, same as in Formatter
-    Options.instance(context).put(Option.SOURCE, "9");
     JCCompilationUnit unit = parse(context, contents);
     if (unit == null) {
       // error handling is done during formatting

File: core/src/main/java/com/google/googlejavaformat/java/CommandLineOptionsParser.java
Patch:
@@ -108,6 +108,9 @@ static CommandLineOptions parse(Iterable<String> options) {
         case "--skip-reflowing-long-strings":
           optionsBuilder.reflowLongStrings(false);
           break;
+        case "--skip-javadoc-formatting":
+          optionsBuilder.formatJavadoc(false);
+          break;
         case "-":
           optionsBuilder.stdin(true);
           break;

File: core/src/main/java/com/google/googlejavaformat/java/JavaCommentsHelper.java
Patch:
@@ -30,9 +30,11 @@
 public final class JavaCommentsHelper implements CommentsHelper {
 
   private final String lineSeparator;
+  private final JavaFormatterOptions options;
 
   public JavaCommentsHelper(String lineSeparator, JavaFormatterOptions options) {
     this.lineSeparator = lineSeparator;
+    this.options = options;
   }
 
   @Override
@@ -41,7 +43,7 @@ public String rewrite(Tok tok, int maxWidth, int column0) {
       return tok.getOriginalText();
     }
     String text = tok.getOriginalText();
-    if (tok.isJavadocComment()) {
+    if (tok.isJavadocComment() && options.formatJavadoc()) {
       text = JavadocFormatter.formatJavadoc(text, column0);
     }
     List<String> lines = new ArrayList<>();

File: core/src/main/java/com/google/googlejavaformat/java/UsageException.java
Patch:
@@ -48,6 +48,8 @@ final class UsageException extends Exception {
     "    Do not remove unused imports. Imports will still be sorted.",
     " . --skip-reflowing-long-strings",
     "    Do not reflow string literals that exceed the column limit.",
+    " . --skip-javadoc-formatting",
+    "    Do not reformat javadoc.",
     "  --dry-run, -n",
     "    Prints the paths of the files whose contents would change if the formatter were run"
         + " normally.",

File: core/src/main/java/com/google/googlejavaformat/java/JavaOutput.java
Patch:
@@ -46,7 +46,7 @@
  */
 public final class JavaOutput extends Output {
   private final String lineSeparator;
-  private final JavaInput javaInput; // Used to follow along while emitting the output.
+  private final Input javaInput; // Used to follow along while emitting the output.
   private final CommentsHelper commentsHelper; // Used to re-flow comments.
   private final Map<Integer, BlankLineWanted> blankLines = new HashMap<>(); // Info on blank lines.
   private final RangeSet<Integer> partialFormatRanges = TreeRangeSet.create();
@@ -62,10 +62,10 @@ public final class JavaOutput extends Output {
   /**
    * {@code JavaOutput} constructor.
    *
-   * @param javaInput the {@link JavaInput}, used to match up blank lines in the output
+   * @param javaInput the {@link Input}, used to match up blank lines in the output
    * @param commentsHelper the {@link CommentsHelper}, used to rewrite comments
    */
-  public JavaOutput(String lineSeparator, JavaInput javaInput, CommentsHelper commentsHelper) {
+  public JavaOutput(String lineSeparator, Input javaInput, CommentsHelper commentsHelper) {
     this.lineSeparator = lineSeparator;
     this.javaInput = javaInput;
     this.commentsHelper = commentsHelper;

File: core/src/main/java/com/google/googlejavaformat/java/JavaOutput.java
Patch:
@@ -178,7 +178,7 @@ public void indent(int indent) {
   }
 
   /** Flush any incomplete last line, then add the EOF token into our data structures. */
-  void flush() {
+  public void flush() {
     String lastLine = lineBuilder.toString();
     if (!CharMatcher.whitespace().matchesAllOf(lastLine)) {
       mutableLines.add(lastLine);

File: core/src/main/java/com/google/googlejavaformat/java/FormatFileCallable.java
Patch:
@@ -55,7 +55,7 @@ private String fixImports(String input) throws FormatterException {
       input = RemoveUnusedImports.removeUnusedImports(input);
     }
     if (parameters.sortImports()) {
-      input = ImportOrderer.reorderImports(input);
+      input = ImportOrderer.reorderImports(input, options.style());
     }
     return input;
   }

File: core/src/main/java/com/google/googlejavaformat/java/Formatter.java
Patch:
@@ -216,7 +216,7 @@ public String formatSource(String input) throws FormatterException {
    *     Google Java Style Guide - 3.3.3 Import ordering and spacing</a>
    */
   public String formatSourceAndFixImports(String input) throws FormatterException {
-    input = ImportOrderer.reorderImports(input);
+    input = ImportOrderer.reorderImports(input, options.style());
     input = RemoveUnusedImports.removeUnusedImports(input);
     String formatted = formatSource(input);
     formatted = StringWrapper.wrap(formatted);

File: core/src/test/java/com/google/googlejavaformat/java/FormatterTest.java
Patch:
@@ -20,6 +20,7 @@
 
 import com.google.common.base.Joiner;
 import com.google.common.io.CharStreams;
+import com.google.googlejavaformat.java.JavaFormatterOptions.Style;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -449,9 +450,9 @@ public void blankLinesImportComment() throws FormatterException {
 
     // Just fixing imports preserves whitespace around imports.
     assertThat(RemoveUnusedImports.removeUnusedImports(withBlank)).isEqualTo(withBlank);
-    assertThat(ImportOrderer.reorderImports(withBlank)).isEqualTo(withBlank);
+    assertThat(ImportOrderer.reorderImports(withBlank, Style.GOOGLE)).isEqualTo(withBlank);
     assertThat(RemoveUnusedImports.removeUnusedImports(withoutBlank)).isEqualTo(withoutBlank);
-    assertThat(ImportOrderer.reorderImports(withoutBlank)).isEqualTo(withoutBlank);
+    assertThat(ImportOrderer.reorderImports(withoutBlank, Style.GOOGLE)).isEqualTo(withoutBlank);
   }
 
   @Test

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -1564,7 +1564,8 @@ private static List<Long> handleStream(List<ExpressionTree> parts) {
                 return false;
               }
               Name name = getMethodName((MethodInvocationTree) p);
-              return Stream.of("stream", "toBuilder").anyMatch(name::contentEquals);
+              return Stream.of("stream", "parallelStream", "toBuilder")
+                  .anyMatch(name::contentEquals);
             })
         .collect(toList());
   }

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -1538,6 +1538,7 @@ private boolean handleLogStatement(MethodInvocationTree node) {
       ImmutableSet.of(
           "at",
           "atConfig",
+          "atDebug",
           "atFine",
           "atFiner",
           "atFinest",

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -383,6 +383,7 @@ public Void visitCompilationUnit(CompilationUnitTree node, Void unused) {
   private void dropEmptyDeclarations() {
     if (builder.peekToken().equals(Optional.of(";"))) {
       while (builder.peekToken().equals(Optional.of(";"))) {
+        builder.forcedBreak();
         markForPartialFormat();
         token(";");
       }

File: core/src/test/java/com/google/googlejavaformat/java/FormatterTest.java
Patch:
@@ -83,8 +83,8 @@ public void testFormatNonJavaFiles() throws Exception {
     assertThat(main.format("foo.go")).isEqualTo(0);
     assertThat(err.toString()).contains("Skipping non-Java file: " + "foo.go");
 
-    // should fail because the file does not exist
-    assertThat(main.format("Foo.java")).isNotEqualTo(0);
+    // format still fails on missing files
+    assertThat(main.format("Foo.java")).isEqualTo(1);
     assertThat(err.toString()).contains("Foo.java: could not read file: ");
   }
 

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -3324,6 +3324,9 @@ private void maybeAddDims(
           lastWasAnnotation = false;
           break;
         case ".":
+          if (!builder.peekToken().get().equals(".") || !builder.peekToken(1).get().equals(".")) {
+            return;
+          }
           if (lastWasAnnotation) {
             builder.breakToFill(" ");
           } else {

File: core/src/main/java/com/google/googlejavaformat/java/JavaCommentsHelper.java
Patch:
@@ -102,8 +102,10 @@ private String indentLineComments(List<String> lines, int column0) {
     return builder.toString();
   }
 
+  // Preserve special `//noinspection` and `//$NON-NLS-x$` comments used by IDEs, which cannot
+  // contain leading spaces.
   private static final Pattern LINE_COMMENT_MISSING_SPACE_PREFIX =
-      Pattern.compile("^(//+)(?!noinspection)[^\\s/]");
+      Pattern.compile("^(//+)(?!noinspection|\\$NON-NLS-\\d+\\$)[^\\s/]");
 
   private List<String> wrapLineComments(
       List<String> lines, int column0, JavaFormatterOptions options) {

File: idea_plugin/src/com/google/googlejavaformat/intellij/CodeStyleManagerDecorator.java
Patch:
@@ -38,8 +38,6 @@
 /**
  * Decorates the {@link CodeStyleManager} abstract class by delegating to a concrete implementation
  * instance (likely IJ's default instance).
- *
- * @author bcsf@google.com (Brian Chang)
  */
 @SuppressWarnings("deprecation")
 class CodeStyleManagerDecorator extends CodeStyleManager

File: idea_plugin/src/com/google/googlejavaformat/intellij/GoogleJavaFormatSettings.java
Patch:
@@ -81,7 +81,7 @@ private void updateFormatterState() {
   }
 
   static class State {
-    public boolean enabled = false;
+    public boolean enabled = true;
     public JavaFormatterOptions.Style style = JavaFormatterOptions.Style.GOOGLE;
   }
 }

File: core/src/main/java/com/google/googlejavaformat/java/ImportOrderer.java
Patch:
@@ -291,7 +291,7 @@ private StringAndIndex scanImported(int start) throws FormatterException {
     // At the start of each iteration of this loop, i points to an identifier.
     // On exit from the loop, i points to a token after an identifier or after *.
     while (true) {
-      assert isIdentifierToken(i);
+      Preconditions.checkState(isIdentifierToken(i));
       imported.append(tokenAt(i));
       i++;
       if (!tokenAt(i).equals(".")) {

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -1530,8 +1530,7 @@ public Void visitParameterizedType(ParameterizedTypeTree node, Void unused) {
       for (Tree typeArgument : node.getTypeArguments()) {
         if (!first) {
           token(",");
-          // TODO(cushon): unify breaks
-          builder.breakToFill(" ");
+          builder.breakOp(" ");
         }
         scan(typeArgument, null);
         first = false;

File: core/src/main/java/com/google/googlejavaformat/java/Formatter.java
Patch:
@@ -108,8 +108,8 @@ public Formatter(JavaFormatterOptions options) {
    * @param javaOutput the {@link JavaOutput}
    * @param options the {@link JavaFormatterOptions}
    */
-  static void format(
-      final JavaInput javaInput, JavaOutput javaOutput, JavaFormatterOptions options) {
+  static void format(final JavaInput javaInput, JavaOutput javaOutput, JavaFormatterOptions options)
+      throws FormatterException {
     Context context = new Context();
     DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<>();
     context.put(DiagnosticListener.class, diagnostics);
@@ -148,7 +148,7 @@ public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOExcept
     Iterable<Diagnostic<? extends JavaFileObject>> errorDiagnostics =
         Iterables.filter(diagnostics.getDiagnostics(), Formatter::errorDiagnostic);
     if (!Iterables.isEmpty(errorDiagnostics)) {
-      throw FormattingError.fromJavacDiagnostics(errorDiagnostics);
+      throw FormatterException.fromJavacDiagnostics(errorDiagnostics);
     }
     OpsBuilder builder = new OpsBuilder(javaInput, javaOutput);
     // Output the compilation unit.

File: core/src/main/java/com/google/googlejavaformat/java/javadoc/JavadocLexer.java
Patch:
@@ -539,7 +539,7 @@ private static boolean hasMultipleNewlines(String s) {
    * with matching only one character here. That would eliminate the need for the regex entirely.
    * That might be faster or slower than what we do now.
    */
-  private static final Pattern LITERAL_PATTERN = compile("^.[^ \t\n@<{}*]*");
+  private static final Pattern LITERAL_PATTERN = compile("^.[^ \t\n@<{}*]*", DOTALL);
 
   private static Pattern fullCommentPattern() {
     return compile("^<!--.*?-->", DOTALL);

File: core/src/main/java/com/google/googlejavaformat/java/JavacTokens.java
Patch:
@@ -99,7 +99,7 @@ public static ImmutableList<RawTok> getTokens(
       }
       if (stopTokens.contains(t.kind)) {
         if (t.kind != TokenKind.EOF) {
-          end = t.endPos - 1;
+          end = t.pos;
         }
         break;
       }

File: core/src/main/java/com/google/googlejavaformat/java/DimensionHelpers.java
Patch:
@@ -115,7 +115,7 @@ private static Tree extractDims(Deque<List<AnnotationTree>> dims, Tree node) {
           return node;
         }
         node = extractDims(dims, annotatedTypeTree.getUnderlyingType());
-        dims.addFirst(ImmutableList.<AnnotationTree>copyOf(annotatedTypeTree.getAnnotations()));
+        dims.addFirst(ImmutableList.copyOf(annotatedTypeTree.getAnnotations()));
         return node;
       default:
         return node;

File: core/src/main/java/com/google/googlejavaformat/java/Formatter.java
Patch:
@@ -31,7 +31,6 @@
 import com.google.googlejavaformat.Newlines;
 import com.google.googlejavaformat.Op;
 import com.google.googlejavaformat.OpsBuilder;
-import java.io.File;
 import java.io.IOError;
 import java.io.IOException;
 import java.net.URI;
@@ -122,7 +121,7 @@ static void format(
     JCCompilationUnit unit;
     JavacFileManager fileManager = new JavacFileManager(context, true, UTF_8);
     try {
-      fileManager.setLocation(StandardLocation.PLATFORM_CLASS_PATH, ImmutableList.<File>of());
+      fileManager.setLocation(StandardLocation.PLATFORM_CLASS_PATH, ImmutableList.of());
     } catch (IOException e) {
       // impossible
       throw new IOError(e);

File: core/src/main/java/com/google/googlejavaformat/java/GoogleJavaFormatVersion.java
Patch:
@@ -15,5 +15,5 @@
 package com.google.googlejavaformat.java;
 
 public class GoogleJavaFormatVersion {
-  public static final String VERSION = "1.5-SNAPSHOT";
+  public static final String VERSION = "1.0";
 }

File: core/src/main/java/com/google/googlejavaformat/java/JavaInput.java
Patch:
@@ -328,7 +328,7 @@ public ImmutableMap<Integer, Integer> getPositionToColumnMap() {
 
   /** Lex the input and build the list of toks. */
   private ImmutableList<Tok> buildToks(String text) throws FormatterException {
-    ImmutableList<Tok> toks = buildToks(text, ImmutableSet.<TokenKind>of());
+    ImmutableList<Tok> toks = buildToks(text, ImmutableSet.of());
     kN = getLast(toks).getIndex();
     computeRanges(toks);
     return toks;

File: core/src/main/java/com/google/googlejavaformat/java/CommandLineOptionsParser.java
Patch:
@@ -86,9 +86,6 @@ static CommandLineOptions parse(Iterable<String> options) {
         case "--fix-imports-only":
           optionsBuilder.fixImportsOnly(true);
           break;
-        case "--experimental-remove-javadoc-only-imports":
-          optionsBuilder.removeJavadocOnlyImports(true);
-          break;
         case "--skip-sorting-imports":
           optionsBuilder.sortImports(false);
           break;

File: core/src/main/java/com/google/googlejavaformat/java/RemoveUnusedImports.java
Patch:
@@ -238,7 +238,7 @@ public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOExcept
     unit = parser.parseCompilationUnit();
     unit.sourcefile = source;
     Iterable<Diagnostic<? extends JavaFileObject>> errorDiagnostics =
-        Iterables.filter(diagnostics.getDiagnostics(), Formatter.ERROR_DIAGNOSTIC);
+        Iterables.filter(diagnostics.getDiagnostics(), Formatter::errorDiagnostic);
     if (!Iterables.isEmpty(errorDiagnostics)) {
       // error handling is done during formatting
       throw FormattingError.fromJavacDiagnostics(errorDiagnostics);

File: core/src/main/java/com/google/googlejavaformat/java/Formatter.java
Patch:
@@ -38,7 +38,6 @@
 import java.net.URI;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import org.openjdk.javax.tools.Diagnostic;
 import org.openjdk.javax.tools.DiagnosticCollector;
@@ -204,7 +203,7 @@ public void formatSource(CharSource input, CharSink output)
    * @throws FormatterException if the input string cannot be parsed
    */
   public String formatSource(String input) throws FormatterException {
-    return formatSource(input, Collections.singleton(Range.closedOpen(0, input.length())));
+    return formatSource(input, ImmutableList.of(Range.closedOpen(0, input.length())));
   }
 
   /**

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -68,7 +68,6 @@
 import com.google.googlejavaformat.java.DimensionHelpers.TypeWithDims;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.Deque;
 import java.util.List;
@@ -308,7 +307,7 @@ public JavaInputAstVisitor(OpsBuilder builder, int indentMultiplier) {
   }
 
   /** A record of whether we have visited into an expression. */
-  private final Deque<Boolean> inExpression = new ArrayDeque<>(Arrays.asList(false));
+  private final Deque<Boolean> inExpression = new ArrayDeque<>(ImmutableList.of(false));
 
   private boolean inExpression() {
     return inExpression.peekLast();

File: core/src/main/java/com/google/googlejavaformat/java/ModifierOrderer.java
Patch:
@@ -77,7 +77,7 @@ private static Modifier getModifier(TokenKind kind) {
   /** Reorders all modifiers in the given text to be in JLS order. */
   static JavaInput reorderModifiers(String text) throws FormatterException {
     return reorderModifiers(
-        new JavaInput(text), Collections.singleton(Range.closedOpen(0, text.length())));
+        new JavaInput(text), ImmutableList.of(Range.closedOpen(0, text.length())));
   }
 
   /**

File: core/src/main/java/com/google/googlejavaformat/OpsBuilder.java
Patch:
@@ -206,7 +206,6 @@ public void checkClosed(int previous) {
 
   /** Create a {@link FormatterDiagnostic} at the current position. */
   public FormatterDiagnostic diagnostic(String message) {
-    System.err.printf(">>>> %d: %s\n", inputPosition, message);
     return input.createDiagnostic(inputPosition, message);
   }
 

File: core/src/main/java/com/google/googlejavaformat/java/RemoveUnusedImports.java
Patch:
@@ -53,6 +53,7 @@
 import org.openjdk.source.util.TreeScanner;
 import org.openjdk.tools.javac.api.JavacTrees;
 import org.openjdk.tools.javac.file.JavacFileManager;
+import org.openjdk.tools.javac.main.Option;
 import org.openjdk.tools.javac.parser.JavacParser;
 import org.openjdk.tools.javac.parser.ParserFactory;
 import org.openjdk.tools.javac.tree.DCTree;
@@ -195,6 +196,8 @@ public Void visitIdentifier(IdentifierTree node, Void aVoid) {
   public static String removeUnusedImports(
       final String contents, JavadocOnlyImports javadocOnlyImports) {
     Context context = new Context();
+    // TODO(cushon): this should default to the latest supported source level, same as in Formatter
+    Options.instance(context).put(Option.SOURCE, "9");
     JCCompilationUnit unit = parse(context, contents);
     if (unit == null) {
       // error handling is done during formatting

File: idea_plugin/src/com/google/googlejavaformat/intellij/GoogleJavaFormatSettings.java
Patch:
@@ -52,6 +52,7 @@ public State getState() {
   @Override
   public void loadState(State state) {
     this.state = state;
+    updateFormatterState();
   }
 
   boolean isEnabled() {

File: core/src/main/java/com/google/googlejavaformat/FormattingError.java
Patch:
@@ -17,6 +17,7 @@
 import static java.util.Locale.ENGLISH;
 
 import com.google.common.base.Function;
+import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import javax.tools.Diagnostic;
@@ -32,6 +33,7 @@ public FormattingError(FormatterDiagnostic diagnostic) {
   }
 
   public FormattingError(Iterable<FormatterDiagnostic> diagnostics) {
+    super(Joiner.on("\n").join(diagnostics) + "\n");
     this.diagnostics = ImmutableList.copyOf(diagnostics);
   }
 

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -426,6 +426,7 @@ public Void visitNewArray(NewArrayTree node, Void unused) {
       Deque<ExpressionTree> dimExpressions = new ArrayDeque<>(node.getDimensions());
 
       Deque<List<AnnotationTree>> annotations = new ArrayDeque<>();
+      annotations.add(ImmutableList.copyOf(node.getAnnotations()));
       annotations.addAll((List<List<AnnotationTree>>) node.getDimAnnotations());
       annotations.addAll(extractedDims.dims);
 

File: core/src/main/java/com/google/googlejavaformat/Doc.java
Patch:
@@ -744,7 +744,8 @@ Range<Integer> computeRange() {
     @Override
     public State computeBreaks(CommentsHelper commentsHelper, int maxWidth, State state) {
       text = commentsHelper.rewrite(tok, maxWidth, state.column);
-      return state.withColumn(text.length() - Iterators.getLast(Newlines.lineOffsetIterator(text)));
+      int firstLineLength = text.length() - Iterators.getLast(Newlines.lineOffsetIterator(text));
+      return state.withColumn(state.column + firstLineLength);
     }
 
     @Override

File: core/src/main/java/com/google/googlejavaformat/java/RemoveUnusedImports.java
Patch:
@@ -25,6 +25,7 @@
 import com.google.common.collect.RangeSet;
 import com.google.common.collect.TreeRangeMap;
 import com.google.common.collect.TreeRangeSet;
+import com.google.googlejavaformat.Newlines;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -209,7 +210,7 @@ private static RangeMap<Integer, String> buildReplacements(
       // delete the import
       int endPosition = importTree.getStartPosition() + importTree.getLength();
       endPosition = Math.max(CharMatcher.isNot(' ').indexIn(contents, endPosition), endPosition);
-      String sep = System.lineSeparator();
+      String sep = Newlines.guessLineSeparator(contents);
       if (endPosition + sep.length() < contents.length()
           && contents.subSequence(endPosition, endPosition + sep.length()).equals(sep)) {
         endPosition += sep.length();

File: core/src/main/java/com/google/googlejavaformat/CloseOp.java
Patch:
@@ -26,6 +26,7 @@ public enum CloseOp implements Op {
 
   /**
    * Make a {@code CloseOp}, returning a singleton since they are all the same.
+   *
    * @return the singleton {@code CloseOp}
    */
   public static Op make() {

File: core/src/main/java/com/google/googlejavaformat/CommentsHelper.java
Patch:
@@ -15,12 +15,13 @@
 package com.google.googlejavaformat;
 
 /**
- * Rewrite comments. This interface is implemented by
- * {@link com.google.googlejavaformat.java.JavaCommentsHelper JavaCommentsHelper}.
+ * Rewrite comments. This interface is implemented by {@link
+ * com.google.googlejavaformat.java.JavaCommentsHelper JavaCommentsHelper}.
  */
 public interface CommentsHelper {
   /**
    * Try to rewrite comments, returning rewritten text.
+   *
    * @param tok the comment's tok
    * @param maxWidth the line length for the output
    * @param column0 the current column

File: core/src/main/java/com/google/googlejavaformat/Indent.java
Patch:
@@ -18,9 +18,9 @@
 import com.google.googlejavaformat.Output.BreakTag;
 
 /**
- * An indent for a {@link Doc.Level} or {@link Doc.Break}. The indent is either a constant
- * {@code int}, or a conditional expression whose value depends on whether or not a
- * {@link Doc.Break} has been broken.
+ * An indent for a {@link Doc.Level} or {@link Doc.Break}. The indent is either a constant {@code
+ * int}, or a conditional expression whose value depends on whether or not a {@link Doc.Break} has
+ * been broken.
  */
 public abstract class Indent {
 

File: core/src/main/java/com/google/googlejavaformat/Op.java
Patch:
@@ -17,12 +17,13 @@
 /**
  * An {@code Op} is a member of the sequence of formatting operations emitted by {@link OpsBuilder}
  * and transformed by {@link DocBuilder} into a {@link Doc}. Leaf subclasses of {@link Doc}
- * implement {@code Op}; {@link Doc.Level} is the only non-leaf, and is represented by paired
- * {@link OpenOp}-{@link CloseOp} {@code Op}s.
+ * implement {@code Op}; {@link Doc.Level} is the only non-leaf, and is represented by paired {@link
+ * OpenOp}-{@link CloseOp} {@code Op}s.
  */
 public interface Op {
   /**
    * Add an {@code Op} to a {@link DocBuilder}.
+   *
    * @param builder the {@link DocBuilder}
    */
   void add(DocBuilder builder);

File: core/src/main/java/com/google/googlejavaformat/java/FormatterException.java
Patch:
@@ -35,6 +35,7 @@ public FormatterException(Iterable<FormatterDiagnostic> diagnostics) {
     super(diagnostics.iterator().next().toString());
     this.diagnostics = ImmutableList.copyOf(diagnostics);
   }
+
   public List<FormatterDiagnostic> diagnostics() {
     return diagnostics;
   }

File: core/src/main/java/com/google/googlejavaformat/java/JavaOutput.java
Patch:
@@ -67,6 +67,7 @@ enum From {
 
   /**
    * {@code JavaOutput} constructor.
+   *
    * @param javaInput the {@link JavaInput}, used to match up blank lines in the output
    * @param commentsHelper the {@link CommentsHelper}, used to rewrite comments
    */
@@ -222,6 +223,7 @@ public CommentsHelper getCommentsHelper() {
 
   /**
    * Emit a list of {@link Replacement}s to convert from input to output.
+   *
    * @return a list of {@link Replacement}s, sorted by start index, without overlaps
    */
   public ImmutableList<Replacement> getFormatReplacements(RangeSet<Integer> iRangeSet0) {

File: core/src/main/java/com/google/googlejavaformat/java/Main.java
Patch:
@@ -35,9 +35,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 
-/**
- * The main class for the Java formatter CLI.
- */
+/** The main class for the Java formatter CLI. */
 public final class Main {
   private static final int MAX_THREADS = 20;
   private static final String STDIN_FILENAME = "<stdin>";
@@ -60,6 +58,7 @@ public Main(PrintWriter outWriter, PrintWriter errWriter, InputStream inStream)
    * The main method for the formatter, with some number of file names to format. We process them in
    * parallel, but we must be careful; if multiple file names refer to the same file (which is hard
    * to determine), we must serialize their updates.
+   *
    * @param args the command-line arguments
    */
   public static void main(String[] args) {

File: core/src/main/java/com/google/googlejavaformat/java/Replacement.java
Patch:
@@ -17,9 +17,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.Range;
 
-/**
- * Represents a range in the original source and replacement text for that range.
- */
+/** Represents a range in the original source and replacement text for that range. */
 @AutoValue
 public abstract class Replacement {
 

File: core/src/main/java/com/google/googlejavaformat/java/javadoc/JavadocWriter.java
Patch:
@@ -49,6 +49,7 @@ final class JavadocWriter {
    * inside an {@code <li>} element in that inner list :)
    */
   private boolean continuingListItemOfInnermostList;
+
   private boolean continuingFooterTag;
   private final NestingCounter continuingListItemCount = new NestingCounter();
   private final NestingCounter continuingListCount = new NestingCounter();

File: core/src/main/java/com/google/googlejavaformat/java/ModifierOrderer.java
Patch:
@@ -52,9 +52,7 @@ static Modifier getModifier(int tokenId) {
       case ITerminalSymbols.TokenNamestatic:
         return Modifier.STATIC;
       case ITerminalSymbols.TokenNamedefault:
-        // TODO(cushon): handle default
-        // return Modifier.DEFAULT;
-        return null;
+        return Modifier.DEFAULT;
       case ITerminalSymbols.TokenNamefinal:
         return Modifier.FINAL;
       case ITerminalSymbols.TokenNametransient:

File: core/src/test/java/com/google/googlejavaformat/java/ModifierOrdererTest.java
Patch:
@@ -21,7 +21,6 @@
 import com.google.common.base.Joiner;
 import com.google.common.collect.Range;
 import java.util.Arrays;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -53,7 +52,6 @@ public void everything() throws FormatterException {
                 + " native strictfp");
   }
 
-  @Ignore
   @Test
   public void everythingIncludingDefault() throws FormatterException {
     assertThat(

File: core/src/main/java/com/google/googlejavaformat/Input.java
Patch:
@@ -124,7 +124,7 @@ public String toString() {
    * character offsets to numbers.
    * */
   public FormatterDiagnostic createDiagnostic(int inputPosition, String message) {
-    return new FormatterDiagnostic(
+    return FormatterDiagnostic.create(
         getLineNumber(inputPosition), getColumnNumber(inputPosition), message);
   }
 }

File: core/src/test/java/com/google/googlejavaformat/java/ImportOrdererTest.java
Patch:
@@ -386,7 +386,8 @@ public void reorder() throws FormatterException {
         throw e;
       }
       assertThat(reordered).endsWith("\n");
-      assertThat(e.getMessage()).isEqualTo(reordered.substring(2, reordered.length() - 1));
+      assertThat(e.getMessage())
+          .isEqualTo("error: " + reordered.substring(2, reordered.length() - 1));
     }
   }
 }

File: core/src/test/java/com/google/googlejavaformat/java/MainTest.java
Patch:
@@ -57,7 +57,6 @@ public void testUsageOutput() {
 
       String usage = e.getMessage();
 
-
       // Check that doc links are included.
       assertThat(usage).contains("https://github.com/google/google-java-format");
       assertThat(usage).contains("Usage: google-java-format");

File: core/src/main/java/com/google/googlejavaformat/Doc.java
Patch:
@@ -19,7 +19,6 @@
 import com.google.common.collect.DiscreteDomain;
 import com.google.common.collect.Range;
 import com.google.googlejavaformat.Output.BreakTag;
-
 import java.util.ArrayList;
 import java.util.List;
 

File: core/src/main/java/com/google/googlejavaformat/DocBuilder.java
Patch:
@@ -15,7 +15,6 @@
 package com.google.googlejavaformat;
 
 import com.google.common.base.MoreObjects;
-
 import java.util.ArrayDeque;
 import java.util.List;
 

File: core/src/main/java/com/google/googlejavaformat/InputOutput.java
Patch:
@@ -18,7 +18,6 @@
 import com.google.common.collect.DiscreteDomain;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Range;
-
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;

File: core/src/main/java/com/google/googlejavaformat/java/CommandLineOptionsParser.java
Patch:
@@ -17,7 +17,6 @@
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableRangeSet;
 import com.google.common.collect.Range;
-
 import java.util.Iterator;
 import java.util.List;
 

File: core/src/main/java/com/google/googlejavaformat/java/FormatterException.java
Patch:
@@ -17,7 +17,6 @@
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
 import com.google.googlejavaformat.FormatterDiagnostic;
-
 import java.util.List;
 
 /** Checked exception class for formatter errors. */

File: core/src/main/java/com/google/googlejavaformat/java/ImportOrderer.java
Patch:
@@ -22,7 +22,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.googlejavaformat.java.JavaInput.Tok;
-
 import org.eclipse.jdt.core.compiler.InvalidInputException;
 
 /**

File: core/src/main/java/com/google/googlejavaformat/java/JavaCommentsHelper.java
Patch:
@@ -20,7 +20,6 @@
 import com.google.googlejavaformat.CommentsHelper;
 import com.google.googlejavaformat.Input.Tok;
 import com.google.googlejavaformat.java.javadoc.JavadocFormatter;
-
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;

File: core/src/main/java/com/google/googlejavaformat/java/Main.java
Patch:
@@ -18,7 +18,6 @@
 
 import com.google.common.io.ByteStreams;
 import com.google.googlejavaformat.java.JavaFormatterOptions.Style;
-
 import java.io.IOError;
 import java.io.IOException;
 import java.io.InputStream;

File: core/src/main/java/com/google/googlejavaformat/java/TypeNameClassifier.java
Patch:
@@ -15,7 +15,6 @@
 package com.google.googlejavaformat.java;
 
 import com.google.common.base.Verify;
-
 import java.util.List;
 
 /**

File: core/src/test/java/com/google/googlejavaformat/java/ImportOrdererTest.java
Patch:
@@ -19,14 +19,12 @@
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
-
+import java.util.Collection;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-import java.util.Collection;
-
 /**
  * Tests for {@link ImportOrderer}.
  */

File: core/src/test/java/com/google/googlejavaformat/java/LineRangesToCharRangesTest.java
Patch:
@@ -19,13 +19,11 @@
 import com.google.common.collect.Range;
 import com.google.common.collect.RangeSet;
 import com.google.common.collect.TreeRangeSet;
-
+import java.util.Set;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.util.Set;
-
 /** Tests for {@link Formatter#lineRangesToCharRanges} */
 @RunWith(JUnit4.class)
 public class LineRangesToCharRangesTest {

File: core/src/test/java/com/google/googlejavaformat/java/ModifierOrdererTest.java
Patch:
@@ -20,14 +20,12 @@
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.Range;
-
+import java.util.Arrays;
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.util.Arrays;
-
 /** {@link ModifierOrderer}Test */
 @RunWith(JUnit4.class)
 public class ModifierOrdererTest {

File: core/src/test/java/com/google/googlejavaformat/java/TypeNameClassifierTest.java
Patch:
@@ -18,7 +18,6 @@
 
 import com.google.common.base.Splitter;
 import com.google.googlejavaformat.java.TypeNameClassifier.JavaCaseFormat;
-
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;

File: idea_plugin/src/main/java/com/google/googlejavaformat/intellij/CodeStyleManagerDecorator.java
Patch:
@@ -28,11 +28,10 @@
 import com.intellij.psi.codeStyle.Indent;
 import com.intellij.util.IncorrectOperationException;
 import com.intellij.util.ThrowableRunnable;
+import java.util.Collection;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-import java.util.Collection;
-
 /**
  * Decorates the {@link CodeStyleManager} abstract class by delegating to a concrete
  * implementation instance (likely IJ's default instance).

File: idea_plugin/src/main/java/com/google/googlejavaformat/intellij/GoogleJavaFormatCodeStyleManager.java
Patch:
@@ -32,11 +32,10 @@
 import com.intellij.psi.codeStyle.CodeStyleManager;
 import com.intellij.psi.impl.CheckUtil;
 import com.intellij.util.IncorrectOperationException;
-import org.jetbrains.annotations.NotNull;
-
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.List;
+import org.jetbrains.annotations.NotNull;
 
 /**
  * A {@link CodeStyleManager} implementation which formats .java files with google-java-format.

File: idea_plugin/src/test/java/com/google/googlejavaformat/intellij/GoogleJavaFormatCodeStyleManagerTest.java
Patch:
@@ -23,7 +23,6 @@
 import com.intellij.openapi.util.TextRange;
 import com.intellij.psi.codeStyle.CodeStyleManager;
 import com.intellij.testFramework.fixtures.LightCodeInsightFixtureTestCase;
-
 import java.net.URL;
 import java.net.URLClassLoader;
 

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -2960,7 +2960,7 @@ void addArguments(List<Expression> arguments, Indent plusIndent) {
     builder.open(plusIndent);
     token("(");
     if (!arguments.isEmpty()) {
-      if (argumentsAreTabular(arguments) == 2) {
+      if (arguments.size() % 2 == 0 && argumentsAreTabular(arguments) == 2) {
         builder.forcedBreak();
         builder.open(ZERO);
         boolean first = true;

File: core/src/main/java/com/google/googlejavaformat/java/UsageException.java
Patch:
@@ -51,6 +51,9 @@ public final class UsageException extends Exception {
     "    --version, -version, -v",
     "Print the version.",
     "    Default: false",
+    "Fix import order and remove any unused imports, but do no other formatting.",
+    "    Default: false",
+    "    --fix-imports-only",
   };
 
   private static final String[] ADDITIONAL_USAGE = {

File: core/src/test/java/com/google/googlejavaformat/java/RemoveUnusedImportsTest.java
Patch:
@@ -202,19 +202,19 @@ public static Collection<Object[]> parameters() {
       },
       {
         {
-          "import java.util.*;",
+          "import java.util.*;", //
           "class Test {",
           "  List<String> xs;",
           "}",
         },
         {
-          "import java.util.*;",
+          "import java.util.*;", //
           "class Test {",
           "  List<String> xs;",
           "}",
         },
         {
-          "import java.util.*;",
+          "import java.util.*;", //
           "class Test {",
           "  List<String> xs;",
           "}",

File: core/src/main/java/com/google/googlejavaformat/java/RemoveUnusedImports.java
Patch:
@@ -186,6 +186,9 @@ private static RangeMap<Integer, String> buildReplacements(
           importTree.getName() instanceof QualifiedName
               ? ((QualifiedName) importTree.getName()).getName().toString()
               : importTree.getName().toString();
+      if (importTree.isOnDemand()) {
+        continue;
+      }
       if (usedNames.contains(simpleName)) {
         continue;
       }

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -1554,7 +1554,7 @@ public boolean visit(PrefixExpression node) {
   public boolean visit(PrimitiveType node) {
     sync(node);
     beforeAnnotatableType(node);
-    token(node.toString());
+    token(node.getPrimitiveTypeCode().toString());
     return false;
   }
 

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -1386,11 +1386,11 @@ public boolean visit(Modifier node) {
   @Override
   public boolean visit(NameQualifiedType node) {
     sync(node);
-    beforeAnnotatableType(node);
     builder.open(plusFour);
     node.getQualifier().accept(this);
-    builder.breakOp();
     token(".");
+    builder.breakOp();
+    beforeAnnotatableType(node);
     visit(node.getName());
     builder.close();
     return false;

File: core/src/main/java/com/google/googlejavaformat/java/javadoc/JavadocWriter.java
Patch:
@@ -185,6 +185,8 @@ void writeBlockquoteOpenOrClose(Token token) {
   }
 
   void writePreOpen(Token token) {
+    requestBlankLine();
+
     writeToken(token);
   }
 

File: core/src/test/java/com/google/googlejavaformat/java/FormatterTest.java
Patch:
@@ -20,7 +20,6 @@
 import com.google.common.base.Joiner;
 import com.google.common.io.CharStreams;
 
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
@@ -257,7 +256,6 @@ public void importOrderingWithoutFormatting() throws IOException, UsageException
         "--fix-imports-only", "com/google/googlejavaformat/java/testimports/A.imports-only");
   }
 
-  @Ignore // re-enable when import fixing is on by default
   @Test
   public void importOrderingAndFormatting() throws IOException, UsageException {
     importOrdering(null, "com/google/googlejavaformat/java/testimports/A.imports-and-formatting");

File: core/src/test/java/com/google/googlejavaformat/java/PartialFormattingTest.java
Patch:
@@ -553,7 +553,6 @@ public void noTokensOnLine() throws Exception {
                 " */",
                 "",
                 "import com.google.googlejavaformat.FormatterDiagnostic;",
-                "",
                 "import java.util.List;",
                 "",
                 "/** Checked exception class for formatter errors. */",

File: core/src/test/java/com/google/googlejavaformat/java/CommandLineOptionsParserTest.java
Patch:
@@ -18,7 +18,6 @@
 import static org.junit.Assert.fail;
 
 import com.google.common.collect.Range;
-import com.google.googlejavaformat.java.CommandLineOptions.SortImports;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -43,7 +42,6 @@ public void defaults() {
     assertThat(options.offsets()).isEmpty();
     assertThat(options.inPlace()).isFalse();
     assertThat(options.version()).isFalse();
-    assertThat(options.sortImports()).isEqualTo(SortImports.NO);
   }
 
   @Test

File: core/src/test/java/com/google/googlejavaformat/java/MainTest.java
Patch:
@@ -171,9 +171,9 @@ public void javadoc() throws Exception {
   @Test
   public void imports() throws Exception {
     String[] input = {
-      "import java.util.ArrayList;",
       "import java.util.LinkedList;",
       "import java.util.List;",
+      "import java.util.ArrayList;",
       "class Test {",
       "  /**",
       "   * May be an {@link ArrayList}.",

File: core/src/main/java/com/google/googlejavaformat/java/JavaFormatterOptions.java
Patch:
@@ -119,7 +119,7 @@ public static Builder builder() {
 
   /** A builder for {@link JavaFormatterOptions}. */
   public static class Builder {
-    private JavadocFormatter javadocFormatter = JavadocFormatter.NONE;
+    private JavadocFormatter javadocFormatter = JavadocFormatter.GOOGLE;
     private Style style = Style.GOOGLE;
 
     private Builder() {}

File: core/src/test/java/com/google/googlejavaformat/java/PartialFormattingTest.java
Patch:
@@ -1143,7 +1143,9 @@ public void commentBeforeBadConstructor() throws Exception {
     String output = new Formatter().formatSource(Joiner.on('\n').join(lines));
     String[] expected = {
       "class D {", //
-      "  /** */",
+      "  /**",
+      "   *",
+      "   */",
       "  F() {}",
       "}",
       "",

File: core/src/main/java/com/google/googlejavaformat/java/JavaCommentsHelper.java
Patch:
@@ -48,9 +48,6 @@ public String rewrite(Tok tok, int maxWidth, int column0) {
     for (String line : NEWLINE_SPLITTER.split(text)) {
       lines.add(CharMatcher.whitespace().trimTrailingFrom(line));
     }
-    if (lines.size() == 1) {
-      return tok.getOriginalText().trim();
-    }
     if (tok.isSlashSlashComment()) {
       return indentLineComments(lines, column0);
     } else if (javadocShaped(lines)) {

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -1363,6 +1363,7 @@ public boolean visit(MethodInvocation node) {
     return false;
   }
 
+
   /** Visitor method for {@link Modifier}s. */
   @Override
   public boolean visit(Modifier node) {

File: core/src/test/java/com/google/googlejavaformat/java/DiagnosticTest.java
Patch:
@@ -112,7 +112,7 @@ public void oneFileParseError() throws Exception {
     assertThat(stderr.toString()).contains("One.java:1:11: error: Syntax error, insert \"}\"");
     assertThat(result).isEqualTo(1);
   }
-  
+
   @Test
   public void oneFileParseErrorReplace() throws Exception {
     String one = "class One {}}\n";
@@ -171,7 +171,7 @@ public void parseErrorStdin() throws FormatterException, IOException, UsageExcep
 
     assertThat(exitCode).isEqualTo(1);
     assertThat(err.toString())
-        .isEqualTo("<stdin>:2:4: error: Syntax error, insert \";\" to complete BlockStatements\n");
+        .contains("<stdin>:2:4: error: Syntax error, insert \";\" to complete BlockStatements");
   }
 
   @Test
@@ -204,6 +204,6 @@ public void lexErrorStdin() throws FormatterException, IOException, UsageExcepti
     int exitCode = main.format(args);
 
     assertThat(exitCode).isEqualTo(1);
-    assertThat(err.toString()).isEqualTo("<stdin>:2:4: error: Invalid character constant\n");
+    assertThat(err.toString()).contains("<stdin>:2:4: error: Invalid character constant");
   }
 }

File: core/src/main/java/com/google/googlejavaformat/java/JavaInput.java
Patch:
@@ -518,7 +518,8 @@ Range<Integer> characterRangeToTokenRange(int offset, int length) throws Formatt
     if (requiredLength > text.length()) {
       throw new FormatterException(
           String.format(
-              "invalid length %d, offset + length (%d) is outside the file",
+              "%s: error: invalid length %d, offset + length (%d) is outside the file",
+              filename,
               requiredLength,
               requiredLength));
     }

File: core/src/main/java/com/google/googlejavaformat/java/JavaCommentsHelper.java
Patch:
@@ -18,7 +18,6 @@
 import com.google.common.base.Splitter;
 import com.google.common.base.Strings;
 import com.google.googlejavaformat.CommentsHelper;
-import com.google.googlejavaformat.Input;
 import com.google.googlejavaformat.Input.Tok;
 
 import java.util.ArrayList;

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -818,6 +818,7 @@ public boolean visit(EnhancedForStatement node) {
   @Override
   public boolean visit(EnumConstantDeclaration node) {
     sync(node);
+    markForPartialFormat();
     List<Op> breaks =
         visitModifiers(node.modifiers(), Direction.VERTICAL, Optional.<BreakTag>absent());
     if (!breaks.isEmpty()) {

File: core/src/main/java/com/google/googlejavaformat/java/Formatter.java
Patch:
@@ -118,7 +118,7 @@ static void format(
     builder.sync(javaInput.getText().length());
     builder.drain();
     Doc doc = new DocBuilder().withOps(builder.build()).build();
-    doc.computeBreaks(javaOutput.getCommentsHelper(), maxWidth, new Doc.State(+0, 0, 0));
+    doc.computeBreaks(javaOutput.getCommentsHelper(), maxWidth, new Doc.State(+0, 0));
     doc.write(javaOutput);
     javaOutput.flush();
   }

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -1840,7 +1840,7 @@ public boolean visit(TryStatement node) {
     builder.space();
     if (!node.resources().isEmpty()) {
       token("(");
-      builder.open(plusFour);
+      builder.open(node.resources().size() > 1 ? plusFour : ZERO);
       boolean first = true;
       for (VariableDeclarationExpression resource :
           (List<VariableDeclarationExpression>) node.resources()) {

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -1435,16 +1435,16 @@ public boolean visit(NormalAnnotation node) {
         if (hasArrayInitializer) {
           builder.forcedBreak();
         } else {
-          builder.breakToFill(" ");
+          builder.breakOp(" ");
         }
       }
       value.accept(this);
       first = false;
     }
+    builder.breakOp(FillMode.UNIFIED, "", minusTwo, Optional.<BreakTag>absent());
+    token(")");
     builder.close();
-    builder.breakOp();
     builder.close();
-    token(")");
     return false;
   }
 

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -2026,7 +2026,7 @@ public boolean visit(UnionType node) {
     boolean first = true;
     for (Type type : types) {
       if (!first) {
-        builder.breakToFill(" ");
+        builder.breakOp(" ");
         token("|");
         builder.space();
       }

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -818,7 +818,7 @@ public boolean visit(DoStatement node) {
   @Override
   public boolean visit(EmptyStatement node) {
     sync(node);
-    token(";");
+    builder.guessToken(";");
     return false;
   }
 

File: core/src/test/java/com/google/googlejavaformat/java/MainTest.java
Patch:
@@ -45,7 +45,7 @@ public void deduplicatesSamePath() throws Exception {
     Path testFile = testFolder.newFile("Foo.java").toPath();
 
     ArgInfo argInfo = ArgInfo.processArgs(testFile.toString(), testFile.toString());
-    Main main = new Main(new PrintWriter(out, true), new PrintWriter(err, true));
+    Main main = new Main(new PrintWriter(out, true), new PrintWriter(err, true), System.in);
     assertThat(main.constructFilesToFormat(argInfo).filesToFormat).hasSize(1);
   }
 
@@ -63,7 +63,7 @@ public void deduplicatesDifferentPathsThatResolveToSameCanonicalPath() throws Ex
     Files.createSymbolicLink(symlink, testFile);
 
     ArgInfo argInfo = ArgInfo.processArgs(testFile.toString(), symlink.toString());
-    Main main = new Main(new PrintWriter(out, true), new PrintWriter(err, true));
+    Main main = new Main(new PrintWriter(out, true), new PrintWriter(err, true), System.in);
     assertThat(main.constructFilesToFormat(argInfo).filesToFormat).hasSize(1);
   }
 }

File: core/src/main/java/com/google/googlejavaformat/java/JavaInput.java
Patch:
@@ -239,7 +239,7 @@ public JavaInput(String filename, String text) throws FormatterException {
     tokens = buildTokens(toks);
     ImmutableSortedMap.Builder<Integer, Token> locationTokenMap = ImmutableSortedMap.naturalOrder();
     for (Token token : tokens) {
-      locationTokenMap.put(JavaOutput.startTok(token).getPosition(), token);
+      locationTokenMap.put(JavaOutput.startPosition(token), token);
     }
     positionTokenMap = locationTokenMap.build();
 

File: core/src/main/java/com/google/googlejavaformat/java/JavaInput.java
Patch:
@@ -406,7 +406,7 @@ private static ImmutableList<Token> buildTokens(List<Tok> toks) {
 
       // Non-tokens starting on the same line go here too.
       ImmutableList.Builder<Tok> toksAfter = ImmutableList.builder();
-      while (k < kN && !"\n".equals(toks.get(k).getText()) && !toks.get(k).isToken()) {
+      while (k < kN && !toks.get(k).isToken()) {
         // Don't attach inline comments to leading '('s, e.g. for `f(/*flag1=*/true).
         //
         // Attaching inline comments to the right token is hard, and this barely
@@ -498,7 +498,7 @@ Range<Integer> characterRangeToTokenRange(int offset, int length) throws Formatt
     Map.Entry<Integer, JavaInput.Token> tokenEntryLo =
         firstNonNull(map.floorEntry(offset), map.firstEntry());
     Map.Entry<Integer, JavaInput.Token> tokenEntryHi =
-        firstNonNull(map.ceilingEntry(offset + length - 1), map.lastEntry());
+        firstNonNull(map.floorEntry(offset + length - 1), map.lastEntry());
     return Range.closedOpen(
         tokenEntryLo.getValue().getTok().getIndex(),
         tokenEntryHi.getValue().getTok().getIndex() + 1);

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -533,6 +533,7 @@ private static int maxLinesFilledForItems(List<Expression> expressions, int defa
 
   private static boolean hasOnlyShortItems(List<Expression> expressions) {
     for (Expression expression : expressions) {
+      // TODO(cushon): this ignores attached comments, so `/*myParameterName=*/ true` has length 4.
       if (expression.getLength() >= MAX_ITEM_LENGTH_FOR_FILLING) {
         return false;
       }

File: core/src/main/java/com/google/googlejavaformat/java/Formatter.java
Patch:
@@ -106,7 +106,7 @@ public static void format(
     builder.sync(javaInput.getText().length());
     builder.drain();
     Doc doc = new DocBuilder().withOps(builder.build()).build();
-    doc.computeBreaks(javaOutput.getCommentsHelper(), maxWidth, new Doc.State(+0, 0));
+    doc.computeBreaks(javaOutput.getCommentsHelper(), maxWidth, new Doc.State(+0, 0, 0));
     doc.write(javaOutput);
     javaOutput.flush();
   }

File: core/src/main/java/com/google/googlejavaformat/java/Formatter.java
Patch:
@@ -105,8 +105,9 @@ public static void format(
     new JavaInputAstVisitor(builder, indentationMultiplier).visit(unit);
     builder.sync(javaInput.getText().length());
     builder.drain();
-    new DocBuilder().withOps(builder.build()).build().write(
-        javaOutput, maxWidth, new Doc.State(+0, 0)); // Write the Doc to the Output.
+    Doc doc = new DocBuilder().withOps(builder.build()).build();
+    doc.computeBreaks(javaOutput.getCommentsHelper(), maxWidth, new Doc.State(+0, 0));
+    doc.write(javaOutput);
     javaOutput.flush();
   }
 

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -1841,7 +1841,7 @@ public boolean visit(TypeDeclaration node) {
       }
       if (hasSuperInterfaceTypes) {
         builder.breakToFill(" ");
-        builder.open(plusFour);
+        builder.open(node.superInterfaceTypes().size() > 1 ? plusFour : ZERO);
         token(node.isInterface() ? "extends" : "implements");
         builder.space();
         boolean first = true;

File: core/src/test/java/com/google/googlejavaformat/java/CommandLineFlagsTest.java
Patch:
@@ -28,6 +28,8 @@
 @RunWith(JUnit4.class)
 public class CommandLineFlagsTest {
 
+  // TODO(eaftan): Disallow passing both -lines and -offset/-length, like clang-format.
+
   @Test
   public void formatInPlaceRequiresAtLeastOneFile() {
     try {

File: core/src/main/java/com/google/googlejavaformat/OpsBuilder.java
Patch:
@@ -350,9 +350,7 @@ public final ImmutableList<Op> build() {
                     Doc.Break.make(
                         Doc.FillMode.FORCED,
                         "",
-                        tokBefore.getColumn() == token.getTok().getColumn()
-                            ? ZERO
-                            : tokenOp.getPlusIndentCommentsBefore()));
+                        tokenOp.getPlusIndentCommentsBefore()));
               } else if (!first) {
                 tokOps.put(j, SPACE);
               }

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -2048,7 +2048,7 @@ private void visitBlock(
     if (collapseEmptyOrNot.isYes() && node.statements().isEmpty()) {
       tokenBreakTrailingComment("{", plusTwo);
       builder.blankLineWanted(false);
-      token("}");
+      token("}", plusTwo);
     } else {
       builder.open(ZERO);
       builder.open(plusTwo);

File: core/src/test/resources/com/google/googlejavaformat/java/testdata/input/C.java
Patch:
@@ -74,7 +74,7 @@ void f() {
         if (false == false)
           continue LABEL;
         // Comment indented +2
-      // Comment indented +0
+      // Comment indented +2
       }
     }
   }

File: core/src/test/resources/com/google/googlejavaformat/java/testdata/output/C.java
Patch:
@@ -72,7 +72,7 @@ void f() {
         if (false == true) continue;
         if (false == false) continue LABEL;
         // Comment indented +2
-      // Comment indented +0
+        // Comment indented +2
       }
     }
   }

File: core/src/test/resources/com/google/googlejavaformat/java/testdata/input/B20341001.java
Patch:
@@ -6,7 +6,7 @@ public class B20341001 {
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
   };
   int[] xs = {
-    Foo.CONST,
+    Foo.CONSTxx,
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

File: core/src/test/resources/com/google/googlejavaformat/java/testdata/output/B20341001.java
Patch:
@@ -7,7 +7,7 @@ public class B20341001 {
     1, 1, 1, 1
   };
   int[] xs = {
-    Foo.CONST,
+    Foo.CONSTxx,
     1,
     1,
     1,

File: core/src/test/resources/com/google/googlejavaformat/java/testdata/output/B20128588.java
Patch:
@@ -59,8 +59,8 @@ void f(
       @Foo @Bar @Baz Object var,
       @Foo(xs = 42) @Bar @Baz Object var) {}
 
-  <@TA T extends @TA Object>
-      @TA T f(List<? extends @TA T> a, List<? super @TA T> b) throws @TA Exception {}
+  <@TA T extends @TA Object> @TA T f(List<? extends @TA T> a, List<? super @TA T> b)
+      throws @TA Exception {}
 
   @FooXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
   @BarXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

File: core/src/test/java/com/google/googlejavaformat/java/TypeNameClassifierTest.java
Patch:
@@ -40,6 +40,8 @@ public void caseFormat() throws Exception {
 
     assertThat(JavaCaseFormat.from("A_$")).isEqualTo(JavaCaseFormat.UPPERCASE);
     assertThat(JavaCaseFormat.from("a_$")).isEqualTo(JavaCaseFormat.LOWERCASE);
+    assertThat(JavaCaseFormat.from("_")).isEqualTo(JavaCaseFormat.LOWERCASE);
+    assertThat(JavaCaseFormat.from("_A")).isEqualTo(JavaCaseFormat.UPPERCASE);
   }
 
   private static int getPrefix(String qualifiedName) {

File: core/src/test/resources/com/google/googlejavaformat/java/testdata/input/B21327412.java
Patch:
@@ -0,0 +1,3 @@
+class B21327412 {
+  int i = Data._ID;
+}

File: core/src/test/resources/com/google/googlejavaformat/java/testdata/output/B21327412.java
Patch:
@@ -0,0 +1,3 @@
+class B21327412 {
+  int i = Data._ID;
+}

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -3101,7 +3101,7 @@ final void tokenBreakTrailingComment(String token, Indent breakAndIndentTrailing
    * @param node the ASTNode holding the input position
    */
   final void sync(ASTNode node) {
-    builder.sync(node.getStartPosition(), true);
+    builder.sync(node.getStartPosition());
   }
 
   final BreakTag genSym() {

File: core/src/test/resources/com/google/googlejavaformat/java/testdata/input/B20535125.java
Patch:
@@ -113,9 +113,9 @@ void m() {
 
     }
 
-    try (Lock _ = lock.lock()) {}
+    try (Lock l = lock.lock()) {}
 
-    try (Lock _ = lock.lock()) {} finally {}
+    try (Lock l = lock.lock()) {} finally {}
 
     for (;;) {}
 

File: core/src/test/resources/com/google/googlejavaformat/java/testdata/output/B20535125.java
Patch:
@@ -104,9 +104,9 @@ void m() {
       System.err.println("Hi");
     }
 
-    try (Lock _ = lock.lock()) {}
+    try (Lock l = lock.lock()) {}
 
-    try (Lock _ = lock.lock()) {
+    try (Lock l = lock.lock()) {
     } finally {
     }
 

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -2961,6 +2961,7 @@ void addBodyDeclarations(
       }
       builder.close();
       builder.forcedBreak();
+      builder.markForPartialFormat();
       if (braces.isYes()) {
         builder.blankLineWanted(false);
         token("}", plusTwo);

File: core/src/main/java/com/google/googlejavaformat/FakeOutput.java
Patch:
@@ -82,6 +82,9 @@ public CommentsHelper getCommentsHelper() {
   @Override
   public void blankLine(int k, boolean wanted) {}
 
+  @Override
+  public void markForPartialFormat(int k) {}
+
   @Override
   public String toString() {
     return MoreObjects.toStringHelper(this)

File: core/src/main/java/com/google/googlejavaformat/InputOutput.java
Patch:
@@ -101,7 +101,7 @@ public static Map<Integer, Range<Integer>> makeKToIJ(InputOutput put, int kN) {
     Map<Integer, Range<Integer>> map = new HashMap<>();
     int ijN = put.getLineCount();
     LOOP:
-    for (int ij = 0; ij < ijN; ij++) {
+    for (int ij = 0; ij <= ijN; ij++) {
       Range<Integer> range = put.getRanges(ij).canonical(INTEGERS);
       for (int k = range.lowerEndpoint(); k < range.upperEndpoint(); k++) {
         if (map.containsKey(k)) {

File: core/src/test/resources/com/google/googlejavaformat/java/testdata/output/B20577626.java
Patch:
@@ -1,9 +1,7 @@
 class B20577626 {
   private @Mock GsaConfigFlags mGsaConfig;
 
-  @Foo
-  @Bar
-  private @Mock GsaConfigFlags mGsaConfig;
+  @Foo @Bar private @Mock GsaConfigFlags mGsaConfig;
 
   @Foo
   abstract @Bar void m() {}

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -2338,9 +2338,9 @@ void visitDot(Expression node0) {
       for (int i = 0; i < items.size(); i++) {
         Expression expression = items.get(i);
         if (expression.getNodeType() == ASTNode.METHOD_INVOCATION) {
-          if (i > 0) {
+          if (i > 0 || node != null) {
             // we only want dereference invocations
-            invocationCount++; 
+            invocationCount++;
           }
           if (firstInvocationIndex < 0) {
             firstInvocationIndex = i;

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -1681,13 +1681,15 @@ public boolean visit(TypeDeclaration node) {
       builder.breakOp(" ");
       if (hasSuperclassType) {
         token("extends");
+        // TODO(b/20761216): using a non-breaking space here could cause >100 char lines
         builder.space();
         node.getSuperclassType().accept(this);
       }
       if (hasSuperInterfaceTypes) {
         if (hasSuperclassType) {
           builder.breakOp(" ");
         }
+        builder.open(plusFour);
         token(node.isInterface() ? "extends" : "implements");
         builder.space();
         boolean first = true;
@@ -1699,6 +1701,7 @@ public boolean visit(TypeDeclaration node) {
           superInterfaceType.accept(this);
           first = false;
         }
+        builder.close();
       }
       builder.close();
     }

File: core/src/main/java/com/google/googlejavaformat/java/JavaInputAstVisitor.java
Patch:
@@ -134,6 +134,7 @@
  * An extension of {@link OpsBuilder}, implementing a visit pattern for Eclipse AST nodes to build a
  * sequence of {@link Op}s.
  */
+@SuppressWarnings({"unchecked", "rawtypes"}) // jdt uses rawtypes extensively
 public final class JavaInputAstVisitor extends ASTVisitor {
   /** Direction for Annotations (usually VERTICAL). */
   enum Direction {

File: core/src/main/java/com/google/googlejavaformat/java/JavaCommentsHelper.java
Patch:
@@ -30,7 +30,7 @@ public String rewrite(Input.Tok tok, int maxWidth, int column0) {
     List<String> rawLines = NEWLINE_SPLITTER.splitToList(tok.getOriginalText());
     StringBuilder builder = new StringBuilder();
     String firstLine = rawLines.get(0);
-    builder.append(firstLine).append("\n");
+    builder.append(firstLine);
     int indent = column0;
     if (firstLine.startsWith("/*")) {
       // For block and javadoc comments, add an extra space to trailing lines
@@ -39,7 +39,7 @@ public String rewrite(Input.Tok tok, int maxWidth, int column0) {
     }
     String indentString = Strings.repeat(" ", indent);
     for (int i = 1; i < rawLines.size(); ++i) {
-      builder.append(indentString).append(rawLines.get(i)).append("\n");
+      builder.append("\n").append(indentString).append(rawLines.get(i));
     }
     return builder.toString();
   }

