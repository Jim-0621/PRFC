File: roaringbitmap/src/main/java/org/roaringbitmap/longlong/ImmutableLongBitmapDataProvider.java
Patch:
@@ -90,7 +90,7 @@ default LongStream reverseStream() {
     int characteristics = Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.SIZED;
     Spliterator.OfLong x =
         Spliterators.spliterator(
-            new RoaringOfLong(getLongIterator()), getLongCardinality(), characteristics);
+            new RoaringOfLong(getReverseLongIterator()), getLongCardinality(), characteristics);
     return StreamSupport.longStream(x, false);
   }
 

File: bsi/src/main/java/org/roaringbitmap/bsi/longlong/Roaring64BitmapSliceIndex.java
Patch:
@@ -206,8 +206,8 @@ public void deserialize(DataInput in) throws IOException {
     this.clear();
 
     // read meta
-    this.minValue = WritableUtils.readVInt(in);
-    this.maxValue = WritableUtils.readVInt(in);
+    this.minValue = WritableUtils.readVLong(in);
+    this.maxValue = WritableUtils.readVLong(in);
     this.runOptimized = in.readBoolean();
 
     // read ebm

File: roaringbitmap/src/main/java/org/roaringbitmap/longlong/HighLowContainer.java
Patch:
@@ -185,7 +185,9 @@ public void serialize(ByteBuffer buffer) throws IOException {
         buffer.order() == LITTLE_ENDIAN ? buffer : buffer.slice().order(LITTLE_ENDIAN);
     if (art.isEmpty()) {
       byteBuffer.put(EMPTY_TAG);
-      buffer.position(buffer.position() + byteBuffer.position());
+      if (byteBuffer != buffer) {
+        buffer.position(buffer.position() + byteBuffer.position());
+      }
       return;
     } else {
       byteBuffer.put(NOT_EMPTY_TAG);

File: roaringbitmap/src/test/java/org/roaringbitmap/longlong/TestRoaring64Bitmap.java
Patch:
@@ -46,7 +46,7 @@ private Roaring64Bitmap newDefaultCtor() {
     return new Roaring64Bitmap();
   }
 
-  private Set<Long> getSourceForAllKindsOfNodeTypes() {
+  public static Set<Long> getSourceForAllKindsOfNodeTypes() {
     Random random = new Random(1234);
     Set<Long> source = new HashSet<>();
     int total = 10000;

File: bsi/src/main/java/org/roaringbitmap/bsi/longlong/Roaring64BitmapSliceIndex.java
Patch:
@@ -125,10 +125,10 @@ private long maxValue() {
   }
 
   private long valueAt(long columnId) {
-    int value = 0;
+    long value = 0;
     for (int i = 0; i < this.bitCount(); i += 1) {
       if (this.bA[i].contains(columnId)) {
-        value |= (1 << i);
+        value |= (1L << i);
       }
     }
 

File: RoaringBitmap/src/main/java/org/roaringbitmap/longlong/HighLowContainer.java
Patch:
@@ -180,6 +180,8 @@ public void serialize(ByteBuffer buffer) throws IOException {
         : buffer.slice().order(LITTLE_ENDIAN);
     if (art.isEmpty()) {
       byteBuffer.put(EMPTY_TAG);
+      byteBuffer.position();
+      buffer.position(buffer.position() + byteBuffer.position());
       return;
     } else {
       byteBuffer.put(NOT_EMPTY_TAG);

File: bsi/src/main/java/org/roaringbitmap/bsi/longlong/Roaring64BitmapSliceIndex.java
Patch:
@@ -257,7 +257,7 @@ public void deserialize(ByteBuffer buffer) throws IOException {
     Roaring64Bitmap ebm = new Roaring64Bitmap();
     ebm.deserialize(buffer);
     this.ebM = ebm;
-    // read ba
+    // read back
     buffer.position(buffer.position() + ebm.getSizeInBytes());
     int bitDepth = buffer.getInt();
     Roaring64Bitmap[] ba = new Roaring64Bitmap[bitDepth];

File: bsi/src/main/java/org/roaringbitmap/bsi/RoaringBitmapSliceIndex.java
Patch:
@@ -459,9 +459,9 @@ private RoaringBitmap oNeilCompare(BitmapSliceIndex.Operation operation, int pre
       case LT:
         return RoaringBitmap.and(LT, fixedFoundSet);
       case LE:
-        return RoaringBitmap.or(LT, EQ);
+        return RoaringBitmap.and(RoaringBitmap.or(LT, EQ), fixedFoundSet);
       case GE:
-        return RoaringBitmap.or(GT, EQ);
+        return RoaringBitmap.and(RoaringBitmap.or(GT, EQ), fixedFoundSet);
       default:
         throw new IllegalArgumentException("");
     }

File: RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -2861,10 +2861,11 @@ public long previousValue(int fromValue) {
     char key = Util.highbits(fromValue);
     int containerIndex = highLowContainer.advanceUntil(key, -1);
     if (containerIndex == highLowContainer.size()) {
-      return last();
+      return Util.toUnsignedLong(last());
     }
     if (highLowContainer.getKeyAtIndex(containerIndex) > key) {
-      return -1L;
+      // target absent, key of first container after target too high
+      --containerIndex;
     }
     long prevSetBit = -1L;
     while (containerIndex != -1 && prevSetBit == -1L) {

File: RoaringBitmap/src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -1915,7 +1915,7 @@ public char next() {
   public int nextAsInt() {
     return next();
   }
-  
+
   @Override
   public void advanceIfNeeded(char maxval) {
     if (maxval < (position + 1) * 64) {

File: RoaringBitmap/src/main/java/org/roaringbitmap/BitmapDataProviderSupplier.java
Patch:
@@ -7,7 +7,7 @@
 
 /**
  * Enable customizing the {@link BitmapDataProvider} used by {@link Roaring64NavigableMap}
- * 
+ *
  * @author Benoit Lacelle
  *
  */

File: RoaringBitmap/src/main/java/org/roaringbitmap/CharIterator.java
Patch:
@@ -10,7 +10,7 @@
 public interface CharIterator extends Cloneable {
   /**
    * Creates a copy of the iterator.
-   * 
+   *
    * @return a clone of the current iterator
    */
   CharIterator clone();

File: RoaringBitmap/src/main/java/org/roaringbitmap/FastAggregation.java
Patch:
@@ -522,7 +522,7 @@ private static int horizontalOrCardinality(RoaringBitmap... bitmaps) {
   public static RoaringBitmap workAndMemoryShyAnd(long[] buffer, RoaringBitmap... bitmaps) {
     if(buffer.length < 1024) {
       throw new IllegalArgumentException("buffer should have at least 1024 elements.");
-    } 
+    }
     long[] words = buffer;
     RoaringBitmap first = bitmaps[0];
     for (int i = 0; i < first.highLowContainer.size; ++i) {

File: RoaringBitmap/src/main/java/org/roaringbitmap/IntIterator.java
Patch:
@@ -13,7 +13,7 @@
 public interface IntIterator extends Cloneable {
   /**
    * Creates a copy of the iterator.
-   * 
+   *
    * @return a clone of the current iterator
    */
   IntIterator clone();

File: RoaringBitmap/src/main/java/org/roaringbitmap/InvalidRoaringFormat.java
Patch:
@@ -5,7 +5,7 @@
 /**
  *
  * Exception thrown when attempting to deserialize a roaring bitmap from
- * an input stream missing a cookie or having other similar anomalies. 
+ * an input stream missing a cookie or having other similar anomalies.
  * Some code may translate it to an IOException
  * for convenience when the cause of the problem can be cleanly interpreted as
  * an IO issue. However, when memory-mapping the file from a ByteBuffer,

File: RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitSet.java
Patch:
@@ -71,8 +71,7 @@ public boolean get(int bitIndex) {
 
   @Override
   public BitSet get(int fromIndex, int toIndex) {
-    RoaringBitmap newBitmap = RoaringBitmap.bitmapOfRange(fromIndex, toIndex);
-    newBitmap.and(roaringBitmap);
+    RoaringBitmap newBitmap = roaringBitmap.selectRange(fromIndex, toIndex);
     // shift the bits to start from index 0
     newBitmap = RoaringBitmap.addOffset(newBitmap, -fromIndex);
     return new RoaringBitSet(newBitmap);

File: RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmapSupplier.java
Patch:
@@ -6,7 +6,7 @@
 /**
  * A {@link BitmapDataProviderSupplier} providing {@link RoaringBitmap} as
  * {@link BitmapDataProvider}
- * 
+ *
  * @author Benoit Lacelle
  *
  */

File: RoaringBitmap/src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -2974,12 +2974,12 @@ public void advanceIfNeeded(char maxval) {
     le = maxlength + base - (maxval);
   }
 
-  
+
   @Override
   public char peekNext() {
     return (char) (base + maxlength - le);
   }
-  
+
   @Override
   public void remove() {
     throw new RuntimeException("Not implemented");// TODO

File: RoaringBitmap/src/main/java/org/roaringbitmap/Util.java
Patch:
@@ -185,8 +185,8 @@ public static int advanceUntil(char[] array, int pos, int length, char min) {
     return upper;
 
   }
-  
-  
+
+
   /**
    * Find the largest integer smaller than pos such that array[pos]&lt;= max. If none can be found,
    * return length. Based on code by O. Kaser.

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/BufferIntIteratorFlyweight.java
Patch:
@@ -10,7 +10,7 @@
 /**
  * Fast iterator minimizing the stress on the garbage collector. You can create one reusable
  * instance of this class and then {@link #wrap(ImmutableRoaringBitmap)}
- * 
+ *
  * For better performance, consider the {@link ImmutableRoaringBitmap#forEach} method.
  *
  * @author Borislav Ivanov
@@ -43,7 +43,7 @@ public BufferIntIteratorFlyweight() {
 
   /**
    * Creates an instance that is ready for iteration.
-   * 
+   *
    * @param r bitmap to be iterated over
    */
   public BufferIntIteratorFlyweight(ImmutableRoaringBitmap r) {
@@ -100,7 +100,7 @@ private void nextContainer() {
 
   /**
    * Prepares a bitmap for iteration
-   * 
+   *
    * @param r bitmap to be iterated over
    */
   public void wrap(ImmutableRoaringBitmap r) {

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/ImmutableRoaringArray.java
Patch:
@@ -157,7 +157,7 @@ public int getCardinality(int k) {
 
 
 
-  @Override 
+  @Override
   public int getContainerIndex(char x) {
     return unsignedBinarySearch(x);
   }

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MutableRoaringArray.java
Patch:
@@ -440,8 +440,8 @@ public int getCardinality(int i) {
   @Override
   public int getContainerIndex(char x) {
     return this.binarySearch(0, size, x);
-  }  
-  
+  }
+
 
   @Override
   public MappeableContainer getContainerAtIndex(int i) {

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MutableRoaringBitmapSupplier.java
Patch:
@@ -9,7 +9,7 @@
 /**
  * A {@link BitmapDataProviderSupplier} providing {@link MutableRoaringBitmap} as
  * {@link BitmapDataProvider}
- * 
+ *
  * @author Benoit Lacelle
  *
  */

File: RoaringBitmap/src/main/java/org/roaringbitmap/longlong/LongIterator.java
Patch:
@@ -11,7 +11,7 @@
 public interface LongIterator extends Cloneable {
   /**
    * Creates a copy of the iterator.
-   * 
+   *
    * @return a clone of the current iterator
    */
   LongIterator clone();

File: RoaringBitmap/src/main/java/org/roaringbitmap/longlong/package-info.java
Patch:
@@ -8,8 +8,8 @@
  * The org.roaringbitmap.longlong package  provides
  * one class ({@link org.roaringbitmap.longlong.Roaring64NavigableMap}) that   users
  * can rely upon for fast set of 64-bit integers.
- * 
- * 
+ *
+ *
  * <pre>
  * {@code
  *      import org.roaringbitmap.longlong.*;
@@ -18,7 +18,7 @@
  *
  *      Roaring64NavigableMap r1 = new Roaring64NavigableMap();
  *      for(long k = 4000l; k<4255l;++k) r1.addLong(k);
- *      
+ *
  * }
  * </pre>
  *

File: RoaringBitmap/src/main/java/org/roaringbitmap/package-info.java
Patch:
@@ -8,8 +8,8 @@
  * The org.roaringbitmap package  provides
  * one class ({@link org.roaringbitmap.RoaringBitmap}) that   users
  * can rely upon for fast set of integers.
- * 
- * 
+ *
+ *
  * <pre>
  * {@code
  *      import org.roaringbitmap.*;
@@ -18,7 +18,7 @@
  *
  *      RoaringBitmap r1 = new RoaringBitmap();
  *      for(int k = 4000; k<4255;++k) r1.add(k);
- *      
+ *
  *      RoaringBitmap r2 = new RoaringBitmap();
  *      for(int k = 1000; k<4255; k+=2) r2.add(k);
  *

File: RoaringBitmap/src/test/java/org/roaringbitmap/RangeBitmapTest.java
Patch:
@@ -283,7 +283,7 @@ public void testSerializeBigSlices() {
   }
 
   @ParameterizedTest
-  @ValueSource(longs = {1L, 0xFL, 0xFFL, 0xFFFL, 0xFFFFL, 
+  @ValueSource(longs = {1L, 0xFL, 0xFFL, 0xFFFL, 0xFFFFL,
       0xFFFFFL, 0xFFFFFFL, 0xFFFFFFL, 0xFFFFFFFL, 0xFFFFFFFFL,
       0xFFFFFFFFFL, 0xFFFFFFFFFFL, 0xFFFFFFFFFFFL,
       0xFFFFFFFFFFFFL, 0xFFFFFFFFFFFFFL,  0xFFFFFFFFFFFFFFL,

File: RoaringBitmap/src/test/java/org/roaringbitmap/TestContainer.java
Patch:
@@ -36,7 +36,7 @@ public void testNames() {
     assertEquals(new ArrayContainer().getContainerName(), Container.ContainerNames[1]);
     assertEquals(new RunContainer().getContainerName(), Container.ContainerNames[2]);
   }
-  
+
   public static boolean checkContent(Container c, char[] s) {
     CharIterator si = c.getCharIterator();
     int ctr = 0;

File: RoaringBitmap/src/test/java/org/roaringbitmap/TestForEach.java
Patch:
@@ -24,7 +24,7 @@ public void accept(int value) {
     });
     assertEquals(cardinality.value, bitmap.getCardinality());
   }
-  
+
   @Test
   public void testDense() {
     RoaringBitmap bitmap = new RoaringBitmap();

File: RoaringBitmap/src/test/java/org/roaringbitmap/TestIterators.java
Patch:
@@ -110,7 +110,7 @@ public void testSmallIteration() {
     assertEquals(ImmutableList.of(1, 2, 3), intIteratorCopy);
     assertEquals(ImmutableList.of(3, 2, 1), reverseIntIteratorCopy);
   }
-  
+
   @Test
   public void testSkips() {
     final Random source = new Random(0xcb000a2b9b5bdfb6l);
@@ -134,7 +134,7 @@ public void testSkips() {
     }
     bitmap.getIntIterator().advanceIfNeeded(-1);// should not crash
   }
-  
+
   @Test
   public void testSkipsDense() {
     RoaringBitmap bitmap = new RoaringBitmap();
@@ -185,7 +185,7 @@ public void testSkipsRun() {
       assertEquals(pii.next(), i);
     }
   }
-  
+
   @Test
   public void testIndexIterator4() throws Exception {
       RoaringBitmap b = new RoaringBitmap();

File: RoaringBitmap/src/test/java/org/roaringbitmap/TestRoaringBitmap_FastRank.java
Patch:
@@ -496,16 +496,16 @@ public void testLongSizeInBytes() {
 
     // Check when empty
     assertEquals(16, fast.getLongSizeInBytes());
-    
+
     fast.add(0);
     fast.add(1024);
     fast.add(Integer.MAX_VALUE);
 
     assertEquals(34, fast.getLongSizeInBytes());
-    
+
     // Compute a rank: the cache is allocated
     fast.rank(1024);
-    
+
     // Check the size is bigger once the cache is allocated
     assertEquals(42, fast.getLongSizeInBytes());
   }

File: RoaringBitmap/src/test/java/org/roaringbitmap/TestSerialization.java
Patch:
@@ -109,7 +109,7 @@ public class TestSerialization {
   static ByteBuffer outbb;
 
   static ByteBuffer presoutbb;
-  
+
   // Very small buffer to higher to chance to encounter edge-case
   byte[] buffer = new byte[16];
 
@@ -347,7 +347,7 @@ public void testMutableRunSerializationBasicDeserialization() throws java.io.IOE
       bitmap_a.add(k); // bitmap density and too many little runs
       bitmap_ar.add(k);
       bitmap_am.add(k);
-      bitmap_amr.add(k);    
+      bitmap_amr.add(k);
     }
 
     bitmap_ar.runOptimize();

File: RoaringBitmap/src/test/java/org/roaringbitmap/TestSerializedSize.java
Patch:
@@ -5,7 +5,7 @@
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class TestSerializedSize {
-  
+
   @Test
   public void testLucaSize() {
     System.out.println("testLucaSize");
@@ -88,7 +88,7 @@ public void testManyRanges() {
       for (long step = 1; step < 500; ++step) {
         RoaringBitmap rb = new RoaringBitmap();
         int universe_size = 0;
-        
+
         for (int i = 0; i < step; ++i) {
           final int maxv = i * (1 << 16) + stepsize;
           rb.add(i * (1L << 16), i * (1L << 16) + stepsize);
@@ -124,7 +124,7 @@ private static int[] firstPrimes(int n) {
     }
     return answer;
   }
-  
+
   @Test
   public void testPrimeSerializedSize() {
     System.out.println("[testPrimeSerializedSize]");

File: RoaringBitmap/src/test/java/org/roaringbitmap/TestVeryLargeBitmap.java
Patch:
@@ -13,7 +13,7 @@ public void testSelect() {
     assertEquals(-2, map.select(-2));
     assertEquals(-1, map.select(-1));
   }
-  
+
   @Test // this should run fine given enough memory
   public void stupidlyLarge() {
     try {

File: RoaringBitmap/src/test/java/org/roaringbitmap/buffer/TestFastAggregation.java
Patch:
@@ -97,7 +97,7 @@ public void testPriorityQueueXor() {
       BufferFastAggregation.priorityqueue_xor(data1);
     });
   }
-  
+
 
   @Test
   public void testNaiveAndMapped() {
@@ -137,7 +137,7 @@ public void testPriorityQueueOrMapped() {
     data6.add(data1);
     assertEquals(data1, BufferFastAggregation.priorityqueue_or(data6.iterator()));
   }
-  
+
   public void testBigOrMapped() {
     MutableRoaringBitmap rb1 = new MutableRoaringBitmap();
     MutableRoaringBitmap rb2 = new MutableRoaringBitmap();

File: RoaringBitmap/src/test/java/org/roaringbitmap/buffer/TestMemoryMapping.java
Patch:
@@ -414,7 +414,7 @@ public void run() {
       }
     }
   }
-  
+
 
   @Test
   public void containsTest() throws IOException  {
@@ -426,7 +426,7 @@ public void containsTest() throws IOException  {
       for(int k = 100000; k < 200000; k+=2)
         rr1.add(k + z);
       for(int k = 400000; k < 500000; k++)
-        rr1.add(k + z);    
+        rr1.add(k + z);
       rr1.runOptimize();
       ByteArrayOutputStream bos = new ByteArrayOutputStream();
       DataOutputStream dos = new DataOutputStream(bos);
@@ -441,7 +441,7 @@ public void containsTest() throws IOException  {
       }
     }
   }
-  
+
 
   @Test
   public void oneFormat() throws IOException {

File: RoaringBitmap/src/test/java/org/roaringbitmap/buffer/TestRange.java
Patch:
@@ -20,7 +20,7 @@ public void flip64() {
     assertEquals(1, i.next());
     assertFalse(i.hasNext());
   }
-  
+
   @Test
   @SuppressWarnings( "deprecation" )
   public void testDeprecatedMemberFlip() {

File: RoaringBitmap/src/test/java/org/roaringbitmap/buffer/TestRunContainer.java
Patch:
@@ -1488,10 +1488,10 @@ public void not10() {
    * @Test public void safeSerialization() throws Exception { MappeableRunContainer container = new
    * MappeableRunContainer(); container.add((char) 0); container.add((char) 2);
    * container.add((char) 55); container.add((char) 64); container.add((char) 256);
-   * 
+   *
    * ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream out = new
    * ObjectOutputStream(bos); out.writeObject(container);
-   * 
+   *
    * ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream in =
    * new ObjectInputStream(bis); MappeableRunContainer newContainer = (MappeableRunContainer)
    * in.readObject(); assertEquals(container, newContainer);

File: RoaringBitmap/src/test/java/org/roaringbitmap/buffer/TestSerializedSize.java
Patch:
@@ -79,7 +79,7 @@ public void testManyRanges() {
       for (long step = 1; step < 500; ++step) {
         MutableRoaringBitmap rb = new MutableRoaringBitmap();
         int universe_size = 0;
-        
+
         for (int i = 0; i < step; ++i) {
           final int maxv = i * (1 << 16) + stepsize;
           rb.add(i * (1L << 16), i * (1L << 16) + stepsize);

File: RoaringBitmap/src/test/java/org/roaringbitmap/buffer/TestUtil.java
Patch:
@@ -21,7 +21,7 @@
 
 @Execution(ExecutionMode.CONCURRENT)
 public class TestUtil {
-  
+
     @Test
     public void testCopy() {
       CharBuffer sb = CharBuffer.allocate(64);

File: RoaringBitmap/src/test/java/org/roaringbitmap/buffer/TestVeryLargeBitmap.java
Patch:
@@ -13,7 +13,7 @@ public void testSelect() {
     assertEquals(-2, map.select(-2));
     assertEquals(-1, map.select(-1));
   }
-  
+
   @Test // this should run fine given enough memory
   public void stupidlyLarge() {
     try {

File: RoaringBitmap/src/test/java/org/roaringbitmap/longlong/TestRoaring64NavigableMap.java
Patch:
@@ -1503,12 +1503,12 @@ public void testLongSizeInBytes() {
     map.add(0);
     map.add(2L * Integer.MAX_VALUE);
     map.addRange(8L * Integer.MAX_VALUE, 8L * Integer.MAX_VALUE + 1024);
-    
+
     assertEquals(3, map.getHighToBitmap().size());
 
     // Size with multiple entries
     assertEquals(228, map.getLongSizeInBytes());
-    
+
     // Select does allocate some cache
     map.select(16);
     assertEquals(264, map.getLongSizeInBytes());

File: bsi/src/main/java/org/roaringbitmap/bsi/BitmapSliceIndex.java
Patch:
@@ -12,9 +12,9 @@
  *    2. high compression ratio for number
  * Given that,we have a table T(c1,c2,c3....Cn). As we know,most database has rowId for each row.
  * then table T is actually  T(rowId,c1,c2,c3,Cn).
- * 1. if column c1 is string, we can encode c1 using dictionary. By bsi, 
+ * 1. if column c1 is string, we can encode c1 using dictionary. By bsi,
  * we can only use 33 bit slice express 2^32 cardinality dim.
- * 2. if column c2 is int32(that is 4Byte), for 1_000_000 rows, the size 
+ * 2. if column c2 is int32(that is 4Byte), for 1_000_000 rows, the size
  * of c2 is more than 3.81MB. however,
  * by bsi, the size might be less than 1MB.
  *

File: bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java
Patch:
@@ -299,7 +299,7 @@ private ImmutableRoaringBitmap owenGreatEqual(int predicate,
   //  }                         -- we know at this point that COUNT(G) <= k
   //  F = G OR E                      -- might be too many rows in F; check below
   //  if ((n = (COUNT(F) - k) > 0)            -- if n too many rows in F
-  //   {turn off n bits from E in F};           -- throw out some ties to return exactly k rows 
+  //   {turn off n bits from E in F};           -- throw out some ties to return exactly k rows
   public MutableRoaringBitmap topK(ImmutableRoaringBitmap foundSet, int k) {
     ImmutableRoaringBitmap fixedFoundSet = foundSet == null ? this.ebM : foundSet;
     if (k > fixedFoundSet.getLongCardinality() || k < 0) {
@@ -597,7 +597,7 @@ public MutableBitSliceIndex parallelTransposeWithCount(ImmutableRoaringBitmap fo
   }
 
   /**
-   * parallelIn search the given Set values, 
+   * parallelIn search the given Set values,
    * we scan the bsi,if the value in values, we add it to result Bitmap
    *
    * @param parallelism

File: bsi/src/main/java/org/roaringbitmap/bsi/buffer/ImmutableBitSliceIndex.java
Patch:
@@ -86,7 +86,7 @@ public void setValue(int cid, int value) {
 
 
   @Override
-  public void setValues(List<Pair<Integer, Integer>> values, 
+  public void setValues(List<Pair<Integer, Integer>> values,
       Integer currentMaxValue, Integer currentMinValue) {
     throw new UnsupportedOperationException("ImmutableBSI don't support setValues");
   }

File: examples/src/main/java/ImmutableRoaringBitmapExample.java
Patch:
@@ -10,7 +10,7 @@ public static void main(String[] args) throws IOException {
         ByteArrayOutputStream bos = new ByteArrayOutputStream();
         DataOutputStream dos = new DataOutputStream(bos);
         // If there were runs of consecutive values, you could
-        // call rr1.runOptimize(); or rr2.runOptimize(); to improve compression 
+        // call rr1.runOptimize(); or rr2.runOptimize(); to improve compression
         rr1.serialize(dos);
         rr2.serialize(dos);
         dos.close();

File: jmh/src/jmh/java/org/roaringbitmap/RandomData.java
Patch:
@@ -5,7 +5,7 @@
 import java.util.stream.IntStream;
 
 public class RandomData {
-  
+
   private static final SplittableRandom RANDOM = new SplittableRandom(0);
 
   private static final ThreadLocal<long[]> bits = ThreadLocal.withInitial(() -> new long[1 << 10]);

File: jmh/src/jmh/java/org/roaringbitmap/bithacking/SelectBenchmark.java
Patch:
@@ -112,7 +112,7 @@ public static int selectBitPosition(long w, int j) {
 
   /**
    * Given a word w, return the position of the jth true bit.
-   * 
+   *
    * @param w word
    * @param j index
    * @return position of jth true bit in w
@@ -129,7 +129,7 @@ public static int select(long w, int j) {
 
   /**
    * Given a word w, return the position of the jth true bit.
-   * 
+   *
    * @param w word
    * @param j index
    * @return position of jth true bit in w
@@ -147,7 +147,7 @@ public static int select(int w, int j) {
 
   /**
    * Given a word w, return the position of the jth true bit.
-   * 
+   *
    * @param w word
    * @param j index
    * @return position of jth true bit in w

File: real-roaring-dataset/src/main/java/org/roaringbitmap/RealDataset.java
Patch:
@@ -3,7 +3,7 @@
 public final class RealDataset {
 
   private RealDataset() {
-    
+
   }
 
   public static final String CENSUS_INCOME = "census-income";

File: real-roaring-dataset/src/main/java/org/roaringbitmap/ZipRealDataRangeRetriever.java
Patch:
@@ -32,7 +32,7 @@ public String getName() {
   }
 
   /**
-   * 
+   *
    * Returns next range from file
    * @return some Iterable
    * @throws IOException it can happen

File: RoaringBitmap/src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -317,7 +317,7 @@ protected boolean contains(RunContainer runContainer) {
     for (int i = 0; i < runContainer.numberOfRuns(); ++i) {
       int start = (runContainer.getValue(i));
       int length = (runContainer.getLength(i));
-      if (!contains(start, start + length)) {
+      if (!contains(start, start + length + 1)) {
         return false;
       }
     }

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MappeableArrayContainer.java
Patch:
@@ -1651,7 +1651,7 @@ protected boolean contains(MappeableRunContainer runContainer) {
     for (int i = 0; i < runContainer.numberOfRuns(); ++i) {
       int start = (runContainer.getValue(i));
       int length = (runContainer.getLength(i));
-      if (!contains(start, start + length)) {
+      if (!contains(start, start + length + 1)) {
         return false;
       }
     }

File: RoaringBitmap/src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -830,7 +830,6 @@ protected boolean contains(BitmapContainer bitmapContainer) {
           if (ir == runCount) {
             break;
           }
-          w &= w - 1;
           start = getValue(ir);
           stop = start + getLength(ir);
         } else if (ib * 64 + 64 < stop) {

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MappeableRunContainer.java
Patch:
@@ -2739,7 +2739,6 @@ protected boolean contains(MappeableBitmapContainer bitmapContainer) {
           if (ir == runCount) {
             break;
           }
-          w &= w - 1;
           start = getValue(ir);
           stop = start + getLength(ir);
 

File: RoaringBitmap/src/main/java/org/roaringbitmap/ImmutableBitmapDataProvider.java
Patch:
@@ -235,7 +235,7 @@ public default IntStream reverseStream() {
    *
    * @param  fromValue the lower bound (inclusive)
    * @return the smallest absent value larger than or equal to the specified
-   *       value.
+   *       value or {@code -1} if there is no such value.
    */
   long nextAbsentValue(int fromValue);
 
@@ -246,7 +246,7 @@ public default IntStream reverseStream() {
    *
    * @param  fromValue the lower bound (inclusive)
    * @return the smallest absent value larger than or equal to the specified
-   *       value.
+   *       value or {@code -1} if there is no such value.
    */
   long previousAbsentValue(int fromValue);
 

File: RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -2845,9 +2845,9 @@ public long previousValue(int fromValue) {
   @Override
   public long nextAbsentValue(int fromValue) {
     long nextAbsentBit = computeNextAbsentValue(fromValue);
-    assert nextAbsentBit <= 0xFFFFFFFFL;
-    assert nextAbsentBit >= Util.toUnsignedLong(fromValue);
-    assert !contains((int) nextAbsentBit);
+    if(nextAbsentBit == 0x100000000L) {
+      return -1L;
+    }
     return nextAbsentBit;
   }
 

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -1729,9 +1729,9 @@ public long previousValue(int fromValue) {
   @Override
   public long nextAbsentValue(int fromValue) {
     long nextAbsentBit = computeNextAbsentValue(fromValue);
-    assert nextAbsentBit <= 0xFFFFFFFFL;
-    assert nextAbsentBit >= Util.toUnsignedLong(fromValue);
-    assert !contains((int) nextAbsentBit);
+    if(nextAbsentBit == 0x100000000L) {
+      return -1L;
+    }
     return nextAbsentBit;
   }
 

File: RoaringBitmap/src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -1707,6 +1707,9 @@ public int last() {
     return (i + 1) * 64 - Long.numberOfLeadingZeros(bitmap[i]) - 1;
   }
 
+  public void copyBitmapTo(long[] words, int position, int length) {
+    System.arraycopy(bitmap, 0, words, position, length);
+  }
 }
 
 

File: RoaringBitmap/src/main/java/org/roaringbitmap/ArrayBatchIterator.java
Patch:
@@ -13,11 +13,11 @@ public ArrayBatchIterator(ArrayContainer array) {
   }
 
   @Override
-  public int next(int key, int[] buffer) {
+  public int next(int key, int[] buffer, int offset) {
     int consumed = 0;
     char[] data = array.content;
-    while (consumed < buffer.length && index < array.getCardinality()) {
-      buffer[consumed++] = key + (data[index++]);
+    while ((offset + consumed) < buffer.length && index < array.getCardinality()) {
+      buffer[offset + consumed++] = key + (data[index++]);
     }
     return consumed;
   }

File: RoaringBitmap/src/main/java/org/roaringbitmap/BitmapBatchIterator.java
Patch:
@@ -13,17 +13,17 @@ public BitmapBatchIterator(BitmapContainer bitmap) {
   }
 
   @Override
-  public int next(int key, int[] buffer) {
+  public int next(int key, int[] buffer, int offset) {
     int consumed = 0;
-    while (consumed < buffer.length) {
+    while ((consumed + offset) < buffer.length) {
       while (word == 0) {
         ++wordIndex;
         if (wordIndex == 1024) {
           return consumed;
         }
         word = bitmap.bitmap[wordIndex];
       }
-      buffer[consumed++] = key + (64 * wordIndex) + numberOfTrailingZeros(word);
+      buffer[offset + consumed++] = key + (64 * wordIndex) + numberOfTrailingZeros(word);
       word &= (word - 1);
     }
     return consumed;

File: RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBatchIterator.java
Patch:
@@ -18,9 +18,9 @@ public RoaringBatchIterator(RoaringArray highLowContainer) {
   @Override
   public int nextBatch(int[] buffer) {
     int consumed = 0;
-    while (iterator != null && consumed == 0) {
-      consumed = iterator.next(key, buffer);
-      if (consumed == 0 || !iterator.hasNext()) {
+    while (iterator != null && consumed < buffer.length) {
+      consumed += iterator.next(key, buffer, consumed);
+      if (consumed < buffer.length || !iterator.hasNext()) {
         nextContainer();
       }
     }

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/ArrayBatchIterator.java
Patch:
@@ -17,11 +17,11 @@ public ArrayBatchIterator(MappeableArrayContainer array) {
   }
 
   @Override
-  public int next(int key, int[] buffer) {
+  public int next(int key, int[] buffer, int offset) {
     int consumed = 0;
     CharBuffer data = array.content;
-    while (consumed < buffer.length && index < array.getCardinality()) {
-      buffer[consumed++] = key + (data.get(index++));
+    while ((offset + consumed) < buffer.length && index < array.getCardinality()) {
+      buffer[offset + consumed++] = key + (data.get(index++));
     }
     return consumed;
   }

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/BitmapBatchIterator.java
Patch:
@@ -15,17 +15,17 @@ public BitmapBatchIterator(MappeableBitmapContainer bitmap) {
   }
 
   @Override
-  public int next(int key, int[] buffer) {
+  public int next(int key, int[] buffer, int offset) {
     int consumed = 0;
-    while (consumed < buffer.length) {
+    while ((offset + consumed) < buffer.length) {
       while (word == 0) {
         ++wordIndex;
         if (wordIndex == 1024) {
           return consumed;
         }
         word = bitmap.bitmap.get(wordIndex);
       }
-      buffer[consumed++] = key + (64 * wordIndex) + numberOfTrailingZeros(word);
+      buffer[offset + consumed++] = key + (64 * wordIndex) + numberOfTrailingZeros(word);
       word &= (word - 1);
     }
     return consumed;

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/RoaringBatchIterator.java
Patch:
@@ -20,9 +20,9 @@ public RoaringBatchIterator(MappeableContainerPointer containerPointer) {
   @Override
   public int nextBatch(int[] buffer) {
     int consumed = 0;
-    while (iterator != null && consumed == 0) {
-      consumed = iterator.next(key, buffer);
-      if (consumed == 0 || !iterator.hasNext()) {
+    while (iterator != null && consumed < buffer.length) {
+      consumed += iterator.next(key, buffer, consumed);
+      if (consumed < buffer.length || !iterator.hasNext()) {
         nextContainer();
       }
     }

File: RoaringBitmap/src/test/java/org/roaringbitmap/CloneBatchIteratorTest.java
Patch:
@@ -41,7 +41,7 @@ public void testIndependenceOfClones2() {
     BatchIterator it1 = bitmap.getBatchIterator();
     BatchIterator it2 = it1.clone();
 
-    int[] buffer = new int[8];
+    int[] buffer = new int[3];
 
     assertEquals(3, it2.nextBatch(buffer));
     assertArrayEquals(c1, Arrays.copyOfRange(buffer, 0, 3));

File: RoaringBitmap/src/test/java/org/roaringbitmap/buffer/CloneBatchIteratorTest.java
Patch:
@@ -42,7 +42,7 @@ public void testIndependenceOfClones2() {
     BatchIterator it1 = bitmap.getBatchIterator();
     BatchIterator it2 = it1.clone();
 
-    int[] buffer = new int[8];
+    int[] buffer = new int[3];
 
     assertEquals(3, it2.nextBatch(buffer));
     assertArrayEquals(c1, Arrays.copyOfRange(buffer, 0, 3));

File: RoaringBitmap/src/test/java/org/roaringbitmap/RoaringBitmapBatchIteratorTest.java
Patch:
@@ -208,4 +208,5 @@ public void testBatchIteratorWithAdvanceIfNeeded() {
         assertEquals(batch[1], (3 << 16) + 5);
         assertEquals(batch[2], (3 << 16) + 10);
     }
+
 }

File: RoaringBitmap/src/main/java/org/roaringbitmap/art/AbstractShuttle.java
Patch:
@@ -30,17 +30,18 @@ public void initShuttle() {
   public void initShuttleFrom(long key) {
     depth = -1; // reset
     byte[] high = LongUtils.highPart(key);
+    long highAsLong = LongUtils.rightShiftHighPart(key);
     visitToLeafFrom(high, 0, art.getRoot());
     // If the target container doesn't exist, we may end up in the previous existing leaf here
-    if (currentBeforeHigh(getCurrentLeafNode().getKeyBytes(), high)) {
+    if (currentBeforeHigh(getCurrentLeafNode().getKey(), highAsLong)) {
       // Move the following leaf instead
       hasRun = true; // make it actually move
       moveToNextLeaf();
     }
     hasRun = false; // reset
   }
 
-  protected abstract boolean currentBeforeHigh(byte[] current, byte[] high);
+  protected abstract boolean currentBeforeHigh(long current, long high);
 
   @Override
   public boolean moveToNextLeaf() {

File: RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -910,8 +910,8 @@ public static int andNotCardinality(final RoaringBitmap x1, final RoaringBitmap
       } else if (s1 < s2) {
         while (s1 < s2 && pos1 < length1) {
           cardinality += x1.highLowContainer.getContainerAtIndex(pos1).getCardinality();
-          s1 = x1.highLowContainer.getKeyAtIndex(pos1);
           ++pos1;
+          s1 = x1.highLowContainer.getKeyAtIndex(pos1);
         }
       } else {
         pos2 = x2.highLowContainer.advanceUntil(s1, pos2);

File: RoaringBitmap/src/test/java/org/roaringbitmap/TestSerialization.java
Patch:
@@ -197,6 +197,7 @@ public void testDeserialize_buffer() throws IOException {
     DataInputStream dis = new DataInputStream(in);
     bitmap_empty.deserialize(dis, buffer);
     bitmap_b.deserialize(dis, buffer);
+    assertEquals(bitmap_a, bitmap_b);
   }
 
 

File: RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -1653,7 +1653,6 @@ public boolean contains(long minimum, long supremum) {
     if (begin < 0 || end - begin != span) {
       return false;
     }
-
     int min = (char)minimum;
     int sup = (char)supremum;
     if (firstKey == lastKey) {
@@ -1663,8 +1662,8 @@ public boolean contains(long minimum, long supremum) {
     if (!highLowContainer.getContainerAtIndex(begin).contains(min, 1 << 16)) {
       return false;
     }
-    if (end < len && !highLowContainer.getContainerAtIndex(end)
-            .contains(0, (supremum & 0xFFFF) == 0 ? 0x10000 : sup)) {
+    if (sup != 0 && end < len && !highLowContainer.getContainerAtIndex(end)
+            .contains(0, sup)) {
       return false;
     }
     for (int i = begin + 1; i < end; ++i) {

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -1117,8 +1117,8 @@ public boolean contains(long minimum, long supremum) {
     if (!highLowContainer.getContainerAtIndex(begin).contains(min, 1 << 16)) {
       return false;
     }
-    if (end < len && !highLowContainer.getContainerAtIndex(end)
-            .contains(0, (supremum & 0xFFFF) == 0 ? 0x10000 : sup)) {
+    if (sup != 0 && end < len && !highLowContainer.getContainerAtIndex(end)
+            .contains(0, sup)) {
       return false;
     }
     for (int i = begin + 1; i < end; ++i) {

File: RoaringBitmap/src/main/java/org/roaringbitmap/art/Node4.java
Patch:
@@ -118,7 +118,7 @@ public Node remove(int pos) {
       children[pos] = children[pos + 1];
     }
     if (count == 1) {
-      //shrink to leaf node
+      //shrink to the child node
       Node child = children[0];
       byte newLength = (byte) (child.prefixLength + this.prefixLength + 1);
       byte[] newPrefix = new byte[newLength];

File: RoaringBitmap/src/main/java/org/roaringbitmap/longlong/LongUtils.java
Patch:
@@ -2,6 +2,8 @@
 
 public class LongUtils {
 
+  public static final long MAX_UNSIGNED_INT = Integer.toUnsignedLong(0xFFFFFFFF);
+
   /**
    * get the high 48 bit parts of the input data
    *

File: RoaringBitmap/src/main/java/org/roaringbitmap/RangeBitmap.java
Patch:
@@ -1544,7 +1544,9 @@ private void append() {
               : (toSerialize instanceof RunContainer) ? RUN : ARRAY;
           int required = serializedSize + (type == BITMAP ? 3 : 1);
           if (containers.capacity() - serializedContainerSize < required) {
-            containers = growBuffer(containers, containerGrowth() * 1024);
+            int growthFactor = 8192 * slice.length;
+            int newSize = Math.max(growthFactor, (required + 8191) & -8192);
+            containers = growBuffer(containers, newSize);
           }
           containers.put(serializedContainerSize, (byte) type);
           if (type == BITMAP) {

File: RoaringBitmap/src/main/java/org/roaringbitmap/ImmutableBitmapDataProvider.java
Patch:
@@ -190,15 +190,15 @@ public default IntStream reverseStream() {
 
   /**
    * Get the first (smallest) integer in this RoaringBitmap,
-   * that is, returns the minimum of the set.
+   * that is, return the minimum of the set.
    * @return the first (smallest) integer
    * @throws NoSuchElementException if empty
    */
   int first();
 
   /**
    * Get the last (largest) integer in this RoaringBitmap,
-   * that is, returns the maximum of the set.
+   * that is, return the maximum of the set.
    * @return the last (largest) integer
    * @throws NoSuchElementException if empty
    */

File: RoaringBitmap/src/main/java/org/roaringbitmap/longlong/Roaring64NavigableMap.java
Patch:
@@ -37,7 +37,7 @@ public class Roaring64NavigableMap implements Externalizable, LongBitmapDataProv
   // negative long
   private boolean signedLongs = false;
 
-  private BitmapDataProviderSupplier supplier;
+  private transient BitmapDataProviderSupplier supplier;
 
   // By default, we cache cardinalities
   private transient boolean doCacheCardinalities = true;

File: RoaringBitmap/src/test/java/org/roaringbitmap/longlong/TestRoaring64Bitmap.java
Patch:
@@ -2224,7 +2224,7 @@ public void testRangeAroundLongMax() {
   @Test
   public void testRangeExtremeEnd() {
     Roaring64Bitmap x = newDefaultCtor();
-    x.add(-3L, -1L);
+    x.addRange(-3L, -1L);
 
     Assertions.assertEquals(2L, x.getLongCardinality());
     Assertions.assertArrayEquals(x.toArray(), new long[] {-3L, -2L});

File: RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -1182,10 +1182,10 @@ public boolean intersects(long minimum, long supremum) {
     int supKey = (int)(supremum >>> 16);
     int length = highLowContainer.size;
     char[] keys = highLowContainer.keys;
-    int offset = lowbitsAsInteger(minimum);
     int limit = lowbitsAsInteger(supremum);
     int index = Util.unsignedBinarySearch(keys, 0, length, (char)minKey);
     int pos = index >= 0 ? index : -index - 1;
+    int offset = index >= 0 ? lowbitsAsInteger(minimum) : 0;
     if (pos < length && supKey == (keys[pos])) {
       if (supKey > minKey) {
         offset = 0;

File: RoaringBitmap/src/main/java/org/roaringbitmap/art/BackwardShuttle.java
Patch:
@@ -32,7 +32,7 @@ protected int boundaryNodePosition(Node node, boolean inRunDirection) {
 
   @Override
   protected boolean prefixMismatchIsInRunDirection(byte nodeValue, byte highValue) {
-    return nodeValue > highValue;
+    return Byte.toUnsignedInt(nodeValue) > Byte.toUnsignedInt(highValue);
   }
 
   @Override

File: RoaringBitmap/src/main/java/org/roaringbitmap/art/ForwardShuttle.java
Patch:
@@ -32,7 +32,7 @@ protected int boundaryNodePosition(Node node, boolean inRunDirection) {
 
   @Override
   protected boolean prefixMismatchIsInRunDirection(byte nodeValue, byte highValue) {
-    return nodeValue < highValue;
+    return Byte.toUnsignedInt(nodeValue) < Byte.toUnsignedInt(highValue);
   }
 
   @Override

File: RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBatchIterator.java
Patch:
@@ -39,6 +39,9 @@ public BatchIterator clone() {
       if (null != iterator) {
         it.iterator = iterator.clone();
       }
+      it.arrayBatchIterator = null;
+      it.bitmapBatchIterator = null;
+      it.runBatchIterator = null;
       return it;
     } catch (CloneNotSupportedException e) {
       // won't happen

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/RoaringBatchIterator.java
Patch:
@@ -57,6 +57,9 @@ public BatchIterator clone() {
       if (null != containerPointer) {
         it.containerPointer = containerPointer.clone();
       }
+      it.arrayBatchIterator = null;
+      it.bitmapBatchIterator = null;
+      it.runBatchIterator = null;
       return it;
     } catch (CloneNotSupportedException e) {
       // won't happen

File: bsi/src/test/java/org/roaringbitmap/bsi/BufferBSITest.java
Patch:
@@ -23,7 +23,7 @@
  * TestBase
  *
  */
-public class BufferBSITestBase {
+public class BufferBSITest {
 
     private Map<Integer, Integer> testDataSet = new HashMap<>();
 
@@ -210,7 +210,8 @@ public void testEQ() {
 
         ImmutableRoaringBitmap bitmap = bsi.toImmutableBitSliceIndex().rangeEQ(null, 1);
         Assertions.assertTrue(bitmap.getLongCardinality() == 50L);
-
+        ImmutableRoaringBitmap bitmap129 = bsi.toImmutableBitSliceIndex().rangeEQ(null, 129);
+        Assertions.assertTrue(bitmap129.getLongCardinality() == 0L);
     }
 
 

File: bsi/src/test/java/org/roaringbitmap/bsi/RBBsiTest.java
Patch:
@@ -12,10 +12,10 @@
 import java.util.stream.IntStream;
 
 /**
- * RBBsiTestBase
+ * RBBsiTest
  * created by haihuang@alibaba-inc.com on 2021/6/6
  */
-public class RBBsiTestBase {
+public class RBBsiTest {
     private Map<Integer, Integer> testDataSet = new HashMap<>();
 
     private RoaringBitmapSliceIndex bsi;

File: RoaringBitmap/src/main/java/org/roaringbitmap/RangeBitmap.java
Patch:
@@ -672,7 +672,7 @@ private void andLowAndHigh() {
               .limit(skip >>> 1);
           MappeableArrayContainer array = new MappeableArrayContainer(cb, size);
           low.and(array);
-          low.and(array);
+          high.and(array);
           position += skip;
         }
         break;

File: RoaringBitmap/src/main/java/org/roaringbitmap/RangeBitmap.java
Patch:
@@ -606,7 +606,7 @@ private Container containerForSlice(int sliceNumber) {
      * @return a mask with a multiple of 8 contiguous bits set.
      */
     private static long rangeMaxForLimit(long maxValue) {
-      int lz = Long.numberOfLeadingZeros(maxValue);
+      int lz = Long.numberOfLeadingZeros(maxValue | 1);
       return lz <= 8 ? -1L : (1L << ((64 - lz + 7) & -8)) - 1;
     }
   }

File: RoaringBitmap/src/main/java/org/roaringbitmap/RangeBitmap.java
Patch:
@@ -606,7 +606,7 @@ private Container containerForSlice(int sliceNumber) {
      * @return a mask with a multiple of 8 contiguous bits set.
      */
     private static long rangeMaxForLimit(long maxValue) {
-      int lz = Long.numberOfLeadingZeros(maxValue);
+      int lz = Long.numberOfLeadingZeros(maxValue | 1);
       return lz <= 8 ? -1L : (1L << ((64 - lz + 7) & -8)) - 1;
     }
   }

File: RoaringBitmap/src/main/java/org/roaringbitmap/RangeBitmap.java
Patch:
@@ -77,7 +77,7 @@ public static RangeBitmap map(ByteBuffer buffer) {
     long mask = sliceCount == 64 ? -1L : (1L << sliceCount) - 1;
     long maxRid = source.getInt() & 0xFFFFFFFFL;
     int masksOffset = source.position();
-    int containersOffset = masksOffset + (maxKey + 1) * (sliceCount >>> 3);
+    int containersOffset = masksOffset + maxKey * (sliceCount >>> 3);
     return new RangeBitmap(mask, maxRid,
         (ByteBuffer) source.position(buffer.position()), masksOffset, containersOffset);
   }
@@ -353,7 +353,7 @@ public int serializedSizeInBytes() {
           + slicesSize
           + maxKeySize
           + maxRidSize;
-      int keysSize = (key + 1) * (Long.bitCount(rangeMask) >>> 3);
+      int keysSize = key * (Long.bitCount(rangeMask) >>> 3);
       return headerSize + keysSize + serializedContainerSize;
     }
 
@@ -379,7 +379,7 @@ public void serialize(ByteBuffer buffer) {
       target.put((byte) Long.bitCount(rangeMask));
       target.putChar((char) key);
       target.putInt(rid);
-      int spaceForKeys = (key + 1) * (Long.bitCount(rangeMask) >>> 3);
+      int spaceForKeys = key * (Long.bitCount(rangeMask) >>> 3);
       target.put(((ByteBuffer) maskBuffer.slice()
           .order(LITTLE_ENDIAN).limit(spaceForKeys)));
       target.put(((ByteBuffer) containers.slice()

File: RoaringBitmap/src/main/java/org/roaringbitmap/RangeBitmap.java
Patch:
@@ -77,7 +77,7 @@ public static RangeBitmap map(ByteBuffer buffer) {
     long mask = sliceCount == 64 ? -1L : (1L << sliceCount) - 1;
     long maxRid = source.getInt() & 0xFFFFFFFFL;
     int masksOffset = source.position();
-    int containersOffset = masksOffset + (maxKey + 1) * (sliceCount >>> 3);
+    int containersOffset = masksOffset + maxKey * (sliceCount >>> 3);
     return new RangeBitmap(mask, maxRid,
         (ByteBuffer) source.position(buffer.position()), masksOffset, containersOffset);
   }
@@ -353,7 +353,7 @@ public int serializedSizeInBytes() {
           + slicesSize
           + maxKeySize
           + maxRidSize;
-      int keysSize = (key + 1) * (Long.bitCount(rangeMask) >>> 3);
+      int keysSize = key * (Long.bitCount(rangeMask) >>> 3);
       return headerSize + keysSize + serializedContainerSize;
     }
 
@@ -379,7 +379,7 @@ public void serialize(ByteBuffer buffer) {
       target.put((byte) Long.bitCount(rangeMask));
       target.putChar((char) key);
       target.putInt(rid);
-      int spaceForKeys = (key + 1) * (Long.bitCount(rangeMask) >>> 3);
+      int spaceForKeys = key * (Long.bitCount(rangeMask) >>> 3);
       target.put(((ByteBuffer) maskBuffer.slice()
           .order(LITTLE_ENDIAN).limit(spaceForKeys)));
       target.put(((ByteBuffer) containers.slice()

File: RoaringBitmap/src/main/java/org/roaringbitmap/RangeBitmap.java
Patch:
@@ -74,7 +74,7 @@ public static RangeBitmap map(ByteBuffer buffer) {
     }
     int sliceCount = source.get() & 0xFF;
     int maxKey = source.getChar();
-    long mask = (1L << sliceCount) - 1;
+    long mask = sliceCount == 64 ? -1L : (1L << sliceCount) - 1;
     long maxRid = source.getInt() & 0xFFFFFFFFL;
     int masksOffset = source.position();
     int containersOffset = masksOffset + (maxKey + 1) * (sliceCount >>> 3);
@@ -113,7 +113,7 @@ public RoaringBitmap lte(long threshold) {
    * @return a bitmap of matching rows.
    */
   public RoaringBitmap lt(long threshold) {
-    return threshold <= 0 ? new RoaringBitmap() : lte(threshold - 1);
+    return threshold == 0 ? new RoaringBitmap() : lte(threshold - 1);
   }
 
   /**
@@ -133,7 +133,7 @@ public RoaringBitmap gt(long threshold) {
    * @return a bitmap of matching rows.
    */
   public RoaringBitmap gte(long threshold) {
-    return threshold <= 0 ? RoaringBitmap.bitmapOfRange(0, max) : gt(threshold - 1);
+    return threshold == 0 ? RoaringBitmap.bitmapOfRange(0, max) : gt(threshold - 1);
   }
 
   private RoaringBitmap evaluateRange(long threshold, boolean upper) {

File: RoaringBitmap/src/main/java/org/roaringbitmap/RangeBitmap.java
Patch:
@@ -74,7 +74,7 @@ public static RangeBitmap map(ByteBuffer buffer) {
     }
     int sliceCount = source.get() & 0xFF;
     int maxKey = source.getChar();
-    long mask = (1L << sliceCount) - 1;
+    long mask = sliceCount == 64 ? -1L : (1L << sliceCount) - 1;
     long maxRid = source.getInt() & 0xFFFFFFFFL;
     int masksOffset = source.position();
     int containersOffset = masksOffset + (maxKey + 1) * (sliceCount >>> 3);
@@ -113,7 +113,7 @@ public RoaringBitmap lte(long threshold) {
    * @return a bitmap of matching rows.
    */
   public RoaringBitmap lt(long threshold) {
-    return threshold <= 0 ? new RoaringBitmap() : lte(threshold - 1);
+    return threshold == 0 ? new RoaringBitmap() : lte(threshold - 1);
   }
 
   /**
@@ -133,7 +133,7 @@ public RoaringBitmap gt(long threshold) {
    * @return a bitmap of matching rows.
    */
   public RoaringBitmap gte(long threshold) {
-    return threshold <= 0 ? RoaringBitmap.bitmapOfRange(0, max) : gt(threshold - 1);
+    return threshold == 0 ? RoaringBitmap.bitmapOfRange(0, max) : gt(threshold - 1);
   }
 
   private RoaringBitmap evaluateRange(long threshold, boolean upper) {

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MappeableArrayContainer.java
Patch:
@@ -261,7 +261,6 @@ public void andInto(long[] bits) {
     for (int i = 0; i < this.getCardinality(); ++i) {
       int value = content.get(i);
       Util.resetBitmapRange(bits, prev, value);
-      bits[value >>> 6] &= (1L << value);
       prev = value + 1;
     }
     Util.resetBitmapRange(bits, prev, MAX_CAPACITY);

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MappeableArrayContainer.java
Patch:
@@ -261,7 +261,6 @@ public void andInto(long[] bits) {
     for (int i = 0; i < this.getCardinality(); ++i) {
       int value = content.get(i);
       Util.resetBitmapRange(bits, prev, value);
-      bits[value >>> 6] &= (1L << value);
       prev = value + 1;
     }
     Util.resetBitmapRange(bits, prev, MAX_CAPACITY);

File: RoaringBitmap/src/main/java/org/roaringbitmap/art/Node48.java
Patch:
@@ -145,7 +145,7 @@ public int getNextSmallerPos(int pos) {
     }
     pos--;
     int i = pos >>> INDEX_SHIFT;
-    for (; i >= 0; i--) {
+    for (; i >= 0 && i < LONGS_USED; i--) {
       long longv = childIndex[i];
       if (longv == INIT_LONG_VALUE) {
         //skip over empty bytes

File: RoaringBitmap/src/main/java/org/roaringbitmap/art/Shuttle.java
Patch:
@@ -17,7 +17,7 @@ public interface Shuttle {
 
   /**
    *
-   * @return true: has a LeafNode ,false: has no LeafNode
+   * @return true: has a LeafNode, false: has no LeafNode
    */
   public boolean moveToNextLeaf();
 

File: RoaringBitmap/src/main/java/org/roaringbitmap/longlong/Roaring64Bitmap.java
Patch:
@@ -903,7 +903,7 @@ PeekableCharIterator getIterator(Container container) {
     
     @Override
     boolean compare(long next, long val) {
-      return next >= val;
+      return Long.compareUnsigned(next, val) >= 0;
     }
   }
 
@@ -919,7 +919,7 @@ PeekableCharIterator getIterator(Container container) {
     
     @Override
     boolean compare(long next, long val) {
-      return next <= val;
+      return Long.compareUnsigned(next, val) <= 0;
     }
   }
 }

File: RoaringBitmap/src/main/java/org/roaringbitmap/Container.java
Patch:
@@ -903,7 +903,7 @@ public Container or(Container x) {
 
 
   /**
-   * Computes the bitwise OR of this container with another (symmetric difference). This container
+   * Computes the bitwise XOR of this container with another (symmetric difference). This container
    * as well as the provided container are left unaffected.
    *
    * @param x other parameter

File: RoaringBitmap/src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -2503,7 +2503,7 @@ public void forEach(char msb, IntConsumer ic) {
     for(int k = 0; k < this.nbrruns; ++k) {
       int base = this.getValue(k) | high;
       int le = this.getLength(k);
-      for (int l = base; l <= base + le; ++l) {
+      for(int l = base; l - le <= base; ++l) {
         ic.accept(l);
       }
     }

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MappeableRunContainer.java
Patch:
@@ -2443,7 +2443,7 @@ public void forEach(char msb, IntConsumer ic) {
     for(int k = 0; k < this.nbrruns; ++k) {
       int base = (this.getValue(k) & 0xFFFF) | high;
       int le = this.getLength(k) & 0xFFFF;
-      for(int l = base; l <= base + le; ++l ) {
+      for(int l = base; l - le <= base; ++l) {
         ic.accept(l);
       }
     }

File: RoaringBitmap/src/test/java/org/roaringbitmap/longlong/TestRoaring64Bitmap.java
Patch:
@@ -211,7 +211,7 @@ public void testAddOneSelect2() {
   public void testAddInt() {
     Roaring64Bitmap map = newDefaultCtor();
     map.addInt(-1);
-    assertEquals(4294967295L, map.select(0));
+    assertEquals(0xFFFFFFFFL, map.select(0));
   }
 
   @Test
@@ -912,11 +912,11 @@ public void testToString() {
   @Test
   public void testInvalidIntMask() {
     Roaring64Bitmap map = new Roaring64Bitmap();
-    int a = 0xFFFF;  // -1 in two's compliment
+    int a = 0xFFFFFFFF;  // -1 in two's compliment
     map.addInt(a);
     assertEquals(map.getIntCardinality(), 1);
     long addedInt = map.getLongIterator().next();
-    assertEquals(0xFFFFL, addedInt);
+    assertEquals(0xFFFFFFFFL, addedInt);
   }
 
   @Test

File: RoaringBitmap/src/main/java/org/roaringbitmap/longlong/Roaring64Bitmap.java
Patch:
@@ -36,7 +36,7 @@ public Roaring64Bitmap() {
   }
 
   public void addInt(int x) {
-    addLong(x);
+    addLong(Util.toUnsignedLong(x));
   }
 
   /**

File: RoaringBitmap/src/main/java/org/roaringbitmap/art/AbstractShuttle.java
Patch:
@@ -58,7 +58,7 @@ public boolean moveToNextLeaf() {
       int pos;
       int nextPos;
       if (!currentNodeEntry.visited) {
-        pos = currentNodeEntry.node.getMinPos();
+        pos = boundaryNodePosition(currentNodeEntry.node);
         currentNodeEntry.position = pos;
         nextPos = pos;
         currentNodeEntry.visited = true;

File: RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java
Patch:
@@ -153,8 +153,8 @@ public Node remove(int pos) {
     children[pos] = null;
     ByteBuffer byteBuffer = ByteBuffer.allocate(16).order(ByteOrder.BIG_ENDIAN);
     byte[] bytes = byteBuffer.putLong(firstV).putLong(secondV).array();
-    System.arraycopy(bytes, pos + 1, bytes, pos, count - pos);
-    System.arraycopy(children, pos + 1, children, pos, count - pos);
+    System.arraycopy(bytes, pos + 1, bytes, pos, (16 - pos - 1));
+    System.arraycopy(children, pos + 1, children, pos, (16 - pos - 1));
     firstV = byteBuffer.getLong(0);
     secondV = byteBuffer.getLong(8);
     count--;

File: RoaringBitmap/src/main/java/org/roaringbitmap/art/Node4.java
Patch:
@@ -107,7 +107,7 @@ public Node remove(int pos) {
     assert pos < count;
     children[pos] = null;
     count--;
-    key = IntegerUtil.shiftLeftFromSpecifiedPosition(key, pos, count);
+    key = IntegerUtil.shiftLeftFromSpecifiedPosition(key, pos, (4 - pos - 1));
     for (; pos < count; pos++) {
       children[pos] = children[pos + 1];
     }

File: shims/src/java11/java/org/roaringbitmap/ArraysShim.java
Patch:
@@ -36,6 +36,9 @@ public static boolean equals(char[] x, int xmin, int xmax, char[] y, int ymin, i
    */
   public static int mismatch(byte[] a, int aFromIndex, int aToIndex,
       byte[] b, int bFromIndex, int bToIndex) {
+    if (bFromIndex > bToIndex) {
+      return -1;
+    }
     return Arrays.mismatch(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex);
   }
 }

File: RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBatchIterator.java
Patch:
@@ -17,6 +17,9 @@ public RoaringBatchIterator(RoaringArray highLowContainer) {
 
   @Override
   public int nextBatch(int[] buffer) {
+    if (!hasNext()){
+      return 0;
+    }
     int consumed = 0;
     if (iterator.hasNext()) {
       consumed += iterator.next(key, buffer);

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/RoaringBatchIterator.java
Patch:
@@ -19,6 +19,9 @@ public RoaringBatchIterator(MappeableContainerPointer containerPointer) {
 
   @Override
   public int nextBatch(int[] buffer) {
+    if (!hasNext()){
+      return 0;
+    }
     int consumed = 0;
     if (iterator.hasNext()) {
       consumed += iterator.next(key, buffer);

File: RoaringBitmap/src/test/java/org/roaringbitmap/longlong/Node256Test.java
Patch:
@@ -34,6 +34,7 @@ public void test() {
     }
     node256 = (Node256) node256.remove(120);
     int pos119 = node256.getChildPos((byte) 119);
+    Assertions.assertEquals((byte) 119, node256.getChildKey(pos119));
     Assertions.assertEquals(119, pos119);
     int pos121 = node256.getNextLargerPos(pos119);
     Assertions.assertEquals(121, pos121);

File: RoaringBitmap/src/test/java/org/roaringbitmap/longlong/Node48Test.java
Patch:
@@ -32,8 +32,10 @@ public void test() throws IOException {
       Assertions.assertEquals(i, nextPos);
       LeafNode leafNode1 = (LeafNode) node48.getChild(nextPos);
       Assertions.assertEquals(i, leafNode1.getContainerIdx());
-      int childPos = node48.getChildPos((byte) i);
+      byte key = (byte) i;
+      int childPos = node48.getChildPos(key);
       Assertions.assertEquals(i, childPos);
+      Assertions.assertEquals(key, node48.getChildKey(childPos));
       currentPos = nextPos;
     }
     int maxPos = node48.getMaxPos();

File: RoaringBitmap/src/main/java/org/roaringbitmap/longlong/HighLowContainer.java
Patch:
@@ -111,6 +111,9 @@ public void serialize(ByteBuffer buffer) throws IOException {
     }
     art.serializeArt(byteBuffer);
     containers.serialize(byteBuffer);
+    if (byteBuffer != buffer) {
+      buffer.position(buffer.position() + byteBuffer.position());
+    }
   }
 
   /**

File: jmh/src/jmh/java/org/roaringbitmap/writer/WriteSequential.java
Patch:
@@ -27,7 +27,7 @@ RoaringBitmapWriter<RoaringBitmap> newWriter() {
       }
     }
     ;
-    abstract RoaringBitmapWriter newWriter();
+    abstract RoaringBitmapWriter<RoaringBitmap> newWriter();
   }
 
   @Param({"100", "1000", "10000", "100000", "1000000", "10000000"})

File: real-roaring-dataset/src/main/java/org/roaringbitmap/ZipRealDataRangeRetriever.java
Patch:
@@ -55,8 +55,7 @@ public boolean hasNext() {
 
           @Override
           public int[][] next() {
-            try {
-              BufferedReader buf = new BufferedReader(new InputStreamReader(zis));
+            try (BufferedReader buf = new BufferedReader(new InputStreamReader(zis))) {
               String oneLine = buf.readLine(); // a single, perhaps very long, line
               String[] positions = oneLine.split(",");
               int[][] ans = new int[positions.length][2];

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/BufferFastAggregation.java
Patch:
@@ -70,6 +70,7 @@ public static MutableRoaringBitmap and(Iterator<? extends ImmutableRoaringBitmap
    *
    * In practice, calls {#link workShyAnd}
    *
+   * @param aggregationBuffer a buffer for use in aggregations
    * @param bitmaps input bitmaps (ImmutableRoaringBitmap or MutableRoaringBitmap)
    * @return aggregated bitmap
    */

File: fuzz-tests/src/test/java/org/roaringbitmap/BufferFuzzer.java
Patch:
@@ -499,7 +499,7 @@ public void testFastAggregationAnd() {
                 bitmaps[j] = randomBitmap(512);
               }
               MutableRoaringBitmap naive = BufferFastAggregation.naive_and(bitmaps);
-              MutableRoaringBitmap workShy = BufferFastAggregation.workShyAnd(bitmaps);
+              MutableRoaringBitmap workShy = BufferFastAggregation.and(bitmaps);
               assertEquals(naive, workShy);
             });
   }

File: fuzz-tests/src/test/java/org/roaringbitmap/Fuzzer.java
Patch:
@@ -563,7 +563,7 @@ public void testFastAggregationAnd() {
                 bitmaps[j] = randomBitmap(512);
               }
               RoaringBitmap naive = FastAggregation.naive_and(bitmaps);
-              RoaringBitmap workShy = FastAggregation.workShyAnd(bitmaps);
+              RoaringBitmap workShy = FastAggregation.and(bitmaps);
               assertEquals(naive, workShy);
             });
   }

File: jmh/src/jmh/java/org/roaringbitmap/realdata/ParallelAggregatorBenchmark.java
Patch:
@@ -72,7 +72,7 @@ public RoaringBitmap fastOr() {
 
   @Benchmark
   public RoaringBitmap fastAnd() {
-    return FastAggregation.workShyAnd(bitmaps);
+    return FastAggregation.and(bitmaps);
   }
 
   @Benchmark

File: RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -2583,7 +2583,7 @@ public long previousValue(int fromValue) {
     char key = Util.highbits(fromValue);
     int containerIndex = highLowContainer.advanceUntil(key, -1);
     if (containerIndex == highLowContainer.size()) {
-      return -1L;
+      return last();
     }
     long prevSetBit = -1L;
     while (containerIndex != -1 && prevSetBit == -1L) {

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -1669,6 +1669,9 @@ public long nextValue(int fromValue) {
   public long previousValue(int fromValue) {
     char key = highbits(fromValue);
     int containerIndex = highLowContainer.advanceUntil(key, -1);
+    if (containerIndex == highLowContainer.size()) {
+      return last();
+    }
     long prevSetBit = -1L;
     while (containerIndex != -1 && containerIndex < highLowContainer.size() && prevSetBit == -1L) {
       char containerKey = highLowContainer.getKeyAtIndex(containerIndex);

File: RoaringBitmap/src/test/java/org/roaringbitmap/TestRoaringBitmap.java
Patch:
@@ -5277,11 +5277,11 @@ public void testPreviousValue() {
         long b1 = Util.toUnsignedLong(bitmap.last());
         int b2 = bitset.previousSetBit(Integer.MAX_VALUE);
         int i = bitmap.getCardinality();
-        while (b1 != -1 && b2 != -1) {
+        while (b1 > 0 && b2 > 0) {
             assertEquals(b1, b2);
             b1 = bitmap.previousValue((int) (b1 - 1));
             b2 = bitset.previousSetBit(b2 - 1);
-            assertEquals(b1, b2, "mismatch at " + i);
+            assertEquals(b1, b2, "mismatch at " + i + "(bitset=" + b2 + ", rb=" + b1 + ")");
             --i;
         }
     }

File: RoaringBitmap/src/test/java/org/roaringbitmap/RoaringBitmapIntervalIntersectionTest.java
Patch:
@@ -14,6 +14,7 @@ public class RoaringBitmapIntervalIntersectionTest {
   public static Object[][] params() {
     return new Object[][] {
             {RoaringBitmap.bitmapOf(1, 2, 3), 0, 1 << 16},
+            {RoaringBitmap.bitmapOf(1, 2, 3), 1, 1},
             {RoaringBitmap.bitmapOf(1 << 31 | 1 << 30), 0, 1 << 16},
             {RoaringBitmap.bitmapOf(1 << 31 | 1 << 30), 0, 256},
             {RoaringBitmap.bitmapOf(1, 1 << 31 | 1 << 30), 0, 256},
@@ -56,8 +57,8 @@ public void testIntersects() {
   public void testContains() {
     RoaringBitmap test = new RoaringBitmap();
     test.add(minimum, supremum);
-    Assert.assertEquals(bitmap.contains(test), bitmap.contains(minimum, supremum));
-    Assert.assertTrue(test.contains(minimum, supremum));
+    Assert.assertEquals(!test.isEmpty() && bitmap.contains(test), bitmap.contains(minimum, supremum));
+    Assert.assertTrue(test.isEmpty() || test.contains(minimum, supremum));
   }
 
   @Test

File: RoaringBitmap/src/test/java/org/roaringbitmap/buffer/RoaringBitmapIntervalIntersectionTest.java
Patch:
@@ -15,6 +15,7 @@ public class RoaringBitmapIntervalIntersectionTest {
   public static Object[][] params() {
     return new Object[][] {
             {RoaringBitmap.bitmapOf(1, 2, 3), 0, 1 << 16},
+            {RoaringBitmap.bitmapOf(1, 2, 3), 1, 1},
             {RoaringBitmap.bitmapOf(1 << 31 | 1 << 30), 0, 1 << 16},
             {RoaringBitmap.bitmapOf(1 << 31 | 1 << 30), 0, 256},
             {RoaringBitmap.bitmapOf(1, 1 << 31 | 1 << 30), 0, 256},
@@ -64,8 +65,8 @@ public void testIntersects() {
   public void testContains() {
     MutableRoaringBitmap test = new MutableRoaringBitmap();
     test.add(minimum, supremum);
-    Assert.assertEquals(bitmap.contains(test), bitmap.contains(minimum, supremum));
-    Assert.assertTrue(test.contains(minimum, supremum));
+    Assert.assertEquals(!test.isEmpty() && bitmap.contains(test), bitmap.contains(minimum, supremum));
+    Assert.assertTrue(test.isEmpty() || test.contains(minimum, supremum));
   }
 
   @Test

File: RoaringBitmap/src/test/java/org/roaringbitmap/RoaringBitmapIntervalIntersectionTest.java
Patch:
@@ -14,6 +14,7 @@ public class RoaringBitmapIntervalIntersectionTest {
   public static Object[][] params() {
     return new Object[][] {
             {RoaringBitmap.bitmapOf(1, 2, 3), 0, 1 << 16},
+            {RoaringBitmap.bitmapOf(1, 2, 3), 1, 1},
             {RoaringBitmap.bitmapOf(1 << 31 | 1 << 30), 0, 1 << 16},
             {RoaringBitmap.bitmapOf(1 << 31 | 1 << 30), 0, 256},
             {RoaringBitmap.bitmapOf(1, 1 << 31 | 1 << 30), 0, 256},
@@ -56,8 +57,8 @@ public void testIntersects() {
   public void testContains() {
     RoaringBitmap test = new RoaringBitmap();
     test.add(minimum, supremum);
-    Assert.assertEquals(bitmap.contains(test), bitmap.contains(minimum, supremum));
-    Assert.assertTrue(test.contains(minimum, supremum));
+    Assert.assertEquals(!test.isEmpty() && bitmap.contains(test), bitmap.contains(minimum, supremum));
+    Assert.assertTrue(test.isEmpty() || test.contains(minimum, supremum));
   }
 
   @Test

File: RoaringBitmap/src/test/java/org/roaringbitmap/buffer/RoaringBitmapIntervalIntersectionTest.java
Patch:
@@ -15,6 +15,7 @@ public class RoaringBitmapIntervalIntersectionTest {
   public static Object[][] params() {
     return new Object[][] {
             {RoaringBitmap.bitmapOf(1, 2, 3), 0, 1 << 16},
+            {RoaringBitmap.bitmapOf(1, 2, 3), 1, 1},
             {RoaringBitmap.bitmapOf(1 << 31 | 1 << 30), 0, 1 << 16},
             {RoaringBitmap.bitmapOf(1 << 31 | 1 << 30), 0, 256},
             {RoaringBitmap.bitmapOf(1, 1 << 31 | 1 << 30), 0, 256},
@@ -64,8 +65,8 @@ public void testIntersects() {
   public void testContains() {
     MutableRoaringBitmap test = new MutableRoaringBitmap();
     test.add(minimum, supremum);
-    Assert.assertEquals(bitmap.contains(test), bitmap.contains(minimum, supremum));
-    Assert.assertTrue(test.contains(minimum, supremum));
+    Assert.assertEquals(!test.isEmpty() && bitmap.contains(test), bitmap.contains(minimum, supremum));
+    Assert.assertTrue(test.isEmpty() || test.contains(minimum, supremum));
   }
 
   @Test

File: RoaringBitmap/src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -1092,7 +1092,8 @@ public Container or(final ArrayContainer value2) {
     return answer;
   }
 
-  protected boolean isFull() {
+  @Override
+  public boolean isFull() {
     return cardinality == MAX_CAPACITY;
   }
 

File: fuzz-tests/src/test/java/org/roaringbitmap/Fuzzer.java
Patch:
@@ -403,9 +403,8 @@ public void orNot() {
               RoaringBitmap range = new RoaringBitmap();
               long limit = toUnsignedLong(l.last()) + 1;
               range.add(0, limit);
-              RoaringBitmap rightFlipped = RoaringBitmap.and(r, range);
-              rightFlipped.flip(0, limit);
-              return RoaringBitmap.or(RoaringBitmap.and(l, range), rightFlipped);
+              range.andNot(r);
+              return RoaringBitmap.or(l, range);
             });
   }
 

File: RoaringBitmap/src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -1618,7 +1618,7 @@ public Container iremove(int begin, int end) {
 
       // last run is one shorter
       if (getLength(eIndex) == 0) {// special case where we remove last run
-        recoverRoomsInRange(eIndex, eIndex + 1);
+        recoverRoomsInRange(eIndex - 1, eIndex);
       } else {
         incrementValue(eIndex);
         decrementLength(eIndex);

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MappeableRunContainer.java
Patch:
@@ -1502,7 +1502,7 @@ public MappeableContainer iremove(int begin, int end) {
       }
       // last run is one charer
       if (getLength(eIndex) == 0) {// special case where we remove last run
-        recoverRoomsInRange(eIndex, eIndex + 1);
+        recoverRoomsInRange(eIndex - 1, eIndex);
       } else {
         incrementValue(eIndex);
         decrementLength(eIndex);

File: RoaringBitmap/src/main/java/org/roaringbitmap/Container.java
Patch:
@@ -221,6 +221,7 @@ public Container orNot(RunContainer x, int endOfRange) {
    * as the provided container are left unaffected.
    *
    * @param x other container
+   * @param endOfRange end of range (size of the universe)
    * @return aggregated container
    */
   public Container orNot(Container x, int endOfRange) {

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MappeableContainer.java
Patch:
@@ -218,6 +218,7 @@ public MappeableContainer orNot(MappeableRunContainer x, int endOfRange) {
    * as the provided container are left unaffected.
    *
    * @param x other container
+   * @param endOfRange end of range (size of the universe)
    * @return aggregated container
    */
   public MappeableContainer orNot(MappeableContainer x, int endOfRange) {

File: RoaringBitmap/src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -543,7 +543,7 @@ public Container iand(BitmapContainer value2) {
     for (int k = 0; k < cardinality; ++k) {
       char v = this.content[k];
       this.content[pos] = v;
-      pos += value2.bitValue(v);
+      pos += (int)value2.bitValue(v);
     }
     cardinality = pos;
     return this;
@@ -569,7 +569,7 @@ public ArrayContainer iandNot(BitmapContainer value2) {
     for (int k = 0; k < cardinality; ++k) {
       char v = this.content[k];
       this.content[pos] = v;
-      pos += 1 - value2.bitValue(v);
+      pos += 1 - (int)value2.bitValue(v);
     }
     this.cardinality = pos;
     return this;

File: RoaringBitmap/src/main/java/org/roaringbitmap/FastRankRoaringBitmap.java
Patch:
@@ -266,7 +266,7 @@ public long getLongSizeInBytes() {
     long size = 8;
     size += super.getLongSizeInBytes();
     if (highToCumulatedCardinality != null) {
-      size += 4 * highToCumulatedCardinality.length;
+      size += 4L * highToCumulatedCardinality.length;
     }
     return size;
   }

File: RoaringBitmap/src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -829,7 +829,7 @@ protected boolean contains(BitmapContainer bitmapContainer) {
         int start = (getValue(ir));
         int stop = start+ (getLength(ir));
         long t = w & -w;
-        long r = ib * 64 + Long.numberOfTrailingZeros(w);
+        long r = ib * 64L + Long.numberOfTrailingZeros(w);
         if (r < start) {
           return false;
         } else if(r > stop) {

File: examples/src/main/java/CompressionResults.java
Patch:
@@ -30,7 +30,7 @@ public static void testSuperDense() {
     int howmany = 100;
     int gap = universe_size / howmany;
     for (int i = 1; i < howmany; i++) {
-      r.add(i * gap+1,((i+1) * gap));
+      r.add(i * gap + 1,((i + 1) * gap));
     }
     System.out.println("Adding "+r.getCardinality()+" values partionned by "+howmany+" gaps of 1 ...");
     System.out.println("As a bitmap it would look like 01111...11011111... ");

File: RoaringBitmap/src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -121,7 +121,7 @@ protected RunContainer(ArrayContainer arr, int nbrRuns) {
     int runCount = 0;
 
     for (int i = 0; i < arr.cardinality; i++) {
-      int curVal = (arr.content[i]);
+      int curVal = arr.content[i];
       if (curVal == prevVal + 1) {
         ++runLen;
       } else {
@@ -960,8 +960,8 @@ public boolean equals(Object o) {
   }
 
   private boolean equals(RunContainer rc) {
-    return ArraysShim.equals(valueslength, 0, nbrruns,
-            rc.valueslength, 0, rc.nbrruns);
+    return ArraysShim.equals(valueslength, 0, 2 * nbrruns,
+            rc.valueslength, 0, 2 * rc.nbrruns);
   }
 
   private boolean equals(ArrayContainer arrayContainer) {

File: RoaringBitmap/src/main/java/org/roaringbitmap/AppendableStorage.java
Patch:
@@ -12,6 +12,6 @@ public interface AppendableStorage<T> {
    * @param key the key to append
    * @param container the data to append
    */
-  void append(short key, T container);
+  void append(char key, T container);
 
 }

File: RoaringBitmap/src/main/java/org/roaringbitmap/ArrayBatchIterator.java
Patch:
@@ -1,6 +1,6 @@
 package org.roaringbitmap;
 
-import static org.roaringbitmap.Util.toIntUnsigned;
+
 
 public final class ArrayBatchIterator implements ContainerBatchIterator {
 
@@ -14,9 +14,9 @@ public ArrayBatchIterator(ArrayContainer array) {
   @Override
   public int next(int key, int[] buffer) {
     int consumed = 0;
-    short[] data = array.content;
+    char[] data = array.content;
     while (consumed < buffer.length && index < array.getCardinality()) {
-      buffer[consumed++] = key + toIntUnsigned(data[index++]);
+      buffer[consumed++] = key + (data[index++]);
     }
     return consumed;
   }

File: RoaringBitmap/src/main/java/org/roaringbitmap/BitSetUtil.java
Patch:
@@ -22,14 +22,14 @@ public class BitSetUtil {
   private static ArrayContainer arrayContainerOf(final int from, final int to,
       final int cardinality, final long[] words) {
     // precondition: cardinality is max 4096
-    final short[] content = new short[cardinality];
+    final char[] content = new char[cardinality];
     int index = 0;
 
     for (int i = from, socket = 0; i < to; ++i, socket += Long.SIZE) {
       long word = words[i];
       while (word != 0) {
         long t = word & -word;
-        content[index++] = (short) (socket + Long.bitCount(t - 1));
+        content[index++] = (char) (socket + Long.bitCount(t - 1));
         word ^= t;
       }
     }

File: RoaringBitmap/src/main/java/org/roaringbitmap/ConstantMemoryContainerAppender.java
Patch:
@@ -74,7 +74,7 @@ public T getUnderlying() {
    */
   @Override
   public void add(int value) {
-    int key = toIntUnsigned(highbits(value));
+    int key = (highbits(value));
     if (key != currentKey) {
       if (key < currentKey) {
         underlying.add(value);
@@ -84,7 +84,7 @@ public void add(int value) {
         currentKey = key;
       }
     }
-    int low = toIntUnsigned(lowbits(value));
+    int low = (lowbits(value));
     bitmap[(low >>> 6)] |= (1L << low);
     dirty = true;
   }
@@ -133,7 +133,7 @@ private Container chooseBestContainer() {
   private int appendToUnderlying() {
     if (dirty) {
       assert currentKey <= 0xFFFF;
-      underlying.append((short) currentKey, chooseBestContainer());
+      underlying.append((char) currentKey, chooseBestContainer());
       Arrays.fill(bitmap, 0L);
       dirty = false;
       return 1;

File: RoaringBitmap/src/main/java/org/roaringbitmap/ContainerAppender.java
Patch:
@@ -71,7 +71,7 @@ public T getUnderlying() {
    */
   @Override
   public void add(int value) {
-    int key = toIntUnsigned(highbits(value));
+    int key = (highbits(value));
     if (key != currentKey) {
       if (key < currentKey) {
         underlying.add(value);
@@ -125,7 +125,7 @@ public void reset() {
   private int appendToUnderlying() {
     if (!container.isEmpty()) {
       assert currentKey <= 0xFFFF;
-      underlying.append((short)currentKey, container.runOptimize());
+      underlying.append((char) currentKey, container.runOptimize());
       container = newContainer.get();
       return 1;
     }

File: RoaringBitmap/src/main/java/org/roaringbitmap/ContainerPointer.java
Patch:
@@ -58,5 +58,5 @@ public interface ContainerPointer extends Comparable<ContainerPointer>, Cloneabl
    * 
    * @return the key
    */
-  short key();
+  char key();
 }

File: RoaringBitmap/src/main/java/org/roaringbitmap/PeekableCharRankIterator.java
Patch:
@@ -1,9 +1,9 @@
 package org.roaringbitmap;
 
 /**
- * PeekableShortIterator that calculates the next value rank during iteration
+ * PeekableCharIterator that calculates the next value rank during iteration
  */
-public interface PeekableShortRankIterator extends PeekableShortIterator {
+public interface PeekableCharRankIterator extends PeekableCharIterator {
 
   /**
    * peek in-container rank of the next value
@@ -16,5 +16,5 @@ public interface PeekableShortRankIterator extends PeekableShortIterator {
   int peekNextRank();
 
   @Override
-  PeekableShortRankIterator clone();
+  PeekableCharRankIterator clone();
 }

File: RoaringBitmap/src/main/java/org/roaringbitmap/RunBatchIterator.java
Patch:
@@ -1,6 +1,6 @@
 package org.roaringbitmap;
 
-import static org.roaringbitmap.Util.toIntUnsigned;
+
 
 public final class RunBatchIterator implements ContainerBatchIterator {
 
@@ -16,8 +16,8 @@ public RunBatchIterator(RunContainer runs) {
   public int next(int key, int[] buffer) {
     int consumed = 0;
     do {
-      int runStart = toIntUnsigned(runs.getValue(run));
-      int runLength = toIntUnsigned(runs.getLength(run));
+      int runStart = (runs.getValue(run));
+      int runLength = (runs.getLength(run));
       int chunkStart = runStart + cursor;
       int chunkEnd = chunkStart + Math.min(runLength - cursor, buffer.length - consumed - 1);
       int chunk = chunkEnd - chunkStart + 1;

File: RoaringBitmap/src/main/java/org/roaringbitmap/WordStorage.java
Patch:
@@ -2,7 +2,7 @@
 
 public interface WordStorage<T> {
 
-  T add(short value);
+  T add(char value);
 
   boolean isEmpty();
 

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MappeableContainerPointer.java
Patch:
@@ -57,7 +57,7 @@ public interface MappeableContainerPointer
    * 
    * @return boolean indicated if it is a bitmap container
    */
-  public boolean isBitmapContainer();
+  boolean isBitmapContainer();
 
   /**
    * Returns true if it is a run container (MappeableRunContainer).
@@ -72,7 +72,7 @@ public interface MappeableContainerPointer
    * 
    * @return the key
    */
-  short key();
+  char key();
 
   /**
    * Move to the previous container

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/RunBatchIterator.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.roaringbitmap.ContainerBatchIterator;
 
-import static org.roaringbitmap.buffer.BufferUtil.toIntUnsigned;
+
 
 public final class RunBatchIterator implements ContainerBatchIterator {
 
@@ -18,8 +18,8 @@ public RunBatchIterator(MappeableRunContainer runs) {
   public int next(int key, int[] buffer) {
     int consumed = 0;
     do {
-      int runStart = toIntUnsigned(runs.getValue(run));
-      int runLength = toIntUnsigned(runs.getLength(run));
+      int runStart = (runs.getValue(run));
+      int runLength = (runs.getLength(run));
       int chunkStart = runStart + cursor;
       int chunkEnd = chunkStart + Math.min(runLength - cursor, buffer.length - consumed - 1);
       int chunk = chunkEnd - chunkStart + 1;

File: RoaringBitmap/src/test/java/org/roaringbitmap/ContainerBatchIteratorTest.java
Patch:
@@ -110,7 +110,7 @@ private void test(int batchSize) {
     private Container createContainer() {
         Container container = new ArrayContainer();
         for (int value : expectedValues) {
-            container = container.add((short) value);
+            container = container.add((char) value);
         }
         return container.runOptimize();
     }

File: RoaringBitmap/src/test/java/org/roaringbitmap/RoaringBitmapWriterRandomisedTest.java
Patch:
@@ -8,7 +8,7 @@
 import java.util.Arrays;
 import java.util.Random;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 import static org.roaringbitmap.RoaringBitmapWriter.writer;
 import static org.roaringbitmap.Util.toUnsignedLong;
 

File: RoaringBitmap/src/test/java/org/roaringbitmap/TestBitSetUtil.java
Patch:
@@ -1,11 +1,11 @@
 package org.roaringbitmap;
 
-import static org.junit.Assert.*;
+import org.junit.Test;
 
 import java.util.BitSet;
 import java.util.Random;
 
-import org.junit.Test;
+import static org.junit.Assert.assertTrue;
 
 public class TestBitSetUtil {
   private static BitSet appendRandomBitset(final Random random, final int offset,

File: RoaringBitmap/src/test/java/org/roaringbitmap/TestFastAggregation.java
Patch:
@@ -4,9 +4,7 @@
 
 import java.util.Arrays;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.*;
 
 public class TestFastAggregation {
 

File: RoaringBitmap/src/test/java/org/roaringbitmap/TestMemory.java
Patch:
@@ -1,10 +1,10 @@
 package org.roaringbitmap;
 
-import java.util.Random;
-
 import org.junit.Assert;
 import org.junit.Test;
 
+import java.util.Random;
+
 public class TestMemory {
   @Test
   public void testGCStability() throws Throwable {

File: RoaringBitmap/src/test/java/org/roaringbitmap/TestRangeCardinality.java
Patch:
@@ -40,7 +40,7 @@ public TestRangeCardinality(int[] elements, int begin, int end, int expected) {
     public void testCardinalityInBitmapWordRange() {
         BitmapContainer bc = new BitmapContainer();
         for (int e : elements) {
-            bc.add((short) e);
+            bc.add((char) e);
         }
         Assert.assertEquals(expected, Util.cardinalityInBitmapRange(bc.bitmap, begin, end));
     }

File: RoaringBitmap/src/test/java/org/roaringbitmap/TestRankIterator.java
Patch:
@@ -14,8 +14,8 @@
 import java.util.stream.IntStream;
 
 import static junit.framework.TestCase.assertTrue;
-import static org.roaringbitmap.SeededTestData.randomBitmap;
 import static org.roaringbitmap.RoaringBitmapWriter.writer;
+import static org.roaringbitmap.SeededTestData.randomBitmap;
 
 @RunWith(Parameterized.class)
 public class TestRankIterator {

File: RoaringBitmap/src/test/java/org/roaringbitmap/TestRoaringBitmap_FastRank.java
Patch:
@@ -3,11 +3,11 @@
  */
 package org.roaringbitmap;
 
-import java.util.Random;
-
 import org.junit.Assert;
 import org.junit.Test;
 
+import java.util.Random;
+
 
 /**
  * Check FastRankRoaringBitmap dismiss the caches cardinalities when necessary

File: RoaringBitmap/src/test/java/org/roaringbitmap/TestSerializedSize.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertTrue;
 
 public class TestSerializedSize {
   

File: RoaringBitmap/src/test/java/org/roaringbitmap/buffer/BufferContainerBatchIteratorTest.java
Patch:
@@ -154,7 +154,7 @@ private void test(int batchSize) {
     private MappeableContainer createContainer() {
         MappeableContainer container = new MappeableArrayContainer();
         for (int value : expectedValues) {
-            container = container.add((short) value);
+            container = container.add((char) value);
         }
         return container.runOptimize();
     }

File: RoaringBitmap/src/test/java/org/roaringbitmap/buffer/MutableRoaringArrayTest.java
Patch:
@@ -9,7 +9,7 @@ public class MutableRoaringArrayTest {
 
   @Test
   public void resizeOnlyIfNecessary() {
-    short[] keys = new short[1];
+    char[] keys = new char[1];
     int size = 0;
     MappeableContainer[] values = new MappeableContainer[1];
     MutableRoaringArray array = new MutableRoaringArray(keys, values, size);

File: RoaringBitmap/src/test/java/org/roaringbitmap/buffer/TestBitSetUtil.java
Patch:
@@ -1,11 +1,11 @@
 package org.roaringbitmap.buffer;
 
-import static org.junit.Assert.*;
+import org.junit.Test;
 
 import java.util.BitSet;
 import java.util.Random;
 
-import org.junit.Test;
+import static org.junit.Assert.assertTrue;
 
 public class TestBitSetUtil {
   private static BitSet appendRandomBitset(final Random random, final int offset,

File: RoaringBitmap/src/test/java/org/roaringbitmap/buffer/TestBufferRangeCardinality.java
Patch:
@@ -43,7 +43,7 @@ public void testCardinalityInBitmapWordRange() {
         LongBuffer array = ByteBuffer.allocateDirect(MappeableBitmapContainer.MAX_CAPACITY / 8).asLongBuffer();
         MappeableBitmapContainer bc = new MappeableBitmapContainer(array, 0);
         for (int e : elements) {
-            bc.add((short) e);
+            bc.add((char) e);
         }
         Assert.assertEquals(false, bc.isArrayBacked());
         Assert.assertEquals(expected, BufferUtil.cardinalityInBitmapRange(bc.bitmap, begin, end));

File: RoaringBitmap/src/test/java/org/roaringbitmap/buffer/TestCompressionRates.java
Patch:
@@ -4,10 +4,10 @@
 
 package org.roaringbitmap.buffer;
 
-import static org.junit.Assert.assertTrue;
-
 import org.junit.Test;
 
+import static org.junit.Assert.assertTrue;
+
 public class TestCompressionRates {
 
   @Test

File: RoaringBitmap/src/test/java/org/roaringbitmap/buffer/TestIntIteratorFlyweight.java
Patch:
@@ -8,7 +8,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import com.google.common.primitives.Ints;
-
 import org.junit.Assert;
 import org.junit.Test;
 import org.roaringbitmap.IntIterator;

File: RoaringBitmap/src/test/java/org/roaringbitmap/buffer/TestMemory.java
Patch:
@@ -1,10 +1,10 @@
 package org.roaringbitmap.buffer;
 
-import java.util.Random;
-
 import org.junit.Assert;
 import org.junit.Test;
 
+import java.util.Random;
+
 public class TestMemory {
   @Test
   public void testGCStability() throws Throwable {

File: RoaringBitmap/src/test/java/org/roaringbitmap/buffer/TestRange.java
Patch:
@@ -1,12 +1,12 @@
 package org.roaringbitmap.buffer;
 
-import static org.junit.Assert.*;
+import org.junit.Test;
+import org.roaringbitmap.IntIterator;
 
 import java.util.BitSet;
 import java.util.Random;
 
-import org.junit.Test;
-import org.roaringbitmap.IntIterator;
+import static org.junit.Assert.*;
 
 
 public class TestRange {

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -54,7 +54,7 @@
  *       MutableRoaringBitmap rr2 = MutableRoaringBitmap.bitmapOf(2, 3, 1010);
  *       ByteArrayOutputStream bos = new ByteArrayOutputStream();
  *       DataOutputStream dos = new DataOutputStream(bos);
- *       // could call "rr1.runOptimize()" and "rr2.runOptimize" if 
+ *       // could call "rr1.runOptimize()" and "rr2.runOptimize" if
  *       // there were runs to compress
  *       rr1.serialize(dos);
  *       rr2.serialize(dos);
@@ -1167,7 +1167,7 @@ public boolean contains(final int x) {
    * Checks if the bitmap contains the range.
    * @param minimum the inclusive lower bound of the range
    * @param supremum the exclusive upper bound of the range
-   * @return whether the bitmap intersects with the range
+   * @return whether the bitmap contains the range
    */
   public boolean contains(long minimum, long supremum) {
     MutableRoaringBitmap.rangeSanityCheck(minimum, supremum);

File: RoaringBitmap/src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -1059,7 +1059,7 @@ public int numberOfRunsAdjustment() {
   public int numberOfRunsLowerBound(int mustNotExceed) {
     int numRuns = 0;
 
-    for (int blockOffset = 0; blockOffset < bitmap.length; blockOffset += BLOCKSIZE) {
+    for (int blockOffset = 0; blockOffset + BLOCKSIZE <= bitmap.length; blockOffset += BLOCKSIZE) {
 
       for (int i = blockOffset; i < blockOffset + BLOCKSIZE; i++) {
         long word = bitmap[i];

File: RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MappeableBitmapContainer.java
Patch:
@@ -1395,7 +1395,7 @@ public int numberOfRunsLowerBound(int mustNotExceed) {
     if (BufferUtil.isBackedBySimpleArray(bitmap)) {
       long[] b = bitmap.array();
 
-      for (int blockOffset = 0; blockOffset < b.length; blockOffset += BLOCKSIZE) {
+      for (int blockOffset = 0; blockOffset + BLOCKSIZE <= b.length; blockOffset += BLOCKSIZE) {
 
         for (int i = blockOffset; i < blockOffset + BLOCKSIZE; i++) {
           long word = b[i];

File: roaringbitmap/src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -690,6 +690,9 @@ public boolean intersects(RunContainer x) {
 
   @Override
   public boolean intersects(int minimum, int supremum) {
+    if((minimum < 0) || (supremum < minimum) || (supremum > (1<<16))) {
+      throw new RuntimeException("This should never happen (bug).");
+    }
     int pos = Util.unsignedBinarySearch(content, 0, cardinality, (short)minimum);
     int index = pos >= 0 ? pos : -pos - 1;
     return index < cardinality && toIntUnsigned(content[index]) < supremum;

File: roaringbitmap/src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -718,6 +718,9 @@ public boolean intersects(RunContainer x) {
 
   @Override
   public boolean intersects(int minimum, int supremum) {
+    if((minimum < 0) || (supremum < minimum) || (supremum > (1<<16))) {
+      throw new RuntimeException("This should never happen (bug).");
+    }
     int start = minimum >>> 6;
     int end = supremum >>> 6;
     if (start == end) {

File: roaringbitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -1137,7 +1137,7 @@ public boolean intersects(long minimum, long supremum) {
     // seek to start
     int index = Util.unsignedBinarySearch(keys, 0, len, minKey);
     int pos = index >= 0 ? index : -index - 1;
-    short offset = Util.lowbits(minimum);
+    int offset = Util.lowbitsAsInteger(minimum);
     while (pos < len && Util.compareUnsigned(supKey, keys[pos]) > 0) {
       Container container = highLowContainer.getContainerAtIndex(pos);
       if (container.intersects(offset, 1 << 16)) {

File: roaringbitmap/src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -1473,6 +1473,9 @@ public boolean intersects(RunContainer x) {
 
   @Override
   public boolean intersects(int minimum, int supremum) {
+    if((minimum < 0) || (supremum < minimum) || (supremum > (1<<16))) {
+      throw new RuntimeException("This should never happen (bug).");
+    }
     for (int i = 0; i < numberOfRuns(); ++i) {
       short runFirstValue = getValue(i);
       short runLastValue = (short) (runFirstValue + getLength(i));

File: roaringbitmap/src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -1156,7 +1156,7 @@ public boolean intersects(long minimum, long supremum) {
             && compareUnsigned(minKey, highLowContainer.getKeyAtIndex(pos)) > 0) {
       ++pos;
     }
-    short offset = lowbits(minimum);
+    int offset = BufferUtil.lowbitsAsInteger(minimum);
     while (pos < len
             && compareUnsigned(supKey, highLowContainer.getKeyAtIndex(pos)) > 0) {
       MappeableContainer container = highLowContainer.getContainerAtIndex(pos);
@@ -1169,7 +1169,7 @@ && compareUnsigned(supKey, highLowContainer.getKeyAtIndex(pos)) > 0) {
     return pos < len
             && supKey == highLowContainer.getKeyAtIndex(pos)
             && highLowContainer.getContainerAtIndex(pos)
-            .intersects((short) 0, (int)((supremum - 1) & 0xFFFF) + 1);
+            .intersects(offset, (int)((supremum - 1) & 0xFFFF) + 1);
   }
 
   /**

File: roaringbitmap/src/main/java/org/roaringbitmap/buffer/MappeableArrayContainer.java
Patch:
@@ -1785,6 +1785,9 @@ protected boolean contains(MappeableBitmapContainer bitmapContainer) {
 
   @Override
   public boolean intersects(int minimum, int supremum) {
+    if((minimum < 0) || (supremum < minimum) || (supremum > (1<<16))) {
+      throw new RuntimeException("This should never happen (bug).");
+    }
     int pos = BufferUtil.unsignedBinarySearch(content, 0, cardinality, (short)minimum);
     int index = pos >= 0 ? pos : -pos - 1;
     return index < cardinality && BufferUtil.toIntUnsigned(content.get(index)) < supremum;

File: roaringbitmap/src/main/java/org/roaringbitmap/buffer/MappeableBitmapContainer.java
Patch:
@@ -1995,6 +1995,9 @@ protected boolean contains(MappeableBitmapContainer bitmapContainer) {
 
   @Override
   public boolean intersects(int minimum, int supremum) {
+    if((minimum < 0) || (supremum < minimum) || (supremum > (1<<16))) {
+      throw new RuntimeException("This should never happen (bug).");
+    }
     int start = minimum >>> 6;
     int end = supremum >>> 6;
     if (start == end) {

File: roaringbitmap/src/test/java/org/roaringbitmap/TestBitmapContainer.java
Patch:
@@ -710,7 +710,7 @@ public void testIntersectsWithRangeUnsigned() {
     assertTrue(container.intersects(0, lower16Bits(-40)));
     assertFalse(container.intersects(lower16Bits(-100), lower16Bits(-55)));
     assertFalse(container.intersects(lower16Bits(-9), lower16Bits(-1)));
-    assertTrue(container.intersects(11, (short)-1));
+    //assertTrue(container.intersects(11, (short)-1)); // forbidden
   }
 
   @Test

File: roaringbitmap/src/test/java/org/roaringbitmap/TestRunContainer.java
Patch:
@@ -3394,7 +3394,7 @@ public void testIntersectsWithRangeUnsigned() {
     assertFalse(container.intersects(0, 1));
     assertTrue(container.intersects(0, lower16Bits(-40)));
     assertFalse(container.intersects(lower16Bits(-100), lower16Bits(-55)));
-    assertFalse(container.intersects(-9, 1 << 16));
+    //assertFalse(container.intersects(-9, 1 << 16)); // forbidden
     assertTrue(container.intersects(11, 1 << 16));
   }
 

File: roaringbitmap/src/test/java/org/roaringbitmap/buffer/TestMappeableBitmapContainer.java
Patch:
@@ -718,7 +718,7 @@ public void testIntersectsWithRangeUnsigned() {
     assertTrue(container.intersects(0, lower16Bits(-40)));
     assertFalse(container.intersects(lower16Bits(-100), lower16Bits(-55)));
     assertFalse(container.intersects(lower16Bits(-9), lower16Bits(-1)));
-    assertTrue(container.intersects(11, (short)-1));
+    //assertTrue(container.intersects(11, (short)-1));// forbidden
   }
 
   @Test

File: roaringbitmap/src/test/java/org/roaringbitmap/buffer/TestRunContainer.java
Patch:
@@ -2458,7 +2458,7 @@ public void testIntersectsWithRangeUnsigned() {
     assertFalse(container.intersects(0, 1));
     assertTrue(container.intersects(0, lower16Bits(-40)));
     assertFalse(container.intersects(lower16Bits(-100), lower16Bits(-55)));
-    assertFalse(container.intersects(-9, 1 << 16));
+    //assertFalse(container.intersects(-9, 1 << 16));// forbidden
     assertTrue(container.intersects(11, 1 << 16));
   }
 

File: roaringbitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -1140,7 +1140,7 @@ public boolean intersects(long minimum, long supremum) {
     return pos < len
             && supKey == keys[pos]
             && highLowContainer.getContainerAtIndex(pos)
-                               .intersects(0, (int)((supremum - 1) & 0xFFFF) + 1);
+                               .intersects(offset, (int)((supremum - 1) & 0xFFFF) + 1);
   }
 
 

File: roaringbitmap/src/main/java/org/roaringbitmap/RoaringArray.java
Patch:
@@ -948,7 +948,9 @@ public void serialize(ByteBuffer buffer) {
     for (int k = 0; k < size; ++k) {
       values[k].writeArray(buf);
     }
-    buffer.position(buf.position());
+    if (buf != buffer) {
+      buffer.position(buffer.position() + buf.position());
+    }
   }
 
   /**

File: roaringbitmap/src/main/java/org/roaringbitmap/buffer/MutableRoaringArray.java
Patch:
@@ -732,7 +732,9 @@ public void serialize(ByteBuffer buffer) {
     for (int k = 0; k < size; ++k) {
       values[k].writeArray(buf);
     }
-    buffer.position(buf.position());
+    if (buf != buffer) {
+      buffer.position(buffer.position() + buf.position());
+    }
   }
 
   /**

File: real-roaring-dataset/src/main/java/org/roaringbitmap/ZipRealDataRangeRetriever.java
Patch:
@@ -34,6 +34,8 @@ public String getName() {
   /**
    * 
    * Returns next range from file
+   * @return some Iterable
+   * @throws IOException it can happen
    */
   public Iterable<int[][]> fetchNextRange() throws IOException {
     final ZipInputStream zis = getResourceAsStream();

File: roaringbitmap/src/main/java/org/roaringbitmap/buffer/ImmutableRoaringArray.java
Patch:
@@ -33,8 +33,8 @@ public final class ImmutableRoaringArray implements PointableRoaringArray {
 
   /**
    * Create an array based on a previously serialized ByteBuffer. The input ByteBuffer is
-   * effectively copied (with the slice operation) so you should expect the provided ByteBuffer to
-   * remain unchanged.
+   * effectively copied (with the slice operation) so you should expect the provided ByteBuffer
+   * position/mark/limit/order to remain unchanged.
    *
    * @param bbf The source ByteBuffer
    */

File: roaringbitmap/src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -956,7 +956,7 @@ protected ImmutableRoaringBitmap() {
    * is more) by setting b.position(b.position() + bitmap.serializedSizeInBytes());
    *
    * Note that the input ByteBuffer is effectively copied (with the slice operation) so you should
-   * expect the provided ByteBuffer to remain unchanged.
+   * expect the provided ByteBuffer position/mark/limit/order to remain unchanged.
    *
    * This constructor may throw IndexOutOfBoundsException if the input is invalid/corrupted.
    * This constructor throws an InvalidRoaringFormat if the provided input

File: roaringbitmap/src/main/java/org/roaringbitmap/insights/BitmapStatistics.java
Patch:
@@ -31,6 +31,8 @@ public class BitmapStatistics {
 
   /**
    * Calculates what fraction of all containers is the `containerTypeCount`
+   * @param containerTypeCount denominator
+   * @return some fraction
    */
   public double containerFraction(long containerTypeCount) {
     if (containerCount() == 0) {
@@ -127,6 +129,7 @@ ArrayContainersStats merge(ArrayContainersStats other) {
 
     /**
      * Average cardinality of ArrayContainers
+     * @return the average
      */
     public long averageCardinality() {
       if (containersCount == 0) {

File: roaringbitmap/src/main/java/org/roaringbitmap/insights/NaiveWriterRecommender.java
Patch:
@@ -8,6 +8,8 @@ public class NaiveWriterRecommender {
   /**
    * Based on the statistics it applies expert rules
    * to help tuning the {@link org.roaringbitmap.RoaringBitmapWriter}
+   * @param s statistics
+   * @return some message
    */
   public static String recommend(BitmapStatistics s) {
     if (s.containerCount() == 0) {

File: roaringbitmap/src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -1441,7 +1441,7 @@ void wrap(ArrayContainer p) {
     pos = 0;
   }
 
-};
+}
 
 
 final class ReverseArrayContainerShortIterator implements ShortIterator {

File: roaringbitmap/src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -1134,7 +1134,7 @@ public BitmapContainer toBitmapContainer() {
   @Override
   public int nextValue(short fromValue) {
     int index = Util.advanceUntil(content, -1, cardinality, fromValue);
-    if (index == content.length) {
+    if (index == cardinality) {
       return fromValue == content[cardinality - 1] ? toIntUnsigned(fromValue) : -1;
     }
     return toIntUnsigned(content[index]);
@@ -1143,7 +1143,7 @@ public int nextValue(short fromValue) {
   @Override
   public int previousValue(short fromValue) {
     int index = Util.advanceUntil(content, -1, cardinality, fromValue);
-    if (content.length != index && content[index] == fromValue) {
+    if (index != cardinality && content[index] == fromValue) {
       return toIntUnsigned(content[index]);
     }
     return index == 0 ? -1 : toIntUnsigned(content[index - 1]);

File: roaringbitmap/src/main/java/org/roaringbitmap/BatchIntIterator.java
Patch:
@@ -30,10 +30,9 @@ public boolean hasNext() {
     if (i < mark) {
       return true;
     }
-    if (!delegate.hasNext()) {
+    if (!delegate.hasNext() || (mark = delegate.nextBatch(buffer)) == 0) {
       return false;
     }
-    mark = delegate.nextBatch(buffer);
     i = 0;
     return true;
   }

File: roaringbitmap/src/test/java/org/roaringbitmap/RoaringBitmapBatchIteratorTest.java
Patch:
@@ -28,6 +28,9 @@ public static Object[][] params() {
                 {testCase().withRunAt((1 << 15) | (1 << 11)).withBitmapAt((1 << 15) | (1 << 12)).withArrayAt((1 << 15) | (1 << 13)).withBitmapAt((1 << 15) | (1 << 14)).build()},
                 {RoaringBitmap.bitmapOf(IntStream.range(1 << 10, 1 << 26).filter(i -> (i & 1) == 0).toArray())},
                 {RoaringBitmap.bitmapOf(IntStream.range(1 << 10, 1 << 25).filter(i -> ((i >>> 8) & 1) == 0).toArray())},
+                {RoaringBitmap.bitmapOf(IntStream.range(0,127).toArray())},
+                {RoaringBitmap.bitmapOf(IntStream.range(0,1024).toArray())},
+                {RoaringBitmap.bitmapOf(IntStream.concat(IntStream.range(0,256), IntStream.range(1 << 16, (1 << 16) | 256)).toArray())},
                 {new RoaringBitmap()}
         };
     }

File: roaringbitmap/src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -1326,8 +1326,8 @@ public void advanceIfNeeded(short minval) {
   }
 
   @Override
-  public short peekNextRank() {
-    return (short) (pos + 1);
+  public int peekNextRank() {
+    return pos + 1;
   }
 
   @Override

File: roaringbitmap/src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -1471,14 +1471,14 @@ public short peekNext() {
 
 final class BitmapContainerShortRankIterator extends BitmapContainerShortIterator
     implements PeekableShortRankIterator {
-  short nextRank = 1;
+  int nextRank = 1;
 
   public BitmapContainerShortRankIterator(long[] p) {
     super(p);
   }
 
   @Override
-  public short peekNextRank() {
+  public int peekNextRank() {
     return nextRank;
   }
 

File: roaringbitmap/src/main/java/org/roaringbitmap/FastRankRoaringBitmap.java
Patch:
@@ -294,7 +294,7 @@ private FastRoaringIntRankIterator() {
 
     @Override
     public int peekNextRank() {
-      int iterRank = Util.toIntUnsigned(iter.peekNextRank());
+      int iterRank = iter.peekNextRank();
       if (pos > 0) {
         return FastRankRoaringBitmap.this.highToCumulatedCardinality[pos - 1] + iterRank;
       } else {

File: roaringbitmap/src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -2693,7 +2693,7 @@ public short peekNext() {
 class RunContainerShortRankIterator extends RunContainerShortIterator
     implements PeekableShortRankIterator {
 
-  short nextRank = 1;
+  int nextRank = 1;
 
   public RunContainerShortRankIterator(RunContainer p) {
     super(p);
@@ -2736,7 +2736,7 @@ public void advanceIfNeeded(short minval) {
   }
 
   @Override
-  public short peekNextRank() {
+  public int peekNextRank() {
     return nextRank;
   }
 

File: roaringbitmap/src/test/java/org/roaringbitmap/TestRankIterator.java
Patch:
@@ -17,7 +17,8 @@
 @RunWith(Parameterized.class)
 public class TestRankIterator {
 
-  @Parameterized.Parameters(name = "{index}: advance by {1}")
+  @SuppressWarnings("unchecked")
+@Parameterized.Parameters(name = "{index}: advance by {1}")
   public static Collection<Object[]> parameters() {
     RoaringBitmap bm = RandomisedTestData.randomBitmap(1 << 12);
     FastRankRoaringBitmap fast = new FastRankRoaringBitmap();
@@ -52,7 +53,6 @@ public void testAdvance() {
       System.out.println("next: " + ms + "ms");
     } else {
       testBitmapRanksOnAdvance(bitmap, advance);
-      long end = System.nanoTime();
       long ms = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
       System.out.println("advance by " + advance + ": " + ms + "ms");
     }

File: roaringbitmap/src/test/java/org/roaringbitmap/TestRoaringBitmap_FastRank.java
Patch:
@@ -368,7 +368,7 @@ public void testDismissCache_addLongRange() {
   public void testDismissCache_addIntRange() {
     FastRankRoaringBitmap fast = prepareFastWithComputedCache();
 
-    fast.add(0, 2);
+    fast.add(0L, 2L);
     Assert.assertTrue(fast.isCacheDismissed());
   }
 
@@ -400,7 +400,7 @@ public void testDismissCache_flip() {
   public void testDismissCache_flipIntRange() {
     FastRankRoaringBitmap fast = prepareFastWithComputedCache();
 
-    fast.flip(0, 2);
+    fast.flip(0L, 2);
     Assert.assertTrue(fast.isCacheDismissed());
   }
 
@@ -424,7 +424,7 @@ public void testDismissCache_remove() {
   public void testDismissCache_removeIntRange() {
     FastRankRoaringBitmap fast = prepareFastWithComputedCache();
 
-    fast.remove(0, 2);
+    fast.remove(0L, 2);
     Assert.assertTrue(fast.isCacheDismissed());
   }
 

File: roaringbitmap/src/test/java/org/roaringbitmap/buffer/BufferContainerBatchIteratorTest.java
Patch:
@@ -4,8 +4,6 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
-import org.roaringbitmap.ArrayContainer;
-import org.roaringbitmap.Container;
 import org.roaringbitmap.ContainerBatchIterator;
 import org.roaringbitmap.RandomisedTestData;
 

File: roaringbitmap/src/test/java/org/roaringbitmap/buffer/RoaringBitmapIntervalIntersectionTest.java
Patch:
@@ -5,7 +5,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.roaringbitmap.RoaringBitmap;
-import org.roaringbitmap.Util;
 
 import static org.roaringbitmap.RandomisedTestData.TestDataSet.testCase;
 

File: roaringbitmap/src/test/java/org/roaringbitmap/buffer/TestFastAggregation.java
Patch:
@@ -135,7 +135,7 @@ public void testBigOrMapped() {
     ImmutableRoaringBitmap data2 = toMapped(rb2);
     ImmutableRoaringBitmap data3 = toMapped(rb3);
     MutableRoaringBitmap mrb = data1.clone().toMutableRoaringBitmap();
-    mrb.add(100,10000);
+    mrb.add(100L,10000L);
     Assert.assertEquals(mrb, BufferFastAggregation.or(data1,data2,data3));
   }
 

File: jmh/src/main/java/org/roaringbitmap/RandomData.java
Patch:
@@ -63,7 +63,7 @@ private static int[] createSorted16BitInts(int howMany) {
   }
 
   private static RoaringBitmap forKeys(int[] keys, double rleLimit, double denseLimit) {
-    OrderedWriter writer = new OrderedWriter();
+    DenseOrderedWriter writer = new DenseOrderedWriter();
     IntStream.of(keys)
             .forEach(key -> {
               double choice = ThreadLocalRandom.current().nextDouble();

File: jmh/src/main/java/org/roaringbitmap/iteration/Concatenation.java
Patch:
@@ -101,7 +101,7 @@ public RoaringBitmap roaringOffset() {
   @Benchmark
   public RoaringBitmap roaringBatchOrderedWriter() {
     int[] buffer = new int[256];
-    OrderedWriter writer = new OrderedWriter();
+    DenseOrderedWriter writer = new DenseOrderedWriter();
       for(int i = 0; i < bitSets.length; ++i) {
         BitSetWithOffset bit = bitSets[i];
         RoaringBatchIterator iterator = bit.bitmap.getBatchIterator();

File: roaringbitmap/src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -70,7 +70,7 @@ public ArrayContainer(final int firstOfRun, final int lastOfRun) {
   }
 
   /**
-   * Create a new container, no copy is made
+   * Create a new container from existing values array. This copies the data.
    *
    * @param newCard desired cardinality
    * @param newContent actual values (length should equal or exceed cardinality)

File: roaringbitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -535,7 +535,7 @@ public static RoaringBitmap bitmapOf(final int... dat) {
   public static RoaringBitmap bitmapOfUnordered(final int... data) {
     partialRadixSort(data);
     RoaringBitmap bitmap = new RoaringBitmap();
-    OrderedWriter writer = new OrderedWriter(bitmap);
+    OrderedWriter writer = new DenseOrderedWriter(bitmap);
     for (int i : data) {
       writer.add(i);
     }

File: roaringbitmap/src/test/java/org/roaringbitmap/OrderedWriterRandomisedTest.java
Patch:
@@ -39,7 +39,7 @@ public OrderedWriterRandomisedTest(int[] values) {
   public void shouldBuildSameBitmapAsBitmapOf() {
     RoaringBitmap baseline = RoaringBitmap.bitmapOf(values);
     RoaringBitmap rb = new RoaringBitmap();
-    OrderedWriter writer = new OrderedWriter(rb);
+    DenseOrderedWriter writer = new DenseOrderedWriter(rb);
     for (int i : values) {
       writer.add(i);
     }

File: roaringbitmap/src/test/java/org/roaringbitmap/RandomisedTestData.java
Patch:
@@ -12,7 +12,7 @@ public class RandomisedTestData {
 
   public static RoaringBitmap randomBitmap(int maxKeys, double rleLimit, double denseLimit) {
     int[] keys = createSorted16BitInts(ThreadLocalRandom.current().nextInt(1, maxKeys));
-    OrderedWriter writer = new OrderedWriter();
+    DenseOrderedWriter writer = new DenseOrderedWriter();
     IntStream.of(keys)
             .forEach(key -> {
               double choice = ThreadLocalRandom.current().nextDouble();
@@ -86,7 +86,7 @@ public static TestDataSet testCase() {
       return new TestDataSet();
     }
 
-    OrderedWriter writer = new OrderedWriter();
+    DenseOrderedWriter writer = new DenseOrderedWriter();
     private List<Long> ranges = new ArrayList<>();
 
     public TestDataSet withRunAt(int key) {

File: roaringbitmap/src/test/java/org/roaringbitmap/TestConcatenation.java
Patch:
@@ -118,7 +118,7 @@ public void canSerializeAndDeserializeBuffer() throws IOException {
 
   private static RoaringBitmap read(String classPathResource) {
     try {
-      OrderedWriter writer = new OrderedWriter();
+      DenseOrderedWriter writer = new DenseOrderedWriter();
       Arrays.stream(Files.readFirstLine(new File(classPathResource), Charset.forName("UTF-8")).split(","))
               .mapToInt(Integer::parseInt)
               .forEach(writer::add);

File: roaringbitmap/src/test/java/org/roaringbitmap/TestRoaringBitmap.java
Patch:
@@ -4654,7 +4654,7 @@ public void testContainsRange_SmallBitmap() {
 
   @Test
   public void testContainsRange_DirtyBitmap() {
-    OrderedWriter writer = new OrderedWriter();
+    DenseOrderedWriter writer = new DenseOrderedWriter();
     IntStream.range(0, 1_000_000)
             .map(i -> i * 2)
             .forEach(writer::add);

File: roaringbitmap/src/main/java/org/roaringbitmap/RoaringArray.java
Patch:
@@ -101,6 +101,7 @@ protected int advanceUntil(short x, int pos) {
   }
 
   protected void append(short key, Container value) {
+    assert !value.isEmpty();
     extendArray(1);
     this.keys[this.size] = key;
     this.values[this.size] = value;

File: roaringbitmap/src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -2217,6 +2217,7 @@ void smartAppend(short start, short length) {
     if ((nbrruns == 0) || (toIntUnsigned(start) > (oldend =
         toIntUnsigned(getValue(nbrruns - 1)) + toIntUnsigned(getLength(nbrruns - 1)))
         + 1)) { // we add a new one
+      ensureCapacity(nbrruns + 1);
       valueslength[2 * nbrruns] = start;
       valueslength[2 * nbrruns + 1] = length;
       nbrruns++;

File: roaringbitmap/src/main/java/org/roaringbitmap/buffer/MappeableRunContainer.java
Patch:
@@ -2085,6 +2085,7 @@ void smartAppend(short start, short length) {
     if ((nbrruns == 0) || (toIntUnsigned(start) > (oldend =
           toIntUnsigned(getValue(nbrruns - 1)) + toIntUnsigned(getLength(nbrruns - 1)))
           + 1)) { // we add a new one
+      ensureCapacity(nbrruns + 1);
       valueslength.put(2 * nbrruns, start);
       valueslength.put(2 * nbrruns + 1, length);
       nbrruns++;

File: roaringbitmap/src/main/java/org/roaringbitmap/buffer/MutableRoaringArray.java
Patch:
@@ -100,6 +100,7 @@ public int advanceUntil(short x, int pos) {
   }
 
   protected void append(short key, MappeableContainer value) {
+    assert !value.isEmpty();
     extendArray(1);
     this.keys[this.size] = key;
     this.values[this.size] = value;

File: roaringbitmap/src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -834,7 +834,7 @@ protected boolean contains(BitmapContainer bitmapContainer) {
     while(ib < bitmapContainer.bitmap.length && ir < runCount) {
       long w = bitmapContainer.bitmap[ib];
       while (w != 0 && ir < runCount) {
-        short start = getValue(ir);
+        int start = Util.toIntUnsigned(getValue(ir));
         int stop = start+ toIntUnsigned(getLength(ir));
         long t = w & -w;
         long r = ib * 64 + Long.numberOfTrailingZeros(w);

File: roaringbitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -2198,7 +2198,7 @@ public long nextValue(int fromValue) {
     short key = Util.highbits(fromValue);
     int containerIndex = highLowContainer.advanceUntil(key, -1);
     long nextSetBit = -1L;
-    while (containerIndex != -1 && containerIndex < highLowContainer.size() && fromValue == -1L) {
+    while (containerIndex != -1 && containerIndex < highLowContainer.size() && nextSetBit == -1L) {
       short containerKey = highLowContainer.getKeyAtIndex(containerIndex);
       Container container = highLowContainer.getContainerAtIndex(containerIndex);
       int bit = (Util.compareUnsigned(containerKey, key) > 0

File: roaringbitmap/src/test/java/org/roaringbitmap/TestRoaringBitmap.java
Patch:
@@ -4692,7 +4692,7 @@ public void addoffset() {
   }
 
   @Test
-  public void testNextSetBit() {
+  public void testNextValue() {
     RoaringBitmap bitmap = RandomisedTestData.TestDataSet.testCase()
             .withRunAt(0)
             .withBitmapAt(1)
@@ -4707,7 +4707,7 @@ public void testNextSetBit() {
     long b1 = 0;
     int b2 = 0;
     while (b1 >= 0 && b2 >= 0) {
-      b1 = bitmap.nextSetBit((int)b1 + 1);
+      b1 = bitmap.nextValue((int)b1 + 1);
       b2 = bitset.nextSetBit(b2 + 1);
       assertEquals(b1, b2);
     }

File: roaringbitmap/src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -2211,7 +2211,7 @@ private void smartAppend(short val) {
     }
   }
 
-  private void smartAppend(short start, short length) {
+  void smartAppend(short start, short length) {
     int oldend;
     if ((nbrruns == 0) || (toIntUnsigned(start) > (oldend =
         toIntUnsigned(getValue(nbrruns - 1)) + toIntUnsigned(getLength(nbrruns - 1)))
@@ -2355,7 +2355,7 @@ Container toBitmapOrArrayContainer(int card) {
   }
 
   // convert to bitmap or array *if needed*
-  private Container toEfficientContainer() {
+  Container toEfficientContainer() {
     int sizeAsRunContainer = RunContainer.serializedSizeInBytes(this.nbrruns);
     int sizeAsBitmapContainer = BitmapContainer.serializedSizeInBytes(0);
     int card = this.getCardinality();

File: roaringbitmap/src/test/java/org/roaringbitmap/buffer/TestAdversarialInputs.java
Patch:
@@ -199,7 +199,7 @@ public void testInputBadFile7() throws IOException {
 	}
 
 
-	@Test(expected = IndexOutOfBoundsException.class)
+	@Test(expected = IllegalArgumentException.class)
 	public void testInputBadFile7Mapped() throws IOException {
 		ByteBuffer bb = memoryMap("testdata/crashproneinput7.bin");
 		ImmutableRoaringBitmap rb = new ImmutableRoaringBitmap(bb);

File: roaringbitmap/src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -1104,10 +1104,10 @@ public String toString() {
     StringBuilder sb = new StringBuilder();
     sb.append("{");
     for (int i = 0; i < this.cardinality - 1; i++) {
-      sb.append(this.content[i]);
+      sb.append(Util.toIntUnsigned(this.content[i]));
       sb.append(",");
     }
-    sb.append(this.content[this.cardinality - 1]);
+    sb.append(Util.toIntUnsigned(this.content[this.cardinality - 1]));
     sb.append("}");
     return sb.toString();
   }

File: roaringbitmap/src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -1229,7 +1229,7 @@ public String toString() {
     final ShortIterator i = this.getShortIterator();
     sb.append("{");
     while (i.hasNext()) {
-      sb.append(i.next());
+      sb.append(Util.toIntUnsigned(i.next()));
       if (i.hasNext()) {
         sb.append(",");
       }

File: roaringbitmap/src/main/java/org/roaringbitmap/buffer/MappeableArrayContainer.java
Patch:
@@ -1396,10 +1396,10 @@ public String toString() {
     final StringBuilder sb = new StringBuilder();
     sb.append("{");
     for (int i = 0; i < this.cardinality - 1; i++) {
-      sb.append(this.content.get(i));
+      sb.append(toIntUnsigned(this.content.get(i)));
       sb.append(",");
     }
-    sb.append(this.content.get(this.cardinality - 1));
+    sb.append(toIntUnsigned(this.content.get(this.cardinality - 1)));
     sb.append("}");
     return sb.toString();
   }

File: roaringbitmap/src/main/java/org/roaringbitmap/buffer/MappeableBitmapContainer.java
Patch:
@@ -1717,7 +1717,7 @@ public String toString() {
     final ShortIterator i = this.getShortIterator();
     sb.append("{");
     while (i.hasNext()) {
-      sb.append(i.next());
+      sb.append(BufferUtil.toIntUnsigned(i.next()));
       if (i.hasNext()) {
         sb.append(",");
       }

File: roaringbitmap/src/main/java/org/roaringbitmap/buffer/MappeableRunContainer.java
Patch:
@@ -2274,7 +2274,7 @@ public String toString() {
       sb.append(toIntUnsigned(this.getValue(k)));
       sb.append(",");
       sb.append(toIntUnsigned(this.getValue(k))
-          + toIntUnsigned(this.getLength(k)) + 1);
+          + toIntUnsigned(this.getLength(k)));
       sb.append("]");
     }
     return sb.toString();

File: roaringbitmap/src/test/java/org/roaringbitmap/TestArrayContainer.java
Patch:
@@ -37,7 +37,9 @@ public void testRemove() {
     @Test
     public void testToString() {
         ArrayContainer ac1 = new ArrayContainer(5, 15);
-        Assert.assertEquals("{5,6,7,8,9,10,11,12,13,14}", ac1.toString());
+        ac1.add((short) -3);
+        ac1.add((short) -17);
+        Assert.assertEquals("{5,6,7,8,9,10,11,12,13,14,65519,65533}", ac1.toString());
     }
 
     @Test

File: roaringbitmap/src/test/java/org/roaringbitmap/TestRunContainer.java
Patch:
@@ -2982,9 +2982,9 @@ public void ensureCapacity() {
 
   @Test
   public void testToString() {
-    Container rc = new RunContainer();
-    rc.add((short)1);
-    assertEquals("[1,1]", rc.toString());
+    Container rc = new RunContainer(32200, 35000);
+    rc.add((short)-1);
+    assertEquals("[32200,34999][65535,65535]", rc.toString());
   }
 
   @Test

File: roaringbitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -1993,10 +1993,10 @@ public boolean contains(RoaringBitmap subset) {
         }
         ++pos1;
         ++pos2;
-      } else if (s1 < s2) {
+      } else if (Util.compareUnsigned(s1, s2) > 0) {
         return false;
       } else {
-        pos2 = subset.highLowContainer.advanceUntil(s1, pos2);
+        pos1 = subset.highLowContainer.advanceUntil(s2, pos1);
       }
     }
     return pos2 == length2;

File: roaringbitmap/src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -1018,10 +1018,10 @@ public boolean contains(ImmutableRoaringBitmap subset) {
         }
         ++pos1;
         ++pos2;
-      } else if (s1 < s2) {
+      } else if (BufferUtil.compareUnsigned(s1, s2) > 0) {
         return false;
       } else {
-        pos2 = subset.highLowContainer.advanceUntil(s1, pos2);
+        pos1 = subset.highLowContainer.advanceUntil(s2, pos1);
       }
     }
     return pos2 == length2;

File: roaringbitmap/src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -1149,7 +1149,7 @@ protected void writeArray(DataOutput out) throws IOException {
     // little endian
     for (int k = 0; k < this.cardinality; ++k) {
       short v = this.content[k];
-      out.write(Short.reverseBytes(v));
+      out.writeShort(Short.reverseBytes(v));
     }
   }
 

File: roaringbitmap/src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -1149,8 +1149,7 @@ protected void writeArray(DataOutput out) throws IOException {
     // little endian
     for (int k = 0; k < this.cardinality; ++k) {
       short v = this.content[k];
-      out.write(v & 0xFF);
-      out.write((v >>> 8) & 0xFF);
+      out.write(Short.reverseBytes(v));
     }
   }
 

File: roaringbitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -2014,6 +2014,7 @@ public int select(int j) {
    * @return the first (smallest) integer 
    * @throws NoSuchElementException if empty
    */
+  @Override
   public int first() {
     return highLowContainer.first();
   }
@@ -2024,6 +2025,7 @@ public int first() {
    * @return the last (largest) integer
    * @throws NoSuchElementException if empty
    */
+  @Override
   public int last() {
     return highLowContainer.last();
   }

File: roaringbitmap/src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -1349,6 +1349,7 @@ public int select(int j) {
    * @return the first (smallest) integer
    * @throws NoSuchElementException if empty
    */
+  @Override
   public int first() {
     return highLowContainer.first();
   }
@@ -1359,6 +1360,7 @@ public int first() {
    * @return the last (largest) integer
    * @throws NoSuchElementException if empty
    */
+  @Override
   public int last() {
     return highLowContainer.last();
   }

File: jmh/src/main/java/org/roaringbitmap/realdata/wrapper/BitmapAggregator.java
Patch:
@@ -2,6 +2,6 @@
 
 public interface BitmapAggregator {
 
-   Bitmap aggregate(Iterable<Bitmap> bitmaps);
+  Bitmap aggregate(Iterable<Bitmap> bitmaps);
 
 }

File: jmh/src/main/java/org/roaringbitmap/realdata/wrapper/BitmapIterator.java
Patch:
@@ -2,8 +2,8 @@
 
 public interface BitmapIterator {
 
-   boolean hasNext();
+  boolean hasNext();
 
-   int next();
+  int next();
 
 }

File: src/main/java/org/roaringbitmap/longlong/Roaring64NavigableMap.java
Patch:
@@ -1076,8 +1076,6 @@ public ImmutableLongBitmapDataProvider limit(long x) {
   /**
    * Use a run-length encoding where it is estimated as more space efficient
    * 
-   * @return
-   *
    * @return whether a change was applied
    */
   public boolean runOptimize() {

File: jmh/src/main/java/org/roaringbitmap/realdata/wrapper/BitmapAggregator.java
Patch:
@@ -2,6 +2,6 @@
 
 public interface BitmapAggregator {
 
-   Bitmap aggregate(Iterable<Bitmap> bitmaps);
+  Bitmap aggregate(Iterable<Bitmap> bitmaps);
 
 }

File: jmh/src/main/java/org/roaringbitmap/realdata/wrapper/BitmapIterator.java
Patch:
@@ -2,8 +2,8 @@
 
 public interface BitmapIterator {
 
-   boolean hasNext();
+  boolean hasNext();
 
-   int next();
+  int next();
 
 }

File: src/main/java/org/roaringbitmap/longlong/Roaring64NavigableMap.java
Patch:
@@ -1076,8 +1076,6 @@ public ImmutableLongBitmapDataProvider limit(long x) {
   /**
    * Use a run-length encoding where it is estimated as more space efficient
    * 
-   * @return
-   *
    * @return whether a change was applied
    */
   public boolean runOptimize() {

File: src/main/java/org/roaringbitmap/longlong/Roaring64NavigableMap.java
Patch:
@@ -1347,5 +1347,7 @@ public void flip(final long x) {
         }
       }
     }
+    
+    invalidateAboveHigh(high);
   }
 }

File: src/main/java/org/roaringbitmap/IntIteratorFlyweight.java
Patch:
@@ -49,7 +49,9 @@ public IntIteratorFlyweight(RoaringBitmap r) {
   public PeekableIntIterator clone() {
     try {
       IntIteratorFlyweight x = (IntIteratorFlyweight) super.clone();
-      if(this.iter != null) x.iter = this.iter.clone();
+      if(this.iter != null) {
+        x.iter = this.iter.clone();
+      }
       return x;
     } catch (CloneNotSupportedException e) {
       return null;// will not happen

File: src/main/java/org/roaringbitmap/ReverseIntIteratorFlyweight.java
Patch:
@@ -51,7 +51,9 @@ public ReverseIntIteratorFlyweight(RoaringBitmap r) {
   public IntIterator clone() {
     try {
       ReverseIntIteratorFlyweight x = (ReverseIntIteratorFlyweight) super.clone();
-      if(this.iter != null) x.iter = this.iter.clone();
+      if(this.iter != null) {
+        x.iter = this.iter.clone();
+      }
       return x;
     } catch (CloneNotSupportedException e) {
       return null;// will not happen

File: src/main/java/org/roaringbitmap/buffer/BufferIntIteratorFlyweight.java
Patch:
@@ -54,7 +54,9 @@ public BufferIntIteratorFlyweight(ImmutableRoaringBitmap r) {
   public PeekableIntIterator clone() {
     try {
       BufferIntIteratorFlyweight x = (BufferIntIteratorFlyweight) super.clone();
-      if(this.iter != null) x.iter = this.iter.clone();
+      if(this.iter != null) {
+        x.iter = this.iter.clone();
+      }
       return x;
     } catch (CloneNotSupportedException e) {
       return null;// will not happen

File: src/main/java/org/roaringbitmap/buffer/BufferReverseIntIteratorFlyweight.java
Patch:
@@ -56,7 +56,9 @@ public BufferReverseIntIteratorFlyweight(ImmutableRoaringBitmap r) {
   public IntIterator clone() {
     try {
       BufferReverseIntIteratorFlyweight x = (BufferReverseIntIteratorFlyweight) super.clone();
-      if(this.iter != null) x.iter = this.iter.clone();
+      if(this.iter != null) {
+        x.iter = this.iter.clone();
+      }
       return x;
     } catch (CloneNotSupportedException e) {
       return null;// will not happen

File: src/main/java/org/roaringbitmap/IntIteratorFlyweight.java
Patch:
@@ -49,7 +49,7 @@ public IntIteratorFlyweight(RoaringBitmap r) {
   public PeekableIntIterator clone() {
     try {
       IntIteratorFlyweight x = (IntIteratorFlyweight) super.clone();
-      x.iter = this.iter.clone();
+      if(this.iter != null) x.iter = this.iter.clone();
       return x;
     } catch (CloneNotSupportedException e) {
       return null;// will not happen

File: src/main/java/org/roaringbitmap/ReverseIntIteratorFlyweight.java
Patch:
@@ -51,7 +51,7 @@ public ReverseIntIteratorFlyweight(RoaringBitmap r) {
   public IntIterator clone() {
     try {
       ReverseIntIteratorFlyweight x = (ReverseIntIteratorFlyweight) super.clone();
-      x.iter = this.iter.clone();
+      if(this.iter != null) x.iter = this.iter.clone();
       return x;
     } catch (CloneNotSupportedException e) {
       return null;// will not happen
@@ -109,4 +109,3 @@ public void wrap(RoaringBitmap r) {
   }
 
 }
-

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -62,7 +62,7 @@ private RoaringIntIterator() {
     public PeekableIntIterator clone() {
       try {
         RoaringIntIterator x = (RoaringIntIterator) super.clone();
-        x.iter = this.iter.clone();
+        if(this.iter != null) x.iter = this.iter.clone();
         return x;
       } catch (CloneNotSupportedException e) {
         return null;// will not happen
@@ -132,7 +132,7 @@ private RoaringReverseIntIterator() {
     public IntIterator clone() {
       try {
         RoaringReverseIntIterator clone = (RoaringReverseIntIterator) super.clone();
-        clone.iter = this.iter.clone();
+        if(this.iter != null) clone.iter = this.iter.clone();
         return clone;
       } catch (CloneNotSupportedException e) {
         return null;// will not happen

File: src/main/java/org/roaringbitmap/buffer/BufferIntIteratorFlyweight.java
Patch:
@@ -54,7 +54,7 @@ public BufferIntIteratorFlyweight(ImmutableRoaringBitmap r) {
   public PeekableIntIterator clone() {
     try {
       BufferIntIteratorFlyweight x = (BufferIntIteratorFlyweight) super.clone();
-      x.iter = this.iter.clone();
+      if(this.iter != null) x.iter = this.iter.clone();
       return x;
     } catch (CloneNotSupportedException e) {
       return null;// will not happen

File: src/main/java/org/roaringbitmap/buffer/BufferReverseIntIteratorFlyweight.java
Patch:
@@ -56,7 +56,7 @@ public BufferReverseIntIteratorFlyweight(ImmutableRoaringBitmap r) {
   public IntIterator clone() {
     try {
       BufferReverseIntIteratorFlyweight x = (BufferReverseIntIteratorFlyweight) super.clone();
-      x.iter = this.iter.clone();
+      if(this.iter != null) x.iter = this.iter.clone();
       return x;
     } catch (CloneNotSupportedException e) {
       return null;// will not happen
@@ -114,4 +114,3 @@ public void wrap(ImmutableRoaringBitmap r) {
   }
 
 }
-

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -1981,7 +1981,7 @@ public boolean contains(RoaringBitmap subset) {
    */
   @Override
   public int select(int j) {
-    long leftover = Integer.toUnsignedLong(j);
+    long leftover = ((long) j) & 0xffffffffL;
     for (int i = 0; i < this.highLowContainer.size(); i++) {
       Container c = this.highLowContainer.getContainerAtIndex(i);
       int thiscard = c.getCardinality();

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -1312,7 +1312,7 @@ public int rank(int x) {
    */
   @Override
   public int select(int j) {
-    long leftover = Integer.toUnsignedLong(j);
+    long leftover = ((long) j) & 0xffffffffL;
     for (int i = 0; i < this.highLowContainer.size(); i++) {
       int thiscard = this.highLowContainer.getCardinality(i);
       if (thiscard > leftover) {

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -1983,13 +1983,13 @@ public boolean contains(RoaringBitmap subset) {
    */
   @Override
   public int select(int j) {
-    int leftover = j;
+    long leftover = Integer.toUnsignedLong(j);
     for (int i = 0; i < this.highLowContainer.size(); i++) {
       Container c = this.highLowContainer.getContainerAtIndex(i);
       int thiscard = c.getCardinality();
       if (thiscard > leftover) {
         int keycontrib = this.highLowContainer.getKeyAtIndex(i) << 16;
-        int lowcontrib = Util.toIntUnsigned(c.select(leftover));
+        int lowcontrib = Util.toIntUnsigned(c.select((int)leftover));
         return lowcontrib + keycontrib;
       }
       leftover -= thiscard;

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -1312,13 +1312,13 @@ public int rank(int x) {
    */
   @Override
   public int select(int j) {
-    int leftover = j;
+    long leftover = Integer.toUnsignedLong(j);
     for (int i = 0; i < this.highLowContainer.size(); i++) {
       int thiscard = this.highLowContainer.getCardinality(i);
       if (thiscard > leftover) {
         int keycontrib = this.highLowContainer.getKeyAtIndex(i) << 16;
         MappeableContainer c = this.highLowContainer.getContainerAtIndex(i);
-        int lowcontrib = BufferUtil.toIntUnsigned(c.select(leftover));
+        int lowcontrib = BufferUtil.toIntUnsigned(c.select((int)leftover));
         return lowcontrib + keycontrib;
       }
       leftover -= thiscard;

File: jmh/src/main/java/org/roaringbitmap/needwork/RandomAccess.java
Patch:
@@ -33,7 +33,8 @@ public static class BenchmarkState extends NeedWorkBenchmarkState {
         public BenchmarkState() {
         }
 
-        @Setup
+        @Override
+		@Setup
         public void setup() throws Exception {
             super.setup();
 

File: jmh/src/main/java/org/roaringbitmap/realdata/RealDataBenchmarkContains.java
Patch:
@@ -32,7 +32,8 @@ public static class BenchmarkState extends RealDataBenchmarkState {
       public BenchmarkState() {
       }
 
-      @Setup
+      @Override
+	@Setup
       public void setup() throws Exception {
          super.setup();
 

File: jmh/src/test/java/org/roaringbitmap/realdata/RealDataBenchmarkAndNotTest.java
Patch:
@@ -31,7 +31,8 @@ public class RealDataBenchmarkAndNotTest extends RealDataBenchmarkSanityTest {
                     .put(WIKILEAKS_NOQUOTES_SRT, 286904)
             .build();
 
-    @Before
+    @Override
+	@Before
     public void setup() throws Exception {
         Assume.assumeFalse(type.equals(CONCISE) && immutable);
         Assume.assumeFalse(type.equals(WAH) && immutable);

File: jmh/src/test/java/org/roaringbitmap/realdata/RealDataBenchmarkForEachTest.java
Patch:
@@ -30,7 +30,8 @@ public class RealDataBenchmarkForEachTest extends RealDataBenchmarkSanityTest {
                     .put(WIKILEAKS_NOQUOTES_SRT, 1921022163)
             .build();
 
-    @Before
+    @Override
+	@Before
     public void setup() throws Exception {
         Assume.assumeFalse(type.equals(CONCISE));
         Assume.assumeFalse(type.equals(WAH));

File: jmh/src/test/java/org/roaringbitmap/realdata/RealDataBenchmarkIOrTest.java
Patch:
@@ -30,7 +30,8 @@ public class RealDataBenchmarkIOrTest extends RealDataBenchmarkSanityTest {
                     .put(WIKILEAKS_NOQUOTES_SRT, 236436)
             .build();
 
-    @Before
+    @Override
+	@Before
     public void setup() throws Exception {
         Assume.assumeFalse(type.equals(CONCISE));
         Assume.assumeFalse(type.equals(WAH));

File: jmh/src/test/java/org/roaringbitmap/realdata/RealDataBenchmarkReverseIterateTest.java
Patch:
@@ -31,7 +31,8 @@ public class RealDataBenchmarkReverseIterateTest extends RealDataBenchmarkSanity
                     .put(WIKILEAKS_NOQUOTES_SRT, 1921022163)
             .build();
 
-    @Before
+    @Override
+	@Before
     public void setup() throws Exception {
         Assume.assumeFalse(type.equals(CONCISE) && immutable);
         Assume.assumeFalse(type.equals(WAH) && immutable);

File: jmh/src/test/java/org/roaringbitmap/realdata/RealDataBenchmarkXorTest.java
Patch:
@@ -31,7 +31,8 @@ public class RealDataBenchmarkXorTest extends RealDataBenchmarkSanityTest {
                     .put(WIKILEAKS_NOQUOTES_SRT, 574311)
             .build();
 
-    @Before
+    @Override
+	@Before
     public void setup() throws Exception {
         Assume.assumeFalse(type.equals(CONCISE) && immutable);
         Assume.assumeFalse(type.equals(WAH) && immutable);

File: src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -1084,6 +1084,7 @@ public int serializedSizeInBytes() {
    *
    * @return the bitmap container
    */
+  @Override
   public BitmapContainer toBitmapContainer() {
     BitmapContainer bc = new BitmapContainer();
     bc.loadData(this);

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -935,6 +935,7 @@ public RoaringBitmap(ImmutableRoaringBitmap rb) {
    *
    * @param x integer value
    */
+  @Override
   public void add(final int x) {
     final short hb = Util.highbits(x);
     final int i = highLowContainer.getIndex(hb);
@@ -1800,6 +1801,7 @@ public void readExternal(ObjectInput in) throws IOException, ClassNotFoundExcept
    *
    * @param x integer value representing the index in a bitmap
    */
+  @Override
   public void remove(final int x) {
     final short hb = Util.highbits(x);
     final int i = highLowContainer.getIndex(hb);
@@ -2258,6 +2260,7 @@ public String toString() {
   /**
    * Recover allocated but unused memory.
    */
+  @Override
   public void trim() {
     for (int i = 0; i < this.highLowContainer.size(); i++) {
       this.highLowContainer.getContainerAtIndex(i).trim();

File: src/main/java/org/roaringbitmap/buffer/MappeableArrayContainer.java
Patch:
@@ -1356,6 +1356,7 @@ public int serializedSizeInBytes() {
    *
    * @return the bitmap container
    */
+  @Override
   public MappeableBitmapContainer toBitmapContainer() {
     final MappeableBitmapContainer bc = new MappeableBitmapContainer();
     bc.loadData(this);

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -1981,13 +1981,13 @@ public boolean contains(RoaringBitmap subset) {
    */
   @Override
   public int select(int j) {
-    int leftover = j;
+    long leftover = Integer.toUnsignedLong(j);
     for (int i = 0; i < this.highLowContainer.size(); i++) {
       Container c = this.highLowContainer.getContainerAtIndex(i);
       int thiscard = c.getCardinality();
       if (thiscard > leftover) {
         int keycontrib = this.highLowContainer.getKeyAtIndex(i) << 16;
-        int lowcontrib = Util.toIntUnsigned(c.select(leftover));
+        int lowcontrib = Util.toIntUnsigned(c.select((int)leftover));
         return lowcontrib + keycontrib;
       }
       leftover -= thiscard;

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -1312,13 +1312,13 @@ public int rank(int x) {
    */
   @Override
   public int select(int j) {
-    int leftover = j;
+    long leftover = Integer.toUnsignedLong(j);
     for (int i = 0; i < this.highLowContainer.size(); i++) {
       int thiscard = this.highLowContainer.getCardinality(i);
       if (thiscard > leftover) {
         int keycontrib = this.highLowContainer.getKeyAtIndex(i) << 16;
         MappeableContainer c = this.highLowContainer.getContainerAtIndex(i);
-        int lowcontrib = BufferUtil.toIntUnsigned(c.select(leftover));
+        int lowcontrib = BufferUtil.toIntUnsigned(c.select((int)leftover));
         return lowcontrib + keycontrib;
       }
       leftover -= thiscard;

File: src/test/java/org/roaringbitmap/longlong/TestTreeRoaringBitmap.java
Patch:
@@ -224,7 +224,7 @@ public void testAddingLowValueAfterHighValue() {
     Assert.assertEquals(Long.MAX_VALUE, map.select(0));
     map.addLong(666);
     Assert.assertEquals(666, map.select(0));
-    Assert.assertEquals(Long.MAX_VALUE, map.select(0));
+    Assert.assertEquals(Long.MAX_VALUE, map.select(1));
   }
 
   @Test

File: src/main/java/org/roaringbitmap/longlong/RoaringTreeMap.java
Patch:
@@ -88,11 +88,11 @@ public long select(final long j) {
         Arrays.binarySearch(sortedCumulatedCardinality, 0, sortedCumulatedCardinality.length, j);
 
     if (position <= -1) {
-      throwSelectInvalidIndex(j);
+      return throwSelectInvalidIndex(j);
     } else if (position >= 0) {
       if (position == sortedCumulatedCardinality.length) {
         // .select has been called on this.getCardinality
-        throwSelectInvalidIndex(j);
+        return throwSelectInvalidIndex(j);
       }
 
       // There is a bucket leading to this cardinality: the j-th element is the first element of next bucket
@@ -122,7 +122,7 @@ public long select(final long j) {
     }
   }
 
-  private void throwSelectInvalidIndex(long j) {
+  private long throwSelectInvalidIndex(long j) {
     // see org.roaringbitmap.buffer.ImmutableRoaringBitmap.select(int)
     throw new IllegalArgumentException(
         "select " + j + " when the cardinality is " + this.getCardinality());

File: src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -2467,7 +2467,7 @@ public BitmapContainer toBitmapContainer() {
   @Override
   public int first() {
     assertNonEmpty(numberOfRuns() == 0);
-    return valueslength[0];
+    return Util.toIntUnsigned(valueslength[0]);
   }
 
   @Override

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -1613,8 +1613,7 @@ protected void naivelazyor(RoaringBitmap  x2) {
 
       while (true) {
         if (s1 == s2) {
-          Container c1 = highLowContainer.getContainerAtIndex(pos1);
-          c1 = c1.toBitmapContainer();
+          BitmapContainer c1 = highLowContainer.getContainerAtIndex(pos1).toBitmapContainer();
           this.highLowContainer.setContainerAtIndex(pos1,
               c1.lazyIOR(x2.highLowContainer.getContainerAtIndex(pos2)));
           pos1++;

File: src/main/java/org/roaringbitmap/buffer/MutableRoaringBitmap.java
Patch:
@@ -1110,9 +1110,8 @@ protected void naivelazyor(final ImmutableRoaringBitmap x2) {
 
       while (true) {
         if (s1 == s2) {
-          MappeableContainer c1 = highLowContainer
-              .getContainerAtIndex(pos1);
-          c1 = c1.toBitmapContainer();
+          MappeableBitmapContainer c1 = highLowContainer.getContainerAtIndex(pos1)
+              .toBitmapContainer();
           getMappeableRoaringArray().setContainerAtIndex(pos1,
               c1.lazyIOR(x2.highLowContainer.getContainerAtIndex(pos2)));
           pos1++;

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -1775,9 +1775,10 @@ public long rankLong(int x) {
 
     for (int i = 0; i < this.highLowContainer.size(); i++) {
       short key = this.highLowContainer.getKeyAtIndex(i);
-      if (Util.compareUnsigned(key, xhigh) < 0) {
+      int comparison = Util.compareUnsigned(key, xhigh);
+      if (comparison < 0) {
         size += this.highLowContainer.getContainerAtIndex(i).getCardinality();
-      } else {
+      } else if (comparison == 0) {
         return size + this.highLowContainer.getContainerAtIndex(i).rank(Util.lowbits(x));
       }
     }

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -1267,9 +1267,10 @@ public long rankLong(int x) {
     short xhigh = BufferUtil.highbits(x);
     for (int i = 0; i < this.highLowContainer.size(); i++) {
       short key = this.highLowContainer.getKeyAtIndex(i);
-      if (Util.compareUnsigned(key, xhigh) < 0) {
+      int comparison = Util.compareUnsigned(key, xhigh);
+      if (comparison < 0) {
         size += this.highLowContainer.getCardinality(i);
-      } else {
+      } else if(comparison == 0) {
         return size + this.highLowContainer.getContainerAtIndex(i).rank(BufferUtil.lowbits(x));
       }
     }

File: src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -560,7 +560,7 @@ public int andCardinality(RunContainer x) {
           }
         }
         // earliestend - lateststart are all values that are true.
-        cardinality += (short) (earliestend - lateststart);
+        cardinality += earliestend - lateststart;
       }
     }
     return cardinality;

File: src/main/java/org/roaringbitmap/buffer/MappeableRunContainer.java
Patch:
@@ -2482,7 +2482,7 @@ public int andCardinality(MappeableRunContainer x) {
           }
         }
         // earliestend - lateststart are all values that are true.
-        cardinality += (short) (earliestend - lateststart);
+        cardinality += earliestend - lateststart;
       }
     }
     return cardinality;

File: src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -560,7 +560,7 @@ public int andCardinality(RunContainer x) {
           }
         }
         // earliestend - lateststart are all values that are true.
-        cardinality += (short) (earliestend - lateststart);
+        cardinality += earliestend - lateststart;
       }
     }
     return cardinality;

File: src/main/java/org/roaringbitmap/buffer/MappeableRunContainer.java
Patch:
@@ -2482,7 +2482,7 @@ public int andCardinality(MappeableRunContainer x) {
           }
         }
         // earliestend - lateststart are all values that are true.
-        cardinality += (short) (earliestend - lateststart);
+        cardinality += earliestend - lateststart;
       }
     }
     return cardinality;

File: src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -1938,7 +1938,7 @@ public int rank(short lowbits) {
       int length = Util.toIntUnsigned(getLength(k));
       if (x < value) {
         return answer;
-      } else if (value + length + 1 >= x) {
+      } else if (value + length + 1 > x) {
         return answer + x - value + 1;
       }
       answer += length + 1;

File: src/test/java/org/roaringbitmap/TestRunContainer.java
Patch:
@@ -2084,6 +2084,7 @@ public void rank() {
     assertEquals(5, container.rank((short) 1024));
   }
   
+  @Test
   public void shortRangeRank() {
     Container container = new RunContainer();
     container = container.add(16, 32);

File: src/main/java/org/roaringbitmap/buffer/MappeableRunContainer.java
Patch:
@@ -1875,7 +1875,7 @@ public int rank(short lowbits) {
       int length = BufferUtil.toIntUnsigned(getLength(k));
       if (x < value) {
         return answer;
-      } else if (value + length + 1 >= x) {
+      } else if (value + length + 1 > x) {
         return answer + x - value + 1;
       }
       answer += length + 1;

File: src/main/java/org/roaringbitmap/buffer/MappeableRunContainer.java
Patch:
@@ -1875,7 +1875,7 @@ public int rank(short lowbits) {
       int length = BufferUtil.toIntUnsigned(getLength(k));
       if (x < value) {
         return answer;
-      } else if (value + length + 1 >= x) {
+      } else if (value + length + 1 > x) {
         return answer + x - value + 1;
       }
       answer += length + 1;

File: src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -749,7 +749,7 @@ protected boolean contains(RunContainer runContainer) {
       int start1 = getValue(i1);
       int stop1 = start1 + Util.toIntUnsigned(getLength(i1));
       int start2 = runContainer.getValue(i2);
-      int stop2 = start2 + runContainer.getLength(i2);
+      int stop2 = start2 + Util.toIntUnsigned(runContainer.getLength(i2));
       if(start1 > start2) {
         return false;
       } else {

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -1088,7 +1088,7 @@ public Iterator<Integer> iterator() {
 
       ShortIterator iter;
 
-      short pos = 0;
+      int pos = 0;
 
       int x;
 

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -1088,7 +1088,7 @@ public Iterator<Integer> iterator() {
 
       ShortIterator iter;
 
-      short pos = 0;
+      int pos = 0;
 
       int x;
 

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -1088,7 +1088,7 @@ public Iterator<Integer> iterator() {
 
       ShortIterator iter;
 
-      int pos = 0;
+      short pos = 0;
 
       int x;
 

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -1088,7 +1088,7 @@ public Iterator<Integer> iterator() {
 
       ShortIterator iter;
 
-      short pos = 0;
+      int pos = 0;
 
       int x;
 

File: src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -486,8 +486,8 @@ public Container iand(RunContainer x) {
       updateCardinality(prevOnes, 0);
       start = end + Util.toIntUnsigned(x.getLength(rlepos)) + 1;
     }
-    int ones = Util.cardinalityInBitmapRange(this.bitmap, start, BitmapContainer.MAX_CAPACITY);
-    Util.resetBitmapRange(this.bitmap, start, BitmapContainer.MAX_CAPACITY);
+    int ones = Util.cardinalityInBitmapRange(this.bitmap, start, MAX_CAPACITY);
+    Util.resetBitmapRange(this.bitmap, start, MAX_CAPACITY);
     updateCardinality(ones, 0);
     if (getCardinality() > ArrayContainer.DEFAULT_MAX_SIZE) {
       return this;

File: src/test/java/org/roaringbitmap/buffer/TestMappeableRunContainer.java
Patch:
@@ -19,7 +19,7 @@
 public class TestMappeableRunContainer {
 
   protected static MappeableRunContainer generateContainer(short[] values, int numOfRuns) {
-    ShortBuffer array = ByteBuffer.allocateDirect(values.length * Short.BYTES).asShortBuffer();
+    ShortBuffer array = ByteBuffer.allocateDirect(values.length * 2).asShortBuffer();
     for (short v : values) {
       array.put(v);
     }

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringArray.java
Patch:
@@ -156,15 +156,16 @@ public int getCardinality(int k) {
   }
 
 
+  // retired method (inefficient)
   // involves a binary search
-  @Override
+  /*@Override
   public MappeableContainer getContainer(short x) {
     final int i = unsignedBinarySearch(x);
     if (i < 0) {
       return null;
     }
     return getContainerAtIndex(i);
-  }
+  }*/
 
   @Override 
   public int getContainerIndex(short x) {

File: src/main/java/org/roaringbitmap/buffer/MutableRoaringArray.java
Patch:
@@ -297,15 +297,16 @@ public int getCardinality(int i) {
     return getContainerAtIndex(i).getCardinality();
   }
 
+  // retired method (inefficient)
   // involves a binary search
-  @Override
+  /*@Override
   public MappeableContainer getContainer(short x) {
     final int i = this.binarySearch(0, size, x);
     if (i < 0) {
       return null;
     }
     return this.values[i];
-  }
+  }*/
   
   @Override
   public int getContainerIndex(short x) {

File: src/main/java/org/roaringbitmap/buffer/MutableRoaringBitmap.java
Patch:
@@ -627,7 +627,7 @@ public static MutableRoaringBitmap xor(final MutableRoaringBitmap x1,
             break main;
           }
           s1 = x1.highLowContainer.getKeyAtIndex(pos1);
-        } else if (s1 > s2) {
+        } else if (Util.compareUnsigned(s1, s2) > 0) {
           answer.getMappeableRoaringArray().appendCopy(x2.highLowContainer.getKeyAtIndex(pos2),
               x2.highLowContainer.getContainerAtIndex(pos2));
           pos2++;
@@ -643,7 +643,6 @@ public static MutableRoaringBitmap xor(final MutableRoaringBitmap x1,
     } else if (pos2 == length2) {
       answer.getMappeableRoaringArray().appendCopy(x1.highLowContainer, pos1, length1);
     }
-
     return answer;
   }
 

File: src/main/java/org/roaringbitmap/buffer/PointableRoaringArray.java
Patch:
@@ -52,12 +52,12 @@ public interface PointableRoaringArray extends Cloneable {
   public int getCardinality(int i);
 
   /**
-   * 
+   * Obsolete method (retired because it forces us to create a new container).
    * 
    * @param x 16-bit key
    * @return matching container
    */
-  MappeableContainer getContainer(short x);
+  //MappeableContainer getContainer(short x);
 
   
    /**

File: src/test/java/org/roaringbitmap/TestBitmapContainer.java
Patch:
@@ -23,7 +23,7 @@ private static BitmapContainer emptyContainer() {
     return new BitmapContainer(new long[1], 0);
   }
 
-  private BitmapContainer generateContainer(short min, short max, int sample) {
+  static BitmapContainer generateContainer(short min, short max, int sample) {
     BitmapContainer bc = new BitmapContainer();
     for (int i = min; i < max; i++) {
       if (i % sample != 0) bc.add((short) i);

File: src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -651,9 +651,10 @@ public Container ior(RunContainer x) {
     for (int rlepos = 0; rlepos < x.nbrruns; ++rlepos) {
       int start = Util.toIntUnsigned(x.getValue(rlepos));
       int end = start + Util.toIntUnsigned(x.getLength(rlepos)) + 1;
+      int prevOnesInRange = Util.cardinalityInBitmapRange(this.bitmap, start, end);
       Util.setBitmapRange(this.bitmap, start, end);
+      computeCardinality(prevOnesInRange, start, end);
     }
-    computeCardinality();
     if (isFull()) {
       return RunContainer.full();
     }

File: src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -427,8 +427,9 @@ public Container iadd(int begin, int end) {
     if ((begin > end) || (end > (1 << 16))) {
       throw new IllegalArgumentException("Invalid range [" + begin + "," + end + ")");
     }
+    int prevOnesInRange = Util.cardinalityInBitmapRange(bitmap, begin, end);
     Util.setBitmapRange(bitmap, begin, end);
-    computeCardinality();
+    computeCardinality(prevOnesInRange, begin, end);
     return this;
   }
 

File: src/main/java/org/roaringbitmap/buffer/BufferUtil.java
Patch:
@@ -569,9 +569,10 @@ protected static int unsignedExclusiveUnion2by2(final ShortBuffer set1, final in
 
   protected static int unsignedIntersect2by2(final ShortBuffer set1, final int length1,
       final ShortBuffer set2, final int length2, final short[] buffer) {
-    if (length1 * 64 < length2) {
+    final int THRESHOLD = 34;
+    if (length1 * THRESHOLD < length2) {
       return unsignedOneSidedGallopingIntersect2by2(set1, length1, set2, length2, buffer);
-    } else if (length2 * 64 < length1) {
+    } else if (length2 * THRESHOLD < length1) {
       return unsignedOneSidedGallopingIntersect2by2(set2, length2, set1, length1, buffer);
     } else {
       return unsignedLocalIntersect2by2(set1, length1, set2, length2, buffer);

File: src/main/java/org/roaringbitmap/Util.java
Patch:
@@ -657,9 +657,10 @@ public static int unsignedExclusiveUnion2by2(final short[] set1, final int lengt
    */
   public static int unsignedIntersect2by2(final short[] set1, final int length1, final short[] set2,
       final int length2, final short[] buffer) {
-    if (set1.length * 64 < set2.length) {
+    final int THRESHOLD = 25;
+    if (set1.length * THRESHOLD < set2.length) {
       return unsignedOneSidedGallopingIntersect2by2(set1, length1, set2, length2, buffer);
-    } else if (set2.length * 64 < set1.length) {
+    } else if (set2.length * THRESHOLD < set1.length) {
       return unsignedOneSidedGallopingIntersect2by2(set2, length2, set1, length1, buffer);
     } else {
       return unsignedLocalIntersect2by2(set1, length1, set2, length2, buffer);

File: src/main/java/org/roaringbitmap/buffer/MappeableRunContainer.java
Patch:
@@ -2335,7 +2335,7 @@ public void forEach(short msb, IntConsumer ic) {
   @Override
   public int andCardinality(MappeableArrayContainer x) {
     if (this.nbrruns == 0) {
-      return x.cardinality;
+      return 0;
     }
     int rlepos = 0;
     int arraypos = 0;

File: src/main/java/org/roaringbitmap/buffer/MappeableArrayContainer.java
Patch:
@@ -962,7 +962,7 @@ int numberOfRuns() {
       }
       return numRuns;
     } else {
-      int numRuns = 0;
+      int numRuns = 1;
       int previous = BufferUtil.toIntUnsigned(content.get(0));
       // we do not proceed like above for fear that calling "get" twice per loop would be too much
       for (int i = 1; i < cardinality; i++) {

File: src/main/java/org/roaringbitmap/buffer/MappeableArrayContainer.java
Patch:
@@ -71,7 +71,7 @@ public MappeableArrayContainer(final int capacity) {
   }
 
   /**
-   * Create an array container with a run of ones from firstOfRun to lastOfRun, inclusive. Caller is
+   * Create an array container with a run of ones from firstOfRun to lastOfRun, exclusive. Caller is
    * responsible for making sure the range is small enough that ArrayContainer is appropriate.
    *
    * @param firstOfRun first index

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -2054,7 +2054,7 @@ public String toString() {
     final IntIterator i = this.getIntIterator();
     answer.append("{");
     if (i.hasNext()) {
-      answer.append(i.next());
+      answer.append(i.next() & 0xFFFFFFFFL);
     }
     while (i.hasNext()) {
       answer.append(",");
@@ -2063,7 +2063,7 @@ public String toString() {
         answer.append("...");
         break;
       }
-      answer.append(i.next());
+      answer.append(i.next() & 0xFFFFFFFFL);
       
     }
     answer.append("}");

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -1334,7 +1334,7 @@ public String toString() {
     final IntIterator i = this.getIntIterator();
     answer.append("{");
     if (i.hasNext()) {
-      answer.append(i.next());
+      answer.append(i.next() & 0xFFFFFFFFL);
     }
     while (i.hasNext()) {
       answer.append(",");
@@ -1343,7 +1343,7 @@ public String toString() {
         answer.append("...");
         break;
       }
-      answer.append(i.next());
+      answer.append(i.next() & 0xFFFFFFFFL);
     }
     answer.append("}");
     return answer.toString();

File: jmh/src/main/java/org/roaringbitmap/realdata/wrapper/BitmapFactory.java
Patch:
@@ -25,6 +25,8 @@ public final class BitmapFactory {
    public static final String EWAH32 = "ewah32";
    public static final String ROARING = "roaring";
    public static final String ROARING_WITH_RUN = "roaring_with_run";
+   public static final String ROARING_ONLY = "ROARING_ONLY";
+   public static final String BITMAP_TYPES = "BITMAP_TYPES";
 
    private static final List<File> TEMP_FILES = new ArrayList<File>();
 

File: jmh/src/test/java/org/roaringbitmap/realdata/RealDataBenchmarkSanityTest.java
Patch:
@@ -8,6 +8,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.roaringbitmap.realdata.state.RealDataBenchmarkState;
+import org.roaringbitmap.realdata.wrapper.BitmapFactory;
 
 import java.util.Collection;
 import java.util.List;
@@ -26,8 +27,8 @@ public abstract class RealDataBenchmarkSanityTest {
                                                     CENSUS_INCOME_SRT, CENSUS1881_SRT,
                                                     WEATHER_SEPT_85_SRT, WIKILEAKS_NOQUOTES_SRT };
 
-    public static final String[] BITMAP_TYPES = 
-        "ROARING_ONLY".equals(System.getProperty("BITMAP_TYPES")) 
+    public static final String[] BITMAP_TYPES =
+        ROARING_ONLY.equals(System.getProperty(BitmapFactory.BITMAP_TYPES))
             ? new String[] { ROARING, ROARING_WITH_RUN }
             : new String[] { CONCISE, WAH,
                              EWAH, EWAH32,

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -92,11 +92,11 @@ private void nextContainer() {
 
     @Override
     public void advanceIfNeeded(int minval) {
-      while (hasNext() && ((0xFFFF & (hs >>> 16)) < (0xFFFF & (minval >>> 16)))) {
+      while (hasNext() && ((hs >>> 16) < (minval >>> 16))) {
         ++pos;
         nextContainer();
       }
-      if (hasNext()) {
+      if (hasNext() && ((hs >>> 16) == (minval >>> 16))) {
         iter.advanceIfNeeded(Util.lowbits(minval));
         if (!iter.hasNext()) {
           ++pos;

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -106,11 +106,11 @@ private void nextContainer() {
 
     @Override
     public void advanceIfNeeded(int minval) {
-      while (hasNext() && ((0xFFFF & (hs >>> 16)) < (0xFFFF & (minval >>> 16)))) {
+      while (hasNext() && ((hs >>> 16) < (minval >>> 16))) {
         cp.advance();
         nextContainer();
       }
-      if (ok) {
+      if (ok && ((hs >>> 16) == (minval >>> 16))) {
         iter.advanceIfNeeded(BufferUtil.lowbits(minval));
         if (!iter.hasNext()) {
           cp.advance();

File: src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -801,7 +801,7 @@ public Container limit(int maxcardinality) {
     }
     int lastword = s % 64;
     if (lastword != 0) {
-      bc.bitmap[s / 64] = (bc.bitmap[s / 64] << (64 - lastword)) >> (64 - lastword);
+      bc.bitmap[s / 64] &= (0xFFFFFFFFFFFFFFFFL >>> (64 - lastword));
     }
     return bc;
   }

File: src/main/java/org/roaringbitmap/buffer/MappeableBitmapContainer.java
Patch:
@@ -1176,7 +1176,7 @@ public MappeableContainer limit(int maxcardinality) {
     }
     int lastword = s % 64;
     if (lastword != 0) {
-      bc.bitmap.put(s / 64, (bc.bitmap.get(s / 64) << (64 - lastword)) >> (64 - lastword));
+      bc.bitmap.put(s / 64, (bc.bitmap.get(s / 64) & (0xFFFFFFFFFFFFFFFFL >>> (64 - lastword))));
     }
     return bc;
   }

File: src/main/java/org/roaringbitmap/RoaringArray.java
Patch:
@@ -352,7 +352,7 @@ public ContainerPointer getContainerPointer() {
   * @param startIndex starting index in the container list
   * @return a ContainerPointer
   */
-  public ContainerPointer getContainerPointer(int startIndex) {
+  public ContainerPointer getContainerPointer(final int startIndex) {
     return new ContainerPointer() {
       int k = startIndex;
 

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -92,7 +92,7 @@ private void nextContainer() {
 
     @Override
     public void advanceIfNeeded(int minval) {
-      while ((0xFFFF & (hs >>> 16)) < (0xFFFF & (minval >>> 16))) {
+      while (hasNext() && ((0xFFFF & (hs >>> 16)) < (0xFFFF & (minval >>> 16)))) {
         ++pos;
         nextContainer();
       }

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -106,7 +106,7 @@ private void nextContainer() {
 
     @Override
     public void advanceIfNeeded(int minval) {
-      while ((0xFFFF & (hs >>> 16)) < (0xFFFF & (minval >>> 16))) {
+      while (hasNext() && ((0xFFFF & (hs >>> 16)) < (0xFFFF & (minval >>> 16)))) {
         cp.advance();
         nextContainer();
       }

File: src/test/java/org/roaringbitmap/TestIntIteratorFlyweight.java
Patch:
@@ -88,6 +88,8 @@ public void testIteration() {
       Assert.assertEquals(j.peekNext(),data[k]);            
       Assert.assertEquals(iter2.peekNext(),data[k]);
     }
+    new IntIteratorFlyweight(bitmap).advanceIfNeeded(-1);
+    bitmap.getIntIterator().advanceIfNeeded(-1);// should not crash
 
     ReverseIntIteratorFlyweight reverseIter = new ReverseIntIteratorFlyweight();
     reverseIter.wrap(bitmap);

File: src/test/java/org/roaringbitmap/TestIterators.java
Patch:
@@ -128,6 +128,7 @@ public void testSkips() {
       pii.next();
       Assert.assertEquals(data[i],pii.peekNext() );
     }
+    bitmap.getIntIterator().advanceIfNeeded(-1);// should not crash
   }
   
   @Test

File: src/test/java/org/roaringbitmap/buffer/TestIntIteratorFlyweight.java
Patch:
@@ -85,6 +85,9 @@ public void testIteration() {
       Assert.assertEquals(j.peekNext(),data[k]);            
       Assert.assertEquals(iter2.peekNext(),data[k]);
     }
+    new BufferIntIteratorFlyweight(bitmap).advanceIfNeeded(-1);
+    bitmap.getIntIterator().advanceIfNeeded(-1);// should not crash
+
 
     BufferReverseIntIteratorFlyweight reverseIter = new BufferReverseIntIteratorFlyweight();
     reverseIter.wrap(bitmap);

File: src/test/java/org/roaringbitmap/buffer/TestIterators.java
Patch:
@@ -194,6 +194,7 @@ public void testSkips() {
       pii.next();
       Assert.assertEquals(data[i],pii.peekNext() );
     }
+    bitmap.getIntIterator().advanceIfNeeded(-1);
   }
   
   @Test

File: src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -949,7 +949,7 @@ public Container runOptimize() {
     // passes some threshold based on the cardinality.
     int numRuns = numberOfRuns();
     int sizeAsRunContainer = RunContainer.serializedSizeInBytes(numRuns);
-    if (getArraySizeInBytes() > RunContainer.RUN_OPTI_MINIMAL_GAIN * sizeAsRunContainer) {
+    if (getArraySizeInBytes() > sizeAsRunContainer) {
       return new RunContainer(this, numRuns); // this could be maybe
                                               // faster if initial
                                               // container is a bitmap

File: src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -1058,7 +1058,7 @@ public Container runOptimize() {
 
     int sizeAsRunContainerLowerBound = RunContainer.serializedSizeInBytes(numRuns);
 
-    if (RunContainer.RUN_OPTI_MINIMAL_GAIN * sizeAsRunContainerLowerBound >= getArraySizeInBytes()) {
+    if (sizeAsRunContainerLowerBound >= getArraySizeInBytes()) {
       return this;
     }
     // else numRuns is a relatively tight bound that needs to be exact
@@ -1067,7 +1067,7 @@ public Container runOptimize() {
     numRuns += numberOfRunsAdjustment();
     int sizeAsRunContainer = RunContainer.serializedSizeInBytes(numRuns);
 
-    if (getArraySizeInBytes() > RunContainer.RUN_OPTI_MINIMAL_GAIN *sizeAsRunContainer) {
+    if (getArraySizeInBytes() > sizeAsRunContainer) {
       return new RunContainer(this, numRuns);
     } else {
       return this;

File: src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -949,7 +949,7 @@ public Container runOptimize() {
     // passes some threshold based on the cardinality.
     int numRuns = numberOfRuns();
     int sizeAsRunContainer = RunContainer.serializedSizeInBytes(numRuns);
-    if (getArraySizeInBytes() > sizeAsRunContainer) {
+    if (getArraySizeInBytes() > RunContainer.RUN_OPTI_MINIMAL_GAIN * sizeAsRunContainer) {
       return new RunContainer(this, numRuns); // this could be maybe
                                               // faster if initial
                                               // container is a bitmap

File: src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -1058,7 +1058,7 @@ public Container runOptimize() {
 
     int sizeAsRunContainerLowerBound = RunContainer.serializedSizeInBytes(numRuns);
 
-    if (sizeAsRunContainerLowerBound >= getArraySizeInBytes()) {
+    if (RunContainer.RUN_OPTI_MINIMAL_GAIN * sizeAsRunContainerLowerBound >= getArraySizeInBytes()) {
       return this;
     }
     // else numRuns is a relatively tight bound that needs to be exact
@@ -1067,7 +1067,7 @@ public Container runOptimize() {
     numRuns += numberOfRunsAdjustment();
     int sizeAsRunContainer = RunContainer.serializedSizeInBytes(numRuns);
 
-    if (getArraySizeInBytes() > sizeAsRunContainer) {
+    if (getArraySizeInBytes() > RunContainer.RUN_OPTI_MINIMAL_GAIN *sizeAsRunContainer) {
       return new RunContainer(this, numRuns);
     } else {
       return this;

File: src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -1045,6 +1045,9 @@ public Container remove(final short i) {
   public Container repairAfterLazy() {
     if (getCardinality() < 0) {
       computeCardinality();
+      if(getCardinality() <= ArrayContainer.DEFAULT_MAX_SIZE) {
+        return this.toArrayContainer();
+      }
     }
     return this;
   }

File: src/main/java/org/roaringbitmap/Container.java
Patch:
@@ -551,7 +551,7 @@ public Container ixor(Container x) {
   public Container lazyIOR(Container x) {
     if (this instanceof ArrayContainer) {
       if (x instanceof ArrayContainer) {
-        return ior((ArrayContainer) x);
+        return ((ArrayContainer)this).lazyor((ArrayContainer) x);
       } else if (x instanceof BitmapContainer) {
         return ior((BitmapContainer) x);
       }
@@ -585,7 +585,7 @@ public Container lazyIOR(Container x) {
   public Container lazyOR(Container x) {
     if (this instanceof ArrayContainer) {
       if (x instanceof ArrayContainer) {
-        return or((ArrayContainer) x);
+        return ((ArrayContainer)this).lazyor((ArrayContainer) x);
       } else if (x instanceof BitmapContainer) {
         return ((BitmapContainer) x).lazyor((ArrayContainer) this);
       }

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -565,7 +565,7 @@ protected static RoaringBitmap lazyorfromlazyinputs(final RoaringBitmap x1,
           }
           s1 = x1.highLowContainer.getKeyAtIndex(pos1);
         } else { // s1 > s2
-          Container c2 = x1.highLowContainer.getContainerAtIndex(pos2);
+          Container c2 = x2.highLowContainer.getContainerAtIndex(pos2);
           answer.highLowContainer.append(s2,c2);
           pos2++;
           if (pos2 == length2) {

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -2005,7 +2005,7 @@ private static RoaringBitmap selectRangeWithoutCopy(RoaringBitmap rb, final long
 
 
   /**
-   * Return the set values as an array, if the cardinality is smaller than 1<<31. 
+   * Return the set values as an array, if the cardinality is smaller than 2147483648. 
    * The integer values are in sorted order.
    * 
    * @return array representing the set values.

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -1317,7 +1317,7 @@ public int serializedSizeInBytes() {
 
   /**
    * Return the set values as an array if the cardinality is less 
-   * than 1<<31. The integer values are in sorted order.
+   * than 2147483648. The integer values are in sorted order.
    * 
    * @return array representing the set values.
    */

File: src/main/java/org/roaringbitmap/buffer/BufferUtil.java
Patch:
@@ -288,6 +288,7 @@ private static int cardinalityInBitmapWordRange(LongBuffer bitmap, int start, in
    * @param bitmap array of words to be modified
    * @param start first index to be modified (inclusive)
    * @param end last index to be modified (exclusive)
+   * @return cardinality change
    */
   public static int setBitmapRangeAndCardinalityChange(LongBuffer bitmap, int start, int end) {
     if (BufferUtil.isBackedBySimpleArray(bitmap)) {
@@ -306,6 +307,7 @@ public static int setBitmapRangeAndCardinalityChange(LongBuffer bitmap, int star
    * @param bitmap array of words to be modified
    * @param start first index to be modified (inclusive)
    * @param end last index to be modified (exclusive)
+   * @return cardinality change
    */
   public static int flipBitmapRangeAndCardinalityChange(LongBuffer bitmap, int start, int end) {
     if (BufferUtil.isBackedBySimpleArray(bitmap)) {
@@ -324,6 +326,7 @@ public static int flipBitmapRangeAndCardinalityChange(LongBuffer bitmap, int sta
    * @param bitmap array of words to be modified
    * @param start first index to be modified (inclusive)
    * @param end last index to be modified (exclusive)
+   * @return cardinality change
    */
   public static int resetBitmapRangeAndCardinalityChange(LongBuffer bitmap, int start, int end) {
     if (BufferUtil.isBackedBySimpleArray(bitmap)) {

File: src/main/java/org/roaringbitmap/IntIteratorFlyweight.java
Patch:
@@ -103,8 +103,8 @@ public void wrap(RoaringBitmap r) {
   }
 
   @Override
-  public void advanceIfNeeded(int minval) {
-    while ((hs >>> 16) < (minval >>> 16)) {
+  public void advanceIfNeeded(final int minval) {
+    while ((0xFFFF & (hs >>> 16)) < (0xFFFF & (minval >>> 16))) {
       ++pos;
       if (pos < this.roaringBitmap.highLowContainer.size()) {
         nextContainer();

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -89,7 +89,7 @@ private void nextContainer() {
 
     @Override
     public void advanceIfNeeded(int minval) {
-      while ((hs >>> 16) < (minval >>> 16)) {
+      while ((0xFFFF & (hs >>> 16)) < (0xFFFF & (minval >>> 16))) {
         ++pos;
         nextContainer();
       }

File: src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -2472,7 +2472,7 @@ public void advanceIfNeeded(short minval) {
     }
     if (base > Util.toIntUnsigned(minval)) {
       return;
-    }
+    }    
     le = Util.toIntUnsigned(minval) - base;
   }
 

File: src/main/java/org/roaringbitmap/buffer/BufferIntIteratorFlyweight.java
Patch:
@@ -6,7 +6,6 @@
 
 import org.roaringbitmap.PeekableIntIterator;
 import org.roaringbitmap.PeekableShortIterator;
-import org.roaringbitmap.RoaringBitmap;
 
 /**
  * Fast iterator minimizing the stress on the garbage collector. You can create one reusable
@@ -111,14 +110,15 @@ public void wrap(ImmutableRoaringBitmap r) {
 
   @Override
   public void advanceIfNeeded(int minval) {
-    while ((hs >>> 16) < (minval >>> 16)) {
+    while ((0xFFFF & (hs >>> 16)) < (0xFFFF & (minval >>> 16))) {
       pos++;
       if (pos < this.roaringBitmap.highLowContainer.size()) {
         nextContainer();
       } else {
         return;
       }
     }
+    iter.advanceIfNeeded(BufferUtil.lowbits(minval));
   }
 
   @Override

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -106,7 +106,7 @@ private void nextContainer() {
 
     @Override
     public void advanceIfNeeded(int minval) {
-      while ((hs >>> 16) < (minval >>> 16)) {
+      while ((0xFFFF & (hs >>> 16)) < (0xFFFF & (minval >>> 16))) {
         cp.advance();
         nextContainer();
       }

File: src/main/java/org/roaringbitmap/ReverseIntIteratorFlyweight.java
Patch:
@@ -44,7 +44,7 @@ public ReverseIntIteratorFlyweight() {
    * @param r bitmap to be iterated over
    */
   public ReverseIntIteratorFlyweight(RoaringBitmap r) {
-
+    wrap(r);
   }
 
   @Override

File: src/main/java/org/roaringbitmap/buffer/BufferReverseIntIteratorFlyweight.java
Patch:
@@ -49,7 +49,7 @@ public BufferReverseIntIteratorFlyweight() {
    * @param r bitmap to be iterated over
    */
   public BufferReverseIntIteratorFlyweight(ImmutableRoaringBitmap r) {
-
+    wrap(r);
   }
 
   @Override

File: src/test/java/org/roaringbitmap/buffer/TestRoaringBitmap.java
Patch:
@@ -23,7 +23,7 @@
 @SuppressWarnings({"static-method"})
 public class TestRoaringBitmap {
   
-  public static ImmutableRoaringBitmap toMapped(MutableRoaringBitmap r) {
+  private static ImmutableRoaringBitmap toMapped(MutableRoaringBitmap r) {
     ByteArrayOutputStream bos = new ByteArrayOutputStream();
     DataOutputStream dos = new DataOutputStream(bos);
     try {
@@ -34,7 +34,7 @@ public static ImmutableRoaringBitmap toMapped(MutableRoaringBitmap r) {
     }
     ByteBuffer bb = ByteBuffer.wrap(bos.toByteArray());
     return new ImmutableRoaringBitmap(bb);
-}
+  }
 
 
   @Test

File: src/main/java/org/roaringbitmap/Util.java
Patch:
@@ -200,7 +200,7 @@ public static void flipBitmapRange(long[] bitmap, int start, int end) {
     }
     int firstword = start / 64;
     int endword = (end - 1) / 64;
-    bitmap[firstword] ^= ~(~0L << start);;
+    bitmap[firstword] ^= ~(~0L << start);
     for (int i = firstword; i < endword; i++) {
       bitmap[i] = ~bitmap[i];
     }

File: src/main/java/org/roaringbitmap/buffer/BufferUtil.java
Patch:
@@ -715,7 +715,7 @@ protected static int unsignedLocalIntersect2by2Cardinality(final ShortBuffer set
 
         } while (toIntUnsigned(s1) < toIntUnsigned(s2));
       } else {
-        // (set2.get(k2) == set1.get(k1))
+        ++pos;
         ++k1;
         if (k1 == length1) {
           break;

File: src/main/java/org/roaringbitmap/IntIteratorFlyweight.java
Patch:
@@ -8,6 +8,8 @@
  * Fast iterator minimizing the stress on the garbage collector. You can create one reusable
  * instance of this class and then {@link #wrap(RoaringBitmap)}
  * 
+ * For better performance, consider the {@link RoaringBitmap#forEach} method.
+ * 
  * @author Borislav Ivanov
  **/
 public class IntIteratorFlyweight implements PeekableIntIterator {

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -97,7 +97,9 @@ public void advanceIfNeeded(int minval) {
           return;
         }
       }
-      iter.advanceIfNeeded(Util.lowbits(minval));
+      if(hasNext()) {
+        iter.advanceIfNeeded(Util.lowbits(minval));
+      }
     }
 
     @Override

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -113,7 +113,9 @@ public void advanceIfNeeded(int minval) {
           return;
         }
       }
-      iter.advanceIfNeeded(BufferUtil.lowbits(minval));
+      if(ok) {
+        iter.advanceIfNeeded(BufferUtil.lowbits(minval));
+      }
     }
 
     @Override

File: src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -364,7 +364,7 @@ public ShortIterator getReverseShortIterator() {
   }
 
   @Override
-  public ShortIterator getShortIterator() {
+  public PeekableShortIterator getShortIterator() {
     return new ArrayContainerShortIterator(this);
   }
 
@@ -1087,9 +1087,9 @@ public void advanceIfNeeded(short minval) {
 
 
   @Override
-  public ShortIterator clone() {
+  public PeekableShortIterator clone() {
     try {
-      return (ShortIterator) super.clone();
+      return (PeekableShortIterator) super.clone();
     } catch (CloneNotSupportedException e) {
       return null;// will not happen
     }

File: src/main/java/org/roaringbitmap/Container.java
Patch:
@@ -260,7 +260,7 @@ public String getContainerName() {
    *
    * @return iterator
    */
-  public abstract ShortIterator getShortIterator();
+  public abstract PeekableShortIterator getShortIterator();
 
   /**
    * Computes an estimate of the memory usage of this container. The estimate is not meant to be

File: src/main/java/org/roaringbitmap/ImmutableBitmapDataProvider.java
Patch:
@@ -31,7 +31,7 @@ public interface ImmutableBitmapDataProvider {
   /**
    * @return a custom iterator over set bits, the bits are traversed in ascending sorted order
    */
-  public IntIterator getIntIterator();
+  public PeekableIntIterator getIntIterator();
 
   /**
    * @return a custom iterator over set bits, the bits are traversed in descending sorted order

File: src/main/java/org/roaringbitmap/buffer/MappeableContainer.java
Patch:
@@ -5,6 +5,7 @@
 package org.roaringbitmap.buffer;
 
 import org.roaringbitmap.Container;
+import org.roaringbitmap.PeekableShortIterator;
 import org.roaringbitmap.ShortIterator;
 
 import java.io.DataOutput;
@@ -213,7 +214,7 @@ public String getContainerName() {
    *
    * @return iterator
    */
-  public abstract ShortIterator getShortIterator();
+  public abstract PeekableShortIterator getShortIterator();
 
   /**
    * Computes an estimate of the memory usage of this container. The estimate is not meant to be

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -1556,8 +1556,8 @@ public void serialize(DataOutput out) throws IOException {
   public static long maximumSerializedSize(long cardinality, long universe_size) {
     long contnbr = (universe_size+65535)/65536;
     if(contnbr > cardinality) {
-        contnbr = cardinality; 
-        // we can't have more containers than we have values
+      contnbr = cardinality; 
+      // we can't have more containers than we have values
     }
     final long headermax = Math.max(8, 4 + (contnbr + 7) / 8) + 8 * contnbr;
     final long valsarray = 2 * cardinality;

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringArray.java
Patch:
@@ -45,7 +45,7 @@ protected ImmutableRoaringArray(ByteBuffer bbf) {
     if ((cookie & 0xFFFF) != SERIAL_COOKIE && cookie != SERIAL_COOKIE_NO_RUNCONTAINER) {
       throw new RuntimeException("I failed to find one of the right cookies. " + cookie);
     }
-    boolean hasRunContainers = ((cookie & 0xFFFF) == SERIAL_COOKIE);
+    boolean hasRunContainers = (cookie & 0xFFFF) == SERIAL_COOKIE;
     this.size = hasRunContainers ? (cookie >>> 16) + 1 : buffer.getInt(4);
     int theLimit = size > 0 ? computeSerializedSizeInBytes() : headerSize(hasRunContainers);
     buffer.limit(theLimit);

File: src/main/java/org/roaringbitmap/buffer/MappeableBitmapContainer.java
Patch:
@@ -503,7 +503,7 @@ public void fillLeastSignificant16bits(int[] x, int i, int mask) {
   public MappeableContainer flip(short i) {
     final int x = BufferUtil.toIntUnsigned(i);
     final long bef = bitmap.get(x / 64);
-    final long mask = (1L << x);
+    final long mask = 1L << x;
     if (cardinality == MappeableArrayContainer.DEFAULT_MAX_SIZE + 1) {// this
                                                                       // is
       // the
@@ -981,7 +981,7 @@ public MappeableContainer ixor(final MappeableArrayContainer value2) {
       int c = value2.cardinality;
       for (int k = 0; k < c; ++k) {
         short vc = v2[k];
-        long mask = (1L << v2[k]);
+        long mask = 1L << v2[k];
         final int index = BufferUtil.toIntUnsigned(vc) >>> 6;
         long ba = b[index];
         // TODO: check whether a branchy version could be faster
@@ -993,7 +993,7 @@ public MappeableContainer ixor(final MappeableArrayContainer value2) {
       int c = value2.cardinality;
       for (int k = 0; k < c; ++k) {
         short v2 = value2.content.get(k);
-        long mask = (1L << v2);
+        long mask = 1L << v2;
         final int index = BufferUtil.toIntUnsigned(v2) >>> 6;
         long ba = b[index];
         // TODO: check whether a branchy version could be faster

File: src/main/java/org/roaringbitmap/buffer/MutableRoaringArray.java
Patch:
@@ -522,7 +522,7 @@ public void serialize(DataOutput out) throws IOException {
     }
     for (int k = 0; k < size; ++k) {
       out.writeShort(Short.reverseBytes(this.keys[k]));
-      out.writeShort(Short.reverseBytes((short) ((this.values[k].getCardinality() - 1))));
+      out.writeShort(Short.reverseBytes((short) (this.values[k].getCardinality() - 1)));
     }
     if ((!hasrun) || (this.size >= NO_OFFSET_THRESHOLD)) {
       for (int k = 0; k < this.size; k++) {

File: src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -804,7 +804,7 @@ public Container remove(final short i) {
         final int x = Util.toIntUnsigned(i);
         int index = x / 64;
         long bef = bitmap[index];
-        long mask = (1L << x);
+        long mask = 1L << x;
         if (cardinality == ArrayContainer.DEFAULT_MAX_SIZE + 1) {// this is
             // the
             // uncommon
@@ -887,7 +887,7 @@ public Container xor(final ArrayContainer value2) {
         for (int k = 0; k < c; ++k) {
             short vc =  value2.content[k];
             final int index = Util.toIntUnsigned(vc) >>> 6;
-            final long mask = (1L << vc);
+            final long mask = 1L << vc;
             final long val = answer.bitmap[index];
             // TODO: check whether a branchy version could be faster
             answer.cardinality += 1 - 2 * ((val & mask) >>> vc);

File: src/main/java/org/roaringbitmap/RoaringArray.java
Patch:
@@ -359,7 +359,7 @@ public void serialize(DataOutput out) throws IOException {
         }
         for (int k = 0; k < size; ++k) {
             out.writeShort(Short.reverseBytes(this.keys[k]));
-            out.writeShort(Short.reverseBytes((short) ((this.values[k].getCardinality() - 1))));
+            out.writeShort(Short.reverseBytes((short) (this.values[k].getCardinality() - 1)));
         }
         if((! hasrun) || (this.size >= NO_OFFSET_THRESHOLD) ) {
             //writing the containers offsets

File: src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -787,7 +787,7 @@ public Container inot(int rangeStart, int rangeEnd) {
         //could try using unsignedInterleavedBinarySearch(valueslength, 0, nbrruns, rangeStart) instead of sequential scan
         //to find the starting location
 
-        for(; (k < myNbrRuns) && ((Util.toIntUnsigned(this.getValue(k)) < rangeStart)) ; ++k) {
+        for(; (k < myNbrRuns) && (Util.toIntUnsigned(this.getValue(k)) < rangeStart) ; ++k) {
             // since it is atop self, there is no copying needed
             //ans.valueslength[2 * k] = this.valueslength[2 * k];
             //ans.valueslength[2 * k + 1] = this.valueslength[2 * k + 1];
@@ -880,7 +880,7 @@ public Container not(int rangeStart, int rangeEnd) {
         if (rangeEnd <= rangeStart) return this.clone();
         RunContainer ans = new RunContainer(nbrruns+1);
         int k = 0;
-        for(; (k < this.nbrruns) && ((Util.toIntUnsigned(this.getValue(k)) < rangeStart)) ; ++k) {
+        for(; (k < this.nbrruns) && (Util.toIntUnsigned(this.getValue(k)) < rangeStart) ; ++k) {
                 ans.valueslength[2 * k] = this.valueslength[2 * k];
                 ans.valueslength[2 * k + 1] = this.valueslength[2 * k + 1];
                 ans.nbrruns++;
@@ -1941,7 +1941,7 @@ public Container ior(RunContainer x) {
         }
 
         while (rlepos < nbrruns) {
-            this.smartAppend(this.getValue(offset + rlepos), this.getLength((offset + rlepos)));
+            this.smartAppend(this.getValue(offset + rlepos), this.getLength(offset + rlepos));
             ++rlepos;
         }
 

File: src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -334,7 +334,7 @@ private void increaseCapacity(boolean allowIllegalSize) {
         if (newCapacity > ArrayContainer.DEFAULT_MAX_SIZE  && ! allowIllegalSize)
             newCapacity = ArrayContainer.DEFAULT_MAX_SIZE;
         // if we are within 1/16th of the max, go to max 
-        if( newCapacity < ArrayContainer.DEFAULT_MAX_SIZE - ArrayContainer.DEFAULT_MAX_SIZE/16)
+        if( newCapacity > ArrayContainer.DEFAULT_MAX_SIZE - ArrayContainer.DEFAULT_MAX_SIZE/16)
             newCapacity = ArrayContainer.DEFAULT_MAX_SIZE;
         this.content = Arrays.copyOf(this.content, newCapacity);
     }

File: src/main/java/org/roaringbitmap/buffer/MappeableArrayContainer.java
Patch:
@@ -501,7 +501,7 @@ private void increaseCapacity(boolean allowIllegalSize) {
         if (newCapacity > MappeableArrayContainer.DEFAULT_MAX_SIZE && !allowIllegalSize )
             newCapacity = MappeableArrayContainer.DEFAULT_MAX_SIZE;
         // if we are within 1/16th of the max., go to max right away to avoid further reallocations
-        if(newCapacity < MappeableArrayContainer.DEFAULT_MAX_SIZE  -  MappeableArrayContainer.DEFAULT_MAX_SIZE / 16)
+        if(newCapacity > MappeableArrayContainer.DEFAULT_MAX_SIZE  -  MappeableArrayContainer.DEFAULT_MAX_SIZE / 16)
             newCapacity = MappeableArrayContainer.DEFAULT_MAX_SIZE;
         final ShortBuffer newContent = ShortBuffer.allocate(newCapacity);
         this.content.rewind();

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -509,7 +509,7 @@ public ImmutableRoaringBitmap(final ByteBuffer b) {
     @Override
     public ImmutableRoaringBitmap clone() {
         try {
-            final ImmutableRoaringBitmap x = (MutableRoaringBitmap) super
+            final ImmutableRoaringBitmap x = (ImmutableRoaringBitmap) super
                     .clone();
             x.highLowContainer = highLowContainer.clone();
             return x;

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -510,7 +510,7 @@ public ImmutableRoaringBitmap(final ByteBuffer b) {
     @Override
     public ImmutableRoaringBitmap clone() {
         try {
-            final ImmutableRoaringBitmap x = (MutableRoaringBitmap) super
+            final ImmutableRoaringBitmap x = (ImmutableRoaringBitmap) super
                     .clone();
             x.highLowContainer = highLowContainer.clone();
             return x;

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringArray.java
Patch:
@@ -412,6 +412,7 @@ public int hashCode() {
         while (cp.hasContainer()) {
             int th = cp.key() * 0xF0F0F0 + cp.getContainer().hashCode();
             hashvalue = 31 * hashvalue + th;
+            cp.advance();
         }
         return hashvalue;
     }

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringArray.java
Patch:
@@ -410,6 +410,7 @@ public int hashCode() {
         while (cp.hasContainer()) {
             int th = cp.key() * 0xF0F0F0 + cp.getContainer().hashCode();
             hashvalue = 31 * hashvalue + th;
+            cp.advance();
         }
         return hashvalue;
     }

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -1445,8 +1445,8 @@ public boolean removeRunCompression() {
         for (int i = 0; i < this.highLowContainer.size(); i++) {
             Container c = this.highLowContainer.getContainerAtIndex(i);
             if(c instanceof RunContainer) {
-                ((RunContainer)c).toBitmapOrArrayContainer(c.getCardinality());
-                this.highLowContainer.setContainerAtIndex(i, c);
+                Container newc = ((RunContainer)c).toBitmapOrArrayContainer(c.getCardinality());
+                this.highLowContainer.setContainerAtIndex(i, newc);
                 answer = true;
             }
         }

File: src/main/java/org/roaringbitmap/buffer/MutableRoaringBitmap.java
Patch:
@@ -1128,8 +1128,8 @@ public boolean removeRunCompression() {
         for (int i = 0; i < this.highLowContainer.size(); i++) {
             MappeableContainer c = getMappeableRoaringArray().getContainerAtIndex(i);
             if(c instanceof MappeableRunContainer) {
-                ((MappeableRunContainer)c).toBitmapOrArrayContainer(c.getCardinality());
-                getMappeableRoaringArray().setContainerAtIndex(i, c);
+                MappeableContainer mc = ((MappeableRunContainer)c).toBitmapOrArrayContainer(c.getCardinality());
+                getMappeableRoaringArray().setContainerAtIndex(i, mc);
                 answer = true;
             }
         }

File: src/test/java/org/roaringbitmap/TestRoaringBitmap.java
Patch:
@@ -20,6 +20,8 @@
 @SuppressWarnings({ "static-method" })
 public class TestRoaringBitmap {
 
+
+
     @Test
     public void containerSharingWithXor() {
         RoaringBitmap r1 = new RoaringBitmap();

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -220,7 +220,7 @@ public static MutableRoaringBitmap flip(ImmutableRoaringBitmap bm,
             if (i >= 0) {
                 final MappeableContainer c = bm.highLowContainer
                         .getContainerAtIndex(i).not(containerStart,
-                                containerLast);
+                                containerLast+1);
                 if (c.getCardinality() > 0)
                     answer.getMappeableRoaringArray().insertNewKeyValueAt(
                             -j - 1, hb, c);

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -220,7 +220,7 @@ public static MutableRoaringBitmap flip(ImmutableRoaringBitmap bm,
             if (i >= 0) {
                 final MappeableContainer c = bm.highLowContainer
                         .getContainerAtIndex(i).not(containerStart,
-                                containerLast);
+                                containerLast+1);
                 if (c.getCardinality() > 0)
                     answer.getMappeableRoaringArray().insertNewKeyValueAt(
                             -j - 1, hb, c);

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -1544,7 +1544,7 @@ public void xor(final RoaringBitmap x2) {
                     }
                     s1 = highLowContainer.getKeyAtIndex(pos1);
                 } else { // s1 > s2
-                    highLowContainer.insertNewKeyValueAt(pos1, s2, x2.highLowContainer.getContainerAtIndex(pos2));
+                    highLowContainer.insertNewKeyValueAt(pos1, s2, x2.highLowContainer.getContainerAtIndex(pos2).clone());
                     pos1++;
                     length1++;
                     pos2++;

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -1165,7 +1165,7 @@ public void or(final RoaringBitmap x2) {
                     }
                     s1 = highLowContainer.getKeyAtIndex(pos1);
                 } else { // s1 > s2
-                    highLowContainer.insertNewKeyValueAt(pos1, s2, x2.highLowContainer.getContainerAtIndex(pos2)
+                    highLowContainer.insertNewKeyValueAt(pos1, s2, x2.highLowContainer.getContainerAtIndex(pos2).clone()
                     );
                     pos1++;
                     length1++;

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -955,7 +955,7 @@ private void nextContainer() {
         @Override
         public IntIterator clone() {
             try {
-                ImmutableRoaringIntIterator x = (ImmutableRoaringIntIterator) super.clone();
+                ImmutableRoaringReverseIntIterator x = (ImmutableRoaringReverseIntIterator) super.clone();
                 x.iter = this.iter.clone();
                 x.cp = this.cp.clone();
                 return x;

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -955,7 +955,7 @@ private void nextContainer() {
         @Override
         public IntIterator clone() {
             try {
-                ImmutableRoaringIntIterator x = (ImmutableRoaringIntIterator) super.clone();
+                ImmutableRoaringReverseIntIterator x = (ImmutableRoaringReverseIntIterator) super.clone();
                 x.iter = this.iter.clone();
                 x.cp = this.cp.clone();
                 return x;

File: src/main/java/org/roaringbitmap/buffer/MappeableRunContainer.java
Patch:
@@ -756,7 +756,8 @@ public MappeableContainer inot(int rangeStart, int rangeEnd) {
         // 0 run vs start with a 1 run.  If you both start and end with 0s,
         // you will require room for expansion.
         
-        if (vl.length <= 2*nbrruns)  {
+        // the +1 below is needed in case the valueslength.length is odd
+        if (vl.length <= 2*nbrruns + 1)  {
             // no room for expansion
             // analyze whether this is a case that will require expansion (that we cannot do) 
             // this is a bit costly now (4 "contains" checks)

File: src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -671,7 +671,8 @@ public Container inot(int rangeStart, int rangeEnd) {
         // 0 run vs start with a 1 run.  If you both start and end with 0s,
         // you will require room for expansion.
         
-        if (valueslength.length <= 2*nbrruns)  {
+        // the +1 below is needed in case the valueslength.length is odd
+        if (valueslength.length <= 2*nbrruns+1)  {
             // no room for expansion
             // analyze whether this is a case that will require expansion (that we cannot do) 
             // this is a bit costly now (4 "contains" checks)

File: src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -81,6 +81,7 @@ int numberOfRuns() {
     }
 
 
+
   
 
     /**
@@ -288,7 +289,7 @@ private void increaseCapacity(boolean allowIllegalSize) {
         if (newCapacity > ArrayContainer.DEFAULT_MAX_SIZE  && ! allowIllegalSize)
             newCapacity = ArrayContainer.DEFAULT_MAX_SIZE;
         // if we are within 1/16th of the max, go to max 
-        if(ArrayContainer.DEFAULT_MAX_SIZE - newCapacity < ArrayContainer.DEFAULT_MAX_SIZE/16)
+        if( newCapacity < ArrayContainer.DEFAULT_MAX_SIZE - ArrayContainer.DEFAULT_MAX_SIZE/16)
             newCapacity = ArrayContainer.DEFAULT_MAX_SIZE;
         this.content = Arrays.copyOf(this.content, newCapacity);
     }
@@ -302,7 +303,7 @@ private void increaseCapacity(int min) {
         if (newCapacity > ArrayContainer.DEFAULT_MAX_SIZE)
             newCapacity = ArrayContainer.DEFAULT_MAX_SIZE;
         // if we are within 1/16th of the max, go to max 
-        if(ArrayContainer.DEFAULT_MAX_SIZE - newCapacity < ArrayContainer.DEFAULT_MAX_SIZE/16)
+        if( newCapacity < ArrayContainer.DEFAULT_MAX_SIZE - ArrayContainer.DEFAULT_MAX_SIZE/16)
             newCapacity = ArrayContainer.DEFAULT_MAX_SIZE;
         this.content = Arrays.copyOf(this.content, newCapacity);
     }

File: src/main/java/org/roaringbitmap/buffer/MappeableArrayContainer.java
Patch:
@@ -476,8 +476,7 @@ private void increaseCapacity(boolean allowIllegalSize) {
         if (newCapacity > MappeableArrayContainer.DEFAULT_MAX_SIZE && !allowIllegalSize )
             newCapacity = MappeableArrayContainer.DEFAULT_MAX_SIZE;
         // if we are within 1/16th of the max., go to max right away to avoid further reallocations
-        if(MappeableArrayContainer.DEFAULT_MAX_SIZE  - newCapacity 
-                < MappeableArrayContainer.DEFAULT_MAX_SIZE / 16)
+        if(newCapacity < MappeableArrayContainer.DEFAULT_MAX_SIZE  -  MappeableArrayContainer.DEFAULT_MAX_SIZE / 16)
             newCapacity = MappeableArrayContainer.DEFAULT_MAX_SIZE;
         final ShortBuffer newContent = ShortBuffer.allocate(newCapacity);
         this.content.rewind();
@@ -494,6 +493,8 @@ private void increaseCapacity(int min) {
         if(newCapacity < min) newCapacity = min;
         if (newCapacity > MappeableArrayContainer.DEFAULT_MAX_SIZE)
             newCapacity = MappeableArrayContainer.DEFAULT_MAX_SIZE;
+        if(newCapacity < MappeableArrayContainer.DEFAULT_MAX_SIZE  -  MappeableArrayContainer.DEFAULT_MAX_SIZE / 16)
+            newCapacity = MappeableArrayContainer.DEFAULT_MAX_SIZE;
         final ShortBuffer newContent = ShortBuffer.allocate(newCapacity);
         this.content.rewind();
         newContent.put(this.content);

File: jmh/src/main/java/org/roaringbitmap/runcontainer/RunContainerRealDataBenchmarkWideOrNaive.java
Patch:
@@ -108,7 +108,7 @@ public int Concise_naive(BenchmarkState benchmarkState) {
     public int WAH_naive(BenchmarkState benchmarkState) {
         ConciseSet bitmapor = benchmarkState.wah.get(0);
         for (int j = 1; j < Math.min(benchmarkState.wah.size(),benchmarkState.count) ; ++j) {
-            bitmapor = bitmapor.union(benchmarkState.cc.get(j));
+            bitmapor = bitmapor.union(benchmarkState.wah.get(j));
         }
         int answer = bitmapor.size();
         if(answer != benchmarkState.horizontalor)

File: src/main/java/org/roaringbitmap/buffer/MappeableContainer.java
Patch:
@@ -426,7 +426,7 @@ else if (x instanceof MappeableBitmapContainer)
             return ((MappeableRunContainer) x).lazyor((MappeableArrayContainer) this);
         } else if (this instanceof MappeableRunContainer)  {
             if (x instanceof MappeableArrayContainer)
-                return ((MappeableRunContainer)this).ilazyor((MappeableArrayContainer) x);
+                return ((MappeableRunContainer)this).lazyor((MappeableArrayContainer) x);
             else if (x instanceof MappeableBitmapContainer)
                 return ((MappeableBitmapContainer) x).lazyor((MappeableRunContainer)this);
             return or((MappeableRunContainer) x);

File: src/main/java/org/roaringbitmap/buffer/MappeableContainer.java
Patch:
@@ -462,7 +462,7 @@ else if (x instanceof MappeableBitmapContainer)
             return ((MappeableRunContainer) x).lazyor((MappeableArrayContainer) this);
         } else if (this instanceof MappeableRunContainer) {
             if (x instanceof MappeableArrayContainer)
-                return ((MappeableRunContainer) this).lazyor((MappeableArrayContainer) x);
+                return ((MappeableRunContainer) this).ilazyor((MappeableArrayContainer) x);
             else if (x instanceof MappeableBitmapContainer) 
                 return ((MappeableBitmapContainer) x).lazyor((MappeableRunContainer) this);
             return ior((MappeableRunContainer) x);

File: src/main/java/org/roaringbitmap/buffer/MappeableRunContainer.java
Patch:
@@ -761,8 +761,8 @@ private MappeableContainer lazyorToRun(MappeableArrayContainer x) {
         if(i.hasNext()) {
             if(answer.nbrruns>0) {
                 // this might be useful if the run container has just one very large run
-                int lastval = BufferUtil.toIntUnsigned(answer.getValue(answer.nbrruns))
-                        + BufferUtil.toIntUnsigned(answer.getLength(answer.nbrruns)) + 1;
+                int lastval = BufferUtil.toIntUnsigned(answer.getValue(answer.nbrruns - 1))
+                        + BufferUtil.toIntUnsigned(answer.getLength(answer.nbrruns - 1)) + 1;
                 i.advanceIfNeeded((short) lastval);
             }
             while (i.hasNext()) {

File: src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -43,7 +43,7 @@ public String toString() {
             sb.append(Util.toIntUnsigned(this.getValue(k)));
             sb.append(",");
             sb.append(Util.toIntUnsigned(this.getValue(k)) +
-                    Util.toIntUnsigned(this.getLength(k)) + 1);
+                    Util.toIntUnsigned(this.getLength(k)));
             sb.append("]");
         }
         return sb.toString();

File: jmh/src/main/java/org/roaringbitmap/runcontainer/RunContainerRealDataBenchmarkWideAnd.java
Patch:
@@ -335,7 +335,7 @@ public void setup() throws Exception {
                     + String.format("%1$10s",df.format(stupidbitmapsize * 8.0 / totalcount)));
             System.out.println("==============");
             System.out.println();
-            expectedvalue = FastAggregation.naive_or(limit(count,rc.iterator()))
+            expectedvalue = FastAggregation.naive_and(limit(count,rc.iterator()))
                     .getCardinality();
         }
 

File: src/main/java/org/roaringbitmap/buffer/BufferFastAggregation.java
Patch:
@@ -5,8 +5,6 @@
 
 package org.roaringbitmap.buffer;
 
-import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Iterator;
@@ -30,7 +28,7 @@ public final class BufferFastAggregation {
      */
     public static MutableRoaringBitmap naive_and(MutableRoaringBitmap... bitmaps) {
        if(bitmaps.length == 0) return new MutableRoaringBitmap();
-       MutableRoaringBitmap answer = bitmaps[0];
+       MutableRoaringBitmap answer = bitmaps[0].clone();
        for(int k = 1; k < bitmaps.length; ++k)
           answer.and(bitmaps[k]);
        return answer;

File: src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -1671,10 +1671,11 @@ public Container repairAfterLazy() {
         return toEfficientContainer();
     }
     
-    // a very cheap check... if you have more than 2048, then you should use a bitmap container.
+    // a very cheap check... if you have more than 4096, then you should use a bitmap container.
     // this function avoids computing the cardinality
     private Container convertToLazyBitmapIfNeeded() {
-        if(this.nbrruns > 2048) {//RunContainer.serializedSizeInBytes(this.nbrruns) > BitmapContainer.serializedSizeInBytes(0)
+        // when nbrruns exceed ArrayContainer.DEFAULT_MAX_SIZE, then we know it should be stored as a bitmap, always 
+        if(this.nbrruns > ArrayContainer.DEFAULT_MAX_SIZE) {
             BitmapContainer answer = new BitmapContainer();
             for (int rlepos=0; rlepos < this.nbrruns; ++rlepos) {
                 int start = Util.toIntUnsigned(this.getValue(rlepos));

File: src/main/java/org/roaringbitmap/buffer/MappeableRunContainer.java
Patch:
@@ -1737,10 +1737,11 @@ public MappeableContainer repairAfterLazy() {
         return toEfficientContainer();
     }
     
-    // a very cheap check... if you have more than 2048, then you should use a bitmap container.
+    // a very cheap check... if you have more than 4096, then you should use a bitmap container.
     // this function avoids computing the cardinality
     private MappeableContainer convertToLazyBitmapIfNeeded() {
-        if(this.nbrruns > 2048) {//RunContainer.serializedSizeInBytes(this.nbrruns) > BitmapContainer.serializedSizeInBytes(0)
+        // when nbrruns exceed MappeableArrayContainer.DEFAULT_MAX_SIZE, then we know it should be stored as a bitmap, always 
+        if(this.nbrruns > MappeableArrayContainer.DEFAULT_MAX_SIZE) {
             MappeableBitmapContainer answer = new MappeableBitmapContainer();
             for (int rlepos=0; rlepos < this.nbrruns; ++rlepos) {
                 int start = BufferUtil.toIntUnsigned(this.getValue(rlepos));

File: jmh/src/main/java/org/roaringbitmap/runcontainer/MappedRunContainerRealDataBenchmarkWideOrNaive.java
Patch:
@@ -131,7 +131,7 @@ public int EWAH_naive(BenchmarkState benchmarkState) {
     
     @Benchmark
     public int EWAH32_naive(BenchmarkState benchmarkState) {
-        Iterator i = limit(benchmarkState.count,benchmarkState.ewah.iterator());
+        Iterator i = limit(benchmarkState.count,benchmarkState.ewah32.iterator());
         EWAHCompressedBitmap32 bitmapor = (EWAHCompressedBitmap32) i.next();
         while(i.hasNext())
             bitmapor = bitmapor.or((EWAHCompressedBitmap32) i.next());

File: jmh/src/main/java/org/roaringbitmap/runcontainer/RunContainerRealDataBenchmarkWideOrNaive.java
Patch:
@@ -154,7 +154,7 @@ public int EWAH_naive(BenchmarkState benchmarkState) {
     
     @Benchmark
     public int EWAH32_naive(BenchmarkState benchmarkState) {
-        Iterator i = limit(benchmarkState.count,benchmarkState.ewah.iterator());
+        Iterator i = limit(benchmarkState.count,benchmarkState.ewah32.iterator());
         EWAHCompressedBitmap32 bitmapor = (EWAHCompressedBitmap32) i.next();
         while(i.hasNext())
             bitmapor = bitmapor.or((EWAHCompressedBitmap32) i.next());

File: src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -1671,8 +1671,10 @@ public Container repairAfterLazy() {
         return toEfficientContainer();
     }
     
+    // a very cheap check... if you have more than 2048, then you should use a bitmap container.
+    // this function avoids computing the cardinality
     private Container convertToLazyBitmapIfNeeded() {
-        if(this.nbrruns > 4096) {
+        if(this.nbrruns > 2048) {//RunContainer.serializedSizeInBytes(this.nbrruns) > BitmapContainer.serializedSizeInBytes(0)
             BitmapContainer answer = new BitmapContainer();
             for (int rlepos=0; rlepos < this.nbrruns; ++rlepos) {
                 int start = Util.toIntUnsigned(this.getValue(rlepos));

File: src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -1600,14 +1600,15 @@ private void smartAppendExclusive(short start, short length) {
 
     @Override
     public Container or(RunContainer x) {
-        if(isFull() || x.isFull()) return clone(); // cheap case that can save a lot of computation
+        if(isFull()) return clone();
+        if(x.isFull()) return x.clone(); // cheap case that can save a lot of computation
         // we really ought to optimize the rest of the code for the frequent case where there is a single run
         RunContainer answer = new RunContainer(0,new short[2 * (this.nbrruns + x.nbrruns)]);
         int rlepos = 0;
         int xrlepos = 0;
 
         while ((xrlepos < x.nbrruns) && (rlepos < this.nbrruns)) {
-            if(Util.compareUnsigned(getValue(rlepos), x.getValue(xrlepos)) < 0) {
+            if(Util.compareUnsigned(getValue(rlepos), x.getValue(xrlepos)) <= 0) {
                 answer.smartAppend(getValue(rlepos), getLength(rlepos));
                 rlepos++;
             } else {

File: src/main/java/org/roaringbitmap/buffer/MappeableRunContainer.java
Patch:
@@ -1670,15 +1670,16 @@ private void smartAppend(short[] vl, short val) {
     
     @Override
     public MappeableContainer or(MappeableRunContainer x) {
-        if(isFull() || x.isFull()) return clone(); // cheap case that can save a lot of computation
+        if(isFull()) return clone();
+        if(x.isFull()) return x.clone(); // cheap case that can save a lot of computation
         // we really ought to optimize the rest of the code for the frequent case where there is a single run
         MappeableRunContainer answer = new MappeableRunContainer(0,ShortBuffer.allocate(2 * (this.nbrruns + x.nbrruns)));
         short[] vl = answer.valueslength.array();
         int rlepos = 0;
         int xrlepos = 0;
 
         while ((rlepos < this.nbrruns) && (xrlepos < x.nbrruns)) {
-            if(BufferUtil.compareUnsigned(getValue(rlepos), x.getValue(xrlepos)) < 0) {
+            if(BufferUtil.compareUnsigned(getValue(rlepos), x.getValue(xrlepos)) <= 0) {
                 answer.smartAppend(vl,getValue(rlepos), getLength(rlepos));
                 rlepos++;
             } else {

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -1001,7 +1001,7 @@ protected void lazyor(final RoaringBitmap x2) {
                     }
                     s1 = highLowContainer.getKeyAtIndex(pos1);
                 } else { // s1 > s2
-                    highLowContainer.insertNewKeyValueAt(pos1, s2, x2.highLowContainer.getContainerAtIndex(pos2)
+                    highLowContainer.insertNewKeyValueAt(pos1, s2, x2.highLowContainer.getContainerAtIndex(pos2).clone()
                     );
                     pos1++;
                     length1++;

File: src/main/java/org/roaringbitmap/PeekableShortIterator.java
Patch:
@@ -18,7 +18,7 @@ public interface PeekableShortIterator extends ShortIterator {
      */
     public short peekNext();
     /**
-     * If needed, advance as long as the next value is >= minval
+     * If needed, advance as long as the next value is greater or equal to minval (as an unsigned short)
      * @param minval threshold
      */
     public void advanceIfNeeded(short minval);

File: src/main/java/org/roaringbitmap/FastAggregation.java
Patch:
@@ -70,7 +70,8 @@ public static RoaringBitmap naive_and(Iterator<RoaringBitmap> bitmaps) {
     public static RoaringBitmap naive_or(RoaringBitmap... bitmaps) {
        RoaringBitmap answer = new RoaringBitmap();
        for(int k = 0; k < bitmaps.length; ++k)
-          answer.or(bitmaps[k]);
+          answer.lazyor(bitmaps[k]);
+       answer.repairAfterLazy();
        return answer;
     }
 

File: src/main/java/org/roaringbitmap/buffer/BufferFastAggregation.java
Patch:
@@ -62,7 +62,8 @@ public static MutableRoaringBitmap naive_and(@SuppressWarnings("rawtypes") Itera
     public static MutableRoaringBitmap naive_or(MutableRoaringBitmap... bitmaps) {
        MutableRoaringBitmap answer = new MutableRoaringBitmap();
        for(int k = 0; k < bitmaps.length; ++k)
-          answer.or(bitmaps[k]);
+          answer.lazyor(bitmaps[k]);
+       answer.repairAfterLazy();
        return answer;
     }
 

File: jmh/src/main/java/org/roaringbitmap/runcontainer/RunContainerRealDataBenchmarkXor.java
Patch:
@@ -91,7 +91,7 @@ public int pairwiseXor_EWAH(BenchmarkState benchmarkState) {
          for(int k = 0; k + 1 < benchmarkState.ewah.size(); ++k)
              total += benchmarkState.ewah.get(k).xor(benchmarkState.ewah.get(k+1)).cardinality();
          if(total !=benchmarkState.totalxor )
-             throw new RuntimeException("bad pairwise and result");
+             throw new RuntimeException("bad pairwise xor result");
          return total;
      }
 
@@ -101,7 +101,7 @@ public int pairwiseXor_EWAH32(BenchmarkState benchmarkState) {
          for(int k = 0; k + 1 < benchmarkState.ewah32.size(); ++k)
              total += benchmarkState.ewah32.get(k).xor(benchmarkState.ewah32.get(k+1)).cardinality();
          if(total !=benchmarkState.totalxor )
-             throw new RuntimeException("bad pairwise and result");
+             throw new RuntimeException("bad pairwise xor result");
          return total;
      }
 

File: jmh/src/main/java/org/roaringbitmap/runcontainer/RunArrayAndBenchmark.java
Patch:
@@ -13,7 +13,6 @@
 import org.openjdk.jmh.annotations.Scope;
 import org.openjdk.jmh.annotations.State;
 import org.roaringbitmap.Container;
-import org.roaringbitmap.FastAggregation;
 import org.roaringbitmap.RoaringBitmap;
 
 @BenchmarkMode(Mode.AverageTime)

File: jmh/src/main/java/org/roaringbitmap/runcontainer/RunArrayOrBenchmark.java
Patch:
@@ -13,7 +13,6 @@
 import org.openjdk.jmh.annotations.Scope;
 import org.openjdk.jmh.annotations.State;
 import org.roaringbitmap.Container;
-import org.roaringbitmap.FastAggregation;
 import org.roaringbitmap.RoaringBitmap;
 
 @BenchmarkMode(Mode.AverageTime)

File: jmh/src/main/java/org/roaringbitmap/runcontainer/RunArrayXorBenchmark.java
Patch:
@@ -13,7 +13,6 @@
 import org.openjdk.jmh.annotations.Scope;
 import org.openjdk.jmh.annotations.State;
 import org.roaringbitmap.Container;
-import org.roaringbitmap.FastAggregation;
 import org.roaringbitmap.RoaringBitmap;
 
 @BenchmarkMode(Mode.AverageTime)

File: jmh/src/main/java/org/roaringbitmap/runcontainer/RunContainerRealDataBenchmarkAnd.java
Patch:
@@ -86,7 +86,7 @@ public int pairwiseAnd_WAH(BenchmarkState benchmarkState) {
     public int pairwiseAnd_EWAH(BenchmarkState benchmarkState) {
         int total = 0;
         for(int k = 0; k + 1 < benchmarkState.ewah.size(); ++k)
-            total += EWAHCompressedBitmap.and(benchmarkState.ewah.get(k),benchmarkState.ewah.get(k+1)).cardinality();
+            total += benchmarkState.ewah.get(k).and(benchmarkState.ewah.get(k+1)).cardinality();
         if(total !=benchmarkState.totaland )
             throw new RuntimeException("bad pairwise and result");
         return total;
@@ -96,7 +96,7 @@ public int pairwiseAnd_EWAH(BenchmarkState benchmarkState) {
     public int pairwiseAnd_EWAH32(BenchmarkState benchmarkState) {
         int total = 0;
         for(int k = 0; k + 1 < benchmarkState.ewah32.size(); ++k)
-            total += EWAHCompressedBitmap32.and(benchmarkState.ewah32.get(k),benchmarkState.ewah32.get(k+1)).cardinality();
+            total += benchmarkState.ewah32.get(k).and(benchmarkState.ewah32.get(k+1)).cardinality();
         if(total !=benchmarkState.totaland )
             throw new RuntimeException("bad pairwise and result");
         return total;

File: jmh/src/main/java/org/roaringbitmap/runcontainer/RunContainerRealDataBenchmarkIterate.java
Patch:
@@ -18,7 +18,6 @@
 import org.roaringbitmap.FastAggregation;
 import org.roaringbitmap.RoaringBitmap;
 import org.roaringbitmap.ZipRealDataRetriever;
-import org.roaringbitmap.runcontainer.RunContainerRealDataBenchmarkAndNot.BenchmarkState;
 
 import com.googlecode.javaewah.EWAHCompressedBitmap;
 import com.googlecode.javaewah32.EWAHCompressedBitmap32;

File: jmh/src/main/java/org/roaringbitmap/runcontainer/RunContainerRealDataBenchmarkXor.java
Patch:
@@ -17,7 +17,6 @@
 import org.openjdk.jmh.annotations.State;
 import org.roaringbitmap.RoaringBitmap;
 import org.roaringbitmap.ZipRealDataRetriever;
-import org.roaringbitmap.runcontainer.RunContainerRealDataBenchmarkAndNot.BenchmarkState;
 
 import com.googlecode.javaewah.EWAHCompressedBitmap;
 import com.googlecode.javaewah32.EWAHCompressedBitmap32;

File: src/main/java/org/roaringbitmap/Util.java
Patch:
@@ -279,7 +279,7 @@ public static int unsignedDifference(ShortIterator set1, ShortIterator set2,
             if (toIntUnsigned(v1) < toIntUnsigned(v2)) {
                 buffer[pos++] = v1;
                 if (! set1.hasNext()) {
-                    break;
+                    return pos;
                 }
                 v1 = set1.next();
             } else if (v1 == v2) {
@@ -295,12 +295,12 @@ public static int unsignedDifference(ShortIterator set1, ShortIterator set2,
                 v2 = set2.next();
             } else {// if (val1>val2)
                 if (!set2.hasNext()) {
+                    buffer[pos++] = v1;
                     while(set1.hasNext())
                         buffer[pos++] = set1.next();
                     return pos;
                 }
-                v2 = set2.next();
-                
+                v2 = set2.next();                
             }
         }
         return pos;

File: src/main/java/org/roaringbitmap/buffer/MappeableContainer.java
Patch:
@@ -45,9 +45,6 @@ public static MappeableContainer rangeOfOnes(final int start, final int last) {
         MappeableContainer answer = new MappeableRunContainer();
         answer = answer.iadd(start, last);
         return answer;
-        /*if (last - start  > MappeableArrayContainer.DEFAULT_MAX_SIZE)
-            return new MappeableBitmapContainer(start, last);
-        return new MappeableArrayContainer(start, last);*/
     }
 
     /**

File: src/main/java/org/roaringbitmap/buffer/MappeableRunContainer.java
Patch:
@@ -1223,7 +1223,7 @@ public MappeableContainer iremove(int begin, int end) {
                     }
 
                 } else {
-                    if(valueLengthContains(end-1, eIndex)) {
+                    if(valueLengthContains(end, eIndex)) { // was end-1
                         initValueLength(end, eIndex);
                         recoverRoomsInRange(bIndex, eIndex - 1);
                     } else {

File: src/main/java/org/roaringbitmap/FastAggregation.java
Patch:
@@ -61,6 +61,7 @@ public static RoaringBitmap and(Iterator<RoaringBitmap> bitmaps) {
         ArrayList<RoaringBitmap> array = new ArrayList<RoaringBitmap>();
         while(bitmaps.hasNext())
             array.add(bitmaps.next());
+        if(array.size() == 1) return array.get(0);
         Collections.sort(array, new Comparator<RoaringBitmap>() {
             @Override
             public int compare(RoaringBitmap a, RoaringBitmap b) {

File: src/main/java/org/roaringbitmap/RoaringBitmap.java
Patch:
@@ -461,6 +461,7 @@ public void add(final int rangeStart, final int rangeEnd) {
      * @param rb initial bitmap (will not be modified)
      * @param rangeStart inclusive beginning of range
      * @param rangeEnd   exclusive ending of range
+     * @return the bitmap
      */
     public static RoaringBitmap add(RoaringBitmap rb, final int rangeStart, final int rangeEnd) {
         if (rangeStart >= rangeEnd)
@@ -561,6 +562,7 @@ public void remove(final int rangeStart, final int rangeEnd) {
      * @param rb initial bitmap (will not be modified)
      * @param rangeStart inclusive beginning of range
      * @param rangeEnd   exclusive ending of range
+     * @return the bitmap
      */
     public static RoaringBitmap remove(RoaringBitmap rb, final int rangeStart, final int rangeEnd) {
         if (rangeStart >= rangeEnd)

File: src/main/java/org/roaringbitmap/Util.java
Patch:
@@ -177,7 +177,7 @@ protected static int toIntUnsigned(short x) {
      * @param begin first index (inclusive)
      * @param end last index (exclusive)
      * @param k value we search for
-     * @return
+     * @return count
      */
     public static int unsignedBinarySearch(final short[] array, final int begin,
                                               final int end, final short k) {

File: src/main/java/org/roaringbitmap/buffer/MappeableContainer.java
Patch:
@@ -680,6 +680,8 @@ public MappeableContainer runOptimize() {
              return this;
          }
      }
+     
+     protected abstract boolean isArrayBacked();
 
      abstract int numberOfRuns();
 

File: src/main/java/org/roaringbitmap/buffer/MutableRoaringBitmap.java
Patch:
@@ -840,7 +840,7 @@ public void or(final ImmutableRoaringBitmap x2) {
                     s1 = highLowContainer.getKeyAtIndex(pos1);
                 } else { // s1 > s2
                     getMappeableRoaringArray().insertNewKeyValueAt(pos1, (short)s2,
-                            x2.highLowContainer.getContainerAtIndex(pos2));
+                            x2.highLowContainer.getContainerAtIndex(pos2).clone());
                     pos1++;
                     length1++;
                     pos2++;
@@ -1003,7 +1003,7 @@ public void xor(final ImmutableRoaringBitmap x2) {
                     s1 = highLowContainer.getKeyAtIndex(pos1);
                 } else { // s1 > s2
                     getMappeableRoaringArray().insertNewKeyValueAt(pos1, (short)s2,
-                            x2.highLowContainer.getContainerAtIndex(pos2));
+                            x2.highLowContainer.getContainerAtIndex(pos2).clone());
                     pos1++;
                     length1++;
                     pos2++;

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringArray.java
Patch:
@@ -87,7 +87,7 @@ public boolean equals(Object o) {
 
         if (o instanceof MutableRoaringArray) {
             final MutableRoaringArray srb = (MutableRoaringArray) o;
-            MappeableContainerPointer cp1 = srb.getContainerPointer();
+            MappeableContainerPointer cp1 = this.getContainerPointer();
             MappeableContainerPointer cp2 = srb.getContainerPointer();
             while (cp1.hasContainer()) {
                 if (!cp2.hasContainer())

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringArray.java
Patch:
@@ -87,7 +87,7 @@ public boolean equals(Object o) {
 
         if (o instanceof MutableRoaringArray) {
             final MutableRoaringArray srb = (MutableRoaringArray) o;
-            MappeableContainerPointer cp1 = srb.getContainerPointer();
+            MappeableContainerPointer cp1 = this.getContainerPointer();
             MappeableContainerPointer cp2 = srb.getContainerPointer();
             while (cp1.hasContainer()) {
                 if (!cp2.hasContainer())

File: jmh/src/main/java/org/roaringbitmap/runcontainer/ZipRealDataRetriever.java
Patch:
@@ -15,7 +15,7 @@
  * portable format (as lists of ints) inside a zip file
  * 
  * 
- * @author Daneil Lemire
+ * @author Daniel Lemire
  */
  public class ZipRealDataRetriever {
 

File: jmh/src/main/java/org/roaringbitmap/runcontainer/ZipRealDataRetriever.java
Patch:
@@ -12,7 +12,7 @@
 
 /**
  * This class will retrieve bitmaps that have been previously stored in a
- * portable format (as lists of ints) insize a zip file
+ * portable format (as lists of ints) inside a zip file
  * 
  * 
  * @author Daneil Lemire

File: src/main/java/org/roaringbitmap/Container.java
Patch:
@@ -683,7 +683,6 @@ else if (x instanceof BitmapContainer)
      public Container runOptimize() {
          // TODO: this code could possibly be faster when the initial container is a bitmap
          // TODO: should probably not convert if the container is a run container initially
-         // TODO: or maybe one would need to check that the run container is really appropriate
          int numRuns = 0; 
          ShortIterator sIt = getShortIterator();
          int previous = -2;
@@ -694,9 +693,10 @@ public Container runOptimize() {
              previous = val;
          }
          int sizeAsRunContainer = RunContainer.serializedSizeInBytes(numRuns);
-         if (serializedSizeInBytes() > sizeAsRunContainer)
+         if (getArraySizeInBytes() > sizeAsRunContainer) {
              return new RunContainer( getShortIterator(),  numRuns); // this could be maybe faster if initial container is a bitmap
-         else 
+         } else { 
              return this;
+         }
      }
 }

File: src/main/java/org/roaringbitmap/RoaringArray.java
Patch:
@@ -386,7 +386,6 @@ public int serializedSizeInBytes() {
         // the RunContainer exists, all else being equal, you will get different answers...is this ok?
         if (hasRunContainer())
             count += 4*((size+31)/32);
-        
         return count;
     }
 

File: src/main/java/org/roaringbitmap/buffer/MutableRoaringArray.java
Patch:
@@ -610,7 +610,7 @@ public int serializedSizeInBytes() {
             count += 4*((size+31)/32);
         return count;
     }
-
+    
     protected void setContainerAtIndex(int i, MappeableContainer c) {
         this.array[i].value = c;
     }

File: jmh/src/main/java/org/roaringbitmap/runcontainer/RunContainerRealDataBenchmark.java
Patch:
@@ -11,7 +11,6 @@
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.Mode;
 import org.openjdk.jmh.annotations.OutputTimeUnit;
-import org.openjdk.jmh.annotations.Param;
 import org.openjdk.jmh.annotations.Scope;
 import org.openjdk.jmh.annotations.State;
 import org.roaringbitmap.FastAggregation;

File: src/main/java/org/roaringbitmap/buffer/BufferUtil.java
Patch:
@@ -221,7 +221,7 @@ protected static void fillArrayXOR(short[] container, LongBuffer bitmap1,
     
     protected static int getSizeInBytesFromCardinalityEtc(int card, int numRuns, boolean isRunEncoded) {
         if (isRunEncoded)
-            return numRuns * 2 * 2;  // each run uses 2 shorts
+            return 2 + numRuns * 2 * 2;  // each run uses 2 shorts, plus the initial short giving num runs
         boolean isBitmap = card > MappeableArrayContainer.DEFAULT_MAX_SIZE;
         if (isBitmap)
             return MappeableBitmapContainer.MAX_CAPACITY / 8;

File: src/test/java/org/roaringbitmap/buffer/TestRoaringBitmap.java
Patch:
@@ -49,6 +49,7 @@ public void testCheckedRemove() {
 		// when adding new ints
 		for (int i = 0; i < 2 * (1 << 16); i++)
 			rb.add(i);
+
 		for (int i = 0; i < 2 * (1 << 16); i += 2)
 			Assert.assertTrue(rb.checkedRemove(i));
 		for (int i = 0; i < 2 * (1 << 16); i += 2)
@@ -252,6 +253,7 @@ public void ANDNOTtest() {
         for (int k = 10 * 65535; k < 10 * 65535 + 5000; ++k) {
             rr2.add(k);
         }
+
         final MutableRoaringBitmap correct = MutableRoaringBitmap.andNot(rr, rr2);
         rr.andNot(rr2);
         Assert.assertTrue(correct.equals(rr));

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringArray.java
Patch:
@@ -233,7 +233,7 @@ public int advanceUntil(short x, int pos) {
 
         // maybe we are lucky (could be common case when the seek ahead
         // expected to be small and sequential will otherwise make us look bad)
-        if (getKey(upper) == x) {
+        if (getKey(upper) == BufferUtil.toIntUnsigned(x)) {
             return upper;
         }
 

File: src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -29,7 +29,7 @@ private RunContainer(int nbrruns, short[] valueslength) {
     
     // needed for deserialization
     public RunContainer(short [] valueslength) {
-        this(valueslength.length, valueslength);
+        this(valueslength.length/2, valueslength);
     }
 
     // lower-level specialized implementations might be faster

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringBitmap.java
Patch:
@@ -66,8 +66,8 @@ public static MutableRoaringBitmap and(final ImmutableRoaringBitmap x1,
         final int length1 = x1.highLowContainer.size(), length2 = x2.highLowContainer.size();
 
         while (pos1 < length1 && pos2 < length2) {
-            int s1 = BufferUtil.toIntUnsigned(x1.highLowContainer.getKeyAtIndex(pos1));
-            int s2 = BufferUtil.toIntUnsigned(x2.highLowContainer.getKeyAtIndex(pos2));
+            final int s1 = BufferUtil.toIntUnsigned(x1.highLowContainer.getKeyAtIndex(pos1));
+            final int s2 = BufferUtil.toIntUnsigned(x2.highLowContainer.getKeyAtIndex(pos2));
 
             if (s1 == s2) {
                 final MappeableContainer c1 = x1.highLowContainer.getContainerAtIndex(pos1);

File: src/main/java/org/roaringbitmap/buffer/PointableRoaringArray.java
Patch:
@@ -70,7 +70,7 @@ public interface PointableRoaringArray extends Cloneable {
      * @return the smallest index greater than pos such that getKeyAtIndex(index) is at least as large
      * as min, or size if it is not possible.
      */
-    int advanceUntil(short x, int pos);
+    int advanceUntil(int x, int pos);
 
     /**
      * @return number of keys

File: jmh/src/main/java/org/roaringbitmap/buffer/aggregation/and/identical/MutableRoaringBitmapBenchmark.java
Patch:
@@ -1,7 +1,6 @@
 package org.roaringbitmap.buffer.aggregation.and.identical;
 
 import org.openjdk.jmh.annotations.*;
-import org.roaringbitmap.RoaringBitmap;
 import org.roaringbitmap.buffer.MutableRoaringBitmap;
 
 import java.util.concurrent.TimeUnit;

File: jmh/src/main/java/org/roaringbitmap/buffer/aggregation/and/worstcase/MutableRoaringBitmapBenchmark.java
Patch:
@@ -1,7 +1,6 @@
 package org.roaringbitmap.buffer.aggregation.and.worstcase;
 
 import org.openjdk.jmh.annotations.*;
-import org.roaringbitmap.RoaringBitmap;
 import org.roaringbitmap.buffer.MutableRoaringBitmap;
 
 import java.util.concurrent.TimeUnit;

File: jmh/src/main/java/org/roaringbitmap/buffer/aggregation/andnot/bestcase/MutableRoaringBitmapBenchmark.java
Patch:
@@ -1,7 +1,6 @@
 package org.roaringbitmap.buffer.aggregation.andnot.bestcase;
 
 import org.openjdk.jmh.annotations.*;
-import org.roaringbitmap.RoaringBitmap;
 import org.roaringbitmap.buffer.MutableRoaringBitmap;
 
 import java.util.concurrent.TimeUnit;

File: jmh/src/main/java/org/roaringbitmap/buffer/aggregation/andnot/identical/MutableRoaringBitmapBenchmark.java
Patch:
@@ -1,7 +1,6 @@
 package org.roaringbitmap.buffer.aggregation.andnot.identical;
 
 import org.openjdk.jmh.annotations.*;
-import org.roaringbitmap.RoaringBitmap;
 import org.roaringbitmap.buffer.MutableRoaringBitmap;
 
 import java.util.concurrent.TimeUnit;

File: src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -805,7 +805,7 @@ public Container iadd(int begin, int end) {
     public Container iremove(int begin, int end) {
        Util.resetBitmapRange(bitmap,begin,end);
        computeCardinality(); 
-       if(getCardinality() < ArrayContainer.DEFAULT_MAX_SIZE)
+       if(getCardinality() <= ArrayContainer.DEFAULT_MAX_SIZE)
            return toArrayContainer();
        return this;
     }
@@ -841,7 +841,7 @@ public Container remove(int begin, int end) {
         BitmapContainer answer = clone();
         Util.resetBitmapRange(answer.bitmap, begin, end);
         answer.computeCardinality(); 
-        if (answer.getCardinality() < ArrayContainer.DEFAULT_MAX_SIZE)
+        if (answer.getCardinality() <= ArrayContainer.DEFAULT_MAX_SIZE)
             return answer.toArrayContainer();
         return answer;
     }

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringArray.java
Patch:
@@ -7,7 +7,6 @@
 
 import java.io.DataOutput;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;

File: src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -1166,7 +1166,7 @@ private Container operationArrayGuess(RunContainer x, int opcode) {
         // hoping that iterator overhead can be largely optimized away, dunno...
 
         ShortIterator it = getShortIterator();  // rely on unsigned ordering
-        ShortIterator xIt = getShortIterator();
+        ShortIterator xIt = x.getShortIterator();
         
         thisHead = (it.hasNext() ?  Util.toIntUnsigned(it.next()) : -1);
         xHead =  (xIt.hasNext() ?  Util.toIntUnsigned(xIt.next()) : -1);
@@ -1239,7 +1239,7 @@ private Container operationBitmapGuess(RunContainer x, int opcode) {
         int thisHead, xHead; // -1 means end of run
         
         ShortIterator it = getShortIterator();  
-        ShortIterator xIt = getShortIterator();
+        ShortIterator xIt = x.getShortIterator();
         
         thisHead = (it.hasNext() ?  Util.toIntUnsigned(it.next()) : -1);
         xHead =  (xIt.hasNext() ?  Util.toIntUnsigned(xIt.next()) : -1);

File: src/main/java/org/roaringbitmap/Container.java
Patch:
@@ -156,7 +156,7 @@ else if (x instanceof BitmapContainer)
 
     /**
      * Fill the least significant 16 bits of the integer array, starting at
-     * index index, with the short values from this container. The caller is
+     * index i, with the short values from this container. The caller is
      * responsible to allocate enough room. The most significant 16 bits of
      * each integer are given by the most significant bits of the provided
      * mask.

File: src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -285,11 +285,10 @@ public void deserialize(DataInput in) throws IOException {
 
     @Override
     public void fillLeastSignificant16bits(int[] x, int i, int mask) {
-        int pos = 0;
+        int pos = i;
         for (int k = 0; k < this.nbrruns; ++k) {
             for(int le = 0; le <= Util.toIntUnsigned(this.getLength(k)); ++le) {
-              x[k + pos] = (Util.toIntUnsigned(this.getValue(k)) + le) | mask;
-              pos++;
+              x[pos++] = (Util.toIntUnsigned(this.getValue(k)) + le) | mask;
             }
         }
     }

File: src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -34,7 +34,7 @@ public BitmapContainer() {
 
     /**
      * Create a bitmap container with a run of ones from firstOfRun to
-     * lastOfRun, inclusive caller must ensure that the range isn't so small
+     * lastOfRun.  Caller must ensure that the range isn't so small
      * that an ArrayContainer should have been created instead
      *
      * @param firstOfRun first index

File: src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -340,7 +340,7 @@ public Container or(BitmapContainer x) {
         for(int rlepos = 0; rlepos < this.nbrruns; ++rlepos ) {
             int start = Util.toIntUnsigned(this.getValue(rlepos));
             int end = Util.toIntUnsigned(this.getValue(rlepos)) + Util.toIntUnsigned(this.getLength(rlepos)) + 1;
-            Util.setBitmapRange(x.bitmap, start, end);
+            Util.setBitmapRange(answer.bitmap, start, end);
         }
         answer.computeCardinality();
         return answer;

File: src/main/java/org/roaringbitmap/RunContainer.java
Patch:
@@ -115,8 +115,8 @@ public Container add(short k) {
                 if(index + 1 < nbrruns) {
                     if(Util.toIntUnsigned(getValue(index + 1))  == Util.toIntUnsigned(k) + 1) {
                         // indeed fusion is needed
-                        recoverRoomAtIndex(index + 1);
                         setLength(index, (short) (getValue(index + 1) + getLength(index + 1) - getValue(index)));
+                        recoverRoomAtIndex(index + 1);
                         return this;
                     }
                 }
@@ -135,8 +135,8 @@ public Container add(short k) {
             }
         }
         makeRoomAtIndex(index + 1);
-        setValue(index + 1, (short) k);
-        setLength(index+1,(short)0);
+        setValue(index + 1, k);
+        setLength(index + 1,(short)0);
         return this;
     }
 

File: jmh/src/main/java/org/roaringbitmap/serialization/SerializationBenchmark.java
Patch:
@@ -1,4 +1,4 @@
-package org.roaringbitmap.iteration;
+package org.roaringbitmap.serialization;
 
 import org.openjdk.jmh.annotations.*;
 import org.roaringbitmap.RoaringBitmap;

File: jmh/src/main/java/org/roaringbitmap/serialization/SerializationBenchmark.java
Patch:
@@ -1,4 +1,4 @@
-package org.roaringbitmap.iteration;
+package org.roaringbitmap.serialization;
 
 import org.openjdk.jmh.annotations.*;
 import org.roaringbitmap.RoaringBitmap;

File: src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -855,9 +855,7 @@ public Container flip(short i) {
               return this.toArrayContainer();
           } 
       }
-
       cardinality +=  1 - 2 * ( (bitmap[x / 64] & (1l << x)) >>> x ) ;
-      
       bitmap[x / 64] ^= (1l << x);      
       return this;
 		}

File: src/main/java/org/roaringbitmap/buffer/MappeableContainer.java
Patch:
@@ -24,7 +24,7 @@ public abstract class MappeableContainer implements Iterable<Short>, Cloneable,
      * @param start
      *            first index
      * @param last
-     *            last index (range in exclusive)
+     *            last index (range is exclusive)
      * @return a new container initialized with the specified values
      */
     public static MappeableContainer rangeOfOnes(final int start, final int last) {

File: src/test/java/org/roaringbitmap/TestRoaringBitmap.java
Patch:
@@ -5,7 +5,6 @@
 package org.roaringbitmap;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
 
 import org.junit.Assert;
 import org.junit.Test;

File: src/test/java/org/roaringbitmap/buffer/TestExamples.java
Patch:
@@ -32,7 +32,7 @@ public  void serializationExample() throws IOException {
         ByteBuffer bb = memoryMappedFile.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, totalcount);
         ImmutableRoaringBitmap mapped = new ImmutableRoaringBitmap(bb);
         System.out.println("Mapped the bitmap "+mapped);
-        if(!mapped.equals(Bitmap)) throw new RuntimeException("This will not happen");
         memoryMappedFile.close();
+        if(!mapped.equals(Bitmap)) throw new RuntimeException("This will not happen");
     }
 }

File: src/main/java/org/roaringbitmap/Container.java
Patch:
@@ -378,7 +378,7 @@ protected Container lazyIOR(Container x) {
      * @param rangeStart beginning of range (inclusive); 0 is beginning of this
      *                   container.
      * @param rangeEnd   ending of range (exclusive)
-     * @return (partially) completmented container
+     * @return (partially) complemented container
      */
     public abstract Container not(int rangeStart, int rangeEnd);
 

File: src/main/java/org/roaringbitmap/buffer/MappeableBitmapContainer.java
Patch:
@@ -442,11 +442,10 @@ public MappeableContainer iandNot(final MappeableBitmapContainer b2) {
         return ac;
     }
 
-    // complicated so that it should be reasonably efficient even when the
-    // ranges are small
+
     @Override
     public MappeableContainer inot(final int firstOfRange, final int lastOfRange) {
-        return not(this, firstOfRange, lastOfRange);
+        return not(this, firstOfRange, lastOfRange); 
     }
 
     @Override

File: src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -801,7 +801,7 @@ public Container limit(int maxcardinality) {
         if(maxcardinality >= this.cardinality) {
             return clone();
         } 
-        if(maxcardinality < ArrayContainer.DEFAULT_MAX_SIZE) {
+        if(maxcardinality <= ArrayContainer.DEFAULT_MAX_SIZE) {
             ArrayContainer ac = new ArrayContainer(maxcardinality);
             int pos = 0;
             for (int k = 0; (ac.cardinality <maxcardinality) && (k < bitmap.length); ++k) {

File: src/main/java/org/roaringbitmap/buffer/MappeableBitmapContainer.java
Patch:
@@ -1087,7 +1087,7 @@ public MappeableContainer limit(int maxcardinality) {
         if(maxcardinality >= this.cardinality) {
             return clone();
         } 
-        if(maxcardinality < MappeableArrayContainer.DEFAULT_MAX_SIZE) {
+        if(maxcardinality <= MappeableArrayContainer.DEFAULT_MAX_SIZE) {
             MappeableArrayContainer ac = new MappeableArrayContainer(maxcardinality);
             int pos = 0;
             short[] cont = ac.content.array();

File: src/main/java/org/roaringbitmap/BitmapContainer.java
Patch:
@@ -801,7 +801,7 @@ public Container limit(int maxcardinality) {
         if(maxcardinality >= this.cardinality) {
             return clone();
         } 
-        if(maxcardinality <= MAX_CAPACITY) {
+        if(maxcardinality < ArrayContainer.DEFAULT_MAX_SIZE) {
             ArrayContainer ac = new ArrayContainer(maxcardinality);
             int pos = 0;
             for (int k = 0; (ac.cardinality <maxcardinality) && (k < bitmap.length); ++k) {

File: src/main/java/org/roaringbitmap/buffer/MappeableBitmapContainer.java
Patch:
@@ -1087,7 +1087,7 @@ public MappeableContainer limit(int maxcardinality) {
         if(maxcardinality >= this.cardinality) {
             return clone();
         } 
-        if(maxcardinality <= MAX_CAPACITY) {
+        if(maxcardinality < MappeableArrayContainer.DEFAULT_MAX_SIZE) {
             MappeableArrayContainer ac = new MappeableArrayContainer(maxcardinality);
             int pos = 0;
             short[] cont = ac.content.array();

File: jmh/src/main/java/org/roaringbitmap/BasicBenchmark.java
Patch:
@@ -12,7 +12,7 @@
 import java.util.concurrent.TimeUnit;
 
 /**
- * Created by bobby on 4/2/15.
+ * Created by Borislav Ivanov on 4/2/15.
  */
 @BenchmarkMode(Mode.Throughput)
 @OutputTimeUnit(TimeUnit.SECONDS)

File: jmh/src/main/java/org/roaringbitmap/iteration/IteratorsBenchmark.java
Patch:
@@ -10,6 +10,9 @@
 import java.util.Random;
 import java.util.concurrent.TimeUnit;
 
+/**
+ * Created by Borislav Ivanov on 4/2/15.
+ */
 @BenchmarkMode(Mode.Throughput)
 @OutputTimeUnit(TimeUnit.SECONDS)
 public class IteratorsBenchmark {

File: src/main/java/org/roaringbitmap/ReverseIntIteratorFlyweight.java
Patch:
@@ -48,7 +48,7 @@ public ReverseIntIteratorFlyweight(RoaringBitmap r) {
  
    /**
     * Prepares a bitmap for iteration
-    * @param r
+    * @param r  bitmap to be iterated over
     */
    public void wrap(RoaringBitmap r) {
       this.roaringBitmap = r;

File: src/main/java/org/roaringbitmap/buffer/BufferReverseIntIteratorFlyweight.java
Patch:
@@ -51,7 +51,7 @@ public BufferReverseIntIteratorFlyweight(ImmutableRoaringBitmap r) {
  
    /**
     * Prepares a bitmap for iteration
-    * @param r
+    * @param r bitmap to be iterated over
     */
    public void wrap(ImmutableRoaringBitmap r) {
       this.roaringBitmap = r;

File: src/main/java/org/roaringbitmap/buffer/PointableRoaringArray.java
Patch:
@@ -42,6 +42,7 @@ public interface PointableRoaringArray extends Cloneable {
     MappeableContainerPointer getContainerPointer();
 
     /**
+     * @param startIndex starting index
      * @return a ContainerPointer to iterator over the array initially positioned at startIndex
      */
     MappeableContainerPointer getContainerPointer(int startIndex);

File: src/test/java/org/roaringbitmap/TestBenchmarkIterator.java
Patch:
@@ -49,6 +49,8 @@ public static void prepare() throws IOException {
         final Random source = new Random(0xcb000a2b9b5bdfb6l);
         final int[] data = takeSortedAndDistinct(source, 1000000);
         bitmap = RoaringBitmap.bitmapOf(data);
+        intIterator = new IntIteratorFlyweight();
+        
     }
 
     private static int[] takeSortedAndDistinct(Random source, int count) {

File: src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -308,7 +308,7 @@ public ArrayContainer iandNot(BitmapContainer value2) {
     }
 
     private void increaseCapacity() {
-        int newCapacity = this.content.length < 64 ? this.content.length * 2
+        int newCapacity = (this.content.length == 0) ? DEFAULT_INIT_SIZE : this.content.length < 64 ? this.content.length * 2
                 : this.content.length < 1024 ? this.content.length * 3 / 2
                 : this.content.length * 5 / 4;
         if (newCapacity > ArrayContainer.DEFAULT_MAX_SIZE)

File: src/main/java/org/roaringbitmap/buffer/MappeableArrayContainer.java
Patch:
@@ -398,7 +398,7 @@ public MappeableArrayContainer iandNot(MappeableBitmapContainer value2) {
     }
 
     private void increaseCapacity() {
-        int newCapacity = this.content.limit() < 64 ? this.content.limit() * 2
+        int newCapacity = (this.content.limit() == 0) ? DEFAULT_INIT_SIZE : this.content.limit() < 64 ? this.content.limit() * 2
                 : this.content.limit() < 1024 ? this.content.limit() * 3 / 2
                         : this.content.limit() * 5 / 4;
         if (newCapacity > MappeableArrayContainer.DEFAULT_MAX_SIZE)

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringArray.java
Patch:
@@ -230,7 +230,7 @@ public int hashCode() {
      */
     public void serialize(DataOutput out) throws IOException {
         if(buffer.hasArray()) {
-            out.write(buffer.array());
+            out.write(buffer.array(), buffer.arrayOffset(), buffer.limit());
         } else {
             ByteBuffer tmp = buffer.duplicate();
             tmp.position(0);

File: src/main/java/org/roaringbitmap/buffer/MappeableBitmapContainer.java
Patch:
@@ -425,7 +425,7 @@ public int hashCode() {
         long hash = 0;
         for (int k = 0; k < this.bitmap.limit(); ++k)
             hash += 31 * hash + this.bitmap.get(k);
-        return (int) (hash >> 32);
+        return (int) hash;
     }
 
     @Override

File: src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -266,7 +266,7 @@ public int getSizeInBytes() {
     public int hashCode() {
         int hash = 0;
         for (int k = 0; k < cardinality; ++k)
-            hash += 31 * content[k];
+            hash += 31 * hash + content[k];
         return hash;
     }
 

File: src/main/java/org/roaringbitmap/buffer/MappeableArrayContainer.java
Patch:
@@ -348,7 +348,7 @@ public int getSizeInBytes() {
     public int hashCode() {
         int hash = 0;
         for (int k = 0; k < cardinality; ++k)
-            hash += 31 * content.get(k);
+            hash += 31 * hash + content.get(k);
         return hash;
     }
 

File: src/main/java/org/roaringbitmap/buffer/MappeableBitmapContainer.java
Patch:
@@ -424,7 +424,7 @@ public int getSizeInBytes() {
     public int hashCode() {
         long hash = 0;
         for (int k = 0; k < this.bitmap.limit(); ++k)
-            hash += 31 * this.bitmap.get(k);
+            hash += 31 * hash + this.bitmap.get(k);
         return (int) (hash >> 32);
     }
 

File: src/main/java/org/roaringbitmap/Util.java
Patch:
@@ -165,7 +165,7 @@ protected static int unsignedBinarySearch(final short[] array, final int begin,
                                               final int end, final short k) {
         int ikey = toIntUnsigned(k);
         // next line accelerates the possibly common case where the value would be inserted at the end
-        if((end>0) && (toIntUnsigned(array[end-1]) < ikey)) return -end;
+        if((end>0) && (toIntUnsigned(array[end-1]) < ikey)) return - end - 1;
         int low = begin;
         int high = end - 1;
         while (low <= high) {

File: src/main/java/org/roaringbitmap/buffer/BufferUtil.java
Patch:
@@ -160,7 +160,7 @@ protected static int unsignedBinarySearch(final ShortBuffer array, final int beg
             final int end, final short k) {
         final int ikey = toIntUnsigned(k);
         // next line accelerates the possibly common case where the value would be inserted at the end
-        if((end>0) && (toIntUnsigned(array.get(end-1)) < ikey)) return -end;
+        if((end>0) && (toIntUnsigned(array.get(end-1)) < ikey)) return - end - 1;
         int low = begin;
         int high = end - 1;
         while (low <= high) {

File: examples/SerializeToByteBufferExample.java
Patch:
@@ -22,8 +22,8 @@ public void close() {}
             public void flush() {}
             public void write(int b) {
                 mBB.put((byte) b);}
-            public void write(byte[] b) {}            
-            public void write(byte[] b, int off, int l) {}
+            public void write(byte[] b) {mBB.put(b);}            
+            public void write(byte[] b, int off, int l) {mBB.put(b,off,l);}
         }.init(outbb)));
         //
         outbb.flip();

File: src/main/java/org/roaringbitmap/buffer/MutableRoaringArray.java
Patch:
@@ -277,6 +277,9 @@ public void deserialize(DataInput in) throws IOException {
             cardinalities[k] = 1 + (buffer[0] & 0xFF | ((buffer[1] & 0xFF) << 8));
             isBitmap[k] = cardinalities[k] > MappeableArrayContainer.DEFAULT_MAX_SIZE;
         }
+        //skipping the offsets
+        in.skipBytes(this.size*4);
+        //Reading the containers
         for (int k = 0; k < this.size; ++k) {
             MappeableContainer val;
             if (isBitmap[k]) {

File: src/main/java/org/roaringbitmap/RoaringArray.java
Patch:
@@ -266,7 +266,7 @@ public void serialize(DataOutput out) throws IOException {
             out.write(((this.array[k].value.getCardinality() - 1) >>> 8) & 0xFF);
         }
         //writing the containers offsets
-        int startOffset = 4 + 4 + (1 << (2 << this.size));
+        int startOffset = 4 + 4 + 4*this.size + 4*this.size;
         for(int k=0; k<this.size; k++){
         	out.write(startOffset & 0xFF);
             out.write((startOffset >>> 8) & 0xFF);

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringArray.java
Patch:
@@ -56,8 +56,8 @@ protected ImmutableRoaringArray(ByteBuffer bbf) {
     }
 
     public long bufferMemoryUsage(){
-        long buffer = RamUsageEstimator.sizeOf(this.buffer);
-        return buffer;
+        long size = RamUsageEstimator.sizeOf(this.buffer);
+        return size;
     }
 
     public ImmutableRoaringArray clone() {

File: src/main/java/org/roaringbitmap/buffer/MutableRoaringArray.java
Patch:
@@ -502,8 +502,8 @@ public void serialize(DataOutput out) throws IOException {
             out.write((this.array[k].value.getCardinality() - 1) & 0xFF);
             out.write(((this.array[k].value.getCardinality() - 1) >>> 8) & 0xFF);
         }
-        //writing the containers offsets
-        int startOffset = 4 + 4 + (1 << (2 << this.size));
+        //writing the containers offset
+        int startOffset = 4 + 4 + this.size*4 + this.size*4;
         for(int k=0; k<this.size; k++){
         	out.write(startOffset & 0xFF);
             out.write((startOffset >>> 8) & 0xFF);
@@ -522,7 +522,7 @@ public void serialize(DataOutput out) throws IOException {
      * @return the size in bytes
      */
     public int serializedSizeInBytes() {
-        int count = 4 + 4 + (1 << (2 << this.size));
+        int count = 4 + 4 + 4*this.size + 4*this.size;
         for (int k = 0; k < this.size; ++k) {
             count += array[k].value.getArraySizeInBytes();
         }

File: src/test/java/org/roaringbitmap/buffer/TestMemoryMapping.java
Patch:
@@ -182,7 +182,7 @@ public static void initFiles() throws IOException {
                     rb2.serialize(dos);
                     long paft = fos.getChannel().position();
                     if(paft - pbef != rb2.serializedSizeInBytes()) {
-                        throw new RuntimeException("wrong serializedSizeInBytes");
+                        throw new RuntimeException("wrong serializedSizeInBytes:: paft-pbef = "+(paft - pbef)+", serializedSize = "+rb2.serializedSizeInBytes());
                     }
                     dos.flush();
                     rambitmaps.add(rb2);

File: src/main/java/org/roaringbitmap/buffer/MutableRoaringArray.java
Patch:
@@ -509,7 +509,7 @@ public void serialize(DataOutput out) throws IOException {
             out.write((startOffset >>> 8) & 0xFF);
             out.write((startOffset >>> 16) & 0xFF);
             out.write((startOffset >>> 24) & 0xFF);
-        	startOffset=startOffset+BufferUtil.getSizeInBytesFromCardinality(this.array[k].value.getCardinality());
+        	startOffset=startOffset+array[k].value.getArraySizeInBytes();
         }
         for (int k = 0; k < size; ++k) {
             array[k].value.writeArray(out);

File: src/main/java/org/roaringbitmap/buffer/MutableRoaringArray.java
Patch:
@@ -519,7 +519,7 @@ public void serialize(DataOutput out) throws IOException {
      * @return the size in bytes
      */
     public int serializedSizeInBytes() {
-        int count = 4 + 4 + 4 * size;
+        int count = 4 + 4 + 1 << (2 << size);
         for (int k = 0; k < size; ++k) {
             count += array[k].value.getArraySizeInBytes();
         }

File: src/main/java/org/roaringbitmap/RoaringArray.java
Patch:
@@ -7,7 +7,6 @@
 
 import java.io.*;
 import java.util.Arrays;
-import java.util.Iterator;
 
 
 /**

File: src/main/java/org/roaringbitmap/buffer/ImmutableRoaringArray.java
Patch:
@@ -152,15 +152,15 @@ public MappeableContainer getContainerAtIndex(int i) {
 	}
 
 	// involves a binary search
-	protected int getIndex(short x) {
+	public int getIndex(short x) {
 		return  unsignedBinarySearch(keys, 0, keys.length, x);
 	}
 
-	protected short getKeyAtIndex(int i) {
+	public short getKeyAtIndex(int i) {
 		return this.keys[i];
 	}
 
-	protected int size() {
+	public int size() {
 		return this.keys.length;
 	}
 

File: src/main/java/org/roaringbitmap/buffer/PointableArray.java
Patch:
@@ -6,4 +6,7 @@ public interface PointableArray extends Cloneable {
 	MappeableContainer getContainerAtIndex(int i); 
 	
 	PointableArray clone();
+	int getIndex(short x);
+	int size();
+	short getKeyAtIndex(int i);
 }

File: src/test/java/org/roaringbitmap/buffer/TestRoaringBitmap.java
Patch:
@@ -1055,7 +1055,7 @@ public void removeSpeedyArrayTest() {
             rb.add(i);
 
         for (int i = 10000; i > 0; i++) {
-            rb.highLowContainer.remove(BufferUtil.highbits(i));
+        	rb.getMappeableRoaringArray().remove(BufferUtil.highbits(i));
             Assert.assertEquals(rb.contains(i), false);
         }
 

File: src/main/java/org/roaringbitmap/buffer/BufferFastAggregation.java
Patch:
@@ -33,7 +33,7 @@ public static MappeableRoaringBitmap and(ImmutableRoaringBitmap... bitmaps) {
         if (bitmaps.length == 0)
           return new MappeableRoaringBitmap();
         else if(bitmaps.length == 1)
-    	  return bitmaps[0].clone();
+    	  return bitmaps[0].toMappeableRoaringBitmap();
         final ImmutableRoaringBitmap[] array = Arrays.copyOf(bitmaps, bitmaps.length);
         Arrays.sort(array, new Comparator<ImmutableRoaringBitmap>() {
             @Override

File: src/main/java/org/roaringbitmap/RoaringArray.java
Patch:
@@ -11,7 +11,8 @@
 
 
 /**
- * Specialized array to stored the containers used by a RoaringBitmap.
+ * Specialized array to store the containers used by a RoaringBitmap.
+ * This is not meant to be used by end users.
  */
 public final class RoaringArray implements Cloneable, Externalizable {
     protected static final short SERIAL_COOKIE = 12345;

File: src/main/java/org/roaringbitmap/buffer/MappeableRoaringArray.java
Patch:
@@ -13,9 +13,9 @@
 import java.util.Iterator;
 
 /**
- * Specialized array to stored the containers used by a RoaringBitmap. This
+ * Specialized array to store the containers used by a RoaringBitmap. This
  * class is similar to org.roaringbitmap.RoaringArray but meant to be used with
- * memory mapping.
+ * memory mapping.  This is not meant to be used by end users.
  * 
  * Objects of this class reside in RAM.
  */

File: src/main/java/org/roaringbitmap/FastAggregation.java
Patch:
@@ -100,7 +100,7 @@ public static RoaringBitmap horizontal_or(RoaringBitmap... bitmaps) {
         	}
         	ContainerPointer x2 = pq.poll();       	
         	Container newc = x1.getContainer().or(x2.getContainer());
-        	while(pq.peek().key() == x1.key()) {
+        	while(!pq.isEmpty() && (pq.peek().key() == x1.key())) {
 
         		ContainerPointer x = pq.poll();       	
             	newc = newc.ior(x.getContainer());
@@ -174,7 +174,7 @@ public static RoaringBitmap horizontal_xor(RoaringBitmap... bitmaps) {
         	}
         	ContainerPointer x2 = pq.poll();       	
         	Container newc = x1.getContainer().xor(x2.getContainer());
-        	while(pq.peek().key() == x1.key()) {
+        	while(!pq.isEmpty() && (pq.peek().key() == x1.key())) {
         		ContainerPointer x = pq.poll();       	
         		newc = newc.ixor(x.getContainer());
         		x.advance();

File: src/main/java/org/roaringbitmap/buffer/BufferFastAggregation.java
Patch:
@@ -104,7 +104,7 @@ public static MappeableRoaringBitmap horizontal_or(ImmutableRoaringBitmap... bit
         	}
         	MappeableContainerPointer x2 = pq.poll();       	
         	MappeableContainer newc = x1.getContainer().or(x2.getContainer());
-        	while(pq.peek().key() == x1.key()) {
+        	while(!pq.isEmpty() && (pq.peek().key() == x1.key())) {
 
         		MappeableContainerPointer x = pq.poll();       	
             	newc = newc.ior(x.getContainer());
@@ -182,7 +182,7 @@ public static MappeableRoaringBitmap horizontal_xor(ImmutableRoaringBitmap... bi
         	}
         	MappeableContainerPointer x2 = pq.poll();       	
         	MappeableContainer newc = x1.getContainer().xor(x2.getContainer());
-        	while(pq.peek().key() == x1.key()) {
+        	while(!pq.isEmpty() && (pq.peek().key() == x1.key())) {
 
         		MappeableContainerPointer x = pq.poll();       	
             	newc = newc.ixor(x.getContainer());

File: src/main/java/org/roaringbitmap/RoaringArray.java
Patch:
@@ -299,15 +299,15 @@ public void deserialize(DataInput in) throws IOException {
         final byte[] buffer = new byte[2];
         // little endian
         in.readFully(buffer4);
-        final int cookie = buffer4[0] | ((buffer4[1] & 0xFF) << 8)
+        final int cookie = (buffer4[0] & 0xFF) | ((buffer4[1] & 0xFF) << 8)
                 | ((buffer4[2] & 0xFF) << 16)
                 | ((buffer4[3] & 0xFF) << 24);
         if (cookie != serialCookie)
             throw new IOException(
                     "I failed to find the right cookie.");
 
         in.readFully(buffer4);
-        this.size = buffer4[0] | ((buffer4[1] & 0xFF) << 8)
+        this.size = (buffer4[0] & 0xFF) | ((buffer4[1] & 0xFF) << 8)
                 | ((buffer4[2] & 0xFF) << 16)
                 | ((buffer4[3] & 0xFF) << 24);
         if ((this.array == null) || (this.array.length < this.size))

File: src/main/java/org/roaringbitmap/RoaringArray.java
Patch:
@@ -299,15 +299,15 @@ public void deserialize(DataInput in) throws IOException {
         final byte[] buffer = new byte[2];
         // little endian
         in.readFully(buffer4);
-        final int cookie = buffer4[0] | ((buffer4[1] & 0xFF) << 8)
+        final int cookie = (buffer4[0] & 0xFF) | ((buffer4[1] & 0xFF) << 8)
                 | ((buffer4[2] & 0xFF) << 16)
                 | ((buffer4[3] & 0xFF) << 24);
         if (cookie != serialCookie)
             throw new IOException(
                     "I failed to find the right cookie.");
 
         in.readFully(buffer4);
-        this.size = buffer4[0] | ((buffer4[1] & 0xFF) << 8)
+        this.size = (buffer4[0] & 0xFF) | ((buffer4[1] & 0xFF) << 8)
                 | ((buffer4[2] & 0xFF) << 16)
                 | ((buffer4[3] & 0xFF) << 24);
         if ((this.array == null) || (this.array.length < this.size))

File: src/main/java/org/roaringbitmap/IntIterator.java
Patch:
@@ -12,15 +12,15 @@ public interface IntIterator {
         /**
          * @return whether there is another value
          */
-        public boolean hasNext();
+        boolean hasNext();
 
         /**
          * @return next integer value
          */
-        public int next();
+        int next();
 
         /**
          * remove current value
          */
-        public void remove();
+        void remove();
 }

File: src/main/java/org/roaringbitmap/buffer/RoaringBitmap.java
Patch:
@@ -537,9 +537,7 @@ public RoaringBitmap clone() {
                         x.highlowcontainer = highlowcontainer.clone();
                         return x;
                 } catch (final CloneNotSupportedException e) {
-                        e.printStackTrace();
-                        throw new RuntimeException(
-                                "shouldn't happen with clone");
+                        throw new RuntimeException("shouldn't happen with clone",e);
                 }
         }
 

File: src/main/java/org/roaringbitmap/IntIterator.java
Patch:
@@ -12,15 +12,15 @@ public interface IntIterator {
         /**
          * @return whether there is another value
          */
-        public boolean hasNext();
+        boolean hasNext();
 
         /**
          * @return next integer value
          */
-        public int next();
+        int next();
 
         /**
          * remove current value
          */
-        public void remove();
+        void remove();
 }

File: src/main/java/org/roaringbitmap/buffer/RoaringBitmap.java
Patch:
@@ -537,9 +537,7 @@ public RoaringBitmap clone() {
                         x.highlowcontainer = highlowcontainer.clone();
                         return x;
                 } catch (final CloneNotSupportedException e) {
-                        e.printStackTrace();
-                        throw new RuntimeException(
-                                "shouldn't happen with clone");
+                        throw new RuntimeException("shouldn't happen with clone",e);
                 }
         }
 

File: src/main/java/org/roaringbitmap/RoaringArray.java
Patch:
@@ -54,9 +54,7 @@ protected void append(short key, Container value) {
          * Append copy of the one value from another array
          * 
          * @param sa
-         * @param startingindex
-         *                starting index in the other array
-         * @param end
+         * @param index index in the other array
          */
         protected void appendCopy(RoaringArray sa, int index) {
                 extendArray(1);

File: src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -447,7 +447,7 @@ public void readExternal(ObjectInput in) throws IOException,
                 byte[] buffer = new byte[2];
                 // little endian
                 in.readFully(buffer);
-                this.cardinality = buffer[0] | (buffer[1] << 8);
+                this.cardinality = (buffer[0] & 0xFF) | ((buffer[1] & 0xFF) << 8);
                 if (this.content.length < this.cardinality)
                         this.content = new short[this.cardinality];
                 for (int k = 0; k < this.cardinality; ++k) {

File: src/main/java/org/roaringbitmap/RoaringArray.java
Patch:
@@ -280,7 +280,7 @@ public void readExternal(ObjectInput in) throws IOException,
                         this.array = new Element[this.size];
                 for (int k = 0; k < this.size; ++k) {
                         in.readFully(buffer);
-                        short key = (short) (buffer[0] | (buffer[1] << 8));
+                        short key = (short) (buffer[0] & 0xFF | ((buffer[1] & 0xFF) << 8));
                         boolean isbitmap = in.readBoolean();
                         Container val;
                         if (isbitmap) {

File: src/main/java/org/roaringbitmap/ArrayContainer.java
Patch:
@@ -447,7 +447,7 @@ public void readExternal(ObjectInput in) throws IOException,
                 byte[] buffer = new byte[2];
                 // little endian
                 in.readFully(buffer);
-                this.cardinality = buffer[0] | (buffer[1] << 8);
+                this.cardinality = (buffer[0] & 0xFF) | ((buffer[1] & 0xFF) << 8);
                 if (this.content.length < this.cardinality)
                         this.content = new short[this.cardinality];
                 for (int k = 0; k < this.cardinality; ++k) {

File: src/main/java/org/roaringbitmap/RoaringArray.java
Patch:
@@ -280,7 +280,7 @@ public void readExternal(ObjectInput in) throws IOException,
                         this.array = new Element[this.size];
                 for (int k = 0; k < this.size; ++k) {
                         in.readFully(buffer);
-                        short key = (short) (buffer[0] | (buffer[1] << 8));
+                        short key = (short) (buffer[0] & 0xFF | ((buffer[1] & 0xFF) << 8));
                         boolean isbitmap = in.readBoolean();
                         Container val;
                         if (isbitmap) {

File: src/main/java/org/roaringbitmap/experiments/colantonio/AsymmetricBenchmark.java
Patch:
@@ -124,9 +124,11 @@ public static void main(final String[] args) {
                 DataGenerator gen = new DataGenerator(N);
                 int TIMES = 100;
                 gen.setUniform();
+                test(gen, false, TIMES, sizeof);
                 test(gen, true, TIMES, sizeof);
                 System.out.println();
                 gen.setZipfian();
+                test(gen, false, TIMES, sizeof);
                 test(gen, true, TIMES, sizeof);
                 System.out.println();
         }

File: src/main/java/org/roaringbitmap/experiments/colantonio/Benchmark.java
Patch:
@@ -108,9 +108,11 @@ public static void main(final String[] args) {
                 DataGenerator gen = new DataGenerator(N);
                 int TIMES = 100;
                 gen.setUniform();
+                test(gen,false, TIMES,sizeof);
                 test(gen,true, TIMES,sizeof);
                 System.out.println();
                 gen.setZipfian();
+                test(gen,false, TIMES,sizeof);
                 test(gen,true, TIMES,sizeof);
                 System.out.println();
        }

File: src/main/java/me/lemire/roaringbitmap/experiments/BenchSpeedyRBConcise.java
Patch:
@@ -20,7 +20,6 @@
 import javax.annotation.Generated;
 
 import me.lemire.roaringbitmap.*;
-import me.lemire.roaringbitmap.SpeedyArray.Element;
 import me.lemire.roaringbitmap.experiments.LineCharts.LineChartDemo1;
 import me.lemire.roaringbitmap.experiments.LineCharts.LineChartPoint;
 

File: src/main/java/me/lemire/roaringbitmap/experiments/IntUtil.java
Patch:
@@ -232,7 +232,7 @@ public static int frogintersect2by2(final int[] set1, final int length1, final i
 	 * @param array
 	 * @param pos
 	 * @param min
-	 * @return
+	 * @return smallest integer
 	 */
 	public static int advanceUntil(int[] array, int pos, int length, int min) {
 		int lower = pos+1;

File: src/main/java/me/lemire/roaringbitmap/SpeedyArray.java
Patch:
@@ -54,7 +54,8 @@ public void extendArray() {
                         this.array = Arrays.copyOf(this.array, newcapacity);
                 }
         }
-        
+
+    // OFK: shouldn't we null the last entry? Risk of memory leak?
         public void removeAtIndex(int i) {
                 System.arraycopy(array, i+1, array, i, nbKeys - i - 1);
                 nbKeys--;
@@ -86,6 +87,7 @@ public Element getAtIndex(int i) {
                 return this.array[i];
         }
 
+    // OFK: shouldn't we null the array elements? (Memory leak)
         public void clear() {
                 this.nbKeys = 0;
         }

File: src/main/java/me/lemire/roaringbitmap/experiments/colantonio/Benchmark.java
Patch:
@@ -118,7 +118,7 @@ public static void main(final String[] args) {
             try {
             		String folderPath;
             		folderPath = (args[0]==null) ? "" : args[0];
-            		folderPath+="/tree/master/scripts";
+            		folderPath+="/scripts";
             		new File(folderPath).mkdirs();
                 	File file = new File(folderPath+"/Benchmark.txt");
 					FileWriter fw = new FileWriter(file.getAbsoluteFile());

File: src/main/java/me/lemire/roaringbitmap/ArrayContainer.java
Patch:
@@ -118,7 +118,8 @@ public Short next() {
 
 			@Override
 			public void remove() {
-				ArrayContainer.this.remove(pos);
+			        ArrayContainer.this.remove((short) (pos-1));
+			        pos--;
 			}
 		};
 	}

File: src/main/java/me/lemire/roaringbitmap/Util.java
Patch:
@@ -30,13 +30,13 @@ protected static Container andNot(Container value1, Container value2) {
                         if (value2 instanceof ArrayContainer)
                                 return ((ArrayContainer) value1)
                                         .andNot((ArrayContainer) value2);
-                        return ((BitmapContainer) value2)
-                                .andNot((ArrayContainer) value1);
+                        return ((ArrayContainer) value1)
+                                .andNot((BitmapContainer) value2);
                 }
                 if (value2 instanceof ArrayContainer)
                         return ((BitmapContainer) value1)
                                 .andNot((ArrayContainer) value2);
-                return ((BitmapContainer) value2).andNot((BitmapContainer) value1);
+                return ((BitmapContainer) value1).andNot((BitmapContainer) value2);
         }
 
         protected static Container inPlaceAND(Container value1, Container value2) {

File: src/main/java/me/lemire/roaringbitmap/experiments/colantonio/Benchmark.java
Patch:
@@ -124,7 +124,7 @@ public static void test(final DataGenerator gen, final boolean verbose, final in
                         System.out
                                 .println("# density\tbitset\t\tconcise\t\twah\t\tspeedyroaring" +
                                 		"\t\tbitset\t\tconcise\t\twah\t\tspeedyroaring");
-                for (double d = 0.005; d <= 0.999; d *= 1.2) {
+                for (double d = 0.001; d <= 0.999; d *= 1.2) {
                         double[] timings = new double[4];
                         double[] storageinbits = new double[4];
 
@@ -183,7 +183,7 @@ public static void test(final DataGenerator gen, final boolean verbose, final in
                                 SpeedyRoaringBitmap rb1 = toSpeedyRoaringBitmap(v1);
                                 SpeedyRoaringBitmap rb2 = toSpeedyRoaringBitmap(v2);
                                 bef = System.nanoTime();
-                                rb1.inPlaceAND(rb2);
+                                rb1 = SpeedyRoaringBitmap.and(rb1,rb2);
                                 aft = System.nanoTime();
                                 // we verify the answer
                                 if(!Arrays.equals(rb1.getIntegers(), toArray(b1)))

File: src/main/java/me/lemire/roaringbitmap/experiments/SpeedyRoaringBenchmark.java
Patch:
@@ -188,7 +188,7 @@ public static void launchBenchmark(int distribution, int N, int repeat,
 				);
 	} catch (IOException e) {e.printStackTrace();}
 		
-		for(double k=0.0001; k<0.01; k*=10) {
+		for(double k=0.0001; k<1.0; k*=10) {
 			SizeGraphCoordinates = new ArrayList<Vector<LineChartPoint>>();
 			OrGraphCoordinates = new ArrayList<Vector<LineChartPoint>>();
 			AndGraphCoordinates = new ArrayList<Vector<LineChartPoint>>();

File: src/main/java/me/lemire/roaringbitmap/experiments/Benchmark.java
Patch:
@@ -54,9 +54,9 @@ public class Benchmark {
 	public static void main(String[] args) {
 		//test(10, 18, 10);
                 if (args.length > 0) {                    
-                	//Tests(nbBitmaps, 10, args[0], distUniform);
+                	Tests(nbBitmaps, 10, args[0], distUniform);
                 	Tests(nbBitmaps, 10, args[0], distZipf);
-                	//Tests(nbBitmaps, 10, args[0], distClustered);
+                	Tests(nbBitmaps, 10, args[0], distClustered);
                 }
                 else {
                         Tests(nbBitmaps, 10, null, distUniform);// no plots needed
@@ -188,7 +188,7 @@ public static void launchBenchmark(int distribution, int N, int repeat,
 				);
 	} catch (IOException e) {e.printStackTrace();}
 		
-		for(double k=0.01; k<1.0; k*=10) {
+		for(double k=0.0001; k<1.0; k*=10) {
 			SizeGraphCoordinates = new ArrayList<Vector<LineChartPoint>>();
 			OrGraphCoordinates = new ArrayList<Vector<LineChartPoint>>();
 			AndGraphCoordinates = new ArrayList<Vector<LineChartPoint>>();

File: src/main/java/me/lemire/roaringbitmap/BitmapContainer.java
Patch:
@@ -21,7 +21,7 @@ public void loadData(final ArrayContainer arrayContainer) {
                 for(int k = 0; k < arrayContainer.cardinality; ++k) {
                         final short x = arrayContainer.content[k];
                         bitmap[Util.toIntUnsigned(x)/64] |= (1l << x);
-                }                
+                }               
 	}
 
 	
@@ -125,7 +125,7 @@ public int getCardinality() {
 
 	public Container and(final BitmapContainer value2) {
 	        final BitmapContainer answer = ContainerFactory.getUnintializedBitmapContainer();
-		answer.cardinality = 0;
+	        answer.cardinality = 0;
 	        for (int k = 0; k < answer.bitmap.length; ++k) 
 		{
 			answer.bitmap[k] = this.bitmap[k] & value2.bitmap[k];

File: src/main/java/me/lemire/roaringbitmap/experiments/Benchmark.java
Patch:
@@ -186,7 +186,7 @@ public static void launchBenchmark(int distribution, int N, int repeat,
 				);
 	} catch (IOException e) {e.printStackTrace();}
 		
-		for(double k=0.0001; k<0.001; k*=10) {
+		for(double k=0.0001; k<1.0; k*=10) {
 			SizeGraphCoordinates = new ArrayList<Vector<LineChartPoint>>();
 			OrGraphCoordinates = new ArrayList<Vector<LineChartPoint>>();
 			AndGraphCoordinates = new ArrayList<Vector<LineChartPoint>>();

File: src/main/java/me/lemire/roaringbitmap/FastAggregation.java
Patch:
@@ -44,7 +44,7 @@ public static RoaringBitmap  inplace_or(RoaringBitmap... bitmaps) {
                         bitmaps.length, new Comparator<RoaringBitmapPointer>() {
                                 @Override
                                 public int compare(RoaringBitmapPointer a, RoaringBitmapPointer b) {
-                                        return  a.cs.getSizeInBytes() - b.cs.getSizeInBytes();
+                                        return a.cs.getSizeInBytes() - b.cs.getSizeInBytes();
                                 }
                         });
                 for (RoaringBitmap x : bitmaps) {

File: src/main/java/me/lemire/roaringbitmap/RoaringBitmap.java
Patch:
@@ -17,7 +17,7 @@ public final class RoaringBitmap implements Iterable<Integer>, Cloneable, Serial
 
         /**
          * set the value to "true", whether it already appears on not.
-         */     																									
+         */     																									// be
         public void add(final int x) {
                 set(x);
         }

File: src/main/java/me/lemire/roaringbitmap/experiments/Benchmark.java
Patch:
@@ -186,7 +186,7 @@ public static void launchBenchmark(int distribution, int N, int repeat,
 				);
 	} catch (IOException e) {e.printStackTrace();}
 		
-		for(double k=0.0001; k<1.0; k*=10) {
+		for(double k=0.0001; k<0.001; k*=10) {
 			SizeGraphCoordinates = new ArrayList<Vector<LineChartPoint>>();
 			OrGraphCoordinates = new ArrayList<Vector<LineChartPoint>>();
 			AndGraphCoordinates = new ArrayList<Vector<LineChartPoint>>();

File: src/main/java/me/lemire/roaringbitmap/FastAggregation.java
Patch:
@@ -44,7 +44,7 @@ public static RoaringBitmap  inplace_or(RoaringBitmap... bitmaps) {
                         bitmaps.length, new Comparator<RoaringBitmapPointer>() {
                                 @Override
                                 public int compare(RoaringBitmapPointer a, RoaringBitmapPointer b) {
-                                        return a.cs.getSizeInBytes() - b.cs.getSizeInBytes();
+                                        return  a.cs.getSizeInBytes() - b.cs.getSizeInBytes();
                                 }
                         });
                 for (RoaringBitmap x : bitmaps) {

File: src/main/java/me/lemire/roaringbitmap/RoaringBitmap.java
Patch:
@@ -17,7 +17,7 @@ public final class RoaringBitmap implements Iterable<Integer>, Cloneable, Serial
 
         /**
          * set the value to "true", whether it already appears on not.
-         */     																									// be
+         */     																									
         public void add(final int x) {
                 set(x);
         }

File: src/main/java/me/lemire/roaringbitmap/experiments/Benchmark.java
Patch:
@@ -186,7 +186,7 @@ public static void launchBenchmark(int distribution, int N, int repeat,
 				);
 	} catch (IOException e) {e.printStackTrace();}
 		
-		for(double k=0.0001; k<0.001; k*=10) {
+		for(double k=0.0001; k<1.0; k*=10) {
 			SizeGraphCoordinates = new ArrayList<Vector<LineChartPoint>>();
 			OrGraphCoordinates = new ArrayList<Vector<LineChartPoint>>();
 			AndGraphCoordinates = new ArrayList<Vector<LineChartPoint>>();

File: src/main/java/me/lemire/roaringbitmap/experiments/Benchmark.java
Patch:
@@ -622,7 +622,7 @@ public static void testConciseSet(int[][] data, int[][] data2, int repeat,
                         ConciseSet bitmapxor2 = ConciseSetUtil.fastXOR(bitmap2);
                         bitmapxor1 = bitmapxor1.intersection(bitmapxor2);
                         int[] array = bitmapxor1.toArray();
-                        bogus += array.length;
+                        if(array != null) bogus += array.length;
                 }
                 aft = System.currentTimeMillis();
                 line += "\t" + df.format((aft - bef) / 1000.0);

File: src/main/java/me/lemire/roaringbitmap/experiments/Benchmark.java
Patch:
@@ -595,7 +595,7 @@ public static void testConciseSet(int[][] data, int[][] data2, int repeat,
                         ConciseSet bitmapand2 = ConciseSetUtil.fastAND(bitmap2);
                         bitmapand1 = bitmapand1.intersection(bitmapand2);
                         int[] array = bitmapand1.toArray();
-                        bogus += array.length;
+                        if(array!=null) bogus += array.length;
                 }
                 aft = System.currentTimeMillis();
                 line += "\t" + df.format((aft - bef) / 1000.0);

File: src/main/java/me/lemire/roaringbitmap/experiments/ConciseSetUtil.java
Patch:
@@ -20,7 +20,7 @@ public int compare(ConciseSet a, ConciseSet b) {
                                 }
                         });
                 for (ConciseSet x : bitmaps) {
-                        pq.add(x);
+                        pq.add(x.clone());
                 }
                 while (pq.size() > 1) {
                         ConciseSet x1 = pq.poll();
@@ -40,7 +40,7 @@ public int compare(ConciseSet a, ConciseSet b) {
                                 }
                         });
                 for (ConciseSet x : bitmaps) {
-                        pq.add(x);
+                        pq.add(x.clone());
                 }
                 while (pq.size() > 1) {
                         ConciseSet x1 = pq.poll();

File: src/main/java/me/lemire/roaringbitmap/ContainerFactory.java
Patch:
@@ -8,7 +8,7 @@
  *
  *
  */
-public class ContainerFactory {
+public  final class ContainerFactory {
         
         static ArrayList<ArrayContainer> buffer = new  ArrayList<ArrayContainer>();
         static ArrayList<BitmapContainer> Bbuffer = new  ArrayList<BitmapContainer>();

File: src/main/java/me/lemire/roaringbitmap/ArrayContainer.java
Patch:
@@ -81,7 +81,7 @@ public Container remove(short x) {
 			// insertion
 			System.arraycopy(content, loc + 1, content, loc, cardinality - loc
 					- 1);
-			++cardinality;
+			--cardinality;
 		}
 		return this;
 	}

File: src/main/java/me/lemire/roaringbitmap/BitmapContainer.java
Patch:
@@ -45,8 +45,8 @@ public Container add(short i) {
 	@Override
 	public Container remove(short x) {
 		if (contains(x)) {
-			--cardinality;
-			bitmap[x / 64] &= ~(1l << x );
+	                --cardinality;
+	                bitmap[x / 64] &= ~(1l << x );
 			if (cardinality < ArrayContainer.DEFAULTMAXSIZE) {
 				return ContainerFactory.transformToArrayContainer(this);
 			}
@@ -200,7 +200,7 @@ public Container xor(BitmapContainer value2) {
 		BitmapContainer answer = new BitmapContainer();
 		for (int k = 0; k < answer.bitmap.length; ++k) {
 			answer.bitmap[k] = this.bitmap[k] ^ value2.bitmap[k];
-			if(answer.bitmap[k]!=0)
+			//if(answer.bitmap[k]!=0) // probably not wise performance-wise
 				answer.cardinality += Long.bitCount(answer.bitmap[k]);
 		}
 		if (answer.cardinality <= ArrayContainer.DEFAULTMAXSIZE)

File: src/main/java/me/lemire/roaringbitmap/ArrayContainer.java
Patch:
@@ -47,7 +47,7 @@ public boolean contains(short x) {
 	@Override
 	public Container add(short x) {
 		
-	        if(( cardinality == 0 )  || (Util.toIntUnsigned(x) > content[cardinality-1])) {
+	        if(( cardinality == 0 )  || (Util.toIntUnsigned(x) > Util.toIntUnsigned(content[cardinality-1]))) {
 	                if (cardinality == content.length) {
                                 BitmapContainer a = ContainerFactory.transformToBitmapContainer(this);
                                 a.add(x);

File: src/main/java/me/lemire/roaringbitmap/BitmapContainer.java
Patch:
@@ -184,7 +184,9 @@ public Container xor(ArrayContainer value2)
 		for (int k = 0; k < value2.getCardinality(); ++k) {
 		        final int index = Util.toIntUnsigned(value2.content[k])/64;
 		        // DL: I have considerably simplified the code here, removing the branching
-                        cardinality += (answer.bitmap[index] ^ (1l << value2.content[k] )) >>> value2.content[k] ;
+		        // Look at next line: no branching, just fast arithmetic
+                        cardinality +=  ((answer.bitmap[index] ^ (1l << value2.content[k] )) - 
+                                (answer.bitmap[index] & (1l << value2.content[k] ))) >>> value2.content[k];
                         answer.bitmap[index] = answer.bitmap[index]
                                         ^ (1l << value2.content[k] );
 		}		

File: src/main/java/me/lemire/roaringbitmap/RoaringBitmap.java
Patch:
@@ -31,7 +31,6 @@ public void set(int x) {
 		if(z != null) {
 		        Container z2 = z.add(Util.lowbits(x));
 		        if(z2 != z) {
-		          ContainerFactory.putBackInStore((ArrayContainer)z); //Conserving the ArrayContainer object  
 		          highlowcontainer.put(hb,z2); //Replace the ArrayContainer by the new bitmapContainer
 		        }
 		} else {

File: src/test/java/RoaringBitmapTest.java
Patch:
@@ -70,7 +70,7 @@ public void andtest() {
 		RoaringBitmap rr2 = new RoaringBitmap();
 		rr2.add(13);
 		RoaringBitmap rrand = RoaringBitmap.and(rr, rr2);
-
+		
 		int[] array = new int[1];
 		int pos = 0;
 		for (int i : rrand) {

File: src/main/java/me/lemire/roaringbitmap/experiments/StarSchemaBenchmark.java
Patch:
@@ -547,7 +547,7 @@ public static void testWAH32(int repeat, DecimalFormat df) {
 			Iterator<Integer> i = bitmapand1.iterator(); i.hasNext(); array[c++] = i
 					.next().intValue()) {
 			}
-			bogus += array[array.length-1];
+			if(array.length>0) bogus += array[array.length-1];
 		}
 		aft = System.currentTimeMillis();
 		line += "\t" + df.format((aft - bef) / 1000.0);

File: src/main/java/me/lemire/roaringbitmap/Container.java
Patch:
@@ -7,4 +7,5 @@ public interface Container extends Iterable<Short>{
 	public boolean contains(short x);
 	public int getCardinality();
     public int getSizeInBits();
+    public void validate();
 }

File: src/main/java/me/lemire/roaringbitmap/Util.java
Patch:
@@ -1,8 +1,5 @@
 package me.lemire.roaringbitmap;
 
-import java.util.Comparator;
-import java.util.PriorityQueue;
-
 public class Util {
 	public static short highbits(int x) {
 		return (short) (x >>> 16);

File: src/main/java/me/lemire/roaringbitmap/experiments/IntUtil.java
Patch:
@@ -11,7 +11,8 @@ public static int[] unite(int[]... set) {
     if(set.length == 0) throw new RuntimeException("nothing");
     PriorityQueue<int[]> pq = new PriorityQueue<int[]>(set.length,
       new Comparator<int[]>(){
-        public int compare(int[] a, int[] b) {
+        @Override
+		public int compare(int[] a, int[] b) {
           return a.length - b.length;
         }}
      );

File: src/main/java/me/lemire/roaringbitmap/RRmain.java
Patch:
@@ -3,7 +3,6 @@
 import java.util.Iterator;
 import java.util.Map.Entry;
 
-import junit.framework.Assert;
 
 public class RRmain {
 	/**

