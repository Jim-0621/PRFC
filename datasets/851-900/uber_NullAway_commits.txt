File: nullaway/src/main/java/com/uber/nullaway/Nullness.java
Patch:
@@ -277,7 +277,7 @@ public static boolean paramHasNonNullAnnotation(
   }
 
   /**
-   * Is the varargs parameter {@code paramSymbol} have a {@code @Nullable} annotation indicating
+   * Does the varargs parameter {@code paramSymbol} have a {@code @Nullable} annotation indicating
    * that the argument array passed at a call site can be {@code null}? Syntactically, this would be
    * written as {@code foo(Object @Nullable... args}}
    */

File: nullaway/src/main/java/com/uber/nullaway/generics/GenericsChecks.java
Patch:
@@ -1030,7 +1030,6 @@ private static void checkTypeParameterNullnessForOverridingMethodParameterType(
       MethodTree tree, Type overriddenMethodType, NullAway analysis, VisitorState state) {
     List<? extends VariableTree> methodParameters = tree.getParameters();
     List<Type> overriddenMethodParameterTypes = overriddenMethodType.getParameterTypes();
-    // TODO handle varargs; they are not handled for now
     for (int i = 0; i < methodParameters.size(); i++) {
       Type overridingMethodParameterType = getTreeType(methodParameters.get(i), state);
       Type overriddenMethodParameterType = overriddenMethodParameterTypes.get(i);

File: jmh/src/test/java/com/uber/nullaway/jmh/BenchmarkCompilationTest.java
Patch:
@@ -3,6 +3,7 @@
 import static org.junit.Assert.assertTrue;
 
 import java.io.IOException;
+import org.junit.Ignore;
 import org.junit.Test;
 
 /** Tests that all our JMH benchmarks compile successfully */
@@ -14,6 +15,7 @@ public void testAutodispose() throws IOException {
   }
 
   @Test
+  @Ignore("Need to update caffeine version; https://github.com/uber/NullAway/issues/1108")
   public void testCaffeine() throws IOException {
     assertTrue(new CaffeineCompiler().compile());
   }

File: jdk-recent-unit-tests/src/test/java/com/uber/nullaway/jdk17/ModuleInfoTests.java
Patch:
@@ -35,6 +35,7 @@ public void testModuleInfo() {
     defaultCompilationHelper
         .addSourceLines(
             "module-info.java",
+            "@SuppressWarnings(\"some-warning-name\")",
             "module com.uber.mymodule {",
             "  // Important: two-level deep module tests matching of identifier `java` as base expression;",
             "  // see further discussion at https://github.com/uber/NullAway/pull/544#discussion_r780829467",

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -688,7 +688,7 @@ public Description matchSwitch(SwitchTree tree, VisitorState state) {
       switchSelectorExpression = ((ParenthesizedTree) switchSelectorExpression).getExpression();
     }
 
-    if (mayBeNullExpr(state, switchSelectorExpression)) {
+    if (!TreeUtils.hasNullCaseLabel(tree) && mayBeNullExpr(state, switchSelectorExpression)) {
       String message =
           "switch expression " + state.getSourceForNode(switchSelectorExpression) + " is @Nullable";
       ErrorMessage errorMessage =

File: nullaway/src/test/java/com/uber/nullaway/CoreTests.java
Patch:
@@ -207,7 +207,7 @@ public void cfNullableArrayField() {
   }
 
   @Test
-  public void supportSwitchExpression() {
+  public void switchOnNullable() {
     defaultCompilationHelper
         .addSourceLines(
             "TestPositive.java",

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handlers.java
Patch:
@@ -51,9 +51,6 @@ public static Handler buildDefault(Config config) {
       // bytecode annotations
       handlerListBuilder.add(new RestrictiveAnnotationHandler(config));
     }
-    if (config.isJarInferEnabled()) {
-      handlerListBuilder.add(new InferredJARModelsHandler());
-    }
     if (config.handleTestAssertionLibraries()) {
       handlerListBuilder.add(new AssertionHandler(methodNameUtil));
     }

File: test-java-lib/src/main/java/com/uber/lib/Varargs.java
Patch:
@@ -7,4 +7,7 @@ public class Varargs {
   public Varargs(@Nullable String... args) {}
 
   public static void typeUse(String @org.jspecify.annotations.Nullable ... args) {}
+
+  public static void typeUseNullableElementsJSpecify(
+      @org.jspecify.annotations.Nullable String... args) {}
 }

File: jar-infer/nullaway-integration-test/src/test/java/com/uber/nullaway/jarinfer/JarInferIntegrationTest.java
Patch:
@@ -88,6 +88,8 @@ public void genericsTest() {
             "    Toys.Generic<String> g = new Toys.Generic<>();",
             "    // BUG: Diagnostic contains: passing @Nullable parameter 'null'",
             "    g.getString(null);",
+            "    // BUG: Diagnostic contains: passing @Nullable parameter 'null'",
+            "    Toys.genericParam(null);",
             "  }",
             "}")
         .doTest();

File: nullaway/src/main/java/com/uber/nullaway/generics/CheckIdenticalNullabilityVisitor.java
Patch:
@@ -35,10 +35,10 @@ public Boolean visitClassType(Type.ClassType lhsType, Type rhsType) {
     // The base type of rhsType may be a subtype of lhsType's base type.  In such cases, we must
     // compare lhsType against the supertype of rhsType with a matching base type.
     Type rhsTypeAsSuper = types.asSuper(rhsType, lhsType.tsym);
-    // This is impossible, considering the fact that standard Java subtyping succeeds before
-    // running NullAway
     if (rhsTypeAsSuper == null) {
-      throw new RuntimeException("Did not find supertype of " + rhsType + " matching " + lhsType);
+      // Surprisingly, this can in fact occur, in cases involving raw types.  See, e.g.,
+      // GenericsTests#issue1082 and https://github.com/uber/NullAway/pull/1086. Bail out.
+      return true;
     }
     // bail out of checking raw types for now
     if (rhsTypeAsSuper.isRaw()) {

File: jmh/src/main/java/com/uber/nullaway/jmh/NullawayJavac.java
Patch:
@@ -186,6 +186,7 @@ private NullawayJavac(
             "-d",
             outputDir.toAbsolutePath().toString(),
             "-XDcompilePolicy=simple",
+            "--should-stop=ifError=FLOW",
             "-Xplugin:ErrorProne -XepDisableAllChecks -Xep:NullAway:ERROR -XepOpt:NullAway:AnnotatedPackages="
                 + annotatedPackages
                 + String.join(" ", extraErrorProneArgs)));

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/ContractHandler.java
Patch:
@@ -208,7 +208,7 @@ public NullnessHint onDataflowVisitMethodInvocation(
       for (int i = 0; i < antecedent.length; ++i) {
         String valueConstraint = antecedent[i].trim();
         if (valueConstraint.equals("_")) {
-          continue;
+          // do nothing
         } else if (valueConstraint.equals("false") || valueConstraint.equals("true")) {
           // We handle boolean constraints in the case that the boolean argument is the result
           // of a null or not-null check. For example,
@@ -262,8 +262,7 @@ public NullnessHint onDataflowVisitMethodInvocation(
         } else if (valueConstraint.equals("!null")
             && inputs.valueOfSubNode(node.getArgument(i)).equals(Nullness.NONNULL)) {
           // We already know this argument can't be null, so we can treat it as not part of the
-          // clause for the purpose of deciding the non-nullness of the other arguments.
-          continue;
+          // clause for the purpose of deciding the non-nullness of the other arguments; do nothing
         } else if (valueConstraint.equals("null") || valueConstraint.equals("!null")) {
           if (arg != null) {
             // More than one argument involved in the antecedent, ignore this rule

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -1852,7 +1852,7 @@ private Description handleInvocation(
       }
       if (config.isJSpecifyMode()) {
         GenericsChecks.compareGenericTypeParameterNullabilityForCall(
-            formalParams, actualParams, varArgsMethod, this, state);
+            methodSymbol, tree, actualParams, varArgsMethod, this, state);
         if (!methodSymbol.getTypeParameters().isEmpty()) {
           GenericsChecks.checkGenericMethodCallTypeArguments(tree, state, this, config, handler);
         }

File: jar-infer/jar-infer-lib/src/main/java/com/uber/nullaway/jarinfer/BytecodeAnnotator.java
Patch:
@@ -172,11 +172,9 @@ private static void annotateBytecode(
       }
       Set<Integer> params = nonnullParams.get(methodSignature);
       if (params != null) {
-        boolean isStatic = (method.access & Opcodes.ACC_STATIC) != 0;
         for (Integer param : params) {
-          int paramNum = isStatic ? param : param - 1;
           // Add a @Nonnull annotation on this parameter.
-          method.visitParameterAnnotation(paramNum, nonnullDesc, visible);
+          method.visitParameterAnnotation(param, nonnullDesc, visible);
           LOG(
               debug,
               "DEBUG",

File: jar-infer/nullaway-integration-test/src/test/java/com/uber/nullaway/jarinfer/JarInferIntegrationTest.java
Patch:
@@ -4,6 +4,7 @@
 import com.uber.nullaway.NullAway;
 import java.util.Arrays;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
@@ -121,6 +122,8 @@ public void jarinferNullableReturnsTest() {
    * project which determines which SDK version's models are being tested.
    */
   @Test
+  @Ignore(
+      "temporarily ignore while making some astubx format changes; see https://github.com/uber/NullAway/issues/1072")
   public void jarInferAndroidSDKModels() {
     compilationHelper
         .setArgs(

File: nullaway/src/main/java/com/uber/nullaway/handlers/InferredJARModelsHandler.java
Patch:
@@ -131,8 +131,7 @@ public Nullness[] onOverrideMethodInvocationParametersNullability(
     for (Map.Entry<Integer, Set<String>> annotationEntry : methodArgAnnotations.entrySet()) {
       if (annotationEntry.getKey() != RETURN
           && annotationEntry.getValue().contains("javax.annotation.Nonnull")) {
-        // Skip 'this' param for non-static methods
-        int nonNullPosition = annotationEntry.getKey() - (methodSymbol.isStatic() ? 0 : 1);
+        int nonNullPosition = annotationEntry.getKey();
         jiNonNullParams.add(nonNullPosition);
         argumentPositionNullness[nonNullPosition] = Nullness.NONNULL;
       }

File: nullaway/src/test/java/com/uber/nullaway/DummyOptionsConfigTest.java
Patch:
@@ -50,7 +50,7 @@ public void allDeclaredMethodsThrowIllegalStateException() {
       Throwable cause = reflectionException.getCause();
       assertThat(cause, instanceOf(IllegalStateException.class));
       IllegalStateException exception = (IllegalStateException) cause;
-      assertEquals(exception.getMessage(), DummyOptionsConfig.ERROR_MESSAGE);
+      assertEquals(DummyOptionsConfig.ERROR_MESSAGE, exception.getMessage());
     }
   }
 }

File: nullaway/src/test/java/com/uber/nullaway/LegacyAndJspecifyModeTest.java
Patch:
@@ -42,6 +42,6 @@ public void testIllegalStateExceptionUsingReflection() throws Exception {
 
     Throwable cause = exception.getCause();
     assertThat(cause, instanceOf(IllegalStateException.class));
-    assertEquals(cause.getMessage(), ERROR);
+    assertEquals(ERROR, cause.getMessage());
   }
 }

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -1853,6 +1853,9 @@ private Description handleInvocation(
       if (config.isJSpecifyMode()) {
         GenericsChecks.compareGenericTypeParameterNullabilityForCall(
             formalParams, actualParams, varArgsMethod, this, state);
+        if (!methodSymbol.getTypeParameters().isEmpty()) {
+          GenericsChecks.checkGenericMethodCallTypeArguments(tree, state, this, config, handler);
+        }
       }
     }
 

File: nullaway/src/test/java/com/uber/nullaway/ContractsTests.java
Patch:
@@ -13,7 +13,7 @@ public void checkContractPositiveCases() {
                 temporaryFolder.getRoot().getAbsolutePath(),
                 "-XepOpt:NullAway:AnnotatedPackages=com.uber",
                 "-XepOpt:NullAway:CheckContracts=true"))
-        .addSourceFile("CheckContractPositiveCases.java")
+        .addSourceFile("testdata/CheckContractPositiveCases.java")
         .doTest();
   }
 
@@ -25,7 +25,7 @@ public void checkContractNegativeCases() {
                 temporaryFolder.getRoot().getAbsolutePath(),
                 "-XepOpt:NullAway:AnnotatedPackages=com.uber",
                 "-XepOpt:NullAway:CheckContracts=true"))
-        .addSourceFile("CheckContractNegativeCases.java")
+        .addSourceFile("testdata/CheckContractNegativeCases.java")
         .doTest();
   }
 

File: nullaway/src/test/java/com/uber/nullaway/ThriftTests.java
Patch:
@@ -156,7 +156,7 @@ public void testThriftAndCastToNonNull() {
                 "-XepOpt:NullAway:CastToNonNullMethod=com.uber.nullaway.testdata.Util.castToNonNull",
                 "-XepOpt:NullAway:TreatGeneratedAsUnannotated=true",
                 "-XepOpt:NullAway:AcknowledgeRestrictiveAnnotations=true"))
-        .addSourceFile("Util.java")
+        .addSourceFile("testdata/Util.java")
         .addSourceLines("TBase.java", "package org.apache.thrift;", "public interface TBase {}")
         .addSourceLines(
             "GeneratedClass.java",

File: nullaway/src/main/java/com/uber/nullaway/dataflow/CoreNullnessStoreInitializer.java
Patch:
@@ -67,6 +67,8 @@ private static NullnessStore methodInitialStore(
     for (LocalVariableNode param : parameters) {
       Symbol paramSymbol = (Symbol) param.getElement();
       Nullness assumed;
+      // Using this flag to check for a varargs parameter works since we know paramSymbol represents
+      // a parameter defined in source code
       if ((paramSymbol.flags() & Flags.VARARGS) != 0) {
         assumed = Nullness.varargsArrayIsNullable(paramSymbol, config) ? NULLABLE : NONNULL;
       } else {

File: nullaway/src/main/java/com/uber/nullaway/ErrorMessage.java
Patch:
@@ -59,6 +59,7 @@ public enum MessageTypes {
     WRONG_OVERRIDE_RETURN_GENERIC,
     WRONG_OVERRIDE_PARAM_GENERIC,
     ASSIGN_NULLABLE_TO_NONNULL_ARRAY,
+    NULLABLE_ON_WRONG_NESTED_CLASS_LEVEL
   }
 
   public String getMessage() {

File: jar-infer/nullaway-integration-test/src/test/java/com/uber/nullaway/jarinfer/JarInferIntegrationTest.java
Patch:
@@ -101,8 +101,7 @@ public void jarinferNullableReturnsTest() {
                 temporaryFolder.getRoot().getAbsolutePath(),
                 "-XepOpt:NullAway:AnnotatedPackages=com.uber",
                 "-XepOpt:NullAway:UnannotatedSubPackages=com.uber.nullaway.[a-zA-Z0-9.]+.unannotated",
-                "-XepOpt:NullAway:JarInferEnabled=true",
-                "-XepOpt:NullAway:JarInferUseReturnAnnotations=true"))
+                "-XepOpt:NullAway:JarInferEnabled=true"))
         .addSourceLines(
             "Test.java",
             "package com.uber;",

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handlers.java
Patch:
@@ -52,7 +52,7 @@ public static Handler buildDefault(Config config) {
       handlerListBuilder.add(new RestrictiveAnnotationHandler(config));
     }
     if (config.isJarInferEnabled()) {
-      handlerListBuilder.add(new InferredJARModelsHandler(config));
+      handlerListBuilder.add(new InferredJARModelsHandler());
     }
     if (config.handleTestAssertionLibraries()) {
       handlerListBuilder.add(new AssertionHandler(methodNameUtil));

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPath.java
Patch:
@@ -287,7 +287,7 @@ && castToNonNull(receiver.getTree()).getKind().equals(Tree.Kind.IDENTIFIER)
             && (receiver.toString().equals("Integer") || receiver.toString().equals("Long"))) {
           return argumentToMapKeySpecifier(arguments.get(0), state, apContext);
         }
-        // Fine to fallthrough:
+      // Fine to fallthrough:
       default:
         // Every other type of expression, including variables, field accesses, new A(...), etc.
         return getAccessPathForNode(argument, state, apContext); // Every AP is a MapKey too
@@ -488,8 +488,8 @@ && isBoxingMethod(ASTHelpers.getSymbol(methodInvocationTree))) {
                   break;
                 }
               }
-              // Cascade to default, symbol is not a constant field
-              // fall through
+            // Cascade to default, symbol is not a constant field
+            // fall through
             default:
               return null; // Not an AP
           }

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPathNullnessPropagation.java
Patch:
@@ -852,7 +852,8 @@ public TransferResult<Nullness, NullnessStore> visitSuper(
   @Override
   public TransferResult<Nullness, NullnessStore> visitReturn(
       ReturnNode returnNode, TransferInput<Nullness, NullnessStore> input) {
-    handler.onDataflowVisitReturn(returnNode.getTree(), input.getThenStore(), input.getElseStore());
+    handler.onDataflowVisitReturn(
+        returnNode.getTree(), state, input.getThenStore(), input.getElseStore());
     return noStoreChanges(NULLABLE, input);
   }
 

File: nullaway/src/main/java/com/uber/nullaway/handlers/BaseNoOpHandler.java
Patch:
@@ -174,7 +174,7 @@ public NullnessHint onDataflowVisitFieldAccess(
 
   @Override
   public void onDataflowVisitReturn(
-      ReturnTree tree, NullnessStore thenStore, NullnessStore elseStore) {
+      ReturnTree tree, VisitorState state, NullnessStore thenStore, NullnessStore elseStore) {
     // NoOp
   }
 

File: nullaway/src/main/java/com/uber/nullaway/handlers/CompositeHandler.java
Patch:
@@ -220,9 +220,9 @@ public NullnessHint onDataflowVisitFieldAccess(
 
   @Override
   public void onDataflowVisitReturn(
-      ReturnTree tree, NullnessStore thenStore, NullnessStore elseStore) {
+      ReturnTree tree, VisitorState state, NullnessStore thenStore, NullnessStore elseStore) {
     for (Handler h : handlers) {
-      h.onDataflowVisitReturn(tree, thenStore, elseStore);
+      h.onDataflowVisitReturn(tree, state, thenStore, elseStore);
     }
   }
 

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handler.java
Patch:
@@ -269,12 +269,14 @@ NullnessHint onDataflowVisitFieldAccess(
    * Called when the Dataflow analysis visits a return statement.
    *
    * @param tree The AST node for the return statement being matched.
+   * @param state The current visitor state
    * @param thenStore The NullnessStore for the true case of the expression inside the return
    *     statement.
    * @param elseStore The NullnessStore for the false case of the expression inside the return
    *     statement.
    */
-  void onDataflowVisitReturn(ReturnTree tree, NullnessStore thenStore, NullnessStore elseStore);
+  void onDataflowVisitReturn(
+      ReturnTree tree, VisitorState state, NullnessStore thenStore, NullnessStore elseStore);
 
   /**
    * Called when the Dataflow analysis visits the result expression inside the body of lambda.

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handlers.java
Patch:
@@ -27,6 +27,7 @@
 import com.uber.nullaway.handlers.contract.ContractCheckHandler;
 import com.uber.nullaway.handlers.contract.ContractHandler;
 import com.uber.nullaway.handlers.contract.fieldcontract.EnsuresNonNullHandler;
+import com.uber.nullaway.handlers.contract.fieldcontract.EnsuresNonNullIfHandler;
 import com.uber.nullaway.handlers.contract.fieldcontract.RequiresNonNullHandler;
 import com.uber.nullaway.handlers.temporary.FluentFutureHandler;
 
@@ -69,6 +70,7 @@ public static Handler buildDefault(Config config) {
     handlerListBuilder.add(new GrpcHandler());
     handlerListBuilder.add(new RequiresNonNullHandler());
     handlerListBuilder.add(new EnsuresNonNullHandler());
+    handlerListBuilder.add(new EnsuresNonNullIfHandler());
     handlerListBuilder.add(new SynchronousCallbackHandler());
     if (config.serializationIsActive() && config.getSerializationConfig().fieldInitInfoEnabled) {
       handlerListBuilder.add(

File: nullaway/src/main/java/com/uber/nullaway/handlers/StreamNullabilityPropagator.java
Patch:
@@ -595,7 +595,7 @@ public NullnessStore.Builder onDataflowInitialStore(
 
   @Override
   public void onDataflowVisitReturn(
-      ReturnTree tree, NullnessStore thenStore, NullnessStore elseStore) {
+      ReturnTree tree, VisitorState state, NullnessStore thenStore, NullnessStore elseStore) {
     Tree filterTree = returnToEnclosingMethodOrLambda.get(tree);
     if (filterTree != null) {
       assert (filterTree instanceof MethodTree || filterTree instanceof LambdaExpressionTree);

File: nullaway/src/main/java/com/uber/nullaway/handlers/InferredJARModelsHandler.java
Patch:
@@ -254,9 +254,9 @@ private String getMethodSignature(Symbol.MethodSymbol method) {
 
   private String getSimpleTypeName(Type typ) {
     if (typ.getKind() == TypeKind.TYPEVAR) {
-      return typ.getUpperBound().tsym.getSimpleName().toString();
+      return typ.getUpperBound().tsym.getQualifiedName().toString();
     } else {
-      return typ.tsym.getSimpleName().toString();
+      return typ.toString();
     }
   }
 }

File: test-java-lib/src/main/java/com/uber/lib/generics/NonNullTypeParam.java
Patch:
@@ -0,0 +1,3 @@
+package com.uber.lib.generics;
+
+public class NonNullTypeParam<E> {}

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -498,7 +498,6 @@ public Description matchAssignment(AssignmentTree tree, VisitorState state) {
           // logic
           return errorBuilder.createErrorDescription(
               errorMessage,
-              expression,
               buildDescription(tree),
               state,
               ASTHelpers.getSymbol(tree.getVariable()));

File: jmh/src/main/java/com/uber/nullaway/jmh/NullawayJavac.java
Patch:
@@ -33,13 +33,13 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
-import javax.annotation.Nullable;
 import javax.tools.DiagnosticListener;
 import javax.tools.JavaCompiler;
 import javax.tools.JavaFileObject;
 import javax.tools.SimpleJavaFileObject;
 import javax.tools.StandardJavaFileManager;
 import javax.tools.ToolProvider;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Code to run Javac with NullAway enabled, designed to aid benchmarking. Construction of {@code
@@ -53,7 +53,7 @@ public class NullawayJavac {
   //////////////////////
   private List<JavaFileObject> compilationUnits;
   private JavaCompiler compiler;
-  @Nullable private DiagnosticListener<JavaFileObject> diagnosticListener;
+  private @Nullable DiagnosticListener<JavaFileObject> diagnosticListener;
   private StandardJavaFileManager fileManager;
   private List<String> options;
 

File: nullaway/src/main/java/com/uber/nullaway/CodeAnnotationInfo.java
Patch:
@@ -35,8 +35,8 @@
 import com.uber.nullaway.handlers.Handler;
 import java.util.HashMap;
 import java.util.Map;
-import javax.annotation.Nullable;
 import javax.lang.model.element.ElementKind;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Provides APIs for querying whether code is annotated for nullness checking, and for related

File: nullaway/src/main/java/com/uber/nullaway/Config.java
Patch:
@@ -26,7 +26,7 @@
 import com.sun.tools.javac.code.Symbol;
 import com.uber.nullaway.fixserialization.FixSerializationConfig;
 import java.util.Set;
-import javax.annotation.Nullable;
+import org.jspecify.annotations.Nullable;
 
 /** Provides configuration parameters for the nullability checker. */
 public interface Config {
@@ -238,8 +238,7 @@ public interface Config {
    *     return an @NonNull copy (likely through an unsafe downcast, but performing runtime checking
    *     and logging)
    */
-  @Nullable
-  String getCastToNonNullMethod();
+  @Nullable String getCastToNonNullMethod();
 
   /**
    * Gets an optional comment to add to auto-fix suppressions.

File: nullaway/src/main/java/com/uber/nullaway/DummyOptionsConfig.java
Patch:
@@ -29,7 +29,7 @@
 import com.sun.tools.javac.code.Symbol;
 import com.uber.nullaway.fixserialization.FixSerializationConfig;
 import java.util.Set;
-import javax.annotation.Nullable;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Dummy Config class required for the {@link NullAway} empty constructor.
@@ -175,8 +175,7 @@ public Set<String> getOptionalClassPaths() {
   }
 
   @Override
-  @Nullable
-  public String getCastToNonNullMethod() {
+  public @Nullable String getCastToNonNullMethod() {
     throw new IllegalStateException(ERROR_MESSAGE);
   }
 

File: nullaway/src/main/java/com/uber/nullaway/ErrorBuilder.java
Patch:
@@ -61,10 +61,10 @@
 import java.util.List;
 import java.util.Set;
 import java.util.stream.StreamSupport;
-import javax.annotation.Nullable;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.tools.JavaFileObject;
+import org.jspecify.annotations.Nullable;
 
 /** A class to construct error message to be displayed after the analysis finds error. */
 public class ErrorBuilder {
@@ -318,8 +318,7 @@ Description.Builder addSuppressWarningsFix(
    * <p>TODO: actually use {@link
    * com.google.errorprone.fixes.SuggestedFixes#addSuppressWarnings(VisitorState, String)} instead
    */
-  @Nullable
-  private Tree suppressibleNode(@Nullable TreePath path) {
+  private @Nullable Tree suppressibleNode(@Nullable TreePath path) {
     if (path == null) {
       return null;
     }

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -110,7 +110,6 @@
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 import java.util.stream.StreamSupport;
-import javax.annotation.Nullable;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -122,6 +121,7 @@
 import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
 import org.checkerframework.nullaway.javacutil.ElementUtils;
 import org.checkerframework.nullaway.javacutil.TreeUtils;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Checker for nullability errors. It assumes that any field, method parameter, or return type that
@@ -2154,8 +2154,7 @@ private Set<Element> getSafeInitMethods(
    * @param state visitor state
    * @return element of safe init function if stmt invokes that function; null otherwise
    */
-  @Nullable
-  private Element getInvokeOfSafeInitMethod(
+  private @Nullable Element getInvokeOfSafeInitMethod(
       StatementTree stmt, Symbol.ClassSymbol enclosingClassSymbol, VisitorState state) {
     Matcher<ExpressionTree> invokeMatcher =
         (expressionTree, s) -> {

File: nullaway/src/main/java/com/uber/nullaway/dataflow/CoreNullnessStoreInitializer.java
Patch:
@@ -18,10 +18,10 @@
 import com.uber.nullaway.handlers.Handler;
 import java.util.List;
 import java.util.Objects;
-import javax.annotation.Nullable;
 import javax.lang.model.element.Element;
 import org.checkerframework.nullaway.dataflow.cfg.UnderlyingAST;
 import org.checkerframework.nullaway.dataflow.cfg.node.LocalVariableNode;
+import org.jspecify.annotations.Nullable;
 
 class CoreNullnessStoreInitializer extends NullnessStoreInitializer {
 
@@ -144,7 +144,7 @@ private static NullnessStore lambdaInitialStore(
     return result.build();
   }
 
-  @Nullable private CodeAnnotationInfo codeAnnotationInfo;
+  private @Nullable CodeAnnotationInfo codeAnnotationInfo;
 
   private CodeAnnotationInfo getCodeAnnotationInfo(Context context) {
     if (codeAnnotationInfo == null) {

File: nullaway/src/main/java/com/uber/nullaway/dataflow/EnclosingEnvironmentNullness.java
Patch:
@@ -8,8 +8,8 @@
 import com.sun.tools.javac.util.Context;
 import java.util.LinkedHashMap;
 import java.util.Map;
-import javax.annotation.Nullable;
 import javax.lang.model.element.NestingKind;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Stores info on nullness of local variables in enclosing environments, used when performing
@@ -37,8 +37,7 @@ public void addEnvironmentMapping(Tree t, NullnessStore s) {
     environmentNullness.put(t, s);
   }
 
-  @Nullable
-  public NullnessStore getEnvironmentMapping(Tree t) {
+  public @Nullable NullnessStore getEnvironmentMapping(Tree t) {
     Preconditions.checkArgument(isValidTreeType(t));
     return environmentNullness.get(t);
   }

File: nullaway/src/main/java/com/uber/nullaway/dataflow/FieldOrMethodCallElement.java
Patch:
@@ -4,8 +4,8 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.Objects;
-import javax.annotation.Nullable;
 import javax.lang.model.element.Element;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Represents a (non-root) field or method call element of an AccessPath.
@@ -16,7 +16,7 @@
  */
 public class FieldOrMethodCallElement implements AccessPathElement {
   private final Element javaElement;
-  @Nullable private final ImmutableList<String> constantArguments;
+  private final @Nullable ImmutableList<String> constantArguments;
 
   public FieldOrMethodCallElement(Element javaElement, List<String> constantArguments) {
     this.javaElement = javaElement;

File: nullaway/src/main/java/com/uber/nullaway/dataflow/NullnessStore.java
Patch:
@@ -29,14 +29,14 @@
 import java.util.Set;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
-import javax.annotation.Nullable;
 import javax.lang.model.element.Element;
 import org.checkerframework.nullaway.dataflow.analysis.Store;
 import org.checkerframework.nullaway.dataflow.cfg.node.FieldAccessNode;
 import org.checkerframework.nullaway.dataflow.cfg.node.LocalVariableNode;
 import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
 import org.checkerframework.nullaway.dataflow.cfg.visualize.CFGVisualizer;
 import org.checkerframework.nullaway.dataflow.expression.JavaExpression;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Highly based on {@link com.google.errorprone.dataflow.LocalStore}, but for {@link AccessPath}s.
@@ -127,8 +127,7 @@ public Set<AccessPath> getAccessPathsWithValue(Nullness value) {
    * IteratorContentsKey} whose variable is {@code iteratorVar}, returns {@code p}. Otherwise,
    * returns {@code null}.
    */
-  @Nullable
-  public AccessPath getMapGetIteratorContentsAccessPath(LocalVariableNode iteratorVar) {
+  public @Nullable AccessPath getMapGetIteratorContentsAccessPath(LocalVariableNode iteratorVar) {
     for (AccessPath accessPath : contents.keySet()) {
       MapKey mapGetArg = accessPath.getMapGetArg();
       if (mapGetArg instanceof IteratorContentsKey) {

File: nullaway/src/main/java/com/uber/nullaway/dataflow/NullnessStoreInitializer.java
Patch:
@@ -11,10 +11,10 @@
 import com.uber.nullaway.handlers.Handler;
 import java.util.List;
 import java.util.Objects;
-import javax.annotation.Nullable;
 import javax.lang.model.element.NestingKind;
 import org.checkerframework.nullaway.dataflow.cfg.UnderlyingAST;
 import org.checkerframework.nullaway.dataflow.cfg.node.LocalVariableNode;
+import org.jspecify.annotations.Nullable;
 
 /**
  * An abstract class that allows overriding initialization of nullness store in dataflow. Currently,
@@ -60,8 +60,7 @@ protected static NullnessStore getEnvNullnessStoreForClass(ClassTree classTree,
     return envStore;
   }
 
-  @Nullable
-  private static ClassTree findEnclosingLocalOrAnonymousClass(
+  private static @Nullable ClassTree findEnclosingLocalOrAnonymousClass(
       ClassTree classTree, Context context) {
     Symbol.ClassSymbol symbol = ASTHelpers.getSymbol(classTree);
     // we need this while loop since we can have a NestingKind.NESTED class (i.e., a nested

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/SerializationService.java
Patch:
@@ -39,7 +39,7 @@
 import java.util.Map;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
-import javax.annotation.Nullable;
+import org.jspecify.annotations.Nullable;
 
 /** A facade class to interact with fix serialization package. */
 public class SerializationService {

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/Serializer.java
Patch:
@@ -37,7 +37,7 @@
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
-import javax.annotation.Nullable;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Serializer class where all generated files in Fix Serialization package is created through APIs
@@ -181,8 +181,7 @@ private void appendToFile(String row, Path path) {
    * @param uri Given uri.
    * @return Real path for the give uri.
    */
-  @Nullable
-  public static Path pathToSourceFileFromURI(@Nullable URI uri) {
+  public static @Nullable Path pathToSourceFileFromURI(@Nullable URI uri) {
     if (uri == null) {
       return null;
     }

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/location/AbstractSymbolLocation.java
Patch:
@@ -30,8 +30,8 @@
 import com.uber.nullaway.fixserialization.Serializer;
 import java.net.URI;
 import java.nio.file.Path;
-import javax.annotation.Nullable;
 import javax.lang.model.element.ElementKind;
+import org.jspecify.annotations.Nullable;
 
 /** abstract base class for {@link SymbolLocation}. */
 public abstract class AbstractSymbolLocation implements SymbolLocation {
@@ -40,7 +40,7 @@ public abstract class AbstractSymbolLocation implements SymbolLocation {
   protected final ElementKind type;
 
   /** Path of the file containing the symbol, if available. */
-  @Nullable protected final Path path;
+  protected final @Nullable Path path;
 
   /** Enclosing class of the symbol. */
   protected final Symbol.ClassSymbol enclosingClass;

File: nullaway/src/main/java/com/uber/nullaway/handlers/AbstractFieldContractHandler.java
Patch:
@@ -36,10 +36,10 @@
 import com.uber.nullaway.handlers.contract.ContractUtils;
 import java.util.Collections;
 import java.util.Set;
-import javax.annotation.Nullable;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.VariableElement;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Abstract base class for handlers that process pre- and post-condition annotations for fields.

File: nullaway/src/main/java/com/uber/nullaway/handlers/ApacheThriftIsSetHandler.java
Patch:
@@ -37,11 +37,11 @@
 import com.uber.nullaway.dataflow.AccessPathNullnessPropagation;
 import java.util.Objects;
 import java.util.Optional;
-import javax.annotation.Nullable;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
 import org.checkerframework.nullaway.dataflow.cfg.node.Node;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Handler to better handle {@code isSetXXXX()} methods in code generated by Apache Thrift. With
@@ -111,9 +111,9 @@ private void updateNonNullAPsForElement(
 
   private static final class FieldAndGetterElements {
 
-    @Nullable final Element fieldElem;
+    final @Nullable Element fieldElem;
 
-    @Nullable final Element getterElem;
+    final @Nullable Element getterElem;
 
     public FieldAndGetterElements(@Nullable Element fieldElem, @Nullable Element getterElem) {
       this.fieldElem = fieldElem;

File: nullaway/src/main/java/com/uber/nullaway/handlers/AssertionHandler.java
Patch:
@@ -30,9 +30,9 @@
 import com.uber.nullaway.dataflow.AccessPath;
 import com.uber.nullaway.dataflow.AccessPathNullnessPropagation;
 import java.util.List;
-import javax.annotation.Nullable;
 import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
 import org.checkerframework.nullaway.dataflow.cfg.node.Node;
+import org.jspecify.annotations.Nullable;
 
 /** This Handler deals with assertions which ensure that their arguments cannot be null. */
 public class AssertionHandler extends BaseNoOpHandler {

File: nullaway/src/main/java/com/uber/nullaway/handlers/BaseNoOpHandler.java
Patch:
@@ -46,11 +46,11 @@
 import java.util.List;
 import java.util.Optional;
 import java.util.function.Predicate;
-import javax.annotation.Nullable;
 import org.checkerframework.nullaway.dataflow.cfg.UnderlyingAST;
 import org.checkerframework.nullaway.dataflow.cfg.node.FieldAccessNode;
 import org.checkerframework.nullaway.dataflow.cfg.node.LocalVariableNode;
 import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Provides a default (No-Op) implementation of every method defined by the Handler interface.
@@ -226,8 +226,7 @@ public MethodInvocationNode onCFGBuildPhase1AfterVisitMethodInvocation(
   }
 
   @Override
-  @Nullable
-  public Integer castToNonNullArgumentPositionsForMethod(
+  public @Nullable Integer castToNonNullArgumentPositionsForMethod(
       List<? extends ExpressionTree> actualParams,
       @Nullable Integer previousArgumentPosition,
       MethodAnalysisContext methodAnalysisContext) {

File: nullaway/src/main/java/com/uber/nullaway/handlers/CompositeHandler.java
Patch:
@@ -50,11 +50,11 @@
 import java.util.List;
 import java.util.Optional;
 import java.util.function.Predicate;
-import javax.annotation.Nullable;
 import org.checkerframework.nullaway.dataflow.cfg.UnderlyingAST;
 import org.checkerframework.nullaway.dataflow.cfg.node.FieldAccessNode;
 import org.checkerframework.nullaway.dataflow.cfg.node.LocalVariableNode;
 import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Registry of all handlers registered on our analysis.
@@ -298,8 +298,7 @@ public MethodInvocationNode onCFGBuildPhase1AfterVisitMethodInvocation(
   }
 
   @Override
-  @Nullable
-  public Integer castToNonNullArgumentPositionsForMethod(
+  public @Nullable Integer castToNonNullArgumentPositionsForMethod(
       List<? extends ExpressionTree> actualParams,
       @Nullable Integer previousArgumentPosition,
       MethodAnalysisContext methodAnalysisContext) {

File: nullaway/src/main/java/com/uber/nullaway/handlers/GrpcHandler.java
Patch:
@@ -42,12 +42,12 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Optional;
-import javax.annotation.Nullable;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.type.TypeKind;
 import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
 import org.checkerframework.nullaway.dataflow.cfg.node.Node;
+import org.jspecify.annotations.Nullable;
 
 public class GrpcHandler extends BaseNoOpHandler {
   private static final String GRPC_METADATA_TNAME = "io.grpc.Metadata";
@@ -124,8 +124,7 @@ public ImmutableSet<String> onRegisterImmutableTypes() {
     return ImmutableSet.of(GRPC_METADATA_KEY_TNAME);
   }
 
-  @Nullable
-  private Symbol.MethodSymbol getGetterForMetadataSubtype(
+  private Symbol.@Nullable MethodSymbol getGetterForMetadataSubtype(
       Symbol.ClassSymbol classSymbol, Types types) {
     // Is there a better way than iteration?
     for (Symbol elem : getEnclosedElements(classSymbol)) {

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handler.java
Patch:
@@ -47,11 +47,11 @@
 import java.util.List;
 import java.util.Optional;
 import java.util.function.Predicate;
-import javax.annotation.Nullable;
 import org.checkerframework.nullaway.dataflow.cfg.UnderlyingAST;
 import org.checkerframework.nullaway.dataflow.cfg.node.FieldAccessNode;
 import org.checkerframework.nullaway.dataflow.cfg.node.LocalVariableNode;
 import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
+import org.jspecify.annotations.Nullable;
 
 /**
  * The general interface representing a handler.
@@ -377,8 +377,7 @@ MethodInvocationNode onCFGBuildPhase1AfterVisitMethodInvocation(
    *     handler in the chain.
    * @param methodAnalysisContext The MethodAnalysisContext object
    */
-  @Nullable
-  Integer castToNonNullArgumentPositionsForMethod(
+  @Nullable Integer castToNonNullArgumentPositionsForMethod(
       List<? extends ExpressionTree> actualParams,
       @Nullable Integer previousArgumentPosition,
       MethodAnalysisContext methodAnalysisContext);

File: nullaway/src/main/java/com/uber/nullaway/handlers/InferredJARModelsHandler.java
Patch:
@@ -38,10 +38,10 @@
 import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
-import javax.annotation.Nullable;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.type.TypeKind;
 import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
+import org.jspecify.annotations.Nullable;
 
 /** This handler loads inferred nullability model from stubs for methods in unannotated packages. */
 public class InferredJARModelsHandler extends BaseNoOpHandler {
@@ -203,8 +203,8 @@ private boolean isReturnAnnotatedNullable(Symbol.MethodSymbol methodSymbol) {
     return false;
   }
 
-  @Nullable
-  private Map<Integer, Set<String>> lookupMethodInCache(String className, String methodSign) {
+  private @Nullable Map<Integer, Set<String>> lookupMethodInCache(
+      String className, String methodSign) {
     if (!argAnnotCache.containsKey(className)) {
       return null;
     }

File: nullaway/src/main/java/com/uber/nullaway/handlers/LombokHandler.java
Patch:
@@ -11,8 +11,8 @@
 import com.uber.nullaway.NullAway;
 import com.uber.nullaway.Nullness;
 import java.util.stream.StreamSupport;
-import javax.annotation.Nullable;
 import javax.lang.model.element.ElementKind;
+import org.jspecify.annotations.Nullable;
 
 /**
  * A general handler for Lombok generated code and its internal semantics.

File: nullaway/src/main/java/com/uber/nullaway/handlers/RestrictiveAnnotationHandler.java
Patch:
@@ -34,9 +34,9 @@
 import com.uber.nullaway.Nullness;
 import com.uber.nullaway.dataflow.AccessPath;
 import com.uber.nullaway.dataflow.AccessPathNullnessPropagation;
-import javax.annotation.Nullable;
 import org.checkerframework.nullaway.dataflow.cfg.node.FieldAccessNode;
 import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
+import org.jspecify.annotations.Nullable;
 
 public class RestrictiveAnnotationHandler extends BaseNoOpHandler {
 
@@ -88,7 +88,7 @@ && isSymbolRestrictivelyNullable(exprSymbol, state.context)) {
     return false;
   }
 
-  @Nullable private CodeAnnotationInfo codeAnnotationInfo;
+  private @Nullable CodeAnnotationInfo codeAnnotationInfo;
 
   private CodeAnnotationInfo getCodeAnnotationInfo(Context context) {
     if (codeAnnotationInfo == null) {

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/ContractHandler.java
Patch:
@@ -41,14 +41,14 @@
 import com.uber.nullaway.dataflow.cfg.NullAwayCFGBuilder;
 import com.uber.nullaway.handlers.BaseNoOpHandler;
 import java.util.Optional;
-import javax.annotation.Nullable;
 import javax.lang.model.type.TypeMirror;
 import org.checkerframework.nullaway.dataflow.cfg.node.AbstractNodeVisitor;
 import org.checkerframework.nullaway.dataflow.cfg.node.BinaryOperationNode;
 import org.checkerframework.nullaway.dataflow.cfg.node.EqualToNode;
 import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
 import org.checkerframework.nullaway.dataflow.cfg.node.Node;
 import org.checkerframework.nullaway.dataflow.cfg.node.NotEqualNode;
+import org.jspecify.annotations.Nullable;
 
 /**
  * This Handler parses the jetbrains @Contract annotation and honors the nullness spec defined there

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/ContractUtils.java
Patch:
@@ -10,9 +10,9 @@
 import com.uber.nullaway.NullabilityUtil;
 import java.util.Set;
 import java.util.stream.Collectors;
-import javax.annotation.Nullable;
 import javax.lang.model.element.AnnotationMirror;
 import org.checkerframework.nullaway.javacutil.AnnotationUtils;
+import org.jspecify.annotations.Nullable;
 
 /** An utility class for {@link ContractHandler} and {@link ContractCheckHandler}. */
 public class ContractUtils {
@@ -120,8 +120,7 @@ static String[] getAntecedent(
    * @param config the NullAway config
    * @return the value of a Contract annotation if present, or {@code null} if not present.
    */
-  @Nullable
-  static String getContractString(Symbol.MethodSymbol methodSymbol, Config config) {
+  static @Nullable String getContractString(Symbol.MethodSymbol methodSymbol, Config config) {
     for (AnnotationMirror annotation : methodSymbol.getAnnotationMirrors()) {
       String name = AnnotationUtils.annotationName(annotation);
       if (config.isContractAnnotation(name)) {

File: nullaway/src/main/java/com/uber/nullaway/handlers/stream/StreamModelBuilder.java
Patch:
@@ -30,7 +30,7 @@
 import com.google.errorprone.suppliers.Suppliers;
 import java.util.ArrayList;
 import java.util.List;
-import javax.annotation.Nullable;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Used to produce a new list of StreamTypeRecord models, where each model represents a class from a

File: sample/src/main/java/com/uber/mylib/Lambdas.java
Patch:
@@ -5,7 +5,7 @@
 import java.util.List;
 import java.util.function.BiFunction;
 import java.util.function.Function;
-import javax.annotation.Nullable;
+import org.jspecify.annotations.Nullable;
 
 /** Code that uses Java 8 lambdas */
 @SuppressWarnings("UnusedVariable") // This is sample code
@@ -14,8 +14,7 @@ public class Lambdas {
   @FunctionalInterface
   interface RetNullableFunction {
 
-    @Nullable
-    Object getVal();
+    @Nullable Object getVal();
   }
 
   public static void testLambda() {

File: sample/src/main/java/com/uber/mylib/MyClass.java
Patch:
@@ -1,6 +1,6 @@
 package com.uber.mylib;
 
-import javax.annotation.Nullable;
+import org.jspecify.annotations.Nullable;
 import org.utilities.StringUtils;
 
 /** A sample class. */

File: sample/src/main/java/org/utilities/StringUtils.java
Patch:
@@ -1,6 +1,6 @@
 package org.utilities;
 
-import javax.annotation.Nullable;
+import org.jspecify.annotations.Nullable;
 
 public class StringUtils {
 

File: test-java-lib-lombok/src/main/java/com/uber/lombok/LombokDTO.java
Patch:
@@ -22,9 +22,9 @@
 
 package com.uber.lombok;
 
-import javax.annotation.Nullable;
 import lombok.Builder;
 import lombok.Data;
+import org.jspecify.annotations.Nullable;
 
 @Builder
 @Data
@@ -35,6 +35,6 @@ public class LombokDTO {
   // issue an uninitialized field warning.
   private String field;
   @Builder.Default private String fieldWithDefault = "Default";
-  @Nullable private String nullableField;
-  @Nullable @Builder.Default private String fieldWithNullDefault = null;
+  private @Nullable String nullableField;
+  @Builder.Default private @Nullable String fieldWithNullDefault = null;
 }

File: test-java-lib-lombok/src/main/java/com/uber/lombok/UsesDTO.java
Patch:
@@ -22,7 +22,7 @@
 
 package com.uber.lombok;
 
-import javax.annotation.Nullable;
+import org.jspecify.annotations.Nullable;
 
 class UsesDTO {
 

File: test-java-lib/src/main/java/com/uber/lib/unannotated/AndroidRecentlyAnnotatedClass.java
Patch:
@@ -5,7 +5,8 @@
 
 public class AndroidRecentlyAnnotatedClass {
 
-  public static @RecentlyNullable Object returnsNull() {
+  @RecentlyNullable
+  public static Object returnsNull() {
     return null;
   }
 

File: test-java-lib/src/main/java/com/uber/lib/unannotated/RestrictivelyAnnotatedFI.java
Patch:
@@ -1,6 +1,6 @@
 package com.uber.lib.unannotated;
 
-import javax.annotation.Nullable;
+import org.jspecify.annotations.Nullable;
 
 public interface RestrictivelyAnnotatedFI {
 

File: test-java-lib/src/main/java/com/uber/lib/unannotated/RestrictivelyAnnotatedFIWithModelOverride.java
Patch:
@@ -1,9 +1,8 @@
 package com.uber.lib.unannotated;
 
-import javax.annotation.Nullable;
+import org.jspecify.annotations.Nullable;
 
 public interface RestrictivelyAnnotatedFIWithModelOverride {
 
-  @Nullable
-  Object apply(@Nullable Object o);
+  @Nullable Object apply(@Nullable Object o);
 }

File: jar-infer/jar-infer-lib/src/main/java/com/uber/nullaway/jarinfer/DefinitelyDerefedParams.java
Patch:
@@ -144,7 +144,7 @@ private Set<Integer> computeDerefParamList(int numParam, int firstParamIndex) {
     // only basic blocks which do not require p being non-null (e.g. by dereferencing it), then
     // mark p as @NonNull
     for (int i = firstParamIndex; i <= numParam; i++) {
-      final Integer param = i - 1;
+      Integer param = i - 1;
       if (!DFS.getReachableNodes(
               prunedCFG,
               ImmutableList.of(prunedCFG.entry()),

File: jar-infer/jar-infer-lib/src/main/java/com/uber/nullaway/jarinfer/DefinitelyDerefedParamsDriver.java
Patch:
@@ -419,7 +419,7 @@ private void writeModelJAR(String outPath) throws IOException {
   //  Note: Need version compatibility check between generated stub files and when reading models
   //    StubxWriter.VERSION_0_FILE_MAGIC_NUMBER (?)
   private void writeModel(DataOutputStream out) throws IOException {
-    Map<String, String> importedAnnotations =
+    ImmutableMap<String, String> importedAnnotations =
         ImmutableMap.<String, String>builder()
             .put("Nonnull", "javax.annotation.Nonnull")
             .put("Nullable", "javax.annotation.Nullable")
@@ -527,7 +527,7 @@ private static String getAstubxSignature(IMethod mtd) {
    * @return String Unqualified type name.
    */
   private static String getSimpleTypeName(TypeReference typ) {
-    final Map<String, String> mapFullTypeName =
+    ImmutableMap<String, String> mapFullTypeName =
         ImmutableMap.<String, String>builder()
             .put("B", "byte")
             .put("C", "char")

File: library-model/library-model-generator/src/main/java/com/uber/nullaway/libmodel/LibraryModelGenerator.java
Patch:
@@ -106,7 +106,7 @@ private void writeToAstubx(
     if (methodRecords.isEmpty() && nullableUpperBounds.isEmpty()) {
       return;
     }
-    Map<String, String> importedAnnotations =
+    ImmutableMap<String, String> importedAnnotations =
         ImmutableMap.of(
             "NonNull", "org.jspecify.annotations.NonNull",
             "Nullable", "org.jspecify.annotations.Nullable");
@@ -208,7 +208,8 @@ public void visit(ClassOrInterfaceDeclaration cid, Void arg) {
                 }
               });
       if (this.isNullMarked) {
-        Set<Integer> nullableUpperBoundParams = getGenericTypeParameterNullableUpperBounds(cid);
+        ImmutableSet<Integer> nullableUpperBoundParams =
+            getGenericTypeParameterNullableUpperBounds(cid);
         if (!nullableUpperBoundParams.isEmpty()) {
           nullableUpperBounds.put(parentName, nullableUpperBoundParams);
         }

File: library-model/library-model-generator/src/main/java/com/uber/nullaway/libmodel/StubxWriter.java
Patch:
@@ -45,7 +45,7 @@ public static void write(
     int numStringEntries = 0;
     Map<String, Integer> encodingDictionary = new LinkedHashMap<>();
     List<String> strings = new ArrayList<String>();
-    List<Collection<String>> keysets =
+    ImmutableList<Collection<String>> keysets =
         ImmutableList.of(
             importedAnnotations.values(),
             packageAnnotations.keySet(),

File: nullaway/src/main/java/com/uber/nullaway/CodeAnnotationInfo.java
Patch:
@@ -80,7 +80,7 @@ public static CodeAnnotationInfo instance(Context context) {
    */
   private static boolean fromAnnotatedPackage(
       Symbol.ClassSymbol outermostClassSymbol, Config config) {
-    final String className = outermostClassSymbol.getQualifiedName().toString();
+    String className = outermostClassSymbol.getQualifiedName().toString();
     Symbol.PackageSymbol enclosingPackage = ASTHelpers.enclosingPackage(outermostClassSymbol);
     if (!config.fromExplicitlyAnnotatedPackage(className)
         && !(enclosingPackage != null
@@ -165,7 +165,7 @@ public boolean isSymbolUnannotated(Symbol symbol, Config config, @Nullable Handl
     } else {
       classSymbol = castToNonNull(ASTHelpers.enclosingClass(symbol));
     }
-    final ClassCacheRecord classCacheRecord = get(classSymbol, config, handler);
+    ClassCacheRecord classCacheRecord = get(classSymbol, config, handler);
     boolean inAnnotatedClass = classCacheRecord.isNullnessAnnotated;
     if (symbol.getKind().equals(ElementKind.METHOD)
         || symbol.getKind().equals(ElementKind.CONSTRUCTOR)) {

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPathNullnessPropagation.java
Patch:
@@ -179,7 +179,7 @@ public AccessPathNullnessPropagation(
     this.nullnessStoreInitializer = nullnessStoreInitializer;
   }
 
-  private static SubNodeValues values(final TransferInput<Nullness, NullnessStore> input) {
+  private static SubNodeValues values(TransferInput<Nullness, NullnessStore> input) {
     return new SubNodeValues() {
       @Override
       public Nullness valueOfSubNode(Node node) {

File: nullaway/src/main/java/com/uber/nullaway/dataflow/CoreNullnessStoreInitializer.java
Patch:
@@ -100,7 +100,7 @@ private static NullnessStore lambdaInitialStore(
         types.memberType(ASTHelpers.getType(code), fiMethodSymbol).getParameterTypes();
     // If fiArgumentPositionNullness[i] == null, parameter position i is unannotated
     Nullness[] fiArgumentPositionNullness = new Nullness[fiMethodParameters.size()];
-    final boolean isFIAnnotated =
+    boolean isFIAnnotated =
         !codeAnnotationInfo.isSymbolUnannotated(fiMethodSymbol, config, handler);
     if (isFIAnnotated) {
       for (int i = 0; i < fiMethodParameters.size(); i++) {

File: nullaway/src/main/java/com/uber/nullaway/handlers/CompositeHandler.java
Patch:
@@ -64,7 +64,7 @@
  */
 class CompositeHandler implements Handler {
 
-  private final List<Handler> handlers;
+  private final ImmutableList<Handler> handlers;
 
   CompositeHandler(ImmutableList<Handler> handlers) {
     // Attach default handlers

File: nullaway/src/main/java/com/uber/nullaway/handlers/FieldInitializationSerializationHandler.java
Patch:
@@ -82,7 +82,7 @@ public void onNonNullFieldAssignment(
     if (methodSymbol.getKind() == ElementKind.CONSTRUCTOR) {
       return;
     }
-    final String fieldName = field.getSimpleName().toString();
+    String fieldName = field.getSimpleName().toString();
     boolean leavesNonNullAtExitPoint =
         analysis.getNonnullFieldsOfReceiverAtExit(pathToMethod, state.context).stream()
             .anyMatch(element -> element.getSimpleName().toString().equals(fieldName));

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handlers.java
Patch:
@@ -43,7 +43,7 @@ private Handlers() {}
    */
   public static Handler buildDefault(Config config) {
     ImmutableList.Builder<Handler> handlerListBuilder = ImmutableList.builder();
-    final MethodNameUtil methodNameUtil = new MethodNameUtil();
+    MethodNameUtil methodNameUtil = new MethodNameUtil();
 
     if (config.acknowledgeRestrictiveAnnotations()) {
       // This runs before LibraryModelsHandler, so that library models can override third-party

File: nullaway/src/main/java/com/uber/nullaway/handlers/StreamNullabilityPropagator.java
Patch:
@@ -26,7 +26,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.Multimap;
+import com.google.common.collect.SetMultimap;
 import com.google.errorprone.VisitorState;
 import com.google.errorprone.util.ASTHelpers;
 import com.sun.source.tree.ClassTree;
@@ -144,7 +144,7 @@ static CollectRecordAndInnerMethod create(
   // or lambda) pairs.
   // We need a Multimap here since there may be multiple relevant methods / lambdas.
   // E.g.: stream.filter(...).collect(Collectors.toMap(l1, l2)) => (record for toMap, {l1,l2})
-  private final Multimap<MethodInvocationTree, CollectRecordAndInnerMethod>
+  private final SetMultimap<MethodInvocationTree, CollectRecordAndInnerMethod>
       collectCallToRecordsAndInnerMethodsOrLambdas = LinkedHashMultimap.create();
 
   // Map from map or collect method (or lambda) to corresponding previous filter method (e.g.

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/ContractCheckHandler.java
Patch:
@@ -102,8 +102,8 @@ public void onMatchMethod(MethodTree tree, MethodAnalysisContext methodAnalysisC
         @Override
         public Void visitReturn(ReturnTree returnTree, Void unused) {
 
-          final VisitorState returnState = state.withPath(getCurrentPath());
-          final Nullness nullness =
+          VisitorState returnState = state.withPath(getCurrentPath());
+          Nullness nullness =
               analysis
                   .getNullnessAnalysis(returnState)
                   .getNullnessForContractDataflow(

File: sample/src/main/java/org/utilities/StringUtils.java
Patch:
@@ -4,7 +4,7 @@
 
 public class StringUtils {
 
-  public static boolean isEmptyOrNull(@Nullable final CharSequence value) {
+  public static boolean isEmptyOrNull(@Nullable CharSequence value) {
     return value == null || value.length() == 0;
   }
 }

File: nullaway/src/test/java/com/uber/nullaway/jspecify/GenericsTests.java
Patch:
@@ -3,6 +3,7 @@
 import com.google.errorprone.CompilationTestHelper;
 import com.uber.nullaway.NullAwayTestsBase;
 import java.util.Arrays;
+import java.util.List;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -1765,6 +1766,7 @@ public void testUseOfUnannotatedCode() {
         .doTest();
   }
 
+  @Test
   public void boxInteger() {
     makeHelper()
         .addSourceLines(
@@ -1796,6 +1798,6 @@ private CompilationTestHelper makeHelper() {
   }
 
   private CompilationTestHelper makeHelperWithoutJSpecifyMode() {
-    return makeTestHelperWithArgs(Arrays.asList("-XepOpt:NullAway:AnnotatedPackages=com.uber"));
+    return makeTestHelperWithArgs(List.of("-XepOpt:NullAway:AnnotatedPackages=com.uber"));
   }
 }

File: nullaway/src/main/java/com/uber/nullaway/handlers/StreamNullabilityPropagator.java
Patch:
@@ -254,13 +254,13 @@ private void handleFilterMethod(
       MethodInvocationTree tree, StreamTypeRecord streamType, VisitorState state) {
     ExpressionTree argTree = tree.getArguments().get(0);
     if (argTree instanceof NewClassTree) {
-      ClassTree annonClassBody = ((NewClassTree) argTree).getClassBody();
+      ClassTree anonClassBody = ((NewClassTree) argTree).getClassBody();
       // Ensure that this `new A() ...` has a custom class body, otherwise, we skip for now.
       // In the future, we could look at the declared type and its inheritance chain, at least
       // for
       // filters.
-      if (annonClassBody != null) {
-        handleFilterAnonClass(streamType, tree, annonClassBody, state);
+      if (anonClassBody != null) {
+        handleFilterAnonClass(streamType, tree, anonClassBody, state);
       }
     } else if (argTree instanceof LambdaExpressionTree) {
       LambdaExpressionTree lambdaTree = (LambdaExpressionTree) argTree;

File: nullaway/src/main/java/com/uber/nullaway/LibraryModels.java
Patch:
@@ -186,8 +186,8 @@ default ImmutableList<StreamTypeRecord> customStreamNullabilitySpecs() {
    * principles:
    *
    * <ul>
-   *   <li>signature is a method name plus argument types, e.g., <code>foo(java.lang.Object,
-   *  java.lang.String)</code>
+   *   <li>signature is a method name plus argument types, with no spaces between the argument
+   *       types, e.g., <code>foo(java.lang.Object,java.lang.String)</code>
    *   <li>constructor for class Foo looks like <code>Foo(java.lang.String)</code>
    *   <li>If the method has its own type parameters, they need to be declared, like <code>
    *       &lt;T&gt;checkNotNull(T)</code>

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -495,7 +495,7 @@ public Description matchAssignment(AssignmentTree tree, VisitorState state) {
       doUnboxingCheck(state, tree.getExpression());
     }
     // generics check
-    if (lhsType != null && lhsType.getTypeArguments().length() > 0 && config.isJSpecifyMode()) {
+    if (lhsType != null && config.isJSpecifyMode()) {
       GenericsChecks.checkTypeParameterNullnessForAssignability(tree, this, state);
     }
 

File: nullaway/src/main/java/com/uber/nullaway/dataflow/cfg/NullAwayCFGBuilder.java
Patch:
@@ -223,7 +223,7 @@ public <R, D> R accept(TreeVisitor<R, D> visitor, D data) {
 
     @Override
     public MethodInvocationNode visitMethodInvocation(MethodInvocationTree tree, Void p) {
-      MethodInvocationNode originalNode = super.visitMethodInvocation(tree, p);
+      MethodInvocationNode originalNode = super.visitMethodInvocation(tree, null);
       return handler.onCFGBuildPhase1AfterVisitMethodInvocation(this, tree, originalNode);
     }
   }

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/ContractCheckHandler.java
Patch:
@@ -156,7 +156,7 @@ public Void visitReturn(ReturnTree returnTree, Void unused) {
                         returnState,
                         null));
           }
-          return super.visitReturn(returnTree, unused);
+          return super.visitReturn(returnTree, null);
         }
       }.scan(state.getPath(), null);
     }

File: nullaway/src/main/java/com/uber/nullaway/LibraryModels.java
Patch:
@@ -196,7 +196,7 @@ default ImmutableList<StreamTypeRecord> customStreamNullabilitySpecs() {
    *  </code>
    * </ul>
    */
-  final class MethodRef {
+  public final class MethodRef {
 
     public final String enclosingClass;
 

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -463,7 +463,8 @@ private void updateEnvironmentMapping(TreePath treePath, VisitorState state) {
     // 2. we keep info on all locals rather than just effectively final ones for simplicity
     EnclosingEnvironmentNullness.instance(state.context)
         .addEnvironmentMapping(
-            treePath.getLeaf(), analysis.getNullnessInfoBeforeNewContext(treePath, state, handler));
+            treePath.getLeaf(),
+            analysis.getNullnessInfoBeforeNestedMethodNode(treePath, state, handler));
   }
 
   private Symbol.MethodSymbol getSymbolOfSuperConstructor(

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handlers.java
Patch:
@@ -69,6 +69,7 @@ public static Handler buildDefault(Config config) {
     handlerListBuilder.add(new GrpcHandler());
     handlerListBuilder.add(new RequiresNonNullHandler());
     handlerListBuilder.add(new EnsuresNonNullHandler());
+    handlerListBuilder.add(new SynchronousCallbackHandler());
     if (config.serializationIsActive() && config.getSerializationConfig().fieldInitInfoEnabled) {
       handlerListBuilder.add(
           new FieldInitializationSerializationHandler(config.getSerializationConfig()));

File: nullaway/src/test/resources/com/uber/nullaway/testdata/NullAwayStreamSupportPositiveCases.java
Patch:
@@ -191,7 +191,8 @@ private Stream<T> test1(Stream<T> stream) {
 
     private Stream<T> test2(Stream<T> stream) {
       Preconditions.checkNotNull(ref);
-      // BUG: Diagnostic contains: dereferenced expression ref is @Nullable
+      // no error since we propagate nullability facts to stream callbacks, which
+      // in sane code are invoked soon after the stream is created
       return stream.filter(s -> ref.equals(s));
     }
   }

File: jdk-recent-unit-tests/src/test/java/com/uber/nullaway/jdk17/InstanceOfBindingTests.java
Patch:
@@ -8,7 +8,7 @@
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
-public class NullAwayInstanceOfBindingTests {
+public class InstanceOfBindingTests {
 
   @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();
 

File: jdk-recent-unit-tests/src/test/java/com/uber/nullaway/jdk17/ModuleInfoTests.java
Patch:
@@ -8,7 +8,7 @@
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
-public class NullAwayModuleInfoTests {
+public class ModuleInfoTests {
 
   @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();
 

File: jdk-recent-unit-tests/src/test/java/com/uber/nullaway/jdk17/OptionalEmptyTests.java
Patch:
@@ -10,7 +10,7 @@
 import org.junit.rules.TemporaryFolder;
 
 /** Tests for support of the {@code Optional.isEmpty()} API. This API was introduced in JDK 11. */
-public class NullAwayOptionalEmptyTests {
+public class OptionalEmptyTests {
 
   @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();
 

File: jdk-recent-unit-tests/src/test/java/com/uber/nullaway/jdk17/RecordTests.java
Patch:
@@ -8,7 +8,7 @@
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
-public class NullAwayRecordTests {
+public class RecordTests {
 
   @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();
 

File: jdk-recent-unit-tests/src/test/java/com/uber/nullaway/jdk17/SwitchTests.java
Patch:
@@ -30,7 +30,7 @@
 import org.junit.rules.TemporaryFolder;
 
 /** NullAway unit tests involving language features available on JDK 17 but not JDK 11. */
-public class NullAwaySwitchTests {
+public class SwitchTests {
 
   @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();
 

File: nullaway/src/test/java/com/uber/nullaway/AccessPathsTests.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.junit.Test;
 
-public class NullAwayAccessPathsTests extends NullAwayTestsBase {
+public class AccessPathsTests extends NullAwayTestsBase {
 
   @Test
   public void testConstantsInAccessPathsNegative() {

File: nullaway/src/test/java/com/uber/nullaway/AcknowledgeRestrictiveAnnotationsTests.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.Arrays;
 import org.junit.Test;
 
-public class NullAwayAcknowledgeRestrictiveAnnotationsTests extends NullAwayTestsBase {
+public class AcknowledgeRestrictiveAnnotationsTests extends NullAwayTestsBase {
 
   @Test
   public void generatedAsUnannotatedPlusRestrictive() {

File: nullaway/src/test/java/com/uber/nullaway/AndroidTest.java
Patch:
@@ -11,7 +11,7 @@
 
 /** Unit tests for {@link com.uber.nullaway.NullAway}. */
 @RunWith(JUnit4.class)
-public class NullAwayAndroidTest {
+public class AndroidTest {
   @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();
 
   private CompilationTestHelper compilationHelper;

File: nullaway/src/test/java/com/uber/nullaway/AssertionLibsTests.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.Arrays;
 import org.junit.Test;
 
-public class NullAwayAssertionLibsTests extends NullAwayTestsBase {
+public class AssertionLibsTests extends NullAwayTestsBase {
 
   @Test
   public void supportTruthAssertThatIsNotNull_Object() {

File: nullaway/src/test/java/com/uber/nullaway/AutoSuggestNoCastTest.java
Patch:
@@ -30,7 +30,7 @@
 import org.junit.runners.JUnit4;
 
 @RunWith(JUnit4.class)
-public class NullAwayAutoSuggestNoCastTest {
+public class AutoSuggestNoCastTest {
 
   @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();
 

File: nullaway/src/test/java/com/uber/nullaway/AutoSuggestTest.java
Patch:
@@ -35,7 +35,7 @@
 import org.junit.runners.JUnit4;
 
 @RunWith(JUnit4.class)
-public class NullAwayAutoSuggestTest {
+public class AutoSuggestTest {
 
   @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();
 

File: nullaway/src/test/java/com/uber/nullaway/BytecodeInteractionsTests.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.junit.Test;
 
-public class NullAwayBytecodeInteractionsTests extends NullAwayTestsBase {
+public class BytecodeInteractionsTests extends NullAwayTestsBase {
   @Test
   public void typeUseJarReturn() {
     defaultCompilationHelper

File: nullaway/src/test/java/com/uber/nullaway/ContractsBooleanTests.java
Patch:
@@ -4,7 +4,7 @@
 import java.util.Arrays;
 import org.junit.Test;
 
-public class NullAwayContractsBooleanTests extends NullAwayTestsBase {
+public class ContractsBooleanTests extends NullAwayTestsBase {
 
   @Test
   public void nonNullCheckIsTrueIsNotNullable() {

File: nullaway/src/test/java/com/uber/nullaway/ContractsTests.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.Arrays;
 import org.junit.Test;
 
-public class NullAwayContractsTests extends NullAwayTestsBase {
+public class ContractsTests extends NullAwayTestsBase {
 
   @Test
   public void checkContractPositiveCases() {

File: nullaway/src/test/java/com/uber/nullaway/CoreTests.java
Patch:
@@ -29,7 +29,7 @@
 
 /** Unit tests for {@link com.uber.nullaway.NullAway}. */
 @RunWith(JUnit4.class)
-public class NullAwayCoreTests extends NullAwayTestsBase {
+public class CoreTests extends NullAwayTestsBase {
 
   @Test
   public void coreNullabilityPositiveCases() {

File: nullaway/src/test/java/com/uber/nullaway/CustomLibraryModelsTests.java
Patch:
@@ -29,7 +29,7 @@
 import java.util.List;
 import org.junit.Test;
 
-public class NullAwayCustomLibraryModelsTests extends NullAwayTestsBase {
+public class CustomLibraryModelsTests extends NullAwayTestsBase {
 
   private CompilationTestHelper makeLibraryModelsTestHelperWithArgs(List<String> args) {
     // Adding directly to args will throw an UnsupportedOperationException, since that list is

File: nullaway/src/test/java/com/uber/nullaway/EnsuresNonNullTests.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.junit.Test;
 
-public class NullAwayEnsuresNonNullTests extends NullAwayTestsBase {
+public class EnsuresNonNullTests extends NullAwayTestsBase {
 
   @Test
   public void requiresNonNullInterpretation() {

File: nullaway/src/test/java/com/uber/nullaway/FrameworkTests.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.Arrays;
 import org.junit.Test;
 
-public class NullAwayFrameworkTests extends NullAwayTestsBase {
+public class FrameworkTests extends NullAwayTestsBase {
   @Test
   public void lombokSupportTesting() {
     defaultCompilationHelper.addSourceFile("lombok/LombokBuilderInit.java").doTest();

File: nullaway/src/test/java/com/uber/nullaway/FunctionalInterfaceNullabilityTests.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.Arrays;
 import org.junit.Test;
 
-public class NullAwayFunctionalInterfaceNullabilityTests extends NullAwayTestsBase {
+public class FunctionalInterfaceNullabilityTests extends NullAwayTestsBase {
 
   @Test
   public void multipleTypeParametersInstantiation() {

File: nullaway/src/test/java/com/uber/nullaway/GuavaAssertionsTests.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.Arrays;
 import org.junit.Test;
 
-public class NullAwayGuavaAssertionsTests extends NullAwayTestsBase {
+public class GuavaAssertionsTests extends NullAwayTestsBase {
 
   @Test
   public void checkNotNullTest() {

File: nullaway/src/test/java/com/uber/nullaway/InitializationTests.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.Arrays;
 import org.junit.Test;
 
-public class NullAwayInitializationTests extends NullAwayTestsBase {
+public class InitializationTests extends NullAwayTestsBase {
   @Test
   public void initFieldPositiveCases() {
     defaultCompilationHelper.addSourceFile("CheckFieldInitPositiveCases.java").doTest();

File: nullaway/src/test/java/com/uber/nullaway/Java8Tests.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.junit.Test;
 
-public class NullAwayJava8Tests extends NullAwayTestsBase {
+public class Java8Tests extends NullAwayTestsBase {
   @Test
   public void java8PositiveCases() {
     defaultCompilationHelper.addSourceFile("NullAwayJava8PositiveCases.java").doTest();

File: nullaway/src/test/java/com/uber/nullaway/KeySetIteratorTests.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.junit.Test;
 
-public class NullAwayKeySetIteratorTests extends NullAwayTestsBase {
+public class KeySetIteratorTests extends NullAwayTestsBase {
 
   @Test
   public void mapKeySetIteratorBasic() {

File: nullaway/src/test/java/com/uber/nullaway/OptionalEmptinessTests.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.Arrays;
 import org.junit.Test;
 
-public class NullAwayOptionalEmptinessTests extends NullAwayTestsBase {
+public class OptionalEmptinessTests extends NullAwayTestsBase {
 
   @Test
   public void optionalEmptinessHandlerTest() {

File: nullaway/src/test/java/com/uber/nullaway/SerializationTest.java
Patch:
@@ -56,7 +56,7 @@
 
 /** Unit tests for {@link com.uber.nullaway.NullAway}. */
 @RunWith(JUnit4.class)
-public class NullAwaySerializationTest extends NullAwayTestsBase {
+public class SerializationTest extends NullAwayTestsBase {
   private String configPath;
   private Path root;
   private final DisplayFactory<FixDisplay> fixDisplayFactory;
@@ -71,7 +71,7 @@ public class NullAwaySerializationTest extends NullAwayTestsBase {
   private static final String FIELD_INIT_FILE_NAME = "field_init.tsv";
   private static final String FIELD_INIT_HEADER = FieldInitializationInfo.header();
 
-  public NullAwaySerializationTest() {
+  public SerializationTest() {
     this.fixDisplayFactory =
         values -> {
           Preconditions.checkArgument(

File: nullaway/src/test/java/com/uber/nullaway/ThriftTests.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.Arrays;
 import org.junit.Test;
 
-public class NullAwayThriftTests extends NullAwayTestsBase {
+public class ThriftTests extends NullAwayTestsBase {
   @Test
   public void testThriftIsSet() {
     defaultCompilationHelper

File: nullaway/src/test/java/com/uber/nullaway/UnannotatedTests.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.Arrays;
 import org.junit.Test;
 
-public class NullAwayUnannotatedTests extends NullAwayTestsBase {
+public class UnannotatedTests extends NullAwayTestsBase {
 
   @Test
   public void coreNullabilitySkipClass() {

File: nullaway/src/test/java/com/uber/nullaway/UnsoundnessTests.java
Patch:
@@ -6,7 +6,7 @@
 import org.junit.Test;
 
 /** Unit tests showing cases where NullAway is unsound. Useful for documentation purposes. */
-public class NullAwayUnsoundnessTests extends NullAwayTestsBase {
+public class UnsoundnessTests extends NullAwayTestsBase {
 
   @Before
   @Override

File: nullaway/src/test/java/com/uber/nullaway/VarargsTests.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.Arrays;
 import org.junit.Test;
 
-public class NullAwayVarargsTests extends NullAwayTestsBase {
+public class VarargsTests extends NullAwayTestsBase {
 
   @Test
   public void testNonNullVarargs() {

File: nullaway/src/test/java/com/uber/nullaway/jspecify/ArrayTests.java
Patch:
@@ -1,10 +1,11 @@
-package com.uber.nullaway;
+package com.uber.nullaway.jspecify;
 
 import com.google.errorprone.CompilationTestHelper;
+import com.uber.nullaway.NullAwayTestsBase;
 import java.util.Arrays;
 import org.junit.Test;
 
-public class NullAwayJSpecifyArrayTests extends NullAwayTestsBase {
+public class ArrayTests extends NullAwayTestsBase {
 
   @Test
   public void arrayTopLevelAnnotationDereference() {

File: nullaway/src/test/java/com/uber/nullaway/jspecify/GenericMethodTests.java
Patch:
@@ -1,11 +1,12 @@
-package com.uber.nullaway;
+package com.uber.nullaway.jspecify;
 
 import com.google.errorprone.CompilationTestHelper;
+import com.uber.nullaway.NullAwayTestsBase;
 import java.util.Arrays;
 import org.junit.Ignore;
 import org.junit.Test;
 
-public class NullAwayJSpecifyGenericMethodTests extends NullAwayTestsBase {
+public class GenericMethodTests extends NullAwayTestsBase {
 
   @Test
   @Ignore("requires generic method support")

File: nullaway/src/test/java/com/uber/nullaway/jspecify/GenericsTests.java
Patch:
@@ -1,11 +1,12 @@
-package com.uber.nullaway;
+package com.uber.nullaway.jspecify;
 
 import com.google.errorprone.CompilationTestHelper;
+import com.uber.nullaway.NullAwayTestsBase;
 import java.util.Arrays;
 import org.junit.Ignore;
 import org.junit.Test;
 
-public class NullAwayJSpecifyGenericsTests extends NullAwayTestsBase {
+public class GenericsTests extends NullAwayTestsBase {
 
   @Test
   public void basicTypeParamInstantiation() {

File: nullaway/src/test/java/com/uber/nullaway/jspecify/NullMarkednessTests.java
Patch:
@@ -1,9 +1,10 @@
-package com.uber.nullaway;
+package com.uber.nullaway.jspecify;
 
+import com.uber.nullaway.NullAwayTestsBase;
 import java.util.Arrays;
 import org.junit.Test;
 
-public class NullAwayJSpecifyTests extends NullAwayTestsBase {
+public class NullMarkednessTests extends NullAwayTestsBase {
 
   @Test
   public void nullMarkedPackageLevel() {

File: nullaway/src/test/java/com/uber/nullaway/thirdpartylibs/GrpcTest.java
Patch:
@@ -35,7 +35,7 @@
 /** Unit tests for {@link com.uber.nullaway.NullAway}. */
 @RunWith(JUnit4.class)
 @SuppressWarnings("CheckTestExtendsBaseClass")
-public class NullAwayGrpcTest {
+public class GrpcTest {
 
   @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();
 

File: nullaway/src/test/resources/com/uber/nullaway/testdata/unannotated/MinimalUnannotatedClass.java
Patch:
@@ -22,8 +22,10 @@
 
 package com.uber.nullaway.testdata.unannotated;
 
+import com.uber.nullaway.SerializationTest;
+
 /**
- * A minimal class, used from {@link com.uber.nullaway.NullAwaySerializationTest} to avoid extra
+ * A minimal class, used from {@link SerializationTest} to avoid extra
  * fixes.
  */
 public class MinimalUnannotatedClass {

File: nullaway/src/main/java/com/uber/nullaway/handlers/InferredJARModelsHandler.java
Patch:
@@ -218,7 +218,8 @@ private boolean isReturnAnnotatedNullable(Symbol.MethodSymbol methodSymbol) {
         if (methodArgAnnotations != null) {
           Set<String> methodAnnotations = methodArgAnnotations.get(RETURN);
           if (methodAnnotations != null) {
-            if (methodAnnotations.contains("javax.annotation.Nullable")) {
+            if (methodAnnotations.contains("javax.annotation.Nullable")
+                || methodAnnotations.contains("org.jspecify.annotations.Nullable")) {
               LOG(DEBUG, "DEBUG", "Nullable return for method: " + methodSign);
               return true;
             }

File: nullaway/src/main/java/com/uber/nullaway/ErrorMessage.java
Patch:
@@ -58,6 +58,7 @@ public enum MessageTypes {
     PASS_NULLABLE_GENERIC,
     WRONG_OVERRIDE_RETURN_GENERIC,
     WRONG_OVERRIDE_PARAM_GENERIC,
+    ASSIGN_NULLABLE_TO_NONNULL_ARRAY,
   }
 
   public String getMessage() {

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -2326,7 +2326,7 @@ private boolean mayBeNullExpr(VisitorState state, ExpressionTree expr) {
         return true;
       case NEW_CLASS:
       case NEW_ARRAY:
-        // for string concatenation, auto-boxing
+      case ARRAY_TYPE:
       case LAMBDA_EXPRESSION:
         // Lambdas may return null, but the lambda literal itself should not be null
       case MEMBER_REFERENCE:
@@ -2485,7 +2485,8 @@ private Description matchDereference(
     if (baseExpressionSymbol != null) {
       if (baseExpressionSymbol.type.isPrimitive()
           || baseExpressionSymbol.getKind() == ElementKind.PACKAGE
-          || ElementUtils.isTypeElement(baseExpressionSymbol)) {
+          || ElementUtils.isTypeElement(baseExpressionSymbol)
+          || baseExpressionSymbol.getKind() == ElementKind.TYPE_PARAMETER) {
         // we know we don't have a null dereference here
         return Description.NO_MATCH;
       }

File: nullaway/src/main/java/com/uber/nullaway/generics/GenericsChecks.java
Patch:
@@ -1,7 +1,6 @@
 package com.uber.nullaway.generics;
 
 import static com.google.common.base.Verify.verify;
-import static com.uber.nullaway.NullabilityUtil.castToNonNull;
 
 import com.google.errorprone.VisitorState;
 import com.google.errorprone.suppliers.Supplier;
@@ -687,8 +686,7 @@ public static Nullness getGenericParameterNullnessAtInvocation(
       return Nullness.NONNULL;
     }
     Type enclosingType =
-        castToNonNull(
-            getTreeType(((MemberSelectTree) tree.getMethodSelect()).getExpression(), state));
+        getTreeType(((MemberSelectTree) tree.getMethodSelect()).getExpression(), state);
     return getGenericMethodParameterNullness(
         paramIndex, invokedMethodSymbol, enclosingType, state, config);
   }

File: nullaway/src/main/java/com/uber/nullaway/generics/CompareNullabilityVisitor.java
Patch:
@@ -22,7 +22,7 @@ public class CompareNullabilityVisitor extends Types.DefaultTypeVisitor<Boolean,
 
   @Override
   public Boolean visitClassType(Type.ClassType lhsType, Type rhsType) {
-    if (rhsType instanceof NullType) {
+    if (rhsType instanceof NullType || rhsType.isPrimitive()) {
       return true;
     }
     Types types = state.getTypes();

File: nullaway/src/main/java/com/uber/nullaway/NullabilityUtil.java
Patch:
@@ -362,7 +362,7 @@ public static boolean mayBeNullFieldFromType(
       Symbol symbol, Config config, CodeAnnotationInfo codeAnnotationInfo) {
     return !(symbol.getSimpleName().toString().equals("class")
             || symbol.isEnum()
-            || codeAnnotationInfo.isSymbolUnannotated(symbol, config))
+            || codeAnnotationInfo.isSymbolUnannotated(symbol, config, null))
         && Nullness.hasNullableAnnotation(symbol, config);
   }
 

File: nullaway/src/main/java/com/uber/nullaway/dataflow/CoreNullnessStoreInitializer.java
Patch:
@@ -100,7 +100,8 @@ private static NullnessStore lambdaInitialStore(
         types.memberType(ASTHelpers.getType(code), fiMethodSymbol).getParameterTypes();
     // If fiArgumentPositionNullness[i] == null, parameter position i is unannotated
     Nullness[] fiArgumentPositionNullness = new Nullness[fiMethodParameters.size()];
-    final boolean isFIAnnotated = !codeAnnotationInfo.isSymbolUnannotated(fiMethodSymbol, config);
+    final boolean isFIAnnotated =
+        !codeAnnotationInfo.isSymbolUnannotated(fiMethodSymbol, config, handler);
     if (isFIAnnotated) {
       for (int i = 0; i < fiMethodParameters.size(); i++) {
         if (Nullness.hasNullableAnnotation(fiMethodParameters.get(i), config)) {

File: nullaway/src/main/java/com/uber/nullaway/handlers/RestrictiveAnnotationHandler.java
Patch:
@@ -62,7 +62,7 @@ public class RestrictiveAnnotationHandler extends BaseNoOpHandler {
    */
   private boolean isSymbolRestrictivelyNullable(Symbol symbol, Context context) {
     CodeAnnotationInfo codeAnnotationInfo = getCodeAnnotationInfo(context);
-    return (codeAnnotationInfo.isSymbolUnannotated(symbol, config)
+    return (codeAnnotationInfo.isSymbolUnannotated(symbol, config, null)
         // with the generated-as-unannotated option enabled, we want to ignore annotations in
         // generated code no matter what
         && !(config.treatGeneratedAsUnannotated() && codeAnnotationInfo.isGenerated(symbol, config))

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/FixSerializationConfig.java
Patch:
@@ -100,7 +100,7 @@ public FixSerializationConfig(
   public FixSerializationConfig(String configFilePath, int serializationVersion) {
     Document document;
     try {
-      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+      DocumentBuilderFactory factory = XMLUtil.safeDocumentBuilderFactory();
       DocumentBuilder builder = factory.newDocumentBuilder();
       document = builder.parse(Files.newInputStream(Paths.get(configFilePath)));
       document.normalize();

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPathNullnessPropagation.java
Patch:
@@ -206,7 +206,7 @@ private static Node unwrapAssignExpr(Node node) {
   public NullnessStore initialStore(
       UnderlyingAST underlyingAST, List<LocalVariableNode> parameters) {
     return nullnessStoreInitializer.getInitialStore(
-        underlyingAST, parameters, handler, state.context, state.getTypes(), config);
+        underlyingAST, parameters, handler, state, config);
   }
 
   @Override

File: nullaway/src/main/java/com/uber/nullaway/handlers/BaseNoOpHandler.java
Patch:
@@ -120,7 +120,7 @@ public Nullness onOverrideMethodReturnNullability(
 
   @Override
   public Nullness[] onOverrideMethodInvocationParametersNullability(
-      Context context,
+      VisitorState state,
       Symbol.MethodSymbol methodSymbol,
       boolean isAnnotated,
       Nullness[] argumentPositionNullness) {

File: nullaway/src/main/java/com/uber/nullaway/handlers/CompositeHandler.java
Patch:
@@ -137,14 +137,14 @@ public Nullness onOverrideMethodReturnNullability(
 
   @Override
   public Nullness[] onOverrideMethodInvocationParametersNullability(
-      Context context,
+      VisitorState state,
       Symbol.MethodSymbol methodSymbol,
       boolean isAnnotated,
       Nullness[] argumentPositionNullness) {
     for (Handler h : handlers) {
       argumentPositionNullness =
           h.onOverrideMethodInvocationParametersNullability(
-              context, methodSymbol, isAnnotated, argumentPositionNullness);
+              state, methodSymbol, isAnnotated, argumentPositionNullness);
     }
     return argumentPositionNullness;
   }

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handler.java
Patch:
@@ -182,7 +182,7 @@ Nullness onOverrideMethodReturnNullability(
    * considered isAnnotated or not. We use a mutable map for performance, but it should not outlive
    * the chain of handler invocations.
    *
-   * @param context The current context.
+   * @param state The current visitor state.
    * @param methodSymbol The method symbol for the method in question.
    * @param isAnnotated A boolean flag indicating whether the called method is considered to be
    *     within isAnnotated or unannotated code, used to avoid querying for this information
@@ -195,7 +195,7 @@ Nullness onOverrideMethodReturnNullability(
    *     handler.
    */
   Nullness[] onOverrideMethodInvocationParametersNullability(
-      Context context,
+      VisitorState state,
       Symbol.MethodSymbol methodSymbol,
       boolean isAnnotated,
       Nullness[] argumentPositionNullness);

File: nullaway/src/main/java/com/uber/nullaway/handlers/InferredJARModelsHandler.java
Patch:
@@ -28,7 +28,6 @@
 import com.sun.source.tree.Tree;
 import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.code.Type;
-import com.sun.tools.javac.util.Context;
 import com.uber.nullaway.Config;
 import com.uber.nullaway.NullAway;
 import com.uber.nullaway.Nullness;
@@ -122,7 +121,7 @@ private void loadStubxFiles() {
 
   @Override
   public Nullness[] onOverrideMethodInvocationParametersNullability(
-      Context context,
+      VisitorState state,
       Symbol.MethodSymbol methodSymbol,
       boolean isAnnotated,
       Nullness[] argumentPositionNullness) {

File: nullaway/src/main/java/com/uber/nullaway/handlers/LibraryModelsHandler.java
Patch:
@@ -82,11 +82,11 @@ public LibraryModelsHandler(Config config) {
 
   @Override
   public Nullness[] onOverrideMethodInvocationParametersNullability(
-      Context context,
+      VisitorState state,
       Symbol.MethodSymbol methodSymbol,
       boolean isAnnotated,
       Nullness[] argumentPositionNullness) {
-    OptimizedLibraryModels optimizedLibraryModels = getOptLibraryModels(context);
+    OptimizedLibraryModels optimizedLibraryModels = getOptLibraryModels(state.context);
     ImmutableSet<Integer> nullableParamsFromModel =
         optimizedLibraryModels.explicitlyNullableParameters(methodSymbol);
     ImmutableSet<Integer> nonNullParamsFromModel =

File: nullaway/src/main/java/com/uber/nullaway/handlers/RestrictiveAnnotationHandler.java
Patch:
@@ -99,7 +99,7 @@ private CodeAnnotationInfo getCodeAnnotationInfo(Context context) {
 
   @Override
   public Nullness[] onOverrideMethodInvocationParametersNullability(
-      Context context,
+      VisitorState state,
       Symbol.MethodSymbol methodSymbol,
       boolean isAnnotated,
       Nullness[] argumentPositionNullness) {

File: nullaway/src/main/java/com/uber/nullaway/Nullness.java
Patch:
@@ -218,7 +218,7 @@ public static boolean paramHasNullableAnnotation(
       return true;
     }
     return hasNullableAnnotation(
-        NullabilityUtil.getAllAnnotationsForParameter(symbol, paramInd), config);
+        NullabilityUtil.getAllAnnotationsForParameter(symbol, paramInd, config), config);
   }
 
   private static boolean isRecordEqualsParam(Symbol.MethodSymbol symbol, int paramInd) {
@@ -249,6 +249,6 @@ private static boolean isRecordEqualsParam(Symbol.MethodSymbol symbol, int param
   public static boolean paramHasNonNullAnnotation(
       Symbol.MethodSymbol symbol, int paramInd, Config config) {
     return hasNonNullAnnotation(
-        NullabilityUtil.getAllAnnotationsForParameter(symbol, paramInd), config);
+        NullabilityUtil.getAllAnnotationsForParameter(symbol, paramInd, config), config);
   }
 }

File: nullaway/src/main/java/com/uber/nullaway/generics/CompareNullabilityVisitor.java
Patch:
@@ -24,7 +24,7 @@ public Boolean visitClassType(Type.ClassType lhsType, Type rhsType) {
     Types types = state.getTypes();
     // The base type of rhsType may be a subtype of lhsType's base type.  In such cases, we must
     // compare lhsType against the supertype of rhsType with a matching base type.
-    rhsType = (Type.ClassType) types.asSuper(rhsType, lhsType.tsym);
+    rhsType = types.asSuper(rhsType, lhsType.tsym);
     // This is impossible, considering the fact that standard Java subtyping succeeds before
     // running NullAway
     if (rhsType == null) {

File: nullaway/src/main/java/com/uber/nullaway/generics/PreservedAnnotationTreeVisitor.java
Patch:
@@ -42,7 +42,7 @@ public Type visitArrayType(ArrayTypeTree tree, Void p) {
   public Type visitParameterizedType(ParameterizedTypeTree tree, Void p) {
     Type.ClassType type = (Type.ClassType) ASTHelpers.getType(tree);
     Preconditions.checkNotNull(type);
-    Type nullableType = GenericsChecks.NULLABLE_TYPE_SUPPLIER.get(state);
+    Type nullableType = GenericsChecks.JSPECIFY_NULLABLE_TYPE_SUPPLIER.get(state);
     List<? extends Tree> typeArguments = tree.getTypeArguments();
     List<Type> newTypeArgs = new ArrayList<>();
     for (int i = 0; i < typeArguments.size(); i++) {

File: nullaway/src/main/java/com/uber/nullaway/ErrorBuilder.java
Patch:
@@ -92,7 +92,7 @@ public class ErrorBuilder {
    *     expression into a @NonNull target, and this parameter is the Symbol for that target.
    * @return the error description
    */
-  Description createErrorDescription(
+  public Description createErrorDescription(
       ErrorMessage errorMessage,
       Description.Builder descriptionBuilder,
       VisitorState state,

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -92,6 +92,7 @@
 import com.uber.nullaway.ErrorMessage.MessageTypes;
 import com.uber.nullaway.dataflow.AccessPathNullnessAnalysis;
 import com.uber.nullaway.dataflow.EnclosingEnvironmentNullness;
+import com.uber.nullaway.generics.GenericsChecks;
 import com.uber.nullaway.handlers.Handler;
 import com.uber.nullaway.handlers.Handlers;
 import java.util.ArrayList;

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPathNullnessPropagation.java
Patch:
@@ -35,9 +35,9 @@
 import com.sun.tools.javac.code.TypeTag;
 import com.uber.nullaway.CodeAnnotationInfo;
 import com.uber.nullaway.Config;
-import com.uber.nullaway.GenericsChecks;
 import com.uber.nullaway.NullabilityUtil;
 import com.uber.nullaway.Nullness;
+import com.uber.nullaway.generics.GenericsChecks;
 import com.uber.nullaway.handlers.Handler;
 import com.uber.nullaway.handlers.Handler.NullnessHint;
 import java.util.HashMap;

File: nullaway/src/main/java/com/uber/nullaway/GenericsChecks.java
Patch:
@@ -784,7 +784,7 @@ public static Nullness getGenericReturnNullnessAtInvocation(
       MethodInvocationTree tree,
       VisitorState state,
       Config config) {
-    if (!(tree.getMethodSelect() instanceof MemberSelectTree)) {
+    if (!(tree.getMethodSelect() instanceof MemberSelectTree) || invokedMethodSymbol.isStatic()) {
       return Nullness.NONNULL;
     }
     Type methodReceiverType =
@@ -834,7 +834,7 @@ public static Nullness getGenericParameterNullnessAtInvocation(
       MethodInvocationTree tree,
       VisitorState state,
       Config config) {
-    if (!(tree.getMethodSelect() instanceof MemberSelectTree)) {
+    if (!(tree.getMethodSelect() instanceof MemberSelectTree) || invokedMethodSymbol.isStatic()) {
       return Nullness.NONNULL;
     }
     Type enclosingType =

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -1962,7 +1962,8 @@ private SetMultimap<MethodTree, Symbol> checkConstructorInitialization(
   }
 
   private boolean symbolHasExternalInitAnnotation(Symbol symbol) {
-    return StreamSupport.stream(NullabilityUtil.getAllAnnotations(symbol).spliterator(), false)
+    return StreamSupport.stream(
+            NullabilityUtil.getAllAnnotations(symbol, config).spliterator(), false)
         .map((anno) -> anno.getAnnotationType().toString())
         .anyMatch(config::isExternalInitClassAnnotation);
   }
@@ -2219,7 +2220,7 @@ private boolean isInitializerMethod(VisitorState state, Symbol.MethodSymbol symb
   }
 
   private boolean skipDueToFieldAnnotation(Symbol fieldSymbol) {
-    return NullabilityUtil.getAllAnnotations(fieldSymbol)
+    return NullabilityUtil.getAllAnnotations(fieldSymbol, config)
         .map(anno -> anno.getAnnotationType().toString())
         .anyMatch(config::isExcludedFieldAnnotation);
   }

File: nullaway/src/main/java/com/uber/nullaway/Nullness.java
Patch:
@@ -192,7 +192,7 @@ private static boolean isNonNullAnnotation(String annotName, Config config) {
    * Config)}
    */
   public static boolean hasNonNullAnnotation(Symbol symbol, Config config) {
-    return hasNonNullAnnotation(NullabilityUtil.getAllAnnotations(symbol), config);
+    return hasNonNullAnnotation(NullabilityUtil.getAllAnnotations(symbol, config), config);
   }
 
   /**
@@ -203,7 +203,7 @@ public static boolean hasNonNullAnnotation(Symbol symbol, Config config) {
    * Config)}
    */
   public static boolean hasNullableAnnotation(Symbol symbol, Config config) {
-    return hasNullableAnnotation(NullabilityUtil.getAllAnnotations(symbol), config);
+    return hasNullableAnnotation(NullabilityUtil.getAllAnnotations(symbol, config), config);
   }
 
   /**

File: nullaway/src/test/java/com/uber/nullaway/NullAwayJSpecifyGenericsTests.java
Patch:
@@ -429,8 +429,7 @@ public void testForMethodReferenceInAnAssignment() {
             "    return o.toString();",
             "  }",
             "  static void testPositive() {",
-            "    // TODO: we should report an error here, since Test::foo cannot take",
-            "    // a @Nullable parameter.  we don't catch this yet",
+            "    // BUG: Diagnostic contains: parameter o of referenced method is @NonNull",
             "    A<@Nullable Object> p = Test::foo;",
             "  }",
             "  static void testNegative() {",

File: nullaway/src/main/java/com/uber/nullaway/ErrorMessage.java
Patch:
@@ -56,6 +56,8 @@ public enum MessageTypes {
     ASSIGN_GENERIC_NULLABLE,
     RETURN_NULLABLE_GENERIC,
     PASS_NULLABLE_GENERIC,
+    WRONG_OVERRIDE_RETURN_GENERIC,
+    WRONG_OVERRIDE_PARAM_GENERIC,
   }
 
   public String getMessage() {

File: nullaway/src/main/java/com/uber/nullaway/ASTHelpersBackports.java
Patch:
@@ -32,6 +32,7 @@ public static boolean isStatic(Symbol symbol) {
    * https://github.com/google/error-prone/blame/a1318e4b0da4347dff7508108835d77c470a7198/check_api/src/main/java/com/google/errorprone/util/ASTHelpers.java#L1148
    * TODO: delete this method and switch to ASTHelpers once we can require Error Prone 2.20.0
    */
+  @SuppressWarnings("ASTHelpersSuggestions")
   public static List<Symbol> getEnclosedElements(Symbol symbol) {
     return symbol.getEnclosedElements();
   }

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -1712,7 +1712,9 @@ private Description checkCastToNonNullTakesNullable(
                 + "at the invocation site, but which are known not to be null at runtime.";
         return errorBuilder.createErrorDescription(
             new ErrorMessage(MessageTypes.CAST_TO_NONNULL_ARG_NONNULL, message),
-            tree,
+            // The Tree passed as suggestTree is the expression being cast
+            // to avoid recomputing the arg index:
+            actual,
             buildDescription(tree),
             state,
             null);

File: nullaway/src/main/java/com/uber/nullaway/GenericsChecks.java
Patch:
@@ -478,7 +478,7 @@ public void compareGenericTypeParameterNullabilityForCall(
       // all remaining actual arguments in the next loop.
       n = n - 1;
     }
-    for (int i = 0; i < n - 1; i++) {
+    for (int i = 0; i < n; i++) {
       Type formalParameter = formalParams.get(i).type;
       if (!formalParameter.getTypeArguments().isEmpty()) {
         Type actualParameter = getTreeType(actualParams.get(i));

File: nullaway/src/main/java/com/uber/nullaway/ErrorBuilder.java
Patch:
@@ -22,6 +22,7 @@
 
 package com.uber.nullaway;
 
+import static com.uber.nullaway.ASTHelpersBackports.isStatic;
 import static com.uber.nullaway.ErrorMessage.MessageTypes.FIELD_NO_INIT;
 import static com.uber.nullaway.ErrorMessage.MessageTypes.GET_ON_EMPTY_OPTIONAL;
 import static com.uber.nullaway.ErrorMessage.MessageTypes.METHOD_NO_INIT;
@@ -479,9 +480,7 @@ void reportInitErrorOnField(Symbol symbol, VisitorState state, Description.Build
       fieldName = flatName.substring(index) + "." + fieldName;
     }
 
-    @SuppressWarnings("ASTHelpersSuggestions") // remove once we require EP 2.16 or greater
-    boolean isStatic = symbol.isStatic();
-    if (isStatic) {
+    if (isStatic(symbol)) {
       state.reportMatch(
           createErrorDescription(
               new ErrorMessage(

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPathNullnessPropagation.java
Patch:
@@ -16,6 +16,7 @@
 package com.uber.nullaway.dataflow;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.uber.nullaway.ASTHelpersBackports.isStatic;
 import static com.uber.nullaway.NullabilityUtil.castToNonNull;
 import static com.uber.nullaway.Nullness.BOTTOM;
 import static com.uber.nullaway.Nullness.NONNULL;
@@ -761,10 +762,9 @@ private CodeAnnotationInfo getCodeAnnotationInfo(VisitorState state) {
     return codeAnnotationInfo;
   }
 
-  @SuppressWarnings("ASTHelpersSuggestions") // remove once we require EP 2.16 or greater
   private void setReceiverNonnull(
       AccessPathNullnessPropagation.ReadableUpdates updates, Node receiver, Symbol symbol) {
-    if (symbol != null && !symbol.isStatic()) {
+    if ((symbol != null) && !isStatic(symbol)) {
       setNonnullIfAnalyzeable(updates, receiver);
     }
   }

File: nullaway/src/main/java/com/uber/nullaway/handlers/AbstractFieldContractHandler.java
Patch:
@@ -22,6 +22,7 @@
 
 package com.uber.nullaway.handlers;
 
+import static com.uber.nullaway.ASTHelpersBackports.getEnclosedElements;
 import static com.uber.nullaway.NullabilityUtil.castToNonNull;
 
 import com.google.common.base.Preconditions;
@@ -222,7 +223,7 @@ protected boolean validateAnnotationSyntax(
   public static @Nullable VariableElement getInstanceFieldOfClass(
       Symbol.ClassSymbol classSymbol, String name) {
     Preconditions.checkNotNull(classSymbol);
-    for (Element member : NullabilityUtil.getEnclosedElements(classSymbol)) {
+    for (Element member : getEnclosedElements(classSymbol)) {
       if (member.getKind().isField() && !member.getModifiers().contains(Modifier.STATIC)) {
         if (member.getSimpleName().toString().equals(name)) {
           return (VariableElement) member;

File: nullaway/src/main/java/com/uber/nullaway/handlers/ApacheThriftIsSetHandler.java
Patch:
@@ -21,6 +21,8 @@
  */
 package com.uber.nullaway.handlers;
 
+import static com.uber.nullaway.ASTHelpersBackports.getEnclosedElements;
+
 import com.google.common.base.Preconditions;
 import com.google.errorprone.VisitorState;
 import com.google.errorprone.suppliers.Supplier;
@@ -30,7 +32,6 @@
 import com.sun.tools.javac.code.Type;
 import com.sun.tools.javac.code.Types;
 import com.uber.nullaway.NullAway;
-import com.uber.nullaway.NullabilityUtil;
 import com.uber.nullaway.Nullness;
 import com.uber.nullaway.dataflow.AccessPath;
 import com.uber.nullaway.dataflow.AccessPathNullnessPropagation;
@@ -143,7 +144,7 @@ private FieldAndGetterElements getFieldAndGetterForProperty(
     Element getter = null;
     String fieldName = decapitalize(capPropName);
     String getterName = "get" + capPropName;
-    for (Symbol elem : NullabilityUtil.getEnclosedElements(symbol.owner)) {
+    for (Symbol elem : getEnclosedElements(symbol.owner)) {
       if (elem.getKind().isField() && elem.getSimpleName().toString().equals(fieldName)) {
         if (field != null) {
           throw new RuntimeException("already found field " + fieldName);

File: nullaway/src/main/java/com/uber/nullaway/handlers/GrpcHandler.java
Patch:
@@ -21,6 +21,7 @@
  */
 package com.uber.nullaway.handlers;
 
+import static com.uber.nullaway.ASTHelpersBackports.getEnclosedElements;
 import static com.uber.nullaway.NullabilityUtil.castToNonNull;
 
 import com.google.common.base.Preconditions;
@@ -35,7 +36,6 @@
 import com.sun.tools.javac.code.Type;
 import com.sun.tools.javac.code.Types;
 import com.uber.nullaway.NullAway;
-import com.uber.nullaway.NullabilityUtil;
 import com.uber.nullaway.Nullness;
 import com.uber.nullaway.dataflow.AccessPath;
 import com.uber.nullaway.dataflow.AccessPathNullnessPropagation;
@@ -123,7 +123,7 @@ public ImmutableSet<String> onRegisterImmutableTypes() {
   private Symbol.MethodSymbol getGetterForMetadataSubtype(
       Symbol.ClassSymbol classSymbol, Types types) {
     // Is there a better way than iteration?
-    for (Symbol elem : NullabilityUtil.getEnclosedElements(classSymbol)) {
+    for (Symbol elem : getEnclosedElements(classSymbol)) {
       if (elem.getKind().equals(ElementKind.METHOD)) {
         Symbol.MethodSymbol methodSymbol = (Symbol.MethodSymbol) elem;
         if (grpcIsMetadataGetCall(methodSymbol, types)) {

File: nullaway/src/main/java/com/uber/nullaway/handlers/AbstractFieldContractHandler.java
Patch:
@@ -222,7 +222,7 @@ protected boolean validateAnnotationSyntax(
   public static @Nullable VariableElement getInstanceFieldOfClass(
       Symbol.ClassSymbol classSymbol, String name) {
     Preconditions.checkNotNull(classSymbol);
-    for (Element member : classSymbol.getEnclosedElements()) {
+    for (Element member : NullabilityUtil.getEnclosedElements(classSymbol)) {
       if (member.getKind().isField() && !member.getModifiers().contains(Modifier.STATIC)) {
         if (member.getSimpleName().toString().equals(name)) {
           return (VariableElement) member;

File: nullaway/src/main/java/com/uber/nullaway/handlers/ApacheThriftIsSetHandler.java
Patch:
@@ -30,6 +30,7 @@
 import com.sun.tools.javac.code.Type;
 import com.sun.tools.javac.code.Types;
 import com.uber.nullaway.NullAway;
+import com.uber.nullaway.NullabilityUtil;
 import com.uber.nullaway.Nullness;
 import com.uber.nullaway.dataflow.AccessPath;
 import com.uber.nullaway.dataflow.AccessPathNullnessPropagation;
@@ -142,7 +143,7 @@ private FieldAndGetterElements getFieldAndGetterForProperty(
     Element getter = null;
     String fieldName = decapitalize(capPropName);
     String getterName = "get" + capPropName;
-    for (Symbol elem : symbol.owner.getEnclosedElements()) {
+    for (Symbol elem : NullabilityUtil.getEnclosedElements(symbol.owner)) {
       if (elem.getKind().isField() && elem.getSimpleName().toString().equals(fieldName)) {
         if (field != null) {
           throw new RuntimeException("already found field " + fieldName);

File: nullaway/src/main/java/com/uber/nullaway/handlers/GrpcHandler.java
Patch:
@@ -35,6 +35,7 @@
 import com.sun.tools.javac.code.Type;
 import com.sun.tools.javac.code.Types;
 import com.uber.nullaway.NullAway;
+import com.uber.nullaway.NullabilityUtil;
 import com.uber.nullaway.Nullness;
 import com.uber.nullaway.dataflow.AccessPath;
 import com.uber.nullaway.dataflow.AccessPathNullnessPropagation;
@@ -122,7 +123,7 @@ public ImmutableSet<String> onRegisterImmutableTypes() {
   private Symbol.MethodSymbol getGetterForMetadataSubtype(
       Symbol.ClassSymbol classSymbol, Types types) {
     // Is there a better way than iteration?
-    for (Symbol elem : classSymbol.getEnclosedElements()) {
+    for (Symbol elem : NullabilityUtil.getEnclosedElements(classSymbol)) {
       if (elem.getKind().equals(ElementKind.METHOD)) {
         Symbol.MethodSymbol methodSymbol = (Symbol.MethodSymbol) elem;
         if (grpcIsMetadataGetCall(methodSymbol, types)) {

File: jar-infer/jar-infer-lib/src/test/java/com/uber/nullaway/jarinfer/JarInferTest.java
Patch:
@@ -170,7 +170,7 @@ private void testAnnotationInAarTemplate(
    * @param result Map of 'method signatures' to their 'inferred list of NonNull parameters'.
    * @param expected Map of 'method signatures' to their 'expected list of NonNull parameters'.
    */
-  private boolean verify(Map<String, Set<Integer>> result, HashMap<String, Set<Integer>> expected) {
+  private boolean verify(Map<String, Set<Integer>> result, Map<String, Set<Integer>> expected) {
     for (Map.Entry<String, Set<Integer>> entry : result.entrySet()) {
       String mtd_sign = entry.getKey();
       Set<Integer> ddParams = entry.getValue();

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handlers.java
Patch:
@@ -28,6 +28,7 @@
 import com.uber.nullaway.handlers.contract.ContractHandler;
 import com.uber.nullaway.handlers.contract.fieldcontract.EnsuresNonNullHandler;
 import com.uber.nullaway.handlers.contract.fieldcontract.RequiresNonNullHandler;
+import com.uber.nullaway.handlers.temporary.FluentFutureHandler;
 
 /** Utility static methods for the handlers package. */
 public class Handlers {
@@ -75,6 +76,7 @@ public static Handler buildDefault(Config config) {
       handlerListBuilder.add(new ContractCheckHandler(config));
     }
     handlerListBuilder.add(new LombokHandler(config));
+    handlerListBuilder.add(new FluentFutureHandler());
 
     return new CompositeHandler(handlerListBuilder.build());
   }

File: nullaway/src/main/java/com/uber/nullaway/handlers/BaseNoOpHandler.java
Patch:
@@ -109,7 +109,7 @@ public void onMatchReturn(NullAway analysis, ReturnTree tree, VisitorState state
   }
 
   @Override
-  public Nullness onOverrideMethodInvocationReturnNullability(
+  public Nullness onOverrideMethodReturnNullability(
       Symbol.MethodSymbol methodSymbol,
       VisitorState state,
       boolean isAnnotated,

File: nullaway/src/main/java/com/uber/nullaway/handlers/CompositeHandler.java
Patch:
@@ -123,15 +123,14 @@ public void onMatchReturn(NullAway analysis, ReturnTree tree, VisitorState state
   }
 
   @Override
-  public Nullness onOverrideMethodInvocationReturnNullability(
+  public Nullness onOverrideMethodReturnNullability(
       Symbol.MethodSymbol methodSymbol,
       VisitorState state,
       boolean isAnnotated,
       Nullness returnNullness) {
     for (Handler h : handlers) {
       returnNullness =
-          h.onOverrideMethodInvocationReturnNullability(
-              methodSymbol, state, isAnnotated, returnNullness);
+          h.onOverrideMethodReturnNullability(methodSymbol, state, isAnnotated, returnNullness);
     }
     return returnNullness;
   }

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handler.java
Patch:
@@ -162,12 +162,12 @@ boolean onOverrideMayBeNullExpr(
    * @param methodSymbol The method symbol for the method in question.
    * @param state The current visitor state.
    * @param isAnnotated A boolean flag indicating whether the called method is considered to be
-   *     within isAnnotated or unannotated code, used to avoid querying for this information
-   *     multiple times within the same handler chain.
+   *     within annotated or unannotated code, used to avoid querying for this information multiple
+   *     times within the same handler chain.
    * @param returnNullness return nullness computed by upstream handlers or NullAway core.
    * @return Updated return nullability computed by this handler.
    */
-  Nullness onOverrideMethodInvocationReturnNullability(
+  Nullness onOverrideMethodReturnNullability(
       Symbol.MethodSymbol methodSymbol,
       VisitorState state,
       boolean isAnnotated,

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handlers.java
Patch:
@@ -74,6 +74,7 @@ public static Handler buildDefault(Config config) {
     if (config.checkContracts()) {
       handlerListBuilder.add(new ContractCheckHandler(config));
     }
+    handlerListBuilder.add(new LombokHandler(config));
 
     return new CompositeHandler(handlerListBuilder.build());
   }

File: nullaway/src/main/java/com/uber/nullaway/handlers/RestrictiveAnnotationHandler.java
Patch:
@@ -133,7 +133,7 @@ public Nullness[] onOverrideMethodInvocationParametersNullability(
   }
 
   @Override
-  public Nullness onOverrideMethodInvocationReturnNullability(
+  public Nullness onOverrideMethodReturnNullability(
       Symbol.MethodSymbol methodSymbol,
       VisitorState state,
       boolean isAnnotated,

File: test-java-lib-lombok/src/main/java/com/uber/lombok/LombokDTO.java
Patch:
@@ -36,4 +36,5 @@ public class LombokDTO {
   private String field;
   @Builder.Default private String fieldWithDefault = "Default";
   @Nullable private String nullableField;
+  @Nullable @Builder.Default private String fieldWithNullDefault = null;
 }

File: test-library-models/src/main/java/com/uber/nullaway/testlibrarymodels/TestLibraryModels.java
Patch:
@@ -66,7 +66,7 @@ public ImmutableSetMultimap<MethodRef, Integer> nullImpliesNullParameters() {
   @Override
   public ImmutableSet<MethodRef> nullableReturns() {
     return ImmutableSet.of(
-        methodRef("com.uber.Foo", "bar()"),
+        methodRef("com.uber.AnnotatedWithModels", "returnsNullFromModel()"),
         methodRef("com.uber.lib.unannotated.UnannotatedWithModels", "returnsNullUnannotated()"),
         methodRef("com.uber.lib.unannotated.UnannotatedWithModels", "returnsNullUnannotated2()"));
   }

File: nullaway/src/main/java/com/uber/nullaway/ErrorProneCLIFlagsConfig.java
Patch:
@@ -213,7 +213,7 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
           "Invalid -XepOpt:" + FL_SUPPRESS_COMMENT + " value. Comment must be single line.");
     }
     skippedLibraryModels = getFlagStringSet(flags, FL_SKIP_LIBRARY_MODELS);
-    /** --- JarInfer configs --- */
+    /* --- JarInfer configs --- */
     jarInferEnabled = flags.getBoolean(FL_JI_ENABLED).orElse(false);
     jarInferUseReturnAnnotations = flags.getBoolean(FL_JI_USE_RETURN).orElse(false);
     // The defaults of these two options translate to: remove .aar/.jar from the file name, and also

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -621,7 +621,7 @@ public Description matchMethod(MethodTree tree, VisitorState state) {
     // package)
     Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(tree);
     handler.onMatchMethod(this, tree, state, methodSymbol);
-    boolean isOverriding = ASTHelpers.hasAnnotation(methodSymbol, Override.class, state);
+    boolean isOverriding = ASTHelpers.hasAnnotation(methodSymbol, "java.lang.Override", state);
     boolean exhaustiveOverride = config.exhaustiveOverride();
     if (isOverriding || !exhaustiveOverride) {
       Symbol.MethodSymbol closestOverriddenMethod =

File: nullaway/src/main/java/com/uber/nullaway/ErrorMessage.java
Patch:
@@ -55,6 +55,7 @@ public enum MessageTypes {
     TYPE_PARAMETER_CANNOT_BE_NULLABLE,
     ASSIGN_GENERIC_NULLABLE,
     RETURN_NULLABLE_GENERIC,
+    PASS_NULLABLE_GENERIC,
   }
 
   public String getMessage() {

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -1624,6 +1624,9 @@ private Description handleInvocation(
                   : Nullness.NONNULL;
         }
       }
+      new GenericsChecks(state, config, this)
+          .compareGenericTypeParameterNullabilityForCall(
+              formalParams, actualParams, methodSymbol.isVarArgs());
     }
 
     // Allow handlers to override the list of non-null argument positions

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPath.java
Patch:
@@ -429,7 +429,8 @@ && isBoxingMethod(ASTHelpers.getSymbol(methodInvocationTree))) {
             case IDENTIFIER: // check for CONST
               // Check for a constant field (static final)
               Symbol symbol = ASTHelpers.getSymbol(tree);
-              if (symbol.getKind().equals(ElementKind.FIELD)) {
+              if (symbol instanceof Symbol.VarSymbol
+                  && symbol.getKind().equals(ElementKind.FIELD)) {
                 Symbol.VarSymbol varSymbol = (Symbol.VarSymbol) symbol;
                 // From docs: getConstantValue() returns the value of this variable if this is a
                 // static final field initialized to a compile-time constant. Returns null

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPathNullnessPropagation.java
Patch:
@@ -718,7 +718,7 @@ public TransferResult<Nullness, NullnessStore> visitVariableDeclaration(
   public TransferResult<Nullness, NullnessStore> visitFieldAccess(
       FieldAccessNode fieldAccessNode, TransferInput<Nullness, NullnessStore> input) {
     ReadableUpdates updates = new ReadableUpdates();
-    Symbol symbol = ASTHelpers.getSymbol(fieldAccessNode.getTree());
+    Symbol symbol = Preconditions.checkNotNull(ASTHelpers.getSymbol(fieldAccessNode.getTree()));
     setReceiverNonnull(updates, fieldAccessNode.getReceiver(), symbol);
     Nullness nullness = NULLABLE;
     boolean fieldMayBeNull;

File: nullaway/src/main/java/com/uber/nullaway/handlers/GrpcHandler.java
Patch:
@@ -94,7 +94,9 @@ public NullnessHint onDataflowVisitMethodInvocation(
       Node base = node.getTarget().getReceiver();
       // Argument list and types should be already checked by grpcIsMetadataContainsKeyCall
       Symbol keyArgSymbol = ASTHelpers.getSymbol(tree.getArguments().get(0));
-      if (getter != null && keyArgSymbol.getKind().equals(ElementKind.FIELD)) {
+      if (getter != null
+          && keyArgSymbol instanceof Symbol.VarSymbol
+          && keyArgSymbol.getKind().equals(ElementKind.FIELD)) {
         Symbol.VarSymbol varSymbol = (Symbol.VarSymbol) keyArgSymbol;
         String immutableFieldFQN =
             varSymbol.enclClass().flatName().toString() + "." + varSymbol.flatName().toString();

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -1493,6 +1493,8 @@ public Description matchUnary(UnaryTree tree, VisitorState state) {
   public Description matchConditionalExpression(
       ConditionalExpressionTree tree, VisitorState state) {
     if (withinAnnotatedCode(state)) {
+      new GenericsChecks(state, config, this)
+          .checkTypeParameterNullnessForConditionalExpression(tree);
       doUnboxingCheck(state, tree.getCondition());
     }
     return Description.NO_MATCH;

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/adapters/SerializationAdapter.java
Patch:
@@ -37,7 +37,7 @@ public interface SerializationAdapter {
    * Latest version number. If version is not defined by the user, NullAway will use the
    * corresponding adapter to this version in its serialization.
    */
-  int LATEST_VERSION = 2;
+  int LATEST_VERSION = 3;
 
   /**
    * Returns header of "errors.tsv" which contains all serialized {@link ErrorInfo} reported by

File: nullaway/src/main/java/com/uber/nullaway/ErrorMessage.java
Patch:
@@ -54,6 +54,7 @@ public enum MessageTypes {
     WRONG_OVERRIDE_PRECONDITION,
     TYPE_PARAMETER_CANNOT_BE_NULLABLE,
     ASSIGN_GENERIC_NULLABLE,
+    RETURN_NULLABLE_GENERIC,
   }
 
   public String getMessage() {

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -834,6 +834,8 @@ private Description checkReturnExpression(
           state,
           methodSymbol);
     }
+    new GenericsChecks(state, config, this)
+        .checkTypeParameterNullnessForFunctionReturnType(retExpr, methodSymbol);
     return Description.NO_MATCH;
   }
 

File: nullaway/src/main/java/com/uber/nullaway/ErrorMessage.java
Patch:
@@ -53,6 +53,7 @@ public enum MessageTypes {
     WRONG_OVERRIDE_POSTCONDITION,
     WRONG_OVERRIDE_PRECONDITION,
     TYPE_PARAMETER_CANNOT_BE_NULLABLE,
+    ASSIGN_GENERIC_NULLABLE,
   }
 
   public String getMessage() {

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -2414,9 +2414,7 @@ private static ExpressionTree stripParensAndCasts(ExpressionTree expr) {
    * @return computed nullness for e, if any, else Nullable
    */
   public Nullness getComputedNullness(ExpressionTree e) {
-    // TODO: use Map.getOrDefault after https://github.com/uber/NullAway/issues/723
-    Nullness nullness = computedNullnessMap.get(e);
-    return nullness != null ? nullness : Nullness.NULLABLE;
+    return computedNullnessMap.getOrDefault(e, Nullness.NULLABLE);
   }
 
   /**

File: nullaway/src/main/java/com/uber/nullaway/LibraryModels.java
Patch:
@@ -84,7 +84,9 @@ public interface LibraryModels {
    * Get (method, parameter) pairs that cause the method to return <code>null</code> when passed
    * <code>null</code> on that parameter.
    *
-   * <p>This is equivalent to annotating a method with a contract like:
+   * <p>This is equivalent to annotating a method with both a {@code @Nullable} return type
+   * <em>and</em> a {@code @Contract} annotation specifying that if the parameter is
+   * {@code @NonNull} then the return is {@code @NonNull}, e.g.:
    *
    * <pre><code>@Contract("!null -&gt; !null") @Nullable</code></pre>
    *

File: nullaway/src/main/java/com/uber/nullaway/handlers/LibraryModelsHandler.java
Patch:
@@ -620,6 +620,8 @@ private static class DefaultLibraryModels implements LibraryModels {
         new ImmutableSet.Builder<MethodRef>()
             .add(methodRef("com.sun.source.tree.CompilationUnitTree", "getPackageName()"))
             .add(methodRef("java.lang.Throwable", "getMessage()"))
+            .add(methodRef("java.lang.Throwable", "getLocalizedMessage()"))
+            .add(methodRef("java.lang.Throwable", "getCause()"))
             .add(methodRef("java.lang.ref.Reference", "get()"))
             .add(methodRef("java.lang.ref.PhantomReference", "get()"))
             .add(methodRef("java.lang.ref.SoftReference", "get()"))

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/adapters/SerializationV2Adapter.java
Patch:
@@ -51,13 +51,13 @@ public String getErrorsOutputFileHeader() {
         "enc_class",
         "enc_member",
         "offset",
-        "uri",
+        "path",
         "target_kind",
         "target_class",
         "target_method",
         "target_param",
         "target_index",
-        "target_uri");
+        "target_path");
   }
 
   @Override
@@ -71,7 +71,7 @@ public String serializeError(ErrorInfo errorInfo) {
             : "null"),
         (errorInfo.getRegionMember() != null ? errorInfo.getRegionMember().toString() : "null"),
         String.valueOf(errorInfo.getOffset()),
-        errorInfo.getUri().getPath(),
+        errorInfo.getPath() != null ? errorInfo.getPath().toString() : "null",
         (errorInfo.getNonnullTarget() != null
             ? SymbolLocation.createLocationFromSymbol(errorInfo.getNonnullTarget())
                 .tabSeparatedToString()

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/location/FieldLocation.java
Patch:
@@ -45,6 +45,6 @@ public String tabSeparatedToString() {
         "null",
         variableSymbol.toString(),
         "null",
-        uri != null ? uri.toASCIIString() : "null");
+        path != null ? path.toString() : "null");
   }
 }

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/location/MethodLocation.java
Patch:
@@ -45,6 +45,6 @@ public String tabSeparatedToString() {
         enclosingMethod.toString(),
         "null",
         "null",
-        uri != null ? uri.toASCIIString() : "null");
+        path != null ? path.toString() : "null");
   }
 }

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/location/MethodParameterLocation.java
Patch:
@@ -66,6 +66,6 @@ public String tabSeparatedToString() {
         enclosingMethod.toString(),
         paramSymbol.toString(),
         String.valueOf(index),
-        uri != null ? uri.toASCIIString() : "null");
+        path != null ? path.toString() : "null");
   }
 }

File: nullaway/src/test/java/com/uber/nullaway/tools/SerializationTestHelper.java
Patch:
@@ -90,8 +90,8 @@ public void doTest() {
     Path outputPath = outputDir.resolve(fileName);
     try {
       Files.deleteIfExists(outputPath);
-    } catch (IOException ignored) {
-      throw new RuntimeException("Failed to delete older file at: " + outputPath);
+    } catch (IOException e) {
+      throw new RuntimeException("Failed to delete older file at: " + outputPath, e);
     }
     compilationTestHelper.doTest();
     List<T> actualOutputs = readActualOutputs(outputPath);

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -2208,6 +2208,7 @@ private boolean mayBeNullExpr(VisitorState state, ExpressionTree expr) {
       case REMAINDER:
       case CONDITIONAL_AND:
       case CONDITIONAL_OR:
+      case BITWISE_COMPLEMENT:
       case LOGICAL_COMPLEMENT:
       case INSTANCE_OF:
       case PREFIX_INCREMENT:

File: nullaway/src/test/resources/com/uber/nullaway/testdata/NullAwayNegativeCases.java
Patch:
@@ -479,6 +479,8 @@ static Number moreBoxing() {
       return b | a;
     } else if (b == 4) {
       return b ^ a;
+    } else if (b == 5) {
+      return ~a;
     } else {
       return 10;
     }
@@ -914,6 +916,7 @@ static String testNoCrashOnUnboxedShifts(int n) {
     s += boxAndDeref(n >>= 1);
     s += boxAndDeref(m >>>= 4);
     s += boxAndDeref(n >>> 3);
+    s += boxAndDeref(~n);
     return s;
   }
 

File: nullaway/src/test/resources/com/uber/nullaway/testdata/NullAwayPositiveCases.java
Patch:
@@ -333,6 +333,9 @@ static void unboxingTests() {
     Boolean z = null;
     // BUG: Diagnostic contains: unboxing
     int d = z ? 3 : 4;
+    Integer w = null;
+    // BUG: Diagnostic contains: unboxing
+    int e = ~w;
   }
 
   static void unboxingTests2() {

File: nullaway/src/main/java/com/uber/nullaway/Config.java
Patch:
@@ -292,4 +292,7 @@ public interface Config {
    *     similarly for {@code @RecentlyNonNull}
    */
   boolean acknowledgeAndroidRecent();
+
+  /** Should new checks based on JSpecify (like checks for generic types) be enabled? */
+  boolean isJSpecifyMode();
 }

File: nullaway/src/main/java/com/uber/nullaway/ErrorMessage.java
Patch:
@@ -52,6 +52,7 @@ public enum MessageTypes {
     PRECONDITION_NOT_SATISFIED,
     WRONG_OVERRIDE_POSTCONDITION,
     WRONG_OVERRIDE_PRECONDITION,
+    TYPE_PARAMETER_CANNOT_BE_NULLABLE,
   }
 
   public String getMessage() {

File: nullaway/src/main/java/com/uber/nullaway/ErrorProneCLIFlagsConfig.java
Patch:
@@ -53,6 +53,7 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
       EP_FL_NAMESPACE + ":CustomGeneratedCodeAnnotations";
   static final String FL_GENERATED_UNANNOTATED = EP_FL_NAMESPACE + ":TreatGeneratedAsUnannotated";
   static final String FL_ACKNOWLEDGE_ANDROID_RECENT = EP_FL_NAMESPACE + ":AcknowledgeAndroidRecent";
+  static final String FL_JSPECIFY_MODE = EP_FL_NAMESPACE + ":JSpecifyMode";
   static final String FL_EXCLUDED_FIELD_ANNOT = EP_FL_NAMESPACE + ":ExcludedFieldAnnotations";
   static final String FL_INITIALIZER_ANNOT = EP_FL_NAMESPACE + ":CustomInitializerAnnotations";
   static final String FL_NULLABLE_ANNOT = EP_FL_NAMESPACE + ":CustomNullableAnnotations";
@@ -188,6 +189,7 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
         flags.getBoolean(FL_HANDLE_TEST_ASSERTION_LIBRARIES).orElse(false);
     treatGeneratedAsUnannotated = flags.getBoolean(FL_GENERATED_UNANNOTATED).orElse(false);
     acknowledgeAndroidRecent = flags.getBoolean(FL_ACKNOWLEDGE_ANDROID_RECENT).orElse(false);
+    jspecifyMode = flags.getBoolean(FL_JSPECIFY_MODE).orElse(false);
     assertsEnabled = flags.getBoolean(FL_ASSERTS_ENABLED).orElse(false);
     fieldAnnotPattern =
         getPackagePattern(

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/out/ClassAndMemberInfo.java
Patch:
@@ -86,7 +86,7 @@ public void findValues() {
         // Node is not enclosed by any method, can be a field declaration or enclosed by it.
         Symbol sym = ASTHelpers.getSymbol(path.getLeaf());
         Symbol.VarSymbol fieldSymbol = null;
-        if (sym != null && sym.getKind().isField()) {
+        if (sym != null && sym.getKind().isField() && sym.isEnclosedBy(classSymbol)) {
           // Directly on a field declaration.
           fieldSymbol = (Symbol.VarSymbol) sym;
         } else {

File: nullaway/src/main/java/com/uber/nullaway/handlers/AssertionHandler.java
Patch:
@@ -69,7 +69,7 @@ public NullnessHint onDataflowVisitMethodInvocation(
         Symbol.MethodSymbol receiver_symbol = ASTHelpers.getSymbol(receiver_method.getTree());
         if (methodNameUtil.isMethodAssertThat(receiver_symbol)) {
           Node arg = receiver_method.getArgument(0);
-          AccessPath ap = AccessPath.getAccessPathForNodeNoMapGet(arg, apContext);
+          AccessPath ap = AccessPath.getAccessPathForNode(arg, state, apContext);
           if (ap != null) {
             bothUpdates.set(ap, NONNULL);
           }
@@ -84,7 +84,7 @@ public NullnessHint onDataflowVisitMethodInvocation(
         || methodNameUtil.isMethodJunitAssertThat(callee)) {
       List<Node> args = node.getArguments();
       if (args.size() == 2 && methodNameUtil.isMatcherIsNotNull(args.get(1))) {
-        AccessPath ap = AccessPath.getAccessPathForNodeNoMapGet(args.get(0), apContext);
+        AccessPath ap = AccessPath.getAccessPathForNode(args.get(0), state, apContext);
         if (ap != null) {
           bothUpdates.set(ap, NONNULL);
         }

File: nullaway/src/main/java/com/uber/nullaway/handlers/LibraryModelsHandler.java
Patch:
@@ -253,7 +253,7 @@ private static Iterable<AccessPath> accessPathsAtIndexes(
       Preconditions.checkArgument(i >= 0 && i < arguments.size(), "Invalid argument index: " + i);
       if (i >= 0 && i < arguments.size()) {
         Node argument = arguments.get(i);
-        AccessPath ap = AccessPath.getAccessPathForNodeWithMapGet(argument, state, apContext);
+        AccessPath ap = AccessPath.getAccessPathForNode(argument, state, apContext);
         if (ap != null) {
           result.add(ap);
         }

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/ContractHandler.java
Patch:
@@ -306,7 +306,7 @@ public NullnessHint onDataflowVisitMethodInvocation(
           argAntecedentNullness != null, "argAntecedentNullness should have been set");
       // The nullness of one argument is all that matters for the antecedent, let's negate the
       // consequent to fix the nullness of this argument.
-      AccessPath accessPath = AccessPath.getAccessPathForNodeNoMapGet(arg, apContext);
+      AccessPath accessPath = AccessPath.getAccessPathForNode(arg, state, apContext);
       if (accessPath == null) {
         continue;
       }

File: nullaway/src/main/java/com/uber/nullaway/handlers/BaseNoOpHandler.java
Patch:
@@ -146,8 +146,7 @@ public NullnessStore.Builder onDataflowInitialStore(
   @Override
   public NullnessHint onDataflowVisitMethodInvocation(
       MethodInvocationNode node,
-      Types types,
-      Context context,
+      VisitorState state,
       AccessPath.AccessPathContext apContext,
       AccessPathNullnessPropagation.SubNodeValues inputs,
       AccessPathNullnessPropagation.Updates thenUpdates,

File: nullaway/src/main/java/com/uber/nullaway/handlers/CompositeHandler.java
Patch:
@@ -173,8 +173,7 @@ public NullnessStore.Builder onDataflowInitialStore(
   @Override
   public NullnessHint onDataflowVisitMethodInvocation(
       MethodInvocationNode node,
-      Types types,
-      Context context,
+      VisitorState state,
       AccessPath.AccessPathContext apContext,
       AccessPathNullnessPropagation.SubNodeValues inputs,
       AccessPathNullnessPropagation.Updates thenUpdates,
@@ -184,7 +183,7 @@ public NullnessHint onDataflowVisitMethodInvocation(
     for (Handler h : handlers) {
       NullnessHint n =
           h.onDataflowVisitMethodInvocation(
-              node, types, context, apContext, inputs, thenUpdates, elseUpdates, bothUpdates);
+              node, state, apContext, inputs, thenUpdates, elseUpdates, bothUpdates);
       nullnessHint = nullnessHint.merge(n);
     }
     return nullnessHint;

File: nullaway/src/main/java/com/uber/nullaway/handlers/GrpcHandler.java
Patch:
@@ -34,7 +34,6 @@
 import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.code.Type;
 import com.sun.tools.javac.code.Types;
-import com.sun.tools.javac.util.Context;
 import com.uber.nullaway.NullAway;
 import com.uber.nullaway.Nullness;
 import com.uber.nullaway.dataflow.AccessPath;
@@ -80,15 +79,15 @@ public void onMatchTopLevelClass(
   @Override
   public NullnessHint onDataflowVisitMethodInvocation(
       MethodInvocationNode node,
-      Types types,
-      Context context,
+      VisitorState state,
       AccessPath.AccessPathContext apContext,
       AccessPathNullnessPropagation.SubNodeValues inputs,
       AccessPathNullnessPropagation.Updates thenUpdates,
       AccessPathNullnessPropagation.Updates elseUpdates,
       AccessPathNullnessPropagation.Updates bothUpdates) {
     MethodInvocationTree tree = castToNonNull(node.getTree());
     Symbol.MethodSymbol symbol = ASTHelpers.getSymbol(tree);
+    Types types = state.getTypes();
     if (grpcIsMetadataContainsKeyCall(symbol, types)) {
       // On seeing o.containsKey(k), set AP for o.get(k) to @NonNull
       Element getter = getGetterForMetadataSubtype(symbol.enclClass(), types);

File: nullaway/src/main/java/com/uber/nullaway/handlers/InferredJARModelsHandler.java
Patch:
@@ -30,7 +30,6 @@
 import com.sun.source.tree.Tree;
 import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.code.Type;
-import com.sun.tools.javac.code.Types;
 import com.sun.tools.javac.util.Context;
 import com.uber.nullaway.Config;
 import com.uber.nullaway.NullAway;
@@ -179,8 +178,7 @@ public Nullness[] onOverrideMethodInvocationParametersNullability(
   @Override
   public NullnessHint onDataflowVisitMethodInvocation(
       MethodInvocationNode node,
-      Types types,
-      Context context,
+      VisitorState state,
       AccessPath.AccessPathContext apContext,
       AccessPathNullnessPropagation.SubNodeValues inputs,
       AccessPathNullnessPropagation.Updates thenUpdates,

File: nullaway/src/main/java/com/uber/nullaway/handlers/RestrictiveAnnotationHandler.java
Patch:
@@ -132,15 +132,14 @@ public Nullness onOverrideMethodInvocationReturnNullability(
   @Override
   public NullnessHint onDataflowVisitMethodInvocation(
       MethodInvocationNode node,
-      Types types,
-      Context context,
+      VisitorState state,
       AccessPath.AccessPathContext apContext,
       AccessPathNullnessPropagation.SubNodeValues inputs,
       AccessPathNullnessPropagation.Updates thenUpdates,
       AccessPathNullnessPropagation.Updates elseUpdates,
       AccessPathNullnessPropagation.Updates bothUpdates) {
     Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(node.getTree());
-    return isSymbolRestrictivelyNullable(methodSymbol, context)
+    return isSymbolRestrictivelyNullable(methodSymbol, state.context)
         ? NullnessHint.HINT_NULLABLE
         : NullnessHint.UNKNOWN;
   }

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handlers.java
Patch:
@@ -55,7 +55,7 @@ public static Handler buildDefault(Config config) {
     if (config.handleTestAssertionLibraries()) {
       handlerListBuilder.add(new AssertionHandler(methodNameUtil));
     }
-    handlerListBuilder.add(new PreconditionsHandler());
+    handlerListBuilder.add(new GuavaAssertionsHandler());
     handlerListBuilder.add(new LibraryModelsHandler(config));
     handlerListBuilder.add(StreamNullabilityPropagatorFactory.getRxStreamNullabilityPropagator());
     handlerListBuilder.add(StreamNullabilityPropagatorFactory.getJavaStreamNullabilityPropagator());

File: nullaway/src/main/java/com/uber/nullaway/ErrorBuilder.java
Patch:
@@ -468,7 +468,9 @@ void reportInitErrorOnField(Symbol symbol, VisitorState state, Description.Build
       fieldName = flatName.substring(index) + "." + fieldName;
     }
 
-    if (symbol.isStatic()) {
+    @SuppressWarnings("ASTHelpersSuggestions") // remove once we require EP 2.16 or greater
+    boolean isStatic = symbol.isStatic();
+    if (isStatic) {
       state.reportMatch(
           createErrorDescription(
               new ErrorMessage(

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPathNullnessPropagation.java
Patch:
@@ -761,6 +761,7 @@ private CodeAnnotationInfo getCodeAnnotationInfo(VisitorState state) {
     return codeAnnotationInfo;
   }
 
+  @SuppressWarnings("ASTHelpersSuggestions") // remove once we require EP 2.16 or greater
   private void setReceiverNonnull(
       AccessPathNullnessPropagation.ReadableUpdates updates, Node receiver, Symbol symbol) {
     if (symbol != null && !symbol.isStatic()) {

File: nullaway/src/main/java/com/uber/nullaway/dataflow/NullnessStore.java
Patch:
@@ -188,7 +188,7 @@ public NullnessStore widenedUpperBound(NullnessStore vNullnessStore) {
   }
 
   @Override
-  public boolean equals(Object o) {
+  public boolean equals(@Nullable Object o) {
     if (!(o instanceof NullnessStore)) {
       return false;
     }

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/location/FieldLocation.java
Patch:
@@ -45,6 +45,6 @@ public String tabSeparatedToString() {
         "null",
         variableSymbol.toString(),
         "null",
-        uri.toASCIIString());
+        uri != null ? uri.toASCIIString() : "null");
   }
 }

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/location/MethodLocation.java
Patch:
@@ -45,6 +45,6 @@ public String tabSeparatedToString() {
         enclosingMethod.toString(),
         "null",
         "null",
-        uri.toASCIIString());
+        uri != null ? uri.toASCIIString() : "null");
   }
 }

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/location/MethodParameterLocation.java
Patch:
@@ -66,6 +66,6 @@ public String tabSeparatedToString() {
         enclosingMethod.toString(),
         paramSymbol.toString(),
         String.valueOf(index),
-        uri.toASCIIString());
+        uri != null ? uri.toASCIIString() : "null");
   }
 }

File: nullaway/src/main/java/com/uber/nullaway/NullabilityUtil.java
Patch:
@@ -58,6 +58,7 @@
 /** Helpful utility methods for nullability analysis. */
 public class NullabilityUtil {
   public static final String NULLMARKED_SIMPLE_NAME = "NullMarked";
+  public static final String NULLUNMARKED_SIMPLE_NAME = "NullUnmarked";
 
   private static final Supplier<Type> MAP_TYPE_SUPPLIER = Suppliers.typeFromString("java.util.Map");
 

File: nullaway/src/main/java/com/uber/nullaway/NullabilityUtil.java
Patch:
@@ -296,12 +296,12 @@ private static Stream<? extends AnnotationMirror> getTypeUseAnnotations(Symbol s
    * @throws NullPointerException if {@code symbol} is null
    */
   public static boolean mayBeNullFieldFromType(
-      Symbol symbol, Config config, ClassAnnotationInfo classAnnotationInfo) {
+      Symbol symbol, Config config, CodeAnnotationInfo codeAnnotationInfo) {
     Preconditions.checkNotNull(
         symbol, "mayBeNullFieldFromType should never be called with a null symbol");
     return !(symbol.getSimpleName().toString().equals("class")
             || symbol.isEnum()
-            || classAnnotationInfo.isSymbolUnannotated(symbol, config))
+            || codeAnnotationInfo.isSymbolUnannotated(symbol, config))
         && Nullness.hasNullableAnnotation(symbol, config);
   }
 

File: nullaway/src/main/java/com/uber/nullaway/handlers/BaseNoOpHandler.java
Patch:
@@ -43,7 +43,6 @@
 import com.uber.nullaway.dataflow.NullnessStore;
 import com.uber.nullaway.dataflow.cfg.NullAwayCFGBuilder;
 import java.util.List;
-import java.util.Map;
 import java.util.Optional;
 import javax.annotation.Nullable;
 import org.checkerframework.nullaway.dataflow.cfg.UnderlyingAST;
@@ -119,11 +118,11 @@ public Nullness onOverrideMethodInvocationReturnNullability(
   }
 
   @Override
-  public Map<Integer, Nullness> onOverrideMethodInvocationParametersNullability(
+  public Nullness[] onOverrideMethodInvocationParametersNullability(
       Context context,
       Symbol.MethodSymbol methodSymbol,
       boolean isAnnotated,
-      Map<Integer, Nullness> argumentPositionNullness) {
+      Nullness[] argumentPositionNullness) {
     // NoOp
     return argumentPositionNullness;
   }

File: nullaway/src/main/java/com/uber/nullaway/handlers/CompositeHandler.java
Patch:
@@ -44,7 +44,6 @@
 import com.uber.nullaway.dataflow.NullnessStore;
 import com.uber.nullaway.dataflow.cfg.NullAwayCFGBuilder;
 import java.util.List;
-import java.util.Map;
 import java.util.Optional;
 import javax.annotation.Nullable;
 import org.checkerframework.nullaway.dataflow.cfg.UnderlyingAST;
@@ -137,11 +136,11 @@ public Nullness onOverrideMethodInvocationReturnNullability(
   }
 
   @Override
-  public Map<Integer, Nullness> onOverrideMethodInvocationParametersNullability(
+  public Nullness[] onOverrideMethodInvocationParametersNullability(
       Context context,
       Symbol.MethodSymbol methodSymbol,
       boolean isAnnotated,
-      Map<Integer, Nullness> argumentPositionNullness) {
+      Nullness[] argumentPositionNullness) {
     for (Handler h : handlers) {
       argumentPositionNullness =
           h.onOverrideMethodInvocationParametersNullability(

File: nullaway/src/main/java/com/uber/nullaway/handlers/InferredJARModelsHandler.java
Patch:
@@ -124,11 +124,11 @@ private void loadStubxFiles() {
   }
 
   @Override
-  public Map<Integer, Nullness> onOverrideMethodInvocationParametersNullability(
+  public Nullness[] onOverrideMethodInvocationParametersNullability(
       Context context,
       Symbol.MethodSymbol methodSymbol,
       boolean isAnnotated,
-      Map<Integer, Nullness> argumentPositionNullness) {
+      Nullness[] argumentPositionNullness) {
     if (isAnnotated) {
       // We currently do not load JarInfer models for code marked as annotated.
       // This is unlikely to change, as the behavior of JarInfer on arguments is to explicitly mark
@@ -167,7 +167,7 @@ public Map<Integer, Nullness> onOverrideMethodInvocationParametersNullability(
         // Skip 'this' param for non-static methods
         int nonNullPosition = annotationEntry.getKey() - (methodSymbol.isStatic() ? 0 : 1);
         jiNonNullParams.add(nonNullPosition);
-        argumentPositionNullness.put(nonNullPosition, Nullness.NONNULL);
+        argumentPositionNullness[nonNullPosition] = Nullness.NONNULL;
       }
     }
     if (!jiNonNullParams.isEmpty()) {

File: nullaway/src/main/java/com/uber/nullaway/ErrorBuilder.java
Patch:
@@ -139,7 +139,7 @@ public Description createErrorDescription(
       if (nonNullTarget != null) {
         SerializationService.serializeFixSuggestion(config, state, nonNullTarget, errorMessage);
       }
-      SerializationService.serializeReportingError(config, state, errorMessage);
+      SerializationService.serializeReportingError(config, state, nonNullTarget, errorMessage);
     }
 
     // #letbuildersbuild

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/location/AbstractSymbolLocation.java
Patch:
@@ -30,8 +30,8 @@
 import java.net.URI;
 import javax.lang.model.element.ElementKind;
 
-/** abstract base class for {@link FixLocation}. */
-public abstract class AbstractFixLocation implements FixLocation {
+/** abstract base class for {@link SymbolLocation}. */
+public abstract class AbstractSymbolLocation implements SymbolLocation {
 
   /** Element kind of the targeted symbol */
   protected final ElementKind type;
@@ -40,7 +40,7 @@ public abstract class AbstractFixLocation implements FixLocation {
   /** Enclosing class of the symbol. */
   protected final Symbol.ClassSymbol enclosingClass;
 
-  public AbstractFixLocation(ElementKind type, Symbol target) {
+  public AbstractSymbolLocation(ElementKind type, Symbol target) {
     Preconditions.checkArgument(
         type.equals(target.getKind()),
         "Cannot instantiate element of type: "

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handler.java
Patch:
@@ -358,7 +358,7 @@ Integer castToNonNullArgumentPositionsForMethod(
 
   /**
    * A three value enum for handlers implementing onDataflowVisitMethodInvocation to communicate
-   * their knowledge of the method return nullability to the the rest of NullAway.
+   * their knowledge of the method return nullability to the rest of NullAway.
    */
   public enum NullnessHint {
     /**

File: nullaway/src/main/java/com/uber/nullaway/Nullness.java
Patch:
@@ -128,14 +128,14 @@ public String toString() {
     return displayName;
   }
 
-  private static boolean hasNullableAnnotation(
+  public static boolean hasNullableAnnotation(
       Stream<? extends AnnotationMirror> annotations, Config config) {
     return annotations
         .map(anno -> anno.getAnnotationType().toString())
         .anyMatch(anno -> isNullableAnnotation(anno, config));
   }
 
-  private static boolean hasNonNullAnnotation(
+  public static boolean hasNonNullAnnotation(
       Stream<? extends AnnotationMirror> annotations, Config config) {
     return annotations
         .map(anno -> anno.getAnnotationType().toString())

File: guava-recent-unit-tests/src/test/java/com/uber/nullaway/guava/NullAwayGuavaParametricNullnessTests.java
Patch:
@@ -41,8 +41,7 @@ public void setup() {
                 Arrays.asList(
                     "-d",
                     temporaryFolder.getRoot().getAbsolutePath(),
-                    "-XepOpt:NullAway:AnnotatedPackages=com.uber,com.google.common",
-                    "-XepOpt:NullAway:AcknowledgeLibraryModelsOfAnnotatedCode=true"));
+                    "-XepOpt:NullAway:AnnotatedPackages=com.uber,com.google.common"));
   }
 
   @Test

File: nullaway/src/main/java/com/uber/nullaway/handlers/LibraryModelsHandler.java
Patch:
@@ -583,6 +583,7 @@ private static class DefaultLibraryModels implements LibraryModels {
     private static final ImmutableSetMultimap<MethodRef, Integer> NULL_IMPLIES_NULL_PARAMETERS =
         new ImmutableSetMultimap.Builder<MethodRef, Integer>()
             .put(methodRef("java.util.Optional", "orElse(T)"), 0)
+            .put(methodRef("com.google.common.io.Closer", "<C>register(C)"), 0)
             .build();
 
     private static final ImmutableSet<MethodRef> NULLABLE_RETURNS =

File: test-library-models/src/main/java/com/uber/nullaway/testlibrarymodels/TestLibraryModels.java
Patch:
@@ -63,7 +63,7 @@ public ImmutableSetMultimap<MethodRef, Integer> nullImpliesNullParameters() {
 
   @Override
   public ImmutableSet<MethodRef> nullableReturns() {
-    return ImmutableSet.of();
+    return ImmutableSet.of(methodRef("com.uber.Foo", "bar()"));
   }
 
   @Override

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/ContractUtils.java
Patch:
@@ -84,7 +84,7 @@ static String[] getAntecedent(
 
     String[] parts = clause.split("->");
 
-    String[] antecedent = parts[0].split(",");
+    String[] antecedent = parts[0].trim().isEmpty() ? new String[0] : parts[0].split(",");
 
     if (antecedent.length != numOfArguments) {
       String message =

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPathNullnessAnalysis.java
Patch:
@@ -80,7 +80,7 @@ private AccessPathNullnessAnalysis(
             config,
             handler,
             new CoreNullnessStoreInitializer());
-    this.dataFlow = new DataFlow(config.assertsEnabled());
+    this.dataFlow = new DataFlow(config.assertsEnabled(), handler);
 
     if (config.checkContracts()) {
       this.contractNullnessPropagation =

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handlers.java
Patch:
@@ -55,6 +55,7 @@ public static Handler buildDefault(Config config) {
     if (config.handleTestAssertionLibraries()) {
       handlerListBuilder.add(new AssertionHandler(methodNameUtil));
     }
+    handlerListBuilder.add(new PreconditionsHandler());
     handlerListBuilder.add(new LibraryModelsHandler(config));
     handlerListBuilder.add(StreamNullabilityPropagatorFactory.getRxStreamNullabilityPropagator());
     handlerListBuilder.add(StreamNullabilityPropagatorFactory.getJavaStreamNullabilityPropagator());

File: nullaway/src/main/java/com/uber/nullaway/handlers/OptionalEmptinessHandler.java
Patch:
@@ -150,9 +150,8 @@ private boolean isOptionalContentNullable(
   public boolean includeApInfoInSavedContext(AccessPath accessPath, VisitorState state) {
 
     if (accessPath.getElements().size() == 1) {
-      AccessPath.Root root = accessPath.getRoot();
-      if (!root.isReceiver()) {
-        final Element e = root.getElement();
+      final Element e = accessPath.getRoot();
+      if (e != null) {
         return e.getKind().equals(ElementKind.LOCAL_VARIABLE)
             && accessPath.getElements().get(0).getJavaElement().equals(OPTIONAL_CONTENT);
       }

File: nullaway/src/test/java/com/uber/nullaway/NullAwayCoreTests.java
Patch:
@@ -613,7 +613,7 @@ public void nullableOnJavaLangVoid() {
             "import javax.annotation.Nullable;",
             "class Test {",
             "  Void foo1() {",
-            "    // BUG: Diagnostic contains: returning @Nullable expression",
+            "    // temporarily, we treat a Void return type as if it was @Nullable Void",
             "    return null;",
             "  }",
             "  @Nullable Void foo2() {",

File: nullaway/src/main/java/com/uber/nullaway/dataflow/NullnessStore.java
Patch:
@@ -238,9 +238,9 @@ public NullnessStore uprootAccessPaths(
       if (ap.getRoot().isReceiver()) {
         continue;
       }
-      Element varElement = ap.getRoot().getVarElement();
+      Element element = ap.getRoot().getElement();
       for (LocalVariableNode fromVar : localVarTranslations.keySet()) {
-        if (varElement.equals(fromVar.getElement())) {
+        if (element.equals(fromVar.getElement())) {
           LocalVariableNode toVar = localVarTranslations.get(fromVar);
           AccessPath newAP =
               new AccessPath(new AccessPath.Root(toVar.getElement()), ap.getElements());

File: nullaway/src/main/java/com/uber/nullaway/handlers/OptionalEmptinessHandler.java
Patch:
@@ -152,7 +152,7 @@ public boolean includeApInfoInSavedContext(AccessPath accessPath, VisitorState s
     if (accessPath.getElements().size() == 1) {
       AccessPath.Root root = accessPath.getRoot();
       if (!root.isReceiver()) {
-        final Element e = root.getVarElement();
+        final Element e = root.getElement();
         return e.getKind().equals(ElementKind.LOCAL_VARIABLE)
             && accessPath.getElements().get(0).getJavaElement().equals(OPTIONAL_CONTENT);
       }

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/location/FieldLocation.java
Patch:
@@ -40,7 +40,7 @@ public FieldLocation(Symbol target) {
   public String tabSeparatedToString() {
     return type.toString()
         + '\t'
-        + enclosingClass
+        + enclosingClass.flatName()
         + '\t'
         + "null"
         + '\t'

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/location/MethodLocation.java
Patch:
@@ -40,7 +40,7 @@ public MethodLocation(Symbol target) {
   public String tabSeparatedToString() {
     return type.toString()
         + '\t'
-        + enclosingClass
+        + enclosingClass.flatName()
         + '\t'
         + enclosingMethod
         + '\t'

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/location/MethodParameterLocation.java
Patch:
@@ -61,7 +61,7 @@ public MethodParameterLocation(Symbol target) {
   public String tabSeparatedToString() {
     return type.toString()
         + '\t'
-        + enclosingClass
+        + enclosingClass.flatName()
         + '\t'
         + enclosingMethod
         + '\t'

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/out/ErrorInfo.java
Patch:
@@ -82,7 +82,7 @@ public String tabSeparatedToString() {
         + escapeSpecialCharacters(errorMessage.getMessage())
         + '\t'
         + (enclosingInfo.getClazz() != null
-            ? ASTHelpers.getSymbol(enclosingInfo.getClazz())
+            ? ASTHelpers.getSymbol(enclosingInfo.getClazz()).flatName()
             : "null")
         + '\t'
         + (enclosingInfo.getMethod() != null

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/out/SuggestedFixInfo.java
Patch:
@@ -87,7 +87,7 @@ public String tabSeparatedToString() {
         + '\t'
         + (enclosingInfo.getClazz() == null
             ? "null"
-            : ASTHelpers.getSymbol(enclosingInfo.getClazz()))
+            : ASTHelpers.getSymbol(enclosingInfo.getClazz()).flatName())
         + '\t'
         + (enclosingInfo.getMethod() == null
             ? "null"

File: nullaway/src/main/java/com/uber/nullaway/handlers/LibraryModelsHandler.java
Patch:
@@ -576,6 +576,7 @@ private static class DefaultLibraryModels implements LibraryModels {
             .add(methodRef("android.view.View", "getHandler()"))
             .add(methodRef("android.webkit.WebView", "getUrl()"))
             .add(methodRef("android.widget.TextView", "getLayout()"))
+            .add(methodRef("java.lang.System", "console()"))
             .build();
 
     private static final ImmutableSet<MethodRef> NONNULL_RETURNS =

File: nullaway/src/main/java/com/uber/nullaway/AbstractConfig.java
Patch:
@@ -36,6 +36,7 @@
 import javax.annotation.Nullable;
 
 /** abstract base class for null checker {@link Config} implementations */
+@SuppressWarnings("NullAway") // TODO: get rid of this class to avoid suppression
 public abstract class AbstractConfig implements Config {
 
   /**

File: nullaway/src/main/java/com/uber/nullaway/ErrorProneCLIFlagsConfig.java
Patch:
@@ -224,7 +224,7 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
      * field be @Nonnull, allowing us to avoid null checks in various places.
      */
     fixSerializationConfig =
-        serializationActivationFlag
+        serializationActivationFlag && fixSerializationConfigPath.isPresent()
             ? new FixSerializationConfig(fixSerializationConfigPath.get())
             : new FixSerializationConfig();
     if (serializationActivationFlag && isSuggestSuppressions) {

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPathElement.java
Patch:
@@ -31,7 +31,7 @@ public Element getJavaElement() {
     return this.javaElement;
   }
 
-  public ImmutableList<String> getConstantArguments() {
+  public @Nullable ImmutableList<String> getConstantArguments() {
     return this.constantArguments;
   }
 

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/location/AbstractFixLocation.java
Patch:
@@ -22,6 +22,8 @@
 
 package com.uber.nullaway.fixserialization.location;
 
+import static com.uber.nullaway.NullabilityUtil.castToNonNull;
+
 import com.google.common.base.Preconditions;
 import com.google.errorprone.util.ASTHelpers;
 import com.sun.tools.javac.code.Symbol;
@@ -47,7 +49,7 @@ public AbstractFixLocation(ElementKind type, Symbol target) {
             + type
             + ".");
     this.type = type;
-    this.enclosingClass = ASTHelpers.enclosingClass(target);
+    this.enclosingClass = castToNonNull(ASTHelpers.enclosingClass(target));
     this.uri = enclosingClass.sourcefile.toUri();
   }
 }

File: nullaway/src/main/java/com/uber/nullaway/fixserialization/qual/AnnotationConfig.java
Patch:
@@ -22,6 +22,8 @@
 
 package com.uber.nullaway.fixserialization.qual;
 
+import com.uber.nullaway.annotations.EnsuresNonNull;
+
 /** Container object of any {@code @Nonnull} and {@code @Nullable} annotations. */
 public class AnnotationConfig {
 
@@ -64,6 +66,7 @@ public AnnotationConfig(String nullable, String nonNull) {
     setFullNames(nonNull, nullable);
   }
 
+  @EnsuresNonNull({"this.nonNull", "this.nullable"})
   public void setFullNames(String nonnullFullName, String nullableFullName) {
     nonNull = new Annotation(nonnullFullName);
     nullable = new Annotation(nullableFullName);

File: nullaway/src/main/java/com/uber/nullaway/handlers/FieldInitializationSerializationHandler.java
Patch:
@@ -88,8 +88,7 @@ public void onNonNullFieldAssignment(
       // Initializer.
       return;
     }
-    config
-        .getSerializer()
+    NullabilityUtil.castToNonNull(config.getSerializer())
         .serializeFieldInitializationInfo(new FieldInitializationInfo(methodSymbol, field));
   }
 }

File: nullaway/src/main/java/com/uber/nullaway/handlers/GrpcHandler.java
Patch:
@@ -21,6 +21,8 @@
  */
 package com.uber.nullaway.handlers;
 
+import static com.uber.nullaway.NullabilityUtil.castToNonNull;
+
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableSet;
 import com.google.errorprone.VisitorState;
@@ -85,7 +87,7 @@ public NullnessHint onDataflowVisitMethodInvocation(
       AccessPathNullnessPropagation.Updates thenUpdates,
       AccessPathNullnessPropagation.Updates elseUpdates,
       AccessPathNullnessPropagation.Updates bothUpdates) {
-    MethodInvocationTree tree = node.getTree();
+    MethodInvocationTree tree = castToNonNull(node.getTree());
     Symbol.MethodSymbol symbol = ASTHelpers.getSymbol(tree);
     if (grpcIsMetadataContainsKeyCall(symbol, types)) {
       // On seeing o.containsKey(k), set AP for o.get(k) to @NonNull

File: nullaway/src/main/java/com/uber/nullaway/handlers/MethodNameUtil.java
Patch:
@@ -22,6 +22,7 @@
  * THE SOFTWARE.
  */
 
+import com.facebook.infer.annotation.Initializer;
 import com.google.errorprone.util.ASTHelpers;
 import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.util.Name;
@@ -81,6 +82,7 @@ class MethodNameUtil {
   private Name notNullValueMatcher;
   private Name nullValueMatcher;
 
+  @Initializer
   void initializeMethodNames(Name.Table table) {
     isNotNull = table.fromString(IS_NOT_NULL_METHOD);
     isNotNullOwner = table.fromString(IS_NOT_NULL_OWNER);

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/ContractNullnessStoreInitializer.java
Patch:
@@ -41,7 +41,9 @@ public NullnessStore getInitialStore(
     final Symbol.MethodSymbol callee = ASTHelpers.getSymbol(methodTree);
     final String contractString = ContractUtils.getContractString(callee, config);
 
-    assert contractString != null;
+    if (contractString == null) {
+      throw new IllegalStateException("expected non-null contractString");
+    }
 
     String[] clauses = contractString.split(";");
     String[] parts = clauses[0].split("->");

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -148,6 +148,7 @@
     summary = "Nullability type error.",
     tags = BugPattern.StandardTags.LIKELY_ERROR,
     severity = WARNING)
+@SuppressWarnings("BugPatternNaming") // remove once we require EP 2.11+
 public class NullAway extends BugChecker
     implements BugChecker.MethodInvocationTreeMatcher,
         BugChecker.AssignmentTreeMatcher,

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/ContractCheckHandler.java
Patch:
@@ -153,7 +153,8 @@ public Void visitReturn(ReturnTree returnTree, Void unused) {
                             ErrorMessage.MessageTypes.ANNOTATION_VALUE_INVALID, errorMessage),
                         returnTree,
                         analysis.buildDescription(returnTree),
-                        returnState));
+                        returnState,
+                        null));
           }
           return super.visitReturn(returnTree, unused);
         }

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/ContractHandler.java
Patch:
@@ -164,7 +164,8 @@ public NullnessHint onDataflowVisitMethodInvocation(
                             ErrorMessage.MessageTypes.ANNOTATION_VALUE_INVALID, errorMessage),
                         node.getTree(),
                         analysis.buildDescription(node.getTree()),
-                        state));
+                        state,
+                        null));
             supported = false;
             break;
           }

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -2027,8 +2027,7 @@ public boolean nullnessFromDataflow(VisitorState state, ExpressionTree expr) {
   }
 
   public AccessPathNullnessAnalysis getNullnessAnalysis(VisitorState state) {
-    return AccessPathNullnessAnalysis.instance(
-        state.context, nonAnnotatedMethod, config, this.handler);
+    return AccessPathNullnessAnalysis.instance(state, nonAnnotatedMethod, config, this.handler);
   }
 
   private boolean mayBeNullFieldAccess(VisitorState state, ExpressionTree expr, Symbol exprSymbol) {

File: nullaway/src/main/java/com/uber/nullaway/dataflow/NullnessStore.java
Patch:
@@ -20,7 +20,7 @@
 import static com.google.common.collect.Sets.intersection;
 
 import com.google.common.collect.ImmutableMap;
-import com.sun.tools.javac.code.Types;
+import com.google.errorprone.VisitorState;
 import com.uber.nullaway.Nullness;
 import com.uber.nullaway.dataflow.AccessPath.IteratorContentsKey;
 import java.util.HashMap;
@@ -97,10 +97,10 @@ public Nullness valueOfField(
    */
   public Nullness valueOfMethodCall(
       MethodInvocationNode node,
-      Types types,
+      VisitorState state,
       Nullness defaultValue,
       AccessPath.AccessPathContext apContext) {
-    AccessPath accessPath = AccessPath.fromMethodCall(node, types, apContext);
+    AccessPath accessPath = AccessPath.fromMethodCall(node, state, apContext);
     if (accessPath == null) {
       return defaultValue;
     }

File: jar-infer/jar-infer-lib/src/main/java/com/uber/nullaway/jarinfer/BytecodeAnnotator.java
Patch:
@@ -46,7 +46,9 @@ public final class BytecodeAnnotator {
   private static boolean debug = false;
 
   private static void LOG(boolean cond, String tag, String msg) {
-    if (cond) System.out.println("[" + tag + "] " + msg);
+    if (cond) {
+      System.out.println("[" + tag + "] " + msg);
+    }
   }
 
   public static final String javaxNullableDesc = "Ljavax/annotation/Nullable;";

File: jar-infer/test-android-lib-jarinfer/src/main/java/com/uber/nullaway/jarinfer/toys/unannotated/Bar.java
Patch:
@@ -5,7 +5,9 @@ public class Bar {
   public int b;
 
   public Bar(String str) {
-    if (str == null) str = "bar";
+    if (str == null) {
+      str = "bar";
+    }
     this.bar = str;
     this.b = bar.length();
   }

File: jar-infer/test-android-lib-jarinfer/src/main/java/com/uber/nullaway/jarinfer/toys/unannotated/Foo.java
Patch:
@@ -4,7 +4,9 @@ public class Foo {
   private String foo;
 
   public Foo(String str) {
-    if (str == null) str = "foo";
+    if (str == null) {
+      str = "foo";
+    }
     this.foo = str;
   }
 

File: jar-infer/test-java-lib-jarinfer/src/main/java/com/uber/nullaway/jarinfer/toys/unannotated/Bar.java
Patch:
@@ -5,7 +5,9 @@ public class Bar {
   public int b;
 
   public Bar(String str) {
-    if (str == null) str = "bar";
+    if (str == null) {
+      str = "bar";
+    }
     this.bar = str;
     this.b = bar.length();
   }

File: jar-infer/test-java-lib-jarinfer/src/main/java/com/uber/nullaway/jarinfer/toys/unannotated/Foo.java
Patch:
@@ -4,7 +4,9 @@ public class Foo {
   private String foo;
 
   public Foo(String str) {
-    if (str == null) str = "foo";
+    if (str == null) {
+      str = "foo";
+    }
     this.foo = str;
   }
 

File: nullaway/src/main/java/com/uber/nullaway/ErrorBuilder.java
Patch:
@@ -356,9 +356,10 @@ private boolean symbolIsExcludedClassSymbol(Symbol symbol) {
 
   static int getLineNumForElement(Element uninitField, VisitorState state) {
     Tree tree = getTreesInstance(state).getTree(uninitField);
-    if (tree == null)
+    if (tree == null) {
       throw new RuntimeException(
           "When getting the line number for uninitialized field, can't get the tree from the element.");
+    }
     DiagnosticPosition position =
         (DiagnosticPosition) tree; // Expect Tree to be JCTree and thus implement DiagnosticPosition
     TreePath path = state.getPath();

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -873,7 +873,9 @@ private boolean relevantInitializerMethodOrBlock(
       return false;
     } else if (methodLambdaOrBlock instanceof MethodTree) {
       MethodTree methodTree = (MethodTree) methodLambdaOrBlock;
-      if (isConstructor(methodTree) && !constructorInvokesAnother(methodTree, state)) return true;
+      if (isConstructor(methodTree) && !constructorInvokesAnother(methodTree, state)) {
+        return true;
+      }
       if (ASTHelpers.getSymbol(methodTree).isStatic()) {
         Set<MethodTree> staticInitializerMethods =
             class2Entities.get(enclosingClassSymbol(enclosingBlockPath)).staticInitializerMethods();

File: nullaway/src/main/java/com/uber/nullaway/dataflow/NullnessStore.java
Patch:
@@ -129,7 +129,9 @@ public Set<AccessPath> getAccessPathsWithValue(Nullness value) {
    * @return The {@link Nullness} value of the access path.
    */
   public Nullness getNullnessOfAccessPath(AccessPath accessPath) {
-    if (contents == null) return Nullness.NULLABLE;
+    if (contents == null) {
+      return Nullness.NULLABLE;
+    }
     Nullness nullness = contents.get(accessPath);
     return (nullness == null) ? Nullness.NULLABLE : nullness;
   }

File: nullaway/src/main/java/com/uber/nullaway/handlers/CompositeHandler.java
Patch:
@@ -218,7 +218,9 @@ public Optional<ErrorMessage> onExpressionDereference(
     Optional<ErrorMessage> optionalErrorMessage;
     for (Handler h : handlers) {
       optionalErrorMessage = h.onExpressionDereference(expr, baseExpr, state);
-      if (optionalErrorMessage.isPresent()) return optionalErrorMessage;
+      if (optionalErrorMessage.isPresent()) {
+        return optionalErrorMessage;
+      }
     }
     return Optional.empty();
   }

File: sample/src/main/java/com/uber/mylib/MyClass.java
Patch:
@@ -7,7 +7,9 @@
 public class MyClass {
 
   static void log(@Nullable Object x) {
-    if (x == null) return;
+    if (x == null) {
+      return;
+    }
     System.out.println(x.toString());
   }
 

File: jdk17-unit-tests/src/test/java/com/uber/nullaway/jdk17/NullAwayModuleInfoTests.java
Patch:
@@ -36,6 +36,9 @@ public void testModuleInfo() {
         .addSourceLines(
             "module-info.java",
             "module com.uber.mymodule {",
+            "  // Important: two-level deep module tests matching of identifier `java` as base expression;",
+            "  // see further discussion at https://github.com/uber/NullAway/pull/544#discussion_r780829467",
+            "  requires java.base;",
             "  requires static org.checkerframework.checker.qual;",
             "}")
         .doTest();

File: nullaway/src/test/java/com/uber/nullaway/NullAwayAndroidTest.java
Patch:
@@ -11,7 +11,6 @@
 
 /** Unit tests for {@link com.uber.nullaway.NullAway}. */
 @RunWith(JUnit4.class)
-@SuppressWarnings("CheckTestExtendsBaseClass")
 public class NullAwayAndroidTest {
   @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();
 

File: nullaway/src/test/java/com/uber/nullaway/NullAwayTest.java
Patch:
@@ -35,7 +35,6 @@
 
 /** Unit tests for {@link com.uber.nullaway.NullAway}. */
 @RunWith(JUnit4.class)
-@SuppressWarnings("CheckTestExtendsBaseClass")
 public class NullAwayTest {
 
   @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -48,6 +48,7 @@
 import com.google.errorprone.matchers.Description;
 import com.google.errorprone.matchers.Matcher;
 import com.google.errorprone.matchers.Matchers;
+import com.google.errorprone.suppliers.Suppliers;
 import com.google.errorprone.util.ASTHelpers;
 import com.sun.source.tree.AnnotationTree;
 import com.sun.source.tree.ArrayAccessTree;
@@ -402,7 +403,7 @@ public Description matchCompoundAssignment(CompoundAssignmentTree tree, VisitorS
       return Description.NO_MATCH;
     }
     Type lhsType = ASTHelpers.getType(tree.getVariable());
-    Type stringType = state.getTypeFromString("java.lang.String");
+    Type stringType = Suppliers.STRING_TYPE.get(state);
     if (lhsType != null && !state.getTypes().isSameType(lhsType, stringType)) {
       // both LHS and RHS could get unboxed
       return doUnboxingCheck(state, tree.getVariable(), tree.getExpression());

File: nullaway/src/main/java/com/uber/nullaway/handlers/AssertionHandler.java
Patch:
@@ -48,6 +48,7 @@ public NullnessHint onDataflowVisitMethodInvocation(
       MethodInvocationNode node,
       Types types,
       Context context,
+      AccessPath.AccessPathContext apContext,
       AccessPathNullnessPropagation.SubNodeValues inputs,
       AccessPathNullnessPropagation.Updates thenUpdates,
       AccessPathNullnessPropagation.Updates elseUpdates,
@@ -70,7 +71,7 @@ public NullnessHint onDataflowVisitMethodInvocation(
         Symbol.MethodSymbol receiver_symbol = ASTHelpers.getSymbol(receiver_method.getTree());
         if (methodNameUtil.isMethodAssertThat(receiver_symbol)) {
           Node arg = receiver_method.getArgument(0);
-          AccessPath ap = AccessPath.getAccessPathForNodeNoMapGet(arg);
+          AccessPath ap = AccessPath.getAccessPathForNodeNoMapGet(arg, apContext);
           if (ap != null) {
             bothUpdates.set(ap, NONNULL);
           }
@@ -85,7 +86,7 @@ public NullnessHint onDataflowVisitMethodInvocation(
         || methodNameUtil.isMethodJunitAssertThat(callee)) {
       List<Node> args = node.getArguments();
       if (args.size() == 2 && methodNameUtil.isMatcherIsNotNull(args.get(1))) {
-        AccessPath ap = AccessPath.getAccessPathForNodeNoMapGet(args.get(0));
+        AccessPath ap = AccessPath.getAccessPathForNodeNoMapGet(args.get(0), apContext);
         if (ap != null) {
           bothUpdates.set(ap, NONNULL);
         }

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handlers.java
Patch:
@@ -60,6 +60,7 @@ public static Handler buildDefault(Config config) {
     handlerListBuilder.add(StreamNullabilityPropagatorFactory.getJavaStreamNullabilityPropagator());
     handlerListBuilder.add(new ContractHandler(config));
     handlerListBuilder.add(new ApacheThriftIsSetHandler());
+    handlerListBuilder.add(new GrpcHandler());
     handlerListBuilder.add(new RequiresNonNullHandler());
     handlerListBuilder.add(new EnsuresNonNullHandler());
     if (config.checkOptionalEmptiness()) {

File: nullaway/src/main/java/com/uber/nullaway/handlers/InferredJARModelsHandler.java
Patch:
@@ -36,6 +36,7 @@
 import com.sun.tools.javac.util.Context;
 import com.uber.nullaway.Config;
 import com.uber.nullaway.NullAway;
+import com.uber.nullaway.dataflow.AccessPath;
 import com.uber.nullaway.dataflow.AccessPathNullnessPropagation;
 import java.io.DataInputStream;
 import java.io.IOException;
@@ -165,6 +166,7 @@ public NullnessHint onDataflowVisitMethodInvocation(
       MethodInvocationNode node,
       Types types,
       Context context,
+      AccessPath.AccessPathContext apContext,
       AccessPathNullnessPropagation.SubNodeValues inputs,
       AccessPathNullnessPropagation.Updates thenUpdates,
       AccessPathNullnessPropagation.Updates elseUpdates,

File: nullaway/src/main/java/com/uber/nullaway/handlers/RestrictiveAnnotationHandler.java
Patch:
@@ -35,6 +35,7 @@
 import com.uber.nullaway.NullAway;
 import com.uber.nullaway.NullabilityUtil;
 import com.uber.nullaway.Nullness;
+import com.uber.nullaway.dataflow.AccessPath;
 import com.uber.nullaway.dataflow.AccessPathNullnessPropagation;
 import java.util.HashSet;
 import java.util.List;
@@ -111,6 +112,7 @@ public NullnessHint onDataflowVisitMethodInvocation(
       MethodInvocationNode node,
       Types types,
       Context context,
+      AccessPath.AccessPathContext apContext,
       AccessPathNullnessPropagation.SubNodeValues inputs,
       AccessPathNullnessPropagation.Updates thenUpdates,
       AccessPathNullnessPropagation.Updates elseUpdates,

File: nullaway/src/main/java/com/uber/nullaway/Nullness.java
Patch:
@@ -21,7 +21,7 @@
 import com.sun.tools.javac.code.Symbol;
 import java.util.stream.Stream;
 import javax.lang.model.element.AnnotationMirror;
-import org.checkerframework.dataflow.analysis.AbstractValue;
+import org.checkerframework.nullaway.dataflow.analysis.AbstractValue;
 
 /**
  * Represents one of the possible nullness values in our nullness analysis.

File: nullaway/src/main/java/com/uber/nullaway/dataflow/CoreNullnessStoreInitializer.java
Patch:
@@ -17,8 +17,8 @@
 import java.util.List;
 import java.util.Objects;
 import javax.lang.model.element.Element;
-import org.checkerframework.dataflow.cfg.UnderlyingAST;
-import org.checkerframework.dataflow.cfg.node.LocalVariableNode;
+import org.checkerframework.nullaway.dataflow.cfg.UnderlyingAST;
+import org.checkerframework.nullaway.dataflow.cfg.node.LocalVariableNode;
 
 class CoreNullnessStoreInitializer extends NullnessStoreInitializer {
 
@@ -30,7 +30,7 @@ public NullnessStore getInitialStore(
       Context context,
       Types types,
       Config config) {
-    if (parameters == null) {
+    if (underlyingAST.getKind().equals(UnderlyingAST.Kind.ARBITRARY_CODE)) {
       // not a method or a lambda; an initializer expression or block
       UnderlyingAST.CFGStatement ast = (UnderlyingAST.CFGStatement) underlyingAST;
       return getEnvNullnessStoreForClass(ast.getClassTree(), context);

File: nullaway/src/main/java/com/uber/nullaway/dataflow/NullnessStoreInitializer.java
Patch:
@@ -13,8 +13,8 @@
 import java.util.Objects;
 import javax.annotation.Nullable;
 import javax.lang.model.element.NestingKind;
-import org.checkerframework.dataflow.cfg.UnderlyingAST;
-import org.checkerframework.dataflow.cfg.node.LocalVariableNode;
+import org.checkerframework.nullaway.dataflow.cfg.UnderlyingAST;
+import org.checkerframework.nullaway.dataflow.cfg.node.LocalVariableNode;
 
 /**
  * An abstract class that allows overriding initialization of nullness store in dataflow. Currently,

File: nullaway/src/main/java/com/uber/nullaway/handlers/ApacheThriftIsSetHandler.java
Patch:
@@ -37,9 +37,9 @@
 import javax.annotation.Nullable;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
-import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;
-import org.checkerframework.dataflow.cfg.node.Node;
-import org.checkerframework.javacutil.Pair;
+import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
+import org.checkerframework.nullaway.dataflow.cfg.node.Node;
+import org.checkerframework.nullaway.javacutil.Pair;
 
 /**
  * Handler to better handle {@code isSetXXXX()} methods in code generated by Apache Thrift. With

File: nullaway/src/main/java/com/uber/nullaway/handlers/AssertionHandler.java
Patch:
@@ -31,8 +31,8 @@
 import com.uber.nullaway.dataflow.AccessPath;
 import com.uber.nullaway.dataflow.AccessPathNullnessPropagation;
 import java.util.List;
-import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;
-import org.checkerframework.dataflow.cfg.node.Node;
+import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
+import org.checkerframework.nullaway.dataflow.cfg.node.Node;
 
 /** This Handler deals with assertions which ensure that their arguments cannot be null. */
 public class AssertionHandler extends BaseNoOpHandler {

File: nullaway/src/main/java/com/uber/nullaway/handlers/BaseNoOpHandler.java
Patch:
@@ -41,9 +41,9 @@
 import com.uber.nullaway.dataflow.NullnessStore;
 import java.util.List;
 import java.util.Optional;
-import org.checkerframework.dataflow.cfg.UnderlyingAST;
-import org.checkerframework.dataflow.cfg.node.LocalVariableNode;
-import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;
+import org.checkerframework.nullaway.dataflow.cfg.UnderlyingAST;
+import org.checkerframework.nullaway.dataflow.cfg.node.LocalVariableNode;
+import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
 
 /**
  * Provides a default (No-Op) implementation of every method defined by the Handler interface.

File: nullaway/src/main/java/com/uber/nullaway/handlers/CompositeHandler.java
Patch:
@@ -42,9 +42,9 @@
 import com.uber.nullaway.dataflow.NullnessStore;
 import java.util.List;
 import java.util.Optional;
-import org.checkerframework.dataflow.cfg.UnderlyingAST;
-import org.checkerframework.dataflow.cfg.node.LocalVariableNode;
-import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;
+import org.checkerframework.nullaway.dataflow.cfg.UnderlyingAST;
+import org.checkerframework.nullaway.dataflow.cfg.node.LocalVariableNode;
+import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
 
 /**
  * Registry of all handlers registered on our analysis.

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handler.java
Patch:
@@ -42,9 +42,9 @@
 import com.uber.nullaway.dataflow.NullnessStore;
 import java.util.List;
 import java.util.Optional;
-import org.checkerframework.dataflow.cfg.UnderlyingAST;
-import org.checkerframework.dataflow.cfg.node.LocalVariableNode;
-import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;
+import org.checkerframework.nullaway.dataflow.cfg.UnderlyingAST;
+import org.checkerframework.nullaway.dataflow.cfg.node.LocalVariableNode;
+import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
 
 /**
  * The general interface representing a handler.

File: nullaway/src/main/java/com/uber/nullaway/handlers/InferredJARModelsHandler.java
Patch:
@@ -53,7 +53,7 @@
 import java.util.jar.JarFile;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.type.TypeKind;
-import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;
+import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
 
 /** This handler loads inferred nullability model from stubs for methods in unannotated packages. */
 public class InferredJARModelsHandler extends BaseNoOpHandler {

File: nullaway/src/main/java/com/uber/nullaway/handlers/LibraryModelsHandler.java
Patch:
@@ -53,8 +53,8 @@
 import java.util.Set;
 import java.util.function.Function;
 import javax.annotation.Nullable;
-import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;
-import org.checkerframework.dataflow.cfg.node.Node;
+import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
+import org.checkerframework.nullaway.dataflow.cfg.node.Node;
 
 /**
  * This Handler deals with any methods from unannotated packages for which we need a nullability

File: nullaway/src/main/java/com/uber/nullaway/handlers/MethodNameUtil.java
Patch:
@@ -25,8 +25,8 @@
 import com.google.errorprone.util.ASTHelpers;
 import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.util.Name;
-import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;
-import org.checkerframework.dataflow.cfg.node.Node;
+import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
+import org.checkerframework.nullaway.dataflow.cfg.node.Node;
 
 /**
  * A utility class that holds the names from the Table. Currently, {@link

File: nullaway/src/main/java/com/uber/nullaway/handlers/OptionalEmptinessHandler.java
Patch:
@@ -53,8 +53,8 @@
 import javax.lang.model.element.Name;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
-import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;
-import org.checkerframework.dataflow.cfg.node.Node;
+import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
+import org.checkerframework.nullaway.dataflow.cfg.node.Node;
 
 /**
  * Handler to better handle {@code isPresent()} methods in code generated for Optionals. With this

File: nullaway/src/main/java/com/uber/nullaway/handlers/RestrictiveAnnotationHandler.java
Patch:
@@ -38,7 +38,7 @@
 import com.uber.nullaway.dataflow.AccessPathNullnessPropagation;
 import java.util.HashSet;
 import java.util.List;
-import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;
+import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
 
 public class RestrictiveAnnotationHandler extends BaseNoOpHandler {
 

File: nullaway/src/main/java/com/uber/nullaway/handlers/StreamNullabilityPropagator.java
Patch:
@@ -59,8 +59,8 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
-import org.checkerframework.dataflow.cfg.UnderlyingAST;
-import org.checkerframework.dataflow.cfg.node.LocalVariableNode;
+import org.checkerframework.nullaway.dataflow.cfg.UnderlyingAST;
+import org.checkerframework.nullaway.dataflow.cfg.node.LocalVariableNode;
 
 /**
  * This Handler transfers nullability info through chains of calls to methods of

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/ContractHandler.java
Patch:
@@ -40,7 +40,7 @@
 import com.uber.nullaway.dataflow.AccessPathNullnessPropagation;
 import com.uber.nullaway.handlers.BaseNoOpHandler;
 import javax.annotation.Nullable;
-import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;
+import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
 
 /**
  * This Handler parses the jetbrains @Contract annotation and honors the nullness spec defined there

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/ContractNullnessStoreInitializer.java
Patch:
@@ -17,8 +17,8 @@
 import com.uber.nullaway.handlers.Handler;
 import java.util.List;
 import javax.lang.model.element.Element;
-import org.checkerframework.dataflow.cfg.UnderlyingAST;
-import org.checkerframework.dataflow.cfg.node.LocalVariableNode;
+import org.checkerframework.nullaway.dataflow.cfg.UnderlyingAST;
+import org.checkerframework.nullaway.dataflow.cfg.node.LocalVariableNode;
 
 /**
  * Nullness Store initializer in case of dataflow for contract check. The nullability of parameters

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/ContractUtils.java
Patch:
@@ -12,7 +12,7 @@
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
 import javax.lang.model.element.AnnotationMirror;
-import org.checkerframework.javacutil.AnnotationUtils;
+import org.checkerframework.nullaway.javacutil.AnnotationUtils;
 
 /** An utility class for {@link ContractHandler} and {@link ContractCheckHandler}. */
 public class ContractUtils {

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/fieldcontract/EnsuresNonNullHandler.java
Patch:
@@ -45,7 +45,7 @@
 import java.util.Set;
 import java.util.stream.Collectors;
 import javax.lang.model.element.VariableElement;
-import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;
+import org.checkerframework.nullaway.dataflow.cfg.node.MethodInvocationNode;
 
 /**
  * This Handler parses {@code @EnsuresNonNull} annotation and when the annotated method is invoked,

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/fieldcontract/RequiresNonNullHandler.java
Patch:
@@ -46,8 +46,8 @@
 import java.util.List;
 import java.util.Set;
 import javax.lang.model.element.VariableElement;
-import org.checkerframework.dataflow.cfg.UnderlyingAST;
-import org.checkerframework.dataflow.cfg.node.LocalVariableNode;
+import org.checkerframework.nullaway.dataflow.cfg.UnderlyingAST;
+import org.checkerframework.nullaway.dataflow.cfg.node.LocalVariableNode;
 
 /**
  * This Handler parses {@code @RequiresNonNull} annotation and when the annotated method is invoked,

File: nullaway/src/test/resources/com/uber/nullaway/testdata/NullAwayTryFinallyCases.java
Patch:
@@ -122,7 +122,7 @@ public void derefOnFinallyReturn(@Nullable Object o) {
       }
       System.out.println(o.toString()); // Safe
     } finally {
-      /// ToDo: This should be an error, but isn't.
+      // BUG: Diagnostic contains: dereferenced expression
       System.out.println(o.toString());
     }
   }

File: nullaway/src/test/resources/com/uber/nullaway/testdata/NullAwayNegativeCases.java
Patch:
@@ -623,11 +623,13 @@ static void checkNotNullWithTemplateMessage(
     o23.toString();
   }
 
-  static void requireNonNull(@Nullable Object o, @Nullable Object p) {
+  static void requireNonNull(@Nullable Object o, @Nullable Object p, @Nullable Object q) {
     Objects.requireNonNull(o);
     o.toString();
     Objects.requireNonNull(p, "should be non null");
     p.toString();
+    Objects.requireNonNull(q, () -> "should be non null");
+    q.toString();
   }
 
   static void isEmpty(@Nullable String s) {

File: test-java-lib-lombok/src/main/java/com/uber/lombok/LombokBuilderInit.java
Patch:
@@ -28,6 +28,7 @@
 
 @Builder
 @Data
+@SuppressWarnings("SameNameButDifferent") // check crashes with EP 2.6.0
 public class LombokBuilderInit {
   private String field;
   @Builder.Default private String fieldWithDefault = "Default";

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handlers.java
Patch:
@@ -58,15 +58,15 @@ public static Handler buildDefault(Config config) {
     handlerListBuilder.add(new LibraryModelsHandler(config));
     handlerListBuilder.add(StreamNullabilityPropagatorFactory.getRxStreamNullabilityPropagator());
     handlerListBuilder.add(StreamNullabilityPropagatorFactory.getJavaStreamNullabilityPropagator());
-    handlerListBuilder.add(new ContractHandler());
+    handlerListBuilder.add(new ContractHandler(config));
     handlerListBuilder.add(new ApacheThriftIsSetHandler());
     handlerListBuilder.add(new RequiresNonNullHandler());
     handlerListBuilder.add(new EnsuresNonNullHandler());
     if (config.checkOptionalEmptiness()) {
       handlerListBuilder.add(new OptionalEmptinessHandler(config, methodNameUtil));
     }
     if (config.checkContracts()) {
-      handlerListBuilder.add(new ContractCheckHandler());
+      handlerListBuilder.add(new ContractCheckHandler(config));
     }
 
     return new CompositeHandler(handlerListBuilder.build());

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/ContractNullnessStoreInitializer.java
Patch:
@@ -1,9 +1,7 @@
 package com.uber.nullaway.handlers.contract;
 
-import static com.uber.nullaway.NullabilityUtil.getAnnotationValue;
 import static com.uber.nullaway.Nullness.NONNULL;
 import static com.uber.nullaway.Nullness.NULLABLE;
-import static com.uber.nullaway.handlers.contract.ContractHandler.CONTRACT_ANNOTATION_NAME;
 
 import com.google.errorprone.util.ASTHelpers;
 import com.sun.source.tree.ClassTree;
@@ -41,7 +39,7 @@ public NullnessStore getInitialStore(
     final MethodTree methodTree = ((UnderlyingAST.CFGMethod) underlyingAST).getMethod();
     final ClassTree classTree = ((UnderlyingAST.CFGMethod) underlyingAST).getClassTree();
     final Symbol.MethodSymbol callee = ASTHelpers.getSymbol(methodTree);
-    final String contractString = getAnnotationValue(callee, CONTRACT_ANNOTATION_NAME);
+    final String contractString = ContractUtils.getContractString(callee, config);
 
     assert contractString != null;
 

File: jar-infer/jar-infer-lib/src/main/java/com/uber/nullaway/jarinfer/DefinitelyDerefedParams.java
Patch:
@@ -35,7 +35,6 @@
 import com.ibm.wala.util.graph.dominators.Dominators;
 import com.ibm.wala.util.graph.impl.GraphInverter;
 import com.ibm.wala.util.graph.traverse.DFS;
-import com.sun.istack.internal.NotNull;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -127,7 +126,6 @@ Set<Integer> analyze() {
     return derefedParamList;
   }
 
-  @NotNull
   private Set<Integer> computeDerefParamList(int numParam, int firstParamIndex) {
     Set<Integer> derefedParamList = new HashSet<>();
     Map<ISSABasicBlock, Set<Integer>> blockToDerefSetMap = new HashMap<>();
@@ -156,7 +154,6 @@ private Set<Integer> computeDerefParamList(int numParam, int firstParamIndex) {
     return derefedParamList;
   }
 
-  @NotNull
   private Set<Integer> computeDerefParamListUsingPDom(int numParam, int firstParamIndex) {
     Set<Integer> derefedParamList = new HashSet<>();
     // Get Dominator Tree

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handlers.java
Patch:
@@ -55,7 +55,7 @@ public static Handler buildDefault(Config config) {
     if (config.handleTestAssertionLibraries()) {
       handlerListBuilder.add(new AssertionHandler(methodNameUtil));
     }
-    handlerListBuilder.add(new LibraryModelsHandler());
+    handlerListBuilder.add(new LibraryModelsHandler(config));
     handlerListBuilder.add(StreamNullabilityPropagatorFactory.getRxStreamNullabilityPropagator());
     handlerListBuilder.add(StreamNullabilityPropagatorFactory.getJavaStreamNullabilityPropagator());
     handlerListBuilder.add(new ContractHandler());

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/ContractCheckHandler.java
Patch:
@@ -22,7 +22,6 @@
 
 package com.uber.nullaway.handlers.contract;
 
-import static com.google.errorprone.BugCheckerInfo.buildDescriptionFromChecker;
 import static com.uber.nullaway.NullabilityUtil.getAnnotationValue;
 import static com.uber.nullaway.handlers.contract.ContractHandler.CONTRACT_ANNOTATION_NAME;
 import static com.uber.nullaway.handlers.contract.ContractUtils.getAntecedent;
@@ -148,7 +147,7 @@ public Void visitReturn(ReturnTree returnTree, Void unused) {
                         new ErrorMessage(
                             ErrorMessage.MessageTypes.ANNOTATION_VALUE_INVALID, errorMessage),
                         returnTree,
-                        buildDescriptionFromChecker(returnTree, analysis),
+                        analysis.buildDescription(returnTree),
                         returnState));
           }
           return super.visitReturn(returnTree, unused);

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/ContractHandler.java
Patch:
@@ -22,7 +22,6 @@
 
 package com.uber.nullaway.handlers.contract;
 
-import static com.google.errorprone.BugCheckerInfo.buildDescriptionFromChecker;
 import static com.uber.nullaway.handlers.contract.ContractUtils.getAntecedent;
 import static com.uber.nullaway.handlers.contract.ContractUtils.getConsequent;
 
@@ -159,7 +158,7 @@ public NullnessHint onDataflowVisitMethodInvocation(
                         new ErrorMessage(
                             ErrorMessage.MessageTypes.ANNOTATION_VALUE_INVALID, errorMessage),
                         node.getTree(),
-                        buildDescriptionFromChecker(node.getTree(), analysis),
+                        analysis.buildDescription(node.getTree()),
                         state));
             supported = false;
             break;

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/fieldcontract/EnsuresNonNullHandler.java
Patch:
@@ -22,7 +22,6 @@
 
 package com.uber.nullaway.handlers.contract.fieldcontract;
 
-import static com.google.errorprone.BugCheckerInfo.buildDescriptionFromChecker;
 import static com.uber.nullaway.NullabilityUtil.getAnnotationValueArray;
 
 import com.google.common.base.Preconditions;
@@ -106,7 +105,7 @@ protected boolean validateAnnotationSemantics(
               .createErrorDescription(
                   new ErrorMessage(ErrorMessage.MessageTypes.POSTCONDITION_NOT_SATISFIED, message),
                   tree,
-                  buildDescriptionFromChecker(tree, analysis),
+                  analysis.buildDescription(tree),
                   state));
       return false;
     }
@@ -162,7 +161,7 @@ protected void validateOverridingRules(
                     ErrorMessage.MessageTypes.WRONG_OVERRIDE_POSTCONDITION,
                     errorMessage.toString()),
                 tree,
-                buildDescriptionFromChecker(tree, analysis),
+                analysis.buildDescription(tree),
                 state));
   }
 

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/fieldcontract/RequiresNonNullHandler.java
Patch:
@@ -22,7 +22,6 @@
 
 package com.uber.nullaway.handlers.contract.fieldcontract;
 
-import static com.google.errorprone.BugCheckerInfo.buildDescriptionFromChecker;
 import static com.uber.nullaway.NullabilityUtil.getAnnotationValueArray;
 
 import com.google.common.base.Preconditions;
@@ -119,7 +118,7 @@ protected void validateOverridingRules(
                 new ErrorMessage(
                     ErrorMessage.MessageTypes.WRONG_OVERRIDE_PRECONDITION, errorMessage.toString()),
                 tree,
-                buildDescriptionFromChecker(tree, analysis),
+                analysis.buildDescription(tree),
                 state));
   }
 
@@ -163,7 +162,7 @@ public void onMatchMethodInvocation(
                 .createErrorDescription(
                     new ErrorMessage(ErrorMessage.MessageTypes.PRECONDITION_NOT_SATISFIED, message),
                     tree,
-                    buildDescriptionFromChecker(tree, analysis),
+                    analysis.buildDescription(tree),
                     state));
       }
     }

File: nullaway/src/main/java/com/uber/nullaway/handlers/contract/ContractHandler.java
Patch:
@@ -101,7 +101,7 @@ public NullnessHint onDataflowVisitMethodInvocation(
     Preconditions.checkNotNull(callee);
     // Check to see if this method has an @Contract annotation
     String contractString = NullabilityUtil.getAnnotationValue(callee, CONTRACT_ANNOTATION_NAME);
-    if (contractString != null) {
+    if (contractString != null && contractString.trim().length() > 0) {
       // Found a contract, lets parse it.
       String[] clauses = contractString.split(";");
       for (String clause : clauses) {

File: nullaway/src/main/java/com/uber/nullaway/Config.java
Patch:
@@ -144,6 +144,8 @@ public interface Config {
    */
   boolean checkOptionalEmptiness();
 
+  boolean checkContracts();
+
   /**
    * Checks if test assertion library handling is enabled.
    *

File: nullaway/src/main/java/com/uber/nullaway/ErrorProneCLIFlagsConfig.java
Patch:
@@ -57,6 +57,7 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
   static final String FL_ACKNOWLEDGE_RESTRICTIVE =
       EP_FL_NAMESPACE + ":AcknowledgeRestrictiveAnnotations";
   static final String FL_CHECK_OPTIONAL_EMPTINESS = EP_FL_NAMESPACE + ":CheckOptionalEmptiness";
+  static final String FL_CHECK_CONTRACTS = EP_FL_NAMESPACE + ":CheckContracts";
   static final String FL_HANDLE_TEST_ASSERTION_LIBRARIES =
       EP_FL_NAMESPACE + ":HandleTestAssertionLibraries";
   static final String FL_OPTIONAL_CLASS_PATHS =
@@ -149,6 +150,7 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
     isSuggestSuppressions = flags.getBoolean(FL_SUGGEST_SUPPRESSIONS).orElse(false);
     isAcknowledgeRestrictive = flags.getBoolean(FL_ACKNOWLEDGE_RESTRICTIVE).orElse(false);
     checkOptionalEmptiness = flags.getBoolean(FL_CHECK_OPTIONAL_EMPTINESS).orElse(false);
+    checkContracts = flags.getBoolean(FL_CHECK_CONTRACTS).orElse(false);
     handleTestAssertionLibraries =
         flags.getBoolean(FL_HANDLE_TEST_ASSERTION_LIBRARIES).orElse(false);
     treatGeneratedAsUnannotated = flags.getBoolean(FL_GENERATED_UNANNOTATED).orElse(false);

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPath.java
Patch:
@@ -87,7 +87,7 @@ private AccessPath(Root root, List<AccessPathElement> elements, MapKey mapGetArg
    * @param node the local
    * @return access path representing the local
    */
-  static AccessPath fromLocal(LocalVariableNode node) {
+  public static AccessPath fromLocal(LocalVariableNode node) {
     return new AccessPath(new Root(node.getElement()), ImmutableList.of());
   }
 

File: nullaway/src/main/java/com/uber/nullaway/dataflow/NullnessStore.java
Patch:
@@ -117,7 +117,7 @@ public Set<AccessPath> getAccessPathsWithValue(Nullness value) {
     return result;
   }
 
-  Builder toBuilder() {
+  public Builder toBuilder() {
     return new Builder(this);
   }
 

File: nullaway/src/main/java/com/uber/nullaway/handlers/BaseNoOpHandler.java
Patch:
@@ -53,7 +53,7 @@
  * interface. Additionally, we can add extensibility points without breaking existing handlers, as
  * long as we define the corresponding No-Op behavior here.
  */
-abstract class BaseNoOpHandler implements Handler {
+public abstract class BaseNoOpHandler implements Handler {
 
   protected BaseNoOpHandler() {
     // We don't allow creating useless handlers, subclass to add real behavior.

File: nullaway/src/main/java/com/uber/nullaway/handlers/LibraryModelsHandler.java
Patch:
@@ -360,6 +360,9 @@ private static class DefaultLibraryModels implements LibraryModels {
 
     private static final ImmutableSetMultimap<MethodRef, Integer> EXPLICITLY_NULLABLE_PARAMETERS =
         new ImmutableSetMultimap.Builder<MethodRef, Integer>()
+            .put(
+                methodRef("android.app.Service", "onStartCommand(android.content.Intent,int,int)"),
+                0)
             .put(
                 methodRef(
                     "android.view.GestureDetector.OnGestureListener",

File: nullaway/src/main/java/com/uber/nullaway/handlers/LibraryModelsHandler.java
Patch:
@@ -483,6 +483,8 @@ private static class DefaultLibraryModels implements LibraryModels {
 
     private static final ImmutableSet<MethodRef> NULLABLE_RETURNS =
         new ImmutableSet.Builder<MethodRef>()
+            .add(methodRef("com.sun.source.tree.CompilationUnitTree", "getPackageName()"))
+            .add(methodRef("java.lang.Throwable", "getMessage()"))
             .add(methodRef("java.lang.ref.Reference", "get()"))
             .add(methodRef("java.lang.ref.PhantomReference", "get()"))
             .add(methodRef("java.lang.ref.SoftReference", "get()"))
@@ -496,9 +498,8 @@ private static class DefaultLibraryModels implements LibraryModels {
             .add(methodRef("javax.lang.model.type.WildcardType", "getSuperBound()"))
             .add(methodRef("android.app.ActivityManager", "getRunningAppProcesses()"))
             .add(methodRef("android.view.View", "getHandler()"))
-            .add(methodRef("java.lang.Throwable", "getMessage()"))
             .add(methodRef("android.webkit.WebView", "getUrl()"))
-            .add(methodRef("com.sun.source.tree.CompilationUnitTree", "getPackageName()"))
+            .add(methodRef("android.widget.TextView", "getLayout()"))
             .build();
 
     private static final ImmutableSet<MethodRef> NONNULL_RETURNS =

File: jar-infer/jar-infer-lib/src/main/java/com/uber/nullaway/jarinfer/DefinitelyDerefedParams.java
Patch:
@@ -99,7 +99,7 @@ private static void LOG(boolean cond, String tag, String msg) {
   /**
    * This is the core analysis that identifies definitely-dereferenced parameters.
    *
-   * @return Set<Integer> The ordinal indices of formal parameters that are definitely-dereferenced.
+   * @return The ordinal indices of formal parameters that are definitely-dereferenced.
    */
   Set<Integer> analyze() {
     // Get ExceptionPrunedCFG

File: nullaway/src/main/java/com/uber/nullaway/handlers/LibraryModelsHandler.java
Patch:
@@ -675,7 +675,7 @@ private static class OptimizedLibraryModels {
      * name as an optimization. The {@link Name} data structure is used to avoid unnecessary String
      * conversions when looking up {@link com.sun.tools.javac.code.Symbol.MethodSymbol}s.
      *
-     * @param <T>
+     * @param <T> the type of the associated state.
      */
     private static class NameIndexedMap<T> {
 

File: nullaway/src/main/java/com/uber/nullaway/Nullness.java
Patch:
@@ -152,6 +152,8 @@ public static boolean isNullableAnnotation(String annotName, Config config) {
         // and will replace `org.checkerframework` with `shadow.checkerframework`. Yes, really...
         // I assume it's something to handle reflection.
         || annotName.endsWith(".checkerframework.checker.nullness.compatqual.NullableDecl")
+        // matches javax.annotation.CheckForNull and edu.umd.cs.findbugs.annotations.CheckForNull
+        || annotName.endsWith(".CheckForNull")
         || (config.acknowledgeAndroidRecent()
             && annotName.equals("androidx.annotation.RecentlyNullable"));
   }

File: nullaway/src/main/java/com/uber/nullaway/handlers/ContractHandler.java
Patch:
@@ -228,7 +228,8 @@ private void reportMatch(Tree errorLocTree, String message) {
               .createErrorDescription(
                   new ErrorMessage(ErrorMessage.MessageTypes.ANNOTATION_VALUE_INVALID, message),
                   errorLocTree,
-                  buildDescriptionFromChecker(errorLocTree, analysis)));
+                  buildDescriptionFromChecker(errorLocTree, analysis),
+                  this.state));
     }
   }
 

File: nullaway/src/main/java/com/uber/nullaway/handlers/LibraryModelsHandler.java
Patch:
@@ -465,6 +465,7 @@ private static class DefaultLibraryModels implements LibraryModels {
             .add(methodRef("android.view.View", "getHandler()"))
             .add(methodRef("java.lang.Throwable", "getMessage()"))
             .add(methodRef("android.webkit.WebView", "getUrl()"))
+            .add(methodRef("com.sun.source.tree.CompilationUnitTree", "getPackageName()"))
             .build();
 
     private static final ImmutableSet<MethodRef> NONNULL_RETURNS =

File: nullaway/src/main/java/com/uber/nullaway/ErrorProneCLIFlagsConfig.java
Patch:
@@ -110,7 +110,8 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
   static final ImmutableSet<String> DEFAULT_EXCLUDED_FIELD_ANNOT =
       ImmutableSet.of(
           "javax.inject.Inject", // no explicit initialization when there is dependency injection
-          "com.google.errorprone.annotations.concurrent.LazyInit");
+          "com.google.errorprone.annotations.concurrent.LazyInit",
+          "org.checkerframework.checker.nullness.qual.MonotonicNonNull");
 
   private static final String DEFAULT_URL = "http://t.uber.com/nullaway";
 

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -1486,7 +1486,7 @@ private void checkFieldInitialization(ClassTree tree, VisitorState state) {
     for (Element constructorElement : errorFieldsForInitializer.keySet()) {
       errorBuilder.reportInitializerError(
           (Symbol.MethodSymbol) constructorElement,
-          errMsgForInitializer(errorFieldsForInitializer.get(constructorElement)),
+          errMsgForInitializer(errorFieldsForInitializer.get(constructorElement), state),
           state,
           buildDescription(getTreesInstance(state).getTree(constructorElement)));
     }

File: nullaway/src/test/resources/com/uber/nullaway/testdata/NullAwayTryFinallyCases.java
Patch:
@@ -259,7 +259,8 @@ class Initializers {
       // method... mmh
     }
 
-    // BUG: Diagnostic contains: initializer method does not guarantee @NonNull field g is
+    // BUG: Diagnostic contains: initializer method does not guarantee @NonNull field g (line 228)
+    // is
     // initialized
     Initializers(Object o1, Object o2, Object o3) {
       f = new Object();

File: jar-infer/jar-infer-cli/src/main/java/com/uber/nullaway/jarinfer/JarInfer.java
Patch:
@@ -103,7 +103,8 @@ public static void main(String[] args) throws Exception {
         pkgName = "L" + pkgName.replaceAll("\\.", "/");
       }
       DefinitelyDerefedParamsDriver driver = new DefinitelyDerefedParamsDriver();
-      driver.run(jarPath, pkgName, outPath, annotateBytecode, stripJarSignatures, debug, verbose);
+      driver.run(
+          jarPath, pkgName, outPath, annotateBytecode, stripJarSignatures, false, debug, verbose);
       if (!new File(outPath).exists()) {
         System.out.println("Could not write jar file: " + outPath);
       }

File: jar-infer/jar-infer-lib/src/test/java/com/uber/nullaway/jarinfer/JarInferTest.java
Patch:
@@ -83,7 +83,8 @@ private void testTemplate(
         compileResult);
     DefinitelyDerefedParamsDriver driver = new DefinitelyDerefedParamsDriver();
     Map<String, Set<Integer>> result =
-        driver.run(temporaryFolder.getRoot().getAbsolutePath(), "L" + pkg.replaceAll("\\.", "/"));
+        driver.run(
+            temporaryFolder.getRoot().getAbsolutePath(), "L" + pkg.replaceAll("\\.", "/"), true);
     Assert.assertTrue(
         testName + ": test failed! \n" + result + " does not match " + expected,
         verify(result, new HashMap<>(expected)));

File: nullaway/src/main/java/com/uber/nullaway/ErrorProneCLIFlagsConfig.java
Patch:
@@ -95,6 +95,7 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
           "androidx.fragment.app.Fragment.onCreate",
           "androidx.fragment.app.Fragment.onAttach",
           "androidx.fragment.app.Fragment.onCreateView",
+          "androidx.fragment.app.Fragment.onActivityCreated",
           "androidx.fragment.app.Fragment.onViewCreated",
           // Multidex app
           "android.support.multidex.Application.onCreate");

File: nullaway/src/test/resources/com/uber/nullaway/testdata/androidstubs/androidx/Fragment.java
Patch:
@@ -40,4 +40,6 @@ public View onCreateView(
       LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
     return null;
   }
+
+  public void onActivityCreated(Bundle savedInstanceState) {}
 }

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -1433,6 +1433,9 @@ private void checkFieldInitialization(ClassTree tree, VisitorState state) {
           ASTHelpers.getSymbol(entities.instanceInitializerMethods().iterator().next());
     }
     for (Symbol uninitField : notInitializedAtAll) {
+      if (errorBuilder.symbolHasSuppressInitializationWarningsAnnotation(uninitField)) {
+        continue;
+      }
       if (singleInitializerMethod != null) {
         // report it on the initializer
         errorFieldsForInitializer.put(singleInitializerMethod, uninitField);

File: jar-infer/jar-infer-lib/src/main/java/com/uber/nullaway/jarinfer/BytecodeAnnotator.java
Patch:
@@ -110,7 +110,7 @@ private static void annotateBytecode(
       MethodReturnAnnotations nullableReturns)
       throws IOException {
     ClassReader cr = new ClassReader(is);
-    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
+    ClassWriter cw = new ClassWriter(0);
     BytecodeAnnotator bytecodeAnnotator = new BytecodeAnnotator(cw, nonnullParams, nullableReturns);
     cr.accept(bytecodeAnnotator, 0);
     os.write(cw.toByteArray());

File: nullaway/src/main/java/com/uber/nullaway/NullabilityUtil.java
Patch:
@@ -186,7 +186,7 @@ public static boolean mayBeNullFieldFromType(@Nullable Symbol symbol, Config con
     return !(symbol.getSimpleName().toString().equals("class")
             || symbol.isEnum()
             || isUnannotated(symbol, config))
-        && Nullness.hasNullableAnnotation(symbol);
+        && Nullness.hasNullableAnnotation(symbol, config);
   }
 
   /**

File: jar-infer/jar-infer-cli/src/main/java/com/uber/nullaway/jarinfer/JarInfer.java
Patch:
@@ -95,8 +95,8 @@ public static void main(String[] args) throws Exception {
       if (!pkgName.isEmpty()) {
         pkgName = "L" + pkgName.replaceAll("\\.", "/");
       }
-      DefinitelyDerefedParamsDriver.run(
-          jarPath, pkgName, outPath, annotateBytecode, debug, verbose);
+      DefinitelyDerefedParamsDriver driver = new DefinitelyDerefedParamsDriver();
+      driver.run(jarPath, pkgName, outPath, annotateBytecode, debug, verbose);
       if (!new File(outPath).exists()) {
         System.out.println("Could not write jar file: " + outPath);
       }

File: nullaway/src/main/java/com/uber/nullaway/handlers/InferredJARModelsHandler.java
Patch:
@@ -72,9 +72,9 @@ private static void LOG(boolean cond, String tag, String msg) {
 
   private static final int RETURN = -1; // '-1' indexes Return type in the Annotation Cache
 
-  private static Map<String, Map<String, Map<Integer, Set<String>>>> argAnnotCache;
-  private static Map<String, Set<String>> mapModelJarLocations;
-  private static Set<String> loadedJars;
+  private final Map<String, Map<String, Map<Integer, Set<String>>>> argAnnotCache;
+  private final Map<String, Set<String>> mapModelJarLocations;
+  private final Set<String> loadedJars;
 
   private final Config config;
 

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPathElement.java
Patch:
@@ -61,7 +61,7 @@ public String toString() {
         + "javaElement="
         + javaElement.toString()
         + ", constantArguments="
-        + Arrays.deepToString(constantArguments.toArray())
+        + Arrays.deepToString(constantArguments != null ? constantArguments.toArray() : null)
         + '}';
   }
 }

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handlers.java
Patch:
@@ -46,6 +46,9 @@ public static Handler buildDefault(Config config) {
     if (config.isJarInferEnabled()) {
       handlerListBuilder.add(new InferredJARModelsHandler(config));
     }
+    if (config.handleTestAssertionLibraries()) {
+      handlerListBuilder.add(new AssertionHandler());
+    }
     handlerListBuilder.add(new LibraryModelsHandler());
     handlerListBuilder.add(new RxNullabilityPropagator());
     handlerListBuilder.add(new ContractHandler());

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -507,7 +507,8 @@ public Description matchSwitch(SwitchTree tree, VisitorState state) {
     }
 
     if (mayBeNullExpr(state, switchExpression)) {
-      final String message = "switch expression " + switchExpression.toString() + " is @Nullable";
+      final String message =
+          "switch expression " + state.getSourceForNode(switchExpression) + " is @Nullable";
       ErrorMessage errorMessage =
           new ErrorMessage(MessageTypes.SWITCH_EXPRESSION_NULLABLE, message);
 

File: jar-infer/jar-infer-lib/src/main/java/com/uber/nullaway/jarinfer/DefinitelyDerefedParamsDriver.java
Patch:
@@ -145,7 +145,6 @@ public static Result run(String inPaths, String pkgName, String outPath, boolean
     DEBUG = dbg;
     VERBOSE = vbs;
     long start = System.currentTimeMillis();
-    String firstInPath = inPaths.split(",")[0];
     Set<String> setInPaths = new HashSet<>(Arrays.asList(inPaths.split(",")));
     for (String inPath : setInPaths) {
       InputStream jarIS = null;

File: jar-infer/jar-infer-lib/src/test/java/com/uber/nullaway/jarinfer/JarInferTest.java
Patch:
@@ -88,12 +88,10 @@ private void testTemplate(
   /**
    * Run a unit test with a specified jar file.
    *
-   * @param testName An useful name for the unit test.
    * @param pkg Qualified package name.
    * @param jarPath Path to the target jar file.
    */
   private void testJARTemplate(
-      String testName,
       String pkg, // in dot syntax
       String jarPath // in dot syntax
       ) throws Exception {
@@ -224,7 +222,6 @@ public void toyNonStatic() throws Exception {
   @Test
   public void toyJAR() throws Exception {
     testJARTemplate(
-        "toyJAR",
         "com.uber.nullaway.jarinfer.toys.unannotated",
         "../test-java-lib-jarinfer/build/libs/test-java-lib-jarinfer.jar");
   }

File: nullaway/src/main/java/com/uber/nullaway/handlers/LibraryModelsHandler.java
Patch:
@@ -124,7 +124,7 @@ public NullnessHint onDataflowVisitMethodInvocation(
     Symbol.MethodSymbol callee = ASTHelpers.getSymbol(node.getTree());
     Preconditions.checkNotNull(callee);
     setUnconditionalArgumentNullness(bothUpdates, node.getArguments(), callee, context);
-    setConditionalArgumentNullness(thenUpdates, elseUpdates, node.getArguments(), callee, context);
+    setConditionalArgumentNullness(elseUpdates, node.getArguments(), callee, context);
     if (getOptLibraryModels(context).hasNonNullReturn(callee, types)) {
       return NullnessHint.FORCE_NONNULL;
     } else if (getOptLibraryModels(context).hasNullableReturn(callee, types)) {
@@ -135,7 +135,6 @@ public NullnessHint onDataflowVisitMethodInvocation(
   }
 
   private void setConditionalArgumentNullness(
-      AccessPathNullnessPropagation.Updates thenUpdates,
       AccessPathNullnessPropagation.Updates elseUpdates,
       List<Node> arguments,
       Symbol.MethodSymbol callee,

File: nullaway/src/test/java/com/uber/nullaway/NullAwayAndroidTest.java
Patch:
@@ -17,6 +17,7 @@ public class NullAwayAndroidTest {
 
   private CompilationTestHelper compilationHelper;
 
+  @SuppressWarnings("CheckReturnValue")
   @Before
   public void setup() {
     compilationHelper = CompilationTestHelper.newInstance(NullAway.class, getClass());
@@ -174,6 +175,7 @@ public void androidxActivitySuccess() {
   }
 
   /** Initialises the default android classes that are commonly used. */
+  @SuppressWarnings("CheckReturnValue")
   private void initialiseAndroidCoreClasses() {
     compilationHelper
         .addSourceFile("androidstubs/core/Context.java")

File: nullaway/src/test/java/com/uber/nullaway/NullAwayTest.java
Patch:
@@ -40,6 +40,7 @@ public class NullAwayTest {
 
   private CompilationTestHelper compilationHelper;
 
+  @SuppressWarnings("CheckReturnValue")
   @Before
   public void setup() {
     compilationHelper = CompilationTestHelper.newInstance(NullAway.class, getClass());

File: sample-app/src/main/java/com/uber/myapplication/MainActivity.java
Patch:
@@ -22,6 +22,7 @@
 import org.utilities.StringUtils;
 
 /** Sample activity. */
+@SuppressWarnings("UnusedVariable") // This is sample code
 public class MainActivity extends AppCompatActivity {
   @NonNull private Object mOnCreateInitialiedField;
 

File: sample-app/src/main/java/com/uber/myapplication/MainFragment.java
Patch:
@@ -9,6 +9,7 @@
 import android.view.View;
 import android.view.ViewGroup;
 
+@SuppressWarnings("UnusedVariable") // This is sample code
 public class MainFragment extends Fragment {
 
   @NonNull private Object mOnCreateInitialisedField;

File: sample/src/main/java/com/uber/mylib/Lambdas.java
Patch:
@@ -8,6 +8,7 @@
 import javax.annotation.Nullable;
 
 /** Code that uses Java 8 lambdas */
+@SuppressWarnings("UnusedVariable") // This is sample code
 public class Lambdas {
 
   @FunctionalInterface

File: nullaway/src/test/java/com/uber/nullaway/NullAwayTest.java
Patch:
@@ -1715,7 +1715,6 @@ public void testNullableVarargs() {
             "package com.uber;",
             "import javax.annotation.Nullable;",
             "public class Utilities {",
-            " // BUG: Diagnostic contains: NullAway doesn't currently support @Nullable VarArgs",
             " public static String takesNullableVarargs(Object o, @Nullable Object... others) {",
             "  String s = o.toString() + \" \";",
             "  // BUG: Diagnostic contains: enhanced-for expression others is @Nullable",

File: nullaway/src/main/java/com/uber/nullaway/ErrorMessage.java
Patch:
@@ -48,6 +48,7 @@ public enum MessageTypes {
     FIELD_NO_INIT,
     UNBOX_NULLABLE,
     NONNULL_FIELD_READ_BEFORE_INIT,
+    NULLABLE_VARARGS_UNSUPPORTED,
     ANNOTATION_VALUE_INVALID,
     CAST_TO_NONNULL_ARG_NONNULL,
     GET_ON_EMPTY_OPTIONAL;

File: nullaway/src/main/java/com/uber/nullaway/Nullness.java
Patch:
@@ -154,7 +154,9 @@ public static boolean isNullableAnnotation(String annotName) {
    * @return true if we treat annotName as a <code>@NonNull</code> annotation, false otherwise
    */
   public static boolean isNonNullAnnotation(String annotName) {
-    return annotName.endsWith(".NonNull") || annotName.endsWith(".NotNull");
+    return annotName.endsWith(".NonNull")
+        || annotName.endsWith(".NotNull")
+        || annotName.endsWith(".Nonnull");
   }
 
   /**

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPathNullnessAnalysis.java
Patch:
@@ -48,8 +48,6 @@ public final class AccessPathNullnessAnalysis {
 
   private final DataFlow dataFlow;
 
-  private static String OPTIONAL_PATH = "java.util.Optional";
-
   // Use #instance to instantiate
   private AccessPathNullnessAnalysis(
       Predicate<MethodInvocationNode> methodReturnsNonNull,

File: nullaway/src/main/java/com/uber/nullaway/ErrorProneCLIFlagsConfig.java
Patch:
@@ -55,6 +55,7 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
   static final String FL_UNANNOTATED_CLASSES = EP_FL_NAMESPACE + ":UnannotatedClasses";
   static final String FL_ACKNOWLEDGE_RESTRICTIVE =
       EP_FL_NAMESPACE + ":AcknowledgeRestrictiveAnnotations";
+  static final String FL_CHECK_OPTIONAL_EMPTINESS = EP_FL_NAMESPACE + ":CheckOptionalEmptiness";
   static final String FL_SUPPRESS_COMMENT = EP_FL_NAMESPACE + ":AutoFixSuppressionComment";
   /** --- JarInfer configs --- */
   static final String FL_JI_ENABLED = EP_FL_NAMESPACE + ":JarInferEnabled";
@@ -132,6 +133,7 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
     isExhaustiveOverride = flags.getBoolean(FL_EXHAUSTIVE_OVERRIDE).orElse(false);
     isSuggestSuppressions = flags.getBoolean(FL_SUGGEST_SUPPRESSIONS).orElse(false);
     isAcknowledgeRestrictive = flags.getBoolean(FL_ACKNOWLEDGE_RESTRICTIVE).orElse(false);
+    checkOptionalEmptiness = flags.getBoolean(FL_CHECK_OPTIONAL_EMPTINESS).orElse(false);
     treatGeneratedAsUnannotated = flags.getBoolean(FL_GENERATED_UNANNOTATED).orElse(false);
     assertsEnabled = flags.getBoolean(FL_ASSERTS_ENABLED).orElse(false);
     fieldAnnotPattern =

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPath.java
Patch:
@@ -311,7 +311,7 @@ public static boolean isMapPut(Symbol.MethodSymbol symbol, Types types) {
    * root of an access path; either a variable {@link javax.lang.model.element.Element} or <code>
    * this</code> (enclosing method receiver)
    */
-  static final class Root {
+  public static final class Root {
 
     /** does this represent the receiver? */
     private final boolean isMethodReceiver;

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handlers.java
Patch:
@@ -50,6 +50,9 @@ public static Handler buildDefault(Config config) {
     handlerListBuilder.add(new RxNullabilityPropagator());
     handlerListBuilder.add(new ContractHandler());
     handlerListBuilder.add(new ApacheThriftIsSetHandler());
+    if (config.checkOptionalEmptiness()) {
+      handlerListBuilder.add(new OptionalEmptinessHandler());
+    }
     return new CompositeHandler(handlerListBuilder.build());
   }
 

File: nullaway/src/main/java/com/uber/nullaway/handlers/LibraryModelsHandler.java
Patch:
@@ -293,6 +293,7 @@ private static class DefaultLibraryModels implements LibraryModels {
                     "javax.lang.model.util.Elements",
                     "getDocComment(javax.lang.model.element.Element)"),
                 0)
+            .put(methodRef("java.util.Optional", "<T>of(T)"), 0)
             .put(methodRef("java.util.Deque", "addFirst(E)"), 0)
             .put(methodRef("java.util.Deque", "addLast(E)"), 0)
             .put(methodRef("java.util.Deque", "offerFirst(E)"), 0)

File: nullaway/src/test/resources/com/uber/nullaway/testdata/NullAwayNativeModels.java
Patch:
@@ -37,6 +37,7 @@
 import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import java.util.Optional;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.annotation.Nullable;
 import javax.lang.model.element.Element;
@@ -229,6 +230,8 @@ static void nonNullParameters() {
     File f = new File(s);
     // BUG: Diagnostic contains: passing @Nullable parameter 'null' where @NonNull is required
     URLClassLoader.newInstance(null, NullAwayNativeModels.class.getClassLoader());
+    // BUG: Diagnostic contains: passing @Nullable parameter 'null' where @NonNull is required
+    Optional<Object> op = Optional.of(null);
   }
 
   static void elementStuff(Element e, Elements elems) {

File: nullaway/src/test/resources/com/uber/nullaway/testdata/NullAwayNegativeCases.java
Patch:
@@ -524,9 +524,11 @@ static void checkNotNull(@Nullable Object o) {
     o.toString();
   }
 
-  static void requireNonNull(@Nullable Object o) {
+  static void requireNonNull(@Nullable Object o, @Nullable Object p) {
     Objects.requireNonNull(o);
     o.toString();
+    Objects.requireNonNull(p, "should be non null");
+    p.toString();
   }
 
   static void isEmpty(@Nullable String s) {

File: nullaway/src/main/java/com/uber/nullaway/ErrorProneCLIFlagsConfig.java
Patch:
@@ -57,6 +57,8 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
       EP_FL_NAMESPACE + ":AcknowledgeRestrictiveAnnotations";
   static final String FL_SUPPRESS_COMMENT = EP_FL_NAMESPACE + ":AutoFixSuppressionComment";
   /** --- JarInfer configs --- */
+  static final String FL_JI_ENABLED = EP_FL_NAMESPACE + ":JarInferEnabled";
+
   static final String FL_JI_USE_RETURN = EP_FL_NAMESPACE + ":JarInferUseReturnAnnotations";
 
   static final String FL_JI_REGEX_MODEL_PATH = EP_FL_NAMESPACE + ":JarInferRegexStripModelJar";
@@ -122,6 +124,7 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
           "Invalid -XepOpt" + FL_SUPPRESS_COMMENT + " value. Comment must be single line.");
     }
     /** --- JarInfer configs --- */
+    jarInferEnabled = flags.getBoolean(FL_JI_ENABLED).orElse(false);
     jarInferUseReturnAnnotations = flags.getBoolean(FL_JI_USE_RETURN).orElse(false);
     // The defaults of these two options translate to: remove .aar/.jar from the file name, and also
     // implicitly mean that NullAway will search for jarinfer models in the same jar which contains

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handlers.java
Patch:
@@ -43,7 +43,9 @@ public static Handler buildDefault(Config config) {
       // bytecode annotations
       handlerListBuilder.add(new RestrictiveAnnotationHandler(config));
     }
-    handlerListBuilder.add(new InferredJARModelsHandler(config));
+    if (config.isJarInferEnabled()) {
+      handlerListBuilder.add(new InferredJARModelsHandler(config));
+    }
     handlerListBuilder.add(new LibraryModelsHandler());
     handlerListBuilder.add(new RxNullabilityPropagator());
     handlerListBuilder.add(new ContractHandler());

File: nullaway/src/main/java/com/uber/nullaway/Config.java
Patch:
@@ -135,4 +135,7 @@ public interface Config {
 
   /** @return the URL to show with NullAway error messages */
   String getErrorURL();
+
+  /** @return true if generated code should be treated as unannotated */
+  boolean treatGeneratedAsUnannotated();
 }

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -942,7 +942,8 @@ private boolean fieldInitializedByPreviousInitializer(
       Symbol fieldSymbol, TreePath initTreePath, VisitorState state) {
     TreePath enclosingClassPath = initTreePath.getParentPath();
     ClassTree enclosingClass = (ClassTree) enclosingClassPath.getLeaf();
-    Multimap<Tree, Element> tree2Init = initTree2PrevFieldInit.get(enclosingClass);
+    Multimap<Tree, Element> tree2Init =
+        initTree2PrevFieldInit.get(ASTHelpers.getSymbol(enclosingClass));
     if (tree2Init == null) {
       tree2Init = computeTree2Init(enclosingClassPath, state);
       initTree2PrevFieldInit.put(ASTHelpers.getSymbol(enclosingClass), tree2Init);

File: nullaway/src/main/java/com/uber/nullaway/handlers/InferredJARModelsHandler.java
Patch:
@@ -238,9 +238,6 @@ private boolean lookupAndBuildCache(Symbol.ClassSymbol klass) {
           // Load model jars
           for (String modelJarPath : mapModelJarLocations.get(jarName)) {
             JarFile jar = new JarFile(modelJarPath);
-            if (jar == null) {
-              throw new Error("Cannot open jar: " + modelJarPath);
-            }
             LOG(DEBUG, "DEBUG", "Found model jar at: " + modelJarPath);
             JarEntry astubxJE = jar.getJarEntry(DEFAULT_ASTUBX_LOCATION);
             if (astubxJE == null) {

File: jar-infer/jar-infer-cli/src/main/java/com/uber/nullaway/jarinfer/JarInfer.java
Patch:
@@ -75,7 +75,7 @@ public static void main(String[] args) throws Exception {
     options.addOption(
         Option.builder("v").argName("verbose").longOpt("verbose").desc("set verbosity").build());
     try {
-      CommandLine line = (new DefaultParser()).parse(options, args);
+      CommandLine line = new DefaultParser().parse(options, args);
       if (line.hasOption('h')) {
         hf.printHelp(appName, options, true);
         return;

File: jar-infer/jar-infer-lib/src/main/java/com/uber/nullaway/jarinfer/DefinitelyDerefedParams.java
Patch:
@@ -132,7 +132,7 @@ public Set<Integer> analyze() {
     // Get number of params and value number of first param
     int numParam = ir.getSymbolTable().getNumberOfParameters();
     int firstParamIndex =
-        (method.isStatic()) ? 1 : 2; // 1-indexed; v1 is 'this' for non-static methods
+        method.isStatic() ? 1 : 2; // 1-indexed; v1 is 'this' for non-static methods
     LOG(DEBUG, "DEBUG", "param value numbers : " + firstParamIndex + " ... " + numParam);
     while (!nodeQueue.isEmpty()) {
       ISSABasicBlock node = nodeQueue.get(0);

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -2160,7 +2160,7 @@ private int depth(ExpressionTree expression) {
       case IDENTIFIER:
         IdentifierTree varTree = (IdentifierTree) expression;
         Symbol symbol = ASTHelpers.getSymbol(varTree);
-        return (symbol.getKind().equals(ElementKind.FIELD)) ? 2 : 1;
+        return symbol.getKind().equals(ElementKind.FIELD) ? 2 : 1;
       default:
         return 0;
     }

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPath.java
Patch:
@@ -50,7 +50,7 @@
  *
  * <p>We do not allow array accesses in access paths for the moment.
  */
-public class AccessPath {
+public final class AccessPath {
 
   private final Root root;
 
@@ -240,7 +240,7 @@ public boolean equals(Object o) {
     if (this == o) {
       return true;
     }
-    if (o == null || getClass() != o.getClass()) {
+    if (!(o instanceof AccessPath)) {
       return false;
     }
 

File: nullaway/src/main/java/com/uber/nullaway/handlers/InferredJARModelsHandler.java
Patch:
@@ -110,7 +110,7 @@ public InferredJARModelsHandler(Config config) {
    */
   private void processClassPath() {
     URL[] classLoaderUrls =
-        ((URLClassLoader) (Thread.currentThread().getContextClassLoader())).getURLs();
+        ((URLClassLoader) Thread.currentThread().getContextClassLoader()).getURLs();
     for (URL url : classLoaderUrls) {
       String path = url.getFile();
       if (path.matches(config.getJarInferRegexStripModelJarName())) {

File: nullaway/src/main/java/com/uber/nullaway/Config.java
Patch:
@@ -95,6 +95,9 @@ public interface Config {
    */
   boolean suggestSuppressions();
 
+  /** @return true if the assert support is enabled. */
+  boolean assertsEnabled();
+
   /**
    * @return true if the null checker should acknowledge stricter nullability annotations whenever
    *     they are available in unannotated code, defaulting to optimistic defaults only when

File: nullaway/src/main/java/com/uber/nullaway/ErrorProneCLIFlagsConfig.java
Patch:
@@ -39,6 +39,7 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
 
   static final String EP_FL_NAMESPACE = "NullAway";
   static final String FL_ANNOTATED_PACKAGES = EP_FL_NAMESPACE + ":AnnotatedPackages";
+  static final String FL_ASSERTS_ENABLED = EP_FL_NAMESPACE + ":AssertsEnabled";
   static final String FL_UNANNOTATED_SUBPACKAGES = EP_FL_NAMESPACE + ":UnannotatedSubPackages";
   static final String FL_CLASSES_TO_EXCLUDE = EP_FL_NAMESPACE + ":ExcludedClasses";
   static final String FL_EXHAUSTIVE_OVERRIDE = EP_FL_NAMESPACE + ":ExhaustiveOverride";
@@ -110,6 +111,7 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
     isSuggestSuppressions = flags.getBoolean(FL_SUGGEST_SUPPRESSIONS).orElse(false);
     isAcknowledgeRestrictive = flags.getBoolean(FL_ACKNOWLEDGE_RESTRICTIVE).orElse(false);
     treatGeneratedAsUnannotated = flags.getBoolean(FL_GENERATED_UNANNOTATED).orElse(false);
+    assertsEnabled = flags.getBoolean(FL_ASSERTS_ENABLED).orElse(false);
     fieldAnnotPattern =
         getPackagePattern(
             getFlagStringSet(flags, FL_EXCLUDED_FIELD_ANNOT, DEFAULT_EXCLUDED_FIELD_ANNOT));

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPathNullnessAnalysis.java
Patch:
@@ -56,7 +56,7 @@ private AccessPathNullnessAnalysis(
     this.nullnessPropagation =
         new AccessPathNullnessPropagation(
             Nullness.NONNULL, methodReturnsNonNull, context, config, handler);
-    this.dataFlow = new DataFlow();
+    this.dataFlow = new DataFlow(config.assertsEnabled());
   }
 
   /**

File: nullaway/src/main/java/com/uber/nullaway/AbstractConfig.java
Patch:
@@ -139,8 +139,8 @@ public boolean isUnannotatedClass(Symbol.ClassSymbol symbol) {
   }
 
   @Override
-  public boolean isExcludedClassAnnotation(String annotationName) {
-    return excludedClassAnnotations.contains(annotationName);
+  public ImmutableSet<String> getExcludedClassAnnotations() {
+    return ImmutableSet.copyOf(excludedClassAnnotations);
   }
 
   @Override

File: nullaway/src/main/java/com/uber/nullaway/DummyOptionsConfig.java
Patch:
@@ -25,6 +25,7 @@
 import static com.uber.nullaway.ErrorProneCLIFlagsConfig.EP_FL_NAMESPACE;
 import static com.uber.nullaway.ErrorProneCLIFlagsConfig.FL_ANNOTATED_PACKAGES;
 
+import com.google.common.collect.ImmutableSet;
 import com.sun.tools.javac.code.Symbol;
 import javax.annotation.Nullable;
 
@@ -67,7 +68,7 @@ public boolean isUnannotatedClass(Symbol.ClassSymbol symbol) {
   }
 
   @Override
-  public boolean isExcludedClassAnnotation(String annotationName) {
+  public ImmutableSet<String> getExcludedClassAnnotations() {
     throw new IllegalStateException(error_msg);
   }
 

File: nullaway/src/main/java/com/uber/nullaway/AbstractConfig.java
Patch:
@@ -187,7 +187,7 @@ public String getCastToNonNullMethod() {
   @Override
   public String getAutofixSuppressionComment() {
     if (autofixSuppressionComment.trim().length() > 0) {
-      return " /* " + autofixSuppressionComment + " */ ";
+      return "/* " + autofixSuppressionComment + " */ ";
     } else {
       return "";
     }

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -242,7 +242,8 @@ private Predicate<MethodInvocationNode> nonAnnotatedMethodCheck() {
 
   @Override
   public String linkUrl() {
-    return "http://t.uber.com/nullaway ";
+    // add a space to make it clickable from iTerm
+    return config.getErrorURL() + " ";
   }
 
   /**

File: nullaway/src/main/java/com/uber/nullaway/handlers/LibraryModelsHandler.java
Patch:
@@ -297,6 +297,7 @@ private static class DefaultLibraryModels implements LibraryModels {
 
     private static final ImmutableSet<MethodRef> NONNULL_RETURNS =
         new ImmutableSet.Builder<MethodRef>()
+            .add(methodRef("com.google.gson", "<T>fromJson(String,Class)"))
             .add(methodRef("android.app.Activity", "<T>findViewById(int)"))
             .add(methodRef("android.view.View", "<T>findViewById(int)"))
             .add(methodRef("android.view.View", "getResources()"))

File: jar-infer/jar-infer-cli/src/main/java/com/uber/nullaway/jarinfer/JarInfer.java
Patch:
@@ -33,7 +33,7 @@ public class JarInfer {
    *
    * @param args Command line arguments.
    */
-  public static void main(String[] args) {
+  public static void main(String[] args) throws Exception {
     Options options = new Options();
     HelpFormatter hf = new HelpFormatter();
     hf.setWidth(100);
@@ -94,8 +94,6 @@ public static void main(String[] args) {
       }
     } catch (ParseException pe) {
       hf.printHelp(appName, options, true);
-    } catch (Exception e) {
-      e.printStackTrace();
     }
   }
 }

File: jar-infer/jar-infer-lib/src/test/java/com/uber/nullaway/jarinfer/CompilerUtil.java
Patch:
@@ -63,7 +63,7 @@ public CompilerUtil(Class<?> klass) {
     try {
       fileManager.setLocation(StandardLocation.SOURCE_PATH, Collections.<File>emptyList());
     } catch (IOException e) {
-      e.printStackTrace();
+      throw new RuntimeException("unexpected IOException", e);
     }
     outputStream = new ByteArrayOutputStream();
     this.compiler =

File: nullaway/src/main/java/com/uber/nullaway/handlers/RxNullabilityPropagator.java
Patch:
@@ -51,9 +51,9 @@
 import com.uber.nullaway.dataflow.AccessPath;
 import com.uber.nullaway.dataflow.AccessPathNullnessAnalysis;
 import com.uber.nullaway.dataflow.NullnessStore;
+import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -543,7 +543,7 @@ public void onDataflowVisitLambdaResultExpression(
    */
   private static class StreamModelBuilder {
 
-    private final List<StreamTypeRecord> typeRecords = new LinkedList<StreamTypeRecord>();
+    private final List<StreamTypeRecord> typeRecords = new ArrayList<StreamTypeRecord>();
     private TypePredicate tp = null;
     private ImmutableSet.Builder<String> filterMethodSigs;
     private ImmutableSet.Builder<String> filterMethodSimpleNames;

File: nullaway/src/main/java/com/uber/nullaway/handlers/InferredJARModelsHandler.java
Patch:
@@ -56,7 +56,7 @@ private static void LOG(boolean cond, String tag, String msg) {
 
   private static final int VERSION_0_FILE_MAGIC_NUMBER = 691458791;
   private static final String DEFAULT_ASTUBX_LOCATION = "META-INF/nullaway/jarinfer.astubx";
-  private static final String ANDROID_ASTUBX_LOCATION = "resources/jarinfer.astubx";
+  private static final String ANDROID_ASTUBX_LOCATION = "jarinfer.astubx";
   private static final String ANDROID_MODEL_CLASS =
       "com.uber.nullaway.jarinfer.AndroidJarInferModels";
 

File: jar-infer/jar-infer-lib/src/main/java/com/uber/nullaway/jarinfer/DefinitelyDerefedParamsDriver.java
Patch:
@@ -329,7 +329,7 @@ private static void writeProcessedAAR(String inAarPath, String outAarPath) throw
   private static void writeModelToJarStream(ZipInputStream zis, ZipOutputStream zos)
       throws IOException {
     for (ZipEntry ze; (ze = zis.getNextEntry()) != null; ) {
-      zos.putNextEntry(ze);
+      zos.putNextEntry(new ZipEntry(ze.getName()));
       IOUtils.copy(zis, zos);
       zos.closeEntry();
     }

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handlers.java
Patch:
@@ -43,6 +43,7 @@ public static Handler buildDefault(Config config) {
       // bytecode annotations
       handlerListBuilder.add(new RestrictiveAnnotationHandler(config));
     }
+    handlerListBuilder.add(new InferredJARModelsHandler());
     handlerListBuilder.add(new LibraryModelsHandler());
     handlerListBuilder.add(new RxNullabilityPropagator());
     handlerListBuilder.add(new ContractHandler());

File: nullaway/src/main/java/com/uber/nullaway/handlers/LibraryModelsHandler.java
Patch:
@@ -300,6 +300,7 @@ private static class DefaultLibraryModels implements LibraryModels {
             .add(methodRef("android.app.Activity", "<T>findViewById(int)"))
             .add(methodRef("android.view.View", "<T>findViewById(int)"))
             .add(methodRef("android.view.View", "getResources()"))
+            .add(methodRef("android.view.ViewGroup", "getChildAt(int)"))
             .add(
                 methodRef(
                     "android.content.res.Resources",

File: test-java-lib/src/main/java/com/uber/lib/unannotated/RestrictivelyAnnotatedClass.java
Patch:
@@ -5,7 +5,7 @@
 
 public class RestrictivelyAnnotatedClass {
 
-  private final Object field;
+  public final Object field;
 
   public RestrictivelyAnnotatedClass(Object field) {
     this.field = field;

File: nullaway/src/main/java/com/uber/nullaway/ErrorProneCLIFlagsConfig.java
Patch:
@@ -50,6 +50,8 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
   static final String FL_CTNN_METHOD = EP_FL_NAMESPACE + ":CastToNonNullMethod";
   static final String FL_EXTERNAL_INIT_ANNOT = EP_FL_NAMESPACE + ":ExternalInitAnnotations";
   static final String FL_UNANNOTATED_CLASSES = EP_FL_NAMESPACE + ":UnannotatedClasses";
+  static final String FL_ACKNOWLEDGE_RESTRICTIVE =
+      EP_FL_NAMESPACE + ":AcknowledgeRestrictiveAnnotations";
   private static final String DELIMITER = ",";
 
   static final ImmutableSet<String> DEFAULT_KNOWN_INITIALIZERS =
@@ -94,6 +96,7 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
     externalInitAnnotations = getFlagStringSet(flags, FL_EXTERNAL_INIT_ANNOT);
     isExhaustiveOverride = flags.getBoolean(FL_EXHAUSTIVE_OVERRIDE).orElse(false);
     isSuggestSuppressions = flags.getBoolean(FL_SUGGEST_SUPPRESSIONS).orElse(false);
+    isAcknowledgeRestrictive = flags.getBoolean(FL_ACKNOWLEDGE_RESTRICTIVE).orElse(false);
     treatGeneratedAsUnannotated = flags.getBoolean(FL_GENERATED_UNANNOTATED).orElse(false);
     fieldAnnotPattern =
         getPackagePattern(

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -182,7 +182,7 @@ public class NullAway extends BugChecker
    * The handler passed to our analysis (usually a {@code CompositeHandler} including handlers for
    * various APIs.
    */
-  private final Handler handler = Handlers.buildDefault();
+  private final Handler handler;
 
   /**
    * entities relevant to field initialization per class. cached for performance. nulled out in
@@ -221,11 +221,13 @@ public class NullAway extends BugChecker
    */
   public NullAway() {
     config = new DummyOptionsConfig();
+    handler = Handlers.buildEmpty();
     nonAnnotatedMethod = nonAnnotatedMethodCheck();
   }
 
   public NullAway(ErrorProneFlags flags) {
     config = new ErrorProneCLIFlagsConfig(flags);
+    handler = Handlers.buildDefault(config);
     nonAnnotatedMethod = nonAnnotatedMethodCheck();
     // workaround for Checker Framework static state bug;
     // See https://github.com/typetools/checker-framework/issues/1482

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -1663,6 +1663,8 @@ private boolean mayBeNullExpr(VisitorState state, ExpressionTree expr) {
       case AND:
       case OR:
       case XOR:
+      case LEFT_SHIFT:
+      case RIGHT_SHIFT:
         // clearly not null
         exprMayBeNull = false;
         break;

File: nullaway/src/main/java/com/uber/nullaway/handlers/ApacheThriftIsSetHandler.java
Patch:
@@ -116,6 +116,8 @@ private boolean thriftIsSetCall(Symbol.MethodSymbol symbol, Types types) {
     // noinspection ConstantConditions
     return tbaseType.isPresent()
         && symbol.getSimpleName().toString().startsWith("isSet")
+        // weeds out the isSet() method in TBase itself
+        && symbol.getParameters().length() == 0
         && types.isSubtype(symbol.owner.type, tbaseType.get());
   }
 }

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPathNullnessPropagation.java
Patch:
@@ -207,7 +207,7 @@ private NullnessStore<Nullness> lambdaInitialStore(
       // corresponding functional interface parameter, unless they are explicitly annotated
       if (Nullness.hasNullableAnnotation(element)) {
         assumed = NULLABLE;
-      } else if (NullabilityUtil.lambdaParamIsExplicitlyTyped(variableTree)) {
+      } else if (!NullabilityUtil.lambdaParamIsImplicitlyTyped(variableTree)) {
         // the parameter has a declared type with no @Nullable annotation
         // treat as non-null
         assumed = NONNULL;

File: nullaway/src/main/java/com/uber/nullaway/handlers/ContractHandler.java
Patch:
@@ -190,6 +190,9 @@ public NullnessHint onDataflowVisitMethodInvocation(
         // consequent to
         // fix the nullness of this argument.
         AccessPath accessPath = AccessPath.getAccessPathForNodeNoMapGet(node.getArgument(argIdx));
+        if (accessPath == null) {
+          continue;
+        }
         if (consequent.equals("false") && argAntecedentNullness.equals(Nullness.NULLABLE)) {
           // If argIdx being null implies the return of the method being false, then the return
           // being true

File: nullaway/src/main/java/com/uber/nullaway/Config.java
Patch:
@@ -34,7 +34,7 @@ public interface Config {
    *     according to our convention (every possibly null parameter / return / field
    *     annotated @Nullable), false otherwise
    */
-  boolean fromAnnotatedPackage(String className);
+  boolean fromAnnotatedPackage(Symbol.ClassSymbol symbol);
 
   /**
    * @param className fully-qualified class name

File: nullaway/src/main/java/com/uber/nullaway/DummyOptionsConfig.java
Patch:
@@ -52,7 +52,7 @@ public class DummyOptionsConfig implements Config {
   public DummyOptionsConfig() {}
 
   @Override
-  public boolean fromAnnotatedPackage(String className) {
+  public boolean fromAnnotatedPackage(Symbol.ClassSymbol symbol) {
     throw new IllegalStateException(error_msg);
   }
 

File: nullaway/src/main/java/com/uber/nullaway/ErrorProneCLIFlagsConfig.java
Patch:
@@ -44,6 +44,7 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
   static final String FL_CLASS_ANNOTATIONS_TO_EXCLUDE =
       EP_FL_NAMESPACE + ":ExcludedClassAnnotations";
   static final String FL_SUGGEST_SUPPRESSIONS = EP_FL_NAMESPACE + ":SuggestSuppressions";
+  static final String FL_GENERATED_UNANNOTATED = EP_FL_NAMESPACE + ":TreatGeneratedAsUnannotated";
   static final String FL_EXCLUDED_FIELD_ANNOT = EP_FL_NAMESPACE + ":ExcludedFieldAnnotations";
   static final String FL_INITIALIZER_ANNOT = EP_FL_NAMESPACE + ":CustomInitializerAnnotations";
   static final String FL_CTNN_METHOD = EP_FL_NAMESPACE + ":CastToNonNullMethod";
@@ -91,6 +92,7 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
     externalInitAnnotations = getFlagStringSet(flags, FL_EXTERNAL_INIT_ANNOT);
     isExhaustiveOverride = flags.getBoolean(FL_EXHAUSTIVE_OVERRIDE).orElse(false);
     isSuggestSuppressions = flags.getBoolean(FL_SUGGEST_SUPPRESSIONS).orElse(false);
+    treatGeneratedAsUnannotated = flags.getBoolean(FL_GENERATED_UNANNOTATED).orElse(false);
     fieldAnnotPattern =
         getPackagePattern(
             getFlagStringSet(flags, FL_EXCLUDED_FIELD_ANNOT, DEFAULT_EXCLUDED_FIELD_ANNOT));

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -1448,7 +1448,7 @@ private boolean isExcludedClass(Symbol.ClassSymbol classSymbol, VisitorState sta
     if (config.isExcludedClass(className)) {
       return true;
     }
-    if (!config.fromAnnotatedPackage(className)) {
+    if (!config.fromAnnotatedPackage(classSymbol)) {
       return true;
     }
     // check annotations

File: nullaway/src/main/java/com/uber/nullaway/NullabilityUtil.java
Patch:
@@ -161,6 +161,6 @@ public static boolean mayBeNullFieldFromType(@Nullable Symbol symbol, Config con
    */
   public static boolean fromUnannotatedPackage(Symbol symbol, Config config) {
     Symbol.ClassSymbol outermostClassSymbol = getOutermostClassSymbol(symbol);
-    return !config.fromAnnotatedPackage(outermostClassSymbol.toString());
+    return !config.fromAnnotatedPackage(outermostClassSymbol);
   }
 }

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPathNullnessPropagation.java
Patch:
@@ -720,7 +720,9 @@ public TransferResult<Nullness, NullnessStore<Nullness>> visitLambdaResultExpres
       TransferInput<Nullness, NullnessStore<Nullness>> input) {
     handler.onDataflowVisitLambdaResultExpression(
         resultNode.getTree(), input.getThenStore(), input.getElseStore());
-    return noStoreChanges(NULLABLE, input);
+    SubNodeValues values = values(input);
+    Nullness nullness = values.valueOfSubNode(resultNode.getResult());
+    return noStoreChanges(nullness, input);
   }
 
   @Override

File: nullaway/src/main/java/com/uber/nullaway/Nullness.java
Patch:
@@ -40,7 +40,7 @@ public enum Nullness implements AbstractValue<Nullness> {
    *         Bottom
    * </pre>
    */
-  NULLABLE("Nullable"), // TODO(eaftan): Rename to POSSIBLY_NULL?
+  NULLABLE("Nullable"),
   NULL("Null"),
   NONNULL("Non-null"),
   BOTTOM("Bottom");

File: nullaway/src/main/java/com/uber/nullaway/handlers/LibraryModelsHandler.java
Patch:
@@ -124,7 +124,7 @@ private static Iterable<AccessPath> accessPathsAtIndexes(
       Preconditions.checkArgument(i >= 0 && i < arguments.size(), "Invalid argument index: " + i);
       if (i >= 0 && i < arguments.size()) {
         Node argument = arguments.get(i);
-        AccessPath ap = AccessPath.getAccessPathForNode(argument);
+        AccessPath ap = AccessPath.getAccessPathForNodeNoMapGet(argument);
         if (ap != null) {
           result.add(ap);
         }

File: nullaway/src/main/java/com/uber/nullaway/handlers/LibraryModelsHandler.java
Patch:
@@ -245,7 +245,7 @@ private static class DefaultLibraryModels implements LibraryModels {
     private static final ImmutableSetMultimap<MethodRef, Integer> NULL_IMPLIES_TRUE_PARAMETERS =
         new ImmutableSetMultimap.Builder<MethodRef, Integer>()
             .put(methodRef(Strings.class, "isNullOrEmpty(java.lang.String)"), 0)
-            .put(methodRef("android.text.TextUtils", "isEmpty(java.lang.String)"), 0)
+            .put(methodRef("android.text.TextUtils", "isEmpty(java.lang.CharSequence)"), 0)
             .build();
 
     private static final ImmutableSet<MethodRef> NULLABLE_RETURNS =

File: nullaway/src/test/java/com/uber/nullaway/NullAwayTest.java
Patch:
@@ -97,6 +97,7 @@ public void coreNullabilityNativeModels() {
     compilationHelper
         .addSourceFile("NullAwayNativeModels.java")
         .addSourceFile("androidstubs/WebView.java")
+        .addSourceFile("androidstubs/TextUtils.java")
         .doTest();
   }
 

File: nullaway/src/main/java/com/uber/nullaway/AbstractConfig.java
Patch:
@@ -36,7 +36,6 @@
 /** abstract base class for null checker {@link Config} implementations */
 public abstract class AbstractConfig implements Config {
 
-  private static final Pattern NULLABLE_PATTERN = Pattern.compile("(?:(.*)\\.Nullable$)");
   /**
    * Packages that we assume have appropriate nullability annotations.
    *
@@ -123,7 +122,7 @@ public boolean isKnownInitializerMethod(Symbol.MethodSymbol methodSymbol) {
 
   @Override
   public boolean isExcludedFieldAnnotation(String annotationName) {
-    return NULLABLE_PATTERN.matcher(annotationName).matches()
+    return Nullness.isNullableAnnotation(annotationName)
         || (fieldAnnotPattern != null && fieldAnnotPattern.matcher(annotationName).matches());
   }
 

File: nullaway/src/main/java/com/uber/nullaway/AbstractConfig.java
Patch:
@@ -56,7 +56,7 @@ public abstract class AbstractConfig implements Config {
   /** Source code in these packages will not be analyzed for nullability issues */
   @Nullable protected ImmutableSet<String> sourceClassesToExclude;
 
-  @Nullable protected Pattern fieldAnnotPattern;
+  protected Pattern fieldAnnotPattern;
 
   protected boolean isExhaustiveOverride;
 

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPathNullnessPropagation.java
Patch:
@@ -675,11 +675,11 @@ public TransferResult<Nullness, NullnessStore<Nullness>> visitVariableDeclaratio
   public TransferResult<Nullness, NullnessStore<Nullness>> visitFieldAccess(
       FieldAccessNode fieldAccessNode, TransferInput<Nullness, NullnessStore<Nullness>> input) {
     ReadableUpdates updates = new ReadableUpdates();
-    setReceiverNonnull(
-        updates, fieldAccessNode.getReceiver(), ASTHelpers.getSymbol(fieldAccessNode.getTree()));
+    Symbol symbol = ASTHelpers.getSymbol(fieldAccessNode.getTree());
+    setReceiverNonnull(updates, fieldAccessNode.getReceiver(), symbol);
     VariableElement element = fieldAccessNode.getElement();
     Nullness nullness = Nullness.NULLABLE;
-    if (!Nullness.hasNullableAnnotation(element)) {
+    if (!NullabilityUtil.mayBeNullFieldFromType(symbol, config)) {
       nullness = NONNULL;
     } else {
       nullness = input.getRegularStore().valueOfField(fieldAccessNode, nullness);

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -1506,7 +1506,8 @@ public AccessPathNullnessAnalysis getNullnessAnalysis(VisitorState state) {
   }
 
   private boolean mayBeNullFieldAccess(VisitorState state, ExpressionTree expr, Symbol exprSymbol) {
-    if (exprSymbol != null && !Nullness.hasNullableAnnotation(exprSymbol)) {
+    if (exprSymbol != null
+        && (fromUnannotatedPackage(exprSymbol) || !Nullness.hasNullableAnnotation(exprSymbol))) {
       return false;
     }
     return nullnessFromDataflow(state, expr);

File: nullaway/src/test/java/com/uber/nullaway/NullAwayTest.java
Patch:
@@ -79,6 +79,7 @@ public void coreNullabilityNegativeCases() {
         .addSourceFile("NullAwayNegativeCases.java")
         .addSourceFile("OtherStuff.java")
         .addSourceFile("TestAnnot.java")
+        .addSourceFile("unannotated/UnannotatedClass.java")
         .doTest();
   }
 

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -978,7 +978,7 @@ private boolean isInitializerMethod(VisitorState state, Symbol.MethodSymbol symb
   }
 
   private boolean skipDueToFieldAnnotation(Symbol fieldSymbol) {
-    for (AnnotationMirror anno : fieldSymbol.getAnnotationMirrors()) {
+    for (AnnotationMirror anno : NullabilityUtil.getAllAnnotations(fieldSymbol)) {
       // Check for Nullable like ReturnValueIsNonNull
       String annoTypeStr = anno.getAnnotationType().toString();
       if (config.isExcludedFieldAnnotation(annoTypeStr)) {

File: nullaway/src/main/java/com/uber/nullaway/Nullness.java
Patch:
@@ -128,8 +128,7 @@ public String toString() {
   }
 
   private static Nullness nullnessFromAnnotations(Element element) {
-    for (AnnotationMirror anno : element.getAnnotationMirrors()) {
-      // Check for Nullable like ReturnValueIsNonNull
+    for (AnnotationMirror anno : NullabilityUtil.getAllAnnotations(element)) {
       if (anno.getAnnotationType().toString().endsWith(".Nullable")) {
         return Nullness.NULLABLE;
       }

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -1042,6 +1042,8 @@ private boolean mayBeNullExpr(VisitorState state, ExpressionTree expr) {
       case CONDITIONAL_OR:
       case LOGICAL_COMPLEMENT:
       case INSTANCE_OF:
+      case PREFIX_INCREMENT:
+      case PREFIX_DECREMENT:
       case POSTFIX_DECREMENT:
       case POSTFIX_INCREMENT:
       case EQUAL_TO:

File: nullaway/src/test/resources/com/uber/nullaway/testdata/NullAwayNegativeCases.java
Patch:
@@ -630,6 +630,8 @@ private void sender() {
       int someValue = 0;
       receiver(-someValue);
       receiver(+someValue);
+      receiver(++someValue);
+      receiver(--someValue);
     }
 
     private void receiver(Integer i) {

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -1050,6 +1050,8 @@ private boolean mayBeNullExpr(VisitorState state, ExpressionTree expr) {
       case GREATER_THAN_EQUAL:
       case LESS_THAN:
       case LESS_THAN_EQUAL:
+      case UNARY_MINUS:
+      case UNARY_PLUS:
         // clearly not null
         exprMayBeNull = false;
         break;

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -94,6 +94,7 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.Modifier;
+import javax.lang.model.type.TypeKind;
 import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;
 import org.checkerframework.javacutil.AnnotationUtils;
 
@@ -428,7 +429,8 @@ public Description matchLambdaExpression(LambdaExpressionTree tree, VisitorState
     if (description != Description.NO_MATCH) {
       return description;
     }
-    if (tree.getBodyKind() == LambdaExpressionTree.BodyKind.EXPRESSION) {
+    if (tree.getBodyKind() == LambdaExpressionTree.BodyKind.EXPRESSION
+        && methodSymbol.getReturnType().getKind() != TypeKind.VOID) {
       ExpressionTree resExpr = (ExpressionTree) tree.getBody();
       return checkReturnExpression(tree, resExpr, methodSymbol, state);
     }

File: nullaway/src/main/java/com/uber/nullaway/ErrorProneCLIFlagsConfig.java
Patch:
@@ -46,6 +46,7 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
   static final String FL_SUGGEST_SUPPRESSIONS = EP_FL_NAMESPACE + ":SuggestSuppressions";
   static final String FL_EXCLUDED_FIELD_ANNOT = EP_FL_NAMESPACE + ":ExcludedFieldAnnotations";
   static final String FL_INITIALIZER_ANNOT = EP_FL_NAMESPACE + ":CustomInitializerAnnotations";
+  static final String FL_CTNN_METHOD = EP_FL_NAMESPACE + ":CastToNonNullMethod";
   private static final String DELIMITER = ",";
 
   static final ImmutableSet<String> DEFAULT_KNOWN_INITIALIZERS =
@@ -82,6 +83,7 @@ final class ErrorProneCLIFlagsConfig extends AbstractConfig {
     isSuggestSuppressions = flags.getBoolean(FL_SUGGEST_SUPPRESSIONS).orElse(false);
     ImmutableSet<String> propStrings = getFlagStringSet(flags, FL_EXCLUDED_FIELD_ANNOT);
     fieldAnnotPattern = propStrings.isEmpty() ? null : getPackagePattern(propStrings);
+    castToNonNullMethod = flags.get(FL_CTNN_METHOD).orElse(null);
   }
 
   private static ImmutableSet<String> getFlagStringSet(ErrorProneFlags flags, String flagName) {

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPathNullnessAnalysis.java
Patch:
@@ -19,12 +19,11 @@
 package com.uber.nullaway.dataflow;
 
 import com.google.common.collect.ImmutableList;
-import com.google.errorprone.dataflow.nullnesspropagation.Nullness;
-import com.google.errorprone.dataflow.nullnesspropagation.NullnessAnalysis;
 import com.sun.source.util.TreePath;
 import com.sun.tools.javac.code.Types;
 import com.sun.tools.javac.util.Context;
 import com.uber.nullaway.Config;
+import com.uber.nullaway.Nullness;
 import com.uber.nullaway.handlers.Handler;
 import java.util.Collections;
 import java.util.LinkedHashSet;

File: nullaway/src/main/java/com/uber/nullaway/dataflow/DataFlow.java
Patch:
@@ -91,15 +91,14 @@ public ControlFlowGraph load(CfgParams key) {
                     LambdaExpressionTree lambdaExpressionTree =
                         (LambdaExpressionTree) methodPath.getLeaf();
                     ast = new UnderlyingAST.CFGLambda(lambdaExpressionTree);
-                    return CFGBuilder.build(
-                        methodPath.getCompilationUnit(), env, ast, false, false);
+                    bodyPath = new TreePath(methodPath, lambdaExpressionTree.getBody());
                   } else {
                     // must be a method per findEnclosingMethodOrLambda
                     MethodTree method = (MethodTree) methodPath.getLeaf();
                     ast = new UnderlyingAST.CFGMethod(method, /*classTree*/ null);
                     bodyPath = new TreePath(methodPath, method.getBody());
-                    return CFGBuilder.build(bodyPath, env, ast, false, false);
                   }
+                  return CFGBuilder.build(bodyPath, env, ast, false, false);
                 }
               });
 

File: nullaway/src/main/java/com/uber/nullaway/handlers/BaseNoOpHandler.java
Patch:
@@ -24,7 +24,6 @@
 
 import com.google.common.collect.ImmutableSet;
 import com.google.errorprone.VisitorState;
-import com.google.errorprone.dataflow.nullnesspropagation.Nullness;
 import com.sun.source.tree.ClassTree;
 import com.sun.source.tree.ExpressionTree;
 import com.sun.source.tree.MethodInvocationTree;
@@ -33,6 +32,7 @@
 import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.code.Types;
 import com.uber.nullaway.NullAway;
+import com.uber.nullaway.Nullness;
 import com.uber.nullaway.dataflow.AccessPathNullnessPropagation;
 import com.uber.nullaway.dataflow.NullnessStore;
 import java.util.List;

File: nullaway/src/main/java/com/uber/nullaway/handlers/CompositeHandler.java
Patch:
@@ -25,7 +25,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.errorprone.VisitorState;
-import com.google.errorprone.dataflow.nullnesspropagation.Nullness;
 import com.sun.source.tree.ClassTree;
 import com.sun.source.tree.ExpressionTree;
 import com.sun.source.tree.MethodInvocationTree;
@@ -34,6 +33,7 @@
 import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.code.Types;
 import com.uber.nullaway.NullAway;
+import com.uber.nullaway.Nullness;
 import com.uber.nullaway.dataflow.AccessPathNullnessPropagation;
 import com.uber.nullaway.dataflow.NullnessStore;
 import java.util.List;

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handler.java
Patch:
@@ -24,7 +24,6 @@
 
 import com.google.common.collect.ImmutableSet;
 import com.google.errorprone.VisitorState;
-import com.google.errorprone.dataflow.nullnesspropagation.Nullness;
 import com.sun.source.tree.ClassTree;
 import com.sun.source.tree.ExpressionTree;
 import com.sun.source.tree.MethodInvocationTree;
@@ -33,6 +32,7 @@
 import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.code.Types;
 import com.uber.nullaway.NullAway;
+import com.uber.nullaway.Nullness;
 import com.uber.nullaway.dataflow.AccessPathNullnessPropagation;
 import com.uber.nullaway.dataflow.NullnessStore;
 import java.util.List;

File: nullaway/src/main/java/com/uber/nullaway/handlers/LibraryModelsHandler.java
Patch:
@@ -22,23 +22,23 @@
 
 package com.uber.nullaway.handlers;
 
-import static com.google.errorprone.dataflow.nullnesspropagation.Nullness.NONNULL;
 import static com.uber.nullaway.LibraryModels.MemberName.member;
+import static com.uber.nullaway.Nullness.NONNULL;
 
 import com.google.common.base.Preconditions;
 import com.google.common.base.Strings;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Sets;
 import com.google.errorprone.VisitorState;
-import com.google.errorprone.dataflow.nullnesspropagation.Nullness;
 import com.google.errorprone.util.ASTHelpers;
 import com.sun.source.tree.ExpressionTree;
 import com.sun.source.tree.Tree;
 import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.code.Types;
 import com.uber.nullaway.LibraryModels;
 import com.uber.nullaway.NullAway;
+import com.uber.nullaway.Nullness;
 import com.uber.nullaway.dataflow.AccessPath;
 import com.uber.nullaway.dataflow.AccessPathNullnessPropagation;
 import java.util.ArrayList;

File: nullaway/src/main/java/com/uber/nullaway/handlers/RxNullabilityPropagator.java
Patch:
@@ -26,7 +26,6 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.errorprone.VisitorState;
-import com.google.errorprone.dataflow.nullnesspropagation.Nullness;
 import com.google.errorprone.predicates.TypePredicate;
 import com.google.errorprone.predicates.type.DescendantOf;
 import com.google.errorprone.suppliers.Suppliers;
@@ -46,6 +45,7 @@
 import com.sun.tools.javac.code.Type;
 import com.uber.nullaway.NullAway;
 import com.uber.nullaway.NullabilityUtil;
+import com.uber.nullaway.Nullness;
 import com.uber.nullaway.dataflow.AccessPath;
 import com.uber.nullaway.dataflow.AccessPathNullnessAnalysis;
 import com.uber.nullaway.dataflow.NullnessStore;

File: nullaway/src/test/resources/com/uber/nullaway/testdata/TestAnnot.java
Patch:
@@ -22,12 +22,12 @@
 
 package com.uber.nullaway.testdata;
 
-import java.lang.annotation.Retention;
-
 import static java.lang.annotation.RetentionPolicy.CLASS;
 
+import java.lang.annotation.Retention;
+
 @Retention(CLASS)
 public @interface TestAnnot {
 
-    String TEST_STR = "test_str";
+  String TEST_STR = "test_str";
 }

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPathNullnessAnalysis.java
Patch:
@@ -18,9 +18,9 @@
 
 package com.uber.nullaway.dataflow;
 
-import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 import com.google.errorprone.dataflow.nullnesspropagation.Nullness;
+import com.google.errorprone.dataflow.nullnesspropagation.NullnessAnalysis;
 import com.sun.source.util.TreePath;
 import com.sun.tools.javac.code.Types;
 import com.sun.tools.javac.util.Context;
@@ -32,6 +32,7 @@
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.Set;
+import java.util.function.Predicate;
 
 import javax.annotation.Nullable;
 import javax.lang.model.element.Element;
@@ -40,7 +41,7 @@
 /**
  * API to our nullness dataflow analysis for access paths.
  *
- * Based on code from Error Prone; see {@link com.google.errorprone.dataflow.nullnesspropagation.NullnessAnalysis}
+ * Based on code from Error Prone; see {@link NullnessAnalysis}
  *
  */
 public final class AccessPathNullnessAnalysis {

File: nullaway/src/main/java/com/uber/nullaway/dataflow/NullnessStore.java
Patch:
@@ -121,7 +121,7 @@ public Set<AccessPath> getAccessPathsWithValue(V value) {
     }
 
     Builder<V> toBuilder() {
-        return new Builder<V>(this);
+        return new Builder<>(this);
     }
 
     @Override

File: nullaway/src/main/java/com/uber/nullaway/handlers/CompositeHandler.java
Patch:
@@ -51,7 +51,7 @@
  */
 class CompositeHandler implements Handler {
 
-    private List<Handler> handlers;
+    private final List<Handler> handlers;
 
     CompositeHandler(ImmutableList<Handler> handlers) {
         // Attach default handlers

File: nullaway/src/main/java/com/uber/nullaway/handlers/Handlers.java
Patch:
@@ -38,7 +38,7 @@ private Handlers() {  }
      */
     public static Handler buildDefault() {
         // In the future we can add LibraryModels functionality here, and even plug-in handlers.
-        return new CompositeHandler(ImmutableList.<Handler>of(
+        return new CompositeHandler(ImmutableList.of(
                 new LibraryModelsHandler(),
                 new RxNullabilityPropagator()));
     }

File: nullaway/src/test/java/com/uber/nullaway/NullAwayTest.java
Patch:
@@ -41,7 +41,7 @@
 public class NullAwayTest {
 
     @Rule
-    public TemporaryFolder temporaryFolder = new TemporaryFolder();
+    public final TemporaryFolder temporaryFolder = new TemporaryFolder();
 
     private CompilationTestHelper compilationHelper;
 

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -232,7 +232,7 @@ public Description matchReturn(ReturnTree tree, VisitorState state) {
             methodSymbol = ASTHelpers.getSymbol(enclosingMethod);
         } else {
             // we have a lambda
-            methodSymbol = NullabilityUtil.getFunctionalInterfaceMethod((LambdaExpressionTree) leaf);
+            methodSymbol = NullabilityUtil.getFunctionalInterfaceMethod((LambdaExpressionTree) leaf, state.getTypes());
         }
         return checkReturnExpression(tree, retExpr, methodSymbol, state);
     }
@@ -419,7 +419,7 @@ private Description checkReturnExpression(
 
     @Override
     public Description matchLambdaExpression(LambdaExpressionTree tree, VisitorState state) {
-        Symbol.MethodSymbol methodSymbol = NullabilityUtil.getFunctionalInterfaceMethod(tree);
+        Symbol.MethodSymbol methodSymbol = NullabilityUtil.getFunctionalInterfaceMethod(tree, state.getTypes());
         Description description = checkParamOverriding(tree, tree.getParameters(), methodSymbol, true);
         if (description != Description.NO_MATCH) {
             return description;

File: nullaway/src/main/java/com/uber/nullaway/dataflow/AccessPathNullnessPropagation.java
Patch:
@@ -187,7 +187,7 @@ private NullnessStore<Nullness> lambdaInitialStore(
         NullnessStore.Builder<Nullness> result = NullnessStore.<Nullness>empty().toBuilder();
         LambdaExpressionTree code = underlyingAST.getLambdaTree();
         // need to check annotation for i'th parameter of functional interface declaration
-        Symbol.MethodSymbol fiMethodSymbol = NullabilityUtil.getFunctionalInterfaceMethod(code);
+        Symbol.MethodSymbol fiMethodSymbol = NullabilityUtil.getFunctionalInterfaceMethod(code, types);
         com.sun.tools.javac.util.List<Symbol.VarSymbol> fiMethodParameters = fiMethodSymbol.getParameters();
         for (int i = 0; i < parameters.size(); i++) {
             LocalVariableNode param = parameters.get(i);

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -1252,6 +1252,7 @@ private String errMsgForInitializer(Set<Element> uninitFields) {
         } else {
             message += "fields " + Joiner.on(", ").join(uninitFields) + " are initialized";
         }
+        message += " along all control-flow paths (remember to check for exceptions or early returns).";
         return message;
     }
 

File: nullaway/src/main/java/com/uber/nullaway/NullAway.java
Patch:
@@ -201,7 +201,7 @@ public NullAway(ErrorProneFlags flags) {
 
     @Override
     public String linkUrl() {
-        return "http://t.uber.com/ep_null_checker ";
+        return "http://t.uber.com/nullaway ";
     }
 
     /**

