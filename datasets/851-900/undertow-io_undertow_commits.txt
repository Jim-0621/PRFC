File: servlet/src/test/java/io/undertow/servlet/test/handlers/AbstractHttpContinueServletTestCase.java
Patch:
@@ -32,7 +32,6 @@
 import org.apache.http.params.HttpParams;
 import org.junit.Assert;
 import org.junit.Assume;
-import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -56,10 +55,10 @@ public abstract class AbstractHttpContinueServletTestCase {
     public static void setup() {
         DeploymentUtils.setupServlet(Servlets.servlet(ContinueConsumeServlet.class).addMappings("/path"),
                 Servlets.servlet(ContinueIgnoreServlet.class).addMappings("/ignore"));
+        Assume.assumeFalse(DefaultServer.isAjp());
     }
 
-    @Before
-    public void before() throws Exception {
+    public static void before() throws Exception {
         Assume.assumeFalse(DefaultServer.isAjp());
     }
 

File: core/src/main/java/io/undertow/websockets/core/CloseMessage.java
Patch:
@@ -36,8 +36,8 @@ public class CloseMessage {
     */
   public static final int NORMAL_CLOSURE = 1000;
    public static final int GOING_AWAY = 1001;
-   public static final int WRONG_CODE = 1002;
-   public static final int PROTOCOL_ERROR = 1003;
+   public static final int PROTOCOL_ERROR = 1002;
+   public static final int WRONG_CODE = 1003;
    public static final int MSG_CONTAINS_INVALID_DATA = 1007;
    public static final int MSG_VIOLATES_POLICY = 1008;
    public static final int MSG_TOO_BIG = 1009;

File: core/src/main/java/io/undertow/websockets/core/CloseMessage.java
Patch:
@@ -36,8 +36,8 @@ public class CloseMessage {
     */
   public static final int NORMAL_CLOSURE = 1000;
    public static final int GOING_AWAY = 1001;
-   public static final int WRONG_CODE = 1002;
-   public static final int PROTOCOL_ERROR = 1003;
+   public static final int PROTOCOL_ERROR = 1002;
+   public static final int WRONG_CODE = 1003;
    public static final int MSG_CONTAINS_INVALID_DATA = 1007;
    public static final int MSG_VIOLATES_POLICY = 1008;
    public static final int MSG_TOO_BIG = 1009;

File: core/src/main/java/io/undertow/util/URLUtils.java
Patch:
@@ -354,7 +354,7 @@ public static boolean isAbsoluteUrl(String location) {
     }
 
     public static boolean getSlashDecodingFlag(final OptionMap options) {
-        final boolean allowEncodedSlash = options.get(UndertowOptions.ALLOW_ENCODED_SLASH, false);
+        final boolean allowEncodedSlash = options.get(UndertowOptions.ALLOW_ENCODED_SLASH, UndertowOptions.DEFAULT_ALLOW_ENCODED_SLASH);
         final Boolean decodeSlash = options.get(UndertowOptions.DECODE_SLASH);
         return getSlashDecodingFlag(allowEncodedSlash, decodeSlash);
     }

File: servlet/src/test/java/io/undertow/servlet/test/handlers/AbstractHttpContinueServletTestCase.java
Patch:
@@ -32,7 +32,6 @@
 import org.apache.http.params.HttpParams;
 import org.junit.Assert;
 import org.junit.Assume;
-import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -56,10 +55,10 @@ public abstract class AbstractHttpContinueServletTestCase {
     public static void setup() {
         DeploymentUtils.setupServlet(Servlets.servlet(ContinueConsumeServlet.class).addMappings("/path"),
                 Servlets.servlet(ContinueIgnoreServlet.class).addMappings("/ignore"));
+        Assume.assumeFalse(DefaultServer.isAjp());
     }
 
-    @Before
-    public void before() throws Exception {
+    public static void before() throws Exception {
         Assume.assumeFalse(DefaultServer.isAjp());
     }
 

File: core/src/test/java/io/undertow/server/handlers/file/FileHandlerIndexTestCase.java
Patch:
@@ -24,7 +24,6 @@
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.text.SimpleDateFormat;
-import java.util.Date;
 import java.util.Locale;
 
 import io.undertow.server.handlers.CanonicalPathHandler;
@@ -103,9 +102,9 @@ public void testDirectoryIndex() throws IOException, URISyntaxException {
             Assert.assertEquals("text/html; charset=UTF-8", headers[0].getValue());
             Assert.assertTrue(response, response.contains("page.html"));
             Assert.assertTrue(response, response.contains("tmp2"));
-            // All invalid symlinks have their date set to epoch
+            // All invalid symlinks have their date set to "-"
             SimpleDateFormat format = new SimpleDateFormat("MMM dd, yyyy HH:mm:ss", Locale.US);
-            Assert.assertTrue(response, response.contains(format.format((new Date(0L)))));
+            Assert.assertTrue(response, response.contains("-"));
         } finally {
             client.getConnectionManager().shutdown();
             if (badSymlink != null) {

File: core/src/main/java/io/undertow/util/URLUtils.java
Patch:
@@ -354,7 +354,7 @@ public static boolean isAbsoluteUrl(String location) {
     }
 
     public static boolean getSlashDecodingFlag(final OptionMap options) {
-        final boolean allowEncodedSlash = options.get(UndertowOptions.ALLOW_ENCODED_SLASH, false);
+        final boolean allowEncodedSlash = options.get(UndertowOptions.ALLOW_ENCODED_SLASH, UndertowOptions.DEFAULT_ALLOW_ENCODED_SLASH);
         final Boolean decodeSlash = options.get(UndertowOptions.DECODE_SLASH);
         return getSlashDecodingFlag(allowEncodedSlash, decodeSlash);
     }

File: core/src/test/java/io/undertow/server/handlers/LotsOfHeadersResponseTestCase.java
Patch:
@@ -67,6 +67,8 @@ public void handleRequest(final HttpServerExchange exchange) {
 
     @Test
     public void testLotsOfHeadersInResponse() throws IOException {
+        // FIXME UNDERTOW-2279
+        Assume.assumeFalse(System.getProperty("os.name").startsWith("Windows"));
         TestHttpClient client = new TestHttpClient();
         try {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path");

File: servlet/src/main/java/io/undertow/servlet/spec/ServletPrintWriter.java
Patch:
@@ -180,8 +180,10 @@ public void write(final CharBuffer input) {
                 remainingContentLength -= writtenLength;
                 outputStream.updateWritten(writtenLength);
                 if (result.isOverflow() || !buffer.hasRemaining()) {
+                    final int remainingBytesBeforeFlush = buffer.remaining();
                     outputStream.flushInternal();
-                    if (buffer.remaining() == remaining) {
+                    if (buffer.remaining() == remainingBytesBeforeFlush) {
+                        // no progress has been made, set error to true
                         error = true;
                         return;
                     }

File: core/src/main/java/io/undertow/UndertowOptions.java
Patch:
@@ -405,6 +405,9 @@ public class UndertowOptions {
      *
      * If not specified, the default value is null.
      */
+
+    public static final Option<Integer> DEFAULT_QUEUED_FRAMES_LOW_WATER_MARK = null;
+
     public static final Option<String> AJP_ALLOWED_REQUEST_ATTRIBUTES_PATTERN = Option.simple(UndertowOptions.class, "AJP_ALLOWED_REQUEST_ATTRIBUTES_PATTERN", String.class);
 
     /**

File: core/src/main/java/io/undertow/UndertowOptions.java
Patch:
@@ -240,7 +240,7 @@ public class UndertowOptions {
      * If connector level statistics should be enabled. This has a slight performance impact, but allows statistics such
      * as bytes sent/recevied to be monitored.
      */
-    @Deprecated
+    @Deprecated(forRemoval = true)
     public static final Option<Boolean> ENABLE_CONNECTOR_STATISTICS = ENABLE_STATISTICS;
 
 

File: core/src/main/java/io/undertow/UndertowOptions.java
Patch:
@@ -401,6 +401,9 @@ public class UndertowOptions {
      *
      * If not specified, the default value is null.
      */
+
+    public static final Option<Integer> DEFAULT_QUEUED_FRAMES_LOW_WATER_MARK = null;
+
     public static final Option<String> AJP_ALLOWED_REQUEST_ATTRIBUTES_PATTERN = Option.simple(UndertowOptions.class, "AJP_ALLOWED_REQUEST_ATTRIBUTES_PATTERN", String.class);
 
     /**

File: core/src/test/java/io/undertow/server/handlers/file/FileHandlerIndexTestCase.java
Patch:
@@ -24,7 +24,6 @@
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.text.SimpleDateFormat;
-import java.util.Date;
 import java.util.Locale;
 
 import io.undertow.server.handlers.CanonicalPathHandler;
@@ -103,9 +102,9 @@ public void testDirectoryIndex() throws IOException, URISyntaxException {
             Assert.assertEquals("text/html; charset=UTF-8", headers[0].getValue());
             Assert.assertTrue(response, response.contains("page.html"));
             Assert.assertTrue(response, response.contains("tmp2"));
-            // All invalid symlinks have their date set to epoch
+            // All invalid symlinks have their date set to "-"
             SimpleDateFormat format = new SimpleDateFormat("MMM dd, yyyy HH:mm:ss", Locale.US);
-            Assert.assertTrue(response, response.contains(format.format((new Date(0L)))));
+            Assert.assertTrue(response, response.contains("-"));
         } finally {
             client.getConnectionManager().shutdown();
             if (badSymlink != null) {

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -647,4 +647,7 @@ public interface UndertowMessages {
     @Message(id = 208, value = "Failed to allocate resource")
     IOException failedToAllocateResource();
 
+    @Message(id = 209, value = "Protocol string was too large for the buffer. Either provide a smaller message or a bigger buffer. Protocol: %s")
+    IllegalStateException protocolTooLargeForBuffer(String protocolString);
+
 }

File: core/src/main/java/io/undertow/server/protocol/proxy/ProxyProtocolReadListener.java
Patch:
@@ -56,7 +56,6 @@ class ProxyProtocolReadListener implements ChannelListener<StreamSourceChannel>
     private InetAddress destAddress;
     private int sourcePort = -1;
     private int destPort = -1;
-    private StringBuilder stringBuilder = new StringBuilder();
     private boolean carriageReturnSeen = false;
     private boolean parsingUnknown = false;
 
@@ -223,6 +222,7 @@ private void parseProxyProtocolV2(PooledByteBuffer buffer, AtomicBoolean freeBuf
     }
 
     private void parseProxyProtocolV1(PooledByteBuffer buffer, AtomicBoolean freeBuffer) throws IOException {
+        final StringBuilder stringBuilder = new StringBuilder();
         while (buffer.getBuffer().hasRemaining()) {
             char c = (char) buffer.getBuffer().get();
             if (byteCount < NAME.length) {

File: core/src/main/java/io/undertow/server/protocol/proxy/ProxyProtocolReadListener.java
Patch:
@@ -56,7 +56,6 @@ class ProxyProtocolReadListener implements ChannelListener<StreamSourceChannel>
     private InetAddress destAddress;
     private int sourcePort = -1;
     private int destPort = -1;
-    private StringBuilder stringBuilder = new StringBuilder();
     private boolean carriageReturnSeen = false;
     private boolean parsingUnknown = false;
 
@@ -223,6 +222,7 @@ private void parseProxyProtocolV2(PooledByteBuffer buffer, AtomicBoolean freeBuf
     }
 
     private void parseProxyProtocolV1(PooledByteBuffer buffer, AtomicBoolean freeBuffer) throws IOException {
+        final StringBuilder stringBuilder = new StringBuilder();
         while (buffer.getBuffer().hasRemaining()) {
             char c = (char) buffer.getBuffer().get();
             if (byteCount < NAME.length) {

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -392,7 +392,7 @@ public interface UndertowMessages {
     @Message(id = 117, value = "Request was not a CONNECT request")
     IllegalStateException notAConnectRequest();
 
-    @Message(id = 118, value = "Cannot reset buffer, response has already been commited")
+    @Message(id = 118, value = "Cannot reset buffer, response has already been committed")
     IllegalStateException cannotResetBuffer();
 
     @Message(id = 119, value = "HTTP2 via prior knowledge failed")

File: servlet/src/main/java/io/undertow/servlet/UndertowServletMessages.java
Patch:
@@ -101,8 +101,8 @@ public interface UndertowServletMessages {
     @Message(id = 10018, value = "Async not started")
     IllegalStateException asyncNotStarted();
 
-    @Message(id = 10019, value = "Response already commited")
-    IllegalStateException responseAlreadyCommited();
+    @Message(id = 10019, value = "Response already committed")
+    IllegalStateException responseAlreadyCommitted();
 
     @Message(id = 10020, value = "Content has been written")
     IllegalStateException contentHasBeenWritten();

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -485,7 +485,7 @@ public boolean isRequestedSessionIdFromURL() {
     @Override
     public boolean authenticate(final HttpServletResponse response) throws IOException, ServletException {
         if (response.isCommitted()) {
-            throw UndertowServletMessages.MESSAGES.responseAlreadyCommited();
+            throw UndertowServletMessages.MESSAGES.responseAlreadyCommitted();
         }
 
         SecurityContext sc = exchange.getSecurityContext();

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -136,7 +136,7 @@ public void sendError(final int sc, final String msg) throws IOException {
             if(src.getErrorCode() > 0) {
                 return; //error already set
             }
-            throw UndertowServletMessages.MESSAGES.responseAlreadyCommited();
+            throw UndertowServletMessages.MESSAGES.responseAlreadyCommitted();
         }
         if(servletContext.getDeployment().getDeploymentInfo().isSendCustomReasonPhraseOnError()) {
             exchange.setReasonPhrase(msg);
@@ -190,7 +190,7 @@ public void sendError(final int sc) throws IOException {
     @Override
     public void sendRedirect(final String location) throws IOException {
         if (responseStarted()) {
-            throw UndertowServletMessages.MESSAGES.responseAlreadyCommited();
+            throw UndertowServletMessages.MESSAGES.responseAlreadyCommitted();
         }
         resetBuffer();
         exchange.getResponseHeaders().remove(Headers.CONTENT_LENGTH);
@@ -815,7 +815,7 @@ public boolean isTreatAsCommitted() {
     @Override
     public void setTrailerFields(Supplier<Map<String, String>> supplier) {
         if(exchange.isResponseStarted()) {
-            throw UndertowServletMessages.MESSAGES.responseAlreadyCommited();
+            throw UndertowServletMessages.MESSAGES.responseAlreadyCommitted();
         }
         if(exchange.getProtocol() == Protocols.HTTP_1_0) {
             throw UndertowServletMessages.MESSAGES.trailersNotSupported("HTTP/1.0 request");

File: servlet/src/main/java/io/undertow/servlet/spec/ServletOutputStreamImpl.java
Patch:
@@ -747,7 +747,7 @@ public void resetBuffer() {
             buffer = null;
             this.written = 0;
         } else {
-            throw UndertowServletMessages.MESSAGES.responseAlreadyCommited();
+            throw UndertowServletMessages.MESSAGES.responseAlreadyCommitted();
         }
     }
 

File: core/src/main/java/io/undertow/server/handlers/LearningPushHandler.java
Patch:
@@ -46,8 +46,8 @@
 public class LearningPushHandler implements HttpHandler {
 
     private static final String SESSION_ATTRIBUTE = "io.undertow.PUSHED_RESOURCES";
-    private static final int DEFAULT_MAX_CACHE_ENTRIES = 200;
-    private static final int DEFAULT_MAX_CACHE_AGE = LRUCache.MAX_AGE_NO_EXPIRY;
+    private static final int DEFAULT_MAX_CACHE_ENTRIES = Integer.getInteger("io.undertow.handlers.learning-push.default-max-entries", 200);
+    private static final int DEFAULT_MAX_CACHE_AGE = Integer.getInteger("io.undertow.handlers.learning-push.default-max-age", LRUCache.MAX_AGE_NO_EXPIRY);
 
     private final LRUCache<String, LRUCache<String, PushedRequest>> cache;
 

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -518,8 +518,8 @@ public interface UndertowMessages {
 //    @Message(id = 159, value = "Max size must be larger than one")
 //    IllegalArgumentException maxSizeMustBeLargerThanOne();
 
-    @Message(id = 161, value = "HTTP/2 header block is too large")
-    String headerBlockTooLarge();
+    @Message(id = 161, value = "HTTP/2 header block is too large, maximum header size is %s")
+    String headerBlockTooLarge(int maxHeaderSize);
 
     @Message(id = 162, value = "An invalid SameSite attribute [%s] is specified. It must be one of %s")
     IllegalArgumentException invalidSameSiteMode(String mode, String validAttributes);

File: core/src/main/java/io/undertow/protocols/http2/Http2FrameHeaderParser.java
Patch:
@@ -26,7 +26,6 @@
 import java.nio.ByteBuffer;
 
 import static io.undertow.protocols.http2.Http2Channel.DATA_FLAG_END_STREAM;
-import static io.undertow.protocols.http2.Http2Channel.ERROR_ENHANCE_YOUR_CALM;
 import static io.undertow.protocols.http2.Http2Channel.FRAME_TYPE_CONTINUATION;
 import static io.undertow.protocols.http2.Http2Channel.FRAME_TYPE_DATA;
 import static io.undertow.protocols.http2.Http2Channel.FRAME_TYPE_GOAWAY;
@@ -110,7 +109,7 @@ public boolean handle(final ByteBuffer byteBuffer) throws IOException {
                     }
                     parser = continuationParser;
                     if (!continuationParser.moreData(length)) {
-                        http2Channel.sendGoAway(ERROR_ENHANCE_YOUR_CALM);
+                        http2Channel.sendGoAway(Http2Channel.ERROR_PROTOCOL_ERROR);
                     }
                     break;
                 }

File: core/src/main/java/io/undertow/protocols/http2/Http2FrameHeaderParser.java
Patch:
@@ -26,7 +26,6 @@
 import java.nio.ByteBuffer;
 
 import static io.undertow.protocols.http2.Http2Channel.DATA_FLAG_END_STREAM;
-import static io.undertow.protocols.http2.Http2Channel.ERROR_ENHANCE_YOUR_CALM;
 import static io.undertow.protocols.http2.Http2Channel.FRAME_TYPE_CONTINUATION;
 import static io.undertow.protocols.http2.Http2Channel.FRAME_TYPE_DATA;
 import static io.undertow.protocols.http2.Http2Channel.FRAME_TYPE_GOAWAY;
@@ -110,7 +109,7 @@ public boolean handle(final ByteBuffer byteBuffer) throws IOException {
                     }
                     parser = continuationParser;
                     if (!continuationParser.moreData(length)) {
-                        http2Channel.sendGoAway(ERROR_ENHANCE_YOUR_CALM);
+                        http2Channel.sendGoAway(Http2Channel.ERROR_PROTOCOL_ERROR);
                     }
                     break;
                 }

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -518,8 +518,8 @@ public interface UndertowMessages {
 //    @Message(id = 159, value = "Max size must be larger than one")
 //    IllegalArgumentException maxSizeMustBeLargerThanOne();
 
-    @Message(id = 161, value = "HTTP/2 header block is too large")
-    String headerBlockTooLarge();
+    @Message(id = 161, value = "HTTP/2 header block is too large, maximum header size is %s")
+    String headerBlockTooLarge(int maxHeaderSize);
 
     @Message(id = 162, value = "An invalid SameSite attribute [%s] is specified. It must be one of %s")
     IllegalArgumentException invalidSameSiteMode(String mode, String validAttributes);

File: core/src/main/java/io/undertow/server/DefaultByteBufferPool.java
Patch:
@@ -228,11 +228,11 @@ public void close() {
         synchronized (threadLocalDataList) {
             for (WeakReference<ThreadLocalData> ref : threadLocalDataList) {
                 ThreadLocalData local = ref.get();
+                ref.clear();
                 if (local != null) {
                     local.buffers.clear();
+                    threadLocalCache.remove(local);
                 }
-                ref.clear();
-                threadLocalCache.remove(local);
             }
             threadLocalDataList.clear();
         }

File: core/src/main/java/io/undertow/protocols/http2/Http2Channel.java
Patch:
@@ -240,7 +240,7 @@ public Http2Channel(StreamConnection connectedStreamChannel, String protocol, By
         encoderHeaderTableSize = settings.get(UndertowOptions.HTTP2_SETTINGS_HEADER_TABLE_SIZE, Hpack.DEFAULT_TABLE_SIZE);
         receiveMaxFrameSize = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_FRAME_SIZE, DEFAULT_MAX_FRAME_SIZE);
         maxPadding = settings.get(UndertowOptions.HTTP2_PADDING_SIZE, 0);
-        maxHeaderListSize = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE, settings.get(UndertowOptions.MAX_HEADER_SIZE, -1));
+        maxHeaderListSize = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE, settings.get(UndertowOptions.MAX_HEADER_SIZE, UndertowOptions.DEFAULT_MAX_HEADER_SIZE));
         if(maxPadding > 0) {
             paddingRandom = new SecureRandom();
         } else {

File: core/src/main/java/io/undertow/protocols/http2/Http2Channel.java
Patch:
@@ -240,7 +240,7 @@ public Http2Channel(StreamConnection connectedStreamChannel, String protocol, By
         encoderHeaderTableSize = settings.get(UndertowOptions.HTTP2_SETTINGS_HEADER_TABLE_SIZE, Hpack.DEFAULT_TABLE_SIZE);
         receiveMaxFrameSize = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_FRAME_SIZE, DEFAULT_MAX_FRAME_SIZE);
         maxPadding = settings.get(UndertowOptions.HTTP2_PADDING_SIZE, 0);
-        maxHeaderListSize = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE, settings.get(UndertowOptions.MAX_HEADER_SIZE, -1));
+        maxHeaderListSize = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE, settings.get(UndertowOptions.MAX_HEADER_SIZE, UndertowOptions.DEFAULT_MAX_HEADER_SIZE));
         if(maxPadding > 0) {
             paddingRandom = new SecureRandom();
         } else {

File: core/src/main/java/io/undertow/server/DefaultByteBufferPool.java
Patch:
@@ -26,9 +26,10 @@
 import java.nio.ByteBuffer;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.HashMap;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.WeakHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
@@ -343,7 +344,7 @@ protected void finalize() throws Throwable {
     // class can be called by a different thread than the one that initialized the data.
     private static class ThreadLocalCache {
 
-        Map<Thread, ThreadLocalData> localsByThread = new HashMap<>();
+        Map<Thread, ThreadLocalData> localsByThread = Collections.synchronizedMap(new WeakHashMap<>());
 
         ThreadLocalData get() {
             return localsByThread.get(Thread.currentThread());

File: core/src/main/java/io/undertow/server/DefaultByteBufferPool.java
Patch:
@@ -26,6 +26,7 @@
 import java.nio.ByteBuffer;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.WeakHashMap;
@@ -343,7 +344,7 @@ protected void finalize() throws Throwable {
     // class can be called by a different thread than the one that initialized the data.
     private static class ThreadLocalCache {
 
-        Map<Thread, ThreadLocalData> localsByThread = new WeakHashMap<>();
+        Map<Thread, ThreadLocalData> localsByThread = Collections.synchronizedMap(new WeakHashMap<>());
 
         ThreadLocalData get() {
             return localsByThread.get(Thread.currentThread());

File: servlet/src/test/java/io/undertow/servlet/test/response/writer/AsyncResponseWriterOnPostServlet.java
Patch:
@@ -39,6 +39,7 @@ protected void doPost(final HttpServletRequest req, final HttpServletResponse re
             throw new IllegalArgumentException("not a test " + test);
         }
         final AsyncContext asyncContext = req.startAsync();
+        asyncContext.setTimeout(50000);
         new Thread(()->{
             try {
                 HttpServletResponse response = (HttpServletResponse) asyncContext.getResponse();

File: servlet/src/test/java/io/undertow/servlet/test/response/writer/ResponseWriterOnPostServlet.java
Patch:
@@ -58,6 +58,8 @@ protected void doPost(final HttpServletRequest req, final HttpServletResponse re
     }
 
     public static Throwable getExceptionIfAny() {
-        return exception;
+        Throwable result = exception;
+        exception = null;
+        return result;
     }
 }

File: core/src/main/java/io/undertow/UndertowOptions.java
Patch:
@@ -103,6 +103,8 @@ public class UndertowOptions {
     public static final Option<Integer> MAX_HEADERS = Option.simple(UndertowOptions.class, "MAX_HEADERS", Integer.class);
 
 
+    public static final int DEFAULT_MAX_COOKIES = 200;
+
     /**
      * The maximum number of cookies that will be parsed. This is used to protect against hash vulnerabilities.
      * <p>
@@ -265,7 +267,7 @@ public class UndertowOptions {
     public static final Option<Boolean> HTTP2_SETTINGS_ENABLE_PUSH = Option.simple(UndertowOptions.class, "HTTP2_SETTINGS_ENABLE_PUSH", Boolean.class);
 
     /**
-     * The maximum number of concurrent
+     * The maximum number of concurrent http2 streams.
      */
     public static final Option<Integer> HTTP2_SETTINGS_MAX_CONCURRENT_STREAMS = Option.simple(UndertowOptions.class, "HTTP2_SETTINGS_MAX_CONCURRENT_STREAMS", Integer.class);
 

File: core/src/main/java/io/undertow/protocols/http2/Http2Channel.java
Patch:
@@ -121,6 +121,8 @@ public class Http2Channel extends AbstractFramedChannel<Http2Channel, AbstractHt
 
     public static final int DEFAULT_INITIAL_WINDOW_SIZE = 65535;
 
+    public static final int DEFAULT_MAX_CONCURRENT_STREAMS = -1;
+
     static final byte[] PREFACE_BYTES = {
             0x50, 0x52, 0x49, 0x20, 0x2a, 0x20, 0x48, 0x54,
             0x54, 0x50, 0x2f, 0x32, 0x2e, 0x30, 0x0d, 0x0a,
@@ -214,7 +216,7 @@ public Http2Channel(StreamConnection connectedStreamChannel, String protocol, By
         pushEnabled = settings.get(UndertowOptions.HTTP2_SETTINGS_ENABLE_PUSH, true);
         this.initialReceiveWindowSize = settings.get(UndertowOptions.HTTP2_SETTINGS_INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE);
         this.receiveWindowSize = initialReceiveWindowSize;
-        this.receiveMaxConcurrentStreams = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_CONCURRENT_STREAMS, -1);
+        this.receiveMaxConcurrentStreams = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_CONCURRENT_STREAMS, DEFAULT_MAX_CONCURRENT_STREAMS);
 
         this.protocol = protocol == null ? Http2OpenListener.HTTP2 : protocol;
         this.maxHeaders = settings.get(UndertowOptions.MAX_HEADERS, clientSide ? -1 : UndertowOptions.DEFAULT_MAX_HEADERS);

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -1205,7 +1205,7 @@ public Iterable<Cookie> requestCookies() {
             Set<Cookie> requestCookiesParam = new OverridableTreeSet<>();
             requestCookies = new DelegatingIterable<>(requestCookiesParam);
             Cookies.parseRequestCookies(
-                    getConnection().getUndertowOptions().get(UndertowOptions.MAX_COOKIES, 200),
+                    getConnection().getUndertowOptions().get(UndertowOptions.MAX_COOKIES, UndertowOptions.DEFAULT_MAX_COOKIES),
                     getConnection().getUndertowOptions().get(UndertowOptions.ALLOW_EQUALS_IN_COOKIE_VALUE, false),
                     requestHeaders.get(Headers.COOKIE), requestCookiesParam);
         }

File: core/src/main/java/io/undertow/client/http2/Http2ClearClientProvider.java
Patch:
@@ -170,7 +170,7 @@ public static String createSettingsFrame(OptionMap options, ByteBufferPool buffe
             if (options.contains(UndertowOptions.HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE)) {
                 pushOption(currentBuffer, Http2Setting.SETTINGS_MAX_HEADER_LIST_SIZE, options.get(UndertowOptions.HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE));
             } else if(options.contains(UndertowOptions.MAX_HEADER_SIZE)) {
-                pushOption(currentBuffer, Http2Setting.SETTINGS_MAX_HEADER_LIST_SIZE, options.get(UndertowOptions.HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE));
+                pushOption(currentBuffer, Http2Setting.SETTINGS_MAX_HEADER_LIST_SIZE, options.get(UndertowOptions.MAX_HEADER_SIZE));
             }
             currentBuffer.flip();
             return FlexBase64.encodeStringURL(currentBuffer, false);

File: core/src/main/java/io/undertow/UndertowOptions.java
Patch:
@@ -267,7 +267,7 @@ public class UndertowOptions {
     public static final Option<Boolean> HTTP2_SETTINGS_ENABLE_PUSH = Option.simple(UndertowOptions.class, "HTTP2_SETTINGS_ENABLE_PUSH", Boolean.class);
 
     /**
-     * The maximum number of concurrent
+     * The maximum number of concurrent http2 streams.
      */
     public static final Option<Integer> HTTP2_SETTINGS_MAX_CONCURRENT_STREAMS = Option.simple(UndertowOptions.class, "HTTP2_SETTINGS_MAX_CONCURRENT_STREAMS", Integer.class);
 

File: core/src/main/java/io/undertow/protocols/http2/Http2Channel.java
Patch:
@@ -121,6 +121,8 @@ public class Http2Channel extends AbstractFramedChannel<Http2Channel, AbstractHt
 
     public static final int DEFAULT_INITIAL_WINDOW_SIZE = 65535;
 
+    public static final int DEFAULT_MAX_CONCURRENT_STREAMS = -1;
+
     static final byte[] PREFACE_BYTES = {
             0x50, 0x52, 0x49, 0x20, 0x2a, 0x20, 0x48, 0x54,
             0x54, 0x50, 0x2f, 0x32, 0x2e, 0x30, 0x0d, 0x0a,
@@ -214,7 +216,7 @@ public Http2Channel(StreamConnection connectedStreamChannel, String protocol, By
         pushEnabled = settings.get(UndertowOptions.HTTP2_SETTINGS_ENABLE_PUSH, true);
         this.initialReceiveWindowSize = settings.get(UndertowOptions.HTTP2_SETTINGS_INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE);
         this.receiveWindowSize = initialReceiveWindowSize;
-        this.receiveMaxConcurrentStreams = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_CONCURRENT_STREAMS, -1);
+        this.receiveMaxConcurrentStreams = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_CONCURRENT_STREAMS, DEFAULT_MAX_CONCURRENT_STREAMS);
 
         this.protocol = protocol == null ? Http2OpenListener.HTTP2 : protocol;
         this.maxHeaders = settings.get(UndertowOptions.MAX_HEADERS, clientSide ? -1 : UndertowOptions.DEFAULT_MAX_HEADERS);

File: core/src/main/java/io/undertow/UndertowOptions.java
Patch:
@@ -103,6 +103,8 @@ public class UndertowOptions {
     public static final Option<Integer> MAX_HEADERS = Option.simple(UndertowOptions.class, "MAX_HEADERS", Integer.class);
 
 
+    public static final int DEFAULT_MAX_COOKIES = 200;
+
     /**
      * The maximum number of cookies that will be parsed. This is used to protect against hash vulnerabilities.
      * <p>

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -1205,7 +1205,7 @@ public Iterable<Cookie> requestCookies() {
             Set<Cookie> requestCookiesParam = new OverridableTreeSet<>();
             requestCookies = new DelegatingIterable<>(requestCookiesParam);
             Cookies.parseRequestCookies(
-                    getConnection().getUndertowOptions().get(UndertowOptions.MAX_COOKIES, 200),
+                    getConnection().getUndertowOptions().get(UndertowOptions.MAX_COOKIES, UndertowOptions.DEFAULT_MAX_COOKIES),
                     getConnection().getUndertowOptions().get(UndertowOptions.ALLOW_EQUALS_IN_COOKIE_VALUE, false),
                     requestHeaders.get(Headers.COOKIE), requestCookiesParam);
         }

File: servlet/src/main/java/io/undertow/servlet/util/DispatchUtils.java
Patch:
@@ -123,7 +123,7 @@ public static ServletPathMatch dispatchInclude(final String path,
         requestImpl.setAttribute(INCLUDE_CONTEXT_PATH, servletContext.getContextPath());
         requestImpl.setAttribute(INCLUDE_SERVLET_PATH, pathMatch.getMatched());
         requestImpl.setAttribute(INCLUDE_PATH_INFO, pathMatch.getRemaining());
-        requestImpl.setAttribute(INCLUDE_MAPPING, pathMatch.getMappingMatch());
+        requestImpl.setAttribute(INCLUDE_MAPPING, requestImpl.getHttpServletMapping());
         return pathMatch;
     }
 

File: core/src/main/java/io/undertow/client/http2/Http2ClearClientProvider.java
Patch:
@@ -170,7 +170,7 @@ public static String createSettingsFrame(OptionMap options, ByteBufferPool buffe
             if (options.contains(UndertowOptions.HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE)) {
                 pushOption(currentBuffer, Http2Setting.SETTINGS_MAX_HEADER_LIST_SIZE, options.get(UndertowOptions.HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE));
             } else if(options.contains(UndertowOptions.MAX_HEADER_SIZE)) {
-                pushOption(currentBuffer, Http2Setting.SETTINGS_MAX_HEADER_LIST_SIZE, options.get(UndertowOptions.HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE));
+                pushOption(currentBuffer, Http2Setting.SETTINGS_MAX_HEADER_LIST_SIZE, options.get(UndertowOptions.MAX_HEADER_SIZE));
             }
             currentBuffer.flip();
             return FlexBase64.encodeStringURL(currentBuffer, false);

File: servlet/src/main/java/io/undertow/servlet/util/DispatchUtils.java
Patch:
@@ -123,7 +123,7 @@ public static ServletPathMatch dispatchInclude(final String path,
         requestImpl.setAttribute(INCLUDE_CONTEXT_PATH, servletContext.getContextPath());
         requestImpl.setAttribute(INCLUDE_SERVLET_PATH, pathMatch.getMatched());
         requestImpl.setAttribute(INCLUDE_PATH_INFO, pathMatch.getRemaining());
-        requestImpl.setAttribute(INCLUDE_MAPPING, pathMatch.getMappingMatch());
+        requestImpl.setAttribute(INCLUDE_MAPPING, requestImpl.getHttpServletMapping());
         return pathMatch;
     }
 

File: servlet/src/test/java/io/undertow/servlet/test/response/writer/ResponseWriterServlet.java
Patch:
@@ -37,13 +37,13 @@ protected void doGet(final HttpServletRequest req, final HttpServletResponse res
 
         String test = req.getParameter("test");
         if (test.equals(CONTENT_LENGTH_FLUSH)) {
-            contentLengthFlush(req, resp);
+            contentLengthFlush(resp);
         } else {
             throw new IllegalArgumentException("not a test " + test);
         }
     }
 
-    private void contentLengthFlush(HttpServletRequest req, HttpServletResponse resp) throws IOException {
+    protected void contentLengthFlush(HttpServletResponse resp) throws IOException {
         int size = 10;
 
         PrintWriter pw = resp.getWriter();
@@ -54,7 +54,7 @@ private void contentLengthFlush(HttpServletRequest req, HttpServletResponse resp
         resp.setContentLength(size);
         //write more data than the content length
         while (i < 20) {
-            tmp = tmp.append("a");
+            tmp.append("a");
             i = i + 1;
         }
         pw.println(tmp);

File: core/src/main/java/io/undertow/conduits/WriteTimeoutStreamSinkConduit.java
Patch:
@@ -98,6 +98,8 @@ private void handleWriteTimeout(final long ret) throws IOException {
         long currentTime = System.currentTimeMillis();
         long expireTimeVar = expireTime;
         if (expireTimeVar != -1 && currentTime > expireTimeVar) {
+            this.expireTime = -1;
+            connection.getSinkChannel().shutdownWrites();
             IoUtils.safeClose(connection);
             throw new ClosedChannelException();
         }

File: core/src/main/java/io/undertow/util/HeaderMap.java
Patch:
@@ -800,7 +800,7 @@ public Collection<String> remove(String headerName) {
 
     public boolean contains(HttpString headerName) {
         final HeaderValues headerValues = getEntry(headerName);
-        if (headerValues == null) {
+        if (headerValues == null || headerValues.size == 0) {
             return false;
         }
         final Object v = headerValues.value;
@@ -818,7 +818,7 @@ public boolean contains(HttpString headerName) {
 
     public boolean contains(String headerName) {
         final HeaderValues headerValues = getEntry(headerName);
-        if (headerValues == null) {
+        if (headerValues == null || headerValues.size == 0) {
             return false;
         }
         final Object v = headerValues.value;

File: servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java
Patch:
@@ -187,7 +187,7 @@ protected void doGet(final HttpServletRequest req, final HttpServletResponse res
                     return;
                 }
                 resp.setContentType("text/html");
-                StringBuilder output = DirectoryUtils.renderDirectoryListing(req.getRequestURI(), resource);
+                StringBuilder output = DirectoryUtils.renderDirectoryListing(exchange, req.getRequestURI(), resource);
                 resp.getWriter().write(output.toString());
             } else {
                 resp.sendError(StatusCodes.FORBIDDEN);

File: core/src/main/java/io/undertow/util/HeaderMap.java
Patch:
@@ -800,7 +800,7 @@ public Collection<String> remove(String headerName) {
 
     public boolean contains(HttpString headerName) {
         final HeaderValues headerValues = getEntry(headerName);
-        if (headerValues == null) {
+        if (headerValues == null || headerValues.size == 0) {
             return false;
         }
         final Object v = headerValues.value;
@@ -818,7 +818,7 @@ public boolean contains(HttpString headerName) {
 
     public boolean contains(String headerName) {
         final HeaderValues headerValues = getEntry(headerName);
-        if (headerValues == null) {
+        if (headerValues == null || headerValues.size == 0) {
             return false;
         }
         final Object v = headerValues.value;

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -635,9 +635,6 @@ public interface UndertowMessages {
     @Message(id = 203, value = "Invalid ACL entry")
     IllegalArgumentException invalidACLAddress(@Cause Exception e);
 
-    @Message(id = 204, value = "Out of flow control window: no WINDOW_UPDATE received from peer within %s miliseconds")
-    IOException noWindowUpdate(long timeoutMiliseconds);
-
     @Message(id = 205, value = "Path is not a directory '%s'")
     IOException pathNotADirectory(Path path);
 

File: servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java
Patch:
@@ -187,7 +187,7 @@ protected void doGet(final HttpServletRequest req, final HttpServletResponse res
                     return;
                 }
                 resp.setContentType("text/html");
-                StringBuilder output = DirectoryUtils.renderDirectoryListing(req.getRequestURI(), resource);
+                StringBuilder output = DirectoryUtils.renderDirectoryListing(exchange, req.getRequestURI(), resource);
                 resp.getWriter().write(output.toString());
             } else {
                 resp.sendError(StatusCodes.FORBIDDEN);

File: core/src/main/java/io/undertow/util/MimeMappings.java
Patch:
@@ -45,8 +45,9 @@ public class MimeMappings {
         defaultMappings.put("jpe", "image/jpeg");
         defaultMappings.put("jpeg", "image/jpeg");
         defaultMappings.put("bmp", "image/bmp");
-        defaultMappings.put("js", "application/javascript");
+        defaultMappings.put("webp", "image/webp");
         defaultMappings.put("png", "image/png");
+        defaultMappings.put("js", "application/javascript");
         defaultMappings.put("java", "text/plain");
         defaultMappings.put("body", "text/html");
         defaultMappings.put("rtx", "text/richtext");

File: servlet/src/main/java/io/undertow/servlet/handlers/security/ServletSecurityConstraintHandler.java
Patch:
@@ -43,6 +43,7 @@ public ServletSecurityConstraintHandler(final SecurityPathMatches securityPathMa
     @Override
     public void handleRequest(final HttpServerExchange exchange) throws Exception {
         final String path = exchange.getRelativePath();
+
         SecurityPathMatch securityMatch = securityPathMatches.getSecurityInfo(path, exchange.getRequestMethod().toString());
         final ServletRequestContext servletRequestContext = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY);
         List<SingleConstraintMatch> list = servletRequestContext.getRequiredConstrains();

File: core/src/test/java/io/undertow/util/NetworkUtilsAddressParsingTestCase.java
Patch:
@@ -132,7 +132,7 @@ public void testIpv6Address() throws IOException {
         Assert.assertEquals("/0:0:0:0:0:0:0:1", res.toString());
     }
 
-    @Test(expected = IOException.class)
+    @Test
     public void testIpV6AddressWithLeadingZero() throws IOException {
         NetworkUtils.parseIpv6Address("2001:1db8:100:03:6:ff00:42:8329");
     }

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -579,7 +579,7 @@ public interface UndertowMessages {
     IOException streamLimitExceeded();
 
     @Message(id = 185, value = "Invalid IP address %s")
-    IOException invalidIpAddress(String addressString);
+    IllegalArgumentException invalidIpAddress(String addressString);
 
     @Message(id = 186, value = "Invalid TLS extension")
     SSLException invalidTlsExt();
@@ -646,4 +646,5 @@ public interface UndertowMessages {
 
     @Message(id = 207, value = "Invalid SNI hostname '%s'")
     IllegalArgumentException invalidSniHostname(String hostNameValue, @Cause Throwable t);
+
 }

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -579,7 +579,7 @@ public interface UndertowMessages {
     IOException streamLimitExceeded();
 
     @Message(id = 185, value = "Invalid IP address %s")
-    IOException invalidIpAddress(String addressString);
+    IllegalArgumentException invalidIpAddress(String addressString);
 
     @Message(id = 186, value = "Invalid TLS extension")
     SSLException invalidTlsExt();
@@ -646,4 +646,5 @@ public interface UndertowMessages {
 
     @Message(id = 207, value = "Invalid SNI hostname '%s'")
     IllegalArgumentException invalidSniHostname(String hostNameValue, @Cause Throwable t);
+
 }

File: servlet/src/main/java/io/undertow/servlet/handlers/security/ServletSecurityConstraintHandler.java
Patch:
@@ -43,6 +43,7 @@ public ServletSecurityConstraintHandler(final SecurityPathMatches securityPathMa
     @Override
     public void handleRequest(final HttpServerExchange exchange) throws Exception {
         final String path = exchange.getRelativePath();
+
         SecurityPathMatch securityMatch = securityPathMatches.getSecurityInfo(path, exchange.getRequestMethod().toString());
         final ServletRequestContext servletRequestContext = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY);
         List<SingleConstraintMatch> list = servletRequestContext.getRequiredConstrains();

File: benchmarks/src/main/java/io/undertow/benchmarks/AsciiEncodingBenchmark.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * JBoss, Home of Professional Open Source.
- * Copyright 2019 Red Hat, Inc., and individual contributors
+ * Copyright 2023 Red Hat, Inc., and individual contributors
  * as indicated by the @author tags.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/main/java/io/undertow/util/MimeMappings.java
Patch:
@@ -45,8 +45,9 @@ public class MimeMappings {
         defaultMappings.put("jpe", "image/jpeg");
         defaultMappings.put("jpeg", "image/jpeg");
         defaultMappings.put("bmp", "image/bmp");
-        defaultMappings.put("js", "application/javascript");
+        defaultMappings.put("webp", "image/webp");
         defaultMappings.put("png", "image/png");
+        defaultMappings.put("js", "application/javascript");
         defaultMappings.put("java", "text/plain");
         defaultMappings.put("body", "text/html");
         defaultMappings.put("rtx", "text/richtext");

File: benchmarks/src/main/java/io/undertow/benchmarks/AsciiEncoders.java
Patch:
@@ -53,7 +53,7 @@ private static int setAsciiBE(ByteBuffer buffer, int out, char[] chars, int off,
                         chars[off + 5] << 16 |
                         chars[off + 7];
                 if (((batch1 | batch2) & 0xff80_ff80_ff80_ff80L) != 0) {
-                    return i;
+                    return i << 3;
                 }
                 final long batch = (batch1 << 8) | batch2;
                 buffer.putLong(out, batch);

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -643,4 +643,7 @@ public interface UndertowMessages {
 
     @Message(id = 206, value = "Path '%s' is not a directory")
     IOException pathElementIsRegularFile(Path path);
+
+    @Message(id = 207, value = "Invalid SNI hostname '%s'")
+    IllegalArgumentException invalidSniHostname(String hostNameValue, @Cause Throwable t);
 }

File: core/src/main/java/io/undertow/server/handlers/resource/ResourceHandler.java
Patch:
@@ -165,7 +165,7 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
 
     private void serveResource(final HttpServerExchange exchange, final boolean sendContent) throws Exception {
 
-        if (DirectoryUtils.sendRequestedBlobs(exchange)) {
+        if (directoryListingEnabled && DirectoryUtils.sendRequestedBlobs(exchange)) {
             return;
         }
 

File: core/src/main/java/io/undertow/server/handlers/resource/ResourceHandler.java
Patch:
@@ -165,7 +165,7 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
 
     private void serveResource(final HttpServerExchange exchange, final boolean sendContent) throws Exception {
 
-        if (DirectoryUtils.sendRequestedBlobs(exchange)) {
+        if (directoryListingEnabled && DirectoryUtils.sendRequestedBlobs(exchange)) {
             return;
         }
 

File: servlet/src/main/java/io/undertow/servlet/spec/AsyncContextImpl.java
Patch:
@@ -61,6 +61,7 @@
 import io.undertow.servlet.handlers.ServletDebugPageHandler;
 import io.undertow.servlet.handlers.ServletPathMatch;
 import io.undertow.servlet.handlers.ServletRequestContext;
+import io.undertow.util.CanonicalPathUtils;
 import io.undertow.util.Headers;
 import io.undertow.util.SameThreadExecutor;
 import io.undertow.util.StatusCodes;
@@ -178,8 +179,7 @@ public void dispatch() {
                 //this should never happen
                 throw UndertowServletMessages.MESSAGES.couldNotFindContextToDispatchTo(requestImpl.getOriginalContextPath());
             }
-            //UNDERTOW-1591 use original, decoded value to dispatch, this should match: ServletInitialHandler.handleRequest
-            String toDispatch = requestImpl.getExchange().getRelativePath();
+            String toDispatch = CanonicalPathUtils.canonicalize(requestImpl.getOriginalRequestURI()).substring(requestImpl.getOriginalContextPath().length());
             String qs = requestImpl.getOriginalQueryString();
             if (qs != null && !qs.isEmpty()) {
                 toDispatch = toDispatch + "?" + qs;

File: servlet/src/main/java/io/undertow/servlet/spec/ServletContextImpl.java
Patch:
@@ -946,8 +946,9 @@ public String rewriteUrl(String originalUrl, String sessionId) {
                         boolean found = false;
                         for (String deploymentName : deployment.getServletContainer().listDeployments()) {
                             DeploymentManager deployment = this.deployment.getServletContainer().getDeployment(deploymentName);
-                            if (deployment != null) {
-                                if (deployment.getDeployment().getSessionManager().getSession(existing) != null) {
+                            if (deployment != null && deployment.getDeployment() != null) {
+                                SessionManager sm = deployment.getDeployment().getSessionManager();
+                                if (sm != null && sm.getSession(existing) != null) {
                                     found = true;
                                     break;
                                 }

File: core/src/main/java/io/undertow/io/UndertowInputStream.java
Patch:
@@ -32,6 +32,7 @@
 import java.util.concurrent.TimeUnit;
 
 import static io.undertow.UndertowLogger.REQUEST_IO_LOGGER;
+import static io.undertow.UndertowOptions.DEFAULT_READ_TIMEOUT;
 import static io.undertow.UndertowOptions.IDLE_TIMEOUT;
 import static org.xnio.Bits.allAreClear;
 import static org.xnio.Bits.anyAreSet;
@@ -82,7 +83,7 @@ else if (idleTimeout != null && idleTimeout > 0 && idleTimeout < readTimeout) {
             // treatment)
             REQUEST_IO_LOGGER.ioException(e);
         }
-        this.readTimeout = readTimeout == null || readTimeout <= 0? io.undertow.UndertowOptions.DEFAULT_READ_TIMEOUT : readTimeout;
+        this.readTimeout = readTimeout == null || readTimeout <= 0? DEFAULT_READ_TIMEOUT : readTimeout;
     }
 
     @Override

File: core/src/main/java/io/undertow/server/ConnectionSSLSessionInfo.java
Patch:
@@ -99,6 +99,7 @@ public Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException, Re
     }
 
     @Override
+    @Deprecated(since="2.2.3", forRemoval=false)
     public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException, RenegotiationRequiredException {
         if (unverified != null) {
             throw unverified;
@@ -115,7 +116,7 @@ public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedExcep
                   renegotiationRequiredException = RENEGOTIATION_REQUIRED_EXCEPTION;
                   throw renegotiationRequiredException;
               }
-            } catch (IOException e1) {
+            } catch (IOException ioe) {
             	// ignore, will not actually happen
             }
             unverified = PEER_UNVERIFIED_EXCEPTION;

File: core/src/main/java/io/undertow/util/Certificates.java
Patch:
@@ -56,6 +56,5 @@ private static String toPem(final byte[] encodedCertificate) {
     }
     
     private Certificates() {
-
     }
 }

File: core/src/main/java/io/undertow/server/protocol/http2/Http2SslSessionInfo.java
Patch:
@@ -71,7 +71,8 @@ public Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException, Re
     }
 
     @Override
-    public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException, RenegotiationRequiredException {
+    public X509Certificate[] getPeerCertificateChain()
+        throws SSLPeerUnverifiedException, RenegotiationRequiredException {
         try {
             return channel.getSslSession().getPeerCertificateChain();
         } catch (SSLPeerUnverifiedException e) {

File: core/src/main/java/io/undertow/util/HttpString.java
Patch:
@@ -344,7 +344,6 @@ private static boolean bytesAreEquivalent(final byte[] a, final byte[] b) {
      * @return the string
      */
     @Override
-    @SuppressWarnings("deprecation")
     public String toString() {
         if (string == null) {
             string = new String(bytes, java.nio.charset.StandardCharsets.US_ASCII);

File: servlet/src/main/java/io/undertow/servlet/handlers/security/SSLInformationAssociationHandler.java
Patch:
@@ -20,13 +20,13 @@
 
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
-import jakarta.servlet.ServletRequest;
 
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.SSLSessionInfo;
 import io.undertow.servlet.handlers.ServletRequestContext;
 import io.undertow.util.HexConverter;
+import jakarta.servlet.ServletRequest;
 
 /**
  * Handler that associates SSL metadata with request

File: core/src/main/java/io/undertow/server/BasicSSLSessionInfo.java
Patch:
@@ -155,6 +155,7 @@ public java.security.cert.Certificate[] getPeerCertificates() throws SSLPeerUnve
         return peerCertificate;
     }
 
+    @Deprecated
     @Override
     public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException {
         if (certificate == null) {

File: core/src/main/java/io/undertow/server/protocol/http2/Http2SslSessionInfo.java
Patch:
@@ -81,11 +81,12 @@ public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedExcep
                     throw new RenegotiationRequiredException();
                 }
             } catch (IOException e1) {
-                //ignore, will not actually happen
+              // ignore, will not actually happen
             }
             throw e;
         }
     }
+
     @Override
     public void renegotiate(HttpServerExchange exchange, SslClientAuthMode sslClientAuthMode) throws IOException {
         throw UndertowMessages.MESSAGES.renegotiationNotSupported();

File: core/src/main/java/io/undertow/util/Certificates.java
Patch:
@@ -28,6 +28,7 @@ public class Certificates {
 
     public static final String END_CERT = "-----END CERTIFICATE-----";
 
+    @Deprecated (since = "2.3.0", forRemoval=true)
     public static String toPem(final javax.security.cert.X509Certificate certificate)
             throws javax.security.cert.CertificateEncodingException {
         return toPem(certificate.getEncoded());

File: core/src/main/java/io/undertow/conduits/DeflatingStreamSinkConduit.java
Patch:
@@ -102,11 +102,11 @@ public DeflatingStreamSinkConduit(final ConduitFactory<StreamSinkConduit> condui
     }
 
     public static ObjectPool<Deflater> newInstanceDeflaterPool(int deflateLevel) {
-        return new NewInstanceObjectPool<Deflater>(() -> new Deflater(deflateLevel, true), Deflater::end);
+        return new NewInstanceObjectPool<>(() -> new Deflater(deflateLevel, true), Deflater::end);
     }
 
     public static ObjectPool<Deflater> simpleDeflaterPool(int poolSize, int deflateLevel) {
-        return new SimpleObjectPool<Deflater>(poolSize, () -> new Deflater(deflateLevel, true), Deflater::reset, Deflater::end);
+        return new SimpleObjectPool<>(poolSize, () -> new Deflater(deflateLevel, true), Deflater::reset, Deflater::end);
     }
 
 

File: core/src/main/java/io/undertow/conduits/InflatingStreamSourceConduit.java
Patch:
@@ -77,11 +77,11 @@ public InflatingStreamSourceConduit(
     }
 
     public static ObjectPool<Inflater> newInstanceInflaterPool() {
-        return new NewInstanceObjectPool<Inflater>(() -> new Inflater(true), Inflater::end);
+        return new NewInstanceObjectPool<>(() -> new Inflater(true), Inflater::end);
     }
 
     public static ObjectPool<Inflater> simpleInflaterPool(int poolSize) {
-        return new SimpleObjectPool<Inflater>(poolSize, () -> new Inflater(true), Inflater::reset, Inflater::end);
+        return new SimpleObjectPool<>(poolSize, () -> new Inflater(true), Inflater::reset, Inflater::end);
     }
 
     @Override

File: core/src/main/java/io/undertow/security/api/SecurityContext.java
Patch:
@@ -103,15 +103,15 @@ public interface SecurityContext {
      * @param mechanism The mechanism to add
      * @deprecated This method is now only applicable to {@code SecurityContext} implementations that also implement the {@link AuthenticationMechanismContext} interface.
      */
-    @Deprecated
+    @Deprecated(since="1.3.0", forRemoval=true)
     void addAuthenticationMechanism(AuthenticationMechanism mechanism);
 
     /**
      *
      * @return A list of all authentication mechanisms in this context
      * @deprecated Obtaining lists of mechanisms is discouraged, however there should not be a need to call this anyway.
      */
-    @Deprecated
+    @Deprecated(since="1.3.0", forRemoval=true)
     List<AuthenticationMechanism> getAuthenticationMechanisms();
 
     /*
@@ -149,7 +149,7 @@ public interface SecurityContext {
      * @return The associated {@link IdentityManager}
      * @deprecated Authentication mechanisms that rely on the {@link IdentityManager} should instead hold their own reference to it.
      */
-    @Deprecated
+    @Deprecated(since="1.2.0", forRemoval=true)
     IdentityManager getIdentityManager();
 
     /**

File: core/src/main/java/io/undertow/security/api/SecurityContextFactory.java
Patch:
@@ -28,7 +28,7 @@
  * @author <a href="mailto:sguilhen@redhat.com">Stefan Guilhen</a>
  * @deprecated Instead extend AbstractSecurityContextAssociationHandler to provide alternative contexts.
  */
-@Deprecated()
+@Deprecated(since="1.3.0", forRemoval=true)
 public interface SecurityContextFactory {
 
     /**

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -1153,7 +1153,7 @@ public HttpServerExchange addPathParam(final String name, final String param) {
      * @return A mutable map of request cookies
      * @deprecated use either {@link #requestCookies()} or {@link #getRequestCookie(String)} or {@link #setRequestCookie(Cookie)} methods instead
      */
-    @Deprecated
+    @Deprecated(since="2.2.0", forRemoval=true)
     public Map<String, Cookie> getRequestCookies() {
         if (deprecatedRequestCookies == null) {
             deprecatedRequestCookies = new MapDelegatingToSet((Set<Cookie>)((DelegatingIterable<Cookie>)requestCookies()).getDelegate());
@@ -1238,7 +1238,7 @@ public HttpServerExchange setResponseCookie(final Cookie cookie) {
      * @return A mutable map of response cookies
      * @deprecated use either {@link #responseCookies()} or {@link #setResponseCookie(Cookie)} methods instead
      */
-    @Deprecated
+    @Deprecated(since="2.2.0", forRemoval=true)
     public Map<String, Cookie> getResponseCookies() {
         if (deprecatedResponseCookies == null) {
             deprecatedResponseCookies = new MapDelegatingToSet((Set<Cookie>)((DelegatingIterable<Cookie>)responseCookies()).getDelegate());

File: core/src/main/java/io/undertow/server/SSLSessionInfo.java
Patch:
@@ -95,7 +95,7 @@ default int getKeySize() {
      *             throws java 15.
      * @see SSLSession#getPeerCertificateChain()
      */
-    @Deprecated
+    @Deprecated(since="2.2.3", forRemoval=false)
     javax.security.cert.X509Certificate[] getPeerCertificateChain() throws javax.net.ssl.SSLPeerUnverifiedException, RenegotiationRequiredException;
 
     /**

File: core/src/main/java/io/undertow/server/handlers/PathHandler.java
Patch:
@@ -118,7 +118,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
      * @see #addPrefixPath(String, io.undertow.server.HttpHandler)
      * @deprecated Superseded by {@link #addPrefixPath(String, io.undertow.server.HttpHandler)}.
      */
-    @Deprecated
+    @Deprecated(since="1.0.0", forRemoval=true)
     public synchronized PathHandler addPath(final String path, final HttpHandler handler) {
         return addPrefixPath(path, handler);
     }

File: core/src/main/java/io/undertow/server/handlers/StuckThreadDetectionHandler.java
Patch:
@@ -66,7 +66,7 @@ public class StuckThreadDetectionHandler implements HttpHandler {
      * are stuck (caused by a long monitor interval)
      */
     private final ConcurrentHashMap<Long, MonitoredThread> activeThreads =
-            new ConcurrentHashMap<Long, MonitoredThread>();
+            new ConcurrentHashMap<>();
     /**
      *
      */

File: core/src/main/java/io/undertow/server/handlers/accesslog/ExtendedAccessLogParser.java
Patch:
@@ -192,7 +192,7 @@ public String getRemains() throws IOException {
     }
 
     public ExchangeAttribute parse(String pattern) {
-        List<ExchangeAttribute> list = new ArrayList<ExchangeAttribute>();
+        List<ExchangeAttribute> list = new ArrayList<>();
 
         PatternTokenizer tokenizer = new PatternTokenizer(pattern);
         try {

File: core/src/main/java/io/undertow/server/handlers/encoding/ContentEncodedResourceManager.java
Patch:
@@ -133,7 +133,7 @@ public ContentEncodedResource getResource(final Resource resource, final HttpSer
             targetFileChannel = FileChannel.open(tempTarget, StandardOpenOption.READ, StandardOpenOption.WRITE);
             sourceFileChannel = FileChannel.open(file, StandardOpenOption.READ);
 
-            StreamSinkConduit conduit = encoding.getEncoding().getResponseWrapper().wrap(new ImmediateConduitFactory<StreamSinkConduit>(new FileConduitTarget(targetFileChannel, exchange)), exchange);
+            StreamSinkConduit conduit = encoding.getEncoding().getResponseWrapper().wrap(new ImmediateConduitFactory<>(new FileConduitTarget(targetFileChannel, exchange)), exchange);
             final ConduitStreamSinkChannel targetChannel = new ConduitStreamSinkChannel(null, conduit);
             long transferred = sourceFileChannel.transferTo(0, resource.getContentLength(), targetChannel);
             targetChannel.shutdownWrites();

File: core/src/main/java/io/undertow/server/handlers/proxy/HostTable.java
Patch:
@@ -44,7 +44,7 @@ public synchronized HostTable addHost(H host) {
         if(hosts.containsKey(host)) {
             throw UndertowMessages.MESSAGES.hostAlreadyRegistered(host);
         }
-        hosts.put(host, new CopyOnWriteArraySet<Target>());
+        hosts.put(host, new CopyOnWriteArraySet<>());
         return this;
     }
 

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/Balancer.java
Patch:
@@ -241,15 +241,15 @@ public BalancerBuilder setMaxRetries(int maxRetries) {
         /**
          * @deprecated Use {@link BalancerBuilder#getMaxRetries()}.
          */
-        @Deprecated
+        @Deprecated(since="2.0.4", forRemoval=true)
         public int getMaxattempts() {
             return maxRetries;
         }
 
         /**
          * @deprecated Use {@link BalancerBuilder#setMaxRetries(int)}.
          */
-        @Deprecated
+        @Deprecated(since="2.0.4", forRemoval=true)
         public BalancerBuilder setMaxattempts(int maxattempts) {
             this.maxRetries = maxattempts;
             return this;

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/ModClusterStatus.java
Patch:
@@ -62,7 +62,7 @@ interface LoadBalancer {
         /**
          * @deprecated Use {@link LoadBalancer#getMaxRetries()}.
          */
-        @Deprecated
+        @Deprecated(since="2.0.4", forRemoval=true)
         int getMaxAttempts();
     }
 

File: core/src/main/java/io/undertow/server/protocol/framed/ShutdownFallbackExecutor.java
Patch:
@@ -41,7 +41,7 @@ static void execute(Runnable runnable) {
                 if (EXECUTOR == null) {
                     EXECUTOR = new ThreadPoolExecutor(0, 1,
                             10, TimeUnit.MILLISECONDS,
-                            new LinkedBlockingQueue<Runnable>(),
+                            new LinkedBlockingQueue<>(),
                             new ShutdownFallbackThreadFactory());
                 }
             }

File: core/src/main/java/io/undertow/util/Cookies.java
Patch:
@@ -204,7 +204,7 @@ private static void handleValue(CookieImpl cookie, String key, String value) {
      * @see <a href="http://tools.ietf.org/search/rfc2109">rfc2109</a>
      * @deprecated use {@link #parseRequestCookies(int, boolean, List, Set)} instead
      */
-    @Deprecated
+    @Deprecated(since="2.2.0", forRemoval=true)
     public static Map<String, Cookie> parseRequestCookies(int maxCookies, boolean allowEqualInValue, List<String> cookies) {
         return parseRequestCookies(maxCookies, allowEqualInValue, cookies, LegacyCookieSupport.COMMA_IS_SEPARATOR);
     }

File: core/src/main/java/io/undertow/util/SimpleObjectPool.java
Patch:
@@ -43,7 +43,7 @@ public SimpleObjectPool(int poolSize, Supplier<T> supplier, Consumer<T> recycler
         this.supplier = supplier;
         this.recycler = recycler;
         this.consumer = consumer;
-        pool = new LinkedBlockingDeque<T>(poolSize);
+        pool = new LinkedBlockingDeque<>(poolSize);
     }
 
     public SimpleObjectPool(int poolSize, Supplier<T> supplier, Consumer<T> consumer) {

File: core/src/main/java/io/undertow/util/Transfer.java
Patch:
@@ -97,7 +97,7 @@ public static <I extends StreamSourceChannel, O extends StreamSinkChannel> void
                 free = false;
             }
 
-            final TransferListener<I, O> listener = new TransferListener<I, O>(pool, current, source, sink, sourceListener, sinkListener, writeExceptionHandler, readExceptionHandler, read == -1);
+            final TransferListener<I, O> listener = new TransferListener<>(pool, current, source, sink, sourceListener, sinkListener, writeExceptionHandler, readExceptionHandler, read == -1);
             sink.getWriteSetter().set(listener);
             source.getReadSetter().set(listener);
             //we resume both reads and writes, as we want to keep trying to fill the buffer

File: core/src/main/java/io/undertow/websockets/client/WebSocket13ClientHandshake.java
Patch:
@@ -91,9 +91,9 @@ public WebSocketChannel createChannel(final StreamConnection channel, final Stri
                     }
                 }
             }
-            return new WebSocket13Channel(channel, bufferPool, wsUri, negotiation.getSelectedSubProtocol(), true, !negotiated.isEmpty(), CompositeExtensionFunction.compose(negotiated), new HashSet<WebSocketChannel>(), options);
+            return new WebSocket13Channel(channel, bufferPool, wsUri, negotiation.getSelectedSubProtocol(), true, !negotiated.isEmpty(), CompositeExtensionFunction.compose(negotiated), new HashSet<>(), options);
         } else {
-            return new WebSocket13Channel(channel, bufferPool, wsUri, negotiation != null ? negotiation.getSelectedSubProtocol() : "", true, false, NoopExtensionFunction.INSTANCE, new HashSet<WebSocketChannel>(), options);
+            return new WebSocket13Channel(channel, bufferPool, wsUri, negotiation != null ? negotiation.getSelectedSubProtocol() : "", true, false, NoopExtensionFunction.INSTANCE, new HashSet<>(), options);
         }
     }
 

File: core/src/main/java/io/undertow/websockets/client/WebSocketClient.java
Patch:
@@ -208,7 +208,7 @@ public ConnectionBuilder setProxySsl(XnioSsl proxySsl) {
         }
 
         public IoFuture<WebSocketChannel> connect() {
-            return connectImpl(uri, new FutureResult<WebSocketChannel>(), 0);
+            return connectImpl(uri, new FutureResult<>(), 0);
         }
         private IoFuture<WebSocketChannel> connectImpl(final URI uri, final FutureResult<WebSocketChannel> ioFuture, final int redirectCount) {
             WebSocketLogger.REQUEST_LOGGER.debugf("Opening websocket connection to %s", uri);

File: servlet/src/main/java/io/undertow/servlet/compat/rewrite/RewriteCond.java
Patch:
@@ -176,7 +176,7 @@ public String toString() {
 
     protected Substitution test = null;
 
-    protected ThreadLocal<Condition> condition = new ThreadLocal<Condition>();
+    protected ThreadLocal<Condition> condition = new ThreadLocal<>();
 
     /**
      * This makes the test case-insensitive, i.e., there is no difference between

File: servlet/src/main/java/io/undertow/servlet/compat/rewrite/RewriteConfig.java
Patch:
@@ -53,7 +53,7 @@ public Map<String, RewriteMap> getMaps() {
 
 
     public String toString() {
-        StringBuffer buffer = new StringBuffer();
+        StringBuilder buffer = new StringBuilder();
         // FIXME: Output maps if possible
         for (int i = 0; i < rules.length; i++) {
             for (int j = 0; j < rules[i].getConditions().length; j++) {

File: servlet/src/main/java/io/undertow/servlet/compat/rewrite/RewriteConfigFactory.java
Patch:
@@ -52,8 +52,8 @@ public static RewriteConfig build(InputStream inputStream) {
 
 
     private static RewriteConfig parse(BufferedReader reader) {
-        ArrayList<RewriteRule> rules = new ArrayList<RewriteRule>();
-        ArrayList<RewriteCond> conditions = new ArrayList<RewriteCond>();
+        ArrayList<RewriteRule> rules = new ArrayList<>();
+        ArrayList<RewriteCond> conditions = new ArrayList<>();
         Map<String, RewriteMap> maps = new HashMap<>();
         while (true) {
             try {

File: servlet/src/main/java/io/undertow/servlet/compat/rewrite/RewriteHandler.java
Patch:
@@ -112,7 +112,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
             if (rules[i].isRedirect() && newtest != null) {
                 // append the query string to the url if there is one and it hasn't been rewritten
                 String queryString = request.getQueryString();
-                StringBuffer urlString = new StringBuffer(url);
+                StringBuilder urlString = new StringBuilder(url);
                 if (queryString != null && queryString.length() > 0) {
                     int index = urlString.indexOf("?");
                     if (index != -1) {
@@ -257,7 +257,7 @@ else if (index == urlString.length() - 1) {
     /**
      * Determine if a URI string has a <code>scheme</code> component.
      */
-    protected static boolean hasScheme(StringBuffer uri) {
+    protected static boolean hasScheme(StringBuilder uri) {
         int len = uri.length();
         for (int i = 0; i < len; i++) {
             char c = uri.charAt(i);

File: servlet/src/main/java/io/undertow/servlet/compat/rewrite/Substitution.java
Patch:
@@ -117,7 +117,7 @@ public void setSub(String sub) {
 
     public void parse(Map<String, RewriteMap> maps) {
 
-        ArrayList<SubstitutionElement> elements = new ArrayList<SubstitutionElement>();
+        ArrayList<SubstitutionElement> elements = new ArrayList<>();
         int pos = 0;
         int percentPos = 0;
         int dollarPos = 0;
@@ -241,7 +241,7 @@ public void parse(Map<String, RewriteMap> maps) {
      * @return
      */
     public String evaluate(Matcher rule, Matcher cond, Resolver resolver) {
-        StringBuffer buf = new StringBuffer();
+        StringBuilder buf = new StringBuilder();
         for (int i = 0; i < elements.length; i++) {
             buf.append(elements[i].evaluate(rule, cond, resolver));
         }

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletPathMatches.java
Patch:
@@ -330,7 +330,7 @@ private ServletPathMatchesData setupServletChains() {
             //initialize the extension map. This contains all the filers in the noExtension map, plus
             //any filters that match the extension key
             for (String ext : extensionMatches) {
-                extension.put(ext, new EnumMap<DispatcherType, List<ManagedFilter>>(DispatcherType.class));
+                extension.put(ext, new EnumMap<>(DispatcherType.class));
             }
 
             //loop over all the filters, and add them to the appropriate map in the correct order

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletPathMatchesData.java
Patch:
@@ -103,7 +103,7 @@ public static final class Builder {
 
         private final Map<String, ServletChain> exactPathMatches = new HashMap<>();
 
-        private final SubstringMap<PathMatch> prefixMatches = new SubstringMap<PathMatch>();
+        private final SubstringMap<PathMatch> prefixMatches = new SubstringMap<>();
 
         private final Map<String, ServletChain> nameMatches = new HashMap<>();
 

File: servlet/src/main/java/io/undertow/servlet/spec/ServletContextImpl.java
Patch:
@@ -722,7 +722,7 @@ public <T extends EventListener> void addListener(final T t) {
                 && ServletContextListener.class.isAssignableFrom(t.getClass())) {
             throw UndertowServletMessages.MESSAGES.cannotAddServletContextListener();
         }
-        ListenerInfo listener = new ListenerInfo(t.getClass(), new ImmediateInstanceFactory<EventListener>(t));
+        ListenerInfo listener = new ListenerInfo(t.getClass(), new ImmediateInstanceFactory<>(t));
         getDeploymentInfo().addListener(listener);
         deployment.getApplicationListeners().addListener(new ManagedListener(listener, true));
     }

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/ServerWebSocketContainer.java
Patch:
@@ -457,7 +457,7 @@ public InstanceHandle<Object> createInstance() throws InstantiationException {
                 hand = ServerWebSocketContainer.handshakes(confguredServerEndpoint, info.getExtensions());
             }
 
-            final ServletWebSocketHttpExchange facade = new ServletWebSocketHttpExchange(request, response, new HashSet<WebSocketChannel>());
+            final ServletWebSocketHttpExchange facade = new ServletWebSocketHttpExchange(request, response, new HashSet<>());
             Handshake handshaker = null;
             for (Handshake method : hand.handshakes) {
                 if (method.matches(facade)) {

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -381,7 +381,7 @@ public String changeSessionId() {
             if (!this.servletContext.getDeployment().getDeploymentInfo().isOrphanSessionAllowed()) {
                 throw UndertowServletMessages.MESSAGES.sessionIdChangeAfterResponseCommittedNotAllowed();
             }
-            UndertowServletLogger.REQUEST_LOGGER.sessionIdChangeAfterResponseCommitted();
+            UndertowServletLogger.REQUEST_LOGGER.debug("Servlet container configured to permit session identifier changes after response was committed. This can result in a memory leak if session has no timeout.");
         }
         String oldId = session.getId();
         Session underlyingSession;

File: servlet/src/main/java/io/undertow/servlet/spec/ServletContextImpl.java
Patch:
@@ -885,7 +885,7 @@ public HttpSessionImpl getSession(final ServletContextImpl originalServletContex
                     if (!this.deployment.getDeploymentInfo().isOrphanSessionAllowed()) {
                         throw UndertowServletMessages.MESSAGES.sessionCreationAfterResponseCommittedNotAllowed();
                     }
-                    UndertowServletLogger.REQUEST_LOGGER.sessionCreationAfterResponseCommitted();
+                    UndertowServletLogger.REQUEST_LOGGER.debug("Servlet container configured to permit session creation after response was committed. This can result in a memory leak if session has no timeout.");
                 }
 
                 String existing = c.findSessionId(exchange);

File: core/src/main/java/io/undertow/server/protocol/http/HttpContinue.java
Patch:
@@ -142,7 +142,6 @@ public void awaitWritable(long time, TimeUnit timeUnit) throws IOException {
         HttpServerExchange newExchange = exchange.getConnection().sendOutOfBandResponse(exchange);
         exchange.putAttachment(ALREADY_SENT, true);
         newExchange.setStatusCode(StatusCodes.CONTINUE);
-        newExchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, 0);
         final StreamSinkChannel responseChannel = newExchange.getResponseChannel();
         return new ContinueResponseSender() {
             boolean shutdown = false;
@@ -219,7 +218,6 @@ private static void internalSendContinueResponse(final HttpServerExchange exchan
         HttpServerExchange newExchange = exchange.getConnection().sendOutOfBandResponse(exchange);
         exchange.putAttachment(ALREADY_SENT, true);
         newExchange.setStatusCode(StatusCodes.CONTINUE);
-        newExchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, 0);
         final StreamSinkChannel responseChannel = newExchange.getResponseChannel();
         try {
             responseChannel.shutdownWrites();

File: core/src/main/java/io/undertow/server/protocol/http/HttpContinue.java
Patch:
@@ -142,7 +142,6 @@ public void awaitWritable(long time, TimeUnit timeUnit) throws IOException {
         HttpServerExchange newExchange = exchange.getConnection().sendOutOfBandResponse(exchange);
         exchange.putAttachment(ALREADY_SENT, true);
         newExchange.setStatusCode(StatusCodes.CONTINUE);
-        newExchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, 0);
         final StreamSinkChannel responseChannel = newExchange.getResponseChannel();
         return new ContinueResponseSender() {
             boolean shutdown = false;
@@ -219,7 +218,6 @@ private static void internalSendContinueResponse(final HttpServerExchange exchan
         HttpServerExchange newExchange = exchange.getConnection().sendOutOfBandResponse(exchange);
         exchange.putAttachment(ALREADY_SENT, true);
         newExchange.setStatusCode(StatusCodes.CONTINUE);
-        newExchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, 0);
         final StreamSinkChannel responseChannel = newExchange.getResponseChannel();
         try {
             responseChannel.shutdownWrites();

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -147,6 +147,7 @@ public void doErrorDispatch(int sc, String error) throws IOException {
         writer = null;
         responseState = ResponseState.NONE;
         resetBuffer();
+        exchange.getResponseHeaders().remove(Headers.CONTENT_LENGTH);
         treatAsCommitted = false;
         final String location = servletContext.getDeployment().getErrorPages().getErrorLocation(sc);
         if (location != null) {
@@ -181,6 +182,7 @@ public void sendRedirect(final String location) throws IOException {
             throw UndertowServletMessages.MESSAGES.responseAlreadyCommited();
         }
         resetBuffer();
+        exchange.getResponseHeaders().remove(Headers.CONTENT_LENGTH);
         setStatus(StatusCodes.FOUND);
         String realPath;
         if (isAbsoluteUrl(location)) {//absolute url

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -147,6 +147,7 @@ public void doErrorDispatch(int sc, String error) throws IOException {
         writer = null;
         responseState = ResponseState.NONE;
         resetBuffer();
+        exchange.getResponseHeaders().remove(Headers.CONTENT_LENGTH);
         treatAsCommitted = false;
         final String location = servletContext.getDeployment().getErrorPages().getErrorLocation(sc);
         if (location != null) {
@@ -181,6 +182,7 @@ public void sendRedirect(final String location) throws IOException {
             throw UndertowServletMessages.MESSAGES.responseAlreadyCommited();
         }
         resetBuffer();
+        exchange.getResponseHeaders().remove(Headers.CONTENT_LENGTH);
         setStatus(StatusCodes.FOUND);
         String realPath;
         if (isAbsoluteUrl(location)) {//absolute url

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -194,6 +194,8 @@ public void sendRedirect(final String location) throws IOException {
                 int lastSlash = current.lastIndexOf("/");
                 if (lastSlash != -1) {
                     current = current.substring(0, lastSlash + 1);
+                } else {
+                    current = "";
                 }
                 realPath = CanonicalPathUtils.canonicalize(servletContext.getContextPath() + current + location);
             }

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -194,6 +194,8 @@ public void sendRedirect(final String location) throws IOException {
                 int lastSlash = current.lastIndexOf("/");
                 if (lastSlash != -1) {
                     current = current.substring(0, lastSlash + 1);
+                } else {
+                    current = "";
                 }
                 realPath = CanonicalPathUtils.canonicalize(servletContext.getContextPath() + current + location);
             }

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpReadListener.java
Patch:
@@ -58,7 +58,7 @@ final class AjpReadListener implements ChannelListener<StreamSourceChannel> {
     private static final byte[] CPONG = {'A', 'B', 0, 1, 9};
     private static final byte[] SEND_HEADERS_INTERNAL_SERVER_ERROR_MSG = {'A', 'B', 0, 8, 4, (byte)((500 >> 8) & 0xFF) , (byte)(500 & 0xFF), 0, 0, '\0', 0, 0};
     private static final byte[] SEND_HEADERS_BAD_REQUEST_MSG = {'A', 'B', 0, 8, 4, (byte)((400 >> 8) & 0xFF) , (byte)(400 & 0xFF), 0, 0, '\0', 0, 0};
-    private static final byte[] END_RESPONSE = {'A', 'B', 0, 2, 5, 1};
+    private static final byte[] END_RESPONSE = {'A', 'B', 0, 2, 5, 0};
 
     private final AjpServerConnection connection;
     private final String scheme;
@@ -235,7 +235,6 @@ public void handleEvent(AjpServerResponseConduit channel) {
             if(oldState.badRequest) {
                 httpServerExchange.setStatusCode(StatusCodes.BAD_REQUEST);
                 httpServerExchange.endExchange();
-                handleBadRequest();
                 safeClose(connection);
             } else {
                 Connectors.executeRootHandler(connection.getRootHandler(), httpServerExchange);

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpReadListener.java
Patch:
@@ -58,7 +58,7 @@ final class AjpReadListener implements ChannelListener<StreamSourceChannel> {
     private static final byte[] CPONG = {'A', 'B', 0, 1, 9};
     private static final byte[] SEND_HEADERS_INTERNAL_SERVER_ERROR_MSG = {'A', 'B', 0, 8, 4, (byte)((500 >> 8) & 0xFF) , (byte)(500 & 0xFF), 0, 0, '\0', 0, 0};
     private static final byte[] SEND_HEADERS_BAD_REQUEST_MSG = {'A', 'B', 0, 8, 4, (byte)((400 >> 8) & 0xFF) , (byte)(400 & 0xFF), 0, 0, '\0', 0, 0};
-    private static final byte[] END_RESPONSE = {'A', 'B', 0, 2, 5, 1};
+    private static final byte[] END_RESPONSE = {'A', 'B', 0, 2, 5, 0};
 
     private final AjpServerConnection connection;
     private final String scheme;
@@ -235,7 +235,6 @@ public void handleEvent(AjpServerResponseConduit channel) {
             if(oldState.badRequest) {
                 httpServerExchange.setStatusCode(StatusCodes.BAD_REQUEST);
                 httpServerExchange.endExchange();
-                handleBadRequest();
                 safeClose(connection);
             } else {
                 Connectors.executeRootHandler(connection.getRootHandler(), httpServerExchange);

File: servlet/src/main/java/io/undertow/servlet/core/DefaultCharsetMapping.java
Patch:
@@ -24,7 +24,7 @@
 
 public final class DefaultCharsetMapping {
 
-    public static DefaultCharsetMapping INSTANCE = new DefaultCharsetMapping();
+    public static final DefaultCharsetMapping INSTANCE = new DefaultCharsetMapping();
     private static final String DEFAULT_MAPPING = "/io/undertow/servlet/core/charset.mapping";
     private final Properties map = new Properties();
 

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -236,7 +236,7 @@ public HttpServletMapping getHttpServletMapping() {
         ServletPathMatch match = src.getOriginalServletPathMatch();
         final DispatcherType dispatcherType = getDispatcherType();
         //UNDERTOW-1899 - ERROR is essentially forward operation
-        if(dispatcherType == DispatcherType.FORWARD || dispatcherType == DispatcherType.ERROR) {
+        if(dispatcherType == DispatcherType.FORWARD || dispatcherType == DispatcherType.ERROR || dispatcherType == DispatcherType.ASYNC || dispatcherType == DispatcherType.REQUEST) {
             match = src.getServletPathMatch();
         }
         String matchValue;

File: examples/src/main/java/io/undertow/examples/jsrwebsockets/JSRWebSocketServer.java
Patch:
@@ -18,7 +18,7 @@
 
 package io.undertow.examples.jsrwebsockets;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.DefaultByteBufferPool;
 

File: examples/src/main/java/io/undertow/examples/jsrwebsockets/JsrChatWebSocketEndpoint.java
Patch:
@@ -1,8 +1,8 @@
 package io.undertow.examples.jsrwebsockets;
 
-import javax.websocket.OnMessage;
-import javax.websocket.Session;
-import javax.websocket.server.ServerEndpoint;
+import jakarta.websocket.OnMessage;
+import jakarta.websocket.Session;
+import jakarta.websocket.server.ServerEndpoint;
 
 /**
  * @author Stuart Douglas

File: examples/src/main/java/io/undertow/examples/servlet/ServletServer.java
Patch:
@@ -18,7 +18,7 @@
 
 package io.undertow.examples.servlet;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.Handlers;
 import io.undertow.Undertow;

File: servlet/src/main/java/io/undertow/servlet/ServletExtension.java
Patch:
@@ -20,7 +20,7 @@
 
 import io.undertow.servlet.api.DeploymentInfo;
 
-import javax.servlet.ServletContext;
+import jakarta.servlet.ServletContext;
 
 /**
  *

File: servlet/src/main/java/io/undertow/servlet/Servlets.java
Patch:
@@ -18,9 +18,9 @@
 
 package io.undertow.servlet;
 
-import javax.servlet.Filter;
-import javax.servlet.MultipartConfigElement;
-import javax.servlet.Servlet;
+import jakarta.servlet.Filter;
+import jakarta.servlet.MultipartConfigElement;
+import jakarta.servlet.Servlet;
 
 import io.undertow.servlet.api.DeploymentInfo;
 import io.undertow.servlet.api.ErrorPage;

File: servlet/src/main/java/io/undertow/servlet/UndertowServletLogger.java
Patch:
@@ -21,7 +21,7 @@
 import java.io.IOException;
 import java.util.Date;
 import java.util.Set;
-import javax.servlet.UnavailableException;
+import jakarta.servlet.UnavailableException;
 
 import org.jboss.logging.BasicLogger;
 import org.jboss.logging.Logger;

File: servlet/src/main/java/io/undertow/servlet/api/AuthorizationManager.java
Patch:
@@ -20,7 +20,7 @@
 
 import io.undertow.security.idm.Account;
 
-import javax.servlet.http.HttpServletRequest;
+import jakarta.servlet.http.HttpServletRequest;
 import java.util.List;
 
 /**

File: servlet/src/main/java/io/undertow/servlet/api/Deployment.java
Patch:
@@ -100,7 +100,7 @@ public interface Deployment {
     DeploymentManager.State getDeploymentState();
 
     /**
-     * Attempts to add a servlet mapping using {@link javax.servlet.ServletRegistration#addMapping(String...)}
+     * Attempts to add a servlet mapping using {@link jakarta.servlet.ServletRegistration#addMapping(String...)}
      *
      * @return true if the addition was sucessful
      */

File: servlet/src/main/java/io/undertow/servlet/api/DeploymentManager.java
Patch:
@@ -18,7 +18,7 @@
 
 package io.undertow.servlet.api;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.HttpHandler;
 

File: servlet/src/main/java/io/undertow/servlet/api/ExceptionHandler.java
Patch:
@@ -18,8 +18,8 @@
 
 package io.undertow.servlet.api;
 
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
+import jakarta.servlet.ServletRequest;
+import jakarta.servlet.ServletResponse;
 
 import io.undertow.server.HttpServerExchange;
 

File: servlet/src/main/java/io/undertow/servlet/api/FilterInfo.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import javax.servlet.Filter;
+import jakarta.servlet.Filter;
 
 import io.undertow.servlet.UndertowServletMessages;
 import io.undertow.servlet.util.ConstructorInstanceFactory;

File: servlet/src/main/java/io/undertow/servlet/api/FilterMappingInfo.java
Patch:
@@ -18,7 +18,7 @@
 
 package io.undertow.servlet.api;
 
-import javax.servlet.DispatcherType;
+import jakarta.servlet.DispatcherType;
 
 /**
  * @author Stuart Douglas

File: servlet/src/main/java/io/undertow/servlet/api/LifecycleInterceptor.java
Patch:
@@ -1,8 +1,8 @@
 package io.undertow.servlet.api;
 
-import javax.servlet.Filter;
-import javax.servlet.Servlet;
-import javax.servlet.ServletException;
+import jakarta.servlet.Filter;
+import jakarta.servlet.Servlet;
+import jakarta.servlet.ServletException;
 
 /**
  * Class that is run around invocations of servlet and filter lifecycle methods (init and destroy).

File: servlet/src/main/java/io/undertow/servlet/api/LoggingExceptionHandler.java
Patch:
@@ -28,8 +28,8 @@
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
+import jakarta.servlet.ServletRequest;
+import jakarta.servlet.ServletResponse;
 
 /**
  * An exception handler that

File: servlet/src/main/java/io/undertow/servlet/api/SecurityInfo.java
Patch:
@@ -28,7 +28,7 @@
 public class SecurityInfo<T extends SecurityInfo> implements Cloneable {
 
     /**
-     * Equivalent to {@link javax.servlet.annotation.ServletSecurity.EmptyRoleSemantic} but with an additional mode to require authentication but no role
+     * Equivalent to {@link jakarta.servlet.annotation.ServletSecurity.EmptyRoleSemantic} but with an additional mode to require authentication but no role
      * check.
      */
     public enum EmptyRoleSemantic {

File: servlet/src/main/java/io/undertow/servlet/api/ServletContainerInitializerInfo.java
Patch:
@@ -24,7 +24,7 @@
 import java.lang.reflect.Constructor;
 import java.util.Set;
 
-import javax.servlet.ServletContainerInitializer;
+import jakarta.servlet.ServletContainerInitializer;
 
 /**
  * @author Stuart Douglas
@@ -61,7 +61,7 @@ public Class<? extends ServletContainerInitializer> getServletContainerInitializ
     /**
      * Returns the actual types present in the deployment that are handled by this ServletContainerInitializer.
      *
-     * (i.e. not the types in the {@link javax.servlet.annotation.HandlesTypes} annotation, but rather actual types
+     * (i.e. not the types in the {@link jakarta.servlet.annotation.HandlesTypes} annotation, but rather actual types
      * the container has discovered that meet the criteria)
      *
      * @return The handled types

File: servlet/src/main/java/io/undertow/servlet/api/ServletInfo.java
Patch:
@@ -27,8 +27,8 @@
 import java.util.Map;
 import java.util.concurrent.Executor;
 
-import javax.servlet.MultipartConfigElement;
-import javax.servlet.Servlet;
+import jakarta.servlet.MultipartConfigElement;
+import jakarta.servlet.Servlet;
 
 import io.undertow.server.HandlerWrapper;
 import io.undertow.servlet.UndertowServletMessages;

File: servlet/src/main/java/io/undertow/servlet/api/ServletSessionConfig.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.util.Set;
 
-import javax.servlet.SessionTrackingMode;
+import jakarta.servlet.SessionTrackingMode;
 
 /**
  *

File: servlet/src/main/java/io/undertow/servlet/attribute/ServletRelativePathAttribute.java
Patch:
@@ -26,7 +26,7 @@
 import io.undertow.server.HttpServerExchange;
 import io.undertow.servlet.handlers.ServletRequestContext;
 
-import javax.servlet.RequestDispatcher;
+import jakarta.servlet.RequestDispatcher;
 
 /**
  * The relative path

File: servlet/src/main/java/io/undertow/servlet/attribute/ServletRequestCharacterEncodingAttribute.java
Patch:
@@ -24,7 +24,7 @@
 import io.undertow.server.HttpServerExchange;
 import io.undertow.servlet.handlers.ServletRequestContext;
 
-import javax.servlet.ServletRequest;
+import jakarta.servlet.ServletRequest;
 
 /**
  * The request session ID

File: servlet/src/main/java/io/undertow/servlet/attribute/ServletRequestLineAttribute.java
Patch:
@@ -25,7 +25,7 @@
 import io.undertow.server.HttpServerExchange;
 import io.undertow.servlet.handlers.ServletRequestContext;
 
-import javax.servlet.RequestDispatcher;
+import jakarta.servlet.RequestDispatcher;
 
 /**
  * The request line

File: servlet/src/main/java/io/undertow/servlet/attribute/ServletRequestLocaleAttribute.java
Patch:
@@ -24,7 +24,7 @@
 import io.undertow.server.HttpServerExchange;
 import io.undertow.servlet.handlers.ServletRequestContext;
 
-import javax.servlet.ServletRequest;
+import jakarta.servlet.ServletRequest;
 
 /**
  * The request session ID

File: servlet/src/main/java/io/undertow/servlet/attribute/ServletRequestURLAttribute.java
Patch:
@@ -25,7 +25,7 @@
 import io.undertow.server.HttpServerExchange;
 import io.undertow.servlet.handlers.ServletRequestContext;
 
-import javax.servlet.RequestDispatcher;
+import jakarta.servlet.RequestDispatcher;
 
 /**
  * The request URL

File: servlet/src/main/java/io/undertow/servlet/attribute/ServletRequestedSessionIdAttribute.java
Patch:
@@ -24,8 +24,8 @@
 import io.undertow.server.HttpServerExchange;
 import io.undertow.servlet.handlers.ServletRequestContext;
 
-import javax.servlet.ServletRequest;
-import javax.servlet.http.HttpServletRequest;
+import jakarta.servlet.ServletRequest;
+import jakarta.servlet.http.HttpServletRequest;
 
 /**
  * The request session ID

File: servlet/src/main/java/io/undertow/servlet/attribute/ServletRequestedSessionIdFromCookieAttribute.java
Patch:
@@ -24,8 +24,8 @@
 import io.undertow.server.HttpServerExchange;
 import io.undertow.servlet.handlers.ServletRequestContext;
 
-import javax.servlet.ServletRequest;
-import javax.servlet.http.HttpServletRequest;
+import jakarta.servlet.ServletRequest;
+import jakarta.servlet.http.HttpServletRequest;
 
 /**
  * The request session ID

File: servlet/src/main/java/io/undertow/servlet/attribute/ServletRequestedSessionIdValidAttribute.java
Patch:
@@ -24,8 +24,8 @@
 import io.undertow.server.HttpServerExchange;
 import io.undertow.servlet.handlers.ServletRequestContext;
 
-import javax.servlet.ServletRequest;
-import javax.servlet.http.HttpServletRequest;
+import jakarta.servlet.ServletRequest;
+import jakarta.servlet.http.HttpServletRequest;
 
 /**
  * The request session ID

File: servlet/src/main/java/io/undertow/servlet/attribute/ServletSessionAttribute.java
Patch:
@@ -18,9 +18,9 @@
 
 package io.undertow.servlet.attribute;
 
-import javax.servlet.ServletRequest;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpSession;
+import jakarta.servlet.ServletRequest;
+import jakarta.servlet.http.HttpServletRequest;
+import jakarta.servlet.http.HttpSession;
 
 import io.undertow.attribute.ExchangeAttribute;
 import io.undertow.attribute.ExchangeAttributeBuilder;

File: servlet/src/main/java/io/undertow/servlet/attribute/ServletSessionIdAttribute.java
Patch:
@@ -18,9 +18,9 @@
 
 package io.undertow.servlet.attribute;
 
-import javax.servlet.ServletRequest;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpSession;
+import jakarta.servlet.ServletRequest;
+import jakarta.servlet.http.HttpServletRequest;
+import jakarta.servlet.http.HttpSession;
 
 import io.undertow.attribute.ExchangeAttribute;
 import io.undertow.attribute.ExchangeAttributeBuilder;

File: servlet/src/main/java/io/undertow/servlet/compat/rewrite/RewriteConfigFactory.java
Patch:
@@ -29,7 +29,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.StringTokenizer;
-import javax.servlet.http.HttpServletResponse;
+import jakarta.servlet.http.HttpServletResponse;
 
 /**
  * @author Stuart Douglas

File: servlet/src/main/java/io/undertow/servlet/compat/rewrite/RewriteHandler.java
Patch:
@@ -31,8 +31,8 @@
 import java.nio.charset.StandardCharsets;
 import java.util.HashMap;
 import java.util.Map;
-import javax.servlet.http.Cookie;
-import javax.servlet.http.HttpServletResponse;
+import jakarta.servlet.http.Cookie;
+import jakarta.servlet.http.HttpServletResponse;
 
 /**
  * @author Remy Maucherat

File: servlet/src/main/java/io/undertow/servlet/compat/rewrite/UndertowResolver.java
Patch:
@@ -22,7 +22,7 @@
 import io.undertow.servlet.handlers.ServletRequestContext;
 import io.undertow.util.DateUtils;
 
-import javax.servlet.http.HttpServletRequest;
+import jakarta.servlet.http.HttpServletRequest;
 import java.io.IOException;
 import java.util.Calendar;
 

File: servlet/src/main/java/io/undertow/servlet/core/BlockingWriterSenderImpl.java
Patch:
@@ -27,7 +27,7 @@
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetDecoder;
 
-import javax.servlet.DispatcherType;
+import jakarta.servlet.DispatcherType;
 
 import io.undertow.UndertowMessages;
 import io.undertow.io.IoCallback;

File: servlet/src/main/java/io/undertow/servlet/core/DefaultAuthorizationManager.java
Patch:
@@ -27,7 +27,7 @@
 import io.undertow.servlet.api.TransportGuaranteeType;
 import io.undertow.servlet.api.SingleConstraintMatch;
 
-import javax.servlet.http.HttpServletRequest;
+import jakarta.servlet.http.HttpServletRequest;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;

File: servlet/src/main/java/io/undertow/servlet/core/ErrorPages.java
Patch:
@@ -22,7 +22,7 @@
 
 import java.util.Map;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 /**
  * Class that maintains information about error page mappings.

File: servlet/src/main/java/io/undertow/servlet/core/Lifecycle.java
Patch:
@@ -18,7 +18,7 @@
 
 package io.undertow.servlet.core;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 /**
  *

File: servlet/src/main/java/io/undertow/servlet/core/ManagedListener.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.util.EventListener;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.servlet.UndertowServletMessages;
 import io.undertow.servlet.api.InstanceHandle;

File: servlet/src/main/java/io/undertow/servlet/core/SecurityActions.java
Patch:
@@ -22,7 +22,7 @@
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 
-import javax.servlet.ServletContext;
+import jakarta.servlet.ServletContext;
 
 import io.undertow.server.HttpHandler;
 import io.undertow.server.session.Session;

File: servlet/src/main/java/io/undertow/servlet/core/ServletBlockingHttpExchange.java
Patch:
@@ -22,8 +22,8 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
+import jakarta.servlet.ServletRequest;
+import jakarta.servlet.ServletResponse;
 
 import io.undertow.io.BlockingReceiverImpl;
 import io.undertow.io.BlockingSenderImpl;

File: servlet/src/main/java/io/undertow/servlet/core/ServletUpgradeListener.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.Executor;
-import javax.servlet.http.HttpUpgradeHandler;
+import jakarta.servlet.http.HttpUpgradeHandler;
 
 import org.xnio.ChannelListener;
 import org.xnio.StreamConnection;

File: servlet/src/main/java/io/undertow/servlet/handlers/CrawlerSessionManagerHandler.java
Patch:
@@ -22,9 +22,9 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.regex.Pattern;
-import javax.servlet.http.HttpSession;
-import javax.servlet.http.HttpSessionBindingEvent;
-import javax.servlet.http.HttpSessionBindingListener;
+import jakarta.servlet.http.HttpSession;
+import jakarta.servlet.http.HttpSessionBindingEvent;
+import jakarta.servlet.http.HttpSessionBindingListener;
 
 import io.undertow.UndertowLogger;
 import io.undertow.server.ExchangeCompletionListener;

File: servlet/src/main/java/io/undertow/servlet/handlers/SecurityActions.java
Patch:
@@ -20,7 +20,7 @@
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 
-import javax.servlet.ServletContext;
+import jakarta.servlet.ServletContext;
 
 import io.undertow.server.session.Session;
 import io.undertow.servlet.spec.HttpSessionImpl;

File: servlet/src/main/java/io/undertow/servlet/handlers/SendErrorPageHandler.java
Patch:
@@ -21,7 +21,7 @@
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
 
-import javax.servlet.http.HttpServletResponse;
+import jakarta.servlet.http.HttpServletResponse;
 
 /**
  * A handler that sends the servlet's error page if the status code is greater than 399
@@ -53,4 +53,4 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
         }
     }
 
-}
\ No newline at end of file
+}

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletChain.java
Patch:
@@ -27,9 +27,9 @@
 import io.undertow.servlet.core.ManagedFilter;
 import io.undertow.servlet.core.ManagedServlet;
 
-import javax.servlet.DispatcherType;
-import javax.servlet.ServletException;
-import javax.servlet.http.MappingMatch;
+import jakarta.servlet.DispatcherType;
+import jakarta.servlet.ServletException;
+import jakarta.servlet.http.MappingMatch;
 
 /**
 * @author Stuart Douglas

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletDebugPageHandler.java
Patch:
@@ -21,7 +21,7 @@
 import io.undertow.server.HttpServerExchange;
 import io.undertow.servlet.spec.HttpServletRequestImpl;
 
-import javax.servlet.ServletOutputStream;
+import jakarta.servlet.ServletOutputStream;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletPathMatch.java
Patch:
@@ -18,7 +18,7 @@
 
 package io.undertow.servlet.handlers;
 
-import javax.servlet.http.MappingMatch;
+import jakarta.servlet.http.MappingMatch;
 
 /**
  * @author Stuart Douglas

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletPathMatches.java
Patch:
@@ -31,8 +31,8 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import javax.servlet.DispatcherType;
-import javax.servlet.http.MappingMatch;
+import jakarta.servlet.DispatcherType;
+import jakarta.servlet.http.MappingMatch;
 
 import io.undertow.UndertowLogger;
 import io.undertow.server.HandlerWrapper;

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletRequestContext.java
Patch:
@@ -35,9 +35,9 @@
 import io.undertow.util.AttachmentKey;
 import io.undertow.util.Headers;
 
-import javax.servlet.DispatcherType;
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
+import jakarta.servlet.DispatcherType;
+import jakarta.servlet.ServletRequest;
+import jakarta.servlet.ServletResponse;
 
 /**
  * All the information that servlet needs to attach to the exchange.

File: servlet/src/main/java/io/undertow/servlet/handlers/SessionRestoringHandler.java
Patch:
@@ -28,8 +28,8 @@
 import io.undertow.servlet.spec.HttpSessionImpl;
 import io.undertow.servlet.spec.ServletContextImpl;
 
-import javax.servlet.http.HttpSessionActivationListener;
-import javax.servlet.http.HttpSessionEvent;
+import jakarta.servlet.http.HttpSessionActivationListener;
+import jakarta.servlet.http.HttpSessionEvent;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.Date;

File: servlet/src/main/java/io/undertow/servlet/handlers/security/CachedAuthenticatedSessionHandler.java
Patch:
@@ -33,7 +33,7 @@
 
 import java.security.AccessController;
 
-import javax.servlet.http.HttpSession;
+import jakarta.servlet.http.HttpSession;
 
 /**
  * {@link HttpHandler} responsible for setting up the {@link AuthenticatedSessionManager} for cached authentications and

File: servlet/src/main/java/io/undertow/servlet/handlers/security/ServletAuthenticationCallHandler.java
Patch:
@@ -27,7 +27,7 @@
  * This is the final {@link io.undertow.server.HttpHandler} in the security chain, it's purpose is to act as a barrier at the end of the chain to
  * ensure authenticate is called after the mechanisms have been associated with the context and the constraint checked.
  *
- * This handler uses the Servlet {@link javax.servlet.http.HttpServletResponse#sendError(int)} method to make
+ * This handler uses the Servlet {@link jakarta.servlet.http.HttpServletResponse#sendError(int)} method to make
  * sure the correct error page is displayed.
  *
  * @author <a href="mailto:darran.lofthouse@jboss.com">Darran Lofthouse</a>

File: servlet/src/main/java/io/undertow/servlet/handlers/security/ServletConfidentialityConstraintHandler.java
Patch:
@@ -28,7 +28,7 @@
 import io.undertow.servlet.handlers.ServletRequestContext;
 import io.undertow.util.StatusCodes;
 
-import javax.servlet.http.HttpServletResponse;
+import jakarta.servlet.http.HttpServletResponse;
 import java.net.URI;
 import java.net.URISyntaxException;
 

File: servlet/src/main/java/io/undertow/servlet/handlers/security/ServletSecurityRoleHandler.java
Patch:
@@ -25,9 +25,9 @@
 import io.undertow.servlet.handlers.ServletRequestContext;
 import io.undertow.util.StatusCodes;
 
-import javax.servlet.DispatcherType;
-import javax.servlet.ServletRequest;
-import javax.servlet.http.HttpServletResponse;
+import jakarta.servlet.DispatcherType;
+import jakarta.servlet.ServletRequest;
+import jakarta.servlet.http.HttpServletResponse;
 import java.util.List;
 
 /**

File: servlet/src/main/java/io/undertow/servlet/predicate/DispatcherTypePredicate.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.Map;
 import java.util.Set;
 
-import javax.servlet.DispatcherType;
+import jakarta.servlet.DispatcherType;
 
 import io.undertow.predicate.Predicate;
 import io.undertow.predicate.PredicateBuilder;

File: servlet/src/main/java/io/undertow/servlet/spec/FilterConfigImpl.java
Patch:
@@ -20,8 +20,8 @@
 
 import java.util.Enumeration;
 
-import javax.servlet.FilterConfig;
-import javax.servlet.ServletContext;
+import jakarta.servlet.FilterConfig;
+import jakarta.servlet.ServletContext;
 
 import io.undertow.servlet.api.FilterInfo;
 import io.undertow.servlet.util.IteratorEnumeration;

File: servlet/src/main/java/io/undertow/servlet/spec/FilterRegistrationImpl.java
Patch:
@@ -26,8 +26,8 @@
 import java.util.Map;
 import java.util.Set;
 
-import javax.servlet.DispatcherType;
-import javax.servlet.FilterRegistration;
+import jakarta.servlet.DispatcherType;
+import jakarta.servlet.FilterRegistration;
 
 import io.undertow.servlet.api.Deployment;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/main/java/io/undertow/servlet/spec/HttpSessionImpl.java
Patch:
@@ -24,9 +24,9 @@
 import java.util.Iterator;
 import java.util.Set;
 
-import javax.servlet.ServletContext;
-import javax.servlet.http.HttpSession;
-import javax.servlet.http.HttpSessionContext;
+import jakarta.servlet.ServletContext;
+import jakarta.servlet.http.HttpSession;
+import jakarta.servlet.http.HttpSessionContext;
 
 import io.undertow.server.session.Session;
 import io.undertow.servlet.UndertowServletMessages;

File: servlet/src/main/java/io/undertow/servlet/spec/MappingImpl.java
Patch:
@@ -18,8 +18,8 @@
 
 package io.undertow.servlet.spec;
 
-import javax.servlet.http.HttpServletMapping;
-import javax.servlet.http.MappingMatch;
+import jakarta.servlet.http.HttpServletMapping;
+import jakarta.servlet.http.MappingMatch;
 
 /**
  * @author Stuart Douglas

File: servlet/src/main/java/io/undertow/servlet/spec/PartImpl.java
Patch:
@@ -33,8 +33,8 @@
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
-import javax.servlet.MultipartConfigElement;
-import javax.servlet.http.Part;
+import jakarta.servlet.MultipartConfigElement;
+import jakarta.servlet.http.Part;
 
 /**
  * @author Stuart Douglas

File: servlet/src/main/java/io/undertow/servlet/spec/PushBuilderImpl.java
Patch:
@@ -27,8 +27,8 @@
 import io.undertow.util.HttpString;
 import io.undertow.util.Methods;
 
-import javax.servlet.http.HttpSession;
-import javax.servlet.http.PushBuilder;
+import jakarta.servlet.http.HttpSession;
+import jakarta.servlet.http.PushBuilder;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Iterator;

File: servlet/src/main/java/io/undertow/servlet/spec/SecurityActions.java
Patch:
@@ -20,7 +20,7 @@
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 
-import javax.servlet.ServletContext;
+import jakarta.servlet.ServletContext;
 
 import io.undertow.server.session.Session;
 import io.undertow.servlet.handlers.ServletRequestContext;

File: servlet/src/main/java/io/undertow/servlet/spec/ServletConfigImpl.java
Patch:
@@ -20,8 +20,8 @@
 
 import java.util.Enumeration;
 
-import javax.servlet.ServletConfig;
-import javax.servlet.ServletContext;
+import jakarta.servlet.ServletConfig;
+import jakarta.servlet.ServletContext;
 
 import io.undertow.servlet.UndertowServletMessages;
 import io.undertow.servlet.api.ServletInfo;

File: servlet/src/main/java/io/undertow/servlet/spec/ServletCookieAdaptor.java
Patch:
@@ -35,12 +35,12 @@
  */
 public class ServletCookieAdaptor implements Cookie {
 
-    private final javax.servlet.http.Cookie cookie;
+    private final jakarta.servlet.http.Cookie cookie;
 
     private boolean sameSite;
     private String sameSiteMode;
 
-    public ServletCookieAdaptor(final javax.servlet.http.Cookie cookie) {
+    public ServletCookieAdaptor(final jakarta.servlet.http.Cookie cookie) {
         this.cookie = cookie;
     }
 

File: servlet/src/main/java/io/undertow/servlet/spec/ServletInputStreamImpl.java
Patch:
@@ -25,8 +25,8 @@
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-import javax.servlet.ReadListener;
-import javax.servlet.ServletInputStream;
+import jakarta.servlet.ReadListener;
+import jakarta.servlet.ServletInputStream;
 
 import org.xnio.ChannelListener;
 import org.xnio.IoUtils;

File: servlet/src/main/java/io/undertow/servlet/spec/ServletPrintWriter.java
Patch:
@@ -18,7 +18,7 @@
 
 package io.undertow.servlet.spec;
 
-import javax.servlet.DispatcherType;
+import jakarta.servlet.DispatcherType;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.nio.ByteBuffer;

File: servlet/src/main/java/io/undertow/servlet/spec/SessionCookieConfigImpl.java
Patch:
@@ -22,7 +22,7 @@
 import io.undertow.server.session.SessionConfig;
 import io.undertow.servlet.UndertowServletMessages;
 
-import javax.servlet.SessionCookieConfig;
+import jakarta.servlet.SessionCookieConfig;
 
 /**
  * @author Stuart Douglas

File: servlet/src/main/java/io/undertow/servlet/spec/UpgradeServletInputStream.java
Patch:
@@ -26,8 +26,8 @@
 import org.xnio.channels.Channels;
 import org.xnio.channels.StreamSourceChannel;
 
-import javax.servlet.ReadListener;
-import javax.servlet.ServletInputStream;
+import jakarta.servlet.ReadListener;
+import jakarta.servlet.ServletInputStream;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.concurrent.Executor;

File: servlet/src/main/java/io/undertow/servlet/spec/UpgradeServletOutputStream.java
Patch:
@@ -24,8 +24,8 @@
 import org.xnio.channels.Channels;
 import org.xnio.channels.StreamSinkChannel;
 
-import javax.servlet.ServletOutputStream;
-import javax.servlet.WriteListener;
+import jakarta.servlet.ServletOutputStream;
+import jakarta.servlet.WriteListener;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.concurrent.Executor;

File: servlet/src/main/java/io/undertow/servlet/spec/WebConnectionImpl.java
Patch:
@@ -21,9 +21,9 @@
 import java.io.IOException;
 import java.util.concurrent.Executor;
 
-import javax.servlet.ServletInputStream;
-import javax.servlet.ServletOutputStream;
-import javax.servlet.http.WebConnection;
+import jakarta.servlet.ServletInputStream;
+import jakarta.servlet.ServletOutputStream;
+import jakarta.servlet.http.WebConnection;
 
 import org.xnio.ChannelListener;
 import org.xnio.IoUtils;

File: servlet/src/main/java/io/undertow/servlet/util/SavedRequest.java
Patch:
@@ -31,7 +31,7 @@
 import io.undertow.util.HttpString;
 import io.undertow.util.ImmediatePooledByteBuffer;
 
-import javax.servlet.http.HttpSession;
+import jakarta.servlet.http.HttpSession;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.Serializable;

File: servlet/src/test/java/io/undertow/servlet/test/ProxyForwardedTestCase.java
Patch:
@@ -41,7 +41,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.Socket;

File: servlet/src/test/java/io/undertow/servlet/test/ProxyXForwardedTestCase.java
Patch:
@@ -41,7 +41,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.Socket;

File: servlet/src/test/java/io/undertow/servlet/test/SimpleServletTestCase.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.io.IOException;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/async/SimpleAsyncTestCase.java
Patch:
@@ -38,8 +38,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletContext;
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletContext;
+import jakarta.servlet.ServletException;
 import java.io.IOException;
 import java.text.ParseException;
 import java.util.Date;

File: servlet/src/test/java/io/undertow/servlet/test/async/TestAsyncRespWrapper.java
Patch:
@@ -21,8 +21,8 @@
 import java.io.IOException;
 import java.io.PrintWriter;
 
-import javax.servlet.http.HttpServletResponse;
-import javax.servlet.http.HttpServletResponseWrapper;
+import jakarta.servlet.http.HttpServletResponse;
+import jakarta.servlet.http.HttpServletResponseWrapper;
 
 class TestAsyncRespWrapper extends HttpServletResponseWrapper {
     TestAsyncRespWrapper(HttpServletResponse resp) {
@@ -35,4 +35,4 @@ public PrintWriter getWriter() throws IOException {
         writer.write("wrapped: ");
         return writer;
     }
-}
\ No newline at end of file
+}

File: servlet/src/test/java/io/undertow/servlet/test/charset/CharacterEncodingTestCase.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.io.IOException;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.servlet.api.ServletInfo;
 import io.undertow.servlet.test.util.DeploymentUtils;

File: servlet/src/test/java/io/undertow/servlet/test/charset/DefaultCharacterEncodingTestCase.java
Patch:
@@ -34,8 +34,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletContext;
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletContext;
+import jakarta.servlet.ServletException;
 import java.io.IOException;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;

File: servlet/src/test/java/io/undertow/servlet/test/charset/DefaultCharsetTestCase.java
Patch:
@@ -22,8 +22,8 @@
 
 import java.io.IOException;
 import java.util.Collections;
-import javax.servlet.ServletContext;
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletContext;
+import jakarta.servlet.ServletException;
 
 import org.apache.http.HttpResponse;
 import org.apache.http.client.entity.UrlEncodedFormEntity;

File: servlet/src/test/java/io/undertow/servlet/test/charset/ParameterCharacterEncodingTestCase.java
Patch:
@@ -37,7 +37,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 import java.io.IOException;
 import java.net.URLEncoder;
 import java.nio.charset.Charset;

File: servlet/src/test/java/io/undertow/servlet/test/charset/UnmappableCharacterTestCase.java
Patch:
@@ -31,7 +31,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 import java.io.IOException;
 
 /**

File: servlet/src/test/java/io/undertow/servlet/test/compat/rewrite/RewriteTestCase.java
Patch:
@@ -39,8 +39,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletContext;
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletContext;
+import jakarta.servlet.ServletException;
 import java.io.ByteArrayInputStream;
 import java.nio.charset.StandardCharsets;
 

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/DefaultServletCachingListenerTestCase.java
Patch:
@@ -24,8 +24,8 @@
 import java.nio.file.Path;
 import java.util.concurrent.TimeUnit;
 
-import javax.servlet.DispatcherType;
-import javax.servlet.ServletException;
+import jakarta.servlet.DispatcherType;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.server.handlers.cache.DirectBufferCache;

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/DefaultServletCachingTestCase.java
Patch:
@@ -22,8 +22,8 @@
 import java.nio.file.Files;
 import java.nio.file.Path;
 
-import javax.servlet.DispatcherType;
-import javax.servlet.ServletException;
+import jakarta.servlet.DispatcherType;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.server.handlers.cache.DirectBufferCache;

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/DefaultServletTestCase.java
Patch:
@@ -20,8 +20,8 @@
 
 import java.io.IOException;
 import java.util.Date;
-import javax.servlet.DispatcherType;
-import javax.servlet.ServletException;
+import jakarta.servlet.DispatcherType;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/SecurityRedirectTestCase.java
Patch:
@@ -26,7 +26,7 @@
 
 import java.io.IOException;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/ServletAndResourceWelcomeFileTestCase.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.io.IOException;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/WelcomeFileSecurityTestCase.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.io.IOException;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/WelcomeFileTestCase.java
Patch:
@@ -39,8 +39,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.DispatcherType;
-import javax.servlet.ServletException;
+import jakarta.servlet.DispatcherType;
+import jakarta.servlet.ServletException;
 import java.io.IOException;
 
 /**

File: servlet/src/test/java/io/undertow/servlet/test/dispatcher/DispatcherForwardTestCase.java
Patch:
@@ -49,8 +49,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.DispatcherType;
-import javax.servlet.ServletException;
+import jakarta.servlet.DispatcherType;
+import jakarta.servlet.ServletException;
 import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;

File: servlet/src/test/java/io/undertow/servlet/test/dispatcher/DispatcherIncludeTestCase.java
Patch:
@@ -20,8 +20,8 @@
 
 import java.io.IOException;
 
-import javax.servlet.DispatcherType;
-import javax.servlet.ServletException;
+import jakarta.servlet.DispatcherType;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/errorpage/ErrorPageTestCase.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.io.IOException;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;
@@ -35,7 +35,7 @@
 import io.undertow.testutils.HttpClientUtils;
 import io.undertow.testutils.TestHttpClient;
 import io.undertow.util.StatusCodes;
-import javax.servlet.RequestDispatcher;
+import jakarta.servlet.RequestDispatcher;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
 import org.hamcrest.CoreMatchers;

File: servlet/src/test/java/io/undertow/servlet/test/errorpage/SecureServlet.java
Patch:
@@ -18,7 +18,7 @@
 
 package io.undertow.servlet.test.errorpage;
 
-import javax.servlet.http.HttpServlet;
+import jakarta.servlet.http.HttpServlet;
 
 /**
  * @author Stuart Douglas

File: servlet/src/test/java/io/undertow/servlet/test/errorpage/SecurityErrorPageTestCase.java
Patch:
@@ -39,9 +39,9 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 import java.io.IOException;
-import javax.servlet.RequestDispatcher;
+import jakarta.servlet.RequestDispatcher;
 import org.hamcrest.CoreMatchers;
 
 /**

File: servlet/src/test/java/io/undertow/servlet/test/handlers/MarkSecureHandlerTestCase.java
Patch:
@@ -39,8 +39,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.DispatcherType;
-import javax.servlet.ServletException;
+import jakarta.servlet.DispatcherType;
+import jakarta.servlet.ServletException;
 import java.io.IOException;
 import java.security.GeneralSecurityException;
 

File: servlet/src/test/java/io/undertow/servlet/test/lifecycle/EagerServletLifecycleTestCase.java
Patch:
@@ -18,7 +18,7 @@
 
 package io.undertow.servlet.test.lifecycle;
 
-import javax.servlet.DispatcherType;
+import jakarta.servlet.DispatcherType;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/lifecycle/ServletLifecycleTestCase.java
Patch:
@@ -35,7 +35,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.DispatcherType;
+import jakarta.servlet.DispatcherType;
 
 /**
  * @author Stuart Douglas

File: servlet/src/test/java/io/undertow/servlet/test/listener/ordering/FirstListener.java
Patch:
@@ -19,8 +19,8 @@
 
 import io.undertow.servlet.test.util.Tracker;
 
-import javax.servlet.ServletRequestEvent;
-import javax.servlet.ServletRequestListener;
+import jakarta.servlet.ServletRequestEvent;
+import jakarta.servlet.ServletRequestListener;
 
 public class FirstListener implements ServletRequestListener {
 

File: servlet/src/test/java/io/undertow/servlet/test/listener/ordering/SecondListener.java
Patch:
@@ -19,8 +19,8 @@
 
 import io.undertow.servlet.test.util.Tracker;
 
-import javax.servlet.ServletRequestEvent;
-import javax.servlet.ServletRequestListener;
+import jakarta.servlet.ServletRequestEvent;
+import jakarta.servlet.ServletRequestListener;
 
 public class SecondListener implements ServletRequestListener {
 

File: servlet/src/test/java/io/undertow/servlet/test/listener/ordering/ServletSessionListenerOrderingTestCase.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/RequestListenerAsyncRequestTestCase.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.io.IOException;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/onComplete/AsyncListenerOnCompleteTest.java
Patch:
@@ -37,7 +37,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 import java.io.IOException;
 import java.util.concurrent.TimeUnit;
 

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/onError/AsyncEventListener.java
Patch:
@@ -24,12 +24,12 @@
 import java.util.concurrent.LinkedBlockingDeque;
 import java.util.concurrent.TimeUnit;
 
-import javax.servlet.AsyncEvent;
+import jakarta.servlet.AsyncEvent;
 
 /**
  * @author Stuart Douglas
  */
-public class AsyncEventListener implements javax.servlet.AsyncListener {
+public class AsyncEventListener implements jakarta.servlet.AsyncListener {
 
     private static final LinkedBlockingDeque<String> EVENTS = new LinkedBlockingDeque<>();
 

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/onError/AsyncListenerOnErrorTest.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.io.IOException;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.testutils.ProxyIgnore;
 import org.apache.http.HttpResponse;

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/onError/AsyncTask.java
Patch:
@@ -17,7 +17,7 @@
  */
 package io.undertow.servlet.test.listener.request.async.onError;
 
-import javax.servlet.AsyncContext;
+import jakarta.servlet.AsyncContext;
 
 public class AsyncTask implements Runnable {
 

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/onTimeout/NestedListenerInvocationTestCase.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.io.IOException;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/onTimeout/SimpleAsyncListener.java
Patch:
@@ -21,9 +21,9 @@
 
 import java.io.IOException;
 
-import javax.servlet.AsyncEvent;
-import javax.servlet.AsyncListener;
-import javax.servlet.http.HttpServletResponse;
+import jakarta.servlet.AsyncEvent;
+import jakarta.servlet.AsyncListener;
+import jakarta.servlet.http.HttpServletResponse;
 
 public class SimpleAsyncListener implements AsyncListener {
 

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/onTimeout/SimpleRequestListener.java
Patch:
@@ -17,8 +17,8 @@
  */
 package io.undertow.servlet.test.listener.request.async.onTimeout;
 
-import javax.servlet.ServletRequestEvent;
-import javax.servlet.ServletRequestListener;
+import jakarta.servlet.ServletRequestEvent;
+import jakarta.servlet.ServletRequestListener;
 
 public class SimpleRequestListener implements ServletRequestListener {
 

File: servlet/src/test/java/io/undertow/servlet/test/listener/servletcontext/DeclareRolesServletContextListener.java
Patch:
@@ -17,8 +17,8 @@
  */
 package io.undertow.servlet.test.listener.servletcontext;
 
-import javax.servlet.ServletContextEvent;
-import javax.servlet.ServletContextListener;
+import jakarta.servlet.ServletContextEvent;
+import jakarta.servlet.ServletContextListener;
 /**
  *
  * @author baranowb

File: servlet/src/test/java/io/undertow/servlet/test/listener/servletcontext/ServletContextListenerTestCase.java
Patch:
@@ -21,7 +21,7 @@
 import java.io.IOException;
 import java.util.Collections;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/listener/servletcontext/ServletContextRolesTestCase.java
Patch:
@@ -27,7 +27,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;

File: servlet/src/test/java/io/undertow/servlet/test/listener/session/ServletSessionInvalidateWithListenerTestCase.java
Patch:
@@ -19,7 +19,7 @@
 
 import java.io.IOException;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/listener/session/SimpleSessionListener.java
Patch:
@@ -17,8 +17,8 @@
  */
 package io.undertow.servlet.test.listener.session;
 
-import javax.servlet.http.HttpSessionEvent;
-import javax.servlet.http.HttpSessionListener;
+import jakarta.servlet.http.HttpSessionEvent;
+import jakarta.servlet.http.HttpSessionListener;
 
 import org.junit.Assert;
 

File: servlet/src/test/java/io/undertow/servlet/test/metrics/ServletMetricsHandlerTestCase.java
Patch:
@@ -41,7 +41,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.DispatcherType;
+import jakarta.servlet.DispatcherType;
 
 /**
  * @author Stuart Douglas

File: servlet/src/test/java/io/undertow/servlet/test/multipart/MultiPartTestCase.java
Patch:
@@ -22,8 +22,8 @@
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
 
-import javax.servlet.ServletContext;
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletContext;
+import jakarta.servlet.ServletException;
 
 import io.undertow.servlet.ServletExtension;
 import io.undertow.servlet.Servlets;

File: servlet/src/test/java/io/undertow/servlet/test/multipart/forward/MultiPartForwardTestCase.java
Patch:
@@ -28,7 +28,7 @@
 import java.io.IOException;
 import java.util.Arrays;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.util.StatusCodes;
 import org.apache.http.HttpEntity;

File: servlet/src/test/java/io/undertow/servlet/test/path/FilterPathMappingTestCase.java
Patch:
@@ -25,8 +25,8 @@
 import java.util.List;
 import java.util.Set;
 
-import javax.servlet.DispatcherType;
-import javax.servlet.ServletException;
+import jakarta.servlet.DispatcherType;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/path/MappingTestCase.java
Patch:
@@ -31,7 +31,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 import java.io.IOException;
 
 /**

File: servlet/src/test/java/io/undertow/servlet/test/path/MultipleMatchingMappingTestCase.java
Patch:
@@ -31,8 +31,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.MappingMatch;
+import jakarta.servlet.ServletException;
+import jakarta.servlet.http.MappingMatch;
 import java.io.IOException;
 
 /**

File: servlet/src/test/java/io/undertow/servlet/test/path/RealPathTestCase.java
Patch:
@@ -18,7 +18,7 @@
 
 package io.undertow.servlet.test.path;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/path/ServletPathMappingTestCase.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.io.IOException;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.servlet.api.ServletInfo;
 import io.undertow.servlet.test.util.DeploymentUtils;

File: servlet/src/test/java/io/undertow/servlet/test/path/ServletSpecExampleTestCase.java
Patch:
@@ -13,8 +13,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.MappingMatch;
+import jakarta.servlet.ServletException;
+import jakarta.servlet.http.MappingMatch;
 import java.io.IOException;
 
 /**

File: servlet/src/test/java/io/undertow/servlet/test/proprietry/BypassServletTestCase.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.io.IOException;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.io.IoCallback;
 import io.undertow.server.HandlerWrapper;

File: servlet/src/test/java/io/undertow/servlet/test/proprietry/ExchangeCompletionTestCase.java
Patch:
@@ -23,7 +23,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 import java.io.IOException;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;

File: servlet/src/test/java/io/undertow/servlet/test/proprietry/TransferTestCase.java
Patch:
@@ -23,7 +23,7 @@
 import java.nio.file.Path;
 import java.nio.file.Paths;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/redirect/RedirectEncodedToSubPathTestCase.java
Patch:
@@ -19,7 +19,7 @@
 
 import static io.undertow.servlet.Servlets.servlet;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;

File: servlet/src/test/java/io/undertow/servlet/test/redirect/RedirectWithContentLengthServlet.java
Patch:
@@ -17,9 +17,9 @@
  */
 package io.undertow.servlet.test.redirect;
 
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
+import jakarta.servlet.http.HttpServlet;
+import jakarta.servlet.http.HttpServletRequest;
+import jakarta.servlet.http.HttpServletResponse;
 import java.io.IOException;
 
 /**

File: servlet/src/test/java/io/undertow/servlet/test/redirect/RedirectWithContentLengthTestCase.java
Patch:
@@ -43,7 +43,7 @@
 @RunWith(DefaultServer.class)
 public class RedirectWithContentLengthTestCase {
     @BeforeClass
-    public static void setup() throws javax.servlet.ServletException {
+    public static void setup() throws jakarta.servlet.ServletException {
         final PathHandler pathHandler = new PathHandler();
         final ServletContainer container = ServletContainer.Factory.newInstance();
         DeploymentInfo builder = new DeploymentInfo()
@@ -78,4 +78,4 @@ public void testServletRedirect() throws Exception {
             client.getConnectionManager().shutdown();
         }
     }
-}
\ No newline at end of file
+}

File: servlet/src/test/java/io/undertow/servlet/test/request/ExecutorPerServletTestCase.java
Patch:
@@ -26,7 +26,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.servlet.api.ServletInfo;
 import io.undertow.servlet.test.util.DeploymentUtils;

File: servlet/src/test/java/io/undertow/servlet/test/request/HttpHostValuesTestCase.java
Patch:
@@ -34,7 +34,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import static io.undertow.servlet.Servlets.servlet;
 

File: servlet/src/test/java/io/undertow/servlet/test/request/RedirectTestCase.java
Patch:
@@ -35,7 +35,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 import java.util.ArrayList;
 import java.util.List;
 

File: servlet/src/test/java/io/undertow/servlet/test/request/RequestPathTestCase.java
Patch:
@@ -21,8 +21,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import javax.servlet.DispatcherType;
-import javax.servlet.ServletException;
+import jakarta.servlet.DispatcherType;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/response/contenttype/ContentTypeCharsetTestCase.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.net.URLEncoder;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.servlet.api.ServletInfo;
 import io.undertow.servlet.test.util.DeploymentUtils;

File: servlet/src/test/java/io/undertow/servlet/test/response/contenttype/ContentTypeFilesTestCase.java
Patch:
@@ -18,7 +18,7 @@
 
 package io.undertow.servlet.test.response.contenttype;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DefaultServletConfig;

File: servlet/src/test/java/io/undertow/servlet/test/response/cookies/ResponseCookiesTestCase.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.Arrays;
 import java.util.Comparator;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.servlet.api.ServletInfo;
 import io.undertow.servlet.test.util.DeploymentUtils;

File: servlet/src/test/java/io/undertow/servlet/test/response/writer/ResponseWriterTestCase.java
Patch:
@@ -18,7 +18,7 @@
 
 package io.undertow.servlet.test.response.writer;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.util.StatusCodes;
 import org.apache.http.HttpResponse;

File: servlet/src/test/java/io/undertow/servlet/test/security/basic/ServletBasicAuthTestCase.java
Patch:
@@ -46,7 +46,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
 import java.util.HashMap;

File: servlet/src/test/java/io/undertow/servlet/test/security/basic/ServletCertAndDigestAuthTestCase.java
Patch:
@@ -26,7 +26,7 @@
 
 import java.nio.charset.StandardCharsets;
 import javax.net.ssl.SSLContext;
-import javax.servlet.MultipartConfigElement;
+import jakarta.servlet.MultipartConfigElement;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.AuthMethodConfig;

File: servlet/src/test/java/io/undertow/servlet/test/security/basic/ServletClientCertAuthTestCase.java
Patch:
@@ -26,7 +26,7 @@
 import java.util.HashSet;
 import java.util.Set;
 import javax.net.ssl.SSLContext;
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;

File: servlet/src/test/java/io/undertow/servlet/test/security/constraint/AuthenticationMessageServlet.java
Patch:
@@ -21,9 +21,9 @@
 
 import java.io.IOException;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
+import jakarta.servlet.ServletException;
+import jakarta.servlet.http.HttpServletRequest;
+import jakarta.servlet.http.HttpServletResponse;
 
 /**
  * An extension to the MessageServlet that can also perform additional checks related to the authenticated principal.

File: servlet/src/test/java/io/undertow/servlet/test/security/constraint/EmptyRoleSemanticTestCase.java
Patch:
@@ -39,7 +39,7 @@
 import io.undertow.testutils.TestHttpClient;
 import io.undertow.util.StatusCodes;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;

File: servlet/src/test/java/io/undertow/servlet/test/security/constraint/SecurityConstraintUrlMappingTestCase.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.io.IOException;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/security/custom/ServletCustomAuthFormEncodingTestCase.java
Patch:
@@ -21,7 +21,7 @@
 
 import java.util.List;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: servlet/src/test/java/io/undertow/servlet/test/security/custom/ServletCustomAuthTestCase.java
Patch:
@@ -41,7 +41,7 @@
 import java.util.Arrays;
 import java.util.List;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import org.apache.http.HttpRequest;
 import org.apache.http.HttpResponse;

File: servlet/src/test/java/io/undertow/servlet/test/security/digest/DigestAuthTestCase.java
Patch:
@@ -50,7 +50,7 @@
 import java.nio.charset.StandardCharsets;
 import java.security.MessageDigest;
 import java.util.Map;
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import static io.undertow.util.Headers.AUTHORIZATION;
 import static io.undertow.util.Headers.DIGEST;

File: servlet/src/test/java/io/undertow/servlet/test/security/form/FormAuthenticationRootContextRedirectTestCase.java
Patch:
@@ -18,7 +18,7 @@
 
 package io.undertow.servlet.test.security.form;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import java.io.IOException;
 import java.net.URI;

File: servlet/src/test/java/io/undertow/servlet/test/security/form/ServletFormAuthDefaultPageTestCase.java
Patch:
@@ -43,7 +43,7 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 import org.apache.http.HttpRequest;
 import org.apache.http.HttpResponse;
 import org.apache.http.NameValuePair;

File: servlet/src/test/java/io/undertow/servlet/test/security/form/ServletFormAuthTestCase.java
Patch:
@@ -26,7 +26,7 @@
 import java.util.List;
 
 import java.util.Map;
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.security.api.AuthenticationMode;
 import io.undertow.server.handlers.PathHandler;

File: servlet/src/test/java/io/undertow/servlet/test/security/form/ServletFormAuthURLRewriteTestCase.java
Patch:
@@ -25,8 +25,8 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
-import javax.servlet.ServletException;
-import javax.servlet.SessionTrackingMode;
+import jakarta.servlet.ServletException;
+import jakarta.servlet.SessionTrackingMode;
 
 import org.apache.http.HttpRequest;
 import org.apache.http.HttpResponse;

File: servlet/src/test/java/io/undertow/servlet/test/security/login/ServletLoginTestCase.java
Patch:
@@ -20,8 +20,8 @@
 
 import java.io.IOException;
 
-import javax.servlet.DispatcherType;
-import javax.servlet.ServletException;
+import jakarta.servlet.DispatcherType;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/servletcontext/GetResourceTestCase.java
Patch:
@@ -39,7 +39,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URLEncoder;

File: servlet/src/test/java/io/undertow/servlet/test/session/ChangeSessionIdListener.java
Patch:
@@ -18,8 +18,8 @@
 
 package io.undertow.servlet.test.session;
 
-import javax.servlet.http.HttpSessionEvent;
-import javax.servlet.http.HttpSessionIdListener;
+import jakarta.servlet.http.HttpSessionEvent;
+import jakarta.servlet.http.HttpSessionIdListener;
 
 /**
  * @author Stuart Douglas

File: servlet/src/test/java/io/undertow/servlet/test/session/ChangeSessionIdTestCase.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.io.IOException;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/session/ServletSessionCrawlerTestCase.java
Patch:
@@ -40,7 +40,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 import java.io.IOException;
 import java.util.Collections;
 import java.util.Date;

File: servlet/src/test/java/io/undertow/servlet/test/session/ServletSessionPersistenceTestCase.java
Patch:
@@ -37,7 +37,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 import java.io.IOException;
 
 /**

File: servlet/src/test/java/io/undertow/servlet/test/session/ServletSessionTestCase.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.Date;
 import java.util.List;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/session/SessionCookieConfigListener.java
Patch:
@@ -18,9 +18,9 @@
 
 package io.undertow.servlet.test.session;
 
-import javax.servlet.ServletContextEvent;
-import javax.servlet.ServletContextListener;
-import javax.servlet.SessionTrackingMode;
+import jakarta.servlet.ServletContextEvent;
+import jakarta.servlet.ServletContextListener;
+import jakarta.servlet.SessionTrackingMode;
 import java.util.Arrays;
 import java.util.HashSet;
 

File: servlet/src/test/java/io/undertow/servlet/test/session/SessionIdHandlingTestCase.java
Patch:
@@ -37,7 +37,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 import java.io.IOException;
 import java.util.List;
 

File: servlet/src/test/java/io/undertow/servlet/test/session/invalidate/ServletSessionInvalidateTestCase.java
Patch:
@@ -19,7 +19,7 @@
 
 import java.io.IOException;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.servlet.api.ServletInfo;
 import io.undertow.servlet.test.util.DeploymentUtils;

File: servlet/src/test/java/io/undertow/servlet/test/spec/GetCookiesTestCase.java
Patch:
@@ -18,7 +18,7 @@
 
 package io.undertow.servlet.test.spec;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.util.StatusCodes;
 import org.apache.http.HttpResponse;

File: servlet/src/test/java/io/undertow/servlet/test/spec/ParameterEchoTestCase.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.Arrays;
 import java.util.List;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;

File: servlet/src/test/java/io/undertow/servlet/test/spec/UnavailableServletTestCase.java
Patch:
@@ -12,7 +12,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import java.io.IOException;
 

File: servlet/src/test/java/io/undertow/servlet/test/streams/ServletInputStreamConnectionTerminationTestCase.java
Patch:
@@ -34,7 +34,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 import java.io.IOException;
 
 /**

File: servlet/src/test/java/io/undertow/servlet/test/streams/ServletInputStreamDrainTestCase.java
Patch:
@@ -18,7 +18,7 @@
 
 package io.undertow.servlet.test.streams;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 
 import io.undertow.util.StatusCodes;
 import org.apache.http.HttpResponse;

File: servlet/src/test/java/io/undertow/servlet/test/streams/ServletInputStreamEarlyCloseClientSideTestCase.java
Patch:
@@ -29,7 +29,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletException;
+import jakarta.servlet.ServletException;
 import java.io.OutputStream;
 import java.net.Socket;
 import java.util.concurrent.TimeUnit;

File: servlet/src/test/java/io/undertow/servlet/test/streams/ServletInputStreamRequestBufferingTestCase.java
Patch:
@@ -18,7 +18,7 @@
 
 package io.undertow.servlet.test.streams;
 
-import javax.servlet.ServletContext;
+import jakarta.servlet.ServletContext;
 
 import io.undertow.server.handlers.RequestBufferingHandler;
 import io.undertow.servlet.ServletExtension;

File: core/src/main/java/io/undertow/server/handlers/IPAddressAccessControlHandler.java
Patch:
@@ -268,6 +268,7 @@ private void addIpV4SlashPrefix(final String peer, final boolean deny) {
             int no = Integer.parseInt(part);
             prefix |= no;
         }
+        prefix &= mask;
         ipv4acl.add(new PrefixIpV4PeerMatch(deny, peer, mask, prefix));
     }
 

File: core/src/main/java/io/undertow/server/handlers/IPAddressAccessControlHandler.java
Patch:
@@ -268,6 +268,7 @@ private void addIpV4SlashPrefix(final String peer, final boolean deny) {
             int no = Integer.parseInt(part);
             prefix |= no;
         }
+        prefix &= mask;
         ipv4acl.add(new PrefixIpV4PeerMatch(deny, peer, mask, prefix));
     }
 

File: servlet/src/main/java/io/undertow/servlet/spec/ServletOutputStreamImpl.java
Patch:
@@ -603,13 +603,13 @@ public void close() throws IOException {
             if (anyAreSet(state, FLAG_CLOSED)) return;
             setFlags(FLAG_CLOSED);
             clearFlags(FLAG_READY);
-            if (allAreClear(state, FLAG_WRITE_STARTED) && channel == null && servletRequestContext.getOriginalResponse().getHeader(Headers.CONTENT_LENGTH_STRING) == null) {
+            if (allAreClear(state, FLAG_WRITE_STARTED) && channel == null) {
                 if (servletRequestContext.getOriginalResponse().getHeader(Headers.TRANSFER_ENCODING_STRING) == null
                         && servletRequestContext.getExchange().getAttachment(HttpAttachments.RESPONSE_TRAILER_SUPPLIER) == null
                         && servletRequestContext.getExchange().getAttachment(HttpAttachments.RESPONSE_TRAILERS) == null) {
                     if (buffer == null) {
                         servletRequestContext.getExchange().getResponseHeaders().put(Headers.CONTENT_LENGTH, "0");
-                    } else {
+                    } else if (servletRequestContext.getOriginalResponse().getHeader(Headers.CONTENT_LENGTH_STRING) == null) {
                         servletRequestContext.getExchange().getResponseHeaders().put(Headers.CONTENT_LENGTH, Integer.toString(buffer.position()));
                     }
                 }

File: core/src/main/java/io/undertow/server/handlers/cache/LimitedBufferSlicePool.java
Patch:
@@ -18,6 +18,8 @@
 
 package io.undertow.server.handlers.cache;
 
+import static org.wildfly.common.Assert.checkNotNullParam;
+
 import org.xnio.BufferAllocator;
 
 import java.nio.ByteBuffer;
@@ -64,7 +66,7 @@ public LimitedBufferSlicePool(final BufferAllocator<ByteBuffer> allocator, final
         }
         buffersPerRegion = maxRegionSize / bufferSize;
         this.bufferSize = bufferSize;
-        this.allocator = allocator;
+        this.allocator = checkNotNullParam("allocator", allocator);
         this.maxRegions = maxRegions;
     }
 

File: core/src/main/java/io/undertow/util/HeaderValues.java
Patch:
@@ -18,6 +18,8 @@
 
 package io.undertow.util;
 
+import static org.wildfly.common.Assert.checkNotNullParam;
+
 import java.util.AbstractCollection;
 import java.util.Arrays;
 import java.util.Collection;
@@ -385,7 +387,7 @@ public int lastIndexOf(final Object o) {
     }
 
     public String set(final int index, final String element) {
-        if (element == null) throw new IllegalArgumentException();
+        checkNotNullParam("element", element);
 
         final byte size = this.size;
         if (index < 0 || index >= size) throw new IndexOutOfBoundsException();

File: core/src/main/java9/io/undertow/util/FastConcurrentDirectDeque.java
Patch:
@@ -24,6 +24,8 @@
 
 package io.undertow.util;
 
+import static org.wildfly.common.Assert.checkNotNullParamWithNullPointerException;
+
 import java.io.Serializable;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
@@ -1319,8 +1321,7 @@ public Object[] toArray() {
      */
     @SuppressWarnings("unchecked")
     public <T> T[] toArray(T[] a) {
-        if (a == null) throw new NullPointerException();
-        return (T[]) toArrayInternal(a);
+        return (T[]) toArrayInternal(checkNotNullParamWithNullPointerException("a", a));
     }
 
     /**

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/onError/AsyncListenerOnErrorTest.java
Patch:
@@ -22,6 +22,7 @@
 
 import javax.servlet.ServletException;
 
+import io.undertow.testutils.ProxyIgnore;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
 import org.jboss.logging.Logger;
@@ -167,7 +168,8 @@ public void testAsyncListenerOnErrorExceptionInFirstServlet() throws IOException
         }
     }
 
-    @Test
+    @Test @ProxyIgnore
+    // FIXME UNDERTOW-1523
     public void testAsyncErrorOnClientBreakdown() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/onError/AsyncServlet5.java
Patch:
@@ -66,6 +66,7 @@ public void run() {
                     e.printStackTrace();
                 }
                 scheduledFuture.cancel(true);
+                ctx.complete();
             }
         });
         t.start();

File: core/src/main/java/io/undertow/security/impl/DigestAuthenticationMechanism.java
Patch:
@@ -168,7 +168,7 @@ public AuthenticationMechanismOutcome authenticate(final HttpServerExchange exch
 
                         return handleDigestHeader(exchange, securityContext);
                     } catch (Exception e) {
-                        e.printStackTrace();
+                        UndertowLogger.SECURITY_LOGGER.authenticationFailedFor(current, exchange, e);
                     }
                 }
 

File: core/src/main/java/io/undertow/security/impl/GSSAPIAuthenticationMechanism.java
Patch:
@@ -202,10 +202,10 @@ public AuthenticationMechanismOutcome runGSSAPI(final HttpServerExchange exchang
             // The AcceptSecurityContext takes over responsibility for setting the result.
             return Subject.doAs(server, new AcceptSecurityContext(exchange, challenge, securityContext));
         } catch (GeneralSecurityException e) {
-            e.printStackTrace();
+            UndertowLogger.SECURITY_LOGGER.failedToObtainSubject(exchange, e);
             return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
         } catch (PrivilegedActionException e) {
-            e.printStackTrace();
+            UndertowLogger.SECURITY_LOGGER.failedToNegotiateAtGSSAPI(exchange, e.getCause());
             return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
         }
     }

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -198,7 +198,8 @@ public void sendRedirect(final String location) throws IOException {
             if (location.startsWith("/")) {
                 realPath = location;
             } else {
-                String current = exchange.getRelativePath();
+                //Match AsyncContext.dispatch, could use 'exchange.getResolvedPath().length()' instead of servlet context
+                String current = exchange.getRequestURI().substring(getServletContext().getContextPath().length());
                 int lastSlash = current.lastIndexOf("/");
                 if (lastSlash != -1) {
                     current = current.substring(0, lastSlash + 1);

File: core/src/main/java/io/undertow/util/NetworkUtils.java
Patch:
@@ -125,7 +125,7 @@ public static byte[] parseIpv6AddressToBytes(final String addressString) throws
                 data[i * 2 + partOffset + 1] = (byte) (num);
             }
         }
-        if (parts.length < 8 && !seenEmpty) {
+        if ((parts.length < 8 && !addressString.endsWith("::")) && !seenEmpty) {
             //address was too small
             throw UndertowMessages.MESSAGES.invalidIpAddress(addressString);
         }

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -198,7 +198,8 @@ public void sendRedirect(final String location) throws IOException {
             if (location.startsWith("/")) {
                 realPath = location;
             } else {
-                String current = exchange.getRelativePath();
+                //Match AsyncContext.dispatch, could use 'exchange.getResolvedPath().length()' instead of servlet context
+                String current = exchange.getRequestURI().substring(getServletContext().getContextPath().length());
                 int lastSlash = current.lastIndexOf("/");
                 if (lastSlash != -1) {
                     current = current.substring(0, lastSlash + 1);

File: core/src/main/java/io/undertow/security/impl/DigestAuthenticationMechanism.java
Patch:
@@ -168,7 +168,7 @@ public AuthenticationMechanismOutcome authenticate(final HttpServerExchange exch
 
                         return handleDigestHeader(exchange, securityContext);
                     } catch (Exception e) {
-                        e.printStackTrace();
+                        UndertowLogger.SECURITY_LOGGER.authenticationFailedFor(current, exchange, e);
                     }
                 }
 

File: core/src/main/java/io/undertow/security/impl/GSSAPIAuthenticationMechanism.java
Patch:
@@ -202,10 +202,10 @@ public AuthenticationMechanismOutcome runGSSAPI(final HttpServerExchange exchang
             // The AcceptSecurityContext takes over responsibility for setting the result.
             return Subject.doAs(server, new AcceptSecurityContext(exchange, challenge, securityContext));
         } catch (GeneralSecurityException e) {
-            e.printStackTrace();
+            UndertowLogger.SECURITY_LOGGER.failedToObtainSubject(exchange, e);
             return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
         } catch (PrivilegedActionException e) {
-            e.printStackTrace();
+            UndertowLogger.SECURITY_LOGGER.failedToNegotiateAtGSSAPI(exchange, e.getCause());
             return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
         }
     }

File: core/src/main/java/io/undertow/util/NetworkUtils.java
Patch:
@@ -125,7 +125,7 @@ public static byte[] parseIpv6AddressToBytes(final String addressString) throws
                 data[i * 2 + partOffset + 1] = (byte) (num);
             }
         }
-        if (parts.length < 8 && !seenEmpty) {
+        if ((parts.length < 8 && !addressString.endsWith("::")) && !seenEmpty) {
             //address was too small
             throw UndertowMessages.MESSAGES.invalidIpAddress(addressString);
         }

File: core/src/main/java/io/undertow/server/handlers/cache/LimitedBufferSlicePool.java
Patch:
@@ -18,6 +18,8 @@
 
 package io.undertow.server.handlers.cache;
 
+import static org.wildfly.common.Assert.checkNotNullParam;
+
 import org.xnio.BufferAllocator;
 
 import java.nio.ByteBuffer;
@@ -64,7 +66,7 @@ public LimitedBufferSlicePool(final BufferAllocator<ByteBuffer> allocator, final
         }
         buffersPerRegion = maxRegionSize / bufferSize;
         this.bufferSize = bufferSize;
-        this.allocator = allocator;
+        this.allocator = checkNotNullParam("allocator", allocator);
         this.maxRegions = maxRegions;
     }
 

File: core/src/main/java/io/undertow/util/HeaderValues.java
Patch:
@@ -18,6 +18,8 @@
 
 package io.undertow.util;
 
+import static org.wildfly.common.Assert.checkNotNullParam;
+
 import java.util.AbstractCollection;
 import java.util.Arrays;
 import java.util.Collection;
@@ -385,7 +387,7 @@ public int lastIndexOf(final Object o) {
     }
 
     public String set(final int index, final String element) {
-        if (element == null) throw new IllegalArgumentException();
+        checkNotNullParam("element", element);
 
         final byte size = this.size;
         if (index < 0 || index >= size) throw new IndexOutOfBoundsException();

File: core/src/main/java9/io/undertow/util/FastConcurrentDirectDeque.java
Patch:
@@ -24,6 +24,8 @@
 
 package io.undertow.util;
 
+import static org.wildfly.common.Assert.checkNotNullParamWithNullPointerException;
+
 import java.io.Serializable;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
@@ -1319,8 +1321,7 @@ public Object[] toArray() {
      */
     @SuppressWarnings("unchecked")
     public <T> T[] toArray(T[] a) {
-        if (a == null) throw new NullPointerException();
-        return (T[]) toArrayInternal(a);
+        return (T[]) toArrayInternal(checkNotNullParamWithNullPointerException("a", a));
     }
 
     /**

File: core/src/main/java/io/undertow/Undertow.java
Patch:
@@ -574,7 +574,7 @@ public <T> Builder setWorkerOption(final Option<T> option, final T value) {
          * Additionally, the provided {@link XnioWorker} will NOT be shutdown when {@link Undertow#stop()} is called.
          * Essentially, the lifecycle of the provided worker must be maintained outside of the {@link Undertow} instance.
          */
-        public <T> Builder setWorker(XnioWorker worker) {
+        public Builder setWorker(XnioWorker worker) {
             this.worker = worker;
             return this;
         }
@@ -584,7 +584,7 @@ public Builder setSslEngineDelegatedTaskExecutor(Executor sslEngineDelegatedTask
             return this;
         }
 
-        public <T> Builder setByteBufferPool(ByteBufferPool byteBufferPool) {
+        public Builder setByteBufferPool(ByteBufferPool byteBufferPool) {
             this.byteBufferPool = byteBufferPool;
             return this;
         }

File: core/src/main/java/io/undertow/attribute/RemoteHostAttribute.java
Patch:
@@ -40,7 +40,7 @@ private RemoteHostAttribute() {
 
     @Override
     public String readAttribute(final HttpServerExchange exchange) {
-        final InetSocketAddress sourceAddress = (InetSocketAddress) exchange.getSourceAddress();
+        final InetSocketAddress sourceAddress = exchange.getSourceAddress();
         return sourceAddress.getHostString();
     }
 

File: core/src/main/java/io/undertow/client/http2/Http2ClientProvider.java
Patch:
@@ -138,7 +138,7 @@ public void handleEvent(SslConnection connection) {
                 listener.completed(createHttp2Channel(connection, bufferPool, options, uri.getHost()));
             }
         }, HTTP2);
-    };
+    }
 
     private void handleConnected(StreamConnection connection, final ClientCallback<ClientConnection> listener, URI uri,ByteBufferPool bufferPool, OptionMap options) {
         ALPNClientSelector.runAlpn((SslConnection) connection, FAILED, listener, alpnProtocol(listener, uri, bufferPool, options));

File: core/src/main/java/io/undertow/protocols/ajp/AjpResponseParser.java
Patch:
@@ -134,7 +134,6 @@ public void parse(final ByteBuffer buf) throws IOException {
                 StringHolder result = parseString(buf, false);
                 if (result.readComplete) {
                     reasonPhrase = result.value;
-                    //exchange.setRequestURI(result.value);
                 } else {
                     this.state = READING_REASON_PHRASE;
                     return;

File: core/src/main/java/io/undertow/protocols/http2/Http2DataStreamSinkChannel.java
Patch:
@@ -197,7 +197,7 @@ protected SendFrameHeader createFrameHeaderImpl() {
                 currentBuffer.put((byte) ((Http2Channel.HEADERS_FLAG_END_STREAM & 0xFF) | (dataPaddingBytes > 0 ? Http2Channel.DATA_FLAG_PADDED : 0))); //flags
             } else {
                 requiresTrailers = true;
-                currentBuffer.put((byte) ((dataPaddingBytes > 0 ? Http2Channel.DATA_FLAG_PADDED : 0))); //flags
+                currentBuffer.put((byte) (dataPaddingBytes > 0 ? Http2Channel.DATA_FLAG_PADDED : 0)); //flags
             }
             Http2ProtocolUtils.putInt(currentBuffer, getStreamId());
             if (dataPaddingBytes > 0) {

File: core/src/main/java/io/undertow/server/handlers/accesslog/DefaultAccessLogReceiver.java
Patch:
@@ -249,7 +249,6 @@ private void writeMessage(final List<String> messages) {
         }
         try {
             if (writer == null) {
-                boolean created = !Files.exists(defaultLogFile);
                 writer = Files.newBufferedWriter(defaultLogFile, StandardCharsets.UTF_8, StandardOpenOption.APPEND, StandardOpenOption.CREATE);
                 if(Files.size(defaultLogFile) == 0 && fileHeaderGenerator != null) {
                     String header = fileHeaderGenerator.generateHeader();

File: core/src/main/java/io/undertow/server/handlers/proxy/ProxyHandler.java
Patch:
@@ -889,7 +889,7 @@ public static class Builder {
         private int maxConnectionRetries = DEFAULT_MAX_RETRY_ATTEMPTS;
         private Predicate idempotentRequestPredicate = IdempotentPredicate.INSTANCE;
 
-        Builder() {};
+        Builder() {}
 
 
         public ProxyClient getProxyClient() {

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/ModCluster.java
Patch:
@@ -24,7 +24,6 @@
 
 import io.undertow.client.UndertowClient;
 import io.undertow.server.HttpHandler;
-import io.undertow.server.handlers.ResponseCodeHandler;
 import io.undertow.server.handlers.proxy.ProxyHandler;
 import io.undertow.server.handlers.proxy.RouteParsingStrategy;
 import org.xnio.OptionMap;
@@ -36,8 +35,6 @@
  */
 public class ModCluster {
 
-    private static final HttpHandler NEXT_HANDLER = ResponseCodeHandler.HANDLE_404;
-
     // Health check intervals
     private final long healthCheckInterval;
     private final long removeBrokenNodes;

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpRequestParser.java
Patch:
@@ -321,9 +321,7 @@ public void parse(final ByteBuffer buf, final AjpRequestParseState state, final
             }
             case AjpRequestParseState.READING_REMOTE_HOST: {
                 StringHolder result = parseString(buf, state, StringType.OTHER);
-                if (result.readComplete) {
-                    //exchange.setRequestURI(result.value);
-                } else {
+                if (!result.readComplete) {
                     state.state = AjpRequestParseState.READING_REMOTE_HOST;
                     return;
                 }

File: core/src/main/java/io/undertow/server/protocol/http/HttpResponseConduit.java
Patch:
@@ -398,9 +398,6 @@ private int processStatefulWrite(int state, final Object userData, int pos, int
                         buffer.clear();
                     }
                     buffer.put((byte) ' ');
-                    //if (valueIterator == null) {
-                    //    valueIterator = exchange.getResponseHeaders().get(headerName).iterator();
-                    //}
                     string = headerValues.get(valueIdx++);
                     charIndex = 0;
                     // fall thru

File: core/src/main/java/io/undertow/util/ETagUtils.java
Patch:
@@ -174,7 +174,6 @@ public static List<ETag> parseETagList(final String header) {
         List<ETag> response = new ArrayList<>();
 
         SearchingFor searchingFor = SearchingFor.START_OF_VALUE;
-        String currentToken = null;
         int valueStart = 0;
         boolean weak = false;
         boolean malformed = false;

File: core/src/main/java/io/undertow/util/PathMatcher.java
Patch:
@@ -95,7 +95,6 @@ public PathMatch<T> match(String path){
                 char c = path.charAt(pathLength);
                 if (c == '/') {
 
-                    //String part = path.substring(0, pathLength);
                     SubstringMap.SubstringMatch<T> next = paths.get(path, pathLength);
                     if (next != null) {
                         UndertowLogger.REQUEST_LOGGER.debugf("Matched prefix path %s for path %s", next.getKey(), path);

File: servlet/src/main/java/io/undertow/servlet/compat/rewrite/Substitution.java
Patch:
@@ -229,7 +229,7 @@ public void parse(Map<String, RewriteMap> maps) {
             }
         }
 
-        this.elements = (SubstitutionElement[]) elements.toArray(new SubstitutionElement[0]);
+        this.elements = elements.toArray(new SubstitutionElement[0]);
 
     }
 

File: servlet/src/main/java/io/undertow/servlet/spec/RequestDispatcherImpl.java
Patch:
@@ -41,7 +41,6 @@
 import io.undertow.server.HttpServerExchange;
 import io.undertow.servlet.UndertowServletLogger;
 import io.undertow.servlet.UndertowServletMessages;
-import io.undertow.servlet.api.ThreadSetupAction;
 import io.undertow.servlet.api.ThreadSetupHandler;
 import io.undertow.servlet.handlers.ServletRequestContext;
 import io.undertow.servlet.handlers.ServletChain;
@@ -120,7 +119,6 @@ private void forwardImplSetup(final ServletRequest request, final ServletRespons
             return;
         }
 
-        ThreadSetupAction.Handle handle = null;
         ServletContextImpl oldServletContext = null;
         HttpSessionImpl oldSession = null;
         if (servletRequestContext.getCurrentServletContext() != this.servletContext) {

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/SendHandlerAdapter.java
Patch:
@@ -31,7 +31,6 @@
  */
 final class SendHandlerAdapter implements WebSocketCallback<Void> {
     private final SendHandler handler;
-    private static final SendResult OK = new SendResult();
     private volatile boolean done;
 
     SendHandlerAdapter(SendHandler handler) {

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -630,4 +630,7 @@ public interface UndertowMessages {
 
     @Message(id = 202, value = "Failed to initialize path manager for '%s' path.")
     RuntimeException failedToInitializePathManager(String path, @Cause IOException ioe);
+
+    @Message(id = 203, value = "Invalid ACL entry")
+    IllegalArgumentException invalidACLAddress(@Cause Exception e);
 }

File: core/src/main/java/io/undertow/server/handlers/ProxyPeerAddressHandler.java
Patch:
@@ -43,9 +43,9 @@
  */
 public class ProxyPeerAddressHandler implements HttpHandler {
 
-    private static final Pattern IP4_EXACT = Pattern.compile("(?:\\d{1,3}\\.){3}\\d{1,3}");
+    private static final Pattern IP4_EXACT = Pattern.compile(NetworkUtils.IP4_EXACT);
 
-    private static final Pattern IP6_EXACT = Pattern.compile("(?:[a-zA-Z0-9]{1,4}:){7}[a-zA-Z0-9]{1,4}");
+    private static final Pattern IP6_EXACT = Pattern.compile(NetworkUtils.IP6_EXACT);
 
     private final HttpHandler next;
 

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -630,4 +630,7 @@ public interface UndertowMessages {
 
     @Message(id = 202, value = "Failed to initialize path manager for '%s' path.")
     RuntimeException failedToInitializePathManager(String path, @Cause IOException ioe);
+
+    @Message(id = 203, value = "Invalid ACL entry")
+    IllegalArgumentException invalidACLAddress(@Cause Exception e);
 }

File: core/src/main/java/io/undertow/server/handlers/ProxyPeerAddressHandler.java
Patch:
@@ -43,9 +43,9 @@
  */
 public class ProxyPeerAddressHandler implements HttpHandler {
 
-    private static final Pattern IP4_EXACT = Pattern.compile("(?:\\d{1,3}\\.){3}\\d{1,3}");
+    private static final Pattern IP4_EXACT = Pattern.compile(NetworkUtils.IP4_EXACT);
 
-    private static final Pattern IP6_EXACT = Pattern.compile("(?:[a-zA-Z0-9]{1,4}:){7}[a-zA-Z0-9]{1,4}");
+    private static final Pattern IP6_EXACT = Pattern.compile(NetworkUtils.IP6_EXACT);
 
     private final HttpHandler next;
 

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/DefaultServletCachingListenerTestCase.java
Patch:
@@ -67,8 +67,8 @@
 public class DefaultServletCachingListenerTestCase {
 
     private static final int MAX_FILE_SIZE = 20;
-    private static final int MAX_WAIT_TIME = 30000;
-    private static final int WAIT_TIME = 1000;
+    private static final int MAX_WAIT_TIME = 300000;
+    private static final int WAIT_TIME = 10000;
     public static final String DIR_NAME = "cacheTest";
 
     private static Path tmpDir;

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/DefaultServletCachingListenerTestCase.java
Patch:
@@ -67,8 +67,8 @@
 public class DefaultServletCachingListenerTestCase {
 
     private static final int MAX_FILE_SIZE = 20;
-    private static final int MAX_WAIT_TIME = 30000;
-    private static final int WAIT_TIME = 1000;
+    private static final int MAX_WAIT_TIME = 300000;
+    private static final int WAIT_TIME = 10000;
     public static final String DIR_NAME = "cacheTest";
 
     private static Path tmpDir;

File: core/src/main/java/io/undertow/server/handlers/resource/PathResourceManager.java
Patch:
@@ -309,7 +309,7 @@ public synchronized void close() throws IOException {
     /**
      * Returns true is some element of path inside base path is a symlink.
      */
-    private SymlinkResult getSymlinkBase(final String base, final Path file) throws IOException {
+    private SymlinkResult getSymlinkBase(final String base, final Path file) {
         int nameCount = file.getNameCount();
         Path root = fileSystem.getPath(base);
         int rootCount = root.getNameCount();

File: core/src/main/java/io/undertow/server/handlers/resource/PathResourceManager.java
Patch:
@@ -309,7 +309,7 @@ public synchronized void close() throws IOException {
     /**
      * Returns true is some element of path inside base path is a symlink.
      */
-    private SymlinkResult getSymlinkBase(final String base, final Path file) throws IOException {
+    private SymlinkResult getSymlinkBase(final String base, final Path file) {
         int nameCount = file.getNameCount();
         Path root = fileSystem.getPath(base);
         int rootCount = root.getNameCount();

File: core/src/main/java/io/undertow/client/http/HttpRequestConduit.java
Patch:
@@ -388,7 +388,7 @@ private int processWrite(int state, final ByteBuffer userData) throws IOExceptio
                         buffer.clear();
                     }
                     buffer.put((byte) 10); // LF
-                    if(valueIterator.hasNext()) {
+                    if(valueIterator != null && valueIterator.hasNext()) {
                         state = STATE_HDR_NAME;
                         break;
                     } else if (nameIterator.hasNext()) {

File: core/src/main/java/io/undertow/conduits/InflatingStreamSourceConduit.java
Patch:
@@ -123,7 +123,7 @@ public int read(ByteBuffer dst) throws IOException {
             } else if (nextDone && inflater.finished()) {
                 done();
                 return -1;
-            } else if (inflater.finished()) {
+            } else if (inflater.finished() && compressed != null) {
                 int rem = inflater.getRemaining();
                 ByteBuffer buf = compressed.getBuffer();
                 buf.position(buf.limit() - rem);

File: core/src/main/java/io/undertow/util/Cookies.java
Patch:
@@ -149,6 +149,9 @@ public static Cookie parseSetCookieHeader(final String headerValue) {
     }
 
     private static void handleValue(CookieImpl cookie, String key, String value) {
+        if (key == null) {
+            return;
+        }
         if (key.equalsIgnoreCase("path")) {
             cookie.setPath(value);
         } else if (key.equalsIgnoreCase("domain")) {

File: core/src/main/java/io/undertow/util/FastConcurrentDirectDeque.java
Patch:
@@ -511,7 +511,7 @@ else if (p == q)
             // TODO: better HOP heuristics
             if (hops < HOPS
                 // always squeeze out interior deleted nodes
-                && (isFirst | isLast))
+                && (isFirst || isLast))
                 return;
 
             // Squeeze out deleted nodes between activePred and
@@ -520,7 +520,7 @@ else if (p == q)
             skipDeletedPredecessors(activeSucc);
 
             // Try to gc-unlink, if possible
-            if ((isFirst | isLast) &&
+            if ((isFirst || isLast) &&
 
                 // Recheck expected state of predecessor and successor
                 (activePred.next == activeSucc) &&

File: core/src/main/java/io/undertow/util/PortableConcurrentDirectDeque.java
Patch:
@@ -478,7 +478,7 @@ else if (p == q)
             // TODO: better HOP heuristics
             if (hops < HOPS
                 // always squeeze out interior deleted nodes
-                && (isFirst | isLast))
+                && (isFirst || isLast))
                 return;
 
             // Squeeze out deleted nodes between activePred and
@@ -487,7 +487,7 @@ else if (p == q)
             skipDeletedPredecessors(activeSucc);
 
             // Try to gc-unlink, if possible
-            if ((isFirst | isLast) &&
+            if ((isFirst || isLast) &&
 
                 // Recheck expected state of predecessor and successor
                 (activePred.next == activeSucc) &&

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/FrameHandler.java
Patch:
@@ -152,6 +152,8 @@ public void run() {
                     }
                 }
             });
+        } else {
+            bufferedBinaryMessage.getData().free();
         }
     }
 

File: core/src/test/java/io/undertow/testutils/TestHttpClient.java
Patch:
@@ -87,8 +87,8 @@ public TestHttpClient(ClientConnectionManager conman, HttpParams params) {
 
     private static HttpParams preventSocketTimeoutException(HttpParams params) {
         // UNDERTOW-1929 prevent the SocketTimeoutException that we see recurring
-        // in CI when running tests on Windows / proxy ajp mode
-        if (System.getProperty("os.name").startsWith("Windows") && DefaultServer.isProxy() && DefaultServer.isAjp()) {
+        // in CI when running tests on proxy mode
+        if (DefaultServer.isProxy()) {
             if (params == null) {
                 params = new SyncBasicHttpParams();
                 setDefaultHttpParams(params);
@@ -107,7 +107,7 @@ protected HttpRequestRetryHandler createHttpRequestRetryHandler() {
     @Override
     protected HttpParams createHttpParams() {
         HttpParams params = super.createHttpParams();
-        HttpConnectionParams.setSoTimeout(params, 30000);
+        HttpConnectionParams.setSoTimeout(params, 120000);
         return params;
     }
 

File: core/src/test/java/io/undertow/testutils/TestHttpClient.java
Patch:
@@ -87,8 +87,8 @@ public TestHttpClient(ClientConnectionManager conman, HttpParams params) {
 
     private static HttpParams preventSocketTimeoutException(HttpParams params) {
         // UNDERTOW-1929 prevent the SocketTimeoutException that we see recurring
-        // in CI when running tests on Windows / proxy ajp mode
-        if (System.getProperty("os.name").startsWith("Windows") && DefaultServer.isProxy() && DefaultServer.isAjp()) {
+        // in CI when running tests on proxy mode
+        if (DefaultServer.isProxy()) {
             if (params == null) {
                 params = new SyncBasicHttpParams();
                 setDefaultHttpParams(params);
@@ -107,7 +107,7 @@ protected HttpRequestRetryHandler createHttpRequestRetryHandler() {
     @Override
     protected HttpParams createHttpParams() {
         HttpParams params = super.createHttpParams();
-        HttpConnectionParams.setSoTimeout(params, 30000);
+        HttpConnectionParams.setSoTimeout(params, 120000);
         return params;
     }
 

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/DefaultServletCachingListenerTestCase.java
Patch:
@@ -67,8 +67,8 @@
 public class DefaultServletCachingListenerTestCase {
 
     private static final int MAX_FILE_SIZE = 20;
-    private static final int MAX_WAIT_TIME = 20000;
-    private static final int WAIT_TIME = 500;
+    private static final int MAX_WAIT_TIME = 30000;
+    private static final int WAIT_TIME = 1000;
     public static final String DIR_NAME = "cacheTest";
 
     private static Path tmpDir;

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -618,4 +618,7 @@ public interface UndertowMessages {
 
     @Message(id = 198, value = "Blocking write timed out after %s nanoseconds.")
     WriteTimeoutException blockingWriteTimedOut(long timeoutNanoseconds);
+
+    @Message(id = 199, value = "Read timed out after %s milliseconds.")
+    ReadTimeoutException readTimedOut(long timeoutMilliseconds);
 }

File: jakartaee9/src/main/java/io/undertow/jakartaee9/JakartaEE9Transformer.java
Patch:
@@ -65,9 +65,9 @@ public static void main (String[] args) throws IOException {
                 assert generatedFile.exists();
                 final File newGeneratedFile = new File(OUTPUT_DIR.getAbsolutePath() + File.separatorChar + newFileName);
                 if (!generatedFile.renameTo(newGeneratedFile)) {
-                    throw LOGGER.renamingFileFalied(generatedFile.getAbsolutePath(), newGeneratedFile.getAbsolutePath());
+                    throw LOGGER.renamingFileFailed(generatedFile.getAbsolutePath(), newGeneratedFile.getAbsolutePath());
                 }
             }
         }
     }
-}
+}
\ No newline at end of file

File: jakartaee9/src/main/java/io/undertow/jakartaee9/PomTransformer.java
Patch:
@@ -79,6 +79,9 @@ class PomTransformer {
     PomTransformer(File inputDir, File outputDir) {
         this.inputDir = inputDir;
         this.outputDir = outputDir;
+        if (!inputDir.exists()) {
+            throw LOGGER.inputDirDoesNotExist(inputDir.getAbsolutePath());
+        }
     }
 
     void transformPoms() throws IOException {

File: core/src/test/java/io/undertow/server/ssl/ComplexSSLTestCase.java
Patch:
@@ -45,6 +45,7 @@
 import org.apache.http.client.methods.HttpPost;
 import org.apache.http.entity.StringEntity;
 import org.junit.Assert;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -107,6 +108,7 @@ public void complexSSLTestCase() throws IOException, GeneralSecurityException, U
     }
 
     @Test
+    @Ignore // FIXME UNDERTOW-1918
     public void testSslLotsOfData() throws IOException, GeneralSecurityException, URISyntaxException {
 
         DefaultServer.setRootHandler(new HttpHandler() {

File: jakartaee9/src/main/java/io/undertow/jakartaee9/JakartaEE9Transformer.java
Patch:
@@ -65,9 +65,9 @@ public static void main (String[] args) throws IOException {
                 assert generatedFile.exists();
                 final File newGeneratedFile = new File(OUTPUT_DIR.getAbsolutePath() + File.separatorChar + newFileName);
                 if (!generatedFile.renameTo(newGeneratedFile)) {
-                    throw LOGGER.renamingFileFalied(generatedFile.getAbsolutePath(), newGeneratedFile.getAbsolutePath());
+                    throw LOGGER.renamingFileFailed(generatedFile.getAbsolutePath(), newGeneratedFile.getAbsolutePath());
                 }
             }
         }
     }
-}
+}
\ No newline at end of file

File: jakartaee9/src/main/java/io/undertow/jakartaee9/UndertowJakartaEE9Logger.java
Patch:
@@ -60,7 +60,7 @@ void transformationInfo (String servletDependencyGroupId, String servletDependen
     IllegalStateException inputFilesNotFoundInDir(String inputDir);
 
     @Message(id = 2, value = "Renaming of file %s to %s failed")
-    RuntimeException renamingFileFalied(String originalName, String newName);
+    RuntimeException renamingFileFailed(String originalName, String newName);
 
     @Message(id = 3, value = "Creation of output dir %s failed")
     RuntimeException cannotCreateOutputDir(String outputDir);

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -228,12 +228,15 @@ public final class HttpServerExchange extends AbstractAttachable {
      * The default value for this is determined by the {@link io.undertow.UndertowOptions#MAX_ENTITY_SIZE} option. A value
      * of 0 indicates that this is unbounded.
      * <p>
+     * In case of multipart handling, this will default to {@link io.undertow.UndertowOptions#MULTIPART_MAX_ENTITY_SIZE}
+     * <p>
      * If this entity size is exceeded the request channel will be forcibly closed.
      * <p>
      * TODO: integrate this with HTTP 100-continue responses, to make it possible to send a 417 rather than just forcibly
      * closing the channel.
      *
      * @see io.undertow.UndertowOptions#MAX_ENTITY_SIZE
+     * @see io.undertow.UndertowOptions#MULTIPART_MAX_ENTITY_SIZE
      */
     private long maxEntitySize;
 

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -228,12 +228,15 @@ public final class HttpServerExchange extends AbstractAttachable {
      * The default value for this is determined by the {@link io.undertow.UndertowOptions#MAX_ENTITY_SIZE} option. A value
      * of 0 indicates that this is unbounded.
      * <p>
+     * In case of multipart handling, this will default to {@link io.undertow.UndertowOptions#MULTIPART_MAX_ENTITY_SIZE}
+     * <p>
      * If this entity size is exceeded the request channel will be forcibly closed.
      * <p>
      * TODO: integrate this with HTTP 100-continue responses, to make it possible to send a 417 rather than just forcibly
      * closing the channel.
      *
      * @see io.undertow.UndertowOptions#MAX_ENTITY_SIZE
+     * @see io.undertow.UndertowOptions#MULTIPART_MAX_ENTITY_SIZE
      */
     private long maxEntitySize;
 

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -232,7 +232,9 @@ public Enumeration<String> getHeaderNames() {
     public HttpServletMapping getHttpServletMapping() {
         ServletRequestContext src = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY);
         ServletPathMatch match = src.getOriginalServletPathMatch();
-        if(getDispatcherType() == DispatcherType.FORWARD) {
+        final DispatcherType dispatcherType = getDispatcherType();
+        //UNDERTOW-1899 - ERROR is essentially forward operation
+        if(dispatcherType == DispatcherType.FORWARD || dispatcherType == DispatcherType.ERROR) {
             match = src.getServletPathMatch();
         }
         String matchValue;

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -232,7 +232,9 @@ public Enumeration<String> getHeaderNames() {
     public HttpServletMapping getHttpServletMapping() {
         ServletRequestContext src = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY);
         ServletPathMatch match = src.getOriginalServletPathMatch();
-        if(getDispatcherType() == DispatcherType.FORWARD) {
+        final DispatcherType dispatcherType = getDispatcherType();
+        //UNDERTOW-1899 - ERROR is essentially forward operation
+        if(dispatcherType == DispatcherType.FORWARD || dispatcherType == DispatcherType.ERROR) {
             match = src.getServletPathMatch();
         }
         String matchValue;

File: core/src/test/java/io/undertow/server/handlers/SetAttributeTestCase.java
Patch:
@@ -93,7 +93,7 @@ public void testRewrite() throws IOException {
             HttpResponse result = client.execute(get);
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
             String response = HttpClientUtils.readResponse(result);
-            Assert.assertEquals("URI: /relative/foo relative: /foo QS:?bar=a&woz=b bar: a woz: b", response);
+            Assert.assertEquals("URI: /relative/foo relative: /foo QS:bar=a&woz=b bar: a woz: b", response);
 
             get = new HttpGet(DefaultServer.getDefaultServerURL() + "/somePath/foo/a/b");
             result = client.execute(get);

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -391,7 +391,7 @@ public interface UndertowMessages {
     @Message(id = 117, value = "Request was not a CONNECT request")
     IllegalStateException notAConnectRequest();
 
-    @Message(id = 118, value = "Cannot reset buffer, response has already been commited")
+    @Message(id = 118, value = "Cannot reset buffer, response has already been committed")
     IllegalStateException cannotResetBuffer();
 
     @Message(id = 119, value = "HTTP2 via prior knowledge failed")

File: servlet/src/main/java/io/undertow/servlet/UndertowServletMessages.java
Patch:
@@ -101,8 +101,8 @@ public interface UndertowServletMessages {
     @Message(id = 10018, value = "Async not started")
     IllegalStateException asyncNotStarted();
 
-    @Message(id = 10019, value = "Response already commited")
-    IllegalStateException responseAlreadyCommited();
+    @Message(id = 10019, value = "Response already committed")
+    IllegalStateException responseAlreadyCommitted();
 
     @Message(id = 10020, value = "Content has been written")
     IllegalStateException contentHasBeenWritten();

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -460,7 +460,7 @@ public boolean isRequestedSessionIdFromUrl() {
     @Override
     public boolean authenticate(final HttpServletResponse response) throws IOException, ServletException {
         if (response.isCommitted()) {
-            throw UndertowServletMessages.MESSAGES.responseAlreadyCommited();
+            throw UndertowServletMessages.MESSAGES.responseAlreadyCommitted();
         }
 
         SecurityContext sc = exchange.getSecurityContext();

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -134,7 +134,7 @@ public void sendError(final int sc, final String msg) throws IOException {
             if(src.getErrorCode() > 0) {
                 return; //error already set
             }
-            throw UndertowServletMessages.MESSAGES.responseAlreadyCommited();
+            throw UndertowServletMessages.MESSAGES.responseAlreadyCommitted();
         }
         if(servletContext.getDeployment().getDeploymentInfo().isSendCustomReasonPhraseOnError()) {
             exchange.setReasonPhrase(msg);
@@ -187,7 +187,7 @@ public void sendError(final int sc) throws IOException {
     @Override
     public void sendRedirect(final String location) throws IOException {
         if (responseStarted()) {
-            throw UndertowServletMessages.MESSAGES.responseAlreadyCommited();
+            throw UndertowServletMessages.MESSAGES.responseAlreadyCommitted();
         }
         resetBuffer();
         setStatus(StatusCodes.FOUND);
@@ -791,7 +791,7 @@ public boolean isTreatAsCommitted() {
     @Override
     public void setTrailerFields(Supplier<Map<String, String>> supplier) {
         if(exchange.isResponseStarted()) {
-            throw UndertowServletMessages.MESSAGES.responseAlreadyCommited();
+            throw UndertowServletMessages.MESSAGES.responseAlreadyCommitted();
         }
         if(exchange.getProtocol() == Protocols.HTTP_1_0) {
             throw UndertowServletMessages.MESSAGES.trailersNotSupported("HTTP/1.0 request");

File: servlet/src/main/java/io/undertow/servlet/spec/ServletOutputStreamImpl.java
Patch:
@@ -736,7 +736,7 @@ public void resetBuffer() {
             buffer = null;
             this.written = 0;
         } else {
-            throw UndertowServletMessages.MESSAGES.responseAlreadyCommited();
+            throw UndertowServletMessages.MESSAGES.responseAlreadyCommitted();
         }
     }
 

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/SessionContainer.java
Patch:
@@ -65,10 +65,10 @@ public void awaitClose(long timeout) {
                 return;
             }
             waiterCount++;
-            long end = System.currentTimeMillis() + timeout;
+            long cur,end = System.currentTimeMillis() + timeout;
             try {
-                while (System.currentTimeMillis() < end && !openSessions.isEmpty()) {
-                    wait(end - System.currentTimeMillis());
+                while ((cur=System.currentTimeMillis()) < end && !openSessions.isEmpty()) {
+                    wait(end - cur);
                 }
             } catch (InterruptedException e) {
                 //ignore

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/SessionContainer.java
Patch:
@@ -65,10 +65,10 @@ public void awaitClose(long timeout) {
                 return;
             }
             waiterCount++;
-            long end = System.currentTimeMillis() + timeout;
+            long cur,end = System.currentTimeMillis() + timeout;
             try {
-                while (System.currentTimeMillis() < end && !openSessions.isEmpty()) {
-                    wait(end - System.currentTimeMillis());
+                while ((cur=System.currentTimeMillis()) < end && !openSessions.isEmpty()) {
+                    wait(end - cur);
                 }
             } catch (InterruptedException e) {
                 //ignore

File: core/src/main/java/io/undertow/server/protocol/http/ALPNLimitingSSLEngine.java
Patch:
@@ -31,7 +31,7 @@
 /**
  * SSLEngine that will limit the cipher selection to HTTP/2 suitable protocols if the client is offering h2 as an option.
  * <p>
- * In theory this is not a perfect solution to the HTTP/2 cipher strength issue, but in practice it should be sufficent
+ * In theory this is not a perfect solution to the HTTP/2 cipher strength issue, but in practice it should be sufficient
  * as any RFC compliant implementation should be able to negotiate TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/server/protocol/http/ALPNLimitingSSLEngine.java
Patch:
@@ -31,7 +31,7 @@
 /**
  * SSLEngine that will limit the cipher selection to HTTP/2 suitable protocols if the client is offering h2 as an option.
  * <p>
- * In theory this is not a perfect solution to the HTTP/2 cipher strength issue, but in practice it should be sufficent
+ * In theory this is not a perfect solution to the HTTP/2 cipher strength issue, but in practice it should be sufficient
  * as any RFC compliant implementation should be able to negotiate TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
  *
  * @author Stuart Douglas

File: servlet/src/main/java/io/undertow/servlet/spec/AsyncContextImpl.java
Patch:
@@ -61,7 +61,6 @@
 import io.undertow.servlet.handlers.ServletDebugPageHandler;
 import io.undertow.servlet.handlers.ServletPathMatch;
 import io.undertow.servlet.handlers.ServletRequestContext;
-import io.undertow.util.CanonicalPathUtils;
 import io.undertow.util.Headers;
 import io.undertow.util.SameThreadExecutor;
 import io.undertow.util.StatusCodes;
@@ -179,7 +178,8 @@ public void dispatch() {
                 //this should never happen
                 throw UndertowServletMessages.MESSAGES.couldNotFindContextToDispatchTo(requestImpl.getOriginalContextPath());
             }
-            String toDispatch = CanonicalPathUtils.canonicalize(requestImpl.getOriginalRequestURI()).substring(requestImpl.getOriginalContextPath().length());
+            //UNDERTOW-1591 use original, decoded value to dispatch, this should match: ServletInitialHandler.handleRequest
+            String toDispatch = requestImpl.getExchange().getRelativePath();
             String qs = requestImpl.getOriginalQueryString();
             if (qs != null && !qs.isEmpty()) {
                 toDispatch = toDispatch + "?" + qs;

File: servlet/src/main/java/io/undertow/servlet/spec/AsyncContextImpl.java
Patch:
@@ -61,7 +61,6 @@
 import io.undertow.servlet.handlers.ServletDebugPageHandler;
 import io.undertow.servlet.handlers.ServletPathMatch;
 import io.undertow.servlet.handlers.ServletRequestContext;
-import io.undertow.util.CanonicalPathUtils;
 import io.undertow.util.Headers;
 import io.undertow.util.SameThreadExecutor;
 import io.undertow.util.StatusCodes;
@@ -179,7 +178,8 @@ public void dispatch() {
                 //this should never happen
                 throw UndertowServletMessages.MESSAGES.couldNotFindContextToDispatchTo(requestImpl.getOriginalContextPath());
             }
-            String toDispatch = CanonicalPathUtils.canonicalize(requestImpl.getOriginalRequestURI()).substring(requestImpl.getOriginalContextPath().length());
+            //UNDERTOW-1591 use original, decoded value to dispatch, this should match: ServletInitialHandler.handleRequest
+            String toDispatch = requestImpl.getExchange().getRelativePath();
             String qs = requestImpl.getOriginalQueryString();
             if (qs != null && !qs.isEmpty()) {
                 toDispatch = toDispatch + "?" + qs;

File: core/src/main/java/io/undertow/util/PathTemplateMatcher.java
Patch:
@@ -51,6 +51,8 @@ public class PathTemplateMatcher<T> {
 
     public PathMatchResult<T> match(final String path) {
         String normalizedPath = "".equals(path) ? "/" : path;
+        if(!normalizedPath.startsWith("/"))
+            normalizedPath = "/"+ normalizedPath;
         final Map<String, String> params = new LinkedHashMap<>();
         int length = normalizedPath.length();
         final int[] lengths = this.lengths;

File: servlet/src/main/java/io/undertow/servlet/api/ServletSessionConfig.java
Patch:
@@ -39,7 +39,7 @@ public class ServletSessionConfig {
     private String domain;
     private boolean secure;
     private boolean httpOnly;
-    private int maxAge;
+    private int maxAge = -1;
     private String comment;
 
     public String getName() {

File: servlet/src/main/java/io/undertow/servlet/api/ServletSessionConfig.java
Patch:
@@ -39,7 +39,7 @@ public class ServletSessionConfig {
     private String domain;
     private boolean secure;
     private boolean httpOnly;
-    private int maxAge;
+    private int maxAge = -1;
     private String comment;
 
     public String getName() {

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -357,7 +357,7 @@ private static Statement createClassStatement(final TestClass testClass, final R
             stopServer();
             statement = new RunBefores(statement, beforeServerStarts, null);
         }
-        final List<FrameworkMethod> afterServerStops = testClass.getAnnotatedMethods(BeforeServerStarts.class);
+        final List<FrameworkMethod> afterServerStops = testClass.getAnnotatedMethods(AfterServerStops.class);
         if (!afterServerStops.isEmpty()) {
             defaultServerStatement.stopTheServerWhenDone();
             statement = new RunAfters(statement, afterServerStops, null);

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -357,7 +357,7 @@ private static Statement createClassStatement(final TestClass testClass, final R
             stopServer();
             statement = new RunBefores(statement, beforeServerStarts, null);
         }
-        final List<FrameworkMethod> afterServerStops = testClass.getAnnotatedMethods(BeforeServerStarts.class);
+        final List<FrameworkMethod> afterServerStops = testClass.getAnnotatedMethods(AfterServerStops.class);
         if (!afterServerStops.isEmpty()) {
             defaultServerStatement.stopTheServerWhenDone();
             statement = new RunAfters(statement, afterServerStops, null);

File: core/src/test/java/io/undertow/server/handlers/SameSiteCookieHandlerTestCase.java
Patch:
@@ -36,7 +36,9 @@
 import io.undertow.testutils.TestHttpClient;
 import io.undertow.util.FileUtils;
 import io.undertow.util.StatusCodes;
+import org.junit.runner.RunWith;
 
+@RunWith(DefaultServer.class)
 public class SameSiteCookieHandlerTestCase {
 
     @Test

File: core/src/test/java/io/undertow/server/handlers/SameSiteCookieHandlerTestCase.java
Patch:
@@ -36,7 +36,9 @@
 import io.undertow.testutils.TestHttpClient;
 import io.undertow.util.FileUtils;
 import io.undertow.util.StatusCodes;
+import org.junit.runner.RunWith;
 
+@RunWith(DefaultServer.class)
 public class SameSiteCookieHandlerTestCase {
 
     @Test

File: core/src/main/java/io/undertow/server/handlers/PathHandler.java
Patch:
@@ -108,7 +108,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
      * Adds a path prefix and a handler for that path. If the path does not start
      * with a / then one will be prepended.
      * <p>
-     * The match is done on a prefix bases, so registering /foo will also match /bar. Exact
+     * The match is done on a prefix bases, so registering /foo will also match /foo/bar. Exact
      * path matches are taken into account first.
      * <p>
      * If / is specified as the path then it will replace the default handler.
@@ -129,7 +129,7 @@ public synchronized PathHandler addPath(final String path, final HttpHandler han
      * <p>
      * The match is done on a prefix bases, so registering /foo will also match /foo/bar.
      * Though exact path matches are taken into account before prefix path matches. So
-     * if an exact path match exists it's  handler will be triggered.
+     * if an exact path match exists its handler will be triggered.
      * <p>
      * If / is specified as the path then it will replace the default handler.
      *

File: core/src/main/java/io/undertow/util/PathMatcher.java
Patch:
@@ -112,7 +112,7 @@ public PathMatch<T> match(String path){
      * Adds a path prefix and a handler for that path. If the path does not start
      * with a / then one will be prepended.
      * <p>
-     * The match is done on a prefix bases, so registering /foo will also match /bar. Exact
+     * The match is done on a prefix bases, so registering /foo will also match /foo/bar. Exact
      * path matches are taken into account first.
      * <p>
      * If / is specified as the path then it will replace the default handler.

File: core/src/main/java/io/undertow/server/handlers/PathHandler.java
Patch:
@@ -108,7 +108,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
      * Adds a path prefix and a handler for that path. If the path does not start
      * with a / then one will be prepended.
      * <p>
-     * The match is done on a prefix bases, so registering /foo will also match /bar. Exact
+     * The match is done on a prefix bases, so registering /foo will also match /foo/bar. Exact
      * path matches are taken into account first.
      * <p>
      * If / is specified as the path then it will replace the default handler.
@@ -129,7 +129,7 @@ public synchronized PathHandler addPath(final String path, final HttpHandler han
      * <p>
      * The match is done on a prefix bases, so registering /foo will also match /foo/bar.
      * Though exact path matches are taken into account before prefix path matches. So
-     * if an exact path match exists it's  handler will be triggered.
+     * if an exact path match exists its handler will be triggered.
      * <p>
      * If / is specified as the path then it will replace the default handler.
      *

File: core/src/main/java/io/undertow/util/PathMatcher.java
Patch:
@@ -112,7 +112,7 @@ public PathMatch<T> match(String path){
      * Adds a path prefix and a handler for that path. If the path does not start
      * with a / then one will be prepended.
      * <p>
-     * The match is done on a prefix bases, so registering /foo will also match /bar. Exact
+     * The match is done on a prefix bases, so registering /foo will also match /foo/bar. Exact
      * path matches are taken into account first.
      * <p>
      * If / is specified as the path then it will replace the default handler.

File: core/src/main/java/io/undertow/protocols/ssl/UndertowAcceptingSslChannel.java
Patch:
@@ -208,7 +208,7 @@ public UndertowSslConnection accept() throws IOException {
     }
 
     protected UndertowSslConnection accept(StreamConnection tcpServer, SSLEngine sslEngine) throws IOException {
-        return new UndertowSslConnection(tcpServer, sslEngine, applicationBufferPool);
+        return new UndertowSslConnection(tcpServer, sslEngine, applicationBufferPool, ssl.getDelegatedTaskExecutor());
     }
 
     public ChannelListener.Setter<? extends AcceptingChannel<SslConnection>> getCloseSetter() {

File: core/src/main/java/io/undertow/protocols/ssl/UndertowSslConnection.java
Patch:
@@ -32,6 +32,7 @@
 import java.io.IOException;
 import java.net.SocketAddress;
 import java.util.Set;
+import java.util.concurrent.Executor;
 
 /**
  * @author Stuart Douglas
@@ -50,11 +51,11 @@ class UndertowSslConnection extends SslConnection {
      *
      * @param delegate the underlying connection
      */
-    UndertowSslConnection(StreamConnection delegate, SSLEngine engine, ByteBufferPool bufferPool) {
+    UndertowSslConnection(StreamConnection delegate, SSLEngine engine, ByteBufferPool bufferPool, Executor delegatedTaskExecutor) {
         super(delegate.getIoThread());
         this.delegate = delegate;
         this.engine = engine;
-        sslConduit = new SslConduit(this, delegate, engine, bufferPool, new HandshakeCallback());
+        sslConduit = new SslConduit(this, delegate, engine, delegatedTaskExecutor, bufferPool, new HandshakeCallback());
         setSourceConduit(sslConduit);
         setSinkConduit(sslConduit);
     }

File: core/src/main/java/io/undertow/attribute/SslSessionIdAttribute.java
Patch:
@@ -20,7 +20,7 @@
 
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.SSLSessionInfo;
-import io.undertow.util.FlexBase64;
+import io.undertow.util.HexConverter;
 
 /**
  * @author Stuart Douglas
@@ -35,7 +35,7 @@ public String readAttribute(HttpServerExchange exchange) {
         if(ssl == null || ssl.getSessionId() == null) {
             return null;
         }
-        return FlexBase64.encodeString(ssl.getSessionId(), false);
+        return HexConverter.convertToHexString(ssl.getSessionId());
     }
 
     @Override

File: core/src/main/java/io/undertow/protocols/ajp/AjpClientRequestClientStreamSinkChannel.java
Patch:
@@ -42,9 +42,9 @@
 import io.undertow.connector.PooledByteBuffer;
 import io.undertow.server.protocol.framed.SendFrameHeader;
 import io.undertow.util.Attachable;
-import io.undertow.util.FlexBase64;
 import io.undertow.util.HeaderMap;
 import io.undertow.util.Headers;
+import io.undertow.util.HexConverter;
 import io.undertow.util.HttpString;
 import io.undertow.util.ImmediatePooledByteBuffer;
 
@@ -209,7 +209,7 @@ private SendFrameHeader createFrameHeaderImpl() {
                 byte[] sslSession = attachable.getAttachment(ProxiedRequestAttachments.SSL_SESSION_ID);
                 if (sslSession != null) {
                     buffer.put((byte) ATTR_SSL_SESSION);
-                    putString(buffer, FlexBase64.encodeString(sslSession, false));
+                    putString(buffer, HexConverter.convertToHexString(sslSession));
                 }
                 Integer sslKeySize = attachable.getAttachment(ProxiedRequestAttachments.SSL_KEY_SIZE);
                 if (sslKeySize != null) {

File: core/src/main/java/io/undertow/server/handlers/proxy/ProxyHandler.java
Patch:
@@ -557,6 +557,7 @@ public void run() {
                 }
                 request.putAttachment(ProxiedRequestAttachments.SSL_CYPHER, sslSessionInfo.getCipherSuite());
                 request.putAttachment(ProxiedRequestAttachments.SSL_SESSION_ID, sslSessionInfo.getSessionId());
+                request.putAttachment(ProxiedRequestAttachments.SSL_KEY_SIZE, sslSessionInfo.getKeySize());
             }
 
             if(rewriteHostHeader) {

File: servlet/src/test/java/io/undertow/servlet/test/security/ssl/SSLAttributesServlet.java
Patch:
@@ -49,6 +49,9 @@ protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws Se
             if (attribute!=null){
                 pw.write(attribute[0].getSerialNumber().toString());
             }
+        } else if (req.getServletPath().equals("/cert-dn")) {
+            final X509Certificate[] attribute = (X509Certificate[]) req.getAttribute("javax.servlet.request.X509Certificate");
+            pw.write(attribute != null && attribute.length > 0? attribute[0].getSubjectDN().toString() : "null");
         }
         pw.close();
     }

File: core/src/main/java/io/undertow/attribute/SslSessionIdAttribute.java
Patch:
@@ -20,7 +20,7 @@
 
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.SSLSessionInfo;
-import io.undertow.util.FlexBase64;
+import io.undertow.util.HexConverter;
 
 /**
  * @author Stuart Douglas
@@ -35,7 +35,7 @@ public String readAttribute(HttpServerExchange exchange) {
         if(ssl == null || ssl.getSessionId() == null) {
             return null;
         }
-        return FlexBase64.encodeString(ssl.getSessionId(), false);
+        return HexConverter.convertToHexString(ssl.getSessionId());
     }
 
     @Override

File: core/src/main/java/io/undertow/protocols/ajp/AjpClientRequestClientStreamSinkChannel.java
Patch:
@@ -42,9 +42,9 @@
 import io.undertow.connector.PooledByteBuffer;
 import io.undertow.server.protocol.framed.SendFrameHeader;
 import io.undertow.util.Attachable;
-import io.undertow.util.FlexBase64;
 import io.undertow.util.HeaderMap;
 import io.undertow.util.Headers;
+import io.undertow.util.HexConverter;
 import io.undertow.util.HttpString;
 import io.undertow.util.ImmediatePooledByteBuffer;
 
@@ -209,7 +209,7 @@ private SendFrameHeader createFrameHeaderImpl() {
                 byte[] sslSession = attachable.getAttachment(ProxiedRequestAttachments.SSL_SESSION_ID);
                 if (sslSession != null) {
                     buffer.put((byte) ATTR_SSL_SESSION);
-                    putString(buffer, FlexBase64.encodeString(sslSession, false));
+                    putString(buffer, HexConverter.convertToHexString(sslSession));
                 }
                 Integer sslKeySize = attachable.getAttachment(ProxiedRequestAttachments.SSL_KEY_SIZE);
                 if (sslKeySize != null) {

File: core/src/main/java/io/undertow/server/handlers/proxy/ProxyHandler.java
Patch:
@@ -557,6 +557,7 @@ public void run() {
                 }
                 request.putAttachment(ProxiedRequestAttachments.SSL_CYPHER, sslSessionInfo.getCipherSuite());
                 request.putAttachment(ProxiedRequestAttachments.SSL_SESSION_ID, sslSessionInfo.getSessionId());
+                request.putAttachment(ProxiedRequestAttachments.SSL_KEY_SIZE, sslSessionInfo.getKeySize());
             }
 
             if(rewriteHostHeader) {

File: servlet/src/test/java/io/undertow/servlet/test/security/ssl/SSLAttributesServlet.java
Patch:
@@ -49,6 +49,9 @@ protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws Se
             if (attribute!=null){
                 pw.write(attribute[0].getSerialNumber().toString());
             }
+        } else if (req.getServletPath().equals("/cert-dn")) {
+            final X509Certificate[] attribute = (X509Certificate[]) req.getAttribute("javax.servlet.request.X509Certificate");
+            pw.write(attribute != null && attribute.length > 0? attribute[0].getSubjectDN().toString() : "null");
         }
         pw.close();
     }

File: servlet/src/test/java/io/undertow/servlet/test/security/form/SaveOriginalPostRequestTestCase.java
Patch:
@@ -122,7 +122,8 @@ public void testParametersFromOriginalPostRequest() throws IOException {
         HttpResponse result = executePostRequest(client, "/servletContext/dumpRequest", new BasicNameValuePair("param1", "param1Value"), new BasicNameValuePair("param2", "param2Value"));
         assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
         String response = HttpClientUtils.readResponse(result);
-        assertTrue(response.contains("param1=param1Value/param2=param2Value"));
+        assertTrue(response.contains("param1=param1Value"));
+        assertTrue(response.contains("param2=param2Value"));
 
         // this request should be saved and the client redirect to the login form.
         result = executePostRequest(client, "/servletContext/secured/dumpRequest", new BasicNameValuePair("securedParam1", "securedParam1Value"), new BasicNameValuePair("securedParam2", "securedParam2Value"));

File: servlet/src/test/java/io/undertow/servlet/test/errorpage/ErrorPageTestCase.java
Patch:
@@ -239,8 +239,8 @@ private void runTest(int deploymentNo, final TestHttpClient client, Integer stat
                     // RequestDispatcher.ERROR_MESSAGE is null
                     Assert.assertThat(response, CoreMatchers.containsString(RequestDispatcher.ERROR_STATUS_CODE + "=500"));
                 } else {
-                    Assert.assertThat(response, CoreMatchers.containsString(RequestDispatcher.ERROR_EXCEPTION_TYPE + "=" + ServletException.class));
-                    Assert.assertThat(response, CoreMatchers.containsString(RequestDispatcher.ERROR_EXCEPTION + "=javax.servlet.ServletException: " + exception.getName()));
+                    Assert.assertThat(response, CoreMatchers.containsString(RequestDispatcher.ERROR_EXCEPTION_TYPE + "=" + exception));
+                    Assert.assertThat(response, CoreMatchers.containsString(RequestDispatcher.ERROR_EXCEPTION + "=" + exception.getName()));
                     Assert.assertThat(response, CoreMatchers.containsString(RequestDispatcher.ERROR_MESSAGE + "=" + exception.getName()));
                     Assert.assertThat(response, CoreMatchers.containsString(RequestDispatcher.ERROR_STATUS_CODE + "=500"));
                 }

File: servlet/src/test/java/io/undertow/servlet/test/errorpage/ErrorPageTestCase.java
Patch:
@@ -239,8 +239,8 @@ private void runTest(int deploymentNo, final TestHttpClient client, Integer stat
                     // RequestDispatcher.ERROR_MESSAGE is null
                     Assert.assertThat(response, CoreMatchers.containsString(RequestDispatcher.ERROR_STATUS_CODE + "=500"));
                 } else {
-                    Assert.assertThat(response, CoreMatchers.containsString(RequestDispatcher.ERROR_EXCEPTION_TYPE + "=" + ServletException.class));
-                    Assert.assertThat(response, CoreMatchers.containsString(RequestDispatcher.ERROR_EXCEPTION + "=javax.servlet.ServletException: " + exception.getName()));
+                    Assert.assertThat(response, CoreMatchers.containsString(RequestDispatcher.ERROR_EXCEPTION_TYPE + "=" + exception));
+                    Assert.assertThat(response, CoreMatchers.containsString(RequestDispatcher.ERROR_EXCEPTION + "=" + exception.getName()));
                     Assert.assertThat(response, CoreMatchers.containsString(RequestDispatcher.ERROR_MESSAGE + "=" + exception.getName()));
                     Assert.assertThat(response, CoreMatchers.containsString(RequestDispatcher.ERROR_STATUS_CODE + "=500"));
                 }

File: servlet/src/test/java/io/undertow/servlet/test/security/form/SaveOriginalPostRequestTestCase.java
Patch:
@@ -122,7 +122,8 @@ public void testParametersFromOriginalPostRequest() throws IOException {
         HttpResponse result = executePostRequest(client, "/servletContext/dumpRequest", new BasicNameValuePair("param1", "param1Value"), new BasicNameValuePair("param2", "param2Value"));
         assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
         String response = HttpClientUtils.readResponse(result);
-        assertTrue(response.contains("param1=param1Value/param2=param2Value"));
+        assertTrue(response.contains("param1=param1Value"));
+        assertTrue(response.contains("param2=param2Value"));
 
         // this request should be saved and the client redirect to the login form.
         result = executePostRequest(client, "/servletContext/secured/dumpRequest", new BasicNameValuePair("securedParam1", "securedParam1Value"), new BasicNameValuePair("securedParam2", "securedParam2Value"));

File: core/src/main/java/io/undertow/protocols/alpn/JDK8HackAlpnProvider.java
Patch:
@@ -50,7 +50,7 @@ public String getSelectedProtocol(SSLEngine engine) {
 
     @Override
     public int getPriority() {
-        return 200;
+        return 300;
     }
 
     @Override

File: core/src/main/java/io/undertow/protocols/alpn/JDK8HackAlpnProvider.java
Patch:
@@ -50,7 +50,7 @@ public String getSelectedProtocol(SSLEngine engine) {
 
     @Override
     public int getPriority() {
-        return 200;
+        return 300;
     }
 
     @Override

File: core/src/main/java/io/undertow/protocols/alpn/JDK9AlpnProvider.java
Patch:
@@ -127,7 +127,7 @@ public String getSelectedProtocol(SSLEngine engine) {
 
     @Override
     public int getPriority() {
-        return 300;
+        return 200;
     }
 
     @Override

File: servlet/src/main/java/io/undertow/servlet/attribute/ServletRequestURLAttribute.java
Patch:
@@ -49,11 +49,11 @@ public String readAttribute(final HttpServerExchange exchange) {
         if (src == null) {
             return RequestURLAttribute.INSTANCE.readAttribute(exchange);
         }
-        String uri = (String) src.getServletRequest().getAttribute(RequestDispatcher.ERROR_REQUEST_URI);
+        String uri = (String) src.getServletRequest().getAttribute(RequestDispatcher.FORWARD_REQUEST_URI);
         if (uri != null) {
             return uri;
         }
-        uri = (String) src.getServletRequest().getAttribute(RequestDispatcher.FORWARD_REQUEST_URI);
+        uri = (String) src.getServletRequest().getAttribute(RequestDispatcher.ERROR_REQUEST_URI);
         if (uri != null) {
             return uri;
         }

File: servlet/src/main/java/io/undertow/servlet/attribute/ServletRequestURLAttribute.java
Patch:
@@ -49,11 +49,11 @@ public String readAttribute(final HttpServerExchange exchange) {
         if (src == null) {
             return RequestURLAttribute.INSTANCE.readAttribute(exchange);
         }
-        String uri = (String) src.getServletRequest().getAttribute(RequestDispatcher.ERROR_REQUEST_URI);
+        String uri = (String) src.getServletRequest().getAttribute(RequestDispatcher.FORWARD_REQUEST_URI);
         if (uri != null) {
             return uri;
         }
-        uri = (String) src.getServletRequest().getAttribute(RequestDispatcher.FORWARD_REQUEST_URI);
+        uri = (String) src.getServletRequest().getAttribute(RequestDispatcher.ERROR_REQUEST_URI);
         if (uri != null) {
             return uri;
         }

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -72,6 +72,7 @@
 import io.undertow.servlet.api.WebResourceCollection;
 import io.undertow.servlet.handlers.CrawlerSessionManagerHandler;
 import io.undertow.servlet.handlers.RedirectDirHandler;
+import io.undertow.servlet.handlers.SendErrorPageHandler;
 import io.undertow.servlet.handlers.ServletDispatchingHandler;
 import io.undertow.servlet.handlers.ServletHandler;
 import io.undertow.servlet.handlers.ServletInitialHandler;
@@ -226,6 +227,7 @@ public Void call(HttpServerExchange exchange, Object ignore) throws Exception {
                         wrappedHandlers = new PredicateHandler(DispatcherTypePredicate.REQUEST, securityHandler, wrappedHandlers);
                     }
                     HttpHandler outerHandlers = wrapHandlers(wrappedHandlers, deploymentInfo.getOuterHandlerChainWrappers());
+                    outerHandlers = new SendErrorPageHandler(outerHandlers);
                     wrappedHandlers = new PredicateHandler(DispatcherTypePredicate.REQUEST, outerHandlers, wrappedHandlers);
                     wrappedHandlers = handleDevelopmentModePersistentSessions(wrappedHandlers, deploymentInfo, deployment.getSessionManager(), servletContext);
 

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -72,6 +72,7 @@
 import io.undertow.servlet.api.WebResourceCollection;
 import io.undertow.servlet.handlers.CrawlerSessionManagerHandler;
 import io.undertow.servlet.handlers.RedirectDirHandler;
+import io.undertow.servlet.handlers.SendErrorPageHandler;
 import io.undertow.servlet.handlers.ServletDispatchingHandler;
 import io.undertow.servlet.handlers.ServletHandler;
 import io.undertow.servlet.handlers.ServletInitialHandler;
@@ -226,6 +227,7 @@ public Void call(HttpServerExchange exchange, Object ignore) throws Exception {
                         wrappedHandlers = new PredicateHandler(DispatcherTypePredicate.REQUEST, securityHandler, wrappedHandlers);
                     }
                     HttpHandler outerHandlers = wrapHandlers(wrappedHandlers, deploymentInfo.getOuterHandlerChainWrappers());
+                    outerHandlers = new SendErrorPageHandler(outerHandlers);
                     wrappedHandlers = new PredicateHandler(DispatcherTypePredicate.REQUEST, outerHandlers, wrappedHandlers);
                     wrappedHandlers = handleDevelopmentModePersistentSessions(wrappedHandlers, deploymentInfo, deployment.getSessionManager(), servletContext);
 

File: core/src/main/java/io/undertow/util/HttpString.java
Patch:
@@ -343,7 +343,7 @@ private static boolean bytesAreEquivalent(final byte[] a, final byte[] b) {
     @SuppressWarnings("deprecation")
     public String toString() {
         if (string == null) {
-            string = new String(bytes, 0);
+            string = new String(bytes, java.nio.charset.StandardCharsets.US_ASCII);
         }
         return string;
     }

File: core/src/main/java/io/undertow/attribute/DateTimeAttribute.java
Patch:
@@ -80,7 +80,9 @@ public void writeAttribute(final HttpServerExchange exchange, final String newVa
 
     @Override
     public String toString() {
-        return DATE_TIME;
+        if (dateFormat == null)
+            return DATE_TIME;
+        return CUSTOM_TIME + dateFormat + "}";
     }
 
     public static final class Builder implements ExchangeAttributeBuilder {

File: core/src/test/java/io/undertow/server/handlers/SecureCookieHandlerTestCase.java
Patch:
@@ -48,7 +48,7 @@ public void testSecureCookieHandler() throws IOException, GeneralSecurityExcepti
         DefaultServer.setRootHandler(new SecureCookieHandler(new HttpHandler() {
             @Override
             public void handleRequest(final HttpServerExchange exchange) throws Exception {
-                exchange.getResponseCookies().put("foo", new CookieImpl("foo", "bar"));
+                exchange.setResponseCookie(new CookieImpl("foo", "bar"));
             }
         }));
 

File: core/src/test/java/io/undertow/server/protocol/proxy/ProxyProtocolTestCase.java
Patch:
@@ -41,8 +41,8 @@ public class ProxyProtocolTestCase {
         @Override
         public void handleRequest(HttpServerExchange exchange) throws Exception {
             exchange.setPersistent(false);
-            exchange.getResponseHeaders().put(new HttpString("result"), exchange.getSourceAddress().toString()
-                    + " " + exchange.getDestinationAddress().toString());
+            exchange.getResponseHeaders().put(new HttpString("result"), exchange.getSourceAddress().toString().replace("[","").replace("]","")
+                    + " " + exchange.getDestinationAddress().toString().replace("[","").replace("]",""));
         }
     }).build();
 

File: core/src/test/java/io/undertow/server/handlers/file/PathResourceManagerTestCase.java
Patch:
@@ -133,7 +133,7 @@ public void testNonDefaultFileSystem() throws Exception {
                 zos.closeEntry();
             }
 
-            try (FileSystem zipFileSystem = FileSystems.newFileSystem(zipFile, null)) {
+            try (FileSystem zipFileSystem = FileSystems.newFileSystem(zipFile, getClass().getClassLoader())) {
 
                 PathResourceManager resourceManager = new PathResourceManager(zipFileSystem.getPath("/dir"));
 

File: core/src/main/java/io/undertow/client/http/HttpClientConnection.java
Patch:
@@ -594,6 +594,7 @@ public void handleEvent(StreamSourceChannel channel) {
                     if (buffer.hasRemaining()) {
                         free = false;
                         pushBackStreamSourceConduit.pushBack(new PooledAdaptor(pooled));
+                        pushBackStreamSourceConduit.wakeupReads();
                     }
 
                 } while (!state.isComplete());

File: core/src/test/java/io/undertow/server/handlers/file/PathResourceManagerTestCase.java
Patch:
@@ -154,7 +154,7 @@ public void testNonDefaultFileSystem() throws Exception {
                 Assert.assertTrue(dir.isDirectory());
                 List<Resource> list = dir.list();
                 Assert.assertEquals(1, list.size());
-                Assert.assertEquals(resource.getFilePath(), list.get(0).getFilePath());
+                Assert.assertEquals(resource.getFilePath().normalize(), list.get(0).getFilePath().normalize());
 
                 Resource outside = resourceManager.getResource("../root_resource.txt");
                 Assert.assertNull(outside);

File: core/src/main/java/io/undertow/UndertowLogger.java
Patch:
@@ -393,7 +393,7 @@ void nodeConfigCreated(URI connectionURI, String balancer, String domain, String
     @Message(id = 5084, value = "Attempted to write %s bytes however content-length has been set to %s")
     IOException dataLargerThanContentLength(long totalToWrite, long responseContentLength);
 
-    @LogMessage(level = ERROR)
+    @LogMessage(level = DEBUG)
     @Message(id = 5085, value = "Connection %s for exchange %s was not closed cleanly, forcibly closing connection")
     void responseWasNotTerminated(ServerConnection connection, HttpServerExchange exchange);
 

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -155,7 +155,7 @@ public final class HttpServerExchange extends AbstractAttachable {
     // mutable state
 
     private int state = 200;
-    private HttpString requestMethod;
+    private HttpString requestMethod = HttpString.EMPTY;
     private String requestScheme;
 
     /**

File: core/src/main/java/io/undertow/server/protocol/http/HttpContinue.java
Patch:
@@ -91,6 +91,9 @@ public static boolean requiresContinueResponse(HeaderMap requestHeaders) {
         return false;
     }
 
+    public static boolean isContinueResponseSent(HttpServerExchange exchange) {
+        return exchange.getAttachment(ALREADY_SENT) != null;
+    }
 
     /**
      * Sends a continuation using async IO, and calls back when it is complete.

File: core/src/main/java/io/undertow/server/protocol/http/HttpContinue.java
Patch:
@@ -91,6 +91,9 @@ public static boolean requiresContinueResponse(HeaderMap requestHeaders) {
         return false;
     }
 
+    public static boolean isContinueResponseSent(HttpServerExchange exchange) {
+        return exchange.getAttachment(ALREADY_SENT) != null;
+    }
 
     /**
      * Sends a continuation using async IO, and calls back when it is complete.

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -605,6 +605,9 @@ public interface UndertowMessages {
     @Message(id = 194, value = "Character decoding failed. Parameter with name [%s] has been ignored. Note: further occurrences of Parameter errors will be logged at DEBUG level.")
     String failedToDecodeParameterName(String parameter, @Cause Exception e);
 
+    @Message(id = 195, value = "Chunk size too large")
+    IOException chunkSizeTooLarge();
+
     @Message(id = 196, value = "Session with id %s already exists")
     IllegalStateException sessionWithIdAlreadyExists(String sessionID);
 }

File: core/src/main/java/io/undertow/server/handlers/SameSiteCookieHandler.java
Patch:
@@ -74,8 +74,9 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
             exchange.addResponseCommitListener(new ResponseCommitListener() {
                 @Override
                 public void beforeCommit(HttpServerExchange exchange) {
-                    // Check user-agents and skip sending "SameSite=None" for incompatible user-agents
-                    if (enableClientChecker && !SameSiteNoneIncompatibleClientChecker.shouldSendSameSiteNone(exchange.getRequestHeaders().getFirst(Headers.USER_AGENT))) {
+                    // If user-agent is available check it and skip sending "SameSite=None" for incompatible user-agents
+                    String userAgent = exchange.getRequestHeaders().getFirst(Headers.USER_AGENT);
+                    if (enableClientChecker && userAgent != null && !SameSiteNoneIncompatibleClientChecker.shouldSendSameSiteNone(userAgent)) {
                         return;
                     }
                     for (Map.Entry<String, Cookie> cookie : exchange.getResponseCookies().entrySet()) {

File: core/src/test/java/io/undertow/server/HttpServerExchangeTestCase.java
Patch:
@@ -65,11 +65,11 @@ public void testHttpServerExchange() throws IOException {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/somepath");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
-            Assert.assertEquals("localhost:" + protocol + ":GET:" + port + ":/somepath:/somepath:", HttpClientUtils.readResponse(result));
+            Assert.assertEquals(DefaultServer.getHostAddress() + ":" + protocol + ":GET:" + port + ":/somepath:/somepath:", HttpClientUtils.readResponse(result));
             get = new HttpGet(DefaultServer.getDefaultServerURL() + "/somepath?a=b");
             result = client.execute(get);
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
-            Assert.assertEquals("localhost:" + protocol + ":GET:" + port + ":/somepath:/somepath:a=b", HttpClientUtils.readResponse(result));
+            Assert.assertEquals(DefaultServer.getHostAddress() + ":" + protocol + ":GET:" + port + ":/somepath:/somepath:a=b", HttpClientUtils.readResponse(result));
             get = new HttpGet(DefaultServer.getDefaultServerURL() + "/somepath?a=b");
             get.addHeader("Host", "[::1]:8080");
             result = client.execute(get);

File: servlet/src/test/java/io/undertow/servlet/test/request/HttpHostValuesTestCase.java
Patch:
@@ -22,7 +22,6 @@
 import io.undertow.servlet.api.DeploymentInfo;
 import io.undertow.servlet.api.DeploymentManager;
 import io.undertow.servlet.api.ServletContainer;
-import io.undertow.servlet.test.SimpleServletTestCase;
 import io.undertow.servlet.test.util.TestClassIntrospector;
 import io.undertow.testutils.DefaultServer;
 import io.undertow.testutils.HttpClientUtils;
@@ -48,13 +47,13 @@
 public class HttpHostValuesTestCase {
 
     @BeforeClass
-    public static void setup() throws ServletException {
+    public static void setup() {
 
 
         final PathHandler pathHandler = new PathHandler();
         final ServletContainer container = ServletContainer.Factory.newInstance();
         DeploymentInfo builder = new DeploymentInfo()
-                .setClassLoader(SimpleServletTestCase.class.getClassLoader())
+                .setClassLoader(HttpHostValuesTestCase.class.getClassLoader())
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")

File: servlet/src/test/java/io/undertow/servlet/test/request/HttpHostValuesTestCase.java
Patch:
@@ -22,7 +22,6 @@
 import io.undertow.servlet.api.DeploymentInfo;
 import io.undertow.servlet.api.DeploymentManager;
 import io.undertow.servlet.api.ServletContainer;
-import io.undertow.servlet.test.SimpleServletTestCase;
 import io.undertow.servlet.test.util.TestClassIntrospector;
 import io.undertow.testutils.DefaultServer;
 import io.undertow.testutils.HttpClientUtils;
@@ -48,13 +47,13 @@
 public class HttpHostValuesTestCase {
 
     @BeforeClass
-    public static void setup() throws ServletException {
+    public static void setup() {
 
 
         final PathHandler pathHandler = new PathHandler();
         final ServletContainer container = ServletContainer.Factory.newInstance();
         DeploymentInfo builder = new DeploymentInfo()
-                .setClassLoader(SimpleServletTestCase.class.getClassLoader())
+                .setClassLoader(HttpHostValuesTestCase.class.getClassLoader())
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")

File: servlet/src/main/java/io/undertow/servlet/spec/ServletInputStreamImpl.java
Patch:
@@ -88,6 +88,9 @@ public boolean isFinished() {
 
     @Override
     public boolean isReady() {
+        if (!asyncContext.isInitialRequestDone()) {
+            return false;
+        }
         boolean finished = anyAreSet(state, FLAG_FINISHED);
         if(finished) {
             if (anyAreClear(state, FLAG_ON_DATA_READ_CALLED)) {

File: servlet/src/test/java/io/undertow/servlet/test/streams/AbstractServletInputStreamTestCase.java
Patch:
@@ -58,6 +58,7 @@ public abstract class AbstractServletInputStreamTestCase {
     public static final String HELLO_WORLD = "Hello World";
     public static final String BLOCKING_SERVLET = "blockingInput";
     public static final String ASYNC_SERVLET = "asyncInput";
+    public static final String ASYNC_EAGER_SERVLET = "asyncEagerInput";
 
     @Test
     public void testBlockingServletInputStream() {

File: core/src/test/java/io/undertow/server/HttpServerExchangeTestCase.java
Patch:
@@ -65,11 +65,11 @@ public void testHttpServerExchange() throws IOException {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/somepath");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
-            Assert.assertEquals("localhost:" + protocol + ":GET:" + port + ":/somepath:/somepath:", HttpClientUtils.readResponse(result));
+            Assert.assertEquals(DefaultServer.getHostAddress() + ":" + protocol + ":GET:" + port + ":/somepath:/somepath:", HttpClientUtils.readResponse(result));
             get = new HttpGet(DefaultServer.getDefaultServerURL() + "/somepath?a=b");
             result = client.execute(get);
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
-            Assert.assertEquals("localhost:" + protocol + ":GET:" + port + ":/somepath:/somepath:a=b", HttpClientUtils.readResponse(result));
+            Assert.assertEquals(DefaultServer.getHostAddress() + ":" + protocol + ":GET:" + port + ":/somepath:/somepath:a=b", HttpClientUtils.readResponse(result));
             get = new HttpGet(DefaultServer.getDefaultServerURL() + "/somepath?a=b");
             get.addHeader("Host", "[::1]:8080");
             result = client.execute(get);

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -604,4 +604,7 @@ public interface UndertowMessages {
 
     @Message(id = 194, value = "Character decoding failed. Parameter with name [%s] has been ignored. Note: further occurrences of Parameter errors will be logged at DEBUG level.")
     String failedToDecodeParameterName(String parameter, @Cause Exception e);
+
+    @Message(id = 195, value = "Session with id %s already exists")
+    IllegalStateException sessionWithIdAlreadyExists(String sessionID);
 }

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -604,4 +604,7 @@ public interface UndertowMessages {
 
     @Message(id = 194, value = "Character decoding failed. Parameter with name [%s] has been ignored. Note: further occurrences of Parameter errors will be logged at DEBUG level.")
     String failedToDecodeParameterName(String parameter, @Cause Exception e);
+
+    @Message(id = 195, value = "Session with id %s already exists")
+    IllegalStateException sessionWithIdAlreadyExists(String sessionID);
 }

File: core/src/main/java/io/undertow/server/protocol/http2/Http2ReceiveListener.java
Patch:
@@ -216,8 +216,7 @@ public void handleEvent(Http2StreamSourceChannel channel) {
     }
 
     /**
-     * Handles the initial request when the exchange was started by a HTTP ugprade.
-     *
+     * Handles the initial request when the exchange was started by a HTTP upgrade.
      *
      * @param initial The initial upgrade request that started the HTTP2 connection
      */

File: core/src/main/java/io/undertow/server/protocol/http2/Http2ReceiveListener.java
Patch:
@@ -216,8 +216,7 @@ public void handleEvent(Http2StreamSourceChannel channel) {
     }
 
     /**
-     * Handles the initial request when the exchange was started by a HTTP ugprade.
-     *
+     * Handles the initial request when the exchange was started by a HTTP upgrade.
      *
      * @param initial The initial upgrade request that started the HTTP2 connection
      */

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/ServerWebSocketContainer.java
Patch:
@@ -358,7 +358,7 @@ public void handleDone(WebSocketChannel data, Object attachment) {
                 if(configured == null) {
                     // make sure to create an instance of AnnotatedEndpoint
                     clientEndpoints.put(endpointInstance.getClass(),
-                            getClientEndpoint(endpointInstance.getClass(), false));
+                            configured = getClientEndpoint(endpointInstance.getClass(), false));
                 }
             }
         }

File: servlet/src/main/java/io/undertow/servlet/compat/rewrite/RewriteHandler.java
Patch:
@@ -218,6 +218,7 @@ else if (index == urlString.length() - 1) {
                 chunk.append(request.getContextPath());
                 chunk.append(urlString);
                 String requestPath = chunk.toString();
+                exchange.setRequestURI(requestPath);
                 exchange.setRequestPath(requestPath);
                 exchange.setRelativePath(urlString);
 

File: core/src/main/java/io/undertow/security/impl/BasicAuthenticationMechanism.java
Patch:
@@ -151,9 +151,9 @@ public AuthenticationMechanismOutcome authenticate(HttpServerExchange exchange,
                         }
 
                         plainChallenge = new String(decode.array(), decode.arrayOffset(), decode.limit(), charset);
-                        UndertowLogger.SECURITY_LOGGER.debugf("Found basic auth header %s (decoded using charset %s) in %s", plainChallenge, charset, exchange);
+                        UndertowLogger.SECURITY_LOGGER.debugf("Found basic auth header (decoded using charset %s) in %s", charset, exchange);
                     } catch (IOException e) {
-                        UndertowLogger.SECURITY_LOGGER.debugf(e, "Failed to decode basic auth header %s in %s", base64Challenge, exchange);
+                        UndertowLogger.SECURITY_LOGGER.debugf(e, "Failed to decode basic auth header in %s", exchange);
                     }
                     int colonPos;
                     if (plainChallenge != null && (colonPos = plainChallenge.indexOf(COLON)) > -1) {

File: core/src/main/java/io/undertow/conduits/StoredResponseStreamSinkConduit.java
Patch:
@@ -93,7 +93,7 @@ public long write(ByteBuffer[] srcs, int offs, int len) throws IOException {
         for (int i = 0; i < len; ++i) {
             ByteBuffer buf = srcs[i + offs];
             int pos = starts[i];
-            while (rem > 0 && pos <= buf.position()) {
+            while (rem > 0 && pos < buf.position()) {
                 outputStream.write(buf.get(pos));
                 pos++;
                 rem--;
@@ -130,7 +130,7 @@ public long writeFinal(ByteBuffer[] srcs, int offs, int len) throws IOException
         for (int i = 0; i < len; ++i) {
             ByteBuffer buf = srcs[i + offs];
             int pos = starts[i];
-            while (rem > 0 && pos <= buf.position()) {
+            while (rem > 0 && pos < buf.position()) {
                 outputStream.write(buf.get(pos));
                 pos++;
                 rem--;

File: core/src/main/java/io/undertow/server/handlers/resource/CachedResource.java
Patch:
@@ -289,8 +289,8 @@ public void serveRange(Sender sender, HttpServerExchange exchange, long start, l
                     b.position((int) (b.position() + startDec));
                     startDec = 0;
                 } else {
-                    b.position(b.limit());
                     startDec -= b.remaining();
+                    b.position(b.limit());
                 }
             }
 

File: core/src/main/java/io/undertow/server/handlers/resource/CachedResource.java
Patch:
@@ -289,8 +289,8 @@ public void serveRange(Sender sender, HttpServerExchange exchange, long start, l
                     b.position((int) (b.position() + startDec));
                     startDec = 0;
                 } else {
-                    b.position(b.limit());
                     startDec -= b.remaining();
+                    b.position(b.limit());
                 }
             }
 

File: core/src/main/java/io/undertow/security/impl/BasicAuthenticationMechanism.java
Patch:
@@ -151,9 +151,9 @@ public AuthenticationMechanismOutcome authenticate(HttpServerExchange exchange,
                         }
 
                         plainChallenge = new String(decode.array(), decode.arrayOffset(), decode.limit(), charset);
-                        UndertowLogger.SECURITY_LOGGER.debugf("Found basic auth header %s (decoded using charset %s) in %s", plainChallenge, charset, exchange);
+                        UndertowLogger.SECURITY_LOGGER.debugf("Found basic auth header (decoded using charset %s) in %s", charset, exchange);
                     } catch (IOException e) {
-                        UndertowLogger.SECURITY_LOGGER.debugf(e, "Failed to decode basic auth header %s in %s", base64Challenge, exchange);
+                        UndertowLogger.SECURITY_LOGGER.debugf(e, "Failed to decode basic auth header in %s", exchange);
                     }
                     int colonPos;
                     if (plainChallenge != null && (colonPos = plainChallenge.indexOf(COLON)) > -1) {

File: core/src/test/java/io/undertow/server/handlers/RangeRequestTestCase.java
Patch:
@@ -80,7 +80,9 @@ public void testResourceHandler() throws IOException, InterruptedException {
     }
     @Test
     public void testCachedResourceHandler() throws IOException, InterruptedException {
-        runTest("/cachedresource/range.txt", false);
+        for(int i = 0; i < 10; ++i) {
+            runTest("/cachedresource/range.txt", false);
+        }
     }
 
     public void runTest(String path, boolean etag) throws IOException, InterruptedException {

File: core/src/main/java/io/undertow/conduits/StoredResponseStreamSinkConduit.java
Patch:
@@ -93,7 +93,7 @@ public long write(ByteBuffer[] srcs, int offs, int len) throws IOException {
         for (int i = 0; i < len; ++i) {
             ByteBuffer buf = srcs[i + offs];
             int pos = starts[i];
-            while (rem > 0 && pos <= buf.position()) {
+            while (rem > 0 && pos < buf.position()) {
                 outputStream.write(buf.get(pos));
                 pos++;
                 rem--;
@@ -130,7 +130,7 @@ public long writeFinal(ByteBuffer[] srcs, int offs, int len) throws IOException
         for (int i = 0; i < len; ++i) {
             ByteBuffer buf = srcs[i + offs];
             int pos = starts[i];
-            while (rem > 0 && pos <= buf.position()) {
+            while (rem > 0 && pos < buf.position()) {
                 outputStream.write(buf.get(pos));
                 pos++;
                 rem--;

File: servlet/src/main/java/io/undertow/servlet/compat/rewrite/RewriteHandler.java
Patch:
@@ -218,6 +218,7 @@ else if (index == urlString.length() - 1) {
                 chunk.append(request.getContextPath());
                 chunk.append(urlString);
                 String requestPath = chunk.toString();
+                exchange.setRequestURI(requestPath);
                 exchange.setRequestPath(requestPath);
                 exchange.setRelativePath(urlString);
 

File: core/src/main/java/io/undertow/security/api/AuthenticationMechanismFactory.java
Patch:
@@ -37,6 +37,8 @@ public interface AuthenticationMechanismFactory {
     String LOGIN_PAGE = "login_page";
     String ERROR_PAGE = "error_page";
     String CONTEXT_PATH = "context_path";
+    String DEFAULT_PAGE = "default_page";
+    String OVERRIDE_INITIAL = "override_initial";
 
     /**
      * Creates an authentication mechanism using the specified properties

File: core/src/main/java/io/undertow/security/api/AuthenticationMechanismFactory.java
Patch:
@@ -37,6 +37,8 @@ public interface AuthenticationMechanismFactory {
     String LOGIN_PAGE = "login_page";
     String ERROR_PAGE = "error_page";
     String CONTEXT_PATH = "context_path";
+    String DEFAULT_PAGE = "default_page";
+    String OVERRIDE_INITIAL = "override_initial";
 
     /**
      * Creates an authentication mechanism using the specified properties

File: core/src/main/java/io/undertow/protocols/http2/HpackDecoder.java
Patch:
@@ -267,7 +267,7 @@ private HttpString handleIndexedHeaderName(int index) throws HpackException {
         if (index <= Hpack.STATIC_TABLE_LENGTH) {
             return Hpack.STATIC_TABLE[index].name;
         } else {
-            if (index >= Hpack.STATIC_TABLE_LENGTH + filledTableSlots) {
+            if (index > Hpack.STATIC_TABLE_LENGTH + filledTableSlots) {
                 throw new HpackException();
             }
             int adjustedIndex = getRealIndex(index - Hpack.STATIC_TABLE_LENGTH);

File: core/src/main/java/io/undertow/server/RoutingHandler.java
Patch:
@@ -125,7 +125,7 @@ public synchronized RoutingHandler add(HttpString method, String template, HttpH
         if (res == null) {
             matcher.add(template, res = new RoutingMatch());
         }
-        if (allMethodsMatcher.get(template) == null) {
+        if (allMethodsMatcher.match(template) == null) {
             allMethodsMatcher.add(template, res);
         }
         res.defaultHandler = handler;
@@ -161,7 +161,7 @@ public synchronized RoutingHandler add(HttpString method, String template, Predi
         if (res == null) {
             matcher.add(template, res = new RoutingMatch());
         }
-        if (allMethodsMatcher.get(template) == null) {
+        if (allMethodsMatcher.match(template) == null) {
             allMethodsMatcher.add(template, res);
         }
         res.predicatedHandlers.add(new HandlerHolder(predicate, handler));
@@ -195,7 +195,7 @@ public synchronized RoutingHandler addAll(RoutingHandler routingHandler) {
             // If we use allMethodsMatcher.addAll() we can have duplicate
             // PathTemplates which we want to ignore here so it does not crash.
             for (PathTemplate template : entry.getValue().getPathTemplates()) {
-                if (allMethodsMatcher.get(template.getTemplateString()) == null) {
+                if (allMethodsMatcher.match(template.getTemplateString()) == null) {
                     allMethodsMatcher.add(template, new RoutingMatch());
                 }
             }

File: servlet/src/main/java/io/undertow/servlet/core/ManagedServlet.java
Patch:
@@ -37,6 +37,7 @@
 import io.undertow.server.handlers.resource.ResourceManager;
 import io.undertow.servlet.UndertowServletLogger;
 import io.undertow.servlet.UndertowServletMessages;
+import io.undertow.servlet.api.DeploymentInfo;
 import io.undertow.servlet.api.DeploymentManager;
 import io.undertow.servlet.api.InstanceFactory;
 import io.undertow.servlet.api.InstanceHandle;
@@ -104,7 +105,8 @@ public void setupMultipart(ServletContextImpl servletContext) {
                 if(locFile.isAbsolute()) {
                     tempDir = locFile;
                 } else {
-                    tempDir = servletContext.getDeployment().getDeploymentInfo().getTempPath().resolve(location);
+                    final DeploymentInfo deploymentInfo = servletContext.getDeployment().getDeploymentInfo();
+                    tempDir = deploymentInfo.requireTempPath().resolve(location);
                 }
             }
 

File: servlet/src/main/java/io/undertow/servlet/core/ManagedServlet.java
Patch:
@@ -37,6 +37,7 @@
 import io.undertow.server.handlers.resource.ResourceManager;
 import io.undertow.servlet.UndertowServletLogger;
 import io.undertow.servlet.UndertowServletMessages;
+import io.undertow.servlet.api.DeploymentInfo;
 import io.undertow.servlet.api.DeploymentManager;
 import io.undertow.servlet.api.InstanceFactory;
 import io.undertow.servlet.api.InstanceHandle;
@@ -104,7 +105,8 @@ public void setupMultipart(ServletContextImpl servletContext) {
                 if(locFile.isAbsolute()) {
                     tempDir = locFile;
                 } else {
-                    tempDir = servletContext.getDeployment().getDeploymentInfo().getTempPath().resolve(location);
+                    final DeploymentInfo deploymentInfo = servletContext.getDeployment().getDeploymentInfo();
+                    tempDir = deploymentInfo.requireTempPath().resolve(location);
                 }
             }
 

File: core/src/main/java/io/undertow/protocols/http2/HpackDecoder.java
Patch:
@@ -267,7 +267,7 @@ private HttpString handleIndexedHeaderName(int index) throws HpackException {
         if (index <= Hpack.STATIC_TABLE_LENGTH) {
             return Hpack.STATIC_TABLE[index].name;
         } else {
-            if (index >= Hpack.STATIC_TABLE_LENGTH + filledTableSlots) {
+            if (index > Hpack.STATIC_TABLE_LENGTH + filledTableSlots) {
                 throw new HpackException();
             }
             int adjustedIndex = getRealIndex(index - Hpack.STATIC_TABLE_LENGTH);

File: servlet/src/main/java/io/undertow/servlet/spec/ServletContextImpl.java
Patch:
@@ -907,7 +907,7 @@ public String rewriteUrl(String originalUrl, String sessionId) {
                                 }
                             }
                         }
-                        if (!found && !c.sessionCookieSource(exchange).equals(SessionConfig.SessionCookieSource.URL)) {
+                        if (!found) {
                             c.clearSession(exchange, existing);
                         }
                     } else {

File: servlet/src/test/java/io/undertow/servlet/test/session/ServletURLRewritingSessionTestCase.java
Patch:
@@ -35,7 +35,6 @@
 import org.apache.http.impl.client.BasicCookieStore;
 import org.junit.Assert;
 import org.junit.BeforeClass;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import io.undertow.servlet.ServletExtension;
@@ -171,7 +170,6 @@ public void testURLRewritingWithExistingOldSessionId() throws IOException {
     }
 
     @Test
-    @Ignore("Failing after fix for UNDERTOW-1575")
     public void testURLRewritingWithExistingOldSessionIdAndOtherPathParams() throws IOException {
         TestHttpClient client = new TestHttpClient();
         client.setCookieStore(new BasicCookieStore());
@@ -183,6 +181,7 @@ public void testURLRewritingWithExistingOldSessionIdAndOtherPathParams() throws
             Header[] header = result.getHeaders(COUNT);
             Assert.assertEquals("0", header[0].getValue());
 
+
             get = new HttpGet(url);
             result = client.execute(get);
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());

File: core/src/main/java/io/undertow/security/handlers/SinglePortConfidentialityHandler.java
Patch:
@@ -19,6 +19,7 @@
 
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
+import io.undertow.util.NetworkUtils;
 
 import java.net.URI;
 import java.net.URISyntaxException;
@@ -45,7 +46,8 @@ protected URI getRedirectURI(HttpServerExchange exchange) throws URISyntaxExcept
 
     protected URI getRedirectURI(final HttpServerExchange exchange, final int port) throws URISyntaxException {
         final StringBuilder uriBuilder = new StringBuilder();
-        uriBuilder.append("https://").append(exchange.getHostName());
+        uriBuilder.append("https://");
+        uriBuilder.append(NetworkUtils.formatPossibleIpv6Address(exchange.getHostName()));
         if (port > 0) {
             uriBuilder.append(":").append(port);
         }

File: core/src/main/java/io/undertow/security/handlers/SinglePortConfidentialityHandler.java
Patch:
@@ -19,6 +19,7 @@
 
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
+import io.undertow.util.NetworkUtils;
 
 import java.net.URI;
 import java.net.URISyntaxException;
@@ -45,7 +46,8 @@ protected URI getRedirectURI(HttpServerExchange exchange) throws URISyntaxExcept
 
     protected URI getRedirectURI(final HttpServerExchange exchange, final int port) throws URISyntaxException {
         final StringBuilder uriBuilder = new StringBuilder();
-        uriBuilder.append("https://").append(exchange.getHostName());
+        uriBuilder.append("https://");
+        uriBuilder.append(NetworkUtils.formatPossibleIpv6Address(exchange.getHostName()));
         if (port > 0) {
             uriBuilder.append(":").append(port);
         }

File: core/src/main/java/io/undertow/server/RoutingHandler.java
Patch:
@@ -125,7 +125,7 @@ public synchronized RoutingHandler add(HttpString method, String template, HttpH
         if (res == null) {
             matcher.add(template, res = new RoutingMatch());
         }
-        if (allMethodsMatcher.get(template) == null) {
+        if (allMethodsMatcher.match(template) == null) {
             allMethodsMatcher.add(template, res);
         }
         res.defaultHandler = handler;
@@ -161,7 +161,7 @@ public synchronized RoutingHandler add(HttpString method, String template, Predi
         if (res == null) {
             matcher.add(template, res = new RoutingMatch());
         }
-        if (allMethodsMatcher.get(template) == null) {
+        if (allMethodsMatcher.match(template) == null) {
             allMethodsMatcher.add(template, res);
         }
         res.predicatedHandlers.add(new HandlerHolder(predicate, handler));
@@ -195,7 +195,7 @@ public synchronized RoutingHandler addAll(RoutingHandler routingHandler) {
             // If we use allMethodsMatcher.addAll() we can have duplicate
             // PathTemplates which we want to ignore here so it does not crash.
             for (PathTemplate template : entry.getValue().getPathTemplates()) {
-                if (allMethodsMatcher.get(template.getTemplateString()) == null) {
+                if (allMethodsMatcher.match(template.getTemplateString()) == null) {
                     allMethodsMatcher.add(template, new RoutingMatch());
                 }
             }

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -71,6 +71,7 @@
 import io.undertow.servlet.api.ThreadSetupHandler;
 import io.undertow.servlet.api.WebResourceCollection;
 import io.undertow.servlet.handlers.CrawlerSessionManagerHandler;
+import io.undertow.servlet.handlers.RedirectDirHandler;
 import io.undertow.servlet.handlers.ServletDispatchingHandler;
 import io.undertow.servlet.handlers.ServletHandler;
 import io.undertow.servlet.handlers.ServletInitialHandler;
@@ -218,6 +219,7 @@ public Void call(HttpServerExchange exchange, Object ignore) throws Exception {
 
                     HttpHandler wrappedHandlers = ServletDispatchingHandler.INSTANCE;
                     wrappedHandlers = wrapHandlers(wrappedHandlers, deploymentInfo.getInnerHandlerChainWrappers());
+                    wrappedHandlers = new RedirectDirHandler(wrappedHandlers, deployment.getServletPaths());
                     if(!deploymentInfo.isSecurityDisabled()) {
                         HttpHandler securityHandler = setupSecurityHandlers(wrappedHandlers);
                         wrappedHandlers = new PredicateHandler(DispatcherTypePredicate.REQUEST, securityHandler, wrappedHandlers);

File: servlet/src/main/java/io/undertow/servlet/spec/ServletContextImpl.java
Patch:
@@ -907,7 +907,7 @@ public String rewriteUrl(String originalUrl, String sessionId) {
                                 }
                             }
                         }
-                        if (!found) {
+                        if (!found && !c.sessionCookieSource(exchange).equals(SessionConfig.SessionCookieSource.URL)) {
                             c.clearSession(exchange, existing);
                         }
                     } else {

File: servlet/src/test/java/io/undertow/servlet/test/session/ServletURLRewritingSessionTestCase.java
Patch:
@@ -35,6 +35,7 @@
 import org.apache.http.impl.client.BasicCookieStore;
 import org.junit.Assert;
 import org.junit.BeforeClass;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import io.undertow.servlet.ServletExtension;
@@ -170,6 +171,7 @@ public void testURLRewritingWithExistingOldSessionId() throws IOException {
     }
 
     @Test
+    @Ignore("Failing after fix for UNDERTOW-1575")
     public void testURLRewritingWithExistingOldSessionIdAndOtherPathParams() throws IOException {
         TestHttpClient client = new TestHttpClient();
         client.setCookieStore(new BasicCookieStore());
@@ -181,7 +183,6 @@ public void testURLRewritingWithExistingOldSessionIdAndOtherPathParams() throws
             Header[] header = result.getHeaders(COUNT);
             Assert.assertEquals("0", header[0].getValue());
 
-
             get = new HttpGet(url);
             result = client.execute(get);
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());

File: core/src/test/java/io/undertow/server/handlers/accesslog/ExtendedAccessLogFileTestCase.java
Patch:
@@ -102,7 +102,7 @@ private void verifySingleLogMessageToFile(Path logFileName, DefaultAccessLogRece
             latchHandler.await();
             logReceiver.awaitWrittenForTest();
             String data = new String(Files.readAllBytes(logFileName));
-            String[] lines = data.split("\n");
+            String[] lines = data.split(System.lineSeparator());
             Assert.assertEquals("#Fields: " + PATTERN, lines[0]);
             Assert.assertEquals("#Version: 2.0", lines[1]);
             Assert.assertEquals("#Software: " + Version.getFullVersionString(), lines[2]);

File: servlet/src/main/java/io/undertow/servlet/spec/ServletContextImpl.java
Patch:
@@ -907,7 +907,7 @@ public String rewriteUrl(String originalUrl, String sessionId) {
                                 }
                             }
                         }
-                        if (!found) {
+                        if (!found && !c.sessionCookieSource(exchange).equals(SessionConfig.SessionCookieSource.URL)) {
                             c.clearSession(exchange, existing);
                         }
                     } else {

File: servlet/src/test/java/io/undertow/servlet/test/session/ServletURLRewritingSessionTestCase.java
Patch:
@@ -35,6 +35,7 @@
 import org.apache.http.impl.client.BasicCookieStore;
 import org.junit.Assert;
 import org.junit.BeforeClass;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import io.undertow.servlet.ServletExtension;
@@ -170,6 +171,7 @@ public void testURLRewritingWithExistingOldSessionId() throws IOException {
     }
 
     @Test
+    @Ignore("Failing after fix for UNDERTOW-1575")
     public void testURLRewritingWithExistingOldSessionIdAndOtherPathParams() throws IOException {
         TestHttpClient client = new TestHttpClient();
         client.setCookieStore(new BasicCookieStore());
@@ -181,7 +183,6 @@ public void testURLRewritingWithExistingOldSessionIdAndOtherPathParams() throws
             Header[] header = result.getHeaders(COUNT);
             Assert.assertEquals("0", header[0].getValue());
 
-
             get = new HttpGet(url);
             result = client.execute(get);
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());

File: core/src/test/java/io/undertow/server/handlers/accesslog/ExtendedAccessLogFileTestCase.java
Patch:
@@ -102,7 +102,7 @@ private void verifySingleLogMessageToFile(Path logFileName, DefaultAccessLogRece
             latchHandler.await();
             logReceiver.awaitWrittenForTest();
             String data = new String(Files.readAllBytes(logFileName));
-            String[] lines = data.split("\n");
+            String[] lines = data.split(System.lineSeparator());
             Assert.assertEquals("#Fields: " + PATTERN, lines[0]);
             Assert.assertEquals("#Version: 2.0", lines[1]);
             Assert.assertEquals("#Software: " + Version.getFullVersionString(), lines[2]);

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletPathMatches.java
Patch:
@@ -457,7 +457,8 @@ private static boolean isFilterApplicable(final String path, final String filter
         }
         if (modifiedPath.endsWith("/*")) {
             String baseFilterPath = modifiedPath.substring(0, modifiedPath.length() - 1);
-            return path.startsWith(baseFilterPath);
+            String exactFilterPath = modifiedPath.substring(0, modifiedPath.length() - 2);
+            return path.startsWith(baseFilterPath) || path.equals(exactFilterPath);
         } else {
             return modifiedPath.equals(path);
         }

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletPathMatches.java
Patch:
@@ -457,7 +457,8 @@ private static boolean isFilterApplicable(final String path, final String filter
         }
         if (modifiedPath.endsWith("/*")) {
             String baseFilterPath = modifiedPath.substring(0, modifiedPath.length() - 1);
-            return path.startsWith(baseFilterPath);
+            String exactFilterPath = modifiedPath.substring(0, modifiedPath.length() - 2);
+            return path.startsWith(baseFilterPath) || path.equals(exactFilterPath);
         } else {
             return modifiedPath.equals(path);
         }

File: servlet/src/main/java/io/undertow/servlet/spec/ServletContextImpl.java
Patch:
@@ -807,7 +807,7 @@ public String getRequestCharacterEncoding() {
     public void setRequestCharacterEncoding(String encoding) {
         ensureNotInitialized();
         ensureNotProgramaticListener();
-        deploymentInfo.setDefaultRequestEncoding(getContextPath());
+        deploymentInfo.setDefaultRequestEncoding(encoding);
     }
 
     @Override

File: core/src/main/java/io/undertow/server/protocol/proxy/ProxyProtocolReadListener.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
- * Implementation of version 1 of the proxy protocol (https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt)
+ * Implementation of version 1 and 2 of the proxy protocol (https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt)
  * <p>
  * Even though it is not required by the spec this implementation provides a stateful parser, that can handle
  * fragmentation of

File: servlet/src/main/java/io/undertow/servlet/spec/ServletContextImpl.java
Patch:
@@ -807,7 +807,7 @@ public String getRequestCharacterEncoding() {
     public void setRequestCharacterEncoding(String encoding) {
         ensureNotInitialized();
         ensureNotProgramaticListener();
-        deploymentInfo.setDefaultRequestEncoding(getContextPath());
+        deploymentInfo.setDefaultRequestEncoding(encoding);
     }
 
     @Override

File: core/src/main/java/io/undertow/server/protocol/proxy/ProxyProtocolReadListener.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
- * Implementation of version 1 of the proxy protocol (https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt)
+ * Implementation of version 1 and 2 of the proxy protocol (https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt)
  * <p>
  * Even though it is not required by the spec this implementation provides a stateful parser, that can handle
  * fragmentation of

File: core/src/main/java/io/undertow/Undertow.java
Patch:
@@ -558,7 +558,7 @@ public <T> Builder setWorkerOption(final Option<T> option, final T value) {
          * to the various worker-related configuration (ioThreads, workerThreads, workerOptions)
          * when {@link Undertow#start()} is called.
          * Additionally, this newly created worker will be shutdown when {@link Undertow#stop()} is called.
-         * <br/>
+         * <br>
          * <p>
          * When non-null, the provided {@link XnioWorker} will be reused instead of creating a new {@link XnioWorker}
          * when {@link Undertow#start()} is called.

File: core/src/main/java/io/undertow/client/http/ResponseParseState.java
Patch:
@@ -67,10 +67,10 @@ class ResponseParseState {
 
     /**
      * This has different meanings depending on the current state.
-     * <p/>
+     * <p>
      * In state {@link #HEADER} it is a the first character of the header, that was read by
      * {@link #HEADER_VALUE} to see if this was a continuation.
-     * <p/>
+     * <p>
      * In state {@link #HEADER_VALUE} if represents the last character that was seen.
      */
     byte leftOver;

File: core/src/main/java/io/undertow/protocols/http2/HPackHuffman.java
Patch:
@@ -34,7 +34,7 @@ public class HPackHuffman {
 
     /**
      * array based tree representation of a huffman code.
-     * <p/>
+     * <p>
      * the high two bytes corresponds to the tree node if the bit is set, and the low two bytes for if it is clear
      * if the high bit is set it is a terminal node, otherwise it contains the next node position.
      */

File: core/src/main/java/io/undertow/protocols/http2/Hpack.java
Patch:
@@ -140,7 +140,7 @@ static class HeaderField {
      * Decodes an integer in the HPACK prefex format. If the return value is -1
      * it means that there was not enough data in the buffer to complete the decoding
      * sequence.
-     * <p/>
+     * <p>
      * If this method returns -1 then the source buffer will not have been modified.
      *
      * @param source The buffer that contains the integer
@@ -188,7 +188,7 @@ static int decodeInteger(ByteBuffer source, int n) throws HpackException {
 
     /**
      * Encodes an integer in the HPACK prefix format.
-     * <p/>
+     * <p>
      * This method assumes that the buffer has already had the first 8-n bits filled.
      * As such it will modify the last byte that is already present in the buffer, and
      * potentially add more if required

File: core/src/main/java/io/undertow/protocols/http2/HpackDecoder.java
Patch:
@@ -298,7 +298,7 @@ private void handleIndex(int index) throws HpackException {
     /**
      * because we use a ring buffer type construct, and don't actually shuffle
      * items in the array, we need to figure out he real index to use.
-     * <p/>
+     * <p>
      * package private for unit tests
      *
      * @param index The index from the hpack

File: core/src/main/java/io/undertow/protocols/http2/Http2GoAwayStreamSinkChannel.java
Patch:
@@ -25,7 +25,7 @@
 
 /**
  * The go away
- * <p/>
+ * <p>
  * TODO: at the moment we don't allow the additional debug data
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/protocols/http2/Http2NoDataStreamSinkChannel.java
Patch:
@@ -28,7 +28,7 @@
 /**
  * Stream sink channel that serves as the basis for channels that do not have the ability
  * to write data.
- * <p/>
+ * <p>
  * In particular these are:
  * - PING
  * - GO_AWAY

File: core/src/main/java/io/undertow/security/handlers/SecurityInitialHandler.java
Patch:
@@ -66,7 +66,7 @@ public SecurityInitialHandler(final AuthenticationMode authenticationMode, final
     }
 
     /**
-     * @see io.undertow.security.handlers.AbstractSecurityContextAssociationHandler#createSecurityContext()
+     * @see io.undertow.security.handlers.AbstractSecurityContextAssociationHandler#createSecurityContext
      */
     @Override
     public SecurityContext createSecurityContext(final HttpServerExchange exchange) {

File: core/src/main/java/io/undertow/server/handlers/JDBCLogHandler.java
Patch:
@@ -259,7 +259,7 @@ private void writeMessage(List<JDBCLogAttribute> messages) {
 
     /**
      * For tests only. Blocks the current thread until all messages are written Just does a busy wait.
-     * <p/>
+     * <p>
      * DO NOT USE THIS OUTSIDE OF A TEST
      */
     void awaitWrittenForTest() throws InterruptedException {

File: core/src/main/java/io/undertow/server/handlers/accesslog/DefaultAccessLogReceiver.java
Patch:
@@ -42,7 +42,7 @@
 /**
  * Log Receiver that stores logs in a directory under the specified file name, and rotates them after
  * midnight.
- * <p/>
+ * <p>
  * Web threads do not touch the log file, but simply queue messages to be written later by a worker thread.
  * A lightweight CAS based locking mechanism is used to ensure than only 1 thread is active writing messages at
  * any given time
@@ -212,7 +212,7 @@ public void run() {
     /**
      * For tests only. Blocks the current thread until all messages are written
      * Just does a busy wait.
-     * <p/>
+     * <p>
      * DO NOT USE THIS OUTSIDE OF A TEST
      */
     void awaitWrittenForTest() throws InterruptedException {

File: core/src/main/java/io/undertow/server/handlers/builder/PredicatedHandlersParser.java
Patch:
@@ -48,7 +48,7 @@
 
 /**
  * Parser for the undertow-handlers.conf file.
- * <p/>
+ * <p>
  * This file has a line by line syntax, specifying predicate -&gt; handler. If no predicate is specified then
  * the line is assumed to just contain a handler.
  *

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/ModClusterProxyClient.java
Patch:
@@ -35,7 +35,7 @@ class ModClusterProxyClient implements ProxyClient {
 
     /**
      * The attachment key that is used to attach the proxy connection to the exchange.
-     * <p/>
+     * <p>
      * This cannot be static as otherwise a connection from a different client could be re-used.
      */
     private final AttachmentKey<ExclusiveConnectionHolder> exclusiveConnectionKey = AttachmentKey

File: core/src/main/java/io/undertow/server/handlers/resource/ResourceHandler.java
Patch:
@@ -99,12 +99,12 @@ public class ResourceHandler implements HttpHandler {
     private volatile ResourceManager resourceManager;
     /**
      * If this is set this will be the maximum time (in seconds) the client will cache the resource.
-     * <p/>
+     * <p>
      * Note: Do not set this for private resources, as it will cause a Cache-Control: public
      * to be sent.
-     * <p/>
+     * <p>
      * TODO: make this more flexible
-     * <p/>
+     * <p>
      * This will only be used if the {@link #cachable} predicate returns true
      */
     private volatile Integer cacheTime;

File: core/src/main/java/io/undertow/server/protocol/http/HttpResponseConduit.java
Patch:
@@ -109,7 +109,7 @@ void reset(HttpServerExchange exchange) {
      * Handles writing out the header data. It can also take a byte buffer of user
      * data, to enable both user data and headers to be written out in a single operation,
      * which has a noticeable performance impact.
-     * <p/>
+     * <p>
      * It is up to the caller to note the current position of this buffer before and after they
      * call this method, and use this to figure out how many bytes (if any) have been written.
      *

File: core/src/main/java/io/undertow/server/protocol/http/HttpTransferEncoding.java
Patch:
@@ -42,7 +42,7 @@
 /**
  * Class that is  responsible for HTTP transfer encoding, this could be part of the {@link HttpReadListener},
  * but is separated out for clarity.
- * <p/>
+ * <p>
  * For more info see http://tools.ietf.org/html/rfc2616#section-4.4
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/server/protocol/http/ParseState.java
Patch:
@@ -22,7 +22,7 @@
 
 /**
  * The current state of the tokenizer state machine. This class is mutable and not thread safe.
- * <p/>
+ * <p>
  * As the machine changes state this class is updated rather than allocating a new one each time.
  *
  * fields are not private to allow for efficient putfield / getfield access

File: core/src/main/java/io/undertow/util/ConnectionUtils.java
Patch:
@@ -46,7 +46,7 @@ private ConnectionUtils() {
 
     /**
      * Cleanly close a connection, by shutting down and flushing writes and then draining reads.
-     * <p/>
+     * <p>
      * If this fails the connection is forcibly closed.
      *
      * @param connection The connection

File: core/src/main/java/io/undertow/util/DateUtils.java
Patch:
@@ -47,7 +47,7 @@ public class DateUtils {
     /**
      * Thread local cache of this date format. This is technically a small memory leak, however
      * in practice it is fine, as it will only be used by server threads.
-     * <p/>
+     * <p>
      * This is the most common date format, which is why we cache it.
      */
     private static final ThreadLocal<SimpleDateFormat> RFC1123_PATTERN_FORMAT = new ThreadLocal<SimpleDateFormat>() {

File: core/src/main/java/io/undertow/util/FastConcurrentDirectDeque.java
Patch:
@@ -82,7 +82,7 @@
  * Java Collections Framework</a>.
  *
  * Based on revision 1.50 of ConcurrentLinkedDeque
- * (see http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentLinkedDeque.java?revision=1.50&view=markup)
+ * (see http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentLinkedDeque.java?revision=1.50&amp;view=markup)
  * This is the version used in JDK 1.8.0_121.
  *
  * @since 1.7

File: core/src/main/java/io/undertow/util/FileUtils.java
Patch:
@@ -52,7 +52,7 @@ public static String readFile(URL url) {
     }
 
     /**
-     * Reads the {@link InputStream file} and converting it to {@link String using UTF-8 encoding.
+     * Reads the {@link InputStream file} and converting it to {@link String} using UTF-8 encoding.
      */
     public static String readFile(InputStream file) {
         try (BufferedInputStream stream = new BufferedInputStream(file)) {

File: core/src/main/java/io/undertow/util/QValueParser.java
Patch:
@@ -135,7 +135,7 @@ public static class QValueResult implements Comparable<QValueResult> {
 
         /**
          * we keep the qvalue as a string to avoid parsing the double.
-         * <p/>
+         * <p>
          * This should give both performance and also possible security improvements
          */
         private String qvalue = "1";

File: core/src/main/java/io/undertow/util/RedirectBuilder.java
Patch:
@@ -103,7 +103,7 @@ public static String redirect(final HttpServerExchange exchange, final String ne
 
     /**
      * perform URL encoding
-     * <p/>
+     * <p>
      * TODO: this whole thing is kinda crappy.
      *
      * @return

File: core/src/main/java/io/undertow/websockets/core/WebSocketFramePriority.java
Patch:
@@ -34,9 +34,9 @@ public class WebSocketFramePriority implements FramePriority<WebSocketChannel, S
 
     /**
      * Strict ordering queue. Makes sure that the initial frame for a stream is sent in the order that send() is called.
-     * <p/>
+     * <p>
      * Required to pass the autobahn test suite with no non-strict performance.
-     * <p/>
+     * <p>
      * TODO: provide a way to disable this.
      */
     private final Queue<StreamSinkFrameChannel> strictOrderQueue = new ConcurrentLinkedDeque<>();

File: core/src/main/java/io/undertow/websockets/extensions/ExtensionFunction.java
Patch:
@@ -26,12 +26,12 @@
 
 /**
  * Base interface for WebSocket Extensions implementation.
- * <p/>
+ * <p>
  * It interacts at the connection phase. It is responsible to apply extension's logic before to write and after to read to/from
  * a WebSocket Endpoint.
- * <p/>
+ * <p>
  * Several extensions can be present in a WebSocket Endpoint being executed in a chain pattern.
- * <p/>
+ * <p>
  * Extension state is stored per WebSocket connection.
  *
  * @author Lucas Ponce

File: core/src/main/java/io/undertow/websockets/extensions/PerMessageDeflateFunction.java
Patch:
@@ -37,11 +37,11 @@
 
 /**
  * Implementation of {@code permessage-deflate} WebSocket Extension.
- * <p/>
+ * <p>
  * This implementation supports parameters: {@code server_no_context_takeover, client_no_context_takeover} .
- * <p/>
+ * <p>
  * This implementation does not support parameters: {@code server_max_window_bits, client_max_window_bits} .
- * <p/>
+ * <p>
  * It uses the DEFLATE implementation algorithm packaged on {@link Deflater} and {@link Inflater} classes.
  *
  * @author Lucas Ponce

File: core/src/test/java/io/undertow/server/handlers/encoding/EncodingSelectionTestCase.java
Patch:
@@ -47,7 +47,7 @@ public class EncodingSelectionTestCase {
 
     /**
      * Tests encoding selection with no qvalue
-     * <p/>
+     * <p>
      * Also tests a lot of non standard formats for Accept-Encoding to make sure that
      * we are liberal in what we accept
      *

File: core/src/test/java/io/undertow/server/protocol/http/SimpleParserTestCase.java
Patch:
@@ -36,9 +36,9 @@
 
 /**
  * Basic test of the HTTP parser functionality.
- * <p/>
+ * <p>
  * This tests parsing the same basic request, over and over, with minor differences.
- * <p/>
+ * <p>
  *
  * @author Stuart Douglas
  */

File: core/src/test/java/io/undertow/server/security/AuthenticationTestBase.java
Patch:
@@ -317,7 +317,7 @@ protected static String getAuthHeader(final HttpString prefix, final Header[] va
 
     /**
      * A simple end of chain handler to set a header and cause the call to return.
-     * <p/>
+     * <p>
      * Reaching this handler is a sign the mechanism handlers have allowed the request through.
      */
     protected static class ResponseHandler implements HttpHandler {

File: servlet/src/main/java/io/undertow/servlet/compat/rewrite/RewriteCond.java
Patch:
@@ -49,9 +49,9 @@ public boolean evaluate(String value, Resolver resolver) {
 
     public static class LexicalCondition extends Condition {
         /**
-         * -1: <
+         * -1: &lt;
          * 0: =
-         * 1: >
+         * 1: &gt;
          */
         public int type = 0;
         public String condition;

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -302,7 +302,7 @@ private void handleExtensions(final DeploymentInfo deploymentInfo, final Servlet
 
     /**
      * sets up the outer security handlers.
-     * <p/>
+     * <p>
      * the handler that actually performs the access check happens later in the chain, it is not setup here
      *
      * @param initialHandler The handler to wrap with security handlers

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletPathMatches.java
Patch:
@@ -190,10 +190,10 @@ public void setWelcomePages(List<String> welcomePages) {
     /**
      * Sets up the handlers in the servlet chain. We setup a chain for every path + extension match possibility.
      * (i.e. if there a m path mappings and n extension mappings we have n*m chains).
-     * <p/>
+     * <p>
      * If a chain consists of only the default servlet then we add it as an async handler, so that resources can be
      * served up directly without using blocking operations.
-     * <p/>
+     * <p>
      * TODO: this logic is a bit convoluted at the moment, we should look at simplifying it
      */
     private ServletPathMatchesData setupServletChains() {

File: servlet/src/test/java/io/undertow/servlet/test/streams/ServletInputStreamEarlyCloseClientSideTestCase.java
Patch:
@@ -36,7 +36,7 @@
 
 /**
  * Tests the behaviour of the input stream when the connection is closed on the client side
- * <p/>
+ * <p>
  * https://issues.jboss.org/browse/WFLY-4827
  *
  * @author Stuart Douglas

File: servlet/src/test/java/io/undertow/servlet/test/wrapper/NonStandardResponseWrapper.java
Patch:
@@ -468,7 +468,7 @@ public String getHeader(String name) {
      * The default behaviour of this method is to call
      * {@link HttpServletResponse#getHeaders} on the wrapped response
      * object.
-     * <p/>
+     * <p>
      * <p>Any changes to the returned <code>Collection</code> must not
      * affect this <code>HttpServletResponseWrapper</code>.
      *
@@ -486,7 +486,7 @@ public Collection<String> getHeaders(String name) {
      * The default behaviour of this method is to call
      * {@link HttpServletResponse#getHeaderNames} on the wrapped response
      * object.
-     * <p/>
+     * <p>
      * <p>Any changes to the returned <code>Collection</code> must not
      * affect this <code>HttpServletResponseWrapper</code>.
      *

File: core/src/main/java/io/undertow/security/handlers/SecurityInitialHandler.java
Patch:
@@ -66,7 +66,7 @@ public SecurityInitialHandler(final AuthenticationMode authenticationMode, final
     }
 
     /**
-     * @see io.undertow.security.handlers.AbstractSecurityContextAssociationHandler#createSecurityContext()
+     * @see io.undertow.security.handlers.AbstractSecurityContextAssociationHandler#createSecurityContext
      */
     @Override
     public SecurityContext createSecurityContext(final HttpServerExchange exchange) {

File: core/src/main/java/io/undertow/util/FastConcurrentDirectDeque.java
Patch:
@@ -82,7 +82,7 @@
  * Java Collections Framework</a>.
  *
  * Based on revision 1.50 of ConcurrentLinkedDeque
- * (see http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentLinkedDeque.java?revision=1.50&view=markup)
+ * (see http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentLinkedDeque.java?revision=1.50&amp;view=markup)
  * This is the version used in JDK 1.8.0_121.
  *
  * @since 1.7

File: core/src/main/java/io/undertow/util/FileUtils.java
Patch:
@@ -52,7 +52,7 @@ public static String readFile(URL url) {
     }
 
     /**
-     * Reads the {@link InputStream file} and converting it to {@link String using UTF-8 encoding.
+     * Reads the {@link InputStream file} and converting it to {@link String} using UTF-8 encoding.
      */
     public static String readFile(InputStream file) {
         try (BufferedInputStream stream = new BufferedInputStream(file)) {

File: servlet/src/main/java/io/undertow/servlet/compat/rewrite/RewriteCond.java
Patch:
@@ -49,9 +49,9 @@ public boolean evaluate(String value, Resolver resolver) {
 
     public static class LexicalCondition extends Condition {
         /**
-         * -1: <
+         * -1: &lt;
          * 0: =
-         * 1: >
+         * 1: &gt;
          */
         public int type = 0;
         public String condition;

File: core/src/main/java/io/undertow/Undertow.java
Patch:
@@ -558,7 +558,7 @@ public <T> Builder setWorkerOption(final Option<T> option, final T value) {
          * to the various worker-related configuration (ioThreads, workerThreads, workerOptions)
          * when {@link Undertow#start()} is called.
          * Additionally, this newly created worker will be shutdown when {@link Undertow#stop()} is called.
-         * <br/>
+         * <br>
          * <p>
          * When non-null, the provided {@link XnioWorker} will be reused instead of creating a new {@link XnioWorker}
          * when {@link Undertow#start()} is called.

File: core/src/main/java/io/undertow/client/http/ResponseParseState.java
Patch:
@@ -67,10 +67,10 @@ class ResponseParseState {
 
     /**
      * This has different meanings depending on the current state.
-     * <p/>
+     * <p>
      * In state {@link #HEADER} it is a the first character of the header, that was read by
      * {@link #HEADER_VALUE} to see if this was a continuation.
-     * <p/>
+     * <p>
      * In state {@link #HEADER_VALUE} if represents the last character that was seen.
      */
     byte leftOver;

File: core/src/main/java/io/undertow/protocols/http2/HPackHuffman.java
Patch:
@@ -34,7 +34,7 @@ public class HPackHuffman {
 
     /**
      * array based tree representation of a huffman code.
-     * <p/>
+     * <p>
      * the high two bytes corresponds to the tree node if the bit is set, and the low two bytes for if it is clear
      * if the high bit is set it is a terminal node, otherwise it contains the next node position.
      */

File: core/src/main/java/io/undertow/protocols/http2/Hpack.java
Patch:
@@ -140,7 +140,7 @@ static class HeaderField {
      * Decodes an integer in the HPACK prefex format. If the return value is -1
      * it means that there was not enough data in the buffer to complete the decoding
      * sequence.
-     * <p/>
+     * <p>
      * If this method returns -1 then the source buffer will not have been modified.
      *
      * @param source The buffer that contains the integer
@@ -188,7 +188,7 @@ static int decodeInteger(ByteBuffer source, int n) throws HpackException {
 
     /**
      * Encodes an integer in the HPACK prefix format.
-     * <p/>
+     * <p>
      * This method assumes that the buffer has already had the first 8-n bits filled.
      * As such it will modify the last byte that is already present in the buffer, and
      * potentially add more if required

File: core/src/main/java/io/undertow/protocols/http2/HpackDecoder.java
Patch:
@@ -298,7 +298,7 @@ private void handleIndex(int index) throws HpackException {
     /**
      * because we use a ring buffer type construct, and don't actually shuffle
      * items in the array, we need to figure out he real index to use.
-     * <p/>
+     * <p>
      * package private for unit tests
      *
      * @param index The index from the hpack

File: core/src/main/java/io/undertow/protocols/http2/Http2GoAwayStreamSinkChannel.java
Patch:
@@ -25,7 +25,7 @@
 
 /**
  * The go away
- * <p/>
+ * <p>
  * TODO: at the moment we don't allow the additional debug data
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/protocols/http2/Http2NoDataStreamSinkChannel.java
Patch:
@@ -28,7 +28,7 @@
 /**
  * Stream sink channel that serves as the basis for channels that do not have the ability
  * to write data.
- * <p/>
+ * <p>
  * In particular these are:
  * - PING
  * - GO_AWAY

File: core/src/main/java/io/undertow/server/handlers/JDBCLogHandler.java
Patch:
@@ -259,7 +259,7 @@ private void writeMessage(List<JDBCLogAttribute> messages) {
 
     /**
      * For tests only. Blocks the current thread until all messages are written Just does a busy wait.
-     * <p/>
+     * <p>
      * DO NOT USE THIS OUTSIDE OF A TEST
      */
     void awaitWrittenForTest() throws InterruptedException {

File: core/src/main/java/io/undertow/server/handlers/accesslog/DefaultAccessLogReceiver.java
Patch:
@@ -42,7 +42,7 @@
 /**
  * Log Receiver that stores logs in a directory under the specified file name, and rotates them after
  * midnight.
- * <p/>
+ * <p>
  * Web threads do not touch the log file, but simply queue messages to be written later by a worker thread.
  * A lightweight CAS based locking mechanism is used to ensure than only 1 thread is active writing messages at
  * any given time
@@ -212,7 +212,7 @@ public void run() {
     /**
      * For tests only. Blocks the current thread until all messages are written
      * Just does a busy wait.
-     * <p/>
+     * <p>
      * DO NOT USE THIS OUTSIDE OF A TEST
      */
     void awaitWrittenForTest() throws InterruptedException {

File: core/src/main/java/io/undertow/server/handlers/builder/PredicatedHandlersParser.java
Patch:
@@ -48,7 +48,7 @@
 
 /**
  * Parser for the undertow-handlers.conf file.
- * <p/>
+ * <p>
  * This file has a line by line syntax, specifying predicate -&gt; handler. If no predicate is specified then
  * the line is assumed to just contain a handler.
  *

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/ModClusterProxyClient.java
Patch:
@@ -35,7 +35,7 @@ class ModClusterProxyClient implements ProxyClient {
 
     /**
      * The attachment key that is used to attach the proxy connection to the exchange.
-     * <p/>
+     * <p>
      * This cannot be static as otherwise a connection from a different client could be re-used.
      */
     private final AttachmentKey<ExclusiveConnectionHolder> exclusiveConnectionKey = AttachmentKey

File: core/src/main/java/io/undertow/server/handlers/resource/ResourceHandler.java
Patch:
@@ -99,12 +99,12 @@ public class ResourceHandler implements HttpHandler {
     private volatile ResourceManager resourceManager;
     /**
      * If this is set this will be the maximum time (in seconds) the client will cache the resource.
-     * <p/>
+     * <p>
      * Note: Do not set this for private resources, as it will cause a Cache-Control: public
      * to be sent.
-     * <p/>
+     * <p>
      * TODO: make this more flexible
-     * <p/>
+     * <p>
      * This will only be used if the {@link #cachable} predicate returns true
      */
     private volatile Integer cacheTime;

File: core/src/main/java/io/undertow/server/protocol/http/HttpResponseConduit.java
Patch:
@@ -109,7 +109,7 @@ void reset(HttpServerExchange exchange) {
      * Handles writing out the header data. It can also take a byte buffer of user
      * data, to enable both user data and headers to be written out in a single operation,
      * which has a noticeable performance impact.
-     * <p/>
+     * <p>
      * It is up to the caller to note the current position of this buffer before and after they
      * call this method, and use this to figure out how many bytes (if any) have been written.
      *

File: core/src/main/java/io/undertow/server/protocol/http/HttpTransferEncoding.java
Patch:
@@ -42,7 +42,7 @@
 /**
  * Class that is  responsible for HTTP transfer encoding, this could be part of the {@link HttpReadListener},
  * but is separated out for clarity.
- * <p/>
+ * <p>
  * For more info see http://tools.ietf.org/html/rfc2616#section-4.4
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/server/protocol/http/ParseState.java
Patch:
@@ -22,7 +22,7 @@
 
 /**
  * The current state of the tokenizer state machine. This class is mutable and not thread safe.
- * <p/>
+ * <p>
  * As the machine changes state this class is updated rather than allocating a new one each time.
  *
  * fields are not private to allow for efficient putfield / getfield access

File: core/src/main/java/io/undertow/util/ConnectionUtils.java
Patch:
@@ -46,7 +46,7 @@ private ConnectionUtils() {
 
     /**
      * Cleanly close a connection, by shutting down and flushing writes and then draining reads.
-     * <p/>
+     * <p>
      * If this fails the connection is forcibly closed.
      *
      * @param connection The connection

File: core/src/main/java/io/undertow/util/DateUtils.java
Patch:
@@ -47,7 +47,7 @@ public class DateUtils {
     /**
      * Thread local cache of this date format. This is technically a small memory leak, however
      * in practice it is fine, as it will only be used by server threads.
-     * <p/>
+     * <p>
      * This is the most common date format, which is why we cache it.
      */
     private static final ThreadLocal<SimpleDateFormat> RFC1123_PATTERN_FORMAT = new ThreadLocal<SimpleDateFormat>() {

File: core/src/main/java/io/undertow/util/QValueParser.java
Patch:
@@ -135,7 +135,7 @@ public static class QValueResult implements Comparable<QValueResult> {
 
         /**
          * we keep the qvalue as a string to avoid parsing the double.
-         * <p/>
+         * <p>
          * This should give both performance and also possible security improvements
          */
         private String qvalue = "1";

File: core/src/main/java/io/undertow/util/RedirectBuilder.java
Patch:
@@ -103,7 +103,7 @@ public static String redirect(final HttpServerExchange exchange, final String ne
 
     /**
      * perform URL encoding
-     * <p/>
+     * <p>
      * TODO: this whole thing is kinda crappy.
      *
      * @return

File: core/src/main/java/io/undertow/websockets/core/WebSocketFramePriority.java
Patch:
@@ -34,9 +34,9 @@ public class WebSocketFramePriority implements FramePriority<WebSocketChannel, S
 
     /**
      * Strict ordering queue. Makes sure that the initial frame for a stream is sent in the order that send() is called.
-     * <p/>
+     * <p>
      * Required to pass the autobahn test suite with no non-strict performance.
-     * <p/>
+     * <p>
      * TODO: provide a way to disable this.
      */
     private final Queue<StreamSinkFrameChannel> strictOrderQueue = new ConcurrentLinkedDeque<>();

File: core/src/main/java/io/undertow/websockets/extensions/ExtensionFunction.java
Patch:
@@ -26,12 +26,12 @@
 
 /**
  * Base interface for WebSocket Extensions implementation.
- * <p/>
+ * <p>
  * It interacts at the connection phase. It is responsible to apply extension's logic before to write and after to read to/from
  * a WebSocket Endpoint.
- * <p/>
+ * <p>
  * Several extensions can be present in a WebSocket Endpoint being executed in a chain pattern.
- * <p/>
+ * <p>
  * Extension state is stored per WebSocket connection.
  *
  * @author Lucas Ponce

File: core/src/main/java/io/undertow/websockets/extensions/PerMessageDeflateFunction.java
Patch:
@@ -37,11 +37,11 @@
 
 /**
  * Implementation of {@code permessage-deflate} WebSocket Extension.
- * <p/>
+ * <p>
  * This implementation supports parameters: {@code server_no_context_takeover, client_no_context_takeover} .
- * <p/>
+ * <p>
  * This implementation does not support parameters: {@code server_max_window_bits, client_max_window_bits} .
- * <p/>
+ * <p>
  * It uses the DEFLATE implementation algorithm packaged on {@link Deflater} and {@link Inflater} classes.
  *
  * @author Lucas Ponce

File: core/src/test/java/io/undertow/server/handlers/encoding/EncodingSelectionTestCase.java
Patch:
@@ -47,7 +47,7 @@ public class EncodingSelectionTestCase {
 
     /**
      * Tests encoding selection with no qvalue
-     * <p/>
+     * <p>
      * Also tests a lot of non standard formats for Accept-Encoding to make sure that
      * we are liberal in what we accept
      *

File: core/src/test/java/io/undertow/server/protocol/http/SimpleParserTestCase.java
Patch:
@@ -36,9 +36,9 @@
 
 /**
  * Basic test of the HTTP parser functionality.
- * <p/>
+ * <p>
  * This tests parsing the same basic request, over and over, with minor differences.
- * <p/>
+ * <p>
  *
  * @author Stuart Douglas
  */

File: core/src/test/java/io/undertow/server/security/AuthenticationTestBase.java
Patch:
@@ -317,7 +317,7 @@ protected static String getAuthHeader(final HttpString prefix, final Header[] va
 
     /**
      * A simple end of chain handler to set a header and cause the call to return.
-     * <p/>
+     * <p>
      * Reaching this handler is a sign the mechanism handlers have allowed the request through.
      */
     protected static class ResponseHandler implements HttpHandler {

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -302,7 +302,7 @@ private void handleExtensions(final DeploymentInfo deploymentInfo, final Servlet
 
     /**
      * sets up the outer security handlers.
-     * <p/>
+     * <p>
      * the handler that actually performs the access check happens later in the chain, it is not setup here
      *
      * @param initialHandler The handler to wrap with security handlers

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletPathMatches.java
Patch:
@@ -190,10 +190,10 @@ public void setWelcomePages(List<String> welcomePages) {
     /**
      * Sets up the handlers in the servlet chain. We setup a chain for every path + extension match possibility.
      * (i.e. if there a m path mappings and n extension mappings we have n*m chains).
-     * <p/>
+     * <p>
      * If a chain consists of only the default servlet then we add it as an async handler, so that resources can be
      * served up directly without using blocking operations.
-     * <p/>
+     * <p>
      * TODO: this logic is a bit convoluted at the moment, we should look at simplifying it
      */
     private ServletPathMatchesData setupServletChains() {

File: servlet/src/test/java/io/undertow/servlet/test/streams/ServletInputStreamEarlyCloseClientSideTestCase.java
Patch:
@@ -36,7 +36,7 @@
 
 /**
  * Tests the behaviour of the input stream when the connection is closed on the client side
- * <p/>
+ * <p>
  * https://issues.jboss.org/browse/WFLY-4827
  *
  * @author Stuart Douglas

File: servlet/src/test/java/io/undertow/servlet/test/wrapper/NonStandardResponseWrapper.java
Patch:
@@ -468,7 +468,7 @@ public String getHeader(String name) {
      * The default behaviour of this method is to call
      * {@link HttpServletResponse#getHeaders} on the wrapped response
      * object.
-     * <p/>
+     * <p>
      * <p>Any changes to the returned <code>Collection</code> must not
      * affect this <code>HttpServletResponseWrapper</code>.
      *
@@ -486,7 +486,7 @@ public Collection<String> getHeaders(String name) {
      * The default behaviour of this method is to call
      * {@link HttpServletResponse#getHeaderNames} on the wrapped response
      * object.
-     * <p/>
+     * <p>
      * <p>Any changes to the returned <code>Collection</code> must not
      * affect this <code>HttpServletResponseWrapper</code>.
      *

File: core/src/main/java/io/undertow/server/ExchangeCompletionListener.java
Patch:
@@ -22,7 +22,7 @@
  * Listener interface for events that are run at the completion of a request/response
  * cycle (i.e. when the request has been completely read, and the response has been fully written).
  *
- * At this point it is to late to modify the exchange further.
+ * At this point it is too late to modify the exchange further.
  *
  * Completion listeners are invoked in reverse order,
  *

File: servlet/src/main/java/io/undertow/servlet/spec/ServletOutputStreamImpl.java
Patch:
@@ -59,7 +59,7 @@
  * Once the write listener has been set operations must only be invoked on this stream from the write
  * listener callback. Attempting to invoke from a different thread will result in an IllegalStateException.
  * <p>
- * Async listener tasks are queued in the {@link AsyncContextImpl}. At most one lister can be active at
+ * Async listener tasks are queued in the {@link AsyncContextImpl}. At most one listener can be active at
  * one time, which simplifies the thread safety requirements.
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/attribute/RemoteObfuscatedIPAttribute.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * JBoss, Home of Professional Open Source.
- * Copyright 2014 Red Hat, Inc., and individual contributors
+ * Copyright 2019 Red Hat, Inc., and individual contributors
  * as indicated by the @author tags.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -368,7 +368,7 @@ private HttpHandler setupSecurityHandlers(HttpHandler initialHandler) {
                 FormEncodedDataDefinition formEncodedDataDefinition = new FormEncodedDataDefinition();
                 String reqEncoding = deploymentInfo.getDefaultRequestEncoding();
                 if(reqEncoding == null) {
-                    deploymentInfo.getDefaultEncoding();
+                    reqEncoding = deploymentInfo.getDefaultEncoding();
                 }
                 if (reqEncoding != null) {
                     formEncodedDataDefinition.setDefaultEncoding(reqEncoding);

File: core/src/main/java/io/undertow/server/protocol/http/AlpnOpenListener.java
Patch:
@@ -252,7 +252,6 @@ public SSLEngine apply(SSLEngine engine) {
                     if (fallbackProtocol != null) {
                         ListenerEntry listener = listeners.get(fallbackProtocol);
                         if (listener != null) {
-                            listener.listener.handleEvent(channel);
                             selectedALPNEngine.complete(null);
                             return engine;
                         }
@@ -271,7 +270,6 @@ public SSLEngine apply(SSLEngine engine) {
                     if (fallbackProtocol != null) {
                         ListenerEntry listener = listeners.get(fallbackProtocol);
                         if (listener != null) {
-                            listener.listener.handleEvent(channel);
                             selectedALPNEngine.complete(null);
                             return engine;
                         }

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -368,7 +368,7 @@ private HttpHandler setupSecurityHandlers(HttpHandler initialHandler) {
                 FormEncodedDataDefinition formEncodedDataDefinition = new FormEncodedDataDefinition();
                 String reqEncoding = deploymentInfo.getDefaultRequestEncoding();
                 if(reqEncoding == null) {
-                    deploymentInfo.getDefaultEncoding();
+                    reqEncoding = deploymentInfo.getDefaultEncoding();
                 }
                 if (reqEncoding != null) {
                     formEncodedDataDefinition.setDefaultEncoding(reqEncoding);

File: core/src/main/java/io/undertow/util/FlexBase64.java
Patch:
@@ -251,7 +251,7 @@ public static String encodeString(ByteBuffer source, boolean wrap) {
      * @return a new String representing the Base64url output
      */
     public static String encodeStringURL(ByteBuffer source, boolean wrap) {
-        return Encoder.encodeString(source, wrap, false);
+        return Encoder.encodeString(source, wrap, true);
     }
 
     /**

File: core/src/main/java/io/undertow/server/ExchangeCompletionListener.java
Patch:
@@ -22,7 +22,7 @@
  * Listener interface for events that are run at the completion of a request/response
  * cycle (i.e. when the request has been completely read, and the response has been fully written).
  *
- * At this point it is to late to modify the exchange further.
+ * At this point it is too late to modify the exchange further.
  *
  * Completion listeners are invoked in reverse order,
  *

File: core/src/main/java/io/undertow/server/handlers/URLDecodingHandler.java
Patch:
@@ -36,7 +36,7 @@
 /**
  * A handler that will decode the URL and query parameters to the specified charset.
  * <p>
- * If you are using this handler you must set the {@link io.undertow.UndertowOptions#DECODE_URL} parameter to false.
+ * This handler will not have any effect unless the {@link io.undertow.UndertowOptions#DECODE_URL} parameter is set to false.
  * <p>
  * This is not as efficient as using the parsers built in UTF-8 decoder. Unless you need to decode to something other
  * than UTF-8 you should rely on the parsers decoding instead.

File: core/src/main/java/io/undertow/server/handlers/URLDecodingHandler.java
Patch:
@@ -86,11 +86,11 @@ private static void decodeQueryString(HttpServerExchange exchange, String charse
         if (!exchange.getQueryString().isEmpty()) {
             final TreeMap<String, Deque<String>> newParams = new TreeMap<>();
             for (Map.Entry<String, Deque<String>> param : exchange.getQueryParameters().entrySet()) {
-                final Deque<String> newVales = new ArrayDeque<>(param.getValue().size());
+                final Deque<String> newValues = new ArrayDeque<>(param.getValue().size());
                 for (String val : param.getValue()) {
-                    newVales.add(URLUtils.decode(val, charset, true, true, sb));
+                    newValues.add(URLUtils.decode(val, charset, true, true, sb));
                 }
-                newParams.put(URLUtils.decode(param.getKey(), charset, true, true, sb), newVales);
+                newParams.put(URLUtils.decode(param.getKey(), charset, true, true, sb), newValues);
             }
             exchange.getQueryParameters().clear();
             exchange.getQueryParameters().putAll(newParams);

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -565,7 +565,7 @@ protected String testName(FrameworkMethod method) {
     public static void setRootHandler(HttpHandler handler) {
         if ((isProxy()) && !ajp) {
             //if we are testing HTTP proxy we always add the SSLHeaderHandler
-            //this allows the SSL information to be propagated to be backend
+            //this allows the SSL information to be propagated to the backend
             handler = new SSLHeaderHandler(new ProxyPeerAddressHandler(handler));
         }
         if (dump) {

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -565,7 +565,7 @@ protected String testName(FrameworkMethod method) {
     public static void setRootHandler(HttpHandler handler) {
         if ((isProxy()) && !ajp) {
             //if we are testing HTTP proxy we always add the SSLHeaderHandler
-            //this allows the SSL information to be propagated to be backend
+            //this allows the SSL information to be propagated to the backend
             handler = new SSLHeaderHandler(new ProxyPeerAddressHandler(handler));
         }
         if (dump) {

File: websockets-jsr/src/test/java/io/undertow/websockets/jsr/test/annotated/AnnotatedEndpointTest.java
Patch:
@@ -197,6 +197,7 @@ public void testIdleTimeout() throws Exception {
 
     @Test
     public void testCloseReason() throws Exception {
+        AnnotatedClientEndpoint.reset();
         MessageEndpoint.reset();
 
         Session session = deployment.connectToServer(AnnotatedClientEndpoint.class, new URI("ws://" + DefaultServer.getHostAddress("default") + ":" + DefaultServer.getHostPort("default") + "/ws/chat/Bob"));

File: servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java
Patch:
@@ -184,6 +184,7 @@ protected void doGet(final HttpServletRequest req, final HttpServletResponse res
                 return;
             }
             if (directoryListingEnabled) {
+                resp.setContentType("text/html");
                 StringBuilder output = DirectoryUtils.renderDirectoryListing(req.getRequestURI(), resource);
                 resp.getWriter().write(output.toString());
             } else {

File: servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java
Patch:
@@ -184,6 +184,7 @@ protected void doGet(final HttpServletRequest req, final HttpServletResponse res
                 return;
             }
             if (directoryListingEnabled) {
+                resp.setContentType("text/html");
                 StringBuilder output = DirectoryUtils.renderDirectoryListing(req.getRequestURI(), resource);
                 resp.getWriter().write(output.toString());
             } else {

File: core/src/main/java/io/undertow/server/DefaultByteBufferPool.java
Patch:
@@ -26,7 +26,6 @@
 import java.nio.ByteBuffer;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
@@ -41,7 +40,8 @@
 public class DefaultByteBufferPool implements ByteBufferPool {
 
     private final ThreadLocal<ThreadLocalData> threadLocalCache = new ThreadLocal<>();
-    private final List<WeakReference<ThreadLocalData>> threadLocalDataList = Collections.synchronizedList(new ArrayList<WeakReference<ThreadLocalData>>());
+    // Access requires synchronization on the threadLocalDataList instance
+    private final List<WeakReference<ThreadLocalData>> threadLocalDataList = new ArrayList<>();
     private final ConcurrentLinkedQueue<ByteBuffer> queue = new ConcurrentLinkedQueue<>();
 
     private final boolean direct;

File: core/src/main/java/io/undertow/server/handlers/resource/PathResource.java
Patch:
@@ -88,7 +88,7 @@ public List<Resource> list() {
         final List<Resource> resources = new ArrayList<>();
         try (DirectoryStream<Path> stream = Files.newDirectoryStream(file)) {
             for (Path child : stream) {
-                resources.add(new PathResource(child, manager, path + File.separator + child.getFileName().toString()));
+                resources.add(new PathResource(child, manager, path + file.getFileSystem().getSeparator() + child.getFileName().toString()));
             }
         } catch (IOException e) {
             throw new RuntimeException(e);

File: servlet/src/main/java/io/undertow/servlet/spec/AsyncContextImpl.java
Patch:
@@ -110,7 +110,6 @@ public AsyncContextImpl(final HttpServerExchange exchange, final ServletRequest
             @Override
             public void run() {
                 exchange.setDispatchExecutor(null);
-                initialRequestDone();
             }
         });
     }

File: core/src/main/java/io/undertow/server/handlers/resource/PathResource.java
Patch:
@@ -88,7 +88,7 @@ public List<Resource> list() {
         final List<Resource> resources = new ArrayList<>();
         try (DirectoryStream<Path> stream = Files.newDirectoryStream(file)) {
             for (Path child : stream) {
-                resources.add(new PathResource(child, manager, path + File.separator + child.getFileName().toString()));
+                resources.add(new PathResource(child, manager, path + file.getFileSystem().getSeparator() + child.getFileName().toString()));
             }
         } catch (IOException e) {
             throw new RuntimeException(e);

File: websockets-jsr/src/test/java/io/undertow/websockets/jsr/test/annotated/AnnotatedEndpointTest.java
Patch:
@@ -181,6 +181,7 @@ public void testIdleTimeout() throws Exception {
 
     @Test
     public void testCloseReason() throws Exception {
+        AnnotatedClientEndpoint.reset();
         MessageEndpoint.reset();
 
         Session session = deployment.connectToServer(AnnotatedClientEndpoint.class, new URI("ws://" + DefaultServer.getHostAddress("default") + ":" + DefaultServer.getHostPort("default") + "/ws/chat/Bob"));

File: core/src/main/java/io/undertow/server/DefaultByteBufferPool.java
Patch:
@@ -26,7 +26,6 @@
 import java.nio.ByteBuffer;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
@@ -41,7 +40,8 @@
 public class DefaultByteBufferPool implements ByteBufferPool {
 
     private final ThreadLocal<ThreadLocalData> threadLocalCache = new ThreadLocal<>();
-    private final List<WeakReference<ThreadLocalData>> threadLocalDataList = Collections.synchronizedList(new ArrayList<WeakReference<ThreadLocalData>>());
+    // Access requires synchronization on the threadLocalDataList instance
+    private final List<WeakReference<ThreadLocalData>> threadLocalDataList = new ArrayList<>();
     private final ConcurrentLinkedQueue<ByteBuffer> queue = new ConcurrentLinkedQueue<>();
 
     private final boolean direct;

File: core/src/main/java/io/undertow/server/Connectors.java
Patch:
@@ -467,7 +467,7 @@ public static void setExchangeRequestPath(final HttpServerExchange exchange, fin
                 URLUtils.parsePathParams(encodedPath.substring(i + 1), exchange, charset, decode, maxParameters);
                 return;
             } else if(c == '%' || c == '+') {
-                requiresDecode = true;
+                requiresDecode = decode;
             }
         }
 

File: core/src/main/java/io/undertow/server/Connectors.java
Patch:
@@ -467,7 +467,7 @@ public static void setExchangeRequestPath(final HttpServerExchange exchange, fin
                 URLUtils.parsePathParams(encodedPath.substring(i + 1), exchange, charset, decode, maxParameters);
                 return;
             } else if(c == '%' || c == '+') {
-                requiresDecode = true;
+                requiresDecode = decode;
             }
         }
 

File: core/src/main/java/io/undertow/util/MimeMappings.java
Patch:
@@ -53,7 +53,6 @@ public class MimeMappings {
         defaultMappings.put("tsv", "text/tab-separated-values");
         defaultMappings.put("etx", "text/x-setext");
         defaultMappings.put("json", "application/json");
-        defaultMappings.put("ps", "application/x-postscript");
         defaultMappings.put("class", "application/java");
         defaultMappings.put("csh", "application/x-csh");
         defaultMappings.put("sh", "application/x-sh");
@@ -125,6 +124,7 @@ public class MimeMappings {
         defaultMappings.put("avx", "video/x-rad-screenplay");
         defaultMappings.put("wrl", "x-world/x-vrml");
         defaultMappings.put("mpv2", "video/mpeg2");
+        defaultMappings.put("jnlp", "application/x-java-jnlp-file");
 
         defaultMappings.put("eot", "application/vnd.ms-fontobject");
         defaultMappings.put("woff", "application/font-woff");

File: core/src/test/java/io/undertow/server/protocol/ajp/AjpCharacterEncodingTestCase.java
Patch:
@@ -54,6 +54,7 @@ public class AjpCharacterEncodingTestCase {
     public static void setup() throws Exception {
         undertow = Undertow.builder()
                 .setServerOption(UndertowOptions.URL_CHARSET, "MS949")
+                .setServerOption(UndertowOptions.ALLOW_UNESCAPED_CHARACTERS_IN_URL, true)
                 .addListener(
                         new Undertow.ListenerBuilder()
                                 .setType(Undertow.ListenerType.AJP)

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -791,7 +791,9 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
 
     private static boolean isAlpnEnabled() {
         if (alpnEnabled == null) {
-            SSLEngine engine = getServerSslContext().createSSLEngine();
+            //we use the client context, as the server one is wrapped by a SNISSLEngine
+            //so we can't tell that ALPN is enabled or now
+            SSLEngine engine = getClientSSLContext().createSSLEngine();
             ALPNProvider provider = ALPNManager.INSTANCE.getProvider(engine);
             if (provider instanceof JettyAlpnProvider) {
                 alpnEnabled = System.getProperty("alpn-boot-string") != null;

File: servlet/src/test/java/io/undertow/servlet/test/dispatcher/DispatcherForwardTestCase.java
Patch:
@@ -42,6 +42,8 @@
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.client.methods.HttpPost;
 import org.junit.Assert;
+import org.junit.Assume;
+import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -76,8 +78,7 @@ public void logMessage(final String msg) {
     public static void setup() throws ServletException {
         //we don't run this test on h2 upgrade, as if it is run with the original request
         //the protocols will not match
-        Assert.assertFalse(DefaultServer.isH2upgrade());
-
+        Assume.assumeFalse(DefaultServer.isH2upgrade());
         final PathHandler root = new PathHandler();
         final ServletContainer container = ServletContainer.Factory.newInstance();
 

File: core/src/main/java/io/undertow/protocols/alpn/JDK9AlpnProvider.java
Patch:
@@ -49,7 +49,7 @@ public JDK9ALPNMethods run() {
                     UndertowLogger.ROOT_LOGGER.debug("Using JDK9 ALPN");
                     return new JDK9ALPNMethods(setApplicationProtocols, getApplicationProtocol);
                 } catch (Exception e) {
-                    UndertowLogger.ROOT_LOGGER.debug("JDK9 ALPN not supported", e);
+                    UndertowLogger.ROOT_LOGGER.debug("JDK9 ALPN not supported");
                     return null;
                 }
             }

File: servlet/src/test/java/io/undertow/servlet/test/streams/ServletInputStreamRequestBufferingTestCase.java
Patch:
@@ -18,6 +18,8 @@
 
 package io.undertow.servlet.test.streams;
 
+import javax.servlet.ServletContext;
+
 import io.undertow.server.handlers.RequestBufferingHandler;
 import io.undertow.servlet.ServletExtension;
 import io.undertow.servlet.api.DeploymentInfo;
@@ -27,8 +29,6 @@
 import org.junit.BeforeClass;
 import org.junit.runner.RunWith;
 
-import javax.servlet.ServletContext;
-
 /**
  * @author Carter Kozak
  */

File: examples/src/main/java/io/undertow/examples/websockets_extension/WebSocketServer.java
Patch:
@@ -36,7 +36,7 @@
 /**
  * @author Stuart Douglas
  */
-@UndertowExample("Web Sockets")
+@UndertowExample("Web Socket Extensions")
 public class WebSocketServer {
 
     public static void main(final String[] args) {

File: core/src/main/java/io/undertow/protocols/alpn/JettyAlpnProvider.java
Patch:
@@ -120,7 +120,6 @@ private ALPNClientSelectionProvider(List<String> protocols, SSLEngine sslEngine)
             this.sslEngine = sslEngine;
         }
 
-        @Override
         public boolean supports() {
             return true;
         }

File: core/src/main/java/io/undertow/protocols/alpn/JettyAlpnProvider.java
Patch:
@@ -120,7 +120,6 @@ private ALPNClientSelectionProvider(List<String> protocols, SSLEngine sslEngine)
             this.sslEngine = sslEngine;
         }
 
-        @Override
         public boolean supports() {
             return true;
         }

File: servlet/src/test/java/io/undertow/servlet/test/listener/servletcontext/ServletContextListenerTestCase.java
Patch:
@@ -59,7 +59,7 @@ public static void setup() throws ServletException {
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
-                .addServletContainerInitalizer(new ServletContainerInitializerInfo(TestSci.class, Collections.<Class<?>>emptySet()))
+                .addServletContainerInitializer(new ServletContainerInitializerInfo(TestSci.class, Collections.<Class<?>>emptySet()))
                 .addServlet(
                         new ServletInfo("servlet", MessageServlet.class)
                                 .addMapping("/aa")

File: servlet/src/test/java/io/undertow/servlet/test/listener/servletcontext/ServletContextListenerTestCase.java
Patch:
@@ -59,7 +59,7 @@ public static void setup() throws ServletException {
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
-                .addServletContainerInitalizer(new ServletContainerInitializerInfo(TestSci.class, Collections.<Class<?>>emptySet()))
+                .addServletContainerInitializer(new ServletContainerInitializerInfo(TestSci.class, Collections.<Class<?>>emptySet()))
                 .addServlet(
                         new ServletInfo("servlet", MessageServlet.class)
                                 .addMapping("/aa")

File: core/src/main/java/io/undertow/conduits/DeflatingStreamSinkConduit.java
Patch:
@@ -106,7 +106,7 @@ public static ObjectPool<Deflater> newInstanceDeflaterPool(int deflateLevel) {
     }
 
     public static ObjectPool<Deflater> simpleDeflaterPool(int poolSize, int deflateLevel) {
-        return new SimpleObjectPool<Deflater>(poolSize, () -> new Deflater(deflateLevel, true), Deflater::end);
+        return new SimpleObjectPool<Deflater>(poolSize, () -> new Deflater(deflateLevel, true), Deflater::reset, Deflater::end);
     }
 
 

File: core/src/main/java/io/undertow/conduits/InflatingStreamSourceConduit.java
Patch:
@@ -81,7 +81,7 @@ public static ObjectPool<Inflater> newInstanceInflaterPool() {
     }
 
     public static ObjectPool<Inflater> simpleInflaterPool(int poolSize) {
-        return new SimpleObjectPool<Inflater>(poolSize, () -> new Inflater(true), Inflater::end);
+        return new SimpleObjectPool<Inflater>(poolSize, () -> new Inflater(true), Inflater::reset, Inflater::end);
     }
 
     @Override

File: servlet/src/main/java/io/undertow/servlet/UndertowServletLogger.java
Patch:
@@ -67,7 +67,7 @@ public interface UndertowServletLogger extends BasicLogger {
 
     @LogMessage(level = ERROR)
     @Message(id = 15005, value = "Error invoking method %s on listener %s")
-    void errorInvokingListener(final String method, Class<?> listenerClass, @Cause Exception e);
+    void errorInvokingListener(final String method, Class<?> listenerClass, @Cause Throwable t);
 
     @LogMessage(level = ERROR)
     @Message(id = 15006, value = "IOException dispatching async event")
@@ -119,7 +119,7 @@ public interface UndertowServletLogger extends BasicLogger {
 
     @LogMessage(level = ERROR)
     @Message(id = 15019, value = "Failed to destroy %s")
-    void failedToDestroy(Object object, @Cause Exception e);
+    void failedToDestroy(Object object, @Cause Throwable t);
 
     @LogMessage(level = WARN)
     @Message(id = 15020, value = "Path %s is secured for some HTTP methods, however it is not secured for %s")

File: servlet/src/main/java/io/undertow/servlet/core/ApplicationListeners.java
Patch:
@@ -200,8 +200,8 @@ public void contextDestroyed() {
             ManagedListener listener = servletContextListeners[i];
             try {
                 this.<ServletContextListener>get(listener).contextDestroyed(event);
-            } catch (Exception e) {
-                UndertowServletLogger.REQUEST_LOGGER.errorInvokingListener("contextDestroyed", listener.getListenerInfo().getListenerClass(), e);
+            } catch (Throwable t) {
+                UndertowServletLogger.REQUEST_LOGGER.errorInvokingListener("contextDestroyed", listener.getListenerInfo().getListenerClass(), t);
             }
         }
     }

File: core/src/main/java/io/undertow/server/ConnectorStatisticsImpl.java
Patch:
@@ -143,7 +143,7 @@ public void setup(HttpServerExchange exchange) {
         do {
             maxActiveRequests = this.maxActiveRequests;
             if(current <= maxActiveRequests) {
-                return;
+                break;
             }
         } while (!maxActiveRequestsUpdater.compareAndSet(this, maxActiveRequests, current));
         exchange.addExchangeCompleteListener(completionListener);

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletChain.java
Patch:
@@ -61,6 +61,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                             if(!initDone) {
                                 ServletRequestContext src = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY);
                                 forceInit(src.getDispatcherType());
+                                initDone = true;
                             }
                         }
                     }

File: core/src/main/java/io/undertow/server/protocol/http2/Http2UpgradeHandler.java
Patch:
@@ -76,7 +76,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
         final String settings = exchange.getRequestHeaders().getFirst("HTTP2-Settings");
         if(settings != null && upgrade != null
                 && upgradeStrings.contains(upgrade)) {
-            if(HttpContinue.requiresContinueResponse(exchange)) {
+            if(HttpContinue.requiresContinueResponse(exchange) && false) {
                 HttpContinue.sendContinueResponse(exchange, new IoCallback() {
                     @Override
                     public void onComplete(HttpServerExchange exchange, Sender sender) {

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -241,7 +241,7 @@ public HttpServletMapping getHttpServletMapping() {
                 break;
             case DEFAULT:
             case CONTEXT_ROOT:
-                matchValue = "\"\""; //blegh
+                matchValue = "";
                 break;
             case PATH:
                 matchValue = match.getRemaining();

File: servlet/src/main/java/io/undertow/servlet/spec/PushBuilderImpl.java
Patch:
@@ -53,7 +53,6 @@ public class PushBuilderImpl implements PushBuilder {
         ignore.add(Headers.RANGE);
         ignore.add(Headers.ACCEPT_RANGES);
         ignore.add(Headers.EXPECT);
-        ignore.add(Headers.AUTHORIZATION);
         ignore.add(Headers.REFERER);
         IGNORE = Collections.unmodifiableSet(ignore);
 

File: servlet/src/test/java/io/undertow/servlet/test/path/MappingTestCase.java
Patch:
@@ -76,15 +76,15 @@ public void testGetMapping() throws IOException {
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
             response = HttpClientUtils.readResponse(result);
             Assert.assertEquals("Mapping match:CONTEXT_ROOT\n" +
-                    "Match value:\"\"\n" +
+                    "Match value:\n" +
                     "Pattern:", response);
 
             get = new HttpGet(DefaultServer.getDefaultServerURL() + "/servletContext/doesnotexist");
             result = client.execute(get);
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
             response = HttpClientUtils.readResponse(result);
             Assert.assertEquals("Mapping match:DEFAULT\n" +
-                    "Match value:\"\"\n" +
+                    "Match value:\n" +
                     "Pattern:/", response);
 
             get = new HttpGet(DefaultServer.getDefaultServerURL() + "/servletContext/exact");

File: core/src/main/java/io/undertow/server/protocol/http/HttpResponseConduit.java
Patch:
@@ -294,8 +294,9 @@ private static void writeString(ByteBuffer buffer, String string) {
         int length = string.length();
         for (int charIndex = 0; charIndex < length; charIndex++) {
             char c = string.charAt(charIndex);
-            if(c != '\r' && c != '\n') {
-                buffer.put((byte) c);
+            byte b = (byte) c;
+            if(b != '\r' && b != '\n') {
+                buffer.put(b);
             } else {
                 buffer.put((byte) ' ');
             }

File: core/src/main/java/io/undertow/server/DefaultByteBufferPool.java
Patch:
@@ -149,7 +149,9 @@ public PooledByteBuffer allocate() {
             }
         }
         if(local != null) {
-            local.allocationDepth++;
+            if(local.allocationDepth < threadLocalCacheSize) { //prevent overflow if the thread only allocates and never frees
+                local.allocationDepth++;
+            }
         }
         buffer.clear();
         return new DefaultPooledBuffer(this, buffer, leakDectionPercent == 0 ? false : (++count % 100 < leakDectionPercent));

File: core/src/main/java/io/undertow/util/FastConcurrentDirectDeque.java
Patch:
@@ -1647,7 +1647,7 @@ private boolean casTail(Node<E> cmp, Node<E> val) {
 
     private static Unsafe getUnsafe() {
         if (System.getSecurityManager() != null) {
-            AccessController.doPrivileged(new PrivilegedAction<Unsafe>() {
+            return AccessController.doPrivileged(new PrivilegedAction<Unsafe>() {
                 public Unsafe run() {
                     return getUnsafe0();
                 }

File: core/src/main/java/io/undertow/util/FastConcurrentDirectDeque.java
Patch:
@@ -1647,7 +1647,7 @@ private boolean casTail(Node<E> cmp, Node<E> val) {
 
     private static Unsafe getUnsafe() {
         if (System.getSecurityManager() != null) {
-            AccessController.doPrivileged(new PrivilegedAction<Unsafe>() {
+            return AccessController.doPrivileged(new PrivilegedAction<Unsafe>() {
                 public Unsafe run() {
                     return getUnsafe0();
                 }

File: core/src/main/java/io/undertow/protocols/ssl/SslConduit.java
Patch:
@@ -806,20 +806,20 @@ private long doUnwrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcep
                     doWrap(null, 0, 0);
                     flush();
                 } catch (Exception e2) {
-                    UndertowLogger.REQUEST_LOGGER.debug("Failed to write out final SSL record", e);
+                    UndertowLogger.REQUEST_LOGGER.debug("Failed to write out final SSL record", e2);
                 }
                 close();
             } catch (Throwable ex) {
                 //we ignore this
-                UndertowLogger.REQUEST_LOGGER.debug("Exception closing SSLConduit after exception in doUnwrap", e);
+                UndertowLogger.REQUEST_LOGGER.debug("Exception closing SSLConduit after exception in doUnwrap", ex);
             }
             throw e;
         } catch (RuntimeException|IOException|Error e) {
             try {
                 close();
             } catch (Throwable ex) {
                 //we ignore this
-                UndertowLogger.REQUEST_LOGGER.debug("Exception closing SSLConduit after exception in doUnwrap", e);
+                UndertowLogger.REQUEST_LOGGER.debug("Exception closing SSLConduit after exception in doUnwrap", ex);
             }
             throw e;
         } finally {

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -55,6 +55,8 @@
 import io.undertow.util.RedirectBuilder;
 import io.undertow.util.StatusCodes;
 
+import static io.undertow.util.URLUtils.isAbsoluteUrl;
+
 
 /**
  * @author Stuart Douglas
@@ -189,7 +191,7 @@ public void sendRedirect(final String location) throws IOException {
         resetBuffer();
         setStatus(StatusCodes.FOUND);
         String realPath;
-        if (location.contains("://")) {//absolute url
+        if (isAbsoluteUrl(location)) {//absolute url
             exchange.getResponseHeaders().put(Headers.LOCATION, location);
         } else {
             if (location.startsWith("/")) {

File: core/src/main/java/io/undertow/client/http/HttpClientConnection.java
Patch:
@@ -437,8 +437,10 @@ private void handleError(Throwable exception) {
     }
     private void handleError(IOException exception) {
         UndertowLogger.REQUEST_IO_LOGGER.ioException(exception);
-        safeClose(connection);
         currentRequest.setFailed(exception);
+        currentRequest = null;
+        pendingResponse = null;
+        safeClose(connection);
     }
 
     public StreamConnection performUpgrade() throws IOException {

File: core/src/main/java/io/undertow/util/BadRequestException.java
Patch:
@@ -25,6 +25,9 @@
  */
 public class BadRequestException extends Exception {
 
+    public BadRequestException() {
+    }
+
     public BadRequestException(String message) {
         super(message);
     }

File: core/src/test/java/io/undertow/client/http/ResponseParserResumeTestCase.java
Patch:
@@ -19,6 +19,7 @@
 package io.undertow.client.http;
 
 import io.undertow.testutils.category.UnitTest;
+import io.undertow.util.BadRequestException;
 import io.undertow.util.HttpString;
 import io.undertow.util.Protocols;
 import io.undertow.util.StatusCodes;
@@ -51,7 +52,7 @@ public void testMethodSplit() {
     }
 
     @Test
-    public void testOneCharacterAtATime() {
+    public void testOneCharacterAtATime() throws BadRequestException {
         byte[] in = DATA.getBytes();
         final ResponseParseState context = new ResponseParseState();
         HttpResponseBuilder result = new HttpResponseBuilder();
@@ -64,7 +65,7 @@ public void testOneCharacterAtATime() {
         runAssertions(result, context);
     }
 
-    private void testResume(final int split, byte[] in) {
+    private void testResume(final int split, byte[] in) throws BadRequestException {
         final ResponseParseState context = new ResponseParseState();
         HttpResponseBuilder result = new HttpResponseBuilder();
         ByteBuffer buffer = ByteBuffer.wrap(in);

File: parser-generator/src/main/java/io/undertow/annotationprocessor/RequestParserGenerator.java
Patch:
@@ -50,9 +50,9 @@ public RequestParserGenerator(String existingClassName) {
     }
 
     protected void createStateMachines(final String[] httpVerbs, final String[] httpVersions, final String[] standardHeaders, final String className, final ClassFile file, final ClassMethod sctor, final AtomicInteger fieldCounter) {
-        createStateMachine(httpVerbs, className, file, sctor, fieldCounter, HANDLE_HTTP_VERB, new VerbStateMachine());
-        createStateMachine(httpVersions, className, file, sctor, fieldCounter, HANDLE_HTTP_VERSION, new VersionStateMachine());
-        createStateMachine(standardHeaders, className, file, sctor, fieldCounter, HANDLE_HEADER, new HeaderStateMachine());
+        createStateMachine(httpVerbs, className, file, sctor, fieldCounter, HANDLE_HTTP_VERB, new VerbStateMachine(), false);
+        createStateMachine(httpVersions, className, file, sctor, fieldCounter, HANDLE_HTTP_VERSION, new VersionStateMachine(), true);
+        createStateMachine(standardHeaders, className, file, sctor, fieldCounter, HANDLE_HEADER, new HeaderStateMachine(), false);
     }
 
 

File: parser-generator/src/main/java/io/undertow/annotationprocessor/ResponseParserGenerator.java
Patch:
@@ -52,8 +52,8 @@ public ResponseParserGenerator(String existingClassName) {
     @Override
     protected void createStateMachines(final String[] httpVerbs, final String[] httpVersions, final String[] standardHeaders, final String className, final ClassFile file, final ClassMethod sctor, final AtomicInteger fieldCounter) {
 
-        createStateMachine(httpVersions, className, file, sctor, fieldCounter, HANDLE_HTTP_VERSION, new VersionStateMachine());
-        createStateMachine(standardHeaders, className, file, sctor, fieldCounter, HANDLE_HEADER, new HeaderStateMachine());
+        createStateMachine(httpVersions, className, file, sctor, fieldCounter, HANDLE_HTTP_VERSION, new VersionStateMachine(), false);
+        createStateMachine(standardHeaders, className, file, sctor, fieldCounter, HANDLE_HEADER, new HeaderStateMachine(), false);
     }
 
     private static class HeaderStateMachine implements CustomStateMachine {

File: core/src/main/java/io/undertow/attribute/SecureExchangeAttribute.java
Patch:
@@ -25,7 +25,7 @@
  */
 public class SecureExchangeAttribute implements ExchangeAttribute {
 
-    public static final String TOKEN = "${SECURE}";
+    public static final String TOKEN = "%{SECURE}";
     public static final ExchangeAttribute INSTANCE = new SecureExchangeAttribute();
 
     @Override

File: core/src/test/java/io/undertow/server/handlers/file/PreCompressedResourceTestCase.java
Patch:
@@ -75,7 +75,7 @@ public void testContentEncodedResource() throws IOException, URISyntaxException
             final String compressedResource = HttpClientUtils.readResponse(result);
             headers = result.getHeaders(Headers.CONTENT_TYPE_STRING);
             Assert.assertEquals("text/html", headers[0].getValue());
-            Assert.assertEquals(nonCompressedResource, compressedResource);
+            Assert.assertEquals(nonCompressedResource.replace("\r", ""), compressedResource.replace("\r", "")); //ignore line ending differences
             Assert.assertEquals("gzip", result.getFirstHeader(Headers.CONTENT_ENCODING_STRING).getValue());
 
         } finally {

File: core/src/main/java/io/undertow/attribute/LocalServerNameAttribute.java
Patch:
@@ -19,7 +19,6 @@
 package io.undertow.attribute;
 
 import io.undertow.server.HttpServerExchange;
-import io.undertow.util.Headers;
 
 /**
  * The local server name

File: servlet/src/main/java/io/undertow/servlet/UndertowServletMessages.java
Patch:
@@ -226,4 +226,7 @@ public interface UndertowServletMessages {
 
     @Message(id = 10060, value = "Trailers not supported for this request due to %s")
     IllegalStateException trailersNotSupported(String reason);
+
+    @Message(id = 10061, value = "Invalid method for push request %s")
+    IllegalArgumentException invalidMethodForPushRequest(String method);
 }

File: servlet/src/main/java/io/undertow/servlet/UndertowServletMessages.java
Patch:
@@ -223,4 +223,7 @@ public interface UndertowServletMessages {
 
     @Message(id = 10059, value = "Param %s cannot be null")
     NullPointerException paramCannotBeNullNPE(String name);
+
+    @Message(id = 10060, value = "Trailers not supported for this request due to %s")
+    IllegalStateException trailersNotSupported(String reason);
 }

File: servlet/src/main/java/io/undertow/servlet/UndertowServletMessages.java
Patch:
@@ -217,4 +217,7 @@ public interface UndertowServletMessages {
 
     @Message(id = 10057, value = "multipart config was not present on Servlet")
     IllegalStateException multipartConfigNotPresent();
+
+    @Message(id = 10058, value = "Servlet name cannot be null")
+    IllegalArgumentException servletNameNull();
 }

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpRequestParseState.java
Patch:
@@ -143,7 +143,7 @@ InetSocketAddress createDestinationAddress() {
     }
 
     public void addStringByte(byte b) {
-        currentString.append((char)b);
+        currentString.append((char)(b & 0xFF));
     }
 
     public String getStringAndClear() throws UnsupportedEncodingException {

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpRequestParser.java
Patch:
@@ -535,7 +535,7 @@ protected StringHolder parseString(ByteBuffer buf, AjpRequestParseState state, S
 
         if (buf.hasRemaining()) {
             buf.get(); //null terminator
-            String value = state.getStringAndClear(encoding);
+            String value = state.getStringAndClear();
             state.stringLength = -1;
             state.containsUrlCharacters = false;
             return new StringHolder(value, true, containsUrlCharacters);

File: core/src/main/java/io/undertow/Undertow.java
Patch:
@@ -169,7 +169,7 @@ public synchronized void start() {
                     AcceptingChannel<? extends StreamConnection> server = worker.createStreamConnectionServer(new InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), acceptListener, socketOptionsWithOverrides);
                     server.resumeAccepts();
                     channels.add(server);
-                    listenerInfo.add(new ListenerInfo("ajp", server.getLocalAddress(), openListener, null, channel));
+                    listenerInfo.add(new ListenerInfo("ajp", server.getLocalAddress(), openListener, null, server));
                 } else {
                     OptionMap undertowOptions = OptionMap.builder().set(UndertowOptions.BUFFER_PIPELINED_DATA, true).addAll(serverOptions).getMap();
                     boolean http2 = serverOptions.get(UndertowOptions.ENABLE_HTTP2, false);
@@ -192,7 +192,7 @@ public synchronized void start() {
                         AcceptingChannel<? extends StreamConnection> server = worker.createStreamConnectionServer(new InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), acceptListener, socketOptionsWithOverrides);
                         server.resumeAccepts();
                         channels.add(server);
-                        listenerInfo.add(new ListenerInfo("http", server.getLocalAddress(), openListener, null, channel));
+                        listenerInfo.add(new ListenerInfo("http", server.getLocalAddress(), openListener, null, server));
                     } else if (listener.type == ListenerType.HTTPS) {
                         OpenListener openListener;
 
@@ -236,7 +236,7 @@ public synchronized void start() {
 
                         sslServer.resumeAccepts();
                         channels.add(sslServer);
-                        listenerInfo.add(new ListenerInfo("https", sslServer.getLocalAddress(), openListener, xnioSsl, channel));
+                        listenerInfo.add(new ListenerInfo("https", sslServer.getLocalAddress(), openListener, xnioSsl, sslServer));
                     }
                 }
 

File: core/src/main/java/io/undertow/server/handlers/SecureCookieHandler.java
Patch:
@@ -28,6 +28,9 @@
 import io.undertow.server.ResponseCommitListener;
 import io.undertow.server.handlers.builder.HandlerBuilder;
 
+/**
+ * Handler that will set the secure flag on all cookies that are received over a secure connection
+ */
 public class SecureCookieHandler implements HttpHandler {
 
     public static final HandlerWrapper WRAPPER = new HandlerWrapper() {

File: core/src/main/java/io/undertow/Undertow.java
Patch:
@@ -430,7 +430,7 @@ private Builder() {
                 //use 16k buffers for best performance
                 //as 16k is generally the max amount of data that can be sent in a single write() call
                 directBuffers = true;
-                bufferSize = 1024 * 16;
+                bufferSize = 1024 * 16 - 20; //the 20 is to allow some space for protocol headers, see UNDERTOW-1209
             }
 
         }

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -113,7 +113,7 @@ public class DefaultServer extends BlockJUnit4ClassRunner {
     private static final int PROXY_OFFSET = 1111;
     public static final int APACHE_PORT = 9080;
     public static final int APACHE_SSL_PORT = 9443;
-    public static final int BUFFER_SIZE = Integer.getInteger("test.bufferSize", 8192 * 3);
+    public static final int BUFFER_SIZE = Integer.getInteger("test.bufferSize", 1024 * 16 - 20);
     public static final DebuggingSlicePool SSL_BUFFER_POOL = new DebuggingSlicePool(new DefaultByteBufferPool(true, 17 * 1024));
 
     private static boolean first = true;

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/ModCluster.java
Patch:
@@ -201,7 +201,7 @@ public static class Builder {
 
         // Fairly restrictive connection pool defaults
         private int maxConnections = 16;
-        private int cacheConnections = 8;
+        private int cacheConnections = 1;
         private int requestQueueSize = 0;
         private boolean queueNewRequests = false;
 

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/ModCluster.java
Patch:
@@ -206,7 +206,7 @@ public static class Builder {
         private boolean queueNewRequests = false;
 
         private int maxRequestTime = -1;
-        private long ttl;
+        private long ttl = TimeUnit.SECONDS.toMillis(60);
         private boolean useAlias = false;
 
         private NodeHealthChecker healthChecker = NodeHealthChecker.NO_CHECK;

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/NodeConfig.java
Patch:
@@ -243,9 +243,9 @@ public static class NodeBuilder {
         private int maxConnections;
         private int cacheConnections;
         private int requestQueueSize;
-        private boolean queueNewRequests = false;
+        private boolean queueNewRequests;
 
-        private long ttl = 60000;
+        private long ttl;
         private int timeout = 0;
         private int waitWorker = -1;
 

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/ModCluster.java
Patch:
@@ -206,7 +206,7 @@ public static class Builder {
         private boolean queueNewRequests = false;
 
         private int maxRequestTime = -1;
-        private long ttl;
+        private long ttl = TimeUnit.SECONDS.toMillis(60);
         private boolean useAlias = false;
 
         private NodeHealthChecker healthChecker = NodeHealthChecker.NO_CHECK;

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/NodeConfig.java
Patch:
@@ -243,9 +243,9 @@ public static class NodeBuilder {
         private int maxConnections;
         private int cacheConnections;
         private int requestQueueSize;
-        private boolean queueNewRequests = false;
+        private boolean queueNewRequests;
 
-        private long ttl = 60000;
+        private long ttl;
         private int timeout = 0;
         private int waitWorker = -1;
 

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/ModCluster.java
Patch:
@@ -201,7 +201,7 @@ public static class Builder {
 
         // Fairly restrictive connection pool defaults
         private int maxConnections = 16;
-        private int cacheConnections = 8;
+        private int cacheConnections = 1;
         private int requestQueueSize = 0;
         private boolean queueNewRequests = false;
 

File: core/src/main/java/io/undertow/protocols/ajp/AjpClientChannel.java
Patch:
@@ -177,6 +177,9 @@ protected void closeSubChannels() {
 
     @Override
     protected Collection<AbstractFramedStreamSourceChannel<AjpClientChannel, AbstractAjpClientStreamSourceChannel, AbstractAjpClientStreamSinkChannel>> getReceivers() {
+        if(source == null) {
+            return Collections.emptyList();
+        }
         return Collections.<AbstractFramedStreamSourceChannel<AjpClientChannel, AbstractAjpClientStreamSourceChannel, AbstractAjpClientStreamSinkChannel>>singleton(source);
     }
 

File: core/src/main/java/io/undertow/websockets/core/WebSocketChannel.java
Patch:
@@ -115,6 +115,9 @@ public void handleEvent(WebSocketChannel channel) {
 
     @Override
     protected Collection<AbstractFramedStreamSourceChannel<WebSocketChannel, StreamSourceFrameChannel, StreamSinkFrameChannel>> getReceivers() {
+        if(fragmentedChannel == null) {
+            return Collections.emptyList();
+        }
         return Collections.<AbstractFramedStreamSourceChannel<WebSocketChannel, StreamSourceFrameChannel, StreamSinkFrameChannel>>singleton(fragmentedChannel);
     }
 

File: core/src/main/java/io/undertow/server/DefaultByteBufferPool.java
Patch:
@@ -152,7 +152,7 @@ public PooledByteBuffer allocate() {
             local.allocationDepth++;
         }
         buffer.clear();
-        return new DefaultPooledBuffer(this, buffer, leakDectionPercent == 0 ? false : (++count % 100 > leakDectionPercent));
+        return new DefaultPooledBuffer(this, buffer, leakDectionPercent == 0 ? false : (++count % 100 < leakDectionPercent));
     }
 
     @Override

File: core/src/main/java/io/undertow/protocols/http2/Http2DataStreamSinkChannel.java
Patch:
@@ -203,6 +203,8 @@ protected SendFrameHeader createFrameHeaderImpl() {
                 currentBuffer.put((byte) (dataPaddingBytes & 0xFF));
                 trailer = ByteBuffer.allocate(dataPaddingBytes);
             }
+        } else if(finalFrame && trailers != null) {
+            requiresTrailers = true;
         }
 
         if (requiresTrailers) {

File: core/src/main/java/io/undertow/client/ALPNClientSelector.java
Patch:
@@ -101,7 +101,8 @@ public void handleEvent(StreamSourceChannel channel) {
                                 fallback.handleEvent(sslConnection);
                                 return;
                             }
-                        } catch (IOException e) {
+                        } catch (Throwable t) {
+                            IOException e = t instanceof IOException ? (IOException) t : new IOException(t);
                             failedListener.failed(e);
                         }
                     }

File: core/src/main/java/io/undertow/client/ajp/AjpClientConnection.java
Patch:
@@ -271,8 +271,8 @@ private void initiateRequest(AjpClientExchange AjpClientExchange) {
                 if (!sinkChannel.flush()) {
                     handleFailedFlush(sinkChannel);
                 }
-            } catch (IOException e) {
-                handleError(e);
+            } catch (Throwable t) {
+                handleError((t instanceof IOException) ? (IOException) t : new IOException(t));
             }
         }
     }
@@ -358,7 +358,7 @@ public void handleEvent(AjpClientChannel channel) {
                     Channels.drain(result, Long.MAX_VALUE);
                 }
 
-            } catch (Exception e) {
+            } catch (Throwable e) {
                 UndertowLogger.CLIENT_LOGGER.exceptionProcessingRequest(e);
                 safeClose(connection);
                 if(currentRequest != null) {

File: core/src/main/java/io/undertow/client/http/HttpClientProvider.java
Patch:
@@ -149,8 +149,8 @@ public void handleEvent(SslConnection connection) {
             if(connection instanceof SslConnection) {
                 try {
                     ((SslConnection) connection).startHandshake();
-                } catch (IOException e) {
-                    listener.failed(e);
+                } catch (Throwable t) {
+                    listener.failed((t instanceof IOException) ? (IOException) t : new IOException(t));
                 }
             }
             listener.completed(new HttpClientConnection(connection, options, bufferPool));

File: core/src/main/java/io/undertow/conduits/AbstractFramedStreamSinkConduit.java
Patch:
@@ -161,13 +161,14 @@ private long doWrite(ByteBuffer[] additionalData, int offs, int len) throws IOEx
             }
             return toAllocate;
 
-        } catch (IOException e) {
+        } catch (IOException | RuntimeException | Error e) {
+            IOException ioe = e instanceof IOException ? (IOException) e : new IOException(e);
             //on exception we fail every item in the frame queue
             try {
                 for (Frame frame : frameQueue) {
                     FrameCallBack cb = frame.callback;
                     if (cb != null) {
-                        cb.failed(e);
+                        cb.failed(ioe);
                     }
                 }
                 frameQueue.clear();

File: core/src/main/java/io/undertow/conduits/InflatingStreamSourceConduit.java
Patch:
@@ -199,7 +199,7 @@ private void done() {
     public long transferTo(final long position, final long count, final FileChannel target) throws IOException {
         try {
             return target.transferFrom(new ConduitReadableByteChannel(this), position, count);
-        } catch (IOException | RuntimeException e) {
+        } catch (IOException | RuntimeException | Error e) {
             IoUtils.safeClose(exchange.getConnection());
             throw e;
         }
@@ -209,7 +209,7 @@ public long transferTo(final long position, final long count, final FileChannel
     public long transferTo(final long count, final ByteBuffer throughBuffer, final StreamSinkChannel target) throws IOException {
         try {
             return IoUtils.transfer(new ConduitReadableByteChannel(this), count, throughBuffer, target);
-        } catch (IOException | RuntimeException e) {
+        } catch (IOException | RuntimeException | Error e) {
             IoUtils.safeClose(exchange.getConnection());
             throw e;
         }

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedStreamSourceChannel.java
Patch:
@@ -529,7 +529,7 @@ public int read(ByteBuffer dst) throws IOException {
         } finally {
             try {
                 exitRead();
-            } catch (Exception e) {
+            } catch (Throwable e) {
                 markStreamBroken();
             }
         }
@@ -558,7 +558,7 @@ private void beforeRead() throws IOException {
                         this.currentDataOriginalSize = frameData.getBuffer().remaining();
                         try {
                             this.data = processFrameData(frameData, frameDataRemaining - currentDataOriginalSize == 0);
-                        } catch (Exception e) {
+                        } catch (Throwable e) {
                             frameData.close();
                             UndertowLogger.REQUEST_IO_LOGGER.ioException(new IOException(e));
                             markStreamBroken();
@@ -660,7 +660,7 @@ protected void markStreamBroken() {
             if(data != null) {
                 try {
                     data.close(); //may have been closed by the read thread
-                } catch (Exception e) {
+                } catch (Throwable e) {
                     //ignore
                 }
                 this.data = null;

File: core/src/main/java/io/undertow/server/protocol/http/AlpnOpenListener.java
Patch:
@@ -366,6 +366,9 @@ public void handleEvent(StreamSourceChannel source) {
             } catch (IOException e) {
                 UndertowLogger.REQUEST_IO_LOGGER.ioException(e);
                 IoUtils.safeClose(channel);
+            } catch (Throwable t) {
+                UndertowLogger.REQUEST_IO_LOGGER.handleUnexpectedFailure(t);
+                IoUtils.safeClose(channel);
             } finally {
                 if (free) {
                     buffer.close();

File: core/src/main/java/io/undertow/server/protocol/http/HttpOpenListener.java
Patch:
@@ -121,6 +121,9 @@ public void handleEvent(final StreamConnection channel, PooledByteBuffer buffer)
         } catch (IOException e) {
             IoUtils.safeClose(channel);
             UndertowLogger.REQUEST_IO_LOGGER.ioException(e);
+        } catch (Throwable t) {
+            IoUtils.safeClose(channel);
+            UndertowLogger.REQUEST_IO_LOGGER.handleUnexpectedFailure(t);
         }
         if(statisticsEnabled) {
             channel.getSinkChannel().setConduit(new BytesSentStreamSinkConduit(channel.getSinkChannel().getConduit(), connectorStatistics.sentAccumulator()));

File: core/src/main/java/io/undertow/server/protocol/http2/Http2ReceiveListener.java
Patch:
@@ -119,6 +119,9 @@ public void handleEvent(Http2Channel channel) {
         } catch (IOException e) {
             UndertowLogger.REQUEST_IO_LOGGER.ioException(e);
             IoUtils.safeClose(channel);
+        } catch (Throwable t) {
+            UndertowLogger.REQUEST_IO_LOGGER.handleUnexpectedFailure(t);
+            IoUtils.safeClose(channel);
         }
     }
 

File: servlet/src/main/java/io/undertow/servlet/spec/ServletInputStreamImpl.java
Patch:
@@ -309,7 +309,7 @@ public void handleEvent(final StreamSourceChannel channel) {
                 } else {
                     channel.resumeReads();
                 }
-            } catch (final RuntimeException|IOException e) {
+            } catch (final Throwable e) {
                 request.getServletContext().invokeRunnable(request.getExchange(), new Runnable() {
                     @Override
                     public void run() {

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedStreamSourceChannel.java
Patch:
@@ -529,7 +529,7 @@ public int read(ByteBuffer dst) throws IOException {
         } finally {
             try {
                 exitRead();
-            } catch (Exception e) {
+            } catch (Throwable e) {
                 markStreamBroken();
             }
         }
@@ -558,7 +558,7 @@ private void beforeRead() throws IOException {
                         this.currentDataOriginalSize = frameData.getBuffer().remaining();
                         try {
                             this.data = processFrameData(frameData, frameDataRemaining - currentDataOriginalSize == 0);
-                        } catch (Exception e) {
+                        } catch (Throwable e) {
                             frameData.close();
                             UndertowLogger.REQUEST_IO_LOGGER.ioException(new IOException(e));
                             markStreamBroken();
@@ -660,7 +660,7 @@ protected void markStreamBroken() {
             if(data != null) {
                 try {
                     data.close(); //may have been closed by the read thread
-                } catch (Exception e) {
+                } catch (Throwable e) {
                     //ignore
                 }
                 this.data = null;

File: core/src/main/java/io/undertow/server/protocol/http/AlpnOpenListener.java
Patch:
@@ -366,6 +366,9 @@ public void handleEvent(StreamSourceChannel source) {
             } catch (IOException e) {
                 UndertowLogger.REQUEST_IO_LOGGER.ioException(e);
                 IoUtils.safeClose(channel);
+            } catch (Throwable t) {
+                UndertowLogger.REQUEST_IO_LOGGER.handleUnexpectedFailure(t);
+                IoUtils.safeClose(channel);
             } finally {
                 if (free) {
                     buffer.close();

File: core/src/main/java/io/undertow/server/protocol/http/HttpOpenListener.java
Patch:
@@ -121,6 +121,9 @@ public void handleEvent(final StreamConnection channel, PooledByteBuffer buffer)
         } catch (IOException e) {
             IoUtils.safeClose(channel);
             UndertowLogger.REQUEST_IO_LOGGER.ioException(e);
+        } catch (Throwable t) {
+            IoUtils.safeClose(channel);
+            UndertowLogger.REQUEST_IO_LOGGER.handleUnexpectedFailure(t);
         }
         if(statisticsEnabled) {
             channel.getSinkChannel().setConduit(new BytesSentStreamSinkConduit(channel.getSinkChannel().getConduit(), connectorStatistics.sentAccumulator()));

File: core/src/main/java/io/undertow/server/protocol/http2/Http2ReceiveListener.java
Patch:
@@ -119,6 +119,9 @@ public void handleEvent(Http2Channel channel) {
         } catch (IOException e) {
             UndertowLogger.REQUEST_IO_LOGGER.ioException(e);
             IoUtils.safeClose(channel);
+        } catch (Throwable t) {
+            UndertowLogger.REQUEST_IO_LOGGER.handleUnexpectedFailure(t);
+            IoUtils.safeClose(channel);
         }
     }
 

File: servlet/src/main/java/io/undertow/servlet/spec/ServletInputStreamImpl.java
Patch:
@@ -309,7 +309,7 @@ public void handleEvent(final StreamSourceChannel channel) {
                 } else {
                     channel.resumeReads();
                 }
-            } catch (final RuntimeException|IOException e) {
+            } catch (final Throwable e) {
                 request.getServletContext().invokeRunnable(request.getExchange(), new Runnable() {
                     @Override
                     public void run() {

File: core/src/main/java/io/undertow/util/Cookies.java
Patch:
@@ -199,7 +199,7 @@ private static void handleValue(CookieImpl cookie, String key, String value) {
      * @see <a href="http://tools.ietf.org/search/rfc2109">rfc2109</a>
      */
     public static Map<String, Cookie> parseRequestCookies(int maxCookies, boolean allowEqualInValue, List<String> cookies) {
-        return parseRequestCookies(maxCookies, allowEqualInValue, cookies, LegacyCookieSupport.COMMA_IS_SEPERATOR);
+        return parseRequestCookies(maxCookies, allowEqualInValue, cookies, LegacyCookieSupport.COMMA_IS_SEPARATOR);
     }
 
     static Map<String, Cookie> parseRequestCookies(int maxCookies, boolean allowEqualInValue, List<String> cookies, boolean commaIsSeperator) {

File: core/src/main/java/io/undertow/util/LegacyCookieSupport.java
Patch:
@@ -56,7 +56,7 @@ public final class LegacyCookieSupport {
      * If set to true, the <code,</code> character will be treated as a
      * separator in Cookie: headers.
      */
-    static final boolean COMMA_IS_SEPERATOR = Boolean.getBoolean("io.undertow.legacy.cookie.COMMA_IS_SEPARATOR");
+    static final boolean COMMA_IS_SEPARATOR = Boolean.getBoolean("io.undertow.legacy.cookie.COMMA_IS_SEPARATOR");
 
     /**
      * The list of separators that apply to version 0 cookies. To quote the

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/MCMPConfig.java
Patch:
@@ -43,12 +43,12 @@ public static WebBuilder webBuilder() {
 
     public MCMPConfig(Builder builder) {
         this.managementSocketAddress = new InetSocketAddress(builder.managementHost, builder.managementPort);
-        if (managementSocketAddress.getAddress().isAnyLocalAddress()) {
-            throw UndertowLogger.PROXY_REQUEST_LOGGER.cannotUseWildcardAddressAsModClusterManagementHost(builder.managementHost);
-        }
         if (managementSocketAddress.isUnresolved()) {
             throw UndertowLogger.PROXY_REQUEST_LOGGER.unableToResolveModClusterManagementHost(builder.managementHost);
         }
+        if (managementSocketAddress.getAddress().isAnyLocalAddress()) {
+            throw UndertowLogger.PROXY_REQUEST_LOGGER.cannotUseWildcardAddressAsModClusterManagementHost(builder.managementHost);
+        }
         if (builder.advertiseBuilder != null) {
             this.advertiseConfig = new AdvertiseConfig(builder.advertiseBuilder, this);
         } else {

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/MCMPConfig.java
Patch:
@@ -43,12 +43,12 @@ public static WebBuilder webBuilder() {
 
     public MCMPConfig(Builder builder) {
         this.managementSocketAddress = new InetSocketAddress(builder.managementHost, builder.managementPort);
-        if (managementSocketAddress.getAddress().isAnyLocalAddress()) {
-            throw UndertowLogger.PROXY_REQUEST_LOGGER.cannotUseWildcardAddressAsModClusterManagementHost(builder.managementHost);
-        }
         if (managementSocketAddress.isUnresolved()) {
             throw UndertowLogger.PROXY_REQUEST_LOGGER.unableToResolveModClusterManagementHost(builder.managementHost);
         }
+        if (managementSocketAddress.getAddress().isAnyLocalAddress()) {
+            throw UndertowLogger.PROXY_REQUEST_LOGGER.cannotUseWildcardAddressAsModClusterManagementHost(builder.managementHost);
+        }
         if (builder.advertiseBuilder != null) {
             this.advertiseConfig = new AdvertiseConfig(builder.advertiseBuilder, this);
         } else {

File: servlet/src/main/java/io/undertow/servlet/spec/ServletPrintWriter.java
Patch:
@@ -121,6 +121,7 @@ public void close() {
     }
 
     public boolean checkError() {
+        flush();
         return error;
     }
 

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -149,10 +149,10 @@ public interface UndertowMessages {
     @Message(id = 38, value = "Authentication failed, requested user name '%s'")
     String authenticationFailed(final String userName);
 
-    @Message(id = 39, value = "To many query parameters, cannot have more than %s query parameters")
+    @Message(id = 39, value = "Too many query parameters, cannot have more than %s query parameters")
     BadRequestException tooManyQueryParameters(int noParams);
 
-    @Message(id = 40, value = "To many headers, cannot have more than %s header")
+    @Message(id = 40, value = "Too many headers, cannot have more than %s header")
     String tooManyHeaders(int noParams);
 
     @Message(id = 41, value = "Channel is closed")

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -149,10 +149,10 @@ public interface UndertowMessages {
     @Message(id = 38, value = "Authentication failed, requested user name '%s'")
     String authenticationFailed(final String userName);
 
-    @Message(id = 39, value = "To many query parameters, cannot have more than %s query parameters")
+    @Message(id = 39, value = "Too many query parameters, cannot have more than %s query parameters")
     BadRequestException tooManyQueryParameters(int noParams);
 
-    @Message(id = 40, value = "To many headers, cannot have more than %s header")
+    @Message(id = 40, value = "Too many headers, cannot have more than %s header")
     String tooManyHeaders(int noParams);
 
     @Message(id = 41, value = "Channel is closed")

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletInitialHandler.java
Patch:
@@ -149,7 +149,6 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
             return;
         }
         final ServletPathMatch info = paths.getServletHandlerByPath(path);
-        info.getServletChain().forceInit(DispatcherType.REQUEST);
         //https://issues.jboss.org/browse/WFLY-3439
         //if the request is an upgrade request then we don't want to redirect
         //as there is a good chance the web socket client won't understand the redirect
@@ -242,7 +241,6 @@ public void dispatchMockRequest(HttpServletRequest request, HttpServletResponse
         }
         exchange.setRelativePath(relative);
         final ServletPathMatch info = paths.getServletHandlerByPath(request.getServletPath());
-        info.getServletChain().forceInit(DispatcherType.REQUEST);
         final HttpServletResponseImpl oResponse = new HttpServletResponseImpl(exchange, servletContext);
         final HttpServletRequestImpl oRequest = new HttpServletRequestImpl(exchange, servletContext);
         final ServletRequestContext servletRequestContext = new ServletRequestContext(servletContext.getDeployment(), oRequest, oResponse, info);

File: servlet/src/main/java/io/undertow/servlet/spec/AsyncContextImpl.java
Patch:
@@ -188,7 +188,6 @@ public void run() {
                 Connectors.executeRootHandler(new HttpHandler() {
                     @Override
                     public void handleRequest(final HttpServerExchange exchange) throws Exception {
-                        pathInfo.getServletChain().forceInit(DispatcherType.ASYNC);
                         servletDispatcher.dispatchToPath(exchange, pathInfo, DispatcherType.ASYNC);
                     }
                 }, exchange);

File: core/src/main/java/io/undertow/server/handlers/resource/PathResourceManager.java
Patch:
@@ -202,7 +202,7 @@ public Resource getResource(final String p) {
                 }
             }
             if (Files.exists(file)) {
-                if(path.endsWith(File.separator) && ! Files.isDirectory(file)) {
+                if(path.endsWith("/") && ! Files.isDirectory(file)) {
                     //UNDERTOW-432 don't return non directories if the path ends with a /
                     log.tracef("Failed to get path resource %s from path resource manager with base %s, as path ended with a / but was not a directory", p, base);
                     return null;

File: core/src/main/java/io/undertow/server/handlers/resource/PathResourceManager.java
Patch:
@@ -202,7 +202,7 @@ public Resource getResource(final String p) {
                 }
             }
             if (Files.exists(file)) {
-                if(path.endsWith(File.separator) && ! Files.isDirectory(file)) {
+                if(path.endsWith("/") && ! Files.isDirectory(file)) {
                     //UNDERTOW-432 don't return non directories if the path ends with a /
                     log.tracef("Failed to get path resource %s from path resource manager with base %s, as path ended with a / but was not a directory", p, base);
                     return null;

File: servlet/src/main/java/io/undertow/servlet/osgi/Activator.java
Patch:
@@ -35,12 +35,10 @@
  */
 public class Activator implements BundleActivator, ServiceTrackerCustomizer<ServletExtension, ServletExtension> {
 
-    BundleContext bundleContext;
     ServiceTracker<ServletExtension, ServletExtension> tracker;
 
     @Override
     public void start(BundleContext context) throws Exception {
-        bundleContext = context;
         tracker = new ServiceTracker<>(context, ServletExtension.class, this);
         tracker.open();
     }

File: servlet/src/main/java/io/undertow/servlet/spec/ServletInputStreamImpl.java
Patch:
@@ -301,7 +301,7 @@ public void handleEvent(final StreamSourceChannel channel) {
                 } else {
                     channel.resumeReads();
                 }
-            } catch (final Exception e) {
+            } catch (final RuntimeException|IOException e) {
                 request.getServletContext().invokeRunnable(request.getExchange(), new Runnable() {
                     @Override
                     public void run() {

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/DefaultServletCachingTestCase.java
Patch:
@@ -86,7 +86,7 @@ public static void setup() throws ServletException, IOException {
                 .setClassLoader(ServletPathMappingTestCase.class.getClassLoader())
                 .setContextPath("/servletContext")
                 .setDeploymentName("servletContext.war")
-                .setResourceManager(new CachingResourceManager(100, 10000, dataCache, new PathResourceManager(tmpDir, 10485760), METADATA_MAX_AGE));
+                .setResourceManager(new CachingResourceManager(100, 10000, dataCache, new PathResourceManager(tmpDir, 10485760, false, false, false), METADATA_MAX_AGE));
 
         builder.addServlet(new ServletInfo("DefaultTestServlet", PathTestServlet.class)
                 .addMapping("/path/default"))

File: core/src/main/java/io/undertow/server/protocol/http/HttpReadListener.java
Patch:
@@ -98,7 +98,7 @@ final class HttpReadListener implements ChannelListener<ConduitStreamSourceChann
         this.maxRequestSize = connection.getUndertowOptions().get(UndertowOptions.MAX_HEADER_SIZE, UndertowOptions.DEFAULT_MAX_HEADER_SIZE);
         this.maxEntitySize = connection.getUndertowOptions().get(UndertowOptions.MAX_ENTITY_SIZE, UndertowOptions.DEFAULT_MAX_ENTITY_SIZE);
         this.recordRequestStartTime = connection.getUndertowOptions().get(UndertowOptions.RECORD_REQUEST_START_TIME, false);
-        this.requireHostHeader = connection.getUndertowOptions().get(UndertowOptions.REQUIRE_HOST_HTTP11, false);
+        this.requireHostHeader = connection.getUndertowOptions().get(UndertowOptions.REQUIRE_HOST_HTTP11, true);
         this.allowUnknownProtocols = connection.getUndertowOptions().get(UndertowOptions.ALLOW_UNKNOWN_PROTOCOLS, false);
         int requestParseTimeout = connection.getUndertowOptions().get(UndertowOptions.REQUEST_PARSE_TIMEOUT, -1);
         int requestIdleTimeout = connection.getUndertowOptions().get(UndertowOptions.NO_REQUEST_TIMEOUT, -1);

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -525,4 +525,7 @@ public interface UndertowMessages {
 
     @Message(id = 165, value = "Invalid character %s in request-target")
     String invalidCharacterInRequestTarget(char next);
+
+    @Message(id = 166, value = "Pooled object is closed")
+    IllegalStateException objectIsClosed();
 }

File: core/src/main/java/io/undertow/protocols/ssl/SslConduit.java
Patch:
@@ -612,7 +612,9 @@ void notifyReadClosed() {
             engine.closeInbound();
         } catch (SSLException e) {
             UndertowLogger.REQUEST_IO_LOGGER.trace("Exception closing read side of SSL channel", e);
-            IoUtils.safeClose(connection, delegate);
+            if(allAreClear(state, FLAG_WRITE_CLOSED) && isWriteResumed()) {
+                runWriteListener();
+            }
         }
 
         state |= FLAG_READ_CLOSED | FLAG_ENGINE_INBOUND_SHUTDOWN | FLAG_READ_SHUTDOWN;

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -603,7 +603,7 @@ private String extractCharset(HeaderMap headers) {
      */
     public String getHostName() {
         String host = requestHeaders.getFirst(Headers.HOST);
-        if (host == null) {
+        if (host == null || "".equals(host.trim())) {
             host = getDestinationAddress().getHostString();
         } else {
             if (host.startsWith("[")) {

File: core/src/main/java/io/undertow/protocols/ssl/SslConduit.java
Patch:
@@ -612,7 +612,7 @@ void notifyReadClosed() {
             engine.closeInbound();
         } catch (SSLException e) {
             UndertowLogger.REQUEST_IO_LOGGER.trace("Exception closing read side of SSL channel", e);
-            IoUtils.safeClose(delegate);
+            IoUtils.safeClose(connection, delegate);
         }
 
         state |= FLAG_READ_CLOSED | FLAG_ENGINE_INBOUND_SHUTDOWN | FLAG_READ_SHUTDOWN;

File: core/src/main/java/io/undertow/protocols/ssl/SslConduit.java
Patch:
@@ -612,7 +612,7 @@ void notifyReadClosed() {
             engine.closeInbound();
         } catch (SSLException e) {
             UndertowLogger.REQUEST_IO_LOGGER.trace("Exception closing read side of SSL channel", e);
-            IoUtils.safeClose(delegate);
+            IoUtils.safeClose(connection, delegate);
         }
 
         state |= FLAG_READ_CLOSED | FLAG_ENGINE_INBOUND_SHUTDOWN | FLAG_READ_SHUTDOWN;

File: websockets-jsr/src/test/java/io/undertow/websockets/jsr/test/stress/WebsocketStressTestCase.java
Patch:
@@ -42,7 +42,6 @@
 import org.junit.AfterClass;
 import org.junit.Assert;
 import org.junit.BeforeClass;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import io.undertow.Handlers;
@@ -86,6 +85,7 @@ public static void setup() throws Exception {
                                 .setBuffers(DefaultServer.getBufferPool())
                                 .setWorker(DefaultServer.getWorker())
                                 .addEndpoint(StressEndpoint.class)
+                                .setDispatchToWorkerThread(true)
                                 .addListener(new WebSocketDeploymentInfo.ContainerReadyListener() {
                                     @Override
                                     public void ready(ServerWebSocketContainer container) {
@@ -110,7 +110,7 @@ public static void after() {
         executor = null;
     }
 
-    @Test @Ignore
+    @Test
     public void webSocketStringStressTestCase() throws Exception {
         List<CountDownLatch> latches = new ArrayList<>();
         for (int i = 0; i < NUM_THREADS; ++i) {

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedChannel.java
Patch:
@@ -665,7 +665,7 @@ protected synchronized void flushSenders() {
                     }
                 }
 
-            } catch (IOException e) {
+            } catch (IOException|RuntimeException e) {
                 safeClose(channel);
                 markWritesBroken(e);
             }

File: core/src/main/java/io/undertow/protocols/http2/Http2Channel.java
Patch:
@@ -1071,7 +1071,7 @@ public String getProtocol() {
         return protocol;
     }
 
-    private boolean isIdle(int streamNo) {
+    private synchronized boolean isIdle(int streamNo) {
         if(streamNo % 2 == streamIdCounter % 2) {
             return streamNo >= streamIdCounter;
         } else {

File: core/src/main/java/io/undertow/protocols/alpn/JettyAlpnProvider.java
Patch:
@@ -146,6 +146,6 @@ public void selected(String s) {
 
     @Override
     public String toString() {
-        return "JettyAlpnProvider{}";
+        return "JettyAlpnProvider";
     }
 }

File: core/src/main/java/io/undertow/protocols/alpn/JettyAlpnProvider.java
Patch:
@@ -146,6 +146,6 @@ public void selected(String s) {
 
     @Override
     public String toString() {
-        return "JettyAlpnProvider{}";
+        return "JettyAlpnProvider";
     }
 }

File: core/src/main/java/io/undertow/client/http/HttpClientConnection.java
Patch:
@@ -35,6 +35,7 @@
 import io.undertow.conduits.ChunkedStreamSinkConduit;
 import io.undertow.conduits.ChunkedStreamSourceConduit;
 import io.undertow.conduits.ConduitListener;
+import io.undertow.conduits.FinishableStreamSourceConduit;
 import io.undertow.conduits.FixedLengthStreamSourceConduit;
 import io.undertow.protocols.http2.Http2Channel;
 import io.undertow.server.Connectors;
@@ -704,6 +705,7 @@ private void prepareResponseChannel(ClientResponse response, ClientExchange exch
         } else if (response.getProtocol().equals(Protocols.HTTP_1_1) && !Connectors.isEntityBodyAllowed(response.getResponseCode())) {
             connection.getSourceChannel().setConduit(new FixedLengthStreamSourceConduit(connection.getSourceChannel().getConduit(), 0, responseFinishedListener));
         } else {
+            connection.getSourceChannel().setConduit(new FinishableStreamSourceConduit(connection.getSourceChannel().getConduit(), responseFinishedListener));
             state |= CLOSE_REQ;
         }
     }

File: core/src/test/java/io/undertow/server/handlers/SetAttributeTestCase.java
Patch:
@@ -93,7 +93,7 @@ public void testRewrite() throws IOException {
             HttpResponse result = client.execute(get);
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
             String response = HttpClientUtils.readResponse(result);
-            Assert.assertEquals("URI: /relative/foo?bar=a&woz=b relative: /foo QS:?bar=a&woz=b bar: a woz: b", response);
+            Assert.assertEquals("URI: /relative/foo relative: /foo QS:?bar=a&woz=b bar: a woz: b", response);
 
             get = new HttpGet(DefaultServer.getDefaultServerURL() + "/somePath/foo/a/b");
             result = client.execute(get);

File: core/src/main/java/io/undertow/conduits/FixedLengthStreamSourceConduit.java
Patch:
@@ -262,7 +262,7 @@ public boolean isReadResumed() {
 
     public void wakeupReads() {
         long val = state;
-        if (anyAreSet(val, FLAG_CLOSED | FLAG_FINISHED) || allAreClear(val, MASK_COUNT)) {
+        if (anyAreSet(val, FLAG_CLOSED | FLAG_FINISHED)) {
             return;
         }
         next.wakeupReads();

File: core/src/main/java/io/undertow/server/protocol/http2/Http2UpgradeHandler.java
Patch:
@@ -102,7 +102,7 @@ public void handle(HttpServerExchange exchange, byte[] message, boolean last) {
                                 try {
                                     outputStream.write(message);
                                     if(last) {
-                                        handleHttp2Upgrade(exchange, upgrade, settings, message);
+                                        handleHttp2Upgrade(exchange, upgrade, settings, outputStream.toByteArray());
                                     } else if(outputStream.size() >= maxBufferedSize) {
                                         exchange.getRequestReceiver().pause();
                                         Connectors.ungetRequestBytes(exchange, new ImmediatePooledByteBuffer(ByteBuffer.wrap(outputStream.toByteArray())));

File: core/src/main/java/io/undertow/client/http2/Http2ClientConnection.java
Patch:
@@ -450,8 +450,6 @@ public void handleEvent(Http2StreamSourceChannel channel) {
 
                 } else if (result instanceof Http2GoAwayStreamSourceChannel) {
                     close();
-                } else if(!channel.isOpen()) {
-                    throw UndertowMessages.MESSAGES.channelIsClosed();
                 } else if(result != null) {
                     Channels.drain(result, Long.MAX_VALUE);
                 }

File: core/src/main/java/io/undertow/server/protocol/http2/Http2ReceiveListener.java
Patch:
@@ -219,6 +219,8 @@ void handleInitialRequest(HttpServerExchange initial, Http2Channel channel, byte
         exchange.setQueryString(initial.getQueryString());
         if(data != null) {
             Connectors.ungetRequestBytes(exchange, new ImmediatePooledByteBuffer(ByteBuffer.wrap(data)));
+        } else {
+            Connectors.terminateRequest(exchange);
         }
         String uri = exchange.getQueryString().isEmpty() ? initial.getRequestURI() : initial.getRequestURI() + '?' + exchange.getQueryString();
         try {
@@ -233,7 +235,6 @@ void handleInitialRequest(HttpServerExchange initial, Http2Channel channel, byte
         if(session != null) {
             connection.setSslSessionInfo(new Http2SslSessionInfo(channel));
         }
-        Connectors.terminateRequest(exchange);
         sink.setCompletionListener(new ChannelListener<Http2DataStreamSinkChannel>() {
             @Override
             public void handleEvent(Http2DataStreamSinkChannel channel) {

File: core/src/main/java/io/undertow/server/protocol/http2/Http2ServerConnection.java
Patch:
@@ -45,9 +45,11 @@
 import org.xnio.StreamConnection;
 import org.xnio.XnioIoThread;
 import org.xnio.XnioWorker;
+import org.xnio.channels.Configurable;
 import org.xnio.channels.ConnectedChannel;
 import org.xnio.conduits.ConduitStreamSinkChannel;
 import org.xnio.conduits.ConduitStreamSourceChannel;
+import org.xnio.conduits.EmptyStreamSourceConduit;
 import org.xnio.conduits.StreamSinkChannelWrappingConduit;
 import org.xnio.conduits.StreamSinkConduit;
 import org.xnio.conduits.StreamSourceChannelWrappingConduit;
@@ -129,7 +131,7 @@ public Http2ServerConnection(Http2Channel channel, Http2DataStreamSinkChannel si
         originalSinkConduit = new StreamSinkChannelWrappingConduit(responseChannel);
         originalSourceConduit = new StreamSourceChannelWrappingConduit(requestChannel);
         this.conduitStreamSinkChannel = new ConduitStreamSinkChannel(responseChannel, originalSinkConduit);
-        this.conduitStreamSourceChannel = null;
+        this.conduitStreamSourceChannel = new ConduitStreamSourceChannel(Configurable.EMPTY, new EmptyStreamSourceConduit(getIoThread()));
     }
     @Override
     public Pool<ByteBuffer> getBufferPool() {

File: core/src/main/java/io/undertow/server/protocol/http2/Http2UpgradeHandler.java
Patch:
@@ -106,6 +106,7 @@ public void handle(HttpServerExchange exchange, byte[] message, boolean last) {
                                     } else if(outputStream.size() >= maxBufferedSize) {
                                         exchange.getRequestReceiver().pause();
                                         Connectors.ungetRequestBytes(exchange, new ImmediatePooledByteBuffer(ByteBuffer.wrap(outputStream.toByteArray())));
+                                        Connectors.resetRequestChannel(exchange);
                                         next.handleRequest(exchange);
                                     }
                                 } catch (IOException e) {

File: core/src/main/java/io/undertow/attribute/RemoteHostAttribute.java
Patch:
@@ -46,14 +46,14 @@ public String readAttribute(final HttpServerExchange exchange) {
 
     @Override
     public void writeAttribute(final HttpServerExchange exchange, final String newValue) throws ReadOnlyAttributeException {
-        throw new ReadOnlyAttributeException("Remote IP", newValue);
+        throw new ReadOnlyAttributeException("Remote host", newValue);
     }
 
     public static final class Builder implements ExchangeAttributeBuilder {
 
         @Override
         public String name() {
-            return "Remote IP";
+            return "Remote host";
         }
 
         @Override

File: core/src/main/java/io/undertow/server/handlers/ProxyPeerAddressHandler.java
Patch:
@@ -113,7 +113,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
     }
 
     private static boolean standardPort(int port, String scheme) {
-        return (port == 80 && "http".equals(scheme)) || (port == 443 & "https".equals(scheme));
+        return (port == 80 && "http".equals(scheme)) || (port == 443 && "https".equals(scheme));
     }
 
     public static class Builder implements HandlerBuilder {

File: core/src/main/java/io/undertow/server/handlers/ProxyPeerAddressHandler.java
Patch:
@@ -113,7 +113,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
     }
 
     private static boolean standardPort(int port, String scheme) {
-        return (port == 80 && "http".equals(scheme)) || (port == 443 & "https".equals(scheme));
+        return (port == 80 && "http".equals(scheme)) || (port == 443 && "https".equals(scheme));
     }
 
     public static class Builder implements HandlerBuilder {

File: core/src/main/java/io/undertow/attribute/RemoteHostAttribute.java
Patch:
@@ -46,14 +46,14 @@ public String readAttribute(final HttpServerExchange exchange) {
 
     @Override
     public void writeAttribute(final HttpServerExchange exchange, final String newValue) throws ReadOnlyAttributeException {
-        throw new ReadOnlyAttributeException("Remote IP", newValue);
+        throw new ReadOnlyAttributeException("Remote host", newValue);
     }
 
     public static final class Builder implements ExchangeAttributeBuilder {
 
         @Override
         public String name() {
-            return "Remote IP";
+            return "Remote host";
         }
 
         @Override

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpRequestParser.java
Patch:
@@ -193,7 +193,7 @@ public void parse(final ByteBuffer buf, final AjpRequestParseState state, final
                     return;
                 } else {
                     if (result.value != 0x1234) {
-                        throw UndertowMessages.MESSAGES.wrongMagicNumber(result.value);
+                        throw new BadRequestException(UndertowMessages.MESSAGES.wrongMagicNumber(result.value));
                     }
                 }
             }
@@ -228,7 +228,7 @@ public void parse(final ByteBuffer buf, final AjpRequestParseState state, final
                     if (method > 0 && method < 28) {
                         exchange.setRequestMethod(HTTP_METHODS[method]);
                     } else if((method & 0xFF) != 0xFF) {
-                        throw new IllegalArgumentException("Unknown method type " + method);
+                        throw new BadRequestException("Unknown method type " + method);
                     }
                 }
             }

File: core/src/main/java/io/undertow/UndertowLogger.java
Patch:
@@ -116,7 +116,7 @@ public interface UndertowLogger extends BasicLogger {
     void ioException(@Cause IOException e);
 
     @LogMessage(level = DEBUG)
-    @Message(id = 5014, value = "Failed to parse HTTP request")
+    @Message(id = 5014, value = "Failed to parse request")
     void failedToParseRequest(@Cause Exception e);
 
     @LogMessage(level = ERROR)

File: core/src/test/java/io/undertow/util/ContentTypeParsingTestCase.java
Patch:
@@ -38,6 +38,8 @@ public void testCharsetParsing() {
         Assert.assertEquals("UTF-8", Headers.extractQuotedValueFromHeader("text/html; charset=\"UTF-8\"; foo=bar", "charset"));
         Assert.assertEquals("UTF-8", Headers.extractQuotedValueFromHeader("text/html; charset=UTF-8 foo=bar", "charset"));
         Assert.assertEquals("UTF-8", Headers.extractQuotedValueFromHeader("text/html; badcharset=bad charset=UTF-8 foo=bar", "charset"));
+        Assert.assertEquals("UTF-8", Headers.extractQuotedValueFromHeader("text/html;charset=UTF-8", "charset"));
+        Assert.assertEquals("UTF-8", Headers.extractQuotedValueFromHeader("text/html;\tcharset=UTF-8", "charset"));
     }
 
 }

File: core/src/main/java/io/undertow/server/handlers/HttpTraceHandler.java
Patch:
@@ -53,6 +53,7 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
                 body.append('?');
                 body.append(exchange.getQueryString());
             }
+            body.append(' ');
             body.append(exchange.getProtocol().toString());
             body.append("\r\n");
             for(HeaderValues header : exchange.getRequestHeaders()) {

File: core/src/main/java/io/undertow/server/handlers/HttpTraceHandler.java
Patch:
@@ -53,6 +53,7 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
                 body.append('?');
                 body.append(exchange.getQueryString());
             }
+            body.append(' ');
             body.append(exchange.getProtocol().toString());
             body.append("\r\n");
             for(HeaderValues header : exchange.getRequestHeaders()) {

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/EncodingFactory.java
Patch:
@@ -157,7 +157,7 @@ public static EncodingFactory createFactory(final ClassIntrospecter classIntrosp
             if (Decoder.Binary.class.isAssignableFrom(decoder)) {
                 try {
                     Method method = decoder.getMethod("decode", ByteBuffer.class);
-                    final Class<?> type = method.getReturnType();
+                    final Class<?> type = resolveReturnType(method, decoder);
                     List<InstanceFactory<? extends Decoder>> list = binaryDecoders.get(type);
                     if (list == null) {
                         binaryDecoders.put(type, list = new ArrayList<>());
@@ -169,7 +169,7 @@ public static EncodingFactory createFactory(final ClassIntrospecter classIntrosp
             } else if (Decoder.BinaryStream.class.isAssignableFrom(decoder)) {
                 try {
                     Method method = decoder.getMethod("decode", InputStream.class);
-                    final Class<?> type = method.getReturnType();
+                    final Class<?> type = resolveReturnType(method, decoder);
                     List<InstanceFactory<? extends Decoder>> list = binaryDecoders.get(type);
                     if (list == null) {
                         binaryDecoders.put(type, list = new ArrayList<>());
@@ -193,7 +193,7 @@ public static EncodingFactory createFactory(final ClassIntrospecter classIntrosp
             } else if (Decoder.TextStream.class.isAssignableFrom(decoder)) {
                 try {
                     Method method = decoder.getMethod("decode", Reader.class);
-                    final Class<?> type = method.getReturnType();
+                    final Class<?> type = resolveReturnType(method, decoder);
                     List<InstanceFactory<? extends Decoder>> list = textDecoders.get(type);
                     if (list == null) {
                         textDecoders.put(type, list = new ArrayList<>());

File: core/src/test/java/io/undertow/util/ContentTypeParsingTestCase.java
Patch:
@@ -34,6 +34,7 @@ public void testCharsetParsing() {
         Assert.assertEquals("UTF-8", Headers.extractQuotedValueFromHeader("text/html; charset=UTF-8", "charset"));
         Assert.assertEquals("UTF-8", Headers.extractQuotedValueFromHeader("text/html; charset=\"UTF-8\"; foo=bar", "charset"));
         Assert.assertEquals("UTF-8", Headers.extractQuotedValueFromHeader("text/html; charset=UTF-8 foo=bar", "charset"));
+        Assert.assertEquals("UTF-8", Headers.extractQuotedValueFromHeader("text/html; badcharset=bad charset=UTF-8 foo=bar", "charset"));
     }
 
 }

File: core/src/main/java/io/undertow/io/DefaultIoCallback.java
Patch:
@@ -56,6 +56,7 @@ public void onComplete(final HttpServerExchange exchange, final Sender sender) {
 
     @Override
     public void onException(final HttpServerExchange exchange, final Sender sender, final IOException exception) {
+        UndertowLogger.REQUEST_IO_LOGGER.ioException(exception);
         try {
             exchange.endExchange();
         } finally {

File: core/src/main/java/io/undertow/security/impl/SingleSignOnAuthenticationMechanism.java
Patch:
@@ -88,7 +88,7 @@ public AuthenticationMechanismOutcome authenticate(HttpServerExchange exchange,
         if (cookie != null) {
             final String ssoId = cookie.getValue();
             log.tracef("Found SSO cookie %s", ssoId);
-            try (final SingleSignOn sso = this.singleSignOnManager.findSingleSignOn(ssoId)) {
+            try (SingleSignOn sso = this.singleSignOnManager.findSingleSignOn(ssoId)) {
                 if (sso != null) {
                     if(log.isTraceEnabled()) {
                         log.tracef("SSO session with ID: %s found.", ssoId);

File: parser-generator/src/main/java/io/undertow/annotationprocessor/AbstractParserGenerator.java
Patch:
@@ -114,7 +114,7 @@ public byte[] createTokenizer(final String[] httpVerbs, String[] httpVersions, S
         return file.toBytecode();
     }
 
-    protected abstract void createStateMachines(final String[] httpVerbs, final String[] httpVersions, final String[] standardHeaders, final String className, final ClassFile file, final ClassMethod sctor, final AtomicInteger fieldCounter);
+    protected abstract void createStateMachines(String[] httpVerbs, String[] httpVersions, String[] standardHeaders, String className, ClassFile file, ClassMethod sctor, AtomicInteger fieldCounter);
 
     protected void createStateMachine(final String[] originalItems, final String className, final ClassFile file, final ClassMethod sctor, final AtomicInteger fieldCounter, final String methodName, final CustomStateMachine stateMachine) {
 
@@ -732,9 +732,9 @@ public interface CustomStateMachine {
 
         boolean isHeader();
 
-        void handleStateMachineMatchedToken(final CodeAttribute c);
+        void handleStateMachineMatchedToken(CodeAttribute c);
 
-        void handleOtherToken(final CodeAttribute c);
+        void handleOtherToken(CodeAttribute c);
 
         void updateParseState(CodeAttribute c);
 

File: parser-generator/src/main/java/io/undertow/annotationprocessor/HttpParserAnnotationProcessor.java
Patch:
@@ -40,7 +40,7 @@
 @SupportedAnnotationTypes("io.undertow.annotationprocessor.HttpParserConfig")
 @SupportedOptions({
 })
-@SupportedSourceVersion(SourceVersion.RELEASE_7)
+@SupportedSourceVersion(SourceVersion.RELEASE_8)
 public class HttpParserAnnotationProcessor extends AbstractProcessor {
 
     private Filer filer;

File: core/src/main/java/io/undertow/security/impl/SingleSignOnAuthenticationMechanism.java
Patch:
@@ -88,7 +88,7 @@ public AuthenticationMechanismOutcome authenticate(HttpServerExchange exchange,
         if (cookie != null) {
             final String ssoId = cookie.getValue();
             log.tracef("Found SSO cookie %s", ssoId);
-            try (final SingleSignOn sso = this.singleSignOnManager.findSingleSignOn(ssoId)) {
+            try (SingleSignOn sso = this.singleSignOnManager.findSingleSignOn(ssoId)) {
                 if (sso != null) {
                     if(log.isTraceEnabled()) {
                         log.tracef("SSO session with ID: %s found.", ssoId);

File: parser-generator/src/main/java/io/undertow/annotationprocessor/AbstractParserGenerator.java
Patch:
@@ -114,7 +114,7 @@ public byte[] createTokenizer(final String[] httpVerbs, String[] httpVersions, S
         return file.toBytecode();
     }
 
-    protected abstract void createStateMachines(final String[] httpVerbs, final String[] httpVersions, final String[] standardHeaders, final String className, final ClassFile file, final ClassMethod sctor, final AtomicInteger fieldCounter);
+    protected abstract void createStateMachines(String[] httpVerbs, String[] httpVersions, String[] standardHeaders, String className, ClassFile file, ClassMethod sctor, AtomicInteger fieldCounter);
 
     protected void createStateMachine(final String[] originalItems, final String className, final ClassFile file, final ClassMethod sctor, final AtomicInteger fieldCounter, final String methodName, final CustomStateMachine stateMachine) {
 
@@ -732,9 +732,9 @@ public interface CustomStateMachine {
 
         boolean isHeader();
 
-        void handleStateMachineMatchedToken(final CodeAttribute c);
+        void handleStateMachineMatchedToken(CodeAttribute c);
 
-        void handleOtherToken(final CodeAttribute c);
+        void handleOtherToken(CodeAttribute c);
 
         void updateParseState(CodeAttribute c);
 

File: parser-generator/src/main/java/io/undertow/annotationprocessor/HttpParserAnnotationProcessor.java
Patch:
@@ -40,7 +40,7 @@
 @SupportedAnnotationTypes("io.undertow.annotationprocessor.HttpParserConfig")
 @SupportedOptions({
 })
-@SupportedSourceVersion(SourceVersion.RELEASE_7)
+@SupportedSourceVersion(SourceVersion.RELEASE_8)
 public class HttpParserAnnotationProcessor extends AbstractProcessor {
 
     private Filer filer;

File: core/src/main/java/io/undertow/server/handlers/resource/FileResourceManager.java
Patch:
@@ -27,6 +27,9 @@
  */
 public class FileResourceManager extends PathResourceManager {
 
+    public FileResourceManager(final File base) {
+        this(base, 1024, true, false, null);
+    }
     public FileResourceManager(final File base, long transferMinSize) {
         this(base, transferMinSize, true, false, null);
     }

File: core/src/main/java/io/undertow/conduits/StoredResponseStreamSinkConduit.java
Patch:
@@ -51,7 +51,7 @@ public StoredResponseStreamSinkConduit(StreamSinkConduit next, HttpServerExchang
         super(next);
         this.exchange = exchange;
         long length = exchange.getResponseContentLength();
-        if (length > 0L) {
+        if (length <= 0L) {
             outputStream = new ByteArrayOutputStream();
         } else {
             if (length > Integer.MAX_VALUE) {

File: core/src/main/java/io/undertow/conduits/StoredResponseStreamSinkConduit.java
Patch:
@@ -51,7 +51,7 @@ public StoredResponseStreamSinkConduit(StreamSinkConduit next, HttpServerExchang
         super(next);
         this.exchange = exchange;
         long length = exchange.getResponseContentLength();
-        if (length > 0) {
+        if (length > 0L) {
             outputStream = new ByteArrayOutputStream();
         } else {
             if (length > Integer.MAX_VALUE) {

File: servlet/src/main/java/io/undertow/servlet/api/ListenerInfo.java
Patch:
@@ -62,7 +62,7 @@ public void setInstanceFactory(InstanceFactory<? extends EventListener> instance
         this.instanceFactory = instanceFactory;
     }
 
-    public Class<?> getListenerClass() {
+    public Class<? extends EventListener> getListenerClass() {
         return listenerClass;
     }
 

File: core/src/main/java/io/undertow/protocols/ajp/AjpClientRequestClientStreamSinkChannel.java
Patch:
@@ -57,7 +57,7 @@ public class AjpClientRequestClientStreamSinkChannel extends AbstractAjpClientSt
 
     private final ChannelListener<AjpClientRequestClientStreamSinkChannel> finishListener;
 
-    private static final int DEFAULT_MAX_DATA_SIZE = 8192;
+    public static final int DEFAULT_MAX_DATA_SIZE = 8192;
 
     private final HeaderMap headers;
     private final String path;

File: core/src/main/java/io/undertow/protocols/http2/Http2Channel.java
Patch:
@@ -116,7 +116,7 @@ public class Http2Channel extends AbstractFramedChannel<Http2Channel, AbstractHt
 
     static final int CONTINUATION_FLAG_END_HEADERS = 0x4;
 
-    static final int DEFAULT_INITIAL_WINDOW_SIZE = 65535;
+    public static final int DEFAULT_INITIAL_WINDOW_SIZE = 65535;
 
     static final byte[] PREFACE_BYTES = {
             0x50, 0x52, 0x49, 0x20, 0x2a, 0x20, 0x48, 0x54,

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentImpl.java
Patch:
@@ -19,6 +19,7 @@
 package io.undertow.servlet.core;
 
 import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -67,7 +68,7 @@ public class DeploymentImpl implements Deployment {
     private volatile ErrorPages errorPages;
     private volatile Map<String, String> mimeExtensionMappings;
     private volatile SessionManager sessionManager;
-    private volatile Charset defaultCharset;
+    private volatile Charset defaultCharset = StandardCharsets.ISO_8859_1;
     private volatile List<AuthenticationMechanism> authenticationMechanisms;
     private volatile List<ThreadSetupHandler> threadSetupActions;
 

File: servlet/src/main/java/io/undertow/servlet/core/ManagedServlet.java
Patch:
@@ -74,7 +74,7 @@ public ManagedServlet(final ServletInfo servletInfo, final ServletContextImpl se
 
     public void setupMultipart(ServletContextImpl servletContext) {
         FormEncodedDataDefinition formDataParser = new FormEncodedDataDefinition()
-                .setDefaultEncoding(servletContext.getDeployment().getDeploymentInfo().getDefaultEncoding());
+                .setDefaultEncoding(servletContext.getDeployment().getDefaultCharset().name());
         MultipartConfigElement multipartConfig = servletInfo.getMultipartConfig();
         if(multipartConfig == null) {
             multipartConfig = servletContext.getDeployment().getDeploymentInfo().getDefaultMultipartConfig();
@@ -105,7 +105,7 @@ public void setupMultipart(ServletContextImpl servletContext) {
             if(config.getMaxFileSize() > 0) {
                 multiPartParserDefinition.setMaxIndividualFileSize(config.getMaxFileSize());
             }
-            multiPartParserDefinition.setDefaultEncoding(servletContext.getDeployment().getDeploymentInfo().getDefaultEncoding());
+            multiPartParserDefinition.setDefaultEncoding(servletContext.getDeployment().getDefaultCharset().name());
 
             formParserFactory = FormParserFactory.builder(false)
                     .addParser(formDataParser)

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -318,7 +318,7 @@ public Collection<String> getHeaderNames() {
     @Override
     public String getCharacterEncoding() {
         if (charset == null) {
-            return servletContext.getDeployment().getDeploymentInfo().getDefaultEncoding();
+            return servletContext.getDeployment().getDefaultCharset().name();
         }
         return charset;
     }

File: servlet/src/main/java/io/undertow/servlet/spec/PartImpl.java
Patch:
@@ -66,7 +66,7 @@ public InputStream getInputStream() throws IOException {
             return new BufferedInputStream(Files.newInputStream(formValue.getPath()));
         } else {
             String requestedCharset = servletRequest.getCharacterEncoding();
-            String charset = requestedCharset != null ? requestedCharset : servletContext.getDeployment().getDeploymentInfo().getDefaultEncoding();
+            String charset = requestedCharset != null ? requestedCharset : servletContext.getDeployment().getDefaultCharset().name();
             return new ByteArrayInputStream(formValue.getValue().getBytes(charset));
         }
     }

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedChannel.java
Patch:
@@ -819,7 +819,7 @@ protected void markReadsBroken(Throwable cause) {
             if(receiver != null) {
                 receiver.markStreamBroken();
             }
-            for(AbstractFramedStreamSourceChannel<C, R, S> r : receivers) {
+            for(AbstractFramedStreamSourceChannel<C, R, S> r : new ArrayList<>(receivers)) {
                 r.markStreamBroken();
             }
 

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/Node.java
Patch:
@@ -335,7 +335,7 @@ protected void hotStandby() {
         int oldState, newState;
         for (;;) {
             oldState = this.state;
-            newState = oldState | HOT_STANDBY;
+            newState = oldState & ~(ERROR | ERROR_MASK) | HOT_STANDBY;
             if (stateUpdater.compareAndSet(this, oldState, newState)) {
                 lbStatus.updateLoad(0);
                 return;

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/MCMPHandler.java
Patch:
@@ -591,7 +591,7 @@ public void failed() {
     /**
      * Process <tt>INFO</tt> request
      *
-     * @throws Exception
+     * @throws IOException
      */
     protected void processInfo(HttpServerExchange exchange) throws IOException {
         final String data = processInfoString();
@@ -634,7 +634,7 @@ protected String processInfoString() {
      * Process <tt>DUMP</tt> request
      *
      * @param exchange
-     * @throws java.io.IOException
+     * @throws IOException
      */
     protected void processDump(HttpServerExchange exchange) throws IOException {
         final String data = processDumpString();
@@ -714,7 +714,7 @@ static void sendResponse(final HttpServerExchange exchange, final String respons
     /**
      * If the process is OK, then add 200 HTTP status and its "OK" phrase
      *
-     * @throws Exception
+     * @throws IOException
      */
     static void processOK(HttpServerExchange exchange) throws IOException {
         exchange.setStatusCode(StatusCodes.OK);

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/ModClusterContainer.java
Patch:
@@ -394,8 +394,8 @@ Context findNewNode(final VirtualHost.HostEntry entry) {
      *
      * @param domain   the load balancing domain, if known
      * @param jvmRoute the original jvmRoute
+     * @param entry    the resolved virtual host entry
      * @return the context, {@code null} if not found
-     * @oaram entry      the resolved virtual host entry
      */
     Context findFailoverNode(final VirtualHost.HostEntry entry, final String domain, final String jvmRoute, final boolean forceStickySession) {
         String failOverDomain = null;

File: core/src/main/java/io/undertow/server/handlers/ChannelUpgradeHandler.java
Patch:
@@ -132,7 +132,7 @@ public synchronized void removeProtocol(String productString, ChannelListener<?
         while (it.hasNext()) {
             Holder holder = it.next();
             if (holder.channelListener == openListener) {
-                it.remove();
+                holders.remove(holder);
                 break;
             }
         }
@@ -157,7 +157,7 @@ public synchronized void removeProtocol(String productString, HttpUpgradeListene
         while (it.hasNext()) {
             Holder holder = it.next();
             if (holder.listener == upgradeListener) {
-                it.remove();
+                holders.remove(holder);
                 break;
             }
         }

File: core/src/main/java/io/undertow/server/handlers/ChannelUpgradeHandler.java
Patch:
@@ -132,7 +132,7 @@ public synchronized void removeProtocol(String productString, ChannelListener<?
         while (it.hasNext()) {
             Holder holder = it.next();
             if (holder.channelListener == openListener) {
-                it.remove();
+                holders.remove(holder);
                 break;
             }
         }
@@ -157,7 +157,7 @@ public synchronized void removeProtocol(String productString, HttpUpgradeListene
         while (it.hasNext()) {
             Holder holder = it.next();
             if (holder.listener == upgradeListener) {
-                it.remove();
+                holders.remove(holder);
                 break;
             }
         }

File: core/src/test/java/io/undertow/server/handlers/proxy/AbstractLoadBalancingProxyTestCase.java
Patch:
@@ -67,7 +67,7 @@ public static void setupFailTest() {
         firstFail = true;
     }
 
-    protected static final int IDLE_TIMEOUT = 100;
+    protected static final int IDLE_TIMEOUT = 1000;
 
     @AfterClass
     public static void teardown() {

File: core/src/main/java/io/undertow/conduits/InflatingStreamSourceConduit.java
Patch:
@@ -85,6 +85,7 @@ public int read(ByteBuffer dst) throws IOException {
             } else if (res == 0) {
                 compressed.close();
                 compressed = null;
+                return 0;
             } else {
                 buf.flip();
                 if (!headerDone) {
@@ -119,6 +120,8 @@ public int read(ByteBuffer dst) throws IOException {
             compressed.close();
             compressed = null;
             return 0;
+        } else if(compressed == null) {
+            throw new RuntimeException();
         }
         uncompressed = exchange.getConnection().getByteBufferPool().getArrayBackedPool().allocate();
         try {

File: core/src/main/java/io/undertow/server/handlers/encoding/EncodingHandler.java
Patch:
@@ -62,7 +62,7 @@ public EncodingHandler(ContentEncodingRepository contentEncodingRepository) {
     @Override
     public void handleRequest(final HttpServerExchange exchange) throws Exception {
         AllowedContentEncodings encodings = contentEncodingRepository.getContentEncodings(exchange);
-        if (encodings == null) {
+        if (encodings == null || !exchange.isResponseChannelAvailable()) {
             next.handleRequest(exchange);
         } else if (encodings.isNoEncodingsAllowed()) {
             noEncodingHandler.handleRequest(exchange);

File: core/src/main/java/io/undertow/protocols/ajp/AjpClientRequestClientStreamSinkChannel.java
Patch:
@@ -57,7 +57,7 @@ public class AjpClientRequestClientStreamSinkChannel extends AbstractAjpClientSt
 
     private final ChannelListener<AjpClientRequestClientStreamSinkChannel> finishListener;
 
-    private static final int DEFAULT_MAX_DATA_SIZE = 8192;
+    public static final int DEFAULT_MAX_DATA_SIZE = 8192;
 
     private final HeaderMap headers;
     private final String path;

File: core/src/main/java/io/undertow/protocols/http2/Http2Channel.java
Patch:
@@ -114,7 +114,7 @@ public class Http2Channel extends AbstractFramedChannel<Http2Channel, AbstractHt
 
     static final int CONTINUATION_FLAG_END_HEADERS = 0x4;
 
-    static final int DEFAULT_INITIAL_WINDOW_SIZE = 65535;
+    public static final int DEFAULT_INITIAL_WINDOW_SIZE = 65535;
 
     static final byte[] PREFACE_BYTES = {
             0x50, 0x52, 0x49, 0x20, 0x2a, 0x20, 0x48, 0x54,

File: core/src/main/java/io/undertow/protocols/http2/Http2Channel.java
Patch:
@@ -429,6 +429,7 @@ protected AbstractHttp2StreamSourceChannel createChannel(FrameHeaderData frameHe
                     }
                 }
                 frameData.close();
+                sendGoAway(ERROR_NO_ERROR);
                 break;
             }
             case FRAME_TYPE_WINDOW_UPDATE: {

File: servlet/src/test/java/io/undertow/servlet/test/multipart/MultiPartTestCase.java
Patch:
@@ -183,7 +183,7 @@ public void testMultiPartRequestToLarge() throws IOException {
 
             post.setEntity(entity);
             HttpResponse result = client.execute(post);
-            Assert.assertEquals(DefaultServer.isH2() ? StatusCodes.SERVICE_UNAVAILABLE : StatusCodes.INTERNAL_SERVER_ERROR, result.getStatusLine().getStatusCode());
+            Assert.assertEquals(DefaultServer.isH2() || DefaultServer.isAjp() ? StatusCodes.SERVICE_UNAVAILABLE : StatusCodes.INTERNAL_SERVER_ERROR, result.getStatusLine().getStatusCode());
             HttpClientUtils.readResponse(result);
         } catch (IOException expected) {
             //in some environments the forced close of the read side will cause a connection reset

File: core/src/main/java/io/undertow/server/handlers/ChannelUpgradeHandler.java
Patch:
@@ -61,7 +61,7 @@ public synchronized void addProtocol(String productString, ChannelListener<? sup
      * @param openListener  the open listener to call
      * @param handshake     a handshake implementation that can be used to verify the client request and modify the response
      */
-    private synchronized void addProtocol(String productString, HttpUpgradeListener openListener, final HttpUpgradeHandshake handshake) {
+    public synchronized void addProtocol(String productString, HttpUpgradeListener openListener, final HttpUpgradeHandshake handshake) {
         addProtocol(productString, openListener, null, handshake);
     }
 

File: core/src/main/java/io/undertow/security/impl/BasicAuthenticationMechanism.java
Patch:
@@ -194,7 +194,7 @@ public ChallengeResult sendChallenge(HttpServerExchange exchange, SecurityContex
             //otherwise we assume another method will send the challenge
             String authHeader = exchange.getRequestHeaders().getFirst(AUTHORIZATION);
             if(authHeader == null) {
-                return new ChallengeResult(false);
+                return ChallengeResult.NOT_SENT;
             }
         }
         exchange.getResponseHeaders().add(WWW_AUTHENTICATE, challenge);

File: core/src/main/java/io/undertow/security/impl/CachedAuthenticatedSessionMechanism.java
Patch:
@@ -81,7 +81,7 @@ public AuthenticationMechanismOutcome runCached(final HttpServerExchange exchang
     @Override
     public ChallengeResult sendChallenge(HttpServerExchange exchange, SecurityContext securityContext) {
         // This mechanism can only use what is already available and can not send a challenge of it's own.
-        return new ChallengeResult(false);
+        return ChallengeResult.NOT_SENT;
     }
 
 }

File: core/src/main/java/io/undertow/security/impl/ClientCertAuthenticationMechanism.java
Patch:
@@ -137,7 +137,7 @@ private Certificate[] getPeerCertificates(final HttpServerExchange exchange, SSL
 
     @Override
     public ChallengeResult sendChallenge(HttpServerExchange exchange, SecurityContext securityContext) {
-        return new ChallengeResult(false);
+        return ChallengeResult.NOT_SENT;
     }
 
     public static final class Factory implements AuthenticationMechanismFactory {

File: core/src/main/java/io/undertow/security/impl/ExternalAuthenticationMechanism.java
Patch:
@@ -85,7 +85,7 @@ public AuthenticationMechanismOutcome authenticate(HttpServerExchange exchange,
 
     @Override
     public ChallengeResult sendChallenge(HttpServerExchange exchange, SecurityContext securityContext) {
-        return new ChallengeResult(false);
+        return ChallengeResult.NOT_SENT;
     }
 
     public static final class Factory implements AuthenticationMechanismFactory {

File: core/src/main/java/io/undertow/security/impl/GSSAPIAuthenticationMechanism.java
Patch:
@@ -184,7 +184,7 @@ public ChallengeResult sendChallenge(final HttpServerExchange exchange, final Se
                 // Deliberately ignore - no Subject so don't offer GSSAPI is our main concern here.
             }
             if (server == null) {
-                return new ChallengeResult(false);
+                return ChallengeResult.NOT_SENT;
             }
         }
 

File: core/src/main/java/io/undertow/security/impl/GenericHeaderAuthenticationMechanism.java
Patch:
@@ -103,7 +103,7 @@ private String getPrincipal(HttpServerExchange exchange) {
 
     @Override
     public ChallengeResult sendChallenge(HttpServerExchange exchange, SecurityContext securityContext) {
-        return new ChallengeResult(false);
+        return ChallengeResult.NOT_SENT;
     }
 
 

File: core/src/main/java/io/undertow/security/impl/SecurityContextImpl.java
Patch:
@@ -294,7 +294,9 @@ private AuthenticationState transition() {
                 final AuthenticationMechanism mechanism = currentMethod.item;
                 currentMethod = currentMethod.next;
                 ChallengeResult result = mechanism.sendChallenge(exchange, SecurityContextImpl.this);
-
+                if(result == null) {
+                    throw UndertowMessages.MESSAGES.sendChallengeReturnedNull(mechanism);
+                }
                 if (result.isChallengeSent()) {
                     challengeSent = true;
                     Integer desiredCode = result.getDesiredResponseCode();

File: core/src/main/java/io/undertow/security/impl/SingleSignOnAuthenticationMechanism.java
Patch:
@@ -147,7 +147,7 @@ private void clearSsoCookie(HttpServerExchange exchange) {
 
     @Override
     public ChallengeResult sendChallenge(HttpServerExchange exchange, SecurityContext securityContext) {
-        return new ChallengeResult(false);
+        return ChallengeResult.NOT_SENT;
     }
 
     protected Session getSession(final HttpServerExchange exchange) {

File: core/src/test/java/io/undertow/server/security/KerberosKDCUtil.java
Patch:
@@ -104,9 +104,9 @@ public static boolean startServer() throws Exception {
         if (initialised) {
             return false;
         }
+        setupEnvironment();
         startLdapServer();
         startKDC();
-        setupEnvironment();
 
         initialised = true;
         return true;

File: core/src/test/java/io/undertow/server/security/KerberosKDCUtil.java
Patch:
@@ -104,9 +104,9 @@ public static boolean startServer() throws Exception {
         if (initialised) {
             return false;
         }
+        setupEnvironment();
         startLdapServer();
         startKDC();
-        setupEnvironment();
 
         initialised = true;
         return true;

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/EncodingFactory.java
Patch:
@@ -295,10 +295,10 @@ private static <T> InstanceFactory<? extends T> createInstanceFactory(final Clas
     private static Class<?> findEncodeMethod(final Class<? extends Encoder> encoder, final Class<?> returnType, Class<?>... otherParameters) throws DeploymentException {
         for (Method method : encoder.getMethods()) {
             if (method.getName().equals("encode") && !method.isBridge() &&
-                    method.getParameterTypes().length == 1 + otherParameters.length &&
+                    method.getParameterCount() == 1 + otherParameters.length &&
                     method.getReturnType() == returnType) {
                 boolean ok = true;
-                for (int i = 1; i < method.getParameterTypes().length; ++i) {
+                for (int i = 1; i < method.getParameterCount(); ++i) {
                     if (method.getParameterTypes()[i] != otherParameters[i - 1]) {
                         ok = false;
                         break;

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/annotated/AnnotatedEndpointFactory.java
Patch:
@@ -265,8 +265,8 @@ private static BoundPathParameters createBoundPathParameters(final Method method
 
 
     private static String[] pathParams(final Method method) {
-        String[] params = new String[method.getParameterTypes().length];
-        for (int i = 0; i < method.getParameterTypes().length; ++i) {
+        String[] params = new String[method.getParameterCount()];
+        for (int i = 0; i < method.getParameterCount(); ++i) {
             PathParam param = getPathParam(method, i);
             if (param != null) {
                 params[i] = param.value();
@@ -317,7 +317,7 @@ private static class BoundSingleParameter implements BoundParameter {
         BoundSingleParameter(final Method method, final Class<?> type, final boolean optional) {
             this.type = type;
             int pos = -1;
-            for (int i = 0; i < method.getParameterTypes().length; ++i) {
+            for (int i = 0; i < method.getParameterCount(); ++i) {
                 boolean pathParam = false;
                 for (Annotation annotation : method.getParameterAnnotations()[i]) {
                     if (annotation.annotationType().equals(PathParam.class)) {

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/EncodingFactory.java
Patch:
@@ -295,10 +295,10 @@ private static <T> InstanceFactory<? extends T> createInstanceFactory(final Clas
     private static Class<?> findEncodeMethod(final Class<? extends Encoder> encoder, final Class<?> returnType, Class<?>... otherParameters) throws DeploymentException {
         for (Method method : encoder.getMethods()) {
             if (method.getName().equals("encode") && !method.isBridge() &&
-                    method.getParameterTypes().length == 1 + otherParameters.length &&
+                    method.getParameterCount() == 1 + otherParameters.length &&
                     method.getReturnType() == returnType) {
                 boolean ok = true;
-                for (int i = 1; i < method.getParameterTypes().length; ++i) {
+                for (int i = 1; i < method.getParameterCount(); ++i) {
                     if (method.getParameterTypes()[i] != otherParameters[i - 1]) {
                         ok = false;
                         break;

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/annotated/AnnotatedEndpointFactory.java
Patch:
@@ -265,8 +265,8 @@ private static BoundPathParameters createBoundPathParameters(final Method method
 
 
     private static String[] pathParams(final Method method) {
-        String[] params = new String[method.getParameterTypes().length];
-        for (int i = 0; i < method.getParameterTypes().length; ++i) {
+        String[] params = new String[method.getParameterCount()];
+        for (int i = 0; i < method.getParameterCount(); ++i) {
             PathParam param = getPathParam(method, i);
             if (param != null) {
                 params[i] = param.value();
@@ -317,7 +317,7 @@ private static class BoundSingleParameter implements BoundParameter {
         BoundSingleParameter(final Method method, final Class<?> type, final boolean optional) {
             this.type = type;
             int pos = -1;
-            for (int i = 0; i < method.getParameterTypes().length; ++i) {
+            for (int i = 0; i < method.getParameterCount(); ++i) {
                 boolean pathParam = false;
                 for (Annotation annotation : method.getParameterAnnotations()[i]) {
                     if (annotation.annotationType().equals(PathParam.class)) {

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/MCMPHandler.java
Patch:
@@ -74,6 +74,7 @@
 import static io.undertow.server.handlers.proxy.mod_cluster.MCMPConstants.TIMEOUT;
 import static io.undertow.server.handlers.proxy.mod_cluster.MCMPConstants.TTL;
 import static io.undertow.server.handlers.proxy.mod_cluster.MCMPConstants.TYPE;
+import static io.undertow.server.handlers.proxy.mod_cluster.MCMPConstants.WAITWORKER;
 
 /**
  * The mod cluster management protocol http handler.
@@ -278,6 +279,8 @@ private void processConfig(final HttpServerExchange exchange, final RequestData
             } else if (ALIAS.equals(name)) {
                 final String[] alias = value.split(",");
                 hosts = Arrays.asList(alias);
+            } else if(WAITWORKER.equals(name)) {
+                node.setWaitWorker(Integer.parseInt(value));
             } else {
                 processError(TYPESYNTAX, SBADFLD + name + SBADFLD1, exchange);
                 return;

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -452,7 +452,7 @@ protected void runChild(FrameworkMethod method, RunNotifier notifier) {
                 return;
             }
         }
-        if (h2 || h2c || ajp) {
+        if(h2 || h2c || ajp || h2cUpgrade) {
             //h2c-upgrade we still allow HTTP1
             HttpOneOnly httpOneOnly = method.getAnnotation(HttpOneOnly.class);
             if (httpOneOnly == null) {

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletInitialHandler.java
Patch:
@@ -170,7 +170,7 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
             //this can only happen if the path ends with a /
             //otherwise there would be a redirect instead
             exchange.setRelativePath(info.getRewriteLocation());
-            exchange.setRequestPath(exchange.getRequestPath() + info.getRewriteLocation());
+            exchange.setRequestPath(exchange.getResolvedPath() + info.getRewriteLocation());
         }
 
         final HttpServletResponseImpl response = new HttpServletResponseImpl(exchange, servletContext);

File: core/src/main/java/io/undertow/client/http2/Http2ClientExchange.java
Patch:
@@ -30,6 +30,7 @@
 import io.undertow.client.ClientRequest;
 import io.undertow.client.ClientResponse;
 import io.undertow.client.ContinueNotification;
+import io.undertow.protocols.http2.Http2Channel;
 import io.undertow.protocols.http2.Http2StreamSinkChannel;
 import io.undertow.protocols.http2.Http2StreamSourceChannel;
 import io.undertow.util.AbstractAttachable;
@@ -135,9 +136,9 @@ void responseReady(Http2StreamSourceChannel result) {
 
     ClientResponse createResponse(Http2StreamSourceChannel result) {
         HeaderMap headers = result.getHeaders();
-        final String status = result.getHeaders().getFirst(Http2ClientConnection.STATUS);
+        final String status = result.getHeaders().getFirst(Http2Channel.STATUS);
         int statusCode = Integer.parseInt(status);
-        headers.remove(Http2ClientConnection.STATUS);
+        headers.remove(Http2Channel.STATUS);
         return new ClientResponse(statusCode, status.substring(3), clientRequest.getProtocol(), headers);
     }
 }

File: core/src/main/java/io/undertow/protocols/http2/HpackDecoder.java
Patch:
@@ -349,7 +349,7 @@ private void resizeIfRequired() {
 
     public interface HeaderEmitter {
 
-        void emitHeader(HttpString name, String value, boolean neverIndex);
+        void emitHeader(HttpString name, String value, boolean neverIndex) throws HpackException;
     }
 
 

File: core/src/main/java/io/undertow/protocols/http2/Http2HeadersParser.java
Patch:
@@ -35,8 +35,8 @@ class Http2HeadersParser extends Http2HeaderBlockParser {
     private boolean headersEndStream = false;
     private boolean exclusive;
 
-    Http2HeadersParser(int frameLength, HpackDecoder hpackDecoder) {
-        super(frameLength, hpackDecoder);
+    Http2HeadersParser(int frameLength, HpackDecoder hpackDecoder, boolean client, int streamId) {
+        super(frameLength, hpackDecoder, client, streamId);
     }
 
     @Override
@@ -69,7 +69,7 @@ protected boolean handleBeforeHeader(ByteBuffer resource, Http2FrameHeaderParser
         return true;
     }
 
-    int getPaddingLength() {
+    protected int getPaddingLength() {
         return paddingLength;
     }
 

File: core/src/main/java/io/undertow/protocols/http2/Http2PushPromiseParser.java
Patch:
@@ -33,8 +33,8 @@ class Http2PushPromiseParser extends Http2HeaderBlockParser {
     private int promisedStreamId;
     private static final int STREAM_MASK = ~(1 << 7);
 
-    Http2PushPromiseParser(int frameLength, HpackDecoder hpackDecoder) {
-        super(frameLength, hpackDecoder);
+    Http2PushPromiseParser(int frameLength, HpackDecoder hpackDecoder, boolean client, int streamId) {
+        super(frameLength, hpackDecoder, client, streamId);
     }
 
     @Override
@@ -54,7 +54,7 @@ protected boolean handleBeforeHeader(ByteBuffer resource, Http2FrameHeaderParser
         return true;
     }
 
-    int getPaddingLength() {
+    protected int getPaddingLength() {
         return paddingLength;
     }
 

File: core/src/main/java/io/undertow/protocols/http2/Http2Setting.java
Patch:
@@ -33,9 +33,9 @@ public class Http2Setting {
     public static final int SETTINGS_MAX_HEADER_LIST_SIZE = 0x6;
 
     private final int id;
-    private final int value;
+    private final long value;
 
-    Http2Setting(int id, int value) {
+    Http2Setting(int id, long value) {
         this.id = id;
         this.value = value;
     }
@@ -44,7 +44,7 @@ public int getId() {
         return id;
     }
 
-    public int getValue() {
+    public long getValue() {
         return value;
     }
 }

File: core/src/main/java/io/undertow/util/ReferenceCountedPooled.java
Patch:
@@ -140,6 +140,7 @@ public ByteBuffer getBuffer() throws IllegalStateException {
             @Override
             public String toString() {
                 return "ReferenceCountedPooled$view{" +
+                        "buffer=" + newValue +
                         "free=" + free +
                         "underlying=" + underlying +
                         ", referenceCount=" + referenceCount +

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -312,7 +312,7 @@ private static void runInternal(final RunNotifier notifier) {
 
                     }
                 } else if (h2 && isAlpnEnabled()) {
-                    openListener = new Http2OpenListener(pool, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true, UndertowOptions.HTTP2_SETTINGS_ENABLE_PUSH, false));
+                    openListener = new Http2OpenListener(pool, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true, UndertowOptions.HTTP2_PADDING_SIZE, 10));
                     acceptListener = ChannelListeners.openListenerAdapter(wrapOpenListener(new AlpnOpenListener(pool).addProtocol(Http2OpenListener.HTTP2, (io.undertow.server.DelegateOpenListener) openListener, 10)));
 
                     SSLContext clientContext = createSSLContext(loadKeyStore(CLIENT_KEY_STORE), loadKeyStore(CLIENT_TRUST_STORE), true);
@@ -329,7 +329,7 @@ private static void runInternal(final RunNotifier notifier) {
 
 
                 } else if (h2c || h2cUpgrade) {
-                    openListener = new HttpOpenListener(pool, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true, UndertowOptions.HTTP2_SETTINGS_ENABLE_PUSH, false));
+                    openListener = new HttpOpenListener(pool, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true, UndertowOptions.HTTP2_PADDING_SIZE, 10));
                     acceptListener = ChannelListeners.openListenerAdapter(wrapOpenListener(openListener));
 
                     InetSocketAddress targetAddress = new InetSocketAddress(Inet4Address.getByName(getHostAddress(DEFAULT)), getHostPort(DEFAULT) + PROXY_OFFSET);

File: core/src/main/java/io/undertow/Version.java
Patch:
@@ -18,6 +18,7 @@
 
 package io.undertow;
 
+import java.io.InputStream;
 import java.util.Properties;
 
 /**
@@ -30,9 +31,9 @@ public class Version {
 
     static {
         String version = "Unknown";
-        try {
+        try (InputStream versionPropsStream = Version.class.getResourceAsStream("version.properties")){
             Properties props = new Properties();
-            props.load(Version.class.getResourceAsStream("version.properties"));
+            props.load(versionPropsStream);
             version = props.getProperty("undertow.version");
         } catch (Exception e) {
             e.printStackTrace();

File: core/src/main/java/io/undertow/client/ajp/AjpClientExchange.java
Patch:
@@ -27,7 +27,6 @@
 import io.undertow.client.ClientResponse;
 import io.undertow.client.ContinueNotification;
 import io.undertow.client.PushCallback;
-import io.undertow.protocols.ajp.AjpClientChannel;
 import io.undertow.protocols.ajp.AjpClientRequestClientStreamSinkChannel;
 import io.undertow.protocols.ajp.AjpClientResponseStreamSourceChannel;
 import io.undertow.util.AbstractAttachable;
@@ -51,7 +50,6 @@ class AjpClientExchange extends AbstractAttachable implements ClientExchange {
     private ClientCallback<ClientExchange> responseCallback;
     private ClientCallback<ClientExchange> readyCallback;
     private ContinueNotification continueNotification;
-    private AjpClientChannel ajpClientChannel;
 
     private ClientResponse response;
     private ClientResponse continueResponse;

File: core/src/main/java/io/undertow/client/ajp/AjpClientProvider.java
Patch:
@@ -135,7 +135,7 @@ public void activity(long bytes) {
     }
 
 
-    private class ClientStatisticsImpl implements ClientStatistics {
+    private static class ClientStatisticsImpl implements ClientStatistics {
         private long requestCount, read, written;
         @Override
         public long getRequests() {

File: core/src/main/java/io/undertow/client/http2/Http2ClientExchange.java
Patch:
@@ -138,6 +138,6 @@ ClientResponse createResponse(Http2StreamSourceChannel result) {
         final String status = result.getHeaders().getFirst(Http2ClientConnection.STATUS);
         int statusCode = Integer.parseInt(status);
         headers.remove(Http2ClientConnection.STATUS);
-        return new ClientResponse(statusCode, status != null ? status.substring(3) : "", clientRequest.getProtocol(), headers);
+        return new ClientResponse(statusCode, status.substring(3), clientRequest.getProtocol(), headers);
     }
 }

File: core/src/main/java/io/undertow/client/http2/Http2PriorKnowledgeClientProvider.java
Patch:
@@ -52,7 +52,7 @@
  */
 public class Http2PriorKnowledgeClientProvider implements ClientProvider {
 
-    public static final byte[] PRI_REQUEST = {'P','R','I',' ','*',' ','H','T','T','P','/','2','.','0','\r','\n','\r','\n','S','M','\r','\n','\r','\n'};
+    private static final byte[] PRI_REQUEST = {'P','R','I',' ','*',' ','H','T','T','P','/','2','.','0','\r','\n','\r','\n','S','M','\r','\n','\r','\n'};
 
     @Override
     public void connect(final ClientCallback<ClientConnection> listener, final URI uri, final XnioWorker worker, final XnioSsl ssl, final ByteBufferPool bufferPool, final OptionMap options) {

File: core/src/main/java/io/undertow/conduits/GzipStreamSinkConduit.java
Patch:
@@ -34,8 +34,8 @@ public class GzipStreamSinkConduit extends DeflatingStreamSinkConduit {
     /*
      * GZIP header magic number.
      */
-    private static final  int GZIP_MAGIC = 0x8b1f;
-    public static final byte[] HEADER = new byte[]{
+    private static final int GZIP_MAGIC = 0x8b1f;
+    private static final byte[] HEADER = new byte[]{
             (byte) GZIP_MAGIC,        // Magic number (short)
             (byte) (GZIP_MAGIC >> 8),  // Magic number (short)
             Deflater.DEFLATED,        // Compression method (CM)

File: core/src/main/java/io/undertow/conduits/ReadTimeoutStreamSourceConduit.java
Patch:
@@ -180,7 +180,9 @@ private Integer getTimeout() {
         Integer timeout = 0;
         try {
             timeout = connection.getSourceChannel().getOption(Options.READ_TIMEOUT);
-        } catch (IOException ignore) {}
+        } catch (IOException ignore) {
+            // should never happen
+        }
         Integer idleTimeout = openListener.getUndertowOptions().get(UndertowOptions.IDLE_TIMEOUT);
         if ((timeout == null || timeout <= 0) && idleTimeout != null) {
             timeout = idleTimeout;

File: core/src/main/java/io/undertow/conduits/WriteTimeoutStreamSinkConduit.java
Patch:
@@ -182,7 +182,9 @@ private Integer getTimeout() {
         Integer timeout = 0;
         try {
             timeout = connection.getSourceChannel().getOption(Options.WRITE_TIMEOUT);
-        } catch (IOException ignore) {}
+        } catch (IOException ignore) {
+            // should never happen, ignoring
+        }
         Integer idleTimeout = openListener.getUndertowOptions().get(UndertowOptions.IDLE_TIMEOUT);
         if ((timeout == null || timeout <= 0) && idleTimeout != null) {
             timeout = idleTimeout;

File: core/src/main/java/io/undertow/predicate/PathMatchPredicate.java
Patch:
@@ -48,7 +48,7 @@ class PathMatchPredicate implements Predicate {
     public boolean resolve(final HttpServerExchange value) {
         final String relativePath = value.getRelativePath();
         PathMatcher.PathMatch<Boolean> result = pathMatcher.match(relativePath);
-        return result.getValue() == Boolean.TRUE;
+        return Boolean.TRUE.equals(result.getValue());
     }
 
     public static class Builder implements PredicateBuilder {

File: core/src/main/java/io/undertow/predicate/PathPrefixPredicate.java
Patch:
@@ -50,7 +50,7 @@ public boolean resolve(final HttpServerExchange value) {
         final String relativePath = value.getRelativePath();
         PathMatcher.PathMatch<Boolean> result = pathMatcher.match(relativePath);
 
-        boolean matches = result.getValue() == Boolean.TRUE;
+        boolean matches = Boolean.TRUE.equals(result.getValue());
         if(matches) {
             Map<String, Object> context = value.getAttachment(PREDICATE_CONTEXT);
             if(context == null) {

File: core/src/main/java/io/undertow/predicate/SecurePredicate.java
Patch:
@@ -29,7 +29,7 @@
  */
 public class SecurePredicate implements Predicate {
 
-    public static SecurePredicate INSTANCE = new SecurePredicate();
+    public static final SecurePredicate INSTANCE = new SecurePredicate();
 
     @Override
     public boolean resolve(HttpServerExchange value) {

File: core/src/main/java/io/undertow/protocols/http2/HpackDecoder.java
Patch:
@@ -66,8 +66,6 @@ public class HpackDecoder {
      */
     private int maxMemorySize;
 
-    private boolean resuming;
-
     private final StringBuilder stringBuilder = new StringBuilder();
 
     public HpackDecoder(int maxMemorySize) {

File: core/src/main/java/io/undertow/security/idm/Account.java
Patch:
@@ -17,6 +17,7 @@
  */
 package io.undertow.security.idm;
 
+import java.io.Serializable;
 import java.security.Principal;
 import java.util.Set;
 
@@ -25,7 +26,7 @@
  *
  * @author <a href="mailto:darran.lofthouse@jboss.com">Darran Lofthouse</a>
  */
-public interface Account {
+public interface Account extends Serializable {
 
     Principal getPrincipal();
 

File: core/src/main/java/io/undertow/server/handlers/StuckThreadDetectionHandler.java
Patch:
@@ -79,7 +79,7 @@ public class StuckThreadDetectionHandler implements HttpHandler {
         @Override
         public void run() {
             timerKey = null;
-            long thresholdInMillis = threshold * 1000;
+            long thresholdInMillis = threshold * 1000L;
 
             // Check monitored threads, being careful that the request might have
             // completed by the time we examine it

File: core/src/main/java/io/undertow/server/handlers/accesslog/ExtendedAccessLogParser.java
Patch:
@@ -386,7 +386,7 @@ protected ExchangeAttribute getProxyElement(PatternTokenizer tokenizer)
             throws IOException {
         String token = null;
         if (tokenizer.hasSubToken()) {
-            token = tokenizer.getToken();
+            tokenizer.getToken();
             return new ConstantExchangeAttribute("-");
         } else if (tokenizer.hasParameter()) {
             tokenizer.getParameter();

File: core/src/main/java/io/undertow/server/handlers/builder/PredicatedHandlersParser.java
Patch:
@@ -34,6 +34,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.Array;
+import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.ArrayDeque;
@@ -69,7 +70,7 @@ public static List<PredicatedHandler> parse(final File file, final ClassLoader c
 
     public static List<PredicatedHandler> parse(final Path file, final ClassLoader classLoader) {
         try {
-            return parse(new String(Files.readAllBytes(file)), classLoader);
+            return parse(new String(Files.readAllBytes(file), StandardCharsets.UTF_8), classLoader);
         } catch (IOException e) {
             throw new RuntimeException(e);
         }

File: core/src/main/java/io/undertow/server/handlers/cache/DirectBufferCache.java
Patch:
@@ -146,7 +146,7 @@ public Set<Object> getAllKeys() {
 
     private void bumpAccess(CacheEntry cacheEntry) {
         Object prevToken = cacheEntry.claimToken();
-        if (prevToken != Boolean.FALSE) {
+        if (!Boolean.FALSE.equals(prevToken)) {
             if (prevToken != null) {
                 accessQueue.removeToken(prevToken);
             }

File: core/src/main/java/io/undertow/server/handlers/cache/LRUCache.java
Patch:
@@ -18,13 +18,13 @@
 
 package io.undertow.server.handlers.cache;
 
-import io.undertow.util.ConcurrentDirectDeque;
-
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
+import io.undertow.util.ConcurrentDirectDeque;
+
 /**
  * A non-blocking cache where entries are indexed by a key.
  * <p>
@@ -119,7 +119,7 @@ public V get(K key) {
 
     private void bumpAccess(CacheEntry<K, V> cacheEntry) {
         Object prevToken = cacheEntry.claimToken();
-        if (prevToken != Boolean.FALSE) {
+        if (!Boolean.FALSE.equals(prevToken)) {
             if (prevToken != null) {
                 accessQueue.removeToken(prevToken);
             }

File: core/src/main/java/io/undertow/server/handlers/cache/LimitedBufferSlicePool.java
Patch:
@@ -18,6 +18,8 @@
 
 package io.undertow.server.handlers.cache;
 
+import org.xnio.BufferAllocator;
+
 import java.nio.ByteBuffer;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
@@ -26,8 +28,6 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
-import org.xnio.BufferAllocator;
-
 /**
  * A limited buffer pooled allocator.  This pool uses a series of buffer regions to back the
  * returned pooled buffers.  When the buffer is no longer needed, it should be freed back into the pool; failure
@@ -171,7 +171,7 @@ public String toString() {
         }
     }
 
-    private final class Slice {
+    private static final class Slice {
         private final ByteBuffer parent;
         private final int start;
         private final int size;

File: core/src/main/java/io/undertow/server/handlers/encoding/ContentEncodedResourceManager.java
Patch:
@@ -152,7 +152,7 @@ public ContentEncodedResource getResource(final Resource resource, final HttpSer
         }
     }
 
-    private final class LockKey {
+    private static final class LockKey {
         private final String path;
         private final String encoding;
 

File: core/src/main/java/io/undertow/server/handlers/form/MultiPartParserDefinition.java
Patch:
@@ -172,7 +172,7 @@ private MultiPartUploadHandler(final HttpServerExchange exchange, final String b
                     charset = value;
                 }
             }
-           this.parser = MultipartParser.beginParse(exchange.getConnection().getByteBufferPool(), this, boundary.getBytes(), charset);
+           this.parser = MultipartParser.beginParse(exchange.getConnection().getByteBufferPool(), this, boundary.getBytes(StandardCharsets.US_ASCII), charset);
 
         }
 

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpRequestParser.java
Patch:
@@ -392,8 +392,9 @@ public void parse(final ByteBuffer buf, final AjpRequestParseState state, final
                     }
                     //query string.
                     if (state.currentAttribute.equals(QUERY_STRING)) {
-                        exchange.setQueryString(result == null ? "" : result);
-                        URLUtils.parseQueryString(result, exchange, encoding, doDecode);
+                        String resultAsQueryString = result == null ? "" : result;
+                        exchange.setQueryString(resultAsQueryString);
+                        URLUtils.parseQueryString(resultAsQueryString, exchange, encoding, doDecode);
                     } else if (state.currentAttribute.equals(REMOTE_USER)) {
                         exchange.putAttachment(ExternalAuthenticationMechanism.EXTERNAL_PRINCIPAL, result);
                     } else if (state.currentAttribute.equals(AUTH_TYPE)) {

File: core/src/main/java/io/undertow/util/ByteRange.java
Patch:
@@ -176,7 +176,7 @@ public RangeResponseResult getResponseResult(final long resourceContentLength, S
         return new RangeResponseResult(start, end, rangeLength,  "bytes " + start + "-" + end + "/" + resourceContentLength, StatusCodes.PARTIAL_CONTENT);
     }
 
-    public class RangeResponseResult {
+    public static class RangeResponseResult {
         private final long start;
         private final long end;
         private final long contentLength;

File: core/src/main/java/io/undertow/util/FlexBase64.java
Patch:
@@ -763,6 +763,7 @@ private static String encodeString(byte[] source, int pos, int limit, boolean wr
                     return STRING_CONSTRUCTOR.newInstance(target, Boolean.TRUE);
                 }
             } catch (Exception e) {
+                // Ignoring on purpose
             }
 
             return new String(target);
@@ -867,6 +868,7 @@ private static String encodeString(ByteBuffer source, boolean wrap, boolean url)
                     return STRING_CONSTRUCTOR.newInstance(target, Boolean.TRUE);
                 }
             } catch (Exception e) {
+                // Ignoring on purpose
             }
 
             return new String(target);

File: core/src/main/java/io/undertow/util/HeaderMap.java
Patch:
@@ -761,6 +761,7 @@ public HeaderMap putAll(HttpString headerName, Collection<String> headerValues)
         }
         if (headerValues == null || headerValues.isEmpty()) {
             remove(headerName);
+            return this;
         }
         final HeaderValues entry = getOrCreateEntry(headerName);
         entry.clear();

File: core/src/main/java/io/undertow/util/HttpString.java
Patch:
@@ -38,6 +38,8 @@
  * @author <a href="mailto:david.lloyd@redhat.com">David M. Lloyd</a>
  */
 public final class HttpString implements Comparable<HttpString>, Serializable {
+    private static final long serialVersionUID = 1L;
+
     private final byte[] bytes;
     private final transient int hashCode;
     /**

File: core/src/main/java/io/undertow/websockets/core/BufferedBinaryMessage.java
Patch:
@@ -42,7 +42,7 @@ public class BufferedBinaryMessage {
     private final long maxMessageSize;
     private long currentSize;
     private boolean complete;
-    private int frameCount;
+//    private int frameCount; // was used only in handleNewFrame() which is marked for removal => commenting out
 
 
     public BufferedBinaryMessage(long maxMessageSize, boolean bufferFullMessage) {

File: core/src/main/java/io/undertow/websockets/core/UTF8Output.java
Patch:
@@ -18,16 +18,16 @@
 
 package io.undertow.websockets.core;
 
-import java.nio.ByteBuffer;
-
 import org.xnio.Buffers;
 
+import java.nio.ByteBuffer;
+
 /**
  * Utility class which allows to extract a UTF8 String from bytes respecting valid code-points
  */
 public final class UTF8Output {
     private static final int UTF8_ACCEPT = 0;
-    private final byte HIGH_BIT = (byte) (1 << 7);
+    private static final byte HIGH_BIT = (byte) (1 << 7);
 
     private static final byte[] TYPES = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

File: core/src/main/java/io/undertow/websockets/core/protocol/version07/WebSocket07FrameSinkChannel.java
Patch:
@@ -41,6 +41,7 @@ public abstract class WebSocket07FrameSinkChannel extends StreamSinkFrameChannel
     private final Masker masker;
     private volatile boolean dataWritten = false;
     protected final ExtensionFunction extensionFunction;
+    private final Random random = new Random();
 
     protected WebSocket07FrameSinkChannel(WebSocket07Channel wsChannel, WebSocketFrameType type) {
         super(wsChannel, type);
@@ -140,7 +141,7 @@ Known extensions (i.e. compression) should not modify RSV bit on continuation bi
         }
 
         if(masker != null) {
-            int maskingKey = new Random().nextInt(); //generate a new key for this frame
+            int maskingKey = random.nextInt(); //generate a new key for this frame
             header.put((byte)((maskingKey >> 24) & 0xFF));
             header.put((byte)((maskingKey >> 16) & 0xFF));
             header.put((byte)((maskingKey >> 8) & 0xFF));

File: core/src/main/java/io/undertow/websockets/extensions/PerMessageDeflateFunction.java
Patch:
@@ -49,7 +49,7 @@
  */
 public class PerMessageDeflateFunction implements ExtensionFunction {
 
-    public static final byte[] TAIL = new byte[]{0x00, 0x00, (byte) 0xFF, (byte) 0xFF};
+    private static final byte[] TAIL = new byte[]{0x00, 0x00, (byte) 0xFF, (byte) 0xFF};
 
     private final int deflaterLevel;
     private final boolean compressContextTakeover;

File: core/src/test/java/io/undertow/websockets/utils/FrameChecker.java
Patch:
@@ -25,7 +25,7 @@
 import org.xnio.FutureResult;
 
 import java.io.IOException;
-import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
 
 /**
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
@@ -53,7 +53,7 @@ public void onFrame(WebSocketFrame frame) {
                 if (frame instanceof TextWebSocketFrame) {
                     String buf = ((TextWebSocketFrame) frame).text();
 
-                    Assert.assertEquals(new String(expectedPayload, Charset.forName("UTF-8")), buf);
+                    Assert.assertEquals(new String(expectedPayload, StandardCharsets.UTF_8), buf);
                 } else {
                     ByteBuf buf = frame.content();
                     byte[] data = new byte[buf.readableBytes()];

File: servlet/src/test/java/io/undertow/servlet/test/security/SendSchemeServlet.java
Patch:
@@ -20,6 +20,7 @@
 import java.io.IOException;
 import java.io.OutputStream;
 import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServlet;
@@ -35,7 +36,7 @@ public class SendSchemeServlet extends HttpServlet {
 
     private static final long serialVersionUID = -4804724108087346230L;
 
-    private static final Charset UTF_8 = Charset.forName("UTF-8");
+    private static final Charset UTF_8 = StandardCharsets.UTF_8;
 
     @Override
     protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

File: servlet/src/test/java/io/undertow/servlet/test/security/constraint/ServletIdentityManager.java
Patch:
@@ -25,6 +25,7 @@
 import io.undertow.util.HexConverter;
 
 import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.security.Principal;
@@ -41,7 +42,7 @@
  */
 public class ServletIdentityManager implements IdentityManager {
 
-    private static final Charset UTF_8 = Charset.forName("UTF-8");
+    private static final Charset UTF_8 = StandardCharsets.UTF_8;
     private final Map<String, UserAccount> users = new HashMap<>();
 
     public void addUser(final String name, final String password, final String... roles) {

File: servlet/src/test/java/io/undertow/servlet/test/websocket/WebSocketServletTest.java
Patch:
@@ -40,19 +40,20 @@
 import org.junit.runner.RunWith;
 import org.xnio.FutureResult;
 
-import javax.servlet.Servlet;
 import java.io.IOException;
 import java.net.URI;
 import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
 import java.util.concurrent.atomic.AtomicBoolean;
+import javax.servlet.Servlet;
 
 /**
  * @author Stuart Douglas
  */
 @HttpOneOnly
 @RunWith(DefaultServer.class)
 public class WebSocketServletTest {
-    public static final Charset US_ASCII = Charset.forName("US-ASCII");
+    public static final Charset US_ASCII = StandardCharsets.US_ASCII;
 
     @Test
     public void testText() throws Exception {

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/ServerWebSocketContainer.java
Patch:
@@ -804,7 +804,7 @@ private static List<WebSocketExtension> toExtensionList(final List<Extension> ex
         return ret;
     }
 
-    private class ClientNegotiation extends WebSocketClientNegotiation {
+    private static class ClientNegotiation extends WebSocketClientNegotiation {
 
         private final ClientEndpointConfig config;
 

File: servlet/src/main/java/io/undertow/servlet/spec/AsyncContextImpl.java
Patch:
@@ -90,7 +90,7 @@ public class AsyncContextImpl implements AsyncContext {
 
     private final Deque<Runnable> asyncTaskQueue = new ArrayDeque<>();
     private boolean processingAsyncTask = false;
-    private boolean complete = false;
+    private volatile boolean complete = false;
 
     public AsyncContextImpl(final HttpServerExchange exchange, final ServletRequest servletRequest, final ServletResponse servletResponse, final ServletRequestContext servletRequestContext, boolean requestSupplied, final AsyncContextImpl previousAsyncContext) {
         this.exchange = exchange;

File: core/src/main/java/io/undertow/websockets/core/WebSockets.java
Patch:
@@ -638,7 +638,7 @@ private static <T> void sendInternal(final ByteBuffer data, WebSocketFrameType t
             flushChannelAsync(wsChannel, callback, channel, context, timeoutmillis);
         } catch (IOException e) {
             if (callback != null) {
-                callback.onError(wsChannel, null, e);
+                callback.onError(wsChannel, context, e);
             } else {
                 IoUtils.safeClose(wsChannel);
             }

File: core/src/main/java/io/undertow/protocols/ssl/ALPNHackServerByteArrayOutputStream.java
Patch:
@@ -50,7 +50,7 @@ class ALPNHackServerByteArrayOutputStream extends ByteArrayOutputStream {
     }
 
     @Override
-    public synchronized void write(byte[] b, int off, int len) {
+    public void write(byte[] b, int off, int len) {
         if(ready) {
             if(b[off] == 2) { // server hello
                 ready = false; //we are done processing

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedChannel.java
Patch:
@@ -110,7 +110,7 @@ public abstract class AbstractFramedChannel<C extends AbstractFramedChannel<C, R
     private volatile long frameDataRemaining;
     private volatile R receiver;
 
-    private boolean receivesSuspended = true;
+    private volatile boolean receivesSuspended = true;
 
     @SuppressWarnings("unused")
     private volatile int readsBroken = 0;
@@ -121,7 +121,7 @@ public abstract class AbstractFramedChannel<C extends AbstractFramedChannel<C, R
     private static final AtomicIntegerFieldUpdater<AbstractFramedChannel> readsBrokenUpdater = AtomicIntegerFieldUpdater.newUpdater(AbstractFramedChannel.class, "readsBroken");
     private static final AtomicIntegerFieldUpdater<AbstractFramedChannel> writesBrokenUpdater = AtomicIntegerFieldUpdater.newUpdater(AbstractFramedChannel.class, "writesBroken");
 
-    private ReferenceCountedPooled readData = null;
+    private volatile ReferenceCountedPooled readData = null;
     private final List<ChannelListener<C>> closeTasks = new CopyOnWriteArrayList<>();
     private volatile boolean flushingSenders = false;
 
@@ -138,7 +138,7 @@ public abstract class AbstractFramedChannel<C extends AbstractFramedChannel<C, R
      * If this is true then the flush() method must be called to queue writes. This is provided to support batching
      */
     private volatile boolean requireExplicitFlush = false;
-    private boolean readChannelDone = false;
+    private volatile boolean readChannelDone = false;
 
     private final ReferenceCountedPooled.FreeNotifier freeNotifier = new ReferenceCountedPooled.FreeNotifier() {
         @Override

File: core/src/main/java/io/undertow/client/http/HttpClientConnection.java
Patch:
@@ -630,7 +630,7 @@ protected void doHttp2Upgrade() {
         try {
             StreamConnection connectedStreamChannel = this.performUpgrade();
             Http2Channel http2Channel = new Http2Channel(connectedStreamChannel, null, bufferPool, null, true, true, options);
-            Http2ClientConnection http2ClientConnection = new Http2ClientConnection(http2Channel, currentRequest.getResponseCallback(), currentRequest.getRequest(), currentRequest.getRequest().getRequestHeaders().getFirst(Headers.HOST), clientStatistics);
+            Http2ClientConnection http2ClientConnection = new Http2ClientConnection(http2Channel, currentRequest.getResponseCallback(), currentRequest.getRequest(), currentRequest.getRequest().getRequestHeaders().getFirst(Headers.HOST), clientStatistics, false);
             http2ClientConnection.getCloseSetter().set(new ChannelListener<ClientConnection>() {
                 @Override
                 public void handleEvent(ClientConnection channel) {

File: core/src/main/java/io/undertow/client/http2/Http2ClearClientProvider.java
Patch:
@@ -224,7 +224,7 @@ public void activity(long bytes) {
             }
 
             Http2Channel http2Channel = new Http2Channel(channel, null, bufferPool, null, true, true, options);
-            Http2ClientConnection http2ClientConnection = new Http2ClientConnection(http2Channel, true, defaultHost, clientStatistics);
+            Http2ClientConnection http2ClientConnection = new Http2ClientConnection(http2Channel, true, defaultHost, clientStatistics, false);
 
             listener.completed(http2ClientConnection);
         }

File: core/src/main/java/io/undertow/client/http2/Http2ClientProvider.java
Patch:
@@ -166,7 +166,7 @@ public void activity(long bytes) {
             clientStatistics = null;
         }
         Http2Channel http2Channel = new Http2Channel(connection, null, bufferPool, null, true, false, options);
-        return new Http2ClientConnection(http2Channel, false, defaultHost, clientStatistics);
+        return new Http2ClientConnection(http2Channel, false, defaultHost, clientStatistics, true);
     }
 
     private static class ClientStatisticsImpl implements ClientStatistics {

File: core/src/main/java/io/undertow/client/http2/Http2PriorKnowledgeClientProvider.java
Patch:
@@ -144,15 +144,15 @@ public void handleEvent(ConduitStreamSinkChannel channel) {
                             if(pri.hasRemaining()) {
                                 return;
                             }
-                            listener.completed(new Http2ClientConnection(new Http2Channel(connection, null, bufferPool, null, true, false, options), false, defaultHost, clientStatistics));
+                            listener.completed(new Http2ClientConnection(new Http2Channel(connection, null, bufferPool, null, true, false, options), false, defaultHost, clientStatistics, false));
                         } catch (IOException e) {
                             listener.failed(e);
                         }
                     }
                 });
                 return;
             }
-            listener.completed(new Http2ClientConnection(new Http2Channel(connection, null, bufferPool, null, true, false, options), false, defaultHost, clientStatistics));
+            listener.completed(new Http2ClientConnection(new Http2Channel(connection, null, bufferPool, null, true, false, options), false, defaultHost, clientStatistics, false));
         } catch (IOException e) {
             listener.failed(e);
         }

File: core/src/main/java/io/undertow/client/http2/Http2ClientProvider.java
Patch:
@@ -58,8 +58,6 @@ public class Http2ClientProvider implements ClientProvider {
     private static final String HTTP2 = "h2";
     private static final String HTTP_1_1 = "http/1.1";
 
-    private static final String[] PROTOCOLS = {HTTP2, HTTP_1_1};
-
     private static final ChannelListener<SslConnection> FAILED = new ChannelListener<SslConnection>() {
         @Override
         public void handleEvent(SslConnection connection) {

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpOpenListener.java
Patch:
@@ -60,7 +60,7 @@ public class AjpOpenListener implements OpenListener {
 
     private volatile OptionMap undertowOptions;
 
-    private final AjpRequestParser parser;
+    private volatile AjpRequestParser parser;
 
     private volatile boolean statisticsEnabled;
     private final ConnectorStatisticsImpl connectorStatistics;
@@ -165,6 +165,7 @@ public void setUndertowOptions(final OptionMap undertowOptions) {
         }
         this.undertowOptions = undertowOptions;
         statisticsEnabled = undertowOptions.get(UndertowOptions.ENABLE_CONNECTOR_STATISTICS, false);
+        parser = new AjpRequestParser(undertowOptions.get(URL_CHARSET, StandardCharsets.UTF_8.name()), undertowOptions.get(DECODE_URL, true));
     }
 
     @Override

File: core/src/main/java/io/undertow/util/URLUtils.java
Patch:
@@ -22,7 +22,6 @@
 import io.undertow.server.HttpServerExchange;
 
 import java.io.UnsupportedEncodingException;
-import java.net.URLDecoder;
 
 /**
  * Utilities for dealing with URLs
@@ -238,7 +237,7 @@ void parse(final String string, final HttpServerExchange exchange, final String
 
         private String decode(String charset, String attrName, final boolean doDecode) throws UnsupportedEncodingException {
             if (doDecode) {
-                return URLDecoder.decode(attrName, charset);
+                return URLUtils.decode(attrName, charset, true, new StringBuilder());
             }
             return attrName;
         }

File: core/src/test/java/io/undertow/server/handlers/QueryParametersTestCase.java
Patch:
@@ -28,6 +28,7 @@
 import io.undertow.server.HttpServerExchange;
 import io.undertow.testutils.DefaultServer;
 import io.undertow.testutils.HttpClientUtils;
+import io.undertow.testutils.ProxyIgnore;
 import io.undertow.testutils.TestHttpClient;
 import org.apache.http.client.methods.HttpGet;
 import org.junit.Assert;
@@ -101,6 +102,7 @@ public void testQueryParameters() throws IOException {
 
 
     @Test
+    @ProxyIgnore
     public void testQueryParametersShiftJIS() throws IOException {
         OptionMap old = DefaultServer.getUndertowOptions();
         try {

File: core/src/main/java/io/undertow/client/http/HttpRequestConduit.java
Patch:
@@ -612,7 +612,7 @@ public void truncateWrites() throws IOException {
             }
             return;
         }
-        this.state = oldVal & ~MASK_STATE | FLAG_SHUTDOWN | STATE_BODY;
+        this.state = oldVal & ~MASK_STATE | FLAG_SHUTDOWN;
         throw new TruncatedResponseException();
     }
 

File: core/src/main/java/io/undertow/protocols/ssl/ALPNHackClientByteArrayOutputStream.java
Patch:
@@ -43,7 +43,7 @@ class ALPNHackClientByteArrayOutputStream extends ByteArrayOutputStream {
     }
 
     @Override
-    public synchronized void write(byte[] b, int off, int len) {
+    public void write(byte[] b, int off, int len) {
         if(ready) {
             if(b[off] == 2) { // server hello
                 ready = false; //we are done processing

File: core/src/main/java/io/undertow/server/Connectors.java
Patch:
@@ -194,7 +194,7 @@ private static String addVersion1ResponseCookieToExchange(final Cookie cookie) {
             header.append("; Expires=");
             header.append(DateUtils.toDateString(cookie.getExpires()));
         }
-        if (cookie.getMaxAge() != null) {
+        if (cookie.getComment() != null) {
             if (cookie.getComment() != null && !cookie.getComment().isEmpty()) {
                 header.append("; Comment=");
                 header.append(cookie.getComment());

File: core/src/main/java/io/undertow/protocols/http2/AbstractHttp2StreamSourceChannel.java
Patch:
@@ -24,7 +24,7 @@
 import io.undertow.server.protocol.framed.FrameHeaderData;
 
 /**
- * SPDY stream source channel
+ * HTTP2 stream source channel
  *
  * @author Stuart Douglas
  */

File: core/src/main/java/io/undertow/protocols/http2/Http2RstStreamParser.java
Patch:
@@ -21,7 +21,7 @@
 import java.nio.ByteBuffer;
 
 /**
- * Parser for SPDY ping frames.
+ * Parser for HTTP2 ping frames.
  *
  * @author Stuart Douglas
  */

File: core/src/main/java/io/undertow/protocols/alpn/OpenSSLAlpnProvider.java
Patch:
@@ -49,7 +49,7 @@ public OpenSSLALPNMethods run() {
                     Method getApplicationProtocol = openSSLEngine.getMethod("getSelectedApplicationProtocol");
                     UndertowLogger.ROOT_LOGGER.debug("OpenSSL ALPN Enabled");
                     return new OpenSSLALPNMethods(setApplicationProtocols, getApplicationProtocol);
-                } catch (Exception e) {
+                } catch (Throwable e) {
                     UndertowLogger.ROOT_LOGGER.debug("OpenSSL ALPN Enabled", e);
                     return null;
                 }

File: core/src/main/java/io/undertow/protocols/ssl/SslConduit.java
Patch:
@@ -791,7 +791,7 @@ private long doUnwrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcep
         } finally {
             boolean requiresListenerInvocation = false; //if there is data in the buffer and reads are resumed we should re-run the listener
             //we always need to re-invoke if bytes have been produced, as the engine may have buffered some data
-            if (bytesProduced || (unwrappedData != null && unwrappedData.getBuffer().hasRemaining())) {
+            if (bytesProduced || (unwrappedData != null && unwrappedData.isOpen() && unwrappedData.getBuffer().hasRemaining())) {
                 requiresListenerInvocation = true;
             }
             if (dataToUnwrap != null) {

File: core/src/main/java/io/undertow/Undertow.java
Patch:
@@ -135,7 +135,7 @@ public synchronized void start() {
                     .getMap();
 
             OptionMap serverOptions = OptionMap.builder()
-                    .set(UndertowOptions.NO_REQUEST_TIMEOUT, 60000000)
+                    .set(UndertowOptions.NO_REQUEST_TIMEOUT, 60 * 1000)
                     .addAll(this.serverOptions)
                     .getMap();
 

File: core/src/main/java/io/undertow/attribute/ResponseTimeAttribute.java
Patch:
@@ -49,7 +49,7 @@ public String readAttribute(HttpServerExchange exchange) {
         final long nanos = System.nanoTime() - requestStartTime;
         if(timeUnit == TimeUnit.SECONDS) {
             StringBuilder buf = new StringBuilder();
-            long milis = timeUnit.convert(nanos, TimeUnit.NANOSECONDS);
+            long milis = TimeUnit.MILLISECONDS.convert(nanos, TimeUnit.NANOSECONDS);
             buf.append(Long.toString(milis / 1000));
             buf.append('.');
             int remains = (int) (milis % 1000);

File: core/src/main/java/io/undertow/attribute/ResponseTimeAttribute.java
Patch:
@@ -49,7 +49,7 @@ public String readAttribute(HttpServerExchange exchange) {
         final long nanos = System.nanoTime() - requestStartTime;
         if(timeUnit == TimeUnit.SECONDS) {
             StringBuilder buf = new StringBuilder();
-            long milis = timeUnit.convert(nanos, TimeUnit.NANOSECONDS);
+            long milis = TimeUnit.MILLISECONDS.convert(nanos, TimeUnit.NANOSECONDS);
             buf.append(Long.toString(milis / 1000));
             buf.append('.');
             int remains = (int) (milis % 1000);

File: core/src/main/java/io/undertow/UndertowLogger.java
Patch:
@@ -60,6 +60,7 @@ public interface UndertowLogger extends BasicLogger {
     UndertowLogger CLIENT_LOGGER = Logger.getMessageLogger(UndertowLogger.class, ClientConnection.class.getPackage().getName());
 
     UndertowLogger REQUEST_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + ".request");
+    UndertowLogger SESSION_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + ".session");
     UndertowLogger SECURITY_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + ".request.security");
     UndertowLogger PROXY_REQUEST_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + ".proxy");
     UndertowLogger REQUEST_DUMPER_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + ".request.dump");

File: core/src/main/java/io/undertow/security/handlers/AbstractConfidentialityHandler.java
Patch:
@@ -47,7 +47,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
         } else {
             try {
                 URI redirectUri = getRedirectURI(exchange);
-
+                UndertowLogger.SECURITY_LOGGER.debugf("Redirecting request %s to %s to meet confidentiality requirements", exchange, redirectUri);
                 exchange.setStatusCode(StatusCodes.FOUND);
                 exchange.getResponseHeaders().put(Headers.LOCATION, redirectUri.toString());
             } catch (Exception e) {

File: core/src/main/java/io/undertow/security/handlers/AuthenticationConstraintHandler.java
Patch:
@@ -17,6 +17,7 @@
  */
 package io.undertow.security.handlers;
 
+import io.undertow.UndertowLogger;
 import io.undertow.security.api.SecurityContext;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
@@ -45,6 +46,7 @@ public AuthenticationConstraintHandler(final HttpHandler next) {
     public void handleRequest(HttpServerExchange exchange) throws Exception {
         if (isAuthenticationRequired(exchange)) {
             SecurityContext context = exchange.getSecurityContext();
+            UndertowLogger.SECURITY_LOGGER.debugf("Setting authentication required for exchange %s", exchange);
             context.setAuthenticationRequired();
         }
 

File: core/src/main/java/io/undertow/security/impl/AbstractSecurityContext.java
Patch:
@@ -91,6 +91,7 @@ protected void authenticationComplete(Account account, String mechanism, boolean
 
     @Override
     public void authenticationFailed(String message, String mechanism) {
+        UndertowLogger.SECURITY_LOGGER.debugf("Authentication failed with message %s and mechanism %s for %s", message, mechanism, exchange);
         sendNoticiation(new SecurityNotification(exchange, EventType.FAILED_AUTHENTICATION, null, mechanism, false, message, true));
     }
 
@@ -137,6 +138,7 @@ public void logout() {
         if (!isAuthenticated()) {
             return;
         }
+        UndertowLogger.SECURITY_LOGGER.debugf("Logged out %s", exchange);
         sendNoticiation(new SecurityNotification(exchange, SecurityNotification.EventType.LOGGED_OUT, account, mechanismName, true,
                 MESSAGES.userLoggedOut(account.getPrincipal().getName()), true));
 

File: core/src/main/java/io/undertow/security/impl/SecurityContextImpl.java
Patch:
@@ -107,6 +107,7 @@ private boolean authTransition() {
             return authTransition();
 
         } else {
+            UndertowLogger.SECURITY_LOGGER.debugf("Authentication result was %s for %s", authenticationState, exchange);
             // Keep in mind this switch statement is only called after a call to authTransitionRequired.
             switch (authenticationState) {
                 case NOT_ATTEMPTED: // No constraint was set that mandated authentication so not reason to hold up the request.

File: core/src/main/java/io/undertow/security/impl/SingleSignOnAuthenticationMechanism.java
Patch:
@@ -87,6 +87,7 @@ public AuthenticationMechanismOutcome authenticate(HttpServerExchange exchange,
         Cookie cookie = exchange.getRequestCookies().get(cookieName);
         if (cookie != null) {
             final String ssoId = cookie.getValue();
+            log.tracef("Found SSO cookie %s", ssoId);
             try (final SingleSignOn sso = this.singleSignOnManager.findSingleSignOn(ssoId)) {
                 if (sso != null) {
                     if(log.isTraceEnabled()) {
@@ -111,6 +112,7 @@ public void handleNotification(SecurityNotification notification) {
                             }
                         }
                     });
+                    log.tracef("Authenticated account %s using SSO", verified.getPrincipal().getName());
                     return AuthenticationMechanismOutcome.AUTHENTICATED;
                 }
             }

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -868,6 +868,7 @@ public HttpServerExchange upgradeChannel(final HttpUpgradeListener listener) {
         if(!getRequestHeaders().contains(Headers.UPGRADE)) {
             throw UndertowMessages.MESSAGES.notAnUpgradeRequest();
         }
+        UndertowLogger.REQUEST_LOGGER.debugf("Upgrading request %s", this);
         connection.setUpgradeListener(listener);
         setStatusCode(StatusCodes.SWITCHING_PROTOCOLS);
         getResponseHeaders().put(Headers.CONNECTION, Headers.UPGRADE_STRING);
@@ -887,6 +888,7 @@ public HttpServerExchange upgradeChannel(String productName, final HttpUpgradeLi
         if (!connection.isUpgradeSupported()) {
             throw UndertowMessages.MESSAGES.upgradeNotSupported();
         }
+        UndertowLogger.REQUEST_LOGGER.debugf("Upgrading request %s", this);
         connection.setUpgradeListener(listener);
         setStatusCode(StatusCodes.SWITCHING_PROTOCOLS);
         final HeaderMap headers = getResponseHeaders();

File: core/src/main/java/io/undertow/server/handlers/encoding/DeflateEncodingProvider.java
Patch:
@@ -18,6 +18,7 @@
 
 package io.undertow.server.handlers.encoding;
 
+import io.undertow.UndertowLogger;
 import io.undertow.conduits.DeflatingStreamSinkConduit;
 import io.undertow.server.ConduitWrapper;
 import io.undertow.server.HttpServerExchange;
@@ -36,6 +37,7 @@ public ConduitWrapper<StreamSinkConduit> getResponseWrapper() {
         return new ConduitWrapper<StreamSinkConduit>() {
             @Override
             public StreamSinkConduit wrap(final ConduitFactory<StreamSinkConduit> factory, final HttpServerExchange exchange) {
+                UndertowLogger.REQUEST_LOGGER.tracef("Created DEFLATE response conduit for %s", exchange);
                 return new DeflatingStreamSinkConduit(factory, exchange);
             }
         };

File: core/src/main/java/io/undertow/server/handlers/encoding/GzipEncodingProvider.java
Patch:
@@ -18,6 +18,7 @@
 
 package io.undertow.server.handlers.encoding;
 
+import io.undertow.UndertowLogger;
 import io.undertow.conduits.GzipStreamSinkConduit;
 import io.undertow.server.ConduitWrapper;
 import io.undertow.server.HttpServerExchange;
@@ -36,6 +37,7 @@ public ConduitWrapper<StreamSinkConduit> getResponseWrapper() {
         return new ConduitWrapper<StreamSinkConduit>() {
             @Override
             public StreamSinkConduit wrap(final ConduitFactory<StreamSinkConduit> factory, final HttpServerExchange exchange) {
+                UndertowLogger.REQUEST_LOGGER.tracef("Created GZIP response conduit for %s", exchange);
                 return new GzipStreamSinkConduit(factory, exchange);
             }
         };

File: core/src/main/java/io/undertow/server/handlers/form/FormEncodedDataDefinition.java
Patch:
@@ -63,6 +63,7 @@ public FormDataParser create(final HttpServerExchange exchange)  {
                     charset = cs;
                 }
             }
+            UndertowLogger.REQUEST_LOGGER.tracef("Created form encoded parser for %s", exchange);
             return new FormEncodedDataParser(charset, exchange);
         }
         return null;

File: core/src/main/java/io/undertow/server/handlers/form/MultiPartParserDefinition.java
Patch:
@@ -95,6 +95,8 @@ public void exchangeEvent(final HttpServerExchange exchange, final NextListener
             if(sizeLimit != null) {
                 exchange.setMaxEntitySize(sizeLimit);
             }
+            UndertowLogger.REQUEST_LOGGER.tracef("Created multipart parser for %s", exchange);
+
             return parser;
 
         }

File: core/src/main/java/io/undertow/server/handlers/resource/CachedResource.java
Patch:
@@ -167,6 +167,7 @@ public void serve(final Sender sender, final HttpServerExchange exchange, final
             }
             underlyingResource.serve(newSender, exchange, completionCallback);
         } else {
+            UndertowLogger.REQUEST_LOGGER.tracef("Serving resource %s from the buffer cache to %s", name, exchange);
             //serve straight from the cache
             ByteBuffer[] buffers;
             boolean ok = false;

File: core/src/main/java/io/undertow/server/handlers/sse/ServerSentEventHandler.java
Patch:
@@ -18,6 +18,7 @@
 
 package io.undertow.server.handlers.sse;
 
+import io.undertow.UndertowLogger;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.util.Headers;
@@ -83,6 +84,7 @@ public void run() {
     }
 
     private void handleConnect(StreamSinkChannel channel, HttpServerExchange exchange) {
+        UndertowLogger.REQUEST_LOGGER.debugf("Opened SSE connection to %s", exchange);
         final ServerSentEventConnection connection = new ServerSentEventConnection(exchange, channel);
         PathTemplateMatch pt = exchange.getAttachment(PathTemplateMatch.ATTACHMENT_KEY);
         if(pt != null) {

File: core/src/main/java/io/undertow/util/PipeliningExecutor.java
Patch:
@@ -29,6 +29,7 @@
  *
  * @author Stuart Douglas
  */
+@Deprecated
 public class PipeliningExecutor implements Executor {
 
     private final Executor executor;

File: core/src/main/java/io/undertow/websockets/WebSocketProtocolHandshakeHandler.java
Patch:
@@ -25,6 +25,7 @@
 import io.undertow.server.handlers.ResponseCodeHandler;
 import io.undertow.util.Methods;
 import io.undertow.websockets.core.WebSocketChannel;
+import io.undertow.websockets.core.WebSocketLogger;
 import io.undertow.websockets.core.protocol.Handshake;
 import io.undertow.websockets.core.protocol.version07.Hybi07Handshake;
 import io.undertow.websockets.core.protocol.version08.Hybi08Handshake;
@@ -186,6 +187,7 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
         if (handshaker == null) {
             next.handleRequest(exchange);
         } else {
+            WebSocketLogger.REQUEST_LOGGER.debugf("Attempting websocket handshake with %s on %s", handshaker, exchange);
             final Handshake selected = handshaker;
             if (upgradeListener == null) {
                 exchange.upgradeChannel(new HttpUpgradeListener() {

File: core/src/main/java/io/undertow/websockets/client/WebSocketClient.java
Patch:
@@ -29,6 +29,7 @@
 import io.undertow.util.Methods;
 import io.undertow.util.Protocols;
 import io.undertow.websockets.core.WebSocketChannel;
+import io.undertow.websockets.core.WebSocketLogger;
 import io.undertow.websockets.core.WebSocketVersion;
 
 import io.undertow.websockets.extensions.ExtensionHandshake;
@@ -210,6 +211,7 @@ public IoFuture<WebSocketChannel> connect() {
             return connectImpl(uri, new FutureResult<WebSocketChannel>(), 0);
         }
         private IoFuture<WebSocketChannel> connectImpl(final URI uri, final FutureResult<WebSocketChannel> ioFuture, final int redirectCount) {
+            WebSocketLogger.REQUEST_LOGGER.debugf("Opening websocket connection to %s", uri);
             final String scheme = uri.getScheme().equals("wss") ? "https" : "http";
             final URI newUri;
             try {
@@ -253,6 +255,7 @@ public void completed(ClientExchange response) {
                                         if (response.getResponse().getResponseCode() == 200) {
                                             try {
                                                 StreamConnection targetConnection = connection.performUpgrade();
+                                                WebSocketLogger.REQUEST_LOGGER.debugf("Established websocket connection to %s", uri);
                                                 if(uri.getScheme().equals("wss") || uri.getScheme().equals("https")) {
                                                     handleConnectionWithExistingConnection(((UndertowXnioSsl)ssl).wrapExistingConnection(targetConnection, optionMap));
                                                 } else {

File: core/src/main/java/io/undertow/websockets/extensions/PerMessageDeflateHandshake.java
Patch:
@@ -151,6 +151,7 @@ public WebSocketExtension accept(final WebSocketExtension extension) {
                 return null;
             }
         }
+        WebSocketLogger.EXTENSION_LOGGER.debugf("Negotiated extension %s for handshake %s", negotiated, extension);
         return negotiated;
     }
 

File: parser-generator/src/main/java/io/undertow/annotationprocessor/RequestParserGenerator.java
Patch:
@@ -44,8 +44,8 @@ public class RequestParserGenerator extends AbstractParserGenerator {
     public static final int HEADER = 6;
     public static final int HEADER_VALUE = 7;
 
-    public RequestParserGenerator() {
-        super(PARSE_STATE_CLASS, HTTP_EXCHANGE_CLASS, "(Lorg/xnio/OptionMap;)V");
+    public RequestParserGenerator(String existingClassName) {
+        super(PARSE_STATE_CLASS, HTTP_EXCHANGE_CLASS, "(Lorg/xnio/OptionMap;)V", existingClassName);
     }
 
     protected void createStateMachines(final String[] httpVerbs, final String[] httpVersions, final String[] standardHeaders, final String className, final ClassFile file, final ClassMethod sctor, final AtomicInteger fieldCounter) {

File: parser-generator/src/main/java/io/undertow/annotationprocessor/ResponseParserGenerator.java
Patch:
@@ -44,8 +44,8 @@ public class ResponseParserGenerator extends AbstractParserGenerator {
     public static final int PARSE_COMPLETE = 6;
 
 
-    public ResponseParserGenerator() {
-        super(PARSE_STATE_CLASS, HTTP_RESPONSE_CLASS, "()V");
+    public ResponseParserGenerator(String existingClassName) {
+        super(PARSE_STATE_CLASS, HTTP_RESPONSE_CLASS, "()V", existingClassName);
     }
 
 

File: core/src/main/java/io/undertow/client/http2/Http2ClientConnection.java
Patch:
@@ -33,6 +33,7 @@
 import io.undertow.protocols.http2.Http2GoAwayStreamSourceChannel;
 import io.undertow.protocols.http2.Http2PushPromiseStreamSourceChannel;
 import io.undertow.util.HeaderValues;
+import io.undertow.util.NetworkUtils;
 import io.undertow.util.Protocols;
 import org.xnio.ChannelExceptionHandler;
 import org.xnio.ChannelListener;
@@ -170,7 +171,7 @@ public void sendRequest(ClientRequest request, ClientCallback<ClientExchange> cl
         }
         String hn = request.getAttachment(ProxiedRequestAttachments.SERVER_NAME);
         if(hn != null) {
-            request.getRequestHeaders().put(Headers.X_FORWARDED_HOST, hn);
+            request.getRequestHeaders().put(Headers.X_FORWARDED_HOST, NetworkUtils.formatPossibleIpv6Address(hn));
         }
         Integer port = request.getAttachment(ProxiedRequestAttachments.SERVER_PORT);
         if(port != null) {

File: core/src/main/java/io/undertow/server/handlers/proxy/ProxyHandler.java
Patch:
@@ -50,6 +50,7 @@
 import io.undertow.util.HeaderValues;
 import io.undertow.util.Headers;
 import io.undertow.util.HttpString;
+import io.undertow.util.NetworkUtils;
 import io.undertow.util.SameThreadExecutor;
 import io.undertow.util.StatusCodes;
 import io.undertow.util.Transfer;
@@ -455,7 +456,7 @@ public void run() {
             if(!exchange.getRequestHeaders().contains(Headers.X_FORWARDED_HOST)) {
                 final String hostName = exchange.getHostName();
                 if(hostName != null) {
-                    request.getRequestHeaders().put(Headers.X_FORWARDED_HOST, hostName);
+                    request.getRequestHeaders().put(Headers.X_FORWARDED_HOST, NetworkUtils.formatPossibleIpv6Address(hostName));
                 }
             }
 
@@ -470,7 +471,7 @@ public void run() {
                     request.putAttachment(ProxiedRequestAttachments.SERVER_PORT, port);
                 }
             } else {
-                int port = exchange.getConnection().getLocalAddress(InetSocketAddress.class).getPort();
+                int port = exchange.getHostPort();
                 request.getRequestHeaders().put(Headers.X_FORWARDED_PORT, port);
                 request.putAttachment(ProxiedRequestAttachments.SERVER_PORT, port);
             }

File: core/src/main/java/io/undertow/server/Connectors.java
Patch:
@@ -221,6 +221,7 @@ public static void executeRootHandler(final HttpHandler handler, final HttpServe
                 exchange.endExchange();
             }
         } catch (Throwable t) {
+            exchange.putAttachment(DefaultResponseListener.EXCEPTION, t);
             exchange.setInCall(false);
             if (!exchange.isResponseStarted()) {
                 exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);

File: core/src/main/java/io/undertow/server/handlers/builder/PredicatedHandlersParser.java
Patch:
@@ -704,7 +704,7 @@ public static Deque<Token> tokenize(final String string) {
         return ret;
     }
 
-    public static IllegalStateException error(final String string, int pos, String reason) {
+    private static IllegalStateException error(final String string, int pos, String reason) {
         StringBuilder b = new StringBuilder();
         int linePos = 0;
         for (int i = 0; i < string.length(); ++i) {

File: core/src/main/java/io/undertow/conduits/DeflatingStreamSinkConduit.java
Patch:
@@ -52,7 +52,6 @@
  */
 public class DeflatingStreamSinkConduit implements StreamSinkConduit {
 
-    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
     protected final Deflater deflater;
     private final ConduitFactory<StreamSinkConduit> conduitFactory;
     private final HttpServerExchange exchange;

File: core/src/main/java/io/undertow/protocols/http2/Http2StreamSinkChannel.java
Patch:
@@ -71,10 +71,10 @@ protected void channelForciblyClosed() throws IOException {
         if (streamId % 2 == (getChannel().isClient() ? 1 : 0)) {
             //we initiated the stream
             //we only actually reset if we have sent something to the other endpoint
-            if (isFirstDataWritten()) {
+            if (isFirstDataWritten() && !getChannel().isThisGoneAway()) {
                 getChannel().sendRstStream(streamId, Http2Channel.ERROR_CANCEL);
             }
-        } else {
+        } else if(!getChannel().isThisGoneAway()) {
             getChannel().sendRstStream(streamId, Http2Channel.ERROR_STREAM_CLOSED);
         }
         markBroken();

File: core/src/main/java/io/undertow/protocols/http2/Http2StreamSourceChannel.java
Patch:
@@ -133,7 +133,7 @@ public long transferTo(long position, long count, FileChannel target) throws IOE
         return read;
     }
 
-    private void updateFlowControlWindow(final int read) {
+    private void updateFlowControlWindow(final int read) throws IOException {
         if (read <= 0) {
             return;
         }

File: core/src/main/java/io/undertow/io/AsyncReceiverImpl.java
Patch:
@@ -439,11 +439,11 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                                                     return;
                                                 }
                                             }
-                                        } catch (final IOException e) {
+                                        } catch (final Exception e) {
                                             Connectors.executeRootHandler(new HttpHandler() {
                                                 @Override
                                                 public void handleRequest(HttpServerExchange exchange) throws Exception {
-                                                    error.error(exchange, e);
+                                                    error.error(exchange, new IOException(e));
                                                 }
                                             }, exchange);
                                             return;

File: core/src/main/java/io/undertow/protocols/http2/Http2Channel.java
Patch:
@@ -349,10 +349,10 @@ protected AbstractHttp2StreamSourceChannel createChannel(FrameHeaderData frameHe
                 //the peer is going away
                 //everything is broken
                 for(Http2StreamSourceChannel stream : incomingStreams.values()) {
-                    stream.close();
+                    stream.rstStream();
                 }
                 for(Http2StreamSinkChannel stream : outgoingStreams.values()) {
-                    stream.close();
+                    stream.rstStream();
                 }
                 break;
             }

File: core/src/main/java/io/undertow/protocols/spdy/SpdyChannel.java
Patch:
@@ -178,10 +178,10 @@ protected SpdyStreamSourceChannel createChannel(FrameHeaderData frameHeaderData,
                 //the peer is going away
                 //everything is broken
                 for(SpdyStreamStreamSourceChannel stream : incomingStreams.values()) {
-                    stream.close();
+                    stream.rstStream();
                 }
                 for(SpdyStreamStreamSinkChannel stream : outgoingStreams.values()) {
-                    stream.close();
+                    stream.rstStream();
                 }
                 break;
             }

File: servlet/src/test/java/io/undertow/servlet/test/dispatcher/DispatcherForwardTestCase.java
Patch:
@@ -36,6 +36,7 @@
 import io.undertow.testutils.DefaultServer;
 import io.undertow.testutils.HttpClientUtils;
 import io.undertow.testutils.TestHttpClient;
+import io.undertow.util.Protocols;
 import io.undertow.util.StatusCodes;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
@@ -127,7 +128,8 @@ public void testPathBasedInclude() throws IOException, InterruptedException {
             Assert.assertEquals("Path!Name!forwarded", response);
             latch.await(30, TimeUnit.SECONDS);
             //UNDERTOW-327 make sure that the access log includes the original path
-            Assert.assertEquals("GET /servletContext/dispatch HTTP/1.1 /servletContext/dispatch /dispatch", message);
+            String protocol = DefaultServer.isH2() ? Protocols.HTTP_2_0_STRING : Protocols.HTTP_1_1_STRING;
+            Assert.assertEquals("GET /servletContext/dispatch " + protocol + " /servletContext/dispatch /dispatch", message);
         } finally {
             client.getConnectionManager().shutdown();
         }

File: core/src/main/java/io/undertow/websockets/core/WebSockets.java
Patch:
@@ -425,9 +425,7 @@ public void handleException(StreamSinkFrameChannel channel, IOException exceptio
                             if (callback != null) {
                                 callback.onError(wsChannel, context, exception);
                             }
-                            if (type == WebSocketFrameType.CLOSE && wsChannel.isCloseFrameReceived()) {
-                                IoUtils.safeClose(wsChannel);
-                            }
+                            IoUtils.safeClose(channel, wsChannel);
                         }
                     }
             ));

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/SendResultFuture.java
Patch:
@@ -40,7 +40,7 @@ final class SendResultFuture<T> implements Future<Void>, WebSocketCallback<T> {
     @Override
     public synchronized void complete(WebSocketChannel channel, T context) {
         if (done) {
-            throw new IllegalStateException();
+            return;
         }
 
         if (waiters > 0) {
@@ -52,7 +52,7 @@ public synchronized void complete(WebSocketChannel channel, T context) {
     @Override
     public synchronized void onError(WebSocketChannel channel, T context, Throwable throwable) {
         if (done) {
-            throw new IllegalStateException();
+            return;
         }
         exception = throwable;
         done = true;

File: core/src/main/java/io/undertow/channels/WriteTimeoutStreamSinkChannel.java
Patch:
@@ -40,6 +40,7 @@
  * @author Stuart Douglas
  * @see org.xnio.Options#WRITE_TIMEOUT
  */
+@Deprecated
 public final class WriteTimeoutStreamSinkChannel extends DelegatingStreamSinkChannel<WriteTimeoutStreamSinkChannel> {
 
     private int writeTimeout;

File: core/src/main/java/io/undertow/UndertowLogger.java
Patch:
@@ -60,6 +60,7 @@ public interface UndertowLogger extends BasicLogger {
     UndertowLogger CLIENT_LOGGER = Logger.getMessageLogger(UndertowLogger.class, ClientConnection.class.getPackage().getName());
 
     UndertowLogger REQUEST_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + ".request");
+    UndertowLogger SECURITY_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + ".request.security");
     UndertowLogger PROXY_REQUEST_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + ".proxy");
     UndertowLogger REQUEST_DUMPER_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + ".request.dump");
     /**

File: core/src/main/java/io/undertow/security/impl/AbstractSecurityContext.java
Patch:
@@ -18,6 +18,8 @@
 package io.undertow.security.impl;
 
 import static io.undertow.UndertowMessages.MESSAGES;
+
+import io.undertow.UndertowLogger;
 import io.undertow.security.api.NotificationReceiver;
 import io.undertow.security.api.SecurityContext;
 import io.undertow.security.api.SecurityNotification;
@@ -82,6 +84,7 @@ protected void authenticationComplete(Account account, String mechanism, boolean
         this.account = account;
         this.mechanismName = mechanism;
 
+        UndertowLogger.SECURITY_LOGGER.debugf("Authenticated as %s, roles %s", account.getPrincipal().getName(), account.getRoles());
         sendNoticiation(new SecurityNotification(exchange, EventType.AUTHENTICATED, account, mechanism, programatic,
                 MESSAGES.userAuthenticated(account.getPrincipal().getName()), cachingRequired));
     }

File: servlet/src/main/java/io/undertow/servlet/handlers/security/ServletSecurityConstraintHandler.java
Patch:
@@ -17,6 +17,7 @@
  */
 package io.undertow.servlet.handlers.security;
 
+import io.undertow.UndertowLogger;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.servlet.api.SingleConstraintMatch;
@@ -53,6 +54,8 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
         if (type == null || type.ordinal() < securityMatch.getTransportGuaranteeType().ordinal()) {
             servletRequestContext.setTransportGuarenteeType(securityMatch.getTransportGuaranteeType());
         }
+
+        UndertowLogger.SECURITY_LOGGER.debugf("Security constraints for request %s are %s", exchange.getRequestURI(), list);
         next.handleRequest(exchange);
     }
 }

File: core/src/main/java/io/undertow/util/HttpString.java
Patch:
@@ -109,7 +109,7 @@ public HttpString(final String string) {
         for (int i = 0; i < len; i++) {
             char c = string.charAt(i);
             if (c > 0xff) {
-                throw new IllegalArgumentException("Invalid string contents");
+                throw new IllegalArgumentException("Invalid string contents " + string);
             }
             bytes[i] = (byte) c;
         }

File: core/src/test/java/io/undertow/websockets/extensions/AutobahnExtensionsServer.java
Patch:
@@ -74,8 +74,6 @@ public void run() {
         xnio = Xnio.getInstance();
         try {
             worker = xnio.createWorker(OptionMap.builder()
-                    .set(Options.WORKER_WRITE_THREADS, 4)
-                    .set(Options.WORKER_READ_THREADS, 4)
                     .set(Options.CONNECTION_HIGH_WATER, 1000000)
                     .set(Options.CONNECTION_LOW_WATER, 1000000)
                     .set(Options.WORKER_TASK_CORE_THREADS, 10)
@@ -85,7 +83,6 @@ public void run() {
                     .getMap());
 
             OptionMap serverOptions = OptionMap.builder()
-                    .set(Options.WORKER_ACCEPT_THREADS, 4)
                     .set(Options.TCP_NODELAY, true)
                     .set(Options.REUSE_ADDRESSES, true)
                     .getMap();

File: core/src/main/java/io/undertow/websockets/client/WebSocket13ClientHandshake.java
Patch:
@@ -87,7 +87,7 @@ public WebSocketChannel createChannel(final StreamConnection channel, final Stri
             }
             return new WebSocket13Channel(channel, bufferPool, wsUri, negotiation.getSelectedSubProtocol(), true, !negotiated.isEmpty(), CompositeExtensionFunction.compose(negotiated), new HashSet<WebSocketChannel>(), options);
         } else {
-            return new WebSocket13Channel(channel, bufferPool, wsUri, negotiation != null ? negotiation.getSelectedSubProtocol() : "", true, false, NoopExtensionFunction.instance, new HashSet<WebSocketChannel>(), options);
+            return new WebSocket13Channel(channel, bufferPool, wsUri, negotiation != null ? negotiation.getSelectedSubProtocol() : "", true, false, NoopExtensionFunction.INSTANCE, new HashSet<WebSocketChannel>(), options);
         }
     }
 

File: core/src/main/java/io/undertow/websockets/core/StreamSourceFrameChannel.java
Patch:
@@ -72,7 +72,7 @@ protected StreamSourceFrameChannel(WebSocketChannel wsChannel, WebSocketFrameTyp
         if (rsv > 0) {
             this.extensionFunction = wsChannel.getExtensionFunction();
         } else {
-            this.extensionFunction = NoopExtensionFunction.instance;
+            this.extensionFunction = NoopExtensionFunction.INSTANCE;
         }
     }
 

File: core/src/main/java/io/undertow/websockets/core/WebSocketChannel.java
Patch:
@@ -164,12 +164,12 @@ protected FrameHeaderData parseFrame(ByteBuffer data) throws IOException {
             partialFrame.handle(data);
         } catch (WebSocketException e) {
             //the data was corrupt
+            //send a close message
+            WebSockets.sendClose(new CloseMessage(CloseMessage.WRONG_CODE, e.getMessage()).toByteBuffer(), this, null);
             markReadsBroken(e);
             if (WebSocketLogger.REQUEST_LOGGER.isDebugEnabled()) {
                 WebSocketLogger.REQUEST_LOGGER.debugf(e, "receive failed due to Exception");
             }
-            //send a close message
-            WebSockets.sendClose(new CloseMessage(CloseMessage.WRONG_CODE, e.getMessage()).toByteBuffer(), this, null);
 
             throw new IOException(e);
         }

File: core/src/main/java/io/undertow/websockets/core/protocol/Handshake.java
Patch:
@@ -225,7 +225,7 @@ public final void addExtension(ExtensionHandshake extension) {
      * @param exchange the exchange used to retrieve negotiated extensions
      * @return         a list of {@code ExtensionFunction} with the implementation of the extensions
      */
-    protected final ExtensionFunction initExtensions(final WebSocketHttpExchange exchange) {
+    protected final List<ExtensionFunction> initExtensions(final WebSocketHttpExchange exchange) {
         String extHeader = exchange.getResponseHeaders().get(Headers.SEC_WEB_SOCKET_EXTENSIONS_STRING) != null ?
                 exchange.getResponseHeaders().get(Headers.SEC_WEB_SOCKET_EXTENSIONS_STRING).get(0) : null;
 
@@ -242,6 +242,6 @@ protected final ExtensionFunction initExtensions(final WebSocketHttpExchange exc
                 }
             }
         }
-        return CompositeExtensionFunction.compose(negotiated);
+        return negotiated;
     }
 }

File: core/src/main/java/io/undertow/websockets/core/protocol/version07/WebSocket07FrameSinkChannel.java
Patch:
@@ -56,7 +56,7 @@ protected WebSocket07FrameSinkChannel(WebSocket07Channel wsChannel, WebSocketFra
             extensionFunction = wsChannel.getExtensionFunction();
             setRsv(extensionFunction.writeRsv(0));
         } else {
-            extensionFunction = NoopExtensionFunction.instance;
+            extensionFunction = NoopExtensionFunction.INSTANCE;
             setRsv(0);
         }
     }

File: core/src/main/java/io/undertow/websockets/extensions/CompositeExtensionFunction.java
Patch:
@@ -16,14 +16,14 @@ private CompositeExtensionFunction(ExtensionFunction... delegates) {
 
     public static ExtensionFunction compose(List<ExtensionFunction> functions) {
         if (null == functions) {
-            return NoopExtensionFunction.instance;
+            return NoopExtensionFunction.INSTANCE;
         }
         return compose(functions.toArray(new ExtensionFunction[functions.size()]));
     }
 
     public static ExtensionFunction compose(ExtensionFunction... functions) {
         if (functions == null || functions.length == 0) {
-            return NoopExtensionFunction.instance;
+            return NoopExtensionFunction.INSTANCE;
         } else if (functions.length == 1) {
             return functions[0];
         }

File: core/src/main/java/io/undertow/websockets/extensions/NoopExtensionFunction.java
Patch:
@@ -6,7 +6,7 @@
 import java.io.IOException;
 
 public class NoopExtensionFunction implements ExtensionFunction {
-    public static final ExtensionFunction instance = new NoopExtensionFunction();
+    public static final ExtensionFunction INSTANCE = new NoopExtensionFunction();
 
     @Override
     public boolean hasExtensionOpCode() {

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/UndertowContainerProvider.java
Patch:
@@ -51,7 +51,7 @@ public class UndertowContainerProvider extends ContainerProvider {
 
     private static final Map<ClassLoader, WebSocketContainer> webSocketContainers = new ConcurrentHashMap<>();
 
-    private static volatile WebSocketContainer defaultContainer;
+    private static volatile ServerWebSocketContainer defaultContainer;
     private static volatile boolean defaultContainerDisabled = false;
 
     private static final SwitchableClassIntrospector defaultIntrospector = new SwitchableClassIntrospector();
@@ -76,7 +76,7 @@ public ClassLoader run() {
         return webSocketContainer;
     }
 
-    private WebSocketContainer getDefaultContainer() {
+    static ServerWebSocketContainer getDefaultContainer() {
         if(defaultContainerDisabled) {
             return null;
         }

File: core/src/main/java/io/undertow/server/handlers/proxy/ProxyHandler.java
Patch:
@@ -167,7 +167,7 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
             return;
         }
         final long timeout = maxRequestTime > 0 ? System.currentTimeMillis() + maxRequestTime : 0;
-        final ProxyClientHandler clientHandler = new ProxyClientHandler(exchange, target, timeout, DEFAULT_MAX_RETRY_ATTEMPTS);
+        final ProxyClientHandler clientHandler = new ProxyClientHandler(exchange, target, timeout, maxConnectionRetries);
         if (timeout > 0) {
             final XnioExecutor.Key key = exchange.getIoThread().executeAfter(new Runnable() {
                 @Override

File: core/src/test/java/io/undertow/server/handlers/proxy/LoadBalancingProxyAJPTestCase.java
Patch:
@@ -60,7 +60,7 @@ public static void setup() throws URISyntaxException {
                 .setConnectionsPerThread(16)
                 .addHost(new URI("ajp", null, DefaultServer.getHostAddress("default"), port + 1, null, null, null), "s1")
                 .addHost(new URI("ajp", null, DefaultServer.getHostAddress("default"), port + 2, null, null, null), "s2")
-                , 10000, ResponseCodeHandler.HANDLE_404));
+                , 10000, ResponseCodeHandler.HANDLE_404, false, false , 2));
     }
 
 }

File: core/src/test/java/io/undertow/server/handlers/proxy/LoadBalancingProxyHTTP2TestCase.java
Patch:
@@ -102,7 +102,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                 .setConnectionsPerThread(4)
                 .addHost(new URI("https", null, DefaultServer.getHostAddress("default"), port + 1, null, null, null), "s1", ssl, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true))
                 .addHost(new URI("https", null, DefaultServer.getHostAddress("default"), port + 2, null, null, null), "s2", ssl, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true))
-                , 10000, ResponseCodeHandler.HANDLE_404));
+                , 10000, ResponseCodeHandler.HANDLE_404, false, false , 2));
     }
 
 

File: core/src/test/java/io/undertow/server/handlers/proxy/LoadBalancingProxyHTTP2ViaUpgradeTestCase.java
Patch:
@@ -96,7 +96,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                 .setConnectionsPerThread(4)
                 .addHost(new URI("h2c", null, DefaultServer.getHostAddress("default"), port + 1, null, null, null), "s1")
                 .addHost(new URI("h2c", null, DefaultServer.getHostAddress("default"), port + 2, null, null, null), "s2")
-                , 10000, ResponseCodeHandler.HANDLE_404));
+                , 10000, ResponseCodeHandler.HANDLE_404, false, false , 2));
     }
 
     @Test

File: core/src/test/java/io/undertow/server/handlers/proxy/LoadBalancingProxyHttpsTestCase.java
Patch:
@@ -77,7 +77,7 @@ public static void setup() throws URISyntaxException {
                 .setConnectionsPerThread(4)
                 .addHost(new URI("https", null, DefaultServer.getHostAddress("default"), port + 1, null, null, null), "s1", ssl, OptionMap.create(UndertowOptions.ENABLE_SPDY, false))
                 .addHost(new URI("https", null, DefaultServer.getHostAddress("default"), port + 2, null, null, null), "s2", ssl, OptionMap.create(UndertowOptions.ENABLE_SPDY, false))
-                , 10000, ResponseCodeHandler.HANDLE_404));
+                , 10000, ResponseCodeHandler.HANDLE_404, false, false , 2));
     }
 
 }

File: core/src/test/java/io/undertow/server/handlers/proxy/LoadBalancingProxySPDYTestCase.java
Patch:
@@ -82,7 +82,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                 .setConnectionsPerThread(4)
                 .addHost(new URI("https", null, DefaultServer.getHostAddress("default"), port + 1, null, null, null), "s1", ssl, OptionMap.create(UndertowOptions.ENABLE_SPDY, true))
                 .addHost(new URI("https", null, DefaultServer.getHostAddress("default"), port + 2, null, null, null), "s2", ssl, OptionMap.create(UndertowOptions.ENABLE_SPDY, true))
-                , 10000, ResponseCodeHandler.HANDLE_404));
+                , 10000, ResponseCodeHandler.HANDLE_404, false, false , 2));
     }
 
 

File: core/src/test/java/io/undertow/server/handlers/proxy/LoadBalancingProxyTestCase.java
Patch:
@@ -58,7 +58,7 @@ public static void setup() throws URISyntaxException {
                 .setConnectionsPerThread(4)
                 .addHost(new URI("http", null, DefaultServer.getHostAddress("default"), port + 1, null, null, null), "s1")
                 .addHost(new URI("http", null, DefaultServer.getHostAddress("default"), port + 2, null, null, null), "s2")
-                , 10000, ResponseCodeHandler.HANDLE_404));
+                , 10000, ResponseCodeHandler.HANDLE_404, false, false , 1));
     }
 
 }

File: core/src/test/java/io/undertow/server/handlers/proxy/LoadBalancingProxyHTTP2ViaUpgradeTestCase.java
Patch:
@@ -66,7 +66,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                             throw new RuntimeException("Not HTTP2");
                         }
                         exchange.getResponseHeaders().add(new HttpString("X-Custom-Header"), "foo");
-                        System.out.println(exchange.getRequestHeaders());
+                        System.out.println("server1 " + exchange.getRequestHeaders());
                         handler1.handleRequest(exchange);
                     }
                 }))
@@ -84,7 +84,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                             throw new RuntimeException("Not HTTP2");
                         }
                         exchange.getResponseHeaders().add(new HttpString("X-Custom-Header"), "foo");
-                        System.out.println(exchange.getRequestHeaders());
+                        System.out.println("server2 " + exchange.getRequestHeaders());
                         handler2.handleRequest(exchange);
                     }
                 }))

File: core/src/main/java/io/undertow/UndertowLogger.java
Patch:
@@ -67,6 +67,7 @@ public interface UndertowLogger extends BasicLogger {
      * attacker to fill up the logs by intentionally causing IO exceptions.
      */
     UndertowLogger REQUEST_IO_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + ".request.io");
+    UndertowLogger ERROR_RESPONSE = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + ".request.error-response");
 
     @LogMessage(level = ERROR)
     @Message(id = 5001, value = "An exception occurred processing the request")

File: core/src/main/java/io/undertow/server/handlers/ByteRangeHandler.java
Patch:
@@ -18,6 +18,7 @@
 
 package io.undertow.server.handlers;
 
+import io.undertow.conduits.HeadStreamSinkConduit;
 import io.undertow.conduits.RangeStreamSinkConduit;
 import io.undertow.server.ConduitWrapper;
 import io.undertow.server.HandlerWrapper;
@@ -106,7 +107,7 @@ public StreamSinkConduit wrap(ConduitFactory<StreamSinkConduit> factory, HttpSer
                         exchange.getResponseHeaders().put(Headers.CONTENT_RANGE, rangeResponse.getContentRange());
                         exchange.setResponseContentLength(rangeResponse.getContentLength());
                         if(rangeResponse.getStatusCode() == StatusCodes.REQUEST_RANGE_NOT_SATISFIABLE) {
-                            return new RangeStreamSinkConduit(factory.create(), 0, 0, responseLength);
+                            return new HeadStreamSinkConduit(factory.create(), null, true);
                         }
                         return new RangeStreamSinkConduit(factory.create(), start, end, responseLength);
                     } else {

File: core/src/test/java/io/undertow/server/handlers/sse/ServerSentEventTestCase.java
Patch:
@@ -171,7 +171,7 @@ public void connected(ServerSentEventConnection connection, String lastEventId)
                     connection.send(sb.toString(), new ServerSentEventConnection.EventCallback() {
                         @Override
                         public void done(ServerSentEventConnection connection, String data, String event, String id) {
-                            IoUtils.safeClose(connection);
+                            connection.shutdown();
                         }
 
                         @Override

File: core/src/test/java/io/undertow/server/handlers/sse/ServerSentEventTestCase.java
Patch:
@@ -63,7 +63,7 @@ public void done(ServerSentEventConnection connection, String data, String event
                             connection.send("msg 2", new ServerSentEventConnection.EventCallback() {
                                 @Override
                                 public void done(ServerSentEventConnection connection, String data, String event, String id) {
-                                    IoUtils.safeClose(connection);
+                                    connection.shutdown();
                                 }
 
                                 @Override

File: core/src/main/java/io/undertow/server/handlers/ByteRangeHandler.java
Patch:
@@ -128,7 +128,7 @@ public StreamSinkConduit wrap(ConduitFactory<StreamSinkConduit> factory, HttpSer
                         exchange.setResponseContentLength(toWrite);
                     }
                     exchange.setStatusCode(StatusCodes.PARTIAL_CONTENT);
-                    exchange.getResponseHeaders().put(Headers.CONTENT_RANGE, start + "-" + end + "/" + responseLength);
+                    exchange.getResponseHeaders().put(Headers.CONTENT_RANGE, "bytes " + start + "-" + end + "/" + responseLength);
                     return new RangeStreamSinkConduit(factory.create(), start, end, responseLength);
                 }
             });

File: core/src/main/java/io/undertow/server/handlers/resource/ResourceHandler.java
Patch:
@@ -268,7 +268,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                         }
                         if(range != null) {
                             exchange.setStatusCode(StatusCodes.PARTIAL_CONTENT);
-                            exchange.getResponseHeaders().put(Headers.CONTENT_RANGE, start + "-" + end + "/" + contentLength);
+                            exchange.getResponseHeaders().put(Headers.CONTENT_RANGE, "bytes " + start + "-" + end + "/" + contentLength);
                         }
                     }
                 }

File: servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java
Patch:
@@ -343,7 +343,7 @@ private void serveFileBlocking(final HttpServletRequest req, final HttpServletRe
                         }
                         if(range != null) {
                             resp.setStatus(StatusCodes.PARTIAL_CONTENT);
-                            resp.setHeader(Headers.CONTENT_RANGE_STRING, range.getStart(0) + "-" + range.getEnd(0) + "/" + contentLength);
+                            resp.setHeader(Headers.CONTENT_RANGE_STRING, "bytes " + range.getStart(0) + "-" + range.getEnd(0) + "/" + contentLength);
                         }
                     } else {
                         resp.setHeader(Headers.ACCEPT_RANGES_STRING, "bytes");

File: core/src/main/java/io/undertow/channels/DetachableStreamSinkChannel.java
Patch:
@@ -274,7 +274,7 @@ private static class SetterDelegatingListener implements ChannelListener<StreamS
         private final SimpleSetter<StreamSinkChannel> setter;
         private final StreamSinkChannel channel;
 
-        public SetterDelegatingListener(final SimpleSetter<StreamSinkChannel> setter, final StreamSinkChannel channel) {
+        SetterDelegatingListener(final SimpleSetter<StreamSinkChannel> setter, final StreamSinkChannel channel) {
             this.setter = setter;
             this.channel = channel;
         }

File: core/src/main/java/io/undertow/channels/DetachableStreamSourceChannel.java
Patch:
@@ -220,7 +220,7 @@ private static class SetterDelegatingListener implements ChannelListener<StreamS
         private final SimpleSetter<StreamSourceChannel> setter;
         private final StreamSourceChannel channel;
 
-        public SetterDelegatingListener(final SimpleSetter<StreamSourceChannel> setter, final StreamSourceChannel channel) {
+        SetterDelegatingListener(final SimpleSetter<StreamSourceChannel> setter, final StreamSourceChannel channel) {
             this.setter = setter;
             this.channel = channel;
         }

File: core/src/main/java/io/undertow/client/ajp/AjpClientExchange.java
Patch:
@@ -64,7 +64,7 @@ class AjpClientExchange extends AbstractAttachable implements ClientExchange {
     private static final int REQUEST_TERMINATED = 1;
     private static final int RESPONSE_TERMINATED = 1 << 1;
 
-    public AjpClientExchange(ClientCallback<ClientExchange> readyCallback, ClientRequest request, AjpClientConnection clientConnection) {
+    AjpClientExchange(ClientCallback<ClientExchange> readyCallback, ClientRequest request, AjpClientConnection clientConnection) {
         this.readyCallback = readyCallback;
         this.request = request;
         this.clientConnection = clientConnection;

File: core/src/main/java/io/undertow/client/http/ClientFixedLengthStreamSinkConduit.java
Patch:
@@ -34,7 +34,7 @@ class ClientFixedLengthStreamSinkConduit extends AbstractFixedLengthStreamSinkCo
      * @param propagateClose {@code true} if this instance should pass close to the next
      * @param exchange
      */
-    public ClientFixedLengthStreamSinkConduit(StreamSinkConduit next, long contentLength, boolean configurable, boolean propagateClose, HttpClientExchange exchange) {
+    ClientFixedLengthStreamSinkConduit(StreamSinkConduit next, long contentLength, boolean configurable, boolean propagateClose, HttpClientExchange exchange) {
         super(next, contentLength, configurable, propagateClose);
         this.exchange = exchange;
     }

File: core/src/main/java/io/undertow/client/http/HttpClientExchange.java
Patch:
@@ -57,7 +57,7 @@ class HttpClientExchange extends AbstractAttachable implements ClientExchange {
     private static final int REQUEST_TERMINATED = 1;
     private static final int RESPONSE_TERMINATED = 1 << 1;
 
-    public HttpClientExchange(ClientCallback<ClientExchange> readyCallback, ClientRequest request, HttpClientConnection clientConnection) {
+    HttpClientExchange(ClientCallback<ClientExchange> readyCallback, ClientRequest request, HttpClientConnection clientConnection) {
         this.readyCallback = readyCallback;
         this.request = request;
         this.clientConnection = clientConnection;

File: core/src/main/java/io/undertow/client/http/ResponseParseState.java
Patch:
@@ -80,7 +80,7 @@ class ResponseParseState {
      */
     HttpString nextHeader;
 
-    public ResponseParseState() {
+    ResponseParseState() {
         this.parseState = 0;
         this.pos = 0;
     }

File: core/src/main/java/io/undertow/client/http2/Http2ClearClientProvider.java
Patch:
@@ -193,7 +193,7 @@ private static class Http2ClearOpenListener implements ChannelListener<StreamCon
         private final ClientCallback<ClientConnection> listener;
         private final String defaultHost;
 
-        public Http2ClearOpenListener(ByteBufferPool bufferPool, OptionMap options, ClientCallback<ClientConnection> listener, String defaultHost) {
+        Http2ClearOpenListener(ByteBufferPool bufferPool, OptionMap options, ClientCallback<ClientConnection> listener, String defaultHost) {
             this.bufferPool = bufferPool;
             this.options = options;
             this.listener = listener;
@@ -233,7 +233,7 @@ public void activity(long bytes) {
     private static class FailedNotifier implements IoFuture.Notifier<StreamConnection, Object> {
         private final ClientCallback<ClientConnection> listener;
 
-        public FailedNotifier(ClientCallback<ClientConnection> listener) {
+        FailedNotifier(ClientCallback<ClientConnection> listener) {
             this.listener = listener;
         }
 

File: core/src/main/java/io/undertow/conduits/ChunkReader.java
Patch:
@@ -60,7 +60,7 @@ class ChunkReader<T extends Conduit> {
     private final ConduitListener<? super T> finishListener;
     private final T conduit;
 
-    public ChunkReader(final Attachable attachable, final AttachmentKey<HeaderMap> trailerAttachmentKey, ConduitListener<? super T> finishListener, T conduit) {
+    ChunkReader(final Attachable attachable, final AttachmentKey<HeaderMap> trailerAttachmentKey, ConduitListener<? super T> finishListener, T conduit) {
         this.attachable = attachable;
         this.trailerAttachmentKey = trailerAttachmentKey;
         this.finishListener = finishListener;

File: core/src/main/java/io/undertow/predicate/AndPredicate.java
Patch:
@@ -27,7 +27,7 @@ class AndPredicate implements Predicate {
 
     private final Predicate[] predicates;
 
-    public AndPredicate(final Predicate ... predicates) {
+    AndPredicate(final Predicate ... predicates) {
         this.predicates = predicates;
     }
 

File: core/src/main/java/io/undertow/predicate/MaxContentSizePredicate.java
Patch:
@@ -35,7 +35,7 @@ class MaxContentSizePredicate implements Predicate {
 
     private final long maxSize;
 
-    public MaxContentSizePredicate(final long maxSize) {
+    MaxContentSizePredicate(final long maxSize) {
         this.maxSize = maxSize;
     }
 

File: core/src/main/java/io/undertow/predicate/MinContentSizePredicate.java
Patch:
@@ -35,7 +35,7 @@ class MinContentSizePredicate implements Predicate {
 
     private final long minSize;
 
-    public MinContentSizePredicate(final long minSize) {
+    MinContentSizePredicate(final long minSize) {
         this.minSize = minSize;
     }
 

File: core/src/main/java/io/undertow/predicate/NotPredicate.java
Patch:
@@ -27,7 +27,7 @@ class NotPredicate implements Predicate {
 
     private final Predicate predicate;
 
-    public NotPredicate(final Predicate predicate) {
+    NotPredicate(final Predicate predicate) {
         this.predicate = predicate;
     }
 

File: core/src/main/java/io/undertow/predicate/OrPredicate.java
Patch:
@@ -27,7 +27,7 @@ class OrPredicate implements Predicate {
 
     private final Predicate[] predicates;
 
-    public OrPredicate(final Predicate... predicates) {
+    OrPredicate(final Predicate... predicates) {
         this.predicates = predicates;
     }
 

File: core/src/main/java/io/undertow/predicate/PathMatchPredicate.java
Patch:
@@ -32,7 +32,7 @@ class PathMatchPredicate implements Predicate {
 
     private final PathMatcher<Boolean> pathMatcher;
 
-    public PathMatchPredicate(final String... paths) {
+    PathMatchPredicate(final String... paths) {
         PathMatcher<Boolean> matcher = new PathMatcher<>();
         for(String path : paths) {
             if(!path.startsWith("/")) {

File: core/src/main/java/io/undertow/predicate/PathPrefixPredicate.java
Patch:
@@ -33,7 +33,7 @@ class PathPrefixPredicate implements Predicate {
 
     private final PathMatcher<Boolean> pathMatcher;
 
-    public PathPrefixPredicate(final String... paths) {
+    PathPrefixPredicate(final String... paths) {
         PathMatcher<Boolean> matcher = new PathMatcher<>();
         for(String path : paths) {
             if(!path.startsWith("/")) {

File: core/src/main/java/io/undertow/predicate/PathSuffixPredicate.java
Patch:
@@ -31,7 +31,7 @@ class PathSuffixPredicate implements Predicate {
 
     private final String suffix;
 
-    public PathSuffixPredicate(final String suffix) {
+    PathSuffixPredicate(final String suffix) {
             this.suffix = suffix;
     }
 

File: core/src/main/java/io/undertow/protocols/http2/Http2DataFrameParser.java
Patch:
@@ -30,7 +30,7 @@ class Http2DataFrameParser extends Http2PushBackParser {
 
     private int padding = 0;
 
-    public Http2DataFrameParser(int frameLength) {
+    Http2DataFrameParser(int frameLength) {
         super(frameLength);
     }
 

File: core/src/main/java/io/undertow/protocols/http2/Http2FrameHeaderParser.java
Patch:
@@ -57,7 +57,7 @@ class Http2FrameHeaderParser implements FrameHeaderData {
     private static final int SECOND_RESERVED_MASK = ~(1 << 7);
     private Http2Channel http2Channel;
 
-    public Http2FrameHeaderParser(Http2Channel http2Channel, Http2HeadersParser continuationParser) {
+    Http2FrameHeaderParser(Http2Channel http2Channel, Http2HeadersParser continuationParser) {
         this.http2Channel = http2Channel;
         this.continuationParser = continuationParser;
     }

File: core/src/main/java/io/undertow/protocols/http2/Http2HeaderBlockParser.java
Patch:
@@ -41,7 +41,7 @@ abstract class Http2HeaderBlockParser extends Http2PushBackParser implements Hpa
     private int frameRemaining = -1;
     private boolean invalid = false;
 
-    public Http2HeaderBlockParser(int frameLength, HpackDecoder decoder) {
+    Http2HeaderBlockParser(int frameLength, HpackDecoder decoder) {
         super(frameLength);
         this.decoder = decoder;
     }

File: core/src/main/java/io/undertow/protocols/http2/Http2HeadersParser.java
Patch:
@@ -35,7 +35,7 @@ class Http2HeadersParser extends Http2HeaderBlockParser {
     private boolean headersEndStream = false;
     private boolean exclusive;
 
-    public Http2HeadersParser(int frameLength, HpackDecoder hpackDecoder) {
+    Http2HeadersParser(int frameLength, HpackDecoder hpackDecoder) {
         super(frameLength, hpackDecoder);
     }
 

File: core/src/main/java/io/undertow/protocols/http2/Http2PingParser.java
Patch:
@@ -34,7 +34,7 @@ class Http2PingParser extends Http2PushBackParser {
 
     final byte[] data = new byte[PING_FRAME_LENGTH];
 
-    public Http2PingParser(int frameLength) {
+    Http2PingParser(int frameLength) {
         super(frameLength);
     }
 

File: core/src/main/java/io/undertow/protocols/http2/Http2PriorityParser.java
Patch:
@@ -33,7 +33,7 @@ class Http2PriorityParser extends Http2PushBackParser {
     private int weight;
     private boolean exclusive;
 
-    public Http2PriorityParser(int frameLength) {
+    Http2PriorityParser(int frameLength) {
         super(frameLength);
     }
 

File: core/src/main/java/io/undertow/protocols/http2/Http2PushPromiseParser.java
Patch:
@@ -33,7 +33,7 @@ class Http2PushPromiseParser extends Http2HeaderBlockParser {
     private int promisedStreamId;
     private static final int STREAM_MASK = ~(1 << 7);
 
-    public Http2PushPromiseParser(int frameLength, HpackDecoder hpackDecoder) {
+    Http2PushPromiseParser(int frameLength, HpackDecoder hpackDecoder) {
         super(frameLength, hpackDecoder);
     }
 

File: core/src/main/java/io/undertow/protocols/http2/Http2RstStreamParser.java
Patch:
@@ -29,7 +29,7 @@ class Http2RstStreamParser extends Http2PushBackParser {
 
     private int errorCode;
 
-    public Http2RstStreamParser(int frameLength) {
+    Http2RstStreamParser(int frameLength) {
         super(frameLength);
     }
 

File: core/src/main/java/io/undertow/protocols/http2/Http2SettingsParser.java
Patch:
@@ -31,7 +31,7 @@ class Http2SettingsParser extends Http2PushBackParser {
 
     private final List<Http2Setting> settings = new ArrayList<>();
 
-    public Http2SettingsParser(int frameLength) {
+    Http2SettingsParser(int frameLength) {
         super(frameLength);
     }
 

File: core/src/main/java/io/undertow/protocols/http2/Http2WindowUpdateParser.java
Patch:
@@ -29,7 +29,7 @@ class Http2WindowUpdateParser extends Http2PushBackParser {
 
     private int deltaWindowSize;
 
-    public Http2WindowUpdateParser(int frameLength) {
+    Http2WindowUpdateParser(int frameLength) {
         super(frameLength);
     }
 

File: core/src/main/java/io/undertow/protocols/spdy/SpdyHeaderBlockParser.java
Patch:
@@ -52,7 +52,7 @@ abstract class SpdyHeaderBlockParser extends SpdyPushBackParser {
     private byte[] dataOverflow;
 
 
-    public SpdyHeaderBlockParser(SpdyChannel channel, int frameLength, Inflater inflater) {
+    SpdyHeaderBlockParser(SpdyChannel channel, int frameLength, Inflater inflater) {
         super(frameLength);
         this.channel = channel;
         this.inflater = inflater;

File: core/src/main/java/io/undertow/protocols/spdy/SpdyHeadersParser.java
Patch:
@@ -30,7 +30,7 @@
  */
 class SpdyHeadersParser extends SpdyHeaderBlockParser {
 
-    public SpdyHeadersParser(ByteBufferPool bufferPool, SpdyChannel channel, int frameLength, Inflater inflater) {
+    SpdyHeadersParser(ByteBufferPool bufferPool, SpdyChannel channel, int frameLength, Inflater inflater) {
         super(channel,frameLength, inflater);
     }
 

File: core/src/main/java/io/undertow/protocols/spdy/SpdyPingParser.java
Patch:
@@ -30,7 +30,7 @@ class SpdyPingParser extends SpdyPushBackParser {
 
     private int id;
 
-    public SpdyPingParser(int frameLength) {
+    SpdyPingParser(int frameLength) {
         super(frameLength);
     }
 

File: core/src/main/java/io/undertow/protocols/spdy/SpdyRstStreamParser.java
Patch:
@@ -29,7 +29,7 @@ class SpdyRstStreamParser extends SpdyPushBackParser {
 
     private int statusCode;
 
-    public SpdyRstStreamParser(int frameLength) {
+    SpdyRstStreamParser(int frameLength) {
         super(frameLength);
     }
 

File: core/src/main/java/io/undertow/protocols/spdy/SpdySettingsParser.java
Patch:
@@ -35,7 +35,7 @@ class SpdySettingsParser extends SpdyPushBackParser {
 
     private final List<SpdySetting> settings = new ArrayList<>();
 
-    public SpdySettingsParser(int frameLength) {
+    SpdySettingsParser(int frameLength) {
         super(frameLength);
     }
 

File: core/src/main/java/io/undertow/protocols/spdy/SpdySynReplyParser.java
Patch:
@@ -30,7 +30,7 @@
  */
 class SpdySynReplyParser extends SpdyHeaderBlockParser {
 
-    public SpdySynReplyParser(ByteBufferPool bufferPool, SpdyChannel channel, int frameLength, Inflater inflater) {
+    SpdySynReplyParser(ByteBufferPool bufferPool, SpdyChannel channel, int frameLength, Inflater inflater) {
         super(channel, frameLength, inflater);
     }
 

File: core/src/main/java/io/undertow/protocols/spdy/SpdySynStreamParser.java
Patch:
@@ -34,7 +34,7 @@ class SpdySynStreamParser extends SpdyHeaderBlockParser {
     private int associatedToStreamId = -1;
     private int priority = -1;
 
-    public SpdySynStreamParser(ByteBufferPool bufferPool, SpdyChannel channel, int frameLength, Inflater inflater) {
+    SpdySynStreamParser(ByteBufferPool bufferPool, SpdyChannel channel, int frameLength, Inflater inflater) {
         super(channel, frameLength, inflater);
     }
 

File: core/src/main/java/io/undertow/protocols/spdy/SpdyWindowUpdateParser.java
Patch:
@@ -29,7 +29,7 @@ class SpdyWindowUpdateParser extends SpdyPushBackParser {
 
     private int deltaWindowSize;
 
-    public SpdyWindowUpdateParser(int frameLength) {
+    SpdyWindowUpdateParser(int frameLength) {
         super(frameLength);
     }
 

File: core/src/main/java/io/undertow/protocols/ssl/UndertowAcceptingSslChannel.java
Patch:
@@ -79,7 +79,7 @@ class UndertowAcceptingSslChannel implements AcceptingChannel<SslConnection> {
     protected final boolean startTls;
     protected final ByteBufferPool applicationBufferPool;
 
-    public UndertowAcceptingSslChannel(final UndertowXnioSsl ssl, final AcceptingChannel<? extends StreamConnection> tcpServer, final OptionMap optionMap, final ByteBufferPool applicationBufferPool, final boolean startTls) {
+    UndertowAcceptingSslChannel(final UndertowXnioSsl ssl, final AcceptingChannel<? extends StreamConnection> tcpServer, final OptionMap optionMap, final ByteBufferPool applicationBufferPool, final boolean startTls) {
         this.tcpServer = tcpServer;
         this.ssl = ssl;
         this.applicationBufferPool = applicationBufferPool;

File: core/src/main/java/io/undertow/protocols/ssl/UndertowXnioSsl.java
Patch:
@@ -305,7 +305,7 @@ private class StreamConnectionChannelListener implements ChannelListener<StreamC
         private final FutureResult<SslConnection> futureResult;
         private final ChannelListener<? super SslConnection> openListener;
 
-        public StreamConnectionChannelListener(OptionMap optionMap, InetSocketAddress destination, FutureResult<SslConnection> futureResult, ChannelListener<? super SslConnection> openListener) {
+        StreamConnectionChannelListener(OptionMap optionMap, InetSocketAddress destination, FutureResult<SslConnection> futureResult, ChannelListener<? super SslConnection> openListener) {
             this.optionMap = optionMap;
             this.destination = destination;
             this.futureResult = futureResult;

File: core/src/main/java/io/undertow/security/api/AuthenticatedSessionManager.java
Patch:
@@ -40,7 +40,7 @@ public interface AuthenticatedSessionManager {
 
     void clearSession(HttpServerExchange exchange);
 
-    public static class AuthenticatedSession implements Serializable {
+    class AuthenticatedSession implements Serializable {
 
         private final Account account;
         private final String mechanism;

File: core/src/main/java/io/undertow/security/api/AuthenticationMechanism.java
Patch:
@@ -85,7 +85,7 @@ AuthenticationMechanismOutcome authenticate(final HttpServerExchange exchange,
      * overall authentication process will then used this along with the current AuthenticationState to decide how to proceed
      * with the current request.
      */
-    public enum AuthenticationMechanismOutcome {
+    enum AuthenticationMechanismOutcome {
         /**
          * Based on the current request the mechanism has successfully performed authentication.
          */
@@ -108,7 +108,7 @@ public enum AuthenticationMechanismOutcome {
     /**
      * Simple class to wrap the result of requesting a mechanism sends it's challenge.
      */
-    public class ChallengeResult {
+    class ChallengeResult {
 
         private final boolean challengeSent;
         private final Integer statusCode;

File: core/src/main/java/io/undertow/security/idm/DigestAlgorithm.java
Patch:
@@ -49,7 +49,7 @@ public enum DigestAlgorithm {
     private final String digestAlgorithm;
     private final boolean session;
 
-    private DigestAlgorithm(final String token, final String digestAlgorithm, final boolean session) {
+    DigestAlgorithm(final String token, final String digestAlgorithm, final boolean session) {
         this.token = token;
         this.digestAlgorithm = digestAlgorithm;
         this.session = session;

File: core/src/main/java/io/undertow/security/impl/AuthenticationInfoToken.java
Patch:
@@ -53,7 +53,7 @@ public enum AuthenticationInfoToken implements HeaderToken {
     private final String name;
     private final boolean quoted;
 
-    private AuthenticationInfoToken(final HttpString name, final boolean quoted) {
+    AuthenticationInfoToken(final HttpString name, final boolean quoted) {
         this.name = name.toString();
         this.quoted = quoted;
     }

File: core/src/main/java/io/undertow/security/impl/DigestAuthorizationToken.java
Patch:
@@ -60,7 +60,7 @@ public enum DigestAuthorizationToken implements HeaderToken {
     private final String name;
     private final boolean quoted;
 
-    private DigestAuthorizationToken(final HttpString name, final boolean quoted) {
+    DigestAuthorizationToken(final HttpString name, final boolean quoted) {
         this.name = name.toString();
         this.quoted = quoted;
     }

File: core/src/main/java/io/undertow/security/impl/DigestQop.java
Patch:
@@ -46,7 +46,7 @@ public enum DigestQop {
     private final String token;
     private final boolean integrity;
 
-    private DigestQop(final String token, final boolean integrity) {
+    DigestQop(final String token, final boolean integrity) {
         this.token = token;
         this.integrity = integrity;
     }

File: core/src/main/java/io/undertow/security/impl/DigestWWWAuthenticateToken.java
Patch:
@@ -57,7 +57,7 @@ public enum DigestWWWAuthenticateToken implements HeaderToken {
     private final String name;
     private final boolean quoted;
 
-    private DigestWWWAuthenticateToken(final HttpString name, final boolean quoted) {
+    DigestWWWAuthenticateToken(final HttpString name, final boolean quoted) {
         this.name = name.toString();
         this.quoted = quoted;
     }

File: core/src/main/java/io/undertow/server/DefaultByteBufferPool.java
Patch:
@@ -184,7 +184,7 @@ private static class DefaultPooledBuffer implements PooledByteBuffer {
 
 
 
-        public DefaultPooledBuffer(DefaultByteBufferPool pool, ByteBuffer buffer, boolean detectLeaks) {
+        DefaultPooledBuffer(DefaultByteBufferPool pool, ByteBuffer buffer, boolean detectLeaks) {
             this.pool = pool;
             this.buffer = buffer;
             this.leakDetector = detectLeaks ? new LeakDetector() : null;

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -1787,7 +1787,7 @@ private static class ExchangeCompleteNextListener implements ExchangeCompletionL
         private final HttpServerExchange exchange;
         private int i;
 
-        public ExchangeCompleteNextListener(final ExchangeCompletionListener[] list, final HttpServerExchange exchange, int i) {
+        ExchangeCompleteNextListener(final ExchangeCompletionListener[] list, final HttpServerExchange exchange, int i) {
             this.list = list;
             this.exchange = exchange;
             this.i = i;
@@ -1865,7 +1865,7 @@ private class WriteDispatchChannel extends DetachableStreamSinkChannel implement
 
         private boolean wakeup;
 
-        public WriteDispatchChannel(final ConduitStreamSinkChannel delegate) {
+        WriteDispatchChannel(final ConduitStreamSinkChannel delegate) {
             super(delegate);
         }
 
@@ -2023,7 +2023,7 @@ private final class ReadDispatchChannel extends DetachableStreamSourceChannel im
         private boolean readsResumed = false;
 
 
-        public ReadDispatchChannel(final ConduitStreamSourceChannel delegate) {
+        ReadDispatchChannel(final ConduitStreamSourceChannel delegate) {
             super(delegate);
         }
 

File: core/src/main/java/io/undertow/server/handlers/ExceptionHandler.java
Patch:
@@ -47,7 +47,7 @@ public <T extends Throwable> ExceptionHandler addExceptionHandler(Class<T> clazz
     private static class ExceptionHandlerHolder<T extends Throwable> {
         private final Class<T> clazz;
         private final HttpHandler handler;
-        public ExceptionHandlerHolder(Class<T> clazz, HttpHandler handler) {
+        ExceptionHandlerHolder(Class<T> clazz, HttpHandler handler) {
             super();
             this.clazz = clazz;
             this.handler = handler;

File: core/src/main/java/io/undertow/server/handlers/LocalNameResolvingHandler.java
Patch:
@@ -99,7 +99,7 @@ public Object run() {
         next.handleRequest(exchange);
     }
 
-    public static enum ResolveType {
+    public enum ResolveType {
         FORWARD,
         REVERSE,
         FORWARD_AND_REVERSE

File: core/src/main/java/io/undertow/server/handlers/PeerNameResolvingHandler.java
Patch:
@@ -98,7 +98,7 @@ public Object run() {
         next.handleRequest(exchange);
     }
 
-    public static enum ResolveType {
+    public enum ResolveType {
         FORWARD,
         REVERSE,
         FORWARD_AND_REVERSE

File: core/src/main/java/io/undertow/server/handlers/StuckThreadDetectionHandler.java
Patch:
@@ -202,7 +202,7 @@ private static class MonitoredThread {
         private final AtomicInteger state = new AtomicInteger(
             MonitoredThreadState.RUNNING.ordinal());
 
-        public MonitoredThread(Thread thread, String requestUri) {
+        MonitoredThread(Thread thread, String requestUri) {
             this.thread = thread;
             this.requestUri = requestUri;
             this.start = System.currentTimeMillis();
@@ -245,7 +245,7 @@ private static class CompletedStuckThread {
         private final long threadId;
         private final long totalActiveTime;
 
-        public CompletedStuckThread(Thread thread, long totalActiveTime) {
+        CompletedStuckThread(Thread thread, long totalActiveTime) {
             this.threadName = thread.getName();
             this.threadId = thread.getId();
             this.totalActiveTime = totalActiveTime;

File: core/src/main/java/io/undertow/server/handlers/accesslog/ExtendedAccessLogParser.java
Patch:
@@ -82,7 +82,7 @@ private static class PatternTokenizer {
         private boolean subToken;
         private boolean parameter;
 
-        public PatternTokenizer(String str) {
+        PatternTokenizer(String str) {
             sr = new StringReader(str);
         }
 

File: core/src/main/java/io/undertow/server/handlers/cache/ResponseCache.java
Patch:
@@ -202,7 +202,7 @@ boolean isResponseCachable() {
     private static class DereferenceCallback implements IoCallback {
         private final DirectBufferCache.CacheEntry entry;
 
-        public DereferenceCallback(DirectBufferCache.CacheEntry entry) {
+        DereferenceCallback(DirectBufferCache.CacheEntry entry) {
             this.entry = entry;
         }
 

File: core/src/main/java/io/undertow/server/handlers/proxy/ProxyHandler.java
Patch:
@@ -331,7 +331,7 @@ private static class ProxyAction implements Runnable {
         private final boolean rewriteHostHeader;
         private final boolean reuseXForwarded;
 
-        public ProxyAction(final ProxyConnection clientConnection, final HttpServerExchange exchange, Map<HttpString, ExchangeAttribute> requestHeaders,
+        ProxyAction(final ProxyConnection clientConnection, final HttpServerExchange exchange, Map<HttpString, ExchangeAttribute> requestHeaders,
                            boolean rewriteHostHeader, boolean reuseXForwarded) {
             this.clientConnection = clientConnection;
             this.exchange = exchange;

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/Context.java
Patch:
@@ -39,7 +39,7 @@ class Context {
 
     private static final AtomicInteger idGen = new AtomicInteger();
 
-    static enum Status {
+    enum Status {
 
         ENABLED,
         DISABLED,

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/MCMPHandler.java
Patch:
@@ -123,7 +123,7 @@ enum MCMPAction {
     private final ModCluster modCluster;
     protected final ModClusterContainer container;
 
-    public MCMPHandler(MCMPConfig config, ModCluster modCluster, HttpHandler next) {
+    MCMPHandler(MCMPConfig config, ModCluster modCluster, HttpHandler next) {
         this.config = config;
         this.next = next;
         this.modCluster = modCluster;

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/MCMPWebManager.java
Patch:
@@ -49,7 +49,7 @@ class MCMPWebManager extends MCMPHandler {
     private final Random r = new SecureRandom();
     private String nonce = null;
 
-    public MCMPWebManager(MCMPConfig.MCMPWebManagerConfig config, ModCluster modCluster, HttpHandler next) {
+    MCMPWebManager(MCMPConfig.MCMPWebManagerConfig config, ModCluster modCluster, HttpHandler next) {
         super(config, modCluster, next);
         this.checkNonce = config.isCheckNonce();
         this.reduceDisplay = config.isReduceDisplay();

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/NodePingUtil.java
Patch:
@@ -421,7 +421,7 @@ public void failed(IOException e) {
         }
     }
 
-    static enum State {
+    enum State {
         WAITING, DONE, CANCELLED;
     }
 

File: core/src/main/java/io/undertow/server/handlers/resource/CachedResource.java
Patch:
@@ -308,7 +308,7 @@ private static class DereferenceCallback implements IoCallback {
         private final DirectBufferCache.CacheEntry entry;
         private final IoCallback callback;
 
-        public DereferenceCallback(DirectBufferCache.CacheEntry entry, final IoCallback callback) {
+        DereferenceCallback(DirectBufferCache.CacheEntry entry, final IoCallback callback) {
             this.entry = entry;
             this.callback = callback;
         }

File: core/src/main/java/io/undertow/server/protocol/http/AlpnOpenListener.java
Patch:
@@ -155,7 +155,7 @@ private static class ListenerEntry {
         DelegateOpenListener listener;
         int weight;
 
-        public ListenerEntry(DelegateOpenListener listener, int weight) {
+        ListenerEntry(DelegateOpenListener listener, int weight) {
             this.listener = listener;
             this.weight = weight;
         }

File: core/src/main/java/io/undertow/server/protocol/http/ParseState.java
Patch:
@@ -112,7 +112,7 @@ class ParseState {
      */
     final HashMap<HttpString, String> headerValuesCache = new HashMap<>();
 
-    public ParseState() {
+    ParseState() {
         this.parseState = 0;
         this.pos = 0;
     }

File: core/src/main/java/io/undertow/server/protocol/http2/Http2SslSessionInfo.java
Patch:
@@ -39,7 +39,7 @@ class Http2SslSessionInfo implements SSLSessionInfo {
 
     private final Http2Channel channel;
 
-    public Http2SslSessionInfo(Http2Channel channel) {
+    Http2SslSessionInfo(Http2Channel channel) {
         this.channel = channel;
     }
 

File: core/src/main/java/io/undertow/server/protocol/spdy/SpdySslSessionInfo.java
Patch:
@@ -39,7 +39,7 @@ class SpdySslSessionInfo implements SSLSessionInfo {
 
     private final SpdyChannel channel;
 
-    public SpdySslSessionInfo(SpdyChannel channel) {
+    SpdySslSessionInfo(SpdyChannel channel) {
         this.channel = channel;
     }
 

File: core/src/main/java/io/undertow/util/FileUtils.java
Patch:
@@ -80,8 +80,7 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IO
             }
 
             @Override
-            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException
-            {
+            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                 try {
                     Files.delete(dir);
                 } catch (IOException e) {

File: core/src/main/java/io/undertow/websockets/client/WebSocketClient.java
Patch:
@@ -336,7 +336,7 @@ private class WebsocketConnectionListener implements ChannelListener<StreamConne
             private final URI newUri;
             private final FutureResult<WebSocketChannel> ioFuture;
 
-            public WebsocketConnectionListener(OptionMap options, WebSocketClientHandshake handshake, URI newUri, FutureResult<WebSocketChannel> ioFuture) {
+            WebsocketConnectionListener(OptionMap options, WebSocketClientHandshake handshake, URI newUri, FutureResult<WebSocketChannel> ioFuture) {
                 this.options = options;
                 this.handshake = handshake;
                 this.newUri = newUri;

File: core/src/main/java/io/undertow/websockets/core/AbstractReceiveListener.java
Patch:
@@ -201,7 +201,7 @@ protected void onCloseMessage(CloseMessage cm, WebSocketChannel channel) {
     private static class FreeDataCallback implements WebSocketCallback<Void> {
         private final Pooled<ByteBuffer[]> data;
 
-        public FreeDataCallback(Pooled<ByteBuffer[]> data) {
+        FreeDataCallback(Pooled<ByteBuffer[]> data) {
             this.data = data;
         }
 

File: core/src/main/java/io/undertow/websockets/core/protocol/version07/WebSocket07CloseFrameSourceChannel.java
Patch:
@@ -46,7 +46,7 @@ public static class CloseFrameValidatorChannelFunction extends UTF8Checker {
         private int statusBytesRead;
         private int status;
 
-        public CloseFrameValidatorChannelFunction(WebSocket07Channel wsChannel) {
+        CloseFrameValidatorChannelFunction(WebSocket07Channel wsChannel) {
             this.wsChannel = wsChannel;
         }
 

File: core/src/test/java/io/undertow/server/protocol/http2/HTTP2ViaUpgradeTestCase.java
Patch:
@@ -186,7 +186,7 @@ static class Http2ClientInitializer extends ChannelInitializer<SocketChannel> {
         private HttpResponseHandler responseHandler;
         private Http2SettingsHandler settingsHandler;
 
-        public Http2ClientInitializer(int maxContentLength) {
+        Http2ClientInitializer(int maxContentLength) {
             this.maxContentLength = maxContentLength;
         }
 
@@ -279,7 +279,7 @@ static class Http2SettingsHandler extends SimpleChannelInboundHandler<Http2Setti
          *
          * @param promise Promise object used to notify when first settings are received
          */
-        public Http2SettingsHandler(ChannelPromise promise) {
+        Http2SettingsHandler(ChannelPromise promise) {
             this.promise = promise;
         }
 
@@ -313,7 +313,7 @@ static class HttpResponseHandler extends SimpleChannelInboundHandler<FullHttpRes
 
         private SortedMap<Integer, ChannelPromise> streamidPromiseMap;
 
-        public HttpResponseHandler() {
+        HttpResponseHandler() {
             streamidPromiseMap = new TreeMap<Integer, ChannelPromise>();
         }
 

File: core/src/test/java/io/undertow/testutils/DebuggingSlicePool.java
Patch:
@@ -58,7 +58,7 @@ static class DebuggingBuffer implements PooledByteBuffer {
         private volatile boolean free = false;
         private RuntimeException freePoint;
 
-        public DebuggingBuffer(PooledByteBuffer delegate, String label) {
+        DebuggingBuffer(PooledByteBuffer delegate, String label) {
             this.delegate = delegate;
             this.label = label;
             this.no = allocationCount.getAndIncrement();

File: core/src/test/java/io/undertow/websockets/utils/WebSocketTestClient.java
Patch:
@@ -192,7 +192,7 @@ private static final class WSClientHandler extends SimpleChannelInboundHandler<O
         private final WebSocketClientHandshaker handshaker;
         private final CountDownLatch handshakeLatch;
 
-        public WSClientHandler(WebSocketClientHandshaker handshaker, CountDownLatch handshakeLatch) {
+        WSClientHandler(WebSocketClientHandshaker handshaker, CountDownLatch handshakeLatch) {
             super(false);
             this.handshaker = handshaker;
             this.handshakeLatch = handshakeLatch;

File: examples/src/main/java/io/undertow/examples/security/basic/MapIdentityManager.java
Patch:
@@ -42,7 +42,7 @@ class MapIdentityManager implements IdentityManager {
 
     private final Map<String, char[]> users;
 
-    public MapIdentityManager(final Map<String, char[]> users) {
+    MapIdentityManager(final Map<String, char[]> users) {
         this.users = users;
     }
 

File: servlet/src/main/java/io/undertow/servlet/api/DeploymentManager.java
Patch:
@@ -56,7 +56,7 @@ public interface DeploymentManager {
      */
     Deployment getDeployment();
 
-    public static enum State {
+    enum State {
         UNDEPLOYED,
         DEPLOYED,
         STARTED;

File: servlet/src/main/java/io/undertow/servlet/api/FilterMappingInfo.java
Patch:
@@ -53,7 +53,7 @@ public String getFilterName() {
         return filterName;
     }
 
-    public static enum MappingType {
+    public enum MappingType {
         URL,
         SERVLET;
     }

File: servlet/src/main/java/io/undertow/servlet/api/ServletContainer.java
Patch:
@@ -41,7 +41,7 @@ public interface ServletContainer {
 
     DeploymentManager getDeploymentByPath(String uripath);
 
-    public static class Factory {
+    class Factory {
 
         public static ServletContainer newInstance() {
             return new ServletContainerImpl();

File: servlet/src/main/java/io/undertow/servlet/api/ServletStackTraces.java
Patch:
@@ -29,7 +29,7 @@ public enum ServletStackTraces {
 
     private final String value;
 
-    private ServletStackTraces(String value) {
+    ServletStackTraces(String value) {
         this.value = value;
     }
 

File: servlet/src/main/java/io/undertow/servlet/api/SessionPersistenceManager.java
Patch:
@@ -37,7 +37,7 @@ public interface SessionPersistenceManager {
 
     void clear(final String deploymentName);
 
-    public class PersistentSession {
+    class PersistentSession {
         private final Date expiration;
         private final Map<String, Object> sessionData;
 

File: servlet/src/main/java/io/undertow/servlet/core/MetricsChainHandler.java
Patch:
@@ -40,7 +40,7 @@ class MetricsChainHandler implements HttpHandler {
     private final HttpHandler next;
     private final Map<String, MetricsHandler> servletHandlers;
 
-    public MetricsChainHandler(HttpHandler next, MetricsCollector collector, Deployment deployment) {
+    MetricsChainHandler(HttpHandler next, MetricsCollector collector, Deployment deployment) {
         this.next = next;
         final Map<String, MetricsHandler> servletHandlers = new HashMap<>();
         for(Map.Entry<String, ServletHandler> entry : deployment.getServlets().getServletHandlers().entrySet()) {

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletPathMatch.java
Patch:
@@ -82,7 +82,7 @@ public Type getType() {
         return type;
     }
 
-    public static enum Type {
+    public enum Type {
         /**
          * A normal servlet match, the invocation should proceed as normal
          */

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletPathMatchesData.java
Patch:
@@ -38,7 +38,7 @@ class ServletPathMatchesData {
 
     private final Map<String, ServletChain> nameMatches;
 
-    public ServletPathMatchesData(final Map<String, ServletChain> exactPathMatches, final SubstringMap<PathMatch> prefixMatches, final Map<String, ServletChain> nameMatches) {
+    ServletPathMatchesData(final Map<String, ServletChain> exactPathMatches, final SubstringMap<PathMatch> prefixMatches, final Map<String, ServletChain> nameMatches) {
         this.prefixMatches = prefixMatches;
         this.nameMatches = nameMatches;
         Map<String, ServletPathMatch> newExactPathMatches = new HashMap<>();
@@ -155,7 +155,7 @@ private static class PathMatch {
         private volatile ServletChain defaultHandler;
         private volatile boolean requireWelcomeFileMatch;
 
-        public PathMatch(final ServletChain defaultHandler) {
+        PathMatch(final ServletChain defaultHandler) {
             this.defaultHandler = defaultHandler;
         }
     }

File: servlet/src/main/java/io/undertow/servlet/handlers/security/SecurityPathMatches.java
Patch:
@@ -267,7 +267,7 @@ private static final class ExcludedMethodRoles {
         final Set<String> methods;
         final SecurityInformation securityInformation;
 
-        public ExcludedMethodRoles(final Set<String> methods, final SecurityInformation securityInformation) {
+        ExcludedMethodRoles(final Set<String> methods, final SecurityInformation securityInformation) {
             this.methods = methods;
             this.securityInformation = securityInformation;
         }

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -749,7 +749,7 @@ public long getContentLength() {
         return contentLength;
     }
 
-    public static enum ResponseState {
+    public enum ResponseState {
         NONE,
         STREAM,
         WRITER

File: servlet/src/test/java/io/undertow/servlet/test/streams/AsyncInputStreamServlet.java
Patch:
@@ -60,7 +60,7 @@ private class MyListener implements WriteListener, ReadListener {
 
         int written = 0;
 
-        public MyListener(final ServletOutputStream outputStream, final ServletInputStream inputStream, final AsyncContext context) {
+        MyListener(final ServletOutputStream outputStream, final ServletInputStream inputStream, final AsyncContext context) {
             this.outputStream = outputStream;
             this.inputStream = inputStream;
             this.context = context;

File: servlet/src/test/java/io/undertow/servlet/test/util/TestResourceLoader.java
Patch:
@@ -55,7 +55,7 @@ public Resource getResource(String path) throws IOException {
     private static class TestResource implements RangeAwareResource {
         private final Resource delegate;
 
-        public TestResource(Resource delegate) {
+        TestResource(Resource delegate) {
             this.delegate = delegate;
         }
 

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/JsrWebSocketProtocolHandshakeHandler.java
Patch:
@@ -35,7 +35,7 @@
  */
 final class JsrWebSocketProtocolHandshakeHandler extends WebSocketProtocolHandshakeHandler {
 
-    public JsrWebSocketProtocolHandshakeHandler(WebSocketConnectionCallback callback, ConfiguredServerEndpoint... configs) {
+    JsrWebSocketProtocolHandshakeHandler(WebSocketConnectionCallback callback, ConfiguredServerEndpoint... configs) {
         super(handshakes(configs), callback);
     }
 

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/SendHandlerAdapter.java
Patch:
@@ -34,7 +34,7 @@ final class SendHandlerAdapter implements WebSocketCallback<Void> {
     private static final SendResult OK = new SendResult();
     private volatile boolean done;
 
-    public SendHandlerAdapter(SendHandler handler) {
+    SendHandlerAdapter(SendHandler handler) {
         this.handler = handler;
     }
     @Override

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/ServerWebSocketContainer.java
Patch:
@@ -785,7 +785,7 @@ private class ClientNegotiation extends WebSocketClientNegotiation {
 
         private final ClientEndpointConfig config;
 
-        public ClientNegotiation(List<String> supportedSubProtocols, List<WebSocketExtension> supportedExtensions, ClientEndpointConfig config) {
+        ClientNegotiation(List<String> supportedSubProtocols, List<WebSocketExtension> supportedExtensions, ClientEndpointConfig config) {
             super(supportedSubProtocols, supportedExtensions);
             this.config = config;
         }

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/WebSocketSessionRemoteEndpoint.java
Patch:
@@ -48,7 +48,7 @@ final class WebSocketSessionRemoteEndpoint implements RemoteEndpoint {
     private final Basic basic = new BasicWebSocketSessionRemoteEndpoint();
     private final Encoding encoding;
 
-    public WebSocketSessionRemoteEndpoint(UndertowSession session, final Encoding encoding) {
+    WebSocketSessionRemoteEndpoint(UndertowSession session, final Encoding encoding) {
         this.undertowSession = session;
         this.encoding = encoding;
     }

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/annotated/AnnotatedEndpointFactory.java
Patch:
@@ -309,12 +309,12 @@ private static class BoundSingleParameter implements BoundParameter {
         private final int position;
         private final Class<?> type;
 
-        public BoundSingleParameter(int position, final Class<?> type) {
+        BoundSingleParameter(int position, final Class<?> type) {
             this.position = position;
             this.type = type;
         }
 
-        public BoundSingleParameter(final Method method, final Class<?> type, final boolean optional) {
+        BoundSingleParameter(final Method method, final Class<?> type, final boolean optional) {
             this.type = type;
             int pos = -1;
             for (int i = 0; i < method.getParameterTypes().length; ++i) {
@@ -376,7 +376,7 @@ private static class BoundPathParameters implements BoundParameter {
         private final Encoding[] encoders;
         private final Class[] types;
 
-        public BoundPathParameters(final String[] positions, final Method method, Class<?> endpointClass, Set<String> paths) throws DeploymentException {
+        BoundPathParameters(final String[] positions, final Method method, Class<?> endpointClass, Set<String> paths) throws DeploymentException {
             this.positions = positions;
             this.endpointClass = endpointClass;
             this.paths = paths;

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/annotated/BoundMethod.java
Patch:
@@ -43,7 +43,7 @@ final class BoundMethod {
     private final boolean decoderRequired;
     private final long maxMessageSize;
 
-    public BoundMethod(final Method method, final Class<?> messageType, final boolean decoderRequired, long maxMessageSize, BoundParameter... params) throws DeploymentException {
+    BoundMethod(final Method method, final Class<?> messageType, final boolean decoderRequired, long maxMessageSize, BoundParameter... params) throws DeploymentException {
         this.method = method;
         this.messageType = messageType;
         this.decoderRequired = decoderRequired;

File: websockets-jsr/src/test/java/io/undertow/websockets/jsr/test/stress/WebsocketStressTestCase.java
Patch:
@@ -224,7 +224,7 @@ private static class SendRunnable implements Runnable {
         private final ExecutorService executor;
         final CountDownLatch latch = new CountDownLatch(1);
 
-        public SendRunnable(Session session, int thread, ExecutorService executor) {
+        SendRunnable(Session session, int thread, ExecutorService executor) {
             this.session = session;
             this.thread = thread;
             this.executor = executor;

File: core/src/main/java/io/undertow/security/impl/SimpleNonceManager.java
Patch:
@@ -291,7 +291,7 @@ private boolean validateNonceWithCount(Nonce nonce, int nonceCount, final XnioEx
                     return false;
                 }
 
-                if (nonce.timeStamp > earliestAccepted && nonce.timeStamp < now) {
+                if (nonce.timeStamp > earliestAccepted && nonce.timeStamp <= now) {
                     knownNonces.put(nonce.nonce, nonce);
                     long timeTillExpiry = nonce.timeStamp - earliestAccepted;
                     nonce.executorKey = executor.executeAfter(new KnownNonceCleaner(nonce.nonce), timeTillExpiry,

File: core/src/main/java/io/undertow/conduits/IdleTimeoutConduit.java
Patch:
@@ -69,7 +69,7 @@ public void run() {
                 return;
             }
 
-            UndertowLogger.REQUEST_LOGGER.tracef("Timing out channel %s due to inactivity");
+            UndertowLogger.REQUEST_LOGGER.trace("Timing out channel due to inactivity");
             timedOut = true;
             doClose();
             if (sink.isWriteResumed()) {

File: servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java
Patch:
@@ -345,6 +345,8 @@ private void serveFileBlocking(final HttpServletRequest req, final HttpServletRe
                             resp.setStatus(StatusCodes.PARTIAL_CONTENT);
                             resp.setHeader(Headers.CONTENT_RANGE_STRING, range.getStart(0) + "-" + range.getEnd(0) + "/" + contentLength);
                         }
+                    } else {
+                        resp.setHeader(Headers.ACCEPT_RANGES_STRING, "bytes");
                     }
                 }
             }

File: core/src/main/java/io/undertow/attribute/SecureExchangeAttribute.java
Patch:
@@ -30,7 +30,7 @@ public class SecureExchangeAttribute implements ExchangeAttribute {
 
     @Override
     public String readAttribute(HttpServerExchange exchange) {
-        return Boolean.toString(exchange.getProtocol().equals("https"));
+        return Boolean.toString(exchange.getProtocol().equalToString("https"));
     }
 
     @Override

File: core/src/main/java/io/undertow/UndertowLogger.java
Patch:
@@ -124,7 +124,7 @@ public interface UndertowLogger extends BasicLogger {
     void errorWritingAccessLog(@Cause IOException e);
 
     @LogMessage(level = ERROR)
-    @Message(id = 5017, value = "Unknown variable %s")
+    @Message(id = 5017, value = "Unknown variable %s. For the literal percent character use two percent characters: '%%'")
     void unknownVariable(String token);
 
     @LogMessage(level = ERROR)

File: core/src/test/java/io/undertow/server/handlers/builder/PredicatedHandlersParserTestCase.java
Patch:
@@ -93,12 +93,12 @@ public void testParsedHandler1() {
 
     @Test
     public void testParsedHandler2() {
-        String value = "header(header=a, value='b')";
+        String value = "header(header=a, value='a%%lb')";
         List<PredicatedHandler> ret = PredicatedHandlersParser.parse(value, getClass().getClassLoader());
         Assert.assertEquals(1, ret.size());
         SetHeaderHandler handler = (SetHeaderHandler) ret.get(0).getHandler().wrap(ResponseCodeHandler.HANDLE_200);
         Assert.assertEquals("a", handler.getHeader().toString());
-        Assert.assertEquals("b", handler.getValue().readAttribute(null));
+        Assert.assertEquals("a%lb", handler.getValue().readAttribute(null));
     }
 
     @Test

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -953,9 +953,9 @@ public HttpServerExchange setSourceAddress(InetSocketAddress sourceAddress) {
     }
 
     /**
-     * Get the source address of the HTTP request.
+     * Get the destination address of the HTTP request.
      *
-     * @return the source address of the HTTP request
+     * @return the destination address of the HTTP request
      */
     public InetSocketAddress getDestinationAddress() {
         if (destinationAddress != null) {

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -953,9 +953,9 @@ public HttpServerExchange setSourceAddress(InetSocketAddress sourceAddress) {
     }
 
     /**
-     * Get the source address of the HTTP request.
+     * Get the destination address of the HTTP request.
      *
-     * @return the source address of the HTTP request
+     * @return the destination address of the HTTP request
      */
     public InetSocketAddress getDestinationAddress() {
         if (destinationAddress != null) {

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -144,6 +144,8 @@ public void sendError(final int sc, final String msg) throws IOException {
     }
 
     public void doErrorDispatch(int sc, String error) throws IOException {
+        writer = null;
+        responseState = ResponseState.NONE;
         resetBuffer();
         treatAsCommitted = false;
         final String location = servletContext.getDeployment().getErrorPages().getErrorLocation(sc);

File: core/src/main/java/io/undertow/server/handlers/sse/ServerSentEventHandler.java
Patch:
@@ -73,7 +73,7 @@ public void handleException(StreamSinkChannel channel, IOException exception) {
             }));
             sink.resumeWrites();
         } else {
-            exchange.dispatch(new Runnable() {
+            exchange.dispatch(exchange.getIoThread(), new Runnable() {
                 @Override
                 public void run() {
                     handleConnect(sink, exchange);

File: core/src/test/java/io/undertow/server/handlers/sse/ServerSentEventTestCase.java
Patch:
@@ -212,7 +212,6 @@ public void run() {
                         connection.send("hello", new ServerSentEventConnection.EventCallback() {
                             @Override
                             public void done(ServerSentEventConnection connection, String data, String event, String id) {
-                                System.out.println("failed");
                             }
 
                             @Override

File: core/src/main/java/io/undertow/server/handlers/form/MultiPartParserDefinition.java
Patch:
@@ -78,7 +78,7 @@ public MultiPartParserDefinition(final Path tempDir) {
     public FormDataParser create(final HttpServerExchange exchange) {
         String mimeType = exchange.getRequestHeaders().getFirst(Headers.CONTENT_TYPE);
         if (mimeType != null && mimeType.startsWith(MULTIPART_FORM_DATA)) {
-            String boundary = Headers.extractTokenFromHeader(mimeType, "boundary");
+            String boundary = Headers.extractQuotedValueFromHeader(mimeType, "boundary");
             if (boundary == null) {
                 UndertowLogger.REQUEST_LOGGER.debugf("Could not find boundary in multipart request with ContentType: %s, multipart data will not be available", mimeType);
                 return null;

File: core/src/main/java/io/undertow/conduits/WriteTimeoutStreamSinkConduit.java
Patch:
@@ -42,7 +42,7 @@
  * Wrapper for write timeout. This should always be the first wrapper applied to the underlying channel.
  *
  * @author Stuart Douglas
- * @see org.xnio.Options#READ_TIMEOUT
+ * @see org.xnio.Options#WRITE_TIMEOUT
  */
 public final class WriteTimeoutStreamSinkConduit extends AbstractStreamSinkConduit<StreamSinkConduit> {
 

File: core/src/main/java/io/undertow/conduits/WriteTimeoutStreamSinkConduit.java
Patch:
@@ -42,7 +42,7 @@
  * Wrapper for write timeout. This should always be the first wrapper applied to the underlying channel.
  *
  * @author Stuart Douglas
- * @see org.xnio.Options#READ_TIMEOUT
+ * @see org.xnio.Options#WRITE_TIMEOUT
  */
 public final class WriteTimeoutStreamSinkConduit extends AbstractStreamSinkConduit<StreamSinkConduit> {
 

File: core/src/main/java/io/undertow/protocols/ssl/SslConduit.java
Patch:
@@ -223,7 +223,7 @@ private void runReadListener(final boolean resumeInListener) {
             delegate.getIoThread().execute(new Runnable() {
                 @Override
                 public void run() {
-                    if(resumeInListener) {
+                    if(resumeInListener && allAreSet(state, FLAG_READS_RESUMED)) {
                         delegate.getSourceChannel().resumeReads();
                     }
                     readReadyHandler.readReady();
@@ -647,7 +647,7 @@ private long doUnwrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcep
         try {
             //we need to store how much data is in the unwrap buffer. If no progress can be made then we unset
             //the data to unwrap flag
-            int dataToUnwrapLength = -1;
+            int dataToUnwrapLength;
             //try and read some data if we don't already have some
             if(allAreClear(state, FLAG_DATA_TO_UNWRAP)) {
                 if(dataToUnwrap == null) {
@@ -1028,7 +1028,7 @@ private SslReadReadyHandler(ReadReadyHandler delegateHandler) {
 
         @Override
         public void readReady() {
-            if(anyAreSet(state, FLAG_WRITE_REQUIRES_READ) && !anyAreSet(state, FLAG_ENGINE_INBOUND_SHUTDOWN)) {
+            if(allAreSet(state, FLAG_WRITE_REQUIRES_READ | FLAG_WRITES_RESUMED) && !anyAreSet(state, FLAG_ENGINE_INBOUND_SHUTDOWN)) {
                 try {
                     invokingReadListenerHandshake = true;
                     doHandshake();

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -431,4 +431,7 @@ public interface UndertowMessages {
 
     @Message(id = 134, value = "Authentication mechanism %s requires property %s to be set")
     IllegalStateException authenticationPropertyNotSet(String name, String header);
+
+    @Message(id = 135, value = "renegotiation failed")
+    IllegalStateException rengotiationFailed();
 }

File: servlet/src/main/java/io/undertow/servlet/spec/ServletContextImpl.java
Patch:
@@ -199,7 +199,7 @@ public String getMimeType(final String file) {
         String lower = file.toLowerCase(Locale.ENGLISH);
         int pos = lower.lastIndexOf('.');
         if (pos == -1) {
-            return deployment.getMimeExtensionMappings().get(lower);
+            return null; //no extension
         }
         return deployment.getMimeExtensionMappings().get(lower.substring(pos + 1));
     }

File: core/src/main/java/io/undertow/server/handlers/accesslog/DefaultAccessLogReceiver.java
Patch:
@@ -50,7 +50,7 @@
  * @author Stuart Douglas
  */
 public class DefaultAccessLogReceiver implements AccessLogReceiver, Runnable, Closeable {
-    private static final String DEFAULT_LOG_SUFFIX = ".log";
+    private static final String DEFAULT_LOG_SUFFIX = "log";
 
     private final Executor logWriteExecutor;
 
@@ -255,11 +255,11 @@ private void doRotate() {
             if (!Files.exists(defaultLogFile)) {
                 return;
             }
-            Path newFile = outputDirectory.resolve(logBaseName + currentDateString + logNameSuffix);
+            Path newFile = outputDirectory.resolve(logBaseName + currentDateString + "." + logNameSuffix);
             int count = 0;
             while (Files.exists(newFile)) {
                 ++count;
-                newFile = outputDirectory.resolve(logBaseName + currentDateString + "-" + count + logNameSuffix);
+                newFile = outputDirectory.resolve(logBaseName + currentDateString + "-" + count + "." + logNameSuffix);
             }
             Files.move(defaultLogFile, newFile);
         } catch (IOException e) {

File: core/src/test/java/io/undertow/server/handlers/accesslog/ExtendedAccessLogFileTestCase.java
Patch:
@@ -75,7 +75,7 @@ public void testSingleLogMessageToFile() throws IOException, InterruptedExceptio
         Path logFileName = directory.resolve("extended.log");
         DefaultAccessLogReceiver logReceiver = DefaultAccessLogReceiver.builder().setLogWriteExecutor(DefaultServer.getWorker())
                 .setOutputDirectory(directory)
-                .setLogBaseName("extended")
+                .setLogBaseName("extended.")
                 .setLogFileHeaderGenerator(new ExtendedAccessLogParser.ExtendedAccessLogHeaderGenerator(PATTERN)).build();
         verifySingleLogMessageToFile(logFileName, logReceiver);
     }

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -425,9 +425,9 @@ public void setContentType(final String type) {
         if(useCharset || !charsetSet) {
             exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, ct.getHeader());
         } else if(ct.getCharset() == null) {
-            exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, ct.getHeader() + ";charset=" + charset);
+            exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, ct.getHeader() + "; charset=" + charset);
         }else {
-            exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, ct.getContentType() + ";charset=" + charset);
+            exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, ct.getContentType() + "; charset=" + charset);
         }
     }
 

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletPathMatches.java
Patch:
@@ -63,7 +63,7 @@ public class ServletPathMatches {
 
     private volatile ServletPathMatchesData data;
 
-    private final LRUCache<String, ServletPathMatch> pathMatchCache = new LRUCache<>(1000, -1); //TODO: configurable
+    private final LRUCache<String, ServletPathMatch> pathMatchCache = new LRUCache<>(1000, -1, true); //TODO: configurable
 
     public ServletPathMatches(final Deployment deployment) {
         this.deployment = deployment;

File: servlet/src/main/java/io/undertow/servlet/spec/ServletContextImpl.java
Patch:
@@ -128,7 +128,7 @@ public ServletContextImpl(final ServletContainer servletContainer, final Deploym
             this.attributes = deploymentInfo.getServletContextAttributeBackingMap();
         }
         attributes.putAll(deployment.getDeploymentInfo().getServletContextAttributes());
-        this.contentTypeCache = new LRUCache<>(deployment.getDeploymentInfo().getContentTypeCacheSize(), -1);
+        this.contentTypeCache = new LRUCache<>(deployment.getDeploymentInfo().getContentTypeCacheSize(), -1, true);
     }
 
     public void initDone() {

File: servlet/src/main/java/io/undertow/servlet/core/ManagedServlet.java
Patch:
@@ -266,7 +266,7 @@ public Servlet getInstance() {
 
                 @Override
                 public void release() {
-
+                    instance.destroy();
                 }
             };
         }

File: servlet/src/main/java/io/undertow/servlet/spec/AsyncContextImpl.java
Patch:
@@ -62,6 +62,7 @@
 import io.undertow.util.CanonicalPathUtils;
 import io.undertow.util.Headers;
 import io.undertow.util.SameThreadExecutor;
+import io.undertow.util.StatusCodes;
 import org.xnio.IoUtils;
 import org.xnio.XnioExecutor;
 
@@ -412,6 +413,8 @@ public void handleError(final Throwable error) {
         dispatched = false; //we reset the dispatched state
         onAsyncError(error);
         if (!dispatched) {
+            exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);
+            exchange.getResponseHeaders().clear();
             servletRequest.setAttribute(RequestDispatcher.ERROR_EXCEPTION, error);
             try {
                 boolean errorPage = servletRequestContext.displayStackTraces();

File: core/src/main/java/io/undertow/client/http/HttpClientConnection.java
Patch:
@@ -34,6 +34,7 @@
 import io.undertow.conduits.ChunkedStreamSourceConduit;
 import io.undertow.conduits.ConduitListener;
 import io.undertow.conduits.FixedLengthStreamSourceConduit;
+import io.undertow.server.Connectors;
 import io.undertow.server.protocol.http.HttpContinue;
 import io.undertow.util.AbstractAttachable;
 import io.undertow.util.Headers;
@@ -551,7 +552,7 @@ private void prepareResponseChannel(ClientResponse response, ClientExchange exch
                 handleError(new IOException(e));
                 throw e;
             }
-        } else if (response.getProtocol().equals(Protocols.HTTP_1_1)) {
+        } else if (response.getProtocol().equals(Protocols.HTTP_1_1) && !Connectors.isEntityBodyAllowed(response.getResponseCode())) {
             connection.getSourceChannel().setConduit(new FixedLengthStreamSourceConduit(connection.getSourceChannel().getConduit(), 0, responseFinishedListener));
         } else {
             state |= CLOSE_REQ;

File: core/src/main/java/io/undertow/util/MimeMappings.java
Patch:
@@ -128,9 +128,9 @@ public class MimeMappings {
 
         /* Add XML related MIMEs */
 
-        defaultMappings.put("xml", "text/xml");
+        defaultMappings.put("xml", "application/xml");
         defaultMappings.put("xhtml", "application/xhtml+xml");
-        defaultMappings.put("xsl", "text/xml");
+        defaultMappings.put("xsl", "application/xml");
         defaultMappings.put("svg", "image/svg+xml");
         defaultMappings.put("svgz", "image/svg+xml");
         defaultMappings.put("wbmp", "image/vnd.wap.wbmp");

File: core/src/main/java/io/undertow/protocols/http2/Http2FrameHeaderParser.java
Patch:
@@ -134,6 +134,9 @@ public boolean handle(final ByteBuffer byteBuffer) throws IOException {
                     break;
                 }
                 case FRAME_TYPE_PRIORITY: {
+                    if (streamId == 0) {
+                        throw new ConnectionErrorException(Http2Channel.ERROR_PROTOCOL_ERROR, UndertowMessages.MESSAGES.streamIdMustNotBeZeroForFrameType(Http2Channel.FRAME_TYPE_PRIORITY));
+                    }
                     parser = new Http2PriorityParser(length);
                     break;
                 }

File: core/src/main/java/io/undertow/security/impl/DigestAuthenticationMechanism.java
Patch:
@@ -44,7 +44,6 @@
 import java.nio.charset.StandardCharsets;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -136,7 +135,7 @@ public DigestAuthenticationMechanism(final String realmName, final String domain
     }
 
     public DigestAuthenticationMechanism(final String realmName, final String domain, final String mechanismName, final IdentityManager identityManager) {
-        this(Collections.singletonList(DigestAlgorithm.MD5), new ArrayList<DigestQop>(0), realmName, domain, new SimpleNonceManager(), DEFAULT_NAME, identityManager);
+        this(Collections.singletonList(DigestAlgorithm.MD5), Collections.singletonList(DigestQop.AUTH), realmName, domain, new SimpleNonceManager(), DEFAULT_NAME, identityManager);
     }
 
     @SuppressWarnings("deprecation")

File: servlet/src/test/java/io/undertow/servlet/test/security/digest/DigestAuthTestCase.java
Patch:
@@ -21,7 +21,6 @@
 import static io.undertow.util.Headers.DIGEST;
 import static io.undertow.util.Headers.WWW_AUTHENTICATE;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import io.undertow.security.idm.DigestAlgorithm;
 import io.undertow.security.impl.DigestAuthorizationToken;
@@ -131,7 +130,7 @@ public void testCall(final String path, final String expectedResponse) throws Ex
         Map<DigestWWWAuthenticateToken, String> parsedHeader = DigestWWWAuthenticateToken.parseHeader(value.substring(7));
         assertEquals(REALM_NAME, parsedHeader.get(DigestWWWAuthenticateToken.REALM));
         assertEquals(DigestAlgorithm.MD5.getToken(), parsedHeader.get(DigestWWWAuthenticateToken.ALGORITHM));
-        assertFalse(parsedHeader.containsKey(DigestWWWAuthenticateToken.MESSAGE_QOP));
+        assertTrue(parsedHeader.containsKey(DigestWWWAuthenticateToken.MESSAGE_QOP));
 
         String nonce = parsedHeader.get(DigestWWWAuthenticateToken.NONCE);
 

File: core/src/main/java/io/undertow/security/impl/DigestAuthenticationMechanism.java
Patch:
@@ -44,7 +44,6 @@
 import java.nio.charset.StandardCharsets;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -136,7 +135,7 @@ public DigestAuthenticationMechanism(final String realmName, final String domain
     }
 
     public DigestAuthenticationMechanism(final String realmName, final String domain, final String mechanismName, final IdentityManager identityManager) {
-        this(Collections.singletonList(DigestAlgorithm.MD5), new ArrayList<DigestQop>(0), realmName, domain, new SimpleNonceManager(), DEFAULT_NAME, identityManager);
+        this(Collections.singletonList(DigestAlgorithm.MD5), Collections.singletonList(DigestQop.AUTH), realmName, domain, new SimpleNonceManager(), DEFAULT_NAME, identityManager);
     }
 
     @SuppressWarnings("deprecation")

File: servlet/src/test/java/io/undertow/servlet/test/security/digest/DigestAuthTestCase.java
Patch:
@@ -21,7 +21,6 @@
 import static io.undertow.util.Headers.DIGEST;
 import static io.undertow.util.Headers.WWW_AUTHENTICATE;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import io.undertow.security.idm.DigestAlgorithm;
 import io.undertow.security.impl.DigestAuthorizationToken;
@@ -131,7 +130,7 @@ public void testCall(final String path, final String expectedResponse) throws Ex
         Map<DigestWWWAuthenticateToken, String> parsedHeader = DigestWWWAuthenticateToken.parseHeader(value.substring(7));
         assertEquals(REALM_NAME, parsedHeader.get(DigestWWWAuthenticateToken.REALM));
         assertEquals(DigestAlgorithm.MD5.getToken(), parsedHeader.get(DigestWWWAuthenticateToken.ALGORITHM));
-        assertFalse(parsedHeader.containsKey(DigestWWWAuthenticateToken.MESSAGE_QOP));
+        assertTrue(parsedHeader.containsKey(DigestWWWAuthenticateToken.MESSAGE_QOP));
 
         String nonce = parsedHeader.get(DigestWWWAuthenticateToken.NONCE);
 

File: core/src/main/java/io/undertow/websockets/core/protocol/version07/WebSocket07FrameSinkChannel.java
Patch:
@@ -156,11 +156,11 @@ Known extensions (i.e. compression) should not modify RSV bit on continuation bi
     }
 
     @Override
-    public boolean send(Pooled<ByteBuffer> pooled) throws IOException {
+    public boolean sendInternal(Pooled<ByteBuffer> pooled) throws IOException {
         // Check that the underlying write will succeed prior to applying the function
         // Could corrupt LZW stream if not
         if(safeToSend()) {
-            return super.send(extensionFunction.transformForWrite(pooled, getWebSocketChannel()));
+            return super.sendInternal(extensionFunction.transformForWrite(pooled, getWebSocketChannel()));
         }
 
         return false;

File: servlet/src/main/java/io/undertow/servlet/UndertowServletMessages.java
Patch:
@@ -209,4 +209,6 @@ public interface UndertowServletMessages {
     @Message(id = 10054, value = "Unable to create an instance factory for %s")
     RuntimeException couldNotCreateFactory(String className, @Cause Exception e);
 
+    @Message(id = 10055, value = "Listener is not started")
+    IllegalStateException listenerIsNotStarted();
 }

File: core/src/main/java/io/undertow/server/handlers/form/MultiPartParserDefinition.java
Patch:
@@ -197,7 +197,6 @@ public FormData parseBlocking() throws IOException {
                 return existing;
             }
 
-            final MultipartParser.ParseState parser = MultipartParser.beginParse(exchange.getConnection().getBufferPool(), this, boundary.getBytes(), exchange.getRequestCharset());
             InputStream inputStream = exchange.getInputStream();
             if (inputStream == null) {
                 throw new IOException(UndertowMessages.MESSAGES.requestChannelAlreadyProvided());

File: core/src/main/java/io/undertow/util/Headers.java
Patch:
@@ -324,7 +324,7 @@ public static String extractQuotedValueFromHeader(final String header, final Str
             //no quotes
             for (end = start; end < header.length(); ++end) {
                 char c = header.charAt(end);
-                if (c == ' ' || c == '\t') {
+                if (c == ' ' || c == '\t' || c == ';') {
                     break;
                 }
             }

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletInitialHandler.java
Patch:
@@ -144,6 +144,7 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
             //this can only happen if the path ends with a /
             //otherwise there would be a redirect instead
             exchange.setRelativePath(info.getRewriteLocation());
+            exchange.setRequestPath(exchange.getRequestPath() + info.getRewriteLocation());
         }
 
         final HttpServletResponseImpl response = new HttpServletResponseImpl(exchange, servletContext);

File: servlet/src/test/java/io/undertow/servlet/test/multipart/MultiPartTestCase.java
Patch:
@@ -106,7 +106,8 @@ public void testMultiPartRequest() throws IOException {
         try {
             String uri = DefaultServer.getDefaultServerURL() + "/servletContext/1";
             HttpPost post = new HttpPost(uri);
-            MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);
+
+            MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE, null, StandardCharsets.UTF_8);
 
             entity.addPart("formValue", new StringBody("myValue", "text/plain", StandardCharsets.UTF_8));
             entity.addPart("file", new FileBody(new File(MultiPartTestCase.class.getResource("uploadfile.txt").getFile())));

File: core/src/main/java/io/undertow/websockets/core/AbstractReceiveListener.java
Patch:
@@ -167,11 +167,10 @@ public void onError(WebSocketChannel channel, BufferedTextMessage context, Throw
     }
 
     protected void onFullTextMessage(final WebSocketChannel channel, BufferedTextMessage message) throws IOException {
-
     }
 
     protected void onFullBinaryMessage(final WebSocketChannel channel, BufferedBinaryMessage message) throws IOException {
-
+        message.getData().free();
     }
 
     protected void onFullPingMessage(final WebSocketChannel channel, BufferedBinaryMessage message) throws IOException {
@@ -180,6 +179,7 @@ protected void onFullPingMessage(final WebSocketChannel channel, BufferedBinaryM
     }
 
     protected void onFullPongMessage(final WebSocketChannel channel, BufferedBinaryMessage message) throws IOException {
+        message.getData().free();
     }
 
     protected void onFullCloseMessage(final WebSocketChannel channel, BufferedBinaryMessage message) throws IOException {
@@ -196,7 +196,6 @@ protected void onFullCloseMessage(final WebSocketChannel channel, BufferedBinary
     }
 
     protected void onCloseMessage(CloseMessage cm, WebSocketChannel channel) {
-
     }
 
     private static class FreeDataCallback implements WebSocketCallback<Void> {

File: core/src/main/java/io/undertow/server/protocol/http2/Http2UpgradeHandler.java
Patch:
@@ -66,6 +66,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
             if(settings != null) {
                 //required by spec
                 final ByteBuffer settingsFrame = FlexBase64.decodeURL(settings);
+                exchange.getResponseHeaders().put(Headers.UPGRADE, upgrade);
                 exchange.upgradeChannel(new HttpUpgradeListener() {
                     @Override
                     public void handleUpgrade(StreamConnection streamConnection, HttpServerExchange exchange) {

File: core/src/main/java/io/undertow/websockets/core/protocol/version07/WebSocket07CloseFrameSourceChannel.java
Patch:
@@ -64,7 +64,7 @@ public void afterRead(ByteBuffer buf, int position, int length) throws IOExcepti
                 if(statusBytesRead == 2) {
                     // Must have 2 byte integer within the valid range
                     if (status >= 0 && status <= 999 || status >= 1004 && status <= 1006
-                            || status >= 1012 && status <= 2999) {
+                            || status >= 1012 && status <= 2999 || status >= 5000) {
                         IOException exception =  WebSocketMessages.MESSAGES.invalidCloseFrameStatusCode(status);
                         wsChannel.markReadsBroken(exception);
                         throw exception;

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -242,7 +242,7 @@ public interface UndertowMessages {
     IllegalStateException matcherAlreadyContainsTemplate(String templateString, String templateString1);
 
     @Message(id = 72, value = "Failed to decode url %s to charset %s")
-    IllegalArgumentException failedToDecodeURL(String s, String enc);
+    IllegalArgumentException failedToDecodeURL(String s, String enc, @Cause Exception e);
 
 
     @Message(id = 73, value = "Resource change listeners are not supported")
@@ -414,6 +414,4 @@ public interface UndertowMessages {
     @Message(id = 128, value = "Remote peer closed connection before all data could be read")
     IOException couldNotReadContentLengthData();
 
-    @Message(id = 129, value = "Failed to decode url %s to charset %s")
-    IllegalArgumentException failedToDecodeURL(String s, String enc, @Cause Exception e);
 }

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -413,4 +413,7 @@ public interface UndertowMessages {
 
     @Message(id = 128, value = "Remote peer closed connection before all data could be read")
     IOException couldNotReadContentLengthData();
+
+    @Message(id = 129, value = "Failed to decode url %s to charset %s")
+    IllegalArgumentException failedToDecodeURL(String s, String enc, @Cause Exception e);
 }

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/ModCluster.java
Patch:
@@ -198,7 +198,7 @@ public static class Builder {
 
         private int maxRequestTime = -1;
         private long ttl;
-        private boolean useAlias = true;
+        private boolean useAlias = false;
 
         private NodeHealthChecker healthChecker = NodeHealthChecker.NO_CHECK;
         private long healthCheckInterval = TimeUnit.SECONDS.toMillis(10);

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/ModCluster.java
Patch:
@@ -198,7 +198,7 @@ public static class Builder {
 
         private int maxRequestTime = -1;
         private long ttl;
-        private boolean useAlias = true;
+        private boolean useAlias = false;
 
         private NodeHealthChecker healthChecker = NodeHealthChecker.NO_CHECK;
         private long healthCheckInterval = TimeUnit.SECONDS.toMillis(10);

File: core/src/main/java/io/undertow/server/handlers/accesslog/DefaultAccessLogReceiver.java
Patch:
@@ -32,6 +32,7 @@
 import java.util.Date;
 import java.util.Deque;
 import java.util.List;
+import java.util.Locale;
 import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
@@ -122,7 +123,7 @@ private void calculateChangeOverPoint() {
         calendar.set(Calendar.MINUTE, 0);
         calendar.set(Calendar.HOUR, 0);
         calendar.add(Calendar.DATE, 1);
-        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");
+        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
         currentDateString = df.format(new Date());
         changeOverPoint = calendar.getTimeInMillis();
     }

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/MCMPAdvertiseTask.java
Patch:
@@ -28,6 +28,7 @@
 import java.security.NoSuchAlgorithmException;
 import java.text.SimpleDateFormat;
 import java.util.Date;
+import java.util.Locale;
 import java.util.concurrent.TimeUnit;
 
 import io.undertow.UndertowLogger;
@@ -41,7 +42,7 @@
 class MCMPAdvertiseTask implements Runnable {
 
     public static final String RFC_822_FMT = "EEE, d MMM yyyy HH:mm:ss Z";
-    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(RFC_822_FMT);
+    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(RFC_822_FMT, Locale.US);
     private static final boolean linuxLike;
     private static final boolean windows;
 

File: core/src/main/java/io/undertow/server/handlers/resource/DirectoryUtils.java
Patch:
@@ -26,6 +26,7 @@
 import java.security.NoSuchAlgorithmException;
 import java.text.SimpleDateFormat;
 import java.util.Date;
+import java.util.Locale;
 
 import io.undertow.UndertowLogger;
 import io.undertow.server.HttpServerExchange;
@@ -123,7 +124,7 @@ public static StringBuilder renderDirectoryListing(String path, Resource resourc
         }
 
 
-        SimpleDateFormat format = new SimpleDateFormat("MMM dd, yyyy HH:mm:ss");
+        SimpleDateFormat format = new SimpleDateFormat("MMM dd, yyyy HH:mm:ss", Locale.US);
         int i = 0;
         if (parent != null) {
             i++;

File: servlet/src/main/java/io/undertow/servlet/spec/ServletOutputStreamImpl.java
Patch:
@@ -745,7 +745,7 @@ public void setWriteListener(final WriteListener writeListener) {
         if (listener != null) {
             throw UndertowServletMessages.MESSAGES.listenerAlreadySet();
         }
-        final ServletRequest servletRequest = servletRequestContext.getServletRequest();
+        final ServletRequest servletRequest = servletRequestContext.getOriginalRequest();
         if (!servletRequest.isAsyncStarted()) {
             throw UndertowServletMessages.MESSAGES.asyncNotStarted();
         }

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -410,4 +410,7 @@ public interface UndertowMessages {
 
     @Message(id = 127, value = "Response has already been sent")
     IllegalStateException responseComplete();
+
+    @Message(id = 128, value = "Remote peer closed connection before all data could be read")
+    IOException couldNotReadContentLengthData();
 }

File: core/src/main/java/io/undertow/server/handlers/ByteRangeHandler.java
Patch:
@@ -110,7 +110,7 @@ public StreamSinkConduit wrap(ConduitFactory<StreamSinkConduit> factory, HttpSer
                             return factory.create();
                         }
                         start = responseLength - end;
-                        end = responseLength;
+                        end = responseLength - 1;
                     } else if(end == -1) {
                         //prefix range
                         long toWrite = responseLength - start;
@@ -120,7 +120,7 @@ public StreamSinkConduit wrap(ConduitFactory<StreamSinkConduit> factory, HttpSer
                             //ignore the range request
                             return factory.create();
                         }
-                        end = responseLength;
+                        end = responseLength - 1;
                     } else {
                         long toWrite = end - start + 1;
                         exchange.setResponseContentLength(toWrite);

File: core/src/main/java/io/undertow/server/handlers/resource/ResourceHandler.java
Patch:
@@ -250,7 +250,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                                 range = null;
                             }
                             start = contentLength - end;
-                            end = contentLength;
+                            end = contentLength -1;
                         } else if(end == -1) {
                             //prefix range
                             long toWrite = contentLength - start;
@@ -260,14 +260,14 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                                 //ignore the range request
                                 range = null;
                             }
-                            end = contentLength;
+                            end = contentLength - 1;
                         } else {
                             long toWrite = end - start + 1;
                             exchange.setResponseContentLength(toWrite);
                         }
                         if(range != null) {
                             exchange.setResponseCode(StatusCodes.PARTIAL_CONTENT);
-                            exchange.getResponseHeaders().put(Headers.CONTENT_RANGE, range.getStart(0) + "-" + range.getEnd(0) + "/" + contentLength);
+                            exchange.getResponseHeaders().put(Headers.CONTENT_RANGE, start + "-" + end + "/" + contentLength);
                         }
                     }
                 }

File: core/src/main/java/io/undertow/server/session/InMemorySessionManager.java
Patch:
@@ -361,7 +361,7 @@ synchronized void bumpTimeout() {
 
             final int maxInactiveInterval = getMaxInactiveInterval();
             if (maxInactiveInterval > 0) {
-                long newExpireTime = System.currentTimeMillis() + (maxInactiveInterval * 500L);
+                long newExpireTime = System.currentTimeMillis() + (maxInactiveInterval * 1000L);
                 if(timerCancelKey != null && (newExpireTime < expireTime)) {
                     // We have to re-schedule as the new maxInactiveInterval is lower than the old one
                     if (!timerCancelKey.remove()) {
@@ -374,7 +374,7 @@ synchronized void bumpTimeout() {
                     //+500ms, to make sure that the time has actually expired
                     //we don't re-schedule every time, as it is expensive
                     //instead when it expires we check if the timeout has been bumped, and if so we re-schedule
-                    timerCancelKey = executor.executeAfter(cancelTask, (maxInactiveInterval * 500L) + 1, TimeUnit.MILLISECONDS);
+                    timerCancelKey = executor.executeAfter(cancelTask, (maxInactiveInterval * 1000L) + 500L, TimeUnit.MILLISECONDS);
                 }
             }
             if (evictionToken != null) {

File: core/src/main/java/io/undertow/server/session/InMemorySessionManager.java
Patch:
@@ -361,7 +361,7 @@ synchronized void bumpTimeout() {
 
             final int maxInactiveInterval = getMaxInactiveInterval();
             if (maxInactiveInterval > 0) {
-                long newExpireTime = System.currentTimeMillis() + (maxInactiveInterval * 500L);
+                long newExpireTime = System.currentTimeMillis() + (maxInactiveInterval * 1000L);
                 if(timerCancelKey != null && (newExpireTime < expireTime)) {
                     // We have to re-schedule as the new maxInactiveInterval is lower than the old one
                     if (!timerCancelKey.remove()) {
@@ -374,7 +374,7 @@ synchronized void bumpTimeout() {
                     //+500ms, to make sure that the time has actually expired
                     //we don't re-schedule every time, as it is expensive
                     //instead when it expires we check if the timeout has been bumped, and if so we re-schedule
-                    timerCancelKey = executor.executeAfter(cancelTask, (maxInactiveInterval * 500L) + 1, TimeUnit.MILLISECONDS);
+                    timerCancelKey = executor.executeAfter(cancelTask, (maxInactiveInterval * 1000L) + 500L, TimeUnit.MILLISECONDS);
                 }
             }
             if (evictionToken != null) {

File: core/src/main/java/io/undertow/server/handlers/builder/ResponseCodeHandlerBuilder.java
Patch:
@@ -52,7 +52,7 @@ public Set<String> requiredParameters() {
 
     @Override
     public String defaultParameter() {
-        return "200";
+        return "value";
     }
 
     @Override

File: core/src/test/java/io/undertow/server/handlers/error/FileErrorPageHandlerTestCase.java
Patch:
@@ -49,6 +49,7 @@ public void testFileBasedErrorPageIsGenerated() throws IOException, URISyntaxExc
 
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path");
             HttpResponse result = client.execute(get);
+            Assert.assertEquals("text/html", result.getHeaders("Content-Type")[0].getValue());
             Assert.assertEquals(StatusCodes.NOT_FOUND, result.getStatusLine().getStatusCode());
             final String response = HttpClientUtils.readResponse(result);
 

File: core/src/main/java/io/undertow/server/session/SecureRandomSessionIdGenerator.java
Patch:
@@ -84,13 +84,13 @@ private char[] encode(byte[] data) {
                 val |= (0xFF & (int) data[i + 2]);
                 quad = true;
             }
-            out[index + 3] = alphabet[(quad ? (val & 0x3F) : 64)];
+            out[index + 3] = alphabet[(quad ? (val & 0x3F) : 63)];
             val >>= 6;
-            out[index + 2] = alphabet[(trip ? (val & 0x3F) : 64)];
+            out[index + 2] = alphabet[(trip ? (val & 0x3F) : 63)];
             val >>= 6;
             out[index + 1] = alphabet[val & 0x3F];
             val >>= 6;
-            out[index + 0] = alphabet[val & 0x3F];
+            out[index] = alphabet[val & 0x3F];
         }
         return out;
     }

File: examples/src/main/java/io/undertow/examples/security/basic/BasicAuthServer.java
Patch:
@@ -40,7 +40,7 @@
 
 /**
  * Example of HTTP Basic auth
- * <p/>
+ * <p>
  * TODO: this needs to be cleaned up
  *
  * @author Stuart Douglas

File: http2-test-suite/src/main/java/io/undertow/http2/tests/framework/Http2TestRunner.java
Patch:
@@ -129,7 +129,7 @@ public void testRunFinished(final Result result) throws Exception {
 
     /**
      * When using the default SSL settings returns the corresponding client context.
-     * <p/>
+     * <p>
      * If a test case is initialising a custom server side SSLContext then the test case will be responsible for creating it's
      * own client side.
      *

File: core/src/main/java/io/undertow/server/session/PathParameterSessionConfig.java
Patch:
@@ -91,7 +91,7 @@ public String rewriteUrl(final String url, final String sessionId) {
             anchor = path.substring(pound);
             path = path.substring(0, pound);
         }
-        int fragmentIndex = url.lastIndexOf(';');
+        int fragmentIndex = path.lastIndexOf(';');
         if(fragmentIndex >= 0) {
             fragment = path.substring(fragmentIndex);
             path = path.substring(0, fragmentIndex);

File: core/src/main/java/io/undertow/server/session/SecureRandomSessionIdGenerator.java
Patch:
@@ -34,7 +34,7 @@ public class SecureRandomSessionIdGenerator implements SessionIdGenerator {
 
     private final SecureRandom random = new SecureRandom();
 
-    private volatile int length = 18;
+    private volatile int length = 30;
 
     private static final char[] SESSION_ID_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".toCharArray();
 

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletPathMatches.java
Patch:
@@ -404,10 +404,10 @@ private static MatchData resolveServletForPath(final String path, final Map<Stri
         for (final Map.Entry<String, ServletHandler> entry : pathServlets.entrySet()) {
             String key = entry.getKey();
             if (key.endsWith("/*")) {
-                final String base = key.substring(0, key.length() - 2);
+                final String base = key.substring(0, key.length() - 1);
                 if (match == null || base.length() > match.length()) {
                     if (path.startsWith(base)) {
-                        match = base;
+                        match = base.substring(0, base.length() - 1);
                         servlet = entry.getValue();
                     }
                 }

File: core/src/test/java/io/undertow/server/handlers/PredicatedHandlersTestCase.java
Patch:
@@ -50,7 +50,8 @@ public void testRewrite() throws IOException {
                                         "regex('(.*).css') -> rewrite['${1}.xcss'] -> set[attribute='%{o,chained}', value=true]\n" +
                                         "regex('(.*).redirect$') -> redirect['${1}.redirected']\n" +
                                         "set[attribute='%{o,someHeader}', value=always]\n" +
-                                        "path-template('/foo/{bar}/{f}') -> set[attribute='%{o,template}', value='${bar}']", getClass().getClassLoader()), new HttpHandler() {
+                                        "path-template('/foo/{bar}/{f}') -> set[attribute='%{o,template}', value='${bar}']\n" +
+                                        "path-template('/bar->foo') -> redirect(/)", getClass().getClassLoader()), new HttpHandler() {
                     @Override
                     public void handleRequest(HttpServerExchange exchange) throws Exception {
                         exchange.getResponseSender().send(exchange.getRelativePath());

File: core/src/test/java/io/undertow/server/handlers/form/MultipartFormDataParserTestCase.java
Patch:
@@ -60,8 +60,8 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
                     if (data.getFirst("formValue").getValue().equals("myValue")) {
                         FormData.FormValue file = data.getFirst("file");
                         if (file.isFile()) {
-                            if (file.getFile() != null) {
-                                if (new String(Files.readAllBytes(file.getFile())).startsWith("file contents")) {
+                            if (file.getPath() != null) {
+                                if (new String(Files.readAllBytes(file.getPath())).startsWith("file contents")) {
                                     exchange.setResponseCode(StatusCodes.OK);
                                 }
                             }

File: core/src/main/java/io/undertow/predicate/PredicateParser.java
Patch:
@@ -215,6 +215,9 @@ private static Object parsePredicate(final String string, final Token token, fin
                 }
                 while (!next.token.equals(endChar)) {
                     Token equals = tokens.poll();
+                    if(equals == null) {
+                        throw error(string, string.length(), "Unexpected end of input");
+                    }
                     if (!equals.token.equals("=")) {
                         if (equals.token.equals(endChar) && values.isEmpty()) {
                             //single value case

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -435,7 +435,7 @@ private void initializeTempDir(final ServletContextImpl servletContext, final De
     private void initializeMimeMappings(final DeploymentImpl deployment, final DeploymentInfo deploymentInfo) {
         final Map<String, String> mappings = new HashMap<>(MimeMappings.DEFAULT_MIME_MAPPINGS);
         for (MimeMapping mapping : deploymentInfo.getMimeMappings()) {
-            mappings.put(mapping.getExtension(), mapping.getMimeType());
+            mappings.put(mapping.getExtension().toLowerCase(Locale.ENGLISH), mapping.getMimeType());
         }
         deployment.setMimeExtensionMappings(mappings);
     }

File: servlet/src/main/java/io/undertow/servlet/spec/ServletContextImpl.java
Patch:
@@ -196,7 +196,7 @@ public String getMimeType(final String file) {
         if(file == null) {
             return null;
         }
-        String lower = file.toLowerCase();
+        String lower = file.toLowerCase(Locale.ENGLISH);
         int pos = lower.lastIndexOf('.');
         if (pos == -1) {
             return deployment.getMimeExtensionMappings().get(lower);

File: servlet/src/main/java/io/undertow/servlet/core/ManagedServlet.java
Patch:
@@ -89,14 +89,14 @@ public void setupMultipart(ServletContextImpl servletContext) {
             }
             final Path tempDir;
             if(config.getLocation() == null || config.getLocation().isEmpty()) {
-                tempDir = servletContext.getDeployment().getDeploymentInfo().getTempDirPath();
+                tempDir = servletContext.getDeployment().getDeploymentInfo().getTempPath();
             } else {
                 String location = config.getLocation();
                 Path locFile = Paths.get(location);
                 if(locFile.isAbsolute()) {
                     tempDir = locFile;
                 } else {
-                    tempDir = servletContext.getDeployment().getDeploymentInfo().getTempDirPath().resolve(location);
+                    tempDir = servletContext.getDeployment().getDeploymentInfo().getTempPath().resolve(location);
                 }
             }
 

File: servlet/src/main/java/io/undertow/servlet/spec/PartImpl.java
Patch:
@@ -98,7 +98,7 @@ public void write(final String fileName) throws IOException {
         Path target = Paths.get(fileName);
         if(!target.isAbsolute()) {
             if(config.getLocation().isEmpty()) {
-                target = servletContext.getDeployment().getDeploymentInfo().getTempDirPath().resolve(fileName);
+                target = servletContext.getDeployment().getDeploymentInfo().getTempPath().resolve(fileName);
             } else {
                 target = Paths.get(config.getLocation(), fileName);
             }

File: core/src/main/java/io/undertow/protocols/ssl/SslConduit.java
Patch:
@@ -648,7 +648,7 @@ private long doUnwrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcep
                 this.dataToUnwrap = null;
                 notifyReadClosed();
                 return -1;
-            } else if (res == 0 && engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
+            } else if (!this.dataToUnwrap.getResource().hasRemaining() && engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
                 return 0;
             }
 

File: servlet/src/main/java/io/undertow/servlet/core/ManagedServlet.java
Patch:
@@ -89,14 +89,14 @@ public void setupMultipart(ServletContextImpl servletContext) {
             }
             final Path tempDir;
             if(config.getLocation() == null || config.getLocation().isEmpty()) {
-                tempDir = servletContext.getDeployment().getDeploymentInfo().getTempDir();
+                tempDir = servletContext.getDeployment().getDeploymentInfo().getTempDirPath();
             } else {
                 String location = config.getLocation();
                 Path locFile = Paths.get(location);
                 if(locFile.isAbsolute()) {
                     tempDir = locFile;
                 } else {
-                    tempDir = servletContext.getDeployment().getDeploymentInfo().getTempDir().resolve(location);
+                    tempDir = servletContext.getDeployment().getDeploymentInfo().getTempDirPath().resolve(location);
                 }
             }
 

File: servlet/src/main/java/io/undertow/servlet/spec/PartImpl.java
Patch:
@@ -98,7 +98,7 @@ public void write(final String fileName) throws IOException {
         Path target = Paths.get(fileName);
         if(!target.isAbsolute()) {
             if(config.getLocation().isEmpty()) {
-                target = servletContext.getDeployment().getDeploymentInfo().getTempDir().resolve(fileName);
+                target = servletContext.getDeployment().getDeploymentInfo().getTempDirPath().resolve(fileName);
             } else {
                 target = Paths.get(config.getLocation(), fileName);
             }

File: core/src/main/java/io/undertow/client/http2/Http2ClientConnection.java
Patch:
@@ -94,7 +94,6 @@ public void handleEvent(Http2Channel channel) {
     public void sendRequest(ClientRequest request, ClientCallback<ClientExchange> clientCallback) {
         request.getRequestHeaders().put(PATH, request.getPath());
         request.getRequestHeaders().put(SCHEME, "https");
-        request.getRequestHeaders().put(AUTHORITY, request.getProtocol().toString());
         request.getRequestHeaders().put(METHOD, request.getMethod().toString());
         request.getRequestHeaders().put(AUTHORITY, request.getRequestHeaders().getFirst(Headers.HOST));
         request.getRequestHeaders().remove(Headers.HOST);

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/MCMPAdvertiseTask.java
Patch:
@@ -23,6 +23,7 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.text.SimpleDateFormat;
@@ -168,7 +169,7 @@ public void run() {
                     .append("X-Manager-Host: ").append(host).append(CRLF);
 
             final String payload = builder.toString();
-            final ByteBuffer byteBuffer = ByteBuffer.wrap(payload.getBytes());
+            final ByteBuffer byteBuffer = ByteBuffer.wrap(payload.getBytes(StandardCharsets.US_ASCII));
             UndertowLogger.ROOT_LOGGER.proxyAdvertiseMessagePayload(payload);
             channel.sendTo(address, byteBuffer);
         } catch (Exception e) {

File: servlet/src/test/java/io/undertow/servlet/test/streams/ServletInputStreamConnectionTerminationTestCase.java
Patch:
@@ -27,7 +27,6 @@
 import io.undertow.testutils.TestHttpClient;
 import io.undertow.util.StatusCodes;
 import org.apache.http.HttpResponse;
-import org.apache.http.NoHttpResponseException;
 import org.apache.http.client.methods.HttpPost;
 import org.apache.http.entity.StringEntity;
 import org.junit.Assert;
@@ -44,7 +43,7 @@
 @RunWith(DefaultServer.class)
 @HttpOneOnly
 @ProxyIgnore
-public class ConnectionTerminationTestCase {
+public class ServletInputStreamConnectionTerminationTestCase {
 
     public static final String HELLO_WORLD = "Hello World";
 
@@ -73,7 +72,7 @@ public void testConnectionTermination() throws IOException {
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
             final String response = HttpClientUtils.readResponse(result);
             Assert.fail();
-        } catch (NoHttpResponseException expected) {
+        } catch (IOException expected) {
             //expected
         } finally {
             client.getConnectionManager().shutdown();

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/MCMPAdvertiseTask.java
Patch:
@@ -104,7 +104,7 @@ public void handleEvent(MulticastMessageChannel channel) {
             ssalt = md.digest();
         }
 
-        UndertowLogger.ROOT_LOGGER.infof("Undertow starts mod_cluster proxy advertisements on %s with frequency %d ms.", address, config.getAdvertiseFrequency());
+        UndertowLogger.ROOT_LOGGER.proxyAdvertisementsStarted(address.toString(), config.getAdvertiseFrequency());
     }
 
     private static final String CRLF = "\r\n";
@@ -161,10 +161,10 @@ public void run() {
 
             final String payload = builder.toString();
             final ByteBuffer byteBuffer = ByteBuffer.wrap(payload.getBytes());
-            UndertowLogger.ROOT_LOGGER.debugf("Gonna send payload: \n%s", payload);
+            UndertowLogger.ROOT_LOGGER.proxyAdvertiseMessagePayload(payload);
             channel.sendTo(address, byteBuffer);
         } catch (Exception e) {
-            UndertowLogger.ROOT_LOGGER.errorf(e, "Cannot send advertise message. address: %s", address);
+            UndertowLogger.ROOT_LOGGER.proxyAdvertiseCannotSendMessage(e, address);
         }
     }
 

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/Node.java
Patch:
@@ -367,7 +367,7 @@ protected void markInError() {
             oldState = this.state;
             newState = oldState | ERROR;
             if (stateUpdater.compareAndSet(this, oldState, newState)) {
-                UndertowLogger.ROOT_LOGGER.debugf("Node '%s' in error", jvmRoute);
+                UndertowLogger.ROOT_LOGGER.nodeIsInError(jvmRoute);
                 return;
             }
         }
@@ -395,7 +395,7 @@ private int healthCheckFailed() {
             oldState = this.state;
             if ((oldState & ERROR) != ERROR) {
                 newState = oldState | ERROR;
-                UndertowLogger.ROOT_LOGGER.debugf("Node '%s' in error", jvmRoute);
+                UndertowLogger.ROOT_LOGGER.nodeIsInError(jvmRoute);
             } else if ((oldState & ERROR_MASK) == ERROR_MASK) {
                 return ERROR_MASK;
             } else {

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/NodeConfig.java
Patch:
@@ -17,6 +17,8 @@
  */
 package io.undertow.server.handlers.proxy.mod_cluster;
 
+import io.undertow.UndertowLogger;
+
 import java.net.URI;
 import java.net.URISyntaxException;
 
@@ -95,6 +97,7 @@ public class NodeConfig {
         cacheConnections = b.cacheConnections;
         requestQueueSize = b.requestQueueSize;
         queueNewRequests = b.queueNewRequests;
+        UndertowLogger.ROOT_LOGGER.nodeConfigCreated(this.connectionURI, balancer, domain, jvmRoute, flushPackets, flushwait, ping, ttl, timeout, maxConnections, cacheConnections, requestQueueSize, queueNewRequests);
     }
 
     /**

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/NodePingUtil.java
Patch:
@@ -24,6 +24,7 @@
 import java.nio.ByteBuffer;
 import java.util.concurrent.TimeUnit;
 
+import io.undertow.UndertowLogger;
 import io.undertow.client.ClientCallback;
 import io.undertow.client.ClientConnection;
 import io.undertow.client.ClientExchange;
@@ -308,6 +309,7 @@ static class HttpClientPingTask implements Runnable {
         @Override
         public void run() {
 
+            UndertowLogger.ROOT_LOGGER.httpClientPingTask(connection);
             // TODO AJP has a special ping thing
             client.connect(new ClientCallback<ClientConnection>() {
                 @Override

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/MCMPAdvertiseTask.java
Patch:
@@ -104,7 +104,7 @@ public void handleEvent(MulticastMessageChannel channel) {
             ssalt = md.digest();
         }
 
-        UndertowLogger.ROOT_LOGGER.infof("Undertow starts mod_cluster proxy advertisements on %s with frequency %d ms.", address, config.getAdvertiseFrequency());
+        UndertowLogger.ROOT_LOGGER.proxyAdvertisementsStarted(address.toString(), config.getAdvertiseFrequency());
     }
 
     private static final String CRLF = "\r\n";
@@ -161,10 +161,10 @@ public void run() {
 
             final String payload = builder.toString();
             final ByteBuffer byteBuffer = ByteBuffer.wrap(payload.getBytes());
-            UndertowLogger.ROOT_LOGGER.debugf("Gonna send payload: \n%s", payload);
+            UndertowLogger.ROOT_LOGGER.proxyAdvertiseMessagePayload(payload);
             channel.sendTo(address, byteBuffer);
         } catch (Exception e) {
-            UndertowLogger.ROOT_LOGGER.errorf(e, "Cannot send advertise message. address: %s", address);
+            UndertowLogger.ROOT_LOGGER.proxyAdvertiseCannotSendMessage(e, address);
         }
     }
 

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/Node.java
Patch:
@@ -367,7 +367,7 @@ protected void markInError() {
             oldState = this.state;
             newState = oldState | ERROR;
             if (stateUpdater.compareAndSet(this, oldState, newState)) {
-                UndertowLogger.ROOT_LOGGER.debugf("Node '%s' in error", jvmRoute);
+                UndertowLogger.ROOT_LOGGER.nodeIsInError(jvmRoute);
                 return;
             }
         }
@@ -395,7 +395,7 @@ private int healthCheckFailed() {
             oldState = this.state;
             if ((oldState & ERROR) != ERROR) {
                 newState = oldState | ERROR;
-                UndertowLogger.ROOT_LOGGER.debugf("Node '%s' in error", jvmRoute);
+                UndertowLogger.ROOT_LOGGER.nodeIsInError(jvmRoute);
             } else if ((oldState & ERROR_MASK) == ERROR_MASK) {
                 return ERROR_MASK;
             } else {

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/NodeConfig.java
Patch:
@@ -17,6 +17,8 @@
  */
 package io.undertow.server.handlers.proxy.mod_cluster;
 
+import io.undertow.UndertowLogger;
+
 import java.net.URI;
 import java.net.URISyntaxException;
 
@@ -95,6 +97,7 @@ public class NodeConfig {
         cacheConnections = b.cacheConnections;
         requestQueueSize = b.requestQueueSize;
         queueNewRequests = b.queueNewRequests;
+        UndertowLogger.ROOT_LOGGER.nodeConfigCreated(this.connectionURI, balancer, domain, jvmRoute, flushPackets, flushwait, ping, ttl, timeout, maxConnections, cacheConnections, requestQueueSize, queueNewRequests);
     }
 
     /**

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/NodePingUtil.java
Patch:
@@ -24,6 +24,7 @@
 import java.nio.ByteBuffer;
 import java.util.concurrent.TimeUnit;
 
+import io.undertow.UndertowLogger;
 import io.undertow.client.ClientCallback;
 import io.undertow.client.ClientConnection;
 import io.undertow.client.ClientExchange;
@@ -308,6 +309,7 @@ static class HttpClientPingTask implements Runnable {
         @Override
         public void run() {
 
+            UndertowLogger.ROOT_LOGGER.httpClientPingTask(connection);
             // TODO AJP has a special ping thing
             client.connect(new ClientCallback<ClientConnection>() {
                 @Override

File: core/src/main/java/io/undertow/server/handlers/accesslog/DefaultAccessLogReceiver.java
Patch:
@@ -21,6 +21,7 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.Writer;
+import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.StandardOpenOption;
@@ -199,7 +200,7 @@ private void writeMessage(final List<String> messages) {
         }
         try {
             if (writer == null) {
-                writer = Files.newBufferedWriter(defaultLogFile, StandardOpenOption.APPEND, StandardOpenOption.CREATE);
+                writer = Files.newBufferedWriter(defaultLogFile, StandardCharsets.UTF_8, StandardOpenOption.APPEND, StandardOpenOption.CREATE);
             }
             for (String message : messages) {
                 writer.write(message);

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/ModCluster.java
Patch:
@@ -251,8 +251,9 @@ public long getTtl() {
             return ttl;
         }
 
-        public void setTtl(long ttl) {
+        public Builder setTtl(long ttl) {
             this.ttl = ttl;
+            return this;
         }
     }
 

File: core/src/main/java/io/undertow/server/handlers/cache/DirectBufferCache.java
Patch:
@@ -23,6 +23,7 @@
 import java.nio.ByteBuffer;
 import java.util.HashSet;
 import java.util.Set;
+import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.concurrent.ConcurrentHashMap;
@@ -48,7 +49,7 @@ public class DirectBufferCache {
     private static final int SAMPLE_INTERVAL = 5;
 
     private final LimitedBufferSlicePool pool;
-    private final ConcurrentHashMap<Object, CacheEntry> cache;
+    private final ConcurrentMap<Object, CacheEntry> cache;
     private final ConcurrentDirectDeque<CacheEntry> accessQueue;
     private final int sliceSize;
     private final int maxAge;

File: servlet/src/test/java/io/undertow/servlet/test/metrics/TestMetricsCollector.java
Patch:
@@ -22,13 +22,14 @@
 import io.undertow.servlet.api.MetricsCollector;
 
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 /**
  * @author Tomaz Cerar (c) 2014 Red Hat Inc.
  */
 public class TestMetricsCollector implements MetricsCollector {
 
-    private final ConcurrentHashMap<String,MetricsHandler> metrics = new ConcurrentHashMap<>();
+    private final ConcurrentMap<String,MetricsHandler> metrics = new ConcurrentHashMap<>();
 
     @Override
     public void registerMetric(String name, MetricsHandler handler) {

File: core/src/main/java/io/undertow/server/protocol/http/HttpResponseConduit.java
Patch:
@@ -240,7 +240,7 @@ private int processWrite(int state, final Object userData, int pos, int length)
                 }
                 data[0] = buffer;
                 System.arraycopy(userData, pos, data, 1, length);
-                res = next.write(data, 0, data.length);
+                res = next.write(data, 0, length + 1);
             }
             if (res == 0) {
                 return STATE_BUF_FLUSH;

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/DefaultContainerConfigurator.java
Patch:
@@ -31,7 +31,7 @@
 
 /**
  * Server default container configurator.
- * <p/>
+ * <p>
  * This API is stupid, because it has no way to attach deployment specific context.
  *
  * @author Stuart Douglas

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/EncodingFactory.java
Patch:
@@ -45,7 +45,7 @@
 /**
  * Factory class that produces encoding instances for an endpoint. This also provides static
  * methods about the capabilities of encoders.
- * <p/>
+ * <p>
  * These classes also perform implicit encodings for java primitives
  *
  * @author Stuart Douglas

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/JsrWebSocketFilter.java
Patch:
@@ -51,10 +51,10 @@
 
 /**
  * Filter that provides HTTP upgrade functionality. This should be run after all user filters, but before any servlets.
- * <p/>
+ * <p>
  * The use of a filter rather than a servlet allows for normal HTTP requests to be served from the same location
  * as a web socket endpoint if no upgrade header is found.
- * <p/>
+ * <p>
  * TODO: this needs a lot of work
  *
  * @author Stuart Douglas

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/ServerWebSocketContainer.java
Patch:
@@ -387,11 +387,11 @@ public Set<Extension> getInstalledExtensions() {
 
     /**
      * Runs a web socket invocation, setting up the threads and dispatching a thread pool
-     * <p/>
+     * <p>
      * Unfortunately we need to dispatch to a thread pool, because there is a good chance that the endpoint
      * will use blocking IO methods. We suspend recieves while this is in progress, to make sure that we do not have multiple
      * methods invoked at once.
-     * <p/>
+     * <p>
      *
      * @param invocation The task to run
      */

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/handshake/JsrHybi07Handshake.java
Patch:
@@ -28,7 +28,7 @@
 import java.util.Collections;
 
 /**
- * {@link Hybi07Handshake} sub-class which takes care of match against the {@link javax.websocket.server.ServerEndpointConfiguration} and
+ * {@link Hybi07Handshake} sub-class which takes care of match against the {@link javax.websocket.server.ServerEndpointConfig} and
  * stored the config in the attributes for later usage.
  *
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/handshake/JsrHybi08Handshake.java
Patch:
@@ -28,7 +28,7 @@
 import java.util.Collections;
 
 /**
- * {@link Hybi08Handshake} sub-class which takes care of match against the {@link javax.websocket.server.ServerEndpointConfiguration} and
+ * {@link Hybi08Handshake} sub-class which takes care of match against the {@link javax.websocket.server.ServerEndpointConfig} and
  * stored the config in the attributes for later usage.
  *
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>

File: servlet/src/main/java/io/undertow/servlet/api/ConfidentialPortManager.java
Patch:
@@ -20,7 +20,7 @@
 import io.undertow.server.HttpServerExchange;
 
 /**
- * A utility to take the {@see HttpServerExchange} of the current request and obtain the number of the port number to use in
+ * A utility to take the {@link HttpServerExchange} of the current request and obtain the number of the port number to use in
  * https redirects.
  *
  * @author <a href="mailto:darran.lofthouse@jboss.com">Darran Lofthouse</a>

File: servlet/src/main/java/io/undertow/servlet/api/ExceptionHandler.java
Patch:
@@ -28,7 +28,7 @@
  * handler chain. The default handler will simply log the exception, however it is possible to write custom
  * handlers to handle the error however you want. A common use for this would be to change the log format for
  * exceptions, or possibly suppress the logging for certain exceptions types.
- * <p/>
+ * <p>
  * Implementations of this interface may also choose to suppress error page handler, and handle error page generation
  * internally by returning <code>true</code>
  *
@@ -47,7 +47,7 @@ public interface ExceptionHandler {
      * @param request         The request
      * @param response        The response
      * @param throwable       The exception
-     * @return <core>true</core> true if the error was handled by this method
+     * @return <code>true</code> true if the error was handled by this method
      */
     boolean handleThrowable(final HttpServerExchange exchange, ServletRequest request, ServletResponse response, Throwable throwable);
 }

File: servlet/src/main/java/io/undertow/servlet/api/SecurityInfo.java
Patch:
@@ -28,7 +28,7 @@
 public class SecurityInfo<T extends SecurityInfo> implements Cloneable {
 
     /**
-     * Equivalent to {@see ServletSecurity.EmptyRoleSemantic} but with an additional mode to require authentication but no role
+     * Equivalent to {@link javax.servlet.annotation.ServletSecurity.EmptyRoleSemantic} but with an additional mode to require authentication but no role
      * check.
      */
     public enum EmptyRoleSemantic {

File: servlet/src/main/java/io/undertow/servlet/core/ApplicationListeners.java
Patch:
@@ -45,10 +45,10 @@
 
 /**
  * Class that is responsible for invoking application listeners.
- * <p/>
+ * <p>
  * This class does not perform any context setup, the context must be setup
  * before invoking this class.
- * <p/>
+ * <p>
  * Note that arrays are used instead of lists for performance reasons.
  *
  * @author Stuart Douglas

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentImpl.java
Patch:
@@ -43,7 +43,7 @@
 /**
  * Class that represents the mutable state associated with a servlet deployment that is built up
  * during the bootstrap process.
- * <p/>
+ * <p>
  * Classes calling deployment methods during bootstrap must be aware of ordering concerns.
  *
  * @author Stuart Douglas

File: servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java
Patch:
@@ -58,9 +58,9 @@
  * match the current path then the resources will be served up asynchronously using the
  * {@link io.undertow.server.HttpHandler#handleRequest(io.undertow.server.HttpServerExchange)} method,
  * otherwise the request is handled as a normal servlet request.
- * <p/>
+ * <p>
  * By default we only allow a restricted set of extensions.
- * <p/>
+ * <p>
  * todo: this thing needs a lot more work. In particular:
  * - caching for blocking requests
  * - correct mime type

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletHandler.java
Patch:
@@ -38,7 +38,7 @@
 
 /**
  * The handler that is responsible for invoking the servlet
- * <p/>
+ * <p>
  * TODO: do we want to move lifecycle considerations out of this handler?
  *
  * @author Stuart Douglas

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletRequestContext.java
Patch:
@@ -42,10 +42,10 @@
 
 /**
  * All the information that servlet needs to attach to the exchange.
- * <p/>
+ * <p>
  * This is all stored under this class, rather than using individual attachments, as
  * this approach has significant performance advantages.
- * <p/>
+ * <p>
  * The {@link ServletInitialHandler} also pushed this information to the {@link #CURRENT}
  * thread local, which allows it to be access even if the request or response have been
  * wrapped with non-compliant wrapper classes.

File: servlet/src/main/java/io/undertow/servlet/handlers/SessionRestoringHandler.java
Patch:
@@ -41,7 +41,7 @@
 
 /**
  * A handler that restores persistent HTTP session state for requests in development mode.
- * <p/>
+ * <p>
  * This handler should not be used in production environments.
  *
  * @author Stuart Douglas

File: servlet/src/main/java/io/undertow/servlet/handlers/security/SSLInformationAssociationHandler.java
Patch:
@@ -29,7 +29,7 @@
 
 /**
  * Handler that associates SSL metadata with request
- * <p/>
+ * <p>
  * cipher suite - javax.servlet.request.cipher_suite String
  * bit size of the algorithm - javax.servlet.request.key_size Integer
  * SSL session id - javax.servlet.request.ssl_session_id String
@@ -85,8 +85,8 @@ public static int getKeyLength(String cipherSuite) {
      /* ------------------------------------------------------------ */
 
     /**
-     * <p>Return the chain of X509 certificates used to negotiate the SSL Session.</p>
-     * <p/>
+     * Return the chain of X509 certificates used to negotiate the SSL Session.
+     * <p>
      * We convert JSSE's javax.security.cert.X509Certificate[]  to servlet's  java.security.cert.X509Certificate[]
      *
      * @param session the   javax.net.ssl.SSLSession to use as the source of the cert chain.

File: servlet/src/main/java/io/undertow/servlet/handlers/security/ServletConfidentialityConstraintHandler.java
Patch:
@@ -33,7 +33,7 @@
 import java.net.URISyntaxException;
 
 /**
- * Servlet specific extension to {@see SinglePortConfidentialityHandler}
+ * Servlet specific extension to {@link SinglePortConfidentialityHandler}
  *
  * @author <a href="mailto:darran.lofthouse@jboss.com">Darran Lofthouse</a>
  */

File: servlet/src/main/java/io/undertow/servlet/spec/AsyncContextImpl.java
Patch:
@@ -552,8 +552,7 @@ private synchronized void processAsyncTask() {
      * Adds a task to be run to the async context. These tasks are run one at a time,
      * after the initial request is finished. If the request is dispatched before the initial
      * request is complete then these tasks will not be run
-     * <p/>
-     * <p/>
+     * <p>
      * This method is intended to be used to queue read and write tasks for async streams,
      * to make sure that multiple threads do not end up working on the same exchange at once
      *

File: core/src/main/java/io/undertow/Handlers.java
Patch:
@@ -228,7 +228,7 @@ public static RedirectHandler redirect(final String location) {
     /**
      * Returns a new HTTP trace handler. This handler will handle HTTP TRACE
      * requests as per the RFC.
-     * <p/>
+     * <p>
      * WARNING: enabling trace requests may leak information, in general it is recommended that
      * these be disabled for security reasons.
      *
@@ -371,9 +371,9 @@ public static final HttpContinueAcceptingHandler httpContinueAccepting(final Htt
 
     /**
      * A handler that will decode the URL, query parameters and to the specified charset.
-     * <p/>
+     * <p>
      * If you are using this handler you must set the {@link io.undertow.UndertowOptions#DECODE_URL} parameter to false.
-     * <p/>
+     * <p>
      * This is not as efficient as using the parsers built in UTF-8 decoder. Unless you need to decode to something other
      * than UTF-8 you should rely on the parsers decoding instead.
      *

File: core/src/main/java/io/undertow/Undertow.java
Patch:
@@ -52,7 +52,7 @@
 
 /**
  * Convenience class used to build an Undertow server.
- * <p/>
+ * <p>
  *
  * @author Stuart Douglas
  */

File: core/src/main/java/io/undertow/attribute/ExchangeAttribute.java
Patch:
@@ -39,6 +39,7 @@ public interface ExchangeAttribute {
      * Sets a new value for the attribute. Not all attributes are writable.
      * @param exchange The exchange
      * @param newValue The new value for the attribute
+     * @throws  ReadOnlyAttributeException when attribute cannot be written
      */
     void writeAttribute(final HttpServerExchange exchange, final String newValue) throws ReadOnlyAttributeException;
 }

File: core/src/main/java/io/undertow/attribute/ExchangeAttributeBuilder.java
Patch:
@@ -20,7 +20,7 @@
 
 /**
  * An interface that knows how to build an exchange attribute from a textual representation.
- * <p/>
+ * <p>
  * This makes it easy to configure attributes based on a string representation
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/attribute/ExchangeAttributeParser.java
Patch:
@@ -29,7 +29,7 @@
 
 /**
  * Attribute parser for exchange attributes. This builds an attribute from a string definition.
- * <p/>
+ * <p>
  * This uses a service loader mechanism to allow additional token types to be loaded. Token definitions are loaded
  * from the provided class loader.
  *
@@ -61,9 +61,9 @@ public int compare(ExchangeAttributeBuilder o1, ExchangeAttributeBuilder o2) {
 
     /**
      * Parses the provided value string, and turns it into a list of exchange attributes.
-     * <p/>
+     * <p>
      * Tokens are created according to the following rules:
-     * <p/>
+     * <p>
      * %a - % followed by single character. %% is an escape for a literal %
      * %{.*}a? - % plus curly braces with any amount of content inside, followed by an optional character
      * ${.*} - $ followed by a curly braces to reference an item from the predicate context

File: core/src/main/java/io/undertow/channels/GatedStreamSinkChannel.java
Patch:
@@ -40,7 +40,7 @@
 
 /**
  * A 'gated' stream sink channel.
- * <p/>
+ * <p>
  * This channel has a gate which starts of closed. When the gate is closed writes will return 0. When the gate is opened
  * writes will resume as normal.
  *
@@ -70,7 +70,7 @@ public GatedStreamSinkChannel(final StreamSinkChannel delegate) {
 
     /**
      * Open the gate and allow data to flow.  Once opened, the gate cannot be closed other than closing the channel.
-     * <p/>
+     * <p>
      * If the shutdownWrites() or close() method has already been called this will result it in being invoked on the
      * delegate.
      */

File: core/src/main/java/io/undertow/channels/GatedStreamSourceChannel.java
Patch:
@@ -39,7 +39,7 @@
 
 /**
  * A 'gated' stream source channel.
- * <p/>
+ * <p>
  * This channel has a gate which starts of closed. When the gate is closed reads will return 0. When the gate is opened
  * reads will resume as normal.
  *
@@ -69,7 +69,7 @@ public GatedStreamSourceChannel(final StreamSourceChannel delegate) {
 
     /**
      * Open the gate and allow data to flow.  Once opened, the gate cannot be closed other than closing the channel.
-     * <p/>
+     * <p>
      * If the shutdownReads() or close() method has already been called this will result it in being invoked on the
      * delegate.
      */

File: core/src/main/java/io/undertow/channels/WriteTimeoutStreamSinkChannel.java
Patch:
@@ -35,7 +35,7 @@
 
 /**
  * Wrapper for write timeout. This should always be the first wrapper applied to the underlying channel.
- * <p/>
+ * <p>
  *
  * @author Stuart Douglas
  * @see org.xnio.Options#WRITE_TIMEOUT

File: core/src/main/java/io/undertow/conduits/AbstractFramedStreamSinkConduit.java
Patch:
@@ -40,7 +40,7 @@
 /**
  * Utility class to ease the implementation of framed protocols. This call provides a queue of frames, and a callback
  * that can be invoked when a frame event occurs.
- * <p/>
+ * <p>
  * When a write takes place all frames are attempted to be written out at once via a gathering write. Frames can be
  * queued via {@link #queueFrame(io.undertow.conduits.AbstractFramedStreamSinkConduit.FrameCallBack, java.nio.ByteBuffer...)}.
  *
@@ -241,7 +241,7 @@ protected void finished() {
 
     /**
      * Interface that is called when a frame event takes place. The events are:
-     * <p/>
+     * <p>
      * <ul>
      * <li>
      * Done - The fame has been written out

File: core/src/main/java/io/undertow/conduits/ChunkedStreamSinkConduit.java
Patch:
@@ -57,7 +57,7 @@ public class ChunkedStreamSinkConduit extends AbstractStreamSinkConduit<StreamSi
      * Trailers that are to be attached to the end of the HTTP response. Note that it is the callers responsibility
      * to make sure the client understands trailers (i.e. they have provided a TE header), and to set the 'Trailers:'
      * header appropriately.
-     * <p/>
+     * <p>
      * This attachment must be set before the {@link #terminateWrites()} method is called.
      */
     @Deprecated

File: core/src/main/java/io/undertow/conduits/DebuggingStreamSinkConduit.java
Patch:
@@ -34,7 +34,7 @@
 
 /**
  * Conduit that saves all the data that is written through it and can dump it to the console
- * <p/>
+ * <p>
  * Obviously this should not be used in production.
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/conduits/DebuggingStreamSourceConduit.java
Patch:
@@ -33,7 +33,7 @@
 
 /**
  * Conduit that saves all the data that is written through it and can dump it to the console
- * <p/>
+ * <p>
  * Obviously this should not be used in production.
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/conduits/FixedLengthStreamSourceConduit.java
Patch:
@@ -71,7 +71,7 @@ public final class FixedLengthStreamSourceConduit extends AbstractStreamSourceCo
      * Construct a new instance.  The given listener is called once all the bytes are read from the stream
      * <b>or</b> the stream is closed.  This listener should cause the remaining data to be drained from the
      * underlying stream if the underlying stream is to be reused.
-     * <p/>
+     * <p>
      * Calling this constructor will replace the read listener of the underlying channel.  The listener should be
      * restored from the {@code finishListener} object.  The underlying stream should not be closed while this wrapper
      * stream is active.
@@ -97,7 +97,7 @@ public FixedLengthStreamSourceConduit(final StreamSourceConduit next, final long
      * Construct a new instance.  The given listener is called once all the bytes are read from the stream
      * <b>or</b> the stream is closed.  This listener should cause the remaining data to be drained from the
      * underlying stream if the underlying stream is to be reused.
-     * <p/>
+     * <p>
      * Calling this constructor will replace the read listener of the underlying channel.  The listener should be
      * restored from the {@code finishListener} object.  The underlying stream should not be closed while this wrapper
      * stream is active.

File: core/src/main/java/io/undertow/conduits/RateLimitingStreamSinkConduit.java
Patch:
@@ -30,9 +30,9 @@
 
 /**
  * Class that implements the token bucket algorithm.
- * <p/>
+ * <p>
  * Allows send speed to be throttled
- * <p/>
+ * <p>
  * Note that throttling is applied after an initial write, so if a big write is performed initially
  * it may be a while before it can write again.
  *

File: core/src/main/java/io/undertow/io/Sender.java
Patch:
@@ -68,7 +68,7 @@ public interface Sender {
 
     /**
      * Write the given String using async IO, and calls the given callback on completion or error.
-     * <p/>
+     * <p>
      * The CharSequence is encoded to UTF8
      *
      * @param data     The data to send
@@ -88,7 +88,7 @@ public interface Sender {
 
     /**
      * Write the given String using async IO, and ends the exchange when done
-     * <p/>
+     * <p>
      * The CharSequence is encoded to UTF8
      *
      * @param data     The data to send

File: core/src/main/java/io/undertow/io/UndertowOutputStream.java
Patch:
@@ -37,7 +37,7 @@
 
 /**
  * Buffering output stream that wraps a channel.
- * <p/>
+ * <p>
  * This stream delays channel creation, so if a response will fit in the buffer it is not necessary to
  * set the content length header.
  *

File: core/src/main/java/io/undertow/predicate/PredicateBuilder.java
Patch:
@@ -24,7 +24,7 @@
 /**
  * An interface that knows how to build a predicate from a textual representation. This is loaded
  * using a service loader to make it configurable.
- * <p/>
+ * <p>
  * This makes it easy to configure conditions based on a string representation
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/predicate/PredicatesHandler.java
Patch:
@@ -69,7 +69,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
 
     /**
      * Adds a new predicated handler.
-     * <p/>
+     * <p>
      *
      * @param predicate
      * @param handlerWrapper

File: core/src/main/java/io/undertow/predicate/RegularExpressionPredicate.java
Patch:
@@ -32,8 +32,8 @@
 
 /**
  * A predicate that does a regex match against an exchange.
- * <p/>
- * <p/>
+ * <p>
+ * <p>
  * By default this match is done against the relative URI, however it is possible to set it to match against other
  * exchange attributes.
  *

File: core/src/main/java/io/undertow/protocols/http2/HpackException.java
Patch:
@@ -20,7 +20,7 @@
 
 /**
  * Exception that is thrown when the HPACK compress context is broken.
- * <p/>
+ * <p>
  * In this case the connection must be closed.
  */
 public class HpackException extends Exception {

File: core/src/main/java/io/undertow/protocols/http2/Http2PriorityTree.java
Patch:
@@ -74,9 +74,9 @@ public void registerStream(int streamId, int dependency, int weighting, boolean
     }
 
     /**
-     * Method that is invoked when a stream has
+     * Method that is invoked when a stream has been removed
      *
-     * @param streamId
+     * @param streamId id of the stream removed
      */
     public void streamRemoved(int streamId) {
         Http2PriorityNode node = nodesByID.get(streamId);

File: core/src/main/java/io/undertow/protocols/http2/Http2StreamSinkChannel.java
Patch:
@@ -97,7 +97,7 @@ protected void handleFlushComplete(boolean channelClosed) {
      * This method should be called before sending. It will return the amount of
      * data that can be sent, taking into account the stream and connection flow
      * control windows, and the toSend parameter.
-     * <p/>
+     * <p>
      * It will decrement the flow control windows by the amount that can be sent,
      * so this method should only be called as a frame is being queued.
      *

File: core/src/main/java/io/undertow/protocols/spdy/SpdyStreamStreamSinkChannel.java
Patch:
@@ -176,7 +176,7 @@ protected Pooled<ByteBuffer>[] createHeaderBlock(Pooled<ByteBuffer> firstHeaderB
      * This method should be called before sending. It will return the amount of
      * data that can be sent, taking into account the stream and connection flow
      * control windows, and the toSend parameter.
-     * <p/>
+     * <p>
      * It will decrement the flow control windows by the amount that can be sent,
      * so this method should only be called as a frame is being queued.
      *

File: core/src/main/java/io/undertow/security/api/SecurityContext.java
Patch:
@@ -62,7 +62,7 @@ public interface SecurityContext {
      * Attempts to log the user in using the provided credentials. This result will be stored in the current
      * {@link AuthenticatedSessionManager} (if any), so subsequent requests will automatically be authenticated
      * as this user.
-     * <p/>
+     * <p>
      * This operation may block
      *
      * @param username The username

File: core/src/main/java/io/undertow/security/handlers/SinglePortConfidentialityHandler.java
Patch:
@@ -24,7 +24,7 @@
 import java.net.URISyntaxException;
 
 /**
- * An extension to {@see AbstractConfidentialityHandler} that uses the Host header from the incoming message and specifies the
+ * An extension to {@link AbstractConfidentialityHandler} that uses the Host header from the incoming message and specifies the
  * confidential address by just switching the port.
  *
  * @author <a href="mailto:darran.lofthouse@jboss.com">Darran Lofthouse</a>

File: core/src/main/java/io/undertow/security/idm/DigestCredential.java
Patch:
@@ -19,7 +19,7 @@
 
 /**
  * An extension of {@link Credential} to provide some additional methods needed to enable verification of a request where
- * {@link DigestAuthenticationMechanism} is in use.
+ * {@link io.undertow.security.impl.DigestAuthenticationMechanism} is in use.
  *
  * @author <a href="mailto:darran.lofthouse@jboss.com">Darran Lofthouse</a>
  */

File: core/src/main/java/io/undertow/security/idm/X509CertificateCredential.java
Patch:
@@ -20,7 +20,7 @@
 import java.security.cert.X509Certificate;
 
 /**
- * A {@see Credential} implementation which wraps an X.509 certificate.
+ * A {@link Credential} implementation which wraps an X.509 certificate.
  *
  * @author <a href="mailto:darran.lofthouse@jboss.com">Darran Lofthouse</a>
  */

File: core/src/main/java/io/undertow/security/impl/CachedAuthenticatedSessionMechanism.java
Patch:
@@ -26,7 +26,7 @@
 import io.undertow.server.HttpServerExchange;
 
 /**
- * An {@link AuthenticationMechanism} which uses any cached {@link AuthenticationSession}s.
+ * An {@link AuthenticationMechanism} which uses any cached {@link AuthenticatedSession}s.
  *
  * @author <a href="mailto:darran.lofthouse@jboss.com">Darran Lofthouse</a>
  */

File: core/src/main/java/io/undertow/security/impl/ClientCertAuthenticationMechanism.java
Patch:
@@ -40,7 +40,7 @@
 
 /**
  * The Client Cert based authentication mechanism.
- * <p/>
+ * <p>
  * When authenticate is called the current request is checked to see if it a SSL request, this is further checked to identify if
  * the client has been verified at the SSL level.
  *

File: core/src/main/java/io/undertow/security/impl/GSSAPIAuthenticationMechanism.java
Patch:
@@ -54,10 +54,10 @@
 
 /**
  * {@link io.undertow.security.api.AuthenticationMechanism} for GSSAPI / SPNEGO based authentication.
- * <p/>
+ * <p>
  * GSSAPI authentication is associated with the HTTP connection, as long as a connection is being re-used allow the
  * authentication state to be re-used.
- * <p/>
+ * <p>
  * TODO - May consider an option to allow it to also be associated with the underlying session but that has it's own risks so
  * would need to come with a warning.
  *

File: core/src/main/java/io/undertow/security/impl/SimpleNonceManager.java
Patch:
@@ -146,7 +146,7 @@ private MessageDigest getDigest(final String hashAlg) {
 
     /**
      *
-     * @see io.undertow.security.api.NonceManager#nextNonce(java.lang.String)
+     * @see io.undertow.security.api.NonceManager#nextNonce(java.lang.String, io.undertow.server.HttpServerExchange)
      */
     public String nextNonce(String lastNonce, HttpServerExchange exchange) {
         if (lastNonce == null) {
@@ -230,7 +230,7 @@ private Nonce createNewNonce(NonceHolder previousNonce) {
 
     /**
      *
-     * @see io.undertow.security.api.NonceManager#validateNonce(java.lang.String, int)
+     * @see io.undertow.security.api.NonceManager#validateNonce(java.lang.String, int, io.undertow.server.HttpServerExchange)
      */
     @Override
     public boolean validateNonce(String nonce, int nonceCount, HttpServerExchange exchange) {

File: core/src/main/java/io/undertow/server/Connectors.java
Patch:
@@ -34,7 +34,7 @@
 
 /**
  * This class provides the connector part of the {@link HttpServerExchange} API.
- * <p/>
+ * <p>
  * It contains methods that logically belong on the exchange, however should only be used
  * by connector implementations.
  *

File: core/src/main/java/io/undertow/server/handlers/AccessControlListHandler.java
Patch:
@@ -96,7 +96,7 @@ public AccessControlListHandler setNext(final HttpHandler next) {
 
     /**
      * Adds an allowed user agent peer to the ACL list
-     * <p/>
+     * <p>
      * User agent may be given as regex
      *
      * @param pattern The pattern to add to the ACL
@@ -107,7 +107,7 @@ public AccessControlListHandler addAllow(final String pattern) {
 
     /**
      * Adds an denied user agent to the ACL list
-     * <p/>
+     * <p>
      * User agent may be given as regex
      *
      * @param pattern The user agent to add to the ACL

File: core/src/main/java/io/undertow/server/handlers/Cookie.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * A HTTP cookie.
  *
- * @see io.undertow.server.ExchangeCookieUtils
+ * @see io.undertow.server.Connectors
  * @author Stuart Douglas
  */
 public interface Cookie {

File: core/src/main/java/io/undertow/server/handlers/GracefulShutdownHandler.java
Patch:
@@ -31,9 +31,9 @@
 /**
  * Handler that allows for graceful server shutdown. Basically it provides a way to prevent the server from
  * accepting new requests, and wait for existing requests to complete.
- * <p/>
+ * <p>
  * The handler itself does not shut anything down.
- * <p/>
+ * <p>
  * Import: The thread safety semantics of the handler are very important. Don't touch anything unless you know
  * what you are doing.
  *

File: core/src/main/java/io/undertow/server/handlers/HttpContinueAcceptingHandler.java
Patch:
@@ -31,7 +31,7 @@
 
 /**
  * Handler that provides support for HTTP/1.1 continue responses.
- * <p/>
+ * <p>
  * If the provided predicate returns <code>true</code> then the request will be
  * accepted, otherwise it will be rejected.
  *

File: core/src/main/java/io/undertow/server/handlers/HttpUpgradeHandshake.java
Patch:
@@ -24,10 +24,10 @@
 
 /**
  * Server side upgrade handler. This handler can inspect the request and modify the response.
- * <p/>
+ * <p>
  * If the request does not meet this handlers requirements it should return false to allow
  * other upgrade handlers to inspect the request.
- * <p/>
+ * <p>
  * If the request is invalid (e.g. security information is invalid) this should thrown an IoException.
  * if this occurs no further handlers will be tried.
  *

File: core/src/main/java/io/undertow/server/handlers/ProxyPeerAddressHandler.java
Patch:
@@ -31,7 +31,7 @@
 
 /**
  * Handler that sets the peer address to the value of the X-Forwarded-For header.
- * <p/>
+ * <p>
  * This should only be used behind a proxy that always sets this header, otherwise it
  * is possible for an attacker to forge their peer address;
  *

File: core/src/main/java/io/undertow/server/handlers/RedirectHandler.java
Patch:
@@ -35,7 +35,7 @@
 
 /**
  * A redirect handler that redirects to the specified location via a 302 redirect.
- * <p/>
+ * <p>
  * The location is specified as an exchange attribute string.
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/server/handlers/SSLHeaderHandler.java
Patch:
@@ -41,16 +41,16 @@
 
 /**
  * Handler that sets SSL information on the connection based on the following headers:
- * <p/>
+ * <p>
  * <ul>
  * <li>SSL_CLIENT_CERT</li>
  * <li>SSL_CIPHER</li>
  * <li>SSL_SESSION_ID</li>
  * </ul>
- * <p/>
+ * <p>
  * If this handler is present in the chain it will always override the SSL session information,
  * even if these headers are not present.
- * <p/>
+ * <p>
  * This handler MUST only be used on servers that are behind a reverse proxy, where the reverse proxy
  * has been configured to always set these header for EVERY request (or strip existing headers with these
  * names if no SSL information is present). Otherwise it may be possible for a malicious client to spoof

File: core/src/main/java/io/undertow/server/handlers/URLDecodingHandler.java
Patch:
@@ -34,9 +34,9 @@
 
 /**
  * A handler that will decode the URL and query parameters to the specified charset.
- * <p/>
+ * <p>
  * If you are using this handler you must set the {@link io.undertow.UndertowOptions#DECODE_URL} parameter to false.
- * <p/>
+ * <p>
  * This is not as efficient as using the parsers built in UTF-8 decoder. Unless you need to decode to something other
  * than UTF-8 you should rely on the parsers decoding instead.
  *

File: core/src/main/java/io/undertow/server/handlers/accesslog/DefaultAccessLogReceiver.java
Patch:
@@ -39,7 +39,7 @@
 /**
  * Log Receiver that stores logs in a directory under the specified file name, and rotates them after
  * midnight.
- * <p/>
+ * <p>
  * Web threads do not touch the log file, but simply queue messages to be written later by a worker thread.
  * A lightweight CAS based locking mechanism is used to ensure than only 1 thread is active writing messages at
  * any given time

File: core/src/main/java/io/undertow/server/handlers/builder/HandlerParser.java
Patch:
@@ -39,16 +39,16 @@
 /**
  * Parser that can build a handler from a string representation. The underlying syntax is quite simple, and example is
  * shown below:
- * <p/>
+ * <p>
  * <code>
  * rewrite[value="/path"]
  * </code>
  * If a handler is only being passed a single parameter then the parameter name can be omitted.
  * Strings can be enclosed in optional double or single quotations marks, and quotation marks can be escaped using
  * <code>\"</code>.
- * <p/>
+ * <p>
  * Array types are represented via a comma separated list of values enclosed in curly braces.
- * <p/>
+ * <p>
  * TODO: some way of
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/server/handlers/builder/PredicatedHandlersParser.java
Patch:
@@ -33,8 +33,8 @@
 
 /**
  * Parser for the undertow-handlers.conf file.
- * <p/>
- * This file has a line by line syntax, specifying predicate -> handler. If no predicate is specified then
+ * <p>
+ * This file has a line by line syntax, specifying predicate -&gt; handler. If no predicate is specified then
  * the line is assumed to just contain a handler.
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/server/handlers/cache/LRUCache.java
Patch:
@@ -27,11 +27,11 @@
 
 /**
  * A non-blocking cache where entries are indexed by a key.
- * <p/>
+ * <p>
  * <p>To reduce contention, entry allocation and eviction execute in a sampling
  * fashion (entry hits modulo N). Eviction follows an LRU approach (oldest sampled
  * entries are removed first) when the cache is out of capacity.</p>
- * <p/>
+ * <p>
  *
  * @author Jason T. Greene
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/server/handlers/encoding/ContentEncodedResourceManager.java
Patch:
@@ -71,7 +71,7 @@ public ContentEncodedResourceManager(File encodedResourcesRoot, CachingResourceM
 
     /**
      * Gets a pre-encoded resource.
-     * <p/>
+     * <p>
      * TODO: blocking / non-blocking semantics
      *
      * @param resource

File: core/src/main/java/io/undertow/server/handlers/encoding/EncodingHandler.java
Patch:
@@ -31,12 +31,12 @@
 
 /**
  * Handler that serves as the basis for content encoding implementations.
- * <p/>
+ * <p>
  * Encoding handlers are added as delegates to this handler, with a specified server side priority.
- * <p/>
+ * <p>
  * If a request comes in with no q value then then server will pick the handler with the highest priority
  * as the encoding to use, otherwise the q value will be used to determine the correct handler.
- * <p/>
+ * <p>
  * If no handler matches then the identity encoding is assumed. If the identity encoding has been
  * specifically disallowed due to a q value of 0 then the handler will set the response code
  * 406 (Not Acceptable) and return.

File: core/src/main/java/io/undertow/server/handlers/error/FileErrorPageHandler.java
Patch:
@@ -47,7 +47,7 @@
 
 /**
  * Handler that serves up a file from disk to serve as an error page.
- * <p/>
+ * <p>
  * This handler does not server up and response codes by default, you must configure
  * the response codes it responds to.
  *

File: core/src/main/java/io/undertow/server/handlers/form/EagerFormParsingHandler.java
Patch:
@@ -26,8 +26,8 @@
 /**
  * Handler that eagerly parses form data. The request chain will pause while the data is being read,
  * and then continue when the form data is fully passed.
- * <p/>
- * <p/>
+ * <p>
+ * <p>
  * NOTE: This is not strictly compatible with servlet, as it removes the option for the user to
  * parse the request themselves, however in practice this requirement is probably rare, and
  * using this handler gives a significant performance advantage in that a thread is not blocked

File: core/src/main/java/io/undertow/server/handlers/form/FormData.java
Patch:
@@ -30,7 +30,7 @@
 
 /**
  * Representation of form data.
- * <p/>
+ * <p>
  * TODO: add representation of multipart data
  */
 public final class FormData implements Iterable<String> {

File: core/src/main/java/io/undertow/server/handlers/form/FormDataParser.java
Patch:
@@ -27,7 +27,7 @@
 /**
  * Parser for form data. This can be used by down-stream handlers to parse
  * form data.
- * <p/>
+ * <p>
  * This parser must be closed to make sure any temporary files have been cleaned up.
  *
  * @author Stuart Douglas
@@ -42,10 +42,10 @@ public interface FormDataParser extends Closeable {
     /**
      * Parse the form data asynchronously. If all the data cannot be read immediately then a read listener will be
      * registered, and the data will be parsed by the read thread.
-     * <p/>
+     * <p>
      * When this method completes the handler will be invoked, and the data
      * will be attached under {@link #FORM_DATA}.
-     * <p/>
+     * <p>
      * The method can either invoke the next handler directly, or may delegate to the IO thread
      * to perform the parsing.
      */

File: core/src/main/java/io/undertow/server/handlers/form/FormParserFactory.java
Patch:
@@ -27,7 +27,7 @@
 
 /**
  * Factory class that can create a form data parser for a given request.
- * <p/>
+ * <p>
  * It does this by iterating the available parser definitions, and returning
  * the first parser that is created.
  *

File: core/src/main/java/io/undertow/server/handlers/proxy/LoadBalancingProxyClient.java
Patch:
@@ -43,15 +43,15 @@
 /**
  * Initial implementation of a load balancing proxy client. This initial implementation is rather simplistic, and
  * will likely change.
- * <p/>
+ * <p>
  *
  * @author Stuart Douglas
  */
 public class LoadBalancingProxyClient implements ProxyClient {
 
     /**
      * The attachment key that is used to attach the proxy connection to the exchange.
-     * <p/>
+     * <p>
      * This cannot be static as otherwise a connection from a different client could be re-used.
      */
     private final AttachmentKey<ExclusiveConnectionHolder> exclusiveConnectionKey = AttachmentKey.create(ExclusiveConnectionHolder.class);

File: core/src/main/java/io/undertow/server/handlers/proxy/ProxyHandler.java
Patch:
@@ -87,7 +87,7 @@
 
 /**
  * An HTTP handler which proxies content to a remote server.
- * <p/>
+ * <p>
  * This handler acts like a filter. The {@link ProxyClient} has a chance to decide if it
  * knows how to proxy the request. If it does then it will provide a connection that can
  * used to connect to the remote server, otherwise the next handler will be invoked and the
@@ -200,7 +200,7 @@ public ProxyHandler addRequestHeader(final HttpString header, final String value
     /**
      * Adds a request header to the outgoing request. If the header resolves to null or an empty string
      * it will not be added, however any existing header with the same name will be removed.
-     * <p/>
+     * <p>
      * The attribute value will be parsed, and the resulting exchange attribute will be used to create the actual header
      * value.
      *

File: core/src/main/java/io/undertow/server/handlers/resource/RangeAwareResource.java
Patch:
@@ -41,7 +41,7 @@ public interface RangeAwareResource extends Resource {
     /**
      * It is possible that some resources managers may only support range requests on a subset of their resources,
      *
-     * @return <core>true</core> if this resource supports range requests
+     * @return <code>true</code> if this resource supports range requests
      */
     boolean isRangeSupported();
 }

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpServerConnection.java
Patch:
@@ -37,7 +37,7 @@
 
 /**
  * A server-side AJP connection.
- * <p/>
+ * <p>
  *
  * @author <a href="mailto:david.lloyd@redhat.com">David M. Lloyd</a>
  */

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedStreamSinkChannel.java
Patch:
@@ -46,9 +46,9 @@
 
 /**
  * Framed Stream Sink Channel.
- * <p/>
+ * <p>
  * Thread safety notes:
- * <p/>
+ * <p>
  * The general contract is that this channel is only to be used by a single thread at a time. The only exception to this is
  * during flush. A flush will only happen when {@link #readyForFlush} is set, and while this bit is set the buffer
  * must not be modified.

File: core/src/main/java/io/undertow/server/protocol/http/HttpAttachments.java
Patch:
@@ -47,7 +47,7 @@ public class HttpAttachments {
      * If the value {@code true} is attached to the exchange under this key then Undertow will assume that the underlying application
      * has already taken care of chunking, and will not attempt to add its own chunk markers.
      *
-     * This will only take effect if the application has explicitly set the {@literal Transfer-Encoding: chunked) header.
+     * This will only take effect if the application has explicitly set the {@literal Transfer-Encoding: chunked} header.
      *
      */
     public static final AttachmentKey<Boolean> PRE_CHUNKED_RESPONSE = AttachmentKey.create(Boolean.class);

File: core/src/main/java/io/undertow/server/protocol/http/HttpContinue.java
Patch:
@@ -38,7 +38,7 @@
 
 /**
  * Class that provides support for dealing with HTTP 100 (Continue) responses.
- * <p/>
+ * <p>
  * Note that if a client is pipelining some requests and sending continue for others this
  * could cause problems if the pipelining buffer is enabled.
  *

File: core/src/main/java/io/undertow/server/protocol/http/HttpRequestParser.java
Patch:
@@ -93,10 +93,10 @@
 /**
  * The basic HTTP parser. The actual parser is a sub class of this class that is generated as part of
  * the build process by the {@link io.undertow.annotationprocessor.AbstractParserGenerator} annotation processor.
- * <p/>
+ * <p>
  * The actual processor is a state machine, that means that for common header, method, protocol values
  * it will return an interned string, rather than creating a new string for each one.
- * <p/>
+ * <p>
  *
  * @author Stuart Douglas
  */

File: core/src/main/java/io/undertow/server/protocol/http/HttpServerConnection.java
Patch:
@@ -47,7 +47,7 @@
 
 /**
  * A server-side HTTP connection.
- * <p/>
+ * <p>
  * Note that the lifecycle of the server connection is tied to the underlying TCP connection. Even if the channel
  * is upgraded the connection is not considered closed until the upgraded channel is closed.
  *

File: core/src/main/java/io/undertow/server/protocol/http2/Http2ReceiveListener.java
Patch:
@@ -47,7 +47,7 @@
 
 /**
  * The recieve listener for a Http2 connection.
- * <p/>
+ * <p>
  * A new instance is created per connection.
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/server/protocol/spdy/SpdyReceiveListener.java
Patch:
@@ -42,7 +42,7 @@
 
 /**
  * The recieve listener for a SPDY connection.
- * <p/>
+ * <p>
  * A new instance is created per connection.
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/server/session/InMemorySessionManager.java
Patch:
@@ -41,7 +41,7 @@
 
 /**
  * The default in memory session manager. This basically just stores sessions in an in memory hash map.
- * <p/>
+ * <p>
  *
  * @author Stuart Douglas
  */

File: core/src/main/java/io/undertow/server/session/SessionAttachmentHandler.java
Patch:
@@ -27,9 +27,9 @@
 
 /**
  * Handler that attaches the session to the request.
- * <p/>
+ * <p>
  * This handler is also the place where session cookie configuration properties are configured.
- * <p/>
+ * <p>
  * note: this approach is not used by Servlet, which has its own session handlers
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/server/session/SessionConfig.java
Patch:
@@ -26,7 +26,7 @@
  * attachment such as setting a cookie, as well as actually attaching the session to the exchange for use by later
  * handlers.
  *
- * <p/>
+ * <p>
  * Generally this will just set a cookie.
  *
  * @author Stuart Douglas
@@ -38,9 +38,9 @@ public interface SessionConfig {
     /**
      * Attaches the session to the exchange. The method should attach the exchange under an attachment key,
      * and should also modify the exchange to allow the session to be re-attached on the next request.
-     * <p/>
+     * <p>
      * Generally this will involve setting a cookie
-     * <p/>
+     * <p>
      * Once a session has been attached it must be possible to retrieve it via
      * {@link #findSessionId(io.undertow.server.HttpServerExchange)}
      *

File: core/src/main/java/io/undertow/server/session/SslSessionConfig.java
Patch:
@@ -26,7 +26,7 @@
 
 /**
  * Session config that stores the session ID in the current SSL session.
- * <p/>
+ * <p>
  * It allows for a fallback to be provided for non-ssl connections
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/util/FlexBase64.java
Patch:
@@ -364,7 +364,7 @@ public static DecoderOutputStream createDecoderOutputStream(OutputStream output,
     /**
      * Creates an OutputStream wrapper which decodes base64 content before writing to the passed OutputStream target.
      *
-     * <p></p>All bytes written will be queued to an 8192 byte buffer. This stream, therefore, does
+     * <p>All bytes written will be queued to an 8192 byte buffer. This stream, therefore, does
      * not require BufferedOutputStream, which would lead to double buffering.</p>
      *
      * <p>This stream is not thread-safe, and should not be shared between threads, without establishing a

File: core/src/main/java/io/undertow/util/Headers.java
Patch:
@@ -238,7 +238,7 @@ private Headers() {
 
     /**
      * Extracts a token from a header that has a given key. For instance if the header is
-     * <p/>
+     * <p>
      * content-type=multipart/form-data boundary=myboundary
      * and the key is boundary the myboundary will be returned.
      *
@@ -264,7 +264,7 @@ public static String extractTokenFromHeader(final String header, final String ke
 
     /**
      * Extracts a quoted value from a header that has a given key. For instance if the header is
-     * <p/>
+     * <p>
      * content-disposition=form-data; name="my field"
      * and the key is name then "my field" will be returned without the quotes.
      *

File: core/src/main/java/io/undertow/util/HexConverter.java
Patch:
@@ -55,7 +55,7 @@ public static String convertToHexString(byte[] toBeConverted) {
     /**
      * Take the supplied byte array and convert it to to a byte array of the encoded
      * hex values.
-     * <p/>
+     * <p>
      * Each byte on the incoming array will be converted to two bytes on the return
      * array.
      *
@@ -79,7 +79,7 @@ public static byte[] convertToHexBytes(byte[] toBeConverted) {
 
     /**
      * Take the incoming character of hex encoded data and convert to the raw byte values.
-     * <p/>
+     * <p>
      * The characters in the incoming array are processed in pairs with two chars of a pair
      * being converted to a single byte.
      *
@@ -112,7 +112,7 @@ private static byte toByte(final char[] toConvert, final int pos) {
 
     /**
      * Take the incoming String of hex encoded data and convert to the raw byte values.
-     * <p/>
+     * <p>
      * The characters in the incoming String are processed in pairs with two chars of a pair
      * being converted to a single byte.
      *

File: core/src/main/java/io/undertow/util/PathTemplate.java
Patch:
@@ -30,10 +30,10 @@
 
 /**
  * Represents a parsed web socket path template.
- * <p/>
+ * <p>
  * This class can be compared to other path templates, with templates that are considered
  * lower have a higher priority, and should be checked first.
- * <p/>
+ * <p>
  * This comparison can also be used to check for semantically equal paths, if
  * a.compareTo(b) == 0 then the two paths are equivalent, which will generally
  * result in a deployment exception.
@@ -168,7 +168,7 @@ public static PathTemplate create(final String inputPath) {
     /**
      * Check if the given uri matches the template. If so then it will return true and
      * place the value of any path parameters into the given map.
-     * <p/>
+     * <p>
      * Note the map may be modified even if the match in unsuccessful, however in this case
      * it will be emptied before the method returns
      *

File: core/src/main/java/io/undertow/util/PathTemplateMatcher.java
Patch:
@@ -32,7 +32,7 @@
 /**
  * Utility class that provides fast path matching of path templates. Templates are stored in a map based on the stem of the template,
  * and matches longest stem first.
- * <p/>
+ * <p>
  * TODO: we can probably do this faster using a trie type structure, but I think the current impl should perform ok most of the time
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/util/StringReadChannelListener.java
Patch:
@@ -30,7 +30,7 @@
 
 /**
  * Simple utility class for reading a string
- * <p/>
+ * <p>
  * todo: handle unicode properly
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/util/SubstringMap.java
Patch:
@@ -26,10 +26,10 @@
 /**
  * A string keyed map that can be accessed as a substring, eliminating the need to allocate a new string
  * to do a key comparison against.
- * <p/>
+ * <p>
  * This class uses linear probing and is thread safe due to copy on write semantics. As such it is not recomended
  * for data that changes frequently.
- * <p/>
+ * <p>
  * This class does not actually implement the map interface to avoid implementing unnecessary operations.
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/websockets/core/StreamSinkFrameChannel.java
Patch:
@@ -42,7 +42,7 @@ public int getRsv() {
 
     /**
      * Set the RSV which is used for extensions.
-     * <p/>
+     * <p>
      * This can only be set before any write or transfer operations where passed
      * to the wrapped {@link org.xnio.channels.StreamSinkChannel}, after that an {@link IllegalStateException} will be thrown.
      *

File: core/src/main/java/io/undertow/websockets/core/WebSocketVersion.java
Patch:
@@ -58,7 +58,7 @@ public enum WebSocketVersion {
     V08,
 
     /**
-     * <a href="http://tools.ietf.org/html/rfc6455 ">RFC 6455</a>. This was originally <a href=
+     * <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>. This was originally <a href=
      * "http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17" >draft-ietf-hybi-thewebsocketprotocol-
      * 17</a>
      */

File: core/src/main/java/io/undertow/websockets/core/protocol/version07/UTF8Checker.java
Patch:
@@ -27,7 +27,7 @@
 
 /**
  * An utility class which can be used to check if a sequence of bytes or ByteBuffers contain non UTF-8 data.
- * <p/>
+ * <p>
  * Please use a new instance per stream.
  *
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>

File: core/src/main/java/io/undertow/websockets/spi/WebSocketHttpExchange.java
Patch:
@@ -34,14 +34,14 @@
 
 /**
  * An abstraction for a Http exchange. Undertow uses 3 different types of exchanges:
- * <p/>
+ * <p>
  * - async
  * - blocking
  * - servlet
- * <p/>
+ * <p>
  * This class provides a way to operate on the underling exchange while providing the
  * correct semantics regardless of the underlying exchange type.
- * <p/>
+ * <p>
  * The main use case for this is web sockets. Web sockets should be able to perform
  * a handshake regardless of the nature of the underlying request, while still respecting
  * servlet filters, security etc.

File: servlet/src/main/java/io/undertow/servlet/spec/ServletPrintWriter.java
Patch:
@@ -32,7 +32,7 @@
 /**
  * Real servlet print writer functionality, that is not limited by extending
  * {@link java.io.PrintWriter}
- * <p/>
+ * <p>
  *
  * @author Stuart Douglas
  */

File: servlet/src/main/java/io/undertow/servlet/Servlets.java
Patch:
@@ -105,18 +105,18 @@ public static ServletInfo servlet(final String name, final Class<? extends Servl
 
 
     /**
-     * Creates a new servlet description with the given name and class
+     * Creates a new filter description with the given name and class
      *
      * @param name        The filter name
      * @param filterClass The filter class
-     * @return A new servlet description
+     * @return A new filter description
      */
     public static FilterInfo filter(final String name, final Class<? extends Filter> filterClass) {
         return new FilterInfo(name, filterClass);
     }
 
     /**
-     * Creates a new servlet description with the given name and class
+     * Creates a new filter description with the given name and class
      *
      * @param name        The filter name
      * @param filterClass The filter class

File: core/src/main/java/io/undertow/util/PathMatcher.java
Patch:
@@ -141,7 +141,7 @@ public T getPrefixPath(final String path) {
         final String normalizedPath = URLUtils.normalizeSlashes(path);
 
         // enable the prefix path mechanism to return the default handler
-        SubstringMap.SubstringMatch<T> match = paths.getExact(normalizedPath);
+        SubstringMap.SubstringMatch<T> match = paths.get(normalizedPath);
         if (PathMatcher.STRING_PATH_SEPARATOR.equals(normalizedPath) && match == null) {
             return this.defaultHandler;
         }

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletPathMatchesData.java
Patch:
@@ -116,7 +116,7 @@ public void addExactMatch(final String exactMatch, final ServletChain match) {
         }
 
         public void addPrefixMatch(final String prefix, final ServletChain match, final boolean requireWelcomeFileMatch) {
-            SubstringMap.SubstringMatch<PathMatch> mt = prefixMatches.getExact(prefix);
+            SubstringMap.SubstringMatch<PathMatch> mt = prefixMatches.get(prefix);
             PathMatch m;
             if (mt == null) {
                 prefixMatches.put(prefix, m = new PathMatch(match));
@@ -128,7 +128,7 @@ public void addPrefixMatch(final String prefix, final ServletChain match, final
         }
 
         public void addExtensionMatch(final String prefix, final String extension, final ServletChain match) {
-            SubstringMap.SubstringMatch<PathMatch> mt = prefixMatches.getExact(prefix);
+            SubstringMap.SubstringMatch<PathMatch> mt = prefixMatches.get(prefix);
             PathMatch m;
             if (mt == null) {
                 prefixMatches.put(prefix, m = new PathMatch(null));

File: core/src/main/java/io/undertow/util/PathMatcher.java
Patch:
@@ -74,7 +74,7 @@ public PathMatch<T> match(String path){
         for (int i = 0; i < lengths.length; ++i) {
             int pathLength = lengths[i];
             if (pathLength == length) {
-                SubstringMap.SubstringMatch<T> next = paths.get(path);
+                SubstringMap.SubstringMatch<T> next = paths.get(path, length);
                 if (next != null) {
                     return new PathMatch<>(path, "", next.getValue());
                 }
@@ -141,7 +141,7 @@ public T getPrefixPath(final String path) {
         final String normalizedPath = URLUtils.normalizeSlashes(path);
 
         // enable the prefix path mechanism to return the default handler
-        SubstringMap.SubstringMatch<T> match = paths.get(normalizedPath);
+        SubstringMap.SubstringMatch<T> match = paths.getExact(normalizedPath);
         if (PathMatcher.STRING_PATH_SEPARATOR.equals(normalizedPath) && match == null) {
             return this.defaultHandler;
         }

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletPathMatchesData.java
Patch:
@@ -62,7 +62,7 @@ public ServletPathMatch getServletHandlerByPath(final String path) {
         if (exact != null) {
             return exact;
         }
-        SubstringMap.SubstringMatch<PathMatch> match = prefixMatches.get(path);
+        SubstringMap.SubstringMatch<PathMatch> match = prefixMatches.get(path, path.length());
         if (match != null) {
             return handleMatch(path, match.getValue(), path.lastIndexOf('.'));
         }
@@ -116,7 +116,7 @@ public void addExactMatch(final String exactMatch, final ServletChain match) {
         }
 
         public void addPrefixMatch(final String prefix, final ServletChain match, final boolean requireWelcomeFileMatch) {
-            SubstringMap.SubstringMatch<PathMatch> mt = prefixMatches.get(prefix);
+            SubstringMap.SubstringMatch<PathMatch> mt = prefixMatches.getExact(prefix);
             PathMatch m;
             if (mt == null) {
                 prefixMatches.put(prefix, m = new PathMatch(match));
@@ -128,7 +128,7 @@ public void addPrefixMatch(final String prefix, final ServletChain match, final
         }
 
         public void addExtensionMatch(final String prefix, final String extension, final ServletChain match) {
-            SubstringMap.SubstringMatch<PathMatch> mt = prefixMatches.get(prefix);
+            SubstringMap.SubstringMatch<PathMatch> mt = prefixMatches.getExact(prefix);
             PathMatch m;
             if (mt == null) {
                 prefixMatches.put(prefix, m = new PathMatch(null));

File: core/src/main/java/io/undertow/util/SubstringMap.java
Patch:
@@ -121,6 +121,7 @@ public synchronized V remove(String key) {
                 size--;
             }
         }
+        this.table = newTable;
         if(value == null) {
             return null;
         }

File: core/src/main/java/io/undertow/client/http2/Http2ClientProvider.java
Patch:
@@ -65,7 +65,7 @@ public class Http2ClientProvider implements ClientProvider {
     private static final String HTTP2 = "h2";
     private static final String HTTP_1_1 = "http/1.1";
 
-    private static final List<String> PROTOCOLS = Collections.unmodifiableList(Arrays.asList(new String[]{HTTP2, HTTP_1_1}));
+    private static final List<String> PROTOCOLS = Collections.unmodifiableList(Arrays.asList(HTTP2, HTTP_1_1));
 
     private static final Method ALPN_PUT_METHOD;
 

File: core/src/main/java/io/undertow/client/spdy/SpdyClientProvider.java
Patch:
@@ -68,7 +68,7 @@ public class SpdyClientProvider implements ClientProvider {
     private static final String SPDY_3_1 = "spdy/3.1";
     private static final String HTTP_1_1 = "http/1.1";
 
-    private static final List<String> PROTOCOLS = Collections.unmodifiableList(Arrays.asList(new String[]{SPDY_3_1, HTTP_1_1}));
+    private static final List<String> PROTOCOLS = Collections.unmodifiableList(Arrays.asList(SPDY_3_1, HTTP_1_1));
 
     private static final Method ALPN_PUT_METHOD;
 

File: core/src/main/java/io/undertow/protocols/ajp/AjpClientChannel.java
Patch:
@@ -95,7 +95,7 @@ protected FrameHeaderData parseFrame(ByteBuffer data) throws IOException {
         ajpParser.parse(data);
         if (ajpParser.isComplete()) {
             try {
-                AjpResponseParser parser = (AjpResponseParser) ajpParser;
+                AjpResponseParser parser = ajpParser;
                 if (parser.prefix == FRAME_TYPE_SEND_HEADERS) {
                     return new SendHeadersResponse(parser.statusCode, parser.reasonPhrase, parser.headers);
                 } else if (parser.prefix == FRAME_TYPE_REQUEST_BODY_CHUNK) {

File: core/src/main/java/io/undertow/protocols/http2/HpackEncoder.java
Patch:
@@ -247,7 +247,7 @@ private void addToDynamicTable(HttpString headerName, String val) {
         DynamicTableEntry d = new DynamicTableEntry(headerName, val, -pos);
         List<TableEntry> existing = dynamicTable.get(headerName);
         if (existing == null) {
-            dynamicTable.put(headerName, existing = new ArrayList<TableEntry>(1));
+            dynamicTable.put(headerName, existing = new ArrayList<>(1));
         }
         existing.add(d);
         evictionQueue.add(d);

File: core/src/main/java/io/undertow/protocols/http2/Http2Channel.java
Patch:
@@ -762,7 +762,7 @@ public <T> void addToAttachmentList(AttachmentKey<AttachmentList<T>> key, T valu
         synchronized (attachments) {
             final List<T> list = key.cast(attachments.get(key));
             if (list == null) {
-                final AttachmentList<T> newList = new AttachmentList<T>((Class<T>) Object.class);
+                final AttachmentList<T> newList = new AttachmentList<>((Class<T>) Object.class);
                 attachments.put(key, newList);
                 newList.add(value);
             } else {

File: core/src/main/java/io/undertow/protocols/http2/Http2DataStreamSinkChannel.java
Patch:
@@ -161,7 +161,7 @@ protected SendFrameHeader createFrameHeaderImpl() {
                     newBuf.put(allHeaderBuffers[i].getResource());
                 }
                 newBuf.flip();
-                return new SendFrameHeader(remainingInBuffer, new ImmediatePooled<ByteBuffer>(newBuf));
+                return new SendFrameHeader(remainingInBuffer, new ImmediatePooled<>(newBuf));
             } finally {
                 //the allocate can oome
                 for (int i = 0; i < allHeaderBuffers.length; ++i) {

File: core/src/main/java/io/undertow/protocols/spdy/SpdyChannel.java
Patch:
@@ -484,7 +484,7 @@ public <T> void addToAttachmentList(AttachmentKey<AttachmentList<T>> key, T valu
         synchronized (attachments) {
             final List<T> list = key.cast(attachments.get(key));
             if (list == null) {
-                final AttachmentList<T> newList = new AttachmentList<T>((Class<T>) Object.class);
+                final AttachmentList<T> newList = new AttachmentList<>((Class<T>) Object.class);
                 attachments.put(key, newList);
                 newList.add(value);
             } else {

File: core/src/main/java/io/undertow/protocols/spdy/SpdySynReplyStreamSinkChannel.java
Patch:
@@ -117,7 +117,7 @@ protected SendFrameHeader createFrameHeaderImpl() {
                     newBuf.put(allHeaderBuffers[i].getResource());
                 }
                 newBuf.flip();
-                return new SendFrameHeader(remainingInBuffer, new ImmediatePooled<ByteBuffer>(newBuf));
+                return new SendFrameHeader(remainingInBuffer, new ImmediatePooled<>(newBuf));
             } finally {
                 //the allocate can oome
                 for (int i = 0; i < allHeaderBuffers.length; ++i) {

File: core/src/main/java/io/undertow/protocols/spdy/SpdySynStreamStreamSinkChannel.java
Patch:
@@ -111,7 +111,7 @@ protected SendFrameHeader createFrameHeaderImpl() {
                     newBuf.put(allHeaderBuffers[i].getResource());
                 }
                 newBuf.flip();
-                return new SendFrameHeader(remainingInBuffer, new ImmediatePooled<ByteBuffer>(newBuf));
+                return new SendFrameHeader(remainingInBuffer, new ImmediatePooled<>(newBuf));
             } finally {
                 //the allocate can oome
                 for (int i = 0; i < allHeaderBuffers.length; ++i) {

File: core/src/main/java/io/undertow/protocols/ssl/UndertowSslConnection.java
Patch:
@@ -43,7 +43,7 @@ class UndertowSslConnection extends SslConnection {
 
     private final StreamConnection delegate;
     private final SslConduit sslConduit;
-    private final ChannelListener.SimpleSetter<SslConnection> handshakeSetter = new ChannelListener.SimpleSetter<SslConnection>();
+    private final ChannelListener.SimpleSetter<SslConnection> handshakeSetter = new ChannelListener.SimpleSetter<>();
     private final SSLEngine engine;
 
     /**

File: core/src/main/java/io/undertow/protocols/ssl/UndertowXnioSsl.java
Patch:
@@ -141,7 +141,7 @@ public static SSLEngine getSslEngine(SslConnection connection) {
 
     @SuppressWarnings("deprecation")
     public IoFuture<ConnectedSslStreamChannel> connectSsl(final XnioWorker worker, final InetSocketAddress bindAddress, final InetSocketAddress destination, final ChannelListener<? super ConnectedSslStreamChannel> openListener, final ChannelListener<? super BoundChannel> bindListener, final OptionMap optionMap) {
-        final FutureResult<ConnectedSslStreamChannel> futureResult = new FutureResult<ConnectedSslStreamChannel>(IoUtils.directExecutor());
+        final FutureResult<ConnectedSslStreamChannel> futureResult = new FutureResult<>(IoUtils.directExecutor());
         final IoFuture<SslConnection> futureSslConnection = openSslConnection(worker, bindAddress, destination, new ChannelListener<SslConnection>() {
             public void handleEvent(final SslConnection sslConnection) {
                 final ConnectedSslStreamChannel assembledChannel = new AssembledConnectedSslStreamChannel(sslConnection, sslConnection.getSourceChannel(), sslConnection.getSinkChannel());
@@ -170,13 +170,13 @@ public void handleCancelled(final IoFuture<SslConnection> result) {
     }
 
     public IoFuture<SslConnection> openSslConnection(final XnioWorker worker, final InetSocketAddress bindAddress, final InetSocketAddress destination, final ChannelListener<? super SslConnection> openListener, final ChannelListener<? super BoundChannel> bindListener, final OptionMap optionMap) {
-        final FutureResult<SslConnection> futureResult = new FutureResult<SslConnection>(worker);
+        final FutureResult<SslConnection> futureResult = new FutureResult<>(worker);
         final IoFuture<StreamConnection> connection = worker.openStreamConnection(bindAddress, destination, new StreamConnectionChannelListener(optionMap, destination, futureResult, openListener), bindListener, optionMap);
         return setupSslConnection(futureResult, connection);
     }
     @Override
     public IoFuture<SslConnection> openSslConnection(final XnioIoThread ioThread, final InetSocketAddress bindAddress, final InetSocketAddress destination, final ChannelListener<? super SslConnection> openListener, final ChannelListener<? super BoundChannel> bindListener, final OptionMap optionMap) {
-        final FutureResult<SslConnection> futureResult = new FutureResult<SslConnection>(ioThread);
+        final FutureResult<SslConnection> futureResult = new FutureResult<>(ioThread);
         final IoFuture<StreamConnection> connection = ioThread.openStreamConnection(bindAddress, destination, new StreamConnectionChannelListener(optionMap, destination, futureResult, openListener), bindListener, optionMap);
         return setupSslConnection(futureResult, connection);
     }

File: core/src/main/java/io/undertow/server/handlers/ConnectHandler.java
Patch:
@@ -89,8 +89,8 @@ public void handleEvent(final StreamConnection clientChannel) {
                                 @Override
                                 public void handleUpgrade(StreamConnection streamConnection, HttpServerExchange exchange) {
                                     final ClosingExceptionHandler handler = new ClosingExceptionHandler(streamConnection, clientChannel);
-                                    Transfer.initiateTransfer(clientChannel.getSourceChannel(), streamConnection.getSinkChannel(), ChannelListeners.closingChannelListener(), ChannelListeners.<StreamSinkChannel>writeShutdownChannelListener(ChannelListeners.<StreamSinkChannel>flushingChannelListener(ChannelListeners.closingChannelListener(), ChannelListeners.closingChannelExceptionHandler()), ChannelListeners.closingChannelExceptionHandler()), handler, handler, exchange.getConnection().getBufferPool());
-                                    Transfer.initiateTransfer(streamConnection.getSourceChannel(), clientChannel.getSinkChannel(), ChannelListeners.closingChannelListener(), ChannelListeners.<StreamSinkChannel>writeShutdownChannelListener(ChannelListeners.<StreamSinkChannel>flushingChannelListener(ChannelListeners.closingChannelListener(), ChannelListeners.closingChannelExceptionHandler()), ChannelListeners.closingChannelExceptionHandler()), handler, handler, exchange.getConnection().getBufferPool());
+                                    Transfer.initiateTransfer(clientChannel.getSourceChannel(), streamConnection.getSinkChannel(), ChannelListeners.closingChannelListener(), ChannelListeners.writeShutdownChannelListener(ChannelListeners.<StreamSinkChannel>flushingChannelListener(ChannelListeners.closingChannelListener(), ChannelListeners.closingChannelExceptionHandler()), ChannelListeners.closingChannelExceptionHandler()), handler, handler, exchange.getConnection().getBufferPool());
+                                    Transfer.initiateTransfer(streamConnection.getSourceChannel(), clientChannel.getSinkChannel(), ChannelListeners.closingChannelListener(), ChannelListeners.writeShutdownChannelListener(ChannelListeners.<StreamSinkChannel>flushingChannelListener(ChannelListeners.closingChannelListener(), ChannelListeners.closingChannelExceptionHandler()), ChannelListeners.closingChannelExceptionHandler()), handler, handler, exchange.getConnection().getBufferPool());
                                 }
                             });
                             exchange.setResponseCode(200);

File: core/src/main/java/io/undertow/server/handlers/PathTemplateHandler.java
Patch:
@@ -21,7 +21,6 @@
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.util.AttachmentKey;
-import io.undertow.util.PathTemplateMatch;
 import io.undertow.util.PathTemplateMatcher;
 
 import java.util.Map;

File: core/src/main/java/io/undertow/server/handlers/SSLHeaderHandler.java
Patch:
@@ -99,9 +99,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                 exchange.setRequestScheme(HTTPS);
                 exchange.getConnection().setSslSessionInfo(info);
                 exchange.addExchangeCompleteListener(CLEAR_SSL_LISTENER);
-            } catch (java.security.cert.CertificateException e) {
-                UndertowLogger.REQUEST_LOGGER.debugf(e, "Could not create certificate from header %s", clientCert);
-            } catch (CertificateException e) {
+            } catch (java.security.cert.CertificateException | CertificateException e) {
                 UndertowLogger.REQUEST_LOGGER.debugf(e, "Could not create certificate from header %s", clientCert);
             }
         }

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/MCMPHandler.java
Patch:
@@ -736,9 +736,7 @@ RequestData parseFormData(final HttpServerExchange exchange) throws IOException
         final FormDataParser parser = parserFactory.createParser(exchange);
         final FormData formData = parser.parseBlocking();
         final RequestData data = new RequestData();
-        final Iterator<String> i = formData.iterator();
-        while (i.hasNext()) {
-            final String name = i.next();
+        for (String name : formData) {
             final HttpString key = new HttpString(name);
             data.add(key, formData.get(name));
         }

File: core/src/main/java/io/undertow/server/handlers/resource/FileResourceManager.java
Patch:
@@ -67,7 +67,7 @@ public class FileResourceManager implements ResourceManager {
      * Used if followLinks == true. Set of paths valid to follow symbolic links. If this is empty and followLinks
      * it true then all links will be followed
      */
-    private final TreeSet<String> safePaths = new TreeSet<String>();
+    private final TreeSet<String> safePaths = new TreeSet<>();
 
     public FileResourceManager(final File base, long transferMinSize) {
         this(base, transferMinSize, true, false, null);

File: core/src/main/java/io/undertow/util/SubstringMap.java
Patch:
@@ -99,7 +99,7 @@ public synchronized void put(String key, V value) {
             newTable = new Object[table.length];
             System.arraycopy(table, 0, newTable, 0, table.length);
         }
-        doPut(newTable, key, new SubstringMap.SubstringMatch<V>(key, value));
+        doPut(newTable, key, new SubstringMap.SubstringMatch<>(key, value));
         this.table = newTable;
         size++;
     }

File: core/src/main/java/io/undertow/websockets/core/BufferedBinaryMessage.java
Patch:
@@ -177,7 +177,7 @@ public Pooled<ByteBuffer[]> getData() {
             current.getResource().flip();
             this.current = null;
             final ByteBuffer[] data = new ByteBuffer[]{current.getResource()};
-            return new PooledByteBufferArray(Collections.<Pooled<ByteBuffer>>singletonList(current), data);
+            return new PooledByteBufferArray(Collections.singletonList(current), data);
         }
         current.getResource().flip();
         data.add(current);

File: core/src/main/java/io/undertow/websockets/core/StreamSourceFrameChannel.java
Patch:
@@ -109,7 +109,7 @@ int getWebSocketFrameCount() {
 
     @Override
     protected WebSocketChannel getFramedChannel() {
-        return (WebSocketChannel) super.getFramedChannel();
+        return super.getFramedChannel();
     }
 
     public WebSocketChannel getWebSocketChannel() {

File: core/src/main/java/io/undertow/server/handlers/builder/PredicatedHandlersParser.java
Patch:
@@ -22,7 +22,7 @@
 import io.undertow.predicate.PredicateParser;
 import io.undertow.predicate.Predicates;
 import io.undertow.server.HandlerWrapper;
-import io.undertow.util.ChaninedHandlerWrapper;
+import io.undertow.util.ChainedHandlerWrapper;
 import io.undertow.util.FileUtils;
 
 import java.io.File;
@@ -71,7 +71,7 @@ public static List<PredicatedHandler> parse(final String contents, final ClassLo
                     for(int i = 0; i < handlers.length; ++i) {
                         handlers[i] = HandlerParser.parse(parts[i + 1], classLoader);
                     }
-                    handler = new ChaninedHandlerWrapper(Arrays.asList(handlers));
+                    handler = new ChainedHandlerWrapper(Arrays.asList(handlers));
                 }
                 wrappers.add(new PredicatedHandler(predicate, handler));
             }

File: core/src/main/java/io/undertow/util/ChainedHandlerWrapper.java
Patch:
@@ -28,11 +28,11 @@
  *
  * @author Stuart Douglas
  */
-public class ChaninedHandlerWrapper implements HandlerWrapper {
+public class ChainedHandlerWrapper implements HandlerWrapper {
 
     private final List<HandlerWrapper> handlers;
 
-    public ChaninedHandlerWrapper(List<HandlerWrapper> handlers) {
+    public ChainedHandlerWrapper(List<HandlerWrapper> handlers) {
         this.handlers = handlers;
     }
 

File: core/src/main/java/io/undertow/server/handlers/builder/PredicatedHandlersParser.java
Patch:
@@ -22,7 +22,7 @@
 import io.undertow.predicate.PredicateParser;
 import io.undertow.predicate.Predicates;
 import io.undertow.server.HandlerWrapper;
-import io.undertow.util.ChaninedHandlerWrapper;
+import io.undertow.util.ChainedHandlerWrapper;
 import io.undertow.util.FileUtils;
 
 import java.io.File;
@@ -71,7 +71,7 @@ public static List<PredicatedHandler> parse(final String contents, final ClassLo
                     for(int i = 0; i < handlers.length; ++i) {
                         handlers[i] = HandlerParser.parse(parts[i + 1], classLoader);
                     }
-                    handler = new ChaninedHandlerWrapper(Arrays.asList(handlers));
+                    handler = new ChainedHandlerWrapper(Arrays.asList(handlers));
                 }
                 wrappers.add(new PredicatedHandler(predicate, handler));
             }

File: core/src/main/java/io/undertow/util/ChainedHandlerWrapper.java
Patch:
@@ -28,11 +28,11 @@
  *
  * @author Stuart Douglas
  */
-public class ChaninedHandlerWrapper implements HandlerWrapper {
+public class ChainedHandlerWrapper implements HandlerWrapper {
 
     private final List<HandlerWrapper> handlers;
 
-    public ChaninedHandlerWrapper(List<HandlerWrapper> handlers) {
+    public ChainedHandlerWrapper(List<HandlerWrapper> handlers) {
         this.handlers = handlers;
     }
 

File: core/src/test/java/io/undertow/server/handlers/session/InMemorySessionTestCase.java
Patch:
@@ -112,7 +112,7 @@ public void inMemoryMaxSessionsTest() throws IOException {
 
         try {
             final SessionCookieConfig sessionConfig = new SessionCookieConfig();
-            final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager("", 1), sessionConfig);
+            final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager("", 1, true), sessionConfig);
             handler.setNext(new HttpHandler() {
                 @Override
                 public void handleRequest(final HttpServerExchange exchange) throws Exception {

File: servlet/src/main/java/io/undertow/servlet/core/ErrorPages.java
Patch:
@@ -18,6 +18,8 @@
 
 package io.undertow.servlet.core;
 
+import io.undertow.util.StatusCodes;
+
 import java.util.Map;
 
 import javax.servlet.ServletException;
@@ -65,7 +67,7 @@ public String getErrorLocation(final Throwable exception) {
             }
         }
         if (location == null) {
-            location = defaultErrorPage;
+            location = getErrorLocation(StatusCodes.INTERNAL_SERVER_ERROR);
         }
         return location;
     }

File: servlet/src/test/java/io/undertow/servlet/test/errorpage/ErrorPageTestCase.java
Patch:
@@ -66,7 +66,6 @@ public static void setup() throws IOException, ServletException {
 
         builder1.addErrorPage(new ErrorPage("/defaultErrorPage"));
         builder1.addErrorPage(new ErrorPage("/404", StatusCodes.NOT_FOUND));
-        builder1.addErrorPage(new ErrorPage("/500", StatusCodes.INTERNAL_SERVER_ERROR));
         builder1.addErrorPage(new ErrorPage("/parentException", ParentException.class));
         builder1.addErrorPage(new ErrorPage("/childException", ChildException.class));
         builder1.addErrorPage(new ErrorPage("/runtimeException", RuntimeException.class));
@@ -128,6 +127,7 @@ public static void setup() throws IOException, ServletException {
         builder3.addServlet(new ServletInfo("path", PathServlet.class)
                 .addMapping("/*"));
 
+        builder3.addErrorPage(new ErrorPage("/defaultErrorPage"));
         builder3.addErrorPage(new ErrorPage("/404", StatusCodes.NOT_FOUND));
         builder3.addErrorPage(new ErrorPage("/500", StatusCodes.INTERNAL_SERVER_ERROR));
         builder3.addErrorPage(new ErrorPage("/parentException", ParentException.class));
@@ -158,7 +158,7 @@ public void testErrorPages() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
             runTest(1, client, StatusCodes.NOT_FOUND, null, "/404");
-            runTest(1, client, StatusCodes.INTERNAL_SERVER_ERROR, null, "/500");
+            runTest(1, client, StatusCodes.INTERNAL_SERVER_ERROR, null, "/defaultErrorPage");
             runTest(1, client, StatusCodes.NOT_IMPLEMENTED, null, "/defaultErrorPage");
             runTest(1, client, null, ParentException.class, "/parentException");
             runTest(1, client, null, ChildException.class, "/childException");
@@ -198,7 +198,7 @@ public void testErrorPagesWith500PageMapped() throws IOException {
         try {
             runTest(3, client, StatusCodes.NOT_FOUND, null, "/404");
             runTest(3, client, StatusCodes.INTERNAL_SERVER_ERROR, null, "/500");
-            runTest(3, client, StatusCodes.NOT_IMPLEMENTED, null, "<html><head><title>Error</title></head><body>Not Implemented</body></html>");
+            runTest(3, client, StatusCodes.NOT_IMPLEMENTED, null, "/defaultErrorPage");
             runTest(3, client, null, ParentException.class, "/parentException");
             runTest(3, client, null, ChildException.class, "/childException");
             runTest(3, client, null, RuntimeException.class, "/runtimeException");

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/WebSocketDeploymentInfo.java
Patch:
@@ -97,8 +97,9 @@ public boolean isDispatchToWorkerThread() {
         return dispatchToWorkerThread;
     }
 
-    public void setDispatchToWorkerThread(boolean dispatchToWorkerThread) {
+    public WebSocketDeploymentInfo setDispatchToWorkerThread(boolean dispatchToWorkerThread) {
         this.dispatchToWorkerThread = dispatchToWorkerThread;
+        return this;
     }
 
     public interface ContainerReadyListener {

File: core/src/main/java/io/undertow/util/MimeMappings.java
Patch:
@@ -164,8 +164,9 @@ private Builder(boolean includeDefault) {
             }
         }
 
-        public void addMapping(final String extension, final String contentType) {
+        public Builder addMapping(final String extension, final String contentType) {
             mappings.put(extension, contentType);
+            return this;
         }
 
         public MimeMappings build() {

File: core/src/main/java/io/undertow/server/handlers/form/FormDataParser.java
Patch:
@@ -53,8 +53,8 @@ public interface FormDataParser extends Closeable {
 
     /**
      * Parse the data, blocking the current thread until parsing is complete. For blocking handlers this method is
-     * more efficient than {@link #parse()}, as the calling thread should do that actual parsing, rather than the
-     * read thread
+     * more efficient than {@link #parse(io.undertow.server.HttpHandler next)}, as the calling thread should do that
+     * actual parsing, rather than the read thread
      *
      * @return The parsed form data
      * @throws IOException If the data could not be read

File: core/src/main/java/io/undertow/server/handlers/form/FormEncodedDataDefinition.java
Patch:
@@ -41,7 +41,7 @@
  *
  * @author Stuart Douglas
  */
-public class FormEncodedDataDefinition implements FormParserFactory.ParserDefinition {
+public class FormEncodedDataDefinition implements FormParserFactory.ParserDefinition<FormEncodedDataDefinition> {
 
     public static final String APPLICATION_X_WWW_FORM_URLENCODED = "application/x-www-form-urlencoded";
     private String defaultEncoding = "ISO-8859-1";

File: core/src/main/java/io/undertow/server/handlers/form/MultiPartParserDefinition.java
Patch:
@@ -43,22 +43,23 @@
 import java.io.UnsupportedEncodingException;
 import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.Executor;
 
 /**
  * @author Stuart Douglas
  */
-public class MultiPartParserDefinition implements FormParserFactory.ParserDefinition {
+public class MultiPartParserDefinition implements FormParserFactory.ParserDefinition<MultiPartParserDefinition> {
 
     public static final String MULTIPART_FORM_DATA = "multipart/form-data";
 
     private Executor executor;
 
     private File tempFileLocation;
 
-    private String defaultEncoding = "ISO-8859-1";
+    private String defaultEncoding = StandardCharsets.ISO_8859_1.displayName();
 
     private long maxIndividualFileSize = -1;
 

File: core/src/main/java/io/undertow/server/handlers/resource/ResourceHandler.java
Patch:
@@ -277,9 +277,9 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                     }
                 }
                 //we are going to proceed. Set the appropriate headers
-                final String contentType = resource.getContentType(mimeMappings);
 
                 if (!exchange.getResponseHeaders().contains(Headers.CONTENT_TYPE)) {
+                    final String contentType = resource.getContentType(mimeMappings);
                     if (contentType != null) {
                         exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, contentType);
                     } else {

File: core/src/main/java/io/undertow/server/handlers/resource/ResourceHandler.java
Patch:
@@ -277,9 +277,9 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                     }
                 }
                 //we are going to proceed. Set the appropriate headers
-                final String contentType = resource.getContentType(mimeMappings);
 
                 if (!exchange.getResponseHeaders().contains(Headers.CONTENT_TYPE)) {
+                    final String contentType = resource.getContentType(mimeMappings);
                     if (contentType != null) {
                         exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, contentType);
                     } else {

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpServerRequestConduit.java
Patch:
@@ -234,7 +234,7 @@ private int doRead(final ByteBuffer dst, long state) throws IOException {
             chunkRemaining = this.state & STATE_MASK;
         }
 
-        int limit = dst.remaining();
+        int limit = dst.limit();
         try {
             if (dst.remaining() > chunkRemaining) {
                 dst.limit((int) (dst.position() + chunkRemaining));

File: core/src/main/java/io/undertow/server/handlers/SetHeaderHandler.java
Patch:
@@ -91,7 +91,7 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
     }
 
 
-    public class Builder implements HandlerBuilder {
+    public static class Builder implements HandlerBuilder {
         @Override
         public String name() {
             return "header";

File: core/src/main/java/io/undertow/util/StatusCodes.java
Patch:
@@ -42,7 +42,9 @@ public class StatusCodes {
     public static final int ALREADY_REPORTED = 208;
     public static final int IM_USED = 226;
     public static final int MULTIPLE_CHOICES = 300;
-    public static final int MOVED_PERMENANTLY = 301;
+    public static final int MOVED_PERMANENTLY = 301;
+    @Deprecated //typo, but left in for now due to backwards compat
+    public static final int MOVED_PERMENANTLY = MOVED_PERMANENTLY;
     public static final int FOUND = 302;
     public static final int SEE_OTHER = 303;
     public static final int NOT_MODIFIED = 304;

File: servlet/src/main/java/io/undertow/servlet/spec/SessionCookieConfigImpl.java
Patch:
@@ -40,6 +40,9 @@ public SessionCookieConfigImpl(final ServletContextImpl servletContext) {
 
     @Override
     public String rewriteUrl(final String originalUrl, final String sessionid) {
+        if(fallback != null) {
+            return fallback.rewriteUrl(originalUrl, sessionid);
+        }
         return originalUrl;
     }
 

File: servlet/src/test/java/io/undertow/servlet/test/session/SessionServlet.java
Patch:
@@ -35,6 +35,7 @@ public class SessionServlet extends HttpServlet {
     @Override
     protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {
         HttpSession session = req.getSession();
+        resp.addHeader("url", resp.encodeURL(req.getRequestURL().toString()));
         Integer value = (Integer)session.getAttribute("key");
         if(value == null) {
             value = 1;

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -70,7 +70,7 @@ public interface UndertowMessages {
     @Message(id = 11, value = "Session manager must not be null")
     IllegalStateException sessionManagerMustNotBeNull();
 
-    @Message(id = 12, value = "Session manager was not attached to the request. Make sure that the SessionAttachmentHander is installed in the handler chain")
+    @Message(id = 12, value = "Session manager was not attached to the request. Make sure that the SessionAttachmentHandler is installed in the handler chain")
     IllegalStateException sessionManagerNotFound();
 
     @Message(id = 13, value = "Argument %s cannot be null")

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -70,7 +70,7 @@ public interface UndertowMessages {
     @Message(id = 11, value = "Session manager must not be null")
     IllegalStateException sessionManagerMustNotBeNull();
 
-    @Message(id = 12, value = "Session manager was not attached to the request. Make sure that the SessionAttachmentHander is installed in the handler chain")
+    @Message(id = 12, value = "Session manager was not attached to the request. Make sure that the SessionAttachmentHandler is installed in the handler chain")
     IllegalStateException sessionManagerNotFound();
 
     @Message(id = 13, value = "Argument %s cannot be null")

File: core/src/main/java/io/undertow/util/Headers.java
Patch:
@@ -253,7 +253,7 @@ public static String extractTokenFromHeader(final String header, final String ke
         int start = pos + key.length() + 1;
         for (end = start; end < header.length(); ++end) {
             char c = header.charAt(end);
-            if (c == ' ' || c == '\t') {
+            if (c == ' ' || c == '\t' || c == ';') {
                 break;
             }
         }

File: servlet/src/main/java/io/undertow/servlet/core/ServletContainerImpl.java
Patch:
@@ -71,7 +71,8 @@ public void removeDeployment(final DeploymentInfo deploymentInfo) {
 
     @Override
     public DeploymentManager getDeploymentByPath(final String path) {
-        DeploymentManager exact = deploymentsByPath.get(path);
+
+        DeploymentManager exact = deploymentsByPath.get(path.isEmpty() ? "/" : path);
         if (exact != null) {
             return exact;
         }
@@ -88,6 +89,6 @@ public DeploymentManager getDeploymentByPath(final String path) {
                 }
             }
         }
-        return deploymentsByPath.get("");
+        return deploymentsByPath.get("/");
     }
 }

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -613,7 +613,7 @@ public String getHostAndPort() {
             host = NetworkUtils.formatPossibleIpv6Address(address.getHostString());
             int port = address.getPort();
             if (!((getRequestScheme().equals("http") && port == 80)
-                    || (getRequestScheme().equals("https") && port == 8080))) {
+                    || (getRequestScheme().equals("https") && port == 443))) {
                 host = host + ":" + port;
             }
         }

File: core/src/main/java/io/undertow/protocols/http2/Http2StreamSourceChannel.java
Patch:
@@ -168,6 +168,9 @@ public ChannelListener<Http2StreamSourceChannel> getCompletionListener() {
 
     public void setCompletionListener(ChannelListener<Http2StreamSourceChannel> completionListener) {
         this.completionListener = completionListener;
+        if(isComplete()) {
+            ChannelListeners.invokeChannelListener(this, completionListener);
+        }
     }
 
     @Override

File: core/src/main/java/io/undertow/server/protocol/http/HttpRequestParser.java
Patch:
@@ -374,7 +374,7 @@ final void handlePath(ByteBuffer buffer, ParseState state, HttpServerExchange ex
                 return;
             } else {
 
-                if (decode && (next == '+' || next == '%' || next > 127)) {
+                if (decode && (next == '%' || next > 127)) {
                     urlDecodeRequired = true;
                 } else if (next == ':' && parseState == START) {
                     parseState = FIRST_COLON;
@@ -490,7 +490,7 @@ final void handleQueryParameters(ByteBuffer buffer, ParseState state, HttpServer
             } else if (next == '\r' || next == '\n') {
                 throw UndertowMessages.MESSAGES.failedToParsePath();
             } else {
-                if (decode && (next == '+' || next == '%' || next > 127)) {
+                if (decode && (next == '+' || next == '%' || next > 127)) { //+ is only a whitespace substitute in the query part of the URL
                     urlDecodeRequired = true;
                 } else if (next == '=' && nextQueryParam == null) {
                     nextQueryParam = decode(stringBuilder.substring(queryParamPos), urlDecodeRequired, state, true);
@@ -819,6 +819,7 @@ protected void handleAfterVersion(ByteBuffer buffer, ParseState state) {
      *
      * @return
      */
+    @SuppressWarnings("unused")
     protected static Map<String, HttpString> httpStrings() {
         final Map<String, HttpString> results = new HashMap<>();
         final Class[] classs = {Headers.class, Methods.class, Protocols.class};

File: servlet/src/test/java/io/undertow/servlet/test/request/RequestPathTestCase.java
Patch:
@@ -98,15 +98,15 @@ public void testRequestPaths() throws Exception {
         runtest("/servletContext/somePath", false, "null", "/somePath", "http://localhost:" + port + "/servletContext/somePath", "/servletContext/somePath", "");
         runtest("/servletContext/somePath?foo=bar", false, "null", "/somePath", "http://localhost:" + port + "/servletContext/somePath", "/servletContext/somePath", "foo=bar");
         runtest("/servletContext/somePath?foo=b+a+r", false, "null", "/somePath", "http://localhost:" + port + "/servletContext/somePath", "/servletContext/somePath", "foo=b+a+r");
-        runtest("/servletContext/some+path?foo=b+a+r", false, "null", "/some path", "http://localhost:" + port + "/servletContext/some+path", "/servletContext/some+path", "foo=b+a+r");
+        runtest("/servletContext/some%20path?foo=b+a+r", false, "null", "/some path", "http://localhost:" + port + "/servletContext/some%20path", "/servletContext/some%20path", "foo=b+a+r");
         runtest("/servletContext/somePath.txt", true, "null", "/somePath.txt", "http://localhost:" + port + "/servletContext/somePath.txt", "/servletContext/somePath.txt", "");
         runtest("/servletContext/somePath.txt?foo=bar", true, "null", "/somePath.txt", "http://localhost:" + port + "/servletContext/somePath.txt", "/servletContext/somePath.txt", "foo=bar");
 
         //test non-default mappings
         runtest("/servletContext/req/somePath", false, "/somePath", "/req", "http://localhost:" + port + "/servletContext/req/somePath", "/servletContext/req/somePath", "");
         runtest("/servletContext/req/somePath?foo=bar", false, "/somePath", "/req", "http://localhost:" + port + "/servletContext/req/somePath", "/servletContext/req/somePath", "foo=bar");
         runtest("/servletContext/req/somePath?foo=b+a+r", false, "/somePath", "/req", "http://localhost:" + port + "/servletContext/req/somePath", "/servletContext/req/somePath", "foo=b+a+r");
-        runtest("/servletContext/req/some+path?foo=b+a+r", false, "/some path", "/req", "http://localhost:" + port + "/servletContext/req/some+path", "/servletContext/req/some+path", "foo=b+a+r");
+        runtest("/servletContext/req/some%20path?foo=b+a+r", false, "/some path", "/req", "http://localhost:" + port + "/servletContext/req/some%20path", "/servletContext/req/some%20path", "foo=b+a+r");
         runtest("/servletContext/req/somePath.txt", true, "/somePath.txt", "/req", "http://localhost:" + port + "/servletContext/req/somePath.txt", "/servletContext/req/somePath.txt", "");
         runtest("/servletContext/req/somePath.txt?foo=bar", true, "/somePath.txt", "/req", "http://localhost:" + port + "/servletContext/req/somePath.txt", "/servletContext/req/somePath.txt", "foo=bar");
 

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -498,7 +498,7 @@ private void loadParts() throws IOException, ServletException {
                 if(formData != null) {
                     for (final String namedPart : formData) {
                         for (FormData.FormValue part : formData.get(namedPart)) {
-                            parts.add(new PartImpl(namedPart, part, requestContext.getOriginalServletPathMatch().getServletChain().getManagedServlet().getServletInfo().getMultipartConfig(), servletContext));
+                            parts.add(new PartImpl(namedPart, part, requestContext.getOriginalServletPathMatch().getServletChain().getManagedServlet().getMultipartConfig(), servletContext));
                         }
                     }
                 }

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -244,6 +244,7 @@ public interface UndertowMessages {
     @Message(id = 72, value = "Failed to decode url %s to charset %s")
     IllegalArgumentException failedToDecodeURL(String s, String enc);
 
+
     @Message(id = 73, value = "Resource change listeners are not supported")
     IllegalArgumentException resourceChangeListenerNotSupported();
 

File: core/src/main/java/io/undertow/UndertowOptions.java
Patch:
@@ -32,7 +32,7 @@ public class UndertowOptions {
     /**
      * The default size we allow for the HTTP header.
      */
-    public static final int DEFAULT_MAX_HEADER_SIZE = 50 * 1024;
+    public static final int DEFAULT_MAX_HEADER_SIZE = 1024 * 1024;
 
     /**
      * The default maximum size of the HTTP entity body.

File: core/src/main/java/io/undertow/server/protocol/http/HttpReadListener.java
Patch:
@@ -169,12 +169,13 @@ public void handleEventWithNoRunningRequest(final ConduitStreamSourceChannel cha
                 } else {
                     buffer.flip();
                 }
+                int begin = buffer.remaining();
                 parser.handle(buffer, state, httpServerExchange);
                 if (buffer.hasRemaining()) {
                     free = false;
                     connection.setExtraBytes(pooled);
                 }
-                int total = read + res;
+                int total = read + (begin - buffer.remaining());
                 read = total;
                 if (read > maxRequestSize) {
                     UndertowLogger.REQUEST_LOGGER.requestHeaderWasTooLarge(connection.getPeerAddress(), maxRequestSize);

File: core/src/main/java/io/undertow/Undertow.java
Patch:
@@ -114,6 +114,7 @@ public synchronized void start() {
                     .set(Options.REUSE_ADDRESSES, true)
                     .set(Options.BALANCING_TOKENS, 1)
                     .set(Options.BALANCING_CONNECTIONS, 2)
+                    .set(Options.BACKLOG, 1000)
                     .addAll(this.socketOptions)
                     .getMap();
 

File: core/src/test/java/io/undertow/server/handlers/HttpTunnelingViaConnectTestCase.java
Patch:
@@ -22,7 +22,6 @@
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.testutils.DefaultServer;
-import org.apache.http.HttpException;
 import org.apache.http.HttpHost;
 import org.apache.http.auth.UsernamePasswordCredentials;
 import org.apache.http.impl.client.ProxyClient;
@@ -34,7 +33,6 @@
 import org.junit.runner.RunWith;
 
 import java.io.BufferedReader;
-import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.io.Writer;
@@ -75,7 +73,7 @@ public static void stop() {
     }
 
     @Test
-    public void testConnectViaProxy() throws IOException, InterruptedException, HttpException {
+    public void testConnectViaProxy() throws Exception {
 
         final HttpHost proxy = new HttpHost(DefaultServer.getHostAddress("default"), DefaultServer.getHostPort("default") + 1, "http");
         final HttpHost target = new HttpHost(DefaultServer.getHostAddress("default"), DefaultServer.getHostPort("default"), "http");

File: core/src/test/java/io/undertow/server/handlers/file/FileHandlerIndexTestCase.java
Patch:
@@ -61,7 +61,7 @@ public void testWelcomeFile() throws IOException, URISyntaxException {
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
             final String response = HttpClientUtils.readResponse(result);
             Header[] headers = result.getHeaders("Content-Type");
-            Assert.assertEquals("text/html; charset=UTF-8", headers[0].getValue());
+            Assert.assertEquals("text/html", headers[0].getValue());
             Assert.assertTrue(response, response.contains("A web page"));
 
         } finally {
@@ -84,15 +84,15 @@ public void testDirectoryIndex() throws IOException, URISyntaxException {
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
             String response = HttpClientUtils.readResponse(result);
             Header[] headers = result.getHeaders("Content-Type");
-            Assert.assertEquals("text/html", headers[0].getValue());
+            Assert.assertEquals("text/html; charset=UTF-8", headers[0].getValue());
             Assert.assertTrue(response, response.contains("page.html"));
 
             get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path/.");
             result = client.execute(get);
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
             response = HttpClientUtils.readResponse(result);
             headers = result.getHeaders("Content-Type");
-            Assert.assertEquals("text/html", headers[0].getValue());
+            Assert.assertEquals("text/html; charset=UTF-8", headers[0].getValue());
             Assert.assertTrue(response, response.contains("page.html"));
 
         } finally {

File: core/src/test/java/io/undertow/server/ssl/ComplexSSLTestCase.java
Patch:
@@ -88,15 +88,15 @@ public void complexSSLTestCase() throws IOException, GeneralSecurityException, U
             String responseList = HttpClientUtils.readResponse(resultList);
             Assert.assertTrue(responseList, responseList.contains("page.html"));
             Header[] headersList = resultList.getHeaders("Content-Type");
-            Assert.assertEquals("text/html", headersList[0].getValue());
+            Assert.assertEquals("text/html; charset=UTF-8", headersList[0].getValue());
 
             //get file itself, breaks
             HttpGet getFile = new HttpGet(DefaultServer.getDefaultServerSSLAddress() + "/page.html");
             HttpResponse result = client.execute(getFile);
             Assert.assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());
             String response = HttpClientUtils.readResponse(result);
             Header[] headers = result.getHeaders("Content-Type");
-            Assert.assertEquals("text/html; charset=UTF-8", headers[0].getValue());
+            Assert.assertEquals("text/html", headers[0].getValue());
             Assert.assertTrue(response, response.contains("A web page"));
 
 

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/WebSocketSessionRemoteEndpoint.java
Patch:
@@ -191,7 +191,7 @@ private void sendObjectImpl(final Object o, final WebSocketCallback callback) {
                     WebSockets.sendBinary(ByteBuffer.wrap((byte[])o), webSocketChannel, callback, sendTimeout);
                 } else if(o instanceof ByteBuffer) {
                     WebSockets.sendBinary((ByteBuffer)o, webSocketChannel, callback, sendTimeout);
-                } if (encoding.canEncodeText(o.getClass())) {
+                } else if (encoding.canEncodeText(o.getClass())) {
                     WebSockets.sendText(encoding.encodeText(o), webSocketChannel, callback, sendTimeout);
                 } else if (encoding.canEncodeBinary(o.getClass())) {
                     WebSockets.sendBinary(encoding.encodeBinary(o), webSocketChannel, callback, sendTimeout);

File: core/src/main/java/io/undertow/server/protocol/spdy/SpdyServerConnection.java
Patch:
@@ -246,8 +246,8 @@ protected StreamSinkConduit getSinkConduit(HttpServerExchange exchange, StreamSi
         }
         DateUtils.addDateHeaderIfRequired(exchange);
 
-        headers.add(STATUS, exchange.getResponseCode() + " " + StatusCodes.getReason(exchange.getResponseCode()));
-        headers.add(VERSION, exchange.getProtocol().toString());
+        headers.put(STATUS, exchange.getResponseCode() + " " + StatusCodes.getReason(exchange.getResponseCode()));
+        headers.put(VERSION, exchange.getProtocol().toString());
 
         Connectors.flattenCookies(exchange);
         return originalSinkConduit;
@@ -315,7 +315,6 @@ public boolean pushResource(String path, HttpString method, HeaderMap requestHea
             responseHeaders.put(SpdyReceiveListener.HOST, exchange.getHostAndPort());
             responseHeaders.put(SpdyReceiveListener.SCHEME, exchange.getRequestScheme());
             responseHeaders.put(SpdyReceiveListener.METHOD, method.toString());
-            responseHeaders.put(SpdyReceiveListener.VERSION, Protocols.HTTP_1_1_STRING);
 
             SpdySynStreamStreamSinkChannel sink = channel.createStream(requestChannel.getStreamId(),responseHeaders);
             SpdyServerConnection newConnection = new SpdyServerConnection(rootHandler, channel, sink, getUndertowOptions(), getBufferSize());

File: core/src/main/java/io/undertow/conduits/ReadTimeoutStreamSourceConduit.java
Patch:
@@ -65,7 +65,7 @@ public void run() {
                 handle = connection.getIoThread().executeAfter(timeoutCommand, (expireTime - current) + FUZZ_FACTOR, TimeUnit.MILLISECONDS);
                 return;
             }
-            UndertowLogger.REQUEST_LOGGER.tracef("Timing out channel %s due to inactivity");
+            UndertowLogger.REQUEST_LOGGER.tracef("Timing out channel %s due to inactivity", connection.getSourceChannel());
             IoUtils.safeClose(connection);
             if (connection.getSourceChannel().isReadResumed()) {
                 ChannelListeners.invokeChannelListener(connection.getSourceChannel(), connection.getSourceChannel().getReadListener());

File: core/src/main/java/io/undertow/conduits/WriteTimeoutStreamSinkConduit.java
Patch:
@@ -65,7 +65,7 @@ public void run() {
                 handle = connection.getIoThread().executeAfter(timeoutCommand, (expireTime - current) + FUZZ_FACTOR, TimeUnit.MILLISECONDS);
                 return;
             }
-            UndertowLogger.REQUEST_LOGGER.tracef("Timing out channel %s due to inactivity");
+            UndertowLogger.REQUEST_LOGGER.tracef("Timing out channel %s due to inactivity", connection.getSinkChannel());
             IoUtils.safeClose(connection);
             if (connection.getSourceChannel().isReadResumed()) {
                 ChannelListeners.invokeChannelListener(connection.getSourceChannel(), connection.getSourceChannel().getReadListener());

File: core/src/main/java/io/undertow/conduits/ReadTimeoutStreamSourceConduit.java
Patch:
@@ -65,7 +65,7 @@ public void run() {
                 handle = connection.getIoThread().executeAfter(timeoutCommand, (expireTime - current) + FUZZ_FACTOR, TimeUnit.MILLISECONDS);
                 return;
             }
-            UndertowLogger.REQUEST_LOGGER.tracef("Timing out channel %s due to inactivity");
+            UndertowLogger.REQUEST_LOGGER.tracef("Timing out channel %s due to inactivity", connection.getSourceChannel());
             IoUtils.safeClose(connection);
             if (connection.getSourceChannel().isReadResumed()) {
                 ChannelListeners.invokeChannelListener(connection.getSourceChannel(), connection.getSourceChannel().getReadListener());

File: core/src/main/java/io/undertow/conduits/WriteTimeoutStreamSinkConduit.java
Patch:
@@ -65,7 +65,7 @@ public void run() {
                 handle = connection.getIoThread().executeAfter(timeoutCommand, (expireTime - current) + FUZZ_FACTOR, TimeUnit.MILLISECONDS);
                 return;
             }
-            UndertowLogger.REQUEST_LOGGER.tracef("Timing out channel %s due to inactivity");
+            UndertowLogger.REQUEST_LOGGER.tracef("Timing out channel %s due to inactivity", connection.getSinkChannel());
             IoUtils.safeClose(connection);
             if (connection.getSourceChannel().isReadResumed()) {
                 ChannelListeners.invokeChannelListener(connection.getSourceChannel(), connection.getSourceChannel().getReadListener());

File: core/src/main/java/io/undertow/server/handlers/RequestLimit.java
Patch:
@@ -68,6 +68,7 @@ public void exchangeEvent(final HttpServerExchange exchange, final NextListener
             try {
                 final SuspendedRequest task = queue.poll();
                 if (task != null) {
+                    task.exchange.addExchangeCompleteListener(COMPLETION_LISTENER);
                     task.exchange.dispatch(task.next);
                 } else {
                     decrementRequests();
@@ -99,7 +100,6 @@ public RequestLimit(int maximumConcurrentRequests, int queueSize) {
     }
 
     public void handleRequest(final HttpServerExchange exchange, final HttpHandler next) throws Exception {
-        exchange.addExchangeCompleteListener(COMPLETION_LISTENER);
         long oldVal, newVal;
         do {
             oldVal = state;
@@ -118,6 +118,7 @@ public void run() {
             }
             newVal = oldVal + 1;
         } while (!stateUpdater.compareAndSet(this, oldVal, newVal));
+        exchange.addExchangeCompleteListener(COMPLETION_LISTENER);
         next.handleRequest(exchange);
     }
 

File: servlet/src/main/java/io/undertow/servlet/spec/AsyncContextImpl.java
Patch:
@@ -469,7 +469,7 @@ private final class TimeoutTask implements Runnable {
         @Override
         public void run() {
             synchronized (AsyncContextImpl.this) {
-                if (!dispatched) {
+                if (!dispatched && !complete) {
                     addAsyncTask(new Runnable() {
                         @Override
                         public void run() {

File: core/src/main/java/io/undertow/client/http2/Http2ClientConnection.java
Patch:
@@ -252,7 +252,7 @@ public XnioIoThread getIoThread() {
 
     @Override
     public boolean isOpen() {
-        return http2Channel.isOpen();
+        return http2Channel.isOpen() && !http2Channel.isPeerGoneAway() && !http2Channel.isThisGoneAway();
     }
 
     @Override

File: core/src/main/java/io/undertow/client/http2/Http2ClientProvider.java
Patch:
@@ -203,6 +203,7 @@ public void handleEvent(StreamSourceChannel channel) {
                         try {
                             int read = channel.read(buf);
                             if (read > 0) {
+                                buf.flip();
                                 PushBackStreamSourceConduit pb = new PushBackStreamSourceConduit(connection.getSourceChannel().getConduit());
                                 pb.pushBack(new ImmediatePooled<>(buf));
                                 connection.getSourceChannel().setConduit(pb);

File: core/src/main/java/io/undertow/client/spdy/SpdyClientProvider.java
Patch:
@@ -231,6 +231,7 @@ public void handleEvent(StreamSourceChannel channel) {
                         try {
                             int read = channel.read(buf);
                             if (read > 0) {
+                                buf.flip();
                                 PushBackStreamSourceConduit pb = new PushBackStreamSourceConduit(connection.getSourceChannel().getConduit());
                                 pb.pushBack(new ImmediatePooled<>(buf));
                                 connection.getSourceChannel().setConduit(pb);

File: core/src/main/java/io/undertow/protocols/ssl/SslConduit.java
Patch:
@@ -579,7 +579,6 @@ private long doUnwrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcep
         //copy any exiting data
         if(unwrappedData != null && userBuffers != null) {
             long copied = Buffers.copy(userBuffers, off, len, unwrappedData.getResource());
-            System.out.println("copied " + copied);
             if(!unwrappedData.getResource().hasRemaining()) {
                 unwrappedData.free();
                 this.unwrappedData = null;
@@ -642,7 +641,6 @@ private long doUnwrap(ByteBuffer[] userBuffers, int off, int len) throws IOExcep
             } finally {
                 if(unwrapBufferUsed) {
                     unwrappedData.getResource().flip();
-                    System.out.println("unwrapped " + unwrappedData.getResource().remaining());
                     if(!unwrappedData.getResource().hasRemaining()) {
                         unwrappedData.free();
                         unwrappedData = null;

File: core/src/test/java/io/undertow/testutils/DebuggingSlicePool.java
Patch:
@@ -74,7 +74,7 @@ public void free() {
         @Override
         public ByteBuffer getResource() throws IllegalStateException {
             if(free) {
-                throw new RuntimeException("Buffer already freed, free point: ", freePoint);
+                throw new IllegalStateException("Buffer already freed, free point: ", freePoint);
             }
             return delegate.getResource();
         }

File: core/src/test/java/io/undertow/testutils/DebuggingSlicePool.java
Patch:
@@ -63,7 +63,7 @@ public void discard() {
         @Override
         public void free() {
             if(free) {
-                throw new RuntimeException("Buffer already freed, free point: ", freePoint);
+                return;
             }
             freePoint = new RuntimeException("FREE POINT");
             free = true;

File: core/src/test/java/io/undertow/server/ssl/ComplexSSLTestCase.java
Patch:
@@ -118,15 +118,12 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                 }
                 exchange.startBlocking();
                 ByteArrayOutputStream out = new ByteArrayOutputStream();
-                StringBuilder sb = new StringBuilder();
                 byte[] buf = new byte[100];
                 int res = 0;
                 while ((res = exchange.getInputStream().read(buf)) > 0) {
-                    sb.append(new String(buf, 0, res));
                     out.write(buf, 0, res);
                 }
                 System.out.println("WRITE " + out.size());
-                Assert.assertEquals(message, sb.toString());
                 exchange.getOutputStream().write(out.toByteArray());
                 System.out.println("DONE " + out.size());
             }

File: core/src/main/java/io/undertow/websockets/core/StreamSourceFrameChannel.java
Patch:
@@ -127,6 +127,9 @@ protected void handleHeaderData(FrameHeaderData headerData) {
         if (((WebSocketFrame) headerData).isFinalFragment()) {
             finalFrame();
         }
+        if(masker != null) {
+            masker.newFrame(headerData);
+        }
         if(functions != null) {
             for(ChannelFunction func : functions) {
                 func.newFrame(headerData);

File: core/src/main/java/io/undertow/client/http/HttpClientProvider.java
Patch:
@@ -157,7 +157,7 @@ public void handleEvent(SslConnection channel) {
                 try {
                     ((SslConnection) connection).startHandshake();
                 } catch (IOException e) {
-                    listener.failed(new IOException(e));
+                    listener.failed(e);
                 }
             }
             listener.completed(new HttpClientConnection(connection, options, bufferPool));

File: core/src/main/java/io/undertow/server/protocol/http/HttpContinue.java
Patch:
@@ -178,6 +178,7 @@ public void handleException(Channel channel, IOException e) {
                         }
                 ));
                 responseChannel.resumeWrites();
+                exchange.dispatch();
             } else {
                 callback.onComplete(exchange, null);
             }

File: core/src/main/java/io/undertow/protocols/http2/Http2StreamSourceChannel.java
Patch:
@@ -164,21 +164,20 @@ public void setCompletionListener(ChannelListener<Http2StreamSourceChannel> comp
     }
 
     @Override
-    void rstStream() {
+    void rstStream(int error) {
         if (rst) {
             return;
         }
         rst = true;
         markStreamBroken();
-        getHttp2Channel().sendRstStream(streamId, Http2Channel.ERROR_CANCEL);
     }
 
     @Override
     protected void channelForciblyClosed() {
         if (completionListener != null) {
             completionListener.handleEvent(this);
         }
-        rstStream();
+        getHttp2Channel().sendRstStream(streamId, Http2Channel.ERROR_CANCEL);
     }
 
     public int getStreamId() {

File: core/src/main/java/io/undertow/server/protocol/http2/Http2ServerConnection.java
Patch:
@@ -27,6 +27,7 @@
 import io.undertow.UndertowOptions;
 import io.undertow.protocols.http2.Http2HeadersStreamSinkChannel;
 import io.undertow.server.HttpHandler;
+import io.undertow.util.DateUtils;
 import io.undertow.util.Protocols;
 import org.xnio.ChannelListener;
 import org.xnio.Option;
@@ -238,6 +239,7 @@ protected ConduitStreamSourceChannel getSourceChannel() {
     @Override
     protected StreamSinkConduit getSinkConduit(HttpServerExchange exchange, StreamSinkConduit conduit) {
         HeaderMap headers = responseChannel.getHeaders();
+        DateUtils.addDateHeaderIfRequired(exchange);
         headers.add(STATUS, exchange.getResponseCode());
         Connectors.flattenCookies(exchange);
         return originalSinkConduit;

File: core/src/main/java/io/undertow/server/protocol/spdy/SpdyServerConnection.java
Patch:
@@ -29,6 +29,7 @@
 import io.undertow.protocols.spdy.SpdySynStreamStreamSourceChannel;
 import io.undertow.util.AttachmentKey;
 import io.undertow.util.AttachmentList;
+import io.undertow.util.DateUtils;
 import io.undertow.util.HeaderMap;
 import io.undertow.util.HttpString;
 import io.undertow.util.StatusCodes;
@@ -212,6 +213,7 @@ protected ConduitStreamSourceChannel getSourceChannel() {
     @Override
     protected StreamSinkConduit getSinkConduit(HttpServerExchange exchange, StreamSinkConduit conduit) {
         HeaderMap headers = responseChannel.getHeaders();
+        DateUtils.addDateHeaderIfRequired(exchange);
 
         headers.add(STATUS, exchange.getResponseCode() + " " + StatusCodes.getReason(exchange.getResponseCode()));
         headers.add(VERSION, exchange.getProtocol().toString());

File: examples/src/main/java/io/undertow/examples/http2/Http2Server.java
Patch:
@@ -75,7 +75,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                         exchange.getResponseHeaders().add(Headers.LOCATION, "https://" + exchange.getHostName() + ":" + (exchange.getHostPort() + 363) + exchange.getRelativePath());
                         exchange.setResponseCode(StatusCodes.TEMPORARY_REDIRECT);
                     }
-                }), "X-Undertow-Transport", ExchangeAttributes.transportProtocol())).build();
+                }), "x-undertow-transport", ExchangeAttributes.transportProtocol())).build();
         server.start();
     }
 

File: core/src/main/java/io/undertow/server/handlers/proxy/ProxyHandler.java
Patch:
@@ -223,11 +223,10 @@ static void copyHeaders(final HeaderMap to, final HeaderMap from) {
         HeaderValues values;
         while (f != -1L) {
             values = from.fiCurrent(f);
-            if(to.contains(values.getHeaderName())) {
+            if(!to.contains(values.getHeaderName())) {
                 //don't over write existing headers, normally the map will be empty, if it is not we assume it is not for a reason
-                continue;
+                to.putAll(values.getHeaderName(), values);
             }
-            to.putAll(values.getHeaderName(), values);
             f = from.fiNextNonEmpty(f);
         }
     }

File: core/src/main/java/io/undertow/protocols/http2/Http2Channel.java
Patch:
@@ -354,7 +354,7 @@ protected void lastDataRead() {
 
     @Override
     public boolean isOpen() {
-        return super.isOpen() && !thisGoneAway;
+        return super.isOpen() && !thisGoneAway && !peerGoneAway;
     }
 
     @Override

File: core/src/main/java/io/undertow/protocols/spdy/SpdyChannel.java
Patch:
@@ -222,7 +222,7 @@ protected void lastDataRead() {
 
     @Override
     public boolean isOpen() {
-        return super.isOpen() && !thisGoneAway;
+        return super.isOpen() && !thisGoneAway && !peerGoneAway;
     }
 
     @Override

File: core/src/test/java/io/undertow/server/handlers/proxy/LoadBalancingProxySPDYTestCase.java
Patch:
@@ -24,7 +24,6 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 
-import io.undertow.testutils.ProxyIgnore;
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.runner.RunWith;
@@ -49,7 +48,6 @@
  * @author Stuart Douglas
  */
 @RunWith(DefaultServer.class)
-@ProxyIgnore
 public class LoadBalancingProxySPDYTestCase extends AbstractLoadBalancingProxyTestCase {
 
     @BeforeClass

File: core/src/main/java/io/undertow/server/protocol/http/AlpnOpenListener.java
Patch:
@@ -93,10 +93,10 @@ public void handleEvent(final StreamConnection channel) {
         final AlpnConnectionListener potentialConnection = new AlpnConnectionListener(channel);
         channel.getSourceChannel().setReadListener(potentialConnection);
         final SSLEngine sslEngine = JsseXnioSsl.getSslEngine((SslConnection) channel);
-        final String existing = (String) sslEngine.getSession().getValue(PROTOCOL_KEY);
         ALPN.put(sslEngine, new ALPN.ServerProvider() {
             @Override
             public void unsupported() {
+                final String existing = (String) sslEngine.getHandshakeSession().getValue(PROTOCOL_KEY);
                 if (existing == null || !listeners.containsKey(existing)) {
                     if(fallbackProtocol == null) {
                         UndertowLogger.REQUEST_IO_LOGGER.noALPNFallback(channel.getPeerAddress());
@@ -133,7 +133,7 @@ public String select(List<String> strings) {
                     IoUtils.safeClose(channel);
                     return null;
                 }
-                sslEngine.getSession().putValue(PROTOCOL_KEY, fallbackProtocol);
+                sslEngine.getHandshakeSession().putValue(PROTOCOL_KEY, fallbackProtocol);
                 potentialConnection.selected = fallbackProtocol;
                 return fallbackProtocol;
             }

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/FrameHandler.java
Patch:
@@ -279,6 +279,8 @@ protected void onFullBinaryMessage(WebSocketChannel channel, BufferedBinaryMessa
         HandlerWrapper handler = getHandler(FrameType.BYTE);
         if (handler != null) {
             invokeBinaryHandler(message, handler, true);
+        } else {
+            message.getData().free();
         }
     }
 

File: core/src/main/java/io/undertow/util/RedirectBuilder.java
Patch:
@@ -117,7 +117,7 @@ private static String encodeUrlPart(final String part) throws UnsupportedEncodin
                 break;
             } else if (c == '/') {
                 if (pos != i) {
-                    String original = part.substring(pos, i - 1);
+                    String original = part.substring(pos, i);
                     String encoded = URLEncoder.encode(original, UTF_8);
                     if (!encoded.equals(original)) {
                         return realEncode(part, pos);
@@ -141,7 +141,7 @@ private static String realEncode(String part, int startPos) throws UnsupportedEn
                 break;
             } else if (c == '/') {
                 if (pos != i) {
-                    String original = part.substring(pos, i - 1);
+                    String original = part.substring(pos, i);
                     String encoded = URLEncoder.encode(original, UTF_8);
                     sb.append(encoded);
                     sb.append('/');

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/FrameHandler.java
Patch:
@@ -86,9 +86,9 @@ public void run() {
                     if (singleBuffer.remaining() > 1) {
                         final CloseReason.CloseCode code = CloseReason.CloseCodes.getCloseCode(singleBuffer.getShort());
                         final String reasonPhrase = singleBuffer.remaining() > 1 ? new UTF8Output(singleBuffer).extract() : null;
-                        session.close(new CloseReason(code, reasonPhrase));
+                        session.closeInternal(new CloseReason(code, reasonPhrase));
                     } else {
-                        session.close();
+                        session.closeInternal(new CloseReason(CloseReason.CloseCodes.NO_STATUS_CODE, null));
                     }
                 } catch (IOException e) {
                     invokeOnError(e);

File: core/src/main/java/io/undertow/websockets/core/protocol/Handshake.java
Patch:
@@ -156,7 +156,7 @@ protected final void selectSubprotocol(final WebSocketHttpExchange exchange) {
 
         String[] requestedSubprotocolArray = PATTERN.split(requestedSubprotocols);
         String subProtocol = supportedSubprotols(requestedSubprotocolArray);
-        if (subProtocol != null) {
+        if (subProtocol != null && !subProtocol.isEmpty()) {
             exchange.setResponseHeader(Headers.SEC_WEB_SOCKET_PROTOCOL_STRING, subProtocol);
         }
 

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/DefaultContainerConfigurator.java
Patch:
@@ -48,12 +48,12 @@ public class DefaultContainerConfigurator extends ServerEndpointConfig.Configura
 
     @Override
     public String getNegotiatedSubprotocol(final List<String> supported, final List<String> requested) {
-        for(String proto : supported) {
-            if(requested.contains(proto)) {
+        for(String proto : requested) {
+            if(supported.contains(proto)) {
                 return proto;
             }
         }
-        return null;
+        return "";
     }
 
     @Override

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/UndertowContainerProvider.java
Patch:
@@ -47,6 +47,7 @@
 public class UndertowContainerProvider extends ContainerProvider {
 
     private static final boolean directBuffers = Boolean.getBoolean("io.undertow.websockets.direct-buffers");
+    private static final boolean invokeInIoThread = Boolean.getBoolean("io.undertow.websockets.invoke-in-io-thread");
 
     private static final RuntimePermission PERMISSION = new RuntimePermission("io.undertow.websockets.jsr.MODIFY_WEBSOCKET_CONTAINER");
 
@@ -92,7 +93,7 @@ private WebSocketContainer getDefaultContainer() {
                     //todo: what options should we use here?
                     XnioWorker worker = Xnio.getInstance().createWorker(OptionMap.create(Options.THREAD_DAEMON, true));
                     Pool<ByteBuffer> buffers = new ByteBufferSlicePool(directBuffers ? BufferAllocator.DIRECT_BYTE_BUFFER_ALLOCATOR : BufferAllocator.BYTE_BUFFER_ALLOCATOR, 1024, 10240);
-                    defaultContainer = new ServerWebSocketContainer(defaultIntrospector, UndertowContainerProvider.class.getClassLoader(), worker, buffers, new CompositeThreadSetupAction(Collections.<ThreadSetupAction>emptyList()), false);
+                    defaultContainer = new ServerWebSocketContainer(defaultIntrospector, UndertowContainerProvider.class.getClassLoader(), worker, buffers, new CompositeThreadSetupAction(Collections.<ThreadSetupAction>emptyList()), !invokeInIoThread);
                 } catch (IOException e) {
                     throw new RuntimeException(e);
                 }

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/FrameHandler.java
Patch:
@@ -82,7 +82,6 @@ protected void onFullCloseMessage(final WebSocketChannel channel, final Buffered
         session.getContainer().invokeEndpointMethod(executor, new Runnable() {
             @Override
             public void run() {
-                WebSockets.sendClose(toSend, channel, null);
                 try {
                     if (singleBuffer.remaining() > 1) {
                         final CloseReason.CloseCode code = CloseReason.CloseCodes.getCloseCode(singleBuffer.getShort());
@@ -95,6 +94,7 @@ public void run() {
                     invokeOnError(e);
                 } finally {
                     pooled.free();
+                    WebSockets.sendClose(toSend, channel, null);
                 }
             }
         });

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/annotated/AnnotatedEndpointFactory.java
Patch:
@@ -219,7 +219,7 @@ maxMessageSize, new BoundSingleParameter(method, Session.class, true),
                             break;
                         }
                     }
-                    if (!messageHandled && booleanLocation > 0) {
+                    if (!messageHandled && booleanLocation != -1) {
                         //so it turns out that the boolean was the message type and not a final fragement indicator
                         if (textMessage != null) {
                             throw JsrWebSocketMessages.MESSAGES.moreThanOneAnnotation(OnMessage.class);

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/EncodingFactory.java
Patch:
@@ -322,7 +322,6 @@ static boolean isPrimitiveOrBoxed(final Class<?> clazz) {
                 clazz == Integer.class ||
                 clazz == Long.class ||
                 clazz == Float.class ||
-                clazz == Double.class ||
-                clazz == String.class; //we don't care about void
+                clazz == Double.class;//we don't care about void
     }
 }

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/JsrWebSocketMessages.java
Patch:
@@ -148,4 +148,7 @@ public interface JsrWebSocketMessages {
 
     @Message(id = 3038, value = "Message of size %s was larger than the maximum of %s")
     IllegalArgumentException messageTooLarge(int size, int max);
+
+    @Message(id = 3039, value = "The container cannot find a suitable constructor to instantiate endpoint of type %s")
+    InstantiationException cannotInstantiateEndpoint(Class<?> c);
 }

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/annotated/AnnotatedEndpointFactory.java
Patch:
@@ -278,6 +278,9 @@ private static boolean hasAnnotation(Class<? extends Annotation> annotationType,
 
     @Override
     public InstanceHandle<Endpoint> createInstance() throws InstantiationException {
+        if(underlyingFactory == null) {
+            throw JsrWebSocketMessages.MESSAGES.cannotInstantiateEndpoint(endpointClass);
+        }
         final InstanceHandle<?> instance = underlyingFactory.createInstance();
         final AnnotatedEndpoint endpoint = new AnnotatedEndpoint(instance, OnOpen, OnClose, OnError, textMessage, binaryMessage, pongMessage);
         return new InstanceHandle<Endpoint>() {

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/WebSocketSessionRemoteEndpoint.java
Patch:
@@ -183,7 +183,7 @@ private void sendObjectImpl(final Object o, final WebSocketCallback callback) {
                     throw new EncodeException(o, "No suitable encoder found");
                 }
             } catch (Exception e) {
-                callback.onError(webSocketChannel, o, e);
+                callback.onError(webSocketChannel, null, e);
             }
         }
 

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/SendResultFuture.java
Patch:
@@ -55,6 +55,7 @@ public synchronized void onError(WebSocketChannel channel, T context, Throwable
             throw new IllegalStateException();
         }
         exception = throwable;
+        done = true;
         if (waiters > 0) {
             notifyAll();
         }

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/annotated/AnnotatedEndpoint.java
Patch:
@@ -105,7 +105,7 @@ public void onOpen(final Session session, final EndpointConfig endpointConfigura
     }
 
     private void addPartialHandler(final UndertowSession session, final BoundMethod method) {
-        session.addMessageHandler((Class) textMessage.getMessageType(), new MessageHandler.Partial<Object>() {
+        session.addMessageHandler((Class) method.getMessageType(), new MessageHandler.Partial<Object>() {
             @Override
             public void onMessage(Object partialMessage, boolean last) {
 

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/annotated/AnnotatedEndpoint.java
Patch:
@@ -134,7 +134,7 @@ public void run() {
 
 
     private void addWholeHandler(final UndertowSession session, final BoundMethod method) {
-        session.addMessageHandler((Class) textMessage.getMessageType(), new MessageHandler.Whole<Object>() {
+        session.addMessageHandler((Class) method.getMessageType(), new MessageHandler.Whole<Object>() {
             @Override
             public void onMessage(Object partialMessage) {
 

File: servlet/src/main/java/io/undertow/servlet/spec/RequestDispatcherImpl.java
Patch:
@@ -160,6 +160,7 @@ public void forward(final ServletRequest request, final ServletResponse response
                         servletContext.getDeployment().getServletDispatcher().dispatchToPath(requestImpl.getExchange(), pathMatch, DispatcherType.FORWARD);
                     }
 
+                    //if we are not in an async or error dispatch then we close the response
                     if (!request.isAsyncStarted()) {
                         if (response instanceof HttpServletResponseImpl) {
                             responseImpl.closeStreamAndWriter();

File: core/src/main/java/io/undertow/protocols/http2/Http2Channel.java
Patch:
@@ -433,7 +433,6 @@ synchronized void updateSettings(List<Http2Setting> settings) {
                     sendGoAway(ERROR_PROTOCOL_ERROR);
                     return;
                 }
-                encoder.setMaxTableSize(setting.getValue());
             }
             //ignore the rest for now
         }

File: core/src/main/java/io/undertow/protocols/http2/Http2Channel.java
Patch:
@@ -243,9 +243,10 @@ protected AbstractHttp2StreamSourceChannel createChannel(FrameHeaderData frameHe
                 Http2HeadersParser parser = (Http2HeadersParser) frameParser.parser;
                 channel = new Http2StreamSourceChannel(this, frameData, frameHeaderData.getFrameLength(), parser.getHeaderMap(), frameParser.streamId);
                 lastGoodStreamId = Math.max(lastGoodStreamId, frameParser.streamId);
-                incomingStreams.put(frameParser.streamId, (Http2StreamSourceChannel) channel);
                 if (parser.isHeadersEndStream() && Bits.allAreSet(frameParser.flags, HEADERS_FLAG_END_HEADERS)) {
                     channel.lastFrame();
+                } else {
+                    incomingStreams.put(frameParser.streamId, (Http2StreamSourceChannel) channel);
                 }
                 break;
             }

File: core/src/main/java/io/undertow/protocols/http2/Http2PushBackParser.java
Patch:
@@ -57,7 +57,7 @@ public void parse(ByteBuffer data, Http2FrameHeaderParser headerParser) throws I
             int rem = dataToParse.remaining();
             handleData(dataToParse, headerParser);
             used = rem - dataToParse.remaining();
-            if(remainingData > 0 && used == 0 && dataToParse.remaining() >= remainingData) {
+            if(!isFinished() && remainingData > 0 && used == 0 && dataToParse.remaining() >= remainingData) {
                 throw UndertowMessages.MESSAGES.parserDidNotMakeProgress();
             }
 

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedChannel.java
Patch:
@@ -342,7 +342,9 @@ public synchronized R receive() throws IOException {
                     boolean moreData = data.getFrameLength() > frameData.getResource().remaining();
                     R newChannel = createChannel(data, frameData);
                     if (newChannel != null) {
-                        receivers.add(newChannel);
+                        if(!newChannel.isComplete()) {
+                            receivers.add(newChannel);
+                        }
                         if (moreData) {
                             receiver = newChannel;
                         }

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpOpenListener.java
Patch:
@@ -119,7 +119,7 @@ public void handleEvent(final StreamConnection channel) {
         }
         if(statisticsEnabled) {
             channel.getSinkChannel().setConduit(new BytesSentStreamSinkConduit(channel.getSinkChannel().getConduit(), connectorStatistics.sentAccumulator()));
-            channel.getSourceChannel().setConduit(new BytesReceivedStreamSourceConduit(channel.getSourceChannel().getConduit(), connectorStatistics.sentAccumulator()));
+            channel.getSourceChannel().setConduit(new BytesReceivedStreamSourceConduit(channel.getSourceChannel().getConduit(), connectorStatistics.receivedAccumulator()));
         }
 
         AjpServerConnection connection = new AjpServerConnection(channel, bufferPool, rootHandler, undertowOptions, bufferSize);

File: core/src/main/java/io/undertow/server/protocol/http2/Http2OpenListener.java
Patch:
@@ -212,7 +212,7 @@ public void handleEvent(StreamSourceChannel source) {
                         }
                         if(statisticsEnabled) {
                             this.channel.getSinkChannel().setConduit(new BytesSentStreamSinkConduit(this.channel.getSinkChannel().getConduit(), connectorStatistics.sentAccumulator()));
-                            this.channel.getSourceChannel().setConduit(new BytesReceivedStreamSourceConduit(this.channel.getSourceChannel().getConduit(), connectorStatistics.sentAccumulator()));
+                            this.channel.getSourceChannel().setConduit(new BytesReceivedStreamSourceConduit(this.channel.getSourceChannel().getConduit(), connectorStatistics.receivedAccumulator()));
                         }
                         free = false;
                         channel.getReceiveSetter().set(new Http2ReceiveListener(rootHandler, getUndertowOptions(), bufferSize, connectorStatistics));

File: core/src/main/java/io/undertow/server/protocol/spdy/SpdyOpenListener.java
Patch:
@@ -218,7 +218,7 @@ public void handleEvent(StreamSourceChannel source) {
 
                         if(statisticsEnabled) {
                             this.channel.getSinkChannel().setConduit(new BytesSentStreamSinkConduit(this.channel.getSinkChannel().getConduit(), connectorStatistics.sentAccumulator()));
-                            this.channel.getSourceChannel().setConduit(new BytesReceivedStreamSourceConduit(this.channel.getSourceChannel().getConduit(), connectorStatistics.sentAccumulator()));
+                            this.channel.getSourceChannel().setConduit(new BytesReceivedStreamSourceConduit(this.channel.getSourceChannel().getConduit(), connectorStatistics.receivedAccumulator()));
                         }
                         channel.getReceiveSetter().set(new SpdyReceiveListener(rootHandler, getUndertowOptions(), bufferSize, connectorStatistics));
                         channel.resumeReceives();

File: core/src/main/java/io/undertow/server/protocol/spdy/SpdyPlainOpenListener.java
Patch:
@@ -90,7 +90,7 @@ public void handleEvent(final StreamConnection channel) {
         }
         if(statisticsEnabled) {
             channel.getSinkChannel().setConduit(new BytesSentStreamSinkConduit(channel.getSinkChannel().getConduit(), connectorStatistics.sentAccumulator()));
-            channel.getSourceChannel().setConduit(new BytesReceivedStreamSourceConduit(channel.getSourceChannel().getConduit(), connectorStatistics.sentAccumulator()));
+            channel.getSourceChannel().setConduit(new BytesReceivedStreamSourceConduit(channel.getSourceChannel().getConduit(), connectorStatistics.receivedAccumulator()));
         }
         spdy.getReceiveSetter().set(new SpdyReceiveListener(rootHandler, getUndertowOptions(), bufferSize, statisticsEnabled ? connectorStatistics : null));
         spdy.resumeReceives();

File: core/src/main/java/io/undertow/util/Cookies.java
Patch:
@@ -239,7 +239,7 @@ private static void parseCookie(final String cookie, final Map<String, Cookie> p
                         cookieCount = createCookie(name, cookie.substring(start, i), maxCookies, cookieCount, cookies, additional);
                         state = 0;
                         start = i + 1;
-                    } else if (c == '"') {
+                    } else if (c == '"' && start == i) { //only process the " if it is the first character
                         state = 3;
                         start = i + 1;
                     } else if (!allowEqualInValue && c == '=') {

File: core/src/main/java/io/undertow/websockets/core/protocol/version07/WebSocket07FrameSinkChannel.java
Patch:
@@ -58,6 +58,9 @@ protected WebSocket07FrameSinkChannel(WebSocket07Channel wsChannel, WebSocketFra
     @Override
     protected void handleFlushComplete(boolean finalFrame) {
         dataWritten = true;
+        if(masker != null) {
+            masker.setMaskingKey(maskingKey);
+        }
     }
 
 

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/WebSocketSessionRemoteEndpoint.java
Patch:
@@ -220,8 +220,8 @@ public void sendText(final String partialMessage, final boolean isLast) throws I
                 Channels.writeBlocking(textFrameSender, WebSocketUtils.fromUtf8String(partialMessage));
                 if(isLast) {
                     textFrameSender.shutdownWrites();
-                    Channels.flushBlocking(textFrameSender);
                 }
+                Channels.flushBlocking(textFrameSender);
             } finally {
                 if (isLast) {
                     textFrameSender = null;
@@ -242,8 +242,8 @@ public void sendBinary(final ByteBuffer partialByte, final boolean isLast) throw
                 Channels.writeBlocking(binaryFrameSender, partialByte);
                 if(isLast) {
                     binaryFrameSender.shutdownWrites();
-                    Channels.flushBlocking(binaryFrameSender);
                 }
+                Channels.flushBlocking(binaryFrameSender);
             } finally {
                 if (isLast) {
                     binaryFrameSender = null;

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/WebSocketSessionRemoteEndpoint.java
Patch:
@@ -308,7 +308,7 @@ public void sendPing(final ByteBuffer applicationData) throws IOException, Illeg
 
         @Override
         public void sendPong(final ByteBuffer applicationData) throws IOException, IllegalArgumentException {
-            WebSockets.sendPingBlocking(applicationData, webSocketChannel);
+            WebSockets.sendPongBlocking(applicationData, webSocketChannel);
         }
     }
 }

File: core/src/main/java/io/undertow/conduits/IdleTimeoutConduit.java
Patch:
@@ -46,7 +46,7 @@ public class IdleTimeoutConduit implements StreamSinkConduit, StreamSourceCondui
     private volatile XnioExecutor.Key handle;
     private volatile long idleTimeout;
     private volatile long expireTime = -1;
-    private volatile boolean timedOut = true;
+    private volatile boolean timedOut = false;
 
     private final StreamSinkConduit sink;
     private final StreamSourceConduit source;

File: core/src/main/java/io/undertow/security/handlers/AbstractConfidentialityHandler.java
Patch:
@@ -49,7 +49,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
 
                 exchange.setResponseCode(302);
                 exchange.getResponseHeaders().put(Headers.LOCATION, redirectUri.toString());
-            } catch (URISyntaxException e) {
+            } catch (Exception e) {
                 UndertowLogger.REQUEST_LOGGER.exceptionProcessingRequest(e);
                 exchange.setResponseCode(500);
             }

File: core/src/main/java/io/undertow/security/handlers/AbstractConfidentialityHandler.java
Patch:
@@ -49,7 +49,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
 
                 exchange.setResponseCode(302);
                 exchange.getResponseHeaders().put(Headers.LOCATION, redirectUri.toString());
-            } catch (URISyntaxException e) {
+            } catch (Exception e) {
                 UndertowLogger.REQUEST_LOGGER.exceptionProcessingRequest(e);
                 exchange.setResponseCode(500);
             }

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/WebSocketSessionRemoteEndpoint.java
Patch:
@@ -205,6 +205,7 @@ public void sendText(final String text) throws IOException {
         public void sendBinary(final ByteBuffer data) throws IOException {
             assertNotInFragment();
             WebSockets.sendBinaryBlocking(data, webSocketChannel);
+            data.clear(); //for some reason the TCK expects this, might as well just match the RI behaviour
         }
 
         @Override
@@ -248,6 +249,7 @@ public void sendBinary(final ByteBuffer partialByte, final boolean isLast) throw
                     binaryFrameSender = null;
                 }
             }
+            partialByte.clear();
         }
 
         @Override

File: core/src/main/java/io/undertow/protocols/http2/Http2FramePriority.java
Patch:
@@ -38,6 +38,9 @@ class Http2FramePriority implements FramePriority<Http2Channel, AbstractHttp2Str
     public boolean insertFrame(AbstractHttp2StreamSinkChannel newFrame, List<AbstractHttp2StreamSinkChannel> pendingFrames) {
         //first deal with flow control
         if (newFrame instanceof Http2StreamSinkChannel) {
+            if(newFrame.isBroken()) {
+                return true; //just quietly drop the frame
+            }
             SendFrameHeader header = ((Http2StreamSinkChannel) newFrame).generateSendFrameHeader();
             //if no header is generated then flow control means we can't send anything
             if (header.getByteBuffer() == null) {

File: core/src/main/java/io/undertow/server/protocol/http2/Http2OpenListener.java
Patch:
@@ -89,7 +89,7 @@ public void handleEvent(final StreamConnection channel) {
         final PotentialHttp2Connection potentialConnection = new PotentialHttp2Connection(channel);
         channel.getSourceChannel().setReadListener(potentialConnection);
         final SSLEngine sslEngine = JsseXnioSsl.getSslEngine((SslConnection) channel);
-        String existing = (String) sslEngine.getSession().getValue(PROTOCOL_KEY);
+        String existing = null;// (String) sslEngine.getSession().getValue(PROTOCOL_KEY);
         //resuming an existing session, no need for ALPN
         if (existing != null) {
             UndertowLogger.REQUEST_LOGGER.debug("Resuming existing session, not doing NPN negotiation");

File: core/src/test/java/io/undertow/server/ssl/ComplexSSLTestCase.java
Patch:
@@ -58,7 +58,7 @@ public class ComplexSSLTestCase {
     private static volatile String message;
 
     @Test
-    public void complexSSLTestCase() throws IOException, GeneralSecurityException, URISyntaxException {
+    public void complexSSLTestCase() throws IOException, GeneralSecurityException, URISyntaxException, InterruptedException {
         final PathHandler pathHandler = new PathHandler();
         File rootPath = new File(FileHandlerTestCase.class.getResource("page.html").toURI()).getParentFile();
 

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -321,7 +321,7 @@ private static void runInternal(final RunNotifier notifier) {
 
 
                 } else if (h2 && isAlpnEnabled()) {
-                    openListener = new Http2OpenListener(new DebuggingSlicePool(new ByteBufferSlicePool(BufferAllocator.DIRECT_BYTE_BUFFER_ALLOCATOR, 2* BUFFER_SIZE, 100 * BUFFER_SIZE)), OptionMap.create(UndertowOptions.ENABLE_SPDY, true), BUFFER_SIZE);
+                    openListener = new Http2OpenListener(new DebuggingSlicePool(new ByteBufferSlicePool(BufferAllocator.DIRECT_BYTE_BUFFER_ALLOCATOR, 2* BUFFER_SIZE, 100 * BUFFER_SIZE)), OptionMap.create(UndertowOptions.ENABLE_HTTP2, true, UndertowOptions.HTTP2_SETTINGS_ENABLE_PUSH, false), BUFFER_SIZE);
                     acceptListener = ChannelListeners.openListenerAdapter(wrapOpenListener(openListener));
 
                     SSLContext serverContext = createSSLContext(loadKeyStore(SERVER_KEY_STORE), loadKeyStore(SERVER_TRUST_STORE));
@@ -340,7 +340,7 @@ private static void runInternal(final RunNotifier notifier) {
 
 
                 } else if (h2c) {
-                    openListener = new HttpOpenListener(pool, OptionMap.create(UndertowOptions.BUFFER_PIPELINED_DATA, true), BUFFER_SIZE);
+                    openListener = new HttpOpenListener(pool, OptionMap.create(UndertowOptions.BUFFER_PIPELINED_DATA, true, UndertowOptions.HTTP2_SETTINGS_ENABLE_PUSH, false), BUFFER_SIZE);
                     acceptListener = ChannelListeners.openListenerAdapter(wrapOpenListener(openListener));
 
                     InetSocketAddress targetAddress = new InetSocketAddress(Inet4Address.getByName(getHostAddress(DEFAULT)), getHostPort(DEFAULT) + PROXY_OFFSET);

File: core/src/main/java/io/undertow/server/protocol/http/HttpRequestParser.java
Patch:
@@ -719,6 +719,9 @@ private void handleHeaderValueCacheMiss(ByteBuffer buffer, ParseState state, Htt
                         state.stringBuilder.setLength(0);
                         if (next == '\r') {
                             parseState = AWAIT_DATA_END;
+                        } else if (next == '\n') {
+                            state.state = ParseState.PARSE_COMPLETE;
+                            return;
                         } else {
                             state.state = ParseState.HEADER;
                             state.parseState = 0;

File: core/src/test/java/io/undertow/server/protocol/http/SimpleParserTestCase.java
Patch:
@@ -148,7 +148,7 @@ public void testCarriageReturnLineEnds() {
 
     @Test
     public void testLineFeedsLineEnds() {
-        byte[] in = "GET /somepath HTTP/1.1\nHost:   www.somehost.net\nOtherHeader: some\n    value\n\r\n".getBytes();
+        byte[] in = "GET /somepath HTTP/1.1\nHost:   www.somehost.net\nOtherHeader: some\n    value\n\n".getBytes();
         runTest(in);
     }
 

File: core/src/main/java/io/undertow/server/handlers/ResponseRateLimitingHandler.java
Patch:
@@ -118,7 +118,7 @@ private Wrapper(int bytes, long time, TimeUnit timeUnit) {
 
         @Override
         public HttpHandler wrap(HttpHandler handler) {
-            return new RequestDumpingHandler(handler);
+            return new ResponseRateLimitingHandler(handler, bytes, time, TimeUnit.MILLISECONDS);
         }
     }
 }

File: servlet/src/main/java/io/undertow/servlet/api/DeploymentInfo.java
Patch:
@@ -1134,8 +1134,8 @@ public DeploymentInfo clone() {
         info.disableCachingForSecuredPages = disableCachingForSecuredPages;
         info.exceptionHandler = exceptionHandler;
         info.escapeErrorMessage = escapeErrorMessage;
-        this.sessionListeners.addAll(sessionListeners);
-        this.lifecycleInterceptors.addAll(lifecycleInterceptors);
+        info.sessionListeners.addAll(sessionListeners);
+        info.lifecycleInterceptors.addAll(lifecycleInterceptors);
         return info;
     }
 

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/VirtualHost.java
Patch:
@@ -78,6 +78,9 @@ PathMatcher.PathMatch<HostEntry> match(String path){
                 }
             }
         }
+        if(defaultHandler.contexts.isEmpty()) {
+            return new PathMatcher.PathMatch<>(path, null);
+        }
         return new PathMatcher.PathMatch<>(path, defaultHandler);
     }
 

File: core/src/main/java/io/undertow/UndertowLogger.java
Patch:
@@ -146,8 +146,8 @@ public interface UndertowLogger extends BasicLogger {
     void couldNotInitiateSpdyConnection();
 
     @LogMessage(level = Logger.Level.ERROR)
-    @Message(id = 5026, value = "Jetty ALPN support not found on boot class path, SPDY client will not be available.")
-    void jettyALPNNotFound();
+    @Message(id = 5026, value = "Jetty ALPN support not found on boot class path, %s client will not be available.")
+    void jettyALPNNotFound(String protocol);
 
     @LogMessage(level = Logger.Level.ERROR)
     @Message(id = 5027, value = "Timing out request to %s")

File: core/src/main/java/io/undertow/client/http2/Http2ClientProvider.java
Patch:
@@ -73,7 +73,7 @@ public class Http2ClientProvider implements ClientProvider {
             Class<?> npnClass = Http2ClientProvider.class.getClassLoader().loadClass("org.eclipse.jetty.alpn.ALPN");
             npnPutMethod = npnClass.getDeclaredMethod("put", SSLEngine.class, Http2ClientProvider.class.getClassLoader().loadClass("org.eclipse.jetty.alpn.ALPN$Provider"));
         } catch (Exception e) {
-            UndertowLogger.CLIENT_LOGGER.jettyALPNNotFound();
+            UndertowLogger.CLIENT_LOGGER.jettyALPNNotFound("HTTP2");
             npnPutMethod = null;
         }
         ALPN_PUT_METHOD = npnPutMethod;

File: core/src/main/java/io/undertow/client/spdy/SpdyClientProvider.java
Patch:
@@ -76,7 +76,7 @@ public class SpdyClientProvider implements ClientProvider {
             Class<?> npnClass = SpdyClientProvider.class.getClassLoader().loadClass("org.eclipse.jetty.alpn.ALPN");
             npnPutMethod = npnClass.getDeclaredMethod("put", SSLEngine.class, SpdyClientProvider.class.getClassLoader().loadClass("org.eclipse.jetty.alpn.ALPN$Provider"));
         } catch (Exception e) {
-            UndertowLogger.CLIENT_LOGGER.jettyALPNNotFound();
+            UndertowLogger.CLIENT_LOGGER.jettyALPNNotFound("SPDY");
             npnPutMethod = null;
         }
         ALPN_PUT_METHOD = npnPutMethod;

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -548,6 +548,9 @@ protected String testName(FrameworkMethod method) {
             if(h2) {
                 sb.append("{http2}");
             }
+            if(h2c) {
+                sb.append("{http2-clear}");
+            }
             return sb.toString();
         }
     }

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedStreamSourceChannel.java
Patch:
@@ -160,7 +160,7 @@ public long transferTo(long count, ByteBuffer throughBuffer, StreamSinkChannel s
                         //we can still add more data
                         //stick it it throughbuffer, otherwise transfer code will continue to attempt to use this method
                         throughBuffer.clear();
-                        Buffers.copy(throughBuffer, data.getResource());
+                        frameDataRemaining -= Buffers.copy(throughBuffer, data.getResource());
                         throughBuffer.flip();
                     } else {
                         throughBuffer.position(throughBuffer.limit());

File: core/src/main/java/io/undertow/server/handlers/form/MultiPartParserDefinition.java
Patch:
@@ -325,6 +325,7 @@ public void run() {
                     final FormData existing = exchange.getAttachment(FORM_DATA);
                     if (existing != null) {
                         exchange.dispatch(SameThreadExecutor.INSTANCE, handler);
+                        return;
                     }
                     Pooled<ByteBuffer> pooled = exchange.getConnection().getBufferPool().allocate();
                     try {
@@ -334,6 +335,7 @@ public void run() {
                                 requestChannel.getReadSetter().set(new ChannelListener<StreamSourceChannel>() {
                                     @Override
                                     public void handleEvent(StreamSourceChannel channel) {
+                                        channel.suspendReads();
                                         executor.execute(NonBlockingParseTask.this);
                                     }
                                 });

File: core/src/main/java/io/undertow/protocols/spdy/SpdyChannel.java
Patch:
@@ -619,7 +619,7 @@ public long getFrameLength() {
 
         @Override
         public AbstractFramedStreamSourceChannel<?, ?, ?> getExistingChannel() {
-            if (type == SYN_STREAM) {
+            if (type == SYN_STREAM || type == WINDOW_UPDATE) {
                 return null;
             }
             int id;

File: core/src/main/java/io/undertow/protocols/spdy/SpdySynStreamStreamSourceChannel.java
Patch:
@@ -50,6 +50,7 @@ public class SpdySynStreamStreamSourceChannel extends SpdyStreamSourceChannel {
         this.deflater = deflater;
         this.headers = headers;
         this.streamId = streamId;
+        this.flowControlWindow = framedChannel.getInitialWindowSize();
     }
 
     public SpdySynReplyStreamSinkChannel getResponseChannel() {

File: core/src/main/java/io/undertow/protocols/http2/Http2Channel.java
Patch:
@@ -176,6 +176,7 @@ public Http2Channel(StreamConnection connectedStreamChannel, Pool<ByteBuffer> bu
 
         if(clientSide) {
             sendPreface();
+            prefaceCount = PREFACE_BYTES.length;
         }
         sendSettings();
     }

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -761,7 +761,7 @@ public static boolean isAjp() {
     }
 
     public static boolean isProxy() {
-        return proxy;
+        return proxy || spdy || https;
     }
 
     public static boolean isSpdy() {

File: core/src/main/java/io/undertow/protocols/spdy/SpdyChannel.java
Patch:
@@ -56,7 +56,7 @@
  */
 public class SpdyChannel extends AbstractFramedChannel<SpdyChannel, SpdyStreamSourceChannel, SpdyStreamSinkChannel> implements Attachable {
 
-    static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024 * 0124;
+    static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024;
 
     static final int SYN_STREAM = 1;
     static final int SYN_REPLY = 2;

File: core/src/main/java/io/undertow/protocols/spdy/SpdyChannel.java
Patch:
@@ -56,7 +56,7 @@
  */
 public class SpdyChannel extends AbstractFramedChannel<SpdyChannel, SpdyStreamSourceChannel, SpdyStreamSinkChannel> implements Attachable {
 
-    static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024 * 0124;
+    static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024;
 
     static final int SYN_STREAM = 1;
     static final int SYN_REPLY = 2;

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedChannel.java
Patch:
@@ -24,6 +24,7 @@
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 import java.util.ArrayDeque;
+import java.util.ArrayList;
 import java.util.Deque;
 import java.util.HashSet;
 import java.util.LinkedList;
@@ -817,7 +818,8 @@ public void run() {
                         //if this was a clean shutdown there should not be any senders
                         channel.markBroken();
                     }
-                    for(AbstractFramedStreamSourceChannel<C, R, S> r : receivers) {
+                    
+                    for(AbstractFramedStreamSourceChannel<C, R, S> r : new ArrayList<>(receivers)) {
                         IoUtils.safeClose(r);
                     }
                 }

File: core/src/main/java/io/undertow/server/handlers/PathTemplateHandler.java
Patch:
@@ -55,7 +55,7 @@ public PathTemplateHandler() {
     @Override
     public void handleRequest(HttpServerExchange exchange) throws Exception {
         PathTemplateMatcher.PathMatchResult<HttpHandler> match = pathTemplateMatcher.match(exchange.getRelativePath());
-        if (match.getValue() == null) {
+        if (match == null) {
             ResponseCodeHandler.HANDLE_404.handleRequest(exchange);
             return;
         }

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -482,7 +482,7 @@ protected void runChild(FrameworkMethod method, RunNotifier notifier) {
                 return;
             }
         }
-        if(spdy || spdyPlain || h2 || h2c) {
+        if(spdy || spdyPlain || h2 || h2c || ajp) {
             HttpOneOnly httpOneOnly = method.getAnnotation(HttpOneOnly.class);
             if(httpOneOnly == null) {
                 httpOneOnly = method.getMethod().getDeclaringClass().getAnnotation(HttpOneOnly.class);

File: core/src/main/java/io/undertow/server/handlers/PathTemplateHandler.java
Patch:
@@ -55,7 +55,7 @@ public PathTemplateHandler() {
     @Override
     public void handleRequest(HttpServerExchange exchange) throws Exception {
         PathTemplateMatcher.PathMatchResult<HttpHandler> match = pathTemplateMatcher.match(exchange.getRelativePath());
-        if (match.getValue() == null) {
+        if (match == null) {
             ResponseCodeHandler.HANDLE_404.handleRequest(exchange);
             return;
         }

File: servlet/src/main/java/io/undertow/servlet/spec/ServletPrintWriter.java
Patch:
@@ -228,7 +228,7 @@ public void write(final char[] buf, final int off, final int len) {
                 if (ok) {
                     return;
                 }
-                final CharBuffer cb = CharBuffer.wrap(buf, off + i, off + len);
+                final CharBuffer cb = CharBuffer.wrap(buf, i, len - (i - off));
                 write(cb);
                 return;
             } catch (IOException e) {
@@ -278,7 +278,8 @@ public void write(final String s, final int off, final int len) {
                 if (ok) {
                     return;
                 }
-                final CharBuffer cb = CharBuffer.wrap(s, off + i, off + len);
+                //wrap(String, off, len) acts wrong in the presence of multi byte characters
+                final CharBuffer cb = CharBuffer.wrap(s.toCharArray(), i, len - (i - off));
                 write(cb);
                 return;
             } catch (IOException e) {

File: core/src/main/java/io/undertow/server/handlers/accesslog/AccessLogHandler.java
Patch:
@@ -52,8 +52,7 @@
  * <li><b>%l</b> - Remote logical username from identd (always returns '-')
  * <li><b>%m</b> - Request method
  * <li><b>%p</b> - Local port
- * <li><b>%q</b> - Query string (prepended with a '?' if it exists, otherwise
- * an empty string
+ * <li><b>%q</b> - Query string (excluding the '?' character)
  * <li><b>%r</b> - First line of the request
  * <li><b>%s</b> - HTTP status code of the response
  * <li><b>%t</b> - Date and time, in Common Log Format format

File: servlet/src/main/java/io/undertow/servlet/core/SessionListenerBridge.java
Patch:
@@ -75,7 +75,7 @@ public void sessionDestroyed(final Session session, final HttpServerExchange exc
                 handle.tearDown();
             }
             ServletRequestContext current = SecurityActions.currentServletRequestContext();
-            if (current != null && current.getSession().getSession() == session) {
+            if (current != null && current.getSession() != null && current.getSession().getSession() == session) {
                 current.setSession(null);
             }
         }

File: servlet/src/main/java/io/undertow/servlet/core/SessionListenerBridge.java
Patch:
@@ -75,7 +75,7 @@ public void sessionDestroyed(final Session session, final HttpServerExchange exc
                 handle.tearDown();
             }
             ServletRequestContext current = SecurityActions.currentServletRequestContext();
-            if (current != null && current.getSession().getSession() == session) {
+            if (current != null && current.getSession() != null && current.getSession().getSession() == session) {
                 current.setSession(null);
             }
         }

File: core/src/main/java/io/undertow/server/protocol/http/HttpContinue.java
Patch:
@@ -161,13 +161,12 @@ private static void internalSendContinueResponse(final HttpServerExchange exchan
         try {
             responseChannel.shutdownWrites();
             if (!responseChannel.flush()) {
-                exchange.dispatch();
                 responseChannel.getWriteSetter().set(ChannelListeners.flushingChannelListener(
                         new ChannelListener<StreamSinkChannel>() {
                             @Override
                             public void handleEvent(StreamSinkChannel channel) {
-                                callback.onComplete(exchange, null);
                                 channel.suspendWrites();
+                                callback.onComplete(exchange, null);
                             }
                         }, new ChannelExceptionHandler<Channel>() {
                             @Override

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedStreamSourceChannel.java
Patch:
@@ -234,6 +234,7 @@ void resumeReadsInternal(boolean wakeup) {
                     @Override
                     public void run() {
                         try {
+                            boolean moreData;
                             do {
                                 ChannelListener<? super R> listener = getReadListener();
                                 if (listener == null || !isReadResumed()) {
@@ -243,7 +244,8 @@ public void run() {
                                 //if writes are shutdown or we become active then we stop looping
                                 //we stop when writes are shutdown because we can't flush until we are active
                                 //although we may be flushed as part of a batch
-                            } while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED) && frameDataRemaining > 0 && data != null);
+                                moreData = (frameDataRemaining > 0 &&  data != null) || !pendingFrameData.isEmpty();
+                            } while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED) && moreData);
                         } finally {
                             state &= ~STATE_IN_LISTENER_LOOP;
                         }

File: core/src/main/java/io/undertow/protocols/ajp/AjpClientChannel.java
Patch:
@@ -80,7 +80,7 @@ protected AbstractAjpClientStreamSourceChannel createChannel(FrameHeaderData fra
             return sourceChannel;
         } else if (frameHeaderData instanceof RequestBodyChunk) {
             RequestBodyChunk r = (RequestBodyChunk) frameHeaderData;
-            ((AjpClientRequestClientStreamSinkChannel) this.sink).chunkRequested(r.getLength());
+            this.sink.chunkRequested(r.getLength());
             frameData.free();
             return null;
         } else {

File: core/src/main/java/io/undertow/spdy/SpdySynReplyStreamSinkChannel.java
Patch:
@@ -53,6 +53,7 @@ protected SendFrameHeader createFrameHeaderImpl() {
             //flow control window is exhausted
             return new SendFrameHeader(getBuffer().remaining(), null);
         }
+        final boolean finalFrame = isWritesShutdown() && fcWindow >= getBuffer().remaining();
         Pooled<ByteBuffer> firstHeaderBuffer = getChannel().getBufferPool().allocate();
         Pooled<ByteBuffer>[] allHeaderBuffers = null;
         ByteBuffer firstBuffer = firstHeaderBuffer.getResource();
@@ -89,11 +90,11 @@ protected SendFrameHeader createFrameHeaderImpl() {
                 remainingInBuffer = getBuffer().remaining() - fcWindow;
                 getBuffer().limit(getBuffer().position() + fcWindow);
                 SpdyProtocolUtils.putInt(currentBuffer, getStreamId());
-                SpdyProtocolUtils.putInt(currentBuffer, ((isWritesShutdown() ? SpdyChannel.FLAG_FIN : 0) << 24) + fcWindow);
+                SpdyProtocolUtils.putInt(currentBuffer, ((finalFrame ? SpdyChannel.FLAG_FIN : 0) << 24) + fcWindow);
             } else {
                 remainingInBuffer = getBuffer().remaining();
             }
-        } else if(isWritesShutdown() && !firstFrame) {
+        } else if(finalFrame && !firstFrame) {
             SpdyProtocolUtils.putInt(currentBuffer, getStreamId());
             SpdyProtocolUtils.putInt(currentBuffer, SpdyChannel.FLAG_FIN  << 24);
         }

File: core/src/main/java/io/undertow/spdy/SpdySynStreamStreamSinkChannel.java
Patch:
@@ -49,6 +49,7 @@ protected SendFrameHeader createFrameHeaderImpl() {
         if (fcWindow == 0 && getBuffer().hasRemaining()) {
             return new SendFrameHeader(getBuffer().remaining(), null);
         }
+        final boolean finalFrame = isWritesShutdown() && fcWindow >= getBuffer().remaining();
         Pooled<ByteBuffer> firstHeaderBuffer = getChannel().getBufferPool().allocate();
         Pooled<ByteBuffer>[] allHeaderBuffers = null;
         ByteBuffer firstBuffer = firstHeaderBuffer.getResource();
@@ -85,8 +86,8 @@ protected SendFrameHeader createFrameHeaderImpl() {
                 currentBuffer = currentPooled.getResource();
             }
             SpdyProtocolUtils.putInt(currentBuffer, getStreamId());
-            SpdyProtocolUtils.putInt(currentBuffer, ((isWritesShutdown() ? SpdyChannel.FLAG_FIN : 0) << 24) + fcWindow);
-        } else if(isWritesShutdown() && !firstFrame) {
+            SpdyProtocolUtils.putInt(currentBuffer, ((finalFrame ? SpdyChannel.FLAG_FIN : 0) << 24) + fcWindow);
+        } else if(finalFrame && !firstFrame) {
             SpdyProtocolUtils.putInt(currentBuffer, getStreamId());
             SpdyProtocolUtils.putInt(currentBuffer, SpdyChannel.FLAG_FIN  << 24);
         }

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedChannel.java
Patch:
@@ -31,6 +31,7 @@
 import java.util.ListIterator;
 import java.util.Set;
 import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.LinkedBlockingDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import org.xnio.Buffers;
@@ -89,7 +90,7 @@ public abstract class AbstractFramedChannel<C extends AbstractFramedChannel<C, R
      * new frames to be sent. These will be added to either the pending or held frames list
      * depending on the {@link #framePriority} implementation in use.
      */
-    private final Deque<S> newFrames = new ArrayDeque<>();
+    private final Deque<S> newFrames = new LinkedBlockingDeque<>();
 
     private volatile long frameDataRemaining;
     private volatile R receiver;
@@ -528,7 +529,7 @@ protected synchronized void queueFrame(final S channel) throws IOException {
             throw UndertowMessages.MESSAGES.channelIsClosed();
         }
         newFrames.add(channel);
-        if (newFrames.peek() == channel && !flushingSenders) {
+        if (!flushingSenders) {
             if(channel.getIoThread() == Thread.currentThread()) {
                 flushSenders();
             } else {

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedStreamSinkChannel.java
Patch:
@@ -512,13 +512,13 @@ final void flushComplete() throws IOException {
             if (channelClosed && closeListener != null) {
                 ChannelListeners.invokeChannelListener(getIoThread(), (S) AbstractFramedStreamSinkChannel.this, closeListener);
             }
-            handleFlushComplete();
+            handleFlushComplete(channelClosed);
         } finally {
             wakeupWaiters();
         }
     }
 
-    protected void handleFlushComplete() {
+    protected void handleFlushComplete(boolean finalFrame) {
 
     }
 

File: core/src/main/java/io/undertow/spdy/SpdyStreamStreamSinkChannel.java
Patch:
@@ -90,8 +90,8 @@ protected final SendFrameHeader createFrameHeader() {
     }
 
     @Override
-    protected void handleFlushComplete() {
-        if(isFinalFrameQueued()) {
+    protected void handleFlushComplete(boolean finalFrame) {
+        if(finalFrame) {
             getChannel().removeStreamSink(getStreamId());
         }
     }

File: core/src/main/java/io/undertow/spdy/SpdySynReplyStreamSinkChannel.java
Patch:
@@ -136,9 +136,9 @@ public HeaderMap getHeaders() {
     }
 
     @Override
-    protected void handleFlushComplete() {
-        super.handleFlushComplete();
-        if (isFinalFrameQueued()) {
+    protected void handleFlushComplete(boolean finalFrame) {
+        super.handleFlushComplete(finalFrame);
+        if (finalFrame) {
             if (completionListener != null) {
                 ChannelListeners.invokeChannelListener(this, completionListener);
             }

File: core/src/main/java/io/undertow/websockets/core/protocol/version07/WebSocket07FrameSinkChannel.java
Patch:
@@ -56,7 +56,7 @@ protected WebSocket07FrameSinkChannel(WebSocket07Channel wsChannel, WebSocketFra
     }
 
     @Override
-    protected void handleFlushComplete() {
+    protected void handleFlushComplete(boolean finalFrame) {
         dataWritten = true;
     }
 

File: core/src/main/java/io/undertow/util/QueryParameterUtils.java
Patch:
@@ -97,7 +97,7 @@ public static Map<String, Deque<String>> parseQueryString(final String newQueryS
                 needsDecode = false;
                 startPos = i + 1;
                 equalPos = -1;
-            } else if(c == '%' && encoding != null) {
+            } else if((c == '%' || c == '+') && encoding != null) {
                 needsDecode = true;
             }
         }

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedStreamSourceChannel.java
Patch:
@@ -19,6 +19,7 @@
 package io.undertow.server.protocol.framed;
 
 import static org.xnio.Bits.allAreClear;
+import static org.xnio.Bits.allAreSet;
 import static org.xnio.Bits.anyAreSet;
 
 import java.io.IOException;
@@ -242,7 +243,7 @@ public void run() {
                                 //if writes are shutdown or we become active then we stop looping
                                 //we stop when writes are shutdown because we can't flush until we are active
                                 //although we may be flushed as part of a batch
-                            } while (allAreClear(state, STATE_CLOSED) && frameDataRemaining > 0 && data != null);
+                            } while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED) && frameDataRemaining > 0 && data != null);
                         } finally {
                             state &= ~STATE_IN_LISTENER_LOOP;
                         }

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -35,6 +35,8 @@
 import io.undertow.util.NetworkUtils;
 import io.undertow.util.SingleByteStreamSinkConduit;
 import io.undertow.util.SingleByteStreamSourceConduit;
+
+import org.junit.Ignore;
 import org.junit.runner.Description;
 import org.junit.runner.Result;
 import org.junit.runner.notification.Failure;
@@ -365,7 +367,7 @@ public void testRunFinished(final Result result) throws Exception {
 
     @Override
     protected Description describeChild(FrameworkMethod method) {
-        if (runs > 1) {
+        if (runs > 1 && method.getAnnotation(Ignore.class) == null) {
             return describeRepeatTest(method);
         }
         return super.describeChild(method);

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -308,4 +308,7 @@ public interface UndertowMessages {
 
     @Message(id = 94, value = "Blocking await method called from IO thread. Blocking IO must be dispatched to a worker thread or deadlocks will result.")
     IOException awaitCalledFromIoThread();
+
+    @Message(id = 95, value = "Recursive call to flushSenders()")
+    RuntimeException recursiveCallToFlushingSenders();
 }

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedStreamSourceChannel.java
Patch:
@@ -266,6 +266,7 @@ protected void lastFrame() {
         waitingForFrame = false;
         if(data == null && pendingFrameData.isEmpty() && frameDataRemaining == 0) {
             state |= STATE_DONE | STATE_CLOSED;
+            getFramedChannel().notifyFrameReadComplete(this);
         }
     }
 

File: core/src/test/java/io/undertow/server/handlers/encoding/GzipContentEncodingTestCase.java
Patch:
@@ -95,7 +95,7 @@ public void testSmallMessagePredicateDoesNotCompress() throws IOException {
     }
 
     @Test
-    public void testDeflateEncodingBigResponse() throws IOException {
+    public void testGZipEncodingLargeResponse() throws IOException {
         final StringBuilder messageBuilder = new StringBuilder(691963);
         for (int i = 0; i < 691963; ++i) {
             messageBuilder.append("*");

File: core/src/main/java/io/undertow/server/handlers/accesslog/DefaultAccessLogReceiver.java
Patch:
@@ -166,7 +166,7 @@ private void writeMessage(final List<String> messages) {
         }
         try {
             if (writer == null) {
-                writer = new BufferedWriter(new FileWriter(defaultLogFile));
+                writer = new BufferedWriter(new FileWriter(defaultLogFile, true));
             }
             for (String message : messages) {
                 writer.write(message);

File: websockets-jsr/src/test/java/io/undertow/websockets/jsr/test/JsrWebSocketServer07Test.java
Patch:
@@ -660,7 +660,6 @@ public void testErrorHandling() throws Exception {
         Assert.assertTrue(c.isOpen());
         ((UndertowSession)session).forceClose();
         Assert.assertEquals("CLOSED", ProgramaticErrorEndpoint.getMessage());
-        Assert.assertFalse(c.isOpen());
 
     }
 

File: websockets-jsr/src/test/java/io/undertow/websockets/jsr/test/annotated/AnnotatedEndpointTest.java
Patch:
@@ -189,7 +189,6 @@ public void testErrorHandling() throws Exception {
         Assert.assertTrue(c.isOpen());
         ((UndertowSession)session).forceClose();
         Assert.assertEquals("CLOSED", ErrorEndpoint.getMessage());
-        Assert.assertFalse(c.isOpen());
 
     }
 

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpServerRequestConduit.java
Patch:
@@ -234,9 +234,9 @@ private int doRead(final ByteBuffer dst, long state) throws IOException {
             chunkRemaining = this.state & STATE_MASK;
         }
 
-        int limit = dst.limit();
+        int limit = dst.remaining();
         try {
-            if (limit > chunkRemaining) {
+            if (dst.remaining() > chunkRemaining) {
                 dst.limit((int) (dst.position() + chunkRemaining));
             }
             int read = next.read(dst);

File: servlet/src/test/java/io/undertow/servlet/test/streams/ServletOutputStreamTestCase.java
Patch:
@@ -159,7 +159,9 @@ public void runTest(final String message, String url, final boolean flush, final
                 builder.append(message);
             }
             final String response = HttpClientUtils.readResponse(result);
-            Assert.assertEquals(builder.toString(), response);
+            String expected = builder.toString();
+            Assert.assertEquals(expected.length(), response.length());
+            Assert.assertEquals(expected, response);
         } finally {
             client.getConnectionManager().shutdown();
         }

File: servlet/src/main/java/io/undertow/servlet/spec/ServletOutputStreamImpl.java
Patch:
@@ -792,6 +792,7 @@ public void handleEvent(final StreamSinkChannel aChannel) {
                     }
                 } while (written < toWrite);
                 buffersToWrite = null;
+                buffer.clear();
             }
             if (pendingFile != null) {
                 try {

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpServerResponseConduit.java
Patch:
@@ -83,6 +83,7 @@ final class AjpServerResponseConduit extends AbstractFramedStreamSinkConduit {
     private static final int FLAG_WRITE_RESUMED = 1 << 2;
     private static final int FLAG_WRITE_READ_BODY_CHUNK_FROM_LISTENER = 1 << 3;
     private static final int FLAG_WRITE_SHUTDOWN = 1 << 4;
+    private static final int FLAG_READS_DONE = 1 << 5;
 
     private static final ByteBuffer CLOSE_FRAME_PERSISTENT;
     private static final ByteBuffer CLOSE_FRAME_NON_PERSISTENT;

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedChannel.java
Patch:
@@ -230,7 +230,7 @@ public InetSocketAddress getDestinationAddress() {
      * of calling this method then it can prevent frame channels for being fully consumed.
      */
     public synchronized R receive() throws IOException {
-        if (isLastFrameReceived()) {
+        if (isLastFrameReceived() && receiver == null) {
             //we have received the last frame, we just shut down and return
             //it would probably make more sense to have the last channel responsible for this
             //however it is much simpler just to have it here
@@ -690,7 +690,7 @@ private final class FrameReadListener implements ChannelListener<StreamSourceCha
         @Override
         public void handleEvent(final StreamSourceChannel channel) {
             final R receiver = AbstractFramedChannel.this.receiver;
-            if (isLastFrameReceived() || receivesSuspended) {
+            if ((isLastFrameReceived() || receivesSuspended) && receiver == null) {
                 channel.suspendReads();
                 return;
             } else {

File: core/src/main/java/io/undertow/websockets/core/BufferedBinaryMessage.java
Patch:
@@ -97,6 +97,9 @@ public void read(final StreamSourceFrameChannel channel, final WebSocketCallback
                     channel.getReadSetter().set(new ChannelListener<StreamSourceFrameChannel>() {
                         @Override
                         public void handleEvent(StreamSourceFrameChannel channel) {
+                            if(complete ) {
+                                return;
+                            }
                             try {
                                 for (; ; ) {
                                     if (current == null) {

File: core/src/main/java/io/undertow/websockets/core/BufferedTextMessage.java
Patch:
@@ -115,6 +115,9 @@ public void read(final StreamSourceFrameChannel channel, final WebSocketCallback
                         channel.getReadSetter().set(new ChannelListener<StreamSourceFrameChannel>() {
                             @Override
                             public void handleEvent(StreamSourceFrameChannel channel) {
+                                if(complete ) {
+                                    return;
+                                }
                                 Pooled<ByteBuffer> pooled = channel.getWebSocketChannel().getBufferPool().allocate();
                                 final ByteBuffer buffer = pooled.getResource();
                                 try {

File: websockets-jsr/src/test/java/io/undertow/websockets/jsr/test/annotated/TimeoutEndpoint.java
Patch:
@@ -53,7 +53,7 @@ public void close(CloseReason c) {
     }
 
     public static  CloseReason getReason() throws InterruptedException {
-        closeLatch.await(10, TimeUnit.MINUTES);
+        closeLatch.await(10, TimeUnit.SECONDS);
         return closeReason;
     }
 

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedChannel.java
Patch:
@@ -284,6 +284,9 @@ public synchronized R receive() throws IOException {
                         pooled.free();
                     }
                     readData = null;
+                    if(frameDataRemaining == 0) {
+                        receiver = null;
+                    }
                     return null;
                 } else {
                     ByteBuffer buf = pooled.getResource().duplicate();

File: core/src/main/java/io/undertow/server/handlers/proxy/ProxyHandler.java
Patch:
@@ -518,6 +518,7 @@ private IoExceptionHandler(HttpServerExchange exchange, ClientConnection clientC
 
         @Override
         public void handleException(Channel channel, IOException exception) {
+            IoUtils.safeClose(channel);
             if (exchange.isResponseStarted()) {
                 IoUtils.safeClose(clientConnection);
                 UndertowLogger.REQUEST_IO_LOGGER.debug("Exception reading from target server", exception);

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedStreamSourceChannel.java
Patch:
@@ -533,6 +533,9 @@ public void close() throws IOException {
             data.free();
             data = null;
         }
+        while (!pendingFrameData.isEmpty()) {
+            pendingFrameData.poll().frameData.free();
+        }
         ChannelListeners.invokeChannelListener(this, (ChannelListener<? super AbstractFramedStreamSourceChannel<C, R, S>>) closeSetter.get());
     }
 

File: core/src/main/java/io/undertow/server/BlockingHttpExchange.java
Patch:
@@ -18,6 +18,7 @@
 
 package io.undertow.server;
 
+import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -30,7 +31,7 @@
  *
  * @author Stuart Douglas
  */
-public interface BlockingHttpExchange {
+public interface BlockingHttpExchange extends Closeable {
 
     /**
      * Returns the input stream that is in use for this exchange.

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -235,7 +235,7 @@ public void testFinished(Description description) throws Exception {
                     }
                     for(DebuggingSlicePool.DebuggingBuffer b : DebuggingSlicePool.BUFFERS) {
                         b.getAllocationPoint().printStackTrace();
-                        notifier.fireTestFailure(new Failure(description,  new RuntimeException(b.getLabel(), b.getAllocationPoint())));
+                        notifier.fireTestFailure(new Failure(description,  new RuntimeException("Buffer Leak " + b.getLabel(), b.getAllocationPoint())));
                     }
                     DebuggingSlicePool.BUFFERS.clear();
                 }

File: core/src/main/java/io/undertow/server/handlers/proxy/mod_cluster/MCMPHandler.java
Patch:
@@ -131,6 +131,8 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
         final InetSocketAddress addr = exchange.getDestinationAddress();
         //we use getHostString to avoid a reverse lookup
         if (addr.getPort() != config.getManagementPort() || !addr.getHostString().equals(config.getManagementHost())) {
+            //temporary log statement to see what is going on with CI
+            UndertowLogger.REQUEST_LOGGER.error("Failed to match request on port " + addr.getPort() + " with " + config.getManagementPort() + " and host " + addr.getHostString() + " with " + config.getManagementHost());
             next.handleRequest(exchange);
             return;
         }

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedStreamSourceChannel.java
Patch:
@@ -271,9 +271,9 @@ protected void lastFrame() {
 
     @Override
     public void awaitReadable() throws IOException {
-        if (data == null) {
+        if (data == null && pendingFrameData.isEmpty()) {
             synchronized (lock) {
-                if (data == null) {
+                if (data == null && pendingFrameData.isEmpty()) {
                     try {
                         waiters++;
                         lock.wait();

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletInitialHandler.java
Patch:
@@ -34,7 +34,6 @@
 import io.undertow.servlet.spec.HttpServletResponseImpl;
 import io.undertow.servlet.spec.RequestDispatcherImpl;
 import io.undertow.servlet.spec.ServletContextImpl;
-import io.undertow.util.HeaderValues;
 import io.undertow.util.Headers;
 import io.undertow.util.HttpString;
 import io.undertow.util.Protocols;

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -1575,6 +1575,7 @@ public HttpServerExchange setMaxEntitySize(final long maxEntitySize) {
             throw UndertowMessages.MESSAGES.requestChannelAlreadyProvided();
         }
         this.maxEntitySize = maxEntitySize;
+        connection.maxEntitySizeUpdated(this);
         return this;
     }
 

File: core/src/main/java/io/undertow/server/protocol/spdy/SpdyReceiveListener.java
Patch:
@@ -94,6 +94,7 @@ public void handleEvent(SpdyChannel channel) {
 
 
                 final HttpServerExchange exchange = new HttpServerExchange(connection, dataChannel.getHeaders(), dataChannel.getResponseChannel().getHeaders(), maxEntitySize);
+                dataChannel.setMaxStreamSize(maxEntitySize);
                 exchange.setRequestScheme(exchange.getRequestHeaders().getFirst(SCHEME));
                 exchange.setProtocol(new HttpString(exchange.getRequestHeaders().getFirst(VERSION)));
                 exchange.setRequestMethod(new HttpString(exchange.getRequestHeaders().getFirst(METHOD)));

File: core/src/main/java/io/undertow/spdy/SpdyRstStreamSinkChannel.java
Patch:
@@ -46,6 +46,7 @@ protected SendFrameHeader createFrameHeader() {
         SpdyProtocolUtils.putInt(buf, 8);
         SpdyProtocolUtils.putInt(buf, streamId);
         SpdyProtocolUtils.putInt(buf, statusCode);
+        buf.flip();
         return new SendFrameHeader(new ImmediatePooled<>(buf));
     }
 

File: core/src/main/java/io/undertow/spdy/SpdyStreamSourceChannel.java
Patch:
@@ -33,8 +33,6 @@
  */
 public class SpdyStreamSourceChannel extends AbstractFramedStreamSourceChannel<SpdyChannel, SpdyStreamSourceChannel, SpdyStreamSinkChannel> {
 
-    private boolean reset = true;
-
     SpdyStreamSourceChannel(AbstractFramedChannel<SpdyChannel, SpdyStreamSourceChannel, SpdyStreamSinkChannel> framedChannel) {
         super(framedChannel);
     }
@@ -66,6 +64,8 @@ protected void lastFrame() {
     }
 
     void rstStream() {
-        super.markStreamBroken();
+        //noop by default
     }
+
+
 }

File: core/src/main/java/io/undertow/spdy/SpdyHeaderBlockParser.java
Patch:
@@ -145,7 +145,7 @@ private void handleDecompressedData(ByteBuffer data) throws IOException {
                     this.partialValue = null;
                 } else {
                     remainingData = remainingData - data.remaining();
-                    partialValue.write(data.array(), data.arrayOffset() + data.remaining(), data.remaining());
+                    partialValue.write(data.array(), data.arrayOffset() + data.position(), data.remaining());
                     data.clear();
                     return;
                 }
@@ -211,7 +211,7 @@ private void handleDecompressedData(ByteBuffer data) throws IOException {
                 } else {
                     remainingData = remainingData - data.remaining();
                     partialValue = new ByteArrayOutputStream();
-                    partialValue.write(data.array(), data.arrayOffset() + data.remaining(), data.remaining());
+                    partialValue.write(data.array(), data.arrayOffset() + data.position(), data.remaining());
                     data.clear();
                     return;
                 }

File: core/src/main/java/io/undertow/spdy/SpdyHeaderBlockParser.java
Patch:
@@ -167,7 +167,7 @@ private void handleDecompressedData(ByteBuffer data) throws IOException {
                     byte[] array = data.array();
                     for (int i = start; i < end; ++i) {
                         if (array[i] == 0) {
-                            headerMap.add(currentHeader, new String(array, start, i - start - 1, "UTF-8"));
+                            headerMap.add(currentHeader, new String(array, start, i - start, "UTF-8"));
                             start = i + 1;
                         }
                     }

File: core/src/main/java/io/undertow/client/spdy/SpdyClientProvider.java
Patch:
@@ -239,7 +239,7 @@ public void handleEvent(StreamSourceChannel channel) {
     }
 
     private static SpdyClientConnection createSpdyChannel(StreamConnection connection, Pool<ByteBuffer> bufferPool) {
-        SpdyChannel spdyChannel = new SpdyChannel(connection, bufferPool, null, new ByteBufferSlicePool(BufferAllocator.BYTE_BUFFER_ALLOCATOR, 8192, 8192));
+        SpdyChannel spdyChannel = new SpdyChannel(connection, bufferPool, null, new ByteBufferSlicePool(BufferAllocator.BYTE_BUFFER_ALLOCATOR, 8192, 8192), true);
         return new SpdyClientConnection(spdyChannel);
     }
 

File: core/src/main/java/io/undertow/server/protocol/spdy/SpdyOpenListener.java
Patch:
@@ -105,7 +105,7 @@ public void handleEvent(final StreamConnection channel) {
         if (existing != null) {
             UndertowLogger.REQUEST_LOGGER.debug("Resuming existing session, not doing NPN negotiation");
             if(existing.equals(SPDY_3_1) || existing.equals(SPDY_3)) {
-                SpdyChannel sc = new SpdyChannel(channel, bufferPool, new ImmediatePooled<>(ByteBuffer.wrap(new byte[0])), heapBufferPool);
+                SpdyChannel sc = new SpdyChannel(channel, bufferPool, new ImmediatePooled<>(ByteBuffer.wrap(new byte[0])), heapBufferPool, false);
                 sc.getReceiveSetter().set(new SpdyReceiveListener(rootHandler, getUndertowOptions(), bufferSize));
                 sc.resumeReceives();
             } else {
@@ -194,7 +194,7 @@ public void handleEvent(StreamSourceChannel source) {
 
                         NextProtoNego.remove(JsseXnioSsl.getSslEngine((SslConnection) channel));
                         //cool, we have a spdy connection.
-                        SpdyChannel channel = new SpdyChannel(this.channel, bufferPool, buffer, heapBufferPool);
+                        SpdyChannel channel = new SpdyChannel(this.channel, bufferPool, buffer, heapBufferPool, false);
                         Integer idleTimeout = undertowOptions.get(UndertowOptions.IDLE_TIMEOUT);
                         if(idleTimeout != null && idleTimeout > 0) {
                             channel.setIdleTimeout(idleTimeout);

File: servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java
Patch:
@@ -245,9 +245,9 @@ private void serveFileBlocking(final HttpServletRequest req, final HttpServletRe
         //we are going to proceed. Set the appropriate headers
         final String contentType = deployment.getServletContext().getMimeType(resource.getName());
         if (contentType != null) {
-            resp.setHeader(Headers.CONTENT_TYPE_STRING, contentType);
+            resp.setContentType(contentType);
         } else {
-            resp.setHeader(Headers.CONTENT_TYPE_STRING, "application/octet-stream");
+            resp.setContentType("application/octet-stream");
         }
         if (lastModified != null) {
             resp.setHeader(Headers.LAST_MODIFIED_STRING, resource.getLastModifiedString());

File: core/src/main/java/io/undertow/io/UndertowOutputStream.java
Patch:
@@ -313,6 +313,9 @@ public void close() throws IOException {
             if (channel == null) {
                 channel = exchange.getResponseChannel();
             }
+            if(channel == null) {
+                return;
+            }
             StreamSinkChannel channel = this.channel;
             channel.shutdownWrites();
             Channels.flushBlocking(channel);

File: core/src/main/java/io/undertow/server/Connectors.java
Patch:
@@ -80,7 +80,9 @@ public void exchangeEvent(HttpServerExchange exchange, NextListener nextListener
                 Pooled<ByteBuffer>[] bufs = exchange.getAttachment(HttpServerExchange.BUFFERED_REQUEST_DATA);
                 if (bufs != null) {
                     for (Pooled<ByteBuffer> i : bufs) {
-                        i.free();
+                        if(i != null) {
+                            i.free();
+                        }
                     }
                 }
                 nextListener.proceed();

File: core/src/main/java/io/undertow/spdy/SpdyChannel.java
Patch:
@@ -491,6 +491,7 @@ public long getFrameLength() {
     private class SpdyControlMessageExceptionHandler implements ChannelExceptionHandler<SpdyStreamSinkChannel> {
         @Override
         public void handleException(SpdyStreamSinkChannel channel, IOException exception) {
+            IoUtils.safeClose(channel);
             handleBrokenSinkChannel(exception);
         }
     }

File: core/src/main/java/io/undertow/server/handlers/ProxyPeerAddressHandler.java
Patch:
@@ -50,7 +50,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
             if (index == -1) {
                 value = forwardedFor;
             } else {
-                value = forwardedFor.substring(0, index - 1);
+                value = forwardedFor.substring(0, index);
             }
             InetAddress address = InetAddress.getByName(value);
             //we have no way of knowing the port

File: core/src/test/java/io/undertow/server/handlers/form/FormDataParserTestCase.java
Patch:
@@ -115,9 +115,9 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
     @Test
     public void testFormDataParsing() throws Exception {
         runTest(new BasicNameValuePair("name", "A Value"));
-        runTest(new BasicNameValuePair("name", "A Value"), new BasicNameValuePair("Single value", null));
+        runTest(new BasicNameValuePair("name", "A Value"), new BasicNameValuePair("Single-value", null));
         runTest(new BasicNameValuePair("name", "A Value"), new BasicNameValuePair("A/name/with_special*chars", "A $ value&& with=SomeCharacters"));
-        runTest(new BasicNameValuePair("name", "A Value"), new BasicNameValuePair("Single value", null) , new BasicNameValuePair("A/name/with_special*chars", "A $ value&& with=SomeCharacters"));
+        runTest(new BasicNameValuePair("name", "A Value"), new BasicNameValuePair("Single-value", null) , new BasicNameValuePair("A/name/with_special*chars", "A $ value&& with=SomeCharacters"));
 
     }
 

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -299,4 +299,7 @@ public interface UndertowMessages {
 
     @Message(id = 91, value = "Buffer has already been freed")
     IllegalStateException bufferAlreadyFreed();
+
+    @Message(id = 92, value = "A SPDY header was too large to fit in a response buffer, if you want to support larger headers please increase the buffer size")
+    IllegalStateException headersTooLargeToFitInHeapBuffer();
 }

File: core/src/main/java/io/undertow/spdy/SpdyHeaderBlockParser.java
Patch:
@@ -174,7 +174,7 @@ private void handleDecompressedData(ByteBuffer data) throws IOException {
                 } else {
                     remainingData = valueLength - data.remaining();
                     int start = data.arrayOffset() + data.position();
-                    int end = start + valueLength;
+                    int end = start + data.remaining();
                     byte[] array = data.array();
                     for (int i = start; i < end; ++i) {
                         if (array[i] == 0) {

File: core/src/test/java/io/undertow/server/handlers/form/FormDataParserTestCase.java
Patch:
@@ -115,7 +115,9 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
     @Test
     public void testFormDataParsing() throws Exception {
         runTest(new BasicNameValuePair("name", "A Value"));
+        runTest(new BasicNameValuePair("name", "A Value"), new BasicNameValuePair("Single value", null));
         runTest(new BasicNameValuePair("name", "A Value"), new BasicNameValuePair("A/name/with_special*chars", "A $ value&& with=SomeCharacters"));
+        runTest(new BasicNameValuePair("name", "A Value"), new BasicNameValuePair("Single value", null) , new BasicNameValuePair("A/name/with_special*chars", "A $ value&& with=SomeCharacters"));
 
     }
 
@@ -142,7 +144,7 @@ private void runTest(final NameValuePair... pairs) throws Exception {
 
     private void checkResult(final List<NameValuePair> data, final HttpResponse result) {
         for (NameValuePair vp : data) {
-            Assert.assertEquals(vp.getValue(), result.getHeaders(vp.getName())[0].getValue());
+            Assert.assertEquals(vp.getValue() == null ? "" : vp.getValue(), result.getHeaders(vp.getName())[0].getValue());
         }
     }
 

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/EndpointSessionHandler.java
Patch:
@@ -78,7 +78,7 @@ public void onConnect(WebSocketHttpExchange exchange, WebSocketChannel channel)
             config.getOpenSessions().add(session);
             session.setMaxBinaryMessageBufferSize(getContainer().getDefaultMaxBinaryMessageBufferSize());
             session.setMaxTextMessageBufferSize(getContainer().getDefaultMaxTextMessageBufferSize());
-            //session.setTimeout(getContainer().getMaxSessionIdleTimeout());
+            session.setMaxIdleTimeout(getContainer().getDefaultMaxSessionIdleTimeout());
             session.getAsyncRemote().setSendTimeout(getContainer().getDefaultAsyncSendTimeout());
             try {
                 instance.getInstance().onOpen(session, config.getEndpointConfiguration());

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/ServerWebSocketContainer.java
Patch:
@@ -91,7 +91,7 @@ public class ServerWebSocketContainer implements ServerContainer, Closeable {
     private final boolean dispatchToWorker;
 
     private volatile long defaultAsyncSendTimeout;
-    private volatile long maxSessionIdleTimeout;
+    private volatile long defaultMaxSessionIdleTimeout;
     private volatile int defaultMaxBinaryMessageBufferSize;
     private volatile int defaultMaxTextMessageBufferSize;
     private volatile boolean deploymentComplete = false;
@@ -249,12 +249,12 @@ private Session connectToServerInternal(final Endpoint endpointInstance, XnioSsl
 
     @Override
     public long getDefaultMaxSessionIdleTimeout() {
-        return maxSessionIdleTimeout;
+        return defaultMaxSessionIdleTimeout;
     }
 
     @Override
     public void setDefaultMaxSessionIdleTimeout(final long timeout) {
-        this.maxSessionIdleTimeout = timeout;
+        this.defaultMaxSessionIdleTimeout = timeout;
     }
 
     @Override

File: servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java
Patch:
@@ -74,7 +74,6 @@ public class DefaultServlet extends HttpServlet {
     public static final String RESOLVE_AGAINST_CONTEXT_ROOT = "resolve-against-context-root";
 
     private static final Set<String> DEFAULT_ALLOWED_EXTENSIONS = Collections.unmodifiableSet(new HashSet<>(Arrays.asList("js", "css", "png", "jpg", "gif", "html", "htm", "txt", "pdf", "jpeg", "xml")));
-    private static final Set<String> DEFAULT_DISALLOWED_EXTENSIONS = Collections.unmodifiableSet(new HashSet<>(Arrays.asList("class", "jar", "war")));
 
 
     private Deployment deployment;
@@ -83,7 +82,7 @@ public class DefaultServlet extends HttpServlet {
 
     private boolean defaultAllowed = true;
     private Set<String> allowed = DEFAULT_ALLOWED_EXTENSIONS;
-    private Set<String> disallowed = DEFAULT_DISALLOWED_EXTENSIONS;
+    private Set<String> disallowed = Collections.emptySet();
     private boolean resolveAgainstContextRoot;
 
     @Override

File: core/src/main/java/io/undertow/util/MimeMappings.java
Patch:
@@ -112,6 +112,7 @@ public class MimeMappings {
         defaultMappings.put("aiff", "audio/x-aiff");
         defaultMappings.put("aifc", "audio/x-aiff");
         defaultMappings.put("wav", "audio/x-wav");
+        defaultMappings.put("mp3", "audio/mpeg");
         defaultMappings.put("mpeg", "video/mpeg");
         defaultMappings.put("mpg", "video/mpeg");
         defaultMappings.put("mpe", "video/mpeg");

File: core/src/main/java/io/undertow/util/MimeMappings.java
Patch:
@@ -50,6 +50,7 @@ public class MimeMappings {
         defaultMappings.put("rtx", "text/richtext");
         defaultMappings.put("tsv", "text/tab-separated-values");
         defaultMappings.put("etx", "text/x-setext");
+        defaultMappings.put("json", "application/json");
         defaultMappings.put("ps", "application/x-postscript");
         defaultMappings.put("class", "application/java");
         defaultMappings.put("csh", "application/x-csh");

File: core/src/main/java/io/undertow/util/HexConverter.java
Patch:
@@ -135,7 +135,7 @@ public static void main(String[] args) {
 
         byte[] convertedBack = convertFromHex(hexValue);
 
-        StringBuffer sb = new StringBuffer();
+        StringBuilder sb = new StringBuilder();
         for (byte current : convertedBack) {
             sb.append((int)current).append(" ");
         }

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletInitialHandler.java
Patch:
@@ -286,7 +286,7 @@ public void handleFirstRequest(final HttpServerExchange exchange, final ServletC
                         if (location != null) {
                             RequestDispatcherImpl dispatcher = new RequestDispatcherImpl(location, servletContext);
                             try {
-                                dispatcher.error(request, response, servletChain.getManagedServlet().getServletInfo().getName(), t);
+                                dispatcher.error(servletRequestContext, request, response, servletChain.getManagedServlet().getServletInfo().getName(), t);
                             } catch (Exception e) {
                                 UndertowLogger.REQUEST_LOGGER.exceptionGeneratingErrorPage(e, location);
                             }

File: servlet/src/main/java/io/undertow/servlet/spec/AsyncContextImpl.java
Patch:
@@ -295,13 +295,15 @@ public synchronized void completeInternal() {
                 //at all other times the dispatch is desirable
                 HttpServletResponseImpl response = servletRequestContext.getOriginalResponse();
                 response.responseDone();
+                IoUtils.safeClose(exchange.getInputStream());
             } else {
                 doDispatch(new Runnable() {
                     @Override
                     public void run() {
 
                         HttpServletResponseImpl response = servletRequestContext.getOriginalResponse();
                         response.responseDone();
+                        IoUtils.safeClose(exchange.getInputStream());
                     }
                 });
             }

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -125,7 +125,7 @@ public void sendError(final int sc, final String msg) throws IOException {
             RequestDispatcherImpl requestDispatcher = new RequestDispatcherImpl(location, servletContext);
             final ServletRequestContext servletRequestContext = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY);
             try {
-                requestDispatcher.error(servletRequestContext.getServletRequest(), servletRequestContext.getServletResponse(), exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY).getCurrentServlet().getManagedServlet().getServletInfo().getName(), msg);
+                requestDispatcher.error(servletRequestContext, servletRequestContext.getServletRequest(), servletRequestContext.getServletResponse(), exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY).getCurrentServlet().getManagedServlet().getServletInfo().getName(), msg);
             } catch (ServletException e) {
                 throw new RuntimeException(e);
             }

File: core/src/main/java/io/undertow/server/handlers/SetHeaderHandler.java
Patch:
@@ -24,7 +24,7 @@
 
 /**
  * Set a fixed response header.
- * 
+ *
  * @author Stuart Douglas
  */
 public class SetHeaderHandler implements HttpHandler {

File: core/src/main/java/io/undertow/server/protocol/spdy/SpdyReceiveListener.java
Patch:
@@ -219,7 +219,7 @@ private static void handleQueryParameter(HttpServerExchange exchange, String pat
                 }
                 exchange.addQueryParam(headerName, value);
                 headerName = null;
-                currentPos = i;
+                currentPos = i + 1;
                 decodeRequired = false;
             } else if (c == '%') {
                 decodeRequired = true;

File: core/src/main/java/io/undertow/client/spdy/SpdyClientProvider.java
Patch:
@@ -239,7 +239,7 @@ public void handleEvent(StreamSourceChannel channel) {
     }
 
     private static SpdyClientConnection createSpdyChannel(StreamConnection connection, Pool<ByteBuffer> bufferPool) {
-        SpdyChannel spdyChannel = new SpdyChannel(connection, bufferPool, null, new ByteBufferSlicePool(BufferAllocator.BYTE_BUFFER_ALLOCATOR, 1024, 1024));
+        SpdyChannel spdyChannel = new SpdyChannel(connection, bufferPool, null, new ByteBufferSlicePool(BufferAllocator.BYTE_BUFFER_ALLOCATOR, 8192, 8192));
         return new SpdyClientConnection(spdyChannel);
     }
 

File: core/src/main/java/io/undertow/spdy/SpdyFramePriority.java
Patch:
@@ -53,7 +53,7 @@ public boolean insertFrame(SpdyStreamSinkChannel newFrame, List<SpdyStreamSinkCh
 
     @Override
     public void frameAdded(SpdyStreamSinkChannel addedFrame, List<SpdyStreamSinkChannel> pendingFrames, Deque<SpdyStreamSinkChannel> holdFrames) {
-        Iterator<SpdyStreamSinkChannel> it = pendingFrames.iterator();
+        Iterator<SpdyStreamSinkChannel> it = holdFrames.iterator();
         while (it.hasNext()){
             SpdyStreamSinkChannel pending = it.next();
             if(pending instanceof SpdyStreamStreamSinkChannel) {

File: core/src/main/java/io/undertow/spdy/SpdyStreamStreamSinkChannel.java
Patch:
@@ -92,6 +92,9 @@ synchronized void updateFlowControlWindow(final int delta) throws IOException {
         flowControlWindow += delta;
         if(exhausted) {
             getChannel().notifyFlowControlAllowed();
+            if(isWriteResumed()) {
+                wakeupWrites();
+            }
         }
     }
 }

File: core/src/main/java/io/undertow/spdy/SpdyGoAwayStreamSinkChannel.java
Patch:
@@ -46,6 +46,7 @@ protected SendFrameHeader createFrameHeader() {
         SpdyProtocolUtils.putInt(buf, 8);
         SpdyProtocolUtils.putInt(buf, lastGoodStreamId);
         SpdyProtocolUtils.putInt(buf, status);
+        buf.flip();
         return new SendFrameHeader( new ImmediatePooled<ByteBuffer>(buf));
     }
 

File: core/src/main/java/io/undertow/spdy/SpdyWindowUpdateStreamSinkChannel.java
Patch:
@@ -46,6 +46,7 @@ protected SendFrameHeader createFrameHeader() {
         SpdyProtocolUtils.putInt(buf, 8);
         SpdyProtocolUtils.putInt(buf, streamId);
         SpdyProtocolUtils.putInt(buf, deltaWindowSize);
+        buf.flip();
         return new SendFrameHeader(new ImmediatePooled<ByteBuffer>(buf));
     }
 

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedStreamSourceChannel.java
Patch:
@@ -538,6 +538,7 @@ public void close() throws IOException {
         }
         if(data != null) {
             data.free();
+            data = null;
         }
         ChannelListeners.invokeChannelListener(this, (ChannelListener<? super AbstractFramedStreamSourceChannel<C,R,S>>) closeSetter.get());
     }

File: core/src/main/java/io/undertow/server/protocol/spdy/SpdyReceiveListener.java
Patch:
@@ -93,7 +93,7 @@ public void handleEvent(SpdyChannel channel) {
                 exchange.setRequestScheme(exchange.getRequestHeaders().getFirst(SCHEME));
                 exchange.setProtocol(new HttpString(exchange.getRequestHeaders().getFirst(VERSION)));
                 exchange.setRequestMethod(new HttpString(exchange.getRequestHeaders().getFirst(METHOD)));
-                exchange.getRequestHeaders().add(Headers.HOST, exchange.getRequestHeaders().getFirst(HOST));
+                exchange.getRequestHeaders().put(Headers.HOST, exchange.getRequestHeaders().getFirst(HOST));
                 final String path = exchange.getRequestHeaders().getFirst(PATH);
                 setRequestPath(exchange, path, encoding, allowEncodingSlash, decodeBuffer);
 

File: core/src/main/java/io/undertow/websockets/core/WebSocketChannel.java
Patch:
@@ -356,6 +356,7 @@ public void handleException(final StreamSinkChannel channel, final IOException e
                 }
             }
             ));
+            closeChannel.resumeWrites();
         }
     }
 

File: core/src/test/java/io/undertow/websockets/core/protocol/WebSocket07ServerTest.java
Patch:
@@ -73,7 +73,6 @@ public void onError(WebSocketChannel channel, Void context, Throwable throwable)
                                 data.free();
                             }
                         });
-                        channel.sendClose();
                     }
                 });
                 channel.resumeReceives();

File: core/src/main/java/io/undertow/server/handlers/RequestDumpingHandler.java
Patch:
@@ -36,11 +36,11 @@
  *
  * @author Stuart Douglas
  */
-public class RequestDumplingHandler implements HttpHandler {
+public class RequestDumpingHandler implements HttpHandler {
 
     private final HttpHandler next;
 
-    public RequestDumplingHandler(final HttpHandler next) {
+    public RequestDumpingHandler(final HttpHandler next) {
         this.next = next;
     }
 

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -23,7 +23,7 @@
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.OpenListener;
-import io.undertow.server.handlers.RequestDumplingHandler;
+import io.undertow.server.handlers.RequestDumpingHandler;
 import io.undertow.server.handlers.SSLHeaderHandler;
 import io.undertow.server.handlers.proxy.LoadBalancingProxyClient;
 import io.undertow.server.handlers.proxy.ProxyHandler;
@@ -416,7 +416,7 @@ public static void setRootHandler(HttpHandler handler) {
             handler = new SSLHeaderHandler(handler);
         }
         if (dump) {
-            rootHandler.next = new RequestDumplingHandler(handler);
+            rootHandler.next = new RequestDumpingHandler(handler);
         } else {
             rootHandler.next = handler;
         }

File: core/src/main/java/io/undertow/client/spdy/SpdyClientProvider.java
Patch:
@@ -239,7 +239,8 @@ public void handleEvent(StreamSourceChannel channel) {
     }
 
     private static SpdyClientConnection createSpdyChannel(StreamConnection connection, Pool<ByteBuffer> bufferPool) {
-        return new SpdyClientConnection(new SpdyChannel(connection, bufferPool, null, new ByteBufferSlicePool(BufferAllocator.BYTE_BUFFER_ALLOCATOR, 1024, 1024)));
+        SpdyChannel spdyChannel = new SpdyChannel(connection, bufferPool, null, new ByteBufferSlicePool(BufferAllocator.BYTE_BUFFER_ALLOCATOR, 1024, 1024));
+        return new SpdyClientConnection(spdyChannel);
     }
 
     private static class SpdySelectionProvider implements NextProtoNego.ClientProvider {

File: core/src/test/java/io/undertow/server/handlers/proxy/AbstractLoadBalancingProxyTestCase.java
Patch:
@@ -88,6 +88,8 @@ public void testLoadSharedWithServerShutdown() throws IOException {
                 Assert.assertEquals(200, result.getStatusLine().getStatusCode());
                 resultString.append(HttpClientUtils.readResponse(result));
                 resultString.append(' ');
+            } catch (Throwable t) {
+                throw new RuntimeException("Failed with i=" + i, t);
             } finally {
                 client.getConnectionManager().shutdown();
             }

File: core/src/test/java/io/undertow/server/handlers/proxy/LoadBalancingProxySPDYTestCase.java
Patch:
@@ -30,7 +30,6 @@
 import io.undertow.testutils.DefaultServer;
 import org.eclipse.jetty.npn.NextProtoNego;
 import org.junit.BeforeClass;
-import org.junit.Ignore;
 import org.junit.runner.RunWith;
 import org.xnio.OptionMap;
 import org.xnio.Options;
@@ -48,7 +47,6 @@
  * @author Stuart Douglas
  */
 @RunWith(DefaultServer.class)
-@Ignore
 public class LoadBalancingProxySPDYTestCase extends AbstractLoadBalancingProxyTestCase {
 
     @BeforeClass

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/FrameHandler.java
Patch:
@@ -180,10 +180,10 @@ public void onError(WebSocketChannel channel, BufferedBinaryMessage context, Thr
 
     private void invokeBinaryHandler(final BufferedBinaryMessage context, final HandlerWrapper handler, final boolean finalFragment) {
 
+        final Pooled<ByteBuffer[]> pooled = context.getData();
         session.getContainer().invokeEndpointMethod(executor, new Runnable() {
             @Override
             public void run() {
-                Pooled<ByteBuffer[]> pooled = context.getData();
                 try {
                     if (handler.isPartialHandler()) {
                         MessageHandler.Partial mHandler = (MessageHandler.Partial) handler.getHandler();
@@ -233,11 +233,11 @@ public void run() {
 
     private void invokeTextHandler(final BufferedTextMessage data, final HandlerWrapper handler, final boolean finalFragment) {
 
+        final String message = data.getData();
         session.getContainer().invokeEndpointMethod(executor, new Runnable() {
             @Override
             public void run() {
                 MessageHandler mHandler = handler.getHandler();
-                final String message = data.getData();
 
                 if (mHandler instanceof MessageHandler.Partial) {
                     if (handler.getMessageType() == String.class) {

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedStreamSourceChannel.java
Patch:
@@ -444,6 +444,9 @@ public int read(ByteBuffer dst) throws IOException {
         if (anyAreSet(state, STATE_DONE)) {
             return -1;
         }
+        if(!dst.hasRemaining()) {
+            return 0;
+        }
         beforeRead();
         if (waitingForFrame) {
             return 0;

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedStreamSinkChannel.java
Patch:
@@ -462,7 +462,9 @@ final void flushComplete() throws IOException {
             } else {
                 buffer.getResource().compact();
             }
-            header.getByteBuffer().free();
+            if (header.getByteBuffer() != null) {
+                header.getByteBuffer().free();
+            }
             trailer.free();
             header = null;
             trailer = null;

File: core/src/main/java/io/undertow/client/spdy/SpdyClientConnection.java
Patch:
@@ -118,6 +118,7 @@ public void handleException(StreamSinkChannel channel, IOException exception) {
                             handleError(exception);
                         }
                     }));
+                    sinkChannel.resumeWrites();
                 }
             } catch (IOException e) {
                 handleError(e);

File: core/src/test/java/io/undertow/server/handlers/proxy/LoadBalancingProxySPDYTestCase.java
Patch:
@@ -101,7 +101,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
                 .setConnectionsPerThread(1)
                 .addHost(new URI("https", null, DefaultServer.getHostAddress("default"), port + 1, null, null, null), "s1", ssl, OptionMap.create(UndertowOptions.ENABLE_SPDY, true))
                 .addHost(new URI("https", null, DefaultServer.getHostAddress("default"), port + 2, null, null, null), "s2", ssl, OptionMap.create(UndertowOptions.ENABLE_SPDY, true))
-                , 3000, ResponseCodeHandler.HANDLE_404));
+                , 10000, ResponseCodeHandler.HANDLE_404));
     }
 
 }

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletInitialHandler.java
Patch:
@@ -257,6 +257,9 @@ public void handleFirstRequest(final HttpServerExchange exchange, final ServletC
                         exchange.setResponseCode(500);
                         exchange.getResponseHeaders().clear();
                         String location = servletContext.getDeployment().getErrorPages().getErrorLocation(t);
+                        if (location == null) {
+                            location = servletContext.getDeployment().getErrorPages().getErrorLocation(500);
+                        }
                         if (location != null) {
                             RequestDispatcherImpl dispatcher = new RequestDispatcherImpl(location, servletContext);
                             try {

File: core/src/main/java/io/undertow/server/protocol/http/HttpRequestParser.java
Patch:
@@ -206,6 +206,7 @@ public void handle(ByteBuffer buffer, final ParseState currentState, final HttpS
                     && buffer.get(position + 3) == ' ') {
                 buffer.position(position + 4);
                 builder.setRequestMethod(Methods.GET);
+                currentState.state = ParseState.PATH;
             } else {
                 handleHttpVerb(buffer, currentState, builder);
             }

File: core/src/test/java/io/undertow/server/protocol/http/ParserResumeTestCase.java
Patch:
@@ -36,7 +36,7 @@
  */
 public class ParserResumeTestCase {
 
-    public static final String DATA = "POST http://www.somehost.net/apath+with+spaces%20and%20I%C3%B1t%C3%ABrn%C3%A2ti%C3%B4n%C3%A0li%C5%BE%C3%A6ti%C3%B8n?key1=value1&key2=I%C3%B1t%C3%ABrn%C3%A2ti%C3%B4n%C3%A0li%C5%BE%C3%A6ti%C3%B8n HTTP/1.1\r\nHost:   www.somehost.net\r\nOtherHeader: some\r\n    value\r\nHostee:another\r\nAccept-garbage:   a\r\n\r\ntttt";
+    public static final String DATA = "GET http://www.somehost.net/apath+with+spaces%20and%20I%C3%B1t%C3%ABrn%C3%A2ti%C3%B4n%C3%A0li%C5%BE%C3%A6ti%C3%B8n?key1=value1&key2=I%C3%B1t%C3%ABrn%C3%A2ti%C3%B4n%C3%A0li%C5%BE%C3%A6ti%C3%B8n HTTP/1.1\r\nHost:   www.somehost.net\r\nOtherHeader: some\r\n    value\r\nHostee:another\r\nAccept-garbage:   a\r\n\r\ntttt";
     public static final HttpRequestParser PARSER = HttpRequestParser.instance(OptionMap.create(UndertowOptions.ALLOW_ENCODED_SLASH, true));
 
     final ParseState context = new ParseState();
@@ -83,7 +83,7 @@ private void testResume(final int split, byte[] in) {
     }
 
     private void runAssertions(final HttpServerExchange result) {
-        Assert.assertSame(Methods.POST, result.getRequestMethod());
+        Assert.assertSame(Methods.GET, result.getRequestMethod());
         Assert.assertEquals("/apath with spaces and Iñtërnâtiônàližætiøn", result.getRelativePath());
         Assert.assertEquals("http://www.somehost.net/apath+with+spaces%20and%20I%C3%B1t%C3%ABrn%C3%A2ti%C3%B4n%C3%A0li%C5%BE%C3%A6ti%C3%B8n", result.getRequestURI());
         Assert.assertSame(Protocols.HTTP_1_1, result.getProtocol());

File: core/src/main/java/io/undertow/server/protocol/http/HttpRequestParser.java
Patch:
@@ -741,7 +741,7 @@ protected boolean handleCachedHeader(String existing, ByteBuffer buffer, ParseSt
         while (pos < buffer.limit() && buffer.get(pos) == ' ') {
             pos++;
         }
-        if (existing.length() + 3 + pos > buffer.remaining()) {
+        if (existing.length() + 3 + pos > buffer.limit()) {
             return false;
         }
         int i = 0;

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -296,4 +296,7 @@ public interface UndertowMessages {
 
     @Message(id = 90, value = "Jetty NPN not available")
     IOException jettyNPNNotAvailable();
+
+    @Message(id = 91, value = "Buffer has already been freed")
+    IllegalStateException bufferAlreadyFreed();
 }

File: core/src/main/java/io/undertow/websockets/WebSocketProtocolHandshakeHandler.java
Patch:
@@ -166,8 +166,7 @@ public WebSocketProtocolHandshakeHandler(Collection<Handshake> handshakes, final
     public void handleRequest(final HttpServerExchange exchange) throws Exception {
         if (!exchange.getRequestMethod().equals(Methods.GET)) {
             // Only GET is supported to start the handshake
-            exchange.setResponseCode(403);
-            exchange.endExchange();
+            next.handleRequest(exchange);
             return;
         }
         final AsyncWebSocketHttpServerExchange facade = new AsyncWebSocketHttpServerExchange(exchange);

File: servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java
Patch:
@@ -74,7 +74,7 @@ public class DefaultServlet extends HttpServlet {
     public static final String RESOLVE_AGAINST_CONTEXT_ROOT = "resolve-against-context-root";
 
     private static final Set<String> DEFAULT_ALLOWED_EXTENSIONS = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList("js", "css", "png", "jpg", "gif", "html", "htm", "txt", "pdf", "jpeg", "xml")));
-    private static final Set<String> DEFAULT_DISALLOWED_EXTENSIONS = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList("class", "jar", "war", "zip")));
+    private static final Set<String> DEFAULT_DISALLOWED_EXTENSIONS = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList("class", "jar", "war")));
 
 
     private Deployment deployment;

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpServerRequestConduit.java
Patch:
@@ -247,6 +247,9 @@ private int doRead(final ByteBuffer dst, long state) throws IOException {
             final long maxEntitySize = exchange.getMaxEntitySize();
             if (maxEntitySize > 0) {
                 if (totalRead > maxEntitySize) {
+                    //kill the connection, nothing else can be sent on it
+                    terminateReads();
+                    exchange.setPersistent(false);
                     throw UndertowMessages.MESSAGES.requestEntityWasTooLarge(maxEntitySize);
                 }
             }

File: servlet/src/test/java/io/undertow/servlet/test/websocket/WebSocketServletTest.java
Patch:
@@ -89,6 +89,7 @@ protected void stringDone(final String string) {
                                                     new StringWriteChannelListener(string)
                                                             .setup(channel.send(WebSocketFrameType.TEXT, string.length()));
                                                 }
+                                                channel.sendClose();
                                             } catch (IOException e) {
                                                 e.printStackTrace();
                                                 throw new RuntimeException(e);
@@ -101,13 +102,13 @@ protected void error(final IOException e) {
                                                 e.printStackTrace();
                                                 new StringWriteChannelListener("ERROR")
                                                         .setup(channel.send(WebSocketFrameType.TEXT, "ERROR".length()));
+                                                channel.sendClose();
                                             } catch (IOException ex) {
                                                 ex.printStackTrace();
                                                 throw new RuntimeException(ex);
                                             }
                                         }
                                     }.setup(ws);
-                                    channel.getReceiveSetter().set(null);
 
                                 } catch (IOException e) {
                                     throw new RuntimeException(e);

File: servlet/src/main/java/io/undertow/servlet/core/ServletUpgradeListener.java
Patch:
@@ -61,12 +61,12 @@ public void handleEvent(StreamConnection channel) {
                 }
             }
         });
-        this.exchange.getIoThread().execute(new Runnable() {
+        this.exchange.getConnection().getWorker().execute(new Runnable() {
             @Override
             public void run() {
                 final ThreadSetupAction.Handle handle = threadSetupAction.setup(ServletUpgradeListener.this.exchange);
                 try {
-                    //run the upgrade in the IO thread, to prevent threading issues
+                    //run the upgrade in the worker thread
                     instance.getInstance().init(new WebConnectionImpl(channel, ServletUpgradeListener.this.exchange.getConnection().getBufferPool()));
                 } finally {
                     handle.tearDown();

File: servlet/src/test/java/io/undertow/servlet/test/upgrade/SimpleUpgradeTestCase.java
Patch:
@@ -83,6 +83,7 @@ public void runTest(final String url) throws IOException {
 
             out.write("exit\r\n\r\n".getBytes());
             out.flush();
+            out.close();
 
         } finally {
             client.getConnectionManager().shutdown();

File: servlet/src/main/java/io/undertow/servlet/spec/ServletOutputStreamImpl.java
Patch:
@@ -580,7 +580,7 @@ public void close() throws IOException {
             if (anyAreSet(state, FLAG_CLOSED)) return;
             state |= FLAG_CLOSED;
             state &= ~FLAG_READY;
-            if (allAreClear(state, FLAG_WRITE_STARTED) && channel == null) {
+            if (allAreClear(state, FLAG_WRITE_STARTED) && channel == null && servletRequestContext.getOriginalResponse().getHeader(Headers.CONTENT_LENGTH_STRING) == null) {
                 if (servletRequestContext.getOriginalResponse().getHeader(Headers.TRANSFER_ENCODING_STRING) == null) {
                     if (buffer == null) {
                         servletRequestContext.getExchange().getResponseHeaders().put(Headers.CONTENT_LENGTH, "0");

File: core/src/main/java/io/undertow/client/http/HttpClientConnection.java
Patch:
@@ -405,6 +405,7 @@ public void handleEvent(StreamSourceChannel channel) {
                             UndertowLogger.CLIENT_LOGGER.debugf(e, "Connection closed with IOException");
                         }
                         safeClose(channel);
+                        currentRequest.setFailed(new IOException(MESSAGES.connectionClosed()));
                         return;
                     }
 

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -334,7 +334,7 @@ protected String testName(FrameworkMethod method) {
                 sb.append("{proxy}");
             }
             if (ajp) {
-                sb.append("{ajp");
+                sb.append("{ajp}");
             }
             return sb.toString();
         }

File: core/src/main/java/io/undertow/server/handlers/NameVirtualHostHandler.java
Patch:
@@ -44,7 +44,7 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
         if (hostHeader != null) {
             String host;
             if (hostHeader.contains(":")) { //header can be in host:port format
-                host = hostHeader.substring(0, hostHeader.indexOf(":"));
+                host = hostHeader.substring(0, hostHeader.lastIndexOf(":"));
             } else {
                 host = hostHeader;
             }

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -86,7 +86,7 @@
  */
 public class DefaultServer extends BlockJUnit4ClassRunner {
 
-    private static final String DEFAULT = "default";
+    static final String DEFAULT = "default";
     private static final int PROXY_OFFSET = 1111;
     public static final int APACHE_PORT = 9080;
     public static final int APACHE_SSL_PORT = 9443;

File: core/src/test/java/io/undertow/websockets/core/protocol/WebSocket07ServerTest.java
Patch:
@@ -18,6 +18,7 @@
 package io.undertow.websockets.core.protocol;
 
 import io.undertow.testutils.DefaultServer;
+import io.undertow.util.NetworkUtils;
 import io.undertow.websockets.core.StreamSinkFrameChannel;
 import io.undertow.websockets.core.StreamSourceFrameChannel;
 import io.undertow.websockets.core.WebSocketChannel;
@@ -96,7 +97,7 @@ public void handleEvent(final WebSocketChannel channel) {
         final FutureResult latch = new FutureResult();
         final byte[] payload =  "payload".getBytes();
 
-        WebSocketTestClient client = new WebSocketTestClient(getVersion(), new URI("ws://" + DefaultServer.getHostAddress("default") + ':' + DefaultServer.getHostPort("default") + '/'));
+        WebSocketTestClient client = new WebSocketTestClient(getVersion(), new URI("ws://" + NetworkUtils.formatPossibleIpv6Address(DefaultServer.getHostAddress("default")) + ':' + DefaultServer.getHostPort("default") + '/'));
         client.connect();
         client.send(new PingWebSocketFrame(ChannelBuffers.wrappedBuffer(payload)), new FrameChecker(PongWebSocketFrame.class, payload, latch));
         latch.getIoFuture().get();

File: websockets-jsr/src/test/java/io/undertow/websockets/jsr/test/JsrWebSocketServer07Test.java
Patch:
@@ -26,6 +26,7 @@
 import io.undertow.servlet.test.util.TestClassIntrospector;
 import io.undertow.testutils.AjpIgnore;
 import io.undertow.testutils.DefaultServer;
+import io.undertow.util.NetworkUtils;
 import io.undertow.websockets.jsr.JsrWebSocketFilter;
 import io.undertow.websockets.jsr.ServerWebSocketContainer;
 import io.undertow.websockets.utils.FrameChecker;
@@ -105,7 +106,7 @@ public void onMessage(ByteBuffer message) {
         builder.addEndpoint(ServerEndpointConfig.Builder.create(TestEndPoint.class, "/").configurator(new InstanceConfigurator(new TestEndPoint())).build());
         deployServlet(builder);
 
-        WebSocketTestClient client = new WebSocketTestClient(getVersion(), new URI("ws://" + DefaultServer.getHostAddress("default") + ":" + DefaultServer.getHostPort("default") + "/"));
+        WebSocketTestClient client = new WebSocketTestClient(getVersion(), new URI("ws://" + NetworkUtils.formatPossibleIpv6Address(DefaultServer.getHostAddress("default")) + ":" + DefaultServer.getHostPort("default") + "/"));
         client.connect();
         client.send(new BinaryWebSocketFrame(ChannelBuffers.wrappedBuffer(payload)), new FrameChecker(BinaryWebSocketFrame.class, payload, latch));
         latch.getIoFuture().get();

File: servlet/src/test/java/io/undertow/servlet/test/charset/EchoServlet.java
Patch:
@@ -40,6 +40,9 @@ protected void service(final HttpServletRequest req, final HttpServletResponse r
         }
         PrintWriter writer = resp.getWriter();
         String message = req.getParameter("message");
+        if(message == null) {
+            message = req.getServletPath().substring(1);
+        }
         System.out.println("Received message: " + message);
         writer.write(message);
         writer.close();

File: core/src/main/java/io/undertow/server/handlers/form/FormData.java
Patch:
@@ -21,8 +21,8 @@
 import java.io.File;
 import java.util.ArrayDeque;
 import java.util.Deque;
-import java.util.HashMap;
 import java.util.Iterator;
+import java.util.LinkedHashMap;
 import java.util.Map;
 
 import io.undertow.UndertowMessages;
@@ -35,7 +35,7 @@
  */
 public final class FormData implements Iterable<String> {
 
-    private final Map<String, Deque<FormValue>> values = new HashMap<String, Deque<FormValue>>();
+    private final Map<String, Deque<FormValue>> values = new LinkedHashMap<String, Deque<FormValue>>();
 
     private final int maxValues;
     private int valueCount = 0;

File: servlet/src/main/java/io/undertow/servlet/spec/ServletPrintWriterDelegate.java
Patch:
@@ -43,7 +43,7 @@ private ServletPrintWriterDelegate() {
             @Override
             public Constructor<ServletPrintWriterDelegate> run() {
                 try {
-                    return ReflectionFactory.getReflectionFactory().newConstructorForSerialization(ServletPrintWriterDelegate.class, Object.class.getDeclaredConstructor());
+                    return (Constructor)ReflectionFactory.getReflectionFactory().newConstructorForSerialization(ServletPrintWriterDelegate.class, Object.class.getDeclaredConstructor());
                 } catch (NoSuchMethodException e) {
                     throw new RuntimeException(e);
                 }

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/annotated/AnnotatedEndpoint.java
Patch:
@@ -203,7 +203,7 @@ protected void onFullCloseMessage(final WebSocketChannel channel, BufferedBinary
                         final Map<Class<?>, Object> params = new HashMap<Class<?>, Object>();
                         params.put(Session.class, session);
                         params.put(Map.class, session.getPathParameters());
-                        params.put(CloseReason.class, new CloseReason(CloseReason.CloseCodes.getCloseCode(cm.getReason()), cm.getString()));
+                        params.put(CloseReason.class, new CloseReason(CloseReason.CloseCodes.getCloseCode(cm.getCode()), cm.getReason()));
                         invokeMethod(params, webSocketClose, session);
                     } catch (Exception e) {
                         AnnotatedEndpoint.this.onError(session, e);

File: core/src/main/java/io/undertow/security/impl/ExternalAuthenticationMechanism.java
Patch:
@@ -52,7 +52,7 @@ public AuthenticationMechanismOutcome authenticate(HttpServerExchange exchange,
         String name = exchange.getAttachment(EXTERNAL_AUTHENTICATION_TYPE);
         securityContext.authenticationComplete(account, name != null ? name: this.name, false);
 
-        return null;
+        return AuthenticationMechanismOutcome.AUTHENTICATED;
     }
 
     @Override

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -188,7 +188,7 @@ public static String getDefaultServerSSLAddress() {
         if (sslServer == null && !isApacheTest()) {
             throw new IllegalStateException("SSL Server not started.");
         }
-        return "https://" + getHostAddress(DEFAULT) + ":" + getHostSSLPort(DEFAULT);
+        return "https://" +  NetworkUtils.formatPossibleIpv6Address(getHostAddress(DEFAULT)) + ":" + getHostSSLPort(DEFAULT);
     }
 
     public DefaultServer(Class<?> klass) throws InitializationError {

File: core/src/main/java/io/undertow/websockets/client/WebSocket13ClientHandshake.java
Patch:
@@ -130,7 +130,7 @@ public void checkHandshake(Map<String, String> headers) throws IOException {
                 }
                 if (negotiation != null) {
                     String subProto = headers.get(Headers.SEC_WEB_SOCKET_PROTOCOL_STRING.toLowerCase(Locale.ENGLISH));
-                    if (!negotiation.getSupportedSubProtocols().contains(subProto)) {
+                    if (subProto != null && !negotiation.getSupportedSubProtocols().contains(subProto)) {
                         throw WebSocketMessages.MESSAGES.unsupportedProtocol(subProto, negotiation.getSupportedSubProtocols());
                     }
                     List<WebSocketExtension> extensions = Collections.emptyList();

File: core/src/main/java/io/undertow/websockets/client/WebSocketClientNegotiation.java
Patch:
@@ -13,7 +13,7 @@ public class WebSocketClientNegotiation {
     private final List<String> supportedSubProtocols;
     private final List<WebSocketExtension> supportedExtensions;
     private volatile String selectedSubProtocol;
-    private volatile List<String> selectedExtensions;
+    private volatile List<WebSocketExtension> selectedExtensions;
 
     public WebSocketClientNegotiation(List<String> supportedSubProtocols, List<WebSocketExtension> supportedExtensions) {
         this.supportedSubProtocols = supportedSubProtocols;
@@ -32,7 +32,7 @@ public String getSelectedSubProtocol() {
         return selectedSubProtocol;
     }
 
-    public List<String> getSelectedExtensions() {
+    public List<WebSocketExtension> getSelectedExtensions() {
         return selectedExtensions;
     }
 
@@ -43,7 +43,7 @@ public void afterRequest(final Map<String, String> headers) {
 
     }
 
-    public void handshakeComplete(String selectedProtocol, List<String> selectedExtensions) {
+    public void handshakeComplete(String selectedProtocol, List<WebSocketExtension> selectedExtensions) {
         this.selectedExtensions = selectedExtensions;
         this.selectedSubProtocol = selectedProtocol;
     }

File: core/src/main/java/io/undertow/server/handlers/resource/URLResource.java
Patch:
@@ -74,6 +74,8 @@ public boolean isDirectory() {
         File file = getFile();
         if(file != null) {
             return file.isDirectory();
+        } else if(url.getPath().endsWith("/")) {
+            return true;
         }
         return false;
     }

File: core/src/main/java/io/undertow/client/http/HttpClientProvider.java
Patch:
@@ -36,10 +36,10 @@ public void connect(final ClientCallback<ClientConnection> listener, final URI u
             if (ssl == null) {
                 throw UndertowMessages.MESSAGES.sslWasNull();
             }
-
             ssl.openSslConnection(worker, new InetSocketAddress(uri.getHost(), uri.getPort()), createOpenListener(listener, uri, ssl, bufferPool, options), options).addNotifier(createNotifier(listener), null);
+        } else {
+            worker.openStreamConnection(new InetSocketAddress(uri.getHost(), uri.getPort()), createOpenListener(listener, uri, ssl, bufferPool, options), options).addNotifier(createNotifier(listener), null);
         }
-        worker.openStreamConnection(new InetSocketAddress(uri.getHost(), uri.getPort()), createOpenListener(listener, uri, ssl, bufferPool, options), options).addNotifier(createNotifier(listener), null);
     }
 
     @Override

File: servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java
Patch:
@@ -73,15 +73,15 @@ public class DefaultServlet extends HttpServlet {
     public static final String DISALLOWED_EXTENSIONS = "disallowed-extensions";
     public static final String RESOLVE_AGAINST_CONTEXT_ROOT = "resolve-against-context-root";
 
-    private static final Set<String> DEFAULT_ALLOWED_EXTENSIONS = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList("js", "css", "png", "jpg", "gif", "html", "htm", "txt", "pdf")));
-    private static final Set<String> DEFAULT_DISALLOWED_EXTENSIONS = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList("class", "jar", "war", "zip", "xml")));
+    private static final Set<String> DEFAULT_ALLOWED_EXTENSIONS = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList("js", "css", "png", "jpg", "gif", "html", "htm", "txt", "pdf", "jpeg", "xml")));
+    private static final Set<String> DEFAULT_DISALLOWED_EXTENSIONS = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList("class", "jar", "war", "zip")));
 
 
     private Deployment deployment;
     private ResourceManager resourceManager;
     private boolean directoryListingEnabled = false;
 
-    private boolean defaultAllowed;
+    private boolean defaultAllowed = true;
     private Set<String> allowed = DEFAULT_ALLOWED_EXTENSIONS;
     private Set<String> disallowed = DEFAULT_DISALLOWED_EXTENSIONS;
     private boolean resolveAgainstContextRoot;

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/DefaultServletTestCase.java
Patch:
@@ -100,7 +100,7 @@ public void testDisallowedResource() throws IOException {
         try {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/servletContext/disallowed.sh");
             HttpResponse result = client.execute(get);
-            Assert.assertEquals(404, result.getStatusLine().getStatusCode());
+            Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             HttpClientUtils.readResponse(result);
         } finally {
             client.getConnectionManager().shutdown();

File: core/src/main/java/io/undertow/server/handlers/accesslog/DefaultAccessLogReceiver.java
Patch:
@@ -65,7 +65,7 @@ public DefaultAccessLogReceiver(final Executor logWriteExecutor, final File outp
         this.logBaseName = logBaseName;
         this.logNameSuffix = (logNameSuffix != null) ? logNameSuffix : DEFAULT_LOG_SUFFIX;
         this.pendingMessages = new ConcurrentLinkedDeque<String>();
-        this.defaultLogFile = new File(outputDirectory, logBaseName + logNameSuffix);
+        this.defaultLogFile = new File(outputDirectory, logBaseName + this.logNameSuffix);
         calculateChangeOverPoint();
     }
 

File: core/src/main/java/io/undertow/predicate/EqualsPredicate.java
Patch:
@@ -35,8 +35,8 @@ class EqualsPredicate implements Predicate {
 
     private final ExchangeAttribute[] attributes;
 
-    EqualsPredicate(final ExchangeAttribute[] attribute) {
-        this.attributes = attribute;
+    EqualsPredicate(final ExchangeAttribute[] attributes) {
+        this.attributes = attributes;
     }
 
     @Override

File: core/src/main/java/io/undertow/util/MultipartParser.java
Patch:
@@ -210,7 +210,7 @@ private void headerName(final ByteBuffer buffer) throws MalformedMessageExceptio
                     } else if (currentString == null) {
                         currentString = new ByteArrayOutputStream();
                     }
-                    currentString.write((char) b);
+                    currentString.write(b);
                 }
             }
         }
@@ -233,7 +233,7 @@ private void headerValue(final ByteBuffer buffer) throws MalformedMessageExcepti
                     if (subState != 0) {
                         throw new MalformedMessageException();
                     }
-                    currentString.write((char) b);
+                    currentString.write(b);
                 }
             }
         }

File: core/src/test/java/io/undertow/server/handlers/DateHandlerTestCase.java
Patch:
@@ -35,7 +35,7 @@ public void testDateHandler() throws IOException, InterruptedException {
             Header date = result.getHeaders("Date")[0];
             final long firstDate = DateUtils.parseDate(date.getValue()).getTime();
             Assert.assertTrue((firstDate + 3000) > System.currentTimeMillis());
-            Assert.assertTrue(System.currentTimeMillis() > firstDate);
+            Assert.assertTrue(System.currentTimeMillis() >= firstDate);
             HttpClientUtils.readResponse(result);
             Thread.sleep(1500);
             result = client.execute(get);

File: core/src/test/java/io/undertow/server/handlers/PreChunkedResponseTransferCodingTestCase.java
Patch:
@@ -22,6 +22,7 @@
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.ServerConnection;
 import io.undertow.server.protocol.http.HttpAttachments;
+import io.undertow.testutils.AjpIgnore;
 import io.undertow.testutils.DefaultServer;
 import io.undertow.testutils.HttpClientUtils;
 import io.undertow.testutils.TestHttpClient;
@@ -41,6 +42,7 @@
  * @author Stuart Douglas
  */
 @RunWith(DefaultServer.class)
+@AjpIgnore
 public class PreChunkedResponseTransferCodingTestCase {
 
     private static final String MESSAGE = "My HTTP Request!";

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -24,7 +24,6 @@
 import io.undertow.security.api.AuthenticationMode;
 import io.undertow.security.api.NotificationReceiver;
 import io.undertow.security.api.SecurityContextFactory;
-import io.undertow.security.handlers.AuthenticationCallHandler;
 import io.undertow.security.handlers.AuthenticationMechanismsHandler;
 import io.undertow.security.handlers.NotificationReceiverHandler;
 import io.undertow.security.handlers.SecurityInitialHandler;
@@ -74,6 +73,7 @@
 import io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler;
 import io.undertow.servlet.handlers.security.SSLInformationAssociationHandler;
 import io.undertow.servlet.handlers.security.SecurityPathMatches;
+import io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler;
 import io.undertow.servlet.handlers.security.ServletAuthenticationConstraintHandler;
 import io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler;
 import io.undertow.servlet.handlers.security.ServletFormAuthenticationMechanism;
@@ -286,7 +286,7 @@ private HttpHandler setupSecurityHandlers(HttpHandler initialHandler) {
         current = new SSLInformationAssociationHandler(current);
 
         final SecurityPathMatches securityPathMatches = buildSecurityConstraints();
-        current = new AuthenticationCallHandler(current);
+        current = new ServletAuthenticationCallHandler(current);
         if (!securityPathMatches.isEmpty()) {
             current = new ServletAuthenticationConstraintHandler(current);
         }

File: core/src/main/java/io/undertow/conduits/ChunkedStreamSinkConduit.java
Patch:
@@ -51,7 +51,7 @@
 public class ChunkedStreamSinkConduit extends AbstractStreamSinkConduit<StreamSinkConduit> {
 
     /**
-     * Trails that are to be attached to the end of the HTTP response. Note that it is the callers responsibility
+     * Trailers that are to be attached to the end of the HTTP response. Note that it is the callers responsibility
      * to make sure the client understands trailers (i.e. they have provided a TE header), and to set the 'Trailers:'
      * header appropriately.
      * <p/>

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/annotated/AnnotatedEndpointFactory.java
Patch:
@@ -71,6 +71,7 @@ public static AnnotatedEndpointFactory create(final Executor executor, final Cla
         BoundMethod binaryMessage = null;
         BoundMethod pongMessage = null;
         Class<?> c = endpointClass;
+
         do {
             for (final Method method : c.getDeclaredMethods()) {
                 if (method.isAnnotationPresent(OnOpen.class)) {

File: servlet/src/main/java/io/undertow/servlet/api/DefaultServletConfig.java
Patch:
@@ -9,8 +9,11 @@
  * The default servlet config. By default this has quite a restrictive configuration, only allowing
  * extensions in common use in the web to be served.
  *
+ * This class is deprecated, the default servlet should be configured via context params.
+ *
  * @author Stuart Douglas
  */
+@Deprecated
 public class DefaultServletConfig {
 
     private static final String[] DEFAULT_ALLOWED_EXTENSIONS = {"js", "css", "png", "jpg", "gif", "html", "htm", "txt", "pdf"};

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -502,7 +502,7 @@ public HttpHandler start() throws ServletException {
                 }
             }
 
-            if (servletContainer.isEagerFilterInit()){
+            if (deployment.getDeploymentInfo().isEagerFilterInit()){
                 for(ManagedFilter filter: deployment.getFilters().getFilters().values()) {
                     filter.createFilter();
                 }

File: servlet/src/test/java/io/undertow/servlet/test/lifecycle/EagerServletLifecycleTestCase.java
Patch:
@@ -44,7 +44,7 @@ public void testServletLifecycle() throws Exception {
 
 
         final PathHandler root = new PathHandler();
-        final ServletContainer container = ServletContainer.Factory.newInstance(true);
+        final ServletContainer container = ServletContainer.Factory.newInstance();
 
         FilterInfo f = new FilterInfo("filter", LifecycleFilter.class);
 
@@ -53,6 +53,7 @@ public void testServletLifecycle() throws Exception {
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
+                .setEagerFilterInit(true)
                 .addFilter(f)
                 .addFilterUrlMapping("filter", "/aa", DispatcherType.REQUEST);
 

File: servlet/src/main/java/io/undertow/servlet/handlers/security/ServletFormAuthenticationMechanism.java
Patch:
@@ -9,7 +9,6 @@
 import io.undertow.servlet.handlers.ServletRequestContext;
 import io.undertow.servlet.spec.HttpSessionImpl;
 import io.undertow.servlet.util.SavedRequest;
-import io.undertow.util.Methods;
 import io.undertow.util.RedirectBuilder;
 
 import javax.servlet.RequestDispatcher;
@@ -57,7 +56,6 @@ protected Integer servePage(final HttpServerExchange exchange, final String loca
         ServletRequest req = servletRequestContext.getServletRequest();
         ServletResponse resp = servletRequestContext.getServletResponse();
         RequestDispatcher disp = req.getRequestDispatcher(location);
-        exchange.setRequestMethod(Methods.GET); //TODO: is this correct?
         try {
             disp.forward(req, resp);
         } catch (ServletException e) {

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -359,7 +359,7 @@ private boolean responseStarted() {
 
     @Override
     public void setContentType(final String type) {
-        if (insideInclude || responseStarted()) {
+        if (type == null || insideInclude || responseStarted()) {
             return;
         }
         contentType = type;

File: core/src/main/java/io/undertow/websockets/core/BufferedTextMessage.java
Patch:
@@ -34,7 +34,9 @@ public BufferedTextMessage(boolean bufferFullMessage) {
     }
 
     private void checkMaxSize(StreamSourceFrameChannel channel, int res) throws IOException {
-        currentSize += res;
+        if(res > 0) {
+            currentSize += res;
+        }
         if (maxMessageSize > 0 && currentSize > maxMessageSize) {
             WebSockets.sendClose(new CloseMessage(CloseMessage.MSG_TOO_BIG, WebSocketMessages.MESSAGES.messageToBig(maxMessageSize)).toByteBuffer(), channel.getWebSocketChannel(), null);
             throw new IOException(WebSocketMessages.MESSAGES.messageToBig(maxMessageSize));

File: core/src/main/java/io/undertow/server/protocol/ajp/AbstractAjpParser.java
Patch:
@@ -68,6 +68,7 @@ protected StringHolder parseString(ByteBuffer buf, AbstractAjpParseState state,
         while (length < stringLength) {
             if (!buf.hasRemaining()) {
                 state.stringLength = stringLength;
+                state.containsUrlCharacters = containsUrlCharacters;
                 return new StringHolder(null, false, false);
             }
             char c = (char) buf.get();
@@ -85,6 +86,8 @@ protected StringHolder parseString(ByteBuffer buf, AbstractAjpParseState state,
             state.containsUrlCharacters = false;
             return new StringHolder(builder.toString(), true, containsUrlCharacters);
         } else {
+            state.stringLength = stringLength;
+            state.containsUrlCharacters = containsUrlCharacters;
             return new StringHolder(null, false, false);
         }
     }

File: servlet/src/main/java/io/undertow/servlet/handlers/security/ServletFormAuthenticationMechanism.java
Patch:
@@ -71,7 +71,7 @@ protected Integer servePage(final HttpServerExchange exchange, final String loca
     @Override
     protected void storeInitialLocation(final HttpServerExchange exchange) {
         final ServletRequestContext servletRequestContext = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY);
-        HttpSessionImpl httpSession = servletRequestContext.getCurrentServetContext().getSession(exchange, true);
+        HttpSessionImpl httpSession = servletRequestContext.getCurrentServletContext().getSession(exchange, true);
         Session session;
         if (System.getSecurityManager() == null) {
             session = httpSession.getSession();
@@ -86,7 +86,7 @@ protected void storeInitialLocation(final HttpServerExchange exchange) {
     protected void handleRedirectBack(final HttpServerExchange exchange) {
         final ServletRequestContext servletRequestContext = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY);
         HttpServletResponse resp = (HttpServletResponse) servletRequestContext.getServletResponse();
-        HttpSessionImpl httpSession = servletRequestContext.getCurrentServetContext().getSession(exchange, false);
+        HttpSessionImpl httpSession = servletRequestContext.getCurrentServletContext().getSession(exchange, false);
         if (httpSession != null) {
             Session session;
             if (System.getSecurityManager() == null) {

File: servlet/src/main/java/io/undertow/servlet/util/SavedRequest.java
Patch:
@@ -79,7 +79,7 @@ public static void trySaveRequest(final HttpServerExchange exchange) {
                     }
                     SavedRequest request = new SavedRequest(buffer, read, exchange.getRequestMethod(), exchange.getRequestURI(), exchange.getRequestHeaders());
                     final ServletRequestContext sc = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY);
-                    HttpSessionImpl session = sc.getCurrentServetContext().getSession(exchange, true);
+                    HttpSessionImpl session = sc.getCurrentServletContext().getSession(exchange, true);
                     Session underlyingSession;
                     if(System.getSecurityManager() == null) {
                         underlyingSession = session.getSession();

File: servlet/src/test/java/io/undertow/servlet/test/security/form/SaveOriginalPostRequestTestCase.java
Patch:
@@ -108,7 +108,8 @@ public void testParametersFromOriginalPostRequest() throws IOException {
         response = HttpClientUtils.readResponse(result);
 
         // let's check if the original request was saved, including its parameters.
-        assertTrue(response.contains("securedParam1=securedParam1Value/securedParam2=securedParam2Value"));
+        assertTrue(response.contains("securedParam1=securedParam1Value"));
+        assertTrue(response.contains("securedParam2=securedParam2Value"));
     }
 
     private TestHttpClient createHttpClient() {

File: servlet/src/main/java/io/undertow/servlet/api/DeploymentInfo.java
Patch:
@@ -84,7 +84,7 @@ public class DeploymentInfo implements Cloneable {
     private SessionPersistenceManager sessionPersistenceManager;
     private String defaultEncoding = "ISO-8859-1";
     private String urlEncoding = null;
-    private boolean ignoreFlush = true;
+    private boolean ignoreFlush = false;
     private AuthorizationManager authorizationManager = DefaultAuthorizationManager.INSTANCE;
     private AuthenticationMechanism jaspiAuthenticationMechanism;
     private SecurityContextFactory securityContextFactory;

File: core/src/main/java/io/undertow/util/ImmediateAuthenticationMechanismFactory.java
Patch:
@@ -20,6 +20,6 @@ public ImmediateAuthenticationMechanismFactory(AuthenticationMechanism authentic
 
     @Override
     public AuthenticationMechanism create(String mechanismName, FormParserFactory formParserFactory, Map<String, String> properties) {
-        return null;
+        return authenticationMechanism;
     }
 }

File: servlet/src/main/java/io/undertow/servlet/handlers/security/SSLInformationAssociationHandler.java
Patch:
@@ -36,7 +36,7 @@ public SSLInformationAssociationHandler(final HttpHandler next) {
      * @param cipherSuite String name of the TLS cipher suite.
      * @return int indicating the effective key entropy bit-length.
      */
-    public static int getKeyLenght(String cipherSuite) {
+    public static int getKeyLength(String cipherSuite) {
         // Roughly ordered from most common to least common.
         if (cipherSuite == null) {
             return 0;
@@ -102,7 +102,7 @@ public void handleRequest(HttpServerExchange exchange) throws Exception {
         SSLSessionInfo ssl = exchange.getConnection().getSslSessionInfo();
         if (ssl != null) {
             request.setAttribute("javax.servlet.request.cipher_suite", ssl.getCipherSuite());
-            request.setAttribute("javax.servlet.request.key_size", getKeyLenght(ssl.getCipherSuite()));
+            request.setAttribute("javax.servlet.request.key_size", getKeyLength(ssl.getCipherSuite()));
             request.setAttribute("javax.servlet.request.ssl_session_id", ssl.getSessionId());
             X509Certificate[] certs = getCerts(ssl);
             if (certs != null) {

File: core/src/main/java/io/undertow/server/handlers/form/FormEncodedDataDefinition.java
Patch:
@@ -57,7 +57,7 @@ public FormDataParser create(final HttpServerExchange exchange)  {
             String charset = defaultEncoding;
             String contentType = exchange.getRequestHeaders().getFirst(Headers.CONTENT_TYPE);
             if (contentType != null) {
-                String cs = Headers.extractTokenFromHeader(contentType, "charset");
+                String cs = Headers.extractQuotedValueFromHeader(contentType, "charset");
                 if (cs != null) {
                     charset = cs;
                 }

File: core/src/main/java/io/undertow/server/handlers/form/MultiPartParserDefinition.java
Patch:
@@ -272,7 +272,7 @@ public void endPart() {
                     String charset = defaultEncoding;
                     String contentType = headers.getFirst(Headers.CONTENT_TYPE);
                     if (contentType != null) {
-                        String cs = Headers.extractTokenFromHeader(contentType, "charset");
+                        String cs = Headers.extractQuotedValueFromHeader(contentType, "charset");
                         if (cs != null) {
                             charset = cs;
                         }

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -497,7 +497,7 @@ public String getCharacterEncoding() {
         if (contentType == null) {
             return null;
         }
-        return Headers.extractTokenFromHeader(contentType, "charset");
+        return Headers.extractQuotedValueFromHeader(contentType, "charset");
     }
 
     @Override
@@ -737,7 +737,7 @@ public BufferedReader getReader() throws IOException {
             } else {
                 String contentType = exchange.getRequestHeaders().getFirst(Headers.CONTENT_TYPE);
                 if (contentType != null) {
-                    String c = Headers.extractTokenFromHeader(contentType, "charset");
+                    String c = Headers.extractQuotedValueFromHeader(contentType, "charset");
                     if (c != null) {
                         try {
                             charSet = Charset.forName(c);

File: servlet/src/main/java/io/undertow/servlet/spec/ServletOutputStreamImpl.java
Patch:
@@ -603,9 +603,9 @@ public void close() throws IOException {
             if (allAreClear(state, FLAG_WRITE_STARTED) && channel == null) {
                 if(servletRequestContext.getOriginalResponse().getHeader(Headers.TRANSFER_ENCODING_STRING) == null) {
                     if (buffer == null) {
-                        servletRequestContext.getOriginalResponse().setHeader(Headers.CONTENT_LENGTH, "0");
+                        servletRequestContext.getExchange().getResponseHeaders().put(Headers.CONTENT_LENGTH, "0");
                     } else {
-                        servletRequestContext.getOriginalResponse().setHeader(Headers.CONTENT_LENGTH, Integer.toString(buffer.position()));
+                        servletRequestContext.getExchange().getResponseHeaders().put(Headers.CONTENT_LENGTH, Integer.toString(buffer.position()));
                     }
                 }
             }

File: servlet/src/main/java/io/undertow/servlet/util/SavedRequest.java
Patch:
@@ -55,7 +55,7 @@ public static void trySaveRequest(final HttpServerExchange exchange) {
                 int res = 0;
                 InputStream in = exchange.getInputStream();
                 try {
-                    while ((res = in.read(buffer)) > 0) {
+                    while ((res = in.read(buffer, read, buffer.length - read)) > 0) {
                         read += res;
                         if (read == maxSize) {
                             UndertowLogger.REQUEST_LOGGER.debugf("Request to %s was to large to save", exchange.getRequestURI());

File: core/src/main/java/io/undertow/server/Connectors.java
Patch:
@@ -169,6 +169,9 @@ public static void executeRootHandler(final HttpHandler handler, final HttpServe
             exchange.setInCall(false);
             boolean resumed = exchange.runResumeReadWrite();
             if (exchange.isDispatched()) {
+                if(resumed) {
+                    throw new RuntimeException("resumed and dispatched");
+                }
                 final Runnable dispatchTask = exchange.getDispatchTask();
                 Executor executor = exchange.getDispatchExecutor();
                 exchange.unDispatch();

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -1871,7 +1871,7 @@ public boolean isReadResumed() {
             if(isFinished()) {
                 return false;
             }
-            return anyAreClear(state, FLAG_SHOULD_RESUME_READS) || super.isReadResumed();
+            return anyAreSet(state, FLAG_SHOULD_RESUME_READS) || super.isReadResumed();
         }
 
         @Override

File: servlet/src/main/java/io/undertow/servlet/spec/HttpSessionImpl.java
Patch:
@@ -42,7 +42,7 @@
  */
 public class HttpSessionImpl implements HttpSession {
 
-    private static final RuntimePermission PERMISSION = new RuntimePermission("io.undertow.servlet.spec.UNWRAP_HTTTP_SESSION");
+    private static final RuntimePermission PERMISSION = new RuntimePermission("io.undertow.servlet.spec.UNWRAP_HTTP_SESSION");
 
     public static final String IO_UNDERTOW = "io.undertow";
     private final Session session;

File: core/src/main/java/io/undertow/UndertowLogger.java
Patch:
@@ -109,7 +109,7 @@ public interface UndertowLogger extends BasicLogger {
 
     @LogMessage(level = Logger.Level.ERROR)
     @Message(id = 5017, value = "Unknown variable %s")
-    void unkownVariable(String token);
+    void unknownVariable(String token);
 
     @LogMessage(level = Logger.Level.ERROR)
     @Message(id = 5018, value = "Exception invoking close listener %s")

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -99,7 +99,7 @@ public interface UndertowMessages {
     @Message(id = 22, value = "The specified hash algorithm '%s' can not be found.")
     IllegalArgumentException hashAlgorithmNotFound(String algorithmName);
 
-    @Message(id = 23, value = "An invalid Base64 token has been recieved.")
+    @Message(id = 23, value = "An invalid Base64 token has been received.")
     IllegalArgumentException invalidBase64Token(@Cause final IOException cause);
 
     @Message(id = 24, value = "An invalidly formatted nonce has been received.")
@@ -120,7 +120,7 @@ public interface UndertowMessages {
     @Message(id = 29, value = "Channel was closed mid chunk, if you have attempted to write chunked data you cannot shutdown the channel until after it has all been written.")
     IOException chunkedChannelClosedMidChunk();
 
-    @Message(id = 30, value = "User %s successfuly authenticated.")
+    @Message(id = 30, value = "User %s successfully authenticated.")
     String userAuthenticated(final String userName);
 
     @Message(id = 31, value = "User %s has logged out.")
@@ -222,7 +222,7 @@ public interface UndertowMessages {
     @Message(id = 65, value = "SSL must be specified to connect to a https URL")
     IllegalArgumentException sslWasNull();
 
-    @Message(id = 66, value = "Incorect magic number for AJP packet header")
+    @Message(id = 66, value = "Incorrect magic number for AJP packet header")
     IOException wrongMagicNumber();
 
     @Message(id = 67, value = "No client cert was provided")

File: core/src/main/java/io/undertow/attribute/ExchangeAttributeParser.java
Patch:
@@ -134,7 +134,7 @@ public ExchangeAttribute parseSingleToken(final String token) {
             }
         }
         if (token.startsWith("%")) {
-            UndertowLogger.ROOT_LOGGER.unkownVariable(token);
+            UndertowLogger.ROOT_LOGGER.unknownVariable(token);
         }
         return new ConstantExchangeAttribute(token);
     }

File: core/src/main/java/io/undertow/client/UndertowClientMessages.java
Patch:
@@ -42,10 +42,10 @@ public interface UndertowClientMessages {
     @Message(id = 1033, value = "Invalid connection state")
     IllegalStateException invalidConnectionState();
 
-    @Message(id = 1034, value = "Unkown AJP packet type %s")
+    @Message(id = 1034, value = "Unknown AJP packet type %s")
     IOException unknownAjpMessageType(byte packetType);
 
-    @Message(id = 1035, value = "Unkown method type for AJP request %s")
+    @Message(id = 1035, value = "Unknown method type for AJP request %s")
     IOException unknownMethod(HttpString method);
 
     @Message(id = 1036, value = "Data still remaining in chunk %s")

File: core/src/main/java/io/undertow/conduits/DeflatingStreamSinkConduit.java
Patch:
@@ -54,7 +54,7 @@ public class DeflatingStreamSinkConduit implements StreamSinkConduit {
     private static final int FLUSHING_BUFFER = 1 << 2;
     private static final int WRITES_RESUMED = 1 << 3;
     private static final int CLOSED = 1 << 4;
-    private static final int WRITTEN_TRAILIER = 1 << 5;
+    private static final int WRITTEN_TRAILER = 1 << 5;
 
     public DeflatingStreamSinkConduit(final ConduitFactory<StreamSinkConduit> conduitFactory, final HttpServerExchange exchange) {
         this(conduitFactory, exchange, Deflater.DEFLATED);
@@ -263,8 +263,8 @@ public boolean flush() throws IOException {
                         }
                     }
                     final ByteBuffer buffer = currentBuffer.getResource();
-                    if (allAreClear(WRITTEN_TRAILIER, state)) {
-                        state |= WRITTEN_TRAILIER;
+                    if (allAreClear(WRITTEN_TRAILER, state)) {
+                        state |= WRITTEN_TRAILER;
                         byte[] data  = getTrailer();
                         if(data != null) {
                             if(data.length <= buffer.remaining()) {

File: core/src/main/java/io/undertow/io/UndertowOutputStream.java
Patch:
@@ -38,7 +38,7 @@
 /**
  * Buffering output stream that wraps a channel.
  * <p/>
- * This stream delays channel creation, so if a response will fit in the buffer it is not nessesary to
+ * This stream delays channel creation, so if a response will fit in the buffer it is not necessary to
  * set the content length header.
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/predicate/PredicateBuilder.java
Patch:
@@ -39,18 +39,18 @@ public interface PredicateBuilder {
     String name();
 
     /**
-     * Returns a map of paramters and their types.
+     * Returns a map of parameters and their types.
      */
     Map<String, Class<?>> parameters();
 
     /**
      *
-     * @return The required paramaters
+     * @return The required parameters
      */
     Set<String> requiredParameters();
 
     /**
-     * @return The default parameter name, or null if it does not have a default paramter
+     * @return The default parameter name, or null if it does not have a default parameter
      */
     String defaultParameter();
 

File: core/src/main/java/io/undertow/predicate/Predicates.java
Patch:
@@ -58,9 +58,9 @@ public static Predicate suffix(final String path) {
     }
 
     /**
-     * creates a predicate that returns true if the request path ends with any of the provided suffixs
+     * creates a predicate that returns true if the request path ends with any of the provided suffixes
      */
-    public static Predicate suffixs(final String... paths) {
+    public static Predicate suffixes(final String... paths) {
         final PathSuffixPredicate[] predicates = new PathSuffixPredicate[paths.length];
         for (int i = 0; i < paths.length; ++i) {
             predicates[i] = new PathSuffixPredicate(paths[i]);
@@ -78,7 +78,7 @@ public static Predicate prefix(final String path) {
     /**
      * creates a predicate that returns true if the relative request path matches any of the provided prefixes
      */
-    public static Predicate prefixs(final String... paths) {
+    public static Predicate prefixes(final String... paths) {
         final PathPrefixPredicate[] predicates = new PathPrefixPredicate[paths.length];
         for (int i = 0; i < paths.length; ++i) {
             predicates[i] = new PathPrefixPredicate(paths[i]);

File: core/src/main/java/io/undertow/security/api/NonceManager.java
Patch:
@@ -54,7 +54,7 @@ public interface NonceManager {
      * This method is expected to ONLY be called if the users credentials are valid as a storage overhead could be incurred
      * this overhead must not be accessible to unauthenticated clients.
      *
-     * @param nonce - The nonce receieved from the client.
+     * @param nonce - The nonce received from the client.
      * @param nonceCount - The nonce count from the client or -1 of none specified.
      * @return true if the nonce can be used otherwise return false.
      */

File: core/src/main/java/io/undertow/security/api/SecurityContext.java
Patch:
@@ -34,7 +34,7 @@
 public interface SecurityContext {
 
     // TODO - Some of this is used within the core of undertow, some by the servlet integration and some by the mechanisms -
-    // once released the use by mechanisms will require the greatest level of backwards compatibility maintenace so may be
+    // once released the use by mechanisms will require the greatest level of backwards compatibility maintenance so may be
     // better to split the rest out.
 
     /*
@@ -49,7 +49,7 @@ public interface SecurityContext {
      * If the result indicates that a response has been sent to the client then no further attempts should be made to modify the
      * response. The caller of this method is responsible for ending the exchange.
      *
-     * If this method returns <code>true</code> it can still have committedd the response (e.g. form auth redirects back to the original
+     * If this method returns <code>true</code> it can still have committed the response (e.g. form auth redirects back to the original
      * page). Callers should check that the exchange has not been ended before proceeding.
      *
      * @return <code>true</code> if either the request is successfully authenticated or if there is no failure validating the

File: core/src/main/java/io/undertow/security/api/SessionNonceManager.java
Patch:
@@ -22,7 +22,7 @@
  * hash against a currently valid nonce.
  *
  * If the nonce manager replaces in-use nonces as old ones expire then the associated session hash should be migrated to the
- * replacment nonce.
+ * replacement nonce.
  *
  * @author <a href="mailto:darran.lofthouse@jboss.com">Darran Lofthouse</a>
  */

File: core/src/main/java/io/undertow/security/handlers/SinglePortConfidentialityHandler.java
Patch:
@@ -24,7 +24,7 @@
 import java.net.URISyntaxException;
 
 /**
- * An extension to {@see AbstractConfidentialityHandler} that uses the Host header from the incomming message and specifies the
+ * An extension to {@see AbstractConfidentialityHandler} that uses the Host header from the incoming message and specifies the
  * confidential address by just switching the port.
  *
  * @author <a href="mailto:darran.lofthouse@jboss.com">Darran Lofthouse</a>

File: core/src/main/java/io/undertow/security/impl/SimpleNonceManager.java
Patch:
@@ -91,7 +91,7 @@ public class SimpleNonceManager implements SessionNonceManager {
 
     /**
      * A pseudo-random generator for creating the nonces, a secure random is not required here as this is used purely to
-     * minimise the chance of colisions should two nonces be generated at exactly the same time.
+     * minimise the chance of collisions should two nonces be generated at exactly the same time.
      */
     private final Random random = new Random();
 
@@ -238,7 +238,7 @@ public boolean validateNonce(String nonce, int nonceCount, HttpServerExchange ex
         XnioExecutor executor = exchange.getIoThread();
         if (nonceCount < 0) {
             if (invalidNonces.contains(nonce)) {
-                // Without a nonce count the nonce is only useable once.
+                // Without a nonce count the nonce is only usable once.
                 return false;
             }
             // Not already known so will drop into first use validation.

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -399,7 +399,7 @@ public HttpServerExchange setRequestURI(final String requestURI) {
      * Sets the request URI
      *
      * @param requestURI   The new request URI
-     * @param containsHost If this is true the request URI containst the host part
+     * @param containsHost If this is true the request URI contains the host part
      */
     public HttpServerExchange setRequestURI(final String requestURI, boolean containsHost) {
         this.requestURI = requestURI;

File: core/src/main/java/io/undertow/server/handlers/RedirectHandler.java
Patch:
@@ -8,7 +8,7 @@
 import io.undertow.util.Headers;
 
 /**
- * A redirect handler that redirects to the specifed location via a 302 redirect.
+ * A redirect handler that redirects to the specified location via a 302 redirect.
  * <p/>
  * The location is specified as an exchange attribute string.
  *

File: core/src/main/java/io/undertow/server/handlers/accesslog/DefaultAccessLogReceiver.java
Patch:
@@ -135,15 +135,15 @@ void awaitWrittenForTest() throws InterruptedException {
         }
     }
 
-    private void writeMessage(final List<String> messsages) {
+    private void writeMessage(final List<String> messages) {
         if (System.currentTimeMillis() > changeOverPoint) {
             doRotate();
         }
         try {
             if (writer == null) {
                 writer = new BufferedWriter(new FileWriter(defaultLogFile));
             }
-            for (String message : messsages) {
+            for (String message : messages) {
                 writer.write(message);
                 writer.write('\n');
             }

File: core/src/main/java/io/undertow/server/handlers/cache/ResponseCache.java
Patch:
@@ -62,7 +62,7 @@ public ResponseCache(final DirectBufferCache cache, final HttpServerExchange exc
      * If this returns true then the caller should not modify the exchange any more, as this
      * can result in a handoff to an IO thread
      *
-     * @return <code>true</code> if serving suceeded,
+     * @return <code>true</code> if serving succeeded,
      */
     public boolean tryServeResponse() {
         return tryServeResponse(true);
@@ -78,7 +78,7 @@ public boolean tryServeResponse() {
      * can result in a handoff to an IO thread
      *
      * @param markCacheable If this is true then the resulting response will be considered cachable
-     * @return <code>true</code> if serving suceeded,
+     * @return <code>true</code> if serving succeeded,
      */
     public boolean tryServeResponse(boolean markCacheable) {
         final CachedHttpRequest key = new CachedHttpRequest(exchange);

File: core/src/main/java/io/undertow/server/handlers/encoding/ContentEncodedResourceManager.java
Patch:
@@ -94,7 +94,7 @@ public ContentEncodedResource getResource(final Resource resource, final HttpSer
         FileChannel targetFileChannel = null;
         FileChannel sourceFileChannel = null;
         try {
-            //double check, the compressing thread could have finished just before we aquired the lock
+            //double check, the compressing thread could have finished just before we acquired the lock
             preCompressed = encoded.getResource(newPath);
             if (preCompressed != null) {
                 return new ContentEncodedResource(preCompressed, encoding.getName());

File: core/src/main/java/io/undertow/server/handlers/proxy/ProxyHandler.java
Patch:
@@ -493,7 +493,7 @@ public void handleException(Channel channel, IOException exception) {
     /**
      * perform URL encoding
      * <p/>
-     * TODO: this whole thing is kinda crapy.
+     * TODO: this whole thing is kinda crappy.
      *
      * @return
      */

File: core/src/main/java/io/undertow/server/handlers/resource/ResourceHandler.java
Patch:
@@ -56,7 +56,7 @@ public class ResourceHandler implements HttpHandler {
      * we do not calculate a new expiry date every request. Instead calculate it once
      * and cache it until it is in the past.
      * <p/>
-     * TODO: do we need this policy to be plugable
+     * TODO: do we need this policy to be pluggable
      */
     private volatile long lastExpiryDate;
     private volatile String lastExpiryHeader;

File: core/src/main/java/io/undertow/server/protocol/http/HttpRequestParser.java
Patch:
@@ -463,7 +463,7 @@ final void handleQueryParameters(ByteBuffer buffer, ParseState state, HttpServer
         //also deals with URL decoding the query parameters as well, while also
         //maintaining a non-decoded version to use as the query string
         //In most cases these string will be the same, and as we do not want to
-        //build up two seperate strings we don't use encodedStringBuilder unless
+        //build up two separate strings we don't use encodedStringBuilder unless
         //we encounter an encoded character
 
         while (buffer.hasRemaining()) {

File: core/src/main/java/io/undertow/server/protocol/http/PipeliningBufferingStreamSinkConduit.java
Patch:
@@ -183,7 +183,7 @@ private long flushBufferWithUserData(final ByteBuffer[] byteBuffers) throws IOEx
      * <p/>
      * If this returns false the read thread should suspend reads and resume writes
      *
-     * @return <code>true</code> If the flush suceeded, false otherwise
+     * @return <code>true</code> If the flush succeeded, false otherwise
      * @throws IOException
      */
     public boolean flushPipelinedData() throws IOException {

File: core/src/main/java/io/undertow/util/MultipartParser.java
Patch:
@@ -150,7 +150,7 @@ private void preamble(final ByteBuffer buffer) {
                 } else if (subState == -2) {
                     if (b == LF) {
                         subState = 0;
-                        state = 1;//preaamble is done
+                        state = 1;//preamble is done
                         headers = new HeaderMap();
                         return;
                     } else {
@@ -186,7 +186,7 @@ private void headerName(final ByteBuffer buffer) throws MalformedMessageExceptio
                     state = 3;
                     subState = 0;
                     partHandler.beginPart(headers);
-                    //select the approriate encoding
+                    //select the appropriate encoding
                     String encoding = headers.getFirst(Headers.CONTENT_TRANSFER_ENCODING);
                     if (encoding == null) {
                         encodingHandler = new IdentityEncoding();

File: core/src/main/java/io/undertow/util/PathTemplate.java
Patch:
@@ -146,7 +146,7 @@ public static PathTemplate create(final String path) {
      * Check if the given uri matches the template. If so then it will return true and
      * place the value of any path parameters into the given map.
      * <p/>
-     * Note the map may be modified even if the match in unsucessful, however in this case
+     * Note the map may be modified even if the match in unsuccessful, however in this case
      * it will be emptied before the method returns
      *
      * @param path           The request path, relative to the context root

File: core/src/main/java/io/undertow/util/PathTemplateMatcher.java
Patch:
@@ -82,14 +82,14 @@ public synchronized PathTemplateMatcher<T> add(final PathTemplate template, fina
         }
         PathTemplateHolder holder = new PathTemplateHolder(value, template);
         if (newValues.contains(holder)) {
-            PathTemplate equivilent = null;
+            PathTemplate equivalent = null;
             for (PathTemplateHolder item : newValues) {
                 if (item.compareTo(holder) == 0) {
-                    equivilent = item.template;
+                    equivalent = item.template;
                     break;
                 }
             }
-            throw UndertowMessages.MESSAGES.matcherAlreadyContainsTemplate(template.getTemplateString(), equivilent.getTemplateString());
+            throw UndertowMessages.MESSAGES.matcherAlreadyContainsTemplate(template.getTemplateString(), equivalent.getTemplateString());
         }
         newValues.add(holder);
         pathTemplateMap.put(trimBase(template), newValues);

File: core/src/main/java/io/undertow/util/RedirectBuilder.java
Patch:
@@ -85,7 +85,7 @@ public static String redirect(final HttpServerExchange exchange, final String ne
     /**
      * perform URL encoding
      * <p/>
-     * TODO: this whole thing is kinda crapy.
+     * TODO: this whole thing is kinda crappy.
      *
      * @return
      */

File: core/src/main/java/io/undertow/util/StatusCodes.java
Patch:
@@ -79,7 +79,7 @@ public class StatusCodes {
     public static final String RESET_CONTENT_STRING = "Reset Content";
     public static final String PARTIAL_CONTENT_STRING = "Partial Content";
     public static final String MULTIPLE_CHOICES_STRING = "Multiple Choices";
-    public static final String MOVED_PERMENANTLY_STRING = "Moved Permanently";
+    public static final String MOVED_PERMANENTLY_STRING = "Moved Permanently";
     public static final String FOUND_STRING = "Found";
     public static final String SEE_OTHER_STRING = "See Other";
     public static final String NOT_MODIFIED_STRING = "Not Modified";
@@ -121,7 +121,7 @@ public class StatusCodes {
         putCode(RESET_CONTENT, RESET_CONTENT_STRING);
         putCode(PARTIAL_CONTENT, PARTIAL_CONTENT_STRING);
         putCode(MULTIPLE_CHOICES, MULTIPLE_CHOICES_STRING);
-        putCode(MOVED_PERMENANTLY, MOVED_PERMENANTLY_STRING);
+        putCode(MOVED_PERMENANTLY, MOVED_PERMANENTLY_STRING);
         putCode(FOUND, FOUND_STRING);
         putCode(SEE_OTHER, SEE_OTHER_STRING);
         putCode(NOT_MODIFIED, NOT_MODIFIED_STRING);

File: core/src/main/java/io/undertow/websockets/core/StreamSinkFrameChannel.java
Patch:
@@ -58,14 +58,14 @@ public void setRsv(int rsv) {
     }
 
     /**
-     * {@code true} if fragementation is supported for the {@link WebSocketFrameType}.
+     * {@code true} if fragmentation is supported for the {@link WebSocketFrameType}.
      */
     public boolean isFragmentationSupported() {
         return false;
     }
 
     /**
-     * {@code true} if extendsions are supported for the {@link WebSocketFrameType}.
+     * {@code true} if extensions are supported for the {@link WebSocketFrameType}.
      */
     public boolean areExtensionsSupported() {
         return false;

File: core/src/main/java/io/undertow/websockets/core/WebSocketChannel.java
Patch:
@@ -329,7 +329,7 @@ public void handleException(final StreamSinkChannel channel, final IOException e
      * Create a new StreamSinkFrameChannel which can be used to send a WebSocket Frame of the type {@link WebSocketFrameType}.
      *
      * @param type        The {@link WebSocketFrameType} of the WebSocketFrame which will be send over this {@link StreamSinkFrameChannel}
-     * @param payloadSize The size of the payload to transmit. May be 0 if non payload at all should be included, or -1 if unkown
+     * @param payloadSize The size of the payload to transmit. May be 0 if non payload at all should be included, or -1 if unknown
      */
     protected abstract StreamSinkFrameChannel createStreamSinkChannel(WebSocketFrameType type, long payloadSize);
 

File: core/src/main/java/io/undertow/websockets/core/WebSocketUtils.java
Patch:
@@ -118,7 +118,7 @@ public static String toUtf8String(ByteBuffer... buffers) {
     }
 
     /**
-     * Transfer the data from the source to the sink using the given throughbuffer to pass data through.
+     * Transfer the data from the source to the sink using the given through buffer to pass data through.
      */
     public static long transfer(final ReadableByteChannel source, final long count, final ByteBuffer throughBuffer, final WritableByteChannel sink) throws IOException {
         long total = 0L;

File: core/src/main/java/io/undertow/websockets/core/protocol/version07/Base64.java
Patch:
@@ -93,7 +93,7 @@
  * <li><em>Does not break lines, by default.</em> This is to keep in compliance with <a
  * href="http://www.faqs.org/rfcs/rfc3548.html">RFC3548</a>.</li>
  * <li><em>Throws exceptions instead of returning null values.</em> Because some operations (especially those that may permit
- * the GZIP option) use IO streams, there is a possiblity of an java.io.IOException being thrown. After some discussion and
+ * the GZIP option) use IO streams, there is a possibility of an java.io.IOException being thrown. After some discussion and
  * thought, I've changed the behavior of the methods to throw java.io.IOExceptions rather than return null if ever there's an
  * error. I think this is more appropriate, though it will require some changes to your code. Sorry, it should have been done
  * this way to begin with.</li>
@@ -128,7 +128,7 @@
  * <li>v1.5.1 - Fixed bug when decompressing and decoding to a byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.
  * Added the ability to "suspend" encoding in the Output Stream so you can turn on and off the encoding if you need to embed
  * base64 data in an otherwise "normal" stream (like an XML file).</li>
- * <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself. This helps when using GZIP streams. Added
+ * <li>v1.5 - Output stream passes on flush() command but doesn't do anything itself. This helps when using GZIP streams. Added
  * the ability to GZip-compress objects before encoding them.</li>
  * <li>v1.4 - Added helper methods to read/write files.</li>
  * <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>
@@ -928,7 +928,7 @@ public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int opt
      * Decodes four bytes from array <var>source</var> and writes the resulting bytes (up to three of them) to
      * <var>destination</var>. The source and destination arrays can be manipulated anywhere along their length by specifying
      * <var>srcOffset</var> and <var>destOffset</var>. This method does not check to make sure your arrays are large enough to
-     * accomodate <var>srcOffset</var> + 4 for the <var>source</var> array or <var>destOffset</var> + 3 for the
+     * accommodate <var>srcOffset</var> + 4 for the <var>source</var> array or <var>destOffset</var> + 3 for the
      * <var>destination</var> array. This method returns the actual number of bytes that were converted from the Base64
      * encoding.
      * <p>

File: core/src/main/java/io/undertow/websockets/core/protocol/version07/UTF8Checker.java
Patch:
@@ -72,7 +72,7 @@ private void checkUTF8(int b) throws UnsupportedEncodingException {
      *
      * @param buf           the ByteBuffer to check
      * @param position      the index in the {@link ByteBuffer} to start from
-     * @param length        the number of byted to operate on
+     * @param length        the number of bytes to operate on
      * @throws UnsupportedEncodingException     is thrown if non UTF-8 data is found
      */
     private void checkUTF8(ByteBuffer buf, int position, int length) throws UnsupportedEncodingException {

File: core/src/main/java/io/undertow/websockets/core/protocol/version07/WebSocket07Channel.java
Patch:
@@ -174,10 +174,10 @@ public StreamSourceFrameChannel createChannel(Pooled<ByteBuffer> pooled) {
                 }
 
                 if (!frameFinalFlag) {
-                    // if this is not the final fragment store the used checker to use it in later fragements also
+                    // if this is not the final fragment store the used checker to use it in later fragments also
                     WebSocket07Channel.this.checker = checker;
                 } else {
-                    // was the final fragement reset the checker to null
+                    // was the final fragment reset the checker to null
                     WebSocket07Channel.this.checker = null;
                 }
 
@@ -236,7 +236,7 @@ public void handle(final ByteBuffer buffer) throws WebSocketException {
                             WebSocketLogger.REQUEST_LOGGER.decodingFrameWithOpCode(frameOpcode);
                         }
                         state = State.READING_SECOND;
-                        // clear the lenghtbuffer to reuse it later
+                        // clear the lengthBuffer to reuse it later
                         lengthBuffer.clear();
                     case READING_SECOND:
                         if (!buffer.hasRemaining()) {

File: core/src/main/java/io/undertow/websockets/core/protocol/version08/Hybi08Handshake.java
Patch:
@@ -28,7 +28,7 @@
 import java.util.Set;
 
 /**
- * The handshaking protocol impelemtation for Hybi-07, which is identical to Hybi-08, and thus is just a thin
+ * The handshaking protocol implementation for Hybi-07, which is identical to Hybi-08, and thus is just a thin
  * subclass of {@link Hybi07Handshake} that sets a different version number.
  *
  * @author Mike Brock

File: core/src/test/java/io/undertow/server/MaxRequestSizeTestCase.java
Patch:
@@ -58,10 +58,10 @@ public static void setup() {
             public void handleRequest(final HttpServerExchange exchange) {
                 try {
                     final OutputStream outputStream = exchange.getOutputStream();
-                    final InputStream inputSream = exchange.getInputStream();
-                    String m = HttpClientUtils.readResponse(inputSream);
+                    final InputStream inputStream = exchange.getInputStream();
+                    String m = HttpClientUtils.readResponse(inputStream);
                     Assert.assertEquals(A_MESSAGE, m);
-                    inputSream.close();
+                    inputStream.close();
                     outputStream.close();
                 } catch (IOException e) {
                     try {

File: core/src/test/java/io/undertow/server/handlers/proxy/LoadBalancingProxyTestCase.java
Patch:
@@ -138,7 +138,7 @@ public void testLoadSharedWithServerShutdown() throws IOException {
     }
 
     @Test
-    public void testStickeySessions() throws IOException {
+    public void testStickySessions() throws IOException {
         int expected = 0;
         TestHttpClient client = new TestHttpClient();
         try {

File: core/src/test/java/io/undertow/websockets/utils/WebSocketTestClient.java
Patch:
@@ -100,7 +100,7 @@ public ChannelPipeline getPipeline() throws Exception {
     }
 
     /**
-     * Send the WebSocketFrame and call the FrameListener once a frame was received as resposne or
+     * Send the WebSocketFrame and call the FrameListener once a frame was received as response or
      * when an Exception was caught.
      */
     public WebSocketTestClient send(WebSocketFrame frame, final FrameListener listener) {
@@ -141,7 +141,7 @@ public interface FrameListener {
         void onFrame(WebSocketFrame frame);
 
         /**
-         * Is called if an error accured
+         * Is called if an error occurred
          */
         void onError(Throwable t);
     }

File: servlet/src/main/java/io/undertow/servlet/core/BlockingWriterSenderImpl.java
Patch:
@@ -239,7 +239,7 @@ private void invokeOnComplete(final IoCallback callback) {
     }
 
     private void queue(final ByteBuffer[] byteBuffers, final IoCallback ioCallback) {
-        //if data is sent from withing the callback we queue it, to prevent the stack growing indefinitly
+        //if data is sent from withing the callback we queue it, to prevent the stack growing indefinitely
         if (next != null || pendingFile != null) {
             throw UndertowMessages.MESSAGES.dataAlreadyQueued();
         }
@@ -257,15 +257,15 @@ private void queue(final ByteBuffer[] byteBuffers, final IoCallback ioCallback)
     }
 
     private void queue(final String data, final IoCallback callback) {
-        //if data is sent from withing the callback we queue it, to prevent the stack growing indefinitly
+        //if data is sent from withing the callback we queue it, to prevent the stack growing indefinitely
         if (next != null || pendingFile != null) {
             throw UndertowMessages.MESSAGES.dataAlreadyQueued();
         }
         next = data;
         queuedCallback = callback;
     }
     private void queue(final FileChannel data, final IoCallback callback) {
-        //if data is sent from withing the callback we queue it, to prevent the stack growing indefinitly
+        //if data is sent from withing the callback we queue it, to prevent the stack growing indefinitely
         if (next != null || pendingFile != null) {
             throw UndertowMessages.MESSAGES.dataAlreadyQueued();
         }

File: servlet/src/main/java/io/undertow/servlet/spec/AsyncContextImpl.java
Patch:
@@ -225,7 +225,7 @@ public void dispatch(final ServletContext context, final String path) {
         }
         String newRequestUri = context.getContextPath() + newServletPath;
 
-        //todo: a more efficent impl
+        //todo: a more efficient impl
         Map<String, Deque<String>> newQueryParameters = new HashMap<String, Deque<String>>();
         for (String part : newQueryString.split("&")) {
             String name = part;

File: servlet/src/test/java/io/undertow/servlet/test/security/constraint/AuthenticationMessageServlet.java
Patch:
@@ -52,7 +52,7 @@ private void checkExpectedMechanism(HttpServletRequest req) {
         }
         if (expectedMechanism.equals("None")) {
             if (req.getAuthType() != null) {
-                throw new IllegalStateException("Authentication occured when not expected.");
+                throw new IllegalStateException("Authentication occurred when not expected.");
             }
         } else if (expectedMechanism.equals("BASIC")) {
             if (req.getAuthType() != HttpServletRequest.BASIC_AUTH) {

File: servlet/src/test/java/io/undertow/servlet/test/session/CrossContextServletSessionTestCase.java
Patch:
@@ -45,7 +45,7 @@
 
 /**
  *
- * Test that seperate servlet deployments use seperate session managers, even in the presence of forwards,
+ * Test that separate servlet deployments use seperate session managers, even in the presence of forwards,
  * and that sessions created in a forwarded context are accessible to later direct requests
  *
  * @author Stuart Douglas

File: core/src/main/java/io/undertow/server/handlers/HttpTraceHandler.java
Patch:
@@ -40,6 +40,7 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
                 }
             }
             body.append("\r\n");
+            exchange.getResponseSender().send(body.toString());
         } else {
             handler.handleRequest(exchange);
         }

File: core/src/test/java/io/undertow/server/handlers/proxy/LoadBalancingProxyTestCase.java
Patch:
@@ -66,14 +66,14 @@ public static void setup() throws URISyntaxException {
         server1 = Undertow.builder()
                 .addListener(port + 1, DefaultServer.getHostAddress("default"))
                 .setHandler(jvmRoute("JSESSIONID", "s1", path()
-                        .addPrefixPath("/session", new SessionAttachmentHandler(new SessionTestHandler(sessionConfig), new InMemorySessionManager(), sessionConfig))
+                        .addPrefixPath("/session", new SessionAttachmentHandler(new SessionTestHandler(sessionConfig), new InMemorySessionManager(""), sessionConfig))
                         .addPrefixPath("/name", new StringSendHandler("server1"))))
                 .build();
 
         server2 = Undertow.builder()
                 .addListener(port + 2, DefaultServer.getHostAddress("default"))
                 .setHandler(jvmRoute("JSESSIONID", "s2", path()
-                        .addPrefixPath("/session", new SessionAttachmentHandler(new SessionTestHandler(sessionConfig), new InMemorySessionManager(), sessionConfig))
+                        .addPrefixPath("/session", new SessionAttachmentHandler(new SessionTestHandler(sessionConfig), new InMemorySessionManager(""), sessionConfig))
                         .addPrefixPath("/name", new StringSendHandler("server2"))))
                 .build();
         server1.start();

File: core/src/test/java/io/undertow/server/handlers/session/InMemorySessionTestCase.java
Patch:
@@ -55,7 +55,7 @@ public void inMemorySessionTest() throws IOException {
         client.setCookieStore(new BasicCookieStore());
         try {
             final SessionCookieConfig sessionConfig = new SessionCookieConfig();
-            final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager(), sessionConfig);
+            final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager(""), sessionConfig);
             handler.setNext(new HttpHandler() {
                 @Override
                 public void handleRequest(final HttpServerExchange exchange) throws Exception {
@@ -111,7 +111,7 @@ public void inMemoryMaxSessionsTest() throws IOException {
 
         try {
             final SessionCookieConfig sessionConfig = new SessionCookieConfig();
-            final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager(1), sessionConfig);
+            final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager("", 1), sessionConfig);
             handler.setNext(new HttpHandler() {
                 @Override
                 public void handleRequest(final HttpServerExchange exchange) throws Exception {

File: core/src/test/java/io/undertow/server/handlers/session/SSLSessionTestCase.java
Patch:
@@ -57,7 +57,7 @@ public void testSslSession() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
             final SslSessionConfig sessionConfig = new SslSessionConfig();
-            final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager(), sessionConfig)
+            final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager(""), sessionConfig)
                     .setNext(new HttpHandler() {
                         @Override
                         public void handleRequest(final HttpServerExchange exchange) throws Exception {

File: core/src/test/java/io/undertow/server/handlers/session/URLRewritingSessionTestCase.java
Patch:
@@ -55,7 +55,7 @@ public class URLRewritingSessionTestCase {
     @BeforeClass
     public static void setup() {
         final PathParameterSessionConfig sessionConfig = new PathParameterSessionConfig();
-        final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager(), sessionConfig);
+        final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager(""), sessionConfig);
         handler.setNext(new HttpHandler() {
             @Override
             public void handleRequest(final HttpServerExchange exchange) throws Exception {

File: servlet/src/main/java/io/undertow/servlet/core/InMemorySessionManagerFactory.java
Patch:
@@ -41,6 +41,6 @@ public InMemorySessionManagerFactory(int maxSessions) {
 
     @Override
     public SessionManager createSessionManager(Deployment deployment) {
-        return new InMemorySessionManager(maxSessions);
+        return new InMemorySessionManager(deployment.getDeploymentInfo().getDeploymentName(), maxSessions);
     }
 }

File: core/src/main/java/io/undertow/Handlers.java
Patch:
@@ -66,7 +66,7 @@ public static PathTemplateHandler pathTemplate() {
 
     /**
      *
-     * @param rewriteQueryParams If the query params should be rewitten
+     * @param rewriteQueryParams If the query params should be rewritten
      * @return The path template handler
      */
     public static PathTemplateHandler pathTemplate(boolean rewriteQueryParams) {
@@ -160,7 +160,7 @@ public static RedirectHandler redirect(final String location) {
      * Returns a new HTTP trace handler. This handler will handle HTTP TRACE
      * requests as per the RFC.
      * <p/>
-     * WARNING: enabling trace requests may leak information, in general it is recomended that
+     * WARNING: enabling trace requests may leak information, in general it is recommended that
      * these be disabled for security reasons.
      *
      * @param next The next handler in the chain
@@ -323,7 +323,7 @@ public static GracefulShutdownHandler gracefulShutdown(HttpHandler next) {
 
     /**
      * Returns a new handler that sets the peer address based on the X-Forwarded-For and
-     * X-Forwared-Proto header
+     * X-Forwarded-Proto header
      * @param next The next http handler
      * @return The handler
      */

File: core/src/main/java/io/undertow/attribute/ExchangeAttributeBuilder.java
Patch:
@@ -28,7 +28,7 @@
 public interface ExchangeAttributeBuilder {
 
     /**
-     * The string representation of the attribute name. This is used solelfy for debugging / informational purposes
+     * The string representation of the attribute name. This is used solely for debugging / informational purposes
      *
      * @return The attribute name
      */

File: core/src/main/java/io/undertow/attribute/ExchangeAttributeParser.java
Patch:
@@ -19,15 +19,15 @@
  */
 public class ExchangeAttributeParser {
 
-    private final List<ExchangeAttributeBuilder> buiders;
+    private final List<ExchangeAttributeBuilder> builders;
 
     ExchangeAttributeParser(final ClassLoader classLoader) {
         ServiceLoader<ExchangeAttributeBuilder> loader = ServiceLoader.load(ExchangeAttributeBuilder.class, classLoader);
         final List<ExchangeAttributeBuilder> builders = new ArrayList<ExchangeAttributeBuilder>();
         for (ExchangeAttributeBuilder instance : loader) {
             builders.add(instance);
         }
-        this.buiders = Collections.unmodifiableList(builders);
+        this.builders = Collections.unmodifiableList(builders);
 
     }
 
@@ -127,7 +127,7 @@ public ExchangeAttribute parse(final String valueString) {
     }
 
     public ExchangeAttribute parseSingleToken(final String token) {
-        for (final ExchangeAttributeBuilder builder : buiders) {
+        for (final ExchangeAttributeBuilder builder : builders) {
             ExchangeAttribute res = builder.build(token);
             if (res != null) {
                 return res;

File: core/src/main/java/io/undertow/client/http/HttpClientConnection.java
Patch:
@@ -210,13 +210,13 @@ public void sendRequest(final ClientRequest request, final ClientCallback<Client
         }
         final HttpClientExchange httpClientExchange = new HttpClientExchange(clientCallback, request, this);
         if (currentRequest == null) {
-            inititateRequest(httpClientExchange);
+            initiateRequest(httpClientExchange);
         } else {
             pendingQueue.add(httpClientExchange);
         }
     }
 
-    private void inititateRequest(HttpClientExchange httpClientExchange) {
+    private void initiateRequest(HttpClientExchange httpClientExchange) {
         currentRequest = httpClientExchange;
         pendingResponse = new HttpResponseBuilder();
         ClientRequest request = httpClientExchange.getRequest();
@@ -364,7 +364,7 @@ public void requestDone() {
             connection.getSourceChannel().setReadListener(clientReadListener);
             connection.getSourceChannel().resumeReads();
         } else {
-            inititateRequest(next);
+            initiateRequest(next);
         }
     }
 

File: core/src/main/java/io/undertow/conduits/ChunkedStreamSourceConduit.java
Patch:
@@ -314,7 +314,7 @@ public int read(final ByteBuffer dst) throws IOException {
                 }
                 //there is still more to read
                 //we attempt to just read it directly into the destination buffer
-                //adjusting the limit as nessesary to make sure we do not read too much
+                //adjusting the limit as necessary to make sure we do not read too much
                 if (chunkRemaining > 0) {
                     int old = dst.limit();
                     try {

File: core/src/main/java/io/undertow/io/BlockingSenderImpl.java
Patch:
@@ -256,7 +256,7 @@ private void invokeOnComplete(final IoCallback callback) {
     }
 
     private void queue(final ByteBuffer[] byteBuffers, final IoCallback ioCallback) {
-        //if data is sent from withing the callback we queue it, to prevent the stack growing indefinitly
+        //if data is sent from withing the callback we queue it, to prevent the stack growing indefinitely
         if (next != null) {
             throw UndertowMessages.MESSAGES.dataAlreadyQueued();
         }
@@ -265,7 +265,7 @@ private void queue(final ByteBuffer[] byteBuffers, final IoCallback ioCallback)
     }
 
     private void queue(final FileChannel source, final IoCallback ioCallback) {
-        //if data is sent from withing the callback we queue it, to prevent the stack growing indefinitly
+        //if data is sent from withing the callback we queue it, to prevent the stack growing indefinitely
         if (pendingFile != null) {
             throw UndertowMessages.MESSAGES.dataAlreadyQueued();
         }

File: core/src/main/java/io/undertow/security/impl/DigestAuthenticationMechanism.java
Patch:
@@ -606,7 +606,7 @@ private class AuthenticationException extends Exception {
 
         private static final long serialVersionUID = 4123187263595319747L;
 
-        // TODO - Remove unused constrcutors and maybe even move exception to higher level.
+        // TODO - Remove unused constructors and maybe even move exception to higher level.
 
         public AuthenticationException() {
             super();

File: core/src/main/java/io/undertow/server/AbstractServerConnection.java
Patch:
@@ -223,7 +223,7 @@ public void clearChannel() {
         channel.getSourceChannel().setConduit(originalSourceConduit);
     }
     /**
-     * Resores the channel conduits to a previous state.
+     * Restores the channel conduits to a previous state.
      *
      * @param state The original state
      * @see #resetChannel()

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -1080,7 +1080,7 @@ private void invokeExchangeCompleteListeners() {
     /**
      * Get the response channel. The channel must be closed and fully flushed before the next response can be started.
      * In order to close the channel you must first call {@link org.xnio.channels.StreamSinkChannel#shutdownWrites()},
-     * and then call {@link org.xnio.channels.StreamSinkChannel#flush()} until it returns true. Alternativly you can
+     * and then call {@link org.xnio.channels.StreamSinkChannel#flush()} until it returns true. Alternatively you can
      * call {@link #endExchange()}, which will close the channel as part of its cleanup.
      * <p/>
      * Closing a fixed-length response before the corresponding number of bytes has been written will cause the connection

File: core/src/main/java/io/undertow/server/handlers/GracefulShutdownHandler.java
Patch:
@@ -165,8 +165,8 @@ public interface ShutdownListener {
         /**
          * Notification that the container has shutdown.
          *
-         * @param shutdownSucessful If the shutdown suceeded or not
+         * @param shutdownSuccessful If the shutdown succeeded or not
          */
-        void shutdown(boolean shutdownSucessful);
+        void shutdown(boolean shutdownSuccessful);
     }
 }

File: core/src/main/java/io/undertow/server/handlers/builder/HandlerParser.java
Patch:
@@ -254,7 +254,7 @@ private static Object coerceToType(final String string, final Token token, final
             return Byte.valueOf(token.token);
         } else if (type.equals(Character.class) || type.equals(char.class)) {
             if (token.token.length() != 1) {
-                throw error(string, token.position, "Cannot cooerce " + token.token + " to a Character");
+                throw error(string, token.position, "Cannot coerce " + token.token + " to a Character");
             }
             return Character.valueOf(token.token.charAt(0));
         } else if (type.equals(Short.class) || type.equals(short.class)) {
@@ -274,7 +274,7 @@ private static Object coerceToType(final String string, final Token token, final
         return token.token;
     }
 
-    private static int precidence(String operator) {
+    private static int precedence(String operator) {
         if (operator.equals("not")) {
             return 3;
         } else if (operator.equals("and")) {

File: core/src/main/java/io/undertow/server/handlers/cache/CachedHttpRequest.java
Patch:
@@ -36,7 +36,7 @@ public CachedHttpRequest(final HttpServerExchange exchange) {
             this.lastModified = DateUtils.parseDate(lmString);
         }
         //the content encoding can be decided dynamically, based on the current state of the request
-        //as the decision to compress generally dependends on size and mime type
+        //as the decision to compress generally depends on size and mime type
         final AllowedContentEncodings encoding = exchange.getAttachment(AllowedContentEncodings.ATTACHMENT_KEY);
         if(encoding != null) {
             this.contentEncoding = encoding.getCurrentContentEncoding();

File: core/src/main/java/io/undertow/server/handlers/encoding/ContentEncodedResourceManager.java
Patch:
@@ -116,10 +116,10 @@ public ContentEncodedResource getResource(final Resource resource, final HttpSer
 
             StreamSinkConduit conduit = encoding.getEncoding().getResponseWrapper().wrap(new ImmediateConduitFactory<StreamSinkConduit>(new FileConduitTarget(targetFileChannel, exchange)), exchange);
             final ConduitStreamSinkChannel targetChannel = new ConduitStreamSinkChannel(null, conduit);
-            long transfered = sourceFileChannel.transferTo(0, resource.getContentLength(), targetChannel);
+            long transferred = sourceFileChannel.transferTo(0, resource.getContentLength(), targetChannel);
             targetChannel.shutdownWrites();
             org.xnio.channels.Channels.flushBlocking(targetChannel);
-            if (transfered != resource.getContentLength()) {
+            if (transferred != resource.getContentLength()) {
                 UndertowLogger.REQUEST_LOGGER.error("Failed to write pre-cached file");
             }
             tempTarget.renameTo(finalTarget);

File: core/src/main/java/io/undertow/server/handlers/form/FormEncodedDataDefinition.java
Patch:
@@ -35,7 +35,7 @@
 import org.xnio.channels.StreamSourceChannel;
 
 /**
- * Parser defintion for form encoded data. This handler takes effect for any request that has a mime type
+ * Parser definition for form encoded data. This handler takes effect for any request that has a mime type
  * of application/x-www-form-urlencoded. The handler attaches a {@link FormDataParser} to the chain
  * that can parse the underlying form data asynchronously.
  *

File: core/src/main/java/io/undertow/server/handlers/resource/CachedResource.java
Patch:
@@ -141,7 +141,7 @@ public void serve(final Sender sender, final HttpServerExchange exchange, final
 
         final DirectBufferCache.CacheEntry existing = dataCache.get(cacheKey);
         final Long length = getContentLength();
-        //if it is not eligable to be served from the cache
+        //if it is not eligible to be served from the cache
         if (length == null || length > cachingResourceManager.getMaxFileSize()) {
             underlyingResource.serve(sender, exchange, completionCallback);
             return;

File: core/src/main/java/io/undertow/server/handlers/resource/ClassPathResourceManager.java
Patch:
@@ -15,7 +15,7 @@ public class ClassPathResourceManager implements ResourceManager {
      */
     private final ClassLoader classLoader;
     /**
-     * The prefiex that is appended to resources that are to be loaded.
+     * The prefix that is appended to resources that are to be loaded.
      */
     private final String prefix;
 

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpReadListener.java
Patch:
@@ -264,7 +264,7 @@ private StreamSourceConduit createSourceConduit(StreamSourceConduit underlyingCo
         }
         final String requestContentLength = requestHeaders.getFirst(Headers.CONTENT_LENGTH);
         if (hasTransferEncoding && !transferEncoding.equals(Headers.IDENTITY)) {
-            length = null; //unkown length
+            length = null; //unknown length
         } else if (requestContentLength != null) {
             final long contentLength = Long.parseLong(requestContentLength);
             if (contentLength == 0L) {

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpServerRequestConduit.java
Patch:
@@ -246,7 +246,7 @@ public void awaitReadable(long time, TimeUnit timeUnit) throws IOException {
     }
 
     /**
-     * meethod that is called when an error occurs writing out read body chunk frames
+     * Method that is called when an error occurs writing out read body chunk frames
      * @param e
      */
     void setReadBodyChunkError(IOException e) {

File: core/src/main/java/io/undertow/server/protocol/framed/AbstractFramedChannel.java
Patch:
@@ -211,7 +211,7 @@ public InetSocketAddress getDestinationAddress() {
      * channel that can be used to read the frame contents.
      * <p/>
      * Calling this method can also have the side effect of making additional data available to
-     * existing source channels. In general if you suspend recieves or don't have some other way
+     * existing source channels. In general if you suspend receives or don't have some other way
      * of calling this method then it can prevent frame channels for being fully consumed.
      */
     public synchronized R receive() throws IOException {
@@ -319,7 +319,7 @@ public synchronized R receive() throws IOException {
      * <p/>
      * Frames will be batched up, to allow them all to be written out via a gathering
      * write. The {@link #framePriority} implementation will be invoked to decide which
-     * frames are eligable for sending and in what order.
+     * frames are eligible for sending and in what order.
      *
      * @throws IOException
      */

File: core/src/main/java/io/undertow/server/protocol/framed/FramePriority.java
Patch:
@@ -25,7 +25,7 @@ public interface FramePriority<C extends AbstractFramedChannel<C, R, S>, R exten
      *
      * @param newFrame The new frame to insert into the pending frame list
      * @param pendingFrames The pending frame list
-     * @return true if the frame can be instered into the pending frame list
+     * @return true if the frame can be inserted into the pending frame list
      */
     boolean insertFrame(S newFrame, final List<S> pendingFrames);
 

File: core/src/main/java/io/undertow/server/protocol/http/HttpReadListener.java
Patch:
@@ -60,7 +60,7 @@ final class HttpReadListener implements ChannelListener<ConduitStreamSourceChann
 
     //0 = new request ok, reads resumed
     //1 = request running, new request not ok
-    //2 = suspending/resuming in pogress
+    //2 = suspending/resuming in progress
     private volatile int requestState;
 
     private static final AtomicIntegerFieldUpdater<HttpReadListener> requestStateUpdater = AtomicIntegerFieldUpdater.newUpdater(HttpReadListener.class, "requestState");

File: core/src/main/java/io/undertow/server/protocol/http/HttpRequestParser.java
Patch:
@@ -541,7 +541,7 @@ final void handlePathParameters(ByteBuffer buffer, ParseState state, HttpServerE
         //also deals with URL decoding the query parameters as well, while also
         //maintaining a non-decoded version to use as the query string
         //In most cases these string will be the same, and as we do not want to
-        //build up two seperate strings we don't use encodedStringBuilder unless
+        //build up two separate strings we don't use encodedStringBuilder unless
         //we encounter an encoded character
 
         while (buffer.hasRemaining()) {
@@ -616,7 +616,7 @@ final void handlePathParameters(ByteBuffer buffer, ParseState state, HttpServerE
     private static final int AWAIT_DATA_END = 4;
 
     /**
-     * Parses a header value. This is called from the generated  bytecode.
+     * Parses a header value. This is called from the generated bytecode.
      *
      * @param buffer  The buffer
      * @param state   The current state

File: core/src/main/java/io/undertow/server/protocol/http/HttpTransferEncoding.java
Patch:
@@ -39,7 +39,7 @@
 import org.xnio.conduits.StreamSourceConduit;
 
 /**
- * Class that is  responsible for HTTP transfer encooding, this could be part of the {@link HttpReadListener},
+ * Class that is  responsible for HTTP transfer encoding, this could be part of the {@link HttpReadListener},
  * but is separated out for clarity.
  * <p/>
  * For more info see http://tools.ietf.org/html/rfc2616#section-4.4

File: core/src/main/java/io/undertow/websockets/core/BufferedBinaryMessage.java
Patch:
@@ -130,7 +130,7 @@ public void handleEvent(StreamSourceFrameChannel channel) {
     private void handleNewFrame(StreamSourceFrameChannel channel, final WebSocketCallback<BufferedBinaryMessage> callback) {
         //TODO: remove this crap
         //basically some bogus web sockets TCK tests assume that messages will be broken up into frames
-        //even if we have the full message availble.
+        //even if we have the full message available.
         if(!bufferFullMessage) {
             if(channel.getWebSocketFrameCount() != frameCount && current != null && !channel.isFinalFragment()) {
                 frameCount = channel.getWebSocketFrameCount();

File: core/src/main/java/io/undertow/websockets/core/FixedPayloadFrameSourceChannel.java
Patch:
@@ -104,12 +104,12 @@ public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {
     }
 
     /**
-     * Caled after data was read into the {@link ByteBuffer}
+     * Called after data was read into the {@link ByteBuffer}
      *
      * @param buffer   the {@link ByteBuffer} into which the data was read
      * @param position the position it was written to
      * @param length   the number of bytes there were written
-     * @throws IOException thrown if an error accour
+     * @throws IOException thrown if an error occurs
      */
     protected void afterRead(ByteBuffer buffer, int position, int length) throws IOException {
         try {

File: core/src/main/java/io/undertow/websockets/core/protocol/version07/Base64.java
Patch:
@@ -1790,7 +1790,7 @@ public void write(int theByte) throws java.io.IOException {
             if (suspendEncoding) {
                 this.out.write(theByte);
                 return;
-            } // end if: supsended
+            } // end if: suspended
 
             // Encode?
             if (encode) {
@@ -1841,7 +1841,7 @@ public void write(byte[] theBytes, int off, int len) throws java.io.IOException
             if (suspendEncoding) {
                 this.out.write(theBytes, off, len);
                 return;
-            } // end if: supsended
+            } // end if: suspended
 
             for (int i = 0; i < len; i++) {
                 write(theBytes[off + i]);

File: core/src/test/java/io/undertow/server/handlers/ChunkedRequestTransferCodingTestCase.java
Patch:
@@ -71,10 +71,10 @@ public void handleRequest(final HttpServerExchange exchange) {
                         return;
                     }
                     final OutputStream outputStream = exchange.getOutputStream();
-                    final InputStream inputSream = exchange.getInputStream();
-                    String m = HttpClientUtils.readResponse(inputSream);
+                    final InputStream inputStream = exchange.getInputStream();
+                    String m = HttpClientUtils.readResponse(inputStream);
                     Assert.assertEquals(message, m);
-                    inputSream.close();
+                    inputStream.close();
                     outputStream.close();
                 } catch (IOException e) {
                     e.printStackTrace();

File: core/src/test/java/io/undertow/server/handlers/FixedLengthRequestTestCase.java
Patch:
@@ -71,10 +71,10 @@ public void handleRequest(final HttpServerExchange exchange) {
                         return;
                     }
                     final OutputStream outputStream = exchange.getOutputStream();
-                    final InputStream inputSream =  exchange.getInputStream();
-                    String m = HttpClientUtils.readResponse(inputSream);
+                    final InputStream inputStream =  exchange.getInputStream();
+                    String m = HttpClientUtils.readResponse(inputStream);
                     Assert.assertEquals(message, m);
-                    inputSream.close();
+                    inputStream.close();
                     outputStream.close();
                 } catch (IOException e) {
                     exchange.getResponseHeaders().put(Headers.CONNECTION, "close");

File: core/src/test/java/io/undertow/server/handlers/GracefulShutdownTestCase.java
Patch:
@@ -157,7 +157,7 @@ private class ShutdownListener implements GracefulShutdownHandler.ShutdownListen
         private volatile boolean invoked = false;
 
         @Override
-        public synchronized void shutdown(boolean sucessful) {
+        public synchronized void shutdown(boolean successful) {
             invoked = true;
         }
     }

File: core/src/test/java/io/undertow/server/handlers/accesslog/AccessLogTestCase.java
Patch:
@@ -27,7 +27,7 @@ public class AccessLogTestCase {
     private volatile CountDownLatch latch;
 
 
-    private final AccessLogReceiver RECIEVER = new AccessLogReceiver() {
+    private final AccessLogReceiver RECEIVER = new AccessLogReceiver() {
 
 
         @Override
@@ -47,7 +47,7 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
     @Test
     public void testRemoteAddress() throws IOException, InterruptedException {
         latch = new CountDownLatch(1);
-        DefaultServer.setRootHandler(new AccessLogHandler(HELLO_HANDLER, RECIEVER, "Remote address %a Code %s test-header %{i,test-header}", AccessLogFileTestCase.class.getClassLoader()));
+        DefaultServer.setRootHandler(new AccessLogHandler(HELLO_HANDLER, RECEIVER, "Remote address %a Code %s test-header %{i,test-header}", AccessLogFileTestCase.class.getClassLoader()));
         TestHttpClient client = new TestHttpClient();
         try {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path");

File: core/src/test/java/io/undertow/server/handlers/file/FileHandlerTestCase.java
Patch:
@@ -68,7 +68,7 @@ public void testFileIsServed() throws IOException, URISyntaxException {
     }
 
     @Test
-    public void testFileTranfer() throws IOException, URISyntaxException {
+    public void testFileTransfer() throws IOException, URISyntaxException {
         TestHttpClient client = new TestHttpClient();
         File rootPath = new File(getClass().getResource("page.html").toURI()).getParentFile();
         try {

File: core/src/test/java/io/undertow/server/security/DigestAuthenticationAuthTestCase.java
Patch:
@@ -70,9 +70,9 @@ static AuthenticationMechanism getTestMechanism() {
      */
     @Override
     protected List<AuthenticationMechanism> getTestMechanisms() {
-        AuthenticationMechanism mechanims = getTestMechanism();
+        AuthenticationMechanism mechanism = getTestMechanism();
 
-        return Collections.singletonList(mechanims);
+        return Collections.singletonList(mechanism);
     }
 
     private static String createNonce() {

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -189,13 +189,13 @@ public void deploy() {
 
             HttpHandler outerHandlers = wrapHandlers(wrappedHandlers, deploymentInfo.getOuterHandlerChainWrappers());
             wrappedHandlers = new PredicateHandler(DispatcherTypePredicate.REQUEST, outerHandlers, wrappedHandlers);
+            wrappedHandlers = handleDevelopmentModePersistentSessions(wrappedHandlers, deploymentInfo, deployment.getSessionManager(), servletContext);
 
             final ServletInitialHandler servletInitialHandler = new ServletInitialHandler(deployment.getServletPaths(), wrappedHandlers, deployment.getThreadSetupAction(), servletContext);
 
 
             HttpHandler initialHandler = wrapHandlers(servletInitialHandler, deployment.getDeploymentInfo().getInitialHandlerChainWrappers());
             initialHandler = new HttpContinueReadHandler(initialHandler);
-            initialHandler = handleDevelopmentModePersistentSessions(initialHandler, deploymentInfo, deployment.getSessionManager(), servletContext);
             if(deploymentInfo.getUrlEncoding() != null) {
                 initialHandler = Handlers.urlDecodingHandler(deploymentInfo.getUrlEncoding(), initialHandler);
             }

File: core/src/main/java/io/undertow/server/protocol/http/HttpRequestParser.java
Patch:
@@ -202,8 +202,9 @@ public void handle(ByteBuffer buffer, final ParseState currentState, final HttpS
             if (buffer.remaining() > 3
                     && buffer.get(position) == 'G'
                     && buffer.get(position + 1) == 'E'
-                    && buffer.get(position + 2) == 'T') {
-                buffer.position(position + 3);
+                    && buffer.get(position + 2) == 'T'
+                    && buffer.get(position + 3) == ' ') {
+                buffer.position(position + 4);
                 builder.setRequestMethod(Methods.GET);
             } else {
                 handleHttpVerb(buffer, currentState, builder);

File: core/src/test/java/io/undertow/websockets/core/protocol/AbstractWebSocketServerTest.java
Patch:
@@ -57,7 +57,7 @@
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
 @RunWith(DefaultServer.class)
-@AjpIgnore(apacheOnly = true)
+@AjpIgnore
 public class AbstractWebSocketServerTest {
 
     @org.junit.Test

File: core/src/main/java/io/undertow/server/ServerConnection.java
Patch:
@@ -154,6 +154,8 @@ public abstract class ServerConnection extends AbstractAttachable implements Con
      */
     protected abstract void exchangeComplete(HttpServerExchange exchange);
 
+    protected abstract void setUpgradeListener(HttpUpgradeListener upgradeListener);
+
     public interface CloseListener {
 
         void closed(final ServerConnection connection);

File: servlet/src/main/java/io/undertow/servlet/api/DeploymentInfo.java
Patch:
@@ -913,7 +913,7 @@ public Map<String, AuthenticationMechanismFactory> getAuthenticationMechanisms()
     public boolean isAuthenticationMechanismPresent(final String mechanismName) {
         if(loginConfig != null) {
             for(AuthMethodConfig method : loginConfig.getAuthMethods()) {
-                if(method.equals(mechanismName)) {
+                if(method.getName().equals(mechanismName)) {
                     return true;
                 }
             }

File: core/src/main/java/io/undertow/util/PipeliningExecutor.java
Patch:
@@ -11,13 +11,13 @@
  *
  * @author Stuart Douglas
  */
-public class ContinuingExecutor implements Executor {
+public class PipeliningExecutor implements Executor {
 
     private final Executor executor;
 
     private static final ThreadLocal<LinkedList<Runnable>> THREAD_QUEUE = new ThreadLocal<LinkedList<Runnable>>();
 
-    public ContinuingExecutor(Executor executor) {
+    public PipeliningExecutor(Executor executor) {
         this.executor = executor;
     }
 
@@ -42,7 +42,7 @@ public void run() {
                     Runnable runnable = queue.poll();
                     while (runnable != null) {
                         try {
-                            command.run();
+                            runnable.run();
                         } catch (Throwable t) {
                             UndertowLogger.REQUEST_LOGGER.debugf(t, "Task %s failed", command);
                         }

File: core/src/main/java/io/undertow/client/http/HttpClientConnection.java
Patch:
@@ -32,7 +32,6 @@
 import io.undertow.conduits.ChunkedStreamSinkConduit;
 import io.undertow.conduits.ChunkedStreamSourceConduit;
 import io.undertow.conduits.ConduitListener;
-import io.undertow.conduits.FixedLengthStreamSinkConduit;
 import io.undertow.conduits.FixedLengthStreamSourceConduit;
 import io.undertow.util.AbstractAttachable;
 import io.undertow.util.Headers;
@@ -254,7 +253,7 @@ private void inititateRequest(HttpClientExchange httpClientExchange) {
         if (fixedLengthString != null) {
             try {
                 long length = Long.parseLong(fixedLengthString);
-                conduit = new FixedLengthStreamSinkConduit(conduit, length, false, false, requestFinishListener);
+                conduit = new ClientFixedLengthStreamSinkConduit(conduit, length, false, false, currentRequest);
                 hasContent = length != 0;
             } catch (NumberFormatException e) {
                 handleError(new IOException(e));
@@ -267,7 +266,7 @@ private void inititateRequest(HttpClientExchange httpClientExchange) {
             }
             conduit = new ChunkedStreamSinkConduit(conduit, httpClientExchange.getConnection().getBufferPool(), false, false, httpClientExchange.getRequest().getRequestHeaders(), requestFinishListener, httpClientExchange);
         } else {
-            conduit = new FixedLengthStreamSinkConduit(conduit, 0, false, false, requestFinishListener);
+            conduit = new ClientFixedLengthStreamSinkConduit(conduit, 0, false, false, currentRequest);
             hasContent = false;
         }
         sinkChannel.setConduit(conduit);

File: core/src/main/java/io/undertow/server/protocol/http/HttpReadListener.java
Patch:
@@ -125,7 +125,7 @@ public void handleEvent(final StreamSourceChannel channel) {
             final HttpServerExchange httpServerExchange = this.httpServerExchange;
             httpServerExchange.setRequestScheme(connection.getSslSession() != null ? "https" : "http");
             this.httpServerExchange = null;
-            HttpTransferEncoding.setupRequest(httpServerExchange, false);
+            HttpTransferEncoding.setupRequest(httpServerExchange);
             Connectors.executeRootHandler(connection.getRootHandler(), httpServerExchange);
         } catch (Exception e) {
             sendBadRequestAndClose(connection.getChannel(), e);

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpOpenListener.java
Patch:
@@ -48,6 +48,7 @@ public void handleEvent(final StreamConnection channel) {
 
         AjpServerConnection connection = new AjpServerConnection(channel, bufferPool, rootHandler, undertowOptions, bufferSize);
         AjpReadListener readListener = new AjpReadListener(connection, scheme, parser);
+        connection.setAjpReadListener(readListener);
         readListener.startRequest();
         channel.getSourceChannel().setReadListener(readListener);
         readListener.handleEvent(channel.getSourceChannel());

File: core/src/main/java/io/undertow/server/protocol/http/HttpOpenListener.java
Patch:
@@ -63,6 +63,7 @@ public void handleEvent(final StreamConnection channel) {
         }
         HttpServerConnection connection = new HttpServerConnection(channel, bufferPool, rootHandler, undertowOptions, bufferSize);
         HttpReadListener readListener = new HttpReadListener(connection, parser);
+        connection.setReadListener(readListener);
         readListener.newRequest();
         channel.getSourceChannel().setReadListener(readListener);
         readListener.handleEvent(channel.getSourceChannel());

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -231,6 +231,8 @@ private static void runInternal(final RunNotifier notifier) {
                 serverOptions = OptionMap.builder()
                         .set(Options.TCP_NODELAY, true)
                         .set(Options.REUSE_ADDRESSES, true)
+                        .set(Options.BALANCING_TOKENS, 1)
+                        .set(Options.BALANCING_CONNECTIONS, 2)
                         .getMap();
                 if (ajp) {
                     openListener = new AjpOpenListener(new ByteBufferSlicePool(BufferAllocator.DIRECT_BYTE_BUFFER_ALLOCATOR, 8192, 100 * 8192), 8192);

File: servlet/src/main/java/io/undertow/servlet/core/ServletContainerImpl.java
Patch:
@@ -88,6 +88,6 @@ public DeploymentManager getDeploymentByPath(final String path) {
                 }
             }
         }
-        return null;
+        return deploymentsByPath.get("");
     }
 }

File: servlet/src/main/java/io/undertow/servlet/api/TransportGuaranteeType.java
Patch:
@@ -7,4 +7,5 @@ public enum TransportGuaranteeType {
     NONE,
     INTEGRAL,
     CONFIDENTIAL,
+    REJECTED;
 }

File: core/src/test/java/io/undertow/server/handlers/RedirectTestCase.java
Patch:
@@ -50,13 +50,13 @@ public class RedirectTestCase {
     @BeforeClass
     public static void setup() {
         DefaultServer.setRootHandler(new PathHandler()
-                .addPath("/target", new HttpHandler() {
+                .addPrefixPath("/target", new HttpHandler() {
                     @Override
                     public void handleRequest(HttpServerExchange exchange) throws Exception {
                         message = exchange.getRequestURI();
                     }
                 })
-                .addPath("/", predicateContext(predicate(Predicates.regex("%{REQUEST_URL}", "/(aa.*?)c", RedirectTestCase.class.getClassLoader(), false),
+                .addPrefixPath("/", predicateContext(predicate(Predicates.regex("%{REQUEST_URL}", "/(aa.*?)c", RedirectTestCase.class.getClassLoader(), false),
                         Handlers.redirect("/target/matched/${1}"), Handlers.redirect("/target%U"))))
         );
     }

File: core/src/test/java/io/undertow/server/handlers/SenderTestCase.java
Patch:
@@ -138,9 +138,9 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
             }
         };
 
-        PathHandler handler = new PathHandler().addPath("/lots", lotsOfSendsHandler)
-                .addPath("/fixed", fixedLengthSender)
-                .addPath("/transfer", lotsOfTransferHandler);
+        PathHandler handler = new PathHandler().addPrefixPath("/lots", lotsOfSendsHandler)
+                .addPrefixPath("/fixed", fixedLengthSender)
+                .addPrefixPath("/transfer", lotsOfTransferHandler);
         DefaultServer.setRootHandler(handler);
     }
 

File: core/src/test/java/io/undertow/server/handlers/SetAttributeTestCase.java
Patch:
@@ -81,8 +81,8 @@ public void testSettingHeader() throws IOException {
     public void testRewrite() throws IOException {
         DefaultServer.setRootHandler(
                 rewrite("regex['/somePath/(.*)']", "/otherPath/$1", getClass().getClassLoader(), path()
-                        .addPath("/otherPath", new InfoHandler())
-                        .addPath("/relative",
+                        .addPrefixPath("/otherPath", new InfoHandler())
+                        .addPrefixPath("/relative",
                                 rewrite("path-template['/foo/{bar}/{woz}']", "/foo?bar=${bar}&woz=${woz}", getClass().getClassLoader(), new InfoHandler()))
                 ));
 

File: core/src/test/java/io/undertow/server/handlers/file/FileHandlerIndexTestCase.java
Patch:
@@ -50,7 +50,7 @@ public void testFileIsServed() throws IOException, URISyntaxException {
         try {
             DefaultServer.setRootHandler(new CanonicalPathHandler()
                     .setNext(new PathHandler()
-                            .addPath("/path", new ResourceHandler()
+                            .addPrefixPath("/path", new ResourceHandler()
                                     .setResourceManager(new FileResourceManager(rootPath, 10485760))
                                     .setDirectoryListingEnabled(true)
                                     .addWelcomeFiles("page.html"))));

File: core/src/test/java/io/undertow/server/handlers/file/FileHandlerStressTestCase.java
Patch:
@@ -65,7 +65,7 @@ public void simpleFileStressTest() throws IOException, ExecutionException, Inter
 
             final CacheHandler cacheHandler = new CacheHandler(new DirectBufferCache(1024, 10, 10480), handler);
             final PathHandler path = new PathHandler();
-            path.addPath("/path", cacheHandler);
+            path.addPrefixPath("/path", cacheHandler);
             final CanonicalPathHandler root = new CanonicalPathHandler();
             root.setNext(path);
             DefaultServer.setRootHandler(root);

File: core/src/test/java/io/undertow/server/handlers/file/FileHandlerTestCase.java
Patch:
@@ -50,7 +50,7 @@ public void testFileIsServed() throws IOException, URISyntaxException {
         try {
             DefaultServer.setRootHandler(new CanonicalPathHandler()
                     .setNext(new PathHandler()
-                            .addPath("/path", new ResourceHandler()
+                            .addPrefixPath("/path", new ResourceHandler()
                                     .setResourceManager(new FileResourceManager(rootPath, 10485760))
                                     .setDirectoryListingEnabled(true))));
 
@@ -74,7 +74,7 @@ public void testFileTranfer() throws IOException, URISyntaxException {
         try {
             DefaultServer.setRootHandler(new CanonicalPathHandler()
                     .setNext(new PathHandler()
-                            .addPath("/path", new ResourceHandler()
+                            .addPrefixPath("/path", new ResourceHandler()
                                     // 1 byte = force transfer
                                     .setResourceManager(new FileResourceManager(rootPath, 1))
                                     .setDirectoryListingEnabled(true))));

File: core/src/test/java/io/undertow/server/ssl/ComplexSSLTestCase.java
Patch:
@@ -71,7 +71,7 @@ public void complexSSLTestCase() throws IOException, GeneralSecurityException, U
         virtualHostHandler.addHost("default-host", pathHandler);
         virtualHostHandler.setDefaultHandler(pathHandler);
 
-        pathHandler.addPath("/", new ResourceHandler()
+        pathHandler.addPrefixPath("/", new ResourceHandler()
                 .setResourceManager(new FileResourceManager(rootPath, 10485760))
                 .setDirectoryListingEnabled(true));
 

File: examples/src/main/java/io/undertow/examples/chat/ChatServer.java
Patch:
@@ -34,7 +34,7 @@ public static void main(final String[] args) {
         Undertow server = Undertow.builder()
                 .addListener(8080, "localhost")
                 .setHandler(path()
-                        .addPath("/myapp", websocket(new WebSocketConnectionCallback() {
+                        .addPrefixPath("/myapp", websocket(new WebSocketConnectionCallback() {
 
                             @Override
                             public void onConnect(WebSocketHttpExchange exchange, WebSocketChannel channel) {
@@ -64,7 +64,7 @@ protected void onFullTextMessage(WebSocketChannel channel, BufferedTextMessage m
                                 }
                             }
                         }))
-                        .addPath("/", resource(new ClassPathResourceManager(ChatServer.class.getClassLoader(), ChatServer.class.getPackage()))
+                        .addPrefixPath("/", resource(new ClassPathResourceManager(ChatServer.class.getClassLoader(), ChatServer.class.getPackage()))
                                 .addWelcomeFiles("index.html")))
                 .build();
 

File: examples/src/main/java/io/undertow/examples/websockets/WebSocketServer.java
Patch:
@@ -24,7 +24,7 @@ public static void main(final String[] args) {
         Undertow server = Undertow.builder()
                 .addListener(8080, "localhost")
                 .setHandler(path()
-                        .addPath("/myapp", websocket(new WebSocketConnectionCallback() {
+                        .addPrefixPath("/myapp", websocket(new WebSocketConnectionCallback() {
 
                             @Override
                             public void onConnect(WebSocketHttpExchange exchange, WebSocketChannel channel) {
@@ -38,7 +38,7 @@ protected void onFullTextMessage(WebSocketChannel channel, BufferedTextMessage m
                                 channel.resumeReceives();
                             }
                         }))
-                        .addPath("/", resource(new ClassPathResourceManager(WebSocketServer.class.getClassLoader(), WebSocketServer.class.getPackage())).addWelcomeFiles("index.html")))
+                        .addPrefixPath("/", resource(new ClassPathResourceManager(WebSocketServer.class.getClassLoader(), WebSocketServer.class.getPackage())).addWelcomeFiles("index.html")))
                 .build();
         server.start();
     }

File: jsp/src/test/java/io/undertow/test/jsp/basic/SimpleJspTestCase.java
Patch:
@@ -71,7 +71,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        servletPath.addPath(builder.getContextPath(), manager.start());
+        servletPath.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(servletPath);
         System.setProperty(KEY, "Hello JSP!");

File: servlet/src/test/java/io/undertow/servlet/test/SimpleServletTestCase.java
Patch:
@@ -67,7 +67,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/crosscontext/CrossContextClassLoaderTestCase.java
Patch:
@@ -48,7 +48,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
 
         s = new ServletInfo("included", IncludedServlet.class)
@@ -63,7 +63,7 @@ public static void setup() throws ServletException {
 
         manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/DefaultServletCachingTestCase.java
Patch:
@@ -68,7 +68,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/DefaultServletTestCase.java
Patch:
@@ -53,7 +53,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/ServletAndResourceWelcomeFileTestCase.java
Patch:
@@ -67,7 +67,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/WelcomeFileSecurityTestCase.java
Patch:
@@ -94,7 +94,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/WelcomeFileTestCase.java
Patch:
@@ -57,7 +57,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/dispatcher/DispatcherForwardTestCase.java
Patch:
@@ -90,7 +90,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/dispatcher/DispatcherIncludeTestCase.java
Patch:
@@ -92,7 +92,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/errorpage/ErrorPageTestCase.java
Patch:
@@ -76,7 +76,7 @@ public static void setup() throws IOException, ServletException {
 
         final DeploymentManager manager1 = container.addDeployment(builder1);
         manager1.deploy();
-        root.addPath(builder1.getContextPath(), manager1.start());
+        root.addPrefixPath(builder1.getContextPath(), manager1.start());
 
 
         DeploymentInfo builder2 = new DeploymentInfo();
@@ -101,7 +101,7 @@ public static void setup() throws IOException, ServletException {
 
         final DeploymentManager manager2 = container.addDeployment(builder2);
         manager2.deploy();
-        root.addPath(builder2.getContextPath(), manager2.start());
+        root.addPrefixPath(builder2.getContextPath(), manager2.start());
 
     }
 

File: servlet/src/test/java/io/undertow/servlet/test/listener/ordering/ServletSessionListenerOrderingTestCase.java
Patch:
@@ -68,7 +68,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        path.addPath(builder.getContextPath(), manager.start());
+        path.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(path);
     }

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/RequestListenerAsyncRequestTestCase.java
Patch:
@@ -81,7 +81,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/onError/AsyncListenerOnErrorTest.java
Patch:
@@ -80,7 +80,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/onTimeout/NestedListenerInvocationTestCase.java
Patch:
@@ -67,7 +67,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/listener/servletcontext/ServletContextListenerTestCase.java
Patch:
@@ -66,7 +66,7 @@ public static void setup() throws ServletException {
 
         manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/listener/session/ServletSessionInvalidateWithListenerTestCase.java
Patch:
@@ -61,7 +61,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        path.addPath(builder.getContextPath(), manager.start());
+        path.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(path);
     }

File: servlet/src/test/java/io/undertow/servlet/test/mock/MockRequestTestCase.java
Patch:
@@ -89,7 +89,7 @@ public static void setup() throws ServletException {
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
         deployment = manager.getDeployment();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/path/FilterPathMappingTestCase.java
Patch:
@@ -112,7 +112,7 @@ public void testBasicFilterMappings() throws IOException, ServletException {
 
         final DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
 
@@ -160,7 +160,7 @@ public void testExtensionMatchServletWithGlobalFilter() throws IOException, Serv
 
         final DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
 
@@ -200,7 +200,7 @@ public void test_WFLY_1935() throws IOException, ServletException {
 
         final DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
 

File: servlet/src/test/java/io/undertow/servlet/test/path/RealPathTestCase.java
Patch:
@@ -65,7 +65,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
         client = new TestHttpClient();

File: servlet/src/test/java/io/undertow/servlet/test/proprietry/BypassServletTestCase.java
Patch:
@@ -69,7 +69,7 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/proprietry/TransferTestCase.java
Patch:
@@ -49,7 +49,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/request/RequestPathTestCase.java
Patch:
@@ -82,7 +82,7 @@ public static void setup() throws ServletException {
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
         try {
-            pathHandler.addPath(builder.getContextPath(), manager.start());
+            pathHandler.addPrefixPath(builder.getContextPath(), manager.start());
         } catch (ServletException e) {
             throw new RuntimeException(e);
         }

File: servlet/src/test/java/io/undertow/servlet/test/response/contenttype/ContentTypeFilesTestCase.java
Patch:
@@ -59,7 +59,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
         DefaultServer.setRootHandler(root);
     }
 

File: servlet/src/test/java/io/undertow/servlet/test/security/constraint/EmptyRoleSemanticTestCase.java
Patch:
@@ -96,7 +96,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/security/constraint/SecurityConstraintUrlMappingTestCase.java
Patch:
@@ -102,7 +102,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/security/custom/ServletCustomAuthTestCase.java
Patch:
@@ -100,7 +100,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        path.addPath(builder.getContextPath(), manager.start());
+        path.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(path);
     }

File: servlet/src/test/java/io/undertow/servlet/test/security/digest/DigestAuthTestCase.java
Patch:
@@ -102,7 +102,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        path.addPath(builder.getContextPath(), manager.start());
+        path.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(path);
     }

File: servlet/src/test/java/io/undertow/servlet/test/security/form/ServletFormAuthTestCase.java
Patch:
@@ -78,7 +78,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        path.addPath(builder.getContextPath(), manager.start());
+        path.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(path);
     }

File: servlet/src/test/java/io/undertow/servlet/test/security/login/ServletLoginTestCase.java
Patch:
@@ -62,7 +62,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        path.addPath(builder.getContextPath(), manager.start());
+        path.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(path);
     }

File: servlet/src/test/java/io/undertow/servlet/test/security/ssl/ConfidentialityConstraintUrlMappingTestCase.java
Patch:
@@ -88,7 +88,7 @@ public static void setup() throws Exception {
 
         DeploymentManager manager = container.addDeployment(info);
         manager.deploy();
-        root.addPath(info.getContextPath(), manager.start());
+        root.addPrefixPath(info.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/security/ssl/SSLMetaDataTestCase.java
Patch:
@@ -70,7 +70,7 @@ public static void setup() throws Exception {
 
         DeploymentManager manager = container.addDeployment(info);
         manager.deploy();
-        root.addPath(info.getContextPath(), manager.start());
+        root.addPrefixPath(info.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/session/ChangeSessionIdTestCase.java
Patch:
@@ -45,7 +45,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        path.addPath(builder.getContextPath(), manager.start());
+        path.addPrefixPath(builder.getContextPath(), manager.start());
         DefaultServer.setRootHandler(path);
     }
 

File: servlet/src/test/java/io/undertow/servlet/test/session/CrossContextServletSessionTestCase.java
Patch:
@@ -83,7 +83,7 @@ private static void createDeployment(final String name, final ServletContainer c
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        path.addPath(builder.getContextPath(), manager.start());
+        path.addPrefixPath(builder.getContextPath(), manager.start());
     }
 
 

File: servlet/src/test/java/io/undertow/servlet/test/session/ServletSessionPersistenceTestCase.java
Patch:
@@ -61,7 +61,7 @@ public void testSimpleSessionUsage() throws IOException, ServletException {
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
         try {
-            pathHandler.addPath(builder.getContextPath(), manager.start());
+            pathHandler.addPrefixPath(builder.getContextPath(), manager.start());
         } catch (ServletException e) {
             throw new RuntimeException(e);
         }
@@ -86,7 +86,7 @@ public void testSimpleSessionUsage() throws IOException, ServletException {
             manager.stop();
             manager.undeploy();
             manager.deploy();
-            pathHandler.addPath(builder.getContextPath(), manager.start());
+            pathHandler.addPrefixPath(builder.getContextPath(), manager.start());
 
             result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());

File: servlet/src/test/java/io/undertow/servlet/test/session/ServletSessionTestCase.java
Patch:
@@ -64,7 +64,7 @@ public static void setup() throws ServletException {
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
         try {
-            pathHandler.addPath(builder.getContextPath(), manager.start());
+            pathHandler.addPrefixPath(builder.getContextPath(), manager.start());
         } catch (ServletException e) {
             throw new RuntimeException(e);
         }

File: servlet/src/test/java/io/undertow/servlet/test/spec/ParameterEchoTestCase.java
Patch:
@@ -70,7 +70,7 @@ public static void setup() throws ServletException {
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: servlet/src/test/java/io/undertow/servlet/test/util/DeploymentUtils.java
Patch:
@@ -68,7 +68,7 @@ public static Deployment setupServlet(final ServletExtension servletExtension, f
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
         try {
-            pathHandler.addPath(builder.getContextPath(), manager.start());
+            pathHandler.addPrefixPath(builder.getContextPath(), manager.start());
         } catch (ServletException e) {
             throw new RuntimeException(e);
         }

File: servlet/src/test/java/io/undertow/servlet/test/wrapper/AbstractResponseWrapperTestCase.java
Patch:
@@ -79,7 +79,7 @@ public void setup() throws ServletException {
 
         final DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: websockets-jsr/src/test/java/io/undertow/websockets/jsr/test/JsrWebSocketServer07Test.java
Patch:
@@ -610,7 +610,7 @@ private void deployServlet(final ServerWebSocketContainer deployment) throws Ser
         final ServletContainer container = ServletContainer.Factory.newInstance();
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();
-        root.addPath(builder.getContextPath(), manager.start());
+        root.addPrefixPath(builder.getContextPath(), manager.start());
 
         DefaultServer.setRootHandler(root);
     }

File: core/src/main/java/io/undertow/server/protocol/http/HttpReadListener.java
Patch:
@@ -190,13 +190,12 @@ public void exchangeEvent(final HttpServerExchange exchange, final ExchangeCompl
                 //if we are not pipelining we just register a listener
                 if (exchange.isInIoThread()) {
                     channel.getSourceChannel().getReadSetter().set(this);
-
                     channel.getSourceChannel().resumeReads();
                 } else {
                     channel.getIoThread().execute(new Runnable() {
                         @Override
                         public void run() {
-                            channel.getSourceChannel().getReadSetter().set(this);
+                            channel.getSourceChannel().getReadSetter().set(HttpReadListener.this);
                             channel.getSourceChannel().resumeReads();
                         }
                     });

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -290,7 +290,7 @@ private HttpHandler setupSecurityHandlers(HttpHandler initialHandler) {
             FormParserFactory parser = FormParserFactory.builder(false)
                     .addParser(new FormEncodedDataDefinition().setDefaultEncoding(deploymentInfo.getDefaultEncoding()))
                     .build();
-                    
+
             List<AuthMethodConfig> authMethods = Collections.<AuthMethodConfig>emptyList();
             if(loginConfig != null) {
                 authMethods = loginConfig.getAuthMethods();

File: core/src/test/java/io/undertow/util/SingleByteStreamSourceConduit.java
Patch:
@@ -31,7 +31,8 @@ public SingleByteStreamSourceConduit(StreamSourceConduit next, int singleByteRea
 
     @Override
     public int read(ByteBuffer dst) throws IOException {
-        if (state > singleByteReads) {
+        if (state > singleByteReads || dst.remaining() == 1) {
+            //we always let a single byte read through, otherwise SSL renegotiation breaks
             return next.read(dst);
         }
 

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/EndpointSessionHandler.java
Patch:
@@ -28,8 +28,6 @@
 
 import javax.websocket.Endpoint;
 import java.net.URI;
-import java.util.Collections;
-import java.util.List;
 
 /**
  * {@link WebSocketConnectionCallback} implementation which will setuo the {@link UndertowSession} and notify
@@ -63,7 +61,7 @@ public void onConnect(WebSocketHttpExchange exchange, WebSocketChannel channel)
                 instance = new ImmediateInstanceHandle<Endpoint>((Endpoint) config.getEndpointConfiguration().getConfigurator().getEndpointInstance(config.getEndpointConfiguration().getEndpointClass()));
             }
 
-            UndertowSession session = new UndertowSession(channel, URI.create(exchange.getRequestURI()), exchange.getAttachment(HandshakeUtil.PATH_PARAMS), Collections.<String, List<String>>emptyMap(), this, null, instance, config.getEndpointConfiguration(), exchange.getQueryString(), config.getEncodingFactory().createEncoding(config.getEndpointConfiguration()), config.getOpenSessions());
+            UndertowSession session = new UndertowSession(channel, URI.create(exchange.getRequestURI()), exchange.getAttachment(HandshakeUtil.PATH_PARAMS), exchange.getRequestParameters(), this, null, instance, config.getEndpointConfiguration(), exchange.getQueryString(), config.getEncodingFactory().createEncoding(config.getEndpointConfiguration()), config.getOpenSessions());
             config.getOpenSessions().add(session);
             session.setMaxBinaryMessageBufferSize(getContainer().getDefaultMaxBinaryMessageBufferSize());
             session.setMaxTextMessageBufferSize(getContainer().getDefaultMaxTextMessageBufferSize());

File: core/src/main/java/io/undertow/websockets/core/WebSocketChannel.java
Patch:
@@ -98,6 +98,7 @@ protected void markReadsBroken(Throwable cause) {
     }
 
 
+
     protected boolean isReadsBroken() {
         return super.isReadsBroken();
     }

File: core/src/main/java/io/undertow/util/QueryParameterUtils.java
Patch:
@@ -93,12 +93,9 @@ public static Map<String, Deque<String>> mergeQueryParametersWithNewQueryString(
 
         Map<String, Deque<String>> newQueryParameters = parseQueryString(newQueryString);
         //according to the spec the new query parameters have to 'take precedence'
-        //it looks like they mean they have to be first, rather than completely replacing the existing ones
         for (Map.Entry<String, Deque<String>> entry : queryParameters.entrySet()) {
             if (!newQueryParameters.containsKey(entry.getKey())) {
                 newQueryParameters.put(entry.getKey(), new ArrayDeque<String>(entry.getValue()));
-            } else {
-                newQueryParameters.get(entry.getKey()).addAll(entry.getValue());
             }
         }
         return newQueryParameters;

File: servlet/src/main/java/io/undertow/servlet/spec/RequestDispatcherImpl.java
Patch:
@@ -136,8 +136,6 @@ public void forward(final ServletRequest request, final ServletResponse response
                 String newRequestUri = servletContext.getContextPath() + newServletPath;
 
                 Map<String, Deque<String>> newQueryParameters = QueryParameterUtils.mergeQueryParametersWithNewQueryString(queryParameters, newQueryString);
-                final StringBuilder sb = new StringBuilder();
-
 
                 requestImpl.setQueryParameters(newQueryParameters);
 

File: core/src/main/java/io/undertow/server/handlers/resource/CachingResourceManager.java
Patch:
@@ -63,7 +63,7 @@ public CachingResourceManager(final int metadataCacheSize, final long maxFileSiz
                 @Override
                 public void handleChanges(Collection<ResourceChangeEvent> changes) {
                     for(ResourceChangeEvent change : changes) {
-                        invalidate(change.getResource().getPath());
+                        invalidate(change.getResource());
                     }
                 }
             });

File: core/src/main/java/io/undertow/server/handlers/resource/FileResourceManager.java
Patch:
@@ -120,7 +120,7 @@ public void handleChanges(Collection<FileChangeEvent> changes) {
                         for (FileChangeEvent change : changes) {
                             if (change.getFile().getAbsolutePath().startsWith(base)) {
                                 String path = change.getFile().getAbsolutePath().substring(base.length());
-                                events.add(new ResourceChangeEvent(getResource(path), ResourceChangeEvent.Type.valueOf(change.getType().name())));
+                                events.add(new ResourceChangeEvent(path, ResourceChangeEvent.Type.valueOf(change.getType().name())));
                             }
                         }
                         for (ResourceChangeListener listener : listeners) {

File: core/src/main/java/io/undertow/server/handlers/resource/ResourceChangeEvent.java
Patch:
@@ -7,15 +7,15 @@
  */
 public class ResourceChangeEvent {
 
-    private final Resource resource;
+    private final String resource;
     private final Type type;
 
-    public ResourceChangeEvent(Resource resource, Type type) {
+    public ResourceChangeEvent(String resource, Type type) {
         this.resource = resource;
         this.type = type;
     }
 
-    public Resource getResource() {
+    public String getResource() {
         return resource;
     }
 

File: core/src/test/java/io/undertow/server/handlers/ChunkedResponseTransferCodingTestCase.java
Patch:
@@ -77,7 +77,6 @@ public void sendHttpRequest() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
 
-
             generateMessage(0);
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());

File: core/src/main/java/io/undertow/conduits/ChunkedStreamSinkConduit.java
Patch:
@@ -119,6 +119,9 @@ int doWrite(final ByteBuffer src) throws IOException {
         if (anyAreSet(state, FLAG_WRITES_SHUTDOWN)) {
             throw new ClosedChannelException();
         }
+        if(src.remaining() == 0) {
+            return 0;
+        }
         this.state |= FLAG_FIRST_DATA_WRITTEN;
         int oldLimit = src.limit();
         if (chunkleft == 0) {

File: servlet/src/main/java/io/undertow/servlet/api/Deployment.java
Patch:
@@ -18,6 +18,7 @@
 
 package io.undertow.servlet.api;
 
+import java.nio.charset.Charset;
 import java.util.Map;
 import java.util.concurrent.Executor;
 
@@ -80,4 +81,5 @@ public interface Deployment {
      */
     Executor getAsyncExecutor();
 
+    Charset getDefaultCharset();
 }

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -81,6 +81,7 @@
 import javax.servlet.ServletException;
 import javax.servlet.SessionTrackingMode;
 import java.io.File;
+import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -136,6 +137,8 @@ public void deploy() {
         deployment.setServletContext(servletContext);
         handleExtensions(deploymentInfo, servletContext);
 
+        deployment.setDefaultCharset(Charset.forName(deploymentInfo.getDefaultEncoding()));
+
         handleDeploymentSessionConfig(deploymentInfo, servletContext);
 
         deployment.setSessionManager(deploymentInfo.getSessionManagerFactory().createSessionManager(deployment));

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -91,8 +91,6 @@
  */
 public final class HttpServletRequestImpl implements HttpServletRequest {
 
-    private static final Charset DEFAULT_CHARSET = Charset.forName("ISO-8859-1");
-
     private final HttpServerExchange exchange;
     private final ServletContextImpl originalServletContext;
     private ServletContextImpl servletContext;
@@ -737,7 +735,7 @@ public BufferedReader getReader() throws IOException {
             if (servletInputStream != null) {
                 throw UndertowServletMessages.MESSAGES.getInputStreamAlreadyCalled();
             }
-            Charset charSet = DEFAULT_CHARSET;
+            Charset charSet = servletContext.getDeployment().getDefaultCharset();
             if (characterEncoding != null) {
                 charSet = characterEncoding;
             } else {

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -53,7 +53,6 @@
  */
 public final class HttpServletResponseImpl implements HttpServletResponse {
 
-    public static final String ISO_8859_1 = "ISO-8859-1";
     private final HttpServerExchange exchange;
     private volatile ServletContextImpl servletContext;
 

File: servlet/src/test/java/io/undertow/servlet/test/security/custom/CustomAuthenticationMechanism.java
Patch:
@@ -19,6 +19,7 @@
 
 import io.undertow.security.api.SecurityContext;
 import io.undertow.server.HttpServerExchange;
+import io.undertow.server.handlers.form.FormParserFactory;
 import io.undertow.servlet.handlers.security.ServletFormAuthenticationMechanism;
 import io.undertow.util.Methods;
 
@@ -39,7 +40,7 @@ public class CustomAuthenticationMechanism extends ServletFormAuthenticationMech
     public static final String POST_LOCATION = "custom_security_check";
 
     public CustomAuthenticationMechanism(String name, String loginPage, String errorPage) {
-        super(name, loginPage, errorPage);
+        super(FormParserFactory.builder().build(), name, loginPage, errorPage);
     }
 
     @Override
@@ -50,4 +51,4 @@ public AuthenticationMechanismOutcome authenticate(final HttpServerExchange exch
             return AuthenticationMechanismOutcome.NOT_ATTEMPTED;
         }
     }
-}
\ No newline at end of file
+}

File: servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java
Patch:
@@ -147,10 +147,12 @@ private void serveFileBlocking(final HttpServletRequest req, final HttpServletRe
         try {
             //only set the content length if we are using a stream
             //if we are using a writer who knows what the length will end up being
+            //todo: if someone installs a filter this can cause problems
+            //not sure how best to deal with this
             Long contentLength = resource.getContentLength();
             if (contentLength != null) {
-                resp.setContentLengthLong(contentLength);
                 resp.getOutputStream();
+                resp.setContentLengthLong(contentLength);
             }
         } catch (IllegalStateException e) {
 

File: core/src/main/java/io/undertow/io/UndertowOutputStream.java
Patch:
@@ -249,7 +249,7 @@ public void flush() throws IOException {
             throw UndertowMessages.MESSAGES.streamIsClosed();
         }
         if (buffer != null && buffer.position() != 0) {
-            writeBufferBlocking(true);
+            writeBufferBlocking(false);
         }
         if (channel == null) {
             channel = exchange.getResponseChannel();

File: servlet/src/main/java/io/undertow/servlet/spec/ServletContextImpl.java
Patch:
@@ -144,7 +144,7 @@ public void initDone() {
             if (sessionTrackingModes.contains(SessionTrackingMode.SSL)) {
                 sessionConfig = new SslSessionConfig(sessionCookieConfig);
             } else {
-                if (sessionTrackingModes.contains(SessionTrackingMode.COOKIE) || sessionTrackingModes.contains(SessionTrackingMode.URL)) {
+                if (sessionTrackingModes.contains(SessionTrackingMode.COOKIE) && sessionTrackingModes.contains(SessionTrackingMode.URL)) {
                     sessionConfig = sessionCookieConfig;
                     sessionCookieConfig.setFallback(new PathParameterSessionConfig(sessionCookieConfig.getName().toLowerCase(Locale.ENGLISH)));
                 } else if (sessionTrackingModes.contains(SessionTrackingMode.COOKIE)) {

File: servlet/src/main/java/io/undertow/servlet/api/DeploymentInfo.java
Patch:
@@ -744,8 +744,9 @@ public ServletSessionConfig getServletSessionConfig() {
         return servletSessionConfig;
     }
 
-    public void setServletSessionConfig(final ServletSessionConfig servletSessionConfig) {
+    public DeploymentInfo setServletSessionConfig(final ServletSessionConfig servletSessionConfig) {
         this.servletSessionConfig = servletSessionConfig;
+        return this;
     }
 
     /**

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -531,8 +531,9 @@ public String getHostAndPort() {
      */
     public int getHostPort() {
         String host = requestHeaders.getFirst(Headers.HOST);
-        if (host != null && host.indexOf(':') != -1) {
-            return Integer.parseInt(host.substring(host.indexOf(':')));
+        int colonIndex = host.indexOf(':');
+        if (host != null && colonIndex != -1) {
+            return Integer.parseInt(host.substring(colonIndex + 1));
         }
         return getDestinationAddress().getPort();
     }

File: core/src/main/java/io/undertow/server/handlers/error/FileErrorPageHandler.java
Patch:
@@ -101,7 +101,7 @@ public void run() {
                     exchange.endExchange();
                     return;
                 }
-
+                exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, file.length());
                 final StreamSinkChannel response = exchange.getResponseChannel();
                 exchange.addExchangeCompleteListener(new ExchangeCompletionListener() {
                     @Override
@@ -110,7 +110,6 @@ public void exchangeEvent(HttpServerExchange exchange, NextListener nextListener
                         nextListener.proceed();
                     }
                 });
-                exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, file.length());
 
                 try {
                     log.tracef("Serving file %s (blocking)", fileChannel);

File: core/src/main/java/io/undertow/Undertow.java
Patch:
@@ -91,6 +91,8 @@ public synchronized void start() {
                     .set(Options.WORKER_IO_THREADS, ioThreads)
                     .set(Options.TCP_NODELAY, true)
                     .set(Options.REUSE_ADDRESSES, true)
+                    .set(Options.BALANCING_TOKENS, 1)
+                    .set(Options.BALANCING_CONNECTIONS, 2)
                     .addAll(this.socketOptions)
                     .getMap();
 

File: servlet/src/test/java/io/undertow/servlet/test/response/contenttype/ContentTypeCharsetTestCase.java
Patch:
@@ -51,6 +51,7 @@ public void testCharsetAndContentType() throws Exception {
         runtest("text/html", "UTF8", "text/html;charset=UTF8", "text/html;charset=UTF8\nUTF8");
         runtest("text/html", "", "text/html;charset=ISO-8859-1", "text/html;charset=ISO-8859-1\nISO-8859-1");
         runtest("text/html;   charset=UTF8", "", "text/html;charset=UTF8", "text/html;charset=UTF8\nUTF8");
+        runtest("text/html;   charset=\"UTF8\"", "", "text/html;charset=UTF8", "text/html;charset=UTF8\nUTF8");
         runtest("text/html;   charset=UTF8; boundary=someString;", "", "text/html; boundary=someString;charset=UTF8", "text/html; boundary=someString;charset=UTF8\nUTF8");
         runtest("text/html;   charset=UTF8; boundary=someString;   ", "", "text/html; boundary=someString;charset=UTF8", "text/html; boundary=someString;charset=UTF8\nUTF8");
         runtest("multipart/related; type=\"text/xml\"; boundary=\"uuid:ce7d652a-d035-42fa-962c-5b8315084e32\"; start=\"<root.message@cxf.apache.org>\"; start-info=\"text/xml\"", "", "multipart/related; type=\"text/xml\"; boundary=\"uuid:ce7d652a-d035-42fa-962c-5b8315084e32\"; start=\"<root.message@cxf.apache.org>\"; start-info=\"text/xml\";charset=ISO-8859-1", "multipart/related; type=\"text/xml\"; boundary=\"uuid:ce7d652a-d035-42fa-962c-5b8315084e32\"; start=\"<root.message@cxf.apache.org>\"; start-info=\"text/xml\";charset=ISO-8859-1\nISO-8859-1");

File: core/src/main/java/io/undertow/security/impl/FormAuthenticationMechanism.java
Patch:
@@ -116,6 +116,7 @@ public AuthenticationMechanismOutcome runFormAuth(final HttpServerExchange excha
             } finally {
                 if (outcome == AuthenticationMechanismOutcome.AUTHENTICATED) {
                     handleRedirectBack(exchange);
+                    exchange.endExchange();
                 }
                 return outcome != null ? outcome : AuthenticationMechanismOutcome.NOT_AUTHENTICATED;
             }
@@ -132,6 +133,7 @@ protected void handleRedirectBack(final HttpServerExchange exchange) {
                 @Override
                 public boolean handleDefaultResponse(final HttpServerExchange exchange) {
                     FormAuthenticationMechanism.sendRedirect(exchange, location);
+                    exchange.setResponseCode(302);
                     exchange.endExchange();
                     return true;
                 }

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletDebugPageHandler.java
Patch:
@@ -99,6 +99,9 @@ private static void writeLabel(StringBuilder sb, String label, String value) {
 
 
     public static String escapeBodyText(final String bodyText) {
+        if(bodyText == null) {
+            return "null";
+        }
         return bodyText.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;");
     }
 }

File: core/src/main/java/io/undertow/client/http/HttpClientConnection.java
Patch:
@@ -265,7 +265,7 @@ private void inititateRequest(HttpClientExchange httpClientExchange) {
                 handleError(UndertowClientMessages.MESSAGES.unknownTransferEncoding(transferEncodingString));
                 return;
             }
-            conduit = new ChunkedStreamSinkConduit(conduit, false, false, httpClientExchange.getRequest().getRequestHeaders(), requestFinishListener, httpClientExchange);
+            conduit = new ChunkedStreamSinkConduit(conduit, httpClientExchange.getConnection().getBufferPool(), false, false, httpClientExchange.getRequest().getRequestHeaders(), requestFinishListener, httpClientExchange);
         } else {
             conduit = new FixedLengthStreamSinkConduit(conduit, 0, false, false, requestFinishListener);
             hasContent = false;

File: core/src/main/java/io/undertow/server/protocol/http/HttpTransferEncoding.java
Patch:
@@ -257,7 +257,7 @@ public StreamSinkConduit wrap(final ConduitFactory<StreamSinkConduit> factory, f
             if (transferEncodingHeader == null) {
                 if (exchange.isHttp11()) {
                     responseHeaders.put(Headers.TRANSFER_ENCODING, Headers.CHUNKED.toString());
-                    return new ChunkedStreamSinkConduit(channel, true, !exchange.isPersistent(), responseHeaders, finishListener, exchange);
+                    return new ChunkedStreamSinkConduit(channel, exchange.getConnection().getBufferPool(), true, !exchange.isPersistent(), responseHeaders, finishListener, exchange);
                 } else {
                     exchange.setPersistent(false);
                     responseHeaders.put(Headers.CONNECTION, Headers.CLOSE.toString());
@@ -273,7 +273,7 @@ public StreamSinkConduit wrap(final ConduitFactory<StreamSinkConduit> factory, f
         private StreamSinkConduit handleExplicitTransferEncoding(HttpServerExchange exchange, StreamSinkConduit channel, ConduitListener<StreamSinkConduit> finishListener, HeaderMap responseHeaders, String transferEncodingHeader) {
             HttpString transferEncoding = new HttpString(transferEncodingHeader);
             if (transferEncoding.equals(Headers.CHUNKED)) {
-                return new ChunkedStreamSinkConduit(channel, true, !exchange.isPersistent(), responseHeaders, finishListener, exchange);
+                return new ChunkedStreamSinkConduit(channel, exchange.getConnection().getBufferPool(), true, !exchange.isPersistent(), responseHeaders, finishListener, exchange);
             } else {
 
                 log.trace("Cancelling persistence because response is identity with no content length");

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletPathMatches.java
Patch:
@@ -94,8 +94,10 @@ public ServletPathMatch getServletHandlerByPath(final String path) {
                 welcomePage = findWelcomeServlet(pathWithTrailingSlash, !pathEndsWithSlash);
                 if (welcomePage != null) {
                     return welcomePage;
-                } else {
+                } else if(pathEndsWithSlash) {
                     return match;
+                } else {
+                    return new ServletPathMatch(match.getServletChain(), match.getMatched(), match.getRemaining(), REDIRECT, "/");
                 }
             }
 

File: core/src/main/java/io/undertow/server/protocol/http/HttpTransferEncoding.java
Patch:
@@ -232,7 +232,9 @@ public StreamSinkConduit wrap(final ConduitFactory<StreamSinkConduit> factory, f
             final HeaderMap responseHeaders = exchange.getResponseHeaders();
             // test to see if we're still persistent
             String connection = responseHeaders.getFirst(Headers.CONNECTION);
-            if (exchange.isPersistent() && connection != null) {
+            if(!exchange.isPersistent()) {
+                responseHeaders.put(Headers.CONNECTION, Headers.CLOSE.toString());
+            } else if (exchange.isPersistent() && connection != null) {
                 if (HttpString.tryFromString(connection).equals(Headers.CLOSE)) {
                     exchange.setPersistent(false);
                 }

File: servlet/src/test/java/io/undertow/servlet/test/dispatcher/DispatcherForwardTestCase.java
Patch:
@@ -173,7 +173,7 @@ public void testIncludeAggregatesQueryString() throws IOException {
             result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             response = HttpClientUtils.readResponse(result);
-            Assert.assertEquals("pathInfo:null queryString:a=b&foo=bar servletPath:/path requestUri:/servletContext/path", response);
+            Assert.assertEquals("pathInfo:null queryString:foo=bar&a=b servletPath:/path requestUri:/servletContext/path", response);
         } finally {
             client.getConnectionManager().shutdown();
         }

File: examples/src/main/java/io/undertow/examples/chat/ChatServer.java
Patch:
@@ -74,6 +74,7 @@ protected void onFullTextMessage(WebSocketChannel channel, BufferedTextMessage m
                                             }
                                         }
                                     });
+                                    channel.resumeReceives();
                                 }
                             }
                         }))

File: examples/src/main/java/io/undertow/examples/websockets/WebSocketServer.java
Patch:
@@ -11,7 +11,6 @@
 import io.undertow.websockets.spi.WebSocketHttpExchange;
 
 import static io.undertow.Handlers.path;
-import static io.undertow.Handlers.redirect;
 import static io.undertow.Handlers.resource;
 import static io.undertow.Handlers.websocket;
 
@@ -36,10 +35,10 @@ protected void onFullTextMessage(WebSocketChannel channel, BufferedTextMessage m
                                         WebSockets.sendText(message.getData(), channel, null);
                                     }
                                 });
+                                channel.resumeReceives();
                             }
                         }))
-                        .addPath("index.html", resource(new ClassPathResourceManager(WebSocketServer.class.getClassLoader(), WebSocketServer.class.getPackage())))
-                        .addPath("/", redirect("http://localhost:8080/index.html")))
+                        .addPath("/", resource(new ClassPathResourceManager(WebSocketServer.class.getClassLoader(), WebSocketServer.class.getPackage())).addWelcomeFiles("index.html")))
                 .build();
         server.start();
     }

File: core/src/main/java/io/undertow/server/handlers/encoding/AllowedContentEncodings.java
Patch:
@@ -50,7 +50,7 @@ public EncodingMapping getEncoding() {
     }
 
     public boolean isIdentity() {
-        return getCurrentContentEncoding().equals(Headers.IDENTITY);
+        return getCurrentContentEncoding().equals(Headers.IDENTITY.toString());
     }
 
     /**

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpServerRequestConduit.java
Patch:
@@ -96,7 +96,7 @@ public AjpServerRequestConduit(final StreamSourceConduit delegate, HttpServerExc
         if (size == null) {
             state = STATE_SEND_REQUIRED;
             remaining = -1;
-        } else if (size.equals(0)) {
+        } else if (size.longValue() == 0L) {
             state = STATE_FINISHED;
             remaining = 0;
         } else {

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -257,7 +257,7 @@ public Collection<String> getHeaderNames() {
     @Override
     public String getCharacterEncoding() {
         if (charset == null) {
-            return ISO_8859_1;
+            return servletContext.getDeployment().getDeploymentInfo().getDefaultEncoding();
         }
         return charset;
     }

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletPathMatches.java
Patch:
@@ -141,7 +141,7 @@ private ServletPathMatch findWelcomeServlet(final String path, boolean requiresR
         for (String i : welcomePages) {
             String mergedPath = path + i;
             final ServletPathMatch handler = data.getServletHandlerByPath(mergedPath);
-            if (handler != null && !handler.getServletChain().getManagedServlet().getServletInfo().getServletClass().equals(DefaultServlet.class)) {
+            if (handler != null && !handler.isRequiredWelcomeFileMatch()) {
                 return new ServletPathMatch(handler.getServletChain(), mergedPath, null, requiresRedirect ? REDIRECT : REWRITE, i);
             }
         }

File: core/src/main/java/io/undertow/client/UndertowClientMessages.java
Patch:
@@ -53,4 +53,7 @@ public interface UndertowClientMessages {
 
     @Message(id = 1037, value = "Wrong magic number, expected %s, actual %s")
     IOException wrongMagicNumber(String expected, String actual);
+
+    @Message(id = 1038, value = "Received invalid AJP chunk %s with response already complete")
+    IOException receivedInvalidChunk(byte prefix);
 }

File: core/src/main/java/io/undertow/client/ajp/AjpClientExchange.java
Patch:
@@ -56,17 +56,17 @@ public AjpClientExchange(ClientCallback<ClientExchange> readyCallback, ClientReq
 
     void terminateRequest() {
         state |= REQUEST_TERMINATED;
-        clientConnection.getConnection().getSinkChannel().suspendWrites();
         if (anyAreSet(state, RESPONSE_TERMINATED)) {
             clientConnection.requestDone();
         }
     }
 
     void terminateResponse() {
         state |= RESPONSE_TERMINATED;
-        clientConnection.getConnection().getSourceChannel().suspendReads();
         if (anyAreSet(state, REQUEST_TERMINATED)) {
             clientConnection.requestDone();
+        } else {
+            clientConnection.installReadBodyListener();
         }
     }
 

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpReadListener.java
Patch:
@@ -243,7 +243,7 @@ public void handleEvent(ConduitStreamSinkChannel channel) {
 
     @Override
     public void exchangeEvent(final HttpServerExchange exchange, final NextListener nextListener) {
-        if (!exchange.isUpgrade()) {
+        if (!exchange.isUpgrade() && exchange.isPersistent()) {
             startRequest();
             ConduitStreamSourceChannel channel = ((AjpServerConnection) exchange.getConnection()).getChannel().getSourceChannel();
             channel.getReadSetter().set(this);

File: core/src/test/java/io/undertow/server/handlers/session/URLRewritingSessionTestCase.java
Patch:
@@ -29,7 +29,6 @@
 import io.undertow.server.session.Session;
 import io.undertow.server.session.SessionAttachmentHandler;
 import io.undertow.server.session.SessionManager;
-import io.undertow.testutils.AjpIgnore;
 import io.undertow.testutils.DefaultServer;
 import io.undertow.testutils.HttpClientUtils;
 import io.undertow.testutils.TestHttpClient;
@@ -49,7 +48,6 @@
  * @author Stuart Douglas
  */
 @RunWith(DefaultServer.class)
-@AjpIgnore
 public class URLRewritingSessionTestCase {
 
     public static final String COUNT = "count";

File: core/src/test/java/io/undertow/websockets/core/protocol/server/AutobahnWebSocketServer.java
Patch:
@@ -64,16 +64,15 @@
  *               ],
  *
  *    "cases": ["*"],
- *    "exclude-cases": ["9.*"],
+ *    "exclude-cases": [],
  *    "exclude-agent-cases": {}
  * }
  * }
- * Note that we disabled the <strong>9.*</strong> tests for now as these fail.
  *
  * <p>04. Run the <tt>AutobahnServer</tt> located in this package. If you are in Eclipse IDE, right click on
  * <tt>AutobahnServer.java</tt> and select Run As > Java Application.
  *
- * <p>05. Run the Autobahn test <tt>wstest -m fuzzingclient -s fuzzingclient.json</tt>.
+ * <p>05. Run the Autobahn test <tt>wstest -m fuzzingclient -s fuzzing_client_spec.json</tt>.
  *
  * <p>06. See the results in <tt>./reports/servers/index.html</tt>
  *

File: core/src/main/java/io/undertow/server/protocol/http/HttpReadListener.java
Patch:
@@ -114,7 +114,7 @@ public void handleEvent(final StreamSourceChannel channel) {
                     } catch (IOException e) {
                         UndertowLogger.REQUEST_IO_LOGGER.debug("Error reading request", e);
                         // fuck it, it's all ruined
-                        IoUtils.safeClose(channel);
+                        IoUtils.safeClose(connection);
                         return;
                     }
                     return;

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpReadListener.java
Patch:
@@ -173,6 +173,7 @@ public void handleEvent(AjpServerResponseConduit channel) {
 
             try {
                 connection.setSSLSessionInfo(state.createSslSessionInfo());
+                httpServerExchange.setSourceAddress(state.createPeerAddress());
                 if(scheme != null) {
                     httpServerExchange.setRequestScheme(scheme);
                 } else if(connection.getSslSessionInfo() != null) {
@@ -183,6 +184,7 @@ public void handleEvent(AjpServerResponseConduit channel) {
                 state = null;
                 this.httpServerExchange = null;
                 httpServerExchange.setPersistent(true);
+
                 HttpHandlers.executeRootHandler(connection.getRootHandler(), httpServerExchange, Thread.currentThread() instanceof XnioExecutor);
 
             } catch (Throwable t) {

File: core/src/main/java/io/undertow/server/protocol/ajp/AjpRequestParser.java
Patch:
@@ -220,7 +220,7 @@ public void parse(final ByteBuffer buf, final AjpRequestParseState state, final
             case AjpRequestParseState.READING_REMOTE_ADDR: {
                 StringHolder result = parseString(buf, state, false);
                 if (result.readComplete) {
-                    //exchange.setRequestURI(result.value);
+                    state.remoteAddress = result.value;
                 } else {
                     state.state = AjpRequestParseState.READING_REMOTE_ADDR;
                     return;

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -602,7 +602,7 @@ public Enumeration<String> getParameterNames() {
                     String name = it.next();
                     for(FormData.FormValue param : parsedFormData.get(name)) {
                         if(!param.isFile()) {
-                            parameterNames.add(it.next());
+                            parameterNames.add(name);
                             break;
                         }
                     }

File: core/src/main/java/io/undertow/websockets/core/WebSocketChannel.java
Patch:
@@ -609,7 +609,7 @@ public void handleEvent(final StreamSourceChannel channel) {
                     WebSocketLogger.REQUEST_LOGGER.debugf("Suspending reads on channel %s due to no listener", receiver);
                     channel.suspendReads();
                 }
-            } else if (closeFrameReceived) {
+            } else if (closeFrameReceived || receivesSuspended) {
                 channel.suspendReads();
             } else {
                 final ChannelListener listener = receiveSetter.get();

File: core/src/main/java/io/undertow/websockets/core/WebSockets.java
Patch:
@@ -326,6 +326,7 @@ public void handleEvent(StreamSinkFrameChannel channel) {
                                 return;
                             }
                         } while (Buffers.hasRemaining(data));
+                        channel.suspendWrites();
                         try {
                             flushChannelAsync(wsChannel, callback, channel, context);
                         } catch (IOException e) {

File: core/src/main/java/io/undertow/util/HttpString.java
Patch:
@@ -348,7 +348,7 @@ public boolean equalToString(String headerName) {
 
         final int len = bytes.length;
         for (int i = 0; i < len; i++) {
-            if (higher(bytes[i]) != higher((byte)string.charAt(i))) {
+            if (higher(bytes[i]) != higher((byte)headerName.charAt(i))) {
                 return false;
             }
         }

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/UndertowContainerProvider.java
Patch:
@@ -41,7 +41,6 @@ public static void removeContainer(final ClassLoader classLoader) {
         if(System.getSecurityManager() != null) {
             AccessController.checkPermission(PERMISSION);
         }
-        AccessController.checkPermission(PERMISSION);
         webSocketContainers.remove(classLoader);
     }
 }

File: jsp/src/main/java/io/undertow/jsp/JspServletBuilder.java
Patch:
@@ -31,6 +31,9 @@ public static void setupDeployment(final DeploymentInfo deploymentInfo, final Ha
     public static ServletInfo createServlet(final String name, final String path) {
         ServletInfo servlet = new ServletInfo(name, JspServlet.class);
         servlet.addMapping(path);
+        //if the JSP servlet is mapped to a path that ends in /*
+        //we want to perform welcome file matches if the directory is requested
+        servlet.setRequireWelcomeFileMapping(true);
         return servlet;
     }
 

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -459,7 +459,7 @@ private void loadParts() throws IOException, ServletException {
             final List<Part> parts = new ArrayList<Part>();
             String mimeType = exchange.getRequestHeaders().getFirst(Headers.CONTENT_TYPE);
             if (mimeType != null && mimeType.startsWith(MultiPartParserDefinition.MULTIPART_FORM_DATA)) {
-                final ManagedServlet originalServlet = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY).getOriginalServletPathMatch().getManagedServlet();
+                final ManagedServlet originalServlet = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY).getOriginalServletPathMatch().getServletChain().getManagedServlet();
                 final FormDataParser parser = originalServlet.getFormParserFactory().createParser(exchange);
                 if(parser != null) {
                     final FormData value = parser.parseBlocking();
@@ -512,7 +512,7 @@ public void setCharacterEncoding(final String env) throws UnsupportedEncodingExc
         try {
             characterEncoding = Charset.forName(env);
 
-            final ManagedServlet originalServlet = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY).getOriginalServletPathMatch().getManagedServlet();
+            final ManagedServlet originalServlet = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY).getOriginalServletPathMatch().getServletChain().getManagedServlet();
             final FormDataParser parser = originalServlet.getFormParserFactory().createParser(exchange);
             if (parser != null) {
                 parser.setCharacterEncoding(env);
@@ -683,7 +683,7 @@ private FormData parseFormData() {
                 return null;
             }
             readStarted = true;
-            final ManagedServlet originalServlet = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY).getOriginalServletPathMatch().getManagedServlet();
+            final ManagedServlet originalServlet = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY).getOriginalServletPathMatch().getServletChain().getManagedServlet();
             final FormDataParser parser = originalServlet.getFormParserFactory().createParser(exchange);
             if (parser == null) {
                 return null;

File: servlet/src/main/java/io/undertow/servlet/spec/RequestDispatcherImpl.java
Patch:
@@ -58,12 +58,13 @@ public RequestDispatcherImpl(final String path, final ServletContextImpl servlet
         this.path = path;
         this.servletContext = servletContext;
         int qPos = path.indexOf("?");
+
         if (qPos == -1) {
             this.pathMatch = servletContext.getDeployment().getServletPaths().getServletHandlerByPath(path);
         } else {
             this.pathMatch = servletContext.getDeployment().getServletPaths().getServletHandlerByPath(path.substring(0, qPos));
         }
-        this.chain = pathMatch;
+        this.chain = pathMatch.getServletChain();
         this.named = false;
     }
 

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -624,9 +624,7 @@ public String[] getParameterValues(final String name) {
             final FormData parsedFormData = parseFormData();
             if (parsedFormData != null) {
                 Deque<FormData.FormValue> res = parsedFormData.get(name);
-                if (res == null) {
-                    return null;
-                } else {
+                if (res != null) {
                     for (FormData.FormValue value : res) {
                         ret.add(value.getValue());
                     }

File: core/src/main/java/io/undertow/Undertow.java
Patch:
@@ -251,9 +251,10 @@ private Builder() {
                 bufferSize = 1024;
                 buffersPerRegion = 10;
             } else {
-                //use 4k buffers
+                //use 16k buffers for best performance
+                //as 16k is generally the max amount of data that can be sent in a single write() call
                 directBuffers = true;
-                bufferSize = 1024 * 4;
+                bufferSize = 1024 * 16;
                 buffersPerRegion = 20;
             }
 

File: core/src/main/java/io/undertow/client/http/HttpRequestConduit.java
Patch:
@@ -434,7 +434,7 @@ private int processWrite(int state, final ByteBuffer userData) throws IOExceptio
                         ByteBuffer[] b = {buffer, userData};
                         do {
                             long r = next.write(b, 0, b.length);
-                            if (r == 0) {
+                            if (r == 0 && buffer.hasRemaining()) {
                                 log.trace("Continuation");
                                 return STATE_BUF_FLUSH;
                             }

File: core/src/main/java/io/undertow/server/handlers/form/FormEncodedDataDefinition.java
Patch:
@@ -44,7 +44,7 @@
 public class FormEncodedDataDefinition implements FormParserFactory.ParserDefinition {
 
     public static final String APPLICATION_X_WWW_FORM_URLENCODED = "application/x-www-form-urlencoded";
-    private String defaultEncoding = "UTF-8";
+    private String defaultEncoding = "ISO-8859-1";
 
     public FormEncodedDataDefinition() {
     }

File: core/src/main/java/io/undertow/server/handlers/form/MultiPartParserDefinition.java
Patch:
@@ -56,7 +56,7 @@ public class MultiPartParserDefinition implements FormParserFactory.ParserDefini
 
     private File tempFileLocation;
 
-    private String defaultEncoding = "UTF-8";
+    private String defaultEncoding = "ISO-8859-1";
 
     private long maxIndividualFileSize = -1;
 

File: core/src/main/java/io/undertow/server/protocol/http/HttpTransferEncoding.java
Patch:
@@ -193,7 +193,7 @@ public StreamSinkConduit wrap(final ConduitFactory<StreamSinkConduit> factory, f
                 StreamSinkConduit wrappedConduit;
                 final int code = exchange.getResponseCode();
                 if (exchange.getRequestMethod().equals(Methods.HEAD) || (100 <= code && code <= 199) || code == 204 || code == 304) {
-                    final ConduitListener<StreamSinkConduit> finishListener = stillPersistent ? terminateResponseListener(exchange) : null;
+                    final ConduitListener<StreamSinkConduit> finishListener = terminateResponseListener(exchange);
                     if (code == 101 && contentLengthHeader != null) {
                         // add least for websocket upgrades we can have a content length
                         final long contentLength;
@@ -210,13 +210,13 @@ public StreamSinkConduit wrap(final ConduitFactory<StreamSinkConduit> factory, f
                         wrappedConduit = new FixedLengthStreamSinkConduit(channel, 0L, true, !stillPersistent, finishListener);
                     }
                 } else if (!transferEncoding.equals(Headers.IDENTITY)) {
-                    final ConduitListener<StreamSinkConduit> finishListener = stillPersistent ? terminateResponseListener(exchange) : null;
+                    final ConduitListener<StreamSinkConduit> finishListener = terminateResponseListener(exchange);
                     wrappedConduit = new ChunkedStreamSinkConduit(channel, true, !stillPersistent, finishListener, exchange);
                 } else if (contentLengthHeader != null) {
                     final long contentLength;
                     try {
                         contentLength = Long.parseLong(contentLengthHeader);
-                        final ConduitListener<StreamSinkConduit> finishListener = stillPersistent ? terminateResponseListener(exchange) : null;
+                        final ConduitListener<StreamSinkConduit> finishListener = terminateResponseListener(exchange);
                         // fixed-length response
                         wrappedConduit = new FixedLengthStreamSinkConduit(channel, contentLength, true, !stillPersistent, finishListener);
                     } catch (NumberFormatException e) {

File: core/src/main/java/io/undertow/server/ExchangeCookieUtils.java
Patch:
@@ -208,7 +208,7 @@ private static String addVersion0ResponseCookieToExchange(final Cookie cookie) {
                 header.append(DateUtils.toOldCookieDateString(expires));
             } else if (cookie.getMaxAge() > 0) {
                 Date expires = new Date();
-                expires.setTime(expires.getTime() + cookie.getMaxAge());
+                expires.setTime(expires.getTime() + cookie.getMaxAge() * 1000);
                 header.append("; Expires=");
                 header.append(DateUtils.toOldCookieDateString(expires));
             }

File: core/src/main/java/io/undertow/client/UndertowClientMessages.java
Patch:
@@ -50,4 +50,7 @@ public interface UndertowClientMessages {
 
     @Message(id = 1036, value = "Data still remaining in chunk %s")
     IOException dataStillRemainingInChunk(long remaining);
+
+    @Message(id = 1037, value = "Wrong magic number, expected %s, actual %s")
+    IOException wrongMagicNumber(String expected, String actual);
 }

File: core/src/main/java/io/undertow/client/ajp/AjpClientResponseConduit.java
Patch:
@@ -121,8 +121,9 @@ private int doRead(final ByteBuffer dst) throws IOException {
                 headerBuffer.flip();
                 byte b1 = headerBuffer.get(); //A
                 byte b2 = headerBuffer.get(); //B
-                assert b1 == 'A';
-                assert b2 == 'B';
+                if(b1 != 'A' || b2 != 'B') {
+                    throw UndertowClientMessages.MESSAGES.wrongMagicNumber("AB", "" + ((char)b1) + ((char)b2));
+                }
                 headerBuffer.get(); //the length headers, two less than the string length header
                 headerBuffer.get();
 

File: core/src/main/java/io/undertow/server/handlers/proxy/ProxyHandler.java
Patch:
@@ -420,6 +420,7 @@ private IoExceptionHandler(HttpServerExchange exchange, ClientConnection clientC
         @Override
         public void handleException(Channel channel, IOException exception) {
             IoUtils.safeClose(clientConnection);
+            UndertowLogger.REQUEST_IO_LOGGER.debug("Exception reading from target server", exception);
             if (!exchange.isResponseStarted()) {
                 exchange.setResponseCode(500);
             }

File: core/src/test/java/io/undertow/server/handlers/blocking/SimpleBlockingServerTestCase.java
Patch:
@@ -172,7 +172,9 @@ public void testLargeResponse() throws IOException {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
-            Assert.assertTrue(message.equals(HttpClientUtils.readResponse(result)));
+            String resultString = HttpClientUtils.readResponse(result);
+            Assert.assertEquals(message.length(), resultString.length());
+            Assert.assertTrue(message.equals(resultString));
 
             get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path?useSender");
             result = client.execute(get);

File: core/src/main/java/io/undertow/attribute/SslSessionIdAttribute.java
Patch:
@@ -2,6 +2,7 @@
 
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.SSLSessionInfo;
+import io.undertow.util.FlexBase64;
 
 /**
  * @author Stuart Douglas
@@ -16,7 +17,7 @@ public String readAttribute(HttpServerExchange exchange) {
         if(ssl == null) {
             return null;
         }
-        return new String(ssl.getId());
+        return FlexBase64.encodeString(ssl.getId(), false);
     }
 
     @Override

File: servlet/src/main/java/io/undertow/servlet/core/BlockingWriterSenderImpl.java
Patch:
@@ -162,6 +162,7 @@ private void performTransfer(FileChannel source, IoCallback callback) {
                     break;
                 }
                 pos += ret;
+                buffer.flip();
                 if (!writeBuffer(buffer, callback)) {
                     return;
                 }

File: core/src/main/java/io/undertow/client/http/HttpResponseBuilder.java
Patch:
@@ -9,7 +9,7 @@
  *
  * @author Emanuel Muckenhuber
  */
-public final class HttpResponseBuilder {
+final class HttpResponseBuilder {
 
     private final ResponseParseState parseState = new ResponseParseState();
 

File: core/src/main/java/io/undertow/client/http/HttpResponseParser.java
Patch:
@@ -86,7 +86,7 @@
                 WARNING_STRING,
                 WWW_AUTHENTICATE_STRING
         })
-public abstract class HttpResponseParser {
+abstract class HttpResponseParser {
 
     public static final HttpResponseParser INSTANCE;
 

File: core/src/main/java/io/undertow/client/http/ResponseParseState.java
Patch:
@@ -5,7 +5,7 @@
 /**
  * @author Emanuel Muckenhuber
  */
-public class ResponseParseState {
+class ResponseParseState {
 
     //parsing states
     public static final int VERSION = 0;

File: core/src/main/java/io/undertow/server/handlers/proxy/ProxyClient.java
Patch:
@@ -28,4 +28,6 @@ public interface ProxyClient {
 
     void getConnection(final HttpServerExchange exchange, final HttpHandler nextHandler, long timeout, TimeUnit timeUnit);
 
+    boolean isOpen();
+
 }

File: core/src/test/java/io/undertow/server/handlers/form/MultipartFormDataParserTestCase.java
Patch:
@@ -24,6 +24,7 @@
 
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
+import io.undertow.server.handlers.BlockingHandler;
 import io.undertow.testutils.DefaultServer;
 import io.undertow.util.FileUtils;
 import io.undertow.testutils.HttpClientUtils;
@@ -67,14 +68,15 @@ public void handleRequest(final HttpServerExchange exchange) throws Exception {
                     }
                     exchange.endExchange();
                 } catch (IOException e) {
+                    e.printStackTrace();
                     exchange.setResponseCode(500);
                     exchange.endExchange();
                 } finally {
                     IoUtils.safeClose(parser);
                 }
             }
         };
-        DefaultServer.setRootHandler(fd);
+        DefaultServer.setRootHandler(new BlockingHandler(fd));
     }
 
     @Test

File: core/src/test/java/io/undertow/server/handlers/session/URLRewritingSessionTestCase.java
Patch:
@@ -29,6 +29,7 @@
 import io.undertow.server.session.Session;
 import io.undertow.server.session.SessionAttachmentHandler;
 import io.undertow.server.session.SessionManager;
+import io.undertow.testutils.AjpIgnore;
 import io.undertow.testutils.DefaultServer;
 import io.undertow.testutils.HttpClientUtils;
 import io.undertow.testutils.TestHttpClient;
@@ -48,6 +49,7 @@
  * @author Stuart Douglas
  */
 @RunWith(DefaultServer.class)
+@AjpIgnore
 public class URLRewritingSessionTestCase {
 
     public static final String COUNT = "count";

File: core/src/test/java/io/undertow/testutils/AjpIgnore.java
Patch:
@@ -10,4 +10,5 @@
 @Retention(RetentionPolicy.RUNTIME)
 @Inherited
 public @interface AjpIgnore {
+    boolean apacheOnly() default false;
 }

File: core/src/test/java/io/undertow/websockets/core/protocol/version00/WebSocket00ServerTest.java
Patch:
@@ -56,7 +56,7 @@
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
 @RunWith(DefaultServer.class)
-@AjpIgnore
+@AjpIgnore(apacheOnly = true)
 public class WebSocket00ServerTest {
 
     @org.junit.Test

File: servlet/src/test/java/io/undertow/servlet/test/streams/AsyncInputStreamServlet.java
Patch:
@@ -85,9 +85,10 @@ public  void onDataAvailable() throws IOException {
                 int read = inputStream.read(buf);
                 if (read != -1) {
                     dataToWrite.write(buf, 0, read);
+                } else {
+                    onWritePossible();
                 }
             }
-            onWritePossible();
         }
 
         @Override

File: websockets-jsr/src/test/java/io/undertow/websockets/jsr/test/JsrWebSocketServer07Test.java
Patch:
@@ -24,6 +24,7 @@
 import io.undertow.servlet.api.ServletContainer;
 import io.undertow.servlet.core.CompositeThreadSetupAction;
 import io.undertow.servlet.test.util.TestClassIntrospector;
+import io.undertow.testutils.AjpIgnore;
 import io.undertow.testutils.DefaultServer;
 import io.undertow.websockets.jsr.JsrWebSocketFilter;
 import io.undertow.websockets.jsr.ServerWebSocketContainer;
@@ -67,6 +68,7 @@
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
 @RunWith(DefaultServer.class)
+@AjpIgnore(apacheOnly = true)
 public class JsrWebSocketServer07Test {
 
     @org.junit.Test

File: websockets-jsr/src/test/java/io/undertow/websockets/jsr/test/annotated/AnnotatedEndpointTest.java
Patch:
@@ -21,6 +21,7 @@
 import io.undertow.servlet.api.DeploymentManager;
 import io.undertow.servlet.api.ServletContainer;
 import io.undertow.servlet.test.util.TestClassIntrospector;
+import io.undertow.testutils.AjpIgnore;
 import io.undertow.testutils.DefaultServer;
 import io.undertow.websockets.jsr.ServerWebSocketContainer;
 import io.undertow.websockets.jsr.WebSocketDeploymentInfo;
@@ -43,6 +44,7 @@
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
 @RunWith(DefaultServer.class)
+@AjpIgnore(apacheOnly = true)
 public class AnnotatedEndpointTest {
 
     private static ServerWebSocketContainer deployment;

File: servlet/src/test/java/io/undertow/servlet/test/multipart/MultiPartTestCase.java
Patch:
@@ -110,8 +110,9 @@ public void testMultiPartRequest() throws IOException {
                     "content: myValue\n" +
                     "name: file\n" +
                     "filename: uploadfile.txt\n" +
-                    "content-type: null\n" +
+                    "content-type: application/octet-stream\n" +
                     "Content-Disposition: form-data; name=\"file\"; filename=\"uploadfile.txt\"\n" +
+                    "Content-Type: application/octet-stream\n" +
                     "size: 13\n" +
                     "content: file contents\n", response);
         } finally {

File: servlet/src/test/java/io/undertow/servlet/test/websocket/WebSocketServletTest.java
Patch:
@@ -2,6 +2,7 @@
 
 import java.io.IOException;
 import java.net.URI;
+import java.nio.charset.Charset;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import javax.servlet.Servlet;
@@ -23,7 +24,6 @@
 import io.undertow.websockets.spi.WebSocketHttpExchange;
 import io.undertow.websockets.utils.FrameChecker;
 import io.undertow.websockets.utils.WebSocketTestClient;
-import org.apache.james.mime4j.util.CharsetUtil;
 import org.jboss.netty.buffer.ChannelBuffers;
 import org.jboss.netty.handler.codec.http.websocketx.TextWebSocketFrame;
 import org.junit.Test;
@@ -37,7 +37,7 @@
 @AjpIgnore
 @RunWith(DefaultServer.class)
 public class WebSocketServletTest {
-
+    public static final Charset US_ASCII = Charset.forName("US-ASCII");
 
     @Test
     public void testText() throws Exception {
@@ -104,7 +104,7 @@ protected void error(final IOException e) {
         final FutureResult latch = new FutureResult();
         WebSocketTestClient client = new WebSocketTestClient(org.jboss.netty.handler.codec.http.websocketx.WebSocketVersion.V13, new URI("ws://" + NetworkUtils.formatPossibleIpv6Address(DefaultServer.getHostAddress("default")) + ":" + DefaultServer.getHostPort("default") + "/servletContext/"));
         client.connect();
-        client.send(new TextWebSocketFrame(ChannelBuffers.copiedBuffer("hello", CharsetUtil.US_ASCII)), new FrameChecker(TextWebSocketFrame.class, "world".getBytes(CharsetUtil.US_ASCII), latch));
+        client.send(new TextWebSocketFrame(ChannelBuffers.copiedBuffer("hello", US_ASCII)), new FrameChecker(TextWebSocketFrame.class, "world".getBytes(US_ASCII), latch));
         latch.getIoFuture().get();
         client.destroy();
     }

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -80,7 +80,9 @@ public void addCookie(final Cookie cookie) {
             return;
         }
         final ServletCookieAdaptor servletCookieAdaptor = new ServletCookieAdaptor(cookie);
-        servletCookieAdaptor.setVersion(servletContext.getDeployment().getDeploymentInfo().getDefaultCookieVersion());
+        if(cookie.getVersion() == 0) {
+            servletCookieAdaptor.setVersion(servletContext.getDeployment().getDeploymentInfo().getDefaultCookieVersion());
+        }
         exchange.setResponseCookie(servletCookieAdaptor);
     }
 

File: servlet/src/main/java/io/undertow/servlet/spec/ServletCookieAdaptor.java
Patch:
@@ -87,7 +87,7 @@ public Cookie setMaxAge(final Integer maxAge) {
 
     @Override
     public boolean isDiscard() {
-        return false;
+        return cookie.getMaxAge() < 0;
     }
 
     @Override

File: core/src/main/java/io/undertow/util/Headers.java
Patch:
@@ -96,6 +96,7 @@ private Headers() {
     public static final String VIA_STRING = "Via";
     public static final String WARNING_STRING = "Warning";
     public static final String WWW_AUTHENTICATE_STRING = "WWW-Authenticate";
+    public static final String X_FORWARDED_FOR_STRING = "X-Forwarded-For";
 
     // Header names
 
@@ -165,6 +166,7 @@ private Headers() {
     public static final HttpString VIA = new HttpString(VIA_STRING, 64);
     public static final HttpString WARNING = new HttpString(WARNING_STRING, 65);
     public static final HttpString WWW_AUTHENTICATE = new HttpString(WWW_AUTHENTICATE_STRING, 66);
+    public static final HttpString X_FORWARDED_FOR = new HttpString(X_FORWARDED_FOR_STRING, 67);
 
     // Content codings
 

File: servlet/src/main/java/io/undertow/servlet/spec/AsyncContextImpl.java
Patch:
@@ -48,10 +48,10 @@
 import io.undertow.servlet.UndertowServletMessages;
 import io.undertow.servlet.api.Deployment;
 import io.undertow.servlet.api.DeploymentManager;
-import io.undertow.servlet.api.DevelopmentModeInfo;
 import io.undertow.servlet.api.InstanceFactory;
 import io.undertow.servlet.api.ServletContainer;
 import io.undertow.servlet.api.ServletDispatcher;
+import io.undertow.servlet.api.ServletStackTraces;
 import io.undertow.servlet.api.ThreadSetupAction;
 import io.undertow.servlet.core.CompositeThreadSetupAction;
 import io.undertow.servlet.handlers.ServletDebugPageHandler;
@@ -360,8 +360,8 @@ public void handleError(final Throwable error) {
         if (!dispatched) {
             servletRequest.setAttribute(RequestDispatcher.ERROR_EXCEPTION, error);
             try {
-                DevelopmentModeInfo devMode = servletRequestContext.getDeployment().getDeploymentInfo().getDevelopmentMode();
-                boolean errorPage = devMode != null && devMode.isDisplayErrorDetails();
+                ServletStackTraces devMode = servletRequestContext.getDeployment().getDeploymentInfo().getServletStackTraces();
+                boolean errorPage = servletRequestContext.displayStackTraces();
                 if(errorPage) {
                     ServletDebugPageHandler.handleRequest(exchange, servletRequestContext, error);
                 } else {

File: servlet/src/test/java/io/undertow/servlet/test/errorpage/ErrorPageTestCase.java
Patch:
@@ -28,6 +28,7 @@
 import io.undertow.servlet.api.ErrorPage;
 import io.undertow.servlet.api.ServletContainer;
 import io.undertow.servlet.api.ServletInfo;
+import io.undertow.servlet.api.ServletStackTraces;
 import io.undertow.servlet.test.util.TestClassIntrospector;
 import io.undertow.testutils.DefaultServer;
 import io.undertow.testutils.HttpClientUtils;
@@ -70,6 +71,7 @@ public static void setup() throws IOException, ServletException {
         builder1.setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setClassLoader(ErrorPageTestCase.class.getClassLoader())
                 .setContextPath("/servletContext1")
+                .setServletStackTraces(ServletStackTraces.NONE)
                 .setDeploymentName("servletContext1.war");
 
         final DeploymentManager manager1 = container.addDeployment(builder1);
@@ -94,6 +96,7 @@ public static void setup() throws IOException, ServletException {
         builder2.setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setClassLoader(ErrorPageTestCase.class.getClassLoader())
                 .setContextPath("/servletContext2")
+                .setServletStackTraces(ServletStackTraces.NONE)
                 .setDeploymentName("servletContext2.war");
 
         final DeploymentManager manager2 = container.addDeployment(builder2);

File: servlet/src/test/java/io/undertow/servlet/test/session/ServletSessionPersistenceTestCase.java
Patch:
@@ -21,7 +21,6 @@
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.servlet.api.DeploymentInfo;
 import io.undertow.servlet.api.DeploymentManager;
-import io.undertow.servlet.api.DevelopmentModeInfo;
 import io.undertow.servlet.api.ListenerInfo;
 import io.undertow.servlet.api.ServletContainer;
 import io.undertow.servlet.api.ServletInfo;
@@ -55,7 +54,7 @@ public void testSimpleSessionUsage() throws IOException, ServletException {
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
-                .setDevelopmentMode(new DevelopmentModeInfo(true, new InMemorySessionPersistence()))
+                .setSessionPersistenceManager(new InMemorySessionPersistence())
                 .addListener(new ListenerInfo(SessionCookieConfigListener.class))
                 .addServlets(new ServletInfo("servlet", SessionServlet.class)
                         .addMapping("/aa"));

File: core/src/main/java/io/undertow/ajp/AjpResponseConduit.java
Patch:
@@ -310,6 +310,7 @@ public int write(final ByteBuffer src) throws IOException {
                 for (ByteBuffer buffer : buffers) {
                     toWrite += buffer.remaining();
                 }
+                final int originalPayloadSize = writeSize;
                 int total = 0;
                 long r = 0;
                 do {
@@ -332,10 +333,10 @@ public int write(final ByteBuffer src) throws IOException {
                         this.packetHeaderAndDataBuffer = savedBuffers;
                         this.currentDataBuffer = newPooledBuffer;
 
-                        return writeSize;
+                        return originalPayloadSize;
                     }
                 } while (toWrite > 0);
-                return total;
+                return originalPayloadSize;
             } finally {
                 src.limit(limit);
             }

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletInitialHandler.java
Patch:
@@ -84,15 +84,15 @@ public ServletInitialHandler(final ServletPathMatches paths, final HttpHandler n
     @Override
     public void handleRequest(final HttpServerExchange exchange) throws Exception {
         final String path = exchange.getRelativePath();
-        if(path.isEmpty() && (exchange.getRequestMethod().equals(GET) || exchange.getRequestMethod().equals(HEAD))) {
+        final ServletPathMatch info = paths.getServletHandlerByPath(path);
+        if(path.isEmpty() && (exchange.getRequestMethod().equals(GET) || exchange.getRequestMethod().equals(HEAD)) && info.isDefaultServletMatch()) {
             //UNDERTOW-89
             //we redirect on GET requests to the root context to add an / to the end
             exchange.setResponseCode(302);
             exchange.getResponseHeaders().put(Headers.LOCATION, exchange.getResolvedPath() + "/" + (exchange.getQueryString().isEmpty() ? "" : ("?" + exchange.getQueryString())));
             return;
         }
 
-        final ServletPathMatch info = paths.getServletHandlerByPath(path);
 
         final HttpServletResponseImpl response = new HttpServletResponseImpl(exchange, servletContext);
         final HttpServletRequestImpl request = new HttpServletRequestImpl(exchange, servletContext);

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -79,7 +79,9 @@ public void addCookie(final Cookie cookie) {
         if (insideInclude) {
             return;
         }
-        exchange.setResponseCookie(new ServletCookieAdaptor(cookie));
+        final ServletCookieAdaptor servletCookieAdaptor = new ServletCookieAdaptor(cookie);
+        servletCookieAdaptor.setVersion(servletContext.getDeployment().getDeploymentInfo().getDefaultCookieVersion());
+        exchange.setResponseCookie(servletCookieAdaptor);
     }
 
     @Override

File: servlet/src/main/java/io/undertow/servlet/spec/ServletOutputStreamImpl.java
Patch:
@@ -107,7 +107,7 @@ public class ServletOutputStreamImpl extends ServletOutputStream implements Buff
     public ServletOutputStreamImpl(long contentLength, final ServletRequestContext servletRequestContext) {
         this.contentLength = contentLength;
         this.underlyingConnectionChannel = servletRequestContext.getExchange().getConnection().getChannel().getSinkChannel();
-        this.threadSetupAction = servletRequestContext.getDeployment().getServletContext().getDeployment().getThreadSetupAction();
+        this.threadSetupAction = servletRequestContext.getDeployment().getThreadSetupAction();
         this.servletRequestContext = servletRequestContext;
     }
 

File: servlet/src/main/java/io/undertow/servlet/api/ServletContainer.java
Patch:
@@ -37,7 +37,7 @@ public interface ServletContainer {
 
     DeploymentManager getDeployment(String deploymentName);
 
-    void removeDeployment(String deploymentName);
+    void removeDeployment(DeploymentInfo deploymentInfo);
 
     DeploymentManager getDeploymentByPath(String uripath);
 

File: core/src/main/java/io/undertow/server/handlers/MetricsHandler.java
Patch:
@@ -41,6 +41,7 @@ public void exchangeEvent(HttpServerExchange exchange, NextListener nextListener
                 nextListener.proceed();
             }
         });
+        next.handleRequest(exchange);
     }
 
     public void reset() {

File: core/src/test/java/io/undertow/server/handlers/MetricsHandlerTestCase.java
Patch:
@@ -29,6 +29,7 @@ public static void setup() {
             @Override
             public void handleRequest(HttpServerExchange exchange) throws Exception {
                 Thread.sleep(100);
+                exchange.getResponseSender().send("Hello");
             }
         })));
     }
@@ -40,7 +41,7 @@ public void testMetrics() throws IOException, InterruptedException {
         try {
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
-            HttpClientUtils.readResponse(result);
+            Assert.assertEquals("Hello", HttpClientUtils.readResponse(result));
             latchHandler.await();
             latchHandler.reset();
 
@@ -52,7 +53,7 @@ public void testMetrics() throws IOException, InterruptedException {
 
             result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
-            HttpClientUtils.readResponse(result);
+            Assert.assertEquals("Hello", HttpClientUtils.readResponse(result));
 
             latchHandler.await();
             latchHandler.reset();

File: core/src/main/java/io/undertow/UndertowLogger.java
Patch:
@@ -93,7 +93,7 @@ public interface UndertowLogger extends BasicLogger {
     @Message(id = 5013, value = "An IOException occurred")
     void ioException(@Cause IOException e);
 
-    @LogMessage(level = Logger.Level.ERROR)
+    @LogMessage(level = Logger.Level.DEBUG)
     @Message(id = 5014, value = "Failed to parse HTTP request")
     void failedToParseRequest(@Cause Exception e);
 

File: core/src/test/java/io/undertow/server/handlers/PredicatedHandlersTestCase.java
Patch:
@@ -25,6 +25,7 @@ public class PredicatedHandlersTestCase {
     public void testRewrite() throws IOException {
         DefaultServer.setRootHandler(
                 Handlers.predicates(
+
                         PredicatedHandlersParser.parse(
                                 "method[GET] -> set[attribute='%{o,type}', value=get]\n" +
                                         "regex['(.*).css'] -> rewrite['${1}.xcss']\n" +

File: core/src/main/java/io/undertow/server/handlers/resource/Resource.java
Patch:
@@ -74,8 +74,6 @@ public interface Resource {
      */
     Long getContentLength();
 
-    Resource getIndexResource(List<String> possible);
-
     /**
      * @return A string that uniquely identifies this resource
      */

File: core/src/main/java/io/undertow/predicate/PredicateParser.java
Patch:
@@ -365,7 +365,7 @@ private static Object coerceToType(final String string, final Token token, final
         } else if (type.equals(Double.class) || type.equals(double.class)) {
             return Double.valueOf(token.token);
         } else if (type.equals(ExchangeAttribute.class)) {
-            return attributeParser.parseSingleToken(token.token);
+            return attributeParser.parse(token.token);
         }
 
         return token.token;

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -189,4 +189,6 @@ public interface UndertowMessages {
     @Message(id = 55, value = "Could not set attribute %s to %s as it is read only")
     String couldNotSetAttribute(String attributeName, String newValue);
 
+    @Message(id = 56, value = "Could not parse URI template %s, exception at char %s")
+    RuntimeException couldNotParseUriTemplate(String path, int i);
 }

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -59,7 +59,7 @@
 import io.undertow.servlet.api.ServletSecurityInfo;
 import io.undertow.servlet.api.ThreadSetupAction;
 import io.undertow.servlet.api.WebResourceCollection;
-import io.undertow.servlet.handlers.DispatcherTypePredicate;
+import io.undertow.servlet.predicate.DispatcherTypePredicate;
 import io.undertow.servlet.handlers.ServletDispatchingHandler;
 import io.undertow.servlet.handlers.ServletInitialHandler;
 import io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler;

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/ConfiguredServerEndpoint.java
Patch:
@@ -9,6 +9,7 @@
 import javax.websocket.server.ServerEndpointConfig;
 
 import io.undertow.servlet.api.InstanceFactory;
+import io.undertow.util.PathTemplate;
 
 /**
  * @author Stuart Douglas

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/JsrWebSocketMessages.java
Patch:
@@ -27,6 +27,7 @@
 import javax.websocket.DeploymentException;
 import javax.websocket.Encoder;
 
+import io.undertow.util.PathTemplate;
 import org.jboss.logging.Messages;
 import org.jboss.logging.annotations.Cause;
 import org.jboss.logging.annotations.Message;
@@ -103,9 +104,6 @@ public interface JsrWebSocketMessages {
     @Message(id = 3021, value = "%s does not have default constructor")
     DeploymentException classDoesNotHaveDefaultConstructor(Class<?> c, @Cause NoSuchMethodException e);
 
-    @Message(id = 3022, value = "Could not parse URI template %s, exception at char %s")
-    DeploymentException couldNotParseUriTemplate(String path, int i);
-
     @Message(id = 3023, value = "Multiple endpoints with the same logical mapping %s and %s")
     DeploymentException multipleEndpointsWithOverlappingPaths(PathTemplate template, PathTemplate existing);
 

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/ServerWebSocketContainer.java
Patch:
@@ -45,6 +45,7 @@
 import io.undertow.servlet.api.InstanceFactory;
 import io.undertow.servlet.api.InstanceHandle;
 import io.undertow.servlet.util.ImmediateInstanceHandle;
+import io.undertow.util.PathTemplate;
 import io.undertow.websockets.api.WebSocketSessionIdGenerator;
 import io.undertow.websockets.client.WebSocketClient;
 import io.undertow.websockets.core.WebSocketChannel;

File: websockets-jsr/src/test/java/io/undertow/websockets/jsr/test/PathTemplateTestCase.java
Patch:
@@ -24,7 +24,7 @@
 
 import javax.websocket.DeploymentException;
 
-import io.undertow.websockets.jsr.PathTemplate;
+import io.undertow.util.PathTemplate;
 import org.junit.Assert;
 import org.junit.Test;
 

File: core/src/main/java/io/undertow/server/handlers/form/MultiPartParserDefinition.java
Patch:
@@ -241,7 +241,7 @@ public void beginPart(final HeaderMap headers) {
 
         @Override
         public void data(final ByteBuffer buffer) throws IOException {
-            this.currentFileSize += maxIndividualFileSize;
+            this.currentFileSize += buffer.remaining();
             if(this.maxIndividualFileSize > 0 && this.currentFileSize > this.maxIndividualFileSize) {
                 throw UndertowMessages.MESSAGES.maxFileSizeExceeded(this.maxIndividualFileSize);
             }

File: servlet/src/test/java/io/undertow/servlet/test/multipart/MultiPartTestCase.java
Patch:
@@ -112,8 +112,8 @@ public void testMultiPartRequest() throws IOException {
                     "filename: uploadfile.txt\n" +
                     "content-type: null\n" +
                     "Content-Disposition: form-data; name=\"file\"; filename=\"uploadfile.txt\"\n" +
-                    "size: 14\n" +
-                    "content: file contents\n\n", response);
+                    "size: 13\n" +
+                    "content: file contents\n", response);
         } finally {
             client.getConnectionManager().shutdown();
         }

File: servlet/src/test/java/io/undertow/servlet/test/multipart/MultiPartTestCase.java
Patch:
@@ -154,8 +154,8 @@ public void testMultiPartIndividualFileToLarge() throws IOException {
 
             post.setEntity(entity);
             HttpResponse result = client.execute(post);
-            Assert.assertEquals(500, result.getStatusLine().getStatusCode());
-            HttpClientUtils.readResponse(result);
+            String response = HttpClientUtils.readResponse(result);
+            Assert.assertEquals("TEST FAILED: wrong response code\n" + response, 500, result.getStatusLine().getStatusCode());
         } finally {
             client.getConnectionManager().shutdown();
         }

File: servlet/src/test/java/io/undertow/servlet/test/multipart/MultiPartTestCase.java
Patch:
@@ -134,7 +134,9 @@ public void testMultiPartRequestToLarge() throws IOException {
             HttpResponse result = client.execute(post);
             Assert.assertEquals(500, result.getStatusLine().getStatusCode());
             HttpClientUtils.readResponse(result);
-        } finally {
+        } catch (IOException expected) {
+            //in some environments the forced close of the read side will cause a connection reset
+        }finally {
             client.getConnectionManager().shutdown();
         }
     }

File: servlet/src/main/java/io/undertow/servlet/spec/ServletContextImpl.java
Patch:
@@ -209,7 +209,7 @@ public Set<String> getResourcePaths(final String path) {
             if(file != null) {
                 File base = res.getResourceManagerRoot();
                 String filePath = file.getAbsolutePath().substring(base.getAbsolutePath().length());
-                filePath.replace('\\', '/'); //for windows systems
+                filePath = filePath.replace('\\', '/'); //for windows systems
                 if(file.isDirectory()) {
                     filePath = filePath + "/";
                 }

File: core/src/main/java/io/undertow/server/ParseState.java
Patch:
@@ -130,5 +130,6 @@ public final void parseComplete(){
     public void reset() {
         this.state = 0;
         this.pos = 0;
+        this.leftOver = 0;
     }
 }

File: core/src/main/java/io/undertow/server/handlers/resource/CachedResource.java
Patch:
@@ -160,7 +160,7 @@ public void serve(final Sender sender, final HttpServerExchange exchange, final
                     existing.dereference();
                 }
             }
-            exchange.getResponseSender().send(buffers, new DereferenceCallback(existing, completionCallback));
+            sender.send(buffers, new DereferenceCallback(existing, completionCallback));
         }
     }
 

File: core/src/test/java/io/undertow/server/handlers/accesslog/AccessLogTestCase.java
Patch:
@@ -21,7 +21,7 @@ public class AccessLogTestCase {
 
     private static volatile String message;
 
-    private static final AccessLogReciever RECIEVER = new AccessLogReciever() {
+    private static final AccessLogReceiver RECIEVER = new AccessLogReceiver() {
         @Override
         public void logMessage(final String msg) {
             message = msg;

File: servlet/src/main/java/io/undertow/servlet/UndertowServletMessages.java
Patch:
@@ -179,8 +179,8 @@ public interface UndertowServletMessages {
     @Message(id = 10044, value = "listener cannot be null")
     NullPointerException listenerCannotBeNull();
 
-    @Message(id = 10045, value = "Only one session tracking mode at a time is supported")
-    IllegalArgumentException canOnlySetOneSessionTrackingMode();
+    @Message(id = 10045, value = "SSL cannot be combined with any other method")
+    IllegalArgumentException sslCannotBeCombinedWithAnyOtherMethod();
 
     @Message(id = 10046, value = "No servlet context at %s to dispatch to")
     IllegalArgumentException couldNotFindContextToDispatchTo(String originalContextPath);

File: core/src/main/java/io/undertow/server/HttpReadListener.java
Patch:
@@ -83,7 +83,7 @@ public void handleEvent(final StreamSourceChannel channel) {
                         res = channel.read(buffer);
                     } catch (IOException e) {
                         UndertowLogger.REQUEST_IO_LOGGER.debug("Error reading request", e);
-                        safeClose(channel);
+                        safeClose(connection);
                         return;
                     }
                 } else {

File: servlet/src/main/java/io/undertow/servlet/spec/ServletContextImpl.java
Patch:
@@ -584,6 +584,7 @@ public void addListener(final String className) {
     @Override
     public <T extends EventListener> void addListener(final T t) {
         ensureNotInitialized();
+        ensureNotProgramaticListener();
         if(ApplicationListeners.listenerState() != NO_LISTENER &&
                 ServletContextListener.class.isAssignableFrom(t.getClass())) {
             throw UndertowServletMessages.MESSAGES.cannotAddServletContextListener();
@@ -596,6 +597,7 @@ public <T extends EventListener> void addListener(final T t) {
     @Override
     public void addListener(final Class<? extends EventListener> listenerClass) {
         ensureNotInitialized();
+        ensureNotProgramaticListener();
         if(ApplicationListeners.listenerState() != NO_LISTENER &&
                 ServletContextListener.class.isAssignableFrom(listenerClass)) {
             throw UndertowServletMessages.MESSAGES.cannotAddServletContextListener();

File: servlet/src/main/java/io/undertow/servlet/spec/ServletPrintWriter.java
Patch:
@@ -51,14 +51,14 @@ public void write(final CharBuffer cb) {
         ByteBuffer buffer = outputStream.underlyingBuffer();
         try {
             if (!buffer.hasRemaining()) {
-                outputStream.flush();
+                outputStream.flushInternal();
             }
             while (cb.hasRemaining()) {
                 int remaining = buffer.remaining();
                 CoderResult result = charsetEncoder.encode(cb, buffer, false);
                 outputStream.updateWritten(remaining - buffer.remaining());
                 if(result.isOverflow()) {
-                    outputStream.flush();
+                    outputStream.flushInternal();
                 }
             }
         } catch (IOException e) {

File: servlet/src/main/java/io/undertow/servlet/spec/AsyncContextImpl.java
Patch:
@@ -56,6 +56,7 @@
 import io.undertow.servlet.handlers.ServletPathMatch;
 import io.undertow.servlet.handlers.ServletRequestContext;
 import io.undertow.util.AttachmentKey;
+import io.undertow.util.CanonicalPathUtils;
 import io.undertow.util.SameThreadExecutor;
 import org.xnio.XnioExecutor;
 
@@ -166,7 +167,7 @@ public void dispatch() {
                 //this should never happen
                 throw UndertowServletMessages.MESSAGES.couldNotFindContextToDispatchTo(requestImpl.getOriginalContextPath());
             }
-            String toDispatch = requestImpl.getOriginalRequestURI().substring(requestImpl.getOriginalContextPath().length());
+            String toDispatch = CanonicalPathUtils.canonicalize(requestImpl.getOriginalRequestURI()).substring(requestImpl.getOriginalContextPath().length());
             String qs = requestImpl.getOriginalQueryString();
             if (!qs.isEmpty()) {
                 toDispatch = toDispatch + "?" + qs;

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -449,7 +449,6 @@ private void loadParts() throws IOException, ServletException {
                     final FormData value = parser.parseBlocking();
                     for (final String namedPart : value) {
                         for (FormData.FormValue part : value.get(namedPart)) {
-                            //TODO: non-file parts?
                             parts.add(new PartImpl(namedPart, part));
                         }
                     }

File: core/src/main/java/io/undertow/UndertowLogger.java
Patch:
@@ -89,7 +89,7 @@ public interface UndertowLogger extends BasicLogger {
     @Message(id = 5011, value = "Ignoring AJP request with prefix %s")
     void ignoringAjpRequestWithPrefixCode(byte prefix);
 
-    @LogMessage(level = Logger.Level.ERROR)
+    @LogMessage(level = Logger.Level.DEBUG)
     @Message(id = 5013, value = "An IOException occurred")
     void ioException(@Cause IOException e);
 

File: core/src/main/java/io/undertow/websockets/impl/WebSocketChannelSession.java
Patch:
@@ -91,7 +91,8 @@ public void setIdleTimeout(long idleTimeout) {
     @Override
     public long getIdleTimeout() {
         try {
-            return channel.getOption(UndertowOptions.IDLE_TIMEOUT);
+            Long value =  channel.getOption(UndertowOptions.IDLE_TIMEOUT);
+            return value == null ? 0 : value;
         } catch (IOException e) {
             // log this
             WebSocketLogger.REQUEST_LOGGER.getIdleTimeFailed(e);

File: core/src/main/java/io/undertow/UndertowOptions.java
Patch:
@@ -56,7 +56,7 @@ public class UndertowOptions {
     /**
      * The idle timeout in milliseconds after which the channel will be closed.
      */
-    public static final Option<Integer> IDLE_TIMEOUT = Option.simple(UndertowOptions.class, "IDLE_TIMEOUT", Integer.class);
+    public static final Option<Long> IDLE_TIMEOUT = Option.simple(UndertowOptions.class, "IDLE_TIMEOUT", Long.class);
 
     /**
      * The maximum number of parameters that will be parsed. This is used to protect against hash vulnerabilities.

File: core/src/main/java/io/undertow/channels/IdleTimeoutStreamChannel.java
Patch:
@@ -50,7 +50,7 @@ public class IdleTimeoutStreamChannel<C extends StreamChannel> extends Delegatin
     private volatile XnioExecutor.Key handle;
     private static final AtomicReferenceFieldUpdater<IdleTimeoutStreamChannel, XnioExecutor.Key> KEY_UPDATER = AtomicReferenceFieldUpdater.newUpdater(IdleTimeoutStreamChannel.class, XnioExecutor.Key.class, "handle");
 
-    private volatile int idleTimeout;
+    private volatile long idleTimeout;
 
     private final Runnable timeoutCommand = new Runnable() {
         @Override
@@ -77,7 +77,7 @@ public IdleTimeoutStreamChannel(C channel) {
     }
 
     private void handleIdleTimeout(final long ret) {
-        int idleTimeout = this.idleTimeout;
+        long idleTimeout = this.idleTimeout;
         XnioExecutor.Key key = handle;
         if (idleTimeout > 0) {
             if (ret == 0 && key == null) {
@@ -223,7 +223,7 @@ public boolean supportsOption(Option<?> option) {
     public <T> T setOption(final Option<T> option, final T value) throws IllegalArgumentException, IOException {
         T ret = super.setOption(option, value);
         if (option == UndertowOptions.IDLE_TIMEOUT) {
-            idleTimeout = (Integer) value;
+            idleTimeout = (Long) value;
             XnioExecutor.Key key = handle;
             if (key != null) {
                 key.remove();

File: core/src/main/java/io/undertow/websockets/api/WebSocketSession.java
Patch:
@@ -90,15 +90,15 @@ public interface WebSocketSession extends BinaryFrameSender, TextFrameSender, Pi
      *
      * @param idleTimeout   the idle timeout in ms. If the smaller then 1 no timeout is used.
      */
-    void setIdleTimeout(int idleTimeout);
+    void setIdleTimeout(long idleTimeout);
 
     /**
      * Get the idle timeout for this {@link WebSocketSession}. The session will be closed
      * if nothing was received or send in this time.
      *
      * @return the idle timeout in ms. If the smaller then 1 no timeout is used.
      */
-    int getIdleTimeout();
+    long getIdleTimeout();
 
     /**
      * Set the send timeout for this {@link WebSocketSession} when sending a Websocket frame in an async fashion

File: core/src/main/java/io/undertow/websockets/impl/WebSocketChannelSession.java
Patch:
@@ -79,7 +79,7 @@ public WebSocketChannelSession(WebSocketChannel channel, String id, boolean exec
     }
 
     @Override
-    public void setIdleTimeout(int idleTimeout) {
+    public void setIdleTimeout(long idleTimeout) {
         try {
             channel.setOption(UndertowOptions.IDLE_TIMEOUT, idleTimeout);
         } catch (IOException e) {
@@ -89,7 +89,7 @@ public void setIdleTimeout(int idleTimeout) {
     }
 
     @Override
-    public int getIdleTimeout() {
+    public long getIdleTimeout() {
         try {
             return channel.getOption(UndertowOptions.IDLE_TIMEOUT);
         } catch (IOException e) {

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/UndertowSession.java
Patch:
@@ -203,12 +203,12 @@ public boolean isOpen() {
 
     @Override
     public long getMaxIdleTimeout() {
-        return 0;
+        return session.getIdleTimeout();
     }
 
     @Override
     public void setMaxIdleTimeout(final long milliseconds) {
-
+        session.setIdleTimeout(milliseconds);
     }
 
     @Override

File: core/src/main/java/io/undertow/server/handlers/resource/FileResource.java
Patch:
@@ -90,7 +90,7 @@ public boolean isDirectory() {
     public List<Resource> list() {
         final List<Resource> resources = new ArrayList<Resource>();
         for (String child : file.list()) {
-            resources.add(new FileResource(new File(child), resourceManagerRoot));
+            resources.add(new FileResource(new File(this.file, child), resourceManagerRoot));
         }
         return resources;
     }

File: core/src/main/java/io/undertow/client/HttpClientRequestImpl.java
Patch:
@@ -134,7 +134,7 @@ public StreamSinkChannel writeRequestBody(long contentLength) {
         boolean keepAlive;
         if (http11) {
             if(headers.contains(Headers.CONNECTION)) {
-                keepAlive = !headers.get(Headers.CONNECTION).equals(Headers.CLOSE.toString());
+                keepAlive = !Headers.CLOSE.equals(new HttpString(headers.getFirst(Headers.CONNECTION)));
             } else {
                 keepAlive = true;
             }

File: servlet/src/main/java/io/undertow/servlet/UndertowServletMessages.java
Patch:
@@ -181,4 +181,7 @@ public interface UndertowServletMessages {
 
     @Message(id = 10045, value = "Only one session tracking mode at a time is supported")
     IllegalArgumentException canOnlySetOneSessionTrackingMode();
+
+    @Message(id = 10046, value = "No servlet context at %s to dispatch to")
+    IllegalArgumentException couldNotFindContextToDispatchTo(String originalContextPath);
 }

File: servlet/src/main/java/io/undertow/servlet/api/Deployment.java
Patch:
@@ -40,6 +40,8 @@ public interface Deployment {
 
     DeploymentInfo getDeploymentInfo();
 
+    ServletContainer getServletContainer();
+
     ApplicationListeners getApplicationListeners();
 
     Servlets getServlets();

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -115,7 +115,7 @@ public void deploy() {
         DeploymentInfo deploymentInfo = originalDeployment.clone();
 
         deploymentInfo.validate();
-        final DeploymentImpl deployment = new DeploymentImpl(deploymentInfo);
+        final DeploymentImpl deployment = new DeploymentImpl(deploymentInfo, servletContainer);
         this.deployment = deployment;
 
         final ServletContextImpl servletContext = new ServletContextImpl(servletContainer, deployment);

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/EndpointSessionHandler.java
Patch:
@@ -68,7 +68,7 @@ public void onSession(WebSocketSession s, WebSocketHttpExchange exchange) {
                 instance = new ImmediateInstanceHandle<>((Endpoint) config.getEndpointConfiguration().getConfigurator().getEndpointInstance(config.getEndpointConfiguration().getEndpointClass()));
             }
 
-            UndertowSession session = new UndertowSession(channelSession, URI.create(exchange.getRequestURI()), exchange.getAttachment(HandshakeUtil.PATH_PARAMS), Collections.<String, List<String>>emptyMap(), this, null, instance, config.getEndpointConfiguration(), config.getEncodingFactory().createEncoding(config.getEndpointConfiguration()));
+            UndertowSession session = new UndertowSession(channelSession, URI.create(exchange.getRequestURI()), exchange.getAttachment(HandshakeUtil.PATH_PARAMS), Collections.<String, List<String>>emptyMap(), this, null, instance, config.getEndpointConfiguration(), exchange.getQueryString(), config.getEncodingFactory().createEncoding(config.getEndpointConfiguration()));
             session.setMaxBinaryMessageBufferSize(getContainer().getDefaultMaxBinaryMessageBufferSize());
             session.setMaxTextMessageBufferSize(getContainer().getDefaultMaxTextMessageBufferSize());
             //session.setTimeout(getContainer().getMaxSessionIdleTimeout());

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/ServerWebSocketContainer.java
Patch:
@@ -147,7 +147,7 @@ public Session connectToServer(final Endpoint endpointInstance, final ClientEndp
 
         WebSocketRecieveListeners.startRecieving(wss, channel, false);
         EncodingFactory encodingFactory = EncodingFactory.createFactory(classIntrospecter, cec.getDecoders(), cec.getEncoders());
-        UndertowSession undertowSession = new UndertowSession(wss, path, Collections.<String, String>emptyMap(), Collections.<String, List<String>>emptyMap(), sessionHandler, null, new ImmediateInstanceHandle<>(endpointInstance), cec, encodingFactory.createEncoding(cec));
+        UndertowSession undertowSession = new UndertowSession(wss, path, Collections.<String, String>emptyMap(), Collections.<String, List<String>>emptyMap(), sessionHandler, null, new ImmediateInstanceHandle<>(endpointInstance), cec, path.getQuery(), encodingFactory.createEncoding(cec));
         endpointInstance.onOpen(undertowSession, cec);
 
         return undertowSession;
@@ -174,7 +174,7 @@ public Session connectToServerInternal(final Endpoint endpointInstance, final Co
 
         WebSocketRecieveListeners.startRecieving(wss, channel, false);
 
-        UndertowSession undertowSession = new UndertowSession(wss, path, Collections.<String, String>emptyMap(), Collections.<String, List<String>>emptyMap(), sessionHandler, null, new ImmediateInstanceHandle<>(endpointInstance), cec.getConfig(), cec.getEncodingFactory().createEncoding(cec.getConfig()));
+        UndertowSession undertowSession = new UndertowSession(wss, path, Collections.<String, String>emptyMap(), Collections.<String, List<String>>emptyMap(), sessionHandler, null, new ImmediateInstanceHandle<>(endpointInstance), cec.getConfig(), path.getQuery(), cec.getEncodingFactory().createEncoding(cec.getConfig()));
         endpointInstance.onOpen(undertowSession, cec.getConfig());
 
         return undertowSession;

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/annotated/BoundMethod.java
Patch:
@@ -8,6 +8,7 @@
 import java.util.Map;
 import java.util.Set;
 
+import javax.websocket.DecodeException;
 import javax.websocket.DeploymentException;
 
 import io.undertow.websockets.jsr.JsrWebSocketMessages;
@@ -41,7 +42,7 @@ public BoundMethod(final Method method, final Class<?> messageType, final boolea
         }
     }
 
-    public Object invoke(final Object instance, final Map<Class<?>, Object> values) {
+    public Object invoke(final Object instance, final Map<Class<?>, Object> values) throws DecodeException {
         final Object[] params = new Object[method.getParameterTypes().length];
         for (BoundParameter param : parameters) {
             param.populate(params, values);

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/PathTemplate.java
Patch:
@@ -179,7 +179,8 @@ public boolean matches(final String path, final Map<String, String> pathParamete
                 }
                 ++cp;
                 if (cp == parts.size()) {
-                    return true;
+                    //this is a match if this is the last character
+                    return i == (path.length() - 1);
                 }
                 current = parts.get(cp);
                 stringStart = i + 1;

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/UndertowSession.java
Patch:
@@ -252,7 +252,8 @@ public Map<String, List<String>> getRequestParameterMap() {
 
     @Override
     public String getQueryString() {
-        return requestUri.getQuery();
+        String qs = requestUri.getQuery();
+        return qs == null ? "" : qs;
     }
 
     @Override

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/annotated/AnnotatedEndpoint.java
Patch:
@@ -229,7 +229,7 @@ public void onBinaryFrame(final WebSocketSession s, final WebSocketFrameHeader h
                 Object result = null;
                 for (int i = 0; i < payload.length; ++i) {
 
-                    params.put(ByteBuffer.class, payload);
+                    params.put(ByteBuffer.class, payload[i]);
                     params.put(boolean.class, header.isLastFragement() && i == payload.length - 1);
                     result = binaryMessage.invoke(instance.getInstance(), params);
                     sendResult(result);

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -112,6 +112,7 @@ public void sendError(final int sc, final String msg) throws IOException {
         if (exchange.isResponseStarted()) {
             throw UndertowServletMessages.MESSAGES.responseAlreadyCommited();
         }
+        resetBuffer();
         writer = null;
         responseState = ResponseState.NONE;
         exchange.setResponseCode(sc);

File: servlet/src/main/java/io/undertow/servlet/UndertowServletMessages.java
Patch:
@@ -172,4 +172,7 @@ public interface UndertowServletMessages {
 
     @Message(id = 10042, value = "This method cannot be called from a servlet context listener that has been added programatically")
     UnsupportedOperationException cannotCallFromProgramaticListener();
+
+    @Message(id = 10043, value = "Cannot add servlet context listener from a programatically added listener")
+    IllegalArgumentException cannotAddServletContextListener();
 }

File: servlet/src/main/java/io/undertow/servlet/api/ListenerInfo.java
Patch:
@@ -25,6 +25,7 @@
 import javax.servlet.ServletContextListener;
 import javax.servlet.ServletRequestAttributeListener;
 import javax.servlet.ServletRequestListener;
+import javax.servlet.http.HttpSessionIdListener;
 
 import io.undertow.servlet.UndertowServletMessages;
 import io.undertow.servlet.util.ConstructorInstanceFactory;
@@ -39,7 +40,8 @@ public class ListenerInfo {
             ServletRequestListener.class,
             ServletRequestAttributeListener.class,
             javax.servlet.http.HttpSessionListener.class,
-            javax.servlet.http.HttpSessionAttributeListener.class};
+            javax.servlet.http.HttpSessionAttributeListener.class,
+            HttpSessionIdListener.class};
 
     private final Class<? extends EventListener> listenerClass;
     private final InstanceFactory<? extends EventListener> instanceFactory;

File: servlet/src/main/java/io/undertow/servlet/UndertowServletMessages.java
Patch:
@@ -166,4 +166,7 @@ public interface UndertowServletMessages {
 
     @Message(id = 10040, value = "More than one default error page %s and %s")
     IllegalStateException moreThanOneDefaultErrorPage(String defaultErrorPage, String location);
+
+    @Message(id = 10041, value = "The servlet context has already been initialized, you can only call this method from a ServletContainerInitializer or a ServletContextListener.")
+    IllegalStateException servletContextAlreadyInitialized();
 }

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -117,10 +117,9 @@ public void deploy() {
         this.deployment = deployment;
 
         final ServletContextImpl servletContext = new ServletContextImpl(servletContainer, deployment);
-
+        deployment.setServletContext(servletContext);
         handleExtensions(deploymentInfo, servletContext);
 
-        deployment.setServletContext(servletContext);
         deployment.setSessionManager(deploymentInfo.getSessionManagerFactory().createSessionManager(deployment));
         deployment.getSessionManager().setDefaultSessionTimeout(deploymentInfo.getDefaultSessionTimeout());
 
@@ -173,6 +172,7 @@ public void deploy() {
             deployment.setInitialHandler(initialHandler);
             deployment.setServletHandler(servletInitialHandler);
             deployment.getServletPaths().invalidate(); //make sure we have a fresh set of servlet paths
+            servletContext.initDone();
         } catch (Exception e) {
             throw new RuntimeException(e);
         } finally {

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -179,4 +179,5 @@ public interface UndertowMessages {
 
     @Message(id = 52, value = "Session data requested when non session based authentication in use")
     IllegalStateException noSessionData();
+
 }

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -40,6 +40,7 @@
 import io.undertow.util.DateUtils;
 import io.undertow.util.Headers;
 import io.undertow.util.HttpString;
+import io.undertow.util.StatusCodes;
 
 
 /**
@@ -126,15 +127,15 @@ public void sendError(final int sc, final String msg) throws IOException {
             }
         } else if (msg != null) {
             setContentType("text/html");
-            getWriter().write(msg);
+            getWriter().write("<html><head><title>Error</title></head><body>" + msg + "</body></html>");
             getWriter().close();
         }
         responseDone();
     }
 
     @Override
     public void sendError(final int sc) throws IOException {
-        sendError(sc, null);
+        sendError(sc, StatusCodes.getReason(sc));
     }
 
     @Override

File: core/src/main/java/io/undertow/server/HttpReadListener.java
Patch:
@@ -108,7 +108,7 @@ public void handleEvent(final StreamSourceChannel channel) {
                             responseChannel.resumeWrites();
                         }
                     } catch (IOException e) {
-                        UndertowLogger.REQUEST_IO_LOGGER.ioException(e);
+                        UndertowLogger.REQUEST_IO_LOGGER.debug("Error reading request", e);
                         // fuck it, it's all ruined
                         IoUtils.safeClose(channel);
                         return;

File: core/src/main/java/io/undertow/server/HttpReadListener.java
Patch:
@@ -82,7 +82,7 @@ public void handleEvent(final StreamSourceChannel channel) {
                     try {
                         res = channel.read(buffer);
                     } catch (IOException e) {
-                        UndertowLogger.REQUEST_IO_LOGGER.ioException(e);
+                        UndertowLogger.REQUEST_IO_LOGGER.debug("Error reading request", e);
                         safeClose(channel);
                         return;
                     }

File: core/src/main/java/io/undertow/server/handlers/error/SimpleErrorPageHandler.java
Patch:
@@ -65,6 +65,7 @@ public boolean handleDefaultResponse(final HttpServerExchange exchange) {
                 if (codes == null ? exchange.getResponseCode() >= 400 : codes.contains(Integer.valueOf(exchange.getResponseCode()))) {
                     final String errorPage = "<html><head><title>Error</title></head><body>" + exchange.getResponseCode() + " - " + StatusCodes.getReason(exchange.getResponseCode()) + "</body></html>";
                     exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, "" + errorPage.length());
+                    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, "text/html");
                     Sender sender = exchange.getResponseSender();
                     sender.send(errorPage);
                     return true;

File: servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java
Patch:
@@ -231,8 +231,8 @@ private String findWelcomeFile(final String path) {
 
     private String findWelcomeServlet(final String path) {
         for (String i : welcomePages) {
-            final ServletPathMatch handler = deployment.getServletPaths().getServletHandlerByExactPath(path + i);
-            if (handler != null) {
+            final ServletPathMatch handler = deployment.getServletPaths().getServletHandlerByPath(path + i);
+            if (handler != null && !handler.getManagedServlet().getServletInfo().getServletClass().equals(DefaultServlet.class)) {
                 return i;
             }
         }

File: core/src/main/java/io/undertow/server/handlers/cache/LRUCache.java
Patch:
@@ -60,7 +60,7 @@ public void add(K key, V newValue) {
         CacheEntry<K, V> value = cache.get(key);
         if (value == null) {
             long expires;
-            if(maxEntries == -1) {
+            if(maxAge == -1) {
                 expires = -1;
             } else {
                 expires = System.currentTimeMillis() + maxAge;

File: core/src/main/java/io/undertow/websockets/core/WebSocketChannel.java
Patch:
@@ -76,7 +76,7 @@ public abstract class WebSocketChannel implements ConnectedChannel {
 
     private final AtomicBoolean broken = new AtomicBoolean(false);
 
-    private boolean receivesSuspended;
+    private boolean receivesSuspended = true;
     private boolean closeFrameReceived;
     private final Set<String> subProtocols;
     private final boolean extensionsSupported;

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/PathTemplate.java
Patch:
@@ -229,6 +229,7 @@ public int compareTo(final PathTemplate o) {
                 if (o.parts.size() == i) {
                     return base.compareTo(o.base);
                 }
+                return 1;
             } else if (o.parts.size() == i) {
                 //we have more parts, so should be checked first
                 return -1;

File: servlet/src/main/java/io/undertow/servlet/spec/ServletContextImpl.java
Patch:
@@ -380,6 +380,9 @@ public <T extends Servlet> T createServlet(final Class<T> clazz) throws ServletE
     @Override
     public ServletRegistration getServletRegistration(final String servletName) {
         final ServletInfo servlet = deploymentInfo.getServlets().get(servletName);
+        if(servlet == null) {
+            return null;
+        }
         return new ServletRegistrationImpl(servlet, deployment);
     }
 

File: core/src/test/java/io/undertow/testutils/DefaultServer.java
Patch:
@@ -44,6 +44,7 @@
 import io.undertow.server.OpenListener;
 import io.undertow.server.handlers.ProxyHandler;
 import io.undertow.server.handlers.RequestDumplingHandler;
+import io.undertow.util.NetworkUtils;
 import org.junit.runner.Description;
 import org.junit.runner.Result;
 import org.junit.runner.notification.RunListener;
@@ -162,7 +163,7 @@ private static SSLContext createSSLContext(final KeyStore keyStore, final KeySto
      * @return The base URL that can be used to make connections to this server
      */
     public static String getDefaultServerURL() {
-        return "http://" + getHostAddress(DEFAULT) + ":" + getHostPort(DEFAULT);
+        return "http://" + NetworkUtils.formatPossibleIpv6Address(getHostAddress(DEFAULT)) + ":" + getHostPort(DEFAULT);
     }
 
     public static InetSocketAddress getDefaultServerAddress() {

File: servlet/src/test/java/io/undertow/servlet/test/websocket/WebSocketServletTest.java
Patch:
@@ -13,6 +13,7 @@
 import io.undertow.servlet.websockets.WebSocketServlet;
 import io.undertow.testutils.AjpIgnore;
 import io.undertow.testutils.DefaultServer;
+import io.undertow.util.NetworkUtils;
 import io.undertow.util.StringReadChannelListener;
 import io.undertow.util.StringWriteChannelListener;
 import io.undertow.websockets.core.StreamSourceFrameChannel;
@@ -101,7 +102,7 @@ protected void error(final IOException e) {
                 .addMapping("/*"));
 
         final FutureResult latch = new FutureResult<>();
-        WebSocketTestClient client = new WebSocketTestClient(org.jboss.netty.handler.codec.http.websocketx.WebSocketVersion.V13, new URI("ws://" + DefaultServer.getHostAddress("default") + ":" + DefaultServer.getHostPort("default") + "/servletContext"));
+        WebSocketTestClient client = new WebSocketTestClient(org.jboss.netty.handler.codec.http.websocketx.WebSocketVersion.V13, new URI("ws://" + NetworkUtils.formatPossibleIpv6Address(DefaultServer.getHostAddress("default")) + ":" + DefaultServer.getHostPort("default") + "/servletContext"));
         client.connect();
         client.send(new TextWebSocketFrame(ChannelBuffers.copiedBuffer("hello", CharsetUtil.US_ASCII)), new FrameChecker(TextWebSocketFrame.class, "world".getBytes(CharsetUtil.US_ASCII), latch));
         latch.getIoFuture().get();

File: servlet/src/test/java/io/undertow/servlet/test/path/PathMappingServlet.java
Patch:
@@ -34,7 +34,7 @@ public class PathMappingServlet extends HttpServlet {
     @Override
     protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {
         PrintWriter writer = resp.getWriter();
-        writer.write(getServletName() + " - " + req.getPathInfo());
+        writer.write(getServletName()  + " - " + req.getServletPath() + " - " + req.getPathInfo());
         writer.close();
     }
 }

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -112,7 +112,6 @@ public void sendError(final int sc, final String msg) throws IOException {
         if (exchange.isResponseStarted()) {
             throw UndertowServletMessages.MESSAGES.responseAlreadyCommited();
         }
-        resetBuffer();
         writer = null;
         responseState = ResponseState.NONE;
         exchange.setResponseCode(sc);

File: servlet/src/main/java/io/undertow/servlet/spec/RequestDispatcherImpl.java
Patch:
@@ -307,7 +307,6 @@ private void error(final ServletRequest request, final ServletResponse response,
                 }
             }
         }
-        response.resetBuffer();
 
         final ServletRequest oldRequest = servletRequestContext.getServletRequest();
         final ServletResponse oldResponse = servletRequestContext.getServletResponse();

File: servlet/src/main/java/io/undertow/servlet/UndertowServletMessages.java
Patch:
@@ -163,4 +163,7 @@ public interface UndertowServletMessages {
 
     @Message(id = 10039, value = "Unknown authentication mechanism %s")
     RuntimeException unknownAuthenticationMechanism(String mechName);
+
+    @Message(id = 10040, value = "More than one default error page %s and %s")
+    IllegalStateException moreThanOneDefaultErrorPage(String defaultErrorPage, String location);
 }

File: parser-generator/src/main/java/io/undertow/annotationprocessor/AbstractParserGenerator.java
Patch:
@@ -654,7 +654,7 @@ private static void stateNotFound(final CodeAttribute c, final TableSwitchBuilde
         c.branchEnd(builder.getDefaultBranchEnd().get());
         c.newInstruction(RuntimeException.class);
         c.dup();
-        c.ldc("Could not find state");
+        c.ldc("Invalid character");
         c.invokespecial(RuntimeException.class.getName(), "<init>", "(Ljava/lang/String;)V");
         c.athrow();
     }

File: servlet/src/main/java/io/undertow/servlet/api/DeploymentInfo.java
Patch:
@@ -400,7 +400,7 @@ public Map<String, Object> getServletContextAttributes() {
         return Collections.unmodifiableMap(servletContextAttributes);
     }
 
-    public DeploymentInfo addWelcomePages(final String welcomePage) {
+    public DeploymentInfo addWelcomePage(final String welcomePage) {
         this.welcomePages.add(welcomePage);
         return this;
     }

File: examples/src/main/java/io/undertow/examples/helloworld/HelloWorldServer.java
Patch:
@@ -4,6 +4,7 @@
 import io.undertow.examples.UndertowExample;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
+import io.undertow.util.Headers;
 
 /**
  * @author Stuart Douglas
@@ -17,6 +18,7 @@ public static void main(final String[] args) {
                 .setDefaultHandler(new HttpHandler() {
                     @Override
                     public void handleRequest(final HttpServerExchange exchange) throws Exception {
+                        exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, "text/plain");
                         exchange.getResponseSender().send("Hello World");
                     }
                 }).build();

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -237,7 +237,7 @@ public String getContextPath() {
 
     @Override
     public String getQueryString() {
-        return exchange.getQueryString();
+        return exchange.getQueryString().isEmpty() ? null : exchange.getQueryString();
     }
 
     @Override

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/ServletAndResourceWelcomeFileTestCase.java
Patch:
@@ -80,7 +80,7 @@ public void testWelcomeFileRedirect() throws IOException {
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             String response = HttpClientUtils.readResponse(result);
-            Assert.assertEquals("pathInfo:null queryString: servletPath:/index.html requestUri:/servletContext/index.html", response);
+            Assert.assertEquals("pathInfo:null queryString:null servletPath:/index.html requestUri:/servletContext/index.html", response);
 
         } finally {
             client.getConnectionManager().shutdown();

File: servlet/src/test/java/io/undertow/servlet/test/request/RequestPathServlet.java
Patch:
@@ -35,6 +35,6 @@ protected void doGet(final HttpServletRequest req, final HttpServletResponse res
         resp.getWriter().write(req.getPathInfo() + "\n");
         resp.getWriter().write(req.getRequestURL().toString() + "\n");
         resp.getWriter().write(req.getRequestURI() + "\n");
-        resp.getWriter().write(req.getQueryString());
+        resp.getWriter().write(req.getQueryString() == null ? "" : req.getQueryString());
     }
 }

File: core/src/main/java/io/undertow/server/handlers/Cookie.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.Map;
 
 import io.undertow.util.AttachmentKey;
-import io.undertow.util.AttachmentList;
 
 /**
  * A HTTP cookie.
@@ -33,7 +32,7 @@
 public interface Cookie {
 
     AttachmentKey<Map<String, Cookie>> REQUEST_COOKIES = AttachmentKey.create(Map.class);
-    AttachmentKey<AttachmentList<Cookie>> RESPONSE_COOKIES = AttachmentKey.createList(Cookie.class);
+    AttachmentKey<Map<String, Cookie>> RESPONSE_COOKIES = AttachmentKey.create(Map.class);
 
     String getName();
 

File: core/src/main/java/io/undertow/server/handlers/RequestDumplingHandler.java
Patch:
@@ -2,7 +2,6 @@
 
 import java.util.Deque;
 import java.util.Iterator;
-import java.util.List;
 import java.util.Map;
 
 import io.undertow.UndertowLogger;
@@ -104,9 +103,9 @@ public void exchangeEvent(final HttpServerExchange exchange, final NextListener
                 }
                 sb.append("     contentLength=" + exchange.getResponseContentLength() + "\n");
                 sb.append("       contentType=" + exchange.getResponseHeaders().getFirst(Headers.CONTENT_TYPE) + "\n");
-                List<Cookie> cookies = CookieImpl.getResponseCookies(exchange);
+                Map<String, Cookie> cookies = CookieImpl.getResponseCookies(exchange);
                 if (cookies != null) {
-                    for (Cookie cookie : cookies) {
+                    for (Cookie cookie : cookies.values()) {
                         sb.append("            cookie=" + cookie.getName() + "=" + cookie.getValue() + "; domain=" + cookie.getDomain() + "; path=" + cookie.getPath() + "\n");
                     }
                 }

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -34,14 +34,14 @@
 import javax.servlet.http.HttpServletResponse;
 
 import io.undertow.server.HttpServerExchange;
+import io.undertow.server.handlers.CookieImpl;
 import io.undertow.servlet.UndertowServletMessages;
 import io.undertow.servlet.handlers.ServletRequestContext;
 import io.undertow.util.CanonicalPathUtils;
 import io.undertow.util.DateUtils;
 import io.undertow.util.Headers;
 import io.undertow.util.HttpString;
 
-import static io.undertow.server.handlers.Cookie.RESPONSE_COOKIES;
 
 /**
  * @author Stuart Douglas
@@ -79,7 +79,7 @@ public void addCookie(final Cookie cookie) {
         if (insideInclude) {
             return;
         }
-        exchange.addToAttachmentList(RESPONSE_COOKIES, new ServletCookieAdaptor(cookie));
+        CookieImpl.addResponseCookie(exchange, new ServletCookieAdaptor(cookie));
     }
 
     @Override

File: servlet/src/test/java/io/undertow/servlet/test/response/contenttype/ContentTypeCharsetTestCase.java
Patch:
@@ -49,11 +49,11 @@ public static void setup() throws ServletException {
     @Test
     public void testCharsetAndContentType() throws Exception {
         runtest("text/html", "UTF8", "text/html;charset=UTF8", "text/html;charset=UTF8\nUTF8");
-        runtest("text/html", "", "text/html", "text/html\nISO-8859-1");
+        runtest("text/html", "", "text/html;charset=ISO-8859-1", "text/html;charset=ISO-8859-1\nISO-8859-1");
         runtest("text/html;   charset=UTF8", "", "text/html;charset=UTF8", "text/html;charset=UTF8\nUTF8");
         runtest("text/html;   charset=UTF8; boundary=someString;", "", "text/html; boundary=someString;charset=UTF8", "text/html; boundary=someString;charset=UTF8\nUTF8");
         runtest("text/html;   charset=UTF8; boundary=someString;   ", "", "text/html; boundary=someString;charset=UTF8", "text/html; boundary=someString;charset=UTF8\nUTF8");
-        runtest("multipart/related; type=\"text/xml\"; boundary=\"uuid:ce7d652a-d035-42fa-962c-5b8315084e32\"; start=\"<root.message@cxf.apache.org>\"; start-info=\"text/xml\"", "", "multipart/related; type=\"text/xml\"; boundary=\"uuid:ce7d652a-d035-42fa-962c-5b8315084e32\"; start=\"<root.message@cxf.apache.org>\"; start-info=\"text/xml\"", "multipart/related; type=\"text/xml\"; boundary=\"uuid:ce7d652a-d035-42fa-962c-5b8315084e32\"; start=\"<root.message@cxf.apache.org>\"; start-info=\"text/xml\"\nISO-8859-1");
+        runtest("multipart/related; type=\"text/xml\"; boundary=\"uuid:ce7d652a-d035-42fa-962c-5b8315084e32\"; start=\"<root.message@cxf.apache.org>\"; start-info=\"text/xml\"", "", "multipart/related; type=\"text/xml\"; boundary=\"uuid:ce7d652a-d035-42fa-962c-5b8315084e32\"; start=\"<root.message@cxf.apache.org>\"; start-info=\"text/xml\";charset=ISO-8859-1", "multipart/related; type=\"text/xml\"; boundary=\"uuid:ce7d652a-d035-42fa-962c-5b8315084e32\"; start=\"<root.message@cxf.apache.org>\"; start-info=\"text/xml\";charset=ISO-8859-1\nISO-8859-1");
 
     }
 

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -137,6 +137,7 @@ public void deploy() {
         final ServletContextImpl servletContext = new ServletContextImpl(servletContainer, deployment);
         deployment.setServletContext(servletContext);
         deployment.setSessionManager(deploymentInfo.getSessionManagerFactory().createSessionManager(deployment));
+        deployment.getSessionManager().setDefaultSessionTimeout(deploymentInfo.getDefaultSessionTimeout());
 
         final List<ThreadSetupAction> setup = new ArrayList<ThreadSetupAction>();
         setup.add(new ContextClassLoaderSetupAction(deploymentInfo.getClassLoader()));

File: servlet/src/test/java/io/undertow/servlet/test/streams/ContentLengthCloseFlushServlet.java
Patch:
@@ -16,7 +16,7 @@ public class ContentLengthCloseFlushServlet extends HttpServlet {
     private boolean completed = false;
 
     @Override
-    protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {
+    protected synchronized void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {
         if (completed) {
             resp.getWriter().write("OK");
         } else {

File: core/src/main/java/io/undertow/client/PendingHttpRequest.java
Patch:
@@ -304,7 +304,7 @@ public void done() {
             }
 
             if (! transferEncoding.equals(Headers.IDENTITY.toString())) {
-                conduit = new ChunkedStreamSourceConduit(conduit, channel, connection.getBufferPool(), getFinishListener(closeConnection), maxEntitySize(connection.getOptions()));
+                conduit = new ChunkedStreamSourceConduit(conduit, channel, connection.getBufferPool(), getFinishListener(closeConnection), maxEntitySize(connection.getOptions()), request);
             } else if (headers.contains(Headers.CONTENT_LENGTH)) {
                 contentLength = Long.parseLong(headers.getFirst(Headers.CONTENT_LENGTH));
                 if(contentLength == 0L) {

File: core/src/main/java/io/undertow/conduits/ChunkedStreamSinkConduit.java
Patch:
@@ -181,7 +181,7 @@ public boolean flush() throws IOException {
                 return next.flush();
             } else {
                 if(trailerBuffer == null) {
-                next.write(chunkingBuffer);
+                    next.write(chunkingBuffer);
                 } else {
                     next.write(new ByteBuffer[]{chunkingBuffer, trailerBuffer}, 0, 2);
                 }

File: core/src/main/java/io/undertow/conduits/ChunkedStreamSourceConduit.java
Patch:
@@ -24,6 +24,7 @@
 import java.nio.channels.FileChannel;
 
 import io.undertow.UndertowMessages;
+import io.undertow.client.HttpClientRequest;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.util.Attachable;
 import io.undertow.util.AttachmentKey;
@@ -78,7 +79,7 @@ public class ChunkedStreamSourceConduit extends AbstractStreamSourceConduit<Stre
 
     private static final long MASK_COUNT = longBitMask(0, 56);
 
-    public ChunkedStreamSourceConduit(final StreamSourceConduit next, final PushBackStreamChannel channel, final Pool<ByteBuffer> pool, final ConduitListener<? super ChunkedStreamSourceConduit> finishListener, final long maxLength) {
+    public ChunkedStreamSourceConduit(final StreamSourceConduit next, final PushBackStreamChannel channel, final Pool<ByteBuffer> pool, final ConduitListener<? super ChunkedStreamSourceConduit> finishListener, final long maxLength, final HttpClientRequest request) {
         this(next, new BufferWrapper() {
             @Override
             public Pooled<ByteBuffer> allocate() {
@@ -89,7 +90,7 @@ public Pooled<ByteBuffer> allocate() {
             public void pushBack(Pooled<ByteBuffer> pooled) {
                 channel.unget(pooled);
             }
-        }, finishListener, maxLength, null);
+        }, finishListener, maxLength, request);
     }
 
     public ChunkedStreamSourceConduit(final StreamSourceConduit next, final HttpServerExchange exchange, final ConduitListener<? super ChunkedStreamSourceConduit> finishListener, final long maxLength) {

File: core/src/main/java/io/undertow/client/HttpClientRequest.java
Patch:
@@ -141,4 +141,5 @@ public StreamSinkChannel writeRequestBody(long contentLength, final HttpClientCa
         return channel;
     }
 
+    public abstract void setContinueHandler(final HttpContinueNotification handler);
 }

File: core/src/test/java/io/undertow/client/ResponseParserResumeTestCase.java
Patch:
@@ -50,7 +50,7 @@ public void testMethodSplit() {
     public void testOneCharacterAtATime() {
         byte[] in = DATA.getBytes();
         final ResponseParseState context = new ResponseParseState();
-        PendingHttpRequest result = new PendingHttpRequest(null, null, false, false, false, false, null);
+        PendingHttpRequest result = new PendingHttpRequest(null, null, false, false, false, false, null, null);
         ByteBuffer buffer = ByteBuffer.wrap(in);
         buffer.limit(1);
         while (context.state != ResponseParseState.PARSE_COMPLETE) {
@@ -62,7 +62,7 @@ public void testOneCharacterAtATime() {
 
     private void testResume(final int split, byte[] in) {
         final ResponseParseState context = new ResponseParseState();
-        PendingHttpRequest result = new PendingHttpRequest(null, null, false, false, false, false, null);
+        PendingHttpRequest result = new PendingHttpRequest(null, null, false, false, false, false, null, null);
         ByteBuffer buffer = ByteBuffer.wrap(in);
         buffer.limit(split);
         HttpResponseParser.INSTANCE.handle(buffer, context, result);

File: core/src/main/java/io/undertow/conduits/FixedLengthStreamSourceConduit.java
Patch:
@@ -113,7 +113,7 @@ public long transferTo(final long count, final ByteBuffer throughBuffer, final S
             }
             return res = next.transferTo(min(count, val), throughBuffer, target);
         } finally {
-            exitRead(res == -1L ? val & MASK_COUNT : res);
+            exitRead(res == -1L ? val & MASK_COUNT : res + throughBuffer.remaining());
         }
     }
 

File: core/src/main/java/io/undertow/client/HttpClient.java
Patch:
@@ -31,6 +31,9 @@
 import org.xnio.XnioWorker;
 
 /**
+ *
+ * A HTTP client, intended for use in Undertow. This is not intended to be a general purpose HTTP client.
+ *
  * @author <a href="mailto:david.lloyd@redhat.com">David M. Lloyd</a>
  */
 public abstract class HttpClient implements Closeable {

File: core/src/main/java/io/undertow/client/HttpClientRequestImpl.java
Patch:
@@ -186,7 +186,7 @@ public StreamSinkChannel writeRequestBody(long contentLength) {
         final PendingHttpRequest request = new PendingHttpRequest(this, connection, keepAlive, hasContent, expectContinue, pipelineNext, responseFuture);
         // Create the channel and wrappers
         StreamSinkConduit conduit = new StreamSinkChannelWrappingConduit(underlyingChannel);
-        conduit = new HttpRequestConduit(conduit, connection.getBufferPool(), this);
+        conduit = new HttpRequestConduit(conduit, connection.getBufferPool(), request);
         if(! hasContent) {
             headers.put(Headers.CONTENT_LENGTH, 0L);
             conduit = new FixedLengthStreamSinkConduit(conduit, 0L, false, ! keepAlive, sendCompletedListener(request));

File: core/src/main/java/io/undertow/client/HttpRequestConduit.java
Patch:
@@ -56,7 +56,7 @@ final class HttpRequestConduit extends AbstractStreamSinkConduit<StreamSinkCondu
     private Iterator<String> valueIterator;
     private int charIndex;
     private Pooled<ByteBuffer> pooledBuffer;
-    private final HttpClientRequestImpl request;
+    private final PendingHttpRequest request;
 
     private static final int STATE_BODY = 0; // Message body, normal pass-through operation
     private static final int STATE_START = 1; // No headers written yet
@@ -73,7 +73,7 @@ final class HttpRequestConduit extends AbstractStreamSinkConduit<StreamSinkCondu
     private static final int MASK_STATE         = 0x0000000F;
     private static final int FLAG_SHUTDOWN      = 0x00000010;
 
-    HttpRequestConduit(final StreamSinkConduit next, final Pool<ByteBuffer> pool, final HttpClientRequestImpl request) {
+    HttpRequestConduit(final StreamSinkConduit next, final Pool<ByteBuffer> pool, final PendingHttpRequest request) {
         super(next);
         this.pool = pool;
         this.request = request;
@@ -95,6 +95,7 @@ private int processWrite(int state, final ByteBuffer userData) throws IOExceptio
         if (state == STATE_START) {
             pooledBuffer = pool.allocate();
         }
+        HttpClientRequestImpl request = (HttpClientRequestImpl) this.request.getRequest();
         ByteBuffer buffer = pooledBuffer.getResource();
         Iterator<HttpString> nameIterator = this.nameIterator;
         Iterator<String> valueIterator = this.valueIterator;

File: core/src/main/java/io/undertow/client/PendingHttpRequest.java
Patch:
@@ -301,7 +301,7 @@ void handleResponseComplete(final HttpClientConnectionImpl connection, PushBackS
         }
         // Create the http response
         final StreamSourceChannel responseChannel = new ConduitStreamSourceChannel(channel, conduit);
-        final HttpClientResponse response = new HttpClientResponse(this, contentLength, responseChannel);
+        final HttpClientResponse response = new HttpClientResponse(this, request, contentLength, responseChannel);
         result.setResult(response);
 
         // If there is no content to read, complete the request right away

File: core/src/main/java/io/undertow/conduits/FixedLengthStreamSinkConduit.java
Patch:
@@ -242,7 +242,7 @@ private void exitWrite(long oldVal, long consumed) {
     private void exitFlush(long oldVal, boolean flushed) {
         long newVal = oldVal;
         boolean callFinish = false;
-        if (anyAreSet(oldVal, FLAG_CLOSE_REQUESTED) && flushed) {
+        if ((anyAreSet(oldVal, FLAG_CLOSE_REQUESTED) || (newVal & MASK_COUNT) == 0L) && flushed) {
             newVal |= FLAG_CLOSE_COMPLETE;
 
             if (!anyAreSet(oldVal, FLAG_FINISHED_CALLED) && (newVal & MASK_COUNT) == 0L) {

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -1489,7 +1489,7 @@ public long transferTo(final long position, final long count, final FileChannel
 
         public void awaitReadable() throws IOException {
             if (allAreSet(state, FLAG_REQUEST_TERMINATED)) {
-                throw UndertowMessages.MESSAGES.channelIsClosed();
+                return;
             }
             delegate.awaitReadable();
         }
@@ -1502,9 +1502,8 @@ public void suspendReads() {
         }
 
         public long transferTo(final long count, final ByteBuffer throughBuffer, final StreamSinkChannel target) throws IOException {
-
             if (allAreSet(state, FLAG_REQUEST_TERMINATED)) {
-                throw UndertowMessages.MESSAGES.channelIsClosed();
+                return -1;
             }
             return delegate.transferTo(count, throughBuffer, target);
         }

File: core/src/test/java/io/undertow/test/utils/DefaultServer.java
Patch:
@@ -95,8 +95,8 @@ public class DefaultServer extends BlockJUnit4ClassRunner {
     private static final String CLIENT_TRUST_STORE = "client.truststore";
     private static final char[] STORE_PASSWORD = "password".toCharArray();
 
-    private static final boolean ajp = Boolean.getBoolean("ajp");
-    private static final boolean proxy = Boolean.getBoolean("proxy");
+    private static final boolean ajp = Boolean.getBoolean("test.ajp");
+    private static final boolean proxy = Boolean.getBoolean("test.proxy");
 
     private static final DelegatingHandler rootHandler = new DelegatingHandler();
 

File: servlet/src/main/java/io/undertow/servlet/spec/ServletOutputStreamImpl.java
Patch:
@@ -92,7 +92,7 @@ public class ServletOutputStreamImpl extends ServletOutputStream implements Buff
     private static final int FLAG_IN_CALLBACK = 1 << 4;
 
     //TODO: should this be configurable?
-    private static final int MAX_BUFFERS_TO_ALLOCATE = 10;
+    private static final int MAX_BUFFERS_TO_ALLOCATE = 6;
 
     private final StreamSinkChannel underlyingConnectionChannel;
     private CompositeThreadSetupAction threadSetupAction;

File: servlet/src/main/java/io/undertow/servlet/spec/ServletOutputStreamImpl.java
Patch:
@@ -91,6 +91,7 @@ public class ServletOutputStreamImpl extends ServletOutputStream implements Buff
     private static final int FLAG_DELEGATE_SHUTDOWN = 1 << 3;
     private static final int FLAG_IN_CALLBACK = 1 << 4;
 
+    //TODO: should this be configurable?
     private static final int MAX_BUFFERS_TO_ALLOCATE = 10;
 
     private final StreamSinkChannel underlyingConnectionChannel;

File: core/src/main/java/io/undertow/io/AsyncSenderImpl.java
Patch:
@@ -103,6 +103,7 @@ public void handleEvent(final Channel channel) {
                                         return;
                                     }
                                 } while (written < total);
+                                streamSinkChannel.suspendWrites();
                                 callback.onComplete(exchange, AsyncSenderImpl.this);
                             } catch (IOException e) {
                                 callback.onException(exchange, AsyncSenderImpl.this, e);

File: core/src/main/java/io/undertow/server/HttpHandlers.java
Patch:
@@ -48,7 +48,6 @@ public static void executeHandler(final HttpHandler handler, final HttpServerExc
 
     public static void executeRootHandler(final HttpHandler handler, final HttpServerExchange exchange, boolean inIoThread) {
         try {
-            exchange.setInIoThread(inIoThread);
             exchange.setInCall(true);
             handler.handleRequest(exchange);
             exchange.setInCall(false);

File: core/src/main/java/io/undertow/server/handlers/resource/FileResource.java
Patch:
@@ -141,6 +141,7 @@ public void run() {
                 }
                 ByteBuffer buffer = pooled.getResource();
                 try {
+                    buffer.clear();
                     int res = fileChannel.read(buffer);
                     if (res == -1) {
                         //we are done, just return

File: core/src/main/java/io/undertow/Undertow.java
Patch:
@@ -180,7 +180,7 @@ private HttpHandler buildHandlerChain() {
         final NameVirtualHostHandler virtualHostHandler = new NameVirtualHostHandler();
         for (VirtualHost host : hosts) {
             final PathHandler paths = new PathHandler();
-            paths.setDefaultHandler(host.defaultHandler);
+            paths.addPath("/", host.defaultHandler);
             for (final Map.Entry<String, HttpHandler> entry : host.handlers.entrySet()) {
                 paths.addPath(entry.getKey(), entry.getValue());
             }

File: core/src/test/java/io/undertow/test/handlers/path/PathTestCase.java
Patch:
@@ -61,7 +61,7 @@ public void testBasicPathHanding() throws IOException {
 
             handler.addPath("/path", sub);
             sub.addPath("/subpath", new RemainingPathHandler("/subpath"));
-            sub.setDefaultHandler(new RemainingPathHandler("/path"));
+            sub.addPath("/", new RemainingPathHandler("/path"));
 
             DefaultServer.setRootHandler(handler);
 

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -756,7 +756,7 @@ public void ungetRequestBytes(final Pooled<ByteBuffer> unget) {
                 //TODO: this is horrible, but should not happen often
                 final byte[] data = new byte[ugBuffer.remaining() + buf.remaining()];
                 int first = ugBuffer.remaining();
-                ugBuffer.get(data);
+                ugBuffer.get(data, 0, ugBuffer.remaining());
                 buf.get(data, first, buf.remaining());
                 eb.free();
                 unget.free();

File: servlet/src/test/java/io/undertow/servlet/test/listener/ordering/ServletSessionListenerOrderingTestCase.java
Patch:
@@ -31,7 +31,6 @@
 import io.undertow.servlet.api.ServletInfo;
 import io.undertow.servlet.test.SimpleServletTestCase;
 import io.undertow.servlet.test.util.EmptyServlet;
-import io.undertow.servlet.test.util.MessageServlet;
 import io.undertow.servlet.test.util.TestClassIntrospector;
 import io.undertow.servlet.test.util.Tracker;
 import io.undertow.test.utils.DefaultServer;

File: core/src/main/java/io/undertow/io/BlockingSenderImpl.java
Patch:
@@ -124,6 +124,7 @@ private boolean writeBuffer(final ByteBuffer[] buffers, final IoCallback callbac
             //fast path, if the stream can take a buffer directly just write to it
             try {
                 ((BufferWritableOutputStream) outputStream).write(buffers);
+                return true;
             } catch (IOException e) {
                 callback.onException(exchange, this, e);
                 return false;

File: core/src/test/java/io/undertow/test/handlers/ChunkedRequestTransferCodingTestCase.java
Patch:
@@ -125,7 +125,7 @@ public boolean isChunked() {
                     public void writeTo(OutputStream outstream) throws IOException {
                         int l = 0;
                         int i = 0;
-                        while (i < message.length()) {
+                        while (i <= message.length()) {
                             i += random.nextInt(1000);
                             i = Math.min(i, message.length());
                             outstream.write(message.getBytes(), l, i - l);

File: servlet/src/test/java/io/undertow/servlet/test/streams/BlockingInputStreamServlet.java
Patch:
@@ -37,9 +37,6 @@ public class BlockingInputStreamServlet extends HttpServlet {
     protected void doPost(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {
         final ByteArrayOutputStream out = new ByteArrayOutputStream();
         final ServletInputStream inputStream = req.getInputStream();
-        if(inputStream.available() == 0) {
-            throw new ServletException("Nothing available");
-        }
         byte[] buf = new byte[1024];
         int read;
         while ((read = inputStream.read(buf)) != -1) {

File: core/src/main/java/io/undertow/io/UndertowInputStream.java
Patch:
@@ -42,7 +42,7 @@ public int read() throws IOException {
         if (read == -1) {
             return -1;
         }
-        return b[0];
+        return b[0] & 0xff;
     }
 
     @Override

File: servlet/src/main/java/io/undertow/servlet/spec/ServletInputStreamImpl.java
Patch:
@@ -101,7 +101,7 @@ public int read() throws IOException {
         if (read == -1) {
             return -1;
         }
-        return b[0];
+        return b[0] & 0xff;
     }
 
     @Override

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -1130,7 +1130,7 @@ void startResponse() throws IllegalStateException {
         log.tracef("Starting to write response for %s", this);
     }
 
-    public XnioExecutor getIoThread() {
+    public XnioIoThread getIoThread() {
         return connection.getIoThread();
     }
 

File: servlet/src/main/java/io/undertow/servlet/spec/ServletInputStreamImpl.java
Patch:
@@ -162,6 +162,7 @@ private void readIntoBufferNonBlocking() throws IOException {
                     int res = channel.read(pooled.getResource());
                     if(res == 0) {
                         pooled.free();
+                        pooled = null;
                         return;
                     }
                     pooled.getResource().flip();

File: core/src/main/java/io/undertow/server/HttpOpenListener.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * JBoss, Home of Professional Open Source.
- * Copyright 2012 Red Hat, Inc., and individual contributors
+ * Copyright 2013 Red Hat, Inc., and individual contributors
  * as indicated by the @author tags.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/main/java/io/undertow/server/HttpReadListener.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * JBoss, Home of Professional Open Source.
- * Copyright 2012 Red Hat, Inc., and individual contributors
+ * Copyright 2013 Red Hat, Inc., and individual contributors
  * as indicated by the @author tags.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/main/java/io/undertow/server/HttpRequestParser.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * JBoss, Home of Professional Open Source.
- * Copyright 2012 Red Hat, Inc., and individual contributors
+ * Copyright 2013 Red Hat, Inc., and individual contributors
  * as indicated by the @author tags.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/main/java/io/undertow/server/HttpResponseConduit.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * JBoss, Home of Professional Open Source.
- * Copyright 2012 Red Hat, Inc., and individual contributors
+ * Copyright 2013 Red Hat, Inc., and individual contributors
  * as indicated by the @author tags.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/main/java/io/undertow/server/HttpTransferEncoding.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * JBoss, Home of Professional Open Source.
- * Copyright 2012 Red Hat, Inc., and individual contributors
+ * Copyright 2013 Red Hat, Inc., and individual contributors
  * as indicated by the @author tags.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/main/java/io/undertow/server/ParseState.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * JBoss, Home of Professional Open Source.
- * Copyright 2012 Red Hat, Inc., and individual contributors
+ * Copyright 2013 Red Hat, Inc., and individual contributors
  * as indicated by the @author tags.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/main/java/io/undertow/server/handlers/cache/DirectBufferCache.java
Patch:
@@ -270,7 +270,6 @@ public boolean allocate() {
                     this.buffers = INIT_BUFFERS;
                     return false;
                 }
-
                 buffers[i] = allocate;
             }
 

File: core/src/main/java/io/undertow/server/handlers/cache/LimitedBufferSlicePool.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * JBoss, Home of Professional Open Source.
- * Copyright 2012 Red Hat, Inc., and individual contributors
+ * Copyright 2013 Red Hat, Inc., and individual contributors
  * as indicated by the @author tags.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: core/src/main/java/io/undertow/server/handlers/resource/ResourceHandler.java
Patch:
@@ -162,7 +162,7 @@ public void run() {
                     exchange.getResponseHeaders().put(Headers.LAST_MODIFIED, DateUtils.toDateString(lastModified));
                 }
                 if (etag != null) {
-                    exchange.getResponseHeaders().put(Headers.CONTENT_LANGUAGE, etag.toString());
+                    exchange.getResponseHeaders().put(Headers.ETAG, etag.toString());
                 }
                 Long contentLength = resource.getContentLength();
                 if (contentLength != null) {

File: jsp/src/test/java/io/undertow/test/jsp/basic/SimpleJspTestCase.java
Patch:
@@ -68,7 +68,7 @@ public static void setup() throws ServletException {
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(new TestResourceLoader(SimpleJspTestCase.class))
+                .setResourceManager(new TestResourceLoader(SimpleJspTestCase.class))
                 .addServlet(JspServletBuilder.createServlet("Default Jsp Servlet", "*.jsp"));
         JspServletBuilder.setupDeployment(builder, new HashMap<String, JspPropertyGroup>(), new HashMap<String, TagLibraryInfo>(), new HackInstanceManager());
 

File: servlet/src/main/java/io/undertow/servlet/spec/ServletOutputStreamImpl.java
Patch:
@@ -210,7 +210,6 @@ public void write(final byte[] b, final int off, final int len) throws IOExcepti
     void updateWritten(final int len) throws IOException {
         this.written += len;
         if (contentLength != null && this.written >= contentLength) {
-            flush();
             close();
         }
     }
@@ -338,6 +337,9 @@ private void writeBufferBlocking() throws IOException {
         if (channel == null) {
             channel = servletResponse.getExchange().getResponseChannel();
         }
+        if(!buffer.hasRemaining()) {
+            return;
+        }
         Channels.writeBlocking(channel, buffer);
         buffer.clear();
         state |= FLAG_WRITE_STARTED;

File: servlet/src/main/java/io/undertow/servlet/websockets/ServletWebSocketHttpExchange.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * JBoss, Home of Professional Open Source.
- * Copyright 2012 Red Hat, Inc., and individual contributors
+ * Copyright 2013 Red Hat, Inc., and individual contributors
  * as indicated by the @author tags.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: servlet/src/test/java/io/undertow/servlet/test/ListenerTestCase.java
Patch:
@@ -31,7 +31,6 @@
 import io.undertow.servlet.spec.ServletContextImpl;
 import io.undertow.servlet.test.util.MessageServlet;
 import io.undertow.servlet.test.util.TestClassIntrospector;
-import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.test.utils.DefaultServer;
 import org.junit.Assert;
 import org.junit.BeforeClass;
@@ -57,7 +56,6 @@ public static void setup() throws ServletException {
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                 .addServlet(
                         new ServletInfo("servlet", MessageServlet.class)
                                 .addMapping("/aa")

File: servlet/src/test/java/io/undertow/servlet/test/SimpleServletTestCase.java
Patch:
@@ -29,7 +29,6 @@
 import io.undertow.servlet.api.ServletInfo;
 import io.undertow.servlet.test.util.MessageServlet;
 import io.undertow.servlet.test.util.TestClassIntrospector;
-import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
 import org.apache.http.HttpResponse;
@@ -64,7 +63,6 @@ public static void setup() throws ServletException {
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                 .addServlet(s);
 
         DeploymentManager manager = container.addDeployment(builder);

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/ServletAndResourceWelcomeFileTestCase.java
Patch:
@@ -58,7 +58,7 @@ public static void setup() throws ServletException {
                 .setClassLoader(ServletPathMappingTestCase.class.getClassLoader())
                 .setContextPath("/servletContext")
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(new TestResourceLoader(WelcomeFileBlockingPathTestCase.class))
+                .setResourceManager(new TestResourceLoader(WelcomeFileBlockingPathTestCase.class))
                 .addWelcomePages("doesnotexist.html", "index.html", "default");
 
         builder.addServlet(new ServletInfo("DefaultTestServlet", DefaultTestServlet.class)

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/WelcomeFileAsyncPathTestCase.java
Patch:
@@ -52,7 +52,7 @@ public static void setup() throws ServletException {
                 .setClassLoader(ServletPathMappingTestCase.class.getClassLoader())
                 .setContextPath("/servletContext")
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(new TestResourceLoader(WelcomeFileAsyncPathTestCase.class))
+                .setResourceManager(new TestResourceLoader(WelcomeFileAsyncPathTestCase.class))
                 .addWelcomePages("doesnotexist.html", "index.html", "default");
 
         builder.addServlet(new ServletInfo("DefaultTestServlet", DefaultTestServlet.class)

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/WelcomeFileBlockingPathTestCase.java
Patch:
@@ -53,7 +53,7 @@ public static void setup() throws ServletException {
                 .setClassLoader(ServletPathMappingTestCase.class.getClassLoader())
                 .setContextPath("/servletContext")
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(new TestResourceLoader(WelcomeFileBlockingPathTestCase.class))
+                .setResourceManager(new TestResourceLoader(WelcomeFileBlockingPathTestCase.class))
                 .addWelcomePages("doesnotexist.html", "index.html", "default");
 
         builder.addServlet(new ServletInfo("DefaultTestServlet", DefaultTestServlet.class)

File: servlet/src/test/java/io/undertow/servlet/test/dispatcher/DispatcherIncludeTestCase.java
Patch:
@@ -64,7 +64,7 @@ public static void setup() throws ServletException {
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(new TestResourceLoader(DispatcherIncludeTestCase.class))
+                .setResourceManager(new TestResourceLoader(DispatcherIncludeTestCase.class))
                 .addServlet(
                         new ServletInfo("include", MessageServlet.class)
                                 .addInitParam(MessageServlet.MESSAGE, "included")

File: servlet/src/test/java/io/undertow/servlet/test/listener/ordering/ServletSessionListenerOrderingTestCase.java
Patch:
@@ -32,7 +32,6 @@
 import io.undertow.servlet.test.SimpleServletTestCase;
 import io.undertow.servlet.test.util.MessageServlet;
 import io.undertow.servlet.test.util.TestClassIntrospector;
-import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.servlet.test.util.Tracker;
 import io.undertow.test.utils.DefaultServer;
 import org.apache.http.HttpResponse;
@@ -65,7 +64,6 @@ public static void setup() throws ServletException {
                 .setContextPath("/listener")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("listener.war")
-                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                 .addListener(new ListenerInfo(FirstListener.class))
                 .addListener(new ListenerInfo(SecondListener.class))
                 .addServlet(

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/RequestListenerAsyncRequestTestCase.java
Patch:
@@ -31,7 +31,6 @@
 import io.undertow.servlet.test.SimpleServletTestCase;
 import io.undertow.servlet.test.util.MessageServlet;
 import io.undertow.servlet.test.util.TestClassIntrospector;
-import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
 import io.undertow.util.TestHttpClient;
@@ -76,7 +75,6 @@ public static void setup() throws ServletException {
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                 .addServlets(m, a, a2)
                 .addListener(new ListenerInfo(TestListener.class));
 

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/TestListener.java
Patch:
@@ -44,11 +44,13 @@ public static void init(int count) {
     @Override
     public void requestDestroyed(final ServletRequestEvent sre) {
         RESULTS.add("destroyed " + sre.getServletRequest().getDispatcherType());
+        latch.countDown();
     }
 
     @Override
     public void requestInitialized(final ServletRequestEvent sre) {
         RESULTS.add("created " + sre.getServletRequest().getDispatcherType());
+        latch.countDown();
     }
 
     public static List<String> results() {

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/onError/AsyncListenerOnErrorTest.java
Patch:
@@ -28,7 +28,6 @@
 import io.undertow.servlet.api.ServletContainer;
 import io.undertow.servlet.api.ServletInfo;
 import io.undertow.servlet.test.util.TestClassIntrospector;
-import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
 import io.undertow.util.TestHttpClient;
@@ -77,7 +76,6 @@ public static void setup() throws ServletException {
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                 .addServlets(f, a1, a2, a3);
 
         DeploymentManager manager = container.addDeployment(builder);

File: servlet/src/test/java/io/undertow/servlet/test/path/RealPathTestCase.java
Patch:
@@ -60,7 +60,7 @@ public static void setup() throws ServletException {
                 .setClassLoader(RealPathTestCase.class.getClassLoader())
                 .setContextPath("/servletContext")
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(new TestResourceLoader(RealPathTestCase.class))
+                .setResourceManager(new TestResourceLoader(RealPathTestCase.class))
                 .addServlets(realPathServlet);
 
         DeploymentManager manager = container.addDeployment(builder);

File: servlet/src/test/java/io/undertow/servlet/test/security/constraint/EmptyRoleSemanticTestCase.java
Patch:
@@ -33,7 +33,6 @@
 import io.undertow.servlet.test.SimpleServletTestCase;
 import io.undertow.servlet.test.util.MessageServlet;
 import io.undertow.servlet.test.util.TestClassIntrospector;
-import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
 import io.undertow.util.FlexBase64;
@@ -79,7 +78,6 @@ public static void setup() throws ServletException {
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                 .setIdentityManager(identityManager)
                 .setLoginConfig(new LoginConfig("BASIC", "Test Realm"))
                 .addServlet(s);

File: servlet/src/test/java/io/undertow/servlet/test/security/constraint/SecurityConstraintUrlMappingTestCase.java
Patch:
@@ -15,7 +15,6 @@
 import io.undertow.servlet.test.SimpleServletTestCase;
 import io.undertow.servlet.test.util.MessageServlet;
 import io.undertow.servlet.test.util.TestClassIntrospector;
-import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
 import io.undertow.util.FlexBase64;
@@ -66,7 +65,6 @@ public static void setup() throws ServletException {
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                 .setIdentityManager(identityManager)
                 .setLoginConfig(new LoginConfig("BASIC", "Test Realm"))
                 .addServlet(s);

File: servlet/src/test/java/io/undertow/servlet/test/security/form/ServletFormAuthTestCase.java
Patch:
@@ -21,7 +21,6 @@
 import io.undertow.servlet.test.security.SendUsernameServlet;
 import io.undertow.servlet.test.security.constraint.ServletIdentityManager;
 import io.undertow.servlet.test.util.TestClassIntrospector;
-import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
 import io.undertow.util.TestHttpClient;
@@ -76,7 +75,6 @@ public static void setup() throws ServletException {
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                 .setIdentityManager(identityManager)
                 .setLoginConfig(new LoginConfig("FORM", "Test Realm", "/FormLoginServlet", "/error.html"))
                 .addServlets(s, s1);

File: servlet/src/test/java/io/undertow/servlet/test/security/login/ServletLoginTestCase.java
Patch:
@@ -17,7 +17,6 @@
 import io.undertow.servlet.test.security.SendUsernameServlet;
 import io.undertow.servlet.test.security.constraint.ServletIdentityManager;
 import io.undertow.servlet.test.util.TestClassIntrospector;
-import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
 import io.undertow.util.TestHttpClient;
@@ -58,7 +57,6 @@ public static void setup() throws ServletException {
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                 .setIdentityManager(identityManager)
                 .setLoginConfig(new LoginConfig("BASIC", "Test Realm"))
                 .addServlet(s)

File: servlet/src/test/java/io/undertow/servlet/test/security/ssl/ConfidentialityConstraintUrlMappingTestCase.java
Patch:
@@ -31,7 +31,6 @@
 import io.undertow.servlet.test.security.constraint.SendSchemeMessageServlet;
 import io.undertow.servlet.test.util.TestClassIntrospector;
 import io.undertow.servlet.test.util.TestConfidentialPortManager;
-import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.test.utils.AjpIgnore;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
@@ -74,7 +73,6 @@ public static void setup() throws Exception {
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                 .setConfidentialPortManager(TestConfidentialPortManager.INSTANCE)
                 .addServlet(s);
 

File: servlet/src/test/java/io/undertow/servlet/test/security/ssl/SSLMetaDataTestCase.java
Patch:
@@ -28,7 +28,6 @@
 import io.undertow.servlet.api.ServletInfo;
 import io.undertow.servlet.test.SimpleServletTestCase;
 import io.undertow.servlet.test.util.TestClassIntrospector;
-import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.test.utils.AjpIgnore;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
@@ -69,7 +68,6 @@ public static void setup() throws Exception {
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                 .addServlet(s);
 
 

File: servlet/src/test/java/io/undertow/servlet/test/session/ChangeSessionIdTestCase.java
Patch:
@@ -13,7 +13,6 @@
 import io.undertow.servlet.api.ServletInfo;
 import io.undertow.servlet.test.SimpleServletTestCase;
 import io.undertow.servlet.test.util.TestClassIntrospector;
-import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
 import io.undertow.util.TestHttpClient;
@@ -45,7 +44,6 @@ public static void setup() throws ServletException {
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
                 .addListener(new ListenerInfo(ChangeSessionIdListener.class))
-                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                 .addServlet(s);
 
         DeploymentManager manager = container.addDeployment(builder);

File: servlet/src/test/java/io/undertow/servlet/test/session/CrossContextServletSessionTestCase.java
Patch:
@@ -33,7 +33,6 @@
 import io.undertow.servlet.api.ServletInfo;
 import io.undertow.servlet.test.SimpleServletTestCase;
 import io.undertow.servlet.test.util.TestClassIntrospector;
-import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
 import org.apache.http.HttpResponse;
@@ -80,7 +79,6 @@ private static void createDeployment(final String name, final ServletContainer c
                 .setContextPath("/" + name)
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName( name + ".war")
-                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                 .addServlets(s, forward);
 
         DeploymentManager manager = container.addDeployment(builder);

File: servlet/src/test/java/io/undertow/servlet/test/util/DeploymentUtils.java
Patch:
@@ -56,7 +56,6 @@ public static Deployment setupServlet(final ServletInfo... servlets) {
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                 .addServlets(servlets);
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();

File: websockets-jsr/src/test/java/io/undertow/websockets/jsr/test/JsrWebSocketServer07Test.java
Patch:
@@ -44,7 +44,6 @@
 import io.undertow.servlet.api.FilterInfo;
 import io.undertow.servlet.api.ServletContainer;
 import io.undertow.servlet.test.util.TestClassIntrospector;
-import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.util.ConcreteIoFuture;
 import io.undertow.websockets.jsr.JsrWebSocketFilter;
@@ -610,7 +609,6 @@ private void deployServlet(final ServerWebSocketContainer deployment) throws Ser
                 .setDeploymentName("websocket.war")
                 .addFilter(new FilterInfo("filter", JsrWebSocketFilter.class))
                 .addFilterUrlMapping("filter", "/*", DispatcherType.REQUEST)
-                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                 .addServletContextAttribute(javax.websocket.server.ServerContainer.class.getName(), deployment);
 
         final PathHandler root = new PathHandler();

File: websockets-jsr/src/test/java/io/undertow/websockets/jsr/test/annotated/AnnotatedEndpointTest.java
Patch:
@@ -28,7 +28,6 @@
 import io.undertow.servlet.api.FilterInfo;
 import io.undertow.servlet.api.ServletContainer;
 import io.undertow.servlet.test.util.TestClassIntrospector;
-import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.util.ConcreteIoFuture;
 import io.undertow.websockets.jsr.JsrWebSocketFilter;
@@ -64,7 +63,6 @@ public static void setup() throws Exception {
                 .setContextPath("/")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                 .addServletContextAttribute(javax.websocket.server.ServerContainer.class.getName(), deployment)
                 .addFilter(new FilterInfo("filter", JsrWebSocketFilter.class))
                 .addFilterUrlMapping("filter", "/*", DispatcherType.REQUEST);

File: websockets-jsr/src/test/java/io/undertow/websockets/jsr/test/autobahn/AutobahnServer.java
Patch:
@@ -28,7 +28,6 @@
 import io.undertow.servlet.api.FilterInfo;
 import io.undertow.servlet.api.ServletContainer;
 import io.undertow.servlet.test.util.TestClassIntrospector;
-import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.websockets.jsr.JsrWebSocketFilter;
 import io.undertow.websockets.jsr.ServerWebSocketContainer;
@@ -91,7 +90,6 @@ public void run() {
                     .setContextPath("/")
                     .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                     .setDeploymentName("servletContext.war")
-                    .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                     .addServletContextAttribute(javax.websocket.server.ServerContainer.class.getName(), deployment)
                     .addFilter(new FilterInfo("filter", JsrWebSocketFilter.class))
                     .addFilterUrlMapping("filter", "/*", DispatcherType.REQUEST);

File: servlet/src/test/java/io/undertow/servlet/test/util/Tracker.java
Patch:
@@ -17,6 +17,7 @@
 package io.undertow.servlet.test.util;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -27,7 +28,7 @@
  */
 public class Tracker {
 
-    private static final List<String> actions = new ArrayList<String>();
+    private static final List<String> actions = Collections.synchronizedList(new ArrayList<String>());
 
     public static void addAction(String action) {
         actions.add(action);

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -956,7 +956,7 @@ public int getResponseCode() {
      * Force the codec to treat the response as fully written.  Should only be invoked by handlers which downgrade
      * the socket or implement a transfer coding.
      */
-    void terminateResponse() {
+    public void terminateResponse() {
         int oldVal = state;
         if (allAreSet(oldVal, FLAG_RESPONSE_TERMINATED)) {
             // idempotent

File: core/src/test/java/io/undertow/test/handlers/ChunkedRequestTrailersTestCase.java
Patch:
@@ -28,6 +28,7 @@
 import io.undertow.server.HttpServerConnection;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.handlers.BlockingHandler;
+import io.undertow.test.utils.AjpIgnore;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
 import io.undertow.util.HeaderMap;
@@ -41,6 +42,7 @@
  * @author Stuart Douglas
  */
 @RunWith(DefaultServer.class)
+@AjpIgnore
 public class ChunkedRequestTrailersTestCase {
 
     private static volatile HttpServerConnection connection;

File: core/src/test/java/io/undertow/test/handlers/ChunkedResponseTrailersTestCase.java
Patch:
@@ -28,6 +28,7 @@
 import io.undertow.server.HttpServerConnection;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.handlers.BlockingHandler;
+import io.undertow.test.utils.AjpIgnore;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
 import io.undertow.util.HeaderMap;
@@ -50,6 +51,7 @@
  * @author Stuart Douglas
  */
 @RunWith(DefaultServer.class)
+@AjpIgnore
 public class ChunkedResponseTrailersTestCase {
 
     private static final String MESSAGE = "My HTTP Request!";

File: servlet/src/test/java/io/undertow/servlet/test/security/constraint/EmptyRoleSemanticTestCase.java
Patch:
@@ -153,8 +153,6 @@ public void testAuthenticate() throws Exception {
             get.addHeader("ExpectedMechanism", "BASIC");
             get.addHeader("ExpectedUser", "user1");
             get.addHeader(AUTHORIZATION.toString(), BASIC + " " + FlexBase64.encodeString("user1:password1".getBytes(), false));
-            get.addHeader("ExpectedMechanism", "BASIC");
-            get.addHeader("ExpectedUser", "user1");
             result = client.execute(get);
             assertEquals(200, result.getStatusLine().getStatusCode());
 

File: core/src/main/java/io/undertow/util/MimeMappings.java
Patch:
@@ -125,6 +125,7 @@ public class MimeMappings {
         /* Add XML related MIMEs */
 
         defaultMappings.put("xml", "text/xml");
+        defaultMappings.put("xhtml", "application/xhtml+xml");
         defaultMappings.put("xsl", "text/xml");
         defaultMappings.put("svg", "image/svg+xml");
         defaultMappings.put("svgz", "image/svg+xml");

File: servlet/src/main/java/io/undertow/servlet/spec/ServletOutputStreamImpl.java
Patch:
@@ -515,6 +515,7 @@ public void run() {
                             return;
                         } catch (IOException e) {
                             handleError(e);
+                            return;
                         }
                     }
                     //if there is data still to write
@@ -532,6 +533,7 @@ public void run() {
                                 }
                             } catch (IOException e) {
                                 handleError(e);
+                                return;
                             }
                         } while (written < toWrite);
                         buffersToWrite = null;
@@ -545,6 +547,7 @@ public void run() {
                             }
                         } catch (IOException e) {
                             handleError(e);
+                            return;
                         }
                     } else {
 

File: core/src/main/java/io/undertow/ajp/AjpOpenListener.java
Patch:
@@ -39,7 +39,8 @@ public void handleEvent(final StreamConnection channel) {
         }
 
         HttpServerConnection connection = new HttpServerConnection(channel, bufferPool, rootHandler, undertowOptions, bufferSize);
-        AjpReadListener readListener = new AjpReadListener(channel, connection);
+        AjpReadListener readListener = new AjpReadListener(connection);
+        readListener.startRequest();
         channel.getSourceChannel().setReadListener(readListener);
         readListener.handleEvent(channel.getSourceChannel());
     }

File: core/src/main/java/io/undertow/ajp/AjpResponseConduit.java
Patch:
@@ -176,7 +176,7 @@ private boolean processWrite() throws IOException {
                 putString(buffer, StatusCodes.getReason(exchange.getResponseCode()));
 
                 int headers = 0;
-                //we need to cound the headers
+                //we need to count the headers
                 final HeaderMap responseHeaders = exchange.getResponseHeaders();
                 for (HttpString name : responseHeaders.getHeaderNames()) {
                     headers += responseHeaders.get(name).size();

File: core/src/main/java/io/undertow/server/HttpReadListener.java
Patch:
@@ -57,7 +57,7 @@ final class HttpReadListener implements ChannelListener<StreamSourceChannel>, Ex
     public void newRequest() {
         state.reset();
         read = 0;
-        httpServerExchange = new HttpServerExchange(connection, connection.getChannel().getSourceChannel(), connection.getChannel().getSinkChannel());
+        httpServerExchange = new HttpServerExchange(connection);
         httpServerExchange.addExchangeCompleteListener(this);
     }
 

File: core/src/test/java/io/undertow/ajp/AjpParsingUnitTestCase.java
Patch:
@@ -41,7 +41,7 @@ public class AjpParsingUnitTestCase {
     @Test
     public void testAjpParsing() {
         final ByteBuffer buffer = AjpParsingUnitTestCase.buffer.duplicate();
-        HttpServerExchange result = new HttpServerExchange(null, null, null);
+        HttpServerExchange result = new HttpServerExchange(null);
         final AjpParseState state = new AjpParseState();
         AjpParser.INSTANCE.parse(buffer, state, result);
         Assert.assertEquals(165, state.dataSize);
@@ -55,7 +55,7 @@ public void testAjpParsing() {
     public void testByteByByteAjpParsing() {
         final ByteBuffer buffer = AjpParsingUnitTestCase.buffer.duplicate();
 
-        HttpServerExchange result = new HttpServerExchange(null, null, null);
+        HttpServerExchange result = new HttpServerExchange(null);
         final AjpParseState state = new AjpParseState();
         int limit = buffer.limit();
         for (int i = 1; i <= limit; ++i) {

File: core/src/test/java/io/undertow/server/ParserResumeTestCase.java
Patch:
@@ -51,7 +51,7 @@ public void testMethodSplit() {
     public void testOneCharacterAtATime() {
         byte[] in = DATA.getBytes();
         final ParseState context = new ParseState();
-        HttpServerExchange result = new HttpServerExchange(null, null, null);
+        HttpServerExchange result = new HttpServerExchange(null);
         ByteBuffer buffer = ByteBuffer.wrap(in);
         buffer.limit(1);
         while (context.state != ParseState.PARSE_COMPLETE) {
@@ -63,7 +63,7 @@ public void testOneCharacterAtATime() {
 
     private void testResume(final int split, byte[] in) {
         final ParseState context = new ParseState();
-        HttpServerExchange result = new HttpServerExchange(null, null, null);
+        HttpServerExchange result = new HttpServerExchange(null);
         ByteBuffer buffer = ByteBuffer.wrap(in);
         buffer.limit(split);
         HttpParser.INSTANCE.handle(buffer, context, result);

File: core/src/test/java/io/undertow/test/handlers/LotsOfHeadersResponseTestCase.java
Patch:
@@ -23,6 +23,7 @@
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.handlers.BlockingHandler;
+import io.undertow.test.utils.AjpIgnore;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.util.HttpString;
 import io.undertow.util.TestHttpClient;
@@ -37,6 +38,7 @@
 /**
  * @author Stuart Douglas
  */
+@AjpIgnore //this test generates to many headers to fit in an AJP response
 @RunWith(DefaultServer.class)
 public class LotsOfHeadersResponseTestCase {
 

File: core/src/main/java/io/undertow/conduits/ChunkedStreamSourceConduit.java
Patch:
@@ -198,7 +198,7 @@ public int read(final ByteBuffer dst) throws IOException {
                 while (anyAreSet(newVal, FLAG_READING_LENGTH)) {
                     while (buf.hasRemaining()) {
                         byte b = buf.get();
-                        if ((b >= '0' && b <= '9') || (b >= 'a' && b <= 'f') || (b >= 'A' && b < 'F')) {
+                        if ((b >= '0' && b <= '9') || (b >= 'a' && b <= 'f') || (b >= 'A' && b <= 'F')) {
                             chunkRemaining <<= 4; //shift it 4 bytes and then add the next value to the end
                             chunkRemaining += Integer.parseInt("" + (char) b, 16);
                         } else {

File: core/src/main/java/io/undertow/util/HeaderMap.java
Patch:
@@ -37,7 +37,7 @@ public final class HeaderMap implements Iterable<HeaderValues> {
     private Collection<HttpString> headerNames;
 
     public HeaderMap() {
-        table = new Object[32];
+        table = new Object[16];
     }
 
     private HeaderValues getEntry(final HttpString headerName) {

File: core/src/main/java/io/undertow/conduits/ChunkedStreamSourceConduit.java
Patch:
@@ -86,7 +86,7 @@ public Pooled<ByteBuffer> allocate() {
 
             @Override
             public void pushBack(Pooled<ByteBuffer> pooled) {
-                exchange.getConnection().setExtraBytes(pooled);
+                exchange.ungetRequestBytes(pooled);
             }
         }, finishListener, maxLength);
     }

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/RequestListenerAsyncRequestTestCase.java
Patch:
@@ -46,7 +46,7 @@
  * @author Stuart Douglas
  */
 @RunWith(DefaultServer.class)
-public class RequestListenerAsyncRequest {
+public class RequestListenerAsyncRequestTestCase {
 
     public static final String HELLO_WORLD = "Hello World";
 

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/onError/AsyncServlet1.java
Patch:
@@ -29,6 +29,7 @@ public class AsyncServlet1 extends HttpServlet {
     @Override
     protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
         AsyncContext ctx = req.startAsync();
+        ctx.addListener(new AsyncEventListener());
         ctx.addListener(new SimpleAsyncListener(ctx));
         Thread thread = new Thread(new AsyncTask(ctx));
         thread.start();

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/onError/AsyncServlet2.java
Patch:
@@ -30,6 +30,7 @@ public class AsyncServlet2 extends HttpServlet {
     protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
         AsyncContext ctx = req.startAsync();
         ctx.addListener(new SimpleAsyncListener());
+        ctx.addListener(new AsyncEventListener());
         Thread thread = new Thread(new AsyncTask(ctx));
         thread.start();
     }

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -961,7 +961,7 @@ public void onAsyncError(Throwable t) {
         for (final BoundAsyncListener listener : asyncListeners) {
             AsyncEvent event = new AsyncEvent(asyncContext, listener.servletRequest, listener.servletResponse, t);
             try {
-                listener.asyncListener.onStartAsync(event);
+                listener.asyncListener.onError(event);
             } catch (IOException e) {
                 UndertowServletLogger.REQUEST_LOGGER.ioExceptionDispatchingAsyncEvent(e);
             }

File: servlet/src/test/java/io/undertow/servlet/test/listener/request/async/RequestListenerAsyncRequest.java
Patch:
@@ -73,9 +73,8 @@ public static void setup() throws ServletException {
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
                 .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
-                .addServlets(m, a);
-
-        builder.addListener(new ListenerInfo(TestListener.class));
+                .addServlets(m, a)
+                .addListener(new ListenerInfo(TestListener.class));
 
         DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();

File: core/src/test/java/io/undertow/websockets/core/protocol/version07/WebSocket07ServerTest.java
Patch:
@@ -18,6 +18,7 @@
 package io.undertow.websockets.core.protocol.version07;
 
 import io.undertow.test.utils.DefaultServer;
+import io.undertow.util.ConcreteIoFuture;
 import io.undertow.websockets.core.StreamSinkFrameChannel;
 import io.undertow.websockets.core.StreamSourceFrameChannel;
 import io.undertow.websockets.core.WebSocketChannel;
@@ -39,7 +40,6 @@
 import java.io.IOException;
 import java.net.URI;
 import java.nio.ByteBuffer;
-import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
@@ -89,13 +89,13 @@ public void handleEvent(final WebSocketChannel channel) {
             }
         }));
 
-        final CountDownLatch latch = new CountDownLatch(1);
+        final ConcreteIoFuture latch = new ConcreteIoFuture();
         final byte[] payload =  "payload".getBytes();
 
         WebSocketTestClient client = new WebSocketTestClient(getVersion(), new URI("ws://" + DefaultServer.getHostAddress("default") + ':' + DefaultServer.getHostPort("default") + '/'));
         client.connect();
         client.send(new PingWebSocketFrame(ChannelBuffers.wrappedBuffer(payload)), new FrameChecker(PongWebSocketFrame.class, payload, latch));
-        latch.await();
+        latch.get();
         client.destroy();
     }
 }

File: servlet/src/test/java/io/undertow/servlet/test/websocket/WebSocketServletTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import java.io.IOException;
 import java.net.URI;
-import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -19,6 +18,7 @@
 import io.undertow.servlet.websockets.WebSocketServlet;
 import io.undertow.test.utils.AjpIgnore;
 import io.undertow.test.utils.DefaultServer;
+import io.undertow.util.ConcreteIoFuture;
 import io.undertow.util.StringReadChannelListener;
 import io.undertow.util.StringWriteChannelListener;
 import io.undertow.websockets.core.StreamSourceFrameChannel;
@@ -120,11 +120,11 @@ protected void error(final IOException e) {
 
 
         final AtomicReference<String> result = new AtomicReference<String>();
-        final CountDownLatch latch = new CountDownLatch(1);
+        final ConcreteIoFuture latch = new ConcreteIoFuture();
         WebSocketTestClient client = new WebSocketTestClient(org.jboss.netty.handler.codec.http.websocketx.WebSocketVersion.V13, new URI("ws://" + DefaultServer.getHostAddress("default") + ":" + DefaultServer.getHostPort("default") + "/"));
         client.connect();
         client.send(new TextWebSocketFrame(ChannelBuffers.copiedBuffer("hello", CharsetUtil.US_ASCII)), new FrameChecker(TextWebSocketFrame.class, "world".getBytes(CharsetUtil.US_ASCII), latch));
-        latch.await();
+        latch.get();
         client.destroy();
     }
 }

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/EndpointSessionHandler.java
Patch:
@@ -56,10 +56,11 @@ public void onSession(WebSocketSession s, WebSocketHttpExchange exchange) {
         WebSocketChannelSession channelSession = (WebSocketChannelSession) s;
         ConfiguredServerEndpoint config = HandshakeUtil.getConfig(channelSession.getChannel());
 
+
         try {
             final InstanceHandle<Endpoint> instance = config.getEndpointFactory().createInstance();
 
-            UndertowSession session = new UndertowSession(channelSession, URI.create(exchange.getRequestURI()), Collections.<String, String>emptyMap(), Collections.<String, List<String>>emptyMap(), this, null, instance, config.getEndpointConfiguration());
+            UndertowSession session = new UndertowSession(channelSession, URI.create(exchange.getRequestURI()), exchange.getAttachment(HandshakeUtil.PATH_PARAMS), Collections.<String, List<String>>emptyMap(), this, null, instance, config.getEndpointConfiguration());
             session.setMaxBinaryMessageBufferSize(getContainer().getDefaultMaxBinaryMessageBufferSize());
             session.setMaxTextMessageBufferSize(getContainer().getDefaultMaxTextMessageBufferSize());
             //session.setTimeout(getContainer().getMaxSessionIdleTimeout());

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/handshake/HandshakeUtil.java
Patch:
@@ -39,7 +39,7 @@ public final class HandshakeUtil {
     private static final String CONFIG_KEY = "ServerEndpointConfiguration";
 
 
-    private static final AttachmentKey<Map<String, String>> PATH_PARAMS = AttachmentKey.create(Map.class);
+    public static final AttachmentKey<Map<String, String>> PATH_PARAMS = AttachmentKey.create(Map.class);
 
     private HandshakeUtil() {
     }

File: websockets-jsr/src/test/java/io/undertow/websockets/jsr/test/annotated/AnnotatedEndpointTest.java
Patch:
@@ -18,7 +18,6 @@
 package io.undertow.websockets.jsr.test.annotated;
 
 import java.net.URI;
-import java.util.concurrent.CountDownLatch;
 
 import javax.servlet.DispatcherType;
 import javax.servlet.Filter;
@@ -35,6 +34,7 @@
 import io.undertow.servlet.util.ConstructorInstanceFactory;
 import io.undertow.servlet.util.ImmediateInstanceFactory;
 import io.undertow.test.utils.DefaultServer;
+import io.undertow.util.ConcreteIoFuture;
 import io.undertow.websockets.jsr.ConfiguredServerEndpoint;
 import io.undertow.websockets.jsr.JsrWebSocketFilter;
 import io.undertow.websockets.jsr.ServletWebSocketContainer;
@@ -56,7 +56,7 @@ public class AnnotatedEndpointTest {
     @org.junit.Test
     public void testStringOnMessage() throws Exception {
         final byte[] payload = "hello".getBytes();
-        final CountDownLatch latch = new CountDownLatch(1);
+        final ConcreteIoFuture latch = new ConcreteIoFuture();
 
 
         final InstanceFactory<Endpoint> factory = AnnotatedEndpointFactory.create(AnnotatedTestEndpoint.class, new ConstructorInstanceFactory<>(AnnotatedTestEndpoint.class.getDeclaredConstructor()));
@@ -84,7 +84,7 @@ public void testStringOnMessage() throws Exception {
         WebSocketTestClient client = new WebSocketTestClient(WebSocketVersion.V13, new URI("ws://" + DefaultServer.getHostAddress("default") + ":" + DefaultServer.getHostPort("default") + "/chat/Stuart"));
         client.connect();
         client.send(new TextWebSocketFrame(ChannelBuffers.wrappedBuffer(payload)), new FrameChecker(TextWebSocketFrame.class, "hello Stuart".getBytes(), latch));
-        latch.await();
+        latch.get();
         client.destroy();
     }
 

File: core/src/main/java/io/undertow/server/HttpTransferEncoding.java
Patch:
@@ -260,7 +260,7 @@ private static ConduitWrapper<StreamSourceConduit> fixedLengthStreamSourceCondui
             public StreamSourceConduit wrap(final ConduitFactory<StreamSourceConduit> factory, final HttpServerExchange exchange) {
                 StreamSourceConduit channel = factory.create();
                 final long max = maxEntitySize(exchange);
-                if(contentLength > max) {
+                if(max > 0 && contentLength > max) {
                     return new BrokenStreamSourceConduit(channel, UndertowMessages.MESSAGES.requestEntityWasTooLarge(exchange.getSourceAddress(), max));
                 }
                 return new FixedLengthStreamSourceConduit(channel, contentLength, fixedLengthDrainListener(exchange));

File: core/src/main/java/io/undertow/ajp/AjpParser.java
Patch:
@@ -181,6 +181,7 @@ public void parse(final ByteBuffer buf, final AjpParseState state, final HttpSer
                 StringHolder result = parseString(buf, state, false);
                 if (result.readComplete) {
                     String res = result.value;
+                    exchange.setRequestURI(res);
                     exchange.setRequestPath(res);
                     exchange.setRelativePath(res);
                 } else {
@@ -301,7 +302,7 @@ public void parse(final ByteBuffer buf, final AjpParseState state, final HttpSer
                     //query string.
                     if(state.currentAttribute.equals(ATTRIBUTES[5])) {
                         String res = result.value;
-                        exchange.setQueryString(res);
+                        exchange.setQueryString(res == null ? "" : res);
                         int stringStart = 0;
                         String attrName = null;
                         for (int i = 0; i < res.length(); ++i) {

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -149,7 +149,7 @@ public final class HttpServerExchange extends AbstractAttachable {
     /**
      * the query string
      */
-    private String queryString;
+    private String queryString = "";
 
     private List<ConduitWrapper<StreamSourceConduit>> requestWrappers = new ArrayList<ConduitWrapper<StreamSourceConduit>>(3);
     private List<ConduitWrapper<StreamSinkConduit>> responseWrappers = new ArrayList<ConduitWrapper<StreamSinkConduit>>(3);

File: servlet/src/test/java/io/undertow/servlet/test/security/ssl/ConfidentialityConstraintUrlMappingTestCase.java
Patch:
@@ -31,6 +31,7 @@
 import io.undertow.servlet.test.util.TestClassIntrospector;
 import io.undertow.servlet.test.util.TestConfidentialPortManager;
 import io.undertow.servlet.test.util.TestResourceLoader;
+import io.undertow.test.utils.AjpIgnore;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
 import io.undertow.util.TestHttpClient;
@@ -53,6 +54,7 @@
  * @author <a href="mailto:darran.lofthouse@jboss.com">Darran Lofthouse</a>
  */
 @RunWith(DefaultServer.class)
+@AjpIgnore
 public class ConfidentialityConstraintUrlMappingTestCase {
 
 

File: core/src/test/java/io/undertow/client/HttpClientTestCase.java
Patch:
@@ -23,6 +23,7 @@
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.handlers.HttpContinueHandler;
+import io.undertow.test.utils.AjpIgnore;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
 import io.undertow.util.Headers;
@@ -54,6 +55,7 @@
  * @author Emanuel Muckenhuber
  */
 @RunWith(DefaultServer.class)
+@AjpIgnore
 public class HttpClientTestCase {
 
     private static final String message = "Hello World!";

File: core/src/test/java/io/undertow/test/handlers/file/FileHandlerStressTestCase.java
Patch:
@@ -36,6 +36,7 @@
 import io.undertow.server.handlers.cache.DirectBufferCache;
 import io.undertow.server.handlers.resource.ResourceHandler;
 import io.undertow.server.handlers.resource.FileResourceManager;
+import io.undertow.test.utils.AjpIgnore;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
 import org.apache.http.HttpResponse;
@@ -48,6 +49,7 @@
 /**
  * @author Stuart Douglas
  */
+@AjpIgnore // it looks like apache actually has trouble with the number of requests
 @RunWith(DefaultServer.class)
 public class FileHandlerStressTestCase {
 

File: servlet/src/test/java/io/undertow/servlet/test/listener/ordering/ServletSessionListenerOrderingTestCase.java
Patch:
@@ -50,7 +50,7 @@
  *
  */
 @RunWith(DefaultServer.class)
-public class ServletSessionTestCase {
+public class ServletSessionListenerOrderingTestCase {
 
     @BeforeClass
     public static void setup() throws ServletException {

File: servlet/src/test/java/io/undertow/servlet/test/session/ServletSessionTestCase.java
Patch:
@@ -121,13 +121,11 @@ public void testSessionCookieConfig() throws IOException {
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             response = HttpClientUtils.readResponse(result);
             Assert.assertEquals("2", response);
-            Assert.assertTrue(result.getHeaders("Set-Cookie")[0].getValue().contains("MySessionCookie"));
 
             result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             response = HttpClientUtils.readResponse(result);
             Assert.assertEquals("3", response);
-            Assert.assertTrue(result.getHeaders("Set-Cookie")[0].getValue().contains("MySessionCookie"));
 
 
         } finally {

File: servlet/src/test/java/io/undertow/servlet/test/session/invalidate/ServletSessionInvalidateTestCase.java
Patch:
@@ -43,7 +43,7 @@
  * @author Jozef Hartinger
  */
 @RunWith(DefaultServer.class)
-public class ServletSessionTestCase {
+public class ServletSessionInvalidateTestCase {
 
     @BeforeClass
     public static void setup() throws ServletException {

File: servlet/src/test/java/io/undertow/servlet/test/upgrade/SimpleUpgradeTestCase.java
Patch:
@@ -33,6 +33,7 @@
 import io.undertow.servlet.test.SimpleServletTestCase;
 import io.undertow.servlet.test.util.TestClassIntrospector;
 import io.undertow.servlet.test.util.TestResourceLoader;
+import io.undertow.test.utils.AjpIgnore;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
@@ -43,6 +44,7 @@
 /**
  * @author Stuart Douglas
  */
+@AjpIgnore
 @RunWith(DefaultServer.class)
 public class SimpleUpgradeTestCase {
 

File: servlet/src/test/java/io/undertow/servlet/test/websocket/WebSocketServletTest.java
Patch:
@@ -17,6 +17,7 @@
 import io.undertow.servlet.test.util.TestResourceLoader;
 import io.undertow.servlet.util.ImmediateInstanceFactory;
 import io.undertow.servlet.websockets.WebSocketServlet;
+import io.undertow.test.utils.AjpIgnore;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.util.StringReadChannelListener;
 import io.undertow.util.StringWriteChannelListener;
@@ -37,6 +38,7 @@
 /**
  * @author Stuart Douglas
  */
+@AjpIgnore
 @RunWith(DefaultServer.class)
 public class WebSocketServletTest {
 

File: core/src/main/java/io/undertow/ajp/AjpRequestConduit.java
Patch:
@@ -176,7 +176,7 @@ private int doRead(final ByteBuffer dst, long state) throws IOException {
                 }
             }
         } else {
-            chunkRemaining = this.state & ~STATE_MASK;
+            chunkRemaining = this.state & STATE_MASK;
         }
 
         int limit = dst.limit();

File: core/src/main/java/io/undertow/io/UndertowInputStream.java
Patch:
@@ -7,6 +7,7 @@
 import io.undertow.UndertowMessages;
 import io.undertow.server.HttpServerExchange;
 import org.xnio.Pooled;
+import org.xnio.channels.Channels;
 import org.xnio.channels.StreamSourceChannel;
 
 /**
@@ -38,8 +39,7 @@ public int read(final byte[] b, final int off, final int len) throws IOException
         if (closed) {
             throw UndertowMessages.MESSAGES.streamIsClosed();
         }
-        channel.awaitReadable();
-        return channel.read(ByteBuffer.wrap(b, off, len));
+        return Channels.readBlocking(channel, ByteBuffer.wrap(b, off, len));
     }
 
     @Override
@@ -73,7 +73,7 @@ public long skip(final long n) throws IOException {
     public int read() throws IOException {
         byte[] b = new byte[1];
         int read = read(b);
-        if(read == -1) {
+        if (read == -1) {
             return -1;
         }
         return b[0];

File: core/src/main/java/io/undertow/server/session/InMemorySessionManager.java
Patch:
@@ -97,7 +97,6 @@ public Session getSession(final HttpServerExchange serverExchange, final Session
         if (sess == null) {
             return null;
         } else {
-            config.setSessionId(serverExchange, sess.session.getId());
             return sess.session;
         }
     }

File: core/src/test/java/io/undertow/test/handlers/HttpContinueTestCase.java
Patch:
@@ -27,6 +27,7 @@
 import io.undertow.server.handlers.HttpContinueHandler;
 import io.undertow.server.handlers.BlockingHandler;
 import io.undertow.server.HttpHandler;
+import io.undertow.test.utils.AjpIgnore;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
 import io.undertow.util.TestHttpClient;
@@ -44,6 +45,7 @@
  * @author Stuart Douglas
  */
 @RunWith(DefaultServer.class)
+@AjpIgnore
 public class HttpContinueTestCase {
 
     private static volatile boolean accept = false;

File: core/src/test/java/io/undertow/test/utils/AjpIgnore.java
Patch:
@@ -1,11 +1,13 @@
 package io.undertow.test.utils;
 
+import java.lang.annotation.Inherited;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
 /**
  * @author Stuart Douglas
  */
 @Retention(RetentionPolicy.RUNTIME)
+@Inherited
 public @interface AjpIgnore {
 }

File: core/src/test/java/io/undertow/websockets/client/version13/WebSocketClient13TestCase.java
Patch:
@@ -8,6 +8,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.undertow.client.HttpClient;
+import io.undertow.test.utils.AjpIgnore;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.FileUtils;
 import io.undertow.util.StringWriteChannelListener;
@@ -38,6 +39,7 @@
  * @author Stuart Douglas
  */
 @RunWith(DefaultServer.class)
+@AjpIgnore
 public class WebSocketClient13TestCase {
     private static XnioWorker worker;
 

File: core/src/test/java/io/undertow/websockets/core/protocol/version00/WebSocket00ServerTest.java
Patch:
@@ -17,6 +17,7 @@
  */
 package io.undertow.websockets.core.protocol.version00;
 
+import io.undertow.test.utils.AjpIgnore;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.util.StringReadChannelListener;
 import io.undertow.util.StringWriteChannelListener;
@@ -53,6 +54,7 @@
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
 @RunWith(DefaultServer.class)
+@AjpIgnore
 public class WebSocket00ServerTest {
 
     @org.junit.Test

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -155,10 +155,10 @@ public void deploy() {
                 }
             }
 
-            listeners.contextInitialized();
             initializeErrorPages(deployment, deploymentInfo);
             initializeMimeMappings(deployment, deploymentInfo);
             initializeTempDir(servletContext, deploymentInfo);
+            listeners.contextInitialized();
             //run
 
             ServletPathMatches matches = setupServletChains(servletContext, threadSetupAction, listeners);

File: core/src/main/java/io/undertow/server/HttpHandlers.java
Patch:
@@ -55,7 +55,7 @@ public static void executeRootHandler(final HttpHandler handler, final HttpServe
             if (exchange.isDispatched()) {
                 final Runnable dispatchTask = exchange.getAttachment(HttpServerExchange.DISPATCH_TASK);
                 Executor executor = exchange.getAttachment(HttpServerExchange.DISPATCH_EXECUTOR);
-                exchange.clearDispatched();
+                exchange.unDispatch();
                 if (dispatchTask != null) {
                     executor = executor == null ? exchange.getConnection().getWorker() : executor;
                     executor.execute(dispatchTask);

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -435,7 +435,7 @@ public boolean isDispatched() {
         return anyAreSet(state, FLAG_DISPATCHED);
     }
 
-    void clearDispatched() {
+    public void unDispatch() {
         state &= ~FLAG_DISPATCHED;
         removeAttachment(DISPATCH_EXECUTOR);
         removeAttachment(DISPATCH_TASK);

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletInitialHandler.java
Patch:
@@ -125,6 +125,7 @@ public void handleFirstRequest(final HttpServerExchange exchange, final ServletC
                 }
             }
         } catch (Throwable t) {
+            exchange.unDispatch();
             HttpServletRequestImpl.getRequestImpl(exchange.getAttachment(HttpServletRequestImpl.ATTACHMENT_KEY)).onAsyncError(t);
             if (!exchange.isResponseStarted()) {
                 exchange.setResponseCode(500);
@@ -148,7 +149,7 @@ public void handleFirstRequest(final HttpServerExchange exchange, final ServletC
             handle.tearDown();
         }
 
-        if (!request.isAsyncStarted()) {
+        if (!exchange.isDispatched()) {
             response.responseDone();
             //this request is done, so we close any parser that may have been used
             final FormDataParser parser = exchange.getAttachment(FormDataParser.ATTACHMENT_KEY);

File: core/src/main/java/io/undertow/ajp/AjpParser.java
Patch:
@@ -142,7 +142,7 @@ public void parse(final ByteBuffer buf, final AjpParseState state, final HttpSer
                 } else {
                     final byte prefix = buf.get();
                     if (prefix != 2) {
-                        throw new IllegalArgumentException("We do  not support prefix codes other than 2 yet." + prefix);
+                        throw new IllegalArgumentException("We do not support prefix codes other than 2 yet. Received: " + prefix);
                     }
                 }
             }

File: core/src/main/java/io/undertow/server/HttpContinue.java
Patch:
@@ -39,7 +39,7 @@ public static boolean requiresContinueResponse(final HttpServerExchange exchange
             return false;
         }
         if (exchange.getConnection().getExtraBytes() != null) {
-            //we have already recieved some of the request body
+            //we have already received some of the request body
             //so according to the RFC we do not need to send the Continue
             return false;
         }

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/AsyncFrameHandler.java
Patch:
@@ -29,7 +29,7 @@
 
 /**
  * {@link AbstractFrameHandler} subclass which will allow to use {@link MessageHandler.Async} implementations
- * to operated on received fragements.
+ * to operated on received fragments.
  *
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/JsrWebSocketMessages.java
Patch:
@@ -60,7 +60,7 @@ public interface JsrWebSocketMessages {
     IllegalStateException unsupportedFrameType(Class<?> clazz);
 
     @Message(id = 3007, value = "Unable to detect MessageHandler type for %s")
-    IllegalStateException unkownHandlerType(Class<?> clazz);
+    IllegalStateException unknownHandlerType(Class<?> clazz);
 
     @Message(id = 3008, value = "Unable to detect Encoder type for %s")
     IllegalStateException unknownEncoderType(Class<?> clazz);

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/util/ClassUtils.java
Patch:
@@ -41,7 +41,7 @@ public static Class<?> getHandlerType(Class<? extends MessageHandler> clazz) {
                return m.getParameterTypes()[0];
             }
         }
-        throw JsrWebSocketMessages.MESSAGES.unkownHandlerType(clazz);
+        throw JsrWebSocketMessages.MESSAGES.unknownHandlerType(clazz);
     }
 
     /**

File: websockets-jsr/src/main/java/io/undertow/websockets/jsr/ServerWebSocketContainer.java
Patch:
@@ -66,7 +66,7 @@ public long getDefaultMaxSessionIdleTimeout() {
 
     @Override
     public void setDefaultMaxSessionIdleTimeout(final long timeout) {
-        this.maxSessionIdleTimeout = maxSessionIdleTimeout;
+        this.maxSessionIdleTimeout = timeout;
     }
 
     @Override

File: servlet/src/main/java/io/undertow/servlet/handlers/security/ServletFormAuthenticationMechanism.java
Patch:
@@ -49,7 +49,7 @@ protected Integer servePage(final HttpServerExchange exchange, final String loca
     protected void storeInitialLocation(final HttpServerExchange exchange) {
         HttpServletRequest req = (HttpServletRequest) exchange.getAttachment(HttpServletRequestImpl.ATTACHMENT_KEY);
         HttpServletResponse resp = (HttpServletResponse) exchange.getAttachment(HttpServletResponseImpl.ATTACHMENT_KEY);
-        final Cookie cookie = new Cookie(LOCATION_COOKIE, req.getContextPath() + req.getServletPath() + req.getPathInfo());
+        final Cookie cookie = new Cookie(LOCATION_COOKIE, req.getContextPath() + req.getServletPath() + (req.getPathInfo() == null ? "" : req.getPathInfo()));
         cookie.setPath(req.getServletContext().getContextPath());
         resp.addCookie(cookie);
     }

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletInitialHandler.java
Patch:
@@ -159,9 +159,6 @@ private void handleFirstRequest(final HttpServerExchange exchange, final Dispatc
             //this request is done, so we close any parser that may have been used
             final FormDataParser parser = exchange.getAttachment(FormDataParser.ATTACHMENT_KEY);
             IoUtils.safeClose(parser);
-        } else {
-            request.asyncInitialRequestDone();
-            exchange.dispatch();
         }
     }
 

File: servlet/src/test/java/io/undertow/servlet/test/streams/ServletInputStreamTestCase.java
Patch:
@@ -97,8 +97,8 @@ public void testBlockingServletInputStream() {
     }
 
     @Test
-    @Ignore("This test hangs occasionally")
     public void testAsyncServletInputStream() {
+        //for(int h = 0; h < 20 ; ++h) {
         StringBuilder builder = new StringBuilder(1000 * HELLO_WORLD.length());
         for (int i = 0; i < 10; ++i) {
             try {
@@ -111,6 +111,7 @@ public void testAsyncServletInputStream() {
                 throw new RuntimeException("test failed with i equal to " + i, e);
             }
         }
+        //}
     }
 
     public void runTest(final String message, String url) throws IOException {

File: servlet/src/test/java/io/undertow/servlet/test/path/PathMappingServlet.java
Patch:
@@ -34,7 +34,7 @@ public class PathMappingServlet extends HttpServlet {
     @Override
     protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {
         PrintWriter writer = resp.getWriter();
-        writer.write(getServletName());
+        writer.write(getServletName() + " - " + req.getPathInfo());
         writer.close();
     }
 }

File: servlet/src/main/java/io/undertow/servlet/spec/ServletContextImpl.java
Patch:
@@ -44,6 +44,7 @@
 import javax.servlet.SessionTrackingMode;
 import javax.servlet.descriptor.JspConfigDescriptor;
 
+import io.undertow.Version;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.session.Session;
 import io.undertow.server.session.SessionManager;
@@ -228,7 +229,7 @@ public String getRealPath(final String path) {
 
     @Override
     public String getServerInfo() {
-        return "Undertow 1.0.Alpha1"; //todo: fix this
+        return Version.getVersionString();
     }
 
     @Override

File: core/src/main/java/io/undertow/server/handlers/NameVirtualHostHandler.java
Patch:
@@ -43,7 +43,7 @@ public void handleRequest(final HttpServerExchange exchange) {
         if (hostHeader != null) {
             String host;
             if (hostHeader.contains(":")) { //header can be in host:port format
-                host = hostHeader.substring(hostHeader.indexOf(":") - 1);
+                host = hostHeader.substring(0, hostHeader.indexOf(":"));
             } else {
                 host = hostHeader;
             }

File: core/src/test/java/io/undertow/test/utils/DefaultServer.java
Patch:
@@ -158,7 +158,7 @@ public static String getDefaultServerURL() {
         return "http://" + getHostAddress(DEFAULT) + ":" + getHostPort(DEFAULT);
     }
 
-    public static SocketAddress getDefaultServerAddress() {
+    public static InetSocketAddress getDefaultServerAddress() {
         return new InetSocketAddress(DefaultServer.getHostAddress("default"), DefaultServer.getHostPort("default"));
     }
 

File: servlet/src/main/java/io/undertow/servlet/spec/AsyncContextImpl.java
Patch:
@@ -237,6 +237,7 @@ public synchronized void completeInternal() {
             dispatched = true;
             HttpServletRequestImpl request = HttpServletRequestImpl.getRequestImpl(servletRequest);
             request.asyncInitialRequestDone();
+            request.asyncRequestDispatched();
         } else {
             doDispatch(new Runnable() {
                 @Override
@@ -332,6 +333,8 @@ private synchronized void doDispatch(final Runnable runnable) {
             throw UndertowServletMessages.MESSAGES.asyncRequestAlreadyDispatched();
         }
         dispatched = true;
+        HttpServletRequestImpl request = HttpServletRequestImpl.getRequestImpl(servletRequest);
+        request.asyncRequestDispatched();
         if (initialRequestDone) {
             runnable.run();
         } else {

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -884,9 +884,11 @@ public void setServletContext(final ServletContextImpl servletContext) {
      */
     public void asyncInitialRequestDone() {
         asyncContext.initialRequestDone();
-        asyncContext = null;
     }
 
+    void asyncRequestDispatched() {
+        asyncContext = null;
+    }
 
     public static HttpServletRequestImpl getRequestImpl(final ServletRequest request) {
         final HttpServletRequestImpl requestImpl;

File: core/src/test/java/io/undertow/test/utils/HttpClientUtils.java
Patch:
@@ -42,7 +42,7 @@ public static String readResponse(InputStream stream) throws IOException {
         byte[] data = new byte[100];
         int read;
         while ((read = stream.read(data)) != -1) {
-            builder.append(new String(data,0,read));
+            builder.append(new String(data,0,read,"UTF-8"));
         }
         return builder.toString();
     }

File: core/src/main/java/io/undertow/conduits/ChunkedStreamSinkConduit.java
Patch:
@@ -62,6 +62,7 @@ public class ChunkedStreamSinkConduit extends AbstractStreamSinkConduit<StreamSi
     private static final int FLAG_NEXT_SHUTDWON = 1 << 2;
     private static final int FLAG_WRITTEN_FIRST_CHUNK = 1 << 3;
 
+    int written = 0;
     /**
      * Construct a new instance.
      *
@@ -86,6 +87,7 @@ public int write(final ByteBuffer src) throws IOException {
             if(anyAreSet(state, FLAG_WRITTEN_FIRST_CHUNK)) {
                 chunkingBuffer.put(CRLF);
             }
+            written += src.remaining();
             chunkingBuffer.put(Integer.toHexString(src.remaining()).getBytes());
             chunkingBuffer.put(CRLF);
             chunkingBuffer.flip();

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -516,7 +516,7 @@ public ServletInputStream getInputStream() throws IOException {
             if (reader != null) {
                 throw UndertowServletMessages.MESSAGES.getReaderAlreadyCalled();
             }
-            servletInputStream = new ServletInputStreamImpl(exchange.getRequestChannel());
+            servletInputStream = new ServletInputStreamImpl(this);
         }
         readStarted = true;
         return servletInputStream;

File: servlet/src/main/java/io/undertow/servlet/spec/WebConnectionImpl.java
Patch:
@@ -14,11 +14,11 @@
 public class WebConnectionImpl implements WebConnection {
 
     private final UpgradeServletOutputStream outputStream;
-    private final ServletInputStreamImpl inputStream;
+    private final UpgradeServletInputStream inputStream;
 
     public WebConnectionImpl(final ConnectedStreamChannel channel) {
         this.outputStream = new UpgradeServletOutputStream(channel);
-        this.inputStream = new ServletInputStreamImpl(channel);
+        this.inputStream = new UpgradeServletInputStream(channel);
     }
 
     @Override

File: servlet/src/test/java/io/undertow/servlet/test/upgrade/SimpleUpgradeTestCase.java
Patch:
@@ -100,6 +100,8 @@ public void runTest(final String url) throws IOException {
             out.write("Echo Messages2\r\n\r\n".getBytes());
             Assert.assertEquals("Echo Messages2\r\n\r\n", readBytes(in));
 
+            out.write("exit\r\n\r\n".getBytes());
+
         } finally {
             client.getConnectionManager().shutdown();
         }

File: servlet/src/test/java/io/undertow/servlet/test/upgrade/UpgradeServlet.java
Patch:
@@ -47,7 +47,7 @@ public void init(final WebConnection wc) {
             try {
                 String message = "";
                 do {
-                    //an incredibly proxy implementation of an echo server, that uses /r/n/r/n to delineate messages
+                    //an incredibly poxy implementation of an echo server, that uses /r/n/r/n to delineate messages
                     final StringBuilder builder = new StringBuilder();
                     byte[] data = new byte[100];
                     int read;

File: core/src/test/java/io/undertow/test/handlers/encoding/DeflateContentEncodingTestCase.java
Patch:
@@ -91,6 +91,7 @@ public void testDeflateEncodingBigResponse() throws IOException {
     @Test
     public void testDeflateEncodingRandomSizeResponse() throws IOException {
         int seed = new Random().nextInt();
+        System.out.println("Using seed " + seed);
         try {
             final Random random = new Random(seed);
             int size = random.nextInt(691963);

File: servlet/src/main/java/io/undertow/servlet/spec/ServletOutputStreamImpl.java
Patch:
@@ -368,6 +368,7 @@ public void close() throws IOException {
                 }
                 StreamSinkChannel channel = this.channel;
                 channel.shutdownWrites();
+                state |= FLAG_DELEGATE_SHUTDOWN;
                 Channels.flushBlocking(channel);
             } finally {
                 if (pooledBuffer != null) {
@@ -413,6 +414,7 @@ public void closeAsync() throws IOException {
             }
         }
         channel.shutdownWrites();
+        state |= FLAG_DELEGATE_SHUTDOWN;
         if (!channel.flush()) {
             resumeWrites();
         }
@@ -549,7 +551,7 @@ private void handleError(final StreamSinkChannel channel, final IOException e) {
             try {
                 listener.onError(e);
             } finally {
-                IoUtils.safeClose(channel);
+                IoUtils.safeClose(underlyingConnectionChannel);
             }
         }
     }

File: servlet/src/test/java/io/undertow/servlet/test/streams/ServletOutputStreamTestCase.java
Patch:
@@ -81,7 +81,6 @@ public static void setup() throws ServletException {
 
     @Test
     public void testBlockingServletOutputStream() {
-
         StringBuilder builder = new StringBuilder(1000 * HELLO_WORLD.length());
         for (int i = 0; i < 10; ++i) {
             try {
@@ -101,7 +100,6 @@ public void testBlockingServletOutputStream() {
 
     @Test
     public void testAsyncServletOutputStream() {
-
         StringBuilder builder = new StringBuilder(1000 * HELLO_WORLD.length());
         for (int i = 0; i < 10; ++i) {
             try {

File: core/src/test/java/io/undertow/client/HttpClientTestCase.java
Patch:
@@ -67,7 +67,7 @@ public class HttpClientTestCase {
 
     private static final OptionMap DEFAULT_OPTIONS;
     private static final HttpHandler SIMPLE_MESSAGE_HANDLER;
-    private static final SocketAddress ADDRESS = new InetSocketAddress(DefaultServer.getHostPort("default"));
+    private static final SocketAddress ADDRESS = DefaultServer.getDefaultServerAddress();
     static {
         final OptionMap.Builder builder = OptionMap.builder()
                 .set(Options.WORKER_IO_THREADS, 8)

File: core/src/test/java/io/undertow/test/ReadTimeoutTestCase.java
Patch:
@@ -81,7 +81,7 @@ public void handleException(final StreamSourceChannel channel, final IOException
 
         final TestHttpClient client = new TestHttpClient();
         try {
-            HttpPost post = new HttpPost(DefaultServer.getDefaultServerAddress());
+            HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL());
             post.setEntity(new AbstractHttpEntity() {
 
                 @Override

File: core/src/test/java/io/undertow/test/WriteTimeoutTestCase.java
Patch:
@@ -86,7 +86,7 @@ public void handleEvent(final Channel channel) {
 
         final TestHttpClient client = new TestHttpClient();
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress());
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL());
             try {
                 HttpResponse result = client.execute(get);
                 InputStream content = result.getEntity().getContent();

File: core/src/test/java/io/undertow/test/handlers/ChunkedRequestTransferCodingTestCase.java
Patch:
@@ -93,7 +93,7 @@ public void handleBlockingRequest(final HttpServerExchange exchange) {
     @Test
     public void testChunkedRequest() throws IOException {
         connection = null;
-        HttpPost post = new HttpPost(DefaultServer.getDefaultServerAddress() + "/path");
+        HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + "/path");
         TestHttpClient client = new TestHttpClient();
         try {
             generateMessage(1);
@@ -148,7 +148,7 @@ public void writeTo(OutputStream outstream) throws IOException {
     public void testMaxRequestSizeChunkedRequest() throws IOException {
         connection = null;
         OptionMap existing = DefaultServer.getUndertowOptions();
-        HttpPost post = new HttpPost(DefaultServer.getDefaultServerAddress() + "/path");
+        HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + "/path");
         post.setHeader(HttpHeaders.CONNECTION, "close");
         TestHttpClient client = new TestHttpClient();
         try {

File: core/src/test/java/io/undertow/test/handlers/ChunkedResponseTransferCodingTestCase.java
Patch:
@@ -76,7 +76,7 @@ public void handleBlockingRequest(final HttpServerExchange exchange) {
 
     @Test
     public void sendHttpRequest() throws IOException {
-        HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path");
+        HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path");
         TestHttpClient client = new TestHttpClient();
         try {
             generateMessage(1);

File: core/src/test/java/io/undertow/test/handlers/FixedLengthRequestTestCase.java
Patch:
@@ -94,7 +94,7 @@ public void handleBlockingRequest(final HttpServerExchange exchange) {
     @Test
     public void testFixedLengthRequest() throws IOException {
         connection = null;
-        HttpPost post = new HttpPost(DefaultServer.getDefaultServerAddress() + "/path");
+        HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + "/path");
         TestHttpClient client = new TestHttpClient();
         try {
             generateMessage(1);
@@ -120,7 +120,7 @@ public void testFixedLengthRequest() throws IOException {
     public void testMaxRequestSizeFixedLengthRequest() throws IOException {
         connection = null;
         OptionMap existing = DefaultServer.getUndertowOptions();
-        HttpPost post = new HttpPost(DefaultServer.getDefaultServerAddress() + "/path");
+        HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + "/path");
         post.setHeader(HttpHeaders.CONNECTION, "close");
         TestHttpClient client = new TestHttpClient();
         try {

File: core/src/test/java/io/undertow/test/handlers/HttpContinueTestCase.java
Patch:
@@ -91,7 +91,7 @@ public void testHttpContinueRejected() throws IOException {
         TestHttpClient client = new TestHttpClient();
         client.setParams(httpParams);
         try {
-            HttpPost post = new HttpPost(DefaultServer.getDefaultServerAddress() + "/path");
+            HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + "/path");
             post.addHeader("Expect", "100-continue");
             post.setEntity(new StringEntity(message));
 
@@ -112,7 +112,7 @@ public void testHttpContinueAccepted() throws IOException {
         TestHttpClient client = new TestHttpClient();
         client.setParams(httpParams);
         try {
-            HttpPost post = new HttpPost(DefaultServer.getDefaultServerAddress() + "/path");
+            HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + "/path");
             post.addHeader("Expect", "100-continue");
             post.setEntity(new StringEntity(message));
 

File: core/src/test/java/io/undertow/test/handlers/SimpleNonBlockingServerTestCase.java
Patch:
@@ -49,7 +49,7 @@ public static void setup() {
     public void sendHttpRequest() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             Header[] header = result.getHeaders("MyHeader");
@@ -63,7 +63,7 @@ public void sendHttpRequest() throws IOException {
     public void sendHttp11RequestWithClose() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path");
             get.addHeader("Connection", "close");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
@@ -78,7 +78,7 @@ public void sendHttp11RequestWithClose() throws IOException {
     public void sendHttpOneZeroRequest() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path");
             get.getParams().setParameter(CoreProtocolPNames.PROTOCOL_VERSION, HttpVersion.HTTP_1_0);
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());

File: core/src/test/java/io/undertow/test/handlers/blocking/SimpleBlockingServerTestCase.java
Patch:
@@ -89,7 +89,7 @@ public void sendHttpRequest() throws IOException {
         message = "My HTTP Request!";
         TestHttpClient client = new TestHttpClient();
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             Assert.assertEquals(message, HttpClientUtils.readResponse(result));
@@ -108,7 +108,7 @@ public void testLargeResponse() throws IOException {
         message = messageBuilder.toString();
         TestHttpClient client = new TestHttpClient();
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             Assert.assertEquals(message, HttpClientUtils.readResponse(result));
@@ -126,7 +126,7 @@ public void testLargeRequest() throws IOException {
         }
         TestHttpClient client = new TestHttpClient();
         try {
-            HttpPost post = new HttpPost(DefaultServer.getDefaultServerAddress() + "/path");
+            HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + "/path");
             post.setEntity(new StringEntity(messageBuilder.toString()));
             HttpResponse result = client.execute(post);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());

File: core/src/test/java/io/undertow/test/handlers/caching/CacheHandlerContentEncodingTestCase.java
Patch:
@@ -72,7 +72,7 @@ public boolean resolve(final HttpServerExchange value) {
     public void testCachingWithContentEncoding() throws IOException {
         ContentEncodingHttpClient client = new ContentEncodingHttpClient();
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path");
             //it takes 5 hits to make an entry actually get cached
             for (int i = 1; i <= 5; ++i) {
                 HttpResponse result = client.execute(get);
@@ -100,15 +100,15 @@ public void testCachingWithContentEncoding() throws IOException {
             header = result.getHeaders(Headers.CONTENT_ENCODING_STRING);
             Assert.assertEquals(0, header.length);
 
-            get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path2");
+            get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path2");
 
             result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             Assert.assertEquals("Response 6", HttpClientUtils.readResponse(result));
             header = result.getHeaders(Headers.CONTENT_ENCODING_STRING);
             Assert.assertEquals(0, header.length);
 
-            get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path");
+            get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path");
             get.setHeader("ActuallyDeflate", "true");
             //it takes 5 hits to make an entry actually get cached
             for (int i = 1; i <= 5; ++i) {

File: core/src/test/java/io/undertow/test/handlers/caching/CacheHandlerTestCase.java
Patch:
@@ -55,7 +55,7 @@ public void handleRequest(final HttpServerExchange exchange) {
     public void testBasicPathBasedCaching() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path");
             //it takes 5 hits to make an entry actually get cached
             for (int i = 1; i <= 5; ++i) {
                 HttpResponse result = client.execute(get);
@@ -75,7 +75,7 @@ public void testBasicPathBasedCaching() throws IOException {
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             Assert.assertEquals("Response 5", HttpClientUtils.readResponse(result));
 
-            get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path2");
+            get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path2");
 
             result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());

File: core/src/test/java/io/undertow/test/handlers/encoding/DeflateContentEncodingTestCase.java
Patch:
@@ -66,7 +66,7 @@ public void testSmallMessagePredicateDoesNotCompress() throws IOException {
         ContentEncodingHttpClient client = new ContentEncodingHttpClient();
         try {
             message = "Hi";
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path");
             get.setHeader(Headers.ACCEPT_ENCODING_STRING, "deflate");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
@@ -108,7 +108,7 @@ public void runTest(final String theMessage) throws IOException {
         ContentEncodingHttpClient client = new ContentEncodingHttpClient();
         try {
             message = theMessage;
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path");
             get.setHeader(Headers.ACCEPT_ENCODING_STRING, "deflate");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());

File: core/src/test/java/io/undertow/test/handlers/error/FileErrorPageHandlerTestCase.java
Patch:
@@ -45,7 +45,7 @@ public void testFileBasedErrorPageIsGenerated() throws IOException {
             final FileErrorPageHandler handler = new FileErrorPageHandler(new File(getClass().getResource("errorpage.html").getFile()), 404);
             DefaultServer.setRootHandler(handler);
 
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(404, result.getStatusLine().getStatusCode());
             final String response = HttpClientUtils.readResponse(result);

File: core/src/test/java/io/undertow/test/handlers/error/SimpleErrorPageHandlerTestCase.java
Patch:
@@ -45,7 +45,7 @@ public void testSimpleErrorPageIsGenerated() throws IOException {
             final SimpleErrorPageHandler handler = new SimpleErrorPageHandler();
             DefaultServer.setRootHandler(handler);
 
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(404, result.getStatusLine().getStatusCode());
             final String response = HttpClientUtils.readResponse(result);

File: core/src/test/java/io/undertow/test/handlers/file/FileHandlerStressTestCase.java
Patch:
@@ -72,7 +72,7 @@ public void run() {
                         TestHttpClient client = new TestHttpClient();
                         try {
                             for (int i = 0; i < NUM_REQUESTS; ++i) {
-                                HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path/page.html");
+                                HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path/page.html");
                                 HttpResponse result = client.execute(get);
                                 Assert.assertEquals(200, result.getStatusLine().getStatusCode());
                                 final String response = HttpClientUtils.readResponse(result);

File: core/src/test/java/io/undertow/test/handlers/file/FileHandlerTestCase.java
Patch:
@@ -53,7 +53,7 @@ public void testFileIsServed() throws IOException {
             root.setNext(path);
             DefaultServer.setRootHandler(root);
 
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path/page.html");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/path/page.html");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             final String response = HttpClientUtils.readResponse(result);

File: core/src/test/java/io/undertow/test/handlers/form/FormDataParserTestCase.java
Patch:
@@ -135,7 +135,7 @@ private void runTest(final NameValuePair... pairs) throws Exception {
 
             final List<NameValuePair> data = new ArrayList<NameValuePair>();
             data.addAll(Arrays.asList(pairs));
-            HttpPost post = new HttpPost(DefaultServer.getDefaultServerAddress() + "/path");
+            HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + "/path");
             post.setHeader(Headers.CONTENT_TYPE_STRING, FormEncodedDataHandler.APPLICATION_X_WWW_FORM_URLENCODED);
             post.setEntity(new UrlEncodedFormEntity(data));
             HttpResponse result = client.execute(post);

File: core/src/test/java/io/undertow/test/handlers/form/MultipartFormDataParserTestCase.java
Patch:
@@ -86,7 +86,7 @@ public void testFileUpload() throws Exception {
         TestHttpClient client = new TestHttpClient();
         try {
 
-            HttpPost post = new HttpPost(DefaultServer.getDefaultServerAddress() + "/path");
+            HttpPost post = new HttpPost(DefaultServer.getDefaultServerURL() + "/path");
             //post.setHeader(Headers.CONTENT_TYPE, MultiPartHandler.MULTIPART_FORM_DATA);
             MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);
 

File: core/src/test/java/io/undertow/test/handlers/path/PathTestCase.java
Patch:
@@ -65,13 +65,13 @@ public void testBasicPathHanding() throws IOException {
 
             DefaultServer.setRootHandler(handler);
 
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/notamatchingpath");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/notamatchingpath");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(404, result.getStatusLine().getStatusCode());
             HttpClientUtils.readResponse(result);
 
 
-            get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/");
+            get = new HttpGet(DefaultServer.getDefaultServerURL() + "/");
             result = client.execute(get);
             Assert.assertEquals(404, result.getStatusLine().getStatusCode());
             HttpClientUtils.readResponse(result);
@@ -97,7 +97,7 @@ private void runPathTest(TestHttpClient client, String path, String expectedMatc
         runPathTest(client, path, expectedMatch, expectedRemaining, Collections.<String, String>emptyMap());
     }
     private void runPathTest(TestHttpClient client, String path, String expectedMatch, String expectedRemaining, Map<String, String> queryParams) throws IOException {
-        HttpResponse result;HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + path);
+        HttpResponse result;HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + path);
         result = client.execute(get);
         Assert.assertEquals(200, result.getStatusLine().getStatusCode());
         Header[] header = result.getHeaders(MATCHED);

File: core/src/test/java/io/undertow/test/security/AuthenticationTestBase.java
Patch:
@@ -187,7 +187,7 @@ public void testNoMechanisms() throws Exception {
         DefaultServer.setRootHandler(new ResponseHandler());
 
         TestHttpClient client = new TestHttpClient();
-        HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress());
+        HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL());
         HttpResponse result = client.execute(get);
         assertEquals(200, result.getStatusLine().getStatusCode());
 

File: core/src/test/java/io/undertow/test/security/SimpleConfidentialRedirectTestCase.java
Patch:
@@ -62,7 +62,7 @@ public void handleRequest(final HttpServerExchange exchange) {
         TestHttpClient client = new TestHttpClient();
         client.setSSLContext(DefaultServer.getClientSSLContext());
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress());
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL());
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             Header[] header = result.getHeaders("scheme");

File: core/src/test/java/io/undertow/test/session/inmemory/InMemorySessionTestCase.java
Patch:
@@ -78,21 +78,21 @@ public void handleRequest(final HttpServerExchange exchange) {
             cookieHandler.setNext(handler);
             DefaultServer.setRootHandler(cookieHandler);
 
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/notamatchingpath");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/notamatchingpath");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             HttpClientUtils.readResponse(result);
             Header[] header = result.getHeaders(COUNT);
             Assert.assertEquals("0", header[0].getValue());
 
-            get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/notamatchingpath");
+            get = new HttpGet(DefaultServer.getDefaultServerURL() + "/notamatchingpath");
             result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             HttpClientUtils.readResponse(result);
             header = result.getHeaders(COUNT);
             Assert.assertEquals("1", header[0].getValue());
 
-            get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/notamatchingpath");
+            get = new HttpGet(DefaultServer.getDefaultServerURL() + "/notamatchingpath");
             result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             HttpClientUtils.readResponse(result);

File: jsp/src/test/java/io/undertow/test/jsp/basic/SimpleJspTestCase.java
Patch:
@@ -89,7 +89,7 @@ public static void after(){
     public void testSimpleHttpServlet() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/a.jsp");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/servletContext/a.jsp");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             final String response = HttpClientUtils.readResponse(result);

File: servlet/src/test/java/io/undertow/servlet/test/SimpleServletTestCase.java
Patch:
@@ -78,7 +78,7 @@ public static void setup() throws ServletException {
     public void testSimpleHttpServlet() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/aa");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/servletContext/aa");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             final String response = HttpClientUtils.readResponse(result);

File: servlet/src/test/java/io/undertow/servlet/test/async/SimpleAsyncTestCase.java
Patch:
@@ -85,7 +85,7 @@ public static void setup() throws ServletException {
     public void testSimpleHttpServlet() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/async");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/servletContext/async");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             final String response = HttpClientUtils.readResponse(result);

File: servlet/src/test/java/io/undertow/servlet/test/charset/CharacterEncodingTestCase.java
Patch:
@@ -68,13 +68,13 @@ public static byte[] toByteArray(int[] source) {
     public void testCharacterEncoding() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext?charset=UTF-16BE");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/servletContext?charset=UTF-16BE");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             byte[] response = HttpClientUtils.readRawResponse(result);
             Assert.assertArrayEquals(UTF16, response);
 
-            get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext?charset=UTF-8");
+            get = new HttpGet(DefaultServer.getDefaultServerURL() + "/servletContext?charset=UTF-8");
             result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             response = HttpClientUtils.readRawResponse(result);

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/AbstractWelcomeFileTestCase.java
Patch:
@@ -20,7 +20,7 @@ public class AbstractWelcomeFileTestCase {
     public void testWelcomeFileRedirect() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/servletContext/");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             String response = HttpClientUtils.readResponse(result);
@@ -35,7 +35,7 @@ public void testWelcomeFileRedirect() throws IOException {
     public void testWelcomeServletRedirect() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/path?a=b");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/servletContext/path?a=b");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             String response = HttpClientUtils.readResponse(result);

File: servlet/src/test/java/io/undertow/servlet/test/dispatcher/DispatcherIncludeTestCase.java
Patch:
@@ -95,7 +95,7 @@ public static void setup() throws ServletException {
     public void testPathBasedInclude() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/dispatch");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/servletContext/dispatch");
             get.setHeader("include", "/include");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
@@ -110,7 +110,7 @@ public void testPathBasedInclude() throws IOException {
     public void testNameBasedInclude() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/dispatch");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/servletContext/dispatch");
             get.setHeader("include", "include");
             get.setHeader("name", "true");
             HttpResponse result = client.execute(get);

File: servlet/src/test/java/io/undertow/servlet/test/path/FilterPathMappingTestCase.java
Patch:
@@ -158,7 +158,7 @@ private void runTest(final TestHttpClient client, final String path, final Strin
         final HttpGet get;
         final HttpResponse result;
         final String response;
-        get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/" + path);
+        get = new HttpGet(DefaultServer.getDefaultServerURL() + "/servletContext/" + path);
         result = client.execute(get);
         Assert.assertEquals(200, result.getStatusLine().getStatusCode());
         requireHeaders(result, headers);

File: servlet/src/test/java/io/undertow/servlet/test/security/login/ServletLoginTestCase.java
Patch:
@@ -81,7 +81,7 @@ public static void setup() throws ServletException {
     @Test
     public void testHttpMethod() throws IOException {
         TestHttpClient client = new TestHttpClient();
-        final String url = DefaultServer.getDefaultServerAddress() + "/servletContext/login";
+        final String url = DefaultServer.getDefaultServerURL() + "/servletContext/login";
         try {
             HttpGet get = new HttpGet(url);
             get.addHeader("username", "bob");

File: servlet/src/test/java/io/undertow/servlet/test/security/ssl/ConfidentialityConstraintUrlMappingTestCase.java
Patch:
@@ -120,7 +120,7 @@ private void internalTest(final String path, final String expectedScheme) throws
         TestHttpClient client = new TestHttpClient();
         client.setSSLContext(DefaultServer.getClientSSLContext());
 
-        final String url = DefaultServer.getDefaultServerAddress() + "/servletContext" + path;
+        final String url = DefaultServer.getDefaultServerURL() + "/servletContext" + path;
         try {
             HttpGet get = new HttpGet(url);
             HttpResponse result = client.execute(get);

File: servlet/src/test/java/io/undertow/servlet/test/session/ServletSessionTestCase.java
Patch:
@@ -82,7 +82,7 @@ public static void setup() throws ServletException {
     public void testSimpleSessionUsage() throws IOException {
         TestHttpClient client = new TestHttpClient();
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/aa");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/servletContext/aa");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             String response = HttpClientUtils.readResponse(result);
@@ -110,7 +110,7 @@ public void testSessionCookieConfig() throws IOException {
         servletContext.getSessionCookieConfig().setName("MySessionCookie");
         TestHttpClient client = new TestHttpClient();
         try {
-            HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/aa");
+            HttpGet get = new HttpGet(DefaultServer.getDefaultServerURL() + "/servletContext/aa");
             HttpResponse result = client.execute(get);
             Assert.assertEquals(200, result.getStatusLine().getStatusCode());
             String response = HttpClientUtils.readResponse(result);

File: servlet/src/test/java/io/undertow/servlet/test/streams/ServletOutputStreamTestCase.java
Patch:
@@ -123,7 +123,7 @@ public void runTest(final String message, String url, final boolean flush, final
         TestHttpClient client = new TestHttpClient();
         try {
             ServletOutputStreamTestCase.message = message;
-            String uri = DefaultServer.getDefaultServerAddress() + "/servletContext/" + url + "?reps=" + reps + "&";
+            String uri = DefaultServer.getDefaultServerURL() + "/servletContext/" + url + "?reps=" + reps + "&";
             if (flush) {
                 uri = uri + "flush=true&";
             }

File: servlet/src/main/java/io/undertow/servlet/spec/UpgradeServletOutputStream.java
Patch:
@@ -25,7 +25,7 @@ public class UpgradeServletOutputStream extends ServletOutputStream {
 
     private final StreamSinkChannel channel;
 
-    private volatile WriteListener listener;
+    private WriteListener listener;
 
     /**
      * If this stream is ready for a write
@@ -34,12 +34,12 @@ public class UpgradeServletOutputStream extends ServletOutputStream {
     private static final int FLAG_CLOSED = 1 << 1;
     private static final int FLAG_DELEGATE_SHUTDOWN = 1 << 2;
 
-    private volatile int state;
+    private int state;
 
     /**
      * The buffer that is in the process of being written out
      */
-    private volatile ByteBuffer buffer;
+    private ByteBuffer buffer;
 
     protected UpgradeServletOutputStream(final StreamSinkChannel channel) {
         this.channel = channel;

File: core/src/main/java/io/undertow/security/impl/SimpleNonceManager.java
Patch:
@@ -248,7 +248,7 @@ public boolean validateNonce(String nonce, int nonceCount, HttpServerExchange ex
             // The nonce will also have it's nonce count checked.
             return validateNonceWithCount(new Nonce(nonce), nonceCount, executor);
 
-        } else if (forwardMapping.containsKey(nonce)) {
+        } else if (forwardMapping.containsKey(new NonceHolder(nonce))) {
             // We could have let this drop through as the next validation would fail anyway but
             // why waste the time if we already know a replacement nonce has been issued.
             return false;

File: core/src/main/java/io/undertow/util/HeaderMap.java
Patch:
@@ -66,7 +66,7 @@ public List<String> get(HttpString headerName) {
         } else if(value instanceof List) {
             return (List<String>)value;
         } else {
-            return Collections.<String>singletonList((String)value);
+            return Collections.singletonList((String) value);
         }
     }
 

File: core/src/main/java/io/undertow/Undertow.java
Patch:
@@ -27,6 +27,7 @@
 import io.undertow.server.handlers.NameVirtualHostHandler;
 import io.undertow.server.handlers.PathHandler;
 import io.undertow.server.handlers.ResponseCodeHandler;
+import io.undertow.server.handlers.URLDecodingHandler;
 import io.undertow.server.handlers.cache.CacheHandler;
 import io.undertow.server.handlers.cache.CachedHttpRequest;
 import io.undertow.server.handlers.cache.DirectBufferCache;
@@ -192,6 +193,7 @@ private HttpHandler buildHandlerChain() {
         root = new CookieHandler(root);
         root = new FormEncodedDataHandler(root);
         root = new SimpleErrorPageHandler(root);
+        root = new URLDecodingHandler(root);
         //TODO: multipart
 
         if(cacheSize > 0) {

File: servlet/src/test/java/io/undertow/servlet/test/charset/EchoServlet.java
Patch:
@@ -15,9 +15,9 @@ public class EchoServlet extends HttpServlet {
 
     @Override
     protected void service(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {
-        PrintWriter writer = resp.getWriter();
         String charset = req.getParameter("charset");
         resp.setCharacterEncoding(charset);
+        PrintWriter writer = resp.getWriter();
         String message = req.getParameter("message");
         System.out.println("Received message: " + message);
         writer.write(message);

File: core/src/main/java/io/undertow/predicate/MaxContentSizePredicate.java
Patch:
@@ -17,7 +17,6 @@ public MaxContentSizePredicate(final long maxSize) {
         this.maxSize = maxSize;
     }
 
-
     @Override
     public boolean resolve(final HttpServerExchange value) {
         final String length = value.getResponseHeaders().getFirst(Headers.CONTENT_LENGTH);

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -720,7 +720,7 @@ public void endExchange() {
             //seems like an error condition, so it seems like a more sensible response is just to
             //forcibly close the read side
             setPersistent(false);
-            IoUtils.safeClose(underlyingRequestChannel);
+            IoUtils.safeShutdownReads(underlyingRequestChannel);
         }
         if (anyAreClear(state, FLAG_RESPONSE_TERMINATED)) {
             closeAndFlushResponse();

File: core/src/main/java/io/undertow/server/PipeLiningBuffer.java
Patch:
@@ -26,7 +26,7 @@ public interface PipeLiningBuffer {
      * @throws IOException
      * @return <code>true</code> If the flush suceeded, false otherwise
      */
-    boolean flushPipelinedData(final boolean closeAfterFlush) throws IOException;
+    boolean flushPipelinedData(boolean closeAfterFlush) throws IOException;
 
     /**
      * Gets the channel wrapper that implements the buffering

File: core/src/main/java/io/undertow/server/handlers/file/DirectFileCache.java
Patch:
@@ -119,11 +119,10 @@ public void handleEvent(final Channel channel) {
                 exchange.endExchange();
             } catch (IOException ignored) {
                 log.tracef("Failed to serve %s: %s", fileChannel, ignored);
-                IoUtils.safeClose(fileChannel);
                 exchange.endExchange();
+                IoUtils.safeClose(response);
             } finally {
                 IoUtils.safeClose(fileChannel);
-                IoUtils.safeClose(response);
             }
         }
     }

File: core/src/main/java/io/undertow/server/handlers/form/MultiPartHandler.java
Patch:
@@ -39,7 +39,6 @@
 import io.undertow.util.WorkerDispatcher;
 import org.xnio.FileAccess;
 import org.xnio.IoFuture;
-import org.xnio.IoUtils;
 import org.xnio.Pooled;
 import org.xnio.channels.StreamSourceChannel;
 
@@ -179,7 +178,6 @@ public void run() {
                     int c = requestChannel.read(buf);
                     buf.flip();
                     if (c == -1) {
-                        IoUtils.safeClose(requestChannel);
                         UndertowLogger.REQUEST_LOGGER.connectionTerminatedReadingMultiPartData();
                         exchange.endExchange();
                         return;

File: core/src/main/java/io/undertow/conduits/ChunkedStreamSinkConduit.java
Patch:
@@ -170,7 +170,9 @@ public boolean flush() throws IOException {
                         state |= FLAG_next_SHUTDWON;
                         return next.flush();
                     } finally {
-                        finishListener.handleEvent(this);
+                        if(finishListener != null) {
+                            finishListener.handleEvent(this);
+                        }
                     }
                 } else {
                     return false;

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -126,7 +126,6 @@ public final class HttpServerExchange extends AbstractAttachable {
     private static final int FLAG_RESPONSE_SENT = 1 << 10;
     private static final int FLAG_RESPONSE_TERMINATED = 1 << 11;
     private static final int FLAG_REQUEST_TERMINATED = 1 << 12;
-    private static final int FLAG_CLEANUP = 1 << 13;
     private static final int FLAG_PERSISTENT = 1 << 14;
 
     public HttpServerExchange(final HttpServerConnection connection, final StreamSourceChannel requestChannel, final StreamSinkChannel responseChannel) {
@@ -518,7 +517,7 @@ public boolean isRequestChannelAvailable() {
      * finished.
      */
     public boolean isComplete() {
-        return (state & FLAG_CLEANUP) != 0;
+        return allAreSet(state, FLAG_REQUEST_TERMINATED | FLAG_RESPONSE_TERMINATED);
     }
 
     /**

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -680,7 +680,7 @@ public void endExchange() {
 
         final int state = this.state;
         try {
-            if (anyAreClear(state, FLAG_REQUEST_TERMINATED)) {
+            if (anyAreClear(state, FLAG_REQUEST_TERMINATED) && isPersistent()) {
                 if (isRequestChannelAvailable()) {
                     getRequestChannel();
                 }

File: core/src/main/java/io/undertow/channels/FixedLengthStreamSourceChannel.java
Patch:
@@ -214,7 +214,7 @@ public int read(final ByteBuffer dst) throws IOException {
             final int lim = dst.limit();
             final int pos = dst.position();
             if (lim - pos > remaining) {
-                dst.limit((int) (remaining - (long) pos));
+                dst.limit((int) (remaining + (long) pos));
                 try {
                     return res = delegate.read(dst);
                 } finally {

File: core/src/main/java/io/undertow/ajp/AjpReadListener.java
Patch:
@@ -6,7 +6,7 @@
 import io.undertow.UndertowLogger;
 import io.undertow.UndertowOptions;
 import io.undertow.server.ChannelWrapper;
-import io.undertow.server.ExchangeCompleteListener;
+import io.undertow.server.ExchangeCompletionListener;
 import io.undertow.server.HttpServerConnection;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.util.HeaderMap;
@@ -143,7 +143,7 @@ public void handleEvent(final PushBackStreamChannel channel) {
     /**
      * Action that starts the next request
      */
-    private static class StartNextRequestAction implements ExchangeCompleteListener {
+    private static class StartNextRequestAction implements ExchangeCompletionListener {
 
         private PushBackStreamChannel requestChannel;
         private StreamSinkChannel responseChannel;
@@ -155,7 +155,7 @@ public StartNextRequestAction(final PushBackStreamChannel requestChannel, final
         }
 
         @Override
-        public void exchangeComplete(final HttpServerExchange exchange, final boolean isUpgrade) {
+        public void exchangeEvent(final HttpServerExchange exchange) {
 
             final PushBackStreamChannel channel = this.requestChannel;
             final AjpReadListener listener = new AjpReadListener(responseChannel, channel, exchange.getConnection());

File: core/src/main/java/io/undertow/server/ExchangeCompletionListener.java
Patch:
@@ -8,7 +8,7 @@
  *
  * @author Stuart Douglas
  */
-public interface ExchangeCompleteListener {
+public interface ExchangeCompletionListener {
 
-    void exchangeComplete(final HttpServerExchange exchange, boolean isUpgrade);
+    void exchangeEvent(final HttpServerExchange exchange);
 }

File: core/src/main/java/io/undertow/server/HttpReadListener.java
Patch:
@@ -185,7 +185,7 @@ public void handleEvent(Channel c) {
     /**
      * Action that starts the next request
      */
-    private static class StartNextRequestAction implements ExchangeCompleteListener {
+    private static class StartNextRequestAction implements ExchangeCompletionListener {
 
         private PushBackStreamChannel requestChannel;
         private StreamSinkChannel responseChannel;
@@ -197,7 +197,7 @@ public StartNextRequestAction(final PushBackStreamChannel requestChannel, final
         }
 
         @Override
-        public void exchangeComplete(final HttpServerExchange exchange, final boolean isUpgrade) {
+        public void exchangeEvent(final HttpServerExchange exchange) {
             if (exchange.isPersistent() && !exchange.isUpgrade()) {
                 final PushBackStreamChannel channel = this.requestChannel;
                 final HttpReadListener listener = new HttpReadListener(responseChannel, channel, exchange.getConnection());

File: core/src/main/java/io/undertow/server/session/SessionAttachmentHandler.java
Patch:
@@ -22,7 +22,7 @@
 
 import io.undertow.UndertowLogger;
 import io.undertow.UndertowMessages;
-import io.undertow.server.ExchangeCompleteListener;
+import io.undertow.server.ExchangeCompletionListener;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.handlers.HttpHandlers;
@@ -123,7 +123,7 @@ public SessionAttachmentHandler setSessionManager(final SessionManager sessionMa
         return this;
     }
 
-    private static class UpdateLastAccessTimeListener implements ExchangeCompleteListener {
+    private static class UpdateLastAccessTimeListener implements ExchangeCompletionListener {
 
         private final SessionConfig sessionConfig;
 
@@ -132,7 +132,7 @@ private UpdateLastAccessTimeListener(final SessionConfig sessionConfig) {
         }
 
         @Override
-        public void exchangeComplete(final HttpServerExchange exchange, final boolean isUpgrade) {
+        public void exchangeEvent(final HttpServerExchange exchange) {
             final Session session = sessionConfig.getAttachedSession(exchange);
             if (session != null) {
                 session.updateLastAccessedTime();

File: core/src/main/java/io/undertow/security/api/RoleMappingManager.java
Patch:
@@ -14,9 +14,9 @@ public interface RoleMappingManager {
      * Checks if the current authenticated principal authenticated within the security context is mapped to
      * the given role.
      *
-     * @param role
-     * @param securityContext
-     * @return
+     * @param role The role to check
+     * @param securityContext The current security context
+     * @return <code>true</code> if the user is in the supplied role
      */
     boolean isUserInRole(final String role, final SecurityContext securityContext);
 

File: core/src/main/java/io/undertow/ajp/AjpResponseChannel.java
Patch:
@@ -238,8 +238,8 @@ private boolean processWrite() throws IOException {
             final ByteBuffer buffer = currentDataBuffer.getResource();
             packetHeaderAndDataBuffer = new ByteBuffer[1];
             packetHeaderAndDataBuffer[0] = buffer;
-            buffer.put((byte) 0x12);
-            buffer.put((byte) 0x34);
+            buffer.put((byte) 'A');
+            buffer.put((byte) 'B');
             buffer.put((byte) 0);
             buffer.put((byte) 2);
             buffer.put((byte) 5);

File: websockets/src/test/java/io/undertow/websockets/utils/WebSocketTestClient.java
Patch:
@@ -64,7 +64,7 @@ public WebSocketTestClient(WebSocketVersion version, URI uri) {
      *
      * @throws Exception
      */
-    public WebSocketTestClient  connect() throws Exception {
+    public WebSocketTestClient connect() throws Exception {
         String protocol = uri.getScheme();
         if (!"ws".equals(protocol)) {
             throw new IllegalArgumentException("Unsupported protocol: " + protocol);
@@ -95,7 +95,7 @@ public ChannelPipeline getPipeline() throws Exception {
 
         ch = future.getChannel();
 
-        handshaker.handshake(ch);
+        handshaker.handshake(ch).syncUninterruptibly();
         handshakeLatch.await();
         return this;
     }

File: websockets/src/main/java/io/undertow/websockets/FixedPayloadFrameSourceChannel.java
Patch:
@@ -87,9 +87,8 @@ protected static long transfer(final ReadableByteChannel source, final long coun
             }
             while (throughBuffer.hasRemaining()) {
                 long res = sink.write(throughBuffer);
-
                 if (res <= 0) {
-                    return total == 0L ? res : total;
+                    return total;
                 }
                 total += res;
             }

File: websockets/src/main/java/io/undertow/websockets/FixedPayloadFrameSourceChannel.java
Patch:
@@ -87,8 +87,8 @@ protected static long transfer(final ReadableByteChannel source, final long coun
             while (throughBuffer.hasRemaining()) {
                 long res = sink.write(throughBuffer);
 
-                if (res == 0) {
-                    return total;
+                if (res <= 0) {
+                    return total == 0L ? res : total;
                 }
                 total += res;
             }

File: websockets/src/test/java/io/undertow/websockets/protocol/server/AutobahnWebSocketServer.java
Patch:
@@ -416,7 +416,7 @@ public void handleEvent(final Channel channel) {
                             readFailed(e);
                             return;
                         }
-                        if (lres == 0) {
+                        if (lres == 0 && !buffer.hasRemaining()) {
                             this.count = count;
                             return;
                         }
@@ -471,7 +471,7 @@ public void handleEvent(final Channel channel) {
                             readFailed(e);
                             return;
                         }
-                        if (lres == 0) {
+                        if (lres == 0 && !buffer.hasRemaining()) {
                             this.count = count;
                             this.state = 0;
                             sink.suspendWrites();

File: websockets/src/main/java/io/undertow/websockets/WebSocketChannel.java
Patch:
@@ -419,7 +419,7 @@ void markBroken() {
 
             StreamSourceFrameChannel receiver = this.receiver;
             if (receiver != null && receiver.isReadResumed()) {
-                receiver.queueReadListener();
+                receiver.queueListener(((ChannelListener.SimpleSetter) receiver.getReadSetter()).get());
             }
             synchronized (senders) {
                 for (final StreamSinkFrameChannel channel : senders) {

File: websockets/src/main/java/io/undertow/websockets/function/ChannelFunctionWritableByteChannel.java
Patch:
@@ -37,7 +37,7 @@ public ChannelFunctionWritableByteChannel(WritableByteChannel channel, ChannelFu
 
     @Override
     public int write(ByteBuffer src) throws IOException {
-        for (ChannelFunction func: functions) {
+        for(ChannelFunction func : functions) {
             func.beforeWrite(src);
         }
         return channel.write(src);

File: websockets/src/main/java/io/undertow/websockets/protocol/version07/WebSocket07TextFrameSinkChannel.java
Patch:
@@ -24,7 +24,6 @@
 import io.undertow.websockets.WebSocketFrameType;
 import io.undertow.websockets.function.ChannelFunctionFileChannel;
 import io.undertow.websockets.function.ChannelFunctionStreamSourceChannel;
-import io.undertow.websockets.protocol.version07.UTF8Checker;
 import org.xnio.channels.StreamSinkChannel;
 import org.xnio.channels.StreamSourceChannel;
 

File: websockets/src/main/java/io/undertow/websockets/protocol/version00/WebSocket00BinaryFrameSourceChannel.java
Patch:
@@ -20,15 +20,15 @@
 
 import io.undertow.websockets.WebSocketChannel;
 import io.undertow.websockets.WebSocketFrameType;
-import io.undertow.websockets.protocol.WebSocketFixedPayloadFrameSourceChannel;
+import io.undertow.websockets.FixedPayloadFrameSourceChannel;
 import org.xnio.channels.StreamSourceChannel;
 
 
 /**
  *
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
-public class WebSocket00BinaryFrameSourceChannel extends WebSocketFixedPayloadFrameSourceChannel {
+public class WebSocket00BinaryFrameSourceChannel extends FixedPayloadFrameSourceChannel {
 
     WebSocket00BinaryFrameSourceChannel(WebSocketChannel.StreamSourceChannelControl streamSourceChannelControl, StreamSourceChannel channel, WebSocketChannel wsChannel, long payloadSize) {
         super(streamSourceChannelControl, channel, wsChannel, WebSocketFrameType.BINARY, payloadSize, 0, true);

File: websockets/src/main/java/io/undertow/websockets/protocol/version07/WebSocket07BinaryFrameSourceChannel.java
Patch:
@@ -19,15 +19,14 @@
 
 import io.undertow.websockets.WebSocketChannel;
 import io.undertow.websockets.WebSocketFrameType;
-import io.undertow.websockets.protocol.version07.Masker;
-import io.undertow.websockets.protocol.WebSocketFixedPayloadFrameSourceChannel;
+import io.undertow.websockets.FixedPayloadFrameSourceChannel;
 import org.xnio.channels.StreamSourceChannel;
 
 
 /**
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
-public class WebSocket07BinaryFrameSourceChannel extends WebSocketFixedPayloadFrameSourceChannel {
+public class WebSocket07BinaryFrameSourceChannel extends FixedPayloadFrameSourceChannel {
     WebSocket07BinaryFrameSourceChannel(WebSocketChannel.StreamSourceChannelControl streamSourceChannelControl, StreamSourceChannel channel, WebSocketChannel wsChannel, long payloadSize, int rsv, boolean finalFragment, Masker masker) {
         super(streamSourceChannelControl, channel, wsChannel, WebSocketFrameType.BINARY, payloadSize, rsv, finalFragment, masker);
     }

File: websockets/src/main/java/io/undertow/websockets/protocol/version07/WebSocket07PingFrameSourceChannel.java
Patch:
@@ -19,14 +19,13 @@
 
 import io.undertow.websockets.WebSocketChannel;
 import io.undertow.websockets.WebSocketFrameType;
-import io.undertow.websockets.protocol.version07.Masker;
-import io.undertow.websockets.protocol.WebSocketFixedPayloadFrameSourceChannel;
+import io.undertow.websockets.FixedPayloadFrameSourceChannel;
 import org.xnio.channels.StreamSourceChannel;
 
 /**
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
-public class WebSocket07PingFrameSourceChannel extends WebSocketFixedPayloadFrameSourceChannel {
+public class WebSocket07PingFrameSourceChannel extends FixedPayloadFrameSourceChannel {
     public WebSocket07PingFrameSourceChannel(WebSocketChannel.StreamSourceChannelControl streamSourceChannelControl, StreamSourceChannel channel, WebSocketChannel wsChannel, long payloadSize, int rsv, Masker masker) {
         // can not be fragmented
         super(streamSourceChannelControl, channel, wsChannel, WebSocketFrameType.PING, payloadSize, rsv, true, masker);

File: websockets/src/main/java/io/undertow/websockets/protocol/version07/WebSocket07PongFrameSourceChannel.java
Patch:
@@ -19,14 +19,13 @@
 
 import io.undertow.websockets.WebSocketChannel;
 import io.undertow.websockets.WebSocketFrameType;
-import io.undertow.websockets.protocol.version07.Masker;
-import io.undertow.websockets.protocol.WebSocketFixedPayloadFrameSourceChannel;
+import io.undertow.websockets.FixedPayloadFrameSourceChannel;
 import org.xnio.channels.PushBackStreamChannel;
 
 /**
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
-public class WebSocket07PongFrameSourceChannel extends WebSocketFixedPayloadFrameSourceChannel {
+public class WebSocket07PongFrameSourceChannel extends FixedPayloadFrameSourceChannel {
     public WebSocket07PongFrameSourceChannel(WebSocketChannel.StreamSourceChannelControl streamSourceChannelControl, PushBackStreamChannel channel, WebSocketChannel wsChannel, long payloadSize, int rsv, final Masker masker) {
         // can not be fragmented
         super(streamSourceChannelControl, channel, wsChannel, WebSocketFrameType.PONG, payloadSize, rsv, true, masker);

File: core/src/main/java/io/undertow/channels/FixedLengthStreamSinkChannel.java
Patch:
@@ -341,9 +341,7 @@ public long getRemaining() {
     private void exitWrite(long oldVal, long consumed) {
         long newVal = oldVal - consumed;
         state = newVal;
-        if (allAreSet(newVal, FLAG_CLOSE_COMPLETE)) {
-            // closed while we were in flight.  Call the listener.
-            callClosed();
+        if (anyAreSet(oldVal, MASK_COUNT) && allAreClear(newVal, MASK_COUNT)) {
             callFinish();
         }
     }

File: core/src/main/java/io/undertow/server/handlers/file/DirectBufferCache.java
Patch:
@@ -304,4 +304,4 @@ Object clearToken() {
         }
 
     }
-}
\ No newline at end of file
+}

File: core/src/main/java/io/undertow/server/handlers/file/FastConcurrentDirectDeque.java
Patch:
@@ -1479,4 +1479,4 @@ private static Unsafe getUnsafe0()  {
             throw new RuntimeException("JDK did not allow accessing unsafe", t);
         }
     }
-}
\ No newline at end of file
+}

File: core/src/main/java/io/undertow/server/handlers/file/FileHandler.java
Patch:
@@ -242,4 +242,4 @@ public boolean isDirectoryListingEnabled() {
     public void setDirectoryListingEnabled(final boolean directoryListingEnabled) {
         this.directoryListingEnabled = directoryListingEnabled;
     }
-}
\ No newline at end of file
+}

File: core/src/main/java/io/undertow/server/handlers/file/PortableConcurrentDirectDeque.java
Patch:
@@ -1427,4 +1427,4 @@ private boolean casTail(Node<E> cmp, Node<E> val) {
         NEXT_TERMINATOR = new Node<Object>();
         NEXT_TERMINATOR.prev = NEXT_TERMINATOR;
     }
-}
\ No newline at end of file
+}

File: core/src/main/java/io/undertow/util/AttachmentKey.java
Patch:
@@ -88,4 +88,4 @@ public AttachmentList<T> cast(final Object value) {
     Class<T> getValueClass() {
         return valueClass;
     }
-}
\ No newline at end of file
+}

File: core/src/main/java/io/undertow/util/FlexBase64.java
Patch:
@@ -1702,4 +1702,4 @@ public void close() throws IOException {
             output.close();
         }
     }
-}
\ No newline at end of file
+}

File: core/src/test/java/io/undertow/ssl/SimpleSSLTestCase.java
Patch:
@@ -29,7 +29,7 @@
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -52,7 +52,7 @@ public void handleRequest(final HttpServerExchange exchange, final HttpCompletio
             }
         });
 
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerSSLAddress());
             HttpResponse result = client.execute(get);

File: core/src/test/java/io/undertow/test/MaxRequestSizeTestCase.java
Patch:
@@ -27,6 +27,7 @@
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
 import io.undertow.util.Headers;
+import io.undertow.util.TestHttpClient;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpPost;
 import org.apache.http.entity.StringEntity;
@@ -76,7 +77,7 @@ public void handleRequest(final BlockingHttpServerExchange exchange) {
     public void testMaxRequestHeaderSize() throws IOException {
         OptionMap existing = DefaultServer.getUndertowOptions();
         try {
-            final DefaultHttpClient client = new DefaultHttpClient();
+            final TestHttpClient client = new TestHttpClient();
             HttpPost post = new HttpPost(DefaultServer.getDefaultServerAddress() + "/notamatchingpath");
             post.setEntity(new StringEntity(A_MESSAGE));
             post.addHeader(Headers.CONNECTION_STRING, "close");
@@ -109,7 +110,7 @@ public void testMaxRequestHeaderSize() throws IOException {
     public void testMaxRequestEntitySize() throws IOException {
         OptionMap existing = DefaultServer.getUndertowOptions();
         try {
-            final DefaultHttpClient client = new DefaultHttpClient();
+            final TestHttpClient client = new TestHttpClient();
             HttpPost post = new HttpPost(DefaultServer.getDefaultServerAddress() + "/notamatchingpath");
             post.setEntity(new StringEntity(A_MESSAGE));
             post.addHeader(Headers.CONNECTION_STRING, "close");

File: core/src/test/java/io/undertow/test/handlers/ChunkedResponseTransferCodingTestCase.java
Patch:
@@ -28,7 +28,7 @@
 import io.undertow.test.utils.HttpClientUtils;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -73,7 +73,7 @@ public void handleRequest(final BlockingHttpServerExchange exchange) {
     @Test
     public void sendHttpRequest() throws IOException {
         HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path");
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             generateMessage(1);
             HttpResponse result = client.execute(get);

File: core/src/test/java/io/undertow/test/handlers/OriginTestCase.java
Patch:
@@ -28,7 +28,7 @@
 import io.undertow.util.Headers;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -51,7 +51,7 @@ public class OriginTestCase {
      */
     @Test
     public void testStrictOrigin() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             final OriginHandler handler = new OriginHandler();
             handler.addAllowedOrigins("http://www.mysite.com:80", "http://mysite.com:80");

File: core/src/test/java/io/undertow/test/handlers/SimpleNonBlockingServerTestCase.java
Patch:
@@ -25,7 +25,7 @@
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -45,7 +45,7 @@ public static void setup() {
 
     @Test
     public void sendHttpRequest() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path");
             HttpResponse result = client.execute(get);

File: core/src/test/java/io/undertow/test/handlers/encoding/EncodingSelectionTestCase.java
Patch:
@@ -28,7 +28,7 @@
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -53,7 +53,7 @@ public class EncodingSelectionTestCase {
      */
     @Test
     public void testBasicEncodingSelect() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             final EncodingHandler handler = new EncodingHandler();
             handler.addEncodingHandler("compress", new SetHeaderHandler(HEADER, "compress"), 50);
@@ -124,7 +124,7 @@ public void testBasicEncodingSelect() throws IOException {
      */
     @Test
     public void testEncodingSelectWithQValue() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             final EncodingHandler handler = new EncodingHandler();
             handler.addEncodingHandler("compress", new SetHeaderHandler(HEADER, "compress"), 100);

File: core/src/test/java/io/undertow/test/handlers/error/FileErrorPageHandlerTestCase.java
Patch:
@@ -26,7 +26,7 @@
 import io.undertow.test.utils.HttpClientUtils;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -40,7 +40,7 @@ public class FileErrorPageHandlerTestCase {
 
     @Test
     public void testFileBasedErrorPageIsGenerated() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             final FileErrorPageHandler handler = new FileErrorPageHandler(new File(getClass().getResource("errorpage.html").getFile()), 404);
             DefaultServer.setRootHandler(handler);

File: core/src/test/java/io/undertow/test/handlers/error/SimpleErrorPageHandlerTestCase.java
Patch:
@@ -26,7 +26,7 @@
 import io.undertow.util.StatusCodes;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -40,7 +40,7 @@ public class SimpleErrorPageHandlerTestCase {
 
     @Test
     public void testSimpleErrorPageIsGenerated() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             final SimpleErrorPageHandler handler = new SimpleErrorPageHandler();
             DefaultServer.setRootHandler(handler);

File: core/src/test/java/io/undertow/test/handlers/file/FileHandlerStressTestCase.java
Patch:
@@ -34,7 +34,7 @@
 import io.undertow.test.utils.HttpClientUtils;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -64,7 +64,7 @@ public void simpleFileStressTest() throws IOException, ExecutionException, Inter
                 futures.add(executor.submit(new Runnable() {
                     @Override
                     public void run() {
-                        DefaultHttpClient client = new DefaultHttpClient();
+                        TestHttpClient client = new TestHttpClient();
                         try {
                             for (int i = 0; i < NUM_REQUESTS; ++i) {
                                 HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path/page.html");

File: core/src/test/java/io/undertow/test/handlers/file/FileHandlerTestCase.java
Patch:
@@ -28,7 +28,7 @@
 import io.undertow.test.utils.HttpClientUtils;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -42,7 +42,7 @@ public class FileHandlerTestCase {
 
     @Test
     public void testFileIsServed() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             final FileHandler handler = new FileHandler(new File(getClass().getResource("page.html").getFile()).getParentFile());
             handler.setDirectoryListingEnabled(true);

File: core/src/test/java/io/undertow/test/handlers/form/FormDataParserTestCase.java
Patch:
@@ -43,7 +43,7 @@
 import org.apache.http.NameValuePair;
 import org.apache.http.client.entity.UrlEncodedFormEntity;
 import org.apache.http.client.methods.HttpPost;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.apache.http.message.BasicNameValuePair;
 import org.junit.Assert;
 import org.junit.Test;
@@ -129,7 +129,7 @@ public void testFormDataParsing() throws Exception {
 
     private void runTest(final NameValuePair... pairs) throws Exception {
         DefaultServer.setRootHandler(rootHandler);
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
 
             final List<NameValuePair> data = new ArrayList<NameValuePair>();

File: core/src/test/java/io/undertow/test/handlers/form/MultipartFormDataParserTestCase.java
Patch:
@@ -38,7 +38,7 @@
 import org.apache.http.entity.mime.MultipartEntity;
 import org.apache.http.entity.mime.content.FileBody;
 import org.apache.http.entity.mime.content.StringBody;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -82,7 +82,7 @@ public void handleRequest(final HttpServerExchange exchange, final HttpCompletio
 
     @Test
     public void testFileUpload() throws Exception {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
 
             HttpPost post = new HttpPost(DefaultServer.getDefaultServerAddress() + "/path");

File: core/src/test/java/io/undertow/test/handlers/security/UsernamePasswordAuthenticationTestBase.java
Patch:
@@ -49,7 +49,7 @@
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -156,7 +156,7 @@ protected void setAuthenticationChain() {
     public void testNoMechanisms() throws Exception {
         DefaultServer.setRootHandler(new ResponseHandler());
 
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress());
         HttpResponse result = client.execute(get);
         assertEquals(200, result.getStatusLine().getStatusCode());

File: core/src/test/java/io/undertow/test/session/inmemory/InMemorySessionTestCase.java
Patch:
@@ -38,7 +38,7 @@
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.impl.client.BasicCookieStore;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -55,7 +55,7 @@ public class InMemorySessionTestCase {
 
     @Test
     public void inMemorySessionTest() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         client.setCookieStore(new BasicCookieStore());
         final CookieHandler cookieHandler = new CookieHandler();
         try {

File: core/src/test/java/io/undertow/test/session/inmemory/SSLSessionTestCase.java
Patch:
@@ -36,7 +36,7 @@
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -53,7 +53,7 @@ public class SSLSessionTestCase {
 
     @Test
     public void testBasicPathHanding() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             final SslSessionConfig sessionConfig = new SslSessionConfig();
             final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager(), sessionConfig)

File: jsp/src/test/java/io/undertow/test/jsp/basic/SimpleJspTestCase.java
Patch:
@@ -36,7 +36,7 @@
 import io.undertow.test.utils.HttpClientUtils;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.apache.jasper.deploy.JspPropertyGroup;
 import org.apache.jasper.deploy.TagLibraryInfo;
 import org.junit.AfterClass;
@@ -87,7 +87,7 @@ public static void after(){
 
     @Test
     public void testSimpleHttpServlet() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/a.jsp");
             HttpResponse result = client.execute(get);

File: servlet/src/test/java/io/undertow/servlet/test/SimpleServletTestCase.java
Patch:
@@ -34,7 +34,7 @@
 import io.undertow.test.utils.HttpClientUtils;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -76,7 +76,7 @@ public static void setup() throws ServletException {
 
     @Test
     public void testSimpleHttpServlet() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/aa");
             HttpResponse result = client.execute(get);

File: servlet/src/test/java/io/undertow/servlet/test/async/SimpleAsyncTestCase.java
Patch:
@@ -35,7 +35,7 @@
 import io.undertow.test.utils.HttpClientUtils;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -83,7 +83,7 @@ public static void setup() throws ServletException {
 
     @Test
     public void testSimpleHttpServlet() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/async");
             HttpResponse result = client.execute(get);

File: servlet/src/test/java/io/undertow/servlet/test/charset/CharacterEncodingTestCase.java
Patch:
@@ -16,7 +16,7 @@
 import io.undertow.test.utils.HttpClientUtils;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -66,7 +66,7 @@ public static byte[] toByteArray(int[] source) {
 
     @Test
     public void testCharacterEncoding() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext?charset=UTF-16BE");
             HttpResponse result = client.execute(get);

File: servlet/src/test/java/io/undertow/servlet/test/defaultservlet/AbstractWelcomeFileTestCase.java
Patch:
@@ -6,7 +6,7 @@
 import io.undertow.test.utils.HttpClientUtils;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -18,7 +18,7 @@ public class AbstractWelcomeFileTestCase {
 
     @Test
     public void testWelcomeFileRedirect() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/");
             HttpResponse result = client.execute(get);
@@ -33,7 +33,7 @@ public void testWelcomeFileRedirect() throws IOException {
 
     @Test
     public void testWelcomeServletRedirect() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/path?a=b");
             HttpResponse result = client.execute(get);

File: servlet/src/test/java/io/undertow/servlet/test/dispatcher/DispatcherIncludeTestCase.java
Patch:
@@ -38,7 +38,7 @@
 import io.undertow.test.utils.HttpClientUtils;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -93,7 +93,7 @@ public static void setup() throws ServletException {
 
     @Test
     public void testPathBasedInclude() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/dispatch");
             get.setHeader("include", "/include");
@@ -108,7 +108,7 @@ public void testPathBasedInclude() throws IOException {
 
     @Test
     public void testNameBasedInclude() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/dispatch");
             get.setHeader("include", "include");

File: servlet/src/test/java/io/undertow/servlet/test/path/ServletPathMappingTestCase.java
Patch:
@@ -33,7 +33,7 @@
 import io.undertow.test.utils.HttpClientUtils;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -90,7 +90,7 @@ public static void setup() throws ServletException {
 
     @Test
     public void testSimpleHttpServlet() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/aa");
             HttpResponse result = client.execute(get);

File: servlet/src/test/java/io/undertow/servlet/test/security/SecurityConstraintUrlMappingTestCase.java
Patch:
@@ -23,7 +23,7 @@
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.client.methods.HttpPost;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -136,7 +136,7 @@ public void testAggregatedRoles() throws IOException {
 
     @Test
     public void testHttpMethod() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         final String url = DefaultServer.getDefaultServerAddress() + "/servletContext/public/postSecured/a";
         try {
             HttpGet initialGet = new HttpGet(url);
@@ -175,7 +175,7 @@ public void testHttpMethod() throws IOException {
     }
 
     public void runSimpleUrlTest(final String url, final String badUser, final String goodUser) throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             HttpGet get = new HttpGet(url);
             HttpResponse result = client.execute(get);

File: servlet/src/test/java/io/undertow/servlet/test/session/CrossContextServletSessionTestCase.java
Patch:
@@ -38,7 +38,7 @@
 import io.undertow.test.utils.HttpClientUtils;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -91,7 +91,7 @@ private static void createDeployment(final String name, final ServletContainer c
 
     @Test
     public void testCrossContextSessionInvocation() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             HttpGet direct1 = new HttpGet(DefaultServer.getDefaultServerAddress() + "/1/servlet");
             HttpGet forward1 = new HttpGet(DefaultServer.getDefaultServerAddress() + "/1/forward?context=/2&path=/servlet");

File: servlet/src/test/java/io/undertow/servlet/test/session/ServletSessionTestCase.java
Patch:
@@ -36,7 +36,7 @@
 import io.undertow.test.utils.HttpClientUtils;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import io.undertow.util.TestHttpClient;
 import org.junit.Assert;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -80,7 +80,7 @@ public static void setup() throws ServletException {
 
     @Test
     public void testSimpleSessionUsage() throws IOException {
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/aa");
             HttpResponse result = client.execute(get);
@@ -108,7 +108,7 @@ public void testSimpleSessionUsage() throws IOException {
     @Test
     public void testSessionCookieConfig() throws IOException {
         servletContext.getSessionCookieConfig().setName("MySessionCookie");
-        DefaultHttpClient client = new DefaultHttpClient();
+        TestHttpClient client = new TestHttpClient();
         try {
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/servletContext/aa");
             HttpResponse result = client.execute(get);

File: websockets/src/main/java/io/undertow/websockets/WebSocketHandshakeException.java
Patch:
@@ -41,4 +41,4 @@ public WebSocketHandshakeException(String s, Throwable throwable) {
     public WebSocketHandshakeException(final Throwable cause) {
         super(cause);
     }
-}
\ No newline at end of file
+}

File: websockets/src/main/java/io/undertow/websockets/utf8/UTF8FileChannel.java
Patch:
@@ -60,4 +60,4 @@ protected WritableByteChannel wrapWritableByteChannel(WritableByteChannel channe
     protected AbstractFileChannelWrapper wrapFileChannel(FileChannel channel) {
         return new UTF8FileChannel(channel, checker);
     }
-}
\ No newline at end of file
+}

File: websockets/src/main/java/io/undertow/websockets/utf8/UTF8FixedPayloadMaskedFrameSourceChannel.java
Patch:
@@ -91,4 +91,4 @@ protected void complete() throws IOException {
     protected void checkUTF8(ByteBuffer buffer) throws IOException{
         checker.checkUTF8AfterRead(buffer);
     }
-}
\ No newline at end of file
+}

File: core/src/main/java/io/undertow/server/session/SslSessionConfig.java
Patch:
@@ -41,15 +41,15 @@ public SslSessionConfig(final SessionConfig fallbackSessionConfig, final Attachm
     }
 
     public SslSessionConfig(final SessionConfig fallbackSessionConfig) {
-        this(fallbackSessionConfig, AttachmentKey.create(Session.class));
+        this(fallbackSessionConfig, AttachmentKey.<Session>create(Session.class));
     }
 
     public SslSessionConfig(final AttachmentKey<Session> attachmentKey) {
         this(null, attachmentKey);
     }
 
     public SslSessionConfig() {
-        this(null, AttachmentKey.create(Session.class));
+        this(null, AttachmentKey.<Session>create(Session.class));
     }
 
     @Override

File: core/src/main/java/io/undertow/server/HttpTransferEncodingHandler.java
Patch:
@@ -30,6 +30,8 @@
 import io.undertow.util.BrokenStreamSourceChannel;
 import io.undertow.util.ChunkedStreamSinkChannel;
 import io.undertow.util.ChunkedStreamSourceChannel;
+import io.undertow.util.FixedLengthStreamSinkChannel;
+import io.undertow.util.FixedLengthStreamSourceChannel;
 import io.undertow.util.HeaderMap;
 import io.undertow.util.Headers;
 import io.undertow.util.HttpString;
@@ -41,8 +43,6 @@
 import org.xnio.IoUtils;
 import org.xnio.channels.ChannelFactory;
 import org.xnio.channels.EmptyStreamSourceChannel;
-import org.xnio.channels.FixedLengthStreamSinkChannel;
-import org.xnio.channels.FixedLengthStreamSourceChannel;
 import org.xnio.channels.PushBackStreamChannel;
 import org.xnio.channels.StreamSinkChannel;
 import org.xnio.channels.StreamSourceChannel;

File: core/src/test/java/io/undertow/test/handlers/form/FormDataParserTestCase.java
Patch:
@@ -73,7 +73,7 @@ public static Collection<Object[]> handlerChains() {
         fd.setNext(new HttpHandler() {
             @Override
             public void handleRequest(final HttpServerExchange exchange, final HttpCompletionHandler completionHandler) {
-                final FormDataParser parser = (FormDataParser) exchange.getAttachment(FormDataParser.ATTACHMENT_KEY);
+                final FormDataParser parser = exchange.getAttachment(FormDataParser.ATTACHMENT_KEY);
                 try {
                     FormData data = parser.parse().get();
                     Iterator<String> it = data.iterator();
@@ -100,7 +100,7 @@ public void handleRequest(final HttpServerExchange exchange, final HttpCompletio
 
             @Override
             public void handleRequest(final BlockingHttpServerExchange exchange) throws Exception {
-                final FormDataParser parser = (FormDataParser) exchange.getExchange().getAttachment(FormDataParser.ATTACHMENT_KEY);
+                final FormDataParser parser = exchange.getExchange().getAttachment(FormDataParser.ATTACHMENT_KEY);
                 try {
                     FormData data = parser.parseBlocking();
                     Iterator<String> it = data.iterator();

File: core/src/test/java/io/undertow/test/handlers/form/MultipartFormDataParserTestCase.java
Patch:
@@ -56,7 +56,7 @@ public static void setup() {
         fd.setNext(new HttpHandler() {
             @Override
             public void handleRequest(final HttpServerExchange exchange, final HttpCompletionHandler completionHandler) {
-                final FormDataParser parser = (FormDataParser) exchange.getAttachment(FormDataParser.ATTACHMENT_KEY);
+                final FormDataParser parser = exchange.getAttachment(FormDataParser.ATTACHMENT_KEY);
                 try {
                     FormData data = parser.parse().get();
                     exchange.setResponseCode(500);

File: websockets/src/test/java/io/undertow/websockets/protocol/server/AutobahnWebSocketServer.java
Patch:
@@ -179,9 +179,6 @@ public void handleEvent(StreamSourceFrameChannel streamSourceFrameChannel) {
                         }, new ChannelListener<StreamSinkFrameChannel>() {
                             @Override
                             public void handleEvent(StreamSinkFrameChannel streamSinkFrameChannel) {
-                                if(!streamSinkFrameChannel.isOpen()) {
-                                    return;
-                                }
                                 try {
                                     streamSinkFrameChannel.shutdownWrites();
                                 } catch (IOException e) {
@@ -213,6 +210,8 @@ public void handleException(StreamSinkFrameChannel o, IOException e) {
                                         if (type == WebSocketFrameType.CLOSE) {
                                             IoUtils.safeClose(channel);
                                         }
+                                        streamSinkFrameChannel.getWriteSetter().set(null);
+                                        IoUtils.safeClose(streamSinkFrameChannel);
                                     }
                                 } catch (IOException e) {
                                     e.printStackTrace();

File: websockets/src/main/java/io/undertow/websockets/StreamSinkFrameChannel.java
Patch:
@@ -57,7 +57,7 @@ public abstract class StreamSinkFrameChannel implements StreamSinkChannel {
     private final Object writeWaitLock = new Object();
     private int waiters = 0;
 
-    private boolean writesSuspended = true;
+    private volatile boolean writesSuspended = true;
 
     //todo: I don't think this belongs here
     private int rsv;
@@ -502,19 +502,19 @@ public Setter<? extends StreamSinkChannel> getCloseSetter() {
 
     @Override
     public synchronized void suspendWrites() {
+        writesSuspended = true;
         if (isActive()) {
             channel.suspendWrites();
         }
-        writesSuspended = true;
     }
 
 
     @Override
     public synchronized void resumeWrites() {
+        writesSuspended = false;
         if (isActive()) {
             channel.resumeWrites();
         }
-        writesSuspended = false;
     }
 
     /**

File: websockets/src/main/java/io/undertow/websockets/StreamSourceFrameChannel.java
Patch:
@@ -223,10 +223,10 @@ public void close() throws IOException {
             throw WebSocketMessages.MESSAGES.closedBeforeAllBytesWereRead();
         }
         closed = true;
-        invokeReadListener();
+        queueReadListener();
     }
 
-    private void invokeReadListener() {
+    protected void queueReadListener() {
         getReadThread().execute(new Runnable() {
             @Override
             public void run() {
@@ -285,7 +285,7 @@ public void wakeupReads() {
         channel.wakeupReads();
         if (complete) {
             // if complete we need to invoke the listener by ourself
-            ChannelListeners.invokeChannelListener(this, (ChannelListener<? super StreamSourceFrameChannel>) readSetter.get());
+            queueReadListener();
         }
     }
 

File: websockets/src/main/java/io/undertow/websockets/WebSocketMessages.java
Patch:
@@ -112,4 +112,7 @@ public interface WebSocketMessages {
 
     @Message(id = 2026, value = "Invalid close frame status code: %s")
     IOException invalidCloseFrameStatusCode(int statusCode);
+
+    @Message(id = 2027, value = "Could not send data, as the underlying web socket connection has been broken")
+    IOException streamIsBroken();
 }

File: servlet/src/main/java/io/undertow/servlet/handlers/security/ServletSecurityRoleHandler.java
Patch:
@@ -12,7 +12,6 @@
 
 import io.undertow.server.handlers.blocking.BlockingHttpHandler;
 import io.undertow.server.handlers.blocking.BlockingHttpServerExchange;
-import io.undertow.server.handlers.security.AuthenticationState;
 import io.undertow.server.handlers.security.SecurityContext;
 import io.undertow.servlet.handlers.ServletAttachments;
 import io.undertow.servlet.spec.HttpServletRequestImpl;
@@ -57,7 +56,6 @@ public void handleRequest(final BlockingHttpServerExchange exchange) throws Exce
         } else if (roles.isEmpty()) {
             next.handleRequest(exchange);
         } else {
-            assert sc.getAuthenticationState() == AuthenticationState.AUTHENTICATED;
             for (final Set<String> roleSet : roles) {
                 boolean found = false;
                 for (String role : roleSet) {

File: websockets/src/main/java/io/undertow/websockets/StreamSinkFrameChannel.java
Patch:
@@ -522,6 +522,7 @@ public boolean isWriteResumed() {
     @Override
     public void wakeupWrites() {
         resumeWrites();
+
         ChannelListeners.invokeChannelListener(this, writeSetter.get());
     }
 

File: websockets/src/main/java/io/undertow/websockets/utf8/UTF8FixedPayloadMaskedFrameSourceChannel.java
Patch:
@@ -21,7 +21,6 @@
 import io.undertow.websockets.WebSocketFrameType;
 import io.undertow.websockets.protocol.WebSocketFixedPayloadMaskedFrameSourceChannel;
 import io.undertow.websockets.protocol.version07.WebSocket07Channel;
-import org.xnio.channels.StreamSinkChannel;
 import org.xnio.channels.StreamSourceChannel;
 
 import java.io.IOException;
@@ -83,7 +82,7 @@ protected long read0(ByteBuffer[] dsts, int offset, int length) throws IOExcepti
 
     @Override
     protected void complete() throws IOException {
-        if (isFinalFragment()) {
+        if (checker != null && isFinalFragment()) {
             checker.complete();
         }
         super.complete();

File: websockets/src/main/java/io/undertow/websockets/protocol/version07/WebSocket07Channel.java
Patch:
@@ -152,8 +152,6 @@ public void handle(final ByteBuffer buffer, final PushBackStreamChannel channel)
                                 throw WebSocketMessages.MESSAGES.extensionsNotAllowed(frameRsv);
                             }
 
-                            System.out.println(frameFinalFlag + " " + frameOpcode + " " +frameMasked + " " + framePayloadLen1 + " " + framePayloadLength);
-
                             if (frameOpcode > 7) { // control frame (have MSB in opcode set)
                                 validateControlFrame();
                             } else { // data frame

File: websockets/src/test/java/io/undertow/websockets/protocol/server/AutobahnWebSocketServer.java
Patch:
@@ -76,7 +76,7 @@ public void run() {
                     .set(Options.TCP_NODELAY, true)
                     .set(Options.REUSE_ADDRESSES, true)
                     .getMap();
-            openListener = new HttpOpenListener(new ByteBufferSlicePool(BufferAllocator.DIRECT_BYTE_BUFFER_ALLOCATOR, 8192, 8192 * 8192));
+            openListener = new HttpOpenListener(new ByteBufferSlicePool(BufferAllocator.DIRECT_BYTE_BUFFER_ALLOCATOR, 8192, 8192 * 8192), 8192);
             ChannelListener acceptListener = ChannelListeners.openListenerAdapter(openListener);
             server = worker.createStreamServer(new InetSocketAddress(port), acceptListener, serverOptions);
 

File: core/src/main/java/io/undertow/util/WorkerDispatcher.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.util.concurrent.Executor;
 
+import io.undertow.UndertowLogger;
 import io.undertow.server.HttpServerExchange;
 import org.xnio.channels.StreamSourceChannel;
 
@@ -50,6 +51,8 @@ public void run() {
                     try {
                         executingInWorker.set(e);
                         runnable.run();
+                    } catch (Exception e) {
+                        UndertowLogger.REQUEST_LOGGER.exceptionProcessingRequest(e);
                     } finally {
                         executingInWorker.remove();
                     }

File: core/src/main/java/io/undertow/server/handlers/error/SimpleErrorPageHandler.java
Patch:
@@ -65,8 +65,6 @@ public void handleComplete() {
                     final ChannelFactory<StreamSinkChannel> factory = exchange.getResponseChannelFactory();
                     if (factory != null) {
                         final String errorPage = "<html><head><title>Error</title></head><body>" + exchange.getResponseCode() + " - " + StatusCodes.getReason(exchange.getResponseCode()) + "</body></html>";
-                        //we don't want any headers from the original request hanging around
-                        exchange.getResponseHeaders().clear();
                         exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, "" + errorPage.length());
 
                         final StreamSinkChannel response = factory.create();

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletAttachments.java
Patch:
@@ -3,9 +3,8 @@
 import java.util.List;
 import java.util.Set;
 
-import javax.servlet.annotation.ServletSecurity;
-
 import io.undertow.servlet.api.ServletInfo;
+import io.undertow.servlet.api.TransportGuaranteeType;
 import io.undertow.util.AttachmentKey;
 
 /**
@@ -17,5 +16,5 @@ public class ServletAttachments {
     public static final AttachmentKey<ServletPathMatch> SERVLET_PATH_MATCH = AttachmentKey.create(ServletPathMatch.class);
 
     public static final AttachmentKey<List<Set<String>>> REQUIRED_ROLES = AttachmentKey.create(List.class);
-    public static final AttachmentKey<ServletSecurity.TransportGuarantee> TRANSPORT_GUARANTEE_TYPE = AttachmentKey.create(ServletSecurity.TransportGuarantee.class);
+    public static final AttachmentKey<TransportGuaranteeType> TRANSPORT_GUARANTEE_TYPE = AttachmentKey.create(TransportGuaranteeType.class);
 }

File: servlet/src/main/java/io/undertow/servlet/handlers/security/ServletSecurityConstraintHandler.java
Patch:
@@ -4,12 +4,11 @@
 import java.util.List;
 import java.util.Set;
 
-import javax.servlet.annotation.ServletSecurity;
-
 import io.undertow.server.HttpCompletionHandler;
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.handlers.HttpHandlers;
+import io.undertow.servlet.api.TransportGuaranteeType;
 import io.undertow.servlet.handlers.ServletAttachments;
 
 /**
@@ -34,7 +33,7 @@ public void handleRequest(final HttpServerExchange exchange, final HttpCompletio
             exchange.putAttachment(ServletAttachments.REQUIRED_ROLES, list = new ArrayList<Set<String>>());
         }
         list.addAll(securityMatch.getRequiredRoles());
-        ServletSecurity.TransportGuarantee type = exchange.getAttachment(ServletAttachments.TRANSPORT_GUARANTEE_TYPE);
+        TransportGuaranteeType type = exchange.getAttachment(ServletAttachments.TRANSPORT_GUARANTEE_TYPE);
         if(type == null || type.ordinal() < securityMatch.getTransportGuaranteeType().ordinal()) {
             exchange.putAttachment(ServletAttachments.TRANSPORT_GUARANTEE_TYPE, type);
         }

File: websockets/src/main/java/io/undertow/websockets/protocol/WebSocketFixedPayloadFrameSourceChannel.java
Patch:
@@ -70,7 +70,7 @@ protected static long transfer(final ReadableByteChannel source, final long coun
         long total = 0L;
         throughBuffer.clear();
         while (total < count) {
-            if (count - total < (long) throughBuffer.remaining()) {
+            if (count - total < throughBuffer.remaining()) {
                 throughBuffer.limit((int) (count - total));
             }
 
@@ -101,7 +101,7 @@ protected static long transfer(final ReadableByteChannel source, final long coun
     }
 
     @Override
-    public final long transferTo0(long count, ByteBuffer throughBuffer, StreamSinkChannel target) throws IOException {
+    protected final long transferTo0(long count, ByteBuffer throughBuffer, StreamSinkChannel target) throws IOException {
         long toRead = byteToRead();
         if (toRead < 1) {
             throughBuffer.clear();

File: websockets/src/main/java/io/undertow/websockets/protocol/version07/WebSocket07TextFrameSinkChannel.java
Patch:
@@ -76,7 +76,7 @@ protected long write0(ByteBuffer[] srcs, int offset, int length) throws IOExcept
                 checker.checkUTF8BeforeWrite(src);
             }
         }
-        return super.write0(srcs, offset, length);    //To change body of overridden methods use File | Settings | File Templates.
+        return super.write0(srcs, offset, length);
     }
 
     @Override

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -35,6 +35,7 @@
 import javax.servlet.ServletContext;
 import javax.servlet.ServletException;
 import javax.servlet.annotation.ServletSecurity;
+import javax.servlet.http.HttpServletRequest;
 
 import io.undertow.server.HttpHandler;
 import io.undertow.server.handlers.AttachmentHandler;
@@ -179,7 +180,8 @@ private HttpHandler setupSecurityHandlers(HttpHandler initialHandler) {
         final LoginConfig loginConfig = deploymentInfo.getLoginConfig();
         if (loginConfig != null) {
             if (loginConfig.getAuthMethod().equalsIgnoreCase("BASIC")) {
-                AuthenticationMechanismsHandler basic = new AuthenticationMechanismsHandler(current, Collections.<AuthenticationMechanism>singletonList(new BasicAuthenticationMechanism(loginConfig.getRealmName())));
+                // The mechanism name is passed in from the HttpServletRequest interface as the name reported needs to be comparable using '=='
+                AuthenticationMechanismsHandler basic = new AuthenticationMechanismsHandler(current, Collections.<AuthenticationMechanism>singletonList(new BasicAuthenticationMechanism(loginConfig.getRealmName(), HttpServletRequest.BASIC_AUTH)));
                 current = basic;
             } else {
                 throw new RuntimeException("not yet implemented");

File: websockets/src/main/java/io/undertow/websockets/StreamSourceFrameChannel.java
Patch:
@@ -219,7 +219,7 @@ public void close() throws IOException {
         if (!isComplete() && wsChannel.isOpen()) {
             // the channel is broken
             wsChannel.markBroken();
-            throw new IOException("Closed before all bytes where read");
+            throw WebSocketMessages.MESSAGES.closedBeforeAllBytesWereRead();
         }
         closed = true;
         ChannelListeners.invokeChannelListener(this, closeSetter.get());

File: websockets/src/main/java/io/undertow/websockets/protocol/version07/WebSocket07CloseFrameSourceChannel.java
Patch:
@@ -19,6 +19,7 @@
 
 import io.undertow.websockets.WebSocketChannel;
 import io.undertow.websockets.WebSocketFrameType;
+import io.undertow.websockets.WebSocketMessages;
 import io.undertow.websockets.utf8.UTF8Checker;
 import io.undertow.websockets.utf8.UTF8FixedPayloadMaskedFrameSourceChannel;
 import org.xnio.Pooled;
@@ -186,7 +187,7 @@ private State validateStatus() throws IOException{
 
                 if (statusCode >= 0 && statusCode <= 999 || statusCode >= 1004 && statusCode <= 1006
                         || statusCode >= 1012 && statusCode <= 2999) {
-                    throw new IOException("Invalid close frame status code: " + statusCode);
+                    throw WebSocketMessages.MESSAGES.invalidCloseFrameStatusCode(statusCode);
                 }
                 return State.DONE;
             }

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletInitialHandler.java
Patch:
@@ -183,6 +183,7 @@ private void handleFirstRequest(final BlockingHttpServerExchange exchange, final
         //outer runnable will call the completion handler
         final HttpServletRequestImpl request = HttpServletRequestImpl.getRequestImpl(exchange.getExchange().getAttachment(HttpServletRequestImpl.ATTACHMENT_KEY));
         final HttpServletResponseImpl response = HttpServletResponseImpl.getResponseImpl(exchange.getExchange().getAttachment(HttpServletResponseImpl.ATTACHMENT_KEY));
+
         //the response may have been completed if sendError was invoked
         if (!exchange.getExchange().isComplete()) {
             if (!request.isAsyncStarted()) {

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -452,6 +452,7 @@ public void responseDone(final HttpCompletionHandler handler) {
         if (responseDone) {
             return;
         }
+        servletContext.updateSessionAccessTime(exchange.getExchange());
         responseDone = true;
         if (writer != null) {
             writer.close();

File: servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java
Patch:
@@ -85,7 +85,7 @@ public DefaultServlet(final Deployment deployment, final DefaultServletConfig co
     protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {
         final String path = getPath(req);
         if (!isAllowed(path)) {
-            resp.setStatus(404);
+            resp.sendError(404);
             return;
         }
         final File resource = deployment.getDeploymentInfo().getResourceLoader().getResource(path);
@@ -94,7 +94,7 @@ protected void doGet(final HttpServletRequest req, final HttpServletResponse res
                 //servlet 9.3
                 throw new FileNotFoundException(path);
             } else {
-                resp.setStatus(404);
+                resp.sendError(404);
             }
             return;
         } else if (resource.isDirectory()) {
@@ -199,7 +199,7 @@ private void handleWelcomePage(final HttpServletRequest req, final HttpServletRe
                     throw new ServletException(e);
                 }
             } else {
-                resp.setStatus(404);
+                resp.sendError(404);
             }
         }
     }

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -286,6 +286,7 @@ public PrintWriter getWriter() throws IOException {
             if (responseState == ResponseState.STREAM) {
                 throw UndertowServletMessages.MESSAGES.getOutputStreamAlreadyCalled();
             }
+            responseState = ResponseState.WRITER;
             createOutputStream();
             writer = new PrintWriter(new OutputStreamWriter(servletOutputStream));
         }

File: core/src/main/java/io/undertow/server/session/SessionManager.java
Patch:
@@ -46,14 +46,14 @@ public interface SessionManager {
      *
      * @return The created session
      */
-    IoFuture<Session> getOrCreateSession(final HttpServerExchange serverExchange);
+    IoFuture<Session> getOrCreateSession(final HttpServerExchange serverExchange, final SessionCookieConfig sessionCookieConfig);
 
     /**
      *
      * @param sessionId The session id
      * @return An IoFuture that can be used to retrieve the session, or an IoFuture that will return null if not found
      */
-    IoFuture<Session> getSession(final HttpServerExchange serverExchange);
+    IoFuture<Session> getSession(final HttpServerExchange serverExchange, final SessionCookieConfig sessionCookieConfig);
 
     /**
      * Registers a session listener for the session manager

File: core/src/test/java/io/undertow/test/session/inmemory/InMemorySessionTestCase.java
Patch:
@@ -29,6 +29,7 @@
 import io.undertow.server.session.InMemorySessionManager;
 import io.undertow.server.session.Session;
 import io.undertow.server.session.SessionAttachmentHandler;
+import io.undertow.server.session.SessionCookieConfig;
 import io.undertow.server.session.SessionManager;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
@@ -66,7 +67,7 @@ public void handleRequest(final HttpServerExchange exchange, final HttpCompletio
                         Session session = exchange.getAttachment(Session.ATTACHMENT_KEY);
                         if(session == null) {
                             final SessionManager manager = exchange.getAttachment(SessionManager.ATTACHMENT_KEY);
-                            session = manager.getOrCreateSession(exchange).get();
+                            session = manager.getOrCreateSession(exchange, exchange.getAttachment(SessionCookieConfig.ATTACHMENT_KEY)).get();
                             session.setAttribute(COUNT, 0);
                         }
                         Integer count = (Integer)session.getAttribute(COUNT).get();

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -60,7 +60,6 @@
 import io.undertow.servlet.handlers.ServletInitialHandler;
 import io.undertow.servlet.handlers.ServletMatchingHandler;
 import io.undertow.servlet.handlers.ServletPathMatches;
-import io.undertow.servlet.handlers.ServletSessionCookieConfigHandler;
 import io.undertow.servlet.spec.AsyncContextImpl;
 import io.undertow.servlet.spec.ServletContextImpl;
 import io.undertow.servlet.util.ImmediateInstanceFactory;
@@ -463,7 +462,7 @@ public HttpHandler start() throws ServletException {
         for (Lifecycle object : deployment.getLifecycleObjects()) {
             object.start();
         }
-        HttpHandler root = new ServletSessionCookieConfigHandler(deployment.getServletHandler(), deployment.getServletContext());
+        HttpHandler root = deployment.getServletHandler();
 
         //create the executor, if it exists
         if (deployment.getDeploymentInfo().getExecutorFactory() != null) {

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletInitialHandler.java
Patch:
@@ -145,6 +145,7 @@ private void handleFirstRequest(final BlockingHttpServerExchange exchange, final
                 exchange.getExchange().putAttachment(HttpServletRequestImpl.ATTACHMENT_KEY, request);
                 exchange.getExchange().putAttachment(HttpServletResponseImpl.ATTACHMENT_KEY, response);
             }
+
             next.handleRequest(exchange);
             if (!exchange.getExchange().isResponseStarted() && exchange.getExchange().getResponseCode() >= 400) {
                 String location = servletContext.getDeployment().getErrorPages().getErrorLocation(exchange.getExchange().getResponseCode());

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -151,7 +151,7 @@ private void initializeTempDir(final ServletContextImpl servletContext, final De
     }
 
     private void initializeMimeMappings(final DeploymentImpl deployment, final DeploymentInfo deploymentInfo) {
-        final Map<String, String> mappings = new HashMap<String, String>();
+        final Map<String, String> mappings = new HashMap<String, String>(MimeMapping.DEFAULT_MIME_MAPPINGS);
         for (MimeMapping mapping : deploymentInfo.getMimeMappings()) {
             mappings.put(mapping.getExtension(), mapping.getMimeType());
         }

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -38,6 +38,7 @@
 import io.undertow.server.handlers.AttachmentHandler;
 import io.undertow.server.handlers.blocking.BlockingHttpHandler;
 import io.undertow.servlet.UndertowServletMessages;
+import io.undertow.servlet.api.DefaultServletConfig;
 import io.undertow.servlet.api.Deployment;
 import io.undertow.servlet.api.DeploymentInfo;
 import io.undertow.servlet.api.DeploymentManager;
@@ -243,7 +244,8 @@ private ServletPathMatches setupServletChains(final ServletContextImpl servletCo
         }
 
         if (defaultServlet == null) {
-            DefaultServlet defaultInstance = new DefaultServlet(deployment, deploymentInfo.getWelcomePages());
+            final DefaultServletConfig config = deploymentInfo.getDefaultServletConfig() == null ? new DefaultServletConfig() : deploymentInfo.getDefaultServletConfig();
+            DefaultServlet defaultInstance = new DefaultServlet(deployment, config, deploymentInfo.getWelcomePages());
             final ManagedServlet managedDefaultServlet = new ManagedServlet(new ServletInfo("io.undertow.DefaultServlet", DefaultServlet.class, new ImmediateInstanceFactory<Servlet>(defaultInstance)), servletContext);
             lifecycles.add(managedDefaultServlet);
             defaultServlet = new ServletHandler(managedDefaultServlet);

File: websockets/src/main/java/io/undertow/websockets/protocol/WebSocketFixedPayloadFrameSourceChannel.java
Patch:
@@ -34,7 +34,7 @@
  */
 public abstract class WebSocketFixedPayloadFrameSourceChannel extends StreamSourceFrameChannel {
 
-    protected int readBytes;
+    protected long readBytes;
 
     protected WebSocketFixedPayloadFrameSourceChannel(WebSocketChannel.StreamSourceChannelControl streamSourceChannelControl, StreamSourceChannel channel, WebSocketChannel wsChannel, WebSocketFrameType type, long payloadSize, int rsv, boolean finalFragment) {
         super(streamSourceChannelControl, channel, wsChannel, type, payloadSize, rsv, finalFragment);
@@ -56,7 +56,7 @@ protected long transferTo0(long position, long count, FileChannel target) throws
         }
 
         long r = channel.transferTo(position, count, target);
-        readBytes += (int) r;
+        readBytes += r;
         return r;
     }
 
@@ -71,7 +71,7 @@ public long transferTo0(long count, ByteBuffer throughBuffer, StreamSinkChannel
             count = toRead;
         }
         long r = channel.transferTo(count, throughBuffer, target);
-        readBytes += (int) (r + throughBuffer.remaining());
+        readBytes += r + throughBuffer.remaining();
         return r;
     }
 

File: websockets/src/main/java/io/undertow/websockets/protocol/version07/WebSocket07FrameSinkChannel.java
Patch:
@@ -75,7 +75,7 @@ protected ByteBuffer createFrameStart() {
             header.put((byte) b0);
             header.put((byte)payloadSize);
         } else if (payloadSize <= 0xFFFF) {
-            header = ByteBuffer.allocate(3 + maskLength);
+            header = ByteBuffer.allocate(4 + maskLength);
             header.put((byte) b0);
             header.put((byte) 126);
             header.put((byte) (payloadSize >>> 8 & 0xFF));

File: websockets/src/main/java/io/undertow/websockets/protocol/Handshake.java
Patch:
@@ -88,8 +88,8 @@ protected String getWebSocketLocation(HttpServerExchange exchange) {
      */
     protected void performUpgrade(final ConcreteIoFuture<WebSocketChannel> ioFuture, final HttpServerExchange exchange, final byte[] data) {
         exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, "" + data.length);
-        exchange.getResponseHeaders().put(Headers.UPGRADE, "websocket");
-        exchange.getResponseHeaders().put(Headers.CONNECTION, "upgrade");
+        exchange.getResponseHeaders().put(Headers.UPGRADE, "WebSocket");
+        exchange.getResponseHeaders().put(Headers.CONNECTION, "Upgrade");
 
         exchange.upgradeChannel();
         final StreamSinkChannel channel = exchange.getResponseChannelFactory().create();

File: parser-generator/src/main/java/io/undertow/annotationprocessor/HttpParserAnnotationProcessor.java
Patch:
@@ -56,6 +56,9 @@ public boolean process(final Set<? extends TypeElement> annotations, final Round
 
         for (Element element : roundEnv.getElementsAnnotatedWith(HttpParserConfig.class)) {
             final HttpParserConfig parser = element.getAnnotation(HttpParserConfig.class);
+            if(parser == null) {
+                continue;
+            }
             final byte[] newClass = ParserGenerator.createTokenizer(((TypeElement)element).getQualifiedName().toString(), parser.methods(), parser.protocols(), parser.headers());
             try {
                 JavaFileObject file = filer.createClassFile(((TypeElement) element).getQualifiedName() + ParserGenerator.CLASS_NAME_SUFFIX, element);

File: servlet/src/main/java/io/undertow/servlet/spec/RequestDispatcherImpl.java
Patch:
@@ -128,6 +128,9 @@ public void forward(final ServletRequest request, final ServletResponse response
                 exchange.getExchange().putAttachment(HttpServletRequestImpl.ATTACHMENT_KEY, request);
                 exchange.getExchange().putAttachment(HttpServletResponseImpl.ATTACHMENT_KEY, response);
                 handler.handleRequest(exchange);
+                //if the forward completed sucessfully we need to complete the request
+                responseImpl.flushBuffer();
+                responseImpl.responseDone(exchange.getCompletionHandler());
             } catch (ServletException e) {
                 throw e;
             } catch (IOException e) {

File: websockets/src/main/java/io/undertow/websockets/protocol/version00/WebSocket00Channel.java
Patch:
@@ -75,6 +75,7 @@ public void handle(final ByteBuffer buffer, final PushBackStreamChannel channel)
                 if (!buffer.hasRemaining()) {
                     return;
                 }
+
                 if (receivedClosingHandshake) {
                     // discard everything as we received a close frame before
                     buffer.clear();
@@ -93,6 +94,7 @@ public void handle(final ByteBuffer buffer, final PushBackStreamChannel channel)
                             state = State.TEXT_FRAME;
                         }
                     case NON_TEXT_FRAME:
+
                         if (buffer.remaining() < 1) {
                             return;
                         }
@@ -116,6 +118,7 @@ public void handle(final ByteBuffer buffer, final PushBackStreamChannel channel)
                         } while ((b & 0x80) == 0x80);
                         state = State.FRAME_SIZE_READ;
                     case FRAME_SIZE_READ:
+                        System.out.println(frameSize);
                         if (frameSize == 0) {
                             receivedClosingHandshake = true;
                             this.channel = new WebSocket00CloseFrameSourceChannel(streamSourceChannelControl, channel, WebSocket00Channel.this);

File: websockets/src/main/java/io/undertow/websockets/protocol/version07/WebSocket07PingFrameSinkChannel.java
Patch:
@@ -26,7 +26,7 @@
  */
 public class WebSocket07PingFrameSinkChannel extends WebSocket07FrameSinkChannel {
     public WebSocket07PingFrameSinkChannel(StreamSinkChannel channel, WebSocket07Channel wsChannel, long payloadSize) {
-        super(channel, wsChannel, WebSocketFrameType.CLOSE, payloadSize);
+        super(channel, wsChannel, WebSocketFrameType.PING, payloadSize);
         if (payloadSize > 125) {
             throw WebSocketMessages.MESSAGES.invalidPayloadLengthForPing(payloadSize);
         }

File: websockets/src/main/java/io/undertow/websockets/protocol/version07/WebSocket07Channel.java
Patch:
@@ -121,7 +121,6 @@ private void protocolViolation(PushBackStreamChannel channel, String reason) thr
 
             @Override
             public void handle(final ByteBuffer buffer, final PushBackStreamChannel channel) throws WebSocketException {
-                //TODO: deal with the case where we can't read all the data at once
                 if (!buffer.hasRemaining()) {
                     return;
                 }

File: core/src/main/java/io/undertow/util/MultipartParser.java
Patch:
@@ -246,7 +246,8 @@ private void entity(final ByteBuffer buffer) {
                             //we have our data
                             ByteBuffer retBuffer = buffer.duplicate();
                             retBuffer.position(pos);
-                            retBuffer.limit(buffer.position() - boundary.length);
+
+                            retBuffer.limit(Math.max(buffer.position() - boundary.length, 0));
                             encodingHandler.handle(partHandler, retBuffer);
                             partHandler.endPart();
                             subState = -1;

File: core/src/main/java/io/undertow/UndertowOptions.java
Patch:
@@ -41,7 +41,7 @@ public class UndertowOptions {
     /**
      * The maximum size of the HTTP entity body.
      */
-    public static final Option<Long> MAX_ENTITY_SIZE = Option.simple(UndertowOptions.class, "MAX_HEADER_SIZE", Long.class);
+    public static final Option<Long> MAX_ENTITY_SIZE = Option.simple(UndertowOptions.class, "MAX_ENTITY_SIZE", Long.class);
 
     public static final long DEFAULT_MAX_ENTITY_SIZE = 10 * 1024 * 1024;
 

File: core/src/main/java/io/undertow/server/handlers/NameVirtualHostHandler.java
Patch:
@@ -46,6 +46,7 @@ public void handleRequest(final HttpServerExchange exchange, final HttpCompletio
             final HttpHandler handler = hosts.get(host.getFirst());
             if(handler != null) {
                 HttpHandlers.executeHandler(handler, exchange, completionHandler);
+                return;
             }
         }
         HttpHandlers.executeHandler(defaultHandler, exchange, completionHandler);

File: servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java
Patch:
@@ -63,7 +63,7 @@ public class DefaultServlet extends HttpServlet implements HttpHandler {
     private final Deployment deployment;
     private volatile FileCache fileCache = DirectFileCache.INSTANCE;
 
-    private volatile boolean defaultAllowed = false;
+    private volatile boolean defaultAllowed = true;
 
     private final Set<String> allowed = Collections.newSetFromMap(new CopyOnWriteMap<String, Boolean>());
     private final Set<String> disallowed = Collections.newSetFromMap(new CopyOnWriteMap<String, Boolean>());

File: websockets/src/main/java/io/undertow/websockets/WebSocketChannel.java
Patch:
@@ -380,6 +380,7 @@ protected final void complete(StreamSinkFrameChannel channel) {
         if (senders.peek() == channel) {
             if (senders.remove(channel)) {
                 StreamSinkFrameChannel ch = senders.peek();
+                // check if there is some sink waiting
                 if (ch != null) {
                     ch.activate();
                 }

File: core/src/main/java/io/undertow/server/handlers/security/AuthenticationInfoToken.java
Patch:
@@ -60,7 +60,7 @@ public String getName() {
         return name;
     }
 
-    public boolean isQuoted() {
+    public boolean isAllowQuoted() {
         return quoted;
     }
 

File: core/src/main/java/io/undertow/server/handlers/security/DigestAuthorizationToken.java
Patch:
@@ -69,7 +69,7 @@ public String getName() {
     }
 
     @Override
-    public boolean isQuoted() {
+    public boolean isAllowQuoted() {
         return quoted;
     }
 

File: core/src/main/java/io/undertow/server/handlers/security/DigestWWWAuthenticateToken.java
Patch:
@@ -64,7 +64,7 @@ public String getName() {
         return name;
     }
 
-    public boolean isQuoted() {
+    public boolean isAllowQuoted() {
         return quoted;
     }
 

File: core/src/main/java/io/undertow/util/Headers.java
Patch:
@@ -204,7 +204,7 @@ private Headers() {
     public static final HttpString QOP = new HttpString("qop");
     public static final HttpString REALM = new HttpString("realm");
     public static final HttpString RESPONSE = new HttpString("response");
-    public static final HttpString RESPONSE_AUTH = new HttpString("response-auth");
+    public static final HttpString RESPONSE_AUTH = new HttpString("rspauth");
     public static final HttpString STALE = new HttpString("stale");
     public static final HttpString URI = new HttpString("uri");
     public static final HttpString USERNAME = new HttpString("username");

File: core/src/test/java/io/undertow/test/handlers/security/DigestAuthenticationAuthTestCase.java
Patch:
@@ -184,6 +184,8 @@ public void testDigestSuccess() throws Exception {
             values = result.getHeaders("ProcessedBy");
             assertEquals(1, values.length);
             assertEquals("ResponseHandler", values[0].getValue());
+            
+            // We are sending these quickly so don't expect a replacement nonce.
 
             //values = result.getHeaders("Authentication-Info");
             //assertEquals(1, values.length);

File: websockets/src/main/java/io/undertow/websockets/protocol/version00/WebSocket00BinaryFrameSinkChannel.java
Patch:
@@ -66,7 +66,6 @@ protected ByteBuffer createFrameStart() {
             buffer.put((byte) (b3 | 0x80));
             buffer.put((byte) b4);
         }
-        buffer.flip();
         return buffer;
     }
 

File: websockets/src/main/java/io/undertow/websockets/server/WebSocket13ServerHandshaker.java
Patch:
@@ -12,7 +12,7 @@
 import io.undertow.websockets.WebSocketHandshakeException;
 import io.undertow.websockets.WebSocketMessages;
 import io.undertow.websockets.WebSocketVersion;
-import io.undertow.websockets.version08.WebSocket08Channel;
+import io.undertow.websockets.version13.WebSocket13Channel;
 import org.xnio.IoFuture;
 
 /**
@@ -104,7 +104,7 @@ public IoFuture<WebSocketChannel> handshake(final HttpServerExchange exchange) t
 
     @Override
     protected WebSocketChannel createChannel(final HttpServerExchange exchange) {
-        return new WebSocket08Channel(exchange.getConnection().getChannel(), exchange.getConnection().getBufferPool(), getWebSocketUrl());
+        return new WebSocket13Channel(exchange.getConnection().getChannel(), exchange.getConnection().getBufferPool(), getWebSocketUrl());
     }
 
 }

File: websockets/src/main/java/io/undertow/websockets/StreamSourceFrameChannel.java
Patch:
@@ -48,7 +48,7 @@ public abstract class StreamSourceFrameChannel implements StreamSourceChannel {
     private volatile boolean closed;
     private final boolean finalFragment;
     private boolean complete;
-    
+
     public StreamSourceFrameChannel(final WebSocketChannel.StreamSourceChannelControl streamSourceChannelControl, StreamSourceChannel channel, WebSocketChannel wsChannel, WebSocketFrameType type, boolean finalFragment) {
         this.streamSourceChannelControl = streamSourceChannelControl;
         this.channel = channel;
@@ -123,7 +123,7 @@ public final long transferTo(long position, long count, FileChannel target) thro
             }
         }
     }
-    
+
     protected abstract long transferTo0(long position, long count, FileChannel target) throws IOException;
 
     @Override

File: websockets/src/main/java/io/undertow/websockets/WebSocketChannel.java
Patch:
@@ -318,7 +318,7 @@ public StreamSinkFrameChannel send(WebSocketFrameType type, long payloadSize) {
         StreamSinkFrameChannel ch = create(channel, type, payloadSize);
         boolean o = senders.offer(ch);
         assert o;
-        
+
         if (isInUse(ch)) {
             // Channel is first in the queue so mark it as active
             ch.active();

File: websockets/src/main/java/io/undertow/websockets/version00/WebSocket00BinaryFrameSourceChannel.java
Patch:
@@ -127,10 +127,8 @@ protected long read0(ByteBuffer[] dsts, int offset, int length) throws IOExcepti
                 dsts[i].limit(old[i - offset]);
             }
         }
-
     }
 
-    
     private int byteToRead() {
         return payloadSize - readBytes;
     }

File: websockets/src/main/java/io/undertow/websockets/version00/WebSocket00TextFrameSourceChannel.java
Patch:
@@ -150,7 +150,7 @@ public long transferTo0(long count, ByteBuffer throughBuffer, StreamSinkChannel
                     // to make sure we not read to much
                     throughBuffer.limit((int) toRead);
                 }
-                
+
                 // check if the read operation marked it as complete and if so just return
                 // now
                 if (complete) {
@@ -272,6 +272,4 @@ public long read0(ByteBuffer[] bufs, int index, int length) throws IOException {
     protected boolean isComplete() {
         return complete;
     }
-    
-
 }

File: websockets/src/main/java/io/undertow/websockets/WebSocketChannel.java
Patch:
@@ -98,7 +98,7 @@ public Pool<ByteBuffer> getBufferPool() {
         return bufferPool;
     }
 
-    protected final boolean isInUse(StreamSinkChannel channel) {
+    protected boolean isInUse(StreamSinkChannel channel) {
         return currentSender.peek() == channel;
     }
 
@@ -219,7 +219,6 @@ public StreamSourceFrameChannel receive() throws IOException {
                 partialFrame = receiveFrame(new StreamSourceChannelControl());
             }
 
-            StreamSourceFrameChannel sourceChannel = null;
             int res;
             while (!partialFrame.isDone()) {
                 buffer.clear();
@@ -374,6 +373,7 @@ protected final void complete(StreamSinkFrameChannel channel) {
      * {@link ChannelListener} which delegates the read notification to the appropriate listener
      */
     private final class WebSocketReadListener implements ChannelListener<PushBackStreamChannel> {
+        @SuppressWarnings({ "unchecked", "rawtypes" })
         @Override
         public void handleEvent(final PushBackStreamChannel channel) {
             final StreamSourceFrameChannel receiver = WebSocketChannel.this.receiver;

File: websockets/src/test/java/io/undertow/websockets/version00/WebSocket00ChannelTest.java
Patch:
@@ -82,6 +82,7 @@ private static void checkSend(WebSocketFrameType type, int size, Class<? extends
         expect(mockChannel.getReadSetter()).andReturn(new ChannelListener.SimpleSetter());
         expect(mockChannel.getWriteSetter()).andReturn(new ChannelListener.SimpleSetter());
         expect(mockChannel.isOpen()).andReturn(true);
+        mockChannel.resumeWrites();
         replay(mockChannel);
        
 

File: websockets/src/main/java/io/undertow/websockets/StreamSourceFrameChannel.java
Patch:
@@ -28,7 +28,6 @@
 import org.xnio.Option;
 import org.xnio.XnioExecutor;
 import org.xnio.XnioWorker;
-import org.xnio.channels.PushBackStreamChannel;
 import org.xnio.channels.StreamSourceChannel;
 
 /**
@@ -38,14 +37,14 @@ public abstract class StreamSourceFrameChannel implements StreamSourceChannel {
 
     protected final WebSocketChannel.StreamSourceChannelControl streamSourceChannelControl;
     protected final WebSocketFrameType type;
-    protected final PushBackStreamChannel channel;
+    protected final StreamSourceChannel channel;
     protected final WebSocketChannel wsChannel;
 
     private final SimpleSetter<? extends StreamSourceFrameChannel> readSetter = new SimpleSetter<StreamSourceFrameChannel>();
     private final SimpleSetter<StreamSourceFrameChannel> closeSetter = new SimpleSetter<StreamSourceFrameChannel>();
     private volatile boolean closed;
 
-    public StreamSourceFrameChannel(final WebSocketChannel.StreamSourceChannelControl streamSourceChannelControl, PushBackStreamChannel channel, WebSocketChannel wsChannel, WebSocketFrameType type) {
+    public StreamSourceFrameChannel(final WebSocketChannel.StreamSourceChannelControl streamSourceChannelControl, StreamSourceChannel channel, WebSocketChannel wsChannel, WebSocketFrameType type) {
         this.streamSourceChannelControl = streamSourceChannelControl;
         this.channel = channel;
         this.wsChannel = wsChannel;

File: websockets/src/main/java/io/undertow/websockets/WebSocketChannel.java
Patch:
@@ -378,9 +378,9 @@ public void handleEvent(final PushBackStreamChannel channel) {
     }
 
 
-    private class WebSocketWriteListener implements ChannelListener<WebSocketChannel> {
+    private class WebSocketWriteListener implements ChannelListener<ConnectedStreamChannel> {
         @Override
-        public void handleEvent(final WebSocketChannel channel) {
+        public void handleEvent(final ConnectedStreamChannel channel) {
 
         }
     }

File: websockets/src/main/java/io/undertow/websockets/version00/WebSocket00CloseFrameSourceChannel.java
Patch:
@@ -23,6 +23,7 @@
 import java.nio.channels.FileChannel;
 
 import io.undertow.websockets.WebSocketChannel;
+
 import org.xnio.channels.StreamSinkChannel;
 import org.xnio.channels.StreamSourceChannel;
 

File: websockets/src/main/java/io/undertow/websockets/version00/WebSocket00TextFrameSourceChannel.java
Patch:
@@ -40,7 +40,7 @@ class WebSocket00TextFrameSourceChannel extends StreamSourceFrameChannel {
     private static final byte END_FRAME_MARKER = (byte) 0xFF;
     private boolean complete = false;
 
-    WebSocket00TextFrameSourceChannel(WebSocketChannel.StreamSourceChannelControl streamSourceChannelControl,PushBackStreamChannel channel, WebSocket00Channel wsChannel) {
+    WebSocket00TextFrameSourceChannel(WebSocketChannel.StreamSourceChannelControl streamSourceChannelControl, PushBackStreamChannel channel, WebSocket00Channel wsChannel) {
         super(streamSourceChannelControl, channel, wsChannel, WebSocketFrameType.TEXT);
     }
 
@@ -82,7 +82,7 @@ public long transferTo(long position, long count, FileChannel target) throws IOE
                         if (written == 0) {
                             if (buf.hasRemaining()) {
                                 // nothing could be written and the buffer has something left in there, so push it back to the channel
-                                channel.unget(pooled);
+                                ((PushBackStreamChannel) channel).unget(pooled);
                                 free = false;
                             }
                             return r;

File: websockets/src/test/java/io/undertow/websockets/version00/WebSocket00ChannelTest.java
Patch:
@@ -76,6 +76,7 @@ private static void checkSend(WebSocketFrameType type, int size, Class<? extends
         ConnectedStreamChannel mockChannel = createMock(ConnectedStreamChannel.class);
         expect(mockChannel.getCloseSetter()).andReturn(new ChannelListener.SimpleSetter()).times(2);
         expect(mockChannel.getReadSetter()).andReturn(new ChannelListener.SimpleSetter());
+        expect(mockChannel.getWriteSetter()).andReturn(new ChannelListener.SimpleSetter());
         expect(mockChannel.isOpen()).andReturn(true);
         replay(mockChannel);
        

File: websockets/src/main/java/io/undertow/websockets/version00/WebSocket00TextFrameSourceChannel.java
Patch:
@@ -122,9 +122,6 @@ public long transferTo(long count, ByteBuffer throughBuffer, StreamSinkChannel t
             long r = 0;
             while (r < count) {
                 int i = read(throughBuffer);
-                if (r == 0 || r == -1) {
-                    return -1;
-                }
 
                 if (i < 1) {
                     return r;

File: websockets/src/main/java/io/undertow/websockets/version00/WebSocket00TextFrameSourceChannel.java
Patch:
@@ -37,7 +37,7 @@
  */
 class WebSocket00TextFrameSourceChannel extends StreamSourceFrameChannel {
 
-    private final byte END_FRAME_MARKER = (byte) 0xFF;
+    private static final byte END_FRAME_MARKER = (byte) 0xFF;
     private boolean complete = false;
 
     WebSocket00TextFrameSourceChannel(WebSocketChannel.StreamSourceChannelControl streamSourceChannelControl,PushBackStreamChannel channel, WebSocket00Channel wsChannel) {
@@ -82,7 +82,7 @@ public long transferTo(long position, long count, FileChannel target) throws IOE
                         if (written == 0) {
                             if (buf.hasRemaining()) {
                                 // nothing could be written and the buffer has something left in there, so push it back to the channel
-                                ((PushBackStreamChannel) channel).unget(pooled);
+                                channel.unget(pooled);
                                 free = false;
                             }
                             return r;
@@ -122,7 +122,7 @@ public long transferTo(long count, ByteBuffer throughBuffer, StreamSinkChannel t
             long r = 0;
             while (r < count) {
                 int i = read(throughBuffer);
-                if (r == 0 && r == -1) {
+                if (r == 0 || r == -1) {
                     return -1;
                 }
 

File: websockets/src/main/java/io/undertow/websockets/WebSocketException.java
Patch:
@@ -19,14 +19,13 @@
 
 /**
  * Base class for all WebSocket Exceptions
- * 
- * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  *
+ * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
 public class WebSocketException extends Exception {
 
     /**
-     * 
+     *
      */
     private static final long serialVersionUID = -6784834646314672530L;
 

File: websockets/src/main/java/io/undertow/websockets/WebSocketVersion.java
Patch:
@@ -27,7 +27,7 @@
  * A specification is tied to one wire protocol version but a protocol version may have use by more than 1 version of
  * the specification.
  * </p>
- * 
+ *
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
 public enum WebSocketVersion {

File: websockets/src/main/java/io/undertow/websockets/WebSocketVersionNotSupportedException.java
Patch:
@@ -20,14 +20,13 @@
 /**
  * Special {@link WebSocketHandshakeException} which is thrown if the requested WebSocket Version is not
  * supported.
- * 
- * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  *
+ * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
 public class WebSocketVersionNotSupportedException extends WebSocketHandshakeException {
 
     /**
-     * 
+     *
      */
     private static final long serialVersionUID = 1508553157345558990L;
 

File: websockets/src/main/java/io/undertow/websockets/version00/WebSocket00BinaryFrameSourceChannel.java
Patch:
@@ -29,14 +29,14 @@
 
 /**
  * {@link StreamSourceFrameChannel} implementations for read {@link WebSocketFrameType#BINARY}
- * 
- * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  *
+ * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
 class WebSocket00BinaryFrameSourceChannel extends StreamSourceFrameChannel {
 
     private final int payloadSize;
     private int readBytes;
+
     WebSocket00BinaryFrameSourceChannel(StreamSourceChannel channel, WebSocket00Channel wsChannel, int payloadSize) {
         super(channel, wsChannel, WebSocketFrameType.BINARY);
         this.payloadSize = payloadSize;
@@ -126,6 +126,6 @@ public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {
     }
 
     private int byteToRead() {
-       return payloadSize - readBytes;
+        return payloadSize - readBytes;
     }
 }

File: websockets/src/main/java/io/undertow/websockets/version00/WebSocket00CloseFrameSourceChannel.java
Patch:
@@ -31,9 +31,8 @@
 
 /**
  * {@link StreamSourceFrameChannel} which allows to read WebSocketFrames of type {@link WebSocketFrameType#CLOSE}
- * 
- * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  *
+ * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
 class WebSocket00CloseFrameSourceChannel extends StreamSourceFrameChannel {
 

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -100,7 +100,7 @@ public final class HttpServerExchange extends AbstractAttachable {
     /**
      * The resolved part of the canonical path.
      */
-    private volatile String resolvedPath = "/";
+    private volatile String resolvedPath = "";
 
     /**
      * the query string

File: servlet/src/main/java/io/undertow/servlet/core/ErrorPages.java
Patch:
@@ -41,6 +41,9 @@ public String getErrorLocation(final int code) {
     }
 
     public String getErrorLocation(final Throwable exception) {
+        if(exception == null) {
+            return null;
+        }
         //todo: this is kinda slow, but there is probably not a great deal that can be done about it
         String e = null;
         for(Class c = exception.getClass(); c != null && e == null; c = c.getSuperclass()) {

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -112,6 +112,8 @@ public void deploy() {
         ThreadSetupAction.Handle handle = threadSetupAction.setup(null);
         try {
 
+            final ApplicationListeners listeners = createListeners();
+            deployment.setApplicationListeners(listeners);
             //first run the SCI's
             for (final ServletContainerInitializerInfo sci : deploymentInfo.getServletContainerInitializers()) {
                 final InstanceHandle<? extends ServletContainerInitializer> instance = sci.getInstanceFactory().createInstance();
@@ -122,8 +124,6 @@ public void deploy() {
                 }
             }
 
-            final ApplicationListeners listeners = createListeners();
-            deployment.setApplicationListeners(listeners);
             listeners.contextInitialized();
             initializeErrorPages(deployment, deploymentInfo);
             initializeMimeMappings(deployment, deploymentInfo);

File: servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java
Patch:
@@ -199,7 +199,8 @@ private boolean isAllowed(String path) {
         }
         int ext = lastSegment.lastIndexOf('.');
         if (ext == -1) {
-            return defaultAllowed;
+            //no extension
+            return true;
         }
         final String extension = lastSegment.substring(ext + 1, lastSegment.length());
         if (defaultAllowed) {

File: core/src/main/java/io/undertow/server/handlers/file/FileHandler.java
Patch:
@@ -179,7 +179,7 @@ public static void renderDirectoryListing(HttpServerExchange exchange, HttpCompl
             builder.append("<tr class='").append((++i & 1) == 1 ? "odd" : "even").append("'><td><a class='icon ");
             builder.append(entry.isFile() ? "file" : "dir");
             builder.append("' href='").append(entry.getName()).append("'>").append(entry.getName()).append("</a></td><td>");
-            builder.append(format.format(new Date(file.lastModified()))).append("</td><td>");
+            builder.append(format.format(new Date(entry.lastModified()))).append("</td><td>");
             if (entry.isFile()) {
                 formatSize(builder, entry.length());
             } else {

File: core/src/main/java/io/undertow/server/handlers/security/SecurityInitialHandler.java
Patch:
@@ -52,8 +52,6 @@ public SecurityInitialHandler(final HttpHandler next) {
     public void handleRequest(HttpServerExchange exchange, HttpCompletionHandler completionHandler) {
         SecurityContext existingContext = exchange.getAttachment(SecurityContext.ATTACHMENT_KEY);
         SecurityContext newContext = new SecurityContext();
-        // TODO - At this point make authentication mandatory - will subsequently add a filter.
-        newContext.setAuthenticationState(AuthenticationState.REQUIRED);
         exchange.putAttachment(SecurityContext.ATTACHMENT_KEY, newContext);
 
         HttpCompletionHandler wrapperHandler = new InitialCompletionHandler(exchange, existingContext, completionHandler);

File: core/src/main/java/io/undertow/util/ConcreteIoFuture.java
Patch:
@@ -26,7 +26,7 @@
 /**
 * @author Stuart Douglas
 */
-public class ImmediateIoFuture<T> extends AbstractIoFuture<T> {
+public class ConcreteIoFuture<T> extends AbstractIoFuture<T> {
     @Override
     public boolean setResult(final T result) {
         return super.setResult(result);

File: servlet/src/main/java/io/undertow/servlet/spec/HttpSessionImpl.java
Patch:
@@ -134,7 +134,7 @@ public void setAttribute(final String name, final Object value) {
             } else if(old == null) {
                 applicationListeners.httpSessionAttributeAdded(this, name, value);
             } else {
-                applicationListeners.httpSessionAttributeReplaced(this, name, value);
+                applicationListeners.httpSessionAttributeReplaced(this, name, old);
             }
         } catch (IOException e) {
             throw new RuntimeException(e);

File: servlet/src/main/java/io/undertow/servlet/spec/ServletContextImpl.java
Patch:
@@ -123,7 +123,7 @@ public String getMimeType(final String file) {
         if(pos == -1) {
             return deployment.getMimeExtensionMappings().get(file);
         }
-        return deployment.getMimeExtensionMappings().get(file.substring(pos));
+        return deployment.getMimeExtensionMappings().get(file.substring(pos +1));
     }
 
     @Override

File: servlet/src/main/java/io/undertow/servlet/spec/RequestDispatcherImpl.java
Patch:
@@ -194,7 +194,7 @@ public void include(final ServletRequest request, final ServletResponse response
             requestImpl.setQueryParameters(newQueryParameters);
 
             request.setAttribute(INCLUDE_REQUEST_URI, newRequestUri);
-            request.setAttribute(INCLUDE_CONTEXT_PATH, servletContext);
+            request.setAttribute(INCLUDE_CONTEXT_PATH, servletContext.getContextPath());
             request.setAttribute(INCLUDE_SERVLET_PATH, newServletPath);
             request.setAttribute(INCLUDE_PATH_INFO, pathMatch.getRemaining());
             request.setAttribute(INCLUDE_QUERY_STRING, newQueryString);

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -225,7 +225,9 @@ private ServletPathMatches setupServletChains(final ServletContextImpl servletCo
             final ManagedServlet managedDefaultServlet = new ManagedServlet(new ServletInfo("DefaultServlet", DefaultServlet.class, new ImmediateInstanceFactory<Servlet>(defaultInstance)), servletContext);
             lifecycles.add(managedDefaultServlet);
             defaultServlet = new ServletHandler(managedDefaultServlet);
-            defaultHandler = new ServletInitialHandler(new RequestListenerHandler(listeners, defaultServlet), defaultInstance, threadSetupAction, servletContext, null);
+
+            ServletInfo defaultServletInfo = new ServletInfo("io.undertow.DefaultServlet", DefaultServlet.class, new ImmediateInstanceFactory<Servlet>(defaultInstance));
+            defaultHandler = new ServletInitialHandler(new RequestListenerHandler(listeners, defaultServlet), defaultInstance, threadSetupAction, servletContext, defaultServletInfo);
         }
 
         final ServletPathMatches.Builder builder = ServletPathMatches.builder();

File: servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java
Patch:
@@ -111,14 +111,13 @@ protected void doGet(final HttpServletRequest req, final HttpServletResponse res
     @Override
     public void handleRequest(final HttpServerExchange exchange, final HttpCompletionHandler completionHandler) {
         if (!isAllowed(exchange.getRelativePath())) {
+            //we don't call the completion handler, as we allow the initial handler to do error handling
             exchange.setResponseCode(404);
-            completionHandler.handleComplete();
             return;
         }
         File resource = deployment.getDeploymentInfo().getResourceLoader().getResource(exchange.getRelativePath());
         if (resource == null) {
             exchange.setResponseCode(404);
-            completionHandler.handleComplete();
             return;
         } else if (resource.isDirectory()) {
             handleWelcomePage(exchange, completionHandler, resource);

File: core/src/main/java/io/undertow/util/LocaleUtils.java
Patch:
@@ -29,7 +29,7 @@ public static Locale getLocaleFromString(String localeString) {
         if (localeString == null) {
             return null;
         }
-        final String[] parts = localeString.split("_");
+        final String[] parts = localeString.split("-");
         if(parts.length == 1) {
             return new Locale(localeString, "");
         } else if(parts.length == 2) {

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -689,7 +689,7 @@ public int getRemotePort() {
 
     @Override
     public String getLocalName() {
-        return null;
+        return exchange.getExchange().getDestinationAddress().getHostName();
     }
 
     @Override

File: core/src/main/java/io/undertow/util/SecureHashMap.java
Patch:
@@ -959,7 +959,7 @@ final class KeyIterator implements Iterator<K> {
 
         public boolean hasNext() {
             while (next == null) {
-                if (tableIdx == table.array.length()) {
+                if (tableIdx == table.array.length() && tableIterator == null) {
                     return false;
                 }
                 if (tableIterator == null) {
@@ -1011,7 +1011,7 @@ final class ValueIterator implements Iterator<V> {
 
         public boolean hasNext() {
             while (next == NONEXISTENT) {
-                if (tableIdx == table.array.length()) {
+                if (tableIdx == table.array.length() && tableIterator == null)  {
                     return false;
                 }
                 if (tableIterator == null) {

File: servlet/src/main/java/io/undertow/servlet/api/Deployment.java
Patch:
@@ -21,6 +21,7 @@
 import io.undertow.server.HttpHandler;
 import io.undertow.servlet.core.ApplicationListeners;
 import io.undertow.servlet.core.CompositeThreadSetupAction;
+import io.undertow.servlet.core.ErrorPages;
 import io.undertow.servlet.handlers.ServletPathMatches;
 import io.undertow.servlet.spec.ServletContextImpl;
 
@@ -40,4 +41,6 @@ public interface Deployment {
     ServletPathMatches getServletPaths();
 
     CompositeThreadSetupAction getThreadSetupAction();
+
+    ErrorPages getErrorPages();
 }

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletPathMatches.java
Patch:
@@ -19,7 +19,6 @@
 package io.undertow.servlet.handlers;
 
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.Map;
 
 /**
@@ -75,7 +74,7 @@ public ServletPathMatch getServletHandlerByPath(final String path) {
                 final String part = path.substring(0, i);
                 match = prefixMatches.get(part);
                 if (match != null) {
-                    return  handleMatch(path, match, part, part.substring(i));
+                    return  handleMatch(path, match, part, path.substring(i));
                 }
             }
         }

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -674,7 +674,7 @@ public RequestDispatcher getRequestDispatcher(final String path) {
             }
             realPath = CanonicalPathUtils.canonicalize(current + path);
         }
-        return new RequestDispatcherImpl(realPath, servletContext, servletContext.getDeployment().getServletPaths().getServletHandlerByPath(realPath));
+        return new RequestDispatcherImpl(realPath, servletContext);
     }
 
     @Override

File: servlet/src/main/java/io/undertow/servlet/spec/ServletContextImpl.java
Patch:
@@ -169,7 +169,7 @@ public InputStream getResourceAsStream(final String path) {
 
     @Override
     public RequestDispatcher getRequestDispatcher(final String path) {
-        return new RequestDispatcherImpl(path, deployment.getServletContext(), deployment.getServletPaths().getServletHandlerByPath(path));
+        return new RequestDispatcherImpl(path, deployment.getServletContext());
     }
 
     @Override

File: core/src/main/java/io/undertow/server/session/SessionAttachmentHandler.java
Patch:
@@ -27,6 +27,7 @@
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.handlers.Cookie;
+import io.undertow.server.handlers.CookieImpl;
 import io.undertow.server.handlers.HttpHandlers;
 import io.undertow.server.handlers.ResponseCodeHandler;
 import org.xnio.IoFuture;
@@ -103,7 +104,7 @@ public void notify(final IoFuture<? extends Session> ioFuture, final Session att
     }
 
     private String findSessionId(final HttpServerExchange exchange) {
-        Map<String, Cookie> cookies = Cookie.getRequestCookies(exchange);
+        Map<String, Cookie> cookies = CookieImpl.getRequestCookies(exchange);
         if(cookies != null) {
             Cookie sessionId = cookies.get(cookieName);
             if(sessionId != null) {

File: servlet/src/main/java/io/undertow/servlet/UndertowServletMessages.java
Patch:
@@ -124,4 +124,7 @@ public interface UndertowServletMessages {
 
     @Message(id = 10026, value = "Async is not supported for this request, as not all filters or Servlets were marked as supporting async")
     IllegalStateException startAsyncNotAllowed();
+
+    @Message(id = 10027, value = "Not implemented")
+    IllegalStateException notImplemented();
 }

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -55,13 +55,13 @@
 import javax.servlet.http.HttpSession;
 import javax.servlet.http.Part;
 
+import io.undertow.server.handlers.CookieImpl;
 import io.undertow.server.handlers.blocking.BlockingHttpServerExchange;
 import io.undertow.server.handlers.form.FormData;
 import io.undertow.server.handlers.form.FormDataParser;
 import io.undertow.server.handlers.form.MultiPartHandler;
 import io.undertow.server.session.Session;
 import io.undertow.server.session.SessionManager;
-import io.undertow.servlet.UndertowServletLogger;
 import io.undertow.servlet.UndertowServletMessages;
 import io.undertow.servlet.handlers.ServletPathMatch;
 import io.undertow.servlet.util.EmptyEnumeration;
@@ -123,7 +123,7 @@ public String getAuthType() {
     @Override
     public Cookie[] getCookies() {
         if (cookies == null) {
-            Map<String, io.undertow.server.handlers.Cookie> cookies = io.undertow.server.handlers.Cookie.getRequestCookies(exchange.getExchange());
+            Map<String, io.undertow.server.handlers.Cookie> cookies = CookieImpl.getRequestCookies(exchange.getExchange());
             if (cookies.isEmpty()) {
                 return null;
             }

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -78,7 +78,7 @@ public void addCookie(final Cookie cookie) {
             return;
         }
         final AttachmentList<io.undertow.server.handlers.Cookie> cookies = exchange.getExchange().getAttachment(io.undertow.server.handlers.Cookie.RESPONSE_COOKIES);
-        cookies.add(new io.undertow.server.handlers.Cookie(cookie.getName(), cookie.getValue()));
+        cookies.add(new ServletCookieAdaptor(cookie));
     }
 
     @Override

File: servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java
Patch:
@@ -170,7 +170,7 @@ private String findWelcomeResource(final File resource, final String path) {
         }
 
         for (String i : welcomePages) {
-            final ServletInitialHandler handler = deployment.getServletPaths().getServletHandlerByPath(path + i);
+            final ServletInitialHandler handler = deployment.getServletPaths().getServletHandlerByPath(path + i).getHandler();
             if(handler.getServletInfo() != null) {
                 return i;
             }

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletMatchingHandler.java
Patch:
@@ -39,7 +39,9 @@ public ServletMatchingHandler(final ServletPathMatches paths) {
     @Override
     public void handleRequest(final HttpServerExchange exchange, final HttpCompletionHandler completionHandler) {
         final String path = exchange.getRelativePath();
-        HttpHandlers.executeHandler(paths.getServletHandlerByPath(path), exchange, completionHandler);
+        ServletPathMatch info = paths.getServletHandlerByPath(path);
+        exchange.putAttachment(ServletPathMatch.ATTACHMENT_KEY, info);
+        HttpHandlers.executeHandler(info.getHandler(), exchange, completionHandler);
     }
 
     public ServletPathMatches getPaths() {

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletInitialHandler.java
Patch:
@@ -18,8 +18,6 @@
 
 package io.undertow.servlet.handlers;
 
-import java.util.concurrent.Executor;
-
 import javax.servlet.DispatcherType;
 
 import io.undertow.UndertowLogger;
@@ -129,7 +127,7 @@ private void handleFirstRequest(final BlockingHttpServerExchange exchange, final
         ThreadSetupAction.Handle handle = setupAction.setup(exchange);
         try {
             if (dispatcher == null) {
-                final HttpServletResponseImpl response = new HttpServletResponseImpl(exchange);
+                final HttpServletResponseImpl response = new HttpServletResponseImpl(exchange, servletContext);
                 HttpServletRequestImpl request = new HttpServletRequestImpl(exchange, servletContext);
                 exchange.getExchange().putAttachment(HttpServletRequestImpl.DISPATCHER_TYPE_ATTACHMENT_KEY, DispatcherType.REQUEST);
                 exchange.getExchange().putAttachment(HttpServletRequestImpl.ATTACHMENT_KEY, request);

File: servlet/src/main/java/io/undertow/servlet/spec/AsyncContextImpl.java
Patch:
@@ -159,6 +159,7 @@ public void dispatch(final String path) {
     public void dispatch(final ServletContext context, final String path) {
 
         HttpServletRequestImpl requestImpl = HttpServletRequestImpl.getRequestImpl(servletRequest);
+        HttpServletResponseImpl responseImpl = HttpServletResponseImpl.getResponseImpl(servletResponse);
         final ServletInitialHandler handler;
         final BlockingHttpServerExchange exchange = requestImpl.getExchange();
 
@@ -201,6 +202,7 @@ public void dispatch(final ServletContext context, final String path) {
         requestImpl.getExchange().getExchange().setRequestPath(newRequestUri);
         requestImpl.getExchange().getExchange().setRequestURI(newRequestUri);
         requestImpl.setServletContext((ServletContextImpl) context);
+        responseImpl.setServletContext((ServletContextImpl) context);
 
         Deployment deployment = requestImpl.getServletContext().getDeployment();
         handler = deployment.getServletPaths().getServletHandlerByPath(newServletPath);

File: core/src/main/java/io/undertow/server/HttpResponseChannel.java
Patch:
@@ -27,6 +27,7 @@
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
 import io.undertow.util.HeaderMap;
+import io.undertow.util.StatusCodes;
 import org.jboss.logging.Logger;
 import org.xnio.ChannelListener;
 import org.xnio.ChannelListeners;
@@ -147,7 +148,7 @@ private int processWrite(int state) throws IOException {
                     buffer.put((byte) (code / 10 % 10 + '0'));
                     buffer.put((byte) (code % 10 + '0'));
                     buffer.put((byte) ' ');
-                    string = "Put Response String Here"; // <-- TODO
+                    string = StatusCodes.getReason(code);
                     length = string.length();
                     for (charIndex = 0; charIndex < length; charIndex ++) {
                         buffer.put((byte) string.charAt(charIndex));

File: servlet/src/test/java/io/undertow/servlet/test/runner/ServletServer.java
Patch:
@@ -93,8 +93,8 @@ private static void runInternal(final RunNotifier notifier) {
                         .set(Options.WORKER_READ_THREADS, 4)
                         .set(Options.CONNECTION_HIGH_WATER, 1000000)
                         .set(Options.CONNECTION_LOW_WATER, 1000000)
-                        .set(Options.WORKER_TASK_CORE_THREADS, 10)
-                        .set(Options.WORKER_TASK_MAX_THREADS, 12)
+                        .set(Options.WORKER_TASK_CORE_THREADS, 30)
+                        .set(Options.WORKER_TASK_MAX_THREADS, 32)
                         .set(Options.TCP_NODELAY, true)
                         .set(Options.CORK, true)
                         .getMap());

File: servlet/src/main/java/io/undertow/servlet/api/DeploymentInfo.java
Patch:
@@ -202,6 +202,7 @@ public List<FilterMappingInfo> getFilterMappings() {
         return Collections.unmodifiableList(ret);
     }
 
+
     public DeploymentInfo addListener(final ListenerInfo listener) {
         listeners.add(listener);
         return this;

File: servlet/src/main/java/io/undertow/servlet/api/ClassIntrospecter.java
Patch:
@@ -35,6 +35,6 @@
  */
 public interface ClassIntrospecter {
 
-    <T> InstanceFactory<T> createInstanceFactory(final Class<T> clazz);
+    <T> InstanceFactory<T> createInstanceFactory(final Class<T> clazz) throws NoSuchMethodException;
 
 }

File: core/src/main/java/io/undertow/server/httpparser/HttpParser.java
Patch:
@@ -372,7 +372,7 @@ final int handleHeaderValue(ByteBuffer buffer, int remaining, ParseState state,
                         String headerValue = stringBuilder.toString();
 
                         //TODO: we need to decode this according to RFC-2047 if we have seen a =? symbol
-                        builder.headers.put(nextStandardHeader, headerValue);
+                        builder.headers.add(nextStandardHeader, headerValue);
 
                         state.nextHeader = null;
 

File: core/src/main/java/io/undertow/util/DateUtils.java
Patch:
@@ -35,7 +35,7 @@ public class DateUtils {
 
     private static final TimeZone GMT_ZONE = TimeZone.getTimeZone("GMT");
 
-    private static final String RFC1123_PATTERN = "EEE, dd MMM yyyyy HH:mm:ss z";
+    private static final String RFC1123_PATTERN = "EEE, dd MMM yyyy HH:mm:ss z";
 
     private static final String RFC1036_PATTERN = "EEEEEEEEE, dd-MMM-yy HH:mm:ss z";
 

File: servlet/src/main/java/io/undertow/servlet/core/DeploymentManagerImpl.java
Patch:
@@ -434,7 +434,9 @@ public void undeploy() {
             deployment.getApplicationListeners().stop();
             deployment = null;
         } finally {
-            executor.release();
+            if (executor != null) {
+                executor.release();
+            }
         }
     }
 

File: core/src/test/java/io/undertow/test/MaxRequestSizeTestCase.java
Patch:
@@ -62,6 +62,7 @@ public void handleRequest(final BlockingHttpServerExchange exchange) {
                     exchange.getOutputStream().close();
                 } catch (IOException e) {
                     try {
+                        exchange.getExchange().getResponseHeaders().put(Headers.CONNECTION, "close");
                         exchange.getExchange().setResponseCode(500);
                     } catch (Exception ignore) {
 

File: core/src/test/java/io/undertow/test/handlers/ChunkedRequestTransferCodingTestCase.java
Patch:
@@ -30,6 +30,7 @@
 import io.undertow.server.handlers.blocking.BlockingHttpServerExchange;
 import io.undertow.test.utils.DefaultServer;
 import io.undertow.test.utils.HttpClientUtils;
+import io.undertow.util.Headers;
 import org.apache.http.HttpHeaders;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpPost;
@@ -79,6 +80,7 @@ public void handleRequest(final BlockingHttpServerExchange exchange) {
                     exchange.getInputStream().close();
                     exchange.getOutputStream().close();
                 } catch (IOException e) {
+                    exchange.getExchange().getResponseHeaders().put(Headers.CONNECTION, "close");
                     exchange.getExchange().setResponseCode(500);
                     throw new RuntimeException(e);
                 }

File: core/src/main/java/io/undertow/server/handlers/form/FormData.java
Patch:
@@ -37,7 +37,7 @@
 public final class FormData implements Iterable<String> {
 
 
-    public static interface FormValue {
+    public interface FormValue {
 
         /**
          * @return the simple string value.

File: core/src/main/java/io/undertow/util/MultipartParser.java
Patch:
@@ -299,7 +299,7 @@ public static class MalformedMessageException extends Exception {
     }
 
 
-    private static interface Encoding {
+    private interface Encoding {
         void handle(final PartHandler handler, final ByteBuffer rawData);
     }
 

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -81,4 +81,6 @@ public interface UndertowMessages {
     @Message(id = 18, value = "Form value is a String, use getValue() instead")
     IllegalStateException formValueIsAString();
 
+    @Message(id = 19, value = "Request was not fully consumed")
+    RuntimeException requestWasNotFullyConsumed();
 }

File: core/src/main/java/io/undertow/server/handlers/error/SimpleErrorPageHandler.java
Patch:
@@ -64,11 +64,12 @@ public void handleComplete() {
                 if (codes == null ? exchange.getResponseCode() >= 400 : codes.contains(Integer.valueOf(exchange.getResponseCode()))) {
                     final ChannelFactory<StreamSinkChannel> factory = exchange.getResponseChannelFactory();
                     if (factory != null) {
-                        final StreamSinkChannel response = factory.create();
                         final String errorPage = "<html><head><title>Error</title></head><body>" + exchange.getResponseCode() + " - " + StatusCodes.getReason(exchange.getResponseCode()) + "</body></html>";
                         //we don't want any headers from the original request hanging around
                         exchange.getResponseHeaders().clear();
                         exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, "" + errorPage.length());
+
+                        final StreamSinkChannel response = factory.create();
                         StringWriteChannelListener listener = new StringWriteChannelListener(errorPage) {
                             @Override
                             protected void writeDone(final StreamSinkChannel channel) {

File: core/src/main/java/io/undertow/server/HttpReadListener.java
Patch:
@@ -139,6 +139,7 @@ public void handleEvent(final PushBackStreamChannel channel) {
                 final HttpServerExchange httpServerExchange = new HttpServerExchange(connection, requestHeaders, responseHeaders, parameters, method, protocol, channel, ourResponseChannel, startNextRequestAction, responseTerminateAction);
 
                 try {
+                    httpServerExchange.setRequestScheme("http"); //todo: determine if this is https
                     httpServerExchange.setRequestURI(builder.getFullPath());
                     httpServerExchange.setRelativePath(builder.getRelativePath());
                     httpServerExchange.setRequestPath(builder.getRelativePath());

File: testsuite/servlet/src/test/java/io/undertow/servlet/test/SimpleServletServerTestCase.java
Patch:
@@ -60,7 +60,7 @@ public static void setup() throws ServletException {
                 .setContextPath("/servletContext")
                 .setClassIntrospecter(TestClassIntrospector.INSTANCE)
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(TestResourceLoader.INSTANCE)
+                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                 .addServlet(s);
 
         DeploymentManager manager = container.addDeployment(builder);

File: testsuite/servlet/src/test/java/io/undertow/servlet/test/path/FilterPathMappingTestCase.java
Patch:
@@ -88,7 +88,7 @@ public static void setup() throws ServletException {
                 .setClassLoader(FilterPathMappingTestCase.class.getClassLoader())
                 .setContextPath("/servletContext")
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(TestResourceLoader.INSTANCE);
+                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER);
 
         final DeploymentManager manager = container.addDeployment(builder);
         manager.deploy();

File: testsuite/servlet/src/test/java/io/undertow/servlet/test/path/ServletPathMappingTestCase.java
Patch:
@@ -78,7 +78,7 @@ public static void setup() throws ServletException {
                 .setClassLoader(ServletPathMappingTestCase.class.getClassLoader())
                 .setContextPath("/servletContext")
                 .setDeploymentName("servletContext.war")
-                .setResourceLoader(TestResourceLoader.INSTANCE)
+                .setResourceLoader(TestResourceLoader.NOOP_RESOURCE_LOADER)
                 .addServlets(aStar, aa, aaStar, ab, d, cr, jsp);
 
         DeploymentManager manager = container.addDeployment(builder);

File: core/src/main/java/io/undertow/server/handlers/error/FileErrorPageHandler.java
Patch:
@@ -32,6 +32,7 @@
 import io.undertow.server.handlers.ResponseCodeHandler;
 import io.undertow.server.handlers.file.DirectFileCache;
 import io.undertow.server.handlers.file.FileCache;
+import io.undertow.util.Headers;
 
 /**
  * Handler that serves up a file from disk to serve as an error page.
@@ -66,6 +67,8 @@ public void handleRequest(final HttpServerExchange exchange, final HttpCompletio
             public void handleComplete() {
                 Set<Integer> codes = responseCodes;
                 if (!exchange.isResponseStarted() && codes.contains(exchange.getResponseCode())) {
+                    //we don't want any headers from the original request hanging around
+                    exchange.getResponseHeaders().clear();
                     fileCache.serveFile(exchange, completionHandler, file);
                 } else {
                     completionHandler.handleComplete();

File: servlet/src/main/java/io/undertow/servlet/api/ServletInfo.java
Patch:
@@ -76,7 +76,7 @@ public ServletInfo(final String name, final Class<? extends Servlet> servletClas
     }
 
 
-    public ServletInfo(final String name, final Class<? extends Servlet> servletClass, final InstanceFactory instanceFactory) {
+    public ServletInfo(final String name, final Class<? extends Servlet> servletClass, final InstanceFactory<? extends Servlet> instanceFactory) {
         if (name == null) {
             throw UndertowServletMessages.MESSAGES.paramCannotBeNull("name");
         }

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletInitialHandler.java
Patch:
@@ -49,14 +49,15 @@ public ServletInitialHandler(final BlockingHttpHandler next, final CompositeThre
     @Override
     public void handleRequest(final BlockingHttpServerExchange exchange) throws Exception {
         ThreadSetupAction.Handle handle = setupAction.setup(exchange);
+        final HttpServletRequestImpl request = new HttpServletRequestImpl(exchange, servletContext);
+        final HttpServletResponseImpl response = new HttpServletResponseImpl(exchange);
         try {
-            final HttpServletRequestImpl request = new HttpServletRequestImpl(exchange, servletContext);
-            final HttpServletResponseImpl response = new HttpServletResponseImpl(exchange);
             exchange.getExchange().putAttachment(HttpServletRequestImpl.ATTACHMENT_KEY, request);
             exchange.getExchange().putAttachment(HttpServletResponseImpl.ATTACHMENT_KEY, response);
             next.handleRequest(exchange);
         } finally {
             handle.tearDown();
+            response.flushBuffer();
         }
     }
 

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -463,7 +463,7 @@ public StreamSinkChannel create() {
             StreamSinkChannel oldChannel = firstChannel;
             StreamSinkChannel channel = oldChannel;
             for (ChannelWrapper wrapper : wrappers) {
-                channel = ((ChannelWrapper<StreamSinkChannel>) wrapper).wrap(oldChannel, exchange);
+                channel = ((ChannelWrapper<StreamSinkChannel>) wrapper).wrap(channel, exchange);
                 if (channel == null) {
                     channel = oldChannel;
                 }

File: core/src/main/java/io/undertow/server/handlers/file/CachingFileCache.java
Patch:
@@ -53,7 +53,7 @@ public class CachingFileCache implements FileCache {
     public static final FileCache INSTANCE = new CachingFileCache();
     private static final String JDK7_NO_SUCH_FILE = "java.nio.file.NoSuchFileException";
     private final int sliceSize = 1024;
-    private final DirectBufferCache cache = new DirectBufferCache(sliceSize, sliceSize * 20480);
+    private final DirectBufferCache cache = new DirectBufferCache(sliceSize, sliceSize * 10480);
     private static final int MAX_CACHE_FILE_SIZE = 2048 * 1024;
 
     @Override

File: core/src/main/java/io/undertow/server/handlers/file/DirectBufferCache.java
Patch:
@@ -34,10 +34,10 @@ public DirectBufferCache(int sliceSize, int max, int concurrency) {
         this.max = max;
         this.pool = new ByteBufferSlicePool(BufferAllocator.DIRECT_BYTE_BUFFER_ALLOCATOR, sliceSize, max);
         int shift = 1;
-        while (concurrency < (shift <<= 1)) {}
+        while (concurrency > (shift <<= 1)) {}
         segmentShift = 32 - shift;
         segments = new Segment[shift];
-        for (int i = 0; i < 1; i++) {
+        for (int i = 0; i < segments.length; i++) {
             segments[i] = new Segment(shift);
         }
     }

File: core/src/main/java/io/undertow/server/handlers/file/FileHandler.java
Patch:
@@ -34,7 +34,7 @@
 public class FileHandler implements HttpHandler {
 
     private volatile File base;
-    private volatile FileCache fileCache = DirectFileCache.INSTANCE;
+    private volatile FileCache fileCache = CachingFileCache.INSTANCE;
 
     public FileHandler(final File base) {
         if (base == null) {

File: core/src/main/java/io/undertow/server/handlers/form/FormDataParser.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.io.IOException;
 
+import io.undertow.util.AttachmentKey;
 import org.xnio.IoFuture;
 
 /**
@@ -32,7 +33,7 @@
  */
 public interface FormDataParser {
 
-    String ATTACHMENT_KEY = FormDataParser.class.getName();
+    AttachmentKey<FormDataParser> ATTACHMENT_KEY = AttachmentKey.create(FormDataParser.class);
 
     /**
      * Parse the form data asynchronously. If all the data cannot be read immediately then a read listener will be

File: core/src/main/java/io/undertow/server/session/SessionManager.java
Patch:
@@ -18,6 +18,7 @@
 
 package io.undertow.server.session;
 
+import io.undertow.util.AttachmentKey;
 import org.xnio.IoFuture;
 import io.undertow.server.HttpServerExchange;
 
@@ -36,7 +37,7 @@
  */
 public interface SessionManager {
 
-    String ATTACHMENT_KEY = "io.undertow.session.SessionManager";
+    AttachmentKey<SessionManager> ATTACHMENT_KEY = AttachmentKey.create(SessionManager.class);
 
     /**
      * Creates a new session. Any {@link SessionListener}s registered with this manager will be notified

File: servlet/src/main/java/io/undertow/servlet/handlers/FilterHandler.java
Patch:
@@ -48,8 +48,8 @@ public FilterHandler(final List<ManagedFilter> filters, final BlockingHttpHandle
 
     @Override
     public void handleRequest(final BlockingHttpServerExchange exchange) throws Exception {
-        HttpServletRequestImpl request = (HttpServletRequestImpl) exchange.getExchange().getAttachment(HttpServletRequestImpl.ATTACHMENT_KEY);
-        HttpServletResponseImpl response = (HttpServletResponseImpl) exchange.getExchange().getAttachment(HttpServletResponseImpl.ATTACHMENT_KEY);
+        HttpServletRequestImpl request = exchange.getExchange().getAttachment(HttpServletRequestImpl.ATTACHMENT_KEY);
+        HttpServletResponseImpl response = exchange.getExchange().getAttachment(HttpServletResponseImpl.ATTACHMENT_KEY);
         FilterChainImpl filterChain = new FilterChainImpl(exchange);
         filterChain.doFilter(request, response);
     }

File: servlet/src/main/java/io/undertow/servlet/handlers/ServletHandler.java
Patch:
@@ -88,8 +88,8 @@ public void handleRequest(final BlockingHttpServerExchange exchange) throws IOEx
         if (!started) {
             start();
         }
-        HttpServletRequestImpl request = (HttpServletRequestImpl) exchange.getExchange().getAttachment(HttpServletRequestImpl.ATTACHMENT_KEY);
-        HttpServletResponseImpl response = (HttpServletResponseImpl) exchange.getExchange().getAttachment(HttpServletResponseImpl.ATTACHMENT_KEY);
+        HttpServletRequestImpl request = exchange.getExchange().getAttachment(HttpServletRequestImpl.ATTACHMENT_KEY);
+        HttpServletResponseImpl response = exchange.getExchange().getAttachment(HttpServletResponseImpl.ATTACHMENT_KEY);
         final InstanceHandle servlet = instanceStrategy.getServlet();
         try {
             ((Servlet) servlet.getInstance()).service(request, response);

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletRequestImpl.java
Patch:
@@ -49,6 +49,7 @@
 import io.undertow.servlet.UndertowServletMessages;
 import io.undertow.servlet.util.EmptyEnumeration;
 import io.undertow.servlet.util.IteratorEnumeration;
+import io.undertow.util.AttachmentKey;
 import io.undertow.util.DateUtils;
 import io.undertow.util.HeaderMap;
 import io.undertow.util.Headers;
@@ -60,7 +61,7 @@
  */
 public class HttpServletRequestImpl implements HttpServletRequest {
 
-    public static final String ATTACHMENT_KEY = HttpServletRequestImpl.class.getName();
+    public static final AttachmentKey<HttpServletRequestImpl> ATTACHMENT_KEY = AttachmentKey.create(HttpServletRequestImpl.class);
 
     private final BlockingHttpServerExchange exchange;
 

File: servlet/src/main/java/io/undertow/servlet/spec/HttpServletResponseImpl.java
Patch:
@@ -29,13 +29,14 @@
 
 import io.undertow.server.handlers.blocking.BlockingHttpServerExchange;
 import io.undertow.servlet.UndertowServletMessages;
+import io.undertow.util.AttachmentKey;
 
 /**
  * @author Stuart Douglas
  */
 public class HttpServletResponseImpl implements HttpServletResponse {
 
-    public static final String ATTACHMENT_KEY = HttpServletResponseImpl.class.getName();
+    public static final AttachmentKey<HttpServletResponseImpl> ATTACHMENT_KEY = AttachmentKey.create(HttpServletResponseImpl.class);
 
     private final BlockingHttpServerExchange exchange;
 

File: testsuite/core/src/test/java/io/undertow/test/session/inmemory/InMemorySessionTestCase.java
Patch:
@@ -64,7 +64,7 @@ public void handleRequest(final HttpServerExchange exchange, final HttpCompletio
                     try {
                         Session session = (Session) exchange.getAttachment(Session.ATTACHMENT_KEY);
                         if(session == null) {
-                            final SessionManager manager = (SessionManager) exchange.getAttachment(SessionManager.ATTACHMENT_KEY);
+                            final SessionManager manager = exchange.getAttachment(SessionManager.ATTACHMENT_KEY);
                             session = manager.createSession(exchange).get();
                             session.setAttribute(COUNT, 0);
                         }

File: core/src/main/java/io/undertow/server/httpparser/HttpExchangeBuilder.java
Patch:
@@ -36,7 +36,7 @@ public class HttpExchangeBuilder {
     String relativePath;
     String protocol;
     final HeaderMap headers = new HeaderMap();
-    final Map<String, Deque<String>> queryParameters = new SecureHashMap<String, java.util.Deque<String>>();
+    final Map<String, Deque<String>> queryParameters = new SecureHashMap<String, java.util.Deque<String>>(0);
 
     public String getMethod() {
         return method;

File: core/src/main/java/io/undertow/util/HeaderMap.java
Patch:
@@ -36,6 +36,7 @@ static class HeaderValue extends ArrayDeque<String> {
         private final String name;
 
         HeaderValue(final String name) {
+            super(1);
             this.name = name;
         }
 

File: core/src/main/java/io/undertow/server/handlers/blocking/BlockingHandler.java
Patch:
@@ -62,6 +62,7 @@ public void run() {
                         handler.handleRequest(blockingExchange);
                     }
                 } catch (Throwable t) {
+                    exchange.setResponseCode(500);
                     if (UndertowLogger.REQUEST_LOGGER.isDebugEnabled()) {
                         UndertowLogger.REQUEST_LOGGER.debugf(t, "Blocking request failed %s", blockingExchange);
                     }

File: core/src/main/java/io/undertow/util/SecureHashMap.java
Patch:
@@ -270,7 +270,7 @@ private void resize(Table<K, V> origTable) {
                     }
                 }
             } while (! origArray.compareAndSet(i, origRow, SecureHashMap.<K, V>resized()));
-            sizeUpdater.getAndAdd(newTable, origRow.length);
+            if (origRow != null) sizeUpdater.getAndAdd(newTable, origRow.length);
         }
 
         int size;

File: core/src/main/java/io/undertow/util/SecureHashMap.java
Patch:
@@ -48,7 +48,7 @@ public final class SecureHashMap<K, V> extends AbstractMap<K, V> implements Conc
     private static final float DEFAULT_LOAD_FACTOR = 0.60f;
 
     /** A row which has been resized into the new view. */
-    private static final Object[] RESIZED = new Object[0];
+    private static final Item[] RESIZED = new Item[0];
     /** A non-existent table entry (as opposed to a {@code null} value). */
     private static final Object NONEXISTENT = new Object();
 

File: core/src/main/java/io/undertow/server/HttpTransferEncodingHandler.java
Patch:
@@ -32,6 +32,7 @@
 import org.xnio.ChannelListener;
 import org.xnio.ChannelListeners;
 import org.xnio.IoUtils;
+import org.xnio.channels.ChannelFactory;
 import org.xnio.channels.EmptyStreamSourceChannel;
 import org.xnio.channels.FixedLengthStreamSinkChannel;
 import org.xnio.channels.FixedLengthStreamSourceChannel;
@@ -157,7 +158,8 @@ public StreamSinkChannel setResponseStream(final StreamSinkChannel responseStrea
         public void handleComplete() {
             // create the channels if they haven't yet been
             exchange.getRequestChannel();
-            exchange.getResponseChannelFactory().create();
+            final ChannelFactory<StreamSinkChannel> factory = exchange.getResponseChannelFactory();
+            if (factory != null) factory.create();
             IoUtils.safeClose(requestStream);
             try {
                 responseStream.shutdownWrites();

File: testsuite/core/src/test/java/io/undertow/test/util/DefaultServer.java
Patch:
@@ -69,7 +69,7 @@ public class DefaultServer extends BlockJUnit4ClassRunner {
      * @return The base URL that can be used to make connections to this server
      */
     public static String getDefaultServerAddress() {
-        return "http://" + getHostAddress(DEFAULT) + ":" + getHostPost(DEFAULT);
+        return "http://" + getHostAddress(DEFAULT) + ":" + getHostPort(DEFAULT);
     }
 
     /**
@@ -103,7 +103,7 @@ public void run(final RunNotifier notifier) {
                 worker = xnio.createWorker(OptionMap.create(Options.WORKER_WRITE_THREADS, 2, Options.WORKER_READ_THREADS, 2));
                 openListener = new HttpOpenListener(new ByteBufferSlicePool(10000, 10000));
                 ChannelListener acceptListener = ChannelListeners.openListenerAdapter(openListener);
-                server = worker.createStreamServer(new InetSocketAddress(Inet4Address.getByName(getHostAddress(DEFAULT)), getHostPost(DEFAULT)), acceptListener, OptionMap.EMPTY);
+                server = worker.createStreamServer(new InetSocketAddress(Inet4Address.getByName(getHostAddress(DEFAULT)), getHostPort(DEFAULT)), acceptListener, OptionMap.EMPTY);
                 server.resumeAccepts();
             } catch (IOException e) {
                 throw new RuntimeException(e);
@@ -135,7 +135,7 @@ private static String getHostAddress(String serverName) {
         return System.getProperty(serverName + ".server.address");
     }
 
-    private static int getHostPost(String serverName) {
+    private static int getHostPort(String serverName) {
         return Integer.getInteger(serverName + ".server.port");
     }
 

File: core/src/main/java/io/undertow/server/HttpReadListener.java
Patch:
@@ -60,6 +60,7 @@ final class HttpReadListener implements ChannelListener<PushBackStreamChannel> {
     public void handleEvent(final PushBackStreamChannel channel) {
         final Pooled<ByteBuffer> pooled = connection.getBufferPool().allocate();
         final ByteBuffer buffer = pooled.getResource();
+        buffer.clear();
         boolean free = true;
         try {
             final int res;

File: core/src/main/java/io/undertow/server/handlers/file/DirectFileCache.java
Patch:
@@ -49,7 +49,7 @@ public void serveFile(final HttpServerExchange exchange, final HttpCompletionHan
             final long length = file.length();
             exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, "" + length);
             final StreamSinkChannel response = exchange.getResponseChannelFactory().create();
-            if(response == null) {
+            if (response == null) {
                 throw UndertowMessages.MESSAGES.failedToAcquireResponseChannel();
             }
             final FileChannel fileChannel = response.getWorker().getXnio().openFile(file, FileAccess.READ_ONLY);
@@ -63,7 +63,7 @@ public void serveFile(final HttpServerExchange exchange, final HttpCompletionHan
 
     }
 
-    private class FileWriteTask implements Runnable, ChannelListener<StreamSinkChannel> {
+    private static class FileWriteTask implements Runnable, ChannelListener<StreamSinkChannel> {
 
         private final HttpCompletionHandler completionHandler;
         private final StreamSinkChannel channel;
@@ -93,7 +93,6 @@ public synchronized void run() {
                     channel.resumeWrites();
                 } else {
                     channel.getWriteSetter().set(null);
-                    channel.suspendWrites();
                     IoUtils.safeClose(fileChannel);
                     completionHandler.handleComplete();
                 }
@@ -107,6 +106,7 @@ public synchronized void run() {
         @Override
         public void handleEvent(final StreamSinkChannel channel) {
             channel.getWorker().submit(this);
+            channel.suspendWrites();
         }
     }
 }

File: core/src/main/java/io/undertow/server/HttpOpenListener.java
Patch:
@@ -47,7 +47,8 @@ public void handleEvent(final ConnectedStreamChannel channel) {
             UndertowLogger.REQUEST_LOGGER.tracef("Opened connection with %s", channel.getPeerAddress());
         }
         final PushBackStreamChannel pushBackStreamChannel = new PushBackStreamChannel(channel);
-        HttpReadListener readListener = new HttpReadListener(bufferPool, rootHandler, channel);
+        HttpServerConnection connection = new HttpServerConnection(channel, pushBackStreamChannel, bufferPool, rootHandler);
+        HttpReadListener readListener = new HttpReadListener(channel, connection);
         pushBackStreamChannel.getReadSetter().set(readListener);
         readListener.handleEvent(pushBackStreamChannel);
         channel.resumeReads();

File: core/src/main/java/io/undertow/util/SecureHashMap.java
Patch:
@@ -1020,7 +1020,7 @@ public V next() {
                 return next;
             } finally {
                 removeIterator = tableIterator;
-                next = null;
+                next = nonexistent();
             }
             throw new NoSuchElementException();
         }

File: core/src/test/java/io/undertow/server/httpparser/ParserResumeTestCase.java
Patch:
@@ -19,11 +19,10 @@
 package io.undertow.server.httpparser;
 
 import java.nio.ByteBuffer;
-import java.util.Arrays;
 
+import io.undertow.util.HeaderMap;
 import org.junit.Assert;
 import org.junit.Test;
-import io.undertow.util.HeaderMap;
 
 /**
  * Tests that the parser can resume when it is given partial input
@@ -76,7 +75,7 @@ private void runAssertions(final HttpExchangeBuilder result, final ParseState co
         Assert.assertSame("HTTP/1.1", result.protocol);
         HeaderMap map = new HeaderMap();
         map.add("Host", "www.somehost.net");
-        map.addAll("OtherHeader", Arrays.asList("some", "value"));
+        map.add("OtherHeader", "some value");
         map.add("Hostee", "another");
         map.add("Accept-garbage", "a");
         Assert.assertEquals(map, result.headers);

File: core/src/test/java/io/undertow/server/httpparser/SimpleParserTestCase.java
Patch:
@@ -19,11 +19,10 @@
 package io.undertow.server.httpparser;
 
 import java.nio.ByteBuffer;
-import java.util.Arrays;
 
+import io.undertow.util.HeaderMap;
 import org.junit.Assert;
 import org.junit.Test;
-import io.undertow.util.HeaderMap;
 
 /**
  * Basic test of the HTTP parser functionality.
@@ -83,7 +82,7 @@ private void runTest(final byte[] in) {
         Assert.assertSame("HTTP/1.1", result.protocol);
         HeaderMap map = new HeaderMap();
         map.add("Host", "www.somehost.net");
-        map.addAll("OtherHeader", Arrays.asList("some", "value"));
+        map.add("OtherHeader", "some value");
         Assert.assertEquals(map, result.headers);
         Assert.assertEquals(ParseState.PARSE_COMPLETE, context.state);
     }

File: core/src/main/java/io/undertow/UndertowMessages.java
Patch:
@@ -61,4 +61,6 @@ public interface UndertowMessages {
             "is installed in the handler chain")
     IllegalStateException sessionManagerNotFound();
 
+    @Message(id = 13, value = "Argument cannot be null")
+    IllegalArgumentException argumentCannotBeNull();
 }

File: testsuite/src/test/java/io/undertow/test/handlers/error/FileErrorPageHandlerTestCase.java
Patch:
@@ -42,7 +42,7 @@ public class FileErrorPageHandlerTestCase {
     public void testFileBasedErrorPageIsGenerated() throws IOException {
         DefaultHttpClient client = new DefaultHttpClient();
         try {
-            final FileErrorPageHandler handler = new FileErrorPageHandler(new File(getClass().getResource("errorpage.html").getFile()), DefaultServer.getBlockingExecutorService(), 404);
+            final FileErrorPageHandler handler = new FileErrorPageHandler(new File(getClass().getResource("errorpage.html").getFile()), 404);
             DefaultServer.setRootHandler(handler);
 
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path");

File: parser-generator/src/main/java/io/undertow/annotationprocessor/HttpParserAnnotationProcessor.java
Patch:
@@ -40,7 +40,7 @@
 @SupportedAnnotationTypes("io.undertow.annotationprocessor.HttpParserConfig")
 @SupportedOptions({
 })
-@SupportedSourceVersion(SourceVersion.RELEASE_6)
+@SupportedSourceVersion(SourceVersion.RELEASE_7)
 public class HttpParserAnnotationProcessor extends AbstractProcessor {
 
     private Filer filer;

File: core/src/main/java/io/undertow/server/handlers/error/FileErrorPageHandler.java
Patch:
@@ -77,7 +77,7 @@ public void handleComplete() {
                         try {
                             final FileWriteChannelListener listener = new FileWriteChannelListener(file, response.getWorker().getXnio(), executorService) {
                                 @Override
-                                protected void writeDone(final StreamSinkChannel channel) {
+                                protected void done(final StreamSinkChannel channel, final Exception exception) {
                                     completionHandler.handleComplete();
                                 }
                             };

File: testsuite/src/test/java/io/undertow/test/handlers/error/FileErrorPageHandlerTestCase.java
Patch:
@@ -42,9 +42,7 @@ public class FileErrorPageHandlerTestCase {
     public void testFileBasedErrorPageIsGenerated() throws IOException {
         DefaultHttpClient client = new DefaultHttpClient();
         try {
-            final FileErrorPageHandler handler = new FileErrorPageHandler();
-            handler.setResponseCodes(404);
-            handler.setFile(new File(getClass().getResource("errorpage.html").getFile()));
+            final FileErrorPageHandler handler = new FileErrorPageHandler(new File(getClass().getResource("errorpage.html").getFile()), DefaultServer.getBlockingExecutorService(), 404);
             DefaultServer.setRootHandler(handler);
 
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/path");

File: testsuite/src/test/java/io/undertow/test/session/inmemory/InMemorySessionTestCase.java
Patch:
@@ -55,7 +55,7 @@ public void testBasicPathHanding() throws IOException {
         DefaultHttpClient client = new DefaultHttpClient();
         client.setCookieStore(new BasicCookieStore());
         try {
-            final SessionAttachmentHandler handler = new SessionAttachmentHandler();
+            final SessionAttachmentHandler handler = new SessionAttachmentHandler(new InMemorySessionManager());
             handler.setNext(new HttpHandler() {
                 @Override
                 public void handleRequest(final HttpServerExchange exchange, final HttpCompletionHandler completionHandler) {
@@ -75,7 +75,6 @@ public void handleRequest(final HttpServerExchange exchange, final HttpCompletio
                     }
                 }
             });
-            handler.setSessionManager(new InMemorySessionManager());
             DefaultServer.setRootHandler(handler);
 
             HttpGet get = new HttpGet(DefaultServer.getDefaultServerAddress() + "/notamatchingpath");

File: testsuite/src/test/java/io/undertow/test/util/DefaultServer.java
Patch:
@@ -136,4 +136,7 @@ private static int getHostPost(String serverName) {
         return Integer.getInteger(serverName + ".server.port");
     }
 
+    public static ExecutorService getBlockingExecutorService() {
+        return blockingExecutorService;
+    }
 }

File: core/src/main/java/io/undertow/server/HttpServerExchange.java
Patch:
@@ -571,6 +571,7 @@ public void handleEvent(final StreamSinkChannel channel) {
                     c = channel.write(buffer);
                 } while (buffer.hasRemaining() && c > 0);
                 if (buffer.hasRemaining()) {
+                    channel.resumeWrites();
                     return;
                 } else {
                     // channel will auto-close if the gated channel was closed

File: core/src/main/java/io/undertow/server/handlers/encoding/EncodingHandler.java
Patch:
@@ -64,7 +64,7 @@ public void handleRequest(final HttpServerExchange exchange, final HttpCompletio
                 HttpHandlers.executeHandler(identityHandler, exchange, completionHandler);
             } else {
                 //we don't have an identity handler
-                noEncodingHandler.handleRequest(exchange, completionHandler);
+                HttpHandlers.executeHandler(noEncodingHandler, exchange, completionHandler);
             }
             return;
         }

File: core/src/main/java/tmp/texugo/server/handlers/ResponseCodeHandler.java
Patch:
@@ -29,11 +29,13 @@
  */
 public final class ResponseCodeHandler implements HttpHandler {
 
+    public static final ResponseCodeHandler HANDLE_403 = new ResponseCodeHandler(403);
     /**
      * A handler which sets a 404 code.
      */
     public static final ResponseCodeHandler HANDLE_404 = new ResponseCodeHandler(404);
 
+    public static final ResponseCodeHandler HANDLE_406 = new ResponseCodeHandler(406);
     /**
      * A handler which sets a 500 code.
      */

File: core/src/main/java/tmp/texugo/util/GatedStreamSinkChannel.java
Patch:
@@ -313,7 +313,7 @@ public void wakeupWrites() {
             if (allAreSet(val, FLAG_GATE_OPEN)) {
                 delegate.wakeupWrites();
             } else {
-                getWriteThread().execute(ChannelListeners.getChannelListenerTask(this, writeSetter));
+                getWriteThread().execute(ChannelListeners.getChannelListenerTask(this, writeSetter.get()));
             }
         } finally {
             exit(val, FLAG_IN, 0);

File: core/src/main/java/tmp/texugo/client/HttpClientConnection.java
Patch:
@@ -24,15 +24,16 @@
 
 import java.io.Closeable;
 import java.net.URI;
+
 import org.xnio.IoFuture;
 import org.xnio.OptionMap;
 import org.xnio.channels.ConnectedStreamChannel;
-import tmp.texugo.util.Attachable;
+import tmp.texugo.util.AbstractAttachable;
 
 /**
  * @author <a href="mailto:david.lloyd@redhat.com">David M. Lloyd</a>
  */
-public abstract class HttpClientConnection extends Attachable implements Closeable {
+public abstract class HttpClientConnection extends AbstractAttachable implements Closeable {
     private final HttpClient client;
 
     protected HttpClientConnection(final HttpClient client) {

File: core/src/main/java/tmp/texugo/client/HttpClientRequest.java
Patch:
@@ -23,15 +23,16 @@
 package tmp.texugo.client;
 
 import java.io.IOException;
+
 import org.xnio.IoFuture;
 import org.xnio.channels.StreamSinkChannel;
-import tmp.texugo.util.Attachable;
+import tmp.texugo.util.AbstractAttachable;
 import tmp.texugo.util.HeaderMap;
 
 /**
  * @author <a href="mailto:david.lloyd@redhat.com">David M. Lloyd</a>
  */
-public abstract class HttpClientRequest extends Attachable {
+public abstract class HttpClientRequest extends AbstractAttachable {
     private final HttpClientConnection connection;
     private final HeaderMap requestHeaders = new HeaderMap();
 

File: core/src/main/java/tmp/texugo/client/HttpClientResponse.java
Patch:
@@ -23,14 +23,15 @@
 package tmp.texugo.client;
 
 import java.io.IOException;
+
 import org.xnio.channels.StreamSourceChannel;
-import tmp.texugo.util.Attachable;
+import tmp.texugo.util.AbstractAttachable;
 import tmp.texugo.util.HeaderMap;
 
 /**
  * @author <a href="mailto:david.lloyd@redhat.com">David M. Lloyd</a>
  */
-public abstract class HttpClientResponse extends Attachable {
+public abstract class HttpClientResponse extends AbstractAttachable {
     private final HeaderMap responseHeaders = new HeaderMap();
 
     public final HeaderMap getResponseHeaders() {

File: parser-generator/src/main/java/tmp/texugo/annotationprocessor/ParserGenerator.java
Patch:
@@ -455,6 +455,7 @@ private static void writeStateMachine(final String className, final CodeAttribut
         c.branchEnd(prefixToNoState);
         CodeLocation noStateLoop = c.mark();
 
+        handleReturnIfNoMoreBytes(c, returnIncompleteCode);
         //load 2 copies of the current byte into the stack
         c.aload(BYTE_BUFFER_VAR);
         c.invokevirtual(ByteBuffer.class.getName(), "get", "()B");

File: core/src/main/java/tmp/texugo/server/httpparser/HttpExchangeBuilder.java
Patch:
@@ -22,10 +22,11 @@
 
 package tmp.texugo.server.httpparser;
 
-import java.util.HashMap;
 import java.util.IdentityHashMap;
 import java.util.Map;
 
+import tmp.texugo.util.SecureHashMap;
+
 /**
  *
  *
@@ -36,7 +37,7 @@ public class HttpExchangeBuilder {
     String path;
     String protocol;
     final Map<String, String> standardHeaders = new IdentityHashMap<String, String>();
-    final Map<String, String> otherHeaders = new HashMap<String, String>();
+    final Map<String, String> otherHeaders = new SecureHashMap<String, String>();
     String nextStandardHeader;
     String nextOtherHeader;
 }

