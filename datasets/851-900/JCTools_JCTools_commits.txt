File: jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java
Patch:
@@ -1413,7 +1413,7 @@ public void remove() {
    *  iteration.  The {@link NonBlockingHashMap} does not normally create or
    *  using {@link java.util.Map.Entry} objects so they will be created soley
    *  to support this iteration.  Iterating using {@link Map#keySet} or {@link
-   *  Map##values} will be more efficient.
+   *  Map#values} will be more efficient.
    */
   @Override
   public Set<Map.Entry<TypeK,TypeV>> entrySet() {

File: jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java
Patch:
@@ -1256,7 +1256,7 @@ public void remove() {
    *  iteration.  The {@link NonBlockingIdentityHashMap} does not normally create or
    *  using {@link java.util.Map.Entry} objects so they will be created soley
    *  to support this iteration.  Iterating using {@link Map#keySet} or {@link
-   *  Map##values} will be more efficient.
+   *  Map#values} will be more efficient.
    */
   @Override
   public Set<Map.Entry<TypeK,TypeV>> entrySet() {

File: jctools-core/src/main/java/org/jctools/queues/SpscArrayQueue.java
Patch:
@@ -177,7 +177,7 @@ abstract class SpscArrayQueueL3Pad<E> extends SpscArrayQueueConsumerIndexField<E
  * For convenience the relevant papers are available in the `resources` folder:<br>
  * <i>
  *     2010 - Pisa - SPSC Queues on Shared Cache Multi-Core Systems.pdf<br>
- *     2012 - Junchang- BQueue- Efﬁcient and Practical Queuing.pdf <br>
+ *     2012 - Junchang- BQueue- Efficient and Practical Queuing.pdf <br>
  * </i>
  * This implementation is wait free.
  */

File: jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java
Patch:
@@ -280,7 +280,7 @@ abstract class SpscAtomicArrayQueueL3Pad<E> extends SpscAtomicArrayQueueConsumer
  * For convenience the relevant papers are available in the `resources` folder:<br>
  * <i>
  *     2010 - Pisa - SPSC Queues on Shared Cache Multi-Core Systems.pdf<br>
- *     2012 - Junchang- BQueue- Efﬁcient and Practical Queuing.pdf <br>
+ *     2012 - Junchang- BQueue- Efficient and Practical Queuing.pdf <br>
  * </i>
  * This implementation is wait free.
  */

File: jctools-core/src/main/java/org/jctools/queues/unpadded/SpscUnpaddedArrayQueue.java
Patch:
@@ -137,7 +137,7 @@ abstract class SpscUnpaddedArrayQueueL3Pad<E> extends SpscUnpaddedArrayQueueCons
  * For convenience the relevant papers are available in the `resources` folder:<br>
  * <i>
  *     2010 - Pisa - SPSC Queues on Shared Cache Multi-Core Systems.pdf<br>
- *     2012 - Junchang- BQueue- Efﬁcient and Practical Queuing.pdf <br>
+ *     2012 - Junchang- BQueue- Efficient and Practical Queuing.pdf <br>
  * </i>
  * This implementation is wait free.
  */

File: jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java
Patch:
@@ -1449,7 +1449,7 @@ private void writeObject(java.io.ObjectOutputStream s) throws IOException  {
   }
 
   // --- readObject --------------------------------------------------------
-  // Read a CHM from a stream
+  // Read a NBHM from a stream
   private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {
     s.defaultReadObject();      // Read nothing
     initialize(MIN_SIZE);

File: jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java
Patch:
@@ -1267,7 +1267,7 @@ private void writeObject(java.io.ObjectOutputStream s) throws IOException  {
   }
 
   // --- readObject --------------------------------------------------------
-  // Read a CHM from a stream
+  // Read a NBHML from a stream
   @SuppressWarnings("unchecked")
   private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException  {
     s.defaultReadObject();      // Read nothing

File: jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java
Patch:
@@ -1279,7 +1279,7 @@ public Set<Map.Entry<TypeK,TypeV>> entrySet() {
   }
 
   // --- writeObject -------------------------------------------------------
-  // Write a NBHM to a stream
+  // Write a NBIHM to a stream
   private void writeObject(java.io.ObjectOutputStream s) throws IOException  {
     s.defaultWriteObject();     // Nothing to write
     for( Object K : keySet() ) {
@@ -1292,7 +1292,7 @@ private void writeObject(java.io.ObjectOutputStream s) throws IOException  {
   }
 
   // --- readObject --------------------------------------------------------
-  // Read a CHM from a stream
+  // Read a NBIHM from a stream
   private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {
     s.defaultReadObject();      // Read nothing
     initialize(MIN_SIZE);

File: jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java
Patch:
@@ -191,7 +191,7 @@ private void writeObject(java.io.ObjectOutputStream s) throws IOException  {
   }
 
   // --- readObject --------------------------------------------------------
-  // Read a CHM from a stream
+  // Read a NBSI from a stream
   private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException  {
     s.defaultReadObject();      // Read nothing
     final int len = s.readInt(); // Read max element

File: jctools-core/src/test/java/org/jctools/queues/QueueSanityTest.java
Patch:
@@ -536,7 +536,7 @@ public void testPollOrderContendedFull() throws Exception
             int pId = pThreadId.getAndIncrement() << 24;
 
             int i = 0;
-            while (!stop.get())
+            while (!stop.get() && i < Integer.MAX_VALUE >>> 8)
             {
                 // clear the top 8 bits
                 int nextVal = (i << 8) >>> 8;
@@ -591,7 +591,7 @@ public void testPeekOrderContendedFull() throws Exception
             int pId = pThreadId.getAndIncrement() << 24;
 
             int i = 0;
-            while (!stop.get())
+            while (!stop.get() && i < Integer.MAX_VALUE >>> 8)
             {
                 // clear the top 8 bits
                 int nextVal = (i << 8) >>> 8;
@@ -618,7 +618,7 @@ public void testPeekOrderContendedFull() throws Exception
             Integer[] lastPeekedSequence = new Integer[producers];
             while (!stop.get())
             {
-                final Integer peekedSequenceAndTid = q.poll();
+                final Integer peekedSequenceAndTid = q.peek();
                 if (peekedSequenceAndTid == null)
                 {
                     continue;

File: jctools-core/src/test/java/org/jctools/queues/QueueSanityTestMpscChunked.java
Patch:
@@ -24,6 +24,7 @@ public static Collection<Object[]> parameters()
         ArrayList<Object[]> list = new ArrayList<Object[]>();
         list.add(makeQueue(0, 1, 4, Ordering.FIFO, new MpscChunkedArrayQueue<>(2, 4)));// MPSC size 1
         list.add(makeQueue(0, 1, SIZE, Ordering.FIFO, new MpscChunkedArrayQueue<>(8, SIZE)));// MPSC size SIZE
+        list.add(makeQueue(0, 1, 4096, Ordering.FIFO, new MpscChunkedArrayQueue<>(32, 4096)));// Netty recycler defaults
         return list;
     }
 }

File: jctools-experimental/src/main/java/org/jctools/counters/FixedSizeStripedLongCounter.java
Patch:
@@ -136,7 +136,8 @@ private int index() {
      */
     private int probe() {
         // Fast path for reliable well-distributed probe, available from JDK 7+.
-        // As long as PROBE is final this branch will be inlined.
+        // As long as PROBE is final static this branch will be constant folded
+        // (i.e removed).
         if (PROBE != -1) {
             int probe;
             if ((probe = UNSAFE.getInt(Thread.currentThread(), PROBE)) == 0) {

File: jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java
Patch:
@@ -118,6 +118,7 @@ private static final class Prime {
   // --- hash ----------------------------------------------------------------
   // Helper function to spread lousy hashCodes
   private static final int hash(final Object key) {
+    if (key == null) throw new NullPointerException();
     int h = System.identityHashCode(key); // The real hashCode call
     // I assume that System.identityHashCode is well implemented with a good
     // spreader, and a second bit-spreader is redundant.
@@ -1250,7 +1251,7 @@ public Set<Map.Entry<TypeK,TypeV>> entrySet() {
         if( !(o instanceof Map.Entry)) return false;
         final Map.Entry<?,?> e = (Map.Entry<?,?>)o;
         TypeV v = get(e.getKey());
-        return v.equals(e.getValue());
+        return v != null && v.equals(e.getValue());
       }
       @Override public Iterator<Map.Entry<TypeK,TypeV>> iterator() { return new SnapshotE(); }
     };

File: jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannelFactory.java
Patch:
@@ -177,7 +177,7 @@ public static <E> ProxyChannel<E> createProxy(int capacity,
             byte[] byteCode = classWriter.toByteArray();
             printClassBytes(byteCode);
             // Caveat: The interface and JCTools must be on the same class loader. Maybe class loader should be an argument? Overload?
-            Class<?> definedClass = UnsafeAccess.UNSAFE.defineClass(generatedName, byteCode, 0, byteCode.length, iFace.getClassLoader(), null);
+            Class<?> definedClass = DefineClassHelper.defineClass(iFace, generatedName, byteCode);
             return instantiate(definedClass, capacity, waitStrategy);
         }
     }

File: jctools-concurrency-test/src/main/java/org/jctools/queues/SpscArrayQueueConsumerTest.java
Patch:
@@ -5,7 +5,7 @@
 import org.openjdk.jcstress.annotations.JCStressTest;
 import org.openjdk.jcstress.annotations.Outcome;
 import org.openjdk.jcstress.annotations.State;
-import org.openjdk.jcstress.infra.results.IntResult1;
+import org.openjdk.jcstress.infra.results.I_Result;
 
 import static org.openjdk.jcstress.annotations.Expect.ACCEPTABLE;
 import static org.openjdk.jcstress.annotations.Expect.FORBIDDEN;
@@ -29,7 +29,7 @@ public void actor1() {
     }
 
     @Arbiter
-    public void arbiter1(IntResult1 result) {
-        result.r1 = queue.size();
+    public void arbiter(I_Result r) {
+        r.r1 = queue.size();
     }
 }

File: jctools-concurrency-test/src/main/java/org/jctools/queues/SpscArrayQueueProducerConsumerTest.java
Patch:
@@ -5,7 +5,7 @@
 import org.openjdk.jcstress.annotations.JCStressTest;
 import org.openjdk.jcstress.annotations.Outcome;
 import org.openjdk.jcstress.annotations.State;
-import org.openjdk.jcstress.infra.results.IntResult1;
+import org.openjdk.jcstress.infra.results.I_Result;
 
 import static org.openjdk.jcstress.annotations.Expect.ACCEPTABLE;
 import static org.openjdk.jcstress.annotations.Expect.FORBIDDEN;
@@ -32,7 +32,7 @@ public void actor2() {
     }
 
     @Arbiter
-    public void arbiter1(IntResult1 result) {
-        result.r1 = queue.size();
+    public void arbiter(I_Result r) {
+        r.r1 = queue.size();
     }
 }

File: jctools-concurrency-test/src/main/java/org/jctools/sets/SingleWriterHashSetRemovalTest.java
Patch:
@@ -4,7 +4,7 @@
 import org.openjdk.jcstress.annotations.JCStressTest;
 import org.openjdk.jcstress.annotations.Outcome;
 import org.openjdk.jcstress.annotations.State;
-import org.openjdk.jcstress.infra.results.BooleanResult1;
+import org.openjdk.jcstress.infra.results.Z_Result;
 
 import static org.openjdk.jcstress.annotations.Expect.ACCEPTABLE;
 import static org.openjdk.jcstress.annotations.Expect.FORBIDDEN;
@@ -33,7 +33,7 @@ public void actor1() {
     }
 
     @Actor
-    public void actor2(BooleanResult1 result) {
-        result.r1 = set.contains(17);
+    public void actor2(Z_Result r) {
+        r.r1 = set.contains(17);
     }
 }

File: jctools-core/src/main/java/org/jctools/queues/MpscArrayQueue.java
Patch:
@@ -226,6 +226,7 @@ public boolean offerIfBelowThreshold(final E e, int threshold)
         {
             throw new NullPointerException();
         }
+
         final long mask = this.mask;
         final long capacity = mask + 1;
 
@@ -527,7 +528,7 @@ public int fill(Supplier<E> s, int limit)
         final long capacity = mask + 1;
         long producerLimit = lvProducerLimit();
         long pIndex;
-        int actualLimit = 0;
+        int actualLimit;
         do
         {
             pIndex = lvProducerIndex();

File: jctools-core/src/test/java/org/jctools/queues/MpqSanityTest.java
Patch:
@@ -24,7 +24,7 @@ public abstract class MpqSanityTest
 
     public static final int SIZE = 8192 * 2;
 
-    private final MessagePassingQueue<Integer> queue;
+    protected final MessagePassingQueue<Integer> queue;
     private final ConcurrentQueueSpec spec;
     int count = 0;
     Integer p;

File: jctools-benchmarks/src/main/java/org/jctools/jmh/latency/MpqBurstCost.java
Patch:
@@ -61,11 +61,12 @@ public void setupQueueAndConsumers()
             final Event event = new Event();
 
             // stretch the queue to the limit, working through resizing and full
-            for (int i = 0; i < 128 + 100; i++)
+            // 128 * 2 account for the xadd qs that pool by default 2 chunks
+            for (int i = 0; i < ((128 * 2) + 100); i++)
             {
                 q.offer(event);
             }
-            for (int i = 0; i < 128 + 100; i++)
+            for (int i = 0; i < ((128 * 2) + 100); i++)
             {
                 q.poll();
             }

File: jctools-benchmarks/src/main/java/org/jctools/jmh/latency/QueueBurstCost.java
Patch:
@@ -61,11 +61,12 @@ public void setupQueueAndConsumers()
             final Event event = new Event();
 
             // stretch the queue to the limit, working through resizing and full
-            for (int i = 0; i < 128 + 100; i++)
+            // 128 * 2 account for the xadd qs that pool by default 2 chunks
+            for (int i = 0; i < ((128 * 2) + 100); i++)
             {
                 q.offer(event);
             }
-            for (int i = 0; i < 128 + 100; i++)
+            for (int i = 0; i < ((128 * 2) + 100); i++)
             {
                 q.poll();
             }

File: jctools-core/src/test/java/org/jctools/queues/QueueSanityTestMpmcArray.java
Patch:
@@ -5,6 +5,7 @@
 import java.util.Queue;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import org.jctools.util.TestUtil.Val;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;

File: jctools-core/src/test/java/org/jctools/queues/QueueSanityTestMpscArray.java
Patch:
@@ -5,6 +5,7 @@
 import java.util.Queue;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import org.jctools.util.TestUtil.Val;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;

File: jctools-core/src/test/java/org/jctools/queues/QueueSanityTestMpscBlockingConsumerArrayExtended.java
Patch:
@@ -5,10 +5,9 @@
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import org.jctools.util.TestUtil.Val;
 import org.junit.Test;
 
-import org.jctools.queues.QueueSanityTest.Val;
-
 import static java.util.concurrent.TimeUnit.*;
 import static org.junit.Assert.*;
 

File: jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java
Patch:
@@ -502,7 +502,7 @@ public E poll() {
                 return null;
             }
         }
-        soRefElement(buffer, offset, null);
+        spRefElement(buffer, offset, null);
         soConsumerIndex(cIndex + 1);
         return e;
     }
@@ -555,7 +555,7 @@ public E relaxedPoll() {
         if (null == e) {
             return null;
         }
-        soRefElement(buffer, offset, null);
+        spRefElement(buffer, offset, null);
         soConsumerIndex(cIndex + 1);
         return e;
     }
@@ -586,7 +586,7 @@ public int drain(final Consumer<E> c, final int limit) {
             if (null == e) {
                 return i;
             }
-            soRefElement(buffer, offset, null);
+            spRefElement(buffer, offset, null);
             // ordered store -> atomic and ordered for size()
             soConsumerIndex(index + 1);
             c.accept(e);

File: jctools-core/src/main/java/org/jctools/queues/atomic/MpscLinkedAtomicQueue.java
Patch:
@@ -140,7 +140,8 @@ public int fill(Supplier<E> s, int limit) {
         final LinkedQueueAtomicNode<E> head = tail;
         for (int i = 1; i < limit; i++) {
             final LinkedQueueAtomicNode<E> temp = newNode(s.get());
-            tail.soNext(temp);
+            // spNext: xchgProducerNode ensures correct construction
+            tail.spNext(temp);
             tail = temp;
         }
         final LinkedQueueAtomicNode<E> oldPNode = xchgProducerNode(tail);

File: jctools-core/src/main/java/org/jctools/queues/atomic/SpscLinkedAtomicQueue.java
Patch:
@@ -98,11 +98,12 @@ public int fill(Supplier<E> s, int limit) {
         final LinkedQueueAtomicNode<E> head = tail;
         for (int i = 1; i < limit; i++) {
             final LinkedQueueAtomicNode<E> temp = newNode(s.get());
-            tail.soNext(temp);
+            // spNext : soProducerNode ensures correct construction
+            tail.spNext(temp);
             tail = temp;
         }
         final LinkedQueueAtomicNode<E> oldPNode = lpProducerNode();
-        spProducerNode(tail);
+        soProducerNode(tail);
         // same bubble as offer, and for the same reasons.
         oldPNode.soNext(head);
         return limit;

File: jctools-core/src/main/java/org/jctools/queues/atomic/BaseLinkedAtomicQueue.java
Patch:
@@ -182,6 +182,7 @@ final void spConsumerNode(LinkedQueueAtomicNode<E> newValue) {
         C_NODE_UPDATER.lazySet(this, newValue);
     }
 
+    @SuppressWarnings("unchecked")
     final LinkedQueueAtomicNode<E> lvConsumerNode() {
         return consumerNode;
     }

File: jctools-core/src/main/java/org/jctools/queues/MpmcUnboundedXaddArrayQueue.java
Patch:
@@ -189,7 +189,7 @@ public E poll()
             }
         }
 
-        // if we are the isFirstElementOfNextChunk we need to get the consumer chunk
+        // if we are the isFirstElementOfNewChunk we need to get the consumer chunk
         if (isFirstElementOfNewChunk)
         {
             e = linkNextConsumerChunkAndPoll(cChunk, next, ciChunkIndex);

File: jctools-core/src/main/java/org/jctools/queues/MpscUnboundedXaddArrayQueue.java
Patch:
@@ -158,7 +158,7 @@ public E relaxedPoll()
             {
                 return null;
             }
-            moveToNextConsumerChunk(cIndex, cChunk, next);
+            moveToNextConsumerChunk(cChunk, next);
 
             cChunk = next;
         }
@@ -250,7 +250,7 @@ public int drain(Consumer<E> c, int limit)
                 {
                     return i;
                 }
-                moveToNextConsumerChunk(cIndex, cChunk, next);
+                moveToNextConsumerChunk(cChunk, next);
 
                 cChunk = next;
             }

File: jctools-core/src/test/java/org/jctools/queues/MpqSanityTestMpscUnboundedXadd.java
Patch:
@@ -23,6 +23,8 @@ public static Collection<Object[]> parameters()
         ArrayList<Object[]> list = new ArrayList<Object[]>();
         list.add(makeMpq(0, 1, 0, Ordering.FIFO, new MpscUnboundedXaddArrayQueue<>(1)));
         list.add(makeMpq(0, 1, 0, Ordering.FIFO, new MpscUnboundedXaddArrayQueue<>(64)));
+        list.add(makeMpq(0, 1, 0, Ordering.FIFO, new MpscUnboundedXaddArrayQueue<>(1, 2)));
+        list.add(makeMpq(0, 1, 0, Ordering.FIFO, new MpscUnboundedXaddArrayQueue<>(64, 2)));
         return list;
     }
 }

File: jctools-core/src/test/java/org/jctools/queues/QueueSanityTestMpscUnboundedXadd.java
Patch:
@@ -23,6 +23,8 @@ public static Collection<Object[]> parameters()
         ArrayList<Object[]> list = new ArrayList<Object[]>();
         list.add(makeQueue(0, 1, 0, Ordering.FIFO, new MpscUnboundedXaddArrayQueue<>(1)));
         list.add(makeQueue(0, 1, 0, Ordering.FIFO, new MpscUnboundedXaddArrayQueue<>(64)));
+        list.add(makeQueue(0, 1, 0, Ordering.FIFO, new MpscUnboundedXaddArrayQueue<>(1, 2)));
+        list.add(makeQueue(0, 1, 0, Ordering.FIFO, new MpscUnboundedXaddArrayQueue<>(64, 2)));
         return list;
     }
 }

File: jctools-core/src/main/java/org/jctools/queues/SpmcArrayQueue.java
Patch:
@@ -176,7 +176,7 @@ public boolean offer(final E e)
                 }
             }
         }
-        spElement(buffer, offset, e);
+        soElement(buffer, offset, e);
         // single producer, so store ordered is valid. It is also required to correctly publish the element
         // and for the consumers to pick up the tail value.
         soProducerIndex(currProducerIndex + 1);
@@ -263,7 +263,7 @@ public boolean relaxedOffer(E e)
         {
             return false;
         }
-        spElement(buffer, offset, e);
+        soElement(buffer, offset, e);
         // single producer, so store ordered is valid. It is also required to correctly publish the element
         // and for the consumers to pick up the tail value.
         soProducerIndex(producerIndex + 1);

File: jctools-channels/src/main/java/org/jctools/channels/proxy/ProxyChannel.java
Patch:
@@ -26,7 +26,7 @@
 public interface ProxyChannel<E> {
 
     /**
-     * @param callback the accept function for this consumer
+     * @param impl the accept function for this consumer
      * @return a consumer instance to be used for this particular thread.
      */
     E proxyInstance(E impl);

File: jctools-experimental/src/main/java/org/jctools/queues/MpscRelaxedArrayQueue.java
Patch:
@@ -448,7 +448,7 @@ private void validateSlowProducerOverClaim(final int activeCycleIndex, final lon
             //a definitive fail could be declared only if the claim is trying to overwrite something not consumed yet:
             //isFull is not considering the real occupation of the slot
             final long consumerPosition = lvConsumerPosition();
-            final long effectiveProducerLimit = consumerPosition + (this.cycleLength * 2);
+            final long effectiveProducerLimit = consumerPosition + (this.cycleLength * 2l);
             if (producerPosition >= effectiveProducerLimit)
             {
                 throw new IllegalStateException(

File: jctools-core/src/main/java/org/jctools/queues/MpscBlockingConsumerArrayQueue.java
Patch:
@@ -694,11 +694,11 @@ public int fill(Supplier<E> s, int limit)
             // pIndex is even (lower bit is 0) -> actual index is (pIndex >> 1), consumer is awake
 
             // we want 'limit' slots, but will settle for whatever is visible to 'producerLimit'
-            batchIndex = Math.min(producerLimit, pIndex + shiftedBatchSize);
+            batchIndex = Math.min(producerLimit, pIndex + shiftedBatchSize); //  -> producerLimit >= batchIndex
 
             // Use producer limit to save a read of the more rapidly mutated consumer index.
             // Assumption: queue is usually empty or near empty
-            if (pIndex >= producerLimit || producerLimit < batchIndex)
+            if (pIndex >= producerLimit)
             {
                 if (!recalculateProducerLimit(mask, pIndex, producerLimit))
                 {

File: jctools-core/src/main/java/org/jctools/queues/ConcurrentSequencedCircularArrayQueue.java
Patch:
@@ -38,7 +38,7 @@ public abstract class ConcurrentSequencedCircularArrayQueue<E> extends Concurren
         // 2 cache lines pad
         SEQ_BUFFER_PAD = (PortableJvmInfo.CACHE_LINE_SIZE * 2) / scale;
         // Including the buffer pad in the array base offset
-        ARRAY_BASE = UnsafeAccess.UNSAFE.arrayBaseOffset(long[].class) + (SEQ_BUFFER_PAD * scale);
+        ARRAY_BASE = UnsafeAccess.UNSAFE.arrayBaseOffset(long[].class) + (SEQ_BUFFER_PAD * (long)scale);
     }
 
     protected final long[] sequenceBuffer;
@@ -47,7 +47,7 @@ public ConcurrentSequencedCircularArrayQueue(int capacity)
     {
         super(capacity);
         int actualCapacity = (int) (this.mask + 1);
-        // pad data on either end with some empty slots.
+        // pad data on either end with some empty slots. Note that actualCapacity is <= MAX_POW2_INT
         sequenceBuffer = new long[actualCapacity + SEQ_BUFFER_PAD * 2];
         for (long i = 0; i < actualCapacity; i++)
         {

File: jctools-experimental/src/main/java/org/jctools/queues/MpscLinkedArrayQueue.java
Patch:
@@ -45,8 +45,8 @@ public boolean offer(T value) {
         if (index < end) {
             int offset = (int)(index - start);
             array.lazySet(offset, value);
-        } else
-        if (index >= end) {
+        }
+        else { //(index >= end)
             for (;;) {
                 Object nextArray = array.next();
                 if (nextArray == null) {

File: jctools-core/src/main/java/org/jctools/queues/BaseMpscLinkedArrayQueue.java
Patch:
@@ -546,9 +546,9 @@ public int fill(Supplier<E> s, int limit)
             // a successful CAS ties the ordering, lv(pIndex) -> [mask/buffer] -> cas(pIndex)
 
             // we want 'limit' slots, but will settle for whatever is visible to 'producerLimit'
-            long batchIndex = Math.min(producerLimit, pIndex + 2 * limit);
+            long batchIndex = Math.min(producerLimit, pIndex + 2l * limit); //  -> producerLimit >= batchIndex
 
-            if (pIndex >= producerLimit || producerLimit < batchIndex)
+            if (pIndex >= producerLimit)
             {
                 int result = offerSlowPath(mask, pIndex, producerLimit);
                 switch (result)
@@ -575,7 +575,7 @@ public int fill(Supplier<E> s, int limit)
 
         for (int i = 0; i < claimedSlots; i++)
         {
-            final long offset = modifiedCalcElementOffset(pIndex + 2 * i, mask);
+            final long offset = modifiedCalcElementOffset(pIndex + 2l * i, mask);
             soElement(buffer, offset, s.get());
         }
         return claimedSlots;

File: jctools-core/src/main/java/org/jctools/queues/MessagePassingQueue.java
Patch:
@@ -233,6 +233,7 @@ interface ExitCondition
      * thread subject to the restrictions appropriate to the implementation.
      *
      * @return the number of offered elements
+     * @throws IllegalArgumentException if limit is negative
      */
     int fill(Supplier<T> s, int limit);
 

File: jctools-core/src/main/java/org/jctools/queues/MpscLinkedQueue.java
Patch:
@@ -198,10 +198,11 @@ public int fill(Supplier<E> s)
     @Override
     public int fill(Supplier<E> s, int limit)
     {
+        if (limit < 0)
+            throw new IllegalArgumentException("limit is negative:" + limit);
         if (limit == 0)
-        {
             return 0;
-        }
+
         LinkedQueueNode<E> tail = newNode(s.get());
         final LinkedQueueNode<E> head = tail;
         for (int i = 1; i < limit; i++)

File: jctools-core/src/main/java/org/jctools/queues/SpscLinkedQueue.java
Patch:
@@ -109,10 +109,11 @@ public int fill(Supplier<E> s)
     @Override
     public int fill(Supplier<E> s, int limit)
     {
+        if (limit < 0)
+            throw new IllegalArgumentException("limit is negative:" + limit);
         if (limit == 0)
-        {
             return 0;
-        }
+
         LinkedQueueNode<E> tail = newNode(s.get());
         final LinkedQueueNode<E> head = tail;
         for (int i = 1; i < limit; i++)

File: jctools-core/src/main/java/org/jctools/queues/atomic/MpscLinkedAtomicQueue.java
Patch:
@@ -186,9 +186,10 @@ public int fill(Supplier<E> s) {
 
     @Override
     public int fill(Supplier<E> s, int limit) {
-        if (limit == 0) {
+        if (limit < 0)
+            throw new IllegalArgumentException("limit is negative:" + limit);
+        if (limit == 0)
             return 0;
-        }
         LinkedQueueAtomicNode<E> tail = newNode(s.get());
         final LinkedQueueAtomicNode<E> head = tail;
         for (int i = 1; i < limit; i++) {

File: jctools-core/src/main/java/org/jctools/queues/atomic/SpscLinkedAtomicQueue.java
Patch:
@@ -115,9 +115,10 @@ public int fill(Supplier<E> s) {
 
     @Override
     public int fill(Supplier<E> s, int limit) {
-        if (limit == 0) {
+        if (limit < 0)
+            throw new IllegalArgumentException("limit is negative:" + limit);
+        if (limit == 0)
             return 0;
-        }
         LinkedQueueAtomicNode<E> tail = newNode(s.get());
         final LinkedQueueAtomicNode<E> head = tail;
         for (int i = 1; i < limit; i++) {

File: jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java
Patch:
@@ -767,7 +767,7 @@ private static final Object putIfMatch0(
           (expVal != MATCH_ANY || V == TOMBSTONE || V == null) &&
           !(V==null && expVal == TOMBSTONE) &&    // Match on null/TOMBSTONE combo
           (expVal == null || !expVal.equals(V)) ) // Expensive equals check at the last
-        return V;                                 // Do not update!
+        return (V==null) ? TOMBSTONE : V;         // Do not update!
 
       // Actually change the Value in the Key,Value pair
       if( CAS_val(kvs, idx, V, putval ) ) break;

File: jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java
Patch:
@@ -561,8 +561,8 @@ private Object putIfMatch( final long key, final Object putval, final Object exp
         if( K == NO_KEY ) {     // Slot is free?
           // Found an empty Key slot - which means this Key has never been in
           // this table.  No need to put a Tombstone - the Key is not here!
-          if( putval == TOMBSTONE ) return putval; // Not-now & never-been in this table
-          if( expVal == MATCH_ANY ) return null;   // Will not match, even after K inserts
+          if( putval == TOMBSTONE ) return TOMBSTONE; // Not-now & never-been in this table
+          if( expVal == MATCH_ANY ) return TOMBSTONE; // Will not match, even after K inserts
           // Claim the zero key-slot
           if( CAS_key(idx, NO_KEY, key) ) { // Claim slot for Key
             _slots.add(1);      // Raise key-slots-used count
@@ -635,7 +635,7 @@ private Object putIfMatch( final long key, final Object putval, final Object exp
           (expVal != MATCH_ANY || V == TOMBSTONE || V == null) &&
           !(V==null && expVal == TOMBSTONE) &&    // Match on null/TOMBSTONE combo
           (expVal == null || !expVal.equals(V)) ) // Expensive equals check at the last
-        return V;                                 // Do not update!
+        return (V==null) ? TOMBSTONE : V;         // Do not update!
 
       // Actually change the Value in the Key,Value pair
       if( CAS_val(idx, V, putval ) ) {

File: jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java
Patch:
@@ -669,8 +669,8 @@ private static final Object putIfMatch0(
       if( K == null ) {         // Slot is free?
         // Found an empty Key slot - which means this Key has never been in
         // this table.  No need to put a Tombstone - the Key is not here!
-        if( putval == TOMBSTONE ) return putval; // Not-now & never-been in this table
-        if( expVal == MATCH_ANY ) return null;   // Will not match, even after K inserts
+        if( putval == TOMBSTONE ) return TOMBSTONE; // Not-now & never-been in this table
+        if( expVal == MATCH_ANY ) return TOMBSTONE; // Will not match, even after K inserts
         // Claim the null key-slot
         if( CAS_key(kvs,idx, null, key ) ) { // Claim slot for Key
           chm._slots.add(1);      // Raise key-slots-used count

File: jctools-core/src/main/java/org/jctools/queues/package-info.java
Patch:
@@ -29,7 +29,7 @@
  * <br>
  * <b>Limited Queue methods support:</b><br>
  * The queues implement a subset of the {@link java.util.Queue} interface which is documented under the
- * {@link org.jctools.queues.MessagePassingQueue} interface. In particular {@link java.util.Queue#iterator()} is not
+ * {@link org.jctools.queues.MessagePassingQueue} interface. In particular {@link java.util.Queue#iterator()} is usually not
  * supported and dependent methods from {@link java.util.AbstractQueue} are also not supported such as:
  * <ol>
  * <li>{@link java.util.Queue#remove(Object)}
@@ -38,6 +38,7 @@
  * <li>{@link java.util.Queue#contains(Object)}
  * <li>{@link java.util.Queue#containsAll(java.util.Collection)}
  * </ol>
+ * A few queues do support a limited form of iteration. This support is documented in the Javadoc of the relevant queues.
  * <p>
  * <br>
  * <b>Memory layout controls and False Sharing:</b><br>

File: jctools-core/src/main/java/org/jctools/util/UnsafeRefArrayAccess.java
Patch:
@@ -48,7 +48,7 @@ else if (8 == scale)
         }
         else
         {
-            throw new IllegalStateException("Unknown pointer size");
+            throw new IllegalStateException("Unknown pointer size: " + scale);
         }
         REF_ARRAY_BASE = UnsafeAccess.UNSAFE.arrayBaseOffset(Object[].class);
     }

File: jctools-core/src/main/java/org/jctools/util/UnsafeRefArrayAccess.java
Patch:
@@ -48,7 +48,7 @@ else if (8 == scale)
         }
         else
         {
-            throw new IllegalStateException("Unknown pointer size");
+            throw new IllegalStateException("Unknown pointer size: " + scale);
         }
         REF_ARRAY_BASE = UnsafeAccess.UNSAFE.arrayBaseOffset(Object[].class);
     }

File: jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicArrayQueueGenerator.java
Patch:
@@ -551,14 +551,16 @@ public static void main(String[] args) throws Exception {
             }
             outputFileName += ".java";
 
+            File outputFile = new File(outputDirectory, outputFileName);
             try {
-                writer = new FileWriter(new File(outputDirectory, outputFileName));
+                writer = new FileWriter(outputFile);
                 writer.write(cu.toString());
             } finally {
                 if (writer != null) {
                     writer.close();
                 }
             }
+            System.out.println("Saved to " + outputFile);
         }
     }
 

File: jctools-build/src/main/java/org/jctools/queues/atomic/JavaParsingAtomicLinkedQueueGenerator.java
Patch:
@@ -89,7 +89,6 @@ public void visit(ClassOrInterfaceDeclaration node, Void arg) {
              * Special case for MPSC
              */
             node.removeModifier(Modifier.ABSTRACT);
-            node.addModifier(Modifier.FINAL);
         }
 
         if (isCommentPresent(node, GEN_DIRECTIVE_CLASS_CONTAINS_ORDERED_FIELD_ACCESSORS)) {

File: jctools-core/src/main/java/org/jctools/queues/atomic/MpscLinkedAtomicQueue.java
Patch:
@@ -42,7 +42,7 @@
  * @param <E> the type of elements in this queue
  * @author nitsanw
  */
-public final class MpscLinkedAtomicQueue<E> extends BaseLinkedAtomicQueue<E> {
+public class MpscLinkedAtomicQueue<E> extends BaseLinkedAtomicQueue<E> {
 
     public MpscLinkedAtomicQueue() {
         LinkedQueueAtomicNode<E> node = newNode();

File: jctools-core/src/main/java/org/jctools/queues/atomic/MpscLinkedAtomicQueue.java
Patch:
@@ -42,7 +42,7 @@
  * @param <E> the type of elements in this queue
  * @author nitsanw
  */
-public final class MpscLinkedAtomicQueue<E> extends BaseLinkedAtomicQueue<E> {
+public class MpscLinkedAtomicQueue<E> extends BaseLinkedAtomicQueue<E> {
 
     public MpscLinkedAtomicQueue() {
         LinkedQueueAtomicNode<E> node = newNode();

File: jctools-core/src/test/java/org/jctools/maps/KeyAtomicityTest.java
Patch:
@@ -1,11 +1,11 @@
 package org.jctools.maps;
 
-import org.junit.Test;
-
 import java.util.*;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import org.junit.Test;
+
 import static org.junit.Assert.assertEquals;
 
 public class KeyAtomicityTest

File: jctools-core/src/test/java/org/jctools/queues/ScQueueRemoveTest.java
Patch:
@@ -1,12 +1,12 @@
 package org.jctools.queues;
 
-import org.junit.Test;
-
 import java.util.Queue;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.locks.LockSupport;
 
+import org.junit.Test;
+
 import static org.junit.Assert.*;
 
 public abstract class ScQueueRemoveTest

File: jctools-core/src/test/java/org/jctools/queues/atomic/MpscLinkedAtomicQueueRemoveTest.java
Patch:
@@ -1,9 +1,9 @@
 package org.jctools.queues.atomic;
 
-import org.jctools.queues.ScQueueRemoveTest;
-
 import java.util.Queue;
 
+import org.jctools.queues.ScQueueRemoveTest;
+
 public class MpscLinkedAtomicQueueRemoveTest extends ScQueueRemoveTest {
     @Override
     protected Queue<Integer> newQueue() {

File: jctools-core/src/test/java/org/jctools/queues/matchers/Matchers.java
Patch:
@@ -1,9 +1,9 @@
 package org.jctools.queues.matchers;
 
-import org.hamcrest.Matcher;
-
 import java.util.Collection;
 
+import org.hamcrest.Matcher;
+
 import static org.hamcrest.Matchers.*;
 
 /**

File: jctools-core/src/test/java/org/jctools/queues/MpqSanityTestMpscCompound.java
Patch:
@@ -2,6 +2,7 @@
 
 import org.jctools.queues.spec.ConcurrentQueueSpec;
 import org.jctools.queues.spec.Ordering;
+import org.jctools.util.Pow2;
 import org.junit.Ignore;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -23,7 +24,7 @@ public MpqSanityTestMpscCompound(ConcurrentQueueSpec spec, MessagePassingQueue<I
     public static Collection<Object[]> parameters()
     {
         ArrayList<Object[]> list = new ArrayList<Object[]>();
-        list.add(makeMpq(0, 1, CPUs, Ordering.NONE, null));// MPSC size 1
+        list.add(makeMpq(0, 1, Pow2.roundToPowerOfTwo(CPUs), Ordering.NONE, null));// MPSC size 1
         list.add(makeMpq(0, 1, SIZE, Ordering.NONE, null));// MPSC size SIZE
         return list;
     }

File: jctools-core/src/test/java/org/jctools/queues/QueueSanityTestMpscCompound.java
Patch:
@@ -2,6 +2,7 @@
 
 import org.jctools.queues.spec.ConcurrentQueueSpec;
 import org.jctools.queues.spec.Ordering;
+import org.jctools.util.Pow2;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -26,7 +27,7 @@ public QueueSanityTestMpscCompound(ConcurrentQueueSpec spec, Queue<Integer> queu
     public static Collection<Object[]> parameters()
     {
         ArrayList<Object[]> list = new ArrayList<Object[]>();
-        list.add(makeQueue(0, 1, CPUs, Ordering.NONE, null));
+        list.add(makeQueue(0, 1, Pow2.roundToPowerOfTwo(CPUs), Ordering.NONE, null));
         list.add(makeQueue(0, 1, SIZE, Ordering.NONE, null));
         return list;
     }

File: jctools-core/src/test/java/org/jctools/queues/atomic/AtomicMpqSanityTestMpscCompound.java
Patch:
@@ -5,6 +5,7 @@
 import org.jctools.queues.MpqSanityTestMpscCompound;
 import org.jctools.queues.spec.ConcurrentQueueSpec;
 import org.jctools.queues.spec.Ordering;
+import org.jctools.util.Pow2;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
@@ -25,7 +26,7 @@ public AtomicMpqSanityTestMpscCompound(ConcurrentQueueSpec spec, MessagePassingQ
     public static Collection<Object[]> parameters()
     {
         ArrayList<Object[]> list = new ArrayList<Object[]>();
-        list.add(makeAtomic(0, 1, CPUs, Ordering.NONE, null));// MPSC size 1
+        list.add(makeAtomic(0, 1, Pow2.roundToPowerOfTwo(CPUs), Ordering.NONE, null));// MPSC size 1
         list.add(makeAtomic(0, 1, SIZE, Ordering.NONE, null));// MPSC size SIZE
         return list;
     }

File: jctools-benchmarks/src/main/java/org/jctools/jmh/collections/ConcurrentSetThroughput.java
Patch:
@@ -1,7 +1,7 @@
 package org.jctools.jmh.collections;
 
 import org.jctools.maps.NonBlockingHashSet;
-import org.jctools.maps.nhbm_test.SimpleRandom;
+import org.jctools.maps.nbhm_test.SimpleRandom;
 import org.jctools.sets.SingleWriterHashSet;
 import org.jctools.util.Pow2;
 import org.openjdk.jmh.annotations.*;

File: jctools-benchmarks/src/main/java/org/jctools/maps/nbhm_test/SimpleRandom.java
Patch:
@@ -1,4 +1,4 @@
-package org.jctools.maps.nhbm_test;
+package org.jctools.maps.nbhm_test;
 
 import java.util.concurrent.atomic.AtomicLong;
 

File: jctools-benchmarks/src/main/java/org/jctools/maps/nbhm_test/jmh/ConcurrentMapThroughput.java
Patch:
@@ -1,7 +1,7 @@
-package org.jctools.maps.nhbm_test.jmh;
+package org.jctools.maps.nbhm_test.jmh;
 
 import org.jctools.maps.NonBlockingHashMap;
-import org.jctools.maps.nhbm_test.SimpleRandom;
+import org.jctools.maps.nbhm_test.SimpleRandom;
 import org.jctools.util.Pow2;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;

File: jctools-benchmarks/src/main/java/org/jctools/maps/nbhm_test/perf_hash_test.java
Patch:
@@ -1,4 +1,4 @@
-package org.jctools.maps.nhbm_test;
+package org.jctools.maps.nbhm_test;
 
 import java.util.Random;
 import java.util.concurrent.ConcurrentHashMap;

File: jctools-benchmarks/src/main/java/org/jctools/maps/nbhm_test/perf_hashlong_test.java
Patch:
@@ -1,4 +1,4 @@
-package org.jctools.maps.nhbm_test;
+package org.jctools.maps.nbhm_test;
 
 import java.util.Random;
 import java.util.concurrent.atomic.AtomicLong;

File: jctools-benchmarks/src/main/java/org/jctools/maps/nbhm_test/perf_set_test.java
Patch:
@@ -1,4 +1,4 @@
-package org.jctools.maps.nhbm_test;
+package org.jctools.maps.nbhm_test;
 
 import java.util.AbstractSet;
 import java.util.Random;

File: jctools-benchmarks/src/main/java/org/jctools/jmh/collections/ConcurrentSetThroughput.java
Patch:
@@ -1,7 +1,7 @@
 package org.jctools.jmh.collections;
 
 import org.jctools.maps.NonBlockingHashSet;
-import org.jctools.maps.nhbm_test.SimpleRandom;
+import org.jctools.maps.nbhm_test.SimpleRandom;
 import org.jctools.sets.SingleWriterHashSet;
 import org.jctools.util.Pow2;
 import org.openjdk.jmh.annotations.*;

File: jctools-benchmarks/src/main/java/org/jctools/maps/nbhm_test/SimpleRandom.java
Patch:
@@ -1,4 +1,4 @@
-package org.jctools.maps.nhbm_test;
+package org.jctools.maps.nbhm_test;
 
 import java.util.concurrent.atomic.AtomicLong;
 

File: jctools-benchmarks/src/main/java/org/jctools/maps/nbhm_test/jmh/ConcurrentMapThroughput.java
Patch:
@@ -1,7 +1,7 @@
-package org.jctools.maps.nhbm_test.jmh;
+package org.jctools.maps.nbhm_test.jmh;
 
 import org.jctools.maps.NonBlockingHashMap;
-import org.jctools.maps.nhbm_test.SimpleRandom;
+import org.jctools.maps.nbhm_test.SimpleRandom;
 import org.jctools.util.Pow2;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;

File: jctools-benchmarks/src/main/java/org/jctools/maps/nbhm_test/perf_hash_test.java
Patch:
@@ -1,4 +1,4 @@
-package org.jctools.maps.nhbm_test;
+package org.jctools.maps.nbhm_test;
 
 import java.util.Random;
 import java.util.concurrent.ConcurrentHashMap;

File: jctools-benchmarks/src/main/java/org/jctools/maps/nbhm_test/perf_hashlong_test.java
Patch:
@@ -1,4 +1,4 @@
-package org.jctools.maps.nhbm_test;
+package org.jctools.maps.nbhm_test;
 
 import java.util.Random;
 import java.util.concurrent.atomic.AtomicLong;

File: jctools-benchmarks/src/main/java/org/jctools/maps/nbhm_test/perf_set_test.java
Patch:
@@ -1,4 +1,4 @@
-package org.jctools.maps.nhbm_test;
+package org.jctools.maps.nbhm_test;
 
 import java.util.AbstractSet;
 import java.util.Random;

File: jctools-core/src/test/java/org/jctools/queues/MpqSanityTestMpscCompound.java
Patch:
@@ -2,6 +2,7 @@
 
 import org.jctools.queues.spec.ConcurrentQueueSpec;
 import org.jctools.queues.spec.Ordering;
+import org.jctools.util.Pow2;
 import org.junit.Ignore;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -23,7 +24,7 @@ public MpqSanityTestMpscCompound(ConcurrentQueueSpec spec, MessagePassingQueue<I
     public static Collection<Object[]> parameters()
     {
         ArrayList<Object[]> list = new ArrayList<Object[]>();
-        list.add(makeMpq(0, 1, CPUs, Ordering.NONE, null));// MPSC size 1
+        list.add(makeMpq(0, 1, Pow2.roundToPowerOfTwo(CPUs), Ordering.NONE, null));// MPSC size 1
         list.add(makeMpq(0, 1, SIZE, Ordering.NONE, null));// MPSC size SIZE
         return list;
     }

File: jctools-core/src/test/java/org/jctools/queues/QueueSanityTestMpscCompound.java
Patch:
@@ -2,6 +2,7 @@
 
 import org.jctools.queues.spec.ConcurrentQueueSpec;
 import org.jctools.queues.spec.Ordering;
+import org.jctools.util.Pow2;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -26,7 +27,7 @@ public QueueSanityTestMpscCompound(ConcurrentQueueSpec spec, Queue<Integer> queu
     public static Collection<Object[]> parameters()
     {
         ArrayList<Object[]> list = new ArrayList<Object[]>();
-        list.add(makeQueue(0, 1, CPUs, Ordering.NONE, null));
+        list.add(makeQueue(0, 1, Pow2.roundToPowerOfTwo(CPUs), Ordering.NONE, null));
         list.add(makeQueue(0, 1, SIZE, Ordering.NONE, null));
         return list;
     }

File: jctools-core/src/test/java/org/jctools/queues/atomic/AtomicMpqSanityTestMpscCompound.java
Patch:
@@ -5,6 +5,7 @@
 import org.jctools.queues.MpqSanityTestMpscCompound;
 import org.jctools.queues.spec.ConcurrentQueueSpec;
 import org.jctools.queues.spec.Ordering;
+import org.jctools.util.Pow2;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
@@ -25,7 +26,7 @@ public AtomicMpqSanityTestMpscCompound(ConcurrentQueueSpec spec, MessagePassingQ
     public static Collection<Object[]> parameters()
     {
         ArrayList<Object[]> list = new ArrayList<Object[]>();
-        list.add(makeAtomic(0, 1, CPUs, Ordering.NONE, null));// MPSC size 1
+        list.add(makeAtomic(0, 1, Pow2.roundToPowerOfTwo(CPUs), Ordering.NONE, null));// MPSC size 1
         list.add(makeAtomic(0, 1, SIZE, Ordering.NONE, null));// MPSC size SIZE
         return list;
     }

File: jctools-core/src/main/java/org/jctools/queues/SpscGrowableArrayQueue.java
Patch:
@@ -114,7 +114,7 @@ final boolean offerColdPath(
                     long currConsumerIndex = lvConsumerIndex();
                     // use lookAheadStep to store the consumer distance from final buffer
                     this.lookAheadStep = -(index - currConsumerIndex);
-                    producerBufferLimit = currConsumerIndex + maxCapacity - 1;
+                    producerBufferLimit = currConsumerIndex + maxCapacity;
                 }
                 else
                 {

File: jctools-core/src/main/java/org/jctools/queues/atomic/SpscGrowableAtomicArrayQueue.java
Patch:
@@ -106,7 +106,7 @@ final boolean offerColdPath(final AtomicReferenceArray<E> buffer, final long mas
                     long currConsumerIndex = lvConsumerIndex();
                     // use lookAheadStep to store the consumer distance from final buffer
                     this.lookAheadStep = -(index - currConsumerIndex);
-                    producerBufferLimit = currConsumerIndex + maxCapacity - 1;
+                    producerBufferLimit = currConsumerIndex + maxCapacity;
                 } else {
                     producerBufferLimit = index + producerMask - 1;
                     adjustLookAheadStep(newCapacity);

File: jctools-core/src/main/java/org/jctools/queues/SpscGrowableArrayQueue.java
Patch:
@@ -114,7 +114,7 @@ final boolean offerColdPath(
                     long currConsumerIndex = lvConsumerIndex();
                     // use lookAheadStep to store the consumer distance from final buffer
                     this.lookAheadStep = -(index - currConsumerIndex);
-                    producerBufferLimit = currConsumerIndex + maxCapacity - 1;
+                    producerBufferLimit = currConsumerIndex + maxCapacity;
                 }
                 else
                 {

File: jctools-core/src/main/java/org/jctools/queues/atomic/SpscGrowableAtomicArrayQueue.java
Patch:
@@ -106,7 +106,7 @@ final boolean offerColdPath(final AtomicReferenceArray<E> buffer, final long mas
                     long currConsumerIndex = lvConsumerIndex();
                     // use lookAheadStep to store the consumer distance from final buffer
                     this.lookAheadStep = -(index - currConsumerIndex);
-                    producerBufferLimit = currConsumerIndex + maxCapacity - 1;
+                    producerBufferLimit = currConsumerIndex + maxCapacity;
                 } else {
                     producerBufferLimit = index + producerMask - 1;
                     adjustLookAheadStep(newCapacity);

File: jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/MpqDrainFillThroughputBackoffNone.java
Patch:
@@ -39,8 +39,8 @@
 @Warmup(iterations = 10, time = 1)
 @Measurement(iterations = 10, time = 1)
 public class MpqDrainFillThroughputBackoffNone {
-    static final Integer TEST_ELEMENT = 1;
-    Integer element = TEST_ELEMENT;
+    static final Object TEST_ELEMENT = 1;
+    Integer element = 1;
     Integer escape;
     MessagePassingQueue<Integer> q;
 

File: jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/MpqThroughputBackoffNone.java
Patch:
@@ -41,8 +41,8 @@
 public class MpqThroughputBackoffNone {
     private static final long DELAY_PRODUCER = Long.getLong("delay.p", 0L);
     private static final long DELAY_CONSUMER = Long.getLong("delay.c", 0L);
-    static final Integer TEST_ELEMENT = 1;
-    Integer element = TEST_ELEMENT;
+    static final Object TEST_ELEMENT = 1;
+    Integer element = 1;
     Integer escape;
     MessagePassingQueue<Integer> q;
 

File: jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/QueueThroughputBackoffNone.java
Patch:
@@ -28,8 +28,8 @@
 public class QueueThroughputBackoffNone {
     static final long DELAY_PRODUCER = Long.getLong("delay.p", 0L);
     static final long DELAY_CONSUMER = Long.getLong("delay.c", 0L);
-    static final Integer TEST_ELEMENT = 1;
-    Integer element = TEST_ELEMENT;
+    static final Object TEST_ELEMENT = 1;
+    Integer element = 1;
     Integer escape;
     Queue<Integer> q;
 

File: jctools-core/src/main/java/org/jctools/queues/LinkedArrayQueueUtil.java
Patch:
@@ -3,6 +3,9 @@
 import static org.jctools.util.UnsafeRefArrayAccess.REF_ARRAY_BASE;
 import static org.jctools.util.UnsafeRefArrayAccess.REF_ELEMENT_SHIFT;
 
+/**
+ * This is used for method substitution in the LinkedArray classes code generation.
+ */
 final class LinkedArrayQueueUtil
 {
     private LinkedArrayQueueUtil()

File: jctools-core/src/main/java/org/jctools/queues/MpmcArrayQueue.java
Patch:
@@ -50,7 +50,7 @@ public final long lvProducerIndex()
         return producerIndex;
     }
 
-    protected final boolean casProducerIndex(long expect, long newValue)
+    final boolean casProducerIndex(long expect, long newValue)
     {
         return UNSAFE.compareAndSwapLong(this, P_INDEX_OFFSET, expect, newValue);
     }
@@ -85,7 +85,7 @@ public final long lvConsumerIndex()
         return consumerIndex;
     }
 
-    protected final boolean casConsumerIndex(long expect, long newValue)
+    final boolean casConsumerIndex(long expect, long newValue)
     {
         return UNSAFE.compareAndSwapLong(this, C_INDEX_OFFSET, expect, newValue);
     }

File: jctools-core/src/main/java/org/jctools/queues/MpscLinkedQueue7.java
Patch:
@@ -28,7 +28,7 @@ protected final LinkedQueueNode<E> xchgProducerNode(LinkedQueueNode<E> newVal)
         Object oldVal;
         do
         {
-            oldVal = producerNode;
+            oldVal = lvProducerNode();
         }
         while (!UNSAFE.compareAndSwapObject(this, P_NODE_OFFSET, oldVal, newVal));
         return (LinkedQueueNode<E>) oldVal;

File: jctools-core/src/main/java/org/jctools/queues/SpscLinkedQueue.java
Patch:
@@ -130,15 +130,15 @@ public int fill(Supplier<E> s, int limit)
     @Override
     public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit)
     {
-        LinkedQueueNode<E> chaserNode = producerNode;
+        LinkedQueueNode<E> chaserNode = lpProducerNode();
         while (exit.keepRunning())
         {
             for (int i = 0; i < 4096; i++)
             {
                 final LinkedQueueNode<E> nextNode = newNode(s.get());
                 chaserNode.soNext(nextNode);
                 chaserNode = nextNode;
-                this.producerNode = chaserNode;
+                this.spProducerNode(chaserNode);
             }
         }
     }

File: jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java
Patch:
@@ -53,7 +53,7 @@ public final long lvProducerIndex() {
         return producerIndex;
     }
 
-    protected final boolean casProducerIndex(long expect, long newValue) {
+    final boolean casProducerIndex(long expect, long newValue) {
         return P_INDEX_UPDATER.compareAndSet(this, expect, newValue);
     }
 }
@@ -92,7 +92,7 @@ public final long lvConsumerIndex() {
         return consumerIndex;
     }
 
-    protected final boolean casConsumerIndex(long expect, long newValue) {
+    final boolean casConsumerIndex(long expect, long newValue) {
         return C_INDEX_UPDATER.compareAndSet(this, expect, newValue);
     }
 }

File: jctools-core/src/main/java/org/jctools/queues/atomic/MpscLinkedAtomicQueue.java
Patch:
@@ -42,7 +42,7 @@
  * @param <E> the type of elements in this queue
  * @author nitsanw
  */
-public class MpscLinkedAtomicQueue<E> extends BaseLinkedAtomicQueue<E> {
+public final class MpscLinkedAtomicQueue<E> extends BaseLinkedAtomicQueue<E> {
 
     public MpscLinkedAtomicQueue() {
         LinkedQueueAtomicNode<E> node = newNode();

File: jctools-core/src/main/java/org/jctools/queues/atomic/SpscLinkedAtomicQueue.java
Patch:
@@ -133,13 +133,13 @@ public int fill(Supplier<E> s, int limit) {
 
     @Override
     public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {
-        LinkedQueueAtomicNode<E> chaserNode = producerNode;
+        LinkedQueueAtomicNode<E> chaserNode = lpProducerNode();
         while (exit.keepRunning()) {
             for (int i = 0; i < 4096; i++) {
                 final LinkedQueueAtomicNode<E> nextNode = newNode(s.get());
                 chaserNode.soNext(nextNode);
                 chaserNode = nextNode;
-                this.producerNode = chaserNode;
+                this.spProducerNode(chaserNode);
             }
         }
     }

File: jctools-core/src/test/java/org/jctools/queues/SpscArrayQueueTest.java
Patch:
@@ -15,8 +15,8 @@ public void shouldWorkAfterWrap()
         // Arrange
         final SpscArrayQueue<Object> q = new SpscArrayQueue<Object>(1024);
         // starting point for empty queue at max long, next offer will wrap the producerIndex
-        q.consumerIndex = Long.MAX_VALUE;
-        q.producerIndex = Long.MAX_VALUE;
+        q.soConsumerIndex(Long.MAX_VALUE);
+        q.soProducerIndex(Long.MAX_VALUE);
         q.producerLimit = Long.MAX_VALUE;
         // valid starting point
         assertThat(q, emptyAndZeroSize());

File: jctools-core/src/test/java/org/jctools/queues/atomic/SpscAtomicArrayQueueTest.java
Patch:
@@ -28,8 +28,8 @@ public void shouldWorkAfterWrap()
         // Arrange
         final SpscAtomicArrayQueue<Object> q = new SpscAtomicArrayQueue<Object>(1024);
         // starting point for empty queue at max long, next offer will wrap the producerIndex
-        q.consumerIndex = Long.MAX_VALUE;
-        q.producerIndex = Long.MAX_VALUE;
+        q.soConsumerIndex(Long.MAX_VALUE);
+        q.soProducerIndex(Long.MAX_VALUE);
         q.producerLimit = Long.MAX_VALUE;
         // valid starting point
         assertThat(q, emptyAndZeroSize());

File: jctools-core/src/main/java/org/jctools/queues/atomic/MpscLinkedAtomicQueue.java
Patch:
@@ -42,7 +42,7 @@
  * @param <E> the type of elements in this queue
  * @author nitsanw
  */
-public final class MpscLinkedAtomicQueue<E> extends BaseLinkedAtomicQueue<E> {
+public class MpscLinkedAtomicQueue<E> extends BaseLinkedAtomicQueue<E> {
 
     public MpscLinkedAtomicQueue() {
         LinkedQueueAtomicNode<E> node = newNode();

File: jctools-core/src/test/java/org/jctools/queues/atomic/AtomicQueueSanityTestMpscRelaxedArray.java
Patch:
@@ -40,8 +40,8 @@ public static Collection<Object[]> parameters()
     {
         ArrayList<Object[]> list = new ArrayList<Object[]>();
         // need at least size 2 for this test
-        list.add(makeQueue(0, 1, 2, Ordering.FIFO, new MpscRelaxedAtomicArrayQueue<>(2)));
-        list.add(makeQueue(0, 1, SIZE, Ordering.FIFO, new MpscRelaxedAtomicArrayQueue<>(SIZE)));
+        list.add(makeQueue(1, 1, 2, Ordering.FIFO, new MpscRelaxedAtomicArrayQueue<>(2)));
+        list.add(makeQueue(1, 1, SIZE, Ordering.FIFO, new MpscRelaxedAtomicArrayQueue<>(SIZE)));
         return list;
     }
 }

File: jctools-core/src/test/java/org/jctools/queues/atomic/AtomicQueueSanityTestMpscRelaxedArray.java
Patch:
@@ -40,8 +40,8 @@ public static Collection<Object[]> parameters()
     {
         ArrayList<Object[]> list = new ArrayList<Object[]>();
         // need at least size 2 for this test
-        list.add(makeQueue(0, 1, 2, Ordering.FIFO, new MpscRelaxedAtomicArrayQueue<>(2)));
-        list.add(makeQueue(0, 1, SIZE, Ordering.FIFO, new MpscRelaxedAtomicArrayQueue<>(SIZE)));
+        list.add(makeQueue(1, 1, 2, Ordering.FIFO, new MpscRelaxedAtomicArrayQueue<>(2)));
+        list.add(makeQueue(1, 1, SIZE, Ordering.FIFO, new MpscRelaxedAtomicArrayQueue<>(SIZE)));
         return list;
     }
 }

File: jctools-core/src/test/java/org/jctools/queues/MpqSanityTestMpscRelaxedArray.java
Patch:
@@ -37,8 +37,8 @@ public MpqSanityTestMpscRelaxedArray(ConcurrentQueueSpec spec, MessagePassingQue
     public static Collection<Object[]> parameters()
     {
         ArrayList<Object[]> list = new ArrayList<Object[]>();
-        list.add(makeMpq(0, 1, 2, Ordering.FIFO, new MpscRelaxedArrayQueue<>(2)));// MPSC size 2
-        list.add(makeMpq(0, 1, SIZE, Ordering.FIFO, new MpscRelaxedArrayQueue<>(SIZE)));// MPSC size SIZE
+        list.add(makeMpq(1, 1, 2, Ordering.FIFO, new MpscRelaxedArrayQueue<>(2)));// MPSC size 2
+        list.add(makeMpq(1, 1, SIZE, Ordering.FIFO, new MpscRelaxedArrayQueue<>(SIZE)));// MPSC size SIZE
         return list;
     }
 }

File: jctools-core/src/test/java/org/jctools/queues/QueueSanityTestMpscRelaxed.java
Patch:
@@ -36,8 +36,8 @@ public QueueSanityTestMpscRelaxed(ConcurrentQueueSpec spec, Queue<Integer> queue
     public static Collection<Object[]> parameters()
     {
         ArrayList<Object[]> list = new ArrayList<Object[]>();
-        list.add(makeQueue(0, 1, 2, Ordering.FIFO, new MpscRelaxedArrayQueue<Integer>(2)));// MPSC size 1
-        list.add(makeQueue(0, 1, SIZE, Ordering.FIFO, new MpscRelaxedArrayQueue<Integer>(SIZE)));// MPSC size SIZE
+        list.add(makeQueue(1, 1, 2, Ordering.FIFO, new MpscRelaxedArrayQueue<Integer>(2)));// MPSC size 1
+        list.add(makeQueue(1, 1, SIZE, Ordering.FIFO, new MpscRelaxedArrayQueue<Integer>(SIZE)));// MPSC size SIZE
         return list;
     }
 

File: jctools-core/src/test/java/org/jctools/queues/MpqSanityTestMpscCompound.java
Patch:
@@ -12,7 +12,6 @@
 import static org.jctools.util.PortableJvmInfo.CPUs;
 
 @RunWith(Parameterized.class)
-@Ignore
 public class MpqSanityTestMpscCompound extends MpqSanityTest
 {
     public MpqSanityTestMpscCompound(ConcurrentQueueSpec spec, MessagePassingQueue<Integer> queue)

File: jctools-core/src/test/java/org/jctools/queues/MpqSanityTestMpscCompound.java
Patch:
@@ -2,6 +2,7 @@
 
 import org.jctools.queues.spec.ConcurrentQueueSpec;
 import org.jctools.queues.spec.Ordering;
+import org.junit.Ignore;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
@@ -11,6 +12,7 @@
 import static org.jctools.util.PortableJvmInfo.CPUs;
 
 @RunWith(Parameterized.class)
+@Ignore
 public class MpqSanityTestMpscCompound extends MpqSanityTest
 {
     public MpqSanityTestMpscCompound(ConcurrentQueueSpec spec, MessagePassingQueue<Integer> queue)

File: jctools-core/src/test/java/org/jctools/queues/QueueSanityTestSpscGrowable.java
Patch:
@@ -22,8 +22,8 @@ public QueueSanityTestSpscGrowable(ConcurrentQueueSpec spec, Queue<Integer> queu
     public static Collection<Object[]> parameters()
     {
         ArrayList<Object[]> list = new ArrayList<Object[]>();
-        list.add(makeQueue(0, 1, 16, Ordering.FIFO, new SpscGrowableArrayQueue<>(8, 16)));
-        list.add(makeQueue(0, 1, SIZE, Ordering.FIFO, new SpscGrowableArrayQueue<>(8, SIZE)));
+        list.add(makeQueue(1, 1, 16, Ordering.FIFO, new SpscGrowableArrayQueue<>(8, 16)));
+        list.add(makeQueue(1, 1, SIZE, Ordering.FIFO, new SpscGrowableArrayQueue<>(8, SIZE)));
         return list;
     }
 

File: jctools-core/src/test/java/org/jctools/queues/atomic/AtomicQueueSanityTestSpscGrowable.java
Patch:
@@ -23,8 +23,8 @@ public AtomicQueueSanityTestSpscGrowable(ConcurrentQueueSpec spec, Queue<Integer
     public static Collection<Object[]> parameters()
     {
         ArrayList<Object[]> list = new ArrayList<Object[]>();
-        list.add(makeAtomic(0, 1, 16, Ordering.FIFO, new SpscGrowableAtomicArrayQueue<>(8, 16)));
-        list.add(makeAtomic(0, 1, SIZE, Ordering.FIFO, new SpscGrowableAtomicArrayQueue<>(8, SIZE)));
+        list.add(makeAtomic(1, 1, 16, Ordering.FIFO, new SpscGrowableAtomicArrayQueue<>(8, 16)));
+        list.add(makeAtomic(1, 1, SIZE, Ordering.FIFO, new SpscGrowableAtomicArrayQueue<>(8, SIZE)));
         return list;
     }
 

File: jctools-core/src/test/java/org/jctools/queues/MpqSanityTest.java
Patch:
@@ -104,6 +104,8 @@ public void sanity()
     @Test
     public void sanityDrainBatch()
     {
+        assumeThat(spec.ordering, not(Ordering.NONE));
+
         assertEquals(0, queue.drain(e ->
         {
         }, SIZE));
@@ -174,6 +176,7 @@ public void testSizeIsTheNumberOfOffers()
     public void supplyMessageUntilFull()
     {
         assumeThat(spec.isBounded(), is(Boolean.TRUE));
+        assumeThat(spec.ordering, not(Ordering.NONE));
         final Val instances = new Val();
         instances.value = 0;
         final MessagePassingQueue.Supplier<Integer> messageFactory = () -> instances.value++;

File: jctools-core/src/main/java/org/jctools/queues/atomic/SpscLinkedAtomicQueue.java
Patch:
@@ -13,6 +13,8 @@
  */
 package org.jctools.queues.atomic;
 
+import org.jctools.queues.MessagePassingQueue;
+
 /**
  * This is a weakened version of the MPSC algorithm as presented <a
  * href="http://www.1024cores.net/home/lock-free-algorithms/queues/non-intrusive-mpsc-node-based-queue"> on 1024

File: jctools-core/src/test/java/org/jctools/queues/atomic/SpscLinkedAtomicQueueTest.java
Patch:
@@ -1,7 +1,10 @@
 package org.jctools.queues.atomic;
 
+import org.junit.Ignore;
+
 import java.util.Queue;
 
+@Ignore
 public class SpscLinkedAtomicQueueTest extends ScLinkedAtomicQueueTest {
     @Override
     protected Queue<Integer> newQueue() {

File: jctools-core/src/main/java/org/jctools/queues/SpmcArrayQueue.java
Patch:
@@ -207,7 +207,6 @@ public E peek() {
         return e;
     }
 
-
 	@Override
 	public boolean relaxedOffer(E e) {
 		if (null == e) {

File: jctools-core/src/main/java/org/jctools/queues/atomic/SpmcAtomicArrayQueue.java
Patch:
@@ -117,6 +117,7 @@ public final class SpmcAtomicArrayQueue<E> extends SpmcAtomicArrayQueueL3Pad<E>
     public SpmcAtomicArrayQueue(int capacity) {
         super(capacity);
     }
+    
     @Override
     public boolean offer(final E e) {
         if (null == e) {

File: jctools-core/src/main/java/org/jctools/queues/SpscGrowableArrayQueue.java
Patch:
@@ -98,7 +98,7 @@ final boolean offerColdPath(
                 producerMask = newBuffer.length - 2;
 
                 final long offsetInNew = calcElementOffset(index, producerMask);
-                linkOldToNew(index, buffer, offset, newBuffer, offsetInNew, s.get());
+                linkOldToNew(index, buffer, offset, newBuffer, offsetInNew, v == null ? s.get() : v);
                 int newCapacity = (int) (producerMask + 1);
                 if (newCapacity == maxCapacity)
                 {

File: jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java
Patch:
@@ -12,7 +12,6 @@
  * limitations under the License.
  */
 package org.jctools.maps;
-import static org.jctools.util.UnsafeAccess.UNSAFE;
 
 import java.io.IOException;
 import java.io.Serializable;
@@ -22,6 +21,8 @@
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
+import static org.jctools.util.UnsafeAccess.UNSAFE;
+
 /**
  * A lock-free alternate implementation of {@link java.util.concurrent.ConcurrentHashMap}
  * with better scaling properties and generally lower costs to mutate the Map.
@@ -1380,7 +1381,7 @@ public Set<Map.Entry<TypeK,TypeV>> entrySet() {
         if( !(o instanceof Map.Entry)) return false;
         final Map.Entry<?,?> e = (Map.Entry<?,?>)o;
         TypeV v = get(e.getKey());
-        return v.equals(e.getValue());
+        return v != null && v.equals(e.getValue());
       }
       @Override public Iterator<Map.Entry<TypeK,TypeV>> iterator() { return new SnapshotE(); }
     };

File: jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java
Patch:
@@ -42,7 +42,7 @@ public boolean offer(final E e) {
         final AtomicLongArray sBuffer = sequenceBuffer;
         long currentProducerIndex;
         int seqOffset;
-        long cIndex = Long.MAX_VALUE;// start with bogus value, hope we don't need it
+        long cIndex = Long.MIN_VALUE;// start with bogus value, hope we don't need it
         while (true) {
             currentProducerIndex = lvProducerIndex(); // LoadLoad
             seqOffset = calcSequenceOffset(currentProducerIndex, mask);
@@ -57,8 +57,8 @@ public boolean offer(final E e) {
                 }
                 // failed cas, retry 1
             } else if (delta < 0 && // poll has not moved this value forward
-                    currentProducerIndex - capacity <= cIndex && // test against cached cIndex
-                    currentProducerIndex - capacity <= (cIndex = lvConsumerIndex())) { // test against latest cIndex
+                    currentProducerIndex - capacity >= cIndex && // test against cached cIndex
+                    currentProducerIndex - capacity >= (cIndex = lvConsumerIndex())) { // test against latest cIndex
                 // Extra check required to ensure [Queue.offer == false iff queue is full]
                 return false;
             }

File: jctools-core/src/test/java/org/jctools/queues/atomic/AtomicQueueSanityTest.java
Patch:
@@ -33,9 +33,6 @@ public static Collection<Object[]> parameters() {
         // Compound queue minimal size is the core count
         list.add(makeAtomic(0, 1, CPUs, Ordering.NONE, null));
         list.add(makeAtomic(0, 1, SIZE, Ordering.NONE, null));
-        // Mpmc minimal size is 2
-        list.add(makeAtomic(0, 0, 2, Ordering.FIFO, null));
-        list.add(makeAtomic(0, 0, SIZE, Ordering.FIFO, null));
         return list;
     }
 

File: jctools-experimental/src/main/java/org/jctools/queues/FFBuffer.java
Patch:
@@ -70,9 +70,9 @@ public final class FFBuffer<E> extends FFBufferL3Pad<E> implements Queue<E> {
     private final static long C_INDEX_OFFSET;
     static {
         try {
-            P_INDEX_OFFSET = UnsafeAccess.UNSAFE.objectFieldOffset(FFBufferTailField.class
+            P_INDEX_OFFSET = UnsafeAccess.UNSAFE.objectFieldOffset(FFBufferHeadField.class
                     .getDeclaredField("producerIndex"));
-            C_INDEX_OFFSET = UnsafeAccess.UNSAFE.objectFieldOffset(FFBufferHeadField.class
+            C_INDEX_OFFSET = UnsafeAccess.UNSAFE.objectFieldOffset(FFBufferTailField.class
                     .getDeclaredField("consumerIndex"));
         } catch (NoSuchFieldException e) {
             throw new RuntimeException(e);

File: jctools-core/src/main/java/org/jctools/queues/MpmcArrayQueue.java
Patch:
@@ -115,7 +115,7 @@ public class MpmcArrayQueue<E> extends MpmcArrayQueueConsumerField<E> implements
     long p01, p02, p03, p04, p05, p06, p07;
     long p10, p11, p12, p13, p14, p15, p16, p17;
     final static int RECOMENDED_POLL_BATCH = CPUs * 4;
-    final static int RECOMENDED_OFFER_BATCH = CPUs * 4;
+    public final static int RECOMENDED_OFFER_BATCH = CPUs * 4;
     public MpmcArrayQueue(final int capacity) {
         super(RangeUtil.checkGreaterThanOrEqual(capacity, 2, "capacity"));
     }

File: jctools-core/src/test/java/org/jctools/queues/MpscUnboundedArrayQueueSanityTest.java
Patch:
@@ -10,7 +10,7 @@
 import org.junit.runners.Parameterized;
 
 @RunWith(Parameterized.class)
-public class MpscUnboundedQueueSanityTest extends QueueSanityTest {
+public class MpscUnboundedArrayQueueSanityTest extends QueueSanityTest {
     @Parameterized.Parameters
     public static Collection<Object[]> parameters() {
         ArrayList<Object[]> list = new ArrayList<Object[]>();
@@ -19,7 +19,7 @@ public static Collection<Object[]> parameters() {
         return list;
     }
 
-    public MpscUnboundedQueueSanityTest(ConcurrentQueueSpec spec, Queue<Integer> queue) {
+    public MpscUnboundedArrayQueueSanityTest(ConcurrentQueueSpec spec, Queue<Integer> queue) {
         super(spec, queue);
     }
 

File: jctools-core/src/test/java/org/jctools/queues/atomic/AtomicSpscLinkedArrayQueueSanityTest.java
Patch:
@@ -1,7 +1,6 @@
 package org.jctools.queues.atomic;
 
 import org.jctools.queues.QueueSanityTest;
-import org.jctools.queues.SpscChunkedArrayQueue;
 import org.jctools.queues.spec.ConcurrentQueueSpec;
 import org.jctools.queues.spec.Ordering;
 import org.junit.runner.RunWith;
@@ -17,11 +16,11 @@ public class AtomicSpscLinkedArrayQueueSanityTest extends QueueSanityTest {
     public static Collection<Object[]> parameters() {
         ArrayList<Object[]> list = new ArrayList<Object[]>();
         list.add(makeQueue(1, 1, SIZE, Ordering.FIFO, new AtomicSpscChunkedArrayQueue<Integer>(64, SIZE)));
-        //list.add(makeQueue(1, 1, SIZE, Ordering.FIFO, new AtomicSpscGrowableArrayQueue<Integer>(64, SIZE)));
+        list.add(makeQueue(1, 1, SIZE, Ordering.FIFO, new AtomicSpscGrowableArrayQueue<Integer>(64, SIZE)));
         //list.add(makeQueue(1, 1, 0, Ordering.FIFO, new AtomicSpscUnboundedArrayQueue<Integer>(16)));
         // minimal sizes
         list.add(makeQueue(1, 1, 16, Ordering.FIFO, new AtomicSpscChunkedArrayQueue<Integer>(8, 16)));
-        //list.add(makeQueue(1, 1, 16, Ordering.FIFO, new AtomicSpscGrowableArrayQueue<Integer>(8, 16)));
+        list.add(makeQueue(1, 1, 16, Ordering.FIFO, new AtomicSpscGrowableArrayQueue<Integer>(8, 16)));
         return list;
     }
 

File: jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
+import org.jctools.util.RangeUtil;
 
 /**
  * A lock-free alternate implementation of {@link java.util.concurrent.ConcurrentHashMap}
@@ -266,7 +267,7 @@ private static int reprobe_limit( int len ) {
    *  initial size will be rounded up internally to the next larger power of 2. */
   public NonBlockingHashMap( final int initial_sz ) { initialize(initial_sz); }
   private final void initialize( int initial_sz ) {
-    if( initial_sz < 0 ) throw new IllegalArgumentException();
+    RangeUtil.checkPositiveOrZero(initial_sz, "initial_sz");
     int i;                      // Convert to next largest power-of-2
     if( initial_sz > 1024*1024 ) initial_sz = 1024*1024;
     for( i=MIN_SIZE_LOG; (1<<i) < (initial_sz<<2); i++ ) ;

File: jctools-core/src/main/java/org/jctools/maps/NonBlockingIdentityHashMap.java
Patch:
@@ -31,7 +31,8 @@
 import java.util.Set;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater; 
+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
+import org.jctools.util.RangeUtil;
 
 /**
  * A lock-free alternate implementation of {@link java.util.concurrent.ConcurrentHashMap}
@@ -275,7 +276,7 @@ private static final int reprobe_limit( int len ) {
    *  initial size will be rounded up internally to the next larger power of 2. */
   public NonBlockingIdentityHashMap( final int initial_sz ) { initialize(initial_sz); }
   private final void initialize( int initial_sz ) {
-    if( initial_sz < 0 ) throw new IllegalArgumentException();
+    RangeUtil.checkPositiveOrZero(initial_sz, "initial_sz");
     int i;                      // Convert to next largest power-of-2
     if( initial_sz > 1024*1024 ) initial_sz = 1024*1024;
     for( i=MIN_SIZE_LOG; (1<<i) < (initial_sz<<2); i++ ) ;

File: jctools-core/src/main/java/org/jctools/queues/MpscGrowableArrayQueue.java
Patch:
@@ -14,6 +14,7 @@
 package org.jctools.queues;
 
 import org.jctools.util.Pow2;
+import org.jctools.util.RangeUtil;
 
 
 /**
@@ -45,9 +46,7 @@ public MpscGrowableArrayQueue(int initialCapacity, int maxCapacity) {
     @Override
     protected int getNextBufferSize(E[] buffer) {
         final long maxSize = maxQueueCapacity / 2;
-        if (buffer.length > maxSize) {
-            throw new IllegalStateException();
-        }
+        RangeUtil.checkLessThanOrEqual(buffer.length, maxSize, "buffer.length");
         final int newSize = 2 * (buffer.length - 1);
         return newSize + 1;
     }

File: jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/RingBurstRoundTripWithGroups.java
Patch:
@@ -156,7 +156,7 @@ public void clear() {
     public void prepareChain() {
         // can't have group threads set to zero on a method, so can't handle the length of 1 case
         if (CHAIN_LENGTH < 2) {
-            throw new IllegalArgumentException("Chain length must be 1 or more");
+            throw new IllegalArgumentException("Chain length must be 2 or more");
         }
         // This is an estimate, but for bounded queues if the burst size is more than actual ring capacity
         // the benchmark will hang/

File: jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/RingCqBurstRoundTripWithGroups.java
Patch:
@@ -158,7 +158,7 @@ public void clear() {
     public void prepareChain() {
         // can't have group threads set to zero on a method, so can't handle the length of 1 case
         if (CHAIN_LENGTH < 2) {
-            throw new IllegalArgumentException("Chain length must be 1 or more");
+            throw new IllegalArgumentException("Chain length must be 2 or more");
         }
         // This is an estimate, but for bounded queues if the burst size is more than actual ring capacity
         // the benchmark will hang/

File: jctools-core/src/main/java/org/jctools/queues/MpmcArrayQueue.java
Patch:
@@ -122,7 +122,7 @@ public MpmcArrayQueue(final int capacity) {
 
     private static int validateCapacity(int capacity) {
         if(capacity < 2)
-            throw new IllegalArgumentException("Minimum size is 2");
+            throw new IllegalArgumentException("Minimum size must be 2 or more");
         return capacity;
     }
 

File: jctools-core/src/main/java/org/jctools/queues/SpscChunkedArrayQueue.java
Patch:
@@ -29,11 +29,11 @@ public SpscChunkedArrayQueue(final int capacity) {
 
     public SpscChunkedArrayQueue(final int chunkSize, final int capacity) {
         if (capacity < 16) {
-            throw new IllegalArgumentException("Max capacity must be 4 or more");
+            throw new IllegalArgumentException("Max capacity must be 16 or more");
         }
         // minimal chunk size of eight makes sure minimal lookahead step is 2
         if (chunkSize < 8) {
-            throw new IllegalArgumentException("Chunk size must be 2 or more");
+            throw new IllegalArgumentException("Chunk size must be 8 or more");
         }
 
         maxQueueCapacity = Pow2.roundToPowerOfTwo(capacity);

File: jctools-core/src/main/java/org/jctools/queues/SpscGrowableArrayQueue.java
Patch:
@@ -28,11 +28,11 @@ public SpscGrowableArrayQueue(final int capacity) {
 
     public SpscGrowableArrayQueue(final int chunkSize, final int capacity) {
         if (capacity < 16) {
-            throw new IllegalArgumentException("Max capacity must be 4 or more");
+            throw new IllegalArgumentException("Max capacity must be 16 or more");
         }
         // minimal chunk size of eight makes sure minimal lookahead step is 2
         if (chunkSize < 8) {
-            throw new IllegalArgumentException("Chunk size must be 2 or more");
+            throw new IllegalArgumentException("Chunk size must be 8 or more");
         }
 
         maxQueueCapacity = Pow2.roundToPowerOfTwo(capacity);

File: jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java
Patch:
@@ -31,7 +31,7 @@ public MpmcAtomicArrayQueue(int capacity) {
 
     private static int validateCapacity(int capacity) {
         if(capacity < 2)
-            throw new IllegalArgumentException("Minimum size is 2");
+            throw new IllegalArgumentException("Minimum size must be 2 or more");
         return capacity;
     }
 

File: jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/RingBurstRoundTripWithGroups.java
Patch:
@@ -156,7 +156,7 @@ public void clear() {
     public void prepareChain() {
         // can't have group threads set to zero on a method, so can't handle the length of 1 case
         if (CHAIN_LENGTH < 2) {
-            throw new IllegalArgumentException("Chain length must be 1 or more");
+            throw new IllegalArgumentException("Chain length must be 2 or more");
         }
         // This is an estimate, but for bounded queues if the burst size is more than actual ring capacity
         // the benchmark will hang/

File: jctools-benchmarks/src/main/java/org/jctools/jmh/latency/spsc/RingCqBurstRoundTripWithGroups.java
Patch:
@@ -158,7 +158,7 @@ public void clear() {
     public void prepareChain() {
         // can't have group threads set to zero on a method, so can't handle the length of 1 case
         if (CHAIN_LENGTH < 2) {
-            throw new IllegalArgumentException("Chain length must be 1 or more");
+            throw new IllegalArgumentException("Chain length must be 2 or more");
         }
         // This is an estimate, but for bounded queues if the burst size is more than actual ring capacity
         // the benchmark will hang/

File: jctools-core/src/main/java/org/jctools/queues/MpmcArrayQueue.java
Patch:
@@ -122,7 +122,7 @@ public MpmcArrayQueue(final int capacity) {
 
     private static int validateCapacity(int capacity) {
         if(capacity < 2)
-            throw new IllegalArgumentException("Minimum size is 2");
+            throw new IllegalArgumentException("Minimum size must be 2 or more");
         return capacity;
     }
 

File: jctools-core/src/main/java/org/jctools/queues/SpscChunkedArrayQueue.java
Patch:
@@ -29,11 +29,11 @@ public SpscChunkedArrayQueue(final int capacity) {
 
     public SpscChunkedArrayQueue(final int chunkSize, final int capacity) {
         if (capacity < 16) {
-            throw new IllegalArgumentException("Max capacity must be 4 or more");
+            throw new IllegalArgumentException("Max capacity must be 16 or more");
         }
         // minimal chunk size of eight makes sure minimal lookahead step is 2
         if (chunkSize < 8) {
-            throw new IllegalArgumentException("Chunk size must be 2 or more");
+            throw new IllegalArgumentException("Chunk size must be 8 or more");
         }
 
         maxQueueCapacity = Pow2.roundToPowerOfTwo(capacity);

File: jctools-core/src/main/java/org/jctools/queues/SpscGrowableArrayQueue.java
Patch:
@@ -28,11 +28,11 @@ public SpscGrowableArrayQueue(final int capacity) {
 
     public SpscGrowableArrayQueue(final int chunkSize, final int capacity) {
         if (capacity < 16) {
-            throw new IllegalArgumentException("Max capacity must be 4 or more");
+            throw new IllegalArgumentException("Max capacity must be 16 or more");
         }
         // minimal chunk size of eight makes sure minimal lookahead step is 2
         if (chunkSize < 8) {
-            throw new IllegalArgumentException("Chunk size must be 2 or more");
+            throw new IllegalArgumentException("Chunk size must be 8 or more");
         }
 
         maxQueueCapacity = Pow2.roundToPowerOfTwo(capacity);

File: jctools-core/src/main/java/org/jctools/queues/atomic/MpmcAtomicArrayQueue.java
Patch:
@@ -31,7 +31,7 @@ public MpmcAtomicArrayQueue(int capacity) {
 
     private static int validateCapacity(int capacity) {
         if(capacity < 2)
-            throw new IllegalArgumentException("Minimum size is 2");
+            throw new IllegalArgumentException("Minimum size must be 2 or more");
         return capacity;
     }
 

File: jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMapLong.java
Patch:
@@ -720,7 +720,8 @@ private final CHM resize() {
       // for tables subject to a high key churn rate - but do not
       // forever grow the table.  If there is a high key churn rate
       // the table needs a steady state of rare same-size resize
-      // operations to clean out the dead keys.      long tm = System.currentTimeMillis();
+      // operations to clean out the dead keys.
+      long tm = System.currentTimeMillis();
       if( newsz <= oldlen && // New table would shrink or hold steady?
           tm <= _nbhml._last_resize_milli+10000)  // Recent resize (less than 10 sec ago)
         newsz = oldlen<<1;      // Double the existing size

File: jctools-experimental/src/main/java/org/jctools/channels/mpsc/MpscChannelConsumer.java
Patch:
@@ -13,11 +13,11 @@
  */
 package org.jctools.channels.mpsc;
 
+import java.nio.ByteBuffer;
+
 import org.jctools.channels.ChannelConsumer;
 import org.jctools.channels.ChannelReceiver;
 
-import java.nio.ByteBuffer;
-
 /**
  * Package Scoped: not part of public API.
  */
@@ -33,7 +33,7 @@ public MpscChannelConsumer(
             final int messageSize,
             final ChannelReceiver<E> receiver) {
 
-        super(buffer, capacity, false, true, false, messageSize);
+        super(buffer, capacity, false, true, false, messageSize, null, 0);
 
         this.receiver = receiver;
         this.pointer = EOF;

File: jctools-experimental/src/main/java/org/jctools/channels/mpsc/MpscChannelProducer.java
Patch:
@@ -13,10 +13,10 @@
  */
 package org.jctools.channels.mpsc;
 
-import org.jctools.channels.ChannelProducer;
-
 import java.nio.ByteBuffer;
 
+import org.jctools.channels.ChannelProducer;
+
 /**
  * Package Scoped: not part of public API.
  *
@@ -31,7 +31,7 @@ public MpscChannelProducer(
         final int capacity,
         final int messageSize) {
 
-        super(buffer, capacity, true, false, true, messageSize);
+        super(buffer, capacity, true, false, true, messageSize, null, 0);
         pointer = EOF;
     }
 

File: jctools-experimental/src/main/java/org/jctools/channels/spsc/SpscChannelConsumer.java
Patch:
@@ -33,7 +33,7 @@ public SpscChannelConsumer(
             final int messageSize,
             final ChannelReceiver<E> receiver) {
 
-        super(buffer, capacity, false, true, false, messageSize);
+        super(buffer, capacity, false, true, false, messageSize, null, 0);
 
         this.receiver = receiver;
         this.pointer = EOF;

File: jctools-experimental/src/main/java/org/jctools/channels/spsc/SpscChannelProducer.java
Patch:
@@ -31,7 +31,7 @@ public SpscChannelProducer(
         final int capacity,
         final int messageSize) {
 
-        super(buffer, capacity, true, false, true, messageSize);
+        super(buffer, capacity, true, false, true, messageSize, null, 0);
         pointer = EOF;
     }
 

File: jctools-experimental/src/test/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBufferTest.java
Patch:
@@ -20,7 +20,8 @@ public class SpscOffHeapFixedSizeRingBufferTest extends AbstractOffHeapFixedSize
 
 	@Test
 	public void test() {
-		SpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31);
+        // TODO: Needs test for when referenceMessageSize > 0
+		SpscOffHeapFixedSizeRingBuffer rb = new SpscOffHeapFixedSizeRingBuffer(1024, 31, 0);
 		test(rb);
 	}
 

File: jctools-core/src/main/java/org/jctools/queues/MpscArrayQueue.java
Patch:
@@ -422,7 +422,7 @@ public int drain(final Consumer<E> c, final int limit) {
             if (null == e) {
                 return i;
             }
-            soElement(buffer, offset, null);// StoreStore
+            spElement(buffer, offset, null);
             soConsumerIndex(index + 1); // ordered store -> atomic and ordered for size()
             c.accept(e);
         }
@@ -480,7 +480,7 @@ public void drain(Consumer<E> c, WaitStrategy w, ExitCondition exit) {
                 }
                 cIndex++;
                 counter = 0;
-                soElement(buffer, offset, null);// StoreStore
+                spElement(buffer, offset, null);
                 soConsumerIndex(cIndex); // ordered store -> atomic and ordered for size()
                 c.accept(e);
             }

File: jctools-core/src/test/java/org/jctools/queues/MpscUnboundedQueueSanityTest.java
Patch:
@@ -10,7 +10,7 @@
 import org.junit.runners.Parameterized;
 
 @RunWith(Parameterized.class)
-public class MpscLinkedArrayQueueSanityTest extends QueueSanityTest {
+public class MpscUnboundedQueueSanityTest extends QueueSanityTest {
     @Parameterized.Parameters
     public static Collection<Object[]> parameters() {
         ArrayList<Object[]> list = new ArrayList<Object[]>();
@@ -19,7 +19,7 @@ public static Collection<Object[]> parameters() {
         return list;
     }
 
-    public MpscLinkedArrayQueueSanityTest(ConcurrentQueueSpec spec, Queue<Integer> queue) {
+    public MpscUnboundedQueueSanityTest(ConcurrentQueueSpec spec, Queue<Integer> queue) {
         super(spec, queue);
     }
 

File: jctools-experimental/src/main/java/org/jctools/channels/proxy/DemoProxyResult.java
Patch:
@@ -48,7 +48,7 @@ public int process(Demo1 impl, int limit) {
             case 2: {
                 float x = UnsafeAccess.UNSAFE.getFloat(rOffset + 4);
                 double y = UnsafeAccess.UNSAFE.getDouble(rOffset + 8);
-                boolean z = UnsafeAccess.UNSAFE.getBoolean(null, rOffset + 12);
+                boolean z = UnsafeAccess.UNSAFE.getBoolean(null, rOffset + 16);
                 this.readRelease(rOffset);
                 impl.call2(x, y, z);
                 break;

File: jctools-core/src/main/java/org/jctools/queues/MpscArrayQueue.java
Patch:
@@ -158,9 +158,9 @@ public MpscArrayQueue(final int capacity) {
     /**
      * {@link MpscArrayQueue#offer(E)}} if {@link MpscArrayQueue#size()} is less than threshold.
      *
-     * @param e the object to offer onto the queue.
-     * @param threshold the minimum number of available slots.
-     * @return true if the offer is successful, false if queue size exceeds threshold.
+     * @param e the object to offer onto the queue, not null
+     * @param threshold the maximum allowable size
+     * @return true if the offer is successful, false if queue size exceeds threshold
      * @since 1.0.1
      */
     public boolean offerIfBelowThreshold(final E e, int threshold) {

File: jctools-core/src/main/java/org/jctools/queues/atomic/SpscAtomicArrayQueue.java
Patch:
@@ -66,8 +66,8 @@ else if (null != lvElement(buffer, offset)){
                 return false;
             }
         }
-        soProducerIndex(index + 1); // ordered store -> atomic and ordered for size()
         soElement(buffer, offset, e); // StoreStore
+        soProducerIndex(index + 1); // ordered store -> atomic and ordered for size()
         return true;
     }
 

File: jctools-core/src/main/java/org/jctools/queues/SpscGrowableArrayQueue.java
Patch:
@@ -86,10 +86,11 @@ protected boolean offerColdPath(final E[] buffer, final long mask, final E e, fi
                     adjustLookAheadStep(newCapacity);
                 }
                 final long offsetInNew = calcElementOffset(index, producerMask);
-                soProducerIndex(index + 1);// this ensures correctness on 32bit platforms
                 soElement(newBuffer, offsetInNew, e);// StoreStore
                 soNext(buffer, newBuffer); // new buffer is visible after element is inserted
-                soElement(buffer, offset, JUMP); // new buffer is visible after element is inserted // double the buffer and link old to new
+                soElement(buffer, offset, JUMP); // new buffer is visible after element is inserted
+                // index is visible after elements (isEmpty/poll ordering)
+                soProducerIndex(index + 1);// this ensures correctness on 32bit platforms
             }
             return true;
         }

File: jctools-core/src/main/java/org/jctools/queues/SpscUnboundedArrayQueue.java
Patch:
@@ -60,10 +60,12 @@ private void linkNewBuffer(final E[] oldBuffer, final long currIndex, final long
         producerLimit = currIndex + mask - 1;
 
         // write to new buffer
-        writeToQueue(newBuffer, e, currIndex, offset);
+        soElement(newBuffer, offset, e);// StoreStore
         // link to next buffer and add next indicator as element of old buffer
         soNext(oldBuffer, newBuffer);
         soElement(oldBuffer, offset, JUMP);
+        // index is visible after elements (isEmpty/poll ordering)
+        soProducerIndex(currIndex + 1);// this ensures atomic write of long on 32bit platforms
     }
 
 }

File: jctools-benchmarks/src/main/java/org/jctools/jmh/latency/QueueBurstCost.java
Patch:
@@ -11,7 +11,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.jctools.jmh.latency.spsc;
+package org.jctools.jmh.latency;
 
 import java.util.Queue;
 import java.util.concurrent.TimeUnit;

File: jctools-core/src/main/java/org/jctools/queues/MpscChunkedArrayQueue.java
Patch:
@@ -44,7 +44,7 @@ abstract class MpscChunkedArrayQueueColdProducerFields<E> extends MpscChunkedArr
     protected long maxQueueCapacity;
     protected long producerMask;
     protected E[] producerBuffer;
-    protected volatile long prodcuerLimit;
+    protected volatile long producerLimit;
     protected boolean isFixedChunkSize = false;
 }
 
@@ -91,7 +91,7 @@ public class MpscChunkedArrayQueue<E> extends MpscChunkedArrayQueueConsumerField
             throw new RuntimeException(e);
         }
         try {
-            Field iField = MpscChunkedArrayQueueColdProducerFields.class.getDeclaredField("prodcuerLimit");
+            Field iField = MpscChunkedArrayQueueColdProducerFields.class.getDeclaredField("producerLimit");
             P_LIMIT_OFFSET = UNSAFE.objectFieldOffset(iField);
         }
         catch (NoSuchFieldException e) {
@@ -404,7 +404,7 @@ private void soConsumerIndex(long v) {
     }
 
     private long lvProducerLimit() {
-        return prodcuerLimit;
+        return producerLimit;
     }
 
     private boolean casProducerLimit(long expect, long newValue) {

File: jctools-core/src/main/java/org/jctools/queues/atomic/MpscAtomicArrayQueue.java
Patch:
@@ -49,7 +49,7 @@ public MpscAtomicArrayQueue(int capacity) {
      * concurrently.
      *
      * @see java.util.Queue#offer(java.lang.Object)
-     * @see MessagePassingQueue#offer(Object)
+     * @see org.jctools.queues.MessagePassingQueue#offer(Object)
      */
     @Override
     public boolean offer(final E e) {
@@ -130,7 +130,7 @@ public final int weakOffer(final E e) {
      * Lock free poll using ordered loads/stores. As class name suggests access is limited to a single thread.
      *
      * @see java.util.Queue#poll()
-     * @see MessagePassingQueue#poll()
+     * @see org.jctools.queues.MessagePassingQueue#poll()
      */
     @Override
     public E poll() {
@@ -168,7 +168,7 @@ public E poll() {
      * Lock free peek using ordered loads. As class name suggests access is limited to a single thread.
      *
      * @see java.util.Queue#poll()
-     * @see MessagePassingQueue#poll()
+     * @see org.jctools.queues.MessagePassingQueue#poll()
      */
     @Override
     public E peek() {

File: jctools-core/src/main/java/org/jctools/queues/atomic/MpscLinkedAtomicQueue.java
Patch:
@@ -49,7 +49,7 @@ public MpscLinkedAtomicQueue() {
      * This works because each producer is guaranteed to 'plant' a new node and link the old node. No 2 producers can
      * get the same producer node as part of XCHG guarantee.
      *
-     * @see MessagePassingQueue#offer(Object)
+     * @see org.jctools.queues.MessagePassingQueue#offer(Object)
      * @see java.util.Queue#offer(java.lang.Object)
      */
     @Override
@@ -78,7 +78,7 @@ public final boolean offer(final E e) {
      * This means the consumerNode.value is always null, which is also the starting point for the queue. Because null
      * values are not allowed to be offered this is the only node with it's value set to null at any one time.
      *
-     * @see MessagePassingQueue#poll()
+     * @see org.jctools.queues.MessagePassingQueue#poll()
      * @see java.util.Queue#poll()
      */
     @Override

File: jctools-core/src/test/java/org/jctools/queues/MpscChunkedMessagePassingQueueSanityTest.java
Patch:
@@ -10,7 +10,6 @@
 import org.junit.runners.Parameterized;
 
 @RunWith(Parameterized.class)
-@Ignore
 public class MpscChunkedMessagePassingQueueSanityTest extends MessagePassingQueueSanityTest {
     @Parameterized.Parameters
     public static Collection<Object[]> parameters() {

File: jctools-core/src/test/java/org/jctools/queues/MpscChunkedQueueSanityTest.java
Patch:
@@ -10,7 +10,6 @@
 import org.junit.runners.Parameterized;
 
 @RunWith(Parameterized.class)
-
 public class MpscChunkedQueueSanityTest extends QueueSanityTest {
     @Parameterized.Parameters
     public static Collection<Object[]> parameters() {

File: jctools-core/src/test/java/org/jctools/queues/MpscGrowableMessagePassingQueueSanityTest.java
Patch:
@@ -10,7 +10,6 @@
 import org.junit.runners.Parameterized;
 
 @RunWith(Parameterized.class)
-@Ignore
 public class MpscGrowableMessagePassingQueueSanityTest extends MessagePassingQueueSanityTest {
     @Parameterized.Parameters
     public static Collection<Object[]> parameters() {

File: jctools-core/src/test/java/org/jctools/queues/MpscGrowableQueueSanityTest.java
Patch:
@@ -10,7 +10,6 @@
 import org.junit.runners.Parameterized;
 
 @RunWith(Parameterized.class)
-
 public class MpscGrowableQueueSanityTest extends QueueSanityTest {
     @Parameterized.Parameters
     public static Collection<Object[]> parameters() {

File: jctools-core/src/test/java/org/jctools/queues/MpscChunkedQueueSanityTest.java
Patch:
@@ -15,8 +15,8 @@ public class MpscChunkedQueueSanityTest extends QueueSanityTest {
     @Parameterized.Parameters
     public static Collection<Object[]> parameters() {
         ArrayList<Object[]> list = new ArrayList<Object[]>();
-        list.add(makeQueue(0, 1, 4, Ordering.FIFO, new MpscGrowableArrayQueue<>(4)));// MPSC size 1
-        list.add(makeQueue(0, 1, SIZE, Ordering.FIFO, new MpscGrowableArrayQueue<>(2, SIZE)));// MPSC size SIZE
+        list.add(makeQueue(0, 1, 4, Ordering.FIFO, new MpscChunkedArrayQueue<>(2, 4, true)));// MPSC size 1
+        list.add(makeQueue(0, 1, SIZE, Ordering.FIFO, new MpscChunkedArrayQueue<>(8, SIZE, true)));// MPSC size SIZE
         return list;
     }
 

File: jctools-core/src/test/java/org/jctools/queues/MpscGrowableQueueSanityTest.java
Patch:
@@ -15,8 +15,8 @@ public class MpscGrowableQueueSanityTest extends QueueSanityTest {
     @Parameterized.Parameters
     public static Collection<Object[]> parameters() {
         ArrayList<Object[]> list = new ArrayList<Object[]>();
-        list.add(makeQueue(0, 1, 4, Ordering.FIFO, new MpscGrowableArrayQueue<>(4)));// MPSC size 1
-        list.add(makeQueue(0, 1, SIZE, Ordering.FIFO, new MpscGrowableArrayQueue<>(2, SIZE)));// MPSC size SIZE
+        list.add(makeQueue(0, 1, 4, Ordering.FIFO, new MpscChunkedArrayQueue<>(2, 4, false)));// MPSC size 1
+        list.add(makeQueue(0, 1, SIZE, Ordering.FIFO, new MpscChunkedArrayQueue<>(8, SIZE, false)));// MPSC size SIZE
         return list;
     }
 

File: jctools-core/src/main/java/org/jctools/queues/MpscArrayQueue.java
Patch:
@@ -168,7 +168,7 @@ public MpscArrayQueue(final int capacity) {
      */
     public boolean offerIfBelowTheshold(final E e, int threshold) {
         if (null == e) {
-            throw new NullPointerException("Null is not a valid element");
+            throw new NullPointerException();
         }
         // use a cached view on consumer index (potentially updated in loop)
         final long mask = this.mask;
@@ -260,7 +260,7 @@ public boolean offer(final E e) {
      */
     public final int failFastOffer(final E e) {
         if (null == e) {
-            throw new NullPointerException("Null is not a valid element");
+            throw new NullPointerException();
         }
         final long mask = this.mask;
         final long capacity = mask + 1;

File: jctools-experimental/src/main/java/org/jctools/queues/MpscOnSpscQueue.java
Patch:
@@ -38,7 +38,7 @@ abstract class MpscOnSpscFields<E> extends MpscOnSpscL0Pad<E> {
 
 	static {
 		try {
-			QUEUES_OFFSET = UNSAFE.objectFieldOffset(MpscArrayQueueConsumerField.class.getDeclaredField("queues"));
+			QUEUES_OFFSET = UNSAFE.objectFieldOffset(MpscOnSpscFields.class.getDeclaredField("queues"));
 		} catch (NoSuchFieldException e) {
 			throw new RuntimeException(e);
 		}
@@ -55,7 +55,7 @@ public ThreadWeakRef(ReferenceQueue<? super Thread> q, Object r) {
 		}
 	}
 	private List<ThreadWeakRef> weakRefHolder = Collections.synchronizedList(new ArrayList<ThreadWeakRef>());
-	
+
 	@SuppressWarnings("unchecked")
 	public MpscOnSpscFields(final int capacity) {
 		producerQueue = new ThreadLocal<Queue<E>>() {

File: jctools-core/src/test/java/org/jctools/queues/MessagePassingQueueSanityTest.java
Patch:
@@ -31,8 +31,8 @@ public class MessagePassingQueueSanityTest {
     @Parameterized.Parameters
     public static Collection<Object[]> parameters() {
         ArrayList<Object[]> list = new ArrayList<Object[]>();
-        list.add(test(0, 1, 4, Ordering.FIFO, new MpscChunkedArrayQueue<>(4)));// MPSC size 1
-        list.add(test(0, 1, SIZE, Ordering.FIFO, new MpscChunkedArrayQueue<>(2, SIZE)));// MPSC size SIZE
+//        list.add(test(0, 1, 4, Ordering.FIFO, new MpscChunkedArrayQueue<>(4)));// MPSC size 1
+//        list.add(test(0, 1, SIZE, Ordering.FIFO, new MpscChunkedArrayQueue<>(2, SIZE)));// MPSC size SIZE
 
         list.add(test(1, 1, 0, Ordering.FIFO, null));// unbounded SPSC
         list.add(test(0, 1, 0, Ordering.FIFO, null));// unbounded MPSC

File: jctools-core/src/main/java/org/jctools/queues/SpscUnboundedArrayQueue.java
Patch:
@@ -126,7 +126,7 @@ public final boolean offer(final E e) {
             if (null == lvElement(buffer, lookAheadElementOffset)) {// LoadLoad
                 producerLookAhead = index + lookAheadStep - 1; // joy, there's plenty of room
                 writeToQueue(buffer, e, index, offset);
-            } else if (null != lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full
+            } else if (null == lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full
                 writeToQueue(buffer, e, index, offset);
             } else {
                 linkNewBuffer(buffer, index, offset, e, mask); // add a buffer and link old to new

File: jctools-core/src/main/java/org/jctools/queues/atomic/SpscUnboundedAtomicArrayQueue.java
Patch:
@@ -80,7 +80,7 @@ public final boolean offer(final E e) {
             if (null == lvElement(buffer, lookAheadElementOffset)) {// LoadLoad
                 producerLookAhead = index + lookAheadStep - 1; // joy, there's plenty of room
                 return writeToQueue(buffer, e, index, offset);
-            } else if (null != lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full
+            } else if (null == lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full
                 return writeToQueue(buffer, e, index, offset);
             } else {
                 resize(buffer, index, offset, e, mask); // add a buffer and link old to new

File: jctools-core/src/main/java/org/jctools/queues/SpscUnboundedArrayQueue.java
Patch:
@@ -126,7 +126,7 @@ public final boolean offer(final E e) {
             if (null == lvElement(buffer, lookAheadElementOffset)) {// LoadLoad
                 producerLookAhead = index + lookAheadStep - 1; // joy, there's plenty of room
                 writeToQueue(buffer, e, index, offset);
-            } else if (null != lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full
+            } else if (null == lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full
                 writeToQueue(buffer, e, index, offset);
             } else {
                 linkNewBuffer(buffer, index, offset, e, mask); // add a buffer and link old to new

File: jctools-core/src/main/java/org/jctools/queues/atomic/SpscUnboundedAtomicArrayQueue.java
Patch:
@@ -80,7 +80,7 @@ public final boolean offer(final E e) {
             if (null == lvElement(buffer, lookAheadElementOffset)) {// LoadLoad
                 producerLookAhead = index + lookAheadStep - 1; // joy, there's plenty of room
                 return writeToQueue(buffer, e, index, offset);
-            } else if (null != lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full
+            } else if (null == lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full
                 return writeToQueue(buffer, e, index, offset);
             } else {
                 resize(buffer, index, offset, e, mask); // add a buffer and link old to new

File: jctools-core/src/test/java/org/jctools/queues/QueueSanityTest.java
Patch:
@@ -37,7 +37,7 @@ public static Collection parameters() {
         list.add(test(1, 1, 1, Ordering.FIFO, null));
         list.add(test(1, 1, 0, Ordering.FIFO, null));
         list.add(test(1, 1, SIZE, Ordering.FIFO, null));
-        list.add(test(1, 1, 16, Ordering.FIFO, new SpscGrowableArrayQueue<Integer>(4, 16)));
+        list.add(test(1, 1, 32, Ordering.FIFO, new SpscGrowableArrayQueue<Integer>(4, 32)));
         list.add(test(1, 1, 0, Ordering.FIFO, new SpscUnboundedArrayQueue<Integer>(16)));
         list.add(test(1, 0, 1, Ordering.FIFO, null));
         list.add(test(1, 0, SIZE, Ordering.FIFO, null));

File: jctools-core/src/main/java/org/jctools/queues/SpscGrowableArrayQueue.java
Patch:
@@ -81,8 +81,8 @@ public SpscGrowableArrayQueue(final int capacity) {
     }
 
     public SpscGrowableArrayQueue(final int initialCapacity, int capacity) {
-        int p2initialCapacity = roundToPowerOfTwo(initialCapacity);
-        int p2capacity = roundToPowerOfTwo(capacity);
+        int p2initialCapacity = roundToPowerOfTwo(max(initialCapacity, 32)/2);
+        int p2capacity = roundToPowerOfTwo(max(capacity, 32));
         if (p2initialCapacity >= p2capacity) {
             throw new IllegalArgumentException("Initial capacity("+initialCapacity+") rounded up to a power of 2 cannot exceed maximum capacity ("+capacity+")rounded up to a power of 2");
         }

File: jctools-core/src/main/java/org/jctools/queues/SpscGrowableArrayQueue.java
Patch:
@@ -82,7 +82,7 @@ public SpscGrowableArrayQueue(final int capacity) {
 
     public SpscGrowableArrayQueue(final int initialCapacity, int capacity) {
         int p2initialCapacity = roundToPowerOfTwo(initialCapacity);
-        int p2capacity = roundToPowerOfTwo(initialCapacity);
+        int p2capacity = roundToPowerOfTwo(capacity);
         if (p2initialCapacity >= p2capacity) {
             throw new IllegalArgumentException("Initial capacity("+initialCapacity+") rounded up to a power of 2 cannot exceed maximum capacity ("+capacity+")rounded up to a power of 2");
         }

File: jctools-experimental/src/main/resources/org/jctools/channels/ChannelConsumerTemplate.java
Patch:
@@ -5,7 +5,7 @@
 import org.jctools.channels.ChannelReceiver;
 
 public class {{className}}
-        extends SpscChannelConsumer<{{flyweightInterface}}>
+        extends {{implementationParent}}<{{flyweightInterface}}>
         implements {{flyweightInterface}} {
 
     public {{className}}(
@@ -18,10 +18,11 @@ public class {{className}}
     }
 
     public boolean read() {
-        pointer = readAcquire();
+        final long pointer = readAcquire();
         if (pointer == EOF) {
             return false;
         }
+        this.pointer = pointer;
         receiver.accept(this);
         readRelease(pointer);
         return true;

File: jctools-experimental/src/main/resources/org/jctools/channels/ChannelProducerTemplate.java
Patch:
@@ -3,7 +3,7 @@
 import org.jctools.channels.spsc.SpscChannelProducer;
 
 public class {{className}}
-        extends SpscChannelProducer<{{flyweightInterface}}>
+        extends {{implementationParent}}<{{flyweightInterface}}>
         implements {{flyweightInterface}} {
 
     public {{className}}({{#constructorParams}}

File: jctools-experimental/src/main/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBuffer.java
Patch:
@@ -157,7 +157,7 @@ public final boolean isEmpty() {
     }
 
     private boolean isMessageReady(long offset) {
-        return UNSAFE.getIntVolatile(null, offsetForIndex(offset)) == READY_MESSAGE_INDICATOR;
+        return UNSAFE.getIntVolatile(null, offset) == READY_MESSAGE_INDICATOR;
     }
 
     private void busyIndicator(long offset) {

File: jctools-experimental/src/main/java/org/jctools/channels/mapping/Mapper.java
Patch:
@@ -42,7 +42,7 @@ public Mapper(Class<S> structInterface, boolean debugEnabled) {
      * @return the size that each message takes up in bytes
      */
     public int getSizeInBytes() {
-        return inspector.getSizeInBytes();
+        return Primitive.INT.sizeInBytes + inspector.getSizeInBytes();
     }
 
     public <I> I newFlyweight(Class<I> implementationParent, String templateFile, Object ... args) {

File: jctools-experimental/src/test/java/org/jctools/channels/mapping/MapperTest.java
Patch:
@@ -22,7 +22,7 @@
 
 public class MapperTest {
 
-    private static final int EXAMPLE_SIZE_IN_BYTES = 12;
+    private static final int EXAMPLE_SIZE_IN_BYTES = 16;
 
     private long startAddress;
     private Mapper<Example> mapper;

File: jctools-core/src/main/java/org/jctools/queues/SpscGrowableArrayQueue.java
Patch:
@@ -140,7 +140,7 @@ public final boolean offer(final E e) {
                 if (null == lvElement(buffer, lookAheadElementOffset)) {// LoadLoad
                     producerLookAhead = index + lookAheadStep - 1; // joy, there's plenty of room
                     return writeToQueue(buffer, e, index, offset);
-                } else if (null != lvElement(buffer, calcElementOffset(index + 1, mask))) { // buffer is not full
+                } else if (null == lvElement(buffer, calcElementOffset(index + 1, mask))) { // buffer is not full
                     return writeToQueue(buffer, e, index, offset);
                 } else if (mask == maxSize) {
                     // we're full and can't grow

File: jctools-experimental/src/main/java/org/jctools/queues/FloatingCountersSpscConcurrentArrayQueue.java
Patch:
@@ -30,7 +30,7 @@ abstract class FloatingCaqL0Pad {
 
 abstract class FloatingCaqColdFields<E> extends InlinedRingBufferL0Pad {
     protected static final int BUFFER_PAD = 32;
-    protected static final int SPARSE_SHIFT = Integer.getInteger("sparse.shift", 2);
+    protected static final int SPARSE_SHIFT = Integer.getInteger("sparse.shift", 0);
     protected final int capacity;
     protected final long mask;
     protected final E[] buffer;

File: jctools-experimental/src/main/java/org/jctools/queues/InlinedCountersSpscConcurrentArrayQueue.java
Patch:
@@ -28,7 +28,7 @@ abstract class InlinedRingBufferL0Pad {
 
 abstract class InlinedRingBufferColdFields<E> extends InlinedRingBufferL0Pad {
     protected static final int BUFFER_PAD = 32;
-    protected static final int SPARSE_SHIFT = Integer.getInteger("sparse.shift", 2);
+    protected static final int SPARSE_SHIFT = Integer.getInteger("sparse.shift", 0);
     protected final int capacity;
     protected final long mask;
     protected final E[] buffer;

File: jctools-experimental/src/main/java/org/jctools/queues/MpmcConcurrentQueueStateMarkers.java
Patch:
@@ -29,7 +29,7 @@ abstract class MpmcConcurrentQueueSMBufferL0Pad {
 }
 
 abstract class MpmcConcurrentQueueSMBuffer<E> extends MpmcConcurrentQueueSMBufferL0Pad {
-    private static final int SPARSE_SHIFT = Math.max(1, Integer.getInteger("sparse.shift", 2));// data is sparse to allow the wrap tokens
+    private static final int SPARSE_SHIFT = Math.max(1, Integer.getInteger("sparse.shift", 0));// data is sparse to allow the wrap tokens
     private static final int BUFFER_PAD = 32;
     private static final long REF_ARRAY_BASE;
     private static final int REF_ELEMENT_SHIFT;

File: jctools-experimental/src/main/java/org/jctools/queues/MpscSequencedArrayQueue.java
Patch:
@@ -162,7 +162,7 @@ public E poll() {
 
         // Move sequence ahead by capacity, preparing it for next offer
         // (seeing this value from a consumer will lead to retry 2)
-        soSequence(lSequenceBuffer, seqOffset, consumerIndex + capacity);// StoreStore
+        soSequence(lSequenceBuffer, seqOffset, consumerIndex + mask + 1);// StoreStore
 
         return e;
     }
@@ -175,6 +175,7 @@ public E peek() {
     @Override
     public int size() {
         int size;
+        long capacity = mask + 1;
         do {
             /*
              * It is possible for a thread to be interrupted or reschedule between the read of the producer

File: jctools-core/src/main/java/org/jctools/queues/MessagePassingQueue.java
Patch:
@@ -47,7 +47,7 @@ interface MessagePassingQueue<M> {
 
     /**
      * Called from the consumer thread subject to the restrictions appropriate to the implementation and according to
-     * the {@link Queue#peek()} interface (barring the hard requirement on null returns).
+     * the {@link Queue#peek()} interface.
      * 
      * @return a message from the queue if one is available, null iff empty
      */

File: jctools-core/src/main/java/org/jctools/queues/MpscLinkedQueue7.java
Patch:
@@ -16,8 +16,8 @@
 import static org.jctools.util.UnsafeAccess.UNSAFE;
 
 /**
- * {@inheritDoc}
- * 
+ * @see MpscLinkedQueue
+ *  
  * @author nitsanw
  * 
  * @param <E>

File: jctools-core/src/main/java/org/jctools/queues/SpscLinkedQueue.java
Patch:
@@ -13,7 +13,6 @@
  */
 package org.jctools.queues;
 
-import java.util.Iterator;
 
 
 /**

File: jctools-core/src/main/java/org/jctools/queues/package-info.java
Patch:
@@ -49,8 +49,8 @@
  * use cases:
  * <ol>
  * <li>The queue counters in the queues are all inlined (i.e. are primitive fields of the queue classes). To allow
- * lazySet/CAS semantics to these fields we could use {@link AtomicLongFieldUpdater} but choose not to.
- * <li>We use Unsafe to gain volatile/lazySet access to array elements. We could use {@link AtomicReferenceArray} but
+ * lazySet/CAS semantics to these fields we could use {@link java.util.concurrent.atomic.AtomicLongFieldUpdater} but choose not to.
+ * <li>We use Unsafe to gain volatile/lazySet access to array elements. We could use {@link java.util.concurrent.atomic.AtomicReferenceArray} but
  * the extra reference chase and redundant boundary checks are considered too high a price to pay at this time.
  * </ol>
  * 

File: jctools-core/src/main/java/org/jctools/util/UnsafeAccess.java
Patch:
@@ -27,7 +27,7 @@
  * (depending on JVM version) while Unsafe intrinsification is a far lesser challenge for JIT compilers.
  * <li>To construct flavors of {@link AtomicReferenceArray}.
  * <li>Other use cases exist but are not present in this library yet.
- * <ol>
+ * </ol>
  * 
  * @author nitsanw
  * 

File: jctools-core/src/main/java/org/jctools/queues/MpscLinkedQueue7.java
Patch:
@@ -3,8 +3,8 @@
 import static org.jctools.util.UnsafeAccess.UNSAFE;
 
 /**
- * {@inheritDoc}
- * 
+ * @see MpscLinkedQueue
+ *  
  * @author nitsanw
  * 
  * @param <E>

File: jctools-core/src/main/java/org/jctools/queues/SpscLinkedQueue.java
Patch:
@@ -1,6 +1,5 @@
 package org.jctools.queues;
 
-import java.util.Iterator;
 
 
 /**

File: jctools-core/src/main/java/org/jctools/queues/package-info.java
Patch:
@@ -36,8 +36,8 @@
  * use cases:
  * <ol>
  * <li>The queue counters in the queues are all inlined (i.e. are primitive fields of the queue classes). To allow
- * lazySet/CAS semantics to these fields we could use {@link AtomicLongFieldUpdater} but choose not to.
- * <li>We use Unsafe to gain volatile/lazySet access to array elements. We could use {@link AtomicReferenceArray} but
+ * lazySet/CAS semantics to these fields we could use {@link java.util.concurrent.atomic.AtomicLongFieldUpdater} but choose not to.
+ * <li>We use Unsafe to gain volatile/lazySet access to array elements. We could use {@link java.util.concurrent.atomic.AtomicReferenceArray} but
  * the extra reference chase and redundant boundary checks are considered too high a price to pay at this time.
  * </ol>
  * 

File: jctools-core/src/main/java/org/jctools/util/UnsafeAccess.java
Patch:
@@ -14,7 +14,7 @@
  * (depending on JVM version) while Unsafe intrinsification is a far lesser challenge for JIT compilers.
  * <li>To construct flavors of {@link AtomicReferenceArray}.
  * <li>Other use cases exist but are not present in this library yet.
- * <ol>
+ * </ol>
  * 
  * @author nitsanw
  * 

File: jctools-core/src/main/java/org/jctools/queues/MpscLinkedQueue.java
Patch:
@@ -100,7 +100,7 @@ public final E peek() {
         if (nextNode != null) {
             return nextNode.lpValue();
         }
-        else if (currConsumerNode == lvProducerNode()) {
+        else if (currConsumerNode != lvProducerNode()) {
             // spin, we are no longer wait free
             while((nextNode = currConsumerNode.lvNext()) == null);
             // got the next node...

File: jctools-experimental/src/main/java/org/jctools/channels/spsc/SpscChannelProducer.java
Patch:
@@ -41,8 +41,10 @@ public final boolean claim() {
     }
 
     public final boolean commit() {
+        if (pointer == EOF)
+            return false;
+
         writeRelease(pointer);
-        // can we ever fail to commit?
         return true;
     }
 

File: jctools-experimental/src/main/test/org/jctools/channels/mapping/InvalidInterfaceTest.java
Patch:
@@ -38,7 +38,7 @@ public InvalidInterfaceTest(Class<?> representingKlass) {
 
 	@Test(expected = InvalidInterfaceException.class)
 	public void interfaceIsInvalid() {
-		new Mapper<>(representingKlass, false);
+		new Mapper(representingKlass, false);
 	}
 
 	// ---------------------------------------------------

File: jctools-experimental/src/main/test/org/jctools/channels/mapping/MapperTest.java
Patch:
@@ -33,7 +33,7 @@ public class MapperTest {
     @Before
     public void malloc() {
         startAddress = UnsafeAccess.UNSAFE.allocateMemory(EXAMPLE_SIZE_IN_BYTES * 2);
-        mapper = new Mapper<>(Example.class, true);
+        mapper = new Mapper<Example>(Example.class, true);
     }
 
     @After

File: jctools-core/src/main/java/org/jctools/queues/SpscLinkedQueue.java
Patch:
@@ -42,7 +42,7 @@ public final class SpscLinkedQueue<E> extends SpscLinkedQueueConsumerNodeRef<E>
     long p30, p31, p32, p33, p34, p35, p36, p37;
 
     public SpscLinkedQueue() {
-        producerNode = new LinkedQueueNode<>();
+        producerNode = new LinkedQueueNode<E>();
         consumerNode = producerNode;
         consumerNode.soNext(null); // this ensures correct construction: StoreStore
     }

File: jctools-experimental/src/main/java/org/jctools/channels/mapping/Mapper.java
Patch:
@@ -169,9 +169,9 @@ public void customise(ClassVisitor writer) {
     private <I> I newFlyweight(Class<I> type, Customisation customisation, Object[] args) {
         try {
             Class<?>[] constructorParameterTypes = getTypes(args);
-            Class<I> implementation = new BytecodeGenerator<>(inspector, type, constructorParameterTypes,
-                                                              structInterface, classFileDebugEnabled,
-                                                              customisation).generate();
+            Class<I> implementation = new BytecodeGenerator<S,I>(inspector, type, constructorParameterTypes,
+                                                                 structInterface, classFileDebugEnabled,
+                                                                 customisation).generate();
 
             Constructor<I> constructor = implementation.getConstructor(constructorParameterTypes);
             return constructor.newInstance(args);

File: jctools-experimental/src/main/java/org/jctools/channels/spsc/SpscChannel.java
Patch:
@@ -42,7 +42,7 @@ public final class SpscChannel<E> implements Channel<E> {
 	public SpscChannel(final ByteBuffer buffer, final int capacity, final Class<E> type) {
         this.capacity = capacity;
         this.buffer = buffer;
-        mapper = new Mapper<>(type, false);
+        mapper = new Mapper<E>(type, false);
         elementSize = mapper.getSizeInBytes();
 
         checkSufficientCapacity();

File: jctools-experimental/src/main/java/org/jctools/queues/alt/MpmcArrayConcurrentQueue.java
Patch:
@@ -162,8 +162,8 @@ public void clear() {
 
     public MpmcArrayConcurrentQueueColdFields(int capacity) {
         super(capacity);
-        consumer = new Consumer<>(this);
-        producer = new Producer<>(this);
+        consumer = new Consumer<E>(this);
+        producer = new Producer<E>(this);
     }
 }
 

File: jctools-core/src/main/java/org/jctools/queues/SpscArrayQueue.java
Patch:
@@ -16,7 +16,7 @@
 import static org.jctools.util.UnsafeAccess.UNSAFE;
 
 abstract class SpscArrayQueueColdField<E> extends ConcurrentCircularArrayQueue<E> {
-    private static final Integer MAX_LOOK_AHEAD_STEP = Integer.getInteger("jctoolts.spsc.max.lookahead.step", 4096);
+    private static final Integer MAX_LOOK_AHEAD_STEP = Integer.getInteger("jctools.spsc.max.lookahead.step", 4096);
     protected final int lookAheadStep;
     public SpscArrayQueueColdField(int capacity) {
         super(capacity);

File: jctools-experimental/src/main/java/org/jctools/channels/spsc/SpscOffHeapFixedSizeRingBuffer.java
Patch:
@@ -31,7 +31,7 @@
  */
 public class SpscOffHeapFixedSizeRingBuffer {
 
-    private static final Integer MAX_LOOK_AHEAD_STEP = Integer.getInteger("jctoolts.spsc.max.lookahead.step", 4096);
+    private static final Integer MAX_LOOK_AHEAD_STEP = Integer.getInteger("jctools.spsc.max.lookahead.step", 4096);
     private static final byte NULL_MESSAGE_INDICATOR = 0;
     private static final byte WRITTEN_MESSAGE_INDICATOR = 1;
     private static final int HEADER_SIZE = 4 * CACHE_LINE_SIZE;

File: jctools-benchmarks/src/main/java/org/jctools/jmh/throughput/QueueThroughputBackoffNone.java
Patch:
@@ -106,7 +106,7 @@ protected void backoff() {
 
     @Benchmark
     @Group("tpt")
-    public int poll(PollCounters counters, ConsumerMarker cm) {
+    public Integer poll(PollCounters counters, ConsumerMarker cm) {
         Integer e = q.poll();
         if (e == null) {
             counters.pollsFailed++;

File: jaq-inabox/src/main/java/io/jaq/spsc/FFBufferWithOfferBatch.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 import java.util.Queue;
+
 class FFBufferOfferBatchL1Pad<E> extends ConcurrentRingBuffer<E> {
     long p10, p11, p12, p13, p14, p15, p16;
     long p30, p31, p32, p33, p34, p35, p36, p37;
@@ -84,7 +85,7 @@ public final class FFBufferWithOfferBatch<E> extends FFBufferOfferBatchL3Pad<E>
     protected static final int OFFER_BATCH_SIZE = Integer.getInteger("offer.batch.size", 4096);
 
     public FFBufferWithOfferBatch(final int capacity) {
-        super(capacity);
+        super(Math.max(capacity, 2 * OFFER_BATCH_SIZE));
     }
 
     private long getHeadV() {
@@ -101,6 +102,7 @@ public boolean add(final E e) {
         }
         throw new IllegalStateException("Queue is full");
     }
+
     public boolean offer(final E e) {
         if (null == e) {
             throw new NullPointerException("Null is not a valid element");

File: jaq-inabox/src/main/java/io/jaq/mpmc/MpmcConcurrentQueue.java
Patch:
@@ -98,7 +98,7 @@ public final class MpmcConcurrentQueue<E> extends MpmcConcurrentQueueHeadField<E
     long p30, p31, p32, p33, p34, p35, p36, p37;
 
     public MpmcConcurrentQueue(final int capacity) {
-        super(capacity);
+        super(Math.max(2, capacity));
     }
 
     public boolean add(final E e) {

File: jaq-inabox/src/main/java/io/jaq/mpmc/MpmcConcurrentQueueCq.java
Patch:
@@ -178,7 +178,7 @@ public final class MpmcConcurrentQueueCq<E> extends MpmcConcurrentQueueCqColdFie
     long p10, p11, p12, p13, p14, p15, p16, p17;
 
     public MpmcConcurrentQueueCq(final int capacity) {
-        super(capacity);
+        super(Math.max(2, capacity));
     }
 
     @Override

File: jaq-inabox/src/main/java/io/jaq/spsc/FFBufferWithOfferBatchCq.java
Patch:
@@ -141,7 +141,7 @@ private long getHeadForSize() {
     }
 
     public FFBufferWithOfferBatchCq(final int capacity) {
-        super(capacity);
+        super(Math.max(capacity,2*OFFER_BATCH_SIZE));
     }
 
     @Override

File: jaq-benchmarks/src/main/java/io/jaq/spsc/SPSCConcurrentQueueFactory.java
Patch:
@@ -1,6 +1,7 @@
 package io.jaq.spsc;
 
 import io.jaq.ConcurrentQueue;
+import io.jaq.ConcurrentQueueFactory;
 import io.jaq.mpmc.MpmcConcurrentQueue;
 import io.jaq.mpmc.MpmcConcurrentQueueCq;
 import io.jaq.mpsc.MpscCompoundQueue;
@@ -13,6 +14,8 @@ public class SPSCConcurrentQueueFactory {
     public static final int QUEUE_TYPE = Integer.getInteger("q.type", 0);
     public static ConcurrentQueue<Integer> createQueue() {
         switch (QUEUE_TYPE) {
+        case -1:
+            return new ConcurrentQueueFactory.GenericQueue();
         case 3:
             return new FFBufferWithOfferBatch<Integer>(QUEUE_CAPACITY);
         case 30:

File: jaq-inabox/src/main/java/io/jaq/ConcurrentQueueFactory.java
Patch:
@@ -45,7 +45,7 @@ else if (qs.producers == 1) {
     }
 
     // generic queue solution to fill gaps for now
-    private final static class GenericQueue<E> extends ConcurrentLinkedQueue<E> implements
+    public final static class GenericQueue<E> extends ConcurrentLinkedQueue<E> implements
             ConcurrentQueue<E>, ConcurrentQueueConsumer<E>, ConcurrentQueueProducer<E> {
         private static final long serialVersionUID = -599236378503873292L;
 

File: jaq-inabox/src/main/java/io/jaq/mpmc/MpmcConcurrentQueueCq.java
Patch:
@@ -95,7 +95,7 @@ public boolean offer(final E e) {
                     }
                     else {
                         // head may become visible before element is taken
-                        while (loadVolatile(lb, offset(headCache)) != null);
+                        while (loadVolatile(lb, offset(headCache-1)) != null);
                         // now the coast is clear :)
                     }
                 }

File: jaq-benchmarks/src/main/java/io/jaq/spsc/SPSCQueueFactory.java
Patch:
@@ -6,9 +6,9 @@
 
 public class SPSCQueueFactory {
     public static final int QUEUE_CAPACITY = 1 << Integer.getInteger("pow2.capacity", 15);
+    public static final int QUEUE_TYPE = Integer.getInteger("q.type", 0);
     public static Queue<Integer> createQueue() {
-        int type = Integer.getInteger("q.type", 0);
-        switch (type) {
+        switch (QUEUE_TYPE) {
         case -2:
             return new LinkedTransferQueue<Integer>();
         case -1:
@@ -24,7 +24,7 @@ public static Queue<Integer> createQueue() {
         case 4:
             return new FloatingCountersSpscConcurrentArrayQueue<Integer>(QUEUE_CAPACITY);
         }
-        throw new IllegalArgumentException("Type: " + type);
+        throw new IllegalArgumentException("Type: " + QUEUE_TYPE);
     }
 
 }

File: jaq-inabox/src/main/java/io/jaq/spsc/FFBufferWithOfferBatch.java
Patch:
@@ -96,7 +96,7 @@ public final class FFBufferWithOfferBatch<E> extends FFBufferOfferBatchL3Pad<E>
             throw new RuntimeException(e);
         }
     }
-    protected static final int OFFER_BATCH_SIZE = Integer.getInteger("offer.batch.size", 512);
+    protected static final int OFFER_BATCH_SIZE = Integer.getInteger("offer.batch.size", 4096);
     
     public FFBufferWithOfferBatch(final int capacity) {
         super(capacity);

