File: jsplot/src/main/java/tech/tablesaw/plotly/components/Layout.java
Patch:
@@ -22,7 +22,7 @@ public class Layout {
   private static final String DEFAULT_DECIMAL_SEPARATOR = ".";
   private static final String DEFAULT_THOUSANDS_SEPARATOR = ",";
   private static final boolean DEFAULT_AUTO_SIZE = false;
-  private static final HoverMode DEFAULT_HOVER_MODE = HoverMode.FALSE;
+  private static final HoverMode DEFAULT_HOVER_MODE = HoverMode.CLOSEST;
   private static final DragMode DEFAULT_DRAG_MODE = DragMode.ZOOM;
   private static final int DEFAULT_HOVER_DISTANCE = 20;
   private static final BarMode DEFAULT_BAR_MODE = BarMode.GROUP;

File: core/src/test/java/tech/tablesaw/io/csv/CsvReaderTest.java
Patch:
@@ -756,7 +756,7 @@ public void testReadFailure2() throws IOException {
 
   @Test
   public void testEmptyFileHeaderEnabled() throws IOException {
-    Table table1 = Table.read().csv(CsvReadOptions.builder("../data/empty_file.csv").header(false));
+    Table table1 = Table.read().csv(CsvReadOptions.builder("../data/empty_file.csv").header(true));
     assertEquals("empty_file.csv: 0 rows X 0 cols", table1.shape());
   }
 

File: jsplot/src/main/java/tech/tablesaw/plotly/api/PricePlot.java
Patch:
@@ -27,17 +27,17 @@ public static Figure create(
     NumericColumn<?> low = table.numberColumn(lowCol);
     NumericColumn<?> close = table.numberColumn(closeCol);
     ScatterTrace trace;
-    if (x.type() == ColumnType.LOCAL_DATE) {
+    if (ColumnType.LOCAL_DATE.equals(x.type())) {
       trace =
           ScatterTrace.builder(table.dateColumn(xCol), open, high, low, close)
               .type(plotType)
               .build();
-    } else if (x.type() == ColumnType.LOCAL_DATE_TIME) {
+    } else if (ColumnType.LOCAL_DATE_TIME.equals(x.type())) {
       trace =
           ScatterTrace.builder(table.dateTimeColumn(xCol), open, high, low, close)
               .type(plotType)
               .build();
-    } else if (x.type() == ColumnType.INSTANT) {
+    } else if (ColumnType.INSTANT.equals(x.type())) {
       trace =
           ScatterTrace.builder(table.instantColumn(xCol), open, high, low, close)
               .type(plotType)

File: core/src/test/java/tech/tablesaw/api/DateColumnTest.java
Patch:
@@ -12,6 +12,7 @@
 import org.junit.jupiter.api.Test;
 import tech.tablesaw.columns.dates.DateColumnType;
 import tech.tablesaw.columns.dates.DateParser;
+import tech.tablesaw.columns.datetimes.DateTimeParser;
 
 public class DateColumnTest {
   private DateColumn column1;
@@ -61,7 +62,7 @@ public void testPrint() {
     column1.appendCell("12/23/1924");
     column1.appendCell("12-May-2015");
     column1.appendCell("12-Jan-2015");
-    column1.setPrintFormatter(DateTimeFormatter.ofPattern("MMM~dd~yyyy"), "");
+    column1.setPrintFormatter(DateTimeParser.caseInsensitiveFormatter("MMM~dd~yyyy"), "");
     assertEquals(
         "Column: Game date"
             + System.lineSeparator()
@@ -82,7 +83,7 @@ public void testPrint2() {
     column1.appendCell("12/23/1924");
     column1.appendCell("12-May-2015");
     column1.appendCell("12-Jan-2015");
-    column1.setPrintFormatter(DateTimeFormatter.ofPattern("MMM~dd~yyyy"));
+    column1.setPrintFormatter(DateTimeParser.caseInsensitiveFormatter("MMM~dd~yyyy"));
     assertEquals(
         "Column: Game date"
             + System.lineSeparator()

File: core/src/test/java/tech/tablesaw/api/DateTimeColumnTest.java
Patch:
@@ -22,7 +22,8 @@
 import java.time.LocalDateTime;
 import java.time.ZoneOffset;
 import java.time.format.DateTimeFormatter;
-import java.util.Arrays;
+import java.util.List;
+
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import tech.tablesaw.columns.datetimes.DateTimeParser;
@@ -63,7 +64,7 @@ public void testAppendCell2() {
   public void testCustomParser() {
     // Just do enough to ensure the parser is wired up correctly
     DateTimeParser customParser = new DateTimeParser(ColumnType.LOCAL_DATE_TIME);
-    customParser.setMissingValueStrings(Arrays.asList("not here"));
+    customParser.setMissingValueStrings(List.of("not here"));
     column1.setParser(customParser);
 
     column1.appendCell("not here");

File: core/src/test/java/tech/tablesaw/io/TypeUtilsTest.java
Patch:
@@ -27,16 +27,16 @@
 public class TypeUtilsTest {
 
   @Test
-  public void testDateFormaterWithLocaleEN() {
+  public void testDateFormatterWithLocaleEN() {
     String anotherDate = "12-May-2015";
     LocalDate result =
         LocalDate.parse(anotherDate, DateParser.DEFAULT_FORMATTER.withLocale(Locale.ENGLISH));
     assertNotNull(result);
   }
 
   @Test
-  public void testDateFormater() {
-    final DateTimeFormatter dtTimef8 = DateTimeFormatter.ofPattern("M/d/yyyy h:mm:ss a");
+  public void testDateFormatter() {
+    final DateTimeFormatter dtTimef8 = DateTimeParser.caseInsensitiveFormatter("M/d/yyyy h:mm:ss a");
 
     String anotherDate = "10/2/2016 8:18:03 AM";
     dtTimef8.parse(anotherDate);

File: core/src/test/java/tech/tablesaw/io/csv/CsvReaderTest.java
Patch:
@@ -55,6 +55,7 @@
 import tech.tablesaw.api.ShortColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
+import tech.tablesaw.columns.datetimes.DateTimeParser;
 import tech.tablesaw.columns.numbers.DoubleColumnType;
 import tech.tablesaw.columns.numbers.NumberColumnFormatter;
 import tech.tablesaw.io.AddCellToColumnException;
@@ -302,7 +303,7 @@ public void testDateTimeDetection() {
     CsvReadOptions options =
         CsvReadOptions.builder(reader)
             .header(header)
-            .dateTimeFormat(DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss"))
+            .dateTimeFormat(DateTimeParser.caseInsensitiveFormatter("dd-MMM-yyyy HH:mm:ss"))
             .build();
 
     final List<ColumnType> actual = asList(new CsvReader().detectColumnTypes(reader, options));
@@ -327,7 +328,7 @@ public void testDateTimeDetection2() {
     CsvReadOptions options =
         CsvReadOptions.builder(reader)
             .header(header)
-            .dateTimeFormat(DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss"))
+            .dateTimeFormat(DateTimeParser.caseInsensitiveFormatter("dd-MMM-yyyy HH:mm:ss"))
             .build();
 
     final List<ColumnType> actual = asList(new CsvReader().detectColumnTypes(reader, options));

File: core/src/main/java/tech/tablesaw/api/ColumnType.java
Patch:
@@ -16,7 +16,6 @@
 import tech.tablesaw.columns.numbers.LongColumnType;
 import tech.tablesaw.columns.numbers.ShortColumnType;
 import tech.tablesaw.columns.strings.StringColumnType;
-import tech.tablesaw.columns.strings.TextColumnType;
 import tech.tablesaw.columns.times.TimeColumnType;
 import tech.tablesaw.io.ReadOptions;
 
@@ -40,7 +39,6 @@ public interface ColumnType {
   TimeColumnType LOCAL_TIME = TimeColumnType.instance();
   DateTimeColumnType LOCAL_DATE_TIME = DateTimeColumnType.instance();
   InstantColumnType INSTANT = InstantColumnType.instance();
-  TextColumnType TEXT = TextColumnType.instance();
   SkipColumnType SKIP = SkipColumnType.instance();
 
   /** Registers the given ColumnType, identifying it as supported */

File: core/src/main/java/tech/tablesaw/columns/strings/StringReduceUtils.java
Patch:
@@ -14,9 +14,7 @@
 
 package tech.tablesaw.columns.strings;
 
-import tech.tablesaw.columns.Column;
-
-public interface StringReduceUtils extends Column<String>, Iterable<String> {
+public interface StringReduceUtils extends Iterable<String> {
 
   /**
    * Returns a single string made by appending all the strings in this column, separated by the
@@ -44,4 +42,6 @@ default String appendAll(String delimiter) {
   default String appendAll() {
     return appendAll(" ");
   }
+
+  int size();
 }

File: core/src/main/java/tech/tablesaw/conversion/smile/SmileConverter.java
Patch:
@@ -80,8 +80,6 @@ private DataType toSmileType(ColumnType type) {
       return DataTypes.ShortType;
     } else if (type.equals(ColumnType.STRING)) {
       return DataTypes.StringType;
-    } else if (type.equals(ColumnType.TEXT)) {
-      return DataTypes.StringType;
     }
     throw new IllegalStateException("Unsupported column type " + type);
   }

File: core/src/main/java/tech/tablesaw/index/StringIndex.java
Patch:
@@ -17,7 +17,7 @@
 import it.unimi.dsi.fastutil.ints.IntArrayList;
 import java.util.HashMap;
 import java.util.Map;
-import tech.tablesaw.columns.strings.AbstractStringColumn;
+import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.selection.BitmapBackedSelection;
 import tech.tablesaw.selection.Selection;
 
@@ -30,7 +30,7 @@ public class StringIndex implements Index {
   private final Map<String, IntArrayList> index;
 
   /** Creates an index on the given AbstractStringColumn */
-  public StringIndex(AbstractStringColumn<?> column) {
+  public StringIndex(StringColumn column) {
     int sizeEstimate = Integer.min(1_000_000, column.size() / 100);
     Map<String, IntArrayList> tempMap = new HashMap<>(sizeEstimate);
     for (int i = 0; i < column.size(); i++) {

File: core/src/main/java/tech/tablesaw/io/jdbc/SqlResultSetReader.java
Patch:
@@ -65,8 +65,8 @@ private static Map<Integer, ColumnType> initializeMap() {
             .put(Types.NCHAR, ColumnType.STRING)
             .put(Types.NVARCHAR, ColumnType.STRING)
             .put(Types.VARCHAR, ColumnType.STRING)
-            .put(Types.LONGVARCHAR, ColumnType.TEXT)
-            .put(Types.LONGNVARCHAR, ColumnType.TEXT)
+            .put(Types.LONGVARCHAR, ColumnType.STRING)
+            .put(Types.LONGNVARCHAR, ColumnType.STRING)
             .build());
   }
 

File: core/src/main/java/tech/tablesaw/joining/DataFrameJoiner.java
Patch:
@@ -266,13 +266,14 @@ private Table performJoin(Table left, List<Table> rightTables) {
     }
   }
 
+  @Override
   Table joinInternal(
       Table table1,
       Table table2,
       JoinType joinType,
       boolean allowDuplicates,
       boolean keepAllJoinKeyColumns,
-      String... rightJoinColumnPositions) {
+      String[] rightJoinColumnPositions) {
     return strategy.performJoin(
         table1,
         table2,

File: core/src/main/java/tech/tablesaw/joining/SortMergeJoin.java
Patch:
@@ -391,8 +391,6 @@ private void updateDestinationRow(
     } else if (type.equals(ColumnType.BOOLEAN)) {
       destRow.setBooleanAsByte(
           destColumnPosition, sourceRow.getBooleanAsByte(sourceColumnPosition));
-    } else if (type.equals(ColumnType.TEXT)) {
-      destRow.setText(destColumnPosition, sourceRow.getText(sourceColumnPosition));
     }
   }
 

File: core/src/main/java/tech/tablesaw/table/StandardTableSliceGroup.java
Patch:
@@ -23,7 +23,6 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import tech.tablesaw.api.CategoricalColumn;
-import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.selection.BitmapBackedSelection;
@@ -100,6 +99,7 @@ private void splitOn(String... splitColumnNames) {
     } else { // handle the case where split is on non-text-columns
       int byteSize = getByteSize(splitColumns);
       for (int i = 0; i < getSourceTable().rowCount(); i++) {
+        // TODO: instead of splitting on column type, have a function that returns the byte size?
         StringBuilder stringKey = new StringBuilder();
         ByteBuffer byteBuffer = ByteBuffer.allocate(byteSize);
         int count = 0;
@@ -129,7 +129,8 @@ private void splitOn(String... splitColumnNames) {
   }
 
   private boolean containsTextColumn(List<Column<?>> splitColumns) {
-    return splitColumns.stream().anyMatch(objects -> objects.type().equals(ColumnType.TEXT));
+    return false;
+    // return splitColumns.stream().anyMatch(objects -> objects.type().equals(ColumnType.TEXT));
   }
 
   /** Wrapper class for a byte[] that implements equals and hashcode. */

File: core/src/test/java/tech/tablesaw/api/TableTest.java
Patch:
@@ -62,7 +62,7 @@ static void readTables() {
             .csv(
                 CsvReadOptions.builder(new File("../data/bush.csv"))
                     .columnTypes(BUSH_COLUMN_TYPES));
-    ColumnType[] types = {LOCAL_DATE, SHORT, TEXT};
+    ColumnType[] types = {LOCAL_DATE, SHORT, STRING};
     bushMinimized = Table.read().csv(CsvReadOptions.builder("../data/bush.csv").columnTypes(types));
   }
 

File: core/src/test/java/tech/tablesaw/conversion/smile/SmileConverterTest.java
Patch:
@@ -39,7 +39,6 @@
 import tech.tablesaw.api.ShortColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
-import tech.tablesaw.api.TextColumn;
 import tech.tablesaw.api.TimeColumn;
 
 public class SmileConverterTest {
@@ -84,7 +83,7 @@ public void allColumnTypes() throws IOException {
     table.addColumns(LongColumn.create("long", new long[] {3l, 4l}));
     table.addColumns(ShortColumn.create("short", new short[] {1, 2}));
     table.addColumns(StringColumn.create("string", new String[] {"james", "bond"}));
-    table.addColumns(TextColumn.create("text", new String[] {"foo", "bar"}));
+    table.addColumns(StringColumn.create("text", new String[] {"foo", "bar"}));
     DataFrame dataframe = table.smile().toDataFrame();
     assertEquals(2, dataframe.nrows());
   }

File: core/src/test/java/tech/tablesaw/io/csv/CsvWriterTest.java
Patch:
@@ -190,10 +190,10 @@ void printFormatter_string() throws IOException {
 
   @Test
   void printFormatter_text() throws IOException {
-    Table table = Table.create("", TextColumn.create("strings"));
+    Table table = Table.create("", StringColumn.create("strings"));
     StringColumnFormatter formatter = new StringColumnFormatter(s -> "[" + s + "]", "N/A");
-    table.textColumn("strings").setPrintFormatter(formatter);
-    table.textColumn("strings").append("hey").append("you").appendMissing();
+    table.stringColumn("strings").setPrintFormatter(formatter);
+    table.stringColumn("strings").append("hey").append("you").appendMissing();
     StringWriter writer = new StringWriter();
     table.write().usingOptions(CsvWriteOptions.builder(writer).usePrintFormatters(true).build());
     assertEquals(

File: core/src/test/java/tech/tablesaw/joining/DataFrameJoinerTest.java
Patch:
@@ -12,7 +12,6 @@
 import org.junit.jupiter.api.Test;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
-import tech.tablesaw.api.TextColumn;
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.selection.Selection;
 
@@ -843,8 +842,8 @@ public void innerJoinDuplicateKeysSecondTable() {
   public void innerJoinDuplicateKeysSecondTableWithTextColumn() {
     Table feed = ANIMAL_FEED.copy();
     Table names = ANIMAL_NAMES.copy();
-    feed.replaceColumn("Animal", feed.stringColumn("Animal").asTextColumn());
-    TextColumn nameCol = names.stringColumn("Animal").asTextColumn();
+    feed.replaceColumn("Animal", feed.stringColumn("Animal").asStringColumn());
+    StringColumn nameCol = names.stringColumn("Animal");
     nameCol = nameCol.where(Selection.withRange(0, feed.rowCount()));
     feed.replaceColumn("Animal", nameCol);
     Table joined =

File: core/src/test/java/tech/tablesaw/perf/RowPerformanceTest.java
Patch:
@@ -1,4 +1,4 @@
-package tech.tablesaw.api;
+package tech.tablesaw.perf;
 
 import static java.lang.System.out;
 
@@ -10,6 +10,7 @@
 import java.util.concurrent.TimeUnit;
 import org.apache.commons.lang3.RandomUtils;
 import org.apache.commons.text.RandomStringGenerator;
+import tech.tablesaw.api.*;
 import tech.tablesaw.columns.datetimes.PackedLocalDateTime;
 import tech.tablesaw.columns.numbers.NumberColumnFormatter;
 

File: core/src/test/java/tech/tablesaw/perf/SearchPerformanceTest.java
Patch:
@@ -12,7 +12,7 @@
  * limitations under the License.
  */
 
-package tech.tablesaw.filters;
+package tech.tablesaw.perf;
 
 import static java.lang.System.out;
 

File: core/src/test/java/tech/tablesaw/perf/TimeDependentFilteringTest.java
Patch:
@@ -12,7 +12,7 @@
  * limitations under the License.
  */
 
-package tech.tablesaw.filters;
+package tech.tablesaw.perf;
 
 import static java.lang.System.out;
 import static org.junit.jupiter.api.Assertions.fail;

File: core/src/test/java/tech/tablesaw/table/TableSliceTest.java
Patch:
@@ -129,7 +129,8 @@ public void removeColumns() {
 
   @Test
   public void first() {
-    TableSlice slice = new TableSlice(source, Selection.withRange(2, 12));
+    Table sourceCopy = source;
+    TableSlice slice = new TableSlice(sourceCopy, Selection.withRange(2, 12));
     Table first = slice.first(5);
     assertEquals(first.get(0, 1), slice.get(0, 1));
     assertEquals(first.get(0, 1), source.get(2, 1));

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -492,7 +492,7 @@ public BooleanColumn set(int i, boolean b) {
   }
 
   /** Sets the value at i to b, and returns this column */
-  private BooleanColumn set(int i, byte b) {
+  public BooleanColumn set(int i, byte b) {
     data.set(i, b);
     return this;
   }

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -219,7 +219,7 @@ private static Sort getSort(String... columnNames) {
     return key;
   }
 
-  /** Returns an object that an be used to read data from a file into a new Table */
+  /** Returns an object that can be used to read data from a file into a new Table */
   public static DataFrameReader read() {
     return new DataFrameReader(defaultReaderRegistry);
   }

File: core/src/test/java/tech/tablesaw/api/TextColumnTest.java
Patch:
@@ -31,6 +31,7 @@
 import tech.tablesaw.columns.strings.StringColumnFormatter;
 import tech.tablesaw.columns.strings.StringParser;
 import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.joining.JoinType;
 import tech.tablesaw.selection.Selection;
 
 public class TextColumnTest {
@@ -107,7 +108,7 @@ public void joinTablesWithStringColumnsSuccess() throws IOException {
                                 "13:21:52.451,26.1"))
                     .columnTypesToDetect(Arrays.asList(ColumnType.DOUBLE, ColumnType.TEXT)));
 
-    Table joined = t1.joinOn("TIME").fullOuter(t2);
+    Table joined = t1.joinOn("TIME").with(t2).type(JoinType.FULL_OUTER).join();
     assertEquals(3, joined.columnCount());
   }
 

File: saw/src/main/java/tech/tablesaw/io/saw/CompressionType.java
Patch:
@@ -2,6 +2,8 @@
 
 /** What compression algorithm was applied, or should be applied in reading/writing a Saw File */
 public enum CompressionType {
-  SNAPPY, // Google's Snappy compression algorithm
+  SNAPPY, // Google's Snappy compression algorithm - pure Java
+  LZ4, // Pure Java LZ4
+  ZSTD, // TODO: not implemented
   NONE
 }

File: saw/src/main/java/tech/tablesaw/io/saw/SawMetadata.java
Patch:
@@ -19,7 +19,7 @@ public class SawMetadata {
   static final String METADATA_FILE_NAME = "Metadata.json";
 
   // The version of the Saw Storage system used to write the file
-  private static final int SAW_VERSION = 2;
+  private static final int SAW_VERSION = 3;
 
   private static final ObjectMapper objectMapper = new ObjectMapper();
 

File: saw/src/test/java/tech/tablesaw/io/saw/SawMetadataTest.java
Patch:
@@ -53,7 +53,7 @@ void getRowCount() {
 
   @Test
   void getVersion() {
-    assertEquals(2, metadata1.getVersion());
+    assertEquals(3, metadata1.getVersion());
   }
 
   @Test

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -589,7 +589,7 @@ public BooleanColumn set(Selection rowSelection, boolean newValue) {
    *
    * @param rowSelection the rows to be updated
    * @param newValue a byte representation of boolean values. The only valid arguments are 0, 1, and
-   *     {@link BooleanColumnType:missingValueIndicator()}
+   *     {@link BooleanColumnType#missingValueIndicator()}
    */
   public BooleanColumn set(Selection rowSelection, byte newValue) {
     for (int row : rowSelection) {
@@ -830,7 +830,7 @@ private static class BooleanColumnIterator implements Iterator<Boolean> {
 
     /**
      * Returns {@code true} if the iteration has more elements. (In other words, returns {@code
-     * true} if {@link #next} would return an element rather than throwing an exception.)
+     * true} if {@link #next()} would return an element rather than throwing an exception.)
      *
      * @return {@code true} if the iteration has more elements
      */

File: core/src/main/java/tech/tablesaw/api/InstantColumn.java
Patch:
@@ -574,7 +574,7 @@ public InstantColumn set(int row, Column<Instant> column, int sourceRow) {
     return set(row, ((InstantColumn) column).getLongInternal(sourceRow));
   }
 
-  /** {@inheritDoc} */
+  /** Returns the largest instant value in the column */
   public Instant max() {
     if (isEmpty()) {
       return null;

File: core/src/main/java/tech/tablesaw/columns/numbers/LongColumnType.java
Patch:
@@ -33,7 +33,7 @@ public LongColumn create(String name) {
     return LongColumn.create(name);
   }
 
-  /** {@inheritDoc} */
+  /** Returns the default parser used to convert strings to long values */
   public LongParser defaultParser() {
     return DEFAULT_PARSER;
   }

File: core/src/main/java/tech/tablesaw/table/TableSlice.java
Patch:
@@ -135,7 +135,7 @@ public String name() {
     return name;
   }
 
-  /** {@inheritDoc} */
+  /** Returns the backing table for this slice */
   public Table getTable() {
     return table;
   }

File: core/src/main/java/tech/tablesaw/aggregate/CrossTab.java
Patch:
@@ -60,7 +60,7 @@ public static Table counts(
       a = temp.column(colIndex1).getString(row);
       b = temp.column(colIndex2).getString(row);
       Integer cellValue = gTable.get(a, b);
-      Integer value;
+      int value;
       if (cellValue != null) {
         value = cellValue + 1;
       } else {
@@ -112,7 +112,7 @@ public static Table counts(
 
   /**
    * Returns a Table containing counts of records in the given Table grouped by the given columnName
-   * See also {@link Table:countBy()}
+   * See also {@link Table#countBy(String...)}
    */
   public static Table counts(Table table, String columnName) {
     return table.countBy(table.categoricalColumn(columnName));

File: core/src/main/java/tech/tablesaw/columns/numbers/DoubleColumnType.java
Patch:
@@ -52,7 +52,7 @@ public static boolean isMissingValue(double value) {
 
   /**
    * Returns the missing value indicator for this column type NOTE: Clients should use {@link
-   * DoubleColumnType:valueIsMissing()} to test for missing value indicators
+   * DoubleColumnType#valueIsMissing(double)} to test for missing value indicators
    */
   public static double missingValueIndicator() {
     return Double.NaN;

File: core/src/main/java/tech/tablesaw/aggregate/CrossTab.java
Patch:
@@ -60,7 +60,7 @@ public static Table counts(
       a = temp.column(colIndex1).getString(row);
       b = temp.column(colIndex2).getString(row);
       Integer cellValue = gTable.get(a, b);
-      int value;
+      Integer value;
       if (cellValue != null) {
         value = cellValue + 1;
       } else {
@@ -112,7 +112,7 @@ public static Table counts(
 
   /**
    * Returns a Table containing counts of records in the given Table grouped by the given columnName
-   * See also {@link Table#countBy(String...)}
+   * See also {@link Table:countBy()}
    */
   public static Table counts(Table table, String columnName) {
     return table.countBy(table.categoricalColumn(columnName));

File: core/src/main/java/tech/tablesaw/columns/numbers/DoubleColumnType.java
Patch:
@@ -52,7 +52,7 @@ public static boolean isMissingValue(double value) {
 
   /**
    * Returns the missing value indicator for this column type NOTE: Clients should use {@link
-   * DoubleColumnType#valueIsMissing(double)} to test for missing value indicators
+   * DoubleColumnType:valueIsMissing()} to test for missing value indicators
    */
   public static double missingValueIndicator() {
     return Double.NaN;

File: core/src/main/java/tech/tablesaw/aggregate/CrossTab.java
Patch:
@@ -60,7 +60,7 @@ public static Table counts(
       a = temp.column(colIndex1).getString(row);
       b = temp.column(colIndex2).getString(row);
       Integer cellValue = gTable.get(a, b);
-      Integer value;
+      int value;
       if (cellValue != null) {
         value = cellValue + 1;
       } else {
@@ -112,7 +112,7 @@ public static Table counts(
 
   /**
    * Returns a Table containing counts of records in the given Table grouped by the given columnName
-   * See also {@link Table:countBy()}
+   * See also {@link Table#countBy(String...)}
    */
   public static Table counts(Table table, String columnName) {
     return table.countBy(table.categoricalColumn(columnName));

File: core/src/main/java/tech/tablesaw/columns/numbers/DoubleColumnType.java
Patch:
@@ -52,7 +52,7 @@ public static boolean isMissingValue(double value) {
 
   /**
    * Returns the missing value indicator for this column type NOTE: Clients should use {@link
-   * DoubleColumnType:valueIsMissing()} to test for missing value indicators
+   * DoubleColumnType#valueIsMissing(double)} to test for missing value indicators
    */
   public static double missingValueIndicator() {
     return Double.NaN;

File: core/src/main/java/tech/tablesaw/api/NumberColumn.java
Patch:
@@ -65,8 +65,8 @@ public NumberColumn<C, T> set(DoublePredicate condition, T newValue) {
 
   /** {@inheritDoc} */
   @Override
-  public void setPrintFormatter(final NumberFormat format, final String missingValueIndicator) {
-    this.printFormatter = new NumberColumnFormatter(format, missingValueIndicator);
+  public void setPrintFormatter(NumberFormat format, String missingValueIndicator) {
+    setPrintFormatter(new NumberColumnFormatter(format, missingValueIndicator));
   }
 
   /** {@inheritDoc} */

File: core/src/main/java/tech/tablesaw/columns/numbers/DoubleParser.java
Patch:
@@ -33,7 +33,7 @@ public boolean canParse(String s) {
         Double.parseDouble(AbstractColumnParser.remove(s, ','));
       }
       return true;
-    } catch (NumberFormatException | ParseException e) {
+    } catch (NumberFormatException | ParseException | IndexOutOfBoundsException e) {
       // it's all part of the plan
       return false;
     }

File: core/src/main/java/tech/tablesaw/io/AddCellToColumnException.java
Patch:
@@ -45,7 +45,7 @@ public class AddCellToColumnException extends RuntimeException {
   /**
    * Creates a new instance of this Exception
    *
-   * @param e The Exceeption that caused adding to fail
+   * @param e The Exception that caused adding to fail
    * @param columnIndex The index of the column that threw the Exception
    * @param rowNumber The number of the row that caused the Exception to be thrown
    * @param columnNames The column names stored as an array

File: core/src/main/java/tech/tablesaw/io/csv/CsvReadOptions.java
Patch:
@@ -237,7 +237,7 @@ public Builder lineEnding(String lineEnding) {
     /**
      * Defines maximal value of columns in csv file.
      *
-     * @param maxNumberOfColumns - must be positive integer. Default is 512.
+     * @param maxNumberOfColumns - must be positive integer. Default is 10,000
      */
     public Builder maxNumberOfColumns(Integer maxNumberOfColumns) {
       this.maxNumberOfColumns = maxNumberOfColumns;

File: core/src/test/java/tech/tablesaw/api/RowPerformanceTest.java
Patch:
@@ -66,7 +66,7 @@ public static void main(String[] args) {
     stopwatch.start();
     while (row.hasNext()) {
       row.next();
-      row.getInt("lowValue");
+      row.getDouble("lowValue");
     }
     stopwatch.stop();
     System.out.println("one getInt(): " + stopwatch.elapsed(TimeUnit.MILLISECONDS) + " ms");
@@ -139,7 +139,7 @@ public static void main(String[] args) {
     stopwatch.start();
     while (row.hasNext()) {
       row.next();
-      row.getInt(2);
+      row.getDouble(2);
     }
     stopwatch.stop();
     System.out.println("one getInt(): " + stopwatch.elapsed(TimeUnit.MILLISECONDS) + " ms");

File: core/src/test/java/tech/tablesaw/api/BooleanColumnTest.java
Patch:
@@ -19,7 +19,7 @@
 import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
-import java.util.Arrays;
+import java.util.Collections;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import tech.tablesaw.columns.booleans.BooleanFormatter;
@@ -160,7 +160,7 @@ public void testAddCell() {
   public void testCustomParser() {
     // Just do enough to ensure the parser is wired up correctly
     BooleanParser customParser = new BooleanParser(ColumnType.LOCAL_DATE);
-    customParser.setMissingValueStrings(Arrays.asList("not here"));
+    customParser.setMissingValueStrings(Collections.singletonList("not here"));
     column.setParser(customParser);
 
     column.appendCell("not here");

File: core/src/main/java/tech/tablesaw/api/ColumnType.java
Patch:
@@ -81,8 +81,10 @@ static ColumnType valueOf(String name) {
   /** Returns a printer-friendly version of this ColumnType's name */
   String getPrinterFriendlyName();
 
+  /** TODO: Research this method to provide a good comment */
   AbstractColumnParser<?> customParser(ReadOptions options);
 
+  /** TODO: Research this method to provide a good comment */
   default boolean compare(int rowNumber, Column<?> temp, Column<?> original) {
     Object o1 = original.get(rowNumber);
     Object o2 = temp.get(temp.size() - 1);

File: core/src/main/java/tech/tablesaw/api/InstantColumn.java
Patch:
@@ -639,6 +639,8 @@ public LongIterator longIterator() {
     return data.iterator();
   }
 
+  /** {@inheritDoc} */
+  @Override
   public Set<Instant> asSet() {
     Set<Instant> times = new HashSet<>();
     InstantColumn unique = unique();

File: core/src/main/java/tech/tablesaw/api/TextColumn.java
Patch:
@@ -397,6 +397,8 @@ public Iterator<String> iterator() {
     return values.iterator();
   }
 
+  /** {@inheritDoc} */
+  @Override
   public Set<String> asSet() {
     return new HashSet<>(values);
   }

File: core/src/main/java/tech/tablesaw/api/TextColumn.java
Patch:
@@ -383,9 +383,8 @@ public Set<String> asSet() {
   /** Returns the contents of the cell at rowNumber as a byte[] */
   @Override
   public byte[] asBytes(int rowNumber) {
-    return new byte[0];
-    // TODO (lwhite): FIX ME:  return
-    // ByteBuffer.allocate(byteSize()).putInt(getInt(rowNumber)).array();
+    String value = get(rowNumber);
+    return value.getBytes();
   }
 
   /** Added for naming consistency with all other columns */

File: core/src/main/java/tech/tablesaw/table/SelectionTableSliceGroup.java
Patch:
@@ -41,7 +41,7 @@ private SelectionTableSliceGroup(Table original, String subTableNameTemplate, in
 
   private void splitOnSelection(String nameTemplate, List<Selection> selections) {
     for (int i = 0; i < selections.size(); i++) {
-      TableSlice view = new TableSlice(getSourceTable(), selections.get(i), textColumns);
+      TableSlice view = new TableSlice(getSourceTable(), selections.get(i));
       String name = nameTemplate + ": " + i + 1;
       view.setName(name);
       getSlices().add(view);

File: core/src/main/java/tech/tablesaw/table/SelectionTableSliceGroup.java
Patch:
@@ -41,7 +41,7 @@ private SelectionTableSliceGroup(Table original, String subTableNameTemplate, in
 
   private void splitOnSelection(String nameTemplate, List<Selection> selections) {
     for (int i = 0; i < selections.size(); i++) {
-      TableSlice view = new TableSlice(getSourceTable(), selections.get(i));
+      TableSlice view = new TableSlice(getSourceTable(), selections.get(i), textColumns);
       String name = nameTemplate + ": " + i + 1;
       view.setName(name);
       getSlices().add(view);

File: core/src/main/java/tech/tablesaw/table/StandardTableSliceGroup.java
Patch:
@@ -93,7 +93,7 @@ private void splitOn(String... columnNames) {
 
     // Add all slices
     for (Entry<ByteArray, Selection> entry : selectionMap.entrySet()) {
-      TableSlice slice = new TableSlice(getSourceTable(), entry.getValue());
+      TableSlice slice = new TableSlice(getSourceTable(), entry.getValue(), textColumns);
       slice.setName(sliceNameMap.get(entry.getKey()));
       addSlice(slice);
     }

File: core/src/main/java/tech/tablesaw/table/TableSliceGroup.java
Patch:
@@ -202,7 +202,7 @@ public Table aggregate(ListMultimap<String, AggregateFunction<?, ?>> functions)
           if (firstFunction) {
             groupColumn.append(subTable.name());
           }
-          if (result instanceof Number) {
+          if (function.returnType().equals(ColumnType.DOUBLE)) {
             Number number = (Number) result;
             resultColumn.append(number.doubleValue());
           } else {

File: core/src/main/java/tech/tablesaw/api/DoubleColumn.java
Patch:
@@ -38,9 +38,6 @@ public static boolean valueIsMissing(double value) {
   @Override
   public String getString(int row) {
     final double value = getDouble(row);
-    if (DoubleColumnType.valueIsMissing(value)) {
-      return "";
-    }
     return String.valueOf(getPrintFormatter().format(value));
   }
 

File: core/src/main/java/tech/tablesaw/api/IntColumn.java
Patch:
@@ -274,9 +274,6 @@ public byte[] asBytes(int rowNumber) {
   @Override
   public String getString(final int row) {
     final int value = getInt(row);
-    if (IntColumnType.valueIsMissing(value)) {
-      return "";
-    }
     return String.valueOf(getPrintFormatter().format(value));
   }
 

File: core/src/main/java/tech/tablesaw/api/LongColumn.java
Patch:
@@ -75,9 +75,6 @@ public static LongColumn indexColumn(
   @Override
   public String getString(final int row) {
     final long value = getLong(row);
-    if (LongColumnType.valueIsMissing(value)) {
-      return "";
-    }
     return getPrintFormatter().format(value);
   }
 

File: core/src/main/java/tech/tablesaw/api/NumberColumn.java
Patch:
@@ -61,6 +61,7 @@ public void setPrintFormatter(final NumberFormat format, final String missingVal
   @Override
   public void setPrintFormatter(final NumberColumnFormatter formatter) {
     this.printFormatter = formatter;
+    formatter.setColumnType(type());
   }
 
   protected NumberColumnFormatter getPrintFormatter() {

File: core/src/main/java/tech/tablesaw/api/ShortColumn.java
Patch:
@@ -268,9 +268,6 @@ public ShortColumn append(final Column<Short> column) {
   @Override
   public String getString(final int row) {
     final short value = getShort(row);
-    if (ShortColumnType.valueIsMissing(value)) {
-      return "";
-    }
     return String.valueOf(getPrintFormatter().format(value));
   }
 

File: core/src/main/java/tech/tablesaw/columns/Column.java
Patch:
@@ -78,7 +78,7 @@ default int countUnique() {
   ColumnType type();
 
   /**
-   * Returns the parser used by {@link #appendCell()}.
+   * Returns the parser used by {@link #appendCell(String)} ()}.
    *
    * @return {@link AbstractColumnParser}
    */
@@ -571,6 +571,7 @@ default Column<T> set(Selection rowSelection, T newValue) {
 
   Column<T> set(int row, T value);
 
+  @SuppressWarnings("unchecked")
   default Column<T> set(int row, String stringValue, AbstractColumnParser<?> parser) {
     AbstractColumnParser<T> typedParser = (AbstractColumnParser<T>) parser;
     return set(row, typedParser.parse(stringValue));
@@ -620,7 +621,7 @@ default Column<T> last(final int numRows) {
   Column<T> setName(String name);
 
   /**
-   * Sets the parser used by {@link #appendCell()}
+   * Sets the parser used by {@link #appendCell(String)}
    *
    * @param parser a column parser that converts text input to the column data type
    * @return this Column to allow method chaining

File: core/src/main/java/tech/tablesaw/io/csv/CsvWriter.java
Patch:
@@ -61,7 +61,7 @@ public void write(Table table, CsvWriteOptions options) {
     } finally {
       if (csvWriter != null) {
         csvWriter.flush();
-        csvWriter.close();
+        if (options.autoClose()) csvWriter.close();
       }
     }
   }

File: core/src/main/java/tech/tablesaw/io/fixed/FixedWidthWriter.java
Patch:
@@ -65,7 +65,7 @@ public void write(Table table, FixedWidthWriteOptions options) {
     } finally {
       if (fixedWidthWriter != null) {
         fixedWidthWriter.flush();
-        fixedWidthWriter.close();
+        if (options.autoClose()) fixedWidthWriter.close();
       }
     }
   }

File: core/src/main/java/tech/tablesaw/io/fixed/FixedWidthWriteOptions.java
Patch:
@@ -217,7 +217,7 @@ public FixedWidthWriteOptions.Builder header(boolean header) {
       return this;
     }
 
-    public FixedWidthWriteOptions.Builder header(FixedWidthFields columnSpecs) {
+    public FixedWidthWriteOptions.Builder columnSpecs(FixedWidthFields columnSpecs) {
       this.columnSpecs = columnSpecs;
       return this;
     }

File: core/src/main/java/tech/tablesaw/io/fixed/FixedWidthWriter.java
Patch:
@@ -97,6 +97,9 @@ protected FixedWidthFormat fixedWidthFormat(FixedWidthWriteOptions options) {
 
   protected FixedWidthWriterSettings fixedWidthWriterSettings(FixedWidthWriteOptions options) {
     FixedWidthWriterSettings settings = new FixedWidthWriterSettings();
+    if (options.columnSpecs() != null) {
+      settings = new FixedWidthWriterSettings(options.columnSpecs());
+    }
 
     if (options.autoConfigurationEnabled()) {
       settings.setAutoConfigurationEnabled(options.autoConfigurationEnabled());

File: core/src/main/java/tech/tablesaw/api/DateColumn.java
Patch:
@@ -103,7 +103,7 @@ public static DateColumn create(String name, Stream<LocalDate> stream) {
   }
 
   private DateColumn(String name, IntArrayList data) {
-    super(DateColumnType.instance(), name);
+    super(DateColumnType.instance(), name, DateColumnType.DEFAULT_PARSER);
     this.data = data;
   }
 
@@ -381,7 +381,7 @@ public DateColumn appendObj(Object obj) {
 
   @Override
   public DateColumn appendCell(String string) {
-    return appendInternal(PackedLocalDate.pack(DateColumnType.DEFAULT_PARSER.parse(string)));
+    return appendInternal(PackedLocalDate.pack(parser().parse(string)));
   }
 
   @Override
@@ -477,6 +477,7 @@ public List<LocalDate> bottom(int n) {
     return bottom;
   }
 
+  @Override
   public IntIterator intIterator() {
     return data.iterator();
   }

File: core/src/main/java/tech/tablesaw/api/FloatColumn.java
Patch:
@@ -17,7 +17,7 @@ public class FloatColumn extends NumberColumn<FloatColumn, Float> {
   private final FloatArrayList data;
 
   private FloatColumn(String name, FloatArrayList data) {
-    super(FloatColumnType.instance(), name);
+    super(FloatColumnType.instance(), name, FloatColumnType.DEFAULT_PARSER);
     setPrintFormatter(NumberColumnFormatter.floatingPointDefault());
     this.data = data;
   }
@@ -189,6 +189,7 @@ public FloatColumn append(float i) {
     return this;
   }
 
+  @Override
   public FloatColumn append(Float val) {
     if (val == null) {
       appendMissing();
@@ -342,7 +343,7 @@ public FloatColumn appendObj(Object obj) {
   @Override
   public FloatColumn appendCell(final String value) {
     try {
-      return append(FloatColumnType.DEFAULT_PARSER.parseFloat(value));
+      return append(parser().parseFloat(value));
     } catch (final NumberFormatException e) {
       throw new NumberFormatException(
           "Error adding value to column " + name() + ": " + e.getMessage());

File: core/src/main/java/tech/tablesaw/api/LongColumn.java
Patch:
@@ -20,7 +20,7 @@ public class LongColumn extends NumberColumn<LongColumn, Long> implements Catego
   private final LongArrayList data;
 
   private LongColumn(String name, LongArrayList data) {
-    super(LongColumnType.instance(), name);
+    super(LongColumnType.instance(), name, LongColumnType.DEFAULT_PARSER);
     setPrintFormatter(NumberColumnFormatter.ints());
     this.data = data;
   }
@@ -199,6 +199,7 @@ public LongColumn append(long i) {
     return this;
   }
 
+  @Override
   public LongColumn append(Long val) {
     if (val == null) {
       appendMissing();
@@ -398,7 +399,7 @@ public LongColumn appendObj(Object obj) {
   @Override
   public LongColumn appendCell(final String value) {
     try {
-      return append(LongColumnType.DEFAULT_PARSER.parseLong(value));
+      return append(parser().parseLong(value));
     } catch (final NumberFormatException e) {
       throw new NumberFormatException(
           "Error adding value to column " + name() + ": " + e.getMessage());

File: core/src/main/java/tech/tablesaw/columns/strings/AbstractStringColumn.java
Patch:
@@ -6,6 +6,7 @@
 import tech.tablesaw.api.CategoricalColumn;
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.columns.AbstractColumn;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.columns.Column;
 
 /** Abstract super class for Text like columns. */
@@ -14,8 +15,8 @@ public abstract class AbstractStringColumn<C extends AbstractColumn<C, String>>
     implements CategoricalColumn<String>, StringFilters, StringMapFunctions, StringReduceUtils {
   private StringColumnFormatter printFormatter = new StringColumnFormatter();
 
-  public AbstractStringColumn(ColumnType type, String name) {
-    super(type, name);
+  public AbstractStringColumn(ColumnType type, String name, AbstractColumnParser<String> parser) {
+    super(type, name, parser);
   }
 
   public void setPrintFormatter(StringColumnFormatter formatter) {

File: core/src/main/java/tech/tablesaw/api/StringColumn.java
Patch:
@@ -234,11 +234,11 @@ public StringColumn lag(int n) {
         if (i + n >= size()) {
           break;
         }
-        copy.appendCell(get(i));
+        copy.append(get(i));
       }
     } else {
       for (int i = -n; i < size(); i++) {
-        copy.appendCell(get(i));
+        copy.append(get(i));
       }
       for (int m = 0; m > n; m--) {
         copy.appendMissing();

File: core/src/test/java/tech/tablesaw/io/DataFrameReaderTest.java
Patch:
@@ -26,7 +26,8 @@ void setUp() {
   }
 
   private URL mockUrlHelper(String url, List<String> content) throws Exception {
-    Path path = mockFileHelper(url, content);
+    // Remove http:// part to be able to save to a local filesystem file
+    Path path = mockFileHelper(url.replace("http://", ""), content);
     return path.toUri().toURL();
   }
 
@@ -40,7 +41,7 @@ private Path mockFileHelper(String path, List<String> content) throws IOExceptio
 
   @Test
   public void csv() throws IOException {
-    Path path = mockFileHelper("/data/file.csv", ImmutableList.of("region", "canada", "us"));
+    Path path = mockFileHelper("data/file.csv", ImmutableList.of("region", "canada", "us"));
     Table expected = Table.create(StringColumn.create("region", new String[] {"canada", "us"}));
     Table actual = Table.read().csv(Files.newInputStream(path));
     assertEquals(expected.columnNames(), actual.columnNames());

File: core/src/test/java/tech/tablesaw/io/csv/UnicodeBomHandlingTest.java
Patch:
@@ -6,6 +6,7 @@
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
+import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 import tech.tablesaw.api.Table;
 
@@ -22,6 +23,7 @@ public class UnicodeBomHandlingTest {
   }
 
   @Test
+  @Disabled
   public void javaBehaviour() throws IOException {
 
     Table t =

File: html/src/test/java/tech/tablesaw/io/html/HtmlWriterTest.java
Patch:
@@ -29,7 +29,7 @@
 
 public class HtmlWriterTest {
 
-  private static final String LINE_END = System.lineSeparator();
+  private static final String LINE_END = "\n";
 
   private double[] v1 = {1, 2, NaN};
   private double[] v2 = {1, 2, NaN};

File: core/src/main/java/tech/tablesaw/api/TextColumn.java
Patch:
@@ -292,7 +292,8 @@ public TextColumn appendCell(String object) {
 
   @Override
   public TextColumn appendCell(String object, AbstractColumnParser<?> parser) {
-    return appendObj(parser.parse(object));
+    values.add(String.valueOf(parser.parse(object)));
+    return this;
   }
 
   @Override

File: core/src/main/java/tech/tablesaw/io/TypeUtils.java
Patch:
@@ -28,8 +28,9 @@ public final class TypeUtils {
   private static final String missingInd2 = "*";
   private static final String missingInd3 = "NA";
   private static final String missingInd4 = "null";
+  private static final String missingInd5 = "N/A";
   public static final ImmutableList<String> MISSING_INDICATORS =
-      ImmutableList.of(missingInd1, missingInd2, missingInd3, missingInd4);
+      ImmutableList.of(missingInd1, missingInd2, missingInd3, missingInd4, missingInd5);
 
   /** Private constructor to prevent instantiation */
   private TypeUtils() {}

File: jsplot/src/test/java/tech/tablesaw/examples/DotPlotExample.java
Patch:
@@ -30,7 +30,7 @@ public static void main(String[] args) throws Exception {
     IntColumn year = bush.dateColumn("date").year();
     year.setName("year");
     bush.addColumns(year);
-    bush.dropWhere(bush.intColumn("year").isIn((Number) 2001, (Number) 2002));
+    bush.dropWhere(bush.intColumn("year").isIn(2001, 2002));
     Table summary = bush.summarize("approval", AggregateFunctions.mean).by("who", "year");
 
     Layout layout2 =

File: core/src/test/java/tech/tablesaw/io/csv/CsvReaderTest.java
Patch:
@@ -107,7 +107,7 @@ void textColumnShutoff() throws IOException {
 
     Table table = Table.read().csv(CsvReadOptions.builder("../data/cities-states-zipcode.csv"));
     ColumnType[] types = {INTEGER, STRING, DOUBLE, BOOLEAN};
-    List<ColumnType> typesToDetect = Arrays.asList(types);
+    List<ColumnType> typesToDetect = asList(types);
     Table table2 =
         Table.read()
             .csv(

File: core/src/main/java/tech/tablesaw/io/ReadOptions.java
Patch:
@@ -44,15 +44,15 @@ public class ReadOptions {
 
   private static final List<ColumnType> DEFAULT_TYPES =
       Lists.newArrayList(
-          LOCAL_DATE_TIME, LOCAL_TIME, LOCAL_DATE, BOOLEAN, INTEGER, LONG, DOUBLE, STRING);
+          LOCAL_DATE_TIME, LOCAL_TIME, LOCAL_DATE, BOOLEAN, INTEGER, LONG, DOUBLE, STRING, TEXT);
 
   /**
    * An extended list of types that are used if minimizeColumnSizes is true. By including extra
    * types like Short the resulting table size is reduced at the cost of some additional complexity
    * for the programmer if, for example, they will subsequently modify the data in a way that
    * exceeds the range of the type.
    */
-  private static final List<ColumnType> EXTENDED_TYPES =
+  protected static final List<ColumnType> EXTENDED_TYPES =
       Lists.newArrayList(
           LOCAL_DATE_TIME,
           LOCAL_TIME,

File: core/src/main/java/tech/tablesaw/index/StringIndex.java
Patch:
@@ -17,7 +17,7 @@
 import it.unimi.dsi.fastutil.ints.IntArrayList;
 import java.util.HashMap;
 import java.util.Map;
-import tech.tablesaw.api.StringColumn;
+import tech.tablesaw.columns.strings.AbstractStringColumn;
 import tech.tablesaw.selection.BitmapBackedSelection;
 import tech.tablesaw.selection.Selection;
 
@@ -26,7 +26,7 @@ public class StringIndex implements Index {
 
   private final Map<String, IntArrayList> index;
 
-  public StringIndex(StringColumn column) {
+  public StringIndex(AbstractStringColumn<?> column) {
     int sizeEstimate = Integer.min(1_000_000, column.size() / 100);
     Map<String, IntArrayList> tempMap = new HashMap<>(sizeEstimate);
     for (int i = 0; i < column.size(); i++) {

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -655,7 +655,7 @@ public DoubleColumn asDoubleColumn() {
     DoubleColumn numberColumn = DoubleColumn.create(this.name(), size());
     ByteArrayList data = data();
     for (int i = 0; i < size(); i++) {
-      numberColumn.append(data.getByte(i));
+      numberColumn.set(i, data.getByte(i));
     }
     return numberColumn;
   }

File: core/src/main/java/tech/tablesaw/columns/strings/ByteDictionaryMap.java
Patch:
@@ -17,6 +17,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Comparator;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -177,7 +178,7 @@ public int countOccurrences(String value) {
   }
 
   public Set<String> asSet() {
-    return categories();
+    return new HashSet<>(categories());
   }
 
   public int firstIndexOf(String value) {

File: core/src/main/java/tech/tablesaw/columns/strings/IntDictionaryMap.java
Patch:
@@ -17,6 +17,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Comparator;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -176,7 +177,7 @@ public int countOccurrences(String value) {
   }
 
   public Set<String> asSet() {
-    return categories();
+    return new HashSet<>(categories());
   }
 
   public int firstIndexOf(String value) {

File: core/src/main/java/tech/tablesaw/columns/strings/ShortDictionaryMap.java
Patch:
@@ -17,6 +17,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Comparator;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -186,7 +187,7 @@ public int countOccurrences(String value) {
   }
 
   public Set<String> asSet() {
-    return categories();
+    return new HashSet<>(categories());
   }
 
   public int firstIndexOf(String value) {

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -62,9 +62,9 @@ public class BooleanColumn extends AbstractColumn<BooleanColumn, Boolean>
 
   private final IntComparator comparator =
       (r1, r2) -> {
-        boolean f1 = get(r1);
-        boolean f2 = get(r2);
-        return Boolean.compare(f1, f2);
+        byte f1 = getByte(r1);
+        byte f2 = getByte(r2);
+        return Byte.compare(f1, f2);
       };
 
   private BooleanFormatter formatter = new BooleanFormatter("true", "false", "");

File: core/src/main/java/tech/tablesaw/columns/dates/DateMapFunctions.java
Patch:
@@ -200,7 +200,7 @@ default StringColumn yearDay() {
    * you don't want months from different years aggregated together).
    */
   default StringColumn yearWeek() {
-    StringColumn newColumn = StringColumn.create(this.name() + " year & month");
+    StringColumn newColumn = StringColumn.create(this.name() + " year & week");
     for (int r = 0; r < this.size(); r++) {
       int c1 = this.getIntInternal(r);
       if (DateColumn.valueIsMissing(c1)) {

File: core/src/main/java/tech/tablesaw/api/StringColumn.java
Patch:
@@ -28,7 +28,6 @@
 import tech.tablesaw.columns.strings.AbstractStringColumn;
 import tech.tablesaw.columns.strings.ByteDictionaryMap;
 import tech.tablesaw.columns.strings.DictionaryMap;
-import tech.tablesaw.columns.strings.LookupTableWrapper;
 import tech.tablesaw.columns.strings.NoKeysAvailableException;
 import tech.tablesaw.columns.strings.StringColumnType;
 import tech.tablesaw.selection.BitmapBackedSelection;
@@ -522,7 +521,7 @@ public TextColumn asTextColumn() {
   }
 
   /** For tablesaw internal use only */
-  public LookupTableWrapper getLookupTable() {
-    return new LookupTableWrapper(lookupTable);
+  public DictionaryMap getDictionary() {
+    return lookupTable;
   }
 }

File: core/src/main/java/tech/tablesaw/columns/strings/DictionaryMap.java
Patch:
@@ -100,4 +100,6 @@ default Selection isNotEqualTo(String string) {
   boolean isMissing(int rowNumber);
 
   DictionaryMap promoteYourself();
+
+  int nextKeyWithoutIncrementing();
 }

File: core/src/main/java/tech/tablesaw/aggregate/BooleanNumericFunction.java
Patch:
@@ -19,6 +19,6 @@ public boolean isCompatibleColumn(ColumnType type) {
 
   @Override
   public ColumnType returnType() {
-    return null;
+    return ColumnType.DOUBLE;
   }
 }

File: saw/src/main/java/tech/tablesaw/io/saw/TableMetadata.java
Patch:
@@ -36,7 +36,7 @@ public class TableMetadata {
   private static final ObjectMapper objectMapper = new ObjectMapper();
 
   @JsonProperty("columnMetadata")
-  private List<ColumnMetadata> columnMetadataList = new ArrayList<>();
+  private final List<ColumnMetadata> columnMetadataList = new ArrayList<>();
 
   private String name;
   private int rowCount;

File: saw/src/main/java/tech/tablesaw/io/saw/ColumnMetadata.java
Patch:
@@ -38,6 +38,7 @@
 import tech.tablesaw.api.DateTimeColumn;
 import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.FloatColumn;
+import tech.tablesaw.api.InstantColumn;
 import tech.tablesaw.api.IntColumn;
 import tech.tablesaw.api.LongColumn;
 import tech.tablesaw.api.ShortColumn;
@@ -148,7 +149,7 @@ public Column<?> createColumn() {
       case LOCAL_DATE_TIME:
         return DateTimeColumn.create(name);
       case INSTANT:
-        return DateTimeColumn.create(name);
+        return InstantColumn.create(name);
       case STRING:
         return StringColumn.create(name);
       case TEXT:

File: core/src/main/java/tech/tablesaw/api/ColumnType.java
Patch:
@@ -68,6 +68,8 @@ static ColumnType valueOf(String name) {
   AbstractColumnParser<?> customParser(ReadOptions options);
 
   default boolean compare(int rowNumber, Column<?> temp, Column<?> original) {
-    return original.get(rowNumber).equals(temp.get(temp.size() - 1));
+    Object o1 = original.get(rowNumber);
+    Object o2 = temp.get(temp.size() - 1);
+    return o1 == null ? o2 == null : o1.equals(o2);
   }
 }

File: core/src/main/java/tech/tablesaw/api/DoubleColumn.java
Patch:
@@ -102,7 +102,7 @@ public static DoubleColumn create(String name, long... arr) {
     return new DoubleColumn(name, new DoubleArrayList(doubles));
   }
 
-  public static DoubleColumn create(String name, Collection<Number> numberList) {
+  public static DoubleColumn create(String name, Collection<? extends Number> numberList) {
     DoubleColumn newColumn = new DoubleColumn(name, new DoubleArrayList(0));
     for (Number number : numberList) {
       newColumn.append(number);

File: json/src/main/java/tech/tablesaw/io/json/JsonReader.java
Patch:
@@ -39,7 +39,7 @@ public Table read(JsonReadOptions options) throws IOException {
     }
     if (!jsonObj.isArray()) {
       throw new IllegalStateException(
-          "Only reading a json array or arrays or objects is currently supported");
+          "Only reading a JSON array is currently supported. The array must hold an array or object for each row.");
     }
     if (jsonObj.size() == 0) {
       return Table.create(options.tableName());

File: core/src/main/java/tech/tablesaw/io/csv/CsvWriter.java
Patch:
@@ -81,6 +81,7 @@ protected static CsvWriterSettings createSettings(CsvWriteOptions options) {
     settings.setIgnoreTrailingWhitespaces(options.ignoreTrailingWhitespaces());
     // writes empty lines as well.
     settings.setSkipEmptyLines(false);
+    settings.setQuoteAllFields(options.quoteAllFields());
     return settings;
   }
 

File: core/src/test/java/tech/tablesaw/io/csv/CsvWriteOptionsTest.java
Patch:
@@ -19,6 +19,7 @@ public void testSettingsPropagation() {
             .lineEnd("\r\n")
             .quoteChar('"')
             .separator('.')
+            .quoteAllFields(true)
             .ignoreLeadingWhitespaces(true)
             .ignoreTrailingWhitespaces(true)
             .build();
@@ -28,9 +29,10 @@ public void testSettingsPropagation() {
     assertEquals('.', options.separator());
     assertTrue(options.ignoreLeadingWhitespaces());
     assertTrue(options.ignoreTrailingWhitespaces());
+    assertTrue(options.quoteAllFields());
 
     CsvWriterSettings settings = CsvWriter.createSettings(options);
-
+    assertTrue(settings.getQuoteAllFields());
     assertEquals('~', settings.getFormat().getQuoteEscape());
     assertEquals("\r\n", settings.getFormat().getLineSeparatorString());
     assertEquals('"', settings.getFormat().getQuote());

File: jsplot/src/main/java/tech/tablesaw/plotly/traces/Scatter3DTrace.java
Patch:
@@ -22,7 +22,6 @@ public class Scatter3DTrace extends AbstractTrace {
   private final String[] text;
   private final Mode mode;
   private final HoverLabel hoverLabel;
-  private final boolean showLegend;
   private final Marker marker;
 
   public static Scatter3DBuilder builder(double[] x, double[] y, double[] z) {
@@ -44,7 +43,6 @@ private Scatter3DTrace(Scatter3DBuilder builder) {
     this.z = builder.z;
     this.text = builder.text;
     this.hoverLabel = builder.hoverLabel;
-    this.showLegend = builder.showLegend;
     this.marker = builder.marker;
   }
 
@@ -56,7 +54,6 @@ private Map<String, Object> getContext(int i) {
     context.put("y", dataAsString(y));
     context.put("x", dataAsString(x));
     context.put("z", dataAsString(z));
-    context.put("showlegend", showLegend);
     if (marker != null) {
       context.put("marker", marker);
     }

File: jsplot/src/main/java/tech/tablesaw/plotly/components/threeD/Scene.java
Patch:
@@ -54,7 +54,7 @@ public String asJavascript() {
     Writer writer = new StringWriter();
     PebbleTemplate compiledTemplate;
     try {
-      compiledTemplate = engine.getTemplate("scene_template.html");
+      compiledTemplate = getEngine().getTemplate("scene_template.html");
       compiledTemplate.evaluate(writer, getContext());
     } catch (PebbleException e) {
       throw new IllegalStateException(e);

File: jsplot/src/test/java/tech/tablesaw/components/TemplateUtilsTest.java
Patch:
@@ -5,7 +5,6 @@
 
 import java.io.File;
 import java.net.URL;
-import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 import tech.tablesaw.plotly.components.Figure;
 import tech.tablesaw.plotly.components.Page;
@@ -29,7 +28,6 @@ public void testDefaultTemplateLocation() {
   }
 
   @Test
-  @Disabled
   public void testCustomTemplateLocation() {
     URL url = this.getClass().getResource(this.getClass().getSimpleName() + ".class");
     assertNotNull(url, "Couldn't locate class (as resource), where template is also found");

File: core/src/test/java/tech/tablesaw/columns/ColumnTest.java
Patch:
@@ -282,7 +282,7 @@ public void testMap() {
   public void testMap2() {
     StringColumn c =
         DoubleColumn.create("t1", new double[] {-1, 0, 1})
-            .map(String::valueOf, StringColumn::create);
+            .map(String::valueOf, name -> StringColumn.create(name, 3));
     assertContentEquals(c, "-1.0", "0.0", "1.0");
   }
 

File: jsplot/src/test/java/tech/tablesaw/examples/HoverBroadcastExample.java
Patch:
@@ -7,7 +7,7 @@
 import tech.tablesaw.api.IntColumn;
 import tech.tablesaw.plotly.Plot;
 import tech.tablesaw.plotly.components.Axis;
-import tech.tablesaw.plotly.components.Figure;
+import tech.tablesaw.plotly.components.Figure.FigureBuilder;
 import tech.tablesaw.plotly.components.Layout;
 import tech.tablesaw.plotly.event.HoverBroadcastBody;
 import tech.tablesaw.plotly.event.HoverEventHandler;
@@ -60,6 +60,7 @@ public static void main(String[] args) throws Exception {
             .yAxis2(Axis.builder().title("price").domain(0.35f, 1.0f).build())
             .build();
 
-    Plot.show(new Figure(layout, heh, trace0, trace1));
+    Plot.show(
+        new FigureBuilder().layout(layout).addEventHandlers(heh).addTraces(trace0, trace1).build());
   }
 }

File: core/src/main/java/tech/tablesaw/columns/AbstractColumnType.java
Patch:
@@ -30,6 +30,7 @@ protected AbstractColumnType(int byteSize, String name, String printerFriendlyNa
     this.byteSize = byteSize;
     this.name = name;
     this.printerFriendlyName = printerFriendlyName;
+    ColumnType.register(this);
   }
 
   @Override

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -210,7 +210,8 @@ private void validateColumn(final Column<?> newColumn) {
     }
     if (stringList.contains(newColumn.name().toLowerCase())) {
       String message =
-          String.format("Cannot add column with duplicate name %s to table %s", newColumn, name);
+          String.format(
+              "Cannot add column with duplicate name %s to table %s", newColumn.name(), name);
       throw new IllegalArgumentException(message);
     }
 

File: core/src/main/java/tech/tablesaw/columns/AbstractColumnType.java
Patch:
@@ -30,7 +30,6 @@ protected AbstractColumnType(int byteSize, String name, String printerFriendlyNa
     this.byteSize = byteSize;
     this.name = name;
     this.printerFriendlyName = printerFriendlyName;
-    ColumnType.register(this);
   }
 
   @Override

File: core/src/main/java/tech/tablesaw/io/FileReader.java
Patch:
@@ -19,7 +19,6 @@
 
 public abstract class FileReader {
 
-  /** Constructs a CsvReader */
   public FileReader() {}
 
   /**

File: core/src/main/java/tech/tablesaw/columns/temporal/TemporalPredicates.java
Patch:
@@ -20,7 +20,7 @@
 
 public class TemporalPredicates {
 
-  private TemporalPredicates() {}
+  protected TemporalPredicates() {}
 
   public static final LongPredicate isMissing = i -> i == InstantColumnType.missingValueIndicator();
 

File: core/src/main/java/tech/tablesaw/api/ColumnType.java
Patch:
@@ -22,7 +22,7 @@
 
 public interface ColumnType {
 
-  Map<String, ColumnType> values = new HashMap<>();
+  final Map<String, ColumnType> values = new HashMap<>();
 
   // standard column types
   ShortColumnType SHORT = ShortColumnType.instance();

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -137,7 +137,7 @@ protected ColumnType[] detectColumnTypes(Reader reader, CsvReadOptions options)
     CsvParser parser = csvParser(options);
 
     try {
-      return getTypes(reader, options, linesToSkip, parser);
+      return getColumnTypes(reader, options, linesToSkip, parser);
     } finally {
       parser.stopParsing();
       // we don't close the reader since we didn't create it

File: core/src/main/java/tech/tablesaw/io/fixed/FixedWidthReader.java
Patch:
@@ -138,7 +138,7 @@ public ColumnType[] detectColumnTypes(Reader reader, FixedWidthReadOptions optio
     AbstractParser<?> parser = fixedWidthParser(options);
 
     try {
-      return getTypes(reader, options, linesToSkip, parser);
+      return getColumnTypes(reader, options, linesToSkip, parser);
     } finally {
       parser.stopParsing();
       // we don't close the reader since we didn't create it

File: html/src/main/java/tech/tablesaw/io/html/HtmlReader.java
Patch:
@@ -52,7 +52,9 @@ public Table read(HtmlReadOptions options) throws IOException {
               "Table index outside bounds. The URL has " + tables.size() + " tables");
         }
       } else {
-          throw new IllegalStateException(tables.size() + " tables found. When more than one html table is present on the page you must specify the index of the table to read from.");
+        throw new IllegalStateException(
+            tables.size()
+                + " tables found. When more than one html table is present on the page you must specify the index of the table to read from.");
       }
     }
     Element htmlTable = tables.get(tableIndex);

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -700,7 +700,7 @@ public Table dropWhere(Selection selection) {
   public Table pivot(
       CategoricalColumn<?> column1,
       CategoricalColumn<?> column2,
-      NumberColumn<?> column3,
+      NumericColumn<?> column3,
       AggregateFunction<?, ?> aggregateFunction) {
     return PivotTable.pivot(this, column1, column2, column3, aggregateFunction);
   }

File: core/src/main/java/tech/tablesaw/api/TextColumn.java
Patch:
@@ -41,7 +41,7 @@
  * <p>Because the MISSING_VALUE for this column type is an empty string, there is little or no need
  * for special handling of missing values in this class's methods.
  */
-public class TextColumn extends AbstractStringColumn {
+public class TextColumn extends AbstractStringColumn<TextColumn> {
 
   // holds each element in the column.
   private List<String> values;

File: core/src/main/java/tech/tablesaw/columns/Column.java
Patch:
@@ -380,7 +380,7 @@ default Column<T> filter(Predicate<? super T> test) {
     return result;
   }
 
-  default Column<T> subset(final int[] rows) {
+  default Column<T> subset(int[] rows) {
     final Column<T> c = this.emptyCopy();
     for (final int row : rows) {
       c.appendObj(get(row));

File: core/src/main/java/tech/tablesaw/columns/strings/AbstractStringColumn.java
Patch:
@@ -9,7 +9,8 @@
 import tech.tablesaw.columns.Column;
 
 /** Abstract super class for Text like columns. */
-public abstract class AbstractStringColumn extends AbstractColumn<String>
+public abstract class AbstractStringColumn<C extends AbstractColumn<C, String>>
+    extends AbstractColumn<C, String>
     implements CategoricalColumn<String>, StringFilters, StringMapFunctions, StringReduceUtils {
   private StringColumnFormatter printFormatter = new StringColumnFormatter();
 

File: core/src/main/java/tech/tablesaw/table/TableSlice.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.stream.IntStream;
 import javax.annotation.Nullable;
 import tech.tablesaw.aggregate.NumericAggregateFunction;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.NumericColumn;
 import tech.tablesaw.api.Row;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.Column;
@@ -214,7 +214,7 @@ protected PrimitiveIterator.OfInt sourceRowNumberIterator() {
    *     table
    */
   public double reduce(String numberColumnName, NumericAggregateFunction function) {
-    NumberColumn<?> column = table.numberColumn(numberColumnName);
+    NumericColumn<?> column = table.numberColumn(numberColumnName);
     if (hasSelection()) {
       return function.summarize(column.where(selection));
     }

File: core/src/main/java/tech/tablesaw/util/DoubleArrays.java
Patch:
@@ -16,7 +16,6 @@
 
 import com.google.common.base.Preconditions;
 import java.util.List;
-import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.NumericColumn;
 import tech.tablesaw.table.TableSlice;
 import tech.tablesaw.table.TableSliceGroup;
@@ -57,7 +56,7 @@ public static double[][] to2dArray(TableSliceGroup views, int columnNumber) {
     for (int viewNumber = 0; viewNumber < viewCount; viewNumber++) {
       TableSlice view = views.get(viewNumber);
       allVals[viewNumber] = new double[view.rowCount()];
-      NumberColumn<?> numberColumn = view.numberColumn(columnNumber);
+      NumericColumn<?> numberColumn = view.numberColumn(columnNumber);
       for (int r = 0; r < view.rowCount(); r++) {
         allVals[viewNumber][r] = numberColumn.getDouble(r);
       }

File: core/src/test/java/tech/tablesaw/api/TableTest.java
Patch:
@@ -664,7 +664,7 @@ private DoubleColumn sum(DoubleColumn... columns) {
     DoubleColumn result = DoubleColumn.create("sum", size);
     for (int r = 0; r < size; r++) {
       double sum = 0;
-      for (NumberColumn<Double> nc : columns) {
+      for (DoubleColumn nc : columns) {
         sum += nc.get(r);
       }
       result.set(r, sum);

File: core/src/test/java/tech/tablesaw/columns/ColumnTest.java
Patch:
@@ -214,8 +214,7 @@ public void noneMatch() {
   }
 
   @SafeVarargs
-  private final <T> void assertContentEquals(
-      Column<T> column, @SuppressWarnings("unchecked") T... ts) {
+  private final <T> void assertContentEquals(Column<T> column, T... ts) {
     assertEquals(ts.length, column.size());
     for (int i = 0; i < ts.length; i++) {
       assertEquals(ts[i], column.get(i));

File: jsplot/src/main/java/tech/tablesaw/plotly/api/Histogram.java
Patch:
@@ -1,14 +1,14 @@
 package tech.tablesaw.plotly.api;
 
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.NumericColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.plotly.components.Figure;
 import tech.tablesaw.plotly.components.Layout;
 import tech.tablesaw.plotly.traces.HistogramTrace;
 
 public class Histogram {
 
-  public static Figure create(String title, NumberColumn<?> data) {
+  public static Figure create(String title, NumericColumn<?> data) {
     return create(title, data.asDoubleArray());
   }
 

File: jsplot/src/main/java/tech/tablesaw/plotly/api/QQPlot.java
Patch:
@@ -3,7 +3,7 @@
 import com.google.common.base.Preconditions;
 import java.util.Arrays;
 import org.apache.commons.math3.stat.StatUtils;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.NumericColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.plotly.components.Axis;
 import tech.tablesaw.plotly.components.Figure;
@@ -24,8 +24,8 @@ public class QQPlot {
    */
   public static Figure create(String title, Table table, String columnName1, String columnName2) {
 
-    NumberColumn<?> xCol = table.nCol(columnName1);
-    NumberColumn<?> yCol = table.nCol(columnName2);
+    NumericColumn<?> xCol = table.nCol(columnName1);
+    NumericColumn<?> yCol = table.nCol(columnName2);
 
     return create(title, xCol.name(), xCol.asDoubleArray(), yCol.name(), yCol.asDoubleArray());
   }

File: jsplot/src/main/java/tech/tablesaw/plotly/api/QuantilePlot.java
Patch:
@@ -1,6 +1,6 @@
 package tech.tablesaw.plotly.api;
 
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.NumericColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.plotly.components.Figure;
 import tech.tablesaw.plotly.components.Layout;
@@ -19,15 +19,15 @@ public class QuantilePlot {
    */
   public static Figure create(String title, Table table, String columnName) {
 
-    NumberColumn<?> xCol = table.nCol(columnName);
+    NumericColumn<?> xCol = table.nCol(columnName);
 
     double[] x = new double[xCol.size()];
 
     for (int i = 0; i < x.length; i++) {
       x[i] = i / (float) x.length;
     }
 
-    NumberColumn<?> copy = xCol.copy();
+    NumericColumn<?> copy = xCol.copy();
     copy.sortAscending();
 
     ScatterTrace trace = ScatterTrace.builder(x, copy.asDoubleArray()).build();

File: jsplot/src/main/java/tech/tablesaw/plotly/api/TukeyMeanDifferencePlot.java
Patch:
@@ -3,7 +3,7 @@
 import com.google.common.base.Preconditions;
 import java.util.Arrays;
 import org.apache.commons.math3.stat.StatUtils;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.NumericColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.plotly.components.Axis;
 import tech.tablesaw.plotly.components.Figure;
@@ -37,8 +37,8 @@ public class TukeyMeanDifferencePlot {
   public static Figure create(
       String title, String measure, Table table, String columnName1, String columnName2) {
 
-    NumberColumn<?> xCol = table.nCol(columnName1);
-    NumberColumn<?> yCol = table.nCol(columnName2);
+    NumericColumn<?> xCol = table.nCol(columnName1);
+    NumericColumn<?> yCol = table.nCol(columnName2);
 
     return create(title, measure, xCol.asDoubleArray(), yCol.asDoubleArray());
   }

File: jsplot/src/main/java/tech/tablesaw/plotly/components/Marker.java
Patch:
@@ -10,7 +10,7 @@
 import java.io.Writer;
 import java.util.HashMap;
 import java.util.Map;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.NumericColumn;
 import tech.tablesaw.plotly.Utils;
 
 public class Marker extends Component {
@@ -186,7 +186,7 @@ public MarkerBuilder size(double... size) {
       return this;
     }
 
-    public MarkerBuilder size(NumberColumn<?> size) {
+    public MarkerBuilder size(NumericColumn<?> size) {
       return size(size.asDoubleArray());
     }
 

File: jsplot/src/test/java/tech/tablesaw/examples/BarExample.java
Patch:
@@ -17,7 +17,7 @@
 import static tech.tablesaw.aggregate.AggregateFunctions.sum;
 
 import tech.tablesaw.api.IntColumn;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.NumericColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.numbers.IntColumnType;
 import tech.tablesaw.plotly.Plot;
@@ -34,7 +34,7 @@ public class BarExample {
 
   public static void main(String[] args) throws Exception {
     Table table = Table.read().csv("../data/tornadoes_1950-2014.csv");
-    NumberColumn<?> logNInjuries = table.numberColumn("injuries").add(1).logN();
+    NumericColumn<?> logNInjuries = table.numberColumn("injuries").add(1).logN();
     logNInjuries.setName("log injuries");
     table.addColumns(logNInjuries);
     IntColumn scale = table.intColumn("scale");

File: jsplot/src/test/java/tech/tablesaw/examples/DotPlotExample.java
Patch:
@@ -3,7 +3,7 @@
 import tech.tablesaw.aggregate.AggregateFunctions;
 import tech.tablesaw.api.CategoricalColumn;
 import tech.tablesaw.api.IntColumn;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.NumericColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.plotly.Plot;
 import tech.tablesaw.plotly.components.Figure;
@@ -18,7 +18,7 @@ public static void main(String[] args) throws Exception {
 
     Table bush = Table.read().csv("../data/bush.csv");
 
-    NumberColumn<?> x = bush.nCol("approval");
+    NumericColumn<?> x = bush.nCol("approval");
     CategoricalColumn<?> y = bush.stringColumn("who");
 
     Layout layout = Layout.builder().title("Approval ratings by agency").build();

File: jsplot/src/test/java/tech/tablesaw/examples/LineOptionsExample.java
Patch:
@@ -1,6 +1,6 @@
 package tech.tablesaw.examples;
 
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.NumericColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.plotly.Plot;
 import tech.tablesaw.plotly.components.Figure;
@@ -10,8 +10,8 @@
 
 public class LineOptionsExample {
 
-  private final NumberColumn<?> x;
-  private final NumberColumn<?> y;
+  private final NumericColumn<?> x;
+  private final NumericColumn<?> y;
 
   private LineOptionsExample() throws Exception {
     Table robberies = Table.read().csv("../data/boston-robberies.csv");

File: jsplot/src/test/java/tech/tablesaw/examples/LinePlotExampleWithSmoothing.java
Patch:
@@ -14,7 +14,7 @@
 
 package tech.tablesaw.examples;
 
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.NumericColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.plotly.Plot;
 import tech.tablesaw.plotly.components.Figure;
@@ -27,8 +27,8 @@ public class LinePlotExampleWithSmoothing {
 
   public static void main(String[] args) throws Exception {
     Table robberies = Table.read().csv("../data/boston-robberies.csv");
-    NumberColumn<?> x = robberies.nCol("Record");
-    NumberColumn<?> y = robberies.nCol("Robberies");
+    NumericColumn<?> x = robberies.nCol("Record");
+    NumericColumn<?> y = robberies.nCol("Robberies");
 
     Layout layout =
         Layout.builder().title("Monthly Boston Armed Robberies Jan. 1966 - Oct. 1975").build();

File: jsplot/src/test/java/tech/tablesaw/examples/MarkerOptionsExample.java
Patch:
@@ -1,7 +1,7 @@
 package tech.tablesaw.examples;
 
 import tech.tablesaw.api.IntColumn;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.NumericColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.plotly.Plot;
 import tech.tablesaw.plotly.components.Axis;
@@ -18,8 +18,8 @@
 public class MarkerOptionsExample {
 
   private final Table baseball;
-  private final NumberColumn<?> x;
-  private final NumberColumn<?> y;
+  private final NumericColumn<?> x;
+  private final NumericColumn<?> y;
 
   private MarkerOptionsExample() throws Exception {
     this.baseball = Table.read().csv("../data/baseball.csv");

File: jsplot/src/test/java/tech/tablesaw/examples/ScatterLegendExample.java
Patch:
@@ -1,6 +1,6 @@
 package tech.tablesaw.examples;
 
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.NumericColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.plotly.Plot;
 import tech.tablesaw.plotly.components.Figure;
@@ -14,8 +14,8 @@ public class ScatterLegendExample {
   public static void main(String[] args) throws Exception {
     Table tornadoes = Table.read().csv("../data/tornadoes_1950-2014.csv");
     tornadoes = tornadoes.where(tornadoes.nCol("Start lat").isGreaterThan(20));
-    NumberColumn<?> x = tornadoes.nCol("Start lon");
-    NumberColumn<?> y = tornadoes.nCol("Start lat");
+    NumericColumn<?> x = tornadoes.nCol("Start lon");
+    NumericColumn<?> y = tornadoes.nCol("Start lat");
 
     // show a legend even though there's only one trace, by setting showLegend explicitly to true
     Layout layout =

File: jsplot/src/test/java/tech/tablesaw/examples/ScatterplotWithSpecificAxisRange.java
Patch:
@@ -14,7 +14,7 @@
 
 package tech.tablesaw.examples;
 
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.NumericColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.plotly.Plot;
 import tech.tablesaw.plotly.components.Axis;
@@ -30,8 +30,8 @@ public class ScatterplotWithSpecificAxisRange {
   public static void main(String[] args) throws Exception {
     Table tornadoes = Table.read().csv("../data/tornadoes_1950-2014.csv");
     tornadoes = tornadoes.where(tornadoes.nCol("Start lat").isGreaterThan(20));
-    NumberColumn<?> x = tornadoes.nCol("Start lon");
-    NumberColumn<?> y = tornadoes.nCol("Start lat");
+    NumericColumn<?> x = tornadoes.nCol("Start lon");
+    NumericColumn<?> y = tornadoes.nCol("Start lat");
     Layout layout =
         Layout.builder()
             .title("tornado start points")

File: saw/src/main/java/tech/tablesaw/io/saw/ColumnMetadata.java
Patch:
@@ -60,7 +60,7 @@ public class ColumnMetadata {
   private String type;
   private String stringColumnKeySize;
 
-  ColumnMetadata(Column column) {
+  ColumnMetadata(Column<?> column) {
     this.id = UUID.randomUUID().toString();
     this.name = column.name();
     this.type = column.type().name();
@@ -81,7 +81,7 @@ public class ColumnMetadata {
     }
   }
 
-  private ColumnMetadata() {}
+  protected ColumnMetadata() {}
 
   public static ColumnMetadata fromJson(String jsonString) {
     try {
@@ -131,7 +131,7 @@ public String getStringColumnKeySize() {
     return stringColumnKeySize;
   }
 
-  public Column createColumn() {
+  public Column<?> createColumn() {
     final String typeString = getType();
     switch (typeString) {
       case FLOAT:

File: saw/src/main/java/tech/tablesaw/io/saw/SawWriter.java
Patch:
@@ -133,7 +133,7 @@ public static String saveTable(String parentFolderName, Relation table) {
 
       List<Column<?>> columns = table.columns();
       for (int i = 0; i < columns.size(); i++) {
-        Column column = columns.get(i);
+        Column<?> column = columns.get(i);
         String pathString = tableMetadata.getColumnMetadataList().get(i).getId();
 
         writerCompletionService.submit(
@@ -162,7 +162,7 @@ private static String makeName(Relation table) {
     return name + '.' + FILE_EXTENSION;
   }
 
-  private static void writeColumn(String fileName, Column column) {
+  private static void writeColumn(String fileName, Column<?> column) {
     try {
       final String typeName = column.type().name();
       switch (typeName) {

File: saw/src/main/java/tech/tablesaw/io/saw/TableMetadata.java
Patch:
@@ -45,15 +45,15 @@ public class TableMetadata {
     this.name = table.name();
     this.rowCount = table.rowCount();
 
-    for (Column column : table.columns()) {
+    for (Column<?> column : table.columns()) {
       ColumnMetadata metadata = new ColumnMetadata(column);
       columnMetadataList.add(metadata);
     }
     this.version = SAW_VERSION;
   }
 
   /** Default constructor for Jackson json serialization */
-  private TableMetadata() {}
+  protected TableMetadata() {}
 
   static TableMetadata fromJson(String jsonString) {
     try {

File: core/src/main/java/tech/tablesaw/columns/strings/LookupTableWrapper.java
Patch:
@@ -73,7 +73,7 @@ public void writeToStream(DataOutputStream dos) {
     }
   }
 
-  public Class dictionaryClass() {
+  public Class<? extends DictionaryMap> dictionaryClass() {
     return dictionaryMap.getClass();
   }
 

File: core/src/main/java/tech/tablesaw/io/csv/CsvWriteOptions.java
Patch:
@@ -34,7 +34,7 @@ public boolean header() {
   }
 
   public boolean ignoreLeadingWhitespaces() {
-    return ignoreTrailingWhitespaces;
+    return ignoreLeadingWhitespaces;
   }
 
   public boolean ignoreTrailingWhitespaces() {

File: core/src/main/java/tech/tablesaw/io/FileReader.java
Patch:
@@ -64,6 +64,8 @@ private String[] getHeaderNames(
       for (int i = 0; i < headerNames.length; i++) {
         if (headerNames[i] == null) {
           headerNames[i] = "C" + i;
+        } else {
+          headerNames[i] = headerNames[i].trim();
         }
       }
       return headerNames;

File: core/src/main/java/tech/tablesaw/api/DateColumn.java
Patch:
@@ -126,7 +126,8 @@ public DateColumn appendInternal(int f) {
     return this;
   }
 
-  @Override
+  /** @deprecated Use intIterator(), or getIntInternal() instead */
+  @Deprecated
   public IntArrayList data() {
     return data;
   }
@@ -508,7 +509,7 @@ public Set<LocalDate> asSet() {
 
   public boolean contains(LocalDate localDate) {
     int date = PackedLocalDate.pack(localDate);
-    return data().contains(date);
+    return data.contains(date);
   }
 
   @Override

File: core/src/main/java/tech/tablesaw/api/DateTimeColumn.java
Patch:
@@ -163,7 +163,7 @@ public DateTimeColumn removeMissing() {
 
   public boolean contains(LocalDateTime dateTime) {
     long dt = PackedLocalDateTime.pack(dateTime);
-    return data().contains(dt);
+    return data.contains(dt);
   }
 
   @Override
@@ -251,6 +251,8 @@ public int size() {
     return data.size();
   }
 
+  /** @deprecated Please use the longIterator() or getLongInternal() methods */
+  @Deprecated
   public LongArrayList data() {
     return data;
   }

File: core/src/main/java/tech/tablesaw/api/InstantColumn.java
Patch:
@@ -165,7 +165,7 @@ public InstantColumn removeMissing() {
 
   public boolean contains(Instant dateTime) {
     long dt = PackedInstant.pack(dateTime);
-    return data().contains(dt);
+    return data.contains(dt);
   }
 
   @Override
@@ -241,6 +241,8 @@ public int size() {
     return data.size();
   }
 
+  /** @deprecated Please use the longIterator() or getLongInternal() methods */
+  @Deprecated
   public LongArrayList data() {
     return data;
   }

File: core/src/main/java/tech/tablesaw/api/TimeColumn.java
Patch:
@@ -390,6 +390,8 @@ public IntComparator rowComparator() {
     return comparator;
   }
 
+  /** @deprecated Use intIterator(), or getIntInternal() instead) */
+  @Deprecated
   public IntArrayList data() {
     return data;
   }
@@ -509,7 +511,7 @@ public IntIterator intIterator() {
 
   public boolean contains(LocalTime time) {
     int t = PackedLocalTime.pack(time);
-    return data().contains(t);
+    return data.contains(t);
   }
 
   @Override

File: saw/src/main/java/tech/tablesaw/io/saw/SawReader.java
Patch:
@@ -57,7 +57,7 @@
 @Beta
 public class SawReader {
 
-  private static final int READER_POOL_SIZE = 4;
+  private static final int READER_POOL_SIZE = 10;
 
   public static Table readTable(String path) {
     Path sawPath = Paths.get(path);

File: core/src/main/java/tech/tablesaw/analytic/WindowSpecification.java
Patch:
@@ -10,7 +10,8 @@
 import java.util.stream.Collectors;
 import tech.tablesaw.sorting.Sort;
 
-public final class WindowSpecification {
+/** This class holds data on the Partition By and Order By clauses of an an analytic query. */
+final class WindowSpecification {
 
   private final String windowName;
   private final LinkedHashSet<String> partitionColumns;
@@ -103,7 +104,6 @@ Builder setWindowName(String windowName) {
     Builder setPartitionColumns(List<String> columns) {
       this.partitioning.clear();
       this.partitioning.addAll(columns);
-      // TODO add actual duplicate columns to the error message.
       Preconditions.checkArgument(
           partitioning.size() == columns.size(),
           "Partition by Columns cannot contain duplicate columns");

File: core/src/test/java/tech/tablesaw/analytic/ArgumentListTest.java
Patch:
@@ -110,7 +110,7 @@ public void duplicateColsThrows() {
   public void buildWithStagedThrows() {
     Throwable thrown =
         assertThrows(
-            IllegalArgumentException.class,
+            IllegalStateException.class,
             () -> ArgumentList.builder().stageFunction("col1", AggregateFunctions.MAX).build());
 
     assertTrue(thrown.getMessage().contains("Cannot build when a column is staged"));

File: core/src/main/java/tech/tablesaw/api/Row.java
Patch:
@@ -43,8 +43,8 @@ void put(String columnName, T column) {
     }
 
     /**
-     * Will get thrown when column name is correct, but used the wrong method get/set is called. E.G. the user called
-     * .getLong on an IntColumn.
+     * Will get thrown when column name is correct, but used the wrong method get/set is called.
+     * E.G. the user called .getLong on an IntColumn.
      */
     private void throwWrongTypeError(String columnName) {
       for (int i = 0; i < columnNames.length; i++) {

File: core/src/main/java/tech/tablesaw/columns/AbstractColumnParser.java
Patch:
@@ -33,7 +33,7 @@ public ColumnType columnType() {
     return columnType;
   }
 
-  protected boolean isMissing(String s) {
+  public boolean isMissing(String s) {
     if (s == null) {
       return true;
     }

File: core/src/main/java/tech/tablesaw/analytic/AggregateFunction.java
Patch:
@@ -3,7 +3,9 @@
 public interface AggregateFunction<T, R> {
 
   void removeLeftMost();
+
   void addRightMost(T value);
+
   void addRightMostMissing();
 
   default void addAllRightMost(Iterable<T> newValues) {
@@ -12,4 +14,3 @@ default void addAllRightMost(Iterable<T> newValues) {
 
   R getValue();
 }
-

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -48,13 +48,15 @@
 import tech.tablesaw.columns.booleans.BooleanFilters;
 import tech.tablesaw.columns.booleans.BooleanFormatter;
 import tech.tablesaw.columns.booleans.BooleanMapUtils;
+import tech.tablesaw.filtering.BooleanFilterSpec;
 import tech.tablesaw.filtering.predicates.BytePredicate;
 import tech.tablesaw.selection.BitmapBackedSelection;
 import tech.tablesaw.selection.Selection;
 
 /** A column in a base table that contains float values */
 public class BooleanColumn extends AbstractColumn<Boolean>
-    implements BooleanMapUtils,
+    implements BooleanFilterSpec<Selection>,
+        BooleanMapUtils,
         CategoricalColumn<Boolean>,
         BooleanFillers<BooleanColumn>,
         BooleanFilters {

File: core/src/main/java/tech/tablesaw/columns/AbstractColumn.java
Patch:
@@ -58,8 +58,8 @@ public String toString() {
   @Override
   public StringColumn asStringColumn() {
     StringColumn sc = StringColumn.create(name() + " strings");
-    for(int i = 0; i < size(); i++) {
-    	sc.append(getUnformattedString(i));
+    for (int i = 0; i < size(); i++) {
+      sc.append(getUnformattedString(i));
     }
     return sc;
   }

File: core/src/main/java/tech/tablesaw/columns/Column.java
Patch:
@@ -618,9 +618,10 @@ default Column<T> sampleX(double proportion) {
   }
 
   /**
-   * Returns a StringColumn consisting of the (unformatted) String representation of this column values
+   * Returns a StringColumn consisting of the (unformatted) String representation of this column
+   * values
+   *
    * @return a {@link StringColumn} built using the column {@link #getUnformattedString} method
    */
   StringColumn asStringColumn();
-
 }

File: core/src/main/java/tech/tablesaw/columns/dates/DateFilters.java
Patch:
@@ -13,11 +13,12 @@
 import java.util.function.Predicate;
 import tech.tablesaw.api.DateColumn;
 import tech.tablesaw.columns.Column;
+import tech.tablesaw.filtering.DateAndDateTimeFilterSpec;
 import tech.tablesaw.filtering.predicates.IntBiPredicate;
 import tech.tablesaw.selection.BitmapBackedSelection;
 import tech.tablesaw.selection.Selection;
 
-public interface DateFilters extends Column<LocalDate> {
+public interface DateFilters extends Column<LocalDate>, DateAndDateTimeFilterSpec<Selection> {
 
   DateColumn where(Selection selection);
 

File: core/src/main/java/tech/tablesaw/columns/numbers/NumberFilters.java
Patch:
@@ -22,10 +22,11 @@
 import java.util.function.BiPredicate;
 import java.util.function.DoublePredicate;
 import tech.tablesaw.api.NumericColumn;
+import tech.tablesaw.filtering.NumberFilterSpec;
 import tech.tablesaw.selection.BitmapBackedSelection;
 import tech.tablesaw.selection.Selection;
 
-public interface NumberFilters {
+public interface NumberFilters extends NumberFilterSpec<Selection> {
 
   Selection eval(DoublePredicate predicate);
 

File: core/src/main/java/tech/tablesaw/columns/strings/StringFilters.java
Patch:
@@ -37,10 +37,11 @@
 import java.util.function.BiPredicate;
 import java.util.function.Predicate;
 import tech.tablesaw.columns.Column;
+import tech.tablesaw.filtering.StringFilterSpec;
 import tech.tablesaw.selection.BitmapBackedSelection;
 import tech.tablesaw.selection.Selection;
 
-public interface StringFilters extends Column<String> {
+public interface StringFilters extends Column<String>, StringFilterSpec<Selection> {
 
   default Selection eval(BiPredicate<String, String> predicate, Column<String> otherColumn) {
     Selection selection = new BitmapBackedSelection();

File: core/src/main/java/tech/tablesaw/filtering/And.java
Patch:
@@ -1,10 +1,12 @@
 package tech.tablesaw.filtering;
 
+import com.google.common.annotations.Beta;
 import com.google.common.base.Preconditions;
 import java.util.function.Function;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.selection.Selection;
 
+@Beta
 public class And implements Function<Table, Selection> {
 
   private Function<Table, Selection>[] arguments;

File: core/src/main/java/tech/tablesaw/filtering/DeferredColumn.java
Patch:
@@ -1,5 +1,8 @@
 package tech.tablesaw.filtering;
 
+import com.google.common.annotations.Beta;
+
+@Beta
 public class DeferredColumn {
 
   private final String columnName;

File: core/src/main/java/tech/tablesaw/filtering/Not.java
Patch:
@@ -1,9 +1,11 @@
 package tech.tablesaw.filtering;
 
+import com.google.common.annotations.Beta;
 import java.util.function.Function;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.selection.Selection;
 
+@Beta
 public class Not implements Function<Table, Selection> {
 
   private Function<Table, Selection> argument;

File: core/src/main/java/tech/tablesaw/filtering/Or.java
Patch:
@@ -1,10 +1,12 @@
 package tech.tablesaw.filtering;
 
+import com.google.common.annotations.Beta;
 import com.google.common.base.Preconditions;
 import java.util.function.Function;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.selection.Selection;
 
+@Beta
 public class Or implements Function<Table, Selection> {
 
   private Function<Table, Selection>[] arguments;

File: core/src/test/java/tech/tablesaw/analytic/AnalyticAggregateFunctionsTest.java
Patch:
@@ -50,5 +50,4 @@ public void testMaxSliding() {
     function.addRightMost(3);
     assertEquals(10, function.getValue());
   }
-
-}
\ No newline at end of file
+}

File: core/src/test/java/tech/tablesaw/api/NumberColumnTest.java
Patch:
@@ -551,9 +551,6 @@ public void testCountUniqueShort() {
     assertEquals(3, shorts.unique().size());
   }
 
-
-
-
   @Test
   public void testUnique() {
     DoubleColumn doubles = DoubleColumn.create("doubles");

File: core/src/test/java/tech/tablesaw/api/TextColumnTest.java
Patch:
@@ -496,5 +496,4 @@ public void testCountUnique() {
     assertEquals(3, col1.countUnique());
     assertEquals(3, col1.unique().size());
   }
-
 }

File: core/src/test/java/tech/tablesaw/table/TableSliceGroupTest.java
Patch:
@@ -47,7 +47,8 @@ public Double summarize(NumericColumn<?> data) {
   @BeforeEach
   public void setUp() throws Exception {
     // The source data is sorted by who. Put it in a different order.
-    table = Table.read().csv(CsvReadOptions.builder("../data/bush.csv")).sortAscendingOn("approval");
+    table =
+        Table.read().csv(CsvReadOptions.builder("../data/bush.csv")).sortAscendingOn("approval");
   }
 
   @Test

File: json/src/main/java/tech/tablesaw/io/json/JsonReader.java
Patch:
@@ -101,7 +101,7 @@ private Table convertArrayOfObjects(JsonNode jsonObj, ReadOptions options) throw
     for (JsonNode node : flattenedJsonObj) {
       String[] arr = new String[columnNames.size()];
       for (int i = 0; i < columnNames.size(); i++) {
-        if(node.has(columnNames.get(i))) {
+        if (node.has(columnNames.get(i))) {
           arr[i] = node.get(columnNames.get(i)).asText();
         } else {
           arr[i] = null;

File: core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeColumnFormatter.java
Patch:
@@ -5,7 +5,6 @@
 import java.time.LocalDateTime;
 import java.time.format.DateTimeFormatter;
 import javax.annotation.concurrent.Immutable;
-import tech.tablesaw.columns.times.TimeColumnType;
 
 @Immutable
 public class DateTimeColumnFormatter {
@@ -27,7 +26,7 @@ public DateTimeColumnFormatter(DateTimeFormatter format, String missingValueStri
   }
 
   public String format(long value) {
-    if (value == TimeColumnType.missingValueIndicator()) {
+    if (value == DateTimeColumnType.missingValueIndicator()) {
       return missingValueString;
     }
     if (format == null) {

File: core/src/main/java/tech/tablesaw/table/TableSlice.java
Patch:
@@ -76,7 +76,7 @@ public int rowCount() {
   public List<Column<?>> columns() {
     List<Column<?>> columns = new ArrayList<>();
     for (int i = 0; i < columnCount(); i++) {
-      columns.add(entireColumn(i));
+      columns.add(column(i));
     }
     return columns;
   }
@@ -140,8 +140,8 @@ public TableSlice setName(String name) {
 
   public Table asTable() {
     Table table = Table.create(this.name());
-    for (Column<?> column : columns()) {
-      table.addColumns(column.where(selection));
+    for (Column<?> column : this.columns()) {
+      table.addColumns(column);
     }
     return table;
   }

File: core/src/test/java/tech/tablesaw/table/TableSliceTest.java
Patch:
@@ -53,7 +53,7 @@ public void rowCount() {
   @Test
   public void columns() {
     TableSlice slice = new TableSlice(source, Selection.withRange(0, source.rowCount()));
-    assertEquals(source.columns(), slice.columns());
+    assertEquals(source.columns().get(0).size(), slice.columns().get(0).size());
   }
 
   @Test

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -45,6 +45,7 @@
 import tech.tablesaw.columns.booleans.BooleanColumnType;
 import tech.tablesaw.columns.booleans.BooleanColumnUtils;
 import tech.tablesaw.columns.booleans.BooleanFillers;
+import tech.tablesaw.columns.booleans.BooleanFilters;
 import tech.tablesaw.columns.booleans.BooleanFormatter;
 import tech.tablesaw.columns.booleans.BooleanMapUtils;
 import tech.tablesaw.filtering.predicates.BytePredicate;
@@ -53,7 +54,7 @@
 
 /** A column in a base table that contains float values */
 public class BooleanColumn extends AbstractColumn<Boolean>
-    implements BooleanMapUtils, CategoricalColumn<Boolean>, BooleanFillers<BooleanColumn> {
+    implements BooleanMapUtils, CategoricalColumn<Boolean>, BooleanFillers<BooleanColumn>, BooleanFilters {
 
   private final ByteComparator descendingByteComparator = (o1, o2) -> Byte.compare(o2, o1);
 

File: core/src/main/java/tech/tablesaw/columns/booleans/BooleanFilters.java
Patch:
@@ -5,9 +5,9 @@
 
 public interface BooleanFilters {
 
-    public Selection isFalse();
+    Selection isFalse();
 
-    public Selection isTrue();
+    Selection isTrue();
 
     Selection isEqualTo(BooleanColumn other);
 

File: core/src/main/java/tech/tablesaw/filtering/DeferredBooleanColumn.java
Patch:
@@ -1,4 +1,4 @@
-package tech.tablesaw.filtering.deferred;
+package tech.tablesaw.filtering;
 
 import tech.tablesaw.api.BooleanColumn;
 import tech.tablesaw.api.Table;

File: core/src/main/java/tech/tablesaw/filtering/DeferredColumn.java
Patch:
@@ -1,4 +1,4 @@
-package tech.tablesaw.filtering.deferred;
+package tech.tablesaw.filtering;
 
 public class DeferredColumn {
 

File: core/src/main/java/tech/tablesaw/filtering/DeferredDateColumn.java
Patch:
@@ -1,4 +1,4 @@
-package tech.tablesaw.filtering.deferred;
+package tech.tablesaw.filtering;
 
 import tech.tablesaw.api.DateColumn;
 import tech.tablesaw.api.Table;

File: core/src/main/java/tech/tablesaw/filtering/DeferredDateTimeColumn.java
Patch:
@@ -1,4 +1,4 @@
-package tech.tablesaw.filtering.deferred;
+package tech.tablesaw.filtering;
 
 import tech.tablesaw.api.DateTimeColumn;
 import tech.tablesaw.api.Table;

File: core/src/main/java/tech/tablesaw/filtering/DeferredInstantColumn.java
Patch:
@@ -1,4 +1,4 @@
-package tech.tablesaw.filtering.deferred;
+package tech.tablesaw.filtering;
 
 public class DeferredInstantColumn extends DeferredColumn {
 

File: core/src/main/java/tech/tablesaw/filtering/DeferredNumberColumn.java
Patch:
@@ -1,4 +1,4 @@
-package tech.tablesaw.filtering.deferred;
+package tech.tablesaw.filtering;
 
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.NumericColumn;

File: core/src/main/java/tech/tablesaw/filtering/DeferredStringColumn.java
Patch:
@@ -1,4 +1,4 @@
-package tech.tablesaw.filtering.deferred;
+package tech.tablesaw.filtering;
 
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.Column;

File: core/src/main/java/tech/tablesaw/filtering/DeferredTextColumn.java
Patch:
@@ -1,4 +1,4 @@
-package tech.tablesaw.filtering.deferred;
+package tech.tablesaw.filtering;
 
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.Column;

File: core/src/main/java/tech/tablesaw/filtering/DeferredTimeColumn.java
Patch:
@@ -1,4 +1,4 @@
-package tech.tablesaw.filtering.deferred;
+package tech.tablesaw.filtering;
 
 import tech.tablesaw.api.Table;
 import tech.tablesaw.api.TimeColumn;

File: core/src/main/java/tech/tablesaw/filtering/Not.java
Patch:
@@ -1,4 +1,4 @@
-package tech.tablesaw.filtering.deferred;
+package tech.tablesaw.filtering;
 
 import tech.tablesaw.api.Table;
 import tech.tablesaw.selection.Selection;

File: core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeParser.java
Patch:
@@ -18,7 +18,7 @@ public class DateTimeParser extends AbstractColumnParser<LocalDateTime> {
   private static final DateTimeFormatter dtTimef2 =
       DateTimeFormatter.ofPattern(
           "yyyy-MM-dd HH:mm:ss.S"); // 2014-07-09 13:03:44.7 (as above, but without leading 0 in
-                                    // millis)
+  // millis)
   private static final DateTimeFormatter dtTimef4 =
       DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm"); // 09-Jul-2014 13:03
   private static final DateTimeFormatter dtTimef5 = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

File: core/src/test/java/tech/tablesaw/filters/TimeDependentFilteringTest.java
Patch:
@@ -126,7 +126,7 @@ public static void main(String[] args) throws Exception {
           // this is an error
           fail("There are no event dates");
         } else { // Get the first event for the current patient and createFromCsv a date range
-                 // around it
+          // around it
           LocalDate date = eventDates.get(0);
           result.addRange(
               Range.closed(

File: core/src/test/java/tech/tablesaw/filtering/deferred/DeferredColumnTest.java
Patch:
@@ -13,7 +13,7 @@ class DeferredColumnTest {
 
   @Test
   void testExecution() throws Exception {
-      Table table = Table.read().csv("../data/Bush.csv");
+      Table table = Table.read().csv("../data/bush.csv");
       BooleanColumn b = BooleanColumn.create("test", new BitmapBackedSelection().addRange(0, table.rowCount()), table.rowCount()).setName("b");
       assertTrue(b.get(0));
       table.addColumns(b);

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -34,6 +34,7 @@
 import tech.tablesaw.columns.booleans.BooleanColumnType;
 import tech.tablesaw.columns.booleans.BooleanColumnUtils;
 import tech.tablesaw.columns.booleans.BooleanFillers;
+import tech.tablesaw.columns.booleans.BooleanFilters;
 import tech.tablesaw.columns.booleans.BooleanFormatter;
 import tech.tablesaw.columns.booleans.BooleanMapUtils;
 import tech.tablesaw.filtering.predicates.BytePredicate;
@@ -54,7 +55,7 @@
 
 /** A column in a base table that contains float values */
 public class BooleanColumn extends AbstractColumn<Boolean>
-    implements BooleanMapUtils, CategoricalColumn<Boolean>, BooleanFillers<BooleanColumn> {
+    implements BooleanMapUtils, CategoricalColumn<Boolean>, BooleanFillers<BooleanColumn>, BooleanFilters {
 
   private final ByteComparator descendingByteComparator = (o1, o2) -> Byte.compare(o2, o1);
 

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -289,7 +289,7 @@ public BooleanColumn append(boolean b) {
   @Override
   public BooleanColumn append(Boolean b) {
     if (b == null) {
-      data.add(BooleanColumnType.MISSING_VALUE);
+      appendMissing();
     } else if (b) {
       data.add(BooleanColumnType.BYTE_TRUE);
     } else {

File: jsplot/src/main/java/tech/tablesaw/plotly/api/AreaPlot.java
Patch:
@@ -31,7 +31,8 @@ public static Figure create(
   }
 
   public static Figure create(String title, Table table, String xCol, String yCol) {
-    Layout layout = Layout.builder(title, xCol, yCol).showLegend(true).build();
+    Layout layout = Layout.builder(title, xCol, yCol)
+            .build();
     ScatterTrace trace =
         ScatterTrace.builder(table.numberColumn(xCol), table.numberColumn(yCol))
             .mode(ScatterTrace.Mode.LINE)

File: jsplot/src/main/java/tech/tablesaw/plotly/traces/ScatterTrace.java
Patch:
@@ -68,7 +68,6 @@ public String toString() {
   private final String[] text;
   private final Mode mode;
   private final HoverLabel hoverLabel;
-  private final boolean showLegend;
   private final Marker marker;
   private final Line line;
   private final YAxis yAxis;
@@ -106,7 +105,6 @@ private ScatterTrace(ScatterBuilder builder) {
     this.text = builder.text;
     this.marker = builder.marker;
     this.hoverLabel = builder.hoverLabel;
-    this.showLegend = builder.showLegend;
     this.line = builder.line;
     this.fill = builder.fill;
     this.fillColor = builder.fillColor;
@@ -157,9 +155,9 @@ private Map<String, Object> getContext(int i) {
     if (yAxis != null) {
       context.put("yAxis", yAxis);
     }
+
     context.put("marker", marker);
 
-    context.put("showlegend", showLegend);
     if (!fill.equals(DEFAULT_FILL)) {
       context.put("fill", fill);
     }

File: jsplot/src/main/java/tech/tablesaw/plotly/traces/TraceBuilder.java
Patch:
@@ -9,7 +9,7 @@ public abstract class TraceBuilder {
   protected AbstractTrace.Visibility visible = AbstractTrace.DEFAULT_VISIBILITY;
 
   /** Determines whether or not an item corresponding to this trace is shown in the legend. */
-  protected boolean showLegend = AbstractTrace.DEFAULT_SHOW_LEGEND;
+  protected Boolean showLegend = null;
 
   /**
    * Sets the legend group for this trace. Traces part of the same legend group hide/show at the

File: core/src/main/java/tech/tablesaw/api/FloatColumn.java
Patch:
@@ -14,6 +14,7 @@
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.columns.numbers.FloatColumnType;
+import tech.tablesaw.columns.numbers.NumberColumnFormatter;
 import tech.tablesaw.selection.Selection;
 
 import java.nio.ByteBuffer;
@@ -34,6 +35,7 @@ public class FloatColumn extends NumberColumn<Float> {
 
     private FloatColumn(final String name, FloatArrayList data) {
         super(FloatColumnType.instance(), name);
+        setPrintFormatter(NumberColumnFormatter.floatingPointDefault());
         this.data = data;
     }
 
@@ -43,7 +45,7 @@ public String getString(final int row) {
         if (FloatColumnType.isMissingValue(value)) {
             return "";
         }
-        return String.valueOf(printFormatter.format(value));
+        return String.valueOf(getPrintFormatter().format(value));
     }
 
 

File: core/src/main/java/tech/tablesaw/api/IntColumn.java
Patch:
@@ -36,7 +36,7 @@ public class IntColumn extends NumberColumn<Integer> implements CategoricalColum
 
     protected IntColumn(final String name, IntArrayList data) {
         super(IntColumnType.instance(), name);
-        this.printFormatter = NumberColumnFormatter.ints();
+        setPrintFormatter(NumberColumnFormatter.ints());
         this.data = data;
     }
 
@@ -272,7 +272,7 @@ public String getString(final int row) {
         if (IntColumnType.isMissingValue(value)) {
             return "";
         }
-        return String.valueOf(printFormatter.format(value));
+        return String.valueOf(getPrintFormatter().format(value));
     }
 
     @Override

File: core/src/main/java/tech/tablesaw/api/LongColumn.java
Patch:
@@ -38,7 +38,7 @@ public class LongColumn extends NumberColumn<Long> implements CategoricalColumn<
 
     private LongColumn(final String name, LongArrayList data) {
         super(LongColumnType.instance(), name);
-        this.printFormatter = NumberColumnFormatter.ints();
+        setPrintFormatter(NumberColumnFormatter.ints());
         this.data = data;
     }
 
@@ -87,7 +87,7 @@ public String getString(final int row) {
         if (LongColumnType.isMissingValue(value)) {
             return "";
         }
-        return String.valueOf(printFormatter.format(value));
+        return String.valueOf(getPrintFormatter().format(value));
     }
 
     public static boolean valueIsMissing(long value) {

File: core/src/main/java/tech/tablesaw/api/ShortColumn.java
Patch:
@@ -35,7 +35,7 @@ public class ShortColumn extends NumberColumn<Short> implements CategoricalColum
 
     protected ShortColumn(final String name, ShortArrayList data) {
         super(ShortColumnType.instance(), name);
-        this.printFormatter = NumberColumnFormatter.ints();
+        setPrintFormatter(NumberColumnFormatter.ints());
         this.data = data;
     }
 
@@ -241,7 +241,7 @@ public String getString(final int row) {
         if (ShortColumnType.isMissingValue(value)) {
             return "";
         }
-        return String.valueOf(printFormatter.format(value));
+        return String.valueOf(getPrintFormatter().format(value));
     }
 
     @Override

File: core/src/test/java/tech/tablesaw/api/TableTest.java
Patch:
@@ -66,7 +66,7 @@ void testSummarize() throws Exception {
         Table result = table.summarize("Injuries", mean, stdDev).by("State");
         assertEquals(49, result.rowCount());
         assertEquals(3, result.columnCount());
-        assertEquals("4.580805569368455", result.column(1).getString(0));
+        assertEquals("4.580805569368455", result.doubleColumn(1).getString(0));
     }
 
     @Test

File: jsplot/src/main/java/tech/tablesaw/plotly/components/Layout.java
Patch:
@@ -261,7 +261,7 @@ protected Map<String, Object> getContext() {
         if (!decimalSeparator.equals(DEFAULT_DECIMAL_SEPARATOR)) context.put("decimalSeparator", decimalSeparator);
         if (!thousandsSeparator.equals(DEFAULT_THOUSANDS_SEPARATOR)) context.put("thousandsSeparator", thousandsSeparator);
         if(!dragMode.equals(DEFAULT_DRAG_MODE)) context.put("dragmode", dragMode);
-        if (!showLegend == DEFAULT_SHOW_LEGEND) context.put("showlegend", showLegend);
+        context.put("showlegend", showLegend);
         if (!plotBgColor.equals(DEFAULT_PLOT_BG_COLOR)) context.put("plotbgcolor", plotBgColor);
         if (!paperBgColor.equals(DEFAULT_PAPER_BG_COLOR))context.put("paperbgcolor", paperBgColor);
         if (!barMode.equals(DEFAULT_BAR_MODE)) context.put("barMode", barMode);

File: jsplot/src/main/java/tech/tablesaw/plotly/traces/TraceBuilder.java
Patch:
@@ -18,7 +18,7 @@ public abstract class TraceBuilder {
      * Sets the legend group for this trace. Traces part of the same legend
      * group hide/show at the same time when toggling legend items.
      */
-    protected String legendGroup = " ";
+    protected String legendGroup = "";
 
     /**
      * Sets the opacity of the trace.

File: jsplot/src/test/java/tech/tablesaw/examples/ScatterplotExample2.java
Patch:
@@ -37,9 +37,11 @@ public static void main(String[] args) throws Exception {
                 .title("tornado start points")
                 .height(600)
                 .width(800)
+                .showLegend(false)
                 .build();
         Trace trace = ScatterTrace.builder(x, y)
                 .marker(Marker.builder().size(1).build())
+                .name("lat/lon")
                 .build();
         Plot.show(new Figure(layout, trace));
 

File: jsplot/src/main/java/tech/tablesaw/plotly/components/Layout.java
Patch:
@@ -21,7 +21,7 @@ public class Layout {
     private final static String DEFAULT_DECIMAL_SEPARATOR = ".";
     private final static String DEFAULT_THOUSANDS_SEPARATOR = ",";
     private final static boolean DEFAULT_AUTO_SIZE = false;
-    private final static boolean DEFAULT_SHOW_LEGEND = false;
+    private final static boolean DEFAULT_SHOW_LEGEND = true;
     private final static HoverMode DEFAULT_HOVER_MODE = HoverMode.FALSE;
     private final static DragMode DEFAULT_DRAG_MODE = DragMode.ZOOM;
     private final static int DEFAULT_HOVER_DISTANCE = 20;
@@ -261,7 +261,7 @@ protected Map<String, Object> getContext() {
         if (!decimalSeparator.equals(DEFAULT_DECIMAL_SEPARATOR)) context.put("decimalSeparator", decimalSeparator);
         if (!thousandsSeparator.equals(DEFAULT_THOUSANDS_SEPARATOR)) context.put("thousandsSeparator", thousandsSeparator);
         if(!dragMode.equals(DEFAULT_DRAG_MODE)) context.put("dragmode", dragMode);
-        context.put("showlegend", showLegend);
+        if (!showLegend == DEFAULT_SHOW_LEGEND) context.put("showlegend", showLegend);
         if (!plotBgColor.equals(DEFAULT_PLOT_BG_COLOR)) context.put("plotbgcolor", plotBgColor);
         if (!paperBgColor.equals(DEFAULT_PAPER_BG_COLOR))context.put("paperbgcolor", paperBgColor);
         if (!barMode.equals(DEFAULT_BAR_MODE)) context.put("barMode", barMode);

File: core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeFilters.java
Patch:
@@ -24,7 +24,7 @@ default Selection isAfter(LocalDateTime value) {
     }
 
     default Selection isAfter(LocalDate value) {
-        return isAfter(value.atStartOfDay());
+        return isOnOrAfter(value.plusDays(1));
     }
 
     default Selection isOnOrAfter(LocalDate value) {

File: jsplot/src/main/java/tech/tablesaw/plotly/components/Layout.java
Patch:
@@ -261,7 +261,7 @@ protected Map<String, Object> getContext() {
         if (!decimalSeparator.equals(DEFAULT_DECIMAL_SEPARATOR)) context.put("decimalSeparator", decimalSeparator);
         if (!thousandsSeparator.equals(DEFAULT_THOUSANDS_SEPARATOR)) context.put("thousandsSeparator", thousandsSeparator);
         if(!dragMode.equals(DEFAULT_DRAG_MODE)) context.put("dragmode", dragMode);
-        if (!showLegend == DEFAULT_SHOW_LEGEND) context.put("showlegend", showLegend);
+        context.put("showlegend", showLegend);
         if (!plotBgColor.equals(DEFAULT_PLOT_BG_COLOR)) context.put("plotbgcolor", plotBgColor);
         if (!paperBgColor.equals(DEFAULT_PAPER_BG_COLOR))context.put("paperbgcolor", paperBgColor);
         if (!barMode.equals(DEFAULT_BAR_MODE)) context.put("barMode", barMode);

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -918,7 +918,7 @@ public Table append(Table tableToAppend) {
      *
      * Intended usage:
      *
-     *    for (int i = 0; i < 10; i++) {
+     *    for (int i = 0; ...) {
      *        Row row = table.appendRow();
      *        row.setString("name", "Bob");
      *        row.setFloat("IQ", 123.4f);

File: core/src/main/java/tech/tablesaw/table/TableSliceGroup.java
Patch:
@@ -153,16 +153,16 @@ public Table aggregate(ListMultimap<String, AggregateFunction<?,?>> functions) {
         Table groupTable = summaryTableName(sourceTable);
         StringColumn groupColumn = StringColumn.create("Group");
         groupTable.addColumns(groupColumn);
+        boolean firstFunction = true;
         for (Map.Entry<String, Collection<AggregateFunction<?,?>>> entry : functions.asMap().entrySet()) {
             String columnName = entry.getKey();
-            int functionCount = 0;
             for (AggregateFunction function : entry.getValue()) {
                 String colName = aggregateColumnName(columnName, function.functionName());
                 ColumnType type = function.returnType();
                 Column resultColumn = type.create(colName);
                 for (TableSlice subTable : getSlices()) {
                     Object result = function.summarize(subTable.column(columnName));
-                    if (functionCount == 0) {
+                    if (firstFunction) {
                         groupColumn.append(subTable.name());
                     }
                     if (result instanceof Number) {
@@ -173,7 +173,7 @@ public Table aggregate(ListMultimap<String, AggregateFunction<?,?>> functions) {
                     }
                 }
                 groupTable.addColumns(resultColumn);
-                functionCount++;
+                firstFunction = false;
             }
         }
         return splitGroupingColumn(groupTable);

File: core/src/test/java/tech/tablesaw/api/TableTest.java
Patch:
@@ -214,8 +214,8 @@ public void testSampleSplit() throws Exception {
         Table[] results = t.sampleSplit(.75);
         assertEquals(t.rowCount(), results[0].rowCount() + results[1].rowCount());
     }
-
-    @Test
+    
+   @Test
     public void testStratifiedSampleSplit() throws Exception {
         Table t = Table.read().csv("../data/bush.csv");
         Table[] results = t.stratifiedSampleSplit(t.stringColumn("who"), .75);

File: jsplot/src/main/java/tech/tablesaw/plotly/traces/Scatter3DTrace.java
Patch:
@@ -54,7 +54,9 @@ private Map<String, Object> getContext(int i) {
         context.put("x", dataAsString(x));
         context.put("z", dataAsString(z));
         context.put("showlegend", showLegend);
-        if (marker != null) context.put("marker", marker);
+        if (marker != null) {
+            context.put("marker", marker);
+        }
         if (hoverLabel != null) {
             context.put("hoverlabel", hoverLabel.asJavascript());
         }

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -126,7 +126,7 @@ private static void autoRegisterReadersAndWriters() {
                 try {
                     Class.forName(clazz);
                 } catch (ClassNotFoundException e) {
-                    new IllegalStateException(e);
+                    throw new IllegalStateException(e);
                 }
             }
         }

File: core/src/main/java/tech/tablesaw/io/DataFrameWriter.java
Patch:
@@ -67,7 +67,7 @@ public String toString(String extension) {
         try {
             dataWriter.write(table, new Destination(writer));
         } catch (IOException e) {
-            new IllegalStateException(e);
+            throw new IllegalStateException(e);
         }
         return writer.toString();
     }

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -464,7 +464,7 @@ public Table[] sampleSplit(double table1Proportion) {
      * @return An array two tables, with the first table having the proportion specified in the method parameter,
      * and the second table having the balance of the rows
      */
-    public Table[] stratifiedSampleSplit(CategoricalColumn column, double table1Proportion) {
+    public Table[] stratifiedSampleSplit(CategoricalColumn<?> column, double table1Proportion) {
         Preconditions.checkArgument(containsColumn(column),
                 "The categorical column must be part of the table, you can create a string column and add it to this table before sampling.");
         final Table first = emptyCopy();

File: core/src/main/java/tech/tablesaw/conversion/smile/SmileConverter.java
Patch:
@@ -110,8 +110,9 @@ private Attribute colAsAttribute(Column<?> col) {
     }
 
     private NominalAttribute colAsNominalAttribute(Column<?> col) {
+        Column<?> unique = col.unique();
         return new NominalAttribute(col.name(),
-            col.unique().mapInto(o -> o.toString(), StringColumn.create(col.name(), col.size())).asObjectArray());
+            unique.mapInto(o -> o.toString(), StringColumn.create(col.name(), unique.size())).asObjectArray());
     }
 
     private static enum AttributeType {

File: core/src/test/java/tech/tablesaw/columns/instant/InstantParserTest.java
Patch:
@@ -17,13 +17,13 @@ public class InstantParserTest {
 
   @Test
   public void string() {
-    Instant instant = Instant.now();
+    Instant instant = Instant.parse("2019-05-31T03:45:04.021Z");
     assertEquals(instant, parser.parse(instant.toString()));
   }
 
   @Test
   public void unformattedString() {
-    Instant instant = Instant.now();
+    Instant instant = Instant.parse("2019-05-31T03:45:04.021Z");
     InstantColumn col = InstantColumn.create("instantCol", new Instant[] { instant });
     assertEquals(instant, parser.parse(col.getUnformattedString(0)));
   }

File: core/src/main/java/tech/tablesaw/columns/instant/InstantColumnType.java
Patch:
@@ -1,7 +1,7 @@
 package tech.tablesaw.columns.instant;
 
 import tech.tablesaw.api.ColumnType;
-import tech.tablesaw.api.DateTimeColumn;
+import tech.tablesaw.api.InstantColumn;
 import tech.tablesaw.columns.AbstractColumnType;
 import tech.tablesaw.io.ReadOptions;
 
@@ -26,8 +26,8 @@ public static InstantColumnType instance() {
     }
 
     @Override
-    public DateTimeColumn create(String name) {
-        return DateTimeColumn.create(name);
+    public InstantColumn create(String name) {
+        return InstantColumn.create(name);
     }
 
     @Override

File: core/src/test/java/tech/tablesaw/table/SliceBugTests.java
Patch:
@@ -69,7 +69,7 @@ public void sliceAsTableUsingDatesAfterFilteringDBLoadedTable() throws SQLExcept
         Table salesTable = loadTableFromDB();
 
         Table filteredTable = salesTable.select(salesTable.columnNames().toArray(new String[0]))
-                .where(salesTable.dateTimeColumn("sale_timestamp")
+                .where(salesTable.instantColumn("sale_timestamp").asLocalDateTimeColumn()
                         .isAfter(LocalDateTime.of(2018, 1, 1, 13, 1, 3)
                         ));
         filteredTable.setName("filteredTable");

File: core/src/main/java/tech/tablesaw/io/TableBuildingUtils.java
Patch:
@@ -15,7 +15,7 @@ public static Table build(List<String> columnNames, List<String[]> dataRows, Rea
             return table;
         }
 
-        ColumnTypeDetector detector = new ColumnTypeDetector();
+        ColumnTypeDetector detector = new ColumnTypeDetector(options.columnTypesToDetect());
         Iterator<String[]> iterator = dataRows.iterator();
         ColumnType[] types = detector.detectColumnTypes(iterator, options);
         for (int i = 0; i < columnNames.size(); i++) {

File: core/src/main/java/tech/tablesaw/io/csv/CsvReadOptions.java
Patch:
@@ -268,8 +268,8 @@ public Builder missingValueIndicator(String missingValueIndicator) {
         }
 
         @Override
-        public Builder minimizeColumnSizes(boolean minimizeColumnSizes) {
-            super.minimizeColumnSizes(minimizeColumnSizes);
+        public Builder minimizeColumnSizes() {
+            super.minimizeColumnSizes();
             return this;
         }
     }

File: core/src/main/java/tech/tablesaw/io/fixed/FixedWidthReadOptions.java
Patch:
@@ -290,8 +290,8 @@ public Builder missingValueIndicator(String missingValueIndicator) {
         }
 
         @Override
-        public Builder minimizeColumnSizes(boolean minimizeColumnSizes) {
-            super.minimizeColumnSizes(minimizeColumnSizes);
+        public Builder minimizeColumnSizes() {
+            super.minimizeColumnSizes();
             return this;
         }
     }

File: core/src/test/java/tech/tablesaw/TableFilteringTest.java
Patch:
@@ -41,7 +41,7 @@ public class TableFilteringTest {
 
     @BeforeEach
     public void setUp() throws Exception {
-        table = Table.read().csv(CsvReadOptions.builder("../data/bush.csv").minimizeColumnSizes(true));
+        table = Table.read().csv(CsvReadOptions.builder("../data/bush.csv").minimizeColumnSizes());
     }
 
     @Test

File: core/src/test/java/tech/tablesaw/io/csv/CsvReaderTest.java
Patch:
@@ -164,7 +164,7 @@ public void testDataTypeDetection() throws IOException {
         Reader reader = new FileReader("../data/bus_stop_test.csv");
         CsvReadOptions options = CsvReadOptions.builder(reader)
                 .header(true)
-                .minimizeColumnSizes(true)
+                .minimizeColumnSizes()
                 .separator(',')
                 .sample(false)
                 .locale(Locale.getDefault())
@@ -590,7 +590,7 @@ public void testBoundary2() throws IOException {
     public void testReadFailure() throws IOException {
         // TODO (lwhite): These tests don't fail. What was their intent?
         Table table1 = Table.read().csv(CsvReadOptions.builder("../data/read_failure_test.csv")
-                .minimizeColumnSizes(true));
+                .minimizeColumnSizes());
         table1.structure(); // just make sure the import completed
         ShortColumn test = table1.shortColumn("Test");
         //TODO(lwhite): Better tests
@@ -601,7 +601,7 @@ public void testReadFailure() throws IOException {
     public void testReadFailure2() throws IOException {
         Table table1 = Table.read().csv(
                 CsvReadOptions.builder("../data/read_failure_test2.csv")
-                .minimizeColumnSizes(true));
+                .minimizeColumnSizes());
         table1.structure(); // just make sure the import completed
         ShortColumn test = table1.shortColumn("Test");
 

File: core/src/test/java/tech/tablesaw/io/fixed/FixedWidthReaderTest.java
Patch:
@@ -113,7 +113,7 @@ public void testDataTypeDetection() throws Exception {
                 .lineEnding("\n")
                 .sample(false)
                 .locale(Locale.getDefault())
-                .minimizeColumnSizes(true)
+                .minimizeColumnSizes()
                 .build();
 
         Reader reader = new FileReader("../data/fixed_width_missing_values.txt");
@@ -131,7 +131,7 @@ public void testWithMissingValue() throws Exception {
                 .padding('_')
                 .lineEnding("\n")
                 .missingValueIndicator("null")
-                .minimizeColumnSizes(true)
+                .minimizeColumnSizes()
                 .sample(false)
                 .build();
 

File: excel/src/main/java/tech/tablesaw/io/xlsx/XlsxReadOptions.java
Patch:
@@ -140,8 +140,8 @@ public Builder missingValueIndicator(String missingValueIndicator) {
         }
 
         @Override
-        public Builder minimizeColumnSizes(boolean minimizeColumnSizes) {
-            super.minimizeColumnSizes(minimizeColumnSizes);
+        public Builder minimizeColumnSizes() {
+            super.minimizeColumnSizes();
             return this;
         }
     }

File: html/src/main/java/tech/tablesaw/io/html/HtmlReadOptions.java
Patch:
@@ -170,8 +170,8 @@ public Builder missingValueIndicator(String missingValueIndicator) {
         }
 
         @Override
-        public Builder minimizeColumnSizes(boolean minimizeColumnSizes) {
-            super.minimizeColumnSizes(minimizeColumnSizes);
+        public Builder minimizeColumnSizes() {
+            super.minimizeColumnSizes();
             return this;
         }    
     }

File: json/src/main/java/tech/tablesaw/io/json/JsonReadOptions.java
Patch:
@@ -169,8 +169,8 @@ public Builder missingValueIndicator(String missingValueIndicator) {
         }
 
         @Override
-        public Builder minimizeColumnSizes(boolean minimizeColumnSizes) {
-            super.minimizeColumnSizes(minimizeColumnSizes);
+        public Builder minimizeColumnSizes() {
+            super.minimizeColumnSizes();
             return this;
         }
     }

File: core/src/main/java/tech/tablesaw/io/FileReader.java
Patch:
@@ -227,5 +227,4 @@ protected String getTypeString(Table structure) {
         buf.append(System.lineSeparator());
         return buf.toString();
     }
-
 }

File: core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeParser.java
Patch:
@@ -58,7 +58,7 @@ public DateTimeParser(ColumnType columnType) {
 
     public DateTimeParser(DateTimeColumnType dateTimeColumnType, ReadOptions readOptions) {
         super(dateTimeColumnType);
-        DateTimeFormatter readCsvFormatter = readOptions.dateFormatter();
+        DateTimeFormatter readCsvFormatter = readOptions.dateTimeFormatter();
         if (readCsvFormatter != null) {
             formatter = readCsvFormatter;
         }

File: html/src/main/java/tech/tablesaw/io/html/HtmlWriter.java
Patch:
@@ -62,7 +62,7 @@ private static Element row(int row, Table table, ElementCreator elements) {
         Element tr = elements.create("tr", null, row);
         for (Column<?> col : table.columns()) {
           tr.appendChild(elements.create("td", col, row)
-              .append(String.valueOf(col.getString(row))));
+              .appendText(String.valueOf(col.getString(row))));
         }
         return tr;
     }
@@ -73,7 +73,7 @@ private static Element header(List<Column<?>> cols, ElementCreator elements) {
         thead.appendChild(tr);
         for (Column<?> col : cols) {
             tr.appendChild(elements.create("th", col, null)
-                .append(col.name()));
+                .appendText(col.name()));
         }
         return thead;
     }

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -148,6 +148,7 @@ protected ColumnType[] detectColumnTypes(Reader reader, CsvReadOptions options)
 
     private CsvParser csvParser(CsvReadOptions options) {
         CsvParserSettings settings = new CsvParserSettings();
+        settings.setLineSeparatorDetectionEnabled(options.lineSeparatorDetectionEnabled());
         settings.setFormat(csvFormat(options));
         if (options.maxNumberOfColumns() != null) {
             settings.setMaxColumns(options.maxNumberOfColumns());

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -163,6 +163,9 @@ private CsvFormat csvFormat(CsvReadOptions options) {
         if (options.lineEnding() != null) {
             format.setLineSeparator(options.lineEnding());
         }
+        if(options.commentPrefix() != null) {
+            format.setComment(options.commentPrefix());
+        }
         return format;
     }
 

File: core/src/main/java/tech/tablesaw/columns/dates/DateMapFunctions.java
Patch:
@@ -412,7 +412,7 @@ default DateTimeColumn atTime(LocalTime time) {
         DateTimeColumn newColumn = DateTimeColumn.create(this.name() + " " + time.toString());
         for (int r = 0; r < this.size(); r++) {
             int c1 = this.getIntInternal(r);
-            if (DateColumn.valueIsMissing(c1)) {
+            if (valueIsMissing(c1)) {
         	newColumn.appendMissing();
             } else {
                 LocalDate value1 = PackedLocalDate.asLocalDate(c1);
@@ -431,7 +431,7 @@ default DateTimeColumn atTime(TimeColumn timeColumn) {
         for (int r = 0; r < this.size(); r++) {
             int c1 = this.getIntInternal(r);
             int c2 = timeColumn.getIntInternal(r);
-            if (DateColumn.valueIsMissing(c1) || DateColumn.valueIsMissing(c2)) {
+            if (valueIsMissing(c1) || valueIsMissing(c2)) {
         	newColumn.appendMissing();
             } else {
                 newColumn.appendInternal(PackedLocalDateTime.create(c1, c2));

File: core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeParser.java
Patch:
@@ -89,7 +89,7 @@ public LocalDateTime parse(String value) {
         if (isMissing(value)) {
             return null;
         }
-        value = Strings.padStart(value, 4, '0');
-        return LocalDateTime.parse(value, formatter);
+        String paddedValue = Strings.padStart(value, 4, '0');
+        return LocalDateTime.parse(paddedValue, formatter);
     }
 }

File: core/src/main/java/tech/tablesaw/columns/times/TimeParser.java
Patch:
@@ -97,8 +97,8 @@ public LocalTime parse(String value) {
         if (isMissing(value)) {
             return null;
         }
-        value = Strings.padStart(value, 4, '0');
-        return LocalTime.parse(value, parserFormatter);
+        String paddedValue = Strings.padStart(value, 4, '0');
+        return LocalTime.parse(paddedValue, parserFormatter);
     }
 
 }

File: core/src/main/java/tech/tablesaw/io/ReadOptions.java
Patch:
@@ -198,7 +198,7 @@ public DateTimeFormatter dateFormatter() {
 
     public static class Builder {
 
-        InputStream inputStream;
+	protected InputStream inputStream;
         protected File file;
         protected Reader reader;
         protected String tableName = "";

File: core/src/test/java/tech/tablesaw/api/RowPerformanceTest.java
Patch:
@@ -230,8 +230,7 @@ private static void generateData(int observationCount, LocalDateTime dateTime, T
         }
 
         while (dates.size() <= numberOfRecordsInTable) {
-            dateTime = dateTime.plusMinutes(1);
-            dates.add(PackedLocalDateTime.pack(dateTime));
+            dates.add(PackedLocalDateTime.pack(dateTime.plusMinutes(1)));
         }
 
         DateTimeColumn dateColumn = table.dateTimeColumn("date");

File: core/src/test/java/tech/tablesaw/api/TableTest.java
Patch:
@@ -311,9 +311,10 @@ public void stepWithRows() throws Exception {
         assertEquals(sum1, rowConsumer.getSum());
 
     }
+
     private static class RowConsumer implements Consumer<Row[]> {
 
-        int sum = 0;
+        private int sum = 0;
 
         public int getSum() {
             return sum;

File: core/src/test/java/tech/tablesaw/filters/SearchPerformanceTest.java
Patch:
@@ -144,8 +144,7 @@ private static void generateData(int observationCount, LocalDateTime dateTime, T
         }
 
         while (dates.size() <= numberOfRecordsInTable) {
-            dateTime = dateTime.plusMinutes(1);
-            dates.add(PackedLocalDateTime.pack(dateTime));
+            dates.add(PackedLocalDateTime.pack(dateTime.plusMinutes(1)));
         }
 
         DateTimeColumn dateColumn = table.dateTimeColumn("date");

File: core/src/test/java/tech/tablesaw/io/csv/UnicodeBomHandlingTest.java
Patch:
@@ -24,7 +24,7 @@ public class UnicodeBomHandlingTest {
 
 
     @Test
-    public void test_JavaBehaviour() throws IOException {
+    public void javaBehaviour() throws IOException {
 
         Table t = new CsvReader().read(CsvReadOptions.builder(
                 new InputStreamReader(new ByteArrayInputStream(CONTENT)), "R").header(false).build());

File: excel/src/main/java/tech/tablesaw/io/xlsx/XlsxReader.java
Patch:
@@ -109,15 +109,15 @@ private ColumnType getColumnType(Cell cell) {
     }
 
     private static class TableRange {
-        int startRow, endRow, startColumn, endColumn;
+        private int startRow, endRow, startColumn, endColumn;
         TableRange(int startRow, int endRow, int startColumn, int endColumn) {
             this.startRow = startRow;
             this.endRow = endRow;
             this.startColumn = startColumn;
             this.endColumn = endColumn;
         }
     }
-    
+
     private TableRange findTableArea(Sheet sheet) {
         // find first row and column with contents
         int row1 = -1;

File: jsplot/src/test/java/tech/tablesaw/examples/BarPieAndParetoExample.java
Patch:
@@ -1,6 +1,5 @@
 package tech.tablesaw.examples;
 
-import tech.tablesaw.aggregate.AggregateFunctions;
 import tech.tablesaw.api.IntColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.numbers.IntColumnType;
@@ -11,6 +10,7 @@
 import tech.tablesaw.plotly.components.Layout;
 import tech.tablesaw.plotly.traces.BarTrace;
 
+import static tech.tablesaw.aggregate.AggregateFunctions.mean;
 import static tech.tablesaw.aggregate.AggregateFunctions.sum;
 
 public class BarPieAndParetoExample {
@@ -31,7 +31,7 @@ public static void main(String[] args) throws Exception {
 
         // Sum the number of fatalities from each tornado, grouping by scale
         Table fatalities1 =
-                tornadoes.summarize("fatalities", AggregateFunctions.sum).by("scale");
+                tornadoes.summarize("fatalities", sum).by("scale");
 
         // Plot
         Plot.show(
@@ -42,7 +42,7 @@ public static void main(String[] args) throws Exception {
                         "sum [fatalities]"));		// numeric column name
 
         // Plot the mean injuries rather than a sum.
-        Table injuries1 = tornadoes.summarize("injuries", AggregateFunctions.mean).by("scale");
+        Table injuries1 = tornadoes.summarize("injuries", mean).by("scale");
 
         Plot.show(
                 HorizontalBarPlot.create("Average number of tornado injuries by scale",

File: jsplot/src/test/java/tech/tablesaw/components/MarkerTest.java
Patch:
@@ -20,7 +20,6 @@ public void asJavascript() {
         assertTrue(x.asJavascript().contains("color"));
         assertTrue(x.asJavascript().contains("symbol"));
         assertTrue(x.asJavascript().contains("size"));
-
     }
 
 }

File: core/src/main/java/tech/tablesaw/io/FileReader.java
Patch:
@@ -133,7 +133,7 @@ private void addRows(ReadOptions options, ColumnType[] types, AbstractParser<?>
             // validation
             if (nextLine.length < types.length) {
                 if (nextLine.length == 1 && Strings.isNullOrEmpty(nextLine[0])) {
-                    System.err.println("Warning: Invalid Fixed Width file. Row "
+                    System.err.println("Warning: Invalid file. Row "
                             + rowNumber
                             + " is empty. Continuing.");
                     continue;

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -30,7 +30,7 @@
 import it.unimi.dsi.fastutil.ints.IntComparator;
 import tech.tablesaw.columns.AbstractColumn;
 import tech.tablesaw.columns.Column;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.columns.booleans.BooleanColumnType;
 import tech.tablesaw.columns.booleans.BooleanColumnUtils;
 import tech.tablesaw.columns.booleans.BooleanFillers;
@@ -369,7 +369,7 @@ public BooleanColumn appendCell(String object) {
     }
 
     @Override
-    public BooleanColumn appendCell(String object, AbstractParser<?> parser) {
+    public BooleanColumn appendCell(String object, AbstractColumnParser<?> parser) {
         return append(parser.parseByte(object));
     }
 

File: core/src/main/java/tech/tablesaw/api/ColumnType.java
Patch:
@@ -1,7 +1,7 @@
 package tech.tablesaw.api;
 
 import com.google.common.base.Preconditions;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.columns.SkipColumnType;
 import tech.tablesaw.columns.booleans.BooleanColumnType;
@@ -64,7 +64,7 @@ static ColumnType valueOf(String name) {
 
     String getPrinterFriendlyName();
 
-    AbstractParser<?> customParser(ReadOptions options);
+    AbstractColumnParser<?> customParser(ReadOptions options);
 
     default boolean compare(int rowNumber, Column<?> temp, Column<?> original) {
         return original.get(rowNumber).equals(temp.get(temp.size() - 1));

File: core/src/main/java/tech/tablesaw/api/DateColumn.java
Patch:
@@ -22,7 +22,7 @@
 import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
 import it.unimi.dsi.fastutil.ints.IntSet;
 import tech.tablesaw.columns.AbstractColumn;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.columns.dates.DateColumnFormatter;
 import tech.tablesaw.columns.dates.DateColumnType;
@@ -367,7 +367,7 @@ public DateColumn appendCell(String string) {
     }
 
     @Override
-    public DateColumn appendCell(String string, AbstractParser<?> parser) {
+    public DateColumn appendCell(String string, AbstractColumnParser<?> parser) {
         return appendObj(parser.parse(string));
     }
 

File: core/src/main/java/tech/tablesaw/api/DateTimeColumn.java
Patch:
@@ -23,7 +23,7 @@
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import tech.tablesaw.columns.AbstractColumn;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.columns.datetimes.DateTimeColumnFormatter;
 import tech.tablesaw.columns.datetimes.DateTimeColumnType;
@@ -189,7 +189,7 @@ public DateTimeColumn appendCell(String stringValue) {
     }
 
     @Override
-    public DateTimeColumn appendCell(String stringValue, AbstractParser<?> parser) {
+    public DateTimeColumn appendCell(String stringValue, AbstractColumnParser<?> parser) {
         return appendObj(parser.parse(stringValue));
     }
 

File: core/src/main/java/tech/tablesaw/api/DoubleColumn.java
Patch:
@@ -13,7 +13,7 @@
 import it.unimi.dsi.fastutil.longs.LongArrayList;
 import it.unimi.dsi.fastutil.shorts.ShortArrayList;
 import tech.tablesaw.columns.Column;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.columns.numbers.DoubleColumnType;
 import tech.tablesaw.columns.numbers.FloatColumnType;
 import tech.tablesaw.columns.numbers.NumberFillers;
@@ -426,7 +426,7 @@ public DoubleColumn appendCell(final String value) {
     }
 
     @Override
-    public DoubleColumn appendCell(final String value, AbstractParser<?> parser) {
+    public DoubleColumn appendCell(final String value, AbstractColumnParser<?> parser) {
         try {
             return append(parser.parseDouble(value));
         } catch (final NumberFormatException e) {

File: core/src/main/java/tech/tablesaw/api/FloatColumn.java
Patch:
@@ -12,7 +12,7 @@
 import it.unimi.dsi.fastutil.longs.LongArrayList;
 import it.unimi.dsi.fastutil.shorts.ShortArrayList;
 import tech.tablesaw.columns.Column;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.columns.numbers.FloatColumnType;
 import tech.tablesaw.selection.Selection;
 
@@ -326,7 +326,7 @@ public FloatColumn appendCell(final String value) {
     }
 
     @Override
-    public FloatColumn appendCell(final String value, AbstractParser<?> parser) {
+    public FloatColumn appendCell(final String value, AbstractColumnParser<?> parser) {
         try {
             return append(parser.parseFloat(value));
         } catch (final NumberFormatException e) {

File: core/src/main/java/tech/tablesaw/api/IntColumn.java
Patch:
@@ -12,7 +12,7 @@
 import it.unimi.dsi.fastutil.longs.LongArrayList;
 import it.unimi.dsi.fastutil.shorts.ShortArrayList;
 import tech.tablesaw.columns.Column;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.columns.numbers.DoubleColumnType;
 import tech.tablesaw.columns.numbers.IntColumnType;
 import tech.tablesaw.columns.numbers.NumberColumnFormatter;
@@ -354,7 +354,7 @@ public IntColumn appendCell(final String value) {
     }
 
     @Override
-    public IntColumn appendCell(final String value, AbstractParser<?> parser) {
+    public IntColumn appendCell(final String value, AbstractColumnParser<?> parser) {
         try {
             return append(parser.parseInt(value));
         } catch (final NumberFormatException e) {

File: core/src/main/java/tech/tablesaw/api/LongColumn.java
Patch:
@@ -12,7 +12,7 @@
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.shorts.ShortArrayList;
 import tech.tablesaw.columns.Column;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.columns.numbers.DoubleColumnType;
 import tech.tablesaw.columns.numbers.LongColumnType;
 import tech.tablesaw.columns.numbers.NumberColumnFormatter;
@@ -388,7 +388,7 @@ public LongColumn appendCell(final String value) {
     }
 
     @Override
-    public LongColumn appendCell(final String value, AbstractParser<?> parser) {
+    public LongColumn appendCell(final String value, AbstractColumnParser<?> parser) {
         try {
             return append(parser.parseLong(value));
         } catch (final NumberFormatException e) {

File: core/src/main/java/tech/tablesaw/api/ShortColumn.java
Patch:
@@ -10,7 +10,7 @@
 import it.unimi.dsi.fastutil.shorts.ShortListIterator;
 import it.unimi.dsi.fastutil.shorts.ShortOpenHashSet;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.columns.numbers.DoubleColumnType;
 import tech.tablesaw.columns.numbers.NumberColumnFormatter;
@@ -352,7 +352,7 @@ public ShortColumn appendCell(final String value) {
     }
 
     @Override
-    public ShortColumn appendCell(final String value, AbstractParser<?> parser) {
+    public ShortColumn appendCell(final String value, AbstractColumnParser<?> parser) {
         try {
             return append(parser.parseShort(value));
         } catch (final NumberFormatException e) {

File: core/src/main/java/tech/tablesaw/api/StringColumn.java
Patch:
@@ -18,7 +18,7 @@
 
 import it.unimi.dsi.fastutil.ints.IntComparator;
 import tech.tablesaw.columns.AbstractColumn;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.columns.strings.ByteDictionaryMap;
 import tech.tablesaw.columns.strings.DictionaryMap;
@@ -342,7 +342,7 @@ public StringColumn appendCell(String object) {
     }
 
     @Override
-    public StringColumn appendCell(String object, AbstractParser<?> parser) {
+    public StringColumn appendCell(String object, AbstractColumnParser<?> parser) {
         return appendObj(parser.parse(object));
     }
 

File: core/src/main/java/tech/tablesaw/api/TextColumn.java
Patch:
@@ -18,7 +18,7 @@
 import com.google.common.collect.Lists;
 import it.unimi.dsi.fastutil.ints.IntComparator;
 import tech.tablesaw.columns.AbstractColumn;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.columns.strings.StringColumnFormatter;
 import tech.tablesaw.columns.strings.StringFilters;
@@ -338,7 +338,7 @@ public TextColumn appendCell(String object) {
     }
 
     @Override
-    public TextColumn appendCell(String object, AbstractParser<?> parser) {
+    public TextColumn appendCell(String object, AbstractColumnParser<?> parser) {
         return appendObj(parser.parse(object));
     }
 

File: core/src/main/java/tech/tablesaw/api/TimeColumn.java
Patch:
@@ -23,7 +23,7 @@
 import it.unimi.dsi.fastutil.ints.IntSet;
 import tech.tablesaw.columns.AbstractColumn;
 import tech.tablesaw.columns.Column;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.columns.times.PackedLocalTime;
 import tech.tablesaw.columns.times.TimeColumnFormatter;
 import tech.tablesaw.columns.times.TimeColumnType;
@@ -363,7 +363,7 @@ public TimeColumn appendCell(String object) {
     }
 
     @Override
-    public TimeColumn appendCell(String object, AbstractParser<?> parser) {
+    public TimeColumn appendCell(String object, AbstractColumnParser<?> parser) {
         return appendObj(parser.parse(object));
     }
 

File: core/src/main/java/tech/tablesaw/columns/AbstractColumnParser.java
Patch:
@@ -15,13 +15,13 @@
  *
  * @param <T>   The Class of object to be inserted: String for StringColumn, LocalDate for DateColumn, etc.
  */
-public abstract class AbstractParser<T> {
+public abstract class AbstractColumnParser<T> {
 
     private final ColumnType columnType;
 
     protected List<String> missingValueStrings = TypeUtils.MISSING_INDICATORS;
 
-    public AbstractParser(ColumnType columnType) {
+    public AbstractColumnParser(ColumnType columnType) {
         this.columnType = columnType;
     }
 

File: core/src/main/java/tech/tablesaw/columns/Column.java
Patch:
@@ -493,7 +493,7 @@ default Column<T> set(Selection rowSelection, T newValue) {
 
     Column<T> appendCell(String stringValue);
 
-    Column<T> appendCell(String stringValue, AbstractParser<?> parser);
+    Column<T> appendCell(String stringValue, AbstractColumnParser<?> parser);
 
     Column<T> set(int row, T value);
 

File: core/src/main/java/tech/tablesaw/columns/SkipColumnType.java
Patch:
@@ -22,7 +22,7 @@ public Column<Void> create(String name) {
     }
 
     @Override
-    public AbstractParser<?> customParser(ReadOptions options) {
+    public AbstractColumnParser<?> customParser(ReadOptions options) {
         throw new UnsupportedOperationException("Column type " + name() + " doesn't support parsing");
     }
 

File: core/src/main/java/tech/tablesaw/columns/booleans/BooleanParser.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.google.common.collect.Lists;
 import tech.tablesaw.api.ColumnType;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.io.ReadOptions;
 
 import java.util.Arrays;
@@ -12,7 +12,7 @@
 import static tech.tablesaw.columns.booleans.BooleanColumnType.BYTE_TRUE;
 import static tech.tablesaw.columns.booleans.BooleanColumnType.MISSING_VALUE;
 
-public class BooleanParser extends AbstractParser<Boolean> {
+public class BooleanParser extends AbstractColumnParser<Boolean> {
 
     // A more restricted set of 'false' strings that is used for column type detection
     private static final List<String> FALSE_STRINGS_FOR_DETECTION =

File: core/src/main/java/tech/tablesaw/columns/dates/DateColumnType.java
Patch:
@@ -3,7 +3,7 @@
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.DateColumn;
 import tech.tablesaw.columns.AbstractColumnType;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.io.ReadOptions;
 
 import java.time.LocalDate;
@@ -32,7 +32,7 @@ public DateColumn create(String name) {
     }
 
     @Override
-    public AbstractParser<LocalDate> customParser(ReadOptions options) {
+    public AbstractColumnParser<LocalDate> customParser(ReadOptions options) {
         return new DateParser(this, options);
     }
 

File: core/src/main/java/tech/tablesaw/columns/dates/DateParser.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.google.common.collect.Lists;
 import tech.tablesaw.api.ColumnType;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.io.ReadOptions;
 
 import java.time.LocalDate;
@@ -11,7 +11,7 @@
 import java.time.format.DateTimeParseException;
 import java.util.Locale;
 
-public class DateParser extends AbstractParser<LocalDate> {
+public class DateParser extends AbstractColumnParser<LocalDate> {
 
     // Formats that we accept in parsing dates from strings
     private static final DateTimeFormatter dtf1 = DateTimeFormatter.ofPattern("yyyyMMdd");

File: core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeParser.java
Patch:
@@ -4,7 +4,7 @@
 import com.google.common.collect.Lists;
 
 import tech.tablesaw.api.ColumnType;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.io.ReadOptions;
 
 import java.time.LocalDateTime;
@@ -13,7 +13,7 @@
 import java.time.format.DateTimeParseException;
 import java.util.Locale;
 
-public class DateTimeParser extends AbstractParser<LocalDateTime> {
+public class DateTimeParser extends AbstractColumnParser<LocalDateTime> {
 
     private static final DateTimeFormatter dtTimef0 =
             DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");     // 2014-07-09 13:03:44

File: core/src/main/java/tech/tablesaw/columns/strings/StringParser.java
Patch:
@@ -2,10 +2,10 @@
 
 import com.google.common.collect.Lists;
 import tech.tablesaw.api.ColumnType;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.io.ReadOptions;
 
-public class StringParser extends AbstractParser<String> {
+public class StringParser extends AbstractColumnParser<String> {
 
     public StringParser(ColumnType columnType) {
         super(columnType);

File: core/src/main/java/tech/tablesaw/columns/times/TimeColumnType.java
Patch:
@@ -3,7 +3,7 @@
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.TimeColumn;
 import tech.tablesaw.columns.AbstractColumnType;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.io.ReadOptions;
 
 import java.time.LocalTime;
@@ -33,7 +33,7 @@ public TimeColumn create(String name) {
     }
 
     @Override
-    public AbstractParser<LocalTime> customParser(ReadOptions options) {
+    public AbstractColumnParser<LocalTime> customParser(ReadOptions options) {
         return new TimeParser(this, options);
     }
 

File: core/src/main/java/tech/tablesaw/columns/times/TimeParser.java
Patch:
@@ -3,7 +3,7 @@
 import com.google.common.base.Strings;
 import com.google.common.collect.Lists;
 import tech.tablesaw.api.ColumnType;
-import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.AbstractColumnParser;
 import tech.tablesaw.io.ReadOptions;
 
 import java.time.LocalTime;
@@ -12,7 +12,7 @@
 import java.time.format.DateTimeParseException;
 import java.util.Locale;
 
-public class TimeParser extends AbstractParser<LocalTime> {
+public class TimeParser extends AbstractColumnParser<LocalTime> {
 
     private static final DateTimeFormatter timef1 = DateTimeFormatter.ofPattern("HH:mm:ss.SSS");
     private static final DateTimeFormatter timef2 = DateTimeFormatter.ofPattern("hh:mm:ss a");

File: core/src/test/java/tech/tablesaw/io/fixed/FixedWidthReaderTest.java
Patch:
@@ -112,6 +112,7 @@ public void testDataTypeDetection() throws Exception {
                 .lineEnding("\n")
                 .sample(false)
                 .locale(Locale.getDefault())
+                .minimizeColumnSizes(true)
                 .build();
 
         Reader reader = new FileReader("../data/fixed_width_missing_values.txt");
@@ -129,6 +130,7 @@ public void testWithMissingValue() throws Exception {
                 .padding('_')
                 .lineEnding("\n")
                 .missingValueIndicator("null")
+                .minimizeColumnSizes(true)
                 .sample(false)
                 .build();
 

File: core/src/test/java/tech/tablesaw/TableFilteringTest.java
Patch:
@@ -38,7 +38,7 @@ public class TableFilteringTest {
 
     @Before
     public void setUp() throws Exception {
-        table = Table.read().csv(CsvReadOptions.builder("../data/bush.csv"));
+        table = Table.read().csv(CsvReadOptions.builder("../data/bush.csv").minimizeColumnSizes(true));
     }
 
     @Test

File: core/src/test/java/tech/tablesaw/io/csv/UnicodeBomHandlingTest.java
Patch:
@@ -28,10 +28,10 @@ public void test_JavaBehaviour() throws IOException {
 
         Table t = new CsvReader().read(CsvReadOptions.builder(
                 new InputStreamReader(new ByteArrayInputStream(CONTENT)), "R").header(false).build());
-        assertEquals((short) 1, t.get(0, 0));
+        assertEquals(1, t.get(0, 0));
         t = new CsvReader().read(CsvReadOptions.builder(
                 new InputStreamReader(new ByteArrayInputStream(UTF8_BOM_CONTENT)), "R").header(false).build());
-        assertEquals((short) 1, t.get(0, 0));
+        assertEquals(1, t.get(0, 0));
     }
 
     protected static final class BOM {

File: core/src/main/java/tech/tablesaw/io/AddCellToColumnException.java
Patch:
@@ -12,7 +12,7 @@
  * limitations under the License.
  */
 
-package tech.tablesaw.io.csv;
+package tech.tablesaw.io;
 
 import java.io.PrintStream;
 import java.util.List;

File: core/src/main/java/tech/tablesaw/io/ReadOptions.java
Patch:
@@ -45,9 +45,9 @@ protected ReadOptions(ReadOptions.Builder builder) {
         if (builder.inputStream != null) sourceCount++;
 
         if (sourceCount == 0) {
-            throw new IllegalArgumentException("CsvReadOptions Builder configured with no data source");
+            throw new IllegalArgumentException("ReadOptions Builder configured with no data source");
         } else if (sourceCount > 1) {
-            throw new IllegalArgumentException("CsvReadOptions Builder configured with more than one data source");
+            throw new IllegalArgumentException("ReadOptions Builder configured with more than one data source");
         }
 
         file = builder.file;

File: core/src/main/java/tech/tablesaw/io/html/HtmlTableWriter.java
Patch:
@@ -22,7 +22,8 @@
 import java.io.PrintWriter;
 import java.util.List;
 
-import static tech.tablesaw.io.ParsingUtils.*;
+import static tech.tablesaw.io.ParsingUtils.splitCamelCase;
+import static tech.tablesaw.io.ParsingUtils.splitOnUnderscore;
 
 /**
  * Static utility that writes Tables in HTML format for display

File: core/src/main/java/tech/tablesaw/io/json/JsonWriter.java
Patch:
@@ -14,16 +14,15 @@
 
 package tech.tablesaw.io.json;
 
-import javax.annotation.concurrent.Immutable;
-
 import com.fasterxml.jackson.core.JsonProcessingException;
 import com.fasterxml.jackson.databind.JsonNode;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.node.ArrayNode;
 import com.fasterxml.jackson.databind.node.ObjectNode;
-
 import tech.tablesaw.api.Table;
 
+import javax.annotation.concurrent.Immutable;
+
 @Immutable
 final public class JsonWriter {
 

File: core/src/test/java/tech/tablesaw/io/csv/CsvReaderTest.java
Patch:
@@ -24,6 +24,7 @@
 import tech.tablesaw.api.LongColumn;
 import tech.tablesaw.api.ShortColumn;
 import tech.tablesaw.api.Table;
+import tech.tablesaw.io.AddCellToColumnException;
 
 import java.io.File;
 import java.io.FileInputStream;

File: core/src/main/java/tech/tablesaw/api/ColumnType.java
Patch:
@@ -15,7 +15,7 @@
 import tech.tablesaw.columns.strings.StringColumnType;
 import tech.tablesaw.columns.strings.TextColumnType;
 import tech.tablesaw.columns.times.TimeColumnType;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -64,7 +64,7 @@ static ColumnType valueOf(String name) {
 
     String getPrinterFriendlyName();
 
-    AbstractParser<?> customParser(CsvReadOptions options);
+    AbstractParser<?> customParser(ReadOptions options);
 
     default boolean compare(int rowNumber, Column<?> temp, Column<?> original) {
         return original.get(rowNumber).equals(temp.get(temp.size() - 1));

File: core/src/main/java/tech/tablesaw/columns/SkipColumnType.java
Patch:
@@ -1,6 +1,6 @@
 package tech.tablesaw.columns;
 
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 public class SkipColumnType extends AbstractColumnType {
 
@@ -22,7 +22,7 @@ public Column<Void> create(String name) {
     }
 
     @Override
-    public AbstractParser<?> customParser(CsvReadOptions options) {
+    public AbstractParser<?> customParser(ReadOptions options) {
         throw new UnsupportedOperationException("Column type " + name() + " doesn't support parsing");
     }
 

File: core/src/main/java/tech/tablesaw/columns/booleans/BooleanColumnType.java
Patch:
@@ -3,7 +3,7 @@
 import tech.tablesaw.api.BooleanColumn;
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.columns.AbstractColumnType;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 public class BooleanColumnType extends AbstractColumnType {
 
@@ -36,7 +36,7 @@ public BooleanColumn create(String name) {
     }
 
     @Override
-    public BooleanParser customParser(CsvReadOptions readOptions) {
+    public BooleanParser customParser(ReadOptions readOptions) {
         return new BooleanParser(this, readOptions);
     }
 

File: core/src/main/java/tech/tablesaw/columns/booleans/BooleanParser.java
Patch:
@@ -3,7 +3,7 @@
 import com.google.common.collect.Lists;
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.columns.AbstractParser;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 import java.util.Arrays;
 import java.util.List;
@@ -34,7 +34,7 @@ public BooleanParser(ColumnType columnType) {
         super(columnType);
     }
 
-    public BooleanParser(BooleanColumnType booleanColumnType, CsvReadOptions readOptions) {
+    public BooleanParser(BooleanColumnType booleanColumnType, ReadOptions readOptions) {
         super(booleanColumnType);
         if (readOptions.missingValueIndicator() != null) {
             missingValueStrings = Lists.newArrayList(readOptions.missingValueIndicator());

File: core/src/main/java/tech/tablesaw/columns/dates/DateColumnType.java
Patch:
@@ -4,7 +4,7 @@
 import tech.tablesaw.api.DateColumn;
 import tech.tablesaw.columns.AbstractColumnType;
 import tech.tablesaw.columns.AbstractParser;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 import java.time.LocalDate;
 
@@ -32,7 +32,7 @@ public DateColumn create(String name) {
     }
 
     @Override
-    public AbstractParser<LocalDate> customParser(CsvReadOptions options) {
+    public AbstractParser<LocalDate> customParser(ReadOptions options) {
         return new DateParser(this, options);
     }
 

File: core/src/main/java/tech/tablesaw/columns/dates/DateParser.java
Patch:
@@ -3,7 +3,7 @@
 import com.google.common.collect.Lists;
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.columns.AbstractParser;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 import java.time.LocalDate;
 import java.time.format.DateTimeFormatter;
@@ -61,7 +61,7 @@ public class DateParser extends AbstractParser<LocalDate> {
     private Locale locale = Locale.getDefault();
     private DateTimeFormatter formatter = DEFAULT_FORMATTER;
 
-    public DateParser(ColumnType type, CsvReadOptions readOptions) {
+    public DateParser(ColumnType type, ReadOptions readOptions) {
         super(type);
         DateTimeFormatter readCsvFormatter = readOptions.dateFormatter();
         if (readCsvFormatter != null) {

File: core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeColumnType.java
Patch:
@@ -3,7 +3,7 @@
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.DateTimeColumn;
 import tech.tablesaw.columns.AbstractColumnType;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 public class DateTimeColumnType extends AbstractColumnType {
 
@@ -31,7 +31,7 @@ public DateTimeColumn create(String name) {
     }
 
     @Override
-    public DateTimeParser customParser(CsvReadOptions options) {
+    public DateTimeParser customParser(ReadOptions options) {
         return new DateTimeParser(this, options);
     }
 

File: core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeParser.java
Patch:
@@ -5,7 +5,7 @@
 
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.columns.AbstractParser;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 import java.time.LocalDateTime;
 import java.time.format.DateTimeFormatter;
@@ -56,7 +56,7 @@ public DateTimeParser(ColumnType columnType) {
         super(columnType);
     }
 
-    public DateTimeParser(DateTimeColumnType dateTimeColumnType, CsvReadOptions readOptions) {
+    public DateTimeParser(DateTimeColumnType dateTimeColumnType, ReadOptions readOptions) {
         super(dateTimeColumnType);
         DateTimeFormatter readCsvFormatter = readOptions.dateFormatter();
         if (readCsvFormatter != null) {

File: core/src/main/java/tech/tablesaw/columns/numbers/DoubleColumnType.java
Patch:
@@ -3,7 +3,7 @@
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.columns.AbstractColumnType;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 public class DoubleColumnType extends AbstractColumnType {
 
@@ -31,7 +31,7 @@ public DoubleColumn create(String name) {
     }
 
     @Override
-    public DoubleParser customParser(CsvReadOptions options) {
+    public DoubleParser customParser(ReadOptions options) {
         return new DoubleParser(this, options);
     }
 

File: core/src/main/java/tech/tablesaw/columns/numbers/DoubleParser.java
Patch:
@@ -3,15 +3,15 @@
 import com.google.common.collect.Lists;
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.columns.AbstractParser;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 public class DoubleParser extends AbstractParser<Double> {
 
     public DoubleParser(ColumnType columnType) {
         super(columnType);
     }
 
-    public DoubleParser(DoubleColumnType doubleColumnType, CsvReadOptions readOptions) {
+    public DoubleParser(DoubleColumnType doubleColumnType, ReadOptions readOptions) {
         super(doubleColumnType);
         if (readOptions.missingValueIndicator() != null) {
             missingValueStrings = Lists.newArrayList(readOptions.missingValueIndicator());

File: core/src/main/java/tech/tablesaw/columns/numbers/FloatColumnType.java
Patch:
@@ -3,7 +3,7 @@
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.FloatColumn;
 import tech.tablesaw.columns.AbstractColumnType;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 public class FloatColumnType extends AbstractColumnType {
 
@@ -30,7 +30,7 @@ public FloatColumn create(String name) {
     }
 
     @Override
-    public FloatParser customParser(CsvReadOptions options) {
+    public FloatParser customParser(ReadOptions options) {
         return new FloatParser(this, options);
     }
 

File: core/src/main/java/tech/tablesaw/columns/numbers/FloatParser.java
Patch:
@@ -3,15 +3,15 @@
 import com.google.common.collect.Lists;
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.columns.AbstractParser;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 public class FloatParser extends AbstractParser<Float> {
 
     public FloatParser(ColumnType columnType) {
         super(columnType);
     }
 
-    public FloatParser(FloatColumnType columnType, CsvReadOptions readOptions) {
+    public FloatParser(FloatColumnType columnType, ReadOptions readOptions) {
         super(columnType);
         if (readOptions.missingValueIndicator() != null) {
             missingValueStrings = Lists.newArrayList(readOptions.missingValueIndicator());

File: core/src/main/java/tech/tablesaw/columns/numbers/IntColumnType.java
Patch:
@@ -3,7 +3,7 @@
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.IntColumn;
 import tech.tablesaw.columns.AbstractColumnType;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 public class IntColumnType extends AbstractColumnType {
 
@@ -30,7 +30,7 @@ public IntColumn create(String name) {
     }
 
     @Override
-    public IntParser customParser(CsvReadOptions options) {
+    public IntParser customParser(ReadOptions options) {
         return new IntParser(this, options);
     }
 

File: core/src/main/java/tech/tablesaw/columns/numbers/IntParser.java
Patch:
@@ -3,15 +3,15 @@
 import com.google.common.collect.Lists;
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.columns.AbstractParser;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 public class IntParser extends AbstractParser<Integer> {
 
     public IntParser(ColumnType columnType) {
         super(columnType);
     }
 
-    public IntParser(IntColumnType columnType, CsvReadOptions readOptions) {
+    public IntParser(IntColumnType columnType, ReadOptions readOptions) {
         super(columnType);
         if (readOptions.missingValueIndicator() != null) {
             missingValueStrings = Lists.newArrayList(readOptions.missingValueIndicator());

File: core/src/main/java/tech/tablesaw/columns/numbers/LongColumnType.java
Patch:
@@ -3,7 +3,7 @@
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.LongColumn;
 import tech.tablesaw.columns.AbstractColumnType;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 public class LongColumnType extends AbstractColumnType {
 
@@ -33,7 +33,7 @@ public LongParser defaultParser() {
     }
 
     @Override
-    public LongParser customParser(CsvReadOptions options) {
+    public LongParser customParser(ReadOptions options) {
         return new LongParser(this, options);
     }
 

File: core/src/main/java/tech/tablesaw/columns/numbers/LongParser.java
Patch:
@@ -3,15 +3,15 @@
 import com.google.common.collect.Lists;
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.columns.AbstractParser;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 public class LongParser extends AbstractParser<Long> {
 
     public LongParser(ColumnType columnType) {
         super(columnType);
     }
 
-    public LongParser(LongColumnType columnType, CsvReadOptions readOptions) {
+    public LongParser(LongColumnType columnType, ReadOptions readOptions) {
         super(columnType);
         if (readOptions.missingValueIndicator() != null) {
             missingValueStrings = Lists.newArrayList(readOptions.missingValueIndicator());

File: core/src/main/java/tech/tablesaw/columns/numbers/ShortColumnType.java
Patch:
@@ -2,7 +2,7 @@
 
 import tech.tablesaw.api.ShortColumn;
 import tech.tablesaw.columns.AbstractColumnType;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 public class ShortColumnType extends AbstractColumnType {
 
@@ -29,7 +29,7 @@ public ShortColumn create(String name) {
     }
 
     @Override
-    public ShortParser customParser(CsvReadOptions options) {
+    public ShortParser customParser(ReadOptions options) {
         return new ShortParser(this, options);
     }
 

File: core/src/main/java/tech/tablesaw/columns/numbers/ShortParser.java
Patch:
@@ -2,15 +2,15 @@
 
 import com.google.common.collect.Lists;
 import tech.tablesaw.columns.AbstractParser;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 public class ShortParser extends AbstractParser<Short> {
 
     public ShortParser(ShortColumnType columnType) {
         super(columnType);
     }
 
-    public ShortParser(ShortColumnType columnType, CsvReadOptions readOptions) {
+    public ShortParser(ShortColumnType columnType, ReadOptions readOptions) {
         super(columnType);
         if (readOptions.missingValueIndicator() != null) {
             missingValueStrings = Lists.newArrayList(readOptions.missingValueIndicator());

File: core/src/main/java/tech/tablesaw/columns/strings/StringColumnType.java
Patch:
@@ -3,7 +3,7 @@
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.columns.AbstractColumnType;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 public class StringColumnType extends AbstractColumnType {
 
@@ -31,7 +31,7 @@ public StringColumn create(String name) {
     }
 
     @Override
-    public StringParser customParser(CsvReadOptions options) {
+    public StringParser customParser(ReadOptions options) {
         return new StringParser(this, options);
     }
 

File: core/src/main/java/tech/tablesaw/columns/strings/StringParser.java
Patch:
@@ -3,15 +3,15 @@
 import com.google.common.collect.Lists;
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.columns.AbstractParser;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 public class StringParser extends AbstractParser<String> {
 
     public StringParser(ColumnType columnType) {
         super(columnType);
     }
 
-    public StringParser(ColumnType columnType, CsvReadOptions readOptions) {
+    public StringParser(ColumnType columnType, ReadOptions readOptions) {
         super(columnType);
         if (readOptions.missingValueIndicator() != null) {
             missingValueStrings = Lists.newArrayList(readOptions.missingValueIndicator());

File: core/src/main/java/tech/tablesaw/columns/strings/TextColumnType.java
Patch:
@@ -3,7 +3,7 @@
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.TextColumn;
 import tech.tablesaw.columns.AbstractColumnType;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 public class TextColumnType extends AbstractColumnType {
 
@@ -29,7 +29,7 @@ public TextColumn create(String name) {
     }
 
     @Override
-    public StringParser customParser(CsvReadOptions options) {
+    public StringParser customParser(ReadOptions options) {
         return new StringParser(this, options);
     }
 

File: core/src/main/java/tech/tablesaw/columns/times/TimeColumnType.java
Patch:
@@ -4,7 +4,7 @@
 import tech.tablesaw.api.TimeColumn;
 import tech.tablesaw.columns.AbstractColumnType;
 import tech.tablesaw.columns.AbstractParser;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 import java.time.LocalTime;
 
@@ -33,7 +33,7 @@ public TimeColumn create(String name) {
     }
 
     @Override
-    public AbstractParser<LocalTime> customParser(CsvReadOptions options) {
+    public AbstractParser<LocalTime> customParser(ReadOptions options) {
         return new TimeParser(this, options);
     }
 

File: core/src/main/java/tech/tablesaw/columns/times/TimeParser.java
Patch:
@@ -4,7 +4,7 @@
 import com.google.common.collect.Lists;
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.columns.AbstractParser;
-import tech.tablesaw.io.csv.CsvReadOptions;
+import tech.tablesaw.io.ReadOptions;
 
 import java.time.LocalTime;
 import java.time.format.DateTimeFormatter;
@@ -63,7 +63,7 @@ public TimeParser(ColumnType columnType) {
         super(columnType);
     }
 
-    public TimeParser(ColumnType columnType, CsvReadOptions readOptions) {
+    public TimeParser(ColumnType columnType, ReadOptions readOptions) {
         super(columnType);
         DateTimeFormatter readCsvFormatter = readOptions.timeFormatter();
         if (readCsvFormatter != null) {

File: core/src/main/java/tech/tablesaw/api/ShortColumn.java
Patch:
@@ -10,10 +10,9 @@
 import it.unimi.dsi.fastutil.shorts.ShortListIterator;
 import it.unimi.dsi.fastutil.shorts.ShortOpenHashSet;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
-import tech.tablesaw.columns.Column;
 import tech.tablesaw.columns.AbstractParser;
+import tech.tablesaw.columns.Column;
 import tech.tablesaw.columns.numbers.DoubleColumnType;
-import tech.tablesaw.columns.numbers.IntColumnType;
 import tech.tablesaw.columns.numbers.NumberColumnFormatter;
 import tech.tablesaw.columns.numbers.ShortColumnType;
 import tech.tablesaw.selection.Selection;
@@ -355,7 +354,7 @@ public ShortColumn appendCell(final String value, AbstractParser<?> parser) {
     @Override
     public String getUnformattedString(final int row) {
         final int value = getInt(row);
-        if (IntColumnType.isMissingValue(value)) {
+        if (ShortColumnType.isMissingValue(value)) {
             return "";
         }
         return String.valueOf(value);

File: core/src/main/java/tech/tablesaw/columns/booleans/BooleanFormatter.java
Patch:
@@ -1,7 +1,5 @@
 package tech.tablesaw.columns.booleans;
 
-import tech.tablesaw.api.BooleanColumn;
-
 public class BooleanFormatter {
     private String trueString = "true";
     private String falseString = "false";

File: core/src/main/java/tech/tablesaw/joining/DataFrameJoiner.java
Patch:
@@ -203,7 +203,6 @@ private Table joinInternal(Table table1, Table table2, boolean outer, boolean al
                 ColumnType type = table1Column.type();
                 // relies on both arrays, columns, and col2Names,
                 // having corresponding values at same index
-                String col2Name = col2Names[i];
                 Selection rowBitMapOneCol = null;
                 if (type instanceof DateColumnType) {
                     IntIndex index = (IntIndex) columnIndexMap.get(column);

File: jsplot/src/test/java/tech/tablesaw/examples/MurderVisualizations.java
Patch:
@@ -132,7 +132,7 @@ public static void main(String[] args) throws Exception {
         out(categoryCount.printAll());
 
         Table xtab1 = details.xTabColumnPercents("VicSex", "Weapon category");
-        xtab1.columnsOfType(DOUBLE).forEach(e -> ((NumberColumn)e).setPrintFormatter(NumberColumnFormatter.percent(1)));
+        xtab1.columnsOfType(DOUBLE).forEach(e -> ((DoubleColumn)e).setPrintFormatter(NumberColumnFormatter.percent(1)));
         out(xtab1.printAll());
 
         Plot.show(Histogram.create("victim age", details, "vicage"));
@@ -163,9 +163,9 @@ public static void main(String[] args) throws Exception {
 
         Plot.show(Histogram.create("age", asphyx, "vicAge"));
         Table counts = asphyx.xTabCounts("year", "StateName");
-        counts.columnsOfType(DOUBLE).stream().forEach(e -> ((NumberColumn)e).setPrintFormatter(NumberColumnFormatter.ints()));
+        counts.columnsOfType(DOUBLE).stream().forEach(e -> ((DoubleColumn)e).setPrintFormatter(NumberColumnFormatter.ints()));
         counts.columnsOfType(DOUBLE).stream().forEach(e -> ((DoubleColumn)e)
-                .set(((NumberColumn) e).isEqualTo(0), DoubleColumnType.missingValueIndicator()));
+                .set(((DoubleColumn) e).isEqualTo(0), DoubleColumnType.missingValueIndicator()));
         out(counts.printAll());
         out(femaleVictims.shape());
     }

File: core/src/test/java/tech/tablesaw/io/csv/CsvReaderTest.java
Patch:
@@ -335,12 +335,13 @@ public void testDataTypeDetection2() throws Exception {
     @Test
     public void testLoadFromUrl() throws Exception {
         ColumnType[] types = {LOCAL_DATE, DOUBLE, STRING};
-        String location = "https://raw.githubusercontent.com/jAirframe/Airframe/master/data/bush.csv";
+        String location = "https://raw.githubusercontent.com/jTablesaw/tablesaw/master/data/bush.csv";
         Table table;
         try (InputStream input = new URL(location).openStream()) {
             table = Table.read().csv(CsvReadOptions
                     .builder(input, "Bush approval ratings")
-                    .columnTypes(types));
+                    .columnTypes(types)
+                    );
         }
         assertNotNull(table);
         assertEquals(3, table.columnCount());

File: core/src/main/java/tech/tablesaw/columns/Column.java
Patch:
@@ -137,7 +137,7 @@ default Optional<T> reduce(BinaryOperator<T> op) {
 
 
     default String title() {
-        return "Column: " + name() + '\n';
+        return "Column: " + name() + System.lineSeparator();
     }
 
     Selection isMissing();
@@ -175,7 +175,7 @@ default String print() {
         builder.append(title());
         for (int i = 0; i < size(); i++) {
             builder.append(getString(i));
-            builder.append('\n');
+            builder.append(System.lineSeparator());
         }
         return builder.toString();
     }

File: core/src/main/java/tech/tablesaw/io/csv/CsvWriteOptions.java
Patch:
@@ -63,7 +63,7 @@ public static class Builder {
         private Writer writer;
         private boolean header = true;
         private char separator = ',';
-        private String lineEnd = "\n";
+        private String lineEnd = System.lineSeparator();
         private char escapeChar = '\\';
         private char quoteChar = '"';
 

File: core/src/main/java/tech/tablesaw/aggregate/NumericAggregateFunction.java
Patch:
@@ -2,7 +2,6 @@
 
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.NumericColumn;
-import tech.tablesaw.columns.numbers.ShortColumnType;
 
 /**
  * A partial implementation of aggregate functions to summarize over a numeric column
@@ -18,7 +17,7 @@ public boolean isCompatibleColumn(ColumnType type) {
         return type.equals(ColumnType.DOUBLE)
                 || type.equals(ColumnType.FLOAT)
                 || type.equals(ColumnType.INTEGER)
-                || type.equals(ShortColumnType.INSTANCE)
+                || type.equals(ColumnType.SHORT)
                 || type.equals(ColumnType.LONG);
     }
 

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -70,7 +70,7 @@ public class BooleanColumn extends AbstractColumn<Boolean> implements BooleanMap
     private BooleanFormatter formatter = new BooleanFormatter("true", "false", "");
 
     private BooleanColumn(String name, ByteArrayList values) {
-        super(BooleanColumnType.INSTANCE, name);
+        super(BooleanColumnType.instance(), name);
         data = values;
     }
 

File: core/src/main/java/tech/tablesaw/api/DateColumn.java
Patch:
@@ -95,7 +95,7 @@ public static DateColumn create(String name, LocalDate[] data) {
     }
 
     private DateColumn(String name, IntArrayList data) {
-        super(DateColumnType.INSTANCE, name);
+        super(DateColumnType.instance(), name);
         this.data = data;
     }
 

File: core/src/main/java/tech/tablesaw/api/DateTimeColumn.java
Patch:
@@ -71,7 +71,7 @@ public class DateTimeColumn extends AbstractColumn<LocalDateTime>
     private DateTimeColumnFormatter printFormatter = new DateTimeColumnFormatter();
 
     private DateTimeColumn(String name, LongArrayList data) {
-        super(DateTimeColumnType.INSTANCE, name);
+        super(DateTimeColumnType.instance(), name);
         this.data = data;
     }
 

File: core/src/main/java/tech/tablesaw/api/DoubleColumn.java
Patch:
@@ -42,7 +42,7 @@ public class DoubleColumn extends NumberColumn<Double> implements NumberFillers<
     private final DoubleArrayList data;
 
     protected DoubleColumn(final String name, final DoubleArrayList data) {
-        super(DoubleColumnType.INSTANCE, name);
+        super(DoubleColumnType.instance(), name);
         this.data = data;
     }
 
@@ -62,7 +62,7 @@ public DoubleColumn setMissing(int index) {
     }
 
     protected DoubleColumn(final String name) {
-        super(DoubleColumnType.INSTANCE, name);
+        super(DoubleColumnType.instance(), name);
         this.data = new DoubleArrayList(DEFAULT_ARRAY_SIZE);
     }
 
@@ -350,7 +350,7 @@ public DoubleColumn filter(DoublePredicate test) {
 
     @Override
     public byte[] asBytes(int rowNumber) {
-        return ByteBuffer.allocate(DoubleColumnType.INSTANCE.byteSize()).putDouble(getDouble(rowNumber)).array();
+        return ByteBuffer.allocate(DoubleColumnType.instance().byteSize()).putDouble(getDouble(rowNumber)).array();
     }
 
     @Override

File: core/src/main/java/tech/tablesaw/api/FloatColumn.java
Patch:
@@ -32,7 +32,7 @@ public class FloatColumn extends NumberColumn<Float> {
     private final FloatArrayList data;    
 
     private FloatColumn(final String name, FloatArrayList data) {
-        super(FloatColumnType.INSTANCE, name);
+        super(FloatColumnType.instance(), name);
         this.data = data;
     }
 
@@ -233,7 +233,7 @@ public FloatColumn set(int row, Column<Float> column, int sourceRow) {
 
     @Override
     public byte[] asBytes(int rowNumber) {
-        return ByteBuffer.allocate(FloatColumnType.INSTANCE.byteSize()).putFloat(getFloat(rowNumber)).array();
+        return ByteBuffer.allocate(FloatColumnType.instance().byteSize()).putFloat(getFloat(rowNumber)).array();
     }
 
     @Override

File: core/src/main/java/tech/tablesaw/api/IntColumn.java
Patch:
@@ -34,7 +34,7 @@ public class IntColumn extends NumberColumn<Integer> implements CategoricalColum
     private final IntArrayList data;
 
     protected IntColumn(final String name, IntArrayList data) {
-        super(IntColumnType.INSTANCE, name);
+        super(IntColumnType.instance(), name);
         this.printFormatter = NumberColumnFormatter.ints();
         this.data = data;
     }
@@ -258,7 +258,7 @@ public IntColumn appendMissing() {
 
     @Override
     public byte[] asBytes(int rowNumber) {
-        return ByteBuffer.allocate(IntColumnType.INSTANCE.byteSize()).putInt(getInt(rowNumber)).array();
+        return ByteBuffer.allocate(IntColumnType.instance().byteSize()).putInt(getInt(rowNumber)).array();
     }
 
     @Override

File: core/src/main/java/tech/tablesaw/api/LongColumn.java
Patch:
@@ -36,7 +36,7 @@ public class LongColumn extends NumberColumn<Long> implements CategoricalColumn<
     private final LongArrayList data;
 
     private LongColumn(final String name, LongArrayList data) {
-        super(LongColumnType.INSTANCE, name);
+        super(LongColumnType.instance(), name);
         this.printFormatter = NumberColumnFormatter.ints();
         this.data = data;
     }
@@ -285,7 +285,7 @@ public LongColumn appendMissing() {
 
     @Override
     public byte[] asBytes(int rowNumber) {
-        return ByteBuffer.allocate(LongColumnType.INSTANCE.byteSize()).putLong(getLong(rowNumber)).array();
+        return ByteBuffer.allocate(LongColumnType.instance().byteSize()).putLong(getLong(rowNumber)).array();
     }
 
     @Override

File: core/src/main/java/tech/tablesaw/api/ShortColumn.java
Patch:
@@ -34,7 +34,7 @@ public class ShortColumn extends NumberColumn<Short> implements CategoricalColum
     private final ShortArrayList data;
 
     protected ShortColumn(final String name, ShortArrayList data) {
-        super(ShortColumnType.INSTANCE, name);
+        super(ShortColumnType.instance(), name);
         this.printFormatter = NumberColumnFormatter.ints();
         this.data = data;
     }
@@ -250,7 +250,7 @@ public ShortColumn appendMissing() {
 
     @Override
     public byte[] asBytes(int rowNumber) {
-        return ByteBuffer.allocate(ShortColumnType.INSTANCE.byteSize()).putShort(getShort(rowNumber)).array();
+        return ByteBuffer.allocate(ShortColumnType.instance().byteSize()).putShort(getShort(rowNumber)).array();
     }
 
     @Override

File: core/src/main/java/tech/tablesaw/api/StringColumn.java
Patch:
@@ -93,18 +93,18 @@ public static StringColumn create(String name, int size) {
     }
 
     private StringColumn(String name, List<String> strings) {
-        super(StringColumnType.INSTANCE, name);
+        super(StringColumnType.instance(), name);
         for (String string : strings) {
             append(string);
         }
     }
 
     private StringColumn(String name) {
-        super(StringColumnType.INSTANCE, name);
+        super(StringColumnType.instance(), name);
     }
 
     private StringColumn(String name, String[] strings) {
-        super(StringColumnType.INSTANCE, name);
+        super(StringColumnType.instance(), name);
         for (String string : strings) {
             append(string);
         }

File: core/src/main/java/tech/tablesaw/api/TextColumn.java
Patch:
@@ -61,20 +61,20 @@ public class TextColumn extends AbstractColumn<String>
     private final Comparator<String> descendingStringComparator = Comparator.reverseOrder();
 
     private TextColumn(String name, List<String> strings) {
-        super(TextColumnType.INSTANCE, name);
+        super(TextColumnType.instance(), name);
         values = new ArrayList<>(strings.size());
         for (String string : strings) {
             append(string);
         }
     }
 
     private TextColumn(String name) {
-        super(TextColumnType.INSTANCE, name);
+        super(TextColumnType.instance(), name);
         values = new ArrayList<>(DEFAULT_ARRAY_SIZE);
     }
 
     private TextColumn(String name, String[] strings) {
-        super(TextColumnType.INSTANCE, name);
+        super(TextColumnType.instance(), name);
         values = new ArrayList<>(strings.length);
         for (String string : strings) {
             append(string);

File: core/src/main/java/tech/tablesaw/api/TimeColumn.java
Patch:
@@ -69,12 +69,12 @@ public class TimeColumn extends AbstractColumn<LocalTime>
     };
 
     private TimeColumn(String name, IntArrayList times) {
-        super(TimeColumnType.INSTANCE, name);
+        super(TimeColumnType.instance(), name);
         data = times;
     }
 
     private TimeColumn(String name) {
-        super(TimeColumnType.INSTANCE, name);
+        super(TimeColumnType.instance(), name);
         data = new IntArrayList(DEFAULT_ARRAY_SIZE);
     }
 

File: core/src/main/java/tech/tablesaw/index/ShortIndex.java
Patch:
@@ -33,7 +33,7 @@ public class ShortIndex {
     private final Short2ObjectAVLTreeMap<IntArrayList> index;
 
     public ShortIndex(ShortColumn column) {
-        Preconditions.checkArgument(column.type().equals(ShortColumnType.INSTANCE),
+        Preconditions.checkArgument(column.type().equals(ShortColumnType.instance()),
                 "Short indexing only allowed on SHORT numeric columns");
         int sizeEstimate = Integer.min(1_000_000, column.size() / 100);
         Short2ObjectOpenHashMap<IntArrayList> tempMap = new Short2ObjectOpenHashMap<>(sizeEstimate);

File: core/src/main/java/tech/tablesaw/io/jdbc/SqlResultSetReader.java
Patch:
@@ -59,8 +59,8 @@ private static Map<Integer, ColumnType> initializeMap() {
                 .put(Types.REAL, ColumnType.FLOAT)
 
                 .put(Types.INTEGER, ColumnType.INTEGER)
-                .put(Types.SMALLINT, ShortColumnType.INSTANCE)
-                .put(Types.TINYINT, ShortColumnType.INSTANCE)
+                .put(Types.SMALLINT, ColumnType.SHORT)
+                .put(Types.TINYINT, ColumnType.SHORT)
                 .put(Types.BIGINT, ColumnType.LONG)
 
                 .put(Types.CHAR, ColumnType.STRING)
@@ -118,7 +118,7 @@ public static Table read(ResultSet resultSet, String tableName) throws SQLExcept
                     // Start with SHORT (since ColumnType.BYTE isn't supported yet)
                     // and find the smallest java integer type that fits
                     if (p <= 4) {
-                        type = ShortColumnType.INSTANCE;
+                        type = ShortColumnType.instance();
                     } else if (p <= 9) {
                         type = ColumnType.INTEGER;
                     } else if (p <= 18) {

File: core/src/main/java/tech/tablesaw/aggregate/NumericAggregateFunction.java
Patch:
@@ -2,6 +2,7 @@
 
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.NumericColumn;
+import tech.tablesaw.columns.numbers.ShortColumnType;
 
 /**
  * A partial implementation of aggregate functions to summarize over a numeric column
@@ -17,7 +18,7 @@ public boolean isCompatibleColumn(ColumnType type) {
         return type.equals(ColumnType.DOUBLE)
                 || type.equals(ColumnType.FLOAT)
                 || type.equals(ColumnType.INTEGER)
-                || type.equals(ColumnType.SHORT)
+                || type.equals(ShortColumnType.INSTANCE)
                 || type.equals(ColumnType.LONG);
     }
 

File: core/src/main/java/tech/tablesaw/api/ColumnType.java
Patch:
@@ -1,9 +1,9 @@
 package tech.tablesaw.api;
 
 import com.google.common.base.Preconditions;
+import tech.tablesaw.columns.AbstractParser;
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.columns.SkipColumnType;
-import tech.tablesaw.columns.AbstractParser;
 import tech.tablesaw.columns.booleans.BooleanColumnType;
 import tech.tablesaw.columns.dates.DateColumnType;
 import tech.tablesaw.columns.datetimes.DateTimeColumnType;

File: core/src/main/java/tech/tablesaw/api/DateColumn.java
Patch:
@@ -95,7 +95,7 @@ public static DateColumn create(String name, LocalDate[] data) {
     }
 
     private DateColumn(String name, IntArrayList data) {
-        super(ColumnType.LOCAL_DATE, name);
+        super(DateColumnType.INSTANCE, name);
         this.data = data;
     }
 

File: core/src/main/java/tech/tablesaw/api/TimeColumn.java
Patch:
@@ -48,7 +48,6 @@
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 
-import static tech.tablesaw.api.ColumnType.LOCAL_TIME;
 import static tech.tablesaw.columns.DateAndTimePredicates.*;
 
 /**
@@ -70,12 +69,12 @@ public class TimeColumn extends AbstractColumn<LocalTime>
     };
 
     private TimeColumn(String name, IntArrayList times) {
-        super(LOCAL_TIME, name);
+        super(TimeColumnType.INSTANCE, name);
         data = times;
     }
 
     private TimeColumn(String name) {
-        super(LOCAL_TIME, name);
+        super(TimeColumnType.INSTANCE, name);
         data = new IntArrayList(DEFAULT_ARRAY_SIZE);
     }
 

File: core/src/main/java/tech/tablesaw/columns/numbers/ShortColumnType.java
Patch:
@@ -1,13 +1,12 @@
 package tech.tablesaw.columns.numbers;
 
-import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.ShortColumn;
 import tech.tablesaw.columns.AbstractColumnType;
 import tech.tablesaw.io.csv.CsvReadOptions;
 
 public class ShortColumnType extends AbstractColumnType {
 
-    public static final ShortParser DEFAULT_PARSER = new ShortParser(ColumnType.SHORT);
+    public static final ShortParser DEFAULT_PARSER = new ShortParser(ShortColumnType.INSTANCE);
 
     private static final int BYTE_SIZE = 2;
 

File: core/src/main/java/tech/tablesaw/index/ShortIndex.java
Patch:
@@ -19,8 +19,8 @@
 import it.unimi.dsi.fastutil.shorts.Short2ObjectAVLTreeMap;
 import it.unimi.dsi.fastutil.shorts.Short2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.shorts.Short2ObjectSortedMap;
-import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.ShortColumn;
+import tech.tablesaw.columns.numbers.ShortColumnType;
 import tech.tablesaw.selection.BitmapBackedSelection;
 import tech.tablesaw.selection.Selection;
 
@@ -33,7 +33,7 @@ public class ShortIndex {
     private final Short2ObjectAVLTreeMap<IntArrayList> index;
 
     public ShortIndex(ShortColumn column) {
-        Preconditions.checkArgument(column.type().equals(ColumnType.SHORT),
+        Preconditions.checkArgument(column.type().equals(ShortColumnType.INSTANCE),
                 "Short indexing only allowed on SHORT numeric columns");
         int sizeEstimate = Integer.min(1_000_000, column.size() / 100);
         Short2ObjectOpenHashMap<IntArrayList> tempMap = new Short2ObjectOpenHashMap<>(sizeEstimate);

File: core/src/main/java/tech/tablesaw/columns/DateAndTimePredicates.java
Patch:
@@ -14,7 +14,7 @@
 
 package tech.tablesaw.columns;
 
-import tech.tablesaw.api.TimeColumn;
+import tech.tablesaw.columns.times.TimeColumnType;
 import tech.tablesaw.filtering.predicates.IntBiPredicate;
 
 import java.util.function.IntPredicate;
@@ -26,9 +26,9 @@
  */
 public class DateAndTimePredicates {
 
-    public final static IntPredicate isMissing = i -> i == TimeColumn.MISSING_VALUE;
+    public final static IntPredicate isMissing = i -> i == TimeColumnType.missingValueIndicator();
 
-    public final static IntPredicate isNotMissing = i -> i != TimeColumn.MISSING_VALUE;
+    public final static IntPredicate isNotMissing = i -> i != TimeColumnType.missingValueIndicator();
 
     public final static IntBiPredicate isGreaterThan = (valueToTest, valueToCompareAgainst) -> valueToTest > valueToCompareAgainst;
 

File: core/src/main/java/tech/tablesaw/columns/booleans/BooleanColumnUtils.java
Patch:
@@ -14,12 +14,11 @@
 
 package tech.tablesaw.columns.booleans;
 
-import tech.tablesaw.api.BooleanColumn;
 import tech.tablesaw.filtering.predicates.BytePredicate;
 
 public interface BooleanColumnUtils {
 
-    BytePredicate isMissing = i -> i == BooleanColumn.MISSING_VALUE;
+    BytePredicate isMissing = i -> i == BooleanColumnType.MISSING_VALUE;
 
-    BytePredicate isNotMissing = i -> i != BooleanColumn.MISSING_VALUE;
+    BytePredicate isNotMissing = i -> i != BooleanColumnType.MISSING_VALUE;
 }

File: core/src/main/java/tech/tablesaw/columns/booleans/BooleanFormatter.java
Patch:
@@ -35,7 +35,7 @@ public String format(Boolean value) {
     }
 
     public String format(byte value) {
-        if (value == BooleanColumn.MISSING_VALUE) {
+        if (value == BooleanColumnType.MISSING_VALUE) {
             return missingString;
         }
         if (value == (byte) 1) {

File: core/src/main/java/tech/tablesaw/columns/booleans/BooleanParser.java
Patch:
@@ -8,7 +8,9 @@
 import java.util.Arrays;
 import java.util.List;
 
-import static tech.tablesaw.api.BooleanColumn.*;
+import static tech.tablesaw.columns.booleans.BooleanColumnType.BYTE_FALSE;
+import static tech.tablesaw.columns.booleans.BooleanColumnType.BYTE_TRUE;
+import static tech.tablesaw.columns.booleans.BooleanColumnType.MISSING_VALUE;
 
 public class BooleanParser extends AbstractParser<Boolean> {
 

File: core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeParser.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.google.common.base.Strings;
 import com.google.common.collect.Lists;
+
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.columns.AbstractParser;
 import tech.tablesaw.io.csv.CsvReadOptions;

File: core/src/main/java/tech/tablesaw/columns/times/TimeColumnFormatter.java
Patch:
@@ -4,8 +4,8 @@
 import java.time.LocalTime;
 import java.time.format.DateTimeFormatter;
 
-import static tech.tablesaw.api.TimeColumn.*;
-import static tech.tablesaw.columns.times.PackedLocalTime.*;
+import static tech.tablesaw.columns.times.PackedLocalTime.asLocalTime;
+import static tech.tablesaw.columns.times.PackedLocalTime.toShortTimeString;
 
 @Immutable
 public class TimeColumnFormatter {
@@ -27,7 +27,7 @@ public TimeColumnFormatter(DateTimeFormatter format, String missingString) {
     }
 
     public String format(int value) {
-        if (value == MISSING_VALUE) {
+        if (value == TimeColumnType.missingValueIndicator()) {
             return missingString;
         }
         if (format == null) {

File: core/src/main/java/tech/tablesaw/columns/dates/DateColumnFormatter.java
Patch:
@@ -4,8 +4,8 @@
 import java.time.LocalDate;
 import java.time.format.DateTimeFormatter;
 
-import static tech.tablesaw.api.DateColumn.*;
-import static tech.tablesaw.columns.dates.PackedLocalDate.*;
+import static tech.tablesaw.columns.dates.PackedLocalDate.asLocalDate;
+import static tech.tablesaw.columns.dates.PackedLocalDate.toDateString;
 
 @Immutable
 public class DateColumnFormatter {
@@ -27,7 +27,7 @@ public DateColumnFormatter(DateTimeFormatter format, String missingString) {
     }
 
     public String format(int value) {
-        if (value == MISSING_VALUE) {
+        if (value == DateColumnType.missingValueIndicator()) {
             return missingString;
         }
         if (format == null) {

File: core/src/main/java/tech/tablesaw/columns/dates/DateMapFunctions.java
Patch:
@@ -31,7 +31,6 @@
 import java.time.temporal.TemporalUnit;
 import java.time.temporal.UnsupportedTemporalTypeException;
 
-import static tech.tablesaw.api.DateColumn.MISSING_VALUE;
 import static tech.tablesaw.api.DateColumn.valueIsMissing;
 
 /**
@@ -377,7 +376,7 @@ default DateColumn plus(int value, ChronoUnit unit) {
 
         for (int r = 0; r < column1.size(); r++) {
             int packedDate = column1.getIntInternal(r);
-            if (packedDate == MISSING_VALUE) {
+            if (packedDate == DateColumnType.missingValueIndicator()) {
         	newColumn.appendMissing();
             } else {
                 newColumn.appendInternal(PackedLocalDate.plus(value, unit, packedDate));

File: core/src/test/java/tech/tablesaw/api/DateColumnTest.java
Patch:
@@ -24,7 +24,7 @@ public void setUp() {
     public void testCreate1() {
         LocalDate[] dates = new LocalDate[5];
         DateColumn column = DateColumn.create("Game date", dates);
-        assertEquals(DateColumn.MISSING_VALUE, column.getIntInternal(0));
+        assertEquals(DateColumnType.missingValueIndicator(), column.getIntInternal(0));
     }
 
     @Test
@@ -134,7 +134,7 @@ public void testSummary() {
 
     @Test
     public void testMin() {
-        column1.appendInternal(DateColumn.MISSING_VALUE);
+        column1.appendInternal(DateColumnType.missingValueIndicator());
         column1.appendCell("2013-10-23");
 
         LocalDate actual = column1.min();

File: jsplot/src/main/java/tech/tablesaw/plotly/api/PiePlot.java
Patch:
@@ -19,7 +19,7 @@ public static Figure create(String title, Table table, String groupColName, Stri
                 .build();
 
         PieTrace trace = PieTrace.builder(
-                table.categoricalColumn(groupColName),
+                table.column(groupColName),
                 table.numberColumn(numberColName))
                 .showLegend(true)
                 .build();

File: jsplot/src/main/java/tech/tablesaw/plotly/traces/PieTrace.java
Patch:
@@ -2,8 +2,8 @@
 
 import com.mitchellbosecke.pebble.error.PebbleException;
 import com.mitchellbosecke.pebble.template.PebbleTemplate;
-import tech.tablesaw.api.CategoricalColumn;
 import tech.tablesaw.api.NumericColumn;
+import tech.tablesaw.columns.Column;
 import tech.tablesaw.plotly.Utils;
 
 import java.io.IOException;
@@ -51,7 +51,7 @@ public static PieBuilder builder(Object[] labels, double[] values) {
         return new PieBuilder(labels, values);
     }
 
-    public static PieBuilder builder(CategoricalColumn<?> labels, NumericColumn<? extends Number> values) {
+    public static PieBuilder builder(Column<?> labels, NumericColumn<? extends Number> values) {
         return new PieBuilder(TraceBuilder.columnToStringArray(labels), values.asDoubleArray());
     }
 

File: jsplot/src/main/java/tech/tablesaw/plotly/api/TimeSeriesPlot.java
Patch:
@@ -25,7 +25,7 @@ public static Figure create(String title, Table table, String dateColX, String y
         ScatterTrace[] traces  = new ScatterTrace[tables.size()];
         for (int i = 0; i < tables.size(); i++) {
             List<Table> tableList = tables.asTableList();
-            Table t = tableList.get(i).sortOn("date");
+            Table t = tableList.get(i).sortOn(dateColX);
             traces[i] = ScatterTrace.builder(
                     t.dateColumn(dateColX),
                     t.numberColumn(yCol))

File: core/src/test/java/tech/tablesaw/api/StringColumnTest.java
Patch:
@@ -507,15 +507,15 @@ public void asNumberColumn() {
         String[] words = {"foo", "bar", "larry", "foo", "lion", "ben", "tiger", "bar"};
         StringColumn wordColumn = StringColumn.create("words", words);
         IntColumn result = wordColumn.asNumberColumn();
-        assertArrayEquals(new double[] { 0.0, 1.0, 2.0, 0.0, 4.0, 5.0, 6.0, 1.0 }, result.asDoubleArray(), 0.000_000_1);
+        assertArrayEquals(new double[] { 0.0, 1.0, 2.0, 0.0, 3.0, 4.0, 5.0, 1.0 }, result.asDoubleArray(), 0.000_000_1);
     }
 
     @Test
     public void asDoubleArray() {
-        String[] words = {"foo", "bar", "larry", "foo", "lion", "ben", "tiger", "bar"};
+        String[] words = {"foo", "bar", "larry", "foo", "lion", null, "ben", "tiger", "bar"};
         StringColumn wordColumn = StringColumn.create("words", words);
         double[] result = wordColumn.asDoubleArray();
-        assertArrayEquals(new double[] { 0.0, 1.0, 2.0, 0.0, 4.0, 5.0, 6.0, 1.0 }, result, 0.000_000_1);
+        assertArrayEquals(new double[] { 0.0, 1.0, 2.0, 0.0, 3.0, 4.0, 5.0, 6.0, 1.0 }, result, 0.000_000_1);
     }
 
 }

File: core/src/main/java/tech/tablesaw/columns/datetimes/DateTimePredicates.java
Patch:
@@ -14,16 +14,15 @@
 
 package tech.tablesaw.columns.datetimes;
 
-import tech.tablesaw.api.DateTimeColumn;
 import tech.tablesaw.filtering.predicates.LongBiPredicate;
 
 import java.util.function.LongPredicate;
 
 public class DateTimePredicates {
 
-    public static final LongPredicate isMissing = i -> i == DateTimeColumn.MISSING_VALUE;
+    public static final LongPredicate isMissing = i -> i == DateTimeColumnType.missingValueIndicator();
 
-    public static final LongPredicate isNotMissing = i -> i != DateTimeColumn.MISSING_VALUE;
+    public static final LongPredicate isNotMissing = i -> i != DateTimeColumnType.missingValueIndicator();
 
     public static final LongBiPredicate isGreaterThan = (valueToTest, valueToCompareAgainst) -> valueToTest > valueToCompareAgainst;
 

File: core/src/test/java/tech/tablesaw/columns/datetimes/DateTimeMapFunctionsTest.java
Patch:
@@ -284,8 +284,8 @@ public void testLeadAndLag() {
         DateTimeColumn lead = startCol.lead(1);
         DateTimeColumn lag = startCol.lag(1);
         assertEquals(startCol.get(0), lag.get(1));
-        assertEquals(DateTimeColumn.MISSING_VALUE, lag.getLongInternal(0));
+        assertEquals(DateTimeColumnType.missingValueIndicator(), lag.getLongInternal(0));
         assertEquals(startCol.get(1), lead.get(0));
-        assertEquals(DateTimeColumn.MISSING_VALUE, lead.getLongInternal(2));
+        assertEquals(DateTimeColumnType.missingValueIndicator(), lead.getLongInternal(2));
     }
 }
\ No newline at end of file

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -834,7 +834,7 @@ public BooleanColumn fillWith(Supplier<Boolean> supplier) {
     }
 
     @Override
-    public Object[] asObjectArray() {
+    public Boolean[] asObjectArray() {
         final Boolean[] output = new Boolean[data.size()];
         for (int i = 0; i < data.size(); i++) {
             output[i] = get(i);

File: core/src/main/java/tech/tablesaw/api/DateColumn.java
Patch:
@@ -627,7 +627,7 @@ public DateColumn fillWith(Supplier<LocalDate> supplier) {
     }
 
     @Override
-    public Object[] asObjectArray() {
+    public LocalDate[] asObjectArray() {
         final LocalDate[] output = new LocalDate[data.size()];
         for (int i = 0; i < data.size(); i++) {
             output[i] = get(i);

File: core/src/main/java/tech/tablesaw/api/DateTimeColumn.java
Patch:
@@ -666,7 +666,7 @@ public DateTimeColumn fillWith(Supplier<LocalDateTime> supplier) {
     }
 
     @Override
-    public Object[] asObjectArray() {
+    public LocalDateTime[] asObjectArray() {
         final LocalDateTime[] output = new LocalDateTime[data.size()];
         for (int i = 0; i < data.size(); i++) {
             output[i] = get(i);

File: core/src/main/java/tech/tablesaw/api/DoubleColumn.java
Patch:
@@ -267,7 +267,7 @@ public Iterator<Double> iterator() {
     }
 
     @Override
-    public Object[] asObjectArray() {
+    public Double[] asObjectArray() {
         final Double[] output = new Double[size()];
         for (int i = 0; i < size(); i++) {
             output[i] = getDouble(i);

File: core/src/main/java/tech/tablesaw/api/FloatColumn.java
Patch:
@@ -188,7 +188,7 @@ public Iterator<Float> iterator() {
     }
 
     @Override
-    public Object[] asObjectArray() {
+    public Float[] asObjectArray() {
         final Float[] output = new Float[size()];
         for (int i = 0; i < size(); i++) {
             output[i] = getFloat(i);

File: core/src/main/java/tech/tablesaw/api/IntColumn.java
Patch:
@@ -207,7 +207,7 @@ public Iterator<Integer> iterator() {
     }
 
     @Override
-    public Object[] asObjectArray() {
+    public Integer[] asObjectArray() {
         final Integer[] output = new Integer[size()];
         for (int i = 0; i < size(); i++) {
             output[i] = getInt(i);

File: core/src/main/java/tech/tablesaw/api/LongColumn.java
Patch:
@@ -234,7 +234,7 @@ public Iterator<Long> iterator() {
     }
 
     @Override
-    public Object[] asObjectArray() {
+    public Long[] asObjectArray() {
         final Long[] output = new Long[size()];
         for (int i = 0; i < size(); i++) {
             output[i] = getLong(i);

File: core/src/main/java/tech/tablesaw/api/ShortColumn.java
Patch:
@@ -199,7 +199,7 @@ public Iterator<Short> iterator() {
     }
 
     @Override
-    public Object[] asObjectArray() {
+    public Short[] asObjectArray() {
         final Short[] output = new Short[size()];
         for (int i = 0; i < size(); i++) {
             output[i] = getShort(i);

File: core/src/main/java/tech/tablesaw/api/TimeColumn.java
Patch:
@@ -588,7 +588,7 @@ private TimeColumn fillWith(int count, Iterator<LocalTime> iterator, Consumer<Lo
     }
 
     @Override
-    public Object[] asObjectArray() {
+    public LocalTime[] asObjectArray() {
         final LocalTime[] output = new LocalTime[data.size()];
         for (int i = 0; i < data.size(); i++) {
             output[i] = get(i);

File: core/src/main/java/tech/tablesaw/columns/Column.java
Patch:
@@ -44,7 +44,7 @@ public interface Column<T> extends Iterable<T>, Comparator<T> {
 
     Table summary();
 
-    Object[] asObjectArray();
+    T[] asObjectArray();
 
     /**
      * Returns the count of missing values in this column.

File: core/src/main/java/tech/tablesaw/columns/strings/DictionaryMap.java
Patch:
@@ -33,9 +33,7 @@ public interface DictionaryMap {
 
     int firstIndexOf(String string);
 
-    Object[] asObjectArray();
-
-    String[] asStringArray();
+    String[] asObjectArray();
 
     Selection selectIsIn(String... strings);
 

File: core/src/main/java/tech/tablesaw/api/StringColumn.java
Patch:
@@ -400,7 +400,7 @@ public IntArrayList data() {
     }
 
     public IntColumn asNumberColumn() {
-        IntColumn numberColumn = IntColumn.create(this.name() + ": codes", size());
+        IntColumn numberColumn = IntColumn.create(this.name() + ": codes");
         IntArrayList data = data();
         for (int i = 0; i < size(); i++) {
             numberColumn.append(data.getInt(i));

File: jsplot/src/examples/java/tech/tablesaw/plotly/BarExample.java
Patch:
@@ -14,6 +14,7 @@
 
 package tech.tablesaw.plotly;
 
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.numbers.DoubleColumnType;
@@ -30,10 +31,10 @@ public class BarExample {
 
     public static void main(String[] args) throws Exception {
         Table table = Table.read().csv("../data/tornadoes_1950-2014.csv");
-        NumberColumn logNInjuries = table.numberColumn("injuries").add(1).logN();
+        NumberColumn<?> logNInjuries = table.numberColumn("injuries").add(1).logN();
         logNInjuries.setName("log injuries");
         table.addColumns(logNInjuries);
-        NumberColumn scale = table.numberColumn("scale");
+        DoubleColumn scale = table.doubleColumn("scale");
         scale.set(scale.isLessThan(0), DoubleColumnType.missingValueIndicator());
 
         Table s = table.summarize("fatalities", "log injuries", sum).by("Scale");

File: jsplot/src/examples/java/tech/tablesaw/plotly/BarVisualizations.java
Patch:
@@ -14,8 +14,7 @@
 
 package tech.tablesaw.plotly;
 
-import tech.tablesaw.examples.AbstractExample;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.numbers.DoubleColumnType;
 import tech.tablesaw.plotly.api.HorizontalBarPlot;
@@ -35,7 +34,7 @@ public static void main(String[] args) throws Exception {
         Table murders = Table.read().csv("../data/SHR76_16.csv");
         out(murders.structure().printAll());
         murders.setName("murders");
-        NumberColumn victimAge = murders.numberColumn("vicAge");
+        DoubleColumn victimAge = murders.doubleColumn("vicAge");
         victimAge.set(victimAge.isEqualTo(999), DoubleColumnType.missingValueIndicator());
 
         Table count = murders.countBy(murders.stringColumn("state"));

File: jsplot/src/examples/java/tech/tablesaw/plotly/BubbleExample.java
Patch:
@@ -31,9 +31,9 @@ public class BubbleExample {
     public static void main(String[] args) throws IOException {
         Table marketShare = Table.read().csv("../data/market_share.csv");
         Table sub = marketShare.where(Selection.withRange(0, 4));
-        NumberColumn x = sub.nCol("Products");
-        NumberColumn y = sub.nCol("Sales");
-        NumberColumn data = sub.nCol("Market_Share");
+        NumberColumn<?> x = sub.nCol("Products");
+        NumberColumn<?> y = sub.nCol("Sales");
+        NumberColumn<?> data = sub.nCol("Market_Share");
 
         Layout layout = Layout.builder().title("Market Share").build();
         Marker marker = Marker.builder()

File: jsplot/src/examples/java/tech/tablesaw/plotly/DrugVisualizations.java
Patch:
@@ -1,7 +1,6 @@
 package tech.tablesaw.plotly;
 
 import com.google.common.base.Stopwatch;
-import tech.tablesaw.examples.AbstractExample;
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.io.csv.CsvReadOptions;

File: jsplot/src/examples/java/tech/tablesaw/plotly/LinePlotExample.java
Patch:
@@ -27,8 +27,8 @@ public class LinePlotExample {
 
     public static void main(String[] args) throws Exception {
         Table robberies = Table.read().csv("../data/boston-robberies.csv");
-        NumberColumn x = robberies.nCol("Record");
-        NumberColumn y = robberies.nCol("Robberies");
+        NumberColumn<?> x = robberies.nCol("Record");
+        NumberColumn<?> y = robberies.nCol("Robberies");
 
         Layout layout = Layout.builder()
                 .title("Monthly Boston Armed Robberies Jan. 1966 - Oct. 1975")

File: jsplot/src/examples/java/tech/tablesaw/plotly/LinePlotExampleWithSmoothing.java
Patch:
@@ -28,8 +28,8 @@ public class LinePlotExampleWithSmoothing {
 
     public static void main(String[] args) throws Exception {
         Table robberies = Table.read().csv("../data/boston-robberies.csv");
-        NumberColumn x = robberies.nCol("Record");
-        NumberColumn y = robberies.nCol("Robberies");
+        NumberColumn<?> x = robberies.nCol("Record");
+        NumberColumn<?> y = robberies.nCol("Robberies");
 
         Layout layout = Layout.builder()
                 .title("Monthly Boston Armed Robberies Jan. 1966 - Oct. 1975")

File: jsplot/src/examples/java/tech/tablesaw/plotly/QuantileExample.java
Patch:
@@ -27,15 +27,15 @@ public class QuantileExample {
 
     public static void main(String[] args) throws Exception {
         Table baseball = Table.read().csv("../data/baseball.csv");
-        NumberColumn xCol = baseball.nCol("BA");
+        NumberColumn<?> xCol = baseball.nCol("BA");
 
         double[] x = new double[xCol.size()];
 
         for (int i = 0; i < x.length; i++) {
             x[i] = i / (float) x.length;
         }
 
-        NumberColumn copy = xCol.copy();
+        NumberColumn<?> copy = xCol.copy();
         copy.sortAscending();
 
         ScatterTrace trace = ScatterTrace.builder(x, copy.asDoubleArray()).build();

File: jsplot/src/examples/java/tech/tablesaw/plotly/ScatterVisualizations.java
Patch:
@@ -1,6 +1,5 @@
 package tech.tablesaw.plotly;
 
-import tech.tablesaw.examples.AbstractExample;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.plotly.api.BubblePlot;
 import tech.tablesaw.plotly.api.Scatter3DPlot;

File: jsplot/src/examples/java/tech/tablesaw/plotly/ScatterplotExample.java
Patch:
@@ -29,8 +29,8 @@ public class ScatterplotExample {
 
     public static void main(String[] args) throws Exception {
         Table baseball = Table.read().csv("../data/baseball.csv");
-        NumberColumn x = baseball.nCol("BA");
-        NumberColumn y = baseball.nCol("W");
+        NumberColumn<?> x = baseball.nCol("BA");
+        NumberColumn<?> y = baseball.nCol("W");
         Layout layout = Layout.builder().title("Wins vs BA")
                 .xAxis(Axis.builder().title("Batting Average").build())
                 .yAxis(Axis.builder().title("Wins").build())

File: jsplot/src/examples/java/tech/tablesaw/plotly/ScatterplotExample2.java
Patch:
@@ -31,8 +31,8 @@ public class ScatterplotExample2 {
     public static void main(String[] args) throws Exception {
         Table tornadoes = Table.read().csv("../data/tornadoes_1950-2014.csv");
         tornadoes = tornadoes.where(tornadoes.nCol("Start lat").isGreaterThan(20));
-        NumberColumn x = tornadoes.nCol("Start lon");
-        NumberColumn y = tornadoes.nCol("Start lat");
+        NumberColumn<?> x = tornadoes.nCol("Start lon");
+        NumberColumn<?> y = tornadoes.nCol("Start lat");
         Layout layout = Layout.builder()
                 .title("tornado start points")
                 .height(600)

File: jsplot/src/examples/java/tech/tablesaw/plotly/TornadoVisualizations.java
Patch:
@@ -14,8 +14,7 @@
 
 package tech.tablesaw.plotly;
 
-import tech.tablesaw.examples.AbstractExample;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.numbers.DoubleColumnType;
 import tech.tablesaw.plotly.api.HorizontalBarPlot;
@@ -38,7 +37,7 @@ public static void main(String[] args) throws Exception {
         // filter out a bad data point
         tornadoes = tornadoes.where(tornadoes.numberColumn("Start Lat").isGreaterThan(20f));
 
-        NumberColumn scale = tornadoes.numberColumn("scale");
+        DoubleColumn scale = tornadoes.doubleColumn("scale");
         scale.set(scale.isEqualTo(-9), DoubleColumnType.missingValueIndicator());
 
         Table fatalities1 = tornadoes.summarize("fatalities", sum).by("scale");

File: core/src/main/java/tech/tablesaw/aggregate/PivotTable.java
Patch:
@@ -73,7 +73,7 @@ private static Map<String, Double> getValueMap(
         Table summary = temp.summarize(values.name(), function).by(column1.name(), column2.name());
 
         Map<String, Double> valueMap = new HashMap<>();
-        NumberColumn nc = summary.numberColumn(summary.columnCount() - 1);
+        NumberColumn<?> nc = summary.numberColumn(summary.columnCount() - 1);
         for (int i = 0; i < summary.rowCount(); i++) {
             valueMap.put(String.valueOf(summary.get(i, 1)), nc.getDouble(i));
         }

File: core/src/main/java/tech/tablesaw/api/FloatColumn.java
Patch:
@@ -97,7 +97,7 @@ public FloatColumn unique() {
                 values.add(getFloat(i));
             }
         }
-        final FloatColumn column = FloatColumn.create(name() + " Unique values", values.size());
+        final FloatColumn column = FloatColumn.create(name() + " Unique values");
         for (float value : values) {
             column.append(value);
         }

File: core/src/main/java/tech/tablesaw/api/IntColumn.java
Patch:
@@ -116,7 +116,7 @@ public IntColumn unique() {
                 values.add(getInt(i));
             }
         }
-        final IntColumn column = IntColumn.create(name() + " Unique values", values.size());
+        final IntColumn column = IntColumn.create(name() + " Unique values");
         for (int value : values) {
             column.append(value);
         }

File: core/src/main/java/tech/tablesaw/api/LongColumn.java
Patch:
@@ -118,7 +118,7 @@ public LongColumn unique() {
                 values.add(getLong(i));
             }
         }
-        final LongColumn column = LongColumn.create(name() + " Unique values", values.size());
+        final LongColumn column = LongColumn.create(name() + " Unique values");
         for (long value : values) {
             column.append(value);
         }

File: core/src/main/java/tech/tablesaw/api/ShortColumn.java
Patch:
@@ -107,7 +107,8 @@ public ShortColumn unique() {
                 values.add(getShort(i));
             }
         }
-        final ShortColumn column = ShortColumn.create(name() + " Unique values", values.size());
+        final ShortColumn column = ShortColumn.create(name() + " Unique values");
+
         for (short value : values) {
             column.append(value);
         }

File: core/src/main/java/tech/tablesaw/columns/strings/ByteDictionaryMap.java
Patch:
@@ -218,7 +218,7 @@ public void append(String value) throws NoKeysAvailableException {
         byte key;
         if (value == null || StringColumnType.missingValueIndicator().equals(value)) {
             key = MISSING_VALUE;
-            put(key, value);
+            put(key, StringColumnType.missingValueIndicator());
         } else {
             key = getKeyForValue(value);
         }

File: core/src/main/java/tech/tablesaw/columns/strings/IntDictionaryMap.java
Patch:
@@ -225,7 +225,7 @@ public void append(String value) throws NoKeysAvailableException {
         int key;
         if (value == null || StringColumnType.missingValueIndicator().equals(value)) {
             key = MISSING_VALUE;
-            put(key, value);
+            put(key, StringColumnType.missingValueIndicator());
         } else {
             key = getKeyForValue(value);
         }

File: core/src/main/java/tech/tablesaw/columns/strings/ShortDictionaryMap.java
Patch:
@@ -230,7 +230,7 @@ public void append(String value) throws NoKeysAvailableException {
         short key;
         if (value == null || StringColumnType.missingValueIndicator().equals(value)) {
             key = MISSING_VALUE;
-            put(key, value);
+            put(key, StringColumnType.missingValueIndicator());
         } else {
             key = getKeyForValue(value);
         }

File: core/src/main/java/tech/tablesaw/io/csv/CsvReadOptions.java
Patch:
@@ -185,7 +185,7 @@ public static class Builder {
         private String dateTimeFormat;
         private Locale locale;
         private String missingValueIndicator;
-        private Integer maxNumberOfColumns;
+        private Integer maxNumberOfColumns = 10_000;
 
         public Builder(File file) {
             this.file = file;
@@ -284,4 +284,5 @@ public CsvReadOptions build() {
             return new CsvReadOptions(this);
         }
     }
+
 }

File: core/src/main/java/tech/tablesaw/aggregate/AggregateFunctions.java
Patch:
@@ -378,12 +378,12 @@ public Double summarize(NumericColumn<?> column) {
         }
     };
 
+    public static final NumericAggregateFunction standardDeviation = stdDev;
+
     public static Double percentile(NumericColumn<?> data, Double percentile) {
         return StatUtils.percentile(removeMissing(data), percentile);
     }
 
-    public static final NumericAggregateFunction standardDeviation = stdDev;
-
     private static double[] removeMissing(NumericColumn<?> column) {
         NumericColumn<?> numericColumn = (NumericColumn<?>) column.removeMissing();
         return numericColumn.asDoubleArray();

File: core/src/main/java/tech/tablesaw/api/StringColumn.java
Patch:
@@ -509,7 +509,7 @@ public StringColumn append(String value) {
                 lookupTable.append(value);
             } catch (NoKeysAvailableException e) {
                 // this can't happen
-                throw new RuntimeException(e);
+                throw new IllegalStateException(e);
             }
         }
         return this;

File: core/src/main/java/tech/tablesaw/columns/strings/ByteDictionaryMap.java
Patch:
@@ -413,7 +413,7 @@ public void appendMissing() {
             append(StringColumnType.missingValueIndicator());
         } catch (NoKeysAvailableException e) {
             // This can't happen because missing value key is the first one allocated
-            throw new RuntimeException(e);
+            throw new IllegalStateException(e);
         }
     }
 
@@ -431,7 +431,7 @@ public DictionaryMap promoteYourself() {
             dictionaryMap = new ShortDictionaryMap(this);
         } catch (NoKeysAvailableException e) {
             // this should never happen;
-            throw new RuntimeException(e);
+            throw new IllegalStateException(e);
         }
         return dictionaryMap;
     }

File: core/src/main/java/tech/tablesaw/columns/strings/ShortDictionaryMap.java
Patch:
@@ -419,7 +419,7 @@ public void appendMissing() {
             append(StringColumnType.missingValueIndicator());
         } catch (NoKeysAvailableException e) {
             // This can't happen because missing value key is the first one allocated
-            throw new RuntimeException(e);
+            throw new IllegalStateException(e);
         }
     }
 
@@ -437,7 +437,7 @@ public DictionaryMap promoteYourself() {
             dictionaryMap = new IntDictionaryMap(this);
         } catch (NoKeysAvailableException e) {
             // this should never happen;
-            throw new RuntimeException(e);
+            throw new IllegalStateException(e);
         }
 
         return dictionaryMap;

File: core/src/test/java/tech/tablesaw/api/NumberColumnTest.java
Patch:
@@ -47,6 +47,7 @@
 public class NumberColumnTest {
 
     private static final double MISSING = DoubleColumnType.missingValueIndicator();
+    private static final DoublePredicate isPositiveOrZeroD = d -> d >= 0, isNegativeD = d -> d < 0;
 
     @Ignore
     @Test
@@ -610,8 +611,6 @@ private boolean validateEquality(double[] expectedValues, DoubleColumn col) {
     
     // Functional methods
 
-    private DoublePredicate isPositiveOrZeroD = d -> d >= 0, isNegativeD = d -> d < 0;
-
     @Test
     public void testCountAtLeast() {
         assertEquals(2, DoubleColumn.create("t1", new double[] {0, 1, 2}).count(isPositiveOrZeroD, 2));

File: core/src/test/java/tech/tablesaw/io/csv/CsvReaderTest.java
Patch:
@@ -50,6 +50,9 @@ public class CsvReaderTest {
     private final ColumnType[] bus_types = {SHORT, STRING, STRING, FLOAT, FLOAT};
     private final ColumnType[] bus_types_with_SKIP = {SHORT, STRING, SKIP, DOUBLE, DOUBLE};
 
+    @Rule
+    public ExpectedException thrown = ExpectedException.none();
+
     @Test
     public void testWithBusData() throws Exception {
         // Read the CSV file
@@ -342,8 +345,6 @@ public void testLoadFromUrl() throws Exception {
         assertEquals(3, table.columnCount());
     }
 
-    @Rule
-    public ExpectedException thrown= ExpectedException.none();
     @Test
     public void testEmptyRow() throws Exception {
         Table.read().csv("../data/empty_row.csv");

File: jsplot/src/main/java/tech/tablesaw/plotly/components/threeD/Up.java
Patch:
@@ -2,12 +2,12 @@
 
 public class Up extends CameraComponent {
 
+    public static final Up DEFAULT = Up.upBuilder(0, 0, 1).build();
+
     private Up(UpBuilder builder) {
         super(builder.x, builder.y, builder.z);
     }
 
-    public static final Up DEFAULT = Up.upBuilder(0, 0, 1).build();
-
     public static UpBuilder upBuilder(double x, double y, double z) {
         return new UpBuilder(x, y, z);
     }

File: core/src/main/java/tech/tablesaw/api/StringColumn.java
Patch:
@@ -456,7 +456,7 @@ public int countMissing() {
     public StringColumn removeMissing() {
         StringColumn noMissing = emptyCopy();
         for (String v : this) {
-            if (valueIsMissing(v)) {
+            if (!valueIsMissing(v)) {
                 noMissing.append(v);
             }
         }

File: core/src/main/java/tech/tablesaw/api/TextColumn.java
Patch:
@@ -423,7 +423,7 @@ public TextColumn removeMissing() {
         Iterator<String> iterator = iterator();
         while(iterator.hasNext()) {
             String v = iterator.next();
-            if (valueIsMissing(v)) {
+            if (!valueIsMissing(v)) {
                 noMissing.append(v);
             }
         }

File: core/src/test/java/tech/tablesaw/examples/OperationsExample.java
Patch:
@@ -15,7 +15,7 @@
 package tech.tablesaw.examples;
 
 import tech.tablesaw.api.DateTimeColumn;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.LongColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.api.Row;
 import tech.tablesaw.examples.AbstractExample;
@@ -50,7 +50,7 @@ public static void main(String[] args) throws Exception {
         }
 
         // Calc duration
-        NumberColumn duration = start.differenceInSeconds(end);
+        LongColumn duration = start.differenceInSeconds(end);
         ops.addColumns(duration);
         duration.setName("Duration");
 

File: core/src/test/java/tech/tablesaw/examples/TextExample.java
Patch:
@@ -14,7 +14,7 @@
 
 package tech.tablesaw.examples;
 
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.examples.AbstractExample;
 
@@ -31,7 +31,7 @@ public static void main(String[] args) {
     }
 
     private static void countWords(StringColumn sc) {
-        NumberColumn nc = sc.countTokens(" ");
+        DoubleColumn nc = sc.countTokens(" ");
         out("Word count: " + nc.sum());
     }
 }
\ No newline at end of file

File: core/src/test/java/tech/tablesaw/examples/TornadoExample.java
Patch:
@@ -15,7 +15,7 @@
 package tech.tablesaw.examples;
 
 import tech.tablesaw.api.DateColumn;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.IntColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.selection.Selection;
@@ -126,7 +126,7 @@ public static void main(String[] args) throws Exception {
         // calculate the difference between a date and the prior date using the lagged column
         DateColumn summerDate = summer.dateColumn("Date");
         DateColumn laggedDate = summer.dateColumn("Date lag(1)");
-        NumberColumn delta = laggedDate.daysUntil(summerDate);  // the lagged date is earlier
+        IntColumn delta = laggedDate.daysUntil(summerDate);  // the lagged date is earlier
         summer.addColumns(delta);
 
         out(summer.first(4));

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -596,6 +596,9 @@ private List<AbstractParser<?>> getParserList(List<ColumnType> typeArray, CsvRea
     private CsvParser csvParser(CsvReadOptions options) {
         CsvParserSettings settings = new CsvParserSettings();
         settings.setFormat(csvFormat(options));
+        if (options.maxNumberOfColumns() != null) {
+            settings.setMaxColumns(options.maxNumberOfColumns());
+        }
         return new CsvParser(settings);
     }
 

File: core/src/main/java/tech/tablesaw/api/FloatColumn.java
Patch:
@@ -163,7 +163,7 @@ public FloatColumn append(float i) {
     }
 
     public FloatColumn append(Float val) {
-        this.append(val.intValue());
+        this.append(val.floatValue());
         return this;
     }
 

File: core/src/test/java/tech/tablesaw/examples/AbstractExample.java
Patch:
@@ -12,7 +12,7 @@
  * limitations under the License.
  */
 
-package tech.tablesaw;
+package tech.tablesaw.examples;
 
 /**
  * A helper class for writing example code

File: core/src/test/java/tech/tablesaw/examples/CrossTabsExample.java
Patch:
@@ -1,4 +1,4 @@
-package tech.tablesaw;
+package tech.tablesaw.examples;
 
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.NumberColumn;

File: core/src/test/java/tech/tablesaw/examples/OperationsExample.java
Patch:
@@ -12,12 +12,13 @@
  * limitations under the License.
  */
 
-package tech.tablesaw;
+package tech.tablesaw.examples;
 
 import tech.tablesaw.api.DateTimeColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.api.Row;
+import tech.tablesaw.examples.AbstractExample;
 
 import static tech.tablesaw.aggregate.AggregateFunctions.median;
 

File: core/src/test/java/tech/tablesaw/examples/TextExample.java
Patch:
@@ -12,10 +12,11 @@
  * limitations under the License.
  */
 
-package tech.tablesaw;
+package tech.tablesaw.examples;
 
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.StringColumn;
+import tech.tablesaw.examples.AbstractExample;
 
 /**
  * Usage example using a Tornado data set

File: core/src/test/java/tech/tablesaw/examples/TornadoExample.java
Patch:
@@ -12,7 +12,7 @@
  * limitations under the License.
  */
 
-package tech.tablesaw;
+package tech.tablesaw.examples;
 
 import tech.tablesaw.api.DateColumn;
 import tech.tablesaw.api.NumberColumn;

File: jsplot/src/examples/java/tech/tablesaw/plotly/BarVisualizations.java
Patch:
@@ -14,7 +14,7 @@
 
 package tech.tablesaw.plotly;
 
-import tech.tablesaw.AbstractExample;
+import tech.tablesaw.examples.AbstractExample;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.numbers.DoubleColumnType;

File: jsplot/src/examples/java/tech/tablesaw/plotly/DistributionVisualizations.java
Patch:
@@ -1,6 +1,6 @@
 package tech.tablesaw.plotly;
 
-import tech.tablesaw.AbstractExample;
+import tech.tablesaw.examples.AbstractExample;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.numbers.DoubleColumnType;

File: jsplot/src/examples/java/tech/tablesaw/plotly/DrugVisualizations.java
Patch:
@@ -1,7 +1,7 @@
 package tech.tablesaw.plotly;
 
 import com.google.common.base.Stopwatch;
-import tech.tablesaw.AbstractExample;
+import tech.tablesaw.examples.AbstractExample;
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.io.csv.CsvReadOptions;

File: jsplot/src/examples/java/tech/tablesaw/plotly/MurderVisualizations.java
Patch:
@@ -14,7 +14,7 @@
 
 package tech.tablesaw.plotly;
 
-import tech.tablesaw.AbstractExample;
+import tech.tablesaw.examples.AbstractExample;
 import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.StringColumn;

File: jsplot/src/examples/java/tech/tablesaw/plotly/ScatterVisualizations.java
Patch:
@@ -1,6 +1,6 @@
 package tech.tablesaw.plotly;
 
-import tech.tablesaw.AbstractExample;
+import tech.tablesaw.examples.AbstractExample;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.plotly.api.BubblePlot;
 import tech.tablesaw.plotly.api.Scatter3DPlot;

File: jsplot/src/examples/java/tech/tablesaw/plotly/TornadoVisualizations.java
Patch:
@@ -14,7 +14,7 @@
 
 package tech.tablesaw.plotly;
 
-import tech.tablesaw.AbstractExample;
+import tech.tablesaw.examples.AbstractExample;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.numbers.DoubleColumnType;

File: core/src/examples/java/tech/tablesaw/BusStopExample.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * Some example code using the API
  */
-public class BusStopExample {
+public class BusStopExample extends AbstractExample {
 
     public static void main(String[] args) throws Exception {
 

File: core/src/test/java/tech/tablesaw/io/csv/CsvReaderTest.java
Patch:
@@ -397,7 +397,7 @@ public void testReadFailure2() throws Exception {
     public void testEmptyFileHeaderEnabled() throws Exception {
         Table table1 = Table.read().csv(CsvReadOptions
                 .builder("../data/empty_file.csv")
-                .header(true));
+                .header(false));
         assertEquals("0 rows X 0 cols", table1.shape());
     }
 

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -578,7 +578,6 @@ private List<AbstractParser<?>> getParserList(List<ColumnType> typeArray, CsvRea
     private CsvParser csvParser(CsvReadOptions options) {
         CsvParserSettings settings = new CsvParserSettings();
         settings.setFormat(csvFormat(options));
-        settings.setMaxColumns(Integer.MAX_VALUE);
         return new CsvParser(settings);
     }
 

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -578,6 +578,7 @@ private List<AbstractParser<?>> getParserList(List<ColumnType> typeArray, CsvRea
     private CsvParser csvParser(CsvReadOptions options) {
         CsvParserSettings settings = new CsvParserSettings();
         settings.setFormat(csvFormat(options));
+        settings.setMaxColumns(Integer.MAX_VALUE);
         return new CsvParser(settings);
     }
 

File: core/src/main/java/tech/tablesaw/api/StringColumn.java
Patch:
@@ -273,7 +273,7 @@ public StringColumn set(int rowIndex, String stringValue) {
     
     @Override
     public int countUnique() {
-        return lookupTable.size();
+        return lookupTable.countUnique();
     }
 
     /**

File: core/src/main/java/tech/tablesaw/columns/strings/DictionaryMap.java
Patch:
@@ -45,6 +45,8 @@ public interface DictionaryMap {
 
     void clear();
 
+    int countUnique();
+
     Table countByCategory(String columnName);
 
     Selection isEqualTo(String string);

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -590,7 +590,8 @@ public IntComparator rowComparator() {
     public BooleanColumn append(Column<Boolean> column) {
         checkArgument(column.type() == this.type());
         BooleanColumn col = (BooleanColumn) column;
-        for (int i = 0; i < column.size(); i++) {
+        final int size = col.size();
+        for (int i = 0; i < size; i++) {
             append(col.getByte(i));
         }
         return this;

File: core/src/main/java/tech/tablesaw/api/DateColumn.java
Patch:
@@ -244,7 +244,8 @@ public DateColumn unique() {
     public DateColumn append(final Column<LocalDate> column) {
         Preconditions.checkArgument(column.type() == this.type());
         DateColumn dateColumn = (DateColumn) column;
-        for (int i = 0; i < dateColumn.size(); i++) {
+        final int size = dateColumn.size();
+        for (int i = 0; i < size; i++) {
             appendInternal(dateColumn.getPackedDate(i));
         }
         return this;

File: core/src/main/java/tech/tablesaw/api/DateTimeColumn.java
Patch:
@@ -437,7 +437,8 @@ public long[] asEpochMillisArray(ZoneOffset offset) {
     public DateTimeColumn append(Column<LocalDateTime> column) {
         Preconditions.checkArgument(column.type() == this.type());
         DateTimeColumn dateTimeColumn = (DateTimeColumn) column;
-        for (int i = 0; i < dateTimeColumn.size(); i++) {
+        final int size = dateTimeColumn.size();
+        for (int i = 0; i < size; i++) {
             append(dateTimeColumn.get(i));
         }
         return this;

File: core/src/main/java/tech/tablesaw/api/DoubleColumn.java
Patch:
@@ -294,7 +294,8 @@ public DoubleColumn set(int i, double val) {
     public DoubleColumn append(final Column<Double> column) {
         Preconditions.checkArgument(column.type() == this.type());
         final DoubleColumn numberColumn = (DoubleColumn) column;
-        for (int i = 0; i < numberColumn.size(); i++) {
+        final int size = numberColumn.size();
+        for (int i = 0; i < size; i++) {
             append(numberColumn.getDouble(i));
         }
         return this;

File: core/src/main/java/tech/tablesaw/api/FloatColumn.java
Patch:
@@ -215,7 +215,8 @@ public FloatColumn set(int i, float val) {
     public FloatColumn append(final Column<Float> column) {
         Preconditions.checkArgument(column.type() == this.type());
         final FloatColumn numberColumn = (FloatColumn) column;
-        for (int i = 0; i < numberColumn.size(); i++) {
+        final int size = numberColumn.size();
+        for (int i = 0; i < size; i++) {
             append(numberColumn.getFloat(i));
         }
         return this;

File: core/src/main/java/tech/tablesaw/api/IntColumn.java
Patch:
@@ -234,7 +234,8 @@ public IntColumn set(int i, int val) {
     public IntColumn append(final Column<Integer> column) {
         Preconditions.checkArgument(column.type() == this.type());
         final IntColumn numberColumn = (IntColumn) column;
-        for (int i = 0; i < numberColumn.size(); i++) {
+        final int size = numberColumn.size();
+        for (int i = 0; i < size; i++) {
             append(numberColumn.getInt(i));
         }
         return this;

File: core/src/main/java/tech/tablesaw/api/LongColumn.java
Patch:
@@ -261,7 +261,8 @@ public LongColumn set(int i, long val) {
     public LongColumn append(final Column<Long> column) {
         Preconditions.checkArgument(column.type() == this.type());
         final LongColumn numberColumn = (LongColumn) column;
-        for (int i = 0; i < numberColumn.size(); i++) {
+        final int size = numberColumn.size();
+        for (int i = 0; i < size; i++) {
             append(numberColumn.getLong(i));
         }
         return this;

File: core/src/main/java/tech/tablesaw/api/StringColumn.java
Patch:
@@ -427,8 +427,9 @@ public StringColumn copy() {
     public StringColumn append(Column<String> column) {
         Preconditions.checkArgument(column.type() == this.type());
         StringColumn source = (StringColumn) column;
-        for (String string : source) {
-            append(string);
+        final int size = source.size();
+        for (int i = 0; i < size; i++) {
+            append(source.getString(i));
         }
         return this;
     }

File: core/src/main/java/tech/tablesaw/api/TextColumn.java
Patch:
@@ -386,8 +386,9 @@ public TextColumn copy() {
     public TextColumn append(Column<String> column) {
         Preconditions.checkArgument(column.type() == this.type());
         TextColumn source = (TextColumn) column;
-        for (String string : source) {
-            append(string);
+        final int size = source.size();
+        for (int i = 0; i < size; i++) {
+            append(source.getString(i));
         }
         return this;
     }

File: core/src/main/java/tech/tablesaw/api/TimeColumn.java
Patch:
@@ -415,7 +415,8 @@ public String toString() {
     public TimeColumn append(Column<LocalTime> column) {
         Preconditions.checkArgument(column.type() == this.type());
         TimeColumn timeCol = (TimeColumn) column;
-        for (int i = 0; i < timeCol.size(); i++) {
+        final int size = timeCol.size();
+        for (int i = 0; i < size; i++) {
             appendInternal(timeCol.getIntInternal(i));
         }
         return this;

File: core/src/main/java/tech/tablesaw/columns/strings/ByteDictionaryMap.java
Patch:
@@ -178,8 +178,8 @@ public int firstIndexOf(String value) {
 
     @Override
     public Object[] asObjectArray() {
-        final String[] output = new String[values().size()];
-        for (int i = 0; i < values().size(); i++) {
+        final String[] output = new String[size()];
+        for (int i = 0; i < size(); i++) {
             output[i] = getValueForIndex(i);
         }
         return output;

File: core/src/main/java/tech/tablesaw/columns/strings/IntDictionaryMap.java
Patch:
@@ -181,8 +181,8 @@ public int firstIndexOf(String value) {
 
     @Override
     public Object[] asObjectArray() {
-        final String[] output = new String[values().size()];
-        for (int i = 0; i < values().size(); i++) {
+        final String[] output = new String[size()];
+        for (int i = 0; i < size(); i++) {
             output[i] = getValueForIndex(i);
         }
         return output;

File: core/src/main/java/tech/tablesaw/columns/strings/ShortDictionaryMap.java
Patch:
@@ -186,8 +186,8 @@ public int firstIndexOf(String value) {
 
     @Override
     public Object[] asObjectArray() {
-        final String[] output = new String[values().size()];
-        for (int i = 0; i < values().size(); i++) {
+        final String[] output = new String[size()];
+        for (int i = 0; i < size(); i++) {
             output[i] = getValueForIndex(i);
         }
         return output;

File: core/src/test/java/tech/tablesaw/joining/DataFrameJoinerTest.java
Patch:
@@ -496,7 +496,6 @@ public void innerJoinWithBoolean() {
                 .inner(true, DUPLICATE_COL_NAME_DOGS.copy());
         assertEquals(5, joined.columnCount());
         assertEquals(32, joined.rowCount());
-        System.out.println(joined.printAll());
     }
 
     @Test

File: core/src/main/java/tech/tablesaw/columns/strings/ByteDictionaryMap.java
Patch:
@@ -250,7 +250,8 @@ public void set(int rowIndex, String stringValue) throws NoKeysAvailableExceptio
             str = stringValue;
         }
         byte valueId = getKeyForValue(str);
-        if (valueId == DEFAULT_RETURN_VALUE) {
+
+        if (valueId == DEFAULT_RETURN_VALUE) { // this is a new value not in dictionary
             valueId = getValueId();
             put(valueId, str);
         }
@@ -405,7 +406,6 @@ public DictionaryMap promoteYourself() {
             // this should never happen;
             throw new RuntimeException(e);
         }
-
         return dictionaryMap;
     }
 }

File: core/src/main/java/tech/tablesaw/table/TableSliceGroup.java
Patch:
@@ -151,7 +151,7 @@ public Table aggregate(String colName1, AggregateFunction<?,?>... functions) {
     public Table aggregate(ListMultimap<String, AggregateFunction<?,?>> functions) {
         Preconditions.checkArgument(!getSlices().isEmpty());
         Table groupTable = summaryTableName(sourceTable);
-        StringColumn groupColumn = StringColumn.create("Group", size());
+        StringColumn groupColumn = StringColumn.create("Group");
         groupTable.addColumns(groupColumn);
         for (Map.Entry<String, Collection<AggregateFunction<?,?>>> entry : functions.asMap().entrySet()) {
             String columnName = entry.getKey();

File: core/src/test/java/tech/tablesaw/api/TableTest.java
Patch:
@@ -495,7 +495,7 @@ private DoubleColumn sum(DoubleColumn... columns) {
             for (NumberColumn<Double> nc : columns) {
                 sum += nc.get(r);
             }
-            result.append(sum);
+            result.set(r, sum);
         }
         return result;
     }

File: core/src/test/java/tech/tablesaw/table/RollingColumnTest.java
Patch:
@@ -50,7 +50,8 @@ public void testRollingMaxDate() {
     public void testRollingCountTrue() {
         Boolean[] data = new Boolean[]{true, false, false, true, true};
 
-        DoubleColumn result = (DoubleColumn) BooleanColumn.create("data", data).rolling(2).calc(countTrue);
+        BooleanColumn booleanColumn = BooleanColumn.create("data", data);
+        DoubleColumn result = (DoubleColumn) booleanColumn.rolling(2).calc(countTrue);
 
         assertEquals(Double.NaN, result.getDouble(0), 0.0);
         assertEquals(1, result.getDouble(1), 0.0);

File: core/src/main/java/tech/tablesaw/api/LongColumn.java
Patch:
@@ -348,7 +348,7 @@ public LongColumn appendCell(final String value) {
     @Override
     public LongColumn appendCell(final String value, AbstractParser<?> parser) {
         try {
-            return append(parser.parseInt(value));
+            return append(parser.parseLong(value));
         } catch (final NumberFormatException e) {
             throw new NumberFormatException("Error adding value to column " + name()  + ": " + e.getMessage());
         }

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -47,6 +47,7 @@
 import static tech.tablesaw.api.ColumnType.BOOLEAN;
 import static tech.tablesaw.api.ColumnType.DOUBLE;
 import static tech.tablesaw.api.ColumnType.FLOAT;
+import static tech.tablesaw.api.ColumnType.LONG;
 import static tech.tablesaw.api.ColumnType.INTEGER;
 import static tech.tablesaw.api.ColumnType.LOCAL_DATE;
 import static tech.tablesaw.api.ColumnType.LOCAL_DATE_TIME;
@@ -92,7 +93,7 @@ public class CsvReader {
      * the integer test would never be evaluated and all the ints would be read as doubles.
      */
     private List<ColumnType> typeArray =
-            Lists.newArrayList(LOCAL_DATE_TIME, LOCAL_TIME, LOCAL_DATE, BOOLEAN, SHORT, INTEGER, FLOAT, DOUBLE, STRING, TEXT);
+            Lists.newArrayList(LOCAL_DATE_TIME, LOCAL_TIME, LOCAL_DATE, BOOLEAN, SHORT, INTEGER, LONG, FLOAT, DOUBLE, STRING, TEXT);
 
     /**
      * Constructs a CsvReader

File: core/src/main/java/tech/tablesaw/aggregate/AggregateFunctions.java
Patch:
@@ -385,7 +385,7 @@ public static Double percentile(NumericColumn<?> data, Double percentile) {
     public static final NumericAggregateFunction standardDeviation = stdDev;
 
     private static double[] removeMissing(NumericColumn<?> column) {
-        NumericColumn<?> numericColumn = (NumericColumn) column.removeMissing();
+        NumericColumn<?> numericColumn = (NumericColumn<?>) column.removeMissing();
         return numericColumn.asDoubleArray();
     }
 

File: core/src/main/java/tech/tablesaw/columns/strings/NoKeysAvailableException.java
Patch:
@@ -2,6 +2,8 @@
 
 public class NoKeysAvailableException extends Exception {
 
+    private static final long serialVersionUID = 1L;
+
     public NoKeysAvailableException(String message) {
         super(message);
     }

File: core/src/main/java/tech/tablesaw/table/Relation.java
Patch:
@@ -319,8 +319,7 @@ public StringColumn[] stringColumns() {
         return columns().stream().filter(e->e.type() == ColumnType.STRING).toArray(StringColumn[]::new);
     }
 
-    @SuppressWarnings("rawtypes")
-    public NumericColumn[] numberColumns() {
+    public NumericColumn<?>[] numberColumns() {
         return columns().stream().filter(e->e instanceof NumericColumn<?>).toArray(NumericColumn[]::new);
     }
 

File: core/src/test/java/tech/tablesaw/api/TableTest.java
Patch:
@@ -94,7 +94,6 @@ public void testRowWiseAddition() {
     }
 
     @Test
-    @SuppressWarnings("unchecked")
     public void testRowWiseAddition2() {
         double[] a = {3, 4, 5};
         double[] b = {3, 4, 5};
@@ -488,7 +487,7 @@ public void testIterable() throws Exception {
         }
     }
 
-    private DoubleColumn sum(NumberColumn<Double> ... columns) {
+    private DoubleColumn sum(DoubleColumn... columns) {
         int size = columns[0].size();
         DoubleColumn result = DoubleColumn.create("sum", size);
         for (int r = 0; r < size; r++) {

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -313,7 +313,7 @@ private Table detectedColumnTypes(String csvFileName, boolean header, char delim
                     .separator(delimiter)
                     .header(header)
                     .locale(locale)
-                    .sample(false)
+                    .sample(true)
                     .build();
             ColumnType[] types = detectColumnTypes(stream, options);
             Table t = headerOnly(types, header, options, file);

File: core/src/main/java/tech/tablesaw/api/TextColumn.java
Patch:
@@ -41,6 +41,8 @@
 /**
  * A column that contains String values. They are assumed to be free-form text. For categorical data, use stringColumn
  * <p>
+ * This is the default column type for SQL longvarchar and longnvarchar types
+ * <p>
  * Because the MISSING_VALUE for this column type is an empty string, there is little or no need for special handling
  * of missing values in this class's methods.
  */

File: core/src/main/java/tech/tablesaw/io/jdbc/SqlResultSetReader.java
Patch:
@@ -58,11 +58,11 @@ private static Map<Integer, ColumnType> initializeMap() {
                 .put(Types.BIGINT, ColumnType.DOUBLE)
 
                 .put(Types.CHAR, ColumnType.STRING)
-                .put(Types.LONGVARCHAR, ColumnType.STRING)
-                .put(Types.LONGNVARCHAR, ColumnType.STRING)
                 .put(Types.NCHAR, ColumnType.STRING)
                 .put(Types.NVARCHAR, ColumnType.STRING)
                 .put(Types.VARCHAR, ColumnType.STRING)
+                .put(Types.LONGVARCHAR, ColumnType.TEXT)
+                .put(Types.LONGNVARCHAR, ColumnType.TEXT)
                 .build());
     }
 

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -51,6 +51,7 @@
 import static tech.tablesaw.api.ColumnType.LOCAL_TIME;
 import static tech.tablesaw.api.ColumnType.SKIP;
 import static tech.tablesaw.api.ColumnType.STRING;
+import static tech.tablesaw.api.ColumnType.TEXT;
 
 @Immutable
 public class CsvReader {
@@ -64,7 +65,7 @@ public class CsvReader {
      * the integer test would never be evaluated and all the ints would be read as doubles.
      */
     private List<ColumnType> typeArray =
-            Lists.newArrayList(LOCAL_DATE_TIME, LOCAL_TIME, LOCAL_DATE, BOOLEAN, INTEGER, FLOAT, DOUBLE, STRING);
+            Lists.newArrayList(LOCAL_DATE_TIME, LOCAL_TIME, LOCAL_DATE, BOOLEAN, INTEGER, FLOAT, DOUBLE, STRING, TEXT);
 
     /**
      * Constructs a CsvReader

File: core/src/main/java/tech/tablesaw/table/Relation.java
Patch:
@@ -317,6 +317,7 @@ public StringColumn[] stringColumns() {
         return columns().stream().filter(e->e.type() == ColumnType.STRING).toArray(StringColumn[]::new);
     }
 
+    @SuppressWarnings("rawtypes")
     public NumericColumn[] numberColumns() {
         return columns().stream().filter(e->e instanceof NumericColumn<?>).toArray(NumericColumn[]::new);
     }

File: jsplot/src/main/java/tech/tablesaw/plotly/api/Histogram.java
Patch:
@@ -11,7 +11,7 @@ public class Histogram {
     private static final int HEIGHT = 600;
     private static final int WIDTH = 800;
 
-    public static Figure create(String title, NumberColumn data) {
+    public static Figure create(String title, NumberColumn<?> data) {
         return create(title, data.asDoubleArray());
     }
 

File: jsplot/src/main/java/tech/tablesaw/plotly/api/TimeSeriesPlot.java
Patch:
@@ -49,7 +49,7 @@ public static Figure create(String title, Table table, String dateColXName, Stri
         return new Figure(layout, trace);
     }
 
-    public static Figure create(String title, String xTitle, DateColumn xCol, String yTitle, NumberColumn yCol) {
+    public static Figure create(String title, String xTitle, DateColumn xCol, String yTitle, NumberColumn<?> yCol) {
 
         Layout layout = standardLayout(title, xTitle, yTitle);
 

File: jsplot/src/main/java/tech/tablesaw/plotly/components/Marker.java
Patch:
@@ -164,7 +164,7 @@ public MarkerBuilder size(double ... size) {
             return this;
         }
 
-        public MarkerBuilder size(NumberColumn size) {
+        public MarkerBuilder size(NumberColumn<?> size) {
             return size(size.asDoubleArray());
         }
 

File: jsplot/src/main/java/tech/tablesaw/plotly/traces/BarTrace.java
Patch:
@@ -29,7 +29,7 @@ public static BarBuilder builder(Object[] x, double[] y) {
         return new BarBuilder(x, y);
     }
 
-    public static BarBuilder builder(CategoricalColumn x, Column<? extends Number> y) {
+    public static BarBuilder builder(CategoricalColumn<?> x, Column<? extends Number> y) {
         return new BarBuilder(x, y);
     }
 
@@ -91,7 +91,7 @@ public static class BarBuilder extends TraceBuilder {
             this.y = y;
         }
 
-        BarBuilder(CategoricalColumn x, Column<? extends Number> y) {
+        BarBuilder(CategoricalColumn<?> x, Column<? extends Number> y) {
 
             this.x = TraceBuilder.columnToStringArray(x);
             this.y = y.asDoubleArray();

File: jsplot/src/main/java/tech/tablesaw/plotly/traces/BoxTrace.java
Patch:
@@ -27,7 +27,7 @@ public static BoxBuilder builder(Object[] x, double[] y) {
         return new BoxBuilder(x, y);
     }
 
-    public static BoxBuilder builder(CategoricalColumn x, Column<? extends Number> y) {
+    public static BoxBuilder builder(CategoricalColumn<?> x, Column<? extends Number> y) {
         return new BoxBuilder(x, y);
     }
 
@@ -73,7 +73,7 @@ public static class BoxBuilder extends TraceBuilder {
             this.y = y;
         }
 
-        BoxBuilder(CategoricalColumn x, Column<? extends Number> y) {
+        BoxBuilder(CategoricalColumn<?> x, Column<? extends Number> y) {
             this.x = columnToStringArray(x);
             this.y = y.asDoubleArray();
         }

File: jsplot/src/main/java/tech/tablesaw/plotly/traces/PieTrace.java
Patch:
@@ -51,7 +51,7 @@ public static PieBuilder builder(Object[] labels, double[] values) {
         return new PieBuilder(labels, values);
     }
 
-    public static PieBuilder builder(CategoricalColumn labels, Column<? extends Number> values) {
+    public static PieBuilder builder(CategoricalColumn<?> labels, Column<? extends Number> values) {
         return new PieBuilder(TraceBuilder.columnToStringArray(labels), values.asDoubleArray());
     }
 

File: core/src/test/java/tech/tablesaw/io/csv/CsvReadPerformanceTest.java
Patch:
@@ -69,7 +69,7 @@ public static void main(String[] args) throws Exception {
         Table details = Table.read().csv("../data/SHR76_16.csv");
         stopwatch.stop();
         //System.out.println(details.structure().printAll());
-        System.out.println("Large file (752,313 rows) read: " + stopwatch.elapsed(TimeUnit.MILLISECONDS) + " ms");
+        System.out.println("Large file (752,313 rows) read: " + stopwatch.elapsed(TimeUnit.MILLISECONDS) + " ms with type detection.");
         System.out.println(details.shape());
 
         // TODO (white) printColumnTypes is broken or very slow
@@ -82,7 +82,7 @@ public static void main(String[] args) throws Exception {
                         .columnTypes(types).build());
         stopwatch.stop();
         System.out.println(details.shape());
-        System.out.println("Large file (752,313 rows) read: " + stopwatch.elapsed(TimeUnit.MILLISECONDS) + " ms with type detection.");
+        System.out.println("Large file (752,313 rows) read: " + stopwatch.elapsed(TimeUnit.MILLISECONDS) + " ms without type detection.");
 
     }
 }

File: core/src/main/java/tech/tablesaw/columns/Column.java
Patch:
@@ -303,7 +303,7 @@ default String print() {
     }
 
     /**
-     * Create a copy of this column where values matching the selection are replaced with the corresponding value
+     * Updates this column where values matching the selection are replaced with the corresponding value
      * from the given column
      */
     default Column<T> set(Selection condition, Column<T> other) {

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -157,7 +157,7 @@ private void addRows(CsvReadOptions options, ColumnType[] types, CsvParser reade
         long rowNumber = options.header() ? 1L : 0L;
         String[] nextLine;
 
-        Map<String, StringParser<?>> parserMap = getParserMap(options, table, columnIndexes);
+        Map<String, StringParser<?>> parserMap = getParserMap(options, table);
 
         // Add the rows
         while ((nextLine = reader.parseNext()) != null) {
@@ -192,7 +192,7 @@ private void addRows(CsvReadOptions options, ColumnType[] types, CsvParser reade
         }
     }
 
-    private Map<String, StringParser<?>> getParserMap(CsvReadOptions options, Table table, int[] columnIndexes) {
+    private Map<String, StringParser<?>> getParserMap(CsvReadOptions options, Table table) {
         Map<String, StringParser<?>> parserMap = new HashMap<>();
         for (Column<?> column : table.columns()) {
             StringParser<?> parser = column.type().customParser(options);

File: core/src/main/java/tech/tablesaw/aggregate/NumericAggregateFunction.java
Patch:
@@ -1,12 +1,12 @@
 package tech.tablesaw.aggregate;
 
 import tech.tablesaw.api.ColumnType;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.NumericColumn;
 
 /**
  * A partial implementation of aggregate functions to summarize over a numeric column
  */
-public abstract class NumericAggregateFunction extends AggregateFunction<NumberColumn, Double> {
+public abstract class NumericAggregateFunction extends AggregateFunction<NumericColumn<?>, Double> {
 
     public NumericAggregateFunction(String name) {
         super(name);

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -162,7 +162,7 @@ public Table summary() {
         Table table = Table.create(name());
 
         BooleanColumn booleanColumn = create("Value");
-        NumberColumn countColumn = NumberColumn.create("Count");
+        DoubleColumn countColumn = DoubleColumn.create("Count");
         table.addColumns(booleanColumn);
         table.addColumns(countColumn);
 
@@ -636,8 +636,8 @@ public int[] asIntArray() {
         return output;
     }
 
-    public NumberColumn asNumberColumn() {
-        NumberColumn numberColumn = NumberColumn.create(this.name() + ": ints", size());
+    public DoubleColumn asNumberColumn() {
+        DoubleColumn numberColumn = DoubleColumn.create(this.name() + ": ints", size());
         ByteArrayList data = data();
         for (int i = 0; i < size(); i++) {
             numberColumn.append(data.getByte(i));

File: core/src/main/java/tech/tablesaw/api/CategoricalColumn.java
Patch:
@@ -44,7 +44,7 @@ default Table countByCategory() {
 
         final Table t = new Table("Column: " + name());
         final CategoricalColumn<?> categories = (CategoricalColumn<?>) type().create("Category");
-        final NumberColumn counts = NumberColumn.create("Count");
+        final IntColumn counts = IntColumn.create("Count");
 
         final Object2IntMap<String> valueToCount = new Object2IntOpenHashMap<>();
 

File: core/src/main/java/tech/tablesaw/api/StringColumn.java
Patch:
@@ -224,7 +224,7 @@ public Table summary() {
     public Table countByCategory() {
         Table t = new Table("Column: " + name());
         StringColumn categories = create("Category");
-        NumberColumn counts = NumberColumn.create("Count");
+        IntColumn counts = IntColumn.create("Count");
 
         Int2IntMap valueToCount = new Int2IntOpenHashMap();
 
@@ -511,8 +511,8 @@ public IntArrayList data() {
     }
 
 
-    public NumberColumn asNumberColumn() {
-        NumberColumn numberColumn = NumberColumn.create(this.name() + ": codes", size());
+    public DoubleColumn asNumberColumn() {
+        DoubleColumn numberColumn = DoubleColumn.create(this.name() + ": codes", size());
         IntArrayList data = data();
         for (int i = 0; i < size(); i++) {
             numberColumn.append(data.getInt(i));

File: core/src/main/java/tech/tablesaw/columns/StringParser.java
Patch:
@@ -45,7 +45,7 @@ public byte parseByte(String s) {
     }
 
     public int parseInt(String s) {
-        throw new UnsupportedOperationException(this.getClass().getSimpleName() + " doesn't support parsing to booleans");
+        throw new UnsupportedOperationException(this.getClass().getSimpleName() + " doesn't support parsing to ints");
     }
 
     public double parseDouble(String s) {

File: core/src/main/java/tech/tablesaw/columns/numbers/FloatDataWrapper.java
Patch:
@@ -32,8 +32,8 @@ public NumberIterator numberIterator() {
     }
 
     @Override
-    public Iterator<Double> iterator() {
-        return new NumberIterator(data).iterator();
+    public Iterator<Float> iterator() {
+        return data.iterator();
     }
 
     @Override

File: core/src/main/java/tech/tablesaw/columns/numbers/IntDataWrapper.java
Patch:
@@ -33,8 +33,8 @@ public NumberIterator numberIterator() {
     }
 
     @Override
-    public Iterator<Double> iterator() {
-        return new NumberIterator(data).iterator();
+    public Iterator<Integer> iterator() {
+        return data.iterator();
     }
 
     @Override

File: core/src/main/java/tech/tablesaw/columns/numbers/NumberIterable.java
Patch:
@@ -1,6 +1,6 @@
 package tech.tablesaw.columns.numbers;
 
-public interface NumberIterable extends Iterable<Double> {
+public interface NumberIterable {
 
     NumberIterator numberIterator();
 }

File: core/src/main/java/tech/tablesaw/columns/numbers/NumericDataWrapper.java
Patch:
@@ -1,10 +1,10 @@
 package tech.tablesaw.columns.numbers;
 
+import java.util.Iterator;
+
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.columns.StringParser;
 
-import java.util.Iterator;
-
 public interface NumericDataWrapper extends NumberIterable {
 
     int size();
@@ -52,7 +52,7 @@ public interface NumericDataWrapper extends NumberIterable {
 
     NumberIterator numberIterator();
 
-    Iterator<Double> iterator();
+    Iterator<?> iterator();
 
     NumericDataWrapper top(final int n);
 

File: core/src/main/java/tech/tablesaw/columns/numbers/fillers/DoubleRangeIterable.java
Patch:
@@ -41,7 +41,6 @@ public static DoubleRangeIterable range(final double from, final int count) {
         return range(from, 1.0, count);
     }
 
-    @Override
     public DoubleIterator iterator() {
 
         return new DoubleIterator() {

File: core/src/main/java/tech/tablesaw/index/DoubleIndex.java
Patch:
@@ -18,7 +18,7 @@
 import it.unimi.dsi.fastutil.doubles.Double2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.doubles.Double2ObjectSortedMap;
 import it.unimi.dsi.fastutil.ints.IntArrayList;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.selection.BitmapBackedSelection;
 import tech.tablesaw.selection.Selection;
 
@@ -29,7 +29,7 @@ public class DoubleIndex {
 
     private final Double2ObjectAVLTreeMap<IntArrayList> index;
 
-    public DoubleIndex(NumberColumn column) {
+    public DoubleIndex(DoubleColumn column) {
         int sizeEstimate = Integer.min(1_000_000, column.size() / 100);
         Double2ObjectOpenHashMap<IntArrayList> tempMap = new Double2ObjectOpenHashMap<>(sizeEstimate);
         for (int i = 0; i < column.size(); i++) {

File: core/src/main/java/tech/tablesaw/index/FloatIndex.java
Patch:
@@ -18,7 +18,7 @@
 import it.unimi.dsi.fastutil.floats.Float2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.floats.Float2ObjectSortedMap;
 import it.unimi.dsi.fastutil.ints.IntArrayList;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.selection.BitmapBackedSelection;
 import tech.tablesaw.selection.Selection;
 
@@ -29,7 +29,7 @@ public class FloatIndex {
 
     private final Float2ObjectAVLTreeMap<IntArrayList> index;
 
-    public FloatIndex(NumberColumn column) {
+    public FloatIndex(DoubleColumn column) {
         int sizeEstimate = Integer.min(1_000_000, column.size() / 100);
         Float2ObjectOpenHashMap<IntArrayList> tempMap = new Float2ObjectOpenHashMap<>(sizeEstimate);
         for (int i = 0; i < column.size(); i++) {

File: core/src/main/java/tech/tablesaw/index/LongIndex.java
Patch:
@@ -19,7 +19,7 @@
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectSortedMap;
 import tech.tablesaw.api.DateTimeColumn;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.columns.datetimes.PackedLocalDateTime;
 import tech.tablesaw.selection.BitmapBackedSelection;
 import tech.tablesaw.selection.Selection;
@@ -51,7 +51,7 @@ public LongIndex(DateTimeColumn column) {
         index = new Long2ObjectAVLTreeMap<>(tempMap);
     }
 
-    public LongIndex(NumberColumn column) {
+    public LongIndex(DoubleColumn column) {
         int sizeEstimate = Integer.min(1_000_000, column.size() / 100);
         Long2ObjectOpenHashMap<IntArrayList> tempMap = new Long2ObjectOpenHashMap<>(sizeEstimate);
         for (int i = 0; i < column.size(); i++) {

File: core/src/main/java/tech/tablesaw/table/RollingColumn.java
Patch:
@@ -1,7 +1,7 @@
 package tech.tablesaw.table;
 
 import tech.tablesaw.aggregate.AggregateFunction;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.selection.BitmapBackedSelection;
 import tech.tablesaw.selection.Selection;
@@ -43,7 +43,7 @@ public <INCOL extends Column<?>,OUT> Column<?> calc(AggregateFunction<INCOL,OUT>
             OUT answer = function.summarize(subsetCol);
             if (answer instanceof Number) {
                 Number number = (Number) answer;
-                ((NumberColumn) result).append(number.doubleValue());
+                ((DoubleColumn) result).append(number.doubleValue());
             } else {
                 result.appendObj(answer);
             }

File: core/src/test/java/tech/tablesaw/api/DateColumnTest.java
Patch:
@@ -75,7 +75,7 @@ public void testDayOfMonth() {
         column1.appendCell("12/24/1924");
         column1.appendCell("12-May-2015");
         column1.appendCell("14-Jan-2015");
-        NumberColumn c2 = column1.dayOfMonth();
+        IntColumn c2 = column1.dayOfMonth();
         assertEquals(23, c2.get(0), 0.0001);
         assertEquals(24, c2.get(1), 0.0001);
         assertEquals(12, c2.get(2), 0.0001);
@@ -88,7 +88,7 @@ public void testMonth() {
         column1.appendCell("12/24/1924");
         column1.appendCell("12-May-2015");
         column1.appendCell("14-Jan-2015");
-        NumberColumn c2 = column1.monthValue();
+        IntColumn c2 = column1.monthValue();
         assertEquals(10, c2.get(0), 0.0001);
         assertEquals(12, c2.get(1), 0.0001);
         assertEquals(5, c2.get(2), 0.0001);
@@ -113,7 +113,7 @@ public void testYear() {
         column1.appendCell("2013-10-23");
         column1.appendCell("12/24/1924");
         column1.appendCell("12-May-2015");
-        NumberColumn c2 = column1.year();
+        IntColumn c2 = column1.year();
         assertEquals(2013, c2.get(0), 0.0001);
         assertEquals(1924, c2.get(1), 0.0001);
         assertEquals(2015, c2.get(2), 0.0001);

File: core/src/test/java/tech/tablesaw/api/DateTimeColumnTest.java
Patch:
@@ -57,7 +57,7 @@ public void testAppendCell2() {
     @Test
     public void testConvertMillisSinceEpoch() {
         long millis = 1503952123189L;
-        NumberColumn dc = NumberColumn.create("test");
+        DoubleColumn dc = DoubleColumn.create("test");
         dc.appendCell(Long.toString(millis));
         DateTimeColumn column2 = dc.asDateTimes(ZoneOffset.UTC);
 

File: core/src/test/java/tech/tablesaw/api/StringColumnTest.java
Patch:
@@ -288,7 +288,7 @@ public void testDistance() {
         String[] words2 = {"cancel", "bananas", "islander", "calypso"};
         StringColumn wordColumn = StringColumn.create("words", words);
         StringColumn word2Column = StringColumn.create("words2", words2);
-        NumberColumn distance = wordColumn.distance(word2Column);
+        DoubleColumn distance = wordColumn.distance(word2Column);
         assertEquals(distance.get(0), 3, 0.0001);
         assertEquals(distance.get(3), 7, 0.0001);
     }

File: core/src/test/java/tech/tablesaw/columns/numbers/NumberFillersTest.java
Patch:
@@ -1,7 +1,7 @@
 package tech.tablesaw.columns.numbers;
 
 import static org.junit.Assert.assertEquals;
-import static tech.tablesaw.api.NumberColumn.create;
+import static tech.tablesaw.api.DoubleColumn.create;
 import static tech.tablesaw.columns.numbers.fillers.DoubleRangeIterable.range;
 
 import org.junit.Test;

File: core/src/test/java/tech/tablesaw/columns/strings/StringFiltersTest.java
Patch:
@@ -17,7 +17,7 @@
 import com.google.common.collect.Lists;
 import org.junit.Before;
 import org.junit.Test;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
 
@@ -257,7 +257,7 @@ public void testIsNotEqualTo() {
     public void testCountWords() {
         final String[] words1 = {"one", "two words"};
         final StringColumn stringColumn1 = StringColumn.create("words", words1);
-        NumberColumn nc = stringColumn1.countTokens(" ");
+        DoubleColumn nc = stringColumn1.countTokens(" ");
         assertEquals( 3, nc.sum(), 0.00001);
     }
 }

File: core/src/test/java/tech/tablesaw/index/DoubleIndexTest.java
Patch:
@@ -45,7 +45,7 @@ public void setUp() throws Exception {
                                 ColumnType.STRING,
                                 ColumnType.DOUBLE,
                                 ColumnType.DOUBLE}));
-        index = new DoubleIndex(table.numberColumn("stop_lat"));
+        index = new DoubleIndex(table.doubleColumn("stop_lat"));
     }
 
     @Test

File: core/src/test/java/tech/tablesaw/io/DataFrameWriterTest.java
Patch:
@@ -1,7 +1,7 @@
 package tech.tablesaw.io;
 
 import org.junit.Test;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.Table;
 
 import java.io.ByteArrayOutputStream;
@@ -15,8 +15,8 @@ public class DataFrameWriterTest {
     private double[] v1 = {1, 2, 3, 4, 5, NaN};
     private double[] v2 = {1, 2, 3, 4, 5, NaN};
     private Table table = Table.create("t",
-            NumberColumn.create("v", v1),
-            NumberColumn.create("v2", v2)
+            DoubleColumn.create("v", v1),
+            DoubleColumn.create("v2", v2)
     );
 
     @Test

File: core/src/test/java/tech/tablesaw/io/string/DataFramePrinterTest.java
Patch:
@@ -1,7 +1,7 @@
 package tech.tablesaw.io.string;
 
 import org.junit.Test;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.Table;
 
 import static org.hamcrest.CoreMatchers.containsString;
@@ -11,7 +11,7 @@ public class DataFramePrinterTest {
 
     @Test
     public void printNull() {
-        NumberColumn col = NumberColumn.create("testCol");
+        DoubleColumn col = DoubleColumn.create("testCol");
         col.append(5.0);
         col.appendCell(null);
         col.append(3.0);

File: core/src/test/java/tech/tablesaw/table/RollingColumnTest.java
Patch:
@@ -3,7 +3,7 @@
 import org.junit.Test;
 import tech.tablesaw.api.BooleanColumn;
 import tech.tablesaw.api.DateTimeColumn;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.columns.numbers.DoubleColumnType;
 
 import java.time.LocalDate;
@@ -19,7 +19,7 @@ public void testRollingMean() {
         double[] data = new double[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
         double missing = DoubleColumnType.missingValueIndicator();
         double[] sma5 = new double[]{missing, missing, missing, missing, 3, 4, 5, 6, 7, 8};
-        NumberColumn result = NumberColumn.create("data", data).rolling(5).mean();
+        DoubleColumn result = DoubleColumn.create("data", data).rolling(5).mean();
         assertArrayEquals(sma5, result.asDoubleArray(), 0.000001);
         assertEquals("dataMean5", result.name());
     }
@@ -50,7 +50,7 @@ public void testRollingMaxDate() {
     public void testRollingCountTrue() {
         Boolean[] data = new Boolean[]{true, false, false, true, true};
 
-        NumberColumn result = (NumberColumn) BooleanColumn.create("data", data).rolling(2).calc(countTrue);
+        DoubleColumn result = (DoubleColumn) BooleanColumn.create("data", data).rolling(2).calc(countTrue);
 
         assertEquals(Double.NaN, result.getDouble(0), 0.0);
         assertEquals(1, result.getDouble(1), 0.0);

File: core/src/test/java/tech/tablesaw/util/DoubleArraysTest.java
Patch:
@@ -28,7 +28,7 @@ public class DoubleArraysTest {
     @Test
     public void testTo2dArray() throws Exception {
         Table table = Table.read().csv("../data/tornadoes_1950-2014.csv");
-        TableSliceGroup tableSliceGroup = table.splitOn(table.numberColumn("Scale"));
+        TableSliceGroup tableSliceGroup = table.splitOn("Scale");
         int columnNuumber = table.columnIndex("Injuries");
         DoubleArrays.to2dArray(tableSliceGroup, columnNuumber);
     }

File: jsplot/src/main/java/tech/tablesaw/plotly/api/Heatmap.java
Patch:
@@ -28,7 +28,7 @@ public static Figure create(String title, Table table, String categoryCol1, Stri
         counts = counts.dropRows(counts.rowCount() - 1);
         List<Column<?>> columns = counts.columns();
         columns.remove(counts.columnCount() - 1);
-        Column yColumn = columns.remove(0);
+        Column<?> yColumn = columns.remove(0);
         double[][] z = DoubleArrays.to2dArray(columns);
 
         List<String> x = counts.columnNames();

File: jsplot/src/main/java/tech/tablesaw/plotly/traces/TraceBuilder.java
Patch:
@@ -72,7 +72,7 @@ protected TraceBuilder hoverLabel(HoverLabel hoverLabel) {
         return this;
     }
 
-    static String[] columnToStringArray(Column column) {
+    static String[] columnToStringArray(Column<?> column) {
         String[] x = new String[column.size()];
         for (int i = 0; i < column.size(); i++) {
             x[i] = column.getString(i);

File: core/src/examples/java/tech/tablesaw/TornadoExample.java
Patch:
@@ -34,8 +34,7 @@ public static void main(String[] args) throws Exception {
 
         Table structure = tornadoes.structure();
         out(structure);
-        out(structure.where(
-                structure.stringColumn("Column Type").isEqualTo("DOUBLE")));
+        out(structure.where(structure.stringColumn("Column Type").isEqualTo("DOUBLE")));
 
         tornadoes.setName("tornadoes");
 

File: core/src/main/java/tech/tablesaw/aggregate/AggregateFunction.java
Patch:
@@ -24,7 +24,7 @@ public String toString() {
         return functionName();
     }
 
-    public abstract boolean isCompatableColumn(ColumnType type);
+    public abstract boolean isCompatibleColumn(ColumnType type);
 
     public abstract ColumnType returnType();
 }

File: core/src/main/java/tech/tablesaw/aggregate/BooleanAggregateFunction.java
Patch:
@@ -15,7 +15,7 @@ public BooleanAggregateFunction(String name) {
     abstract public Boolean summarize(BooleanColumn column);
 
     @Override
-    public boolean isCompatableColumn(ColumnType type) {
+    public boolean isCompatibleColumn(ColumnType type) {
         return type == ColumnType.BOOLEAN;
     }
 

File: core/src/main/java/tech/tablesaw/aggregate/BooleanCountFunction.java
Patch:
@@ -13,7 +13,7 @@ public BooleanCountFunction(String functionName) {
     abstract public Integer summarize(BooleanColumn column);
 
     @Override
-    public boolean isCompatableColumn(ColumnType type) {
+    public boolean isCompatibleColumn(ColumnType type) {
         return type.equals(ColumnType.BOOLEAN);
     }
 

File: core/src/main/java/tech/tablesaw/aggregate/BooleanNumericFunction.java
Patch:
@@ -13,7 +13,7 @@ public BooleanNumericFunction(String functionName) {
     abstract public Double summarize(BooleanColumn column);
 
     @Override
-    public boolean isCompatableColumn(ColumnType type) {
+    public boolean isCompatibleColumn(ColumnType type) {
         return type.equals(ColumnType.BOOLEAN);
     }
 

File: core/src/main/java/tech/tablesaw/aggregate/CountFunction.java
Patch:
@@ -13,7 +13,7 @@ public CountFunction(String functionName) {
     abstract public Integer summarize(Column<?> column);
 
     @Override
-    public boolean isCompatableColumn(ColumnType type) {
+    public boolean isCompatibleColumn(ColumnType type) {
         return true;
     }
 

File: core/src/main/java/tech/tablesaw/aggregate/DateAggregateFunction.java
Patch:
@@ -17,7 +17,7 @@ public DateAggregateFunction(String name) {
     abstract public LocalDate summarize(DateColumn column);
 
     @Override
-    public boolean isCompatableColumn(ColumnType type) {
+    public boolean isCompatibleColumn(ColumnType type) {
         return type.equals(ColumnType.LOCAL_DATE);
     }
 

File: core/src/main/java/tech/tablesaw/aggregate/DateTimeAggregateFunction.java
Patch:
@@ -17,7 +17,7 @@ public DateTimeAggregateFunction(String name) {
     abstract public LocalDateTime summarize(DateTimeColumn column);
 
     @Override
-    public boolean isCompatableColumn(ColumnType type) {
+    public boolean isCompatibleColumn(ColumnType type) {
         return type.equals(ColumnType.LOCAL_DATE_TIME);
     }
 

File: core/src/main/java/tech/tablesaw/aggregate/StringFunction.java
Patch:
@@ -15,7 +15,7 @@ public StringFunction(String name) {
     abstract public String summarize(StringColumn column);
 
     @Override
-    public boolean isCompatableColumn(ColumnType type) {
+    public boolean isCompatibleColumn(ColumnType type) {
         return type.equals(ColumnType.STRING);
     }
 

File: core/src/main/java/tech/tablesaw/aggregate/Summarizer.java
Patch:
@@ -200,7 +200,7 @@ private Table summarize(TableSliceGroup group) {
 
         for (String name : reductionMultimap.keys()) {
             List<AggregateFunction<?, ?>> reductions = reductionMultimap.get(name);
-            results.add(group.aggregate(name, reductions.toArray(new AggregateFunction[0])));
+            results.add(group.aggregate(name, reductions.toArray(new AggregateFunction<?, ?>[0])));
         }
         return combineTables(results);
     }
@@ -211,7 +211,7 @@ private Table summarize(TableSliceGroup group) {
             Column<?> column = temp.column(name);
             ColumnType type = column.type();
             for (AggregateFunction<?, ?> reduction : reductions) {
-              if (reduction.isCompatableColumn(type)) {
+              if (reduction.isCompatibleColumn(type)) {
                     reductionMultimap.put(name, reduction);
               }
             }

File: core/src/main/java/tech/tablesaw/aggregate/TimeAggregateFunction.java
Patch:
@@ -17,7 +17,7 @@ public TimeAggregateFunction(String name) {
     abstract public LocalTime summarize(TimeColumn column);
 
     @Override
-    public boolean isCompatableColumn(ColumnType type) {
+    public boolean isCompatibleColumn(ColumnType type) {
         return type.equals(ColumnType.LOCAL_TIME);
     }
 

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -56,7 +56,7 @@
  */
 public class BooleanColumn extends AbstractColumn<Boolean> implements BooleanMapUtils, CategoricalColumn<Boolean>, BooleanFillers<BooleanColumn> {
 
-    public static final byte MISSING_VALUE = (Byte) BOOLEAN.getMissingValue();
+    public static final byte MISSING_VALUE = (Byte) BOOLEAN.getMissingValueIndicator();
 
     public static final byte BYTE_TRUE = 1;
     public static final byte BYTE_FALSE = 0;
@@ -162,7 +162,7 @@ public Table summary() {
         Table table = Table.create(name());
 
         BooleanColumn booleanColumn = create("Value");
-        DoubleColumn countColumn = DoubleColumn.create("Count");
+        NumberColumn countColumn = NumberColumn.create("Count");
         table.addColumns(booleanColumn);
         table.addColumns(countColumn);
 
@@ -637,7 +637,7 @@ public int[] asIntArray() {
     }
 
     public NumberColumn asNumberColumn() {
-        NumberColumn numberColumn = DoubleColumn.create(this.name() + ": ints", size());
+        NumberColumn numberColumn = NumberColumn.create(this.name() + ": ints", size());
         ByteArrayList data = data();
         for (int i = 0; i < size(); i++) {
             numberColumn.append(data.getByte(i));

File: core/src/main/java/tech/tablesaw/api/CategoricalColumn.java
Patch:
@@ -44,7 +44,7 @@ default Table countByCategory() {
 
         final Table t = new Table("Column: " + name());
         final CategoricalColumn<?> categories = (CategoricalColumn<?>) type().create("Category");
-        final DoubleColumn counts = DoubleColumn.create("Count");
+        final NumberColumn counts = NumberColumn.create("Count");
 
         final Object2IntMap<String> valueToCount = new Object2IntOpenHashMap<>();
 

File: core/src/main/java/tech/tablesaw/api/DateColumn.java
Patch:
@@ -51,7 +51,7 @@
 public class DateColumn extends AbstractColumn<LocalDate> implements DateFilters, DateFillers<DateColumn>,
             DateMapFunctions, CategoricalColumn<LocalDate> {
 
-    public static final int MISSING_VALUE = (Integer) ColumnType.LOCAL_DATE.getMissingValue();
+    public static final int MISSING_VALUE = (Integer) DateColumnType.missingValueIndicator();
 
     private final IntComparator reverseIntComparator = DescendingIntComparator.instance();
 

File: core/src/main/java/tech/tablesaw/api/Row.java
Patch:
@@ -16,7 +16,7 @@ public class Row implements Iterator<Row> {
     private final Table table;
     private final String[] columnNames;
     private final Map<String, DateColumn> dateColumnMap = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
-    private final Map<String, DoubleColumn> doubleColumnMap = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
+    private final Map<String, NumberColumn> doubleColumnMap = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
     private final Map<String, StringColumn> stringColumnMap = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
     private final Map<String, BooleanColumn> booleanColumnMap = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
     private final Map<String, DateTimeColumn> dateTimeColumnMap = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
@@ -29,8 +29,8 @@ public Row(Table table) {
         columnNames = table.columnNames().toArray(new String[0]);
         rowNumber = -1;
         for (Column<?> column : table.columns()) {
-            if (column instanceof DoubleColumn) {
-                doubleColumnMap.put(column.name(), (DoubleColumn) column);
+            if (column instanceof NumberColumn) {
+                doubleColumnMap.put(column.name(), (NumberColumn) column);
             }
             if (column instanceof BooleanColumn) {
                 booleanColumnMap.put(column.name(), (BooleanColumn) column);

File: core/src/main/java/tech/tablesaw/api/StringColumn.java
Patch:
@@ -58,7 +58,7 @@
 public class StringColumn extends AbstractColumn<String>
         implements CategoricalColumn<String>, StringFilters, StringMapFunctions, StringReduceUtils {
 
-    public static final String MISSING_VALUE = (String) STRING.getMissingValue();
+    public static final String MISSING_VALUE = (String) STRING.getMissingValueIndicator();
 
     private final AtomicInteger nextIndex = new AtomicInteger(1);
 
@@ -224,7 +224,7 @@ public Table summary() {
     public Table countByCategory() {
         Table t = new Table("Column: " + name());
         StringColumn categories = create("Category");
-        NumberColumn counts = DoubleColumn.create("Count");
+        NumberColumn counts = NumberColumn.create("Count");
 
         Int2IntMap valueToCount = new Int2IntOpenHashMap();
 
@@ -512,7 +512,7 @@ public IntArrayList data() {
 
 
     public NumberColumn asNumberColumn() {
-        NumberColumn numberColumn = DoubleColumn.create(this.name() + ": codes", size());
+        NumberColumn numberColumn = NumberColumn.create(this.name() + ": codes", size());
         IntArrayList data = data();
         for (int i = 0; i < size(); i++) {
             numberColumn.append(data.getInt(i));

File: core/src/main/java/tech/tablesaw/api/TimeColumn.java
Patch:
@@ -54,7 +54,7 @@
 public class TimeColumn extends AbstractColumn<LocalTime>
         implements CategoricalColumn<LocalTime>, TimeFilters, TimeFillers<TimeColumn>, TimeMapFunctions {
 
-    public static final int MISSING_VALUE = (Integer) LOCAL_TIME.getMissingValue();
+    public static final int MISSING_VALUE = (Integer) LOCAL_TIME.getMissingValueIndicator();
 
     private final IntComparator descendingIntComparator = DescendingIntComparator.instance();
 

File: core/src/main/java/tech/tablesaw/columns/dates/PackedLocalDate.java
Patch:
@@ -17,6 +17,7 @@
 import com.google.common.base.Strings;
 import com.google.common.primitives.Ints;
 import tech.tablesaw.api.DateColumn;
+import tech.tablesaw.columns.numbers.IntColumnType;
 
 import java.time.DayOfWeek;
 import java.time.LocalDate;
@@ -32,7 +33,6 @@
 import static java.time.DayOfWeek.*;
 import static java.time.Month.*;
 import static java.time.temporal.ChronoField.*;
-import static tech.tablesaw.api.NumberColumn.MISSING_VALUE;
 import static tech.tablesaw.columns.DateAndTimePredicates.*;
 
 /**
@@ -68,7 +68,7 @@ public static short getYear(int date) {
     }
 
     public static LocalDate asLocalDate(int date) {
-        if (date == MISSING_VALUE) {
+        if (date == IntColumnType.missingValueIndicator()) {
             return null;
         }
 

File: core/src/main/java/tech/tablesaw/columns/numbers/DoubleStringParser.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.google.common.collect.Lists;
 import tech.tablesaw.api.ColumnType;
-import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.columns.StringParser;
 import tech.tablesaw.io.csv.CsvReadOptions;
 
@@ -41,7 +40,7 @@ public boolean canParse(String s) {
     @Override
     public Double parse(String s) {
         if (isMissing(s)) {
-            return DoubleColumn.MISSING_VALUE;
+            return DoubleColumnType.missingValueIndicator();
         }
         final Matcher matcher = COMMA_PATTERN.matcher(s);
         return Double.parseDouble(matcher.replaceAll(""));
@@ -50,7 +49,7 @@ public Double parse(String s) {
     @Override
     public double parseDouble(String s) {
         if (isMissing(s)) {
-            return DoubleColumn.MISSING_VALUE;
+            return DoubleColumnType.missingValueIndicator();
         }
         final Matcher matcher = COMMA_PATTERN.matcher(s);
         return Double.parseDouble(matcher.replaceAll(""));

File: core/src/main/java/tech/tablesaw/columns/numbers/Stats.java
Patch:
@@ -15,7 +15,6 @@
 package tech.tablesaw.columns.numbers;
 
 import org.apache.commons.math3.stat.descriptive.SummaryStatistics;
-import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
@@ -129,7 +128,7 @@ public double secondMoment() {
     public Table asTable() {
         Table t = Table.create(name);
         StringColumn measure = StringColumn.create("Measure");
-        NumberColumn value = DoubleColumn.create("Value");
+        NumberColumn value = NumberColumn.create("Value");
         t.addColumns(measure);
         t.addColumns(value);
 

File: core/src/main/java/tech/tablesaw/io/jdbc/SqlResultSetReader.java
Patch:
@@ -95,7 +95,7 @@ public static Table read(ResultSet resultSet, String tableName) throws SQLExcept
             Preconditions.checkState(type != null,
                     "No column type found for %s as specified for column %s", metaData.getColumnType(i), name);
 
-            Column<?> newColumn = TypeUtils.newColumn(name, type);
+            Column<?> newColumn = type.create(name);
             table.addColumns(newColumn);
         }
 

File: core/src/main/java/tech/tablesaw/table/StandardTableSliceGroup.java
Patch:
@@ -49,7 +49,7 @@ private static String[] splitColumnNames(CategoricalColumn<?>... columns) {
      */
     public static StandardTableSliceGroup create(Table original, String... columnsNames) {
         List<CategoricalColumn<?>> columns = original.categoricalColumns(columnsNames);
-        return new StandardTableSliceGroup(original, columns.toArray(new CategoricalColumn[0]));
+        return new StandardTableSliceGroup(original, columns.toArray(new CategoricalColumn<?>[0]));
     }
 
     /**

File: core/src/main/java/tech/tablesaw/util/DoubleArrays.java
Patch:
@@ -52,7 +52,7 @@ public static double[][] to2dArray(Column<?>... columns) {
     }
 
     public static double[][] to2dArray(List<Column<?>> columnList) {
-        return to2dArray(columnList.toArray(new Column[columnList.size()]));
+        return to2dArray(columnList.toArray(new Column<?>[columnList.size()]));
     }
 
     public static double[][] to2dArray(TableSliceGroup views, int columnNumber) {

File: core/src/test/java/tech/tablesaw/TableFilteringTest.java
Patch:
@@ -17,7 +17,6 @@
 import org.junit.Before;
 import org.junit.Test;
 import tech.tablesaw.api.DateColumn;
-import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
@@ -65,7 +64,7 @@ public void testRejectWithMissingValues() {
         String[] values = {"a", "b", "", "d"};
         double[] values2 = {1, Double.NaN, 3, 4};
         StringColumn sc = StringColumn.create("s", values);
-        NumberColumn nc = DoubleColumn.create("n", values2);
+        NumberColumn nc = NumberColumn.create("n", values2);
         Table test = Table.create("test", sc, nc);
         Table result = test.dropRowsWithMissingValues();
         assertEquals(2, result.rowCount());

File: core/src/test/java/tech/tablesaw/api/DateTimeColumnTest.java
Patch:
@@ -57,7 +57,7 @@ public void testAppendCell2() {
     @Test
     public void testConvertMillisSinceEpoch() {
         long millis = 1503952123189L;
-        DoubleColumn dc = DoubleColumn.create("test");
+        NumberColumn dc = NumberColumn.create("test");
         dc.appendCell(Long.toString(millis));
         DateTimeColumn column2 = dc.asDateTimes(ZoneOffset.UTC);
 

File: core/src/test/java/tech/tablesaw/api/RowPerformanceTest.java
Patch:
@@ -200,8 +200,8 @@ private static Table defineSchema() {
         t = Table.create("Observations");
         StringColumn conceptId = StringColumn.create("concept");
         DateTimeColumn date = DateTimeColumn.create("date");
-        NumberColumn lowValues = DoubleColumn.create("lowValue");
-        NumberColumn highValues = DoubleColumn.create("highValue");
+        NumberColumn lowValues = NumberColumn.create("lowValue");
+        NumberColumn highValues = NumberColumn.create("highValue");
         highValues.setPrintFormatter(NumberColumnFormatter.ints());
         lowValues.setPrintFormatter(NumberColumnFormatter.ints());
 

File: core/src/test/java/tech/tablesaw/api/TimeColumnTest.java
Patch:
@@ -15,6 +15,7 @@
 package tech.tablesaw.api;
 
 import tech.tablesaw.columns.Column;
+import tech.tablesaw.columns.numbers.DoubleColumnType;
 import tech.tablesaw.selection.Selection;
 
 import org.junit.Before;
@@ -314,7 +315,7 @@ public void testSecond() {
         NumberColumn second = column1.second();
         assertEquals(2, second.get(0), 0.001);
         assertEquals(30, second.get(1), 0.001);
-        assertEquals(NumberColumn.MISSING_VALUE, second.get(2), 0.001);
+        assertEquals(DoubleColumnType.missingValueIndicator(), second.get(2), 0.001);
     }
 
     @Test
@@ -323,7 +324,7 @@ public void testMinute() {
         NumberColumn minute = column1.minute();
         assertEquals(4, minute.get(0), 0.001);
         assertEquals(15, minute.get(1), 0.001);
-        assertEquals(NumberColumn.MISSING_VALUE, minute.get(2), 0.001);
+        assertEquals(DoubleColumnType.missingValueIndicator(), minute.get(2), 0.001);
     }
 
     @Test

File: core/src/test/java/tech/tablesaw/columns/dates/DateFiltersTest.java
Patch:
@@ -17,7 +17,6 @@
 import org.junit.Before;
 import org.junit.Test;
 import tech.tablesaw.api.DateColumn;
-import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
@@ -131,7 +130,7 @@ public void testGetMonthValue() {
 
         Table t = Table.create("Test");
         t.addColumns(dateColumn);
-        NumberColumn index = DoubleColumn.indexColumn("index", t.rowCount(), 0);
+        NumberColumn index = NumberColumn.indexColumn("index", t.rowCount(), 0);
         t.addColumns(index);
 
         assertTrue(t.where(t.dateColumn("test").isInJanuary()).numberColumn("index").contains(0.0));
@@ -190,7 +189,7 @@ public void testComparison() {
         assertFalse(dateColumn.isBetweenExcluding(beforeDate, afterDate).contains(2));
         assertFalse(dateColumn.isBetweenExcluding(beforeDate, afterDate).contains(0));
 
-        NumberColumn index = DoubleColumn.indexColumn("index", dateColumn.size(), 0);
+        NumberColumn index = NumberColumn.indexColumn("index", dateColumn.size(), 0);
         Table t = Table.create("test", dateColumn, index);
 
         assertTrue(t.where(dateColumn.isBefore(packed)).nCol("index").contains(0));

File: core/src/test/java/tech/tablesaw/columns/datetimes/DateTimeFiltersTest.java
Patch:
@@ -17,7 +17,6 @@
 import org.junit.Before;
 import org.junit.Test;
 import tech.tablesaw.api.DateTimeColumn;
-import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.selection.Selection;
@@ -152,7 +151,7 @@ public void testGetMonthValue() {
 
         Table t = Table.create("Test");
         t.addColumns(dateTimeColumn);
-        NumberColumn index = DoubleColumn.indexColumn("index", t.rowCount(), 0);
+        NumberColumn index = NumberColumn.indexColumn("index", t.rowCount(), 0);
         t.addColumns(index);
     }
 
@@ -169,7 +168,7 @@ public void testComparison() {
         dateTimeColumn.append(dateTime);
         dateTimeColumn.append(afterDate);
 
-        NumberColumn index = DoubleColumn.indexColumn("index", dateTimeColumn.size(), 0);
+        NumberColumn index = NumberColumn.indexColumn("index", dateTimeColumn.size(), 0);
         Table t = Table.create("test", dateTimeColumn, index);
 
         assertTrue(dateTimeColumn.isOnOrBefore(date).contains(0));

File: core/src/test/java/tech/tablesaw/columns/numbers/NumberFillersTest.java
Patch:
@@ -1,7 +1,7 @@
 package tech.tablesaw.columns.numbers;
 
 import static org.junit.Assert.assertEquals;
-import static tech.tablesaw.api.DoubleColumn.create;
+import static tech.tablesaw.api.NumberColumn.create;
 import static tech.tablesaw.columns.numbers.fillers.DoubleRangeIterable.range;
 
 import org.junit.Test;

File: core/src/test/java/tech/tablesaw/filters/SearchPerformanceTest.java
Patch:
@@ -19,7 +19,6 @@
 import org.apache.commons.lang3.RandomUtils;
 import org.apache.commons.text.RandomStringGenerator;
 import tech.tablesaw.api.DateTimeColumn;
-import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.Row;
 import tech.tablesaw.api.StringColumn;
@@ -114,8 +113,8 @@ private static Table defineSchema() {
         t = Table.create("Observations");
         StringColumn conceptId = StringColumn.create("concept");
         DateTimeColumn date = DateTimeColumn.create("date");
-        NumberColumn lowValues = DoubleColumn.create("lowValue");
-        NumberColumn highValues = DoubleColumn.create("highValue");
+        NumberColumn lowValues = NumberColumn.create("lowValue");
+        NumberColumn highValues = NumberColumn.create("highValue");
         highValues.setPrintFormatter(NumberColumnFormatter.ints());
         lowValues.setPrintFormatter(NumberColumnFormatter.ints());
 

File: core/src/test/java/tech/tablesaw/filters/TimeDependentFilteringTest.java
Patch:
@@ -22,7 +22,6 @@
 import org.apache.commons.lang3.RandomUtils;
 import org.apache.commons.text.RandomStringGenerator;
 import tech.tablesaw.api.DateColumn;
-import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
@@ -140,8 +139,8 @@ private static Table defineSchema() {
         t = Table.create("Observations");
         StringColumn conceptId = StringColumn.create("concept");
         DateColumn date = DateColumn.create("date");
-        NumberColumn value =  DoubleColumn.create("value");
-        NumberColumn patientId =  DoubleColumn.create("patient");
+        NumberColumn value =  NumberColumn.create("value");
+        NumberColumn patientId =  NumberColumn.create("patient");
         patientId.setPrintFormatter(NumberColumnFormatter.ints());
 
         t.addColumns(conceptId);

File: core/src/test/java/tech/tablesaw/io/DataFrameWriterTest.java
Patch:
@@ -1,7 +1,7 @@
 package tech.tablesaw.io;
 
 import org.junit.Test;
-import tech.tablesaw.api.DoubleColumn;
+import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.Table;
 
 import java.io.ByteArrayOutputStream;
@@ -15,8 +15,8 @@ public class DataFrameWriterTest {
     private double[] v1 = {1, 2, 3, 4, 5, NaN};
     private double[] v2 = {1, 2, 3, 4, 5, NaN};
     private Table table = Table.create("t",
-            DoubleColumn.create("v", v1),
-            DoubleColumn.create("v2", v2)
+            NumberColumn.create("v", v1),
+            NumberColumn.create("v2", v2)
     );
 
     @Test

File: core/src/test/java/tech/tablesaw/table/SliceBugTests.java
Patch:
@@ -3,7 +3,6 @@
 import org.junit.Assert;
 import org.junit.Test;
 import tech.tablesaw.api.DateTimeColumn;
-import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
@@ -108,7 +107,7 @@ private Table loadTableFromDB() throws SQLException {
     private Table constructTableFromArrays() {
         StringColumn countries = StringColumn.create("countries", categories);
         DateTimeColumn timestamp = DateTimeColumn.create("sale_timestamp", timestamps);
-        DoubleColumn values = DoubleColumn.create("price", observations);
+        NumberColumn values = NumberColumn.create("price", observations);
 
         return Table.create("table_from_arrays", countries, timestamp, values);
     }

File: jsplot/src/examples/java/tech/tablesaw/plotly/BarExample.java
Patch:
@@ -14,9 +14,9 @@
 
 package tech.tablesaw.plotly;
 
-import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.Table;
+import tech.tablesaw.columns.numbers.DoubleColumnType;
 import tech.tablesaw.plotly.api.HorizontalBarPlot;
 import tech.tablesaw.plotly.api.VerticalBarPlot;
 import tech.tablesaw.plotly.components.Layout;
@@ -34,7 +34,7 @@ public static void main(String[] args) throws Exception {
         logNInjuries.setName("log injuries");
         table.addColumns(logNInjuries);
         NumberColumn scale = table.numberColumn("scale");
-        scale.set(scale.isLessThan(0), DoubleColumn.MISSING_VALUE);
+        scale.set(scale.isLessThan(0), DoubleColumnType.missingValueIndicator());
 
         Table s = table.summarize("fatalities", "log injuries", sum).by("Scale");
         System.out.println(s);

File: jsplot/src/examples/java/tech/tablesaw/plotly/BarVisualizations.java
Patch:
@@ -15,9 +15,9 @@
 package tech.tablesaw.plotly;
 
 import tech.tablesaw.AbstractExample;
-import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.Table;
+import tech.tablesaw.columns.numbers.DoubleColumnType;
 import tech.tablesaw.plotly.api.HorizontalBarPlot;
 import tech.tablesaw.plotly.api.ParetoPlot;
 import tech.tablesaw.plotly.api.PiePlot;
@@ -36,7 +36,7 @@ public static void main(String[] args) throws Exception {
         out(murders.structure().printAll());
         murders.setName("murders");
         NumberColumn victimAge = murders.numberColumn("vicAge");
-        victimAge.set(victimAge.isEqualTo(999), DoubleColumn.MISSING_VALUE);
+        victimAge.set(victimAge.isEqualTo(999), DoubleColumnType.missingValueIndicator());
 
         Table count = murders.countBy(murders.stringColumn("state"));
         out(count.structure());

File: jsplot/src/examples/java/tech/tablesaw/plotly/DistributionVisualizations.java
Patch:
@@ -1,9 +1,9 @@
 package tech.tablesaw.plotly;
 
 import tech.tablesaw.AbstractExample;
-import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.Table;
+import tech.tablesaw.columns.numbers.DoubleColumnType;
 import tech.tablesaw.plotly.api.BoxPlot;
 import tech.tablesaw.plotly.api.Histogram;
 import tech.tablesaw.plotly.api.Histogram2D;
@@ -17,8 +17,8 @@ public static void main(String[] args) throws Exception {
         out(property.xTabCounts("type"));
         NumberColumn sqft = property.numberColumn("sq__ft");
         NumberColumn price = property.numberColumn("price");
-        sqft.set(sqft.isEqualTo(0), DoubleColumn.MISSING_VALUE);
-        price.set(price.isEqualTo(0), DoubleColumn.MISSING_VALUE);
+        sqft.set(sqft.isEqualTo(0), DoubleColumnType.missingValueIndicator());
+        price.set(price.isEqualTo(0), DoubleColumnType.missingValueIndicator());
 
         Plot.show(Histogram.create("Distribution of prices", property.numberColumn("price")));
 

File: jsplot/src/examples/java/tech/tablesaw/plotly/TornadoVisualizations.java
Patch:
@@ -15,9 +15,9 @@
 package tech.tablesaw.plotly;
 
 import tech.tablesaw.AbstractExample;
-import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.Table;
+import tech.tablesaw.columns.numbers.DoubleColumnType;
 import tech.tablesaw.plotly.api.HorizontalBarPlot;
 import tech.tablesaw.plotly.api.ParetoPlot;
 import tech.tablesaw.plotly.api.PiePlot;
@@ -39,7 +39,7 @@ public static void main(String[] args) throws Exception {
         tornadoes = tornadoes.where(tornadoes.numberColumn("Start Lat").isGreaterThan(20f));
 
         NumberColumn scale = tornadoes.numberColumn("scale");
-        scale.set(scale.isEqualTo(-9), DoubleColumn.MISSING_VALUE);
+        scale.set(scale.isEqualTo(-9), DoubleColumnType.missingValueIndicator());
 
         Table fatalities1 = tornadoes.summarize("fatalities", sum).by("scale");
 

File: core/src/main/java/tech/tablesaw/columns/numbers/NumberColumnFormatter.java
Patch:
@@ -46,7 +46,6 @@ public static NumberColumnFormatter currency(String language, String country) {
         return new NumberColumnFormatter(format);
     }
 
-
     public NumberColumnFormatter() {
         this.format = null;
     }

File: core/src/main/java/tech/tablesaw/aggregate/AggregateFunction.java
Patch:
@@ -24,7 +24,7 @@ public String toString() {
         return functionName();
     }
 
-    public abstract boolean isCompatableColumn(ColumnType type);
+    public abstract boolean isCompatibleColumn(ColumnType type);
 
     public abstract ColumnType returnType();
 }

File: core/src/main/java/tech/tablesaw/aggregate/BooleanAggregateFunction.java
Patch:
@@ -15,7 +15,7 @@ public BooleanAggregateFunction(String name) {
     abstract public Boolean summarize(BooleanColumn column);
 
     @Override
-    public boolean isCompatableColumn(ColumnType type) {
+    public boolean isCompatibleColumn(ColumnType type) {
         return type == ColumnType.BOOLEAN;
     }
 

File: core/src/main/java/tech/tablesaw/aggregate/BooleanCountFunction.java
Patch:
@@ -13,7 +13,7 @@ public BooleanCountFunction(String functionName) {
     abstract public Integer summarize(BooleanColumn column);
 
     @Override
-    public boolean isCompatableColumn(ColumnType type) {
+    public boolean isCompatibleColumn(ColumnType type) {
         return type.equals(ColumnType.BOOLEAN);
     }
 

File: core/src/main/java/tech/tablesaw/aggregate/BooleanNumericFunction.java
Patch:
@@ -13,7 +13,7 @@ public BooleanNumericFunction(String functionName) {
     abstract public Double summarize(BooleanColumn column);
 
     @Override
-    public boolean isCompatableColumn(ColumnType type) {
+    public boolean isCompatibleColumn(ColumnType type) {
         return type.equals(ColumnType.BOOLEAN);
     }
 

File: core/src/main/java/tech/tablesaw/aggregate/CountFunction.java
Patch:
@@ -13,7 +13,7 @@ public CountFunction(String functionName) {
     abstract public Integer summarize(Column<?> column);
 
     @Override
-    public boolean isCompatableColumn(ColumnType type) {
+    public boolean isCompatibleColumn(ColumnType type) {
         return true;
     }
 

File: core/src/main/java/tech/tablesaw/aggregate/DateAggregateFunction.java
Patch:
@@ -17,7 +17,7 @@ public DateAggregateFunction(String name) {
     abstract public LocalDate summarize(DateColumn column);
 
     @Override
-    public boolean isCompatableColumn(ColumnType type) {
+    public boolean isCompatibleColumn(ColumnType type) {
         return type.equals(ColumnType.LOCAL_DATE);
     }
 

File: core/src/main/java/tech/tablesaw/aggregate/DateTimeAggregateFunction.java
Patch:
@@ -17,7 +17,7 @@ public DateTimeAggregateFunction(String name) {
     abstract public LocalDateTime summarize(DateTimeColumn column);
 
     @Override
-    public boolean isCompatableColumn(ColumnType type) {
+    public boolean isCompatibleColumn(ColumnType type) {
         return type.equals(ColumnType.LOCAL_DATE_TIME);
     }
 

File: core/src/main/java/tech/tablesaw/aggregate/NumericAggregateFunction.java
Patch:
@@ -13,7 +13,7 @@ public NumericAggregateFunction(String name) {
     }
 
     @Override
-    public boolean isCompatableColumn(ColumnType type) {
+    public boolean isCompatibleColumn(ColumnType type) {
         return type.equals(ColumnType.DOUBLE)
                 || type.equals(ColumnType.FLOAT)
                 || type.equals(ColumnType.INTEGER);

File: core/src/main/java/tech/tablesaw/aggregate/StringFunction.java
Patch:
@@ -15,7 +15,7 @@ public StringFunction(String name) {
     abstract public String summarize(StringColumn column);
 
     @Override
-    public boolean isCompatableColumn(ColumnType type) {
+    public boolean isCompatibleColumn(ColumnType type) {
         return type.equals(ColumnType.STRING);
     }
 

File: core/src/main/java/tech/tablesaw/aggregate/Summarizer.java
Patch:
@@ -211,7 +211,7 @@ private Table summarize(TableSliceGroup group) {
             Column<?> column = temp.column(name);
             ColumnType type = column.type();
             for (AggregateFunction<?, ?> reduction : reductions) {
-              if (reduction.isCompatableColumn(type)) {
+              if (reduction.isCompatibleColumn(type)) {
                     reductionMultimap.put(name, reduction);
               }
             }

File: core/src/main/java/tech/tablesaw/aggregate/TimeAggregateFunction.java
Patch:
@@ -17,7 +17,7 @@ public TimeAggregateFunction(String name) {
     abstract public LocalTime summarize(TimeColumn column);
 
     @Override
-    public boolean isCompatableColumn(ColumnType type) {
+    public boolean isCompatibleColumn(ColumnType type) {
         return type.equals(ColumnType.LOCAL_TIME);
     }
 

File: core/src/main/java/tech/tablesaw/aggregate/NumericAggregateFunction.java
Patch:
@@ -14,7 +14,9 @@ public NumericAggregateFunction(String name) {
 
     @Override
     public boolean isCompatableColumn(ColumnType type) {
-        return type.equals(ColumnType.DOUBLE);
+        return type.equals(ColumnType.DOUBLE)
+                || type.equals(ColumnType.FLOAT)
+                || type.equals(ColumnType.INTEGER);
     }
 
     @Override

File: core/src/main/java/tech/tablesaw/columns/numbers/IntDataWrapper.java
Patch:
@@ -102,7 +102,7 @@ public void append(int i) {
     public double getDouble(int row) {
         int value = data.getInt(row);
         if (isMissingValue(value)) {
-            return IntColumnType.missingValueIndicator();
+            return DoubleColumnType.missingValueIndicator();
         }
         return value;
     }

File: core/src/test/java/tech/tablesaw/io/csv/CsvReaderTest.java
Patch:
@@ -290,7 +290,7 @@ public void testPrintStructure() throws Exception {
         String output =
                 "ColumnType[] columnTypes = {\n" +
                         "LOCAL_DATE, // 0     date        \n" +
-                        "DOUBLE,     // 1     approval    \n" +
+                        "INTEGER,    // 1     approval    \n" +
                         "STRING,     // 2     who         \n" +
                         "}\n";
         assertEquals(output, new CsvReader()

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -56,7 +56,7 @@
  */
 public class BooleanColumn extends AbstractColumn<Boolean> implements BooleanMapUtils, CategoricalColumn<Boolean>, BooleanFillers<BooleanColumn> {
 
-    public static final byte MISSING_VALUE = (Byte) BOOLEAN.getMissingValue();
+    public static final byte MISSING_VALUE = (Byte) BOOLEAN.getMissingValueIndicator();
 
     public static final byte BYTE_TRUE = 1;
     public static final byte BYTE_FALSE = 0;

File: core/src/main/java/tech/tablesaw/api/DateColumn.java
Patch:
@@ -51,7 +51,7 @@
 public class DateColumn extends AbstractColumn<LocalDate> implements DateFilters, DateFillers<DateColumn>,
             DateMapFunctions, CategoricalColumn<LocalDate> {
 
-    public static final int MISSING_VALUE = (Integer) ColumnType.LOCAL_DATE.getMissingValue();
+    public static final int MISSING_VALUE = (Integer) ColumnType.LOCAL_DATE.getMissingValueIndicator();
 
     private final IntComparator reverseIntComparator = DescendingIntComparator.instance();
 

File: core/src/main/java/tech/tablesaw/api/DateTimeColumn.java
Patch:
@@ -55,7 +55,7 @@
 public class DateTimeColumn extends AbstractColumn<LocalDateTime>
     implements DateTimeMapFunctions, DateTimeFilters, DateTimeFillers<DateTimeColumn> {
 
-    public static final long MISSING_VALUE = (Long) ColumnType.LOCAL_DATE_TIME.getMissingValue();
+    public static final long MISSING_VALUE = (Long) ColumnType.LOCAL_DATE_TIME.getMissingValueIndicator();
 
     private final LongComparator reverseLongComparator = DescendingLongComparator.instance();
 

File: core/src/main/java/tech/tablesaw/api/StringColumn.java
Patch:
@@ -58,7 +58,7 @@
 public class StringColumn extends AbstractColumn<String>
         implements CategoricalColumn<String>, StringFilters, StringMapFunctions, StringReduceUtils {
 
-    public static final String MISSING_VALUE = (String) STRING.getMissingValue();
+    public static final String MISSING_VALUE = (String) STRING.getMissingValueIndicator();
 
     private final AtomicInteger nextIndex = new AtomicInteger(1);
 

File: core/src/main/java/tech/tablesaw/api/TimeColumn.java
Patch:
@@ -54,7 +54,7 @@
 public class TimeColumn extends AbstractColumn<LocalTime>
         implements CategoricalColumn<LocalTime>, TimeFilters, TimeFillers<TimeColumn>, TimeMapFunctions {
 
-    public static final int MISSING_VALUE = (Integer) LOCAL_TIME.getMissingValue();
+    public static final int MISSING_VALUE = (Integer) LOCAL_TIME.getMissingValueIndicator();
 
     private final IntComparator descendingIntComparator = DescendingIntComparator.instance();
 

File: core/src/main/java/tech/tablesaw/columns/numbers/DoubleDataWrapper.java
Patch:
@@ -17,7 +17,7 @@ public class DoubleDataWrapper implements NumericDataWrapper {
      */
     private final DoubleComparator descendingComparator = (o2, o1) -> (Double.compare(o1, o2));
 
-    private DoubleArrayList data;
+    private final DoubleArrayList data;
 
     public DoubleDataWrapper(DoubleArrayList data) {
         this.data = data;

File: core/src/main/java/tech/tablesaw/columns/numbers/DoubleStringParser.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.google.common.collect.Lists;
 import tech.tablesaw.api.ColumnType;
-import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.columns.StringParser;
 import tech.tablesaw.io.csv.CsvReadOptions;
 
@@ -41,7 +40,7 @@ public boolean canParse(String s) {
     @Override
     public Double parse(String s) {
         if (isMissing(s)) {
-            return NumberColumn.MISSING_VALUE;
+            return DoubleColumnType.missingValueIndicator();
         }
         final Matcher matcher = COMMA_PATTERN.matcher(s);
         return Double.parseDouble(matcher.replaceAll(""));
@@ -50,7 +49,7 @@ public Double parse(String s) {
     @Override
     public double parseDouble(String s) {
         if (isMissing(s)) {
-            return NumberColumn.MISSING_VALUE;
+            return DoubleColumnType.missingValueIndicator();
         }
         final Matcher matcher = COMMA_PATTERN.matcher(s);
         return Double.parseDouble(matcher.replaceAll(""));

File: core/src/main/java/tech/tablesaw/columns/numbers/IntDataWrapper.java
Patch:
@@ -16,7 +16,7 @@ public class IntDataWrapper implements NumericDataWrapper {
      */
     private final IntComparator descendingComparator = (o2, o1) -> (Integer.compare(o1, o2));
 
-    private IntArrayList data;
+    private final IntArrayList data;
 
     public IntDataWrapper(IntArrayList data) {
         this.data = data;

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -54,7 +54,7 @@ public class CsvReader {
      * the integer test would never be evaluated and all the ints would be read as doubles.
      */
     private List<ColumnType> typeArray =
-            Lists.newArrayList(LOCAL_DATE_TIME, LOCAL_TIME, LOCAL_DATE, BOOLEAN, INTEGER, DOUBLE, STRING);
+            Lists.newArrayList(LOCAL_DATE_TIME, LOCAL_TIME, LOCAL_DATE, BOOLEAN, INTEGER, FLOAT, DOUBLE, STRING);
 
     /**
      * Constructs a CsvReader

File: core/src/test/java/tech/tablesaw/api/NumberColumnTest.java
Patch:
@@ -230,7 +230,7 @@ public void testBetweenExclusive() {
         Selection filter = t.numberColumn("Test").isBetweenExclusive(42, 57);
         Table result = t.where(filter);
         assertEquals(1, result.rowCount());
-        assertEquals("52.0", result.get(0, "Test"));
+        assertEquals("52", result.get(0, "Test"));
     }
 
     @Ignore

File: core/src/test/java/tech/tablesaw/io/csv/CsvReaderTest.java
Patch:
@@ -45,7 +45,7 @@
  */
 public class CsvReaderTest {
 
-    private final ColumnType[] bus_types = {INTEGER, STRING, STRING, DOUBLE, DOUBLE};
+    private final ColumnType[] bus_types = {INTEGER, STRING, STRING, FLOAT, FLOAT};
     private final ColumnType[] bus_types_with_SKIP = {INTEGER, STRING, SKIP, DOUBLE, DOUBLE};
 
     @Test

File: core/src/main/java/tech/tablesaw/columns/numbers/DoubleDataWrapper.java
Patch:
@@ -10,7 +10,7 @@
 
 import static tech.tablesaw.api.NumberColumn.MISSING_VALUE;
 
-public class DoubleDataWrapper implements NumericDataWrapper<Double> {
+public class DoubleDataWrapper implements NumericDataWrapper {
 
     /**
      * Compares two doubles, such that a sort based on this comparator would sort in descending order

File: core/src/main/java/tech/tablesaw/columns/numbers/IntDataWrapper.java
Patch:
@@ -9,7 +9,7 @@
 import java.util.Arrays;
 import java.util.Iterator;
 
-public class IntDataWrapper implements NumericDataWrapper<Integer> {
+public class IntDataWrapper implements NumericDataWrapper {
 
     /**
      * Compares two ints, such that a sort based on this comparator would sort in descending order

File: core/src/main/java/tech/tablesaw/columns/numbers/NumericDataWrapper.java
Patch:
@@ -4,7 +4,7 @@
 
 import java.util.Iterator;
 
-public interface NumericDataWrapper<T> extends NumberIterable {
+public interface NumericDataWrapper extends NumberIterable {
 
     int size();
 

File: core/src/main/java/tech/tablesaw/aggregate/AggregateFunction.java
Patch:
@@ -6,7 +6,7 @@
 /**
  * A partial implementation of aggregate functions to summarize over a numeric column
  */
-public abstract class AggregateFunction<T, C extends Column<?>> {
+public abstract class AggregateFunction<INCOL extends Column<?>, OUT> {
 
     private final String functionName;
 
@@ -18,7 +18,7 @@ public String functionName() {
         return functionName;
     }
 
-    public abstract T summarize(C column);
+    public abstract OUT summarize(INCOL column);
 
     public String toString() {
         return functionName();

File: core/src/main/java/tech/tablesaw/aggregate/BooleanAggregateFunction.java
Patch:
@@ -6,7 +6,7 @@
 /**
  * A partial implementation of aggregate functions to summarize over a boolean column
  */
-public abstract class BooleanAggregateFunction extends AggregateFunction<Boolean, BooleanColumn> {
+public abstract class BooleanAggregateFunction extends AggregateFunction<BooleanColumn, Boolean> {
 
     public BooleanAggregateFunction(String name) {
         super(name);

File: core/src/main/java/tech/tablesaw/aggregate/BooleanCountFunction.java
Patch:
@@ -3,7 +3,7 @@
 import tech.tablesaw.api.BooleanColumn;
 import tech.tablesaw.api.ColumnType;
 
-abstract class BooleanCountFunction extends AggregateFunction<Integer, BooleanColumn> {
+abstract class BooleanCountFunction extends AggregateFunction<BooleanColumn, Integer> {
 
     public BooleanCountFunction(String functionName) {
         super(functionName);

File: core/src/main/java/tech/tablesaw/aggregate/BooleanNumericFunction.java
Patch:
@@ -3,7 +3,7 @@
 import tech.tablesaw.api.BooleanColumn;
 import tech.tablesaw.api.ColumnType;
 
-abstract class BooleanNumericFunction extends AggregateFunction<Double, BooleanColumn> {
+abstract class BooleanNumericFunction extends AggregateFunction<BooleanColumn, Double> {
 
     public BooleanNumericFunction(String functionName) {
         super(functionName);

File: core/src/main/java/tech/tablesaw/aggregate/CountFunction.java
Patch:
@@ -3,7 +3,7 @@
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.columns.Column;
 
-abstract class CountFunction extends AggregateFunction<Integer, Column<?>> {
+abstract class CountFunction extends AggregateFunction<Column<?>, Integer> {
 
     public CountFunction(String functionName) {
         super(functionName);

File: core/src/main/java/tech/tablesaw/aggregate/DateAggregateFunction.java
Patch:
@@ -8,7 +8,7 @@
 /**
  * A partial implementation of aggregate functions to summarize over a date column
  */
-public abstract class DateAggregateFunction extends AggregateFunction<LocalDate, DateColumn> {
+public abstract class DateAggregateFunction extends AggregateFunction<DateColumn, LocalDate> {
 
     public DateAggregateFunction(String name) {
         super(name);

File: core/src/main/java/tech/tablesaw/aggregate/DateTimeAggregateFunction.java
Patch:
@@ -8,7 +8,7 @@
 /**
  * A partial implementation of aggregate functions to summarize over a dateTime column
  */
-public abstract class DateTimeAggregateFunction extends AggregateFunction<LocalDateTime, DateTimeColumn> {
+public abstract class DateTimeAggregateFunction extends AggregateFunction<DateTimeColumn, LocalDateTime> {
 
     public DateTimeAggregateFunction(String name) {
         super(name);

File: core/src/main/java/tech/tablesaw/aggregate/NumericAggregateFunction.java
Patch:
@@ -6,7 +6,7 @@
 /**
  * A partial implementation of aggregate functions to summarize over a numeric column
  */
-public abstract class NumericAggregateFunction extends AggregateFunction<Double, NumberColumn> {
+public abstract class NumericAggregateFunction extends AggregateFunction<NumberColumn, Double> {
 
     public NumericAggregateFunction(String name) {
         super(name);

File: core/src/main/java/tech/tablesaw/aggregate/StringFunction.java
Patch:
@@ -6,7 +6,7 @@
 /**
  * A partial implementation of aggregate functions to summarize over a date column
  */
-public abstract class StringFunction extends AggregateFunction<String, StringColumn> {
+public abstract class StringFunction extends AggregateFunction<StringColumn, String> {
 
     public StringFunction(String name) {
         super(name);

File: core/src/main/java/tech/tablesaw/aggregate/TimeAggregateFunction.java
Patch:
@@ -8,7 +8,7 @@
 /**
  * A partial implementation of aggregate functions to summarize over a time column
  */
-public abstract class TimeAggregateFunction extends AggregateFunction<LocalTime, TimeColumn> {
+public abstract class TimeAggregateFunction extends AggregateFunction<TimeColumn, LocalTime> {
 
     public TimeAggregateFunction(String name) {
         super(name);

File: core/src/test/java/tech/tablesaw/aggregate/AggregateFunctionsTest.java
Patch:
@@ -80,7 +80,6 @@ public void testGroupMean2() {
     public void testApplyWithNonNumericResults() {
         Table result = table.summarize("date", earliestDate, latestDate).apply();
         assertEquals(2, result.columnCount());
-        System.out.println(result);
     }
 
     @Test

File: core/src/main/java/tech/tablesaw/aggregate/AggregateFunction.java
Patch:
@@ -6,7 +6,7 @@
 /**
  * A partial implementation of aggregate functions to summarize over a numeric column
  */
-public abstract class AggregateFunction<T, C extends Column> {
+public abstract class AggregateFunction<T, C extends Column<?>> {
 
     private final String functionName;
 

File: core/src/main/java/tech/tablesaw/api/ColumnType.java
Patch:
@@ -57,9 +57,9 @@ static ColumnType valueOf(String name) {
 
     String getPrinterFriendlyName();
 
-    StringParser defaultParser();
+    StringParser<?> defaultParser();
 
-    StringParser customParser(CsvReadOptions options);
+    StringParser<?> customParser(CsvReadOptions options);
 
     default boolean compare(int rowNumber, Column<?> temp, Column<?> original) {
         return original.get(rowNumber).equals(temp.get(temp.size() - 1));

File: core/src/main/java/tech/tablesaw/api/StringColumn.java
Patch:
@@ -421,9 +421,8 @@ public StringColumn appendCell(String object) {
     }
 
     @Override
-    public StringColumn appendCell(String object, StringParser parser) {
-        addValue((String) parser.parse(object));
-        return this;
+    public StringColumn appendCell(String object, StringParser<?> parser) {
+        return appendObj(parser.parse(object));
     }
 
     @Override

File: core/src/main/java/tech/tablesaw/api/TimeColumn.java
Patch:
@@ -341,9 +341,8 @@ public TimeColumn appendCell(String object) {
     }
 
     @Override
-    public TimeColumn appendCell(String object, StringParser parser) {
-        appendInternal(PackedLocalTime.pack((LocalTime) parser.parse(object)));
-        return this;
+    public TimeColumn appendCell(String object, StringParser<?> parser) {
+        return appendObj(parser.parse(object));
     }
 
     @Override

File: core/src/main/java/tech/tablesaw/columns/Column.java
Patch:
@@ -173,7 +173,7 @@ default Column<T> lead(final int n) {
 
     Column<T> appendCell(String stringValue);
 
-    Column<T> appendCell(String stringValue, StringParser<T> parser);
+    Column<T> appendCell(String stringValue, StringParser<?> parser);
 
     IntComparator rowComparator();
 

File: core/src/main/java/tech/tablesaw/columns/SkipColumnType.java
Patch:
@@ -18,12 +18,12 @@ public Column<Void> create(String name) {
     }
 
     @Override
-    public StringParser defaultParser() {
+    public StringParser<?> defaultParser() {
         throw new UnsupportedOperationException("Column type " + name() + " doesn't support parsing");
     }
 
     @Override
-    public StringParser customParser(CsvReadOptions options) {
+    public StringParser<?> customParser(CsvReadOptions options) {
         throw new UnsupportedOperationException("Column type " + name() + " doesn't support parsing");
     }
 }

File: core/src/main/java/tech/tablesaw/aggregate/Summarizer.java
Patch:
@@ -216,6 +216,9 @@ private Table summarize(TableSliceGroup group) {
               }
             }
         }
+        if (reductionMultimap.isEmpty()) {
+            throw new RuntimeException("None of the aggregate functions provided apply to the summarized column type(s).");
+        }
         return reductionMultimap;
     }
 

File: core/src/test/java/tech/tablesaw/table/RollingColumnTest.java
Patch:
@@ -42,7 +42,7 @@ public void testRollingMaxDate() {
                 LocalDate.of(2011, 1, 9).atStartOfDay()
         };
 
-        DateTimeColumn result = (DateTimeColumn) DateTimeColumn.create("data", data).rolling(2).calc(latest);
+        DateTimeColumn result = (DateTimeColumn) DateTimeColumn.create("data", data).rolling(2).calc(latestDateTime);
         assertArrayEquals(sma5, result.asObjectArray());
     }
 

File: core/src/main/java/tech/tablesaw/aggregate/Summarizer.java
Patch:
@@ -18,7 +18,6 @@
 import com.google.common.collect.ArrayListMultimap;
 import tech.tablesaw.api.CategoricalColumn;
 import tech.tablesaw.api.ColumnType;
-import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.table.SelectionTableSliceGroup;
@@ -161,6 +160,7 @@ public Table by(String groupNameTemplate, int step) {
 
     /**
      * Returns the result of applying to the functions to all the values in the appropriate column
+     * TODO add a test that uses a non numeric return type with apply
      */
     @SuppressWarnings({ "unchecked", "rawtypes" })
     public Table apply() {
@@ -173,7 +173,8 @@ public Table apply() {
             for (AggregateFunction function : reductions) {
                 Column column = temp.column(name);
                 Object result = function.summarize(column);
-                Column newColumn = DoubleColumn.create(TableSliceGroup.aggregateColumnName(name, function.functionName()));
+                ColumnType type = function.returnType();
+                Column newColumn = type.create(TableSliceGroup.aggregateColumnName(name, function.functionName()));
                 if (result instanceof Number) {
                     Number number = (Number) result;
                     newColumn.append(number.doubleValue());

File: core/src/main/java/tech/tablesaw/aggregate/CountFunction.java
Patch:
@@ -3,14 +3,14 @@
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.columns.Column;
 
-abstract class CountFunction extends AggregateFunction<Integer, Column> {
+abstract class CountFunction extends AggregateFunction<Integer, Column<?>> {
 
     public CountFunction(String functionName) {
         super(functionName);
     }
 
     @Override
-    abstract public Integer summarize(Column column);
+    abstract public Integer summarize(Column<?> column);
 
     @Override
     public boolean isCompatableColumn(ColumnType type) {

File: core/src/main/java/tech/tablesaw/columns/dates/DateMapFunctions.java
Patch:
@@ -39,7 +39,7 @@
  */
 public interface DateMapFunctions extends Column<LocalDate> {
 
-    static String dateColumnName(Column column1, int value, TemporalUnit unit) {
+    static String dateColumnName(Column<LocalDate> column1, int value, TemporalUnit unit) {
         return column1.name() + ": " + value + " " + unit.toString() + "(s)";
     }
 

File: core/src/main/java/tech/tablesaw/columns/strings/StringMapFunctions.java
Patch:
@@ -176,7 +176,7 @@ default StringColumn padStart(int minLength, char padChar) {
         return newColumn;
     }
 
-    default StringColumn commonPrefix(Column column2) {
+    default StringColumn commonPrefix(Column<?> column2) {
 
         StringColumn newColumn = StringColumn.create(name() + column2.name() + "[prefix]");
 
@@ -188,7 +188,7 @@ default StringColumn commonPrefix(Column column2) {
         return newColumn;
     }
 
-    default StringColumn commonSuffix(Column column2) {
+    default StringColumn commonSuffix(Column<?> column2) {
 
         StringColumn newColumn = StringColumn.create(name() + column2.name() + "[suffix]");
 
@@ -205,7 +205,7 @@ default StringColumn commonSuffix(Column column2) {
      * Returns a column containing the levenshtein distance between the two given string columns
      */
 
-    default NumberColumn distance(Column column2) {
+    default NumberColumn distance(Column<?> column2) {
 
         NumberColumn newColumn = DoubleColumn.create(name() + column2.name() + "[distance]");
 

File: core/src/main/java/tech/tablesaw/conversion/TableConverter.java
Patch:
@@ -124,7 +124,7 @@ private AttributeDataset smileDataset(Column<?> responseCol, List<Column<?>> var
      * We convert all columns to NumericAttribute. Smile's AttributeDataset only stores data as double.
      * While Smile defines NominalAttribute and DateAttribute they appear to be little used.
      */
-    private Attribute colToAttribute(Column col) {
+    private Attribute colToAttribute(Column<?> col) {
         return new NumericAttribute(col.name());
     }
 

File: core/src/main/java/tech/tablesaw/io/TypeUtils.java
Patch:
@@ -51,7 +51,7 @@ private TypeUtils() {}
     /**
      * Constructs and returns a column for the given {@code name} and {@code type}
      */
-    public static Column newColumn(@Nonnull String name, @Nonnull ColumnType type) {
+    public static Column<?> newColumn(@Nonnull String name, @Nonnull ColumnType type) {
 
         Preconditions.checkArgument(!Strings.isNullOrEmpty(name),
                 "There must be a valid name for a new column");

File: core/src/main/java/tech/tablesaw/io/html/HtmlTableWriter.java
Patch:
@@ -61,7 +61,7 @@ private static String row(int row, Table table) {
         StringBuilder builder = new StringBuilder()
                 .append("<tr>");
 
-        for (Column col : table.columns()) {
+        for (Column<?> col : table.columns()) {
             builder
                     .append("<td>")
                     .append(String.valueOf(col.getString(row)))

File: core/src/main/java/tech/tablesaw/io/jdbc/SqlResultSetReader.java
Patch:
@@ -95,14 +95,14 @@ public static Table read(ResultSet resultSet, String tableName) throws SQLExcept
             Preconditions.checkState(type != null,
                     "No column type found for %s as specified for column %s", metaData.getColumnType(i), name);
 
-            Column newColumn = TypeUtils.newColumn(name, type);
+            Column<?> newColumn = TypeUtils.newColumn(name, type);
             table.addColumns(newColumn);
         }
 
         // Add the rows
         while (resultSet.next()) {
             for (int i = 1; i <= metaData.getColumnCount(); i++) {
-                Column column = table.column(i - 1); // subtract 1 because results sets originate at 1 not 0
+                Column<?> column = table.column(i - 1); // subtract 1 because results sets originate at 1 not 0
                 column.appendCell(resultSet.getString(i));
             }
         }

File: core/src/main/java/tech/tablesaw/sorting/SortUtils.java
Patch:
@@ -17,7 +17,7 @@ public class SortUtils {
     public static IntComparatorChain getChain(Table table, Sort key) {
         Iterator<Map.Entry<String, Sort.Order>> entries = key.iterator();
         Map.Entry<String, Sort.Order> sort = entries.next();
-        Column column = table.column(sort.getKey());
+        Column<?> column = table.column(sort.getKey());
         IntComparator comparator = rowComparator(column, sort.getValue());
 
         IntComparatorChain chain = new IntComparatorChain(comparator);
@@ -34,7 +34,7 @@ public static IntComparatorChain getChain(Table table, Sort key) {
      * @param column     The column to sort
      * @param order      Specifies whether the sort should be in ascending or descending order
      */
-    public static IntComparator rowComparator(Column column, Sort.Order order) {
+    public static IntComparator rowComparator(Column<?> column, Sort.Order order) {
         IntComparator rowComparator = column.rowComparator();
         if (order == Sort.Order.DESCEND) {
             return ReversingIntComparator.reverse(rowComparator);
@@ -49,7 +49,7 @@ public static IntComparator rowComparator(Column column, Sort.Order order) {
     public static IntComparator getComparator(Table table, Sort key) {
         Iterator<Map.Entry<String, Sort.Order>> entries = key.iterator();
         Map.Entry<String, Sort.Order> sort = entries.next();
-        Column column = table.column(sort.getKey());
+        Column<?> column = table.column(sort.getKey());
         return SortUtils.rowComparator(column, sort.getValue());
     }
 }

File: core/src/main/java/tech/tablesaw/table/TableSlice.java
Patch:
@@ -84,7 +84,7 @@ public List<Column<?>> columns() {
     }
 
     @Override
-    public int columnIndex(Column column) {
+    public int columnIndex(Column<?> column) {
         return table.columnIndex(column);
     }
 

File: core/src/test/java/tech/tablesaw/api/TimeColumnTest.java
Patch:
@@ -85,7 +85,7 @@ public void testSorting() {
         List<LocalTime> top = column1.top(3);
 
         column1.sortAscending();
-        Column first = column1.first(3);
+        Column<?> first = column1.first(3);
         TimeColumn timeColumn = (TimeColumn) first;
         List<LocalTime> sortedA = timeColumn.asList();
 

File: core/src/test/java/tech/tablesaw/columns/ColumnTest.java
Patch:
@@ -94,13 +94,13 @@ public void testLast() {
 
     @Test
     public void testName() {
-        Column c = table.numberColumn("approval");
+        Column<?> c = table.numberColumn("approval");
         assertEquals("approval", c.name());
     }
 
     @Test
     public void testType() {
-        Column c = table.numberColumn("approval");
+        Column<?> c = table.numberColumn("approval");
         assertEquals(ColumnType.DOUBLE, c.type());
     }
 

File: core/src/test/java/tech/tablesaw/io/html/HtmlTableWriterTest.java
Patch:
@@ -16,8 +16,9 @@
 
 import org.junit.Before;
 import org.junit.Test;
+
 import tech.tablesaw.aggregate.AggregateFunctions;
-import tech.tablesaw.api.CategoricalColumn;
+import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.io.csv.CsvReadOptions;
 import tech.tablesaw.table.StandardTableSliceGroup;
@@ -34,7 +35,7 @@ public void setUp() throws Exception {
 
     @Test
     public void testWrite() {
-        CategoricalColumn byColumn = table.categoricalColumn("who");
+        StringColumn byColumn = table.stringColumn("who");
         TableSliceGroup group = StandardTableSliceGroup.create(table, byColumn);
         Table result = group.aggregate("approval", AggregateFunctions.mean);
         HtmlTableWriter.write(result);

File: core/src/test/java/tech/tablesaw/table/TableSliceTest.java
Patch:
@@ -61,7 +61,7 @@ public void columnIndex() {
         TableSlice slice = new TableSlice(source, Selection.withRange(0, source.rowCount()));
         assertEquals(source.columnIndex("who"), slice.columnIndex("who"));
 
-        Column who = source.column("who");
+        Column<?> who = source.column("who");
         assertEquals(source.columnIndex(who), slice.columnIndex(who));
     }
 

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -795,8 +795,9 @@ public Table retainColumns(String... columnNames) {
     public Table append(Table tableToAppend) {
         for (final Column<?> column : columnList) {
             final Column<?> columnToAppend = tableToAppend.column(column.name());
-            ColumnType type = column.type();
-            type.appendColumns(column, columnToAppend);
+            for (int i = 0; i < columnToAppend.size(); i++) {
+                column.appendObj(columnToAppend.get(i));
+            }
         }
         return this;
     }

File: core/src/main/java/tech/tablesaw/columns/AbstractColumn.java
Patch:
@@ -25,9 +25,9 @@ public abstract class AbstractColumn<T> implements Column<T> {
 
     private String name;
 
-    private final ColumnType<T> type;
+    private final ColumnType type;
 
-    public AbstractColumn(final ColumnType<T> type, final String name) {
+    public AbstractColumn(ColumnType type, final String name) {
         this.type = type;
         setName(name);
     }
@@ -44,7 +44,7 @@ public Column<T> setName(final String name) {
     }
 
     @Override
-    public ColumnType<T> type() {
+    public ColumnType type() {
         return type;
     }
 

File: core/src/main/java/tech/tablesaw/table/Rows.java
Patch:
@@ -50,7 +50,7 @@ public static boolean compareRows(int rowInOriginal, Table original, Table tempT
         int columnCount = original.columnCount();
         boolean result;
         for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {
-            final ColumnType columnType = original.column(columnIndex).type();
+            ColumnType columnType = original.column(columnIndex).type();
             result = columnType.compare(rowInOriginal, tempTable.column(columnIndex), original.column(columnIndex));
             if (!result) {
                 return false;

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -405,7 +405,7 @@ public ColumnType[] detectColumnTypes(InputStream stream, CsvReadOptions options
             while ((nextLine = csvParser.parseNext()) != null) {
                 // initialize the arrays to hold the strings. we don't know how many we need until we read the first row
                 if (rowCount == 0) {
-                    for (String aNextLine : nextLine) {
+                    for (int i = 0; i < nextLine.length; i++) {
                         columnData.add(new ArrayList<>());
                     }
                 }

File: core/src/main/java/tech/tablesaw/columns/Column.java
Patch:
@@ -114,7 +114,7 @@ default Column<T> lead(final int n) {
      *
      * @return {@link ColumnType}
      */
-    ColumnType type();
+    ColumnType<T> type();
 
     /**
      * Returns a string representation of the value at the given row.
@@ -183,6 +183,8 @@ default Column<T> lead(final int n) {
 
     Column<T> append(Column<T> column);
 
+    Column<T> appendObj(Object value);
+
     default Column<T> first(final int numRows) {
         int newRowCount = Math.min(numRows, size());
         return inRange(0, newRowCount);

File: core/src/main/java/tech/tablesaw/api/Row.java
Patch:
@@ -22,7 +22,7 @@ public class Row implements Iterator<Row> {
     private final Map<String, DateTimeColumn> dateTimeColumnMap = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
     private final Map<String, TimeColumn> timeColumnMap = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
 
-    private final Map<String, Column> columnMap = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
+    private final Map<String, Column<?>> columnMap = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
 
     public Row(Table table) {
         this.table = table;

File: core/src/main/java/tech/tablesaw/api/DateTimeColumn.java
Patch:
@@ -370,7 +370,7 @@ public long[] asEpochMillisArray(ZoneOffset offset) {
     }
 
     @Override
-    public DateTimeColumn append(Column column) {
+    public DateTimeColumn append(Column<LocalDateTime> column) {
         Preconditions.checkArgument(column.type() == this.type());
         DateTimeColumn doubleColumn = (DateTimeColumn) column;
         for (int i = 0; i < doubleColumn.size(); i++) {

File: core/src/main/java/tech/tablesaw/api/Row.java
Patch:
@@ -28,7 +28,7 @@ public Row(Table table) {
         this.table = table;
         columnNames = table.columnNames().toArray(new String[0]);
         rowNumber = -1;
-        for (Column column : table.columns()) {
+        for (Column<?> column : table.columns()) {
             if (column instanceof DoubleColumn) {
                 doubleColumnMap.put(column.name(), (DoubleColumn) column);
             }

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -80,7 +80,7 @@ private Table(String name) {
      * @param name    The name of the table
      * @param columns One or more columns, all of which must have either the same length or size 0
      */
-    protected Table(String name, Column... columns) {
+    protected Table(String name, Column<?>... columns) {
         this(name);
         for (final Column<?> column : columns) {
             this.addColumns(column);
@@ -246,7 +246,7 @@ public List<Column<?>> columns() {
         return columnList;
     }
 
-    public Column[] columnArray() {
+    public Column<?>[] columnArray() {
         return columnList.toArray(new Column[columnCount()]);
     }
 
@@ -685,7 +685,7 @@ public TableSliceGroup splitOn(String... columns) {
      *
      * are preferred
      */
-    public TableSliceGroup splitOn(CategoricalColumn... columns) {
+    public TableSliceGroup splitOn(CategoricalColumn<?>... columns) {
         return StandardTableSliceGroup.create(this, columns);
     }
 

File: core/src/main/java/tech/tablesaw/columns/AbstractColumn.java
Patch:
@@ -25,9 +25,9 @@ public abstract class AbstractColumn<T> implements Column<T> {
 
     private String name;
 
-    private final ColumnType type;
+    private final ColumnType<T> type;
 
-    public AbstractColumn(final ColumnType type, final String name) {
+    public AbstractColumn(final ColumnType<T> type, final String name) {
         this.type = type;
         setName(name);
     }
@@ -44,7 +44,7 @@ public Column<T> setName(final String name) {
     }
 
     @Override
-    public ColumnType type() {
+    public ColumnType<T> type() {
         return type;
     }
 

File: core/src/main/java/tech/tablesaw/columns/AbstractColumnType.java
Patch:
@@ -65,7 +65,7 @@ public String getPrinterFriendlyName() {
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
-        AbstractColumnType that = (AbstractColumnType) o;
+        AbstractColumnType<?> that = (AbstractColumnType<?>) o;
         return byteSize == that.byteSize &&
                 Objects.equal(missingValue, that.missingValue) &&
                 Objects.equal(name, that.name) &&

File: core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeColumnType.java
Patch:
@@ -51,9 +51,7 @@ public void copyFromRows(IntArrayList rows, Column<LocalDateTime> newColumn, Row
         for (int index : rows) {
             row.at(index);
             long packedDateTime = row.getPackedDateTime(newColumn.name());
-            newDateTime.appendInternal(packedDateTime);
-            PackedDateTime dateTime = row.getPackedDateTime(newColumn.name());
-            dateTimes.appendInternal(dateTime.getPackedValue());
+            dateTimes.appendInternal(packedDateTime);
         }
     }
 

File: core/src/main/java/tech/tablesaw/columns/dates/DateColumnType.java
Patch:
@@ -50,8 +50,8 @@ public void copyFromRows(IntArrayList rows, Column<LocalDate> newColumn, Row row
         DateColumn newDate = (DateColumn) newColumn;
         for (int index : rows) {
             row.at(index);
-            PackedDate date = row.getPackedDate(newColumn.name());
-            newDate.appendInternal(date.getPackedValue());
+            int packedDate = row.getPackedDate(newColumn.name());
+            newDate.appendInternal(packedDate);
         }
     }
 

File: core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeColumnType.java
Patch:
@@ -50,6 +50,8 @@ public void copyFromRows(IntArrayList rows, Column<LocalDateTime> newColumn, Row
         DateTimeColumn dateTimes = (DateTimeColumn) newColumn;
         for (int index : rows) {
             row.at(index);
+            long packedDateTime = row.getPackedDateTime(newColumn.name());
+            newDateTime.appendInternal(packedDateTime);
             PackedDateTime dateTime = row.getPackedDateTime(newColumn.name());
             dateTimes.appendInternal(dateTime.getPackedValue());
         }

File: core/src/main/java/tech/tablesaw/columns/times/TimeColumnType.java
Patch:
@@ -50,8 +50,8 @@ public void copyFromRows(IntArrayList rows, Column<LocalTime> newColumn, Row row
         TimeColumn newTime = (TimeColumn) newColumn;
         for (int index : rows) {
             row.at(index);
-            PackedTime time = row.getPackedTime(newColumn.name());
-            newTime.appendInternal(time.getPackedValue());
+            int packedTime = row.getPackedTime(newColumn.name());
+            newTime.appendInternal(packedTime);
         }
     }
 

File: core/src/test/java/tech/tablesaw/api/RowTest.java
Patch:
@@ -90,9 +90,9 @@ public void testGetPackedDate() throws IOException {
         while (row.hasNext()) {
             row.next();
             assertEquals(table.dateColumn(0).getIntInternal(row.getRowNumber()),
-                    row.getPackedDate(0).getPackedValue());
+                    row.getPackedDate(0));
             assertEquals(table.dateColumn("date").getIntInternal(row.getRowNumber()),
-                    row.getPackedDate("date").getPackedValue());
+                    row.getPackedDate("date"));
         }
     }
 }
\ No newline at end of file

File: core/src/test/java/tech/tablesaw/filters/SearchPerformanceTest.java
Patch:
@@ -100,7 +100,7 @@ private static int getRowNumber(Table t, LocalDateTime testDate, double testLow,
         row.at(dateIndex.get(testPackedDateTime).get(0));
         while (row.hasNext()) {
             row.next();
-            if (row.getPackedDateTime("date").isOnOrAfter(testPackedDateTime)) {
+            if (row.getPackedDateTime("date") >= testPackedDateTime) {
                 if (row.getDouble("lowValue") <= testLow
                         || row.getDouble("highValue") >= testHigh) {
                     rowNumber = row.getRowNumber();

File: core/src/main/java/tech/tablesaw/aggregate/Summarizer.java
Patch:
@@ -20,7 +20,6 @@
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.Table;
-import tech.tablesaw.columns.AbstractColumn;
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.table.SelectionTableSliceGroup;
 import tech.tablesaw.table.StandardTableSliceGroup;
@@ -174,7 +173,7 @@ public Table apply() {
             for (AggregateFunction function : reductions) {
                 Column column = temp.column(name);
                 Object result = function.summarize(column);
-                AbstractColumn newColumn = DoubleColumn.create(TableSliceGroup.aggregateColumnName(name, function.functionName()));
+                Column newColumn = DoubleColumn.create(TableSliceGroup.aggregateColumnName(name, function.functionName()));
                 if (result instanceof Number) {
                     Number number = (Number) result;
                     newColumn.append(number.doubleValue());

File: core/src/main/java/tech/tablesaw/api/Row.java
Patch:
@@ -77,7 +77,7 @@ public Row next() {
     }
 
     public double getDouble(String columnName) {
-        return doubleColumnMap.get(columnName).get(rowNumber);
+        return doubleColumnMap.get(columnName).getDouble(rowNumber);
     }
 
     public double getDouble(int columnIndex) {
@@ -165,11 +165,11 @@ public int getRowNumber() {
     }
 
     public Object getObject(String columnName) {
-        return columnMap.get(columnName).getObject(rowNumber);
+        return columnMap.get(columnName).get(rowNumber);
     }
 
     public Object getObject(int columnIndex) {
-        return columnMap.get(columnNames[columnIndex]).getObject(rowNumber);
+        return columnMap.get(columnNames[columnIndex]).get(rowNumber);
     }
 
     @Override

File: core/src/main/java/tech/tablesaw/columns/booleans/BooleanColumnType.java
Patch:
@@ -8,7 +8,7 @@
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.io.csv.CsvReadOptions;
 
-public class BooleanColumnType extends AbstractColumnType {
+public class BooleanColumnType extends AbstractColumnType<Boolean> {
 
     public static final BooleanStringParser DEFAULT_PARSER = new BooleanStringParser(ColumnType.BOOLEAN);
 
@@ -24,7 +24,7 @@ private BooleanColumnType(Comparable<?> missingValue, int byteSize, String name,
     }
 
     @Override
-    public Column create(String name) {
+    public BooleanColumn create(String name) {
         return BooleanColumn.create(name);
     }
 
@@ -39,7 +39,7 @@ public BooleanStringParser customParser(CsvReadOptions readOptions) {
     }
 
     @Override
-    public void copy(IntArrayList rows, Column oldColumn, Column newColumn) {
+    public void copy(IntArrayList rows, Column<Boolean> oldColumn, Column<Boolean> newColumn) {
         BooleanColumn oldBoolean = (BooleanColumn) oldColumn;
         BooleanColumn newBoolean = (BooleanColumn) newColumn;
         for (int index : rows) {

File: core/src/main/java/tech/tablesaw/columns/booleans/BooleanColumnUtils.java
Patch:
@@ -14,12 +14,10 @@
 
 package tech.tablesaw.columns.booleans;
 
-import it.unimi.dsi.fastutil.ints.IntIterable;
 import tech.tablesaw.api.BooleanColumn;
-import tech.tablesaw.columns.Column;
 import tech.tablesaw.filtering.predicates.BytePredicate;
 
-public interface BooleanColumnUtils extends Column, IntIterable {
+public interface BooleanColumnUtils {
 
     BytePredicate isMissing = i -> i == BooleanColumn.MISSING_VALUE;
 

File: core/src/main/java/tech/tablesaw/columns/booleans/BooleanMapUtils.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * An interface for mapping operations unique to Boolean columns
  */
-public interface BooleanMapUtils extends Column {
+public interface BooleanMapUtils extends Column<Boolean> {
 
     /*
      * Returns a Boolean column made by and-ing this column with the arguments

File: core/src/main/java/tech/tablesaw/columns/dates/DateColumnType.java
Patch:
@@ -11,7 +11,7 @@
 
 import java.time.LocalDate;
 
-public class DateColumnType extends AbstractColumnType {
+public class DateColumnType extends AbstractColumnType<LocalDate> {
 
     public static final DateStringParser DEFAULT_PARSER = new DateStringParser(ColumnType.LOCAL_DATE);
     public static final DateColumnType INSTANCE =
@@ -37,7 +37,7 @@ public StringParser<LocalDate> customParser(CsvReadOptions options) {
     }
 
     @Override
-    public void copy(IntArrayList rows, Column oldColumn, Column newColumn) {
+    public void copy(IntArrayList rows, Column<LocalDate> oldColumn, Column<LocalDate> newColumn) {
         DateColumn oldDate = (DateColumn) oldColumn;
         DateColumn newDate = (DateColumn) newColumn;
         for (int index : rows) {
@@ -46,7 +46,7 @@ public void copy(IntArrayList rows, Column oldColumn, Column newColumn) {
     }
 
     @Override
-    public void copyFromRows(IntArrayList rows, Column newColumn, Row row) {
+    public void copyFromRows(IntArrayList rows, Column<LocalDate> newColumn, Row row) {
         DateColumn newDate = (DateColumn) newColumn;
         for (int index : rows) {
             row.at(index);

File: core/src/main/java/tech/tablesaw/columns/dates/DateMapFunctions.java
Patch:
@@ -37,7 +37,7 @@
 /**
  * An interface for mapping operations unique to Date columns
  */
-public interface DateMapFunctions extends Column {
+public interface DateMapFunctions extends Column<LocalDate> {
 
     static String dateColumnName(Column column1, int value, TemporalUnit unit) {
         return column1.name() + ": " + value + " " + unit.toString() + "(s)";

File: core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeFilters.java
Patch:
@@ -16,7 +16,7 @@
 
 import static tech.tablesaw.columns.datetimes.DateTimePredicates.*;
 
-public interface DateTimeFilters extends Column {
+public interface DateTimeFilters extends Column<LocalDateTime> {
 
     default Selection isAfter(LocalDateTime value) {
         return eval(isGreaterThan, PackedLocalDateTime.pack(value));

File: core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java
Patch:
@@ -33,7 +33,7 @@
 import static tech.tablesaw.api.DateTimeColumn.MISSING_VALUE;
 import static tech.tablesaw.columns.datetimes.PackedLocalDateTime.*;
 
-public interface DateTimeMapFunctions extends Column {
+public interface DateTimeMapFunctions extends Column<LocalDateTime> {
 
     default NumberColumn differenceInMilliseconds(DateTimeColumn column2) {
         return difference(column2, ChronoUnit.MILLIS);

File: core/src/main/java/tech/tablesaw/columns/numbers/NumberPredicates.java
Patch:
@@ -14,7 +14,6 @@
 
 package tech.tablesaw.columns.numbers;
 
-import it.unimi.dsi.fastutil.ints.IntIterable;
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.filtering.predicates.DoubleBiPredicate;
 import tech.tablesaw.filtering.predicates.DoubleRangePredicate;
@@ -26,7 +25,7 @@
  * <p>
  * TODO(lwhite): Ensure each returns false when handling missing values
  */
-public interface NumberPredicates extends Column, IntIterable {
+public interface NumberPredicates extends Column<Double> {
 
     DoublePredicate isZero = i -> i == 0.0;
 

File: core/src/main/java/tech/tablesaw/columns/strings/StringFilters.java
Patch:
@@ -25,7 +25,7 @@
 
 import static tech.tablesaw.columns.strings.StringPredicates.*;
 
-public interface StringFilters extends Column {
+public interface StringFilters extends Column<String> {
 
     default Selection eval(BiPredicate<String, String> predicate, StringColumn otherColumn) {
         Selection selection = new BitmapBackedSelection();

File: core/src/main/java/tech/tablesaw/columns/strings/StringMapFunctions.java
Patch:
@@ -19,7 +19,6 @@
 import com.google.common.base.Strings;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.commons.text.similarity.LevenshteinDistance;
-import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.StringColumn;
@@ -34,7 +33,7 @@
  * String utility functions. Each function takes one or more String columns as input and produces
  * another Column as output. The resulting column need not be a string column.
  */
-public interface StringMapFunctions extends Column {
+public interface StringMapFunctions extends Column<String> {
 
     default StringColumn upperCase() {
         StringColumn newColumn = StringColumn.create(this.name() + "[ucase]");
@@ -144,7 +143,7 @@ default StringColumn format(String formatString) {
 
     default NumberColumn parseInt() {
 
-        NumberColumn newColumn = (DoubleColumn) Column.create(name() + "[parsed]", ColumnType.DOUBLE);
+        NumberColumn newColumn = DoubleColumn.create(name() + "[parsed]");
         for (int r = 0; r < size(); r++) {
             newColumn.append(Integer.parseInt(getString(r)));
         }

File: core/src/main/java/tech/tablesaw/columns/strings/StringReduceUtils.java
Patch:
@@ -16,7 +16,7 @@
 
 import tech.tablesaw.columns.Column;
 
-public interface StringReduceUtils extends Column, Iterable<String> {
+public interface StringReduceUtils extends Column<String>, Iterable<String> {
 
     /**
      * Returns a single string made by appending all the strings in this column, separated by the given delimiter

File: core/src/main/java/tech/tablesaw/columns/times/TimeFilters.java
Patch:
@@ -16,7 +16,7 @@
 import static tech.tablesaw.columns.DateAndTimePredicates.isGreaterThan;
 import static tech.tablesaw.columns.DateAndTimePredicates.isLessThan;
 
-public interface TimeFilters extends Column {
+public interface TimeFilters extends Column<LocalTime> {
 
     TimeColumn where(Selection selection);
 

File: core/src/main/java/tech/tablesaw/columns/times/TimeMapFunctions.java
Patch:
@@ -29,7 +29,7 @@
 import static java.time.temporal.ChronoUnit.*;
 import static tech.tablesaw.api.TimeColumn.MISSING_VALUE;
 
-public interface TimeMapFunctions extends Column {
+public interface TimeMapFunctions extends Column<LocalTime> {
 
     default NumberColumn differenceInMilliseconds(TimeColumn column2) {
         return difference(column2, MILLIS);

File: core/src/main/java/tech/tablesaw/index/DoubleIndex.java
Patch:
@@ -33,7 +33,7 @@ public DoubleIndex(NumberColumn column) {
         int sizeEstimate = Integer.min(1_000_000, column.size() / 100);
         Double2ObjectOpenHashMap<IntArrayList> tempMap = new Double2ObjectOpenHashMap<>(sizeEstimate);
         for (int i = 0; i < column.size(); i++) {
-            double value = column.get(i);
+            double value = column.getDouble(i);
             IntArrayList recordIds = tempMap.get(value);
             if (recordIds == null) {
                 recordIds = new IntArrayList();

File: core/src/main/java/tech/tablesaw/table/RollingColumn.java
Patch:
@@ -4,7 +4,6 @@
 import tech.tablesaw.aggregate.AggregateFunction;
 import tech.tablesaw.aggregate.AggregateFunctions;
 import tech.tablesaw.api.NumberColumn;
-import tech.tablesaw.columns.AbstractColumn;
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.selection.BitmapBackedSelection;
 import tech.tablesaw.selection.Selection;
@@ -55,9 +54,9 @@ private String generateNewColumnName(AggregateFunction function) {
      *
      */
     @SuppressWarnings("unchecked")
-    public Column calc(AggregateFunction function) {
+    public Column<?> calc(AggregateFunction function) {
         // TODO: the subset operation copies the array. creating a view would likely be more efficient
-        AbstractColumn result = (AbstractColumn) Column.create(generateNewColumnName(function), function.returnType());
+        Column result = function.returnType().create(generateNewColumnName(function));
         for (int i = 0; i < window - 1; i++) {
             result.appendMissing();
         }

File: core/src/main/java/tech/tablesaw/table/StandardTableSliceGroup.java
Patch:
@@ -48,7 +48,7 @@ private static String[] splitColumnNames(CategoricalColumn... columns) {
      * The named columns must be CategoricalColumns
      */
     public static StandardTableSliceGroup create(Table original, String... columnsNames) {
-        List<CategoricalColumn> columns = original.categoricalColumns(columnsNames);
+        List<CategoricalColumn<?>> columns = original.categoricalColumns(columnsNames);
         return new StandardTableSliceGroup(original, columns.toArray(new CategoricalColumn[0]));
     }
 
@@ -66,7 +66,7 @@ public static StandardTableSliceGroup create(Table original, CategoricalColumn..
      */
     private void splitOn(String... columnNames) {
 
-        List<Column> columns = getSourceTable().columns(columnNames);
+        List<Column<?>> columns = getSourceTable().columns(columnNames);
         int byteSize = getByteSize(columns);
 
         byte[] currentKey = null;

File: core/src/test/java/tech/tablesaw/api/RowTest.java
Patch:
@@ -63,9 +63,9 @@ public void testGetInt() throws IOException {
         Row row = new Row(table);
         while (row.hasNext()) {
             row.next();
-            assertEquals((int) table.numberColumn(1).get(row.getRowNumber()),
+            assertEquals((int) table.numberColumn(1).getDouble(row.getRowNumber()),
                     row.getInt(1));
-            assertEquals((int) table.numberColumn("approval").get(row.getRowNumber()),
+            assertEquals((int) table.numberColumn("approval").getDouble(row.getRowNumber()),
                     row.getInt("approval"));
         }
     }

File: core/src/test/java/tech/tablesaw/api/TableTest.java
Patch:
@@ -296,9 +296,9 @@ public void testRollWithNrows2() throws Exception {
             sums.add(sum);
         };
         t.rollWithRows(rowConsumer,2);
-        assertTrue(sums.contains((int) approval.get(0) + (int) approval.get(1)));
-        assertTrue(sums.contains((int) approval.get(1) + (int) approval.get(2)));
-        assertTrue(sums.contains((int) approval.get(2) + (int) approval.get(3)));
+        assertTrue(sums.contains((int) approval.getDouble(0) + (int) approval.getDouble(1)));
+        assertTrue(sums.contains((int) approval.getDouble(1) + (int) approval.getDouble(2)));
+        assertTrue(sums.contains((int) approval.getDouble(2) + (int) approval.getDouble(3)));
     }
 
     private class PairChild implements Table.Pairs {

File: jsplot/src/main/java/tech/tablesaw/plotly/api/Heatmap.java
Patch:
@@ -26,7 +26,7 @@ public static Figure create(String title, Table table, String categoryCol1, Stri
 
         Table counts = table.xTabCounts(categoryCol1, categoryCol2);
         counts = counts.dropRows(counts.rowCount() - 1);
-        List<Column> columns = counts.columns();
+        List<Column<?>> columns = counts.columns();
         columns.remove(counts.columnCount() - 1);
         Column yColumn = columns.remove(0);
         double[][] z = DoubleArrays.to2dArray(columns);

File: core/src/main/java/tech/tablesaw/aggregate/BooleanAggregateFunction.java
Patch:
@@ -6,7 +6,7 @@
 /**
  * A partial implementation of aggregate functions to summarize over a boolean column
  */
-public abstract class BooleanAggregateFunction<Boolean> extends AggregateFunction {
+public abstract class BooleanAggregateFunction extends AggregateFunction<Boolean, Column> {
 
     public BooleanAggregateFunction(String name) {
         super(name);

File: core/src/main/java/tech/tablesaw/columns/numbers/NumberMapFunctions.java
Patch:
@@ -14,7 +14,6 @@
 
 package tech.tablesaw.columns.numbers;
 
-import it.unimi.dsi.fastutil.doubles.DoubleIterable;
 import org.apache.commons.math3.random.EmpiricalDistribution;
 import org.apache.commons.math3.stat.StatUtils;
 import org.apache.commons.math3.stat.descriptive.SummaryStatistics;

File: core/src/test/java/tech/tablesaw/aggregate/AggregateFunctionsTest.java
Patch:
@@ -57,7 +57,8 @@ public void testGroupMean() {
     public void testDateMin() {
         CategoricalColumn byColumn = table.dateColumn("date").yearQuarter();
         Table result = table.summarize("approval", "date", mean, earliestDate).by(byColumn);
-        System.out.println(result);
+        assertEquals(3, result.columnCount());
+        assertEquals(13, result.rowCount());
     }
 
     @Test

File: core/src/test/java/tech/tablesaw/api/NumberColumnTest.java
Patch:
@@ -88,7 +88,7 @@ public void testPercentiles() {
 
         assertEquals(5, c2.percentile(5), 0.00001);
         assertEquals(5, c.percentile(5), 0.00001);
-        assertEquals(5, percentile(c, 5), 0.00001);
+        assertEquals(5, percentile(c, 5.0), 0.00001);
 
         assertEquals(95, percentile95.summarize(c), 0.00001);
         assertEquals(99, percentile99.summarize(c), 0.00001);

File: core/src/test/java/tech/tablesaw/api/StringColumnTest.java
Patch:
@@ -24,7 +24,6 @@
 import java.util.function.Function;
 
 import static org.junit.Assert.*;
-import static tech.tablesaw.aggregate.AggregateFunctions.count;
 import static tech.tablesaw.columns.strings.StringPredicates.isEqualToIgnoringCase;
 
 public class StringColumnTest {
@@ -39,6 +38,8 @@ public void setUp() {
         column.append("Value 4");
     }
 
+/*
+TODO: fix
     @Test
     public void testSummarizeIf() {
         double result = column.summarizeIf(
@@ -49,6 +50,7 @@ public void testSummarizeIf() {
         double result2 = column.summarizeIf(column.endsWith("3"), count);
         assertEquals(1, result2, 0.0);
     }
+*/
 
     @Test
     public void testConditionalSet() {

File: core/src/test/java/tech/tablesaw/table/TableSliceGroupTest.java
Patch:
@@ -18,9 +18,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import tech.tablesaw.aggregate.NumericAggregateFunction;
+import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
-import tech.tablesaw.columns.Column;
 import tech.tablesaw.io.csv.CsvReadOptions;
 
 import java.util.List;
@@ -35,7 +35,7 @@ public class TableSliceGroupTest {
     private static NumericAggregateFunction exaggerate = new NumericAggregateFunction("exageration") {
 
         @Override
-        public double summarize(Column data) {
+        public Double summarize(NumberColumn data) {
             return StatUtils.max(data.asDoubleArray()) + 1000;
         }
     };

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -100,7 +100,7 @@ public Table read(CsvReadOptions options) throws IOException {
                 .withSeparator(options.separator())
                 .build();
 
-        CSVReader reader;
+        CSVReader reader = null;
         try {
             reader = new CSVReaderBuilder(new InputStreamReader(ubis)).withCSVParser(csvParser).build();
             Table table = Table.create(options.tableName());
@@ -139,8 +139,8 @@ public Table read(CsvReadOptions options) throws IOException {
             addRows(options, types, reader, table, columnNames, columnIndexes);
             return table;
         } finally {
-            if (options.reader() != null) {
-                options.reader().close();
+            if (options.reader() == null && reader != null) {
+                reader.close();
             }
         }
     }

File: core/src/main/java/tech/tablesaw/api/DateColumn.java
Patch:
@@ -53,7 +53,7 @@
 /**
  * A column in a base table that contains float values
  */
-public class DateColumn extends AbstractColumn implements DateFilters, DateFillers<DateColumn>,
+public class DateColumn extends AbstractColumn<LocalDate, DateColumn> implements DateFilters, DateFillers<DateColumn>,
 DateMapFunctions, CategoricalColumn, Iterable<LocalDate> {
 
     public static final int MISSING_VALUE = (Integer) ColumnType.LOCAL_DATE.getMissingValue();
@@ -657,7 +657,7 @@ public Object[] asObjectArray() {
     }
 
     @Override
-    public Object getObject(int index) {
+    public LocalDate getObject(int index) {
         return get(index);
     }
 }

File: core/src/main/java/tech/tablesaw/api/DateTimeColumn.java
Patch:
@@ -52,7 +52,7 @@
 /**
  * A column in a table that contains long-integer encoded (packed) local date-time values
  */
-public class DateTimeColumn extends AbstractColumn
+public class DateTimeColumn extends AbstractColumn<LocalDateTime, DateTimeColumn>
     implements DateTimeMapFunctions, DateTimeFilters, DateTimeFillers<DateTimeColumn>, Iterable<LocalDateTime> {
 
     public static final long MISSING_VALUE = (Long) ColumnType.LOCAL_DATE_TIME.getMissingValue();
@@ -597,7 +597,7 @@ public Object[] asObjectArray() {
     }
 
     @Override
-    public Object getObject(int index) {
+    public LocalDateTime getObject(int index) {
         return get(index);
     }
 }

File: core/src/main/java/tech/tablesaw/api/StringColumn.java
Patch:
@@ -55,7 +55,7 @@
  * Because the MISSING_VALUE for this column type is an empty string, there is little or no need for special handling
  * of missing values in this class's methods.
  */
-public class StringColumn extends AbstractColumn
+public class StringColumn extends AbstractColumn<String, StringColumn>
         implements CategoricalColumn, StringFilters, StringMapFunctions, StringReduceUtils {
 
     public static final String MISSING_VALUE = (String) STRING.getMissingValue();
@@ -571,11 +571,10 @@ public StringColumn removeMissing() {
     }
 
     @Override
-    public Object getObject(int index) {
+    public String getObject(int index) {
         return get(index);
     }
 
-
     @Override
     public Iterator<String> iterator() {
         return new Iterator<String>() {

File: core/src/main/java/tech/tablesaw/api/TimeColumn.java
Patch:
@@ -51,7 +51,7 @@
 /**
  * A column in a base table that contains float values
  */
-public class TimeColumn extends AbstractColumn implements CategoricalColumn, Iterable<LocalTime>, TimeFilters, TimeFillers<TimeColumn>, TimeMapFunctions {
+public class TimeColumn extends AbstractColumn<LocalTime, TimeColumn> implements CategoricalColumn, Iterable<LocalTime>, TimeFilters, TimeFillers<TimeColumn>, TimeMapFunctions {
 
     public static final int MISSING_VALUE = (Integer) LOCAL_TIME.getMissingValue();
 
@@ -595,7 +595,7 @@ public int[] asIntArray() {
     }
 
     @Override
-    public Object getObject(int index) {
+    public LocalTime getObject(int index) {
         return get(index);
     }
 }

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -381,7 +381,7 @@ public static ColumnType[] detectColumnTypes(InputStream stream, CsvReadOptions
             while ((nextLine = reader.readNext()) != null) {
                 // initialize the arrays to hold the strings. we don't know how many we need until we read the first row
                 if (rowCount == 0) {
-                    for (String aNextLine : nextLine) {
+                    for (int i = 0; i < nextLine.length; i++) {
                         columnData.add(new ArrayList<>());
                     }
                 }

File: core/src/examples/java/tech/tablesaw/BusStopExample.java
Patch:
@@ -29,7 +29,7 @@ public static void main(String[] args) throws Exception {
         out("Some Examples: ");
 
         // Read the CSV file
-        ColumnType[] types = {ColumnType.NUMBER, ColumnType.STRING, ColumnType.STRING, ColumnType.NUMBER, ColumnType.NUMBER};
+        ColumnType[] types = {ColumnType.DOUBLE, ColumnType.STRING, ColumnType.STRING, ColumnType.DOUBLE, ColumnType.DOUBLE};
         Table table = Table.read().csv(CsvReadOptions.builder("../data/bus_stop_test.csv").columnTypes(types));
 
         // Look at the column names

File: core/src/examples/java/tech/tablesaw/Example1.java
Patch:
@@ -123,11 +123,11 @@ public static void main(String[] args) throws Exception {
         StringColumn who = table1.stringColumn("who");
 
         Table xtab = CrossTab.counts(table1, month, who);
-        xtab.columnsOfType(ColumnType.NUMBER).forEach(x -> ((NumberColumn)x).setPrintFormatter(NumberColumnFormatter.ints()));
+        xtab.columnsOfType(ColumnType.DOUBLE).forEach(x -> ((NumberColumn)x).setPrintFormatter(NumberColumnFormatter.ints()));
         out(xtab);
 
         Table percents = table1.xTabTablePercents("month", "who");
-        percents.columnsOfType(ColumnType.NUMBER)
+        percents.columnsOfType(ColumnType.DOUBLE)
                 .forEach(x -> ((NumberColumn)x).setPrintFormatter(NumberColumnFormatter.percent(0)));
         out(percents);
 

File: core/src/examples/java/tech/tablesaw/TornadoExample.java
Patch:
@@ -34,7 +34,7 @@ public static void main(String[] args) throws Exception {
 
         out(tornadoes.structure());
         out(tornadoes.structure().where(
-                tornadoes.stringColumn("Column Type").isEqualTo("NUMBER")));
+                tornadoes.stringColumn("Column Type").isEqualTo("DOUBLE")));
 
         tornadoes.setName("tornadoes");
 

File: core/src/main/java/tech/tablesaw/aggregate/NumericAggregateFunction.java
Patch:
@@ -15,6 +15,6 @@ public NumericAggregateFunction(String name) {
     abstract public double summarize(Column column);
 
     public boolean isCompatibleWith(ColumnType type) {
-        return type.equals(ColumnType.NUMBER);
+        return type.equals(ColumnType.DOUBLE);
     }
 }

File: core/src/main/java/tech/tablesaw/api/ColumnType.java
Patch:
@@ -23,7 +23,7 @@ public interface ColumnType {
     // standard column types
     ColumnType BOOLEAN = BooleanColumnType.INSTANCE;
     ColumnType STRING = StringColumnType.INSTANCE;
-    ColumnType NUMBER = DoubleColumnType.INSTANCE;
+    ColumnType DOUBLE = DoubleColumnType.INSTANCE;
     ColumnType LOCAL_DATE = DateColumnType.INSTANCE;
     ColumnType LOCAL_DATE_TIME = DateTimeColumnType.INSTANCE;
     ColumnType LOCAL_TIME = TimeColumnType.INSTANCE;

File: core/src/main/java/tech/tablesaw/api/DoubleColumn.java
Patch:
@@ -51,7 +51,7 @@
 import java.util.function.DoublePredicate;
 import java.util.function.DoubleSupplier;
 
-import static tech.tablesaw.api.ColumnType.NUMBER;
+import static tech.tablesaw.api.ColumnType.DOUBLE;
 
 /**
  * A column in a base table that contains double precision floating point values
@@ -180,7 +180,7 @@ public void setPrintFormatter(final NumberColumnFormatter formatter) {
     }
 
     private DoubleColumn(final String name, final DoubleArrayList data) {
-        super(NUMBER, name);
+        super(DOUBLE, name);
         this.data = data;
     }
 

File: core/src/main/java/tech/tablesaw/api/NumberColumn.java
Patch:
@@ -27,10 +27,10 @@
 import java.util.function.DoublePredicate;
 
 import static tech.tablesaw.aggregate.AggregateFunctions.*;
-import static tech.tablesaw.api.ColumnType.NUMBER;
+import static tech.tablesaw.api.ColumnType.DOUBLE;
 
 public interface NumberColumn extends Column, DoubleIterable, NumberMapFunctions, NumberFilters, NumberFillers<NumberColumn>, CategoricalColumn {
-    double MISSING_VALUE = (Double) NUMBER.getMissingValue();
+    double MISSING_VALUE = (Double) DOUBLE.getMissingValue();
 
     static boolean valueIsMissing(double value) {
         return Double.isNaN(value);

File: core/src/main/java/tech/tablesaw/columns/numbers/DoubleColumnType.java
Patch:
@@ -10,9 +10,9 @@
 
 public class DoubleColumnType extends AbstractColumnType {
 
-    public static final DoubleStringParser DEFAULT_PARSER = new DoubleStringParser(ColumnType.NUMBER);
+    public static final DoubleStringParser DEFAULT_PARSER = new DoubleStringParser(ColumnType.DOUBLE);
     public static final DoubleColumnType INSTANCE =
-            new DoubleColumnType(Double.NaN, 8, "NUMBER", "Number");
+            new DoubleColumnType(Double.NaN, 8, "DOUBLE", "Double");
 
     private DoubleColumnType(Comparable<?> missingValue, int byteSize, String name, String printerFriendlyName) {
         super(missingValue, byteSize, name, printerFriendlyName);

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -434,7 +434,7 @@ private static ColumnType detectType(List<String> valuesList, CsvReadOptions opt
         // Types to choose from. When more than one would work, we pick the first of the options
         ColumnType[] typeArray
                 = // we leave out string, as that is the default type
-                {LOCAL_DATE_TIME, LOCAL_TIME, LOCAL_DATE, BOOLEAN, NUMBER};
+                {LOCAL_DATE_TIME, LOCAL_TIME, LOCAL_DATE, BOOLEAN, DOUBLE};
 
         List<StringParser> parsers = getParserList(typeArray, options);
 

File: core/src/test/java/tech/tablesaw/api/NumberColumnTest.java
Patch:
@@ -490,7 +490,7 @@ public void testSize() {
     @Test
     public void testType() {
         NumberColumn doubles =  DoubleColumn.create("doubles", 100);
-        assertEquals(ColumnType.NUMBER, doubles.type());
+        assertEquals(ColumnType.DOUBLE, doubles.type());
     }
 
     @Test

File: core/src/test/java/tech/tablesaw/columns/ColumnTest.java
Patch:
@@ -30,8 +30,8 @@ public class ColumnTest {
 
     private static final ColumnType[] types = {
             ColumnType.LOCAL_DATE,     // date of poll
-            ColumnType.NUMBER,        // approval rating (pct)
-            ColumnType.STRING             // polling org
+            ColumnType.DOUBLE,         // approval rating (pct)
+            ColumnType.STRING          // polling org
     };
 
     private Table table;
@@ -93,6 +93,6 @@ public void testName() {
     @Test
     public void testType() {
         Column c = table.numberColumn("approval");
-        assertEquals(ColumnType.NUMBER, c.type());
+        assertEquals(ColumnType.DOUBLE, c.type());
     }
 }

File: core/src/test/java/tech/tablesaw/index/DoubleIndexTest.java
Patch:
@@ -40,11 +40,11 @@ public void setUp() throws Exception {
                         // explicitly set column type, due to CsvReader#detectType returns ColumnType.FLOAT
                         // for 'stop_lat' and 'stop_lon' columns
                         .columnTypes(new ColumnType[]{
-                                ColumnType.NUMBER,
+                                ColumnType.DOUBLE,
                                 ColumnType.STRING,
                                 ColumnType.STRING,
-                                ColumnType.NUMBER,
-                                ColumnType.NUMBER}));
+                                ColumnType.DOUBLE,
+                                ColumnType.DOUBLE}));
         index = new DoubleIndex(table.numberColumn("stop_lat"));
     }
 

File: core/src/test/java/tech/tablesaw/index/IntIndexTest.java
Patch:
@@ -35,7 +35,7 @@ public class IntIndexTest {
 
     private ColumnType[] types = {
             ColumnType.LOCAL_DATE,     // date of poll
-            ColumnType.NUMBER,        // approval rating (pct)
+            ColumnType.DOUBLE,        // approval rating (pct)
             ColumnType.STRING        // polling org
     };
 

File: core/src/test/java/tech/tablesaw/io/TypeUtilsTest.java
Patch:
@@ -26,7 +26,7 @@
 
 import static org.hamcrest.CoreMatchers.notNullValue;
 import static org.junit.Assert.assertThat;
-import static tech.tablesaw.api.ColumnType.NUMBER;
+import static tech.tablesaw.api.ColumnType.DOUBLE;
 
 public class TypeUtilsTest {
 
@@ -35,7 +35,7 @@ public class TypeUtilsTest {
      */
     @Test
     public void testNewColumn() {
-        NumberColumn column = (NumberColumn) TypeUtils.newColumn("test", NUMBER);
+        NumberColumn column = (NumberColumn) TypeUtils.newColumn("test", DOUBLE);
         assertThat(column, notNullValue());
     }
 

File: core/src/main/java/tech/tablesaw/api/ColumnType.java
Patch:
@@ -64,6 +64,8 @@ static ColumnType valueOf(String name) {
 
     void copy(IntArrayList rows, Column oldColumn, Column newColumn);
 
+    void copyFromRows(IntArrayList rows, Column newColumn, Row row);
+
 
     boolean compare(int rowNumber, Column temp, Column original);
 }

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -779,6 +779,8 @@ public Table dropDuplicateRows() {
         return temp;
     }
 
+
+
     /**
      * Returns only those records in this table that have no columns with missing values
      */

File: core/src/main/java/tech/tablesaw/columns/dates/DateStringParser.java
Patch:
@@ -107,5 +107,4 @@ public LocalDate parse(String s) {
                     .appendOptional(dtf18)
                     .appendOptional(dtf19)
                     .toFormatter();
-
 }

File: core/src/main/java/tech/tablesaw/columns/dates/DateStringParser.java
Patch:
@@ -85,7 +85,7 @@ public LocalDate parse(String s) {
     private static final DateTimeFormatter dtf19 = DateTimeFormatter.ofPattern("MMM d, yyyy");
 
     // A formatter that handles all the date formats defined above
-    private static final DateTimeFormatter DEFAULT_FORMATTER =
+    public static final DateTimeFormatter DEFAULT_FORMATTER =
             new DateTimeFormatterBuilder()
                     .appendOptional(dtf1)
                     .appendOptional(dtf2)

File: core/src/main/java/tech/tablesaw/columns/Column.java
Patch:
@@ -169,6 +169,8 @@ default Column lead(int n) {
 
     Column appendCell(String stringValue);
 
+    Column appendCell(String stringValue, StringParser parser);
+
     IntComparator rowComparator();
 
     void append(Column column);

File: core/src/test/java/tech/tablesaw/columns/dates/DateMapFunctionsTest.java
Patch:
@@ -22,7 +22,6 @@
 import tech.tablesaw.api.TimeColumn;
 
 import java.time.LocalTime;
-import java.util.Locale;
 
 import static org.junit.Assert.*;
 
@@ -33,7 +32,7 @@ public class DateMapFunctionsTest {
     @Before
     public void setUp() {
         Table table = Table.create("Test");
-        column1 = DateColumn.create("Game date", Locale.ENGLISH);
+        column1 = DateColumn.create("Game date");
         table.addColumns(column1);
     }
 

File: core/src/test/java/tech/tablesaw/io/csv/CsvReaderTest.java
Patch:
@@ -263,9 +263,9 @@ public void testWithMissingValue() throws Exception {
                 .build();
 
         Table t = Table.read().csv(options);
-        assertEquals(t.stringColumn(0).countMissing(), 1);
-        assertEquals(t.numberColumn(1).countMissing(), 1);
-        assertEquals(t.numberColumn(2).countMissing(), 1);
+        assertEquals(1, t.stringColumn(0).countMissing());
+        assertEquals(1, t.numberColumn(1).countMissing());
+        assertEquals(1, t.numberColumn(2).countMissing());
     }
 
     @Test

File: core/src/main/java/tech/tablesaw/columns/dates/DateColumnType.java
Patch:
@@ -11,8 +11,10 @@
 public class DateColumnType extends AbstractColumnType {
 
     public static final DateStringParser DEFAULT_PARSER = new DateStringParser(ColumnType.LOCAL_DATE);
+    public static final DateColumnType INSTANCE =
+            new DateColumnType(Integer.MIN_VALUE, 4, "LOCAL_DATE", "Date");;
 
-    public DateColumnType(Comparable<?> missingValue, int byteSize, String name, String printerFriendlyName) {
+    private DateColumnType(Comparable<?> missingValue, int byteSize, String name, String printerFriendlyName) {
         super(missingValue, byteSize, name, printerFriendlyName);
     }
 

File: core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeColumnType.java
Patch:
@@ -11,8 +11,10 @@
 public class DateTimeColumnType extends AbstractColumnType {
 
     public static final DateTimeStringParser DEFAULT_PARSER = new DateTimeStringParser(ColumnType.LOCAL_DATE_TIME);
+    public static final DateTimeColumnType INSTANCE =
+            new DateTimeColumnType(Long.MIN_VALUE, 8, "LOCAL_DATE_TIME","DateTime");;
 
-    public DateTimeColumnType(Comparable<?> missingValue, int byteSize, String name, String printerFriendlyName) {
+    private DateTimeColumnType(Comparable<?> missingValue, int byteSize, String name, String printerFriendlyName) {
         super(missingValue, byteSize, name, printerFriendlyName);
     }
 

File: core/src/main/java/tech/tablesaw/columns/numbers/DoubleColumnType.java
Patch:
@@ -8,8 +8,10 @@
 public class DoubleColumnType extends AbstractColumnType {
 
     public static final DoubleStringParser DEFAULT_PARSER = new DoubleStringParser(ColumnType.NUMBER);
+    public static final DoubleColumnType INSTANCE =
+            new DoubleColumnType(Double.NaN, 8, "NUMBER", "Number");
 
-    public DoubleColumnType(Comparable<?> missingValue, int byteSize, String name, String printerFriendlyName) {
+    private DoubleColumnType(Comparable<?> missingValue, int byteSize, String name, String printerFriendlyName) {
         super(missingValue, byteSize, name, printerFriendlyName);
     }
 

File: core/src/main/java/tech/tablesaw/columns/times/TimeColumnType.java
Patch:
@@ -11,8 +11,10 @@
 public class TimeColumnType extends AbstractColumnType {
 
     public static final TimeStringParser DEFAULT_PARSER = new TimeStringParser(ColumnType.LOCAL_TIME);
+    public static final TimeColumnType INSTANCE =
+            new TimeColumnType(Integer.MIN_VALUE, 4, "LOCAL_TIME", "Time");;
 
-    public TimeColumnType(Comparable<?> missingValue, int byteSize, String name, String printerFriendlyName) {
+    private TimeColumnType(Comparable<?> missingValue, int byteSize, String name, String printerFriendlyName) {
         super(missingValue, byteSize, name, printerFriendlyName);
     }
 

File: core/src/main/java/tech/tablesaw/columns/Column.java
Patch:
@@ -169,6 +169,8 @@ default Column lead(int n) {
 
     Column appendCell(String stringValue);
 
+    Column appendCell(String stringValue, StringParser parser);
+
     IntComparator rowComparator();
 
     void append(Column column);

File: core/src/test/java/tech/tablesaw/columns/dates/DateMapFunctionsTest.java
Patch:
@@ -22,7 +22,6 @@
 import tech.tablesaw.api.TimeColumn;
 
 import java.time.LocalTime;
-import java.util.Locale;
 
 import static org.junit.Assert.*;
 
@@ -33,7 +32,7 @@ public class DateMapFunctionsTest {
     @Before
     public void setUp() {
         Table table = Table.create("Test");
-        column1 = DateColumn.create("Game date", Locale.ENGLISH);
+        column1 = DateColumn.create("Game date");
         table.addColumns(column1);
     }
 

File: jsplot/src/main/java/tech/tablesaw/plotly/components/Figure.java
Patch:
@@ -16,7 +16,7 @@
  * traces (objects that describe a single series of data in a graph like Scatter or Heatmap)
  * and layout attributes that apply to the rest of the chart, like the title, xaxis, or annotations).
  * <p>
- * Figure combines the two parts, associating one or more traces with a layout. If the layout is null a default layuut
+ * Figure combines the two parts, associating one or more traces with a layout. If the layout is null a default layout
  * is provided.
  */
 public class Figure {

File: core/src/main/java/tech/tablesaw/api/ColumnType.java
Patch:
@@ -1,6 +1,7 @@
 package tech.tablesaw.api;
 
 import com.google.common.base.Preconditions;
+import tech.tablesaw.columns.StringParser;
 import tech.tablesaw.columns.booleans.BooleanColumnType;
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.columns.dates.DateColumnType;
@@ -53,4 +54,6 @@ static ColumnType valueOf(String name) {
     int byteSize();
 
     String getPrinterFriendlyName();
+
+    StringParser parser();
 }

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -555,7 +555,7 @@ private static ColumnType detectType(List<String> valuesList, CsvReadOptions opt
 
         // Types to choose from. When more than one would work, we pick the first of the options
         ColumnType[] typeArray
-                = // we leave out category, as that is the default type
+                = // we leave out string, as that is the default type
                 {LOCAL_DATE_TIME, LOCAL_TIME, LOCAL_DATE, BOOLEAN, NUMBER};
 
         CopyOnWriteArrayList<ColumnType> typeCandidates = new CopyOnWriteArrayList<>(typeArray);

File: core/src/main/java/tech/tablesaw/columns/AbstractColumnType.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * Defines the type of data held by a {@link Column}
  */
-public class ColumnTypeImpl implements ColumnType {
+public abstract class AbstractColumnType implements ColumnType {
 
     private final Comparable<?> missingValue;
 
@@ -31,7 +31,7 @@ public class ColumnTypeImpl implements ColumnType {
 
     private final String printerFriendlyName;
 
-    public ColumnTypeImpl(Comparable<?> missingValue, int byteSize, String name, String printerFriendlyName) {
+    protected AbstractColumnType(Comparable<?> missingValue, int byteSize, String name, String printerFriendlyName) {
         this.missingValue = missingValue;
         this.byteSize = byteSize;
         this.name = name;
@@ -65,7 +65,7 @@ public String getPrinterFriendlyName() {
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
-        ColumnTypeImpl that = (ColumnTypeImpl) o;
+        AbstractColumnType that = (AbstractColumnType) o;
         return byteSize == that.byteSize &&
                 Objects.equal(missingValue, that.missingValue) &&
                 Objects.equal(name, that.name) &&

File: core/src/main/java/tech/tablesaw/io/jdbc/SqlResultSetReader.java
Patch:
@@ -31,8 +31,8 @@
  */
 public class SqlResultSetReader {
 
-    // Maps from supported SQL types to their Airframe 'equivalents'
-    private static final ImmutableMap<Integer, ColumnType> SQL_TYPE_TO_Airframe_TYPE =
+    // Maps from supported SQL types to their Tablesaw equivalents'
+    private static final ImmutableMap<Integer, ColumnType> SQL_TYPE_TO_TABLESAW_TYPE =
             new ImmutableMap.Builder<Integer, ColumnType>()
                     .put(Types.BINARY, ColumnType.BOOLEAN)
                     .put(Types.BOOLEAN, ColumnType.BOOLEAN)
@@ -75,7 +75,7 @@ public static Table read(ResultSet resultSet, String tableName) throws SQLExcept
         for (int i = 1; i <= metaData.getColumnCount(); i++) {
             String name = metaData.getColumnName(i);
 
-            ColumnType type = SQL_TYPE_TO_Airframe_TYPE.get(metaData.getColumnType(i));
+            ColumnType type = SQL_TYPE_TO_TABLESAW_TYPE.get(metaData.getColumnType(i));
             Preconditions.checkState(type != null,
                     "No column type found for %s as specified for column %s", metaData.getColumnType(i), name);
 

File: jsplot/src/examples/java/tech/tablesaw/plotly/TimeSeriesVisualizations.java
Patch:
@@ -14,8 +14,8 @@ public static void main(String[] args) throws Exception {
         Table bush = Table.read().csv("../data/bush.csv");
         Table foxOnly = bush.where(bush.stringColumn("who").equalsIgnoreCase("fox"));
         Figure foxPlot = TimeSeriesPlot.create("George W. Bush approval ratings", foxOnly, "date", "approval");
+        Plot.show(foxPlot);
 
-        System.out.println(foxPlot.asJavascript("div"));
         Plot.show(TimeSeriesPlot.create("George W. Bush approval ratings", bush, "date", "approval", "who"));
 
         Table robberies = Table.read().csv("../data/boston-robberies.csv");

File: jsplot/src/main/java/tech/tablesaw/plotly/components/Page.java
Patch:
@@ -40,7 +40,7 @@ private Map<String, Object> getContext() {
         Map<String, Object> context = new HashMap<>();
         context.put("figureScript", figure.asJavascript(divName));
         context.put("targetDiv", figure.divString(divName));
-        context.put("figureTitle", figure.getLayout().getTitle());
+        context.put("figureTitle", figure.getLayout() != null? figure.getLayout().getTitle() : null);
         return context;
     }
 

File: jsplot/src/main/java/tech/tablesaw/plotly/api/TimeSeriesPlot.java
Patch:
@@ -26,9 +26,10 @@ public static void show(String title, Table table, String dateColX, String yCol,
         ScatterTrace[] traces  = new ScatterTrace[tables.size()];
         for (int i = 0; i < tables.size(); i++) {
             List<Table> tableList = tables.asTableList();
+            Table t = tableList.get(i).sortOn("date");
             traces[i] = ScatterTrace.builder(
-                    tableList.get(i).dateColumn(dateColX),
-                    tableList.get(i).numberColumn(yCol))
+                    t.dateColumn(dateColX),
+                    t.numberColumn(yCol))
                     .showLegend(true)
                     .name(tableList.get(i).name())
                     .mode(ScatterTrace.Mode.LINE)

File: core/src/main/java/tech/tablesaw/api/DoubleColumn.java
Patch:
@@ -136,6 +136,9 @@ public static DoubleColumn create(final String name, final Number[] numbers) {
      * We remove any commas before parsing
      */
     public static double convert(final String stringValue) {
+        if (stringValue == null) {
+            return MISSING_VALUE;
+        }
         if (Strings.isNullOrEmpty(stringValue.trim()) || TypeUtils.MISSING_INDICATORS.contains(stringValue)) {
             return MISSING_VALUE;
         }

File: core/src/main/java/tech/tablesaw/io/TypeUtils.java
Patch:
@@ -299,7 +299,7 @@ public static DateTimeFormatter getDateTimeFormatter(String dateTimeValue) {
         throw new IllegalArgumentException("Could not find datetime parser for " + dateTimeValue);
     }
 
-    private static boolean canParse(DateTimeFormatter formatter, String dateTimeValue) {
+    public static boolean canParse(DateTimeFormatter formatter, String dateTimeValue) {
         try {
             formatter.parse(dateTimeValue);
             return true;

File: core/src/main/java/tech/tablesaw/table/TableSlice.java
Patch:
@@ -160,7 +160,7 @@ private IntIterator intIterator() {
      * @throws IllegalArgumentException if numberColumnName doesn't name a numeric column in this table
      */
     public double reduce(String numberColumnName, AggregateFunction function) {
-        Column column = column(numberColumnName);
+        Column column = table.column(numberColumnName);
         return function.summarize(column.where(selection));
     }
 

File: core/src/main/java/tech/tablesaw/columns/Column.java
Patch:
@@ -41,6 +41,8 @@ static Column create(String columnName, ColumnType type) {
 
     Table summary();
 
+    Object[] asObjectArray();
+
     default Column subset(Selection rows) {
         Column c = this.emptyCopy();
         for (int row : rows) {

File: core/src/main/java/tech/tablesaw/aggregate/CrossTab.java
Patch:
@@ -96,6 +96,8 @@ public static Table counts(Table table, CategoricalColumn column1, CategoricalCo
         }
         if (t.column(0).type().equals(ColumnType.STRING)) {
             t.column(0).appendCell("Total");
+        } else {
+            t.column(0).appendCell("");
         }
         int grandTotal = 0;
         for (int i = 1; i < t.columnCount() - 1; i++) {

File: jsplot/src/main/java/tech/tablesaw/plotly/components/Grid.java
Patch:
@@ -135,7 +135,7 @@ public GridBuilder columns(int columns) {
          * Horizontal space between grid cells, expressed as a fraction of the total width available to one cell.
          * Defaults to 0.1 for coupled-axes grids and 0.2 for independent grids.
          *
-         * @param xGap  a double >= 0 && <= 1
+         * @param xGap  a double &gt;= 0 &amp;&amp; &lt;= 1
          * @return  this GridBuilder
          */
         public GridBuilder xGap(double xGap) {
@@ -148,7 +148,7 @@ public GridBuilder xGap(double xGap) {
          * Vertical space between grid cells, expressed as a fraction of the total height available to one cell.
          * Defaults to 0.1 for coupled-axes grids and 0.3 for independent grids.
          *
-         * @param yGap  a double >= 0 && <= 1
+         * @param yGap  a double &gt;= 0 &amp;&amp; &lt;= 1
          * @return  this GridBuilder
          */
         public GridBuilder yGap(double yGap) {

File: jsplot/src/main/java/tech/tablesaw/plotly/components/Axis.java
Patch:
@@ -430,7 +430,7 @@ public AxisBuilder constrainToward(ConstrainToward constrainToward) {
          * For example, if this value is 10, then every unit on this axis spans 10 times the number of pixels
          * as a unit on the linked axis. Use this for example to create an elevation profile where the vertical
          * scale is exaggerated a fixed amount with respect to the horizontal.
-         * @param scaleRatio    a number >= 1
+         * @param scaleRatio    a number &gt;= 1
          * @return  this AxisBuilder
          */
         public AxisBuilder scaleRatio(double scaleRatio) {

File: jsplot/src/main/java/tech/tablesaw/plotly/components/TickSettings.java
Patch:
@@ -275,7 +275,7 @@ public TickSettings.TickSettingsBuilder placement(TickPlacement placement) {
         /**
          * Specifies the maximum number of ticks for the particular axis. The actual number of ticks will be chosen
          * automatically to be less than or equal to `nticks`. Has an effect only if `tickmode` is set to "auto".
-         * @param nTicks    an int >= 0
+         * @param nTicks a non-negative int
          * @return  this builder
          */
         public TickSettings.TickSettingsBuilder nTicks(int nTicks) {

File: jsplot/src/main/java/tech/tablesaw/plotly/components/TickSettings.java
Patch:
@@ -417,7 +417,7 @@ public TickSettings.TickSettingsBuilder suffix(String suffix) {
          * Sets the placement of the first tick on this axis. Use with `dtick`.
          *
          * If the axis `type` is "log", then you must take the log of your starting tick
-         * (e.g. to set the starting tick to 100, set the `tick0` to 2) except when `dtick`="L<f>"
+         * (e.g. to set the starting tick to 100, set the `tick0` to 2) except when `dtick`="L&lt;f&gt;"
          * (see `dtick` for more info).
          *
          * If the axis `type` is "date", it should be a date string, like date data.
@@ -440,7 +440,7 @@ public TickSettings.TickSettingsBuilder tick0(Object tick0) {
          * If the axis `type` is "log", then ticks are set every 10^(n"dtick) where n is the tick number.
          * For example, to set a tick mark at 1, 10, 100, 1000, ... set dtick to 1. To set tick marks at 1, 100, 10000,
          * ... set dtick to 2. To set tick marks at 1, 5, 25, 125, 625, 3125, ... set dtick to log_10(5),
-         * or 0.69897000433. "log" has several special values; "L<f>", where `f` is a positive number,
+         * or 0.69897000433. "log" has several special values; "L&lt;f&gt;", where `f` is a positive number,
          * gives ticks linearly spaced in value (but not position).
          *
          * For example `tick0` = 0.1, `dtick` = "L0.5" will put ticks at 0.1, 0.6, 1.1, 1.6 etc.
@@ -449,7 +449,7 @@ public TickSettings.TickSettingsBuilder tick0(Object tick0) {
          *
          * If the axis `type` is "date", then you must convert the time to milliseconds.
          * For example, to set the interval between ticks to one day, set `dtick` to 86400000.0.
-         * "date" also has special values "M<n>" gives ticks spaced by a number of months.
+         * "date" also has special values "M&lt;n&gt;" gives ticks spaced by a number of months.
          * `n` must be a positive integer. To set ticks on the 15th of every third month, set `tick0` to "2000-01-15"
          * and `dtick` to "M3". To set ticks every 4 years, set `dtick` to "M48"
          */

File: jsplot/src/main/java/tech/tablesaw/plotly/components/Layout.java
Patch:
@@ -224,6 +224,8 @@ protected Map<String, Object> getContext() {
         if (margin != null) {
             context.put("margin", margin);
         }
+        context.put("decimalSeparator", decimalSeparator);
+        context.put("thousandsSeparator", thousandsSeparator);
         context.put("dragmode", dragMode);
         context.put("showlegend", showLegend);
         context.put("plotbgcolor", plotBgColor);

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -473,7 +473,7 @@ public BooleanColumn lag(int n) {
      * Conditionally update this column, replacing current values with newValue for all rows where the current value
      * matches the selection criteria
      **/
-    public BooleanColumn set(boolean newValue, Selection rowSelection) {
+    public BooleanColumn set(Selection rowSelection, boolean newValue) {
         for (int row : rowSelection) {
             set(row, newValue);
         }

File: core/src/main/java/tech/tablesaw/api/DateColumn.java
Patch:
@@ -315,9 +315,9 @@ public LocalDate min() {
      * matches the selection criteria
      * <p>
      * Example:
-     * myColumn.set(LocalDate.now(), myColumn.valueIsMissing()); // no more missing values
+     * myColumn.set(myColumn.valueIsMissing(), LocalDate.now()); // no more missing values
      */
-    public DateColumn set(LocalDate newValue, Selection rowSelection) {
+    public DateColumn set(Selection rowSelection, LocalDate newValue) {
         int packed = PackedLocalDate.pack(newValue);
         for (int row : rowSelection) {
             set(row, packed);

File: core/src/main/java/tech/tablesaw/api/DateTimeColumn.java
Patch:
@@ -358,9 +358,9 @@ public IntComparator rowComparator() {
      * matches the selection criteria
      * <p>
      * Example:
-     * myColumn.set(LocalDateTime.now(), myColumn.valueIsMissing()); // no more missing values
+     * myColumn.set(myColumn.valueIsMissing(), LocalDateTime.now()); // no more missing values
      */
-    public DateTimeColumn set(LocalDateTime newValue, Selection rowSelection) {
+    public DateTimeColumn set(Selection rowSelection, LocalDateTime newValue) {
         for (int row : rowSelection) {
             set(row, newValue);
         }

File: core/src/main/java/tech/tablesaw/api/StringColumn.java
Patch:
@@ -310,10 +310,10 @@ public StringColumn lag(int n) {
      * matches the selection criteria
      * <p>
      * Examples:
-     * myCatColumn.set("Dog", myCatColumn.isEqualTo("Cat")); // no more cats
-     * myCatColumn.set("Fox", myCatColumn.valueIsMissing()); // no more missing values
+     * myCatColumn.set(myCatColumn.isEqualTo("Cat"), "Dog"); // no more cats
+     * myCatColumn.set(myCatColumn.valueIsMissing(), "Fox"); // no more missing values
      */
-    public StringColumn set(String newValue, Selection rowSelection) {
+    public StringColumn set(Selection rowSelection, String newValue) {
         for (int row : rowSelection) {
             set(row, newValue);
         }

File: core/src/main/java/tech/tablesaw/api/TimeColumn.java
Patch:
@@ -489,9 +489,9 @@ public TimeColumn set(int index, LocalTime value) {
      * matches the selection criteria
      * <p>
      * Example:
-     * myColumn.set(LocalTime.now(), myColumn.valueIsMissing()); // no more missing values
+     * myColumn.set(myColumn.valueIsMissing(), LocalTime.now()); // no more missing values
      */
-    public TimeColumn set(LocalTime newValue, Selection rowSelection) {
+    public TimeColumn set(Selection rowSelection, LocalTime newValue) {
         for (int row : rowSelection) {
             set(row, newValue);
         }

File: core/src/test/java/tech/tablesaw/api/BooleanColumnTest.java
Patch:
@@ -60,7 +60,7 @@ public void testNone() {
     @Test
     public void testSet() {
         assertFalse(column.none());
-        column.set(false, column.isTrue());
+        column.set(column.isTrue(), false);
         assertTrue(column.none());
     }
 

File: core/src/test/java/tech/tablesaw/api/StringColumnTest.java
Patch:
@@ -52,7 +52,7 @@ public void testSummarizeIf() {
 
     @Test
     public void testConditionalSet() {
-        column.set("no Value", column.isEqualTo("Value 4"));
+        column.set(column.isEqualTo("Value 4"), "no Value");
         assertTrue(column.contains("no Value"));
         assertFalse(column.contains("Value 4"));
     }

File: core/src/test/java/tech/tablesaw/api/TimeColumnTest.java
Patch:
@@ -134,7 +134,7 @@ public void testSet() {
         column1.appendCell("11:30:00");
         column1.appendCell("14:00:00");
         column1.appendCell("18:15:30");
-        column1.set(LocalTime.NOON, column1.isBeforeNoon());
+        column1.set(column1.isBeforeNoon(), LocalTime.NOON);
         assertEquals(LocalTime.NOON, column1.get(0));
         assertEquals(LocalTime.NOON, column1.get(1));
         assertNotEquals(LocalTime.NOON, column1.get(2));

File: core/src/test/java/tech/tablesaw/api/NumberColumnTest.java
Patch:
@@ -15,7 +15,7 @@
 package tech.tablesaw.api;
 
 import com.google.common.base.Stopwatch;
-import io.codearte.jfairy.Fairy;
+import com.devskiller.jfairy.Fairy;
 import it.unimi.dsi.fastutil.doubles.DoubleArrayList;
 import org.apache.commons.lang3.RandomUtils;
 import org.apache.commons.math3.stat.StatUtils;

File: core/src/main/java/tech/tablesaw/columns/dates/DateFilters.java
Patch:
@@ -4,7 +4,6 @@
 import it.unimi.dsi.fastutil.ints.IntIterator;
 import tech.tablesaw.api.DateColumn;
 import tech.tablesaw.columns.Column;
-import tech.tablesaw.columns.DateAndTimePredicates;
 import tech.tablesaw.filtering.predicates.IntBiPredicate;
 import tech.tablesaw.selection.BitmapBackedSelection;
 import tech.tablesaw.selection.Selection;

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -256,6 +256,9 @@ private static void addFormatter(Column newColumn, CsvReadOptions options) {
                 return;
             case LOCAL_TIME :
                 ((TimeColumn) newColumn).setFormatter(options.timeFormatter());
+                return;
+            default:
+                return;
         }
     }
 
@@ -446,7 +449,6 @@ public static ColumnType[] detectColumnTypes(InputStream stream, CsvReadOptions
         boolean header = options.header();
         char delimiter = options.separator();
         boolean useSampling = options.sample();
-        Locale locale = options.locale();
 
         int linesToSkip = header ? 1 : 0;
 

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -1030,7 +1030,7 @@ public void doWithRows(Consumer<Row> doable) {
     public boolean detect(Predicate<Row> predicate) {
         Row row = new Row(this);
         while (row.hasNext()) {
-            if (predicate.test(row)) {
+            if (predicate.test(row.next())) {
                 return true;
             }
         }

File: core/src/main/java/tech/tablesaw/io/csv/CsvReadOptions.java
Patch:
@@ -38,7 +38,7 @@ public class CsvReadOptions {
     private final String timeFormat;
     private final Locale locale;
 
-    CsvReadOptions(CsvReadOptions.Builder builder) {
+    private CsvReadOptions(CsvReadOptions.Builder builder) {
         file = builder.file;
         reader = builder.reader;
         tableName = builder.tableName;
@@ -207,5 +207,4 @@ public CsvReadOptions build() {
             return new CsvReadOptions(this);
         }
     }
-
 }

File: core/src/main/java/tech/tablesaw/io/csv/CsvReadOptions.java
Patch:
@@ -149,6 +149,7 @@ public static class Builder {
 
         public Builder file(File file) {
             this.file = file;
+            this.tableName = file.getName();
             return this;
         }
 

File: core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java
Patch:
@@ -66,7 +66,7 @@ default NumberColumn difference(DateTimeColumn column2, ChronoUnit unit) {
             long c1 = this.getLongInternal(r);
             long c2 = column2.getLongInternal(r);
             if (c1 == MISSING_VALUE || c2 == MISSING_VALUE) {
-                newColumn.append(MISSING_VALUE);
+                newColumn.append(NumberColumn.MISSING_VALUE);
             } else {
                 newColumn.append(difference(c1, c2, unit));
             }

File: core/src/main/java/tech/tablesaw/io/csv/CsvReadOptions.java
Patch:
@@ -137,7 +137,7 @@ public static class Builder {
 
         private File file;
         private Reader reader;
-        private String tableName;
+        private String tableName = "";
         private boolean header = true;
         private char separator = ',';
         private boolean sample = true;

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -359,7 +359,7 @@ private static String[] makeColumnNames(ColumnType types[]) {
      * corrected and
      * used to explicitly specify the correct column types.
      */
-    protected static ColumnType[] detectColumnTypes(InputStream stream, boolean header, char delimiter, boolean useSampling, Locale locale)
+    public static ColumnType[] detectColumnTypes(InputStream stream, boolean header, char delimiter, boolean useSampling, Locale locale)
             throws IOException {
 
         int linesToSkip = header ? 1 : 0;

File: core/src/main/java/tech/tablesaw/columns/dates/PackedLocalDate.java
Patch:
@@ -85,6 +85,9 @@ public static byte getMonthValue(int date) {
     }
 
     public static int pack(LocalDate date) {
+        if (date == null) {
+            return DateColumn.MISSING_VALUE;
+        }
         return pack(
                 (short) date.getYear(),
                 (byte) date.getMonthValue(),

File: core/src/test/java/tech/tablesaw/TableFilteringTest.java
Patch:
@@ -160,7 +160,7 @@ public void testFilter3() {
 
         DateColumn dates = result.dateColumn("date");
         NumberColumn approval = result.numberColumn("approval");
-        for (int row = 0; row < table.rowCount(); row++) {
+        for (int row = 0; row < result.rowCount(); row++) {
             assertTrue(PackedLocalDate.isInApril(dates.getIntInternal(row)));
             assertTrue(approval.get(row) > 70);
         }

File: core/src/main/java/tech/tablesaw/api/ColumnType.java
Patch:
@@ -50,6 +50,7 @@ public Column create(String name) {
             case LOCAL_DATE: return DateColumn.create(name);
             case LOCAL_DATE_TIME: return DateTimeColumn.create(name);
             case LOCAL_TIME: return TimeColumn.create(name);
+            case SKIP: throw new IllegalArgumentException("Cannot create column of type SKIP");
         }
         throw new UnsupportedOperationException("Column type " + this.name() + " doesn't support column creation");
     }

File: core/src/main/java/tech/tablesaw/columns/numbers/NumberFilters.java
Patch:
@@ -82,7 +82,7 @@ default Selection isLessThanOrEqualTo(double f) {
 
     Selection isNotIn(Number... doubles);
 
-    Selection isNotIn(double[] doubles);
+    Selection isNotIn(double... doubles);
 
     default Selection isZero() {
         return eval(isZero);

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -281,7 +281,7 @@ public void clear() {
 
     @Override
     public BooleanColumn copy() {
-        return new BooleanColumn(name(), data);
+        return new BooleanColumn(name(), data.clone());
     }
 
     @Override

File: core/src/main/java/tech/tablesaw/aggregate/CrossTab.java
Patch:
@@ -103,9 +103,8 @@ public static Table counts(Table table, CategoricalColumn column1, CategoricalCo
         return t;
     }
 
-
-    public static Table counts(Table table, String column1) {
-        return table.countBy(table.stringColumn(column1));
+    public static Table counts(Table table, String columnName) {
+        return table.countBy(table.categoricalColumn(columnName));
     }
 
     public static Table percents(Table table, String column1) {

File: core/src/main/java/tech/tablesaw/api/StringColumn.java
Patch:
@@ -231,6 +231,7 @@ public Table summary() {
 
     /**
      */
+    @Override
     public Table countByCategory() {
         Table t = new Table("Column: " + name());
         StringColumn categories = create("Category");

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -955,9 +955,8 @@ public Summarizer summarize(NumberColumn column1, NumberColumn column2, NumberCo
     /**
      * Returns a table containing two columns, the grouping column, and a column named "Count" that contains
      * the counts for each grouping column value
-     * Todo: extend count by category to all categorical columns
      */
-    public Table countBy(StringColumn groupingColumn) {
+    public Table countBy(CategoricalColumn groupingColumn) {
         return groupingColumn.countByCategory();
     }
 

File: core/src/main/java/tech/tablesaw/api/DateColumn.java
Patch:
@@ -26,7 +26,7 @@
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.columns.dates.DateColumnFormatter;
 import tech.tablesaw.columns.dates.DateFilters;
-import tech.tablesaw.columns.dates.DateMapUtils;
+import tech.tablesaw.columns.dates.DateMapFunctions;
 import tech.tablesaw.columns.dates.PackedLocalDate;
 import tech.tablesaw.filtering.predicates.IntBiPredicate;
 import tech.tablesaw.io.TypeUtils;
@@ -53,7 +53,7 @@
  * A column in a base table that contains float values
  */
 public class DateColumn extends AbstractColumn implements DateFilters,
-        DateMapUtils, CategoricalColumn, Iterable<LocalDate> {
+        DateMapFunctions, CategoricalColumn, Iterable<LocalDate> {
 
     public static final int MISSING_VALUE = (Integer) ColumnType.LOCAL_DATE.getMissingValue();
 

File: core/src/main/java/tech/tablesaw/api/DateTimeColumn.java
Patch:
@@ -27,7 +27,7 @@
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.columns.datetimes.DateTimeColumnFormatter;
 import tech.tablesaw.columns.datetimes.DateTimeFilters;
-import tech.tablesaw.columns.datetimes.DateTimeMapUtils;
+import tech.tablesaw.columns.datetimes.DateTimeMapFunctions;
 import tech.tablesaw.columns.datetimes.PackedLocalDateTime;
 import tech.tablesaw.io.TypeUtils;
 import tech.tablesaw.selection.Selection;
@@ -52,7 +52,7 @@
  * A column in a table that contains long-integer encoded (packed) local date-time values
  */
 public class DateTimeColumn extends AbstractColumn
-        implements DateTimeMapUtils, DateTimeFilters, Iterable<LocalDateTime> {
+        implements DateTimeMapFunctions, DateTimeFilters, Iterable<LocalDateTime> {
 
     public static final long MISSING_VALUE = (Long) ColumnType.LOCAL_DATE_TIME.getMissingValue();
 

File: core/src/main/java/tech/tablesaw/api/NumberColumn.java
Patch:
@@ -10,7 +10,7 @@
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.columns.numbers.NumberColumnFormatter;
 import tech.tablesaw.columns.numbers.NumberFilters;
-import tech.tablesaw.columns.numbers.NumberMapUtils;
+import tech.tablesaw.columns.numbers.NumberMapFunctions;
 import tech.tablesaw.columns.numbers.NumberReduceUtils;
 import tech.tablesaw.columns.numbers.Stats;
 import tech.tablesaw.filtering.Filter;
@@ -23,7 +23,7 @@
 
 import static tech.tablesaw.api.ColumnType.NUMBER;
 
-public interface NumberColumn extends Column, DoubleIterable, IntConvertibleColumn, NumberMapUtils, NumberReduceUtils, NumberFilters, CategoricalColumn {
+public interface NumberColumn extends Column, DoubleIterable, IntConvertibleColumn, NumberMapFunctions, NumberReduceUtils, NumberFilters, CategoricalColumn {
     double MISSING_VALUE = (Double) NUMBER.getMissingValue();
 
     static boolean valueIsMissing(double value) {

File: core/src/main/java/tech/tablesaw/api/StringColumn.java
Patch:
@@ -32,7 +32,7 @@
 import tech.tablesaw.columns.strings.StringColumnFormatter;
 import tech.tablesaw.columns.strings.StringColumnReference;
 import tech.tablesaw.columns.strings.StringFilters;
-import tech.tablesaw.columns.strings.StringMapUtils;
+import tech.tablesaw.columns.strings.StringMapFunctions;
 import tech.tablesaw.columns.strings.StringReduceUtils;
 import tech.tablesaw.filtering.Filter;
 import tech.tablesaw.io.TypeUtils;
@@ -58,7 +58,7 @@
  * of missing values in this class's methods.
  */
 public class StringColumn extends AbstractColumn
-        implements CategoricalColumn, StringFilters, StringMapUtils, StringReduceUtils {
+        implements CategoricalColumn, StringFilters, StringMapFunctions, StringReduceUtils {
 
     public final StringColumnReference column = new StringColumnReference(this.name());
 

File: core/src/main/java/tech/tablesaw/api/TimeColumn.java
Patch:
@@ -27,7 +27,7 @@
 import tech.tablesaw.columns.times.PackedLocalTime;
 import tech.tablesaw.columns.times.TimeColumnFormatter;
 import tech.tablesaw.columns.times.TimeFilters;
-import tech.tablesaw.columns.times.TimeMapUtils;
+import tech.tablesaw.columns.times.TimeMapFunctions;
 import tech.tablesaw.io.TypeUtils;
 import tech.tablesaw.selection.BitmapBackedSelection;
 import tech.tablesaw.selection.Selection;
@@ -51,7 +51,7 @@
 /**
  * A column in a base table that contains float values
  */
-public class TimeColumn extends AbstractColumn implements Iterable<LocalTime>, TimeFilters, TimeMapUtils {
+public class TimeColumn extends AbstractColumn implements Iterable<LocalTime>, TimeFilters, TimeMapFunctions {
 
     public static final int MISSING_VALUE = (Integer) LOCAL_TIME.getMissingValue();
 

File: core/src/main/java/tech/tablesaw/columns/dates/DateMapFunctions.java
Patch:
@@ -37,7 +37,7 @@
 /**
  * An interface for mapping operations unique to Date columns
  */
-public interface DateMapUtils extends Column {
+public interface DateMapFunctions extends Column {
 
     static String dateColumnName(Column column1, int value, TemporalUnit unit) {
         return column1.name() + ": " + value + " " + unit.toString() + "(s)";

File: core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java
Patch:
@@ -33,7 +33,7 @@
 import static tech.tablesaw.api.DateTimeColumn.MISSING_VALUE;
 import static tech.tablesaw.columns.datetimes.PackedLocalDateTime.*;
 
-public interface DateTimeMapUtils extends Column {
+public interface DateTimeMapFunctions extends Column {
 
     default NumberColumn differenceInMilliseconds(DateTimeColumn column2) {
         return difference(column2, ChronoUnit.MILLIS);

File: core/src/main/java/tech/tablesaw/columns/numbers/NumberMapFunctions.java
Patch:
@@ -22,7 +22,7 @@
 
 import static tech.tablesaw.api.NumberColumn.*;
 
-public interface NumberMapUtils extends Column, NumberReduceUtils, DoubleIterable {
+public interface NumberMapFunctions extends Column, NumberReduceUtils, DoubleIterable {
 
     /**
      * Returns a transformation of the data in this column such that the result has a mean of 0, and a

File: core/src/main/java/tech/tablesaw/columns/strings/StringMapFunctions.java
Patch:
@@ -33,7 +33,7 @@
  * String utility functions. Each function takes one or more String columns as input and produces
  * another Column as output. The resulting column need not be a string column.
  */
-public interface StringMapUtils extends Column {
+public interface StringMapFunctions extends Column {
 
     default StringColumn upperCase() {
         StringColumn newColumn = StringColumn.create(this.name() + "[ucase]");

File: core/src/main/java/tech/tablesaw/columns/times/TimeMapFunctions.java
Patch:
@@ -29,7 +29,7 @@
 import static java.time.temporal.ChronoUnit.*;
 import static tech.tablesaw.api.TimeColumn.*;
 
-public interface TimeMapUtils extends Column {
+public interface TimeMapFunctions extends Column {
 
     default NumberColumn differenceInMilliseconds(TimeColumn column2) {
         return difference(column2, MILLIS);

File: core/src/test/java/tech/tablesaw/columns/dates/DateMapFunctionsTest.java
Patch:
@@ -26,7 +26,7 @@
 
 import static org.junit.Assert.*;
 
-public class DateMapUtilsTest {
+public class DateMapFunctionsTest {
 
     private DateColumn column1;
 

File: core/src/test/java/tech/tablesaw/columns/datetimes/DateTimeMapFunctionsTest.java
Patch:
@@ -32,9 +32,9 @@
 import static org.junit.Assert.assertEquals;
 
 /**
- * Tests for DateTimeMapUtils
+ * Tests for DateTimeMapFunctions
  */
-public class DateTimeMapUtilsTest {
+public class DateTimeMapFunctionsTest {
 
     private DateTimeColumn startCol = DateTimeColumn.create("start");
     private DateTimeColumn stopCol = DateTimeColumn.create("stop");

File: core/src/test/java/tech/tablesaw/columns/numbers/NumberMapFunctionsTest.java
Patch:
@@ -9,7 +9,7 @@
 
 import static org.junit.Assert.*;
 
-public class NumberMapUtilsTest {
+public class NumberMapFunctionsTest {
 
     @Test
     public void testNormalize() {

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -170,7 +170,7 @@ public Table summary() {
         Table table = Table.create(name());
 
         BooleanColumn booleanColumn = create("Value");
-        NumberColumn countColumn = NumberColumn.create("Count");
+        NumberColumn countColumn = DoubleColumn.create("Count");
         table.addColumn(booleanColumn);
         table.addColumn(countColumn);
 
@@ -553,7 +553,7 @@ public int[] asIntArray() {
     }
 
     public NumberColumn asNumberColumn() {
-        NumberColumn numberColumn = NumberColumn.create(this.name() + ": ints", size());
+        NumberColumn numberColumn = DoubleColumn.create(this.name() + ": ints", size());
         ByteArrayList data = data();
         for (int i = 0; i < size(); i++) {
             numberColumn.append(data.getByte(i));

File: core/src/main/java/tech/tablesaw/api/DateTimeColumn.java
Patch:
@@ -362,7 +362,7 @@ public DateColumn date() {
     }
 
     public NumberColumn monthNumber() {
-        NumberColumn newColumn = NumberColumn.create(this.name() + " month");
+        NumberColumn newColumn = DoubleColumn.create(this.name() + " month");
         for (int r = 0; r < this.size(); r++) {
             long c1 = this.getPackedDateTime(r);
             if (DateTimeColumn.valueIsMissing(c1)) {
@@ -375,7 +375,7 @@ public NumberColumn monthNumber() {
     }
 
     public NumberColumn year() {
-        NumberColumn newColumn = NumberColumn.create(this.name() + " year");
+        NumberColumn newColumn = DoubleColumn.create(this.name() + " year");
         for (int r = 0; r < this.size(); r++) {
             long c1 = this.getPackedDateTime(r);
             if (DateTimeColumn.valueIsMissing(c1)) {
@@ -494,7 +494,7 @@ public LocalDateTime min() {
     }
 
     public NumberColumn minuteOfDay() {
-        NumberColumn newColumn = NumberColumn.create(this.name() + " minute of day");
+        NumberColumn newColumn = DoubleColumn.create(this.name() + " minute of day");
         for (int r = 0; r < this.size(); r++) {
             long c1 = getPackedDateTime(r);
             if (c1 == DateTimeColumn.MISSING_VALUE) {

File: core/src/main/java/tech/tablesaw/api/Row.java
Patch:
@@ -30,7 +30,7 @@ public Row(Table table) {
 
             if (column instanceof DateColumn) {
                 dateColumnMap.put(column.name(), new PackedDate((DateColumn) column));
-            } else if (column instanceof NumberColumn) {
+            } else if (column instanceof DoubleColumn) {
                 numberColumnMap.put(column.name(), (NumberColumn) column);
             } else if (column instanceof StringColumn) {
                 categoryColumnMap.put(column.name(), (StringColumn) column);

File: core/src/main/java/tech/tablesaw/api/StringColumn.java
Patch:
@@ -232,7 +232,7 @@ public Table summary() {
     public Table countByCategory() {
         Table t = new Table("Column: " + name());
         StringColumn categories = create("Category");
-        NumberColumn counts = NumberColumn.create("Count");
+        NumberColumn counts = DoubleColumn.create("Count");
 
         Int2IntMap valueToCount = new Int2IntOpenHashMap();
 
@@ -506,7 +506,7 @@ public IntArrayList data() {
 
 
     public NumberColumn asNumberColumn() {
-        NumberColumn numberColumn = NumberColumn.create(this.name() + ": codes", size());
+        NumberColumn numberColumn = DoubleColumn.create(this.name() + ": codes", size());
         IntArrayList data = data();
         for (int i = 0; i < size(); i++) {
             numberColumn.append(data.getInt(i));

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -816,7 +816,7 @@ public String printHtml() {
 
     public Table structure() {
         Table t = new Table("Structure of " + name());
-        NumberColumn index = NumberColumn.create("Index", columnCount());
+        NumberColumn index = DoubleColumn.create("Index", columnCount());
         StringColumn columnName = StringColumn.create("Column Name", columnCount());
         StringColumn columnType = StringColumn.create("Column Type", columnCount());
         t.addColumn(index);

File: core/src/main/java/tech/tablesaw/columns/AbstractColumn.java
Patch:
@@ -22,7 +22,7 @@
  */
 public abstract class AbstractColumn implements Column {
 
-    protected static final int DEFAULT_ARRAY_SIZE = 128;
+    public static final int DEFAULT_ARRAY_SIZE = 128;
 
     private String name;
 

File: core/src/main/java/tech/tablesaw/columns/numbers/Stats.java
Patch:
@@ -15,6 +15,7 @@
 package tech.tablesaw.columns.numbers;
 
 import org.apache.commons.math3.stat.descriptive.SummaryStatistics;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
@@ -128,7 +129,7 @@ public double secondMoment() {
     public Table asTable() {
         Table t = Table.create(name);
         StringColumn measure = StringColumn.create("Measure");
-        NumberColumn value = NumberColumn.create("Value");
+        NumberColumn value = DoubleColumn.create("Value");
         t.addColumn(measure);
         t.addColumn(value);
 

File: core/src/main/java/tech/tablesaw/columns/strings/StringMapUtils.java
Patch:
@@ -19,6 +19,7 @@
 import com.google.common.base.Strings;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.commons.text.similarity.LevenshteinDistance;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.columns.Column;
@@ -191,7 +192,7 @@ default StringColumn commonSuffix(Column column2) {
      */
     default NumberColumn distance(Column column2) {
 
-        NumberColumn newColumn = NumberColumn.create(name() + column2.name() + "[distance]");
+        NumberColumn newColumn = DoubleColumn.create(name() + column2.name() + "[distance]");
 
         for (int r = 0; r < size(); r++) {
             String value1 = getString(r);

File: core/src/main/java/tech/tablesaw/io/TypeUtils.java
Patch:
@@ -21,7 +21,7 @@
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.DateColumn;
 import tech.tablesaw.api.DateTimeColumn;
-import tech.tablesaw.api.NumberColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.TimeColumn;
 import tech.tablesaw.columns.Column;
@@ -250,7 +250,7 @@ public static Column newColumn(@Nonnull String name,
             case LOCAL_DATE_TIME:
                 return DateTimeColumn.create(name);
             case NUMBER:
-                return NumberColumn.create(name);
+                return DoubleColumn.create(name);
             case BOOLEAN:
                 return BooleanColumn.create(name);
             case STRING:

File: core/src/main/java/tech/tablesaw/joining/DataFrameJoiner.java
Patch:
@@ -3,6 +3,7 @@
 import com.google.common.collect.Streams;
 import tech.tablesaw.api.DateColumn;
 import tech.tablesaw.api.DateTimeColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
@@ -72,7 +73,7 @@ public Table inner(Table table2, String col2Name) {
                 table2Rows.removeColumns(col2Name);
                 crossProduct(result, table1Rows, table2Rows);
             }
-        } else if (column instanceof NumberColumn) {
+        } else if (column instanceof DoubleColumn) {
             LongIndex index = new LongIndex(table2.numberColumn(col2Name));
             NumberColumn col1 = (NumberColumn) column;
             for (int i = 0; i < col1.size(); i++) {

File: core/src/main/java/tech/tablesaw/table/Relation.java
Patch:
@@ -19,6 +19,7 @@
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.DateColumn;
 import tech.tablesaw.api.DateTimeColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
@@ -208,10 +209,10 @@ public Table structure() {
                 .append(" variables (cols)");
 
         Table structure = Table.create(nameBuilder.toString());
-        structure.addColumn(NumberColumn.create("Index"));
+        structure.addColumn(DoubleColumn.create("Index"));
         structure.addColumn(StringColumn.create("Column Name"));
         structure.addColumn(StringColumn.create("Type"));
-        structure.addColumn(NumberColumn.create("Unique Values"));
+        structure.addColumn(DoubleColumn.create("Unique Values"));
         structure.addColumn(StringColumn.create("First"));
         structure.addColumn(StringColumn.create("Last"));
 

File: core/src/main/java/tech/tablesaw/table/RollingColumn.java
Patch:
@@ -3,6 +3,7 @@
 import org.apache.commons.lang3.StringUtils;
 import tech.tablesaw.aggregate.AggregateFunction;
 import tech.tablesaw.aggregate.AggregateFunctions;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.columns.Column;
 import tech.tablesaw.selection.BitmapBackedSelection;
@@ -40,7 +41,7 @@ private String generateNewColumnName(AggregateFunction function) {
 
     public NumberColumn calc(AggregateFunction function) {
         // TODO: the subset operation copies the array. creating a view would likely be more efficient
-        NumberColumn result = NumberColumn.create(generateNewColumnName(function), column.size());
+        NumberColumn result = DoubleColumn.create(generateNewColumnName(function), column.size());
         for (int i = 0; i < window - 1; i++) {
             result.append(NumberColumn.MISSING_VALUE);
         }
@@ -49,7 +50,7 @@ public NumberColumn calc(AggregateFunction function) {
             selection.addRange(origColIndex, origColIndex + window);
             Column windowedColumn = column.subset(selection);
             double calc;
-            if (windowedColumn instanceof NumberColumn) {
+            if (windowedColumn instanceof DoubleColumn) {
                 calc = function.agg((NumberColumn) windowedColumn);
             } else {
                 throw new IllegalArgumentException("Cannot calculate " + function.functionName()

File: core/src/main/java/tech/tablesaw/table/TableSliceGroup.java
Patch:
@@ -21,6 +21,7 @@
 import com.google.common.collect.Lists;
 import tech.tablesaw.aggregate.AggregateFunction;
 import tech.tablesaw.api.CategoricalColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
@@ -151,7 +152,7 @@ public Table aggregate(ArrayListMultimap<String, AggregateFunction> functions) {
             int functionCount = 0;
             for (AggregateFunction function : entry.getValue()) {
                 String colName = aggregateColumnName(columnName, function.functionName());
-                NumberColumn resultColumn = NumberColumn.create(colName, getSubTables().size());
+                NumberColumn resultColumn = DoubleColumn.create(colName, getSubTables().size());
                 for (TableSlice subTable : getSubTables()) {
                     double result = subTable.reduce(columnName, function);
                     if (functionCount == 0) {

File: core/src/test/java/tech/tablesaw/TableFilteringTest.java
Patch:
@@ -17,6 +17,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import tech.tablesaw.api.DateColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.QueryHelper;
 import tech.tablesaw.api.StringColumn;
@@ -79,7 +80,7 @@ public void testRejectWithMissingValues() {
         String[] values = {"a", "b", "", "d"};
         double[] values2 = {1, Double.NaN, 3, 4};
         StringColumn sc = StringColumn.create("s", values);
-        NumberColumn nc = NumberColumn.create("n", values2);
+        NumberColumn nc = DoubleColumn.create("n", values2);
         Table test = Table.create("test", sc, nc);
         Table result = test.rejectRowsWithMissingValues();
         assertEquals(2, result.rowCount());

File: core/src/test/java/tech/tablesaw/filters/DateTableFiltersTest.java
Patch:
@@ -17,6 +17,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import tech.tablesaw.api.DateColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.dates.DateColumnReference;
@@ -117,7 +118,7 @@ public void testGetMonthValue() {
         }
         Table t = Table.create("Test");
         t.addColumn(dateColumn);
-        NumberColumn index = NumberColumn.indexColumn("index", t.rowCount(), 0);
+        NumberColumn index = DoubleColumn.indexColumn("index", t.rowCount(), 0);
         t.addColumn(index);
 
         assertTrue(t.selectWhere(dateColumn("test").isInJanuary()).numberColumn("index").contains(0.0));
@@ -156,7 +157,7 @@ public void testComparison() {
         dateColumn.appendInternal(packed);
         dateColumn.appendInternal(after);
 
-        NumberColumn index = NumberColumn.indexColumn("index", dateColumn.size(), 0);
+        NumberColumn index = DoubleColumn.indexColumn("index", dateColumn.size(), 0);
         Table t = Table.create("test", dateColumn, index);
 
         assertTrue(t.selectWhere(dateColumn.isBefore(packed)).nCol("index").contains(0));

File: core/src/test/java/tech/tablesaw/filters/DateTimeTableFiltersTest.java
Patch:
@@ -17,6 +17,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import tech.tablesaw.api.DateTimeColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.datetimes.DateTimeColumnReference;
@@ -115,7 +116,7 @@ public void testGetMonthValue() {
         }
         Table t = Table.create("Test");
         t.addColumn(dateTimeColumn);
-        NumberColumn index = NumberColumn.indexColumn("index", t.rowCount(), 0);
+        NumberColumn index = DoubleColumn.indexColumn("index", t.rowCount(), 0);
         t.addColumn(index);
 
         assertTrue(t.selectWhere(dateTimeColumn("test").isInJanuary()).numberColumn("index").contains(0.0));
@@ -150,7 +151,7 @@ public void testComparison() {
         dateTimeColumn.append(date);
         dateTimeColumn.append(afterDate);
 
-        NumberColumn index = NumberColumn.indexColumn("index", dateTimeColumn.size(), 0);
+        NumberColumn index = DoubleColumn.indexColumn("index", dateTimeColumn.size(), 0);
         Table t = Table.create("test", dateTimeColumn, index);
 
         assertTrue(t.selectWhere(dateTimeColumn("test").isBefore(date)).nCol("index").contains(0));

File: core/src/test/java/tech/tablesaw/filters/TimeDependentFilteringTest.java
Patch:
@@ -143,8 +143,8 @@ private static Table defineSchema() {
         t = Table.create("Observations");
         StringColumn conceptId = StringColumn.create("concept");
         DateColumn date = DateColumn.create("date");
-        NumberColumn value = NumberColumn.create("value");
-        NumberColumn patientId = NumberColumn.create("patient");
+        NumberColumn value =  DoubleColumn.create("value");
+        NumberColumn patientId =  DoubleColumn.create("patient");
         patientId.setPrintFormatter(NumberColumnFormatter.ints());
 
         t.addColumn(conceptId);

File: core/src/test/java/tech/tablesaw/io/string/DataFramePrinterTest.java
Patch:
@@ -1,6 +1,7 @@
 package tech.tablesaw.io.string;
 
 import org.junit.Test;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.Table;
 
@@ -11,7 +12,7 @@ public class DataFramePrinterTest {
 
     @Test
     public void printNull() {
-        NumberColumn col = NumberColumn.create("testCol");
+        NumberColumn col = DoubleColumn.create("testCol");
         col.append(5.0);
         col.appendCell(null);
         col.append(3.0);

File: core/src/test/java/tech/tablesaw/table/RollingColumnTest.java
Patch:
@@ -2,6 +2,7 @@
 
 import org.junit.Assert;
 import org.junit.Test;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 
 import static org.junit.Assert.*;
@@ -12,7 +13,7 @@ public class RollingColumnTest {
     public void testRollingMean() {
         double[] data = new double[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
         double[] sma5 = new double[]{NumberColumn.MISSING_VALUE, NumberColumn.MISSING_VALUE, NumberColumn.MISSING_VALUE, NumberColumn.MISSING_VALUE, 3, 4, 5, 6, 7, 8};
-        NumberColumn result = NumberColumn.create("data", data).rolling(5).mean();
+        NumberColumn result = DoubleColumn.create("data", data).rolling(5).mean();
         assertArrayEquals(sma5, result.asDoubleArray(), 0.000001);
         Assert.assertEquals("dataMean5", result.name());
     }

File: plot/src/main/java/tech/tablesaw/api/plot/Bar.java
Patch:
@@ -18,6 +18,7 @@
 import javafx.embed.swing.JFXPanel;
 import javafx.scene.Scene;
 import javafx.scene.chart.BarChart;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
@@ -65,7 +66,7 @@ public static void show(String title, Table table) {
                 if (table.column(0) instanceof StringColumn) {
                     initAndShowGUI(title, table.stringColumn(0), table.nCol(1), 640, 480);
                 }
-                if (table.column(0) instanceof NumberColumn) {
+                if (table.column(0) instanceof DoubleColumn) {
                     initAndShowGUI(title, table.numberColumn(0), table.nCol(1), 640, 480);
                 }
             } catch (Exception e) {

File: plot/src/main/java/tech/tablesaw/api/plot/HorizontalBar.java
Patch:
@@ -18,6 +18,7 @@
 import javafx.embed.swing.JFXPanel;
 import javafx.scene.Scene;
 import javafx.scene.chart.BarChart;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
@@ -66,7 +67,7 @@ public static void show(String title, Table table) {
                 if (table.column(0) instanceof StringColumn) {
                     initAndShowGUI(title, table.stringColumn(0), table.nCol(1), 640, 480);
                 }
-                if (table.column(0) instanceof NumberColumn) {
+                if (table.column(0) instanceof DoubleColumn) {
                     initAndShowGUI(title, table.numberColumn(0), table.nCol(1), 640, 480);
                 }
             } catch (Exception e) {

File: plot/src/main/java/tech/tablesaw/api/plot/Pareto.java
Patch:
@@ -18,6 +18,7 @@
 import javafx.embed.swing.JFXPanel;
 import javafx.scene.Scene;
 import javafx.scene.chart.BarChart;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
@@ -43,7 +44,7 @@ public static void show(String title, Table table) {
                 if (table.column(0) instanceof StringColumn) {
                     initAndShowGUI(title, table.stringColumn(0), table.nCol(1), 640, 480);
                 }
-                if (table.column(0) instanceof NumberColumn) {
+                if (table.column(0) instanceof DoubleColumn) {
                     initAndShowGUI(title, table.numberColumn(0), table.nCol(1), 640, 480);
                 }
             } catch (Exception e) {

File: plot/src/main/java/tech/tablesaw/api/plot/Pie.java
Patch:
@@ -18,6 +18,7 @@
 import javafx.embed.swing.JFXPanel;
 import javafx.scene.Scene;
 import javafx.scene.chart.PieChart;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.NumberColumn;
 import tech.tablesaw.api.StringColumn;
 import tech.tablesaw.api.Table;
@@ -64,7 +65,7 @@ public static void show(String title, Table table) throws Exception {
                 if (table.column(0) instanceof StringColumn) {
                     initAndShowGUI(title, table.stringColumn(0), table.nCol(1), 640, 480);
                 }
-                if (table.column(0) instanceof NumberColumn) {
+                if (table.column(0) instanceof DoubleColumn) {
                     initAndShowGUI(title, table.numberColumn(0), table.nCol(1), 640, 480);
                 }
             } catch (Exception e) {

File: core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeColumnReference.java
Patch:
@@ -48,7 +48,7 @@
 import tech.tablesaw.columns.datetimes.filters.IsWednesday;
 import tech.tablesaw.columns.datetimes.filters.NotEqualTo;
 import tech.tablesaw.filtering.Filter;
-import tech.tablesaw.filtering.composite.AnyOf;
+import tech.tablesaw.filtering.composite.AllOf;
 
 import java.time.LocalDate;
 import java.time.LocalDateTime;
@@ -84,11 +84,11 @@ public IsBefore isBefore(LocalDate value) {
     }
 
     public Filter isBetweenExcluding(LocalDateTime lowValue, LocalDateTime highValue) {
-        return AnyOf.anyOf(isAfter(lowValue), isBefore(highValue));
+        return AllOf.allOf(isAfter(lowValue), isBefore(highValue));
     }
 
     public Filter isBetweenIncluding(LocalDateTime lowValue, LocalDateTime highValue) {
-        return AnyOf.anyOf(isOnOrAfter(lowValue), isOnOrBefore(highValue));
+        return AllOf.allOf(isOnOrAfter(lowValue), isOnOrBefore(highValue));
     }
 
     public EqualTo isEqualTo(LocalDateTime value) {

File: core/src/test/java/tech/tablesaw/filters/DateFiltersTest.java
Patch:
@@ -18,7 +18,6 @@
 import org.junit.Test;
 import tech.tablesaw.api.DateColumn;
 import tech.tablesaw.api.Table;
-import tech.tablesaw.columns.dates.PackedLocalDate;
 import tech.tablesaw.selection.Selection;
 
 import java.time.LocalDate;
@@ -123,8 +122,8 @@ public void testComparison() {
         int before = minusDays(1, packed);
         int after = plusDays(1, packed);
 
-        LocalDate beforeDate = PackedLocalDate.asLocalDate(before);
-        LocalDate afterDate = PackedLocalDate.asLocalDate(after);
+        LocalDate beforeDate = asLocalDate(before);
+        LocalDate afterDate = asLocalDate(after);
 
         dateColumn.appendInternal(before);
         dateColumn.appendInternal(packed);

File: core/src/test/java/tech/tablesaw/filters/DateTableFiltersTest.java
Patch:
@@ -147,14 +147,13 @@ public void testComparison() {
         DateColumn dateColumn = DateColumn.create("test");
 
         int before = minusDays(1, packed);
-        int equal = packed;
         int after = plusDays(1, packed);
 
         LocalDate beforeDate = PackedLocalDate.asLocalDate(before);
         LocalDate afterDate = PackedLocalDate.asLocalDate(after);
 
         dateColumn.appendInternal(before);
-        dateColumn.appendInternal(equal);
+        dateColumn.appendInternal(packed);
         dateColumn.appendInternal(after);
 
         NumberColumn index = NumberColumn.indexColumn("index", dateColumn.size(), 0);

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -343,7 +343,7 @@ public int countFalse() {
     public double proportionTrue() {
         double n = size() - countMissing();
         double trueCount = countTrue();
-        return trueCount / size();
+        return trueCount / n;
     }
 
     /**

File: core/src/main/java/tech/tablesaw/columns/times/filters/IsAfter.java
Patch:
@@ -41,6 +41,6 @@ public Selection apply(Table relation) {
     @Override
     public Selection apply(Column column) {
         TimeColumn timeColumn = (TimeColumn) column;
-        return timeColumn.select(PackedLocalTime::isAfter, PackedLocalTime.pack(value));
+        return timeColumn.eval(PackedLocalTime::isAfter, PackedLocalTime.pack(value));
     }
 }

File: core/src/main/java/tech/tablesaw/columns/times/filters/IsAfterNoon.java
Patch:
@@ -44,7 +44,7 @@ public Selection apply(Column column) {
         switch (type) {
             case LOCAL_TIME:
                 TimeColumn timeColumn = (TimeColumn) column;
-                return timeColumn.select(PackedLocalTime::PM);
+                return timeColumn.eval(PackedLocalTime::PM);
             case LOCAL_DATE_TIME:
                 DateTimeColumn dateTimeColumn = (DateTimeColumn) column;
                 return dateTimeColumn.eval(PackedLocalDateTime::PM);

File: core/src/main/java/tech/tablesaw/columns/times/filters/IsBefore.java
Patch:
@@ -41,6 +41,6 @@ public Selection apply(Table relation) {
     @Override
     public Selection apply(Column column) {
         TimeColumn timeColumn = (TimeColumn) column;
-        return timeColumn.select(PackedLocalTime::isBefore, PackedLocalTime.pack(value));
+        return timeColumn.eval(PackedLocalTime::isBefore, PackedLocalTime.pack(value));
     }
 }

File: core/src/main/java/tech/tablesaw/columns/times/filters/IsBeforeNoon.java
Patch:
@@ -44,7 +44,7 @@ public Selection apply(Column column) {
         switch (type) {
             case LOCAL_TIME:
                 TimeColumn timeColumn = (TimeColumn) column;
-                return timeColumn.select(PackedLocalTime::AM);
+                return timeColumn.eval(PackedLocalTime::AM);
             case LOCAL_DATE_TIME:
                 DateTimeColumn dateTimeColumn = (DateTimeColumn) column;
                 return dateTimeColumn.eval(PackedLocalDateTime::AM);

File: core/src/main/java/tech/tablesaw/columns/times/filters/IsMidnight.java
Patch:
@@ -44,7 +44,7 @@ public Selection apply(Column column) {
         switch (type) {
             case LOCAL_TIME:
                 TimeColumn timeColumn = (TimeColumn) column;
-                return timeColumn.select(PackedLocalTime::isMidnight);
+                return timeColumn.eval(PackedLocalTime::isMidnight);
             case LOCAL_DATE_TIME:
                 DateTimeColumn dateTimeColumn = (DateTimeColumn) column;
                 return dateTimeColumn.eval(PackedLocalDateTime::isMidnight);

File: core/src/main/java/tech/tablesaw/columns/times/filters/IsNoon.java
Patch:
@@ -44,7 +44,7 @@ public Selection apply(Column column) {
         switch (type) {
             case LOCAL_TIME:
                 TimeColumn timeColumn = (TimeColumn) column;
-                return timeColumn.select(PackedLocalTime::isNoon);
+                return timeColumn.eval(PackedLocalTime::isNoon);
             case LOCAL_DATE_TIME:
                 DateTimeColumn dateTimeColumn = (DateTimeColumn) column;
                 return dateTimeColumn.eval(PackedLocalDateTime::isNoon);

File: core/src/main/java/tech/tablesaw/api/QueryHelper.java
Patch:
@@ -37,7 +37,7 @@
 public class QueryHelper {
 
     /**
-     * Returns a column reference for a Stringolumn with the given name. It will be resolved at query time by associating
+     * Returns a column reference for a String column with the given name. It will be resolved at query time by associating
      * it with a table. At construction time, the columnType is unknown, so the user has to pick the
      * correct type.
      */

File: core/src/main/java/tech/tablesaw/api/Row.java
Patch:
@@ -26,7 +26,6 @@ public class Row implements Iterator<Row> {
     public Row(Table table) {
         this.table = table;
         rowNumber = -1;
-        Map<String, Column> map = new HashMap<>();
         for (Column column : table.columns()) {
 
             if (column instanceof DateColumn) {

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -867,7 +867,6 @@ public DataFrameJoiner join(String columnName) {
         return new DataFrameJoiner(this, columnName);
     }
 
-    @SuppressWarnings("NullableProblems")
     @Override
     public IntIterator iterator() {
 

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -386,7 +386,7 @@ protected static ColumnType[] detectColumnTypes(InputStream stream, boolean head
             while ((nextLine = reader.readNext()) != null) {
                 // initialize the arrays to hold the strings. we don't know how many we need until we read the first row
                 if (rowCount == 0) {
-                    for (String aNextLine : nextLine) {
+                    for (int i = 0; i < nextLine.length; i++) {
                         columnData.add(new ArrayList<>());
                     }
                 }

File: core/src/main/java/tech/tablesaw/sorting/comparators/IntComparatorChain.java
Patch:
@@ -24,6 +24,8 @@
 
 public class IntComparatorChain implements IntComparator, Serializable {
 
+    private static final long serialVersionUID = 1L;
+
     private final List<IntComparator> comparatorChain;
     private BitSet orderingBits;
     private boolean isLocked;

File: core/src/test/java/tech/tablesaw/api/TimeColumnTest.java
Patch:
@@ -15,7 +15,6 @@
 package tech.tablesaw.api;
 
 import tech.tablesaw.columns.Column;
-import tech.tablesaw.columns.times.PackedLocalTime;
 import tech.tablesaw.util.selection.Selection;
 import org.junit.Before;
 import org.junit.Test;

File: core/src/test/java/tech/tablesaw/columns/ColumnTest.java
Patch:
@@ -15,7 +15,6 @@
 package tech.tablesaw.columns;
 
 import tech.tablesaw.api.*;
-import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import tech.tablesaw.io.csv.CsvReadOptions;

File: core/src/main/java/tech/tablesaw/columns/booleans/BooleanMapUtils.java
Patch:
@@ -12,7 +12,7 @@
  * limitations under the License.
  */
 
-package tech.tablesaw.mapping;
+package tech.tablesaw.columns.booleans;
 
 import tech.tablesaw.api.BooleanColumn;
 import tech.tablesaw.columns.Column;
@@ -26,7 +26,7 @@ public interface BooleanMapUtils extends Column {
      * TODO(lwhite): Replace this implementation with a roaring bitmap version
      */
     default BooleanColumn and(BooleanColumn... columns) {
-        BooleanColumn newColumn = new BooleanColumn("");
+        BooleanColumn newColumn = BooleanColumn.create("");
         BooleanColumn thisColumn = (BooleanColumn) this;
         for (int i = 0; i < this.size(); i++) {
             boolean booleanValue = thisColumn.get(i);
@@ -47,7 +47,7 @@ default BooleanColumn and(BooleanColumn... columns) {
     }
 
     default BooleanColumn or(BooleanColumn... columns) {
-        BooleanColumn newColumn = new BooleanColumn("");
+        BooleanColumn newColumn = BooleanColumn.create("");
         BooleanColumn thisColumn = (BooleanColumn) this;
 
         for (int i = 0; i < this.size(); i++) {

File: core/src/test/java/tech/tablesaw/api/TableTest.java
Patch:
@@ -96,7 +96,7 @@ public void testSampleSplit() throws Exception {
         Table[] results = t.sampleSplit(.75);
         assertEquals(t.rowCount(), results[0].rowCount() + results[1].rowCount());
     }
-    
+
     @Test
     public void testRowCount() throws Exception {
         assertEquals(0, table.rowCount());

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -336,7 +336,7 @@ public List<Column> columns(String... columnNames) {
     public List<CategoricalColumn> categoricalColumns(String... columnNames) {
         List<CategoricalColumn> columns = new ArrayList<>();
         for (String columnName : columnNames) {
-            columns.add(categoryColumn(columnName));
+            columns.add(categoricalColumn(columnName));
         }
         return columns;
     }

File: core/src/test/java/tech/tablesaw/api/DoubleColumnTest.java
Patch:
@@ -492,7 +492,7 @@ public void testSubtractLongColumn() {
         DoubleColumn col2 = new DoubleColumn("2", col2Values);
 
         NumericColumn difference = col2.subtract(col1);
-        assertTrue("Expecting DoubleColumn type result", difference instanceof DoubleColumn);
+        assertTrue("Expecting DoubleColumn type runningAverage", difference instanceof DoubleColumn);
         DoubleColumn diffDoubleCol = (DoubleColumn) difference;
         assertTrue(validateEquality(expected, diffDoubleCol));
     }

File: core/src/test/java/tech/tablesaw/api/LongColumnTest.java
Patch:
@@ -84,7 +84,7 @@ public void testSubtractDoubleColumn() {
         Arrays.stream(col2Values).forEach(col2::append);
 
         NumericColumn difference = col1.subtract(col2);
-        assertTrue("Expecting DoubleColumn type result", difference instanceof DoubleColumn);
+        assertTrue("Expecting DoubleColumn type runningAverage", difference instanceof DoubleColumn);
 
         DoubleColumn diffDoubleCol = (DoubleColumn) difference;
         assertEquals("Both sets of data should be the same size.", expected.length, diffDoubleCol.size());
@@ -105,7 +105,7 @@ public void testSubtractIntColumn() {
         Arrays.stream(col2Values).forEach(col2::append);
 
         NumericColumn difference = col1.subtract(col2);
-        assertTrue("Expecting LongColumn type result", difference instanceof LongColumn);
+        assertTrue("Expecting LongColumn type runningAverage", difference instanceof LongColumn);
         LongColumn diffLongCol = (LongColumn) difference;
         assertTrue(validateDifferenceColumn(expected, diffLongCol));
     }

File: core/src/main/java/tech/tablesaw/api/FloatColumn.java
Patch:
@@ -582,6 +582,7 @@ public FloatColumn cube() {
     public FloatColumn remainder(FloatColumn column2) {
         FloatColumn result = new FloatColumn(name() + " % " + column2.name(), size());
         for (int r = 0; r < size(); r++) {
+            // TODO(lwhite): move to NumericColumn and generalize, as with division, multiplication
             result.append(get(r) % column2.get(r));
         }
         return result;

File: core/src/test/java/tech/tablesaw/table/ViewGroupTest.java
Patch:
@@ -90,7 +90,7 @@ public void testWith2GroupingCols() {
         Table t = table.sum("approval").by(splitColumnNames);
 
         // compare the sum of the original column with the sum of the sums of the group table
-        assertEquals(table.intColumn(1).sum(), Math.round(t.doubleColumn(2).sum()));
+        assertEquals(table.shortColumn(1).sum(), Math.round(t.doubleColumn(2).sum()));
         assertEquals(65, tables.size());
     }
 
@@ -114,6 +114,6 @@ public void testCustomFunction() {
     public void testSumGroup() {
         Table groups = table.sum("approval").by("who");
         // compare the sum of the original column with the sum of the sums of the group table
-        assertEquals(table.intColumn(1).sum(), Math.round(groups.doubleColumn(1).sum()));
+        assertEquals(table.shortColumn(1).sum(), Math.round(groups.doubleColumn(1).sum()));
     }
 }
\ No newline at end of file

File: core/src/examples/java/tech/tablesaw/Example1.java
Patch:
@@ -123,7 +123,7 @@ public static void main(String[] args) throws Exception {
 
         CategoryColumn who = table1.categoryColumn("who");
 
-        Table xtab = CrossTab.xTabCount(table1, month, who);
+        Table xtab = CrossTab.counts(table1, month, who);
         out(xtab.print());
 
         out(CrossTab.tablePercents(xtab).print());

File: core/src/main/java/tech/tablesaw/filtering/IntBetweenInclusive.java
Patch:
@@ -33,7 +33,8 @@ public IntBetweenInclusive(ColumnReference reference, int lowValue, int highValu
     public Selection apply(Table relation) {
         IntColumn intColumn = (IntColumn) relation.column(columnReference.getColumnName());
         Selection matches = intColumn.isGreaterThanOrEqualTo(low);
-        matches.toBitmap().and(intColumn.isLessThanOrEqualTo(high).toBitmap());
+        Selection highMatches = intColumn.isLessThanOrEqualTo(high);
+        matches.and(highMatches);
         return matches;
     }
 }

File: plot/src/main/java/tech/tablesaw/api/plot/Bubble.java
Patch:
@@ -64,7 +64,7 @@ public static void show(String chartTitle, NumericColumn x, NumericColumn y, Num
      * @param data column for the bubbles
      */
     public static void show(String chartTitle, NumericColumn x, String xAxis, NumericColumn y, String yAxis, NumericColumn data) {
-        show(chartTitle, x.toDoubleArray(), xAxis, y.toDoubleArray(), yAxis, data.toDoubleArray());
+        show(chartTitle, x.asDoubleArray(), xAxis, y.asDoubleArray(), yAxis, data.asDoubleArray());
     }
     
     /**

File: plot/src/main/java/tech/tablesaw/plotting/smile/SmileHistogram.java
Patch:
@@ -30,7 +30,7 @@ public class SmileHistogram {
 
 
     public static PlotCanvas create(String plotTitle, String xTitle, String yTitle, NumericColumn column) {
-        PlotCanvas canvas = smile.plot.Histogram.plot(column.toDoubleArray());
+        PlotCanvas canvas = smile.plot.Histogram.plot(column.asDoubleArray());
         canvas.setForeground(Color.DARK_GRAY);
         canvas.setTitle(plotTitle);
         canvas.setAxisLabel(0, xTitle);

File: plot/src/main/java/tech/tablesaw/plotting/xchart/XchartQuantile.java
Patch:
@@ -41,7 +41,7 @@ public static void show(String chartTitle, NumericColumn yColumn) {
     }
 
     public static void show(String chartTitle, double[] xData, NumericColumn yColumn, int width, int height) {
-        double[] yData = yColumn.toDoubleArray();
+        double[] yData = yColumn.asDoubleArray();
 
         // Create Chart
         XYChart chart = new XYChart(width, height);

File: smile/src/main/java/tech/tablesaw/api/ml/regression/LeastSquares.java
Patch:
@@ -30,7 +30,7 @@ public class LeastSquares {
     public LeastSquares(NumericColumn responseVariable, NumericColumn... explanatoryVars) {
         this.explanatoryVariables = DoubleArrays.to2dArray(explanatoryVars);
 
-        this.responseVarArray = responseVariable.toDoubleArray();
+        this.responseVarArray = responseVariable.asDoubleArray();
         this.model = new OLS(explanatoryVariables, responseVarArray);
         this.explanatoryVariableCount = explanatoryVars.length;
         this.explanatoryVariableNames = new String[explanatoryVariableCount];

File: core/src/main/java/tech/tablesaw/api/ShortColumn.java
Patch:
@@ -720,5 +720,4 @@ public FloatColumn pctChange() {
         }
         return newColumn;
     }
-
 }

File: plot/src/test/java/tech/tablesaw/api/ml/regression/MoneyballExample.java
Patch:
@@ -45,7 +45,7 @@ public static void main(String[] args) throws Exception {
         Scatter.show("Regular season wins by year", wins, year, moneyball.splitOn(playoffs));
 
         // Calculate the run difference for use in the regression model
-        IntColumn runDifference = moneyball.shortColumn("RS").subtract(moneyball.shortColumn("RA"));
+        IntColumn runDifference = (IntColumn) moneyball.shortColumn("RS").subtract(moneyball.shortColumn("RA"));
         moneyball.addColumn(runDifference);
         runDifference.setName("RD");
 

File: core/src/main/java/tech/tablesaw/api/IntColumn.java
Patch:
@@ -737,7 +737,7 @@ private int add(int val1, int val2) {
         return val1 + val2;
     }
 
-    private int subtract(int val1, int val2) {
+    static int subtract(int val1, int val2) {
         if (val1 == MISSING_VALUE || val2 == MISSING_VALUE) {
             return MISSING_VALUE;
         }

File: core/src/test/java/tech/tablesaw/api/DoubleColumnTest.java
Patch:
@@ -507,11 +507,11 @@ public void testSubtract2Columns() {
         DoubleColumn col1 = new DoubleColumn("1", col1Values);
         DoubleColumn col2 = new DoubleColumn("2", col2Values);
 
-        DoubleColumn difference = DoubleColumn.subtractDouble(col1, col2);
+        DoubleColumn difference = (DoubleColumn) NumericColumn.subtractColumns(col1, col2);
         assertTrue(validateEquality(expected, difference));
 
         // change order to verify size of returned column
-        difference = DoubleColumn.subtractDouble(col2, col1);
+        difference = (DoubleColumn) NumericColumn.subtractColumns(col2, col1);
         expected = new double[]{-0.5, MISSING_VALUE, -3.33, MISSING_VALUE, .01};
         assertTrue(validateEquality(expected, difference));
     }

File: core/src/test/java/tech/tablesaw/api/LongColumnTest.java
Patch:
@@ -119,11 +119,11 @@ public void testSubtract2Columns() {
         LongColumn col1 = new LongColumn("1", col1Values);
         LongColumn col2 = new LongColumn("2", col2Values);
 
-        LongColumn difference = LongColumn.subtractLong(col1, col2);
+        LongColumn difference = (LongColumn) NumericColumn.subtractColumns(col1, col2);
         assertTrue(validateDifferenceColumn(expected, difference));
 
         // change order to verify size of returned column
-        difference = LongColumn.subtractLong(col2, col1);
+        difference = (LongColumn) NumericColumn.subtractColumns(col2, col1);
         expected = new long[]{0, MISSING_VALUE, -4, MISSING_VALUE, 0};
         assertTrue(validateDifferenceColumn(expected, difference));
     }

File: plot/src/main/java/tech/tablesaw/plotting/fx/FxBar.java
Patch:
@@ -52,7 +52,7 @@ public static BarChart<String, Number> chart(String title, CategoryColumn catego
         List<XYChart.Data<String, Number>> data = new ArrayList<>(categoryColumn.size());
 
         for (int i = 0; i < categoryColumn.size(); i++) {
-            data.add(new XYChart.Data<>(categoryColumn.get(i), numericColumn.getFloat(i)));
+            data.add(new XYChart.Data<>(categoryColumn.get(i), numericColumn.getDouble(i)));
         }
 
         barChart.getData().add(getSeries(numericColumn, data));
@@ -69,7 +69,7 @@ public static BarChart<String, Number> chart(String title, ShortColumn categoryC
         List<XYChart.Data<String, Number>> data = new ArrayList<>(categoryColumn.size());
 
         for (int i = 0; i < categoryColumn.size(); i++) {
-            data.add(new XYChart.Data<>(categoryColumn.getString(i), numericColumn.getFloat(i)));
+            data.add(new XYChart.Data<>(categoryColumn.getString(i), numericColumn.getDouble(i)));
         }
 
         barChart.getData().add(getSeries(numericColumn, data));
@@ -85,7 +85,7 @@ public static BarChart<String, Number> chart(String title, IntColumn categoryCol
         List<XYChart.Data<String, Number>> data = new ArrayList<>(categoryColumn.size());
 
         for (int i = 0; i < categoryColumn.size(); i++) {
-            data.add(new XYChart.Data<>(categoryColumn.getString(i), numericColumn.getFloat(i)));
+            data.add(new XYChart.Data<>(categoryColumn.getString(i), numericColumn.getDouble(i)));
         }
 
         barChart.getData().add(getSeries(numericColumn, data));

File: plot/src/main/java/tech/tablesaw/plotting/fx/FxHorizontalBar.java
Patch:
@@ -57,7 +57,7 @@ public static BarChart<Number, String> chart(String title, CategoryColumn catego
         List<XYChart.Data<Number, String>> d2 = new ArrayList<>(numericColumn.size());
 
         for (int i = 0; i < numericColumn.size(); i++) {
-            d2.add(new XYChart.Data<>(numericColumn.getFloat(i), categoryColumn.get(i)));
+            d2.add(new XYChart.Data<>(numericColumn.getDouble(i), categoryColumn.get(i)));
         }
 
         XYChart.Series<Number, String> series1 = getNumberStringSeries(categoryColumn, d2);
@@ -76,7 +76,7 @@ public static BarChart<Number, String> chart(String title, ShortColumn categoryC
         List<XYChart.Data<Number, String>> d2 = new ArrayList<>(numericColumn.size());
 
         for (int i = 0; i < numericColumn.size(); i++) {
-            d2.add(new XYChart.Data<>(numericColumn.getFloat(i), categoryColumn.getString(i)));
+            d2.add(new XYChart.Data<>(numericColumn.getDouble(i), categoryColumn.getString(i)));
         }
 
         XYChart.Series<Number, String> series1 = getNumberStringSeries(categoryColumn, d2);
@@ -94,7 +94,7 @@ public static BarChart<Number, String> chart(String title, IntColumn categoryCol
         List<XYChart.Data<Number, String>> d2 = new ArrayList<>(numericColumn.size());
 
         for (int i = 0; i < numericColumn.size(); i++) {
-            d2.add(new XYChart.Data<>(numericColumn.getFloat(i), categoryColumn.getString(i)));
+            d2.add(new XYChart.Data<>(numericColumn.getDouble(i), categoryColumn.getString(i)));
         }
 
         XYChart.Series<Number, String> series1 = getNumberStringSeries(categoryColumn, d2);

File: plot/src/main/java/tech/tablesaw/plotting/fx/FxPareto.java
Patch:
@@ -55,7 +55,7 @@ public static BarChart<String, Number> chart(
         List<XYChart.Data<String, Number>> d2 = new ArrayList<>(x.size());
 
         for (int i = 0; i < x.size(); i++) {
-            d2.add(new XYChart.Data<>(t.categoryColumn(0).get(i), t.nCol(1).getFloat(i)));
+            d2.add(new XYChart.Data<>(t.categoryColumn(0).get(i), t.nCol(1).getDouble(i)));
         }
         XYChart.Series<String, Number> series1
                 = new XYChart.Series<>(FXCollections.observableList(d2));
@@ -84,7 +84,7 @@ public static BarChart<String, Number> chart(String title, IntColumn categoryCol
         List<XYChart.Data<String, Number>> data = new ArrayList<>(categoryColumn.size());
 
         for (int i = 0; i < categoryColumn.size(); i++) {
-            data.add(new XYChart.Data<>(categoryColumn.getString(i), numericColumn.getFloat(i)));
+            data.add(new XYChart.Data<>(categoryColumn.getString(i), numericColumn.getDouble(i)));
         }
 
         barChart.getData().add(getSeries(numericColumn, data));
@@ -104,7 +104,7 @@ public static BarChart<String, Number> chart(String title, ShortColumn categoryC
         List<XYChart.Data<String, Number>> data = new ArrayList<>(categoryColumn.size());
 
         for (int i = 0; i < categoryColumn.size(); i++) {
-            data.add(new XYChart.Data<>(categoryColumn.getString(i), numericColumn.getFloat(i)));
+            data.add(new XYChart.Data<>(categoryColumn.getString(i), numericColumn.getDouble(i)));
         }
 
         barChart.getData().add(getSeries(numericColumn, data));

File: plot/src/main/java/tech/tablesaw/plotting/fx/FxPie.java
Patch:
@@ -42,7 +42,7 @@ public static PieChart chart(String title, CategoryColumn categoryColumn, Numeri
         List<PieChart.Data> data = new ArrayList<>(categoryColumn.size());
 
         for (int i = 0; i < categoryColumn.size(); i++) {
-            data.add(new PieChart.Data(categoryColumn.getString(i), numericColumn.getFloat(i)));
+            data.add(new PieChart.Data(categoryColumn.getString(i), numericColumn.getDouble(i)));
         }
 
         return createChart(title, data);
@@ -54,7 +54,7 @@ public static PieChart chart(String title, ShortColumn categoryColumn, NumericCo
 
         for (int i = 0; i < categoryColumn.size(); i++) {
             String name = Short.toString(categoryColumn.get(i));
-            data.add(new PieChart.Data(name, numericColumn.getFloat(i)));
+            data.add(new PieChart.Data(name, numericColumn.getDouble(i)));
         }
 
         return createChart(title, data);
@@ -66,7 +66,7 @@ public static PieChart chart(String title, IntColumn categoryColumn, NumericColu
 
         for (int i = 0; i < categoryColumn.size(); i++) {
             String name = Integer.toString(categoryColumn.get(i));
-            data.add(new PieChart.Data(name, numericColumn.getFloat(i)));
+            data.add(new PieChart.Data(name, numericColumn.getDouble(i)));
         }
 
         return createChart(title, data);

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -903,12 +903,15 @@ public SummaryFunction variance(String numericColumnName) {
     public SummaryFunction stdDev(String numericColumnName) {
         return new SummaryFunction(this, numericColumnName, stdDev);
     }
+
     public SummaryFunction count(String numericColumnName) {
         return new SummaryFunction(this, numericColumnName, count);
     }
+
     public SummaryFunction max(String numericColumnName) {
         return new SummaryFunction(this, numericColumnName, max);
     }
+
     public SummaryFunction min(String numericColumnName) {
       return new SummaryFunction(this, numericColumnName, min);
     }

File: core/src/main/java/tech/tablesaw/api/DateTimeColumn.java
Patch:
@@ -290,9 +290,9 @@ public CategoryColumn dayOfWeek() {
         for (int r = 0; r < this.size(); r++) {
             long c1 = this.getLongInternal(r);
             if (c1 == (DateTimeColumn.MISSING_VALUE)) {
-                newColumn.set(r, CategoryColumn.MISSING_VALUE);
+                newColumn.append(CategoryColumn.MISSING_VALUE);
             } else {
-                newColumn.add(PackedLocalDateTime.getDayOfWeek(c1).toString());
+                newColumn.append(PackedLocalDateTime.getDayOfWeek(c1).toString());
             }
         }
         return newColumn;
@@ -303,7 +303,7 @@ public ShortColumn dayOfWeekValue() {
         for (int r = 0; r < this.size(); r++) {
             long c1 = this.getLongInternal(r);
             if (c1 == (DateTimeColumn.MISSING_VALUE)) {
-                newColumn.set(r, ShortColumn.MISSING_VALUE);
+                newColumn.append(ShortColumn.MISSING_VALUE);
             } else {
                 newColumn.append((short) PackedLocalDateTime.getDayOfWeek(c1).getValue());
             }

File: core/src/main/java/tech/tablesaw/io/csv/AddCellToColumnException.java
Patch:
@@ -59,7 +59,7 @@ public class AddCellToColumnException extends RuntimeException {
      * @param line        The original line that caused the Exception
      */
     public AddCellToColumnException(Exception e, int columnIndex, long rowNumber, String[] columnNames, String[] line) {
-        super("Error while addding cell from row " + rowNumber + " and column " + columnNames[columnIndex] + "" +
+        super("Error while adding cell from row " + rowNumber + " and column " + columnNames[columnIndex] + "" +
                 "(position:" + columnIndex + "): " + e.getMessage(), e);
         this.columnIndex = columnIndex;
         this.rowNumber = rowNumber;

File: core/src/test/java/tech/tablesaw/api/DoubleColumnTest.java
Patch:
@@ -465,7 +465,7 @@ public void testSubtractLongColumn() {
         NumericColumn difference = col2.subtract(col1);
         assertTrue("Expecting DoubleColumn type result", difference instanceof DoubleColumn);
         DoubleColumn diffDoubleCol = (DoubleColumn) difference;
-        validateEquality(expected, diffDoubleCol);
+        assertTrue(validateEquality(expected, diffDoubleCol));
     }
 
     @Test
@@ -478,12 +478,12 @@ public void testSubtract2Columns() {
         DoubleColumn col2 = createDoubleColumn(col2Values);
 
         DoubleColumn difference = DoubleColumn.subtractDouble(col1, col2);
-        validateEquality(expected, difference);
+        assertTrue(validateEquality(expected, difference));
 
         // change order to verify size of returned column
         difference = DoubleColumn.subtractDouble(col2, col1);
         expected = new double[]{-0.5, MISSING_VALUE, -3.33, MISSING_VALUE, .01};
-        validateEquality(expected, difference);
+        assertTrue(validateEquality(expected, difference));
     }
 
     private DoubleColumn createDoubleColumn(double[] originalValues) {

File: core/src/main/java/tech/tablesaw/mapping/DateTimeMapUtils.java
Patch:
@@ -18,6 +18,7 @@
 import java.time.temporal.ChronoUnit;
 
 import tech.tablesaw.api.DateTimeColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.IntColumn;
 import tech.tablesaw.api.LongColumn;
 import tech.tablesaw.api.ShortColumn;
@@ -57,7 +58,7 @@ default LongColumn difference(DateTimeColumn column2, ChronoUnit unit) {
             long c1 = this.getLongInternal(r);
             long c2 = column2.getLongInternal(r);
             if (c1 == DateTimeColumn.MISSING_VALUE || c2 == DateTimeColumn.MISSING_VALUE) {
-                newColumn.append(IntColumn.MISSING_VALUE);
+                newColumn.append(LongColumn.MISSING_VALUE);
             } else {
                 newColumn.append(difference(c1, c2, unit));
             }

File: core/src/examples/java/tech/tablesaw/Example1.java
Patch:
@@ -19,11 +19,11 @@
 import tech.tablesaw.api.DateColumn;
 import tech.tablesaw.api.ShortColumn;
 import tech.tablesaw.api.Table;
-import tech.tablesaw.reducing.CrossTab;
+import tech.tablesaw.aggregate.CrossTab;
 import tech.tablesaw.util.Selection;
 
+import static tech.tablesaw.aggregate.AggregateFunctions.range;
 import static tech.tablesaw.api.QueryHelper.*;
-import static tech.tablesaw.reducing.NumericReduceUtils.range;
 
 /**
  *         Example code for:

File: core/src/main/java/tech/tablesaw/columns/packeddata/PackedLocalDateTime.java
Patch:
@@ -70,7 +70,7 @@ public static short getYear(int date) {
         // get first two bytes, then convert to a short
         byte byte1 = (byte) (date >> 24);
         byte byte2 = (byte) (date >> 16);
-        return (short) ((byte2 << 8) + (byte1 & 0xFF));
+        return (short) ((byte1 << 8) + (byte2 & 0xFF));
     }
 
     public static short getYear(long dateTime) {

File: core/src/test/java/tech/tablesaw/api/DateColumnTest.java
Patch:
@@ -112,7 +112,7 @@ public void testMin() {
         assertEquals(PackedLocalDate.asLocalDate(column1.convert("2013-10-23")), actual);
     }
 
-    @Test @Ignore
+    @Test
     public void testSortOn() {
       Table unsorted = Table.read().csv(
           "Date,1 Yr Treasury Rate\n"

File: core/src/test/java/tech/tablesaw/columns/PackedLocalDateTimeTest.java
Patch:
@@ -29,9 +29,6 @@
 import static org.junit.Assert.*;
 import static tech.tablesaw.columns.packeddata.PackedLocalDateTime.*;
 
-/**
- *
- */
 public class PackedLocalDateTimeTest {
 
     @Test

File: core/src/main/java/tech/tablesaw/io/TypeUtils.java
Patch:
@@ -88,7 +88,6 @@ public final class TypeUtils {
             new DateTimeFormatterBuilder()
                     .appendOptional(dtf1)
                     .appendOptional(dtf2)
-                    .appendOptional(dtf2)
                     .appendOptional(dtf3)
                     .appendOptional(dtf4)
                     .appendOptional(dtf5)

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -169,7 +169,7 @@ public void addIndexColumn(String columnName, int startsWith) {
 
         IntColumn indexColumn = new IntColumn(columnName, rowCount());
         for (int i = 0; i < rowCount(); i++) {
-            indexColumn.set(i, i + startsWith);
+            indexColumn.append(i + startsWith);
         }
         addColumn(indexColumn);
     }

File: core/src/main/java/tech/tablesaw/api/ColumnType.java
Patch:
@@ -23,7 +23,7 @@
 public enum ColumnType {
 
     BOOLEAN(Byte.MIN_VALUE),
-    CATEGORY(null),
+    CATEGORY(""),
     FLOAT(Float.NaN),
     DOUBLE(Double.NaN),
     SHORT_INT(Short.MIN_VALUE),

File: core/src/main/java/tech/tablesaw/aggregate/CrossTab.java
Patch:
@@ -231,7 +231,7 @@ public static Table rowPercents(Table xTabCounts) {
         pctTable.addColumn(labels);
 
         for (int i = 0; i < xTabCounts.rowCount(); i++) {
-            labels.add(xTabCounts.column(0).getString(i));
+            labels.append(xTabCounts.column(0).getString(i));
         }
 
         for (int i = 1; i < xTabCounts.columnCount(); i++) {
@@ -263,7 +263,7 @@ public static Table tablePercents(Table xTabCounts) {
         int grandTotal = xTabCounts.intColumn(xTabCounts.columnCount() - 1).get(xTabCounts.rowCount() - 1);
 
         for (int i = 0; i < xTabCounts.rowCount(); i++) {
-            labels.add(xTabCounts.column(0).getString(i));
+            labels.append(xTabCounts.column(0).getString(i));
         }
 
         for (int i = 1; i < xTabCounts.columnCount(); i++) {
@@ -292,7 +292,7 @@ public static Table columnPercents(Table xTabCounts) {
 
         // setup the labels
         for (int i = 0; i < xTabCounts.rowCount(); i++) {
-            labels.add(xTabCounts.column(0).getString(i));
+            labels.append(xTabCounts.column(0).getString(i));
         }
 
         // create the new cols

File: core/src/main/java/tech/tablesaw/api/CategoryColumn.java
Patch:
@@ -122,7 +122,7 @@ public CategoryColumn(String name, List<String> categories) {
         super(name);
         values = new IntArrayList(categories.size());
         for (String string : categories) {
-            addValue(string);
+            append(string);
         }
     }
 
@@ -312,7 +312,7 @@ public List<String> bottom(int n) {
      * @deprecated Use append(String value) instead
      */
     public void add(String stringValue) {
-        addValue(stringValue);
+        addValue(convert(stringValue));
     }
     
     private void addValue(String value) {

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -729,7 +729,7 @@ public Table structure() {
         for (int i = 0; i < columnCount(); i++) {
             Column column = columnList.get(i);
             index.append(i);
-            columnType.add(column.type().name());
+            columnType.append(column.type().name());
         }
         return t;
     }

File: core/src/main/java/tech/tablesaw/table/SubTable.java
Patch:
@@ -99,7 +99,7 @@ void addRow(int rowIndex, Table sourceTable) {
                     break;
                 case CATEGORY:
                     CategoryColumn categoryColumn = (CategoryColumn) column;
-                    categoryColumn.add(sourceTable.categoryColumn(i).get(rowIndex));
+                    categoryColumn.append(sourceTable.categoryColumn(i).get(rowIndex));
                     break;
                 default:
                     throw new IllegalStateException("Unhandled column type updating columns");

File: core/src/main/java/tech/tablesaw/table/TableGroup.java
Patch:
@@ -130,7 +130,7 @@ public Table reduce(String numericColumnName, AggregateFunction function) {
 
         for (SubTable subTable : subTables) {
             double result = subTable.agg(numericColumnName, function);
-            groupColumn.add(subTable.name().replace(SPLIT_STRING, " * "));
+            groupColumn.append(subTable.name().replace(SPLIT_STRING, " * "));
             resultColumn.append((float) result);
         }
         return t;

File: core/src/main/java/tech/tablesaw/table/ViewGroup.java
Patch:
@@ -322,7 +322,7 @@ public NumericSummaryTable agg(Map<String, AggregateFunction> functions) {
           DoubleColumn resultColumn = new DoubleColumn(colName, subTables.size());
           for (TemporaryView subTable : subTables) {
               double result = subTable.reduce(columnName, function);
-              groupColumn.add(subTable.name());
+              groupColumn.append(subTable.name());
               resultColumn.append(result);
           }
           groupTable.addColumn(resultColumn);

File: core/src/test/java/tech/tablesaw/store/StorageManagerTest.java
Patch:
@@ -103,7 +103,7 @@ public void setUp() throws Exception {
         for (int i = 0; i < COUNT; i++) {
             floatColumn.append((float) i);
             localDateColumn.append(LocalDate.now());
-            categoryColumn.add("Category " + i);
+            categoryColumn.append("Category " + i);
             longColumn.append(i);
         }
         table.addColumn(floatColumn);

File: plot/src/main/java/tech/tablesaw/plotting/xchart/XchartQuantile.java
Patch:
@@ -21,13 +21,13 @@
 
 import tech.tablesaw.api.NumericColumn;
 
+import static tech.tablesaw.plotting.xchart.XchartDefaults.*;
+
 /**
  *
  */
 public class XchartQuantile {
 
-    private static final String WINDOW_TITLE = "Tablesaw";
-
     public static void show(String chartTitle, NumericColumn yColumn) {
         double[] x = new double[yColumn.size()];
 
@@ -37,7 +37,7 @@ public static void show(String chartTitle, NumericColumn yColumn) {
 
         NumericColumn copy = (NumericColumn) yColumn.copy();
         copy.sortAscending();
-        show(chartTitle, x, copy, 600, 400);
+        show(chartTitle, x, copy, DEFAULT_WIDTH, DEFAULT_HEIGHT);
     }
 
     public static void show(String chartTitle, double[] xData, NumericColumn yColumn, int width, int height) {

File: core/src/main/java/tech/tablesaw/index/FloatIndex.java
Patch:
@@ -61,7 +61,9 @@ private static void addAllToSelection(IntArrayList tableKeys, Selection selectio
     public Selection get(float value) {
         Selection selection = new BitmapBackedSelection();
         IntArrayList list = index.get(value);
-        addAllToSelection(list, selection);
+        if (list != null) {
+          addAllToSelection(list, selection);
+        }
         return selection;
     }
 

File: core/src/main/java/tech/tablesaw/index/IntIndex.java
Patch:
@@ -100,7 +100,9 @@ private static void addAllToSelection(IntArrayList tableKeys, Selection selectio
     public Selection get(int value) {
         Selection selection = new BitmapBackedSelection();
         IntArrayList list = index.get(value);
-        addAllToSelection(list, selection);
+        if (list != null) {
+          addAllToSelection(list, selection);
+        }
         return selection;
     }
 

File: core/src/main/java/tech/tablesaw/index/LongIndex.java
Patch:
@@ -80,7 +80,9 @@ private static void addAllToSelection(IntArrayList tableKeys, Selection selectio
     public Selection get(long value) {
         Selection selection = new BitmapBackedSelection();
         IntArrayList list = index.get(value);
-        addAllToSelection(list, selection);
+        if (list != null) {
+          addAllToSelection(list, selection);
+        }
         return selection;
     }
 

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -37,7 +37,6 @@
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
-import com.google.common.collect.ImmutableList;
 
 import it.unimi.dsi.fastutil.ints.IntArrayList;
 import it.unimi.dsi.fastutil.ints.IntArrays;
@@ -739,7 +738,7 @@ public Table structure() {
      * @param row the row to select
      * @return the table with the selected rows
      */
-    public Table seclectRow(int row) {
+    public Table selectRow(int row) {
       return selectRows(row, row);
     }
     

File: core/src/main/java/tech/tablesaw/mapping/BooleanMapUtils.java
Patch:
@@ -37,7 +37,6 @@ default BooleanColumn and(BooleanColumn... columns) {
                 for (BooleanColumn booleanColumn : columns) {
                     result = booleanColumn.get(i);
                     if (!result) {
-                        newColumn.append(false);
                         break;
                     }
                 }
@@ -60,7 +59,6 @@ default BooleanColumn or(BooleanColumn... columns) {
                 for (BooleanColumn booleanColumn : columns) {
                     result = booleanColumn.get(i);
                     if (result) {
-                        newColumn.append(true);
                         break;
                     }
                 }

File: core/src/main/java/tech/tablesaw/api/DoubleColumn.java
Patch:
@@ -346,7 +346,7 @@ public Selection isEqualTo(DoubleColumn d) {
     @Override
     public String getString(int row) {
         double value = data.getDouble(row);
-        if (value != MISSING_VALUE) {
+        if (value != value) { // it's NaN 
             return String.valueOf(value);
         }
         return "";

File: core/src/main/java/tech/tablesaw/api/FloatColumn.java
Patch:
@@ -363,7 +363,7 @@ public Selection isEqualTo(FloatColumn f) {
     @Override
     public String getString(int row) {
         float value = data.getFloat(row);
-        if (value != MISSING_VALUE) {
+        if (value != value) { // it's NaN
             return String.valueOf(value);
         }
         return "";

File: core/src/main/java/tech/tablesaw/api/DateColumn.java
Patch:
@@ -275,7 +275,7 @@ public CategoryColumn dayOfWeek() {
         for (int r = 0; r < this.size(); r++) {
             int c1 = this.getIntInternal(r);
             if (c1 == DateColumn.MISSING_VALUE) {
-                newColumn.add(null);
+                newColumn.add(CategoryColumn.MISSING_VALUE);
             } else {
                 newColumn.add(PackedLocalDate.getDayOfWeek(c1).toString());
             }

File: core/src/main/java/tech/tablesaw/api/DateTimeColumn.java
Patch:
@@ -288,7 +288,7 @@ public CategoryColumn dayOfWeek() {
         for (int r = 0; r < this.size(); r++) {
             long c1 = this.getLongInternal(r);
             if (c1 == (DateTimeColumn.MISSING_VALUE)) {
-                newColumn.set(r, null);
+                newColumn.set(r, CategoryColumn.MISSING_VALUE);
             } else {
                 newColumn.add(PackedLocalDateTime.getDayOfWeek(c1).toString());
             }

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -159,7 +159,7 @@ public static Sort getSort(String... columnNames) {
      */
     public void addIndexColumn(String columnName, int startsWith) {
 
-        IntColumn indexColumn = new IntColumn("Index", rowCount());
+        IntColumn indexColumn = new IntColumn(columnName, rowCount());
         for (int i = 0; i < rowCount(); i++) {
             indexColumn.set(i, i + startsWith);
         }

File: core/src/main/java/tech/tablesaw/io/TypeUtils.java
Patch:
@@ -130,6 +130,8 @@ public final class TypeUtils {
 
     private static final DateTimeFormatter dtTimef7 =
             DateTimeFormatter.ofPattern("M/d/yy H:mm");
+    private static final DateTimeFormatter dtTimef8 =
+            DateTimeFormatter.ofPattern("M/d/yyyy h:mm:ss a");
 
     // A formatter that handles date time formats defined above
     public static final DateTimeFormatter DATE_TIME_FORMATTER =
@@ -142,6 +144,7 @@ public final class TypeUtils {
                     .appendOptional(dtTimef5)
                     .appendOptional(dtTimef6)
                     .appendOptional(dtTimef7)
+                    .appendOptional(dtTimef8)
                     .toFormatter();
     private static final DateTimeFormatter timef1 = DateTimeFormatter.ofPattern("HH:mm:ss.SSS");
     private static final DateTimeFormatter timef2 = DateTimeFormatter.ofPattern("hh:mm:ss a");

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -356,7 +356,7 @@ public ByteArrayList data() {
     }
 
     public void set(int i, boolean b) {
-        data.set(i, b ? (byte) 1 : (byte) 0);
+        data.add(i, b ? (byte) 1 : (byte) 0);
     }
 
     @Override

File: core/src/main/java/tech/tablesaw/api/CategoryColumn.java
Patch:
@@ -263,7 +263,7 @@ public void set(int rowIndex, String stringValue) {
         } else {
             valueId = lookupTable.get(stringValue);
         }
-        values.set(rowIndex, valueId);
+        values.add(rowIndex, valueId);
     }
 
     @Override

File: core/src/main/java/tech/tablesaw/api/DateColumn.java
Patch:
@@ -157,7 +157,7 @@ public IntArrayList data() {
     }
 
     public void set(int index, int value) {
-        data.set(index, value);
+        data.add(index, value);
     }
 
     public void append(LocalDate f) {

File: core/src/main/java/tech/tablesaw/api/DoubleColumn.java
Patch:
@@ -635,7 +635,7 @@ public double getDouble(int index) {
     }
 
     public void set(int r, double value) {
-        data.set(r, value);
+        data.add(r, value);
     }
 
     // TODO(lwhite): Reconsider the implementation of this functionality to allow user to provide a specific max error.

File: core/src/main/java/tech/tablesaw/api/FloatColumn.java
Patch:
@@ -637,7 +637,7 @@ public float getFloat(int index) {
     }
 
     public void set(int r, float value) {
-        data.set(r, value);
+        data.add(r, value);
     }
 
     // TODO(lwhite): Reconsider the implementation of this functionality to allow user to provide a specific max error.

File: core/src/main/java/tech/tablesaw/api/IntColumn.java
Patch:
@@ -120,7 +120,7 @@ public void append(int i) {
     }
 
     public void set(int index, int value) {
-        data.set(index, value);
+        data.add(index, value);
     }
 
     public Selection isLessThan(int i) {

File: core/src/main/java/tech/tablesaw/api/LongColumn.java
Patch:
@@ -123,7 +123,7 @@ public void append(long i) {
     }
 
     public void set(int index, long value) {
-        data.set(index, value);
+        data.add(index, value);
     }
 
     public Selection isLessThan(long i) {

File: core/src/main/java/tech/tablesaw/api/ShortColumn.java
Patch:
@@ -120,7 +120,7 @@ public void append(short i) {
     }
 
     public void set(int index, short value) {
-        data.set(index, value);
+        data.add(index, value);
     }
 
     public Selection isLessThan(int i) {

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -153,7 +153,9 @@ public static Sort getSort(String... columnNames) {
     }
 
     /**
-     * Creates an IntColumn containing the integers from star to rowCount() and adds it to this table
+     * Creates an IntColumn containing the integers from startsWith to rowCount() and adds it to this table.
+     * Can be used for maintaining/restoring a specific order on data without an existing order column, or for
+     * generating scatter/line plots where the variation of points in some order is what you're trying to see.
      */
     public void addIndexColumn(String columnName, int startsWith) {
 

File: core/src/main/java/tech/tablesaw/table/Relation.java
Patch:
@@ -138,7 +138,7 @@ public Column column(String columnName) {
     /**
      * Returns a String representing the value found at column index c and row index r
      */
-    public abstract String get(int c, int r);
+    public abstract String get(int r, int c);
 
     /**
      * Returns the name of this relation

File: core/src/main/java/tech/tablesaw/util/Selection.java
Patch:
@@ -25,11 +25,11 @@ public interface Selection extends IntIterable {
 
     int[] toArray();
 
+    RoaringBitmap toBitmap();
+
     /**
      * Returns an IntArrayList containing the ints in this selection
      */
-    RoaringBitmap toBitmap();
-
     IntArrayList toIntArrayList();
 
     /**

File: core/src/main/java/tech/tablesaw/util/DictionaryMap.java
Patch:
@@ -67,7 +67,7 @@ public void remove(short key) {
     }
 
     public void remove(String value) {
-        int key = valueToKey.remove(value);
+        int key = valueToKey.removeInt(value);
         keyToValue.remove(key);
     }
 

File: core/src/main/java/tech/tablesaw/table/Relation.java
Patch:
@@ -186,7 +186,7 @@ public String toString(int rowLimit) {
     
     @Override
     public String toString() {
-      return toString(50);
+      return toString(20);
     }
 
     /**

File: core/src/main/java/tech/tablesaw/api/FloatColumn.java
Patch:
@@ -300,10 +300,10 @@ public Selection isNegative() {
         return select(isNegative);
     }
     public Selection isPositive() {
-        return select(isZero);
+        return select(isPositive);
     }
     public Selection isNonNegative() {
-        return select(isZero);
+        return select(isNonNegative);
     }
 
     public Selection isMissing() {

File: core/src/test/java/tech/tablesaw/api/DateColumnTest.java
Patch:
@@ -4,6 +4,7 @@
 import org.junit.Test;
 
 import java.time.LocalDate;
+import java.util.Locale;
 
 import static org.junit.Assert.assertEquals;
 
@@ -17,7 +18,7 @@ public class DateColumnTest {
     @Before
     public void setUp() throws Exception {
         Table table = Table.create("Test");
-        column1 = new DateColumn("Game date");
+        column1 = new DateColumn("Game date", Locale.ENGLISH);
         table.addColumn(column1);
     }
 

File: core/src/test/java/tech/tablesaw/mapping/DateMapUtilsTest.java
Patch:
@@ -8,6 +8,7 @@
 import tech.tablesaw.api.TimeColumn;
 
 import java.time.LocalTime;
+import java.util.Locale;
 
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
@@ -19,7 +20,7 @@ public class DateMapUtilsTest {
     @Before
     public void setUp() throws Exception {
         Table table = Table.create("Test");
-        column1 = new DateColumn("Game date");
+        column1 = new DateColumn("Game date", Locale.ENGLISH);
         table.addColumn(column1);
     }
 

File: core/src/main/java/tech/tablesaw/io/csv/CsvReader.java
Patch:
@@ -287,7 +287,7 @@ public static Table read(CsvReadOptions options) throws IOException {
             table = Table.create(options.tableName());
             cleanNames(headerRow);
             for (int x = 0; x < types.length; x++) {
-                if (types[x] != ColumnType.SKIP) {
+                if (types[x] != SKIP) {
                     String columnName = headerRow.get(x);
                     if (Strings.isNullOrEmpty(columnName)) {
                         columnName = "Column " + table.columnCount();

File: core/src/main/java/tech/tablesaw/api/IntConvertibleColumn.java
Patch:
@@ -8,7 +8,7 @@ public interface IntConvertibleColumn {
 
     int[] toIntArray();
 
-    default Set<Integer> asSet() {
+    default Set<Integer> asIntegerSet() {
       return new IntOpenHashSet(toIntArray());
     }
 

File: core/src/main/java/tech/tablesaw/api/ml/classification/DecisionTree.java
Patch:
@@ -30,7 +30,7 @@ public int predict(double[] data) {
     public ConfusionMatrix predictMatrix(IntConvertibleColumn labels, NumericColumn... predictors) {
         Preconditions.checkArgument(predictors.length > 0);
 
-        SortedSet<Object> labelSet = new TreeSet<>(labels.asSet());
+        SortedSet<Object> labelSet = new TreeSet<>(labels.asIntegerSet());
         ConfusionMatrix confusion = new StandardConfusionMatrix(labelSet);
 
         populateMatrix(labels.toIntArray(), confusion, predictors);

File: core/src/main/java/tech/tablesaw/api/ml/classification/Knn.java
Patch:
@@ -30,7 +30,7 @@ public int predict(double[] data) {
     public ConfusionMatrix predictMatrix(IntConvertibleColumn labels, NumericColumn... predictors) {
         Preconditions.checkArgument(predictors.length > 0);
 
-        SortedSet<Object> labelSet = new TreeSet<>(labels.asSet());
+        SortedSet<Object> labelSet = new TreeSet<>(labels.asIntegerSet());
         ConfusionMatrix confusion = new StandardConfusionMatrix(labelSet);
 
         populateMatrix(labels.toIntArray(), confusion, predictors);

File: core/src/main/java/tech/tablesaw/api/ml/classification/Lda.java
Patch:
@@ -39,7 +39,7 @@ public int predict(double[] data) {
     public ConfusionMatrix predictMatrix(IntConvertibleColumn labels, NumericColumn... predictors) {
         Preconditions.checkArgument(predictors.length > 0);
 
-        SortedSet<Object> labelSet = new TreeSet<>(labels.asSet());
+        SortedSet<Object> labelSet = new TreeSet<>(labels.asIntegerSet());
         ConfusionMatrix confusion = new StandardConfusionMatrix(labelSet);
 
         populateMatrix(labels.toIntArray(), confusion, predictors);

File: core/src/main/java/tech/tablesaw/api/ml/classification/LogisticRegression.java
Patch:
@@ -53,7 +53,7 @@ public int predict(double[] data) {
     public ConfusionMatrix predictMatrix(IntConvertibleColumn labels, NumericColumn... predictors) {
         Preconditions.checkArgument(predictors.length > 0);
 
-        SortedSet<Object> labelSet = new TreeSet<>(labels.asSet());
+        SortedSet<Object> labelSet = new TreeSet<>(labels.asIntegerSet());
         ConfusionMatrix confusion = new StandardConfusionMatrix(labelSet);
 
         populateMatrix(labels.toIntArray(), confusion, predictors);

File: core/src/main/java/tech/tablesaw/api/ml/classification/RandomForest.java
Patch:
@@ -30,7 +30,7 @@ public int predict(double[] data) {
     public ConfusionMatrix predictMatrix(IntConvertibleColumn labels, NumericColumn... predictors) {
         Preconditions.checkArgument(predictors.length > 0);
 
-        SortedSet<Object> labelSet = new TreeSet<>(labels.asSet());
+        SortedSet<Object> labelSet = new TreeSet<>(labels.asIntegerSet());
         ConfusionMatrix confusion = new StandardConfusionMatrix(labelSet);
 
         populateMatrix(labels.toIntArray(), confusion, predictors);

File: core/src/test/java/tech/tablesaw/TableFilteringTest.java
Patch:
@@ -8,7 +8,7 @@
 import tech.tablesaw.api.IntColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.packeddata.PackedLocalDate;
-import tech.tablesaw.io.csv.CsvReader;
+import tech.tablesaw.io.csv.CsvReadOptions;
 
 import java.time.LocalDate;
 
@@ -30,7 +30,7 @@ public class TableFilteringTest {
 
     @Before
     public void setUp() throws Exception {
-        table = CsvReader.read(types, "../data/BushApproval.csv");
+        table = Table.read().csv(CsvReadOptions.builder("../data/BushApproval.csv").columnTypes(types));
     }
 
     @Test

File: core/src/test/java/tech/tablesaw/TableGroupTest.java
Patch:
@@ -6,7 +6,7 @@
 import tech.tablesaw.api.CategoryColumn;
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.Table;
-import tech.tablesaw.io.csv.CsvReader;
+import tech.tablesaw.io.csv.CsvReadOptions;
 import tech.tablesaw.table.SubTable;
 import tech.tablesaw.table.TableGroup;
 
@@ -29,7 +29,7 @@ public class TableGroupTest {
 
     @Before
     public void setUp() throws Exception {
-        table = CsvReader.read(types, "../data/BushApproval.csv");
+        table = Table.read().csv(CsvReadOptions.builder("../data/BushApproval.csv").columnTypes(types));
     }
 
     @Test

File: core/src/test/java/tech/tablesaw/columns/ColumnTest.java
Patch:
@@ -9,7 +9,7 @@
 import tech.tablesaw.api.IntColumn;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.Column;
-import tech.tablesaw.io.csv.CsvReader;
+import tech.tablesaw.io.csv.CsvReadOptions;
 
 import java.time.LocalDate;
 
@@ -31,7 +31,7 @@ public class ColumnTest {
 
     @Before
     public void setUp() throws Exception {
-        table = CsvReader.read(types, "../data/BushApproval.csv");
+        table = Table.read().csv(CsvReadOptions.builder("../data/BushApproval.csv").columnTypes(types));
     }
 
     @Test

File: core/src/test/java/tech/tablesaw/examples/GettingStarted.java
Patch:
@@ -8,7 +8,7 @@
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.Column;
-import tech.tablesaw.io.csv.CsvReader;
+import tech.tablesaw.io.csv.CsvReadOptions;
 
 /**
  * Basic example code
@@ -25,7 +25,7 @@ public class GettingStarted {
 
     @Before
     public void setUp() throws Exception {
-        table = CsvReader.read(types, "../data/BushApproval.csv");
+        table = Table.read().csv(CsvReadOptions.builder("../data/BushApproval.csv").columnTypes(types));
     }
 
     @Test

File: core/src/test/java/tech/tablesaw/index/IntIndexTest.java
Patch:
@@ -7,7 +7,7 @@
 import tech.tablesaw.columns.packeddata.PackedLocalDate;
 import tech.tablesaw.index.DateIndex;
 import tech.tablesaw.index.IntIndex;
-import tech.tablesaw.io.csv.CsvReader;
+import tech.tablesaw.io.csv.CsvReadOptions;
 import tech.tablesaw.util.Selection;
 
 import org.junit.Before;
@@ -35,7 +35,7 @@ public class IntIndexTest {
 
     @Before
     public void setUp() throws Exception {
-        table = CsvReader.read(types, "../data/BushApproval.csv");
+        table = Table.read().csv(CsvReadOptions.builder("../data/BushApproval.csv").columnTypes(types));
         index = new IntIndex(table.intColumn("approval"));
         dateIndex = new DateIndex(table.dateColumn("date"));
     }

File: core/src/test/java/tech/tablesaw/index/LongIndexTest.java
Patch:
@@ -7,7 +7,7 @@
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.LongColumnUtils;
 import tech.tablesaw.index.LongIndex;
-import tech.tablesaw.io.csv.CsvReader;
+import tech.tablesaw.io.csv.CsvReadOptions;
 import tech.tablesaw.util.Selection;
 
 import static org.junit.Assert.assertEquals;
@@ -28,7 +28,7 @@ public class LongIndexTest {
 
     @Before
     public void setUp() throws Exception {
-        table = CsvReader.read(types, "../data/BushApproval.csv");
+        table = Table.read().csv(CsvReadOptions.builder("../data/BushApproval.csv").columnTypes(types));
         index = new LongIndex(table.longColumn("approval"));
     }
 

File: core/src/test/java/tech/tablesaw/integration/ExamplesTest.java
Patch:
@@ -5,7 +5,7 @@
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.QueryHelper;
 import tech.tablesaw.api.Table;
-import tech.tablesaw.io.csv.CsvReader;
+import tech.tablesaw.io.csv.CsvReadOptions;
 import tech.tablesaw.io.csv.CsvWriter;
 
 /**
@@ -20,7 +20,7 @@ public static void main(String[] args) throws Exception {
 
         // Read the CSV file
         ColumnType[] types = {INTEGER, CATEGORY, CATEGORY, FLOAT, FLOAT};
-        Table table = CsvReader.read(types, "../data/bus_stop_test.csv");
+        Table table = Table.read().csv(CsvReadOptions.builder("../data/bus_stop_test.csv").columnTypes(types));
 
         // Look at the column names
         out(table.columnNames());

File: core/src/test/java/tech/tablesaw/io/html/HtmlTableWriterTest.java
Patch:
@@ -6,7 +6,7 @@
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.Column;
-import tech.tablesaw.io.csv.CsvReader;
+import tech.tablesaw.io.csv.CsvReadOptions;
 import tech.tablesaw.io.html.HtmlTableWriter;
 import tech.tablesaw.reducing.NumericReduceUtils;
 import tech.tablesaw.table.ViewGroup;
@@ -23,7 +23,7 @@ public class HtmlTableWriterTest {
 
     @Before
     public void setUp() throws Exception {
-        table = CsvReader.read(types, "../data/BushApproval.csv");
+        table = Table.read().csv(CsvReadOptions.builder("../data/BushApproval.csv").columnTypes(types));
     }
 
     @Test

File: core/src/test/java/tech/tablesaw/table/ViewGroupTest.java
Patch:
@@ -7,7 +7,7 @@
 import tech.tablesaw.api.CategoryColumn;
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.Table;
-import tech.tablesaw.io.csv.CsvReader;
+import tech.tablesaw.io.csv.CsvReadOptions;
 import tech.tablesaw.reducing.NumericReduceFunction;
 import tech.tablesaw.table.TemporaryView;
 import tech.tablesaw.table.ViewGroup;
@@ -41,7 +41,7 @@ public double reduce(double[] data) {
 
     @Before
     public void setUp() throws Exception {
-        table = CsvReader.read(types, "../data/BushApproval.csv");
+        table = Table.read().csv(CsvReadOptions.builder("../data/BushApproval.csv").columnTypes(types));
     }
 
     @Test

File: core/src/main/java/tech/tablesaw/api/CategoryColumn.java
Patch:
@@ -185,7 +185,7 @@ public String get(int rowIndex) {
     }
 
     /**
-     * Returns a List<String> representation of all the values in this column
+     * Returns a List&lt;String&gt; representation of all the values in this column
      *
      * NOTE: Unless you really need a string consider using the column itself for large datasets as it uses much less memory
      */

File: core/src/test/java/tech/tablesaw/api/BooleanColumnTest.java
Patch:
@@ -57,6 +57,8 @@ public void testAddCell() throws Exception {
         assertTrue(lastEntry());
         column.appendCell("N");
         assertFalse(lastEntry());
+        column.appendCell("");
+        assertFalse(lastEntry());
     }
 
     @Test

File: core/src/examples/java/tech/tablesaw/Example1.java
Patch:
@@ -21,7 +21,7 @@ public class Example1 {
     public static void main(String[] args) throws Exception {
 
         // create our table from a flat file:
-        Table table1 = Table.createFromCsv("data/BushApproval.csv");
+        Table table1 = Table.read().csv("data/BushApproval.csv");
 
         // return the name of the table
         out("Table name: " + table1.name());

File: core/src/main/java/tech/tablesaw/api/IntColumn.java
Patch:
@@ -256,8 +256,6 @@ public boolean isEmpty() {
     public void appendCell(String object) {
         try {
             append(convert(object));
-        } catch (NumberFormatException nfe) {
-            throw new NumberFormatException(name() + ": " + nfe.getMessage());
         } catch (NullPointerException e) {
             throw new RuntimeException(name() + ": "
                     + String.valueOf(object) + ": "

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -109,7 +109,7 @@ public BooleanColumn(String name, Selection hits, int columnSize) {
 
     public static boolean convert(String stringValue) {
         if (Strings.isNullOrEmpty(stringValue) || TypeUtils.MISSING_INDICATORS.contains(stringValue)) {
-            return (boolean) ColumnType.BOOLEAN.getMissingValue();
+            return (Boolean) ColumnType.BOOLEAN.getMissingValue();
         } else if (TypeUtils.TRUE_STRINGS.contains(stringValue)) {
             return true;
         } else if (TypeUtils.FALSE_STRINGS.contains(stringValue)) {

File: core/src/main/java/tech/tablesaw/api/ColumnType.java
Patch:
@@ -20,13 +20,13 @@ public enum ColumnType {
     LOCAL_TIME(-1),
     SKIP(null);
 
-    private final Comparable missingValue;
+    private final Comparable<?> missingValue;
 
-    ColumnType(Comparable missingValue) {
+    ColumnType(Comparable<?> missingValue) {
         this.missingValue = missingValue;
     }
 
-    public Comparable getMissingValue() {
+    public Comparable<?> getMissingValue() {
         return missingValue;
     }
 }

File: core/src/main/java/tech/tablesaw/api/DateColumn.java
Patch:
@@ -39,7 +39,7 @@
  */
 public class DateColumn extends AbstractColumn implements DateMapUtils {
 
-    public static final int MISSING_VALUE = (int) ColumnType.LOCAL_DATE.getMissingValue();
+    public static final int MISSING_VALUE = (Integer) ColumnType.LOCAL_DATE.getMissingValue();
 
     private static final int DEFAULT_ARRAY_SIZE = 128;
 
@@ -346,7 +346,7 @@ public IntComparator rowComparator() {
      */
     public int convert(String value) {
         if (Strings.isNullOrEmpty(value) || TypeUtils.MISSING_INDICATORS.contains(value) || value.equals("-1")) {
-            return (int) ColumnType.LOCAL_DATE.getMissingValue();
+            return (Integer) ColumnType.LOCAL_DATE.getMissingValue();
         }
         value = Strings.padStart(value, 4, '0');
 

File: core/src/main/java/tech/tablesaw/api/DoubleColumn.java
Patch:
@@ -34,7 +34,7 @@
  */
 public class DoubleColumn extends AbstractColumn implements DoubleIterable, NumericColumn {
 
-    public static final double MISSING_VALUE = (double) ColumnType.DOUBLE.getMissingValue();
+    public static final double MISSING_VALUE = (Double) ColumnType.DOUBLE.getMissingValue();
     private static final int BYTE_SIZE = 8;
     private static final Pattern COMMA_PATTERN = Pattern.compile(",");
     private static int DEFAULT_ARRAY_SIZE = 128;

File: core/src/main/java/tech/tablesaw/api/FloatColumn.java
Patch:
@@ -36,7 +36,7 @@
  */
 public class FloatColumn extends AbstractColumn implements FloatIterable, NumericColumn {
 
-    public static final float MISSING_VALUE = (float) ColumnType.FLOAT.getMissingValue();
+    public static final float MISSING_VALUE = (Float) ColumnType.FLOAT.getMissingValue();
     private static final int BYTE_SIZE = 4;
     private static final Pattern COMMA_PATTERN = Pattern.compile(",");
     private static int DEFAULT_ARRAY_SIZE = 128;

File: core/src/main/java/tech/tablesaw/api/IntColumn.java
Patch:
@@ -36,7 +36,7 @@
  */
 public class IntColumn extends AbstractColumn implements IntMapUtils, NumericColumn {
 
-    public static final int MISSING_VALUE = (int) ColumnType.INTEGER.getMissingValue();
+    public static final int MISSING_VALUE = (Integer) ColumnType.INTEGER.getMissingValue();
     public static final int DEFAULT_ARRAY_SIZE = 128;
     private static final int BYTE_SIZE = 4;
     private static final Pattern COMMA_PATTERN = Pattern.compile(",");

File: core/src/main/java/tech/tablesaw/api/LongColumn.java
Patch:
@@ -36,7 +36,7 @@
  */
 public class LongColumn extends AbstractColumn implements LongMapUtils, NumericColumn {
 
-    public static final long MISSING_VALUE = (long) ColumnType.LONG_INT.getMissingValue();
+    public static final long MISSING_VALUE = (Long) ColumnType.LONG_INT.getMissingValue();
 
     private static final int DEFAULT_ARRAY_SIZE = 128;
     private static final int BYTE_SIZE = 8;
@@ -83,7 +83,7 @@ public LongColumn(String name) {
      */
     public static long convert(String stringValue) {
         if (Strings.isNullOrEmpty(stringValue) || TypeUtils.MISSING_INDICATORS.contains(stringValue)) {
-            return (long) ColumnType.LONG_INT.getMissingValue();
+            return (Long) ColumnType.LONG_INT.getMissingValue();
         }
         Matcher matcher = COMMA_PATTERN.matcher(stringValue);
         return Long.parseLong(matcher.replaceAll(""));

File: core/src/main/java/tech/tablesaw/api/ShortColumn.java
Patch:
@@ -36,7 +36,7 @@
  */
 public class ShortColumn extends AbstractColumn implements ShortMapUtils, NumericColumn {
 
-    public static final short MISSING_VALUE = (short) ColumnType.SHORT_INT.getMissingValue();
+    public static final short MISSING_VALUE = (Short) ColumnType.SHORT_INT.getMissingValue();
 
     private static final int DEFAULT_ARRAY_SIZE = 128;
     private static final int BYTE_SIZE = 2;
@@ -84,7 +84,7 @@ public ShortColumn(String name) {
      */
     public static short convert(String stringValue) {
         if (Strings.isNullOrEmpty(stringValue) || TypeUtils.MISSING_INDICATORS.contains(stringValue)) {
-            return (short) ColumnType.SHORT_INT.getMissingValue();
+            return (Short) ColumnType.SHORT_INT.getMissingValue();
         }
         Matcher matcher = COMMA_PATTERN.matcher(stringValue);
         return Short.parseShort(matcher.replaceAll(""));

File: core/src/main/java/tech/tablesaw/api/TimeColumn.java
Patch:
@@ -37,7 +37,7 @@
  */
 public class TimeColumn extends AbstractColumn implements Iterable<LocalTime>, TimeMapUtils {
 
-    public static final int MISSING_VALUE = (int) ColumnType.LOCAL_TIME.getMissingValue();
+    public static final int MISSING_VALUE = (Integer) ColumnType.LOCAL_TIME.getMissingValue();
     private static final int BYTE_SIZE = 4;
 
     private static int DEFAULT_ARRAY_SIZE = 128;
@@ -258,7 +258,7 @@ public int convert(String value) {
         if (Strings.isNullOrEmpty(value)
                 || TypeUtils.MISSING_INDICATORS.contains(value)
                 || value.equals("-1")) {
-            return (int) ColumnType.LOCAL_TIME.getMissingValue();
+            return (Integer) ColumnType.LOCAL_TIME.getMissingValue();
         }
         value = Strings.padStart(value, 4, '0');
         if (selectedFormatter == null) {

File: core/src/main/java/tech/tablesaw/mapping/StringMapUtils.java
Patch:
@@ -7,6 +7,7 @@
 import tech.tablesaw.columns.Column;
 
 import org.apache.commons.lang3.StringUtils;
+import org.apache.commons.text.similarity.LevenshteinDistance;
 
 /**
  *
@@ -165,7 +166,7 @@ default Column distance(Column column2) {
         for (int r = 0; r < size(); r++) {
             String value1 = getString(r);
             String value2 = column2.getString(r);
-            newColumn.append(StringUtils.getLevenshteinDistance(value1, value2));
+            newColumn.append(LevenshteinDistance.getDefaultInstance().apply(value1, value2));
         }
         return newColumn;
     }

File: core/src/main/java/tech/tablesaw/util/DictionaryMap.java
Patch:
@@ -49,7 +49,7 @@ public int get(String value) {
 
     public void remove(short key) {
         String value = keyToValue.remove(key);
-        valueToKey.remove(value);
+        valueToKey.removeInt(value);
     }
 
     public void remove(String value) {

File: plot/src/main/java/tech/tablesaw/plotting/fx/FxBar.java
Patch:
@@ -41,7 +41,7 @@ public static BarChart<String, Number> chart(String title, CategoryColumn catego
             data.add(new XYChart.Data<>(categoryColumn.get(i), numericColumn.getFloat(i)));
         }
 
-        barChart.getData().addAll(getSeries(numericColumn, data));
+        barChart.getData().add(getSeries(numericColumn, data));
         return barChart;
     }
 
@@ -58,7 +58,7 @@ public static BarChart<String, Number> chart(String title, ShortColumn categoryC
             data.add(new XYChart.Data<>(categoryColumn.getString(i), numericColumn.getFloat(i)));
         }
 
-        barChart.getData().addAll(getSeries(numericColumn, data));
+        barChart.getData().add(getSeries(numericColumn, data));
         return barChart;
     }
 
@@ -74,7 +74,7 @@ public static BarChart<String, Number> chart(String title, IntColumn categoryCol
             data.add(new XYChart.Data<>(categoryColumn.getString(i), numericColumn.getFloat(i)));
         }
 
-        barChart.getData().addAll(getSeries(numericColumn, data));
+        barChart.getData().add(getSeries(numericColumn, data));
         return barChart;
     }
 }

File: plot/src/main/java/tech/tablesaw/plotting/fx/FxHorizontalBar.java
Patch:
@@ -48,7 +48,7 @@ public static BarChart<Number, String> chart(String title, CategoryColumn catego
 
         XYChart.Series<Number, String> series1 = getNumberStringSeries(categoryColumn, d2);
 
-        bar.getData().addAll(series1);
+        bar.getData().add(series1);
         return bar;
     }
 
@@ -67,7 +67,7 @@ public static BarChart<Number, String> chart(String title, ShortColumn categoryC
 
         XYChart.Series<Number, String> series1 = getNumberStringSeries(categoryColumn, d2);
 
-        bar.getData().addAll(series1);
+        bar.getData().add(series1);
         return bar;
     }
 
@@ -85,7 +85,7 @@ public static BarChart<Number, String> chart(String title, IntColumn categoryCol
 
         XYChart.Series<Number, String> series1 = getNumberStringSeries(categoryColumn, d2);
 
-        bar.getData().addAll(series1);
+        bar.getData().add(series1);
         return bar;
     }
 

File: plot/src/main/java/tech/tablesaw/plotting/fx/FxPareto.java
Patch:
@@ -54,7 +54,7 @@ public static BarChart<String, Number> chart(
         bar.setBackground(Background.EMPTY);
         bar.setVerticalGridLinesVisible(false);
 
-        bar.getData().addAll(series1);
+        bar.getData().add(series1);
         return bar;
     }
 
@@ -73,7 +73,7 @@ public static BarChart<String, Number> chart(String title, IntColumn categoryCol
             data.add(new XYChart.Data<>(categoryColumn.getString(i), numericColumn.getFloat(i)));
         }
 
-        barChart.getData().addAll(getSeries(numericColumn, data));
+        barChart.getData().add(getSeries(numericColumn, data));
         return barChart;
     }
 
@@ -93,7 +93,7 @@ public static BarChart<String, Number> chart(String title, ShortColumn categoryC
             data.add(new XYChart.Data<>(categoryColumn.getString(i), numericColumn.getFloat(i)));
         }
 
-        barChart.getData().addAll(getSeries(numericColumn, data));
+        barChart.getData().add(getSeries(numericColumn, data));
         return barChart;
     }
 

File: plot/src/test/java/tech/tablesaw/api/plot/BarExample.java
Patch:
@@ -14,7 +14,7 @@ public class BarExample {
 
     public static void main(String[] args) throws Exception {
         Table table = Table.createFromCsv("../data/tornadoes_1950-2014.csv");
-        Table t2 = table.countBy(table.categoryColumn("State"));
+        //Table t2 = table.countBy(table.categoryColumn("State"));
         //show("tornadoes by state", t2.categoryColumn("Category"), t2.numericColumn("Count"));
 
         //show("T", table.summarize("fatalities", sum).by("State"));

File: core/src/main/java/tech/tablesaw/api/BooleanColumn.java
Patch:
@@ -492,7 +492,7 @@ public boolean hasNext() {
          */
         @Override
         public Boolean next() {
-            byte b = iterator.next();
+            byte b = iterator.nextByte();
             if (b == (byte) 0) {
                 return false;
             }

File: core/src/main/java/tech/tablesaw/api/DateColumn.java
Patch:
@@ -761,7 +761,7 @@ public boolean hasNext() {
 
             @Override
             public LocalDate next() {
-                return PackedLocalDate.asLocalDate(intIterator.next());
+                return PackedLocalDate.asLocalDate(intIterator.nextInt());
             }
         };
     }

File: core/src/main/java/tech/tablesaw/api/TimeColumn.java
Patch:
@@ -555,7 +555,7 @@ public boolean hasNext() {
 
             @Override
             public LocalTime next() {
-                return PackedLocalTime.asLocalTime(intIterator.next());
+                return PackedLocalTime.asLocalTime(intIterator.nextInt());
             }
         };
     }

File: core/src/main/java/tech/tablesaw/api/ml/association/AssociationRuleMining.java
Patch:
@@ -82,7 +82,7 @@ public List<AssociationRule> learn(double confidenceThreshold) {
 
     public List<AssociationRule> interestingRules(double confidenceThreshold,
                                                   double interestThreshold,
-                                                  Object2DoubleOpenHashMap confidenceMap) {
+                                                  Object2DoubleOpenHashMap<IntRBTreeSet> confidenceMap) {
         List<AssociationRule> rules = model.learn(confidenceThreshold);
         for (AssociationRule rule : rules) {
             double interest = rule.confidence - confidenceMap.getDouble(rule.consequent);

File: core/src/main/java/tech/tablesaw/columns/AbstractColumn.java
Patch:
@@ -9,7 +9,7 @@
 /**
  * Partial implementation of the {@link Column} interface
  */
-public abstract class AbstractColumn<E extends AbstractColumn> implements Column {
+public abstract class AbstractColumn implements Column {
 
     // this character is sometimes inserted into windows files and needs to be removed
     private static final String UTF8_BOM = "\uFEFF";
@@ -93,7 +93,7 @@ public int columnWidth() {
     }
 
     @Override
-    public E difference() {
+    public Column difference() {
         throw new UnsupportedOperationException("difference() method not supported for all data types");
     }
 }
\ No newline at end of file

File: core/src/main/java/tech/tablesaw/columns/Column.java
Patch:
@@ -12,7 +12,7 @@
  * Columns can either exist on their own or be a part of a table. All the data in a single column is of a particular
  * type.
  */
-public interface Column<E extends Column> {
+public interface Column {
 
     int size();
 
@@ -169,5 +169,5 @@ default double[] toDoubleArray() {
      * The Missing Value Indicator is used for the first cell in the new column.
      * (e.g. IntColumn.MISSING_VALUE)
      */
-    E difference();
+    Column difference();
 }

File: core/src/main/java/tech/tablesaw/io/csv/AddCellToColumnException.java
Patch:
@@ -13,6 +13,8 @@
  */
 public class AddCellToColumnException extends RuntimeException {
 
+    private static final long serialVersionUID = 1L;
+
     /**
      * The index of the column that threw the Exception
      */

File: core/src/main/java/tech/tablesaw/reducing/CrossTab.java
Patch:
@@ -274,8 +274,6 @@ public static Table columnPercents(Table xTabCounts) {
 
         pctTable.addColumn(labels);
 
-        int grandTotal = xTabCounts.intColumn(xTabCounts.columnCount() - 1).get(xTabCounts.rowCount() - 1);
-
         // setup the labels
         for (int i = 0; i < xTabCounts.rowCount(); i++) {
             labels.add(xTabCounts.column(0).getString(i));

File: core/src/main/java/tech/tablesaw/table/TemporaryView.java
Patch:
@@ -116,7 +116,7 @@ public Table first(int nRows) {
         int count = 0;
         IntIterator it = intIterator();
         while (it.hasNext() && count < nRows) {
-            int row = it.next();
+            int row = it.nextInt();
             newMap.add(row);
             count++;
         }
@@ -146,7 +146,7 @@ public String print() {
         buf.append('\n');
         IntIterator iterator = intIterator();
         while (iterator.hasNext()) {
-            int r = iterator.next();
+            int r = iterator.nextInt();
             for (int i = 0; i < columnCount(); i++) {
                 String cell = StringUtils.rightPad(get(i, r), colWidths[i]);
                 buf.append(cell);

File: core/src/test/java/tech/tablesaw/api/DoubleColumnTest.java
Patch:
@@ -175,7 +175,7 @@ public void testIsEqualTo() {
         for (int i = 0; i < 100; i++) { // pick a hundred values at random and see if we can find them
             double aDouble = doubles[randomDataGenerator.nextInt(0, 999_999)];
             results = doubleColumn.isEqualTo(aDouble);
-            assertEquals(aDouble, doubleColumn.get(results.iterator().next()), .001);
+            assertEquals(aDouble, doubleColumn.get(results.iterator().nextInt()), .001);
         }
     }
 
@@ -420,7 +420,6 @@ public void testDifference() {
             doubles.append(RandomUtils.nextDouble(0, 10_000));
             otherDoubles.append(doubles.get(i) - 1.0f);
         }
-        DoubleColumn diff = doubles.subtract(otherDoubles);
         for (int i = 0; i < doubles.size(); i++) {
             assertEquals(doubles.get(i), otherDoubles.get(i) + 1.0, 0.01);
         }

File: core/src/test/java/tech/tablesaw/api/FloatColumnTest.java
Patch:
@@ -179,7 +179,7 @@ public void testIsEqualTo() {
         for (int i = 0; i < 100; i++) { // pick a hundred values at random and see if we can find them
             float f = floats[randomDataGenerator.nextInt(0, 999_999)];
             results = floatColumn.isEqualTo(f);
-            assertEquals(f, floatColumn.get(results.iterator().next()), .001);
+            assertEquals(f, floatColumn.get(results.iterator().nextInt()), .001);
         }
     }
 
@@ -424,7 +424,6 @@ public void testDifference() {
             floats.append(RandomUtils.nextFloat(0, 10_000));
             otherFloats.append(floats.get(i) - 1.0f);
         }
-        FloatColumn diff = floats.subtract(otherFloats);
         for (int i = 0; i < floats.size(); i++) {
             assertEquals(floats.get(i), otherFloats.get(i) + 1.0, 0.01);
         }

File: core/src/test/java/tech/tablesaw/api/ml/classification/ConfusionMatrixTest.java
Patch:
@@ -24,7 +24,6 @@ public class ConfusionMatrixTest extends Example {
     public void testAsTable() throws Exception {
 
         Table example = Table.createFromCsv("../data/KNN_Example_1.csv");
-        BooleanColumn booleanTarget = example.selectIntoColumn("bt", column("Label").isEqualTo(1));
 
         Table[] splits = example.sampleSplit(.5);
         Table train = splits[0];

File: core/src/test/java/tech/tablesaw/index/IntIndexTest.java
Patch:
@@ -1,7 +1,5 @@
 package tech.tablesaw.index;
 
-import com.google.common.base.Stopwatch;
-
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.Table;
 import tech.tablesaw.columns.DateColumnUtils;
@@ -37,7 +35,6 @@ public class IntIndexTest {
 
     @Before
     public void setUp() throws Exception {
-        Stopwatch stopwatch = Stopwatch.createStarted();
         table = CsvReader.read(types, "../data/BushApproval.csv");
         index = new IntIndex(table.intColumn("approval"));
         dateIndex = new DateIndex(table.dateColumn("date"));

File: core/src/test/java/tech/tablesaw/io/TypeUtilsTest.java
Patch:
@@ -3,6 +3,7 @@
 import org.junit.Test;
 import tech.tablesaw.api.DoubleColumn;
 
+import static org.junit.Assert.assertNotNull;
 import static tech.tablesaw.api.ColumnType.DOUBLE;
 
 public class TypeUtilsTest {
@@ -13,6 +14,7 @@ public class TypeUtilsTest {
     @Test
     public void newColumn() throws Exception {
         DoubleColumn column = (DoubleColumn) TypeUtils.newColumn("test", DOUBLE);
+        assertNotNull(column);
     }
 
 }
\ No newline at end of file

File: core/src/test/java/tech/tablesaw/io/html/HtmlTableWriterTest.java
Patch:
@@ -34,7 +34,7 @@ public void testWrite() {
         Column byColumn = table.column("who");
         ViewGroup group = new ViewGroup(table, byColumn);
         Table result = group.reduce("approval", NumericReduceUtils.mean);
-        String str = HtmlTableWriter.write(result, "NA");
+        HtmlTableWriter.write(result, "NA");
     }
 
 }
\ No newline at end of file

File: core/src/test/java/tech/tablesaw/util/DoubleArraysTest.java
Patch:
@@ -16,7 +16,7 @@ public void testTo2dArray() throws Exception {
         Table table = Table.createFromCsv("../data/tornadoes_1950-2014.csv");
         ViewGroup viewGroup = table.splitOn(table.shortColumn("Scale"));
         int columnNuumber = table.columnIndex("Injuries");
-        double[][] results = DoubleArrays.to2dArray(viewGroup, columnNuumber);
+        DoubleArrays.to2dArray(viewGroup, columnNuumber);
     }
 
 }
\ No newline at end of file

File: core/src/main/java/tech/tablesaw/api/CategoryColumn.java
Patch:
@@ -202,7 +202,7 @@ public Table countByCategory() {
             }
         }
 
-        for (Map.Entry<Integer, Integer> entry : valueToCount.entrySet()) {
+        for (Map.Entry<Integer, Integer> entry : valueToCount.int2IntEntrySet()) {
             categories.add(lookupTable.get(entry.getKey()));
             counts.append(entry.getValue());
         }

File: core/src/main/java/tech/tablesaw/api/ColumnType.java
Patch:
@@ -22,8 +22,7 @@ public enum ColumnType {
 
     private final Comparable missingValue;
 
-    ColumnType(
-            Comparable missingValue) {
+    ColumnType(Comparable missingValue) {
         this.missingValue = missingValue;
     }
 

File: core/src/main/java/tech/tablesaw/api/DateTimeColumn.java
Patch:
@@ -815,7 +815,7 @@ public boolean hasNext() {
 
             @Override
             public LocalDateTime next() {
-                return PackedLocalDateTime.asLocalDateTime(longIterator.next());
+                return PackedLocalDateTime.asLocalDateTime(longIterator.nextLong());
             }
         };
     }

File: core/src/main/java/tech/tablesaw/api/LongColumn.java
Patch:
@@ -139,7 +139,7 @@ public Selection isEqualTo(LongColumn f) {
         int i = 0;
         LongIterator longIterator = f.iterator();
         for (long next : data) {
-            if (next == longIterator.next()) {
+            if (next == longIterator.nextLong()) {
                 results.add(i);
             }
             i++;

File: core/src/main/java/tech/tablesaw/api/ShortColumn.java
Patch:
@@ -136,7 +136,7 @@ public Selection isEqualTo(ShortColumn f) {
         int i = 0;
         ShortIterator shortIterator = f.iterator();
         for (int next : data) {
-            if (next == shortIterator.next()) {
+            if (next == shortIterator.nextShort()) {
                 results.add(i);
             }
             i++;

File: core/src/main/java/tech/tablesaw/columns/packeddata/PackedLocalTime.java
Patch:
@@ -126,7 +126,6 @@ public static String toShortTimeString(int time) {
         byte millisecondByte2 = (byte) time;
         char millis = (char) ((millisecondByte1 << 8) | (millisecondByte2 & 0xFF));
         int second = millis / 1000;
-        int millisOnly = millis % 1000;
 
         return String.format("%s:%s:%s",
                 Strings.padStart(Byte.toString(hourByte), 2, '0'),

File: core/src/main/java/tech/tablesaw/io/TypeUtils.java
Patch:
@@ -9,6 +9,7 @@
 import tech.tablesaw.api.ColumnType;
 import tech.tablesaw.api.DateColumn;
 import tech.tablesaw.api.DateTimeColumn;
+import tech.tablesaw.api.DoubleColumn;
 import tech.tablesaw.api.FloatColumn;
 import tech.tablesaw.api.IntColumn;
 import tech.tablesaw.api.LongColumn;
@@ -241,6 +242,8 @@ public static Column newColumn(@Nonnull String name,
                 return new IntColumn(name);
             case FLOAT:
                 return new FloatColumn(name);
+            case DOUBLE:
+                return new DoubleColumn(name);
             case BOOLEAN:
                 return new BooleanColumn(name);
             case CATEGORY:

File: core/src/test/java/tech/tablesaw/TableTest.java
Patch:
@@ -61,7 +61,6 @@ public void testRowCount() throws Exception {
         FloatColumn floatColumn = this.floatColumn;
         floatColumn.append(2f);
         assertEquals(1, table.rowCount());
-
         floatColumn.append(2.2342f);
         assertEquals(2, table.rowCount());
     }

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -586,7 +586,6 @@ public Table fullCopy() {
       for(int i = 0; i < rowCount(); i++)
         integers.add(i);
       Rows.copyRowsToTable(integers,this,copy);
-
       return copy;
     }
 

File: core/src/main/java/tech/tablesaw/api/DoubleColumn.java
Patch:
@@ -85,15 +85,15 @@ public DoubleColumn(ColumnMetadata metadata) {
         data = new DoubleArrayList(metadata.getSize());
     }
 
-    public static DoubleColumn create(String name) {
+    private static DoubleColumn create(String name) {
         return new DoubleColumn(name);
     }
 
-    public static DoubleColumn create(String name, int initialSize) {
+    private static DoubleColumn create(String name, int initialSize) {
         return new DoubleColumn(name, initialSize);
     }
 
-    public static DoubleColumn create(String name, DoubleArrayList doubles) {
+    private static DoubleColumn create(String name, DoubleArrayList doubles) {
         DoubleColumn column = new DoubleColumn(name, doubles.size());
         column.data = new DoubleArrayList(doubles.size());
         column.data.addAll(doubles);

File: core/src/main/java/tech/tablesaw/api/Table.java
Patch:
@@ -851,7 +851,7 @@ public Table selectWhere(Selection selection) {
     }
 
     public BooleanColumn selectIntoColumn(String newColumnName, Selection selection) {
-        return BooleanColumn.create(newColumnName, selection, rowCount());
+        return new BooleanColumn(newColumnName, selection, rowCount());
     }
 
     public Table selectWhere(Filter filter) {
@@ -862,7 +862,7 @@ public Table selectWhere(Filter filter) {
     }
 
     public BooleanColumn selectIntoColumn(String newColumnName, Filter filter) {
-        return BooleanColumn.create(newColumnName, filter.apply(this), rowCount());
+        return new BooleanColumn(newColumnName, filter.apply(this), rowCount());
     }
 
     public ViewGroup splitOn(Column... columns) {
@@ -875,7 +875,7 @@ public String printHtml() {
 
     public Table structure() {
         Table t = new Table("Structure of " + name());
-        IntColumn index = IntColumn.create("Index", columnCount());
+        IntColumn index = new IntColumn("Index", columnCount());
         CategoryColumn columnName = new CategoryColumn("Column Name", columnCount());
         CategoryColumn columnType = new CategoryColumn("Column Type", columnCount());
         t.addColumn(index);

File: core/src/main/java/tech/tablesaw/api/ml/classification/CategoryConfusionMatrix.java
Patch:
@@ -56,10 +56,10 @@ public tech.tablesaw.api.Table toTable() {
         Table<String, String, Integer> sortedTable = sortedTable();
 
         tech.tablesaw.api.Table t = tech.tablesaw.api.Table.create("Confusion Matrix");
-        t.addColumn(CategoryColumn.create(""));
+        t.addColumn(new CategoryColumn(""));
 
         for (String label : sortedTable.rowKeySet()) {
-            t.addColumn(IntColumn.create(label));
+            t.addColumn(new IntColumn(label));
             t.column(0).appendCell("Predicted " + label);
         }
 

File: core/src/main/java/tech/tablesaw/api/ml/classification/StandardConfusionMatrix.java
Patch:
@@ -50,15 +50,15 @@ public String toString() {
 
     public tech.tablesaw.api.Table toTable() {
         tech.tablesaw.api.Table t = tech.tablesaw.api.Table.create("Confusion Matrix");
-        t.addColumn(CategoryColumn.create(""));
+        t.addColumn(new CategoryColumn(""));
 
         // make a set of all the values needed, from the prediction set or the actual set
         TreeSet<Integer> allValues = new TreeSet<>();
         allValues.addAll(table.columnKeySet());
         allValues.addAll(table.rowKeySet());
 
         for (Integer comparable : allValues) {
-            t.addColumn(IntColumn.create(String.valueOf(labels.get(comparable))));
+            t.addColumn(new IntColumn(String.valueOf(labels.get(comparable))));
             t.column(0).appendCell("Predicted " + labels.get(comparable));
         }
 

File: core/src/main/java/tech/tablesaw/api/ml/clustering/Gmeans.java
Patch:
@@ -50,11 +50,11 @@ public int[] getClusterSizes() {
 
     public Table labeledCentroids() {
         Table table = Table.create("Centroids");
-        CategoryColumn labelColumn = CategoryColumn.create("Cluster");
+        CategoryColumn labelColumn = new CategoryColumn("Cluster");
         table.addColumn(labelColumn);
 
         for (int i = 0; i < inputColumns.length; i++) {
-            FloatColumn centroid = FloatColumn.create(inputColumns[i].name());
+            FloatColumn centroid = new FloatColumn(inputColumns[i].name());
             table.addColumn(centroid);
         }
 

File: core/src/main/java/tech/tablesaw/api/ml/clustering/Xmeans.java
Patch:
@@ -50,11 +50,11 @@ public int[] getClusterSizes() {
 
     public Table labeledCentroids() {
         Table table = Table.create("Centroids");
-        CategoryColumn labelColumn = CategoryColumn.create("Cluster");
+        CategoryColumn labelColumn = new CategoryColumn("Cluster");
         table.addColumn(labelColumn);
 
         for (int i = 0; i < inputColumns.length; i++) {
-            FloatColumn centroid = FloatColumn.create(inputColumns[i].name());
+            FloatColumn centroid = new FloatColumn(inputColumns[i].name());
             table.addColumn(centroid);
         }
 

File: core/src/main/java/tech/tablesaw/filtering/IntIsIn.java
Patch:
@@ -20,7 +20,7 @@ public IntIsIn(ColumnReference reference, IntColumn filterColumn) {
 
     public IntIsIn(ColumnReference reference, int... ints) {
         super(reference);
-        this.filterColumn = IntColumn.create("temp", new IntArrayList(ints));
+        this.filterColumn = new IntColumn("temp", new IntArrayList(ints));
     }
 
     public Selection apply(Table relation) {

File: core/src/main/java/tech/tablesaw/filtering/StringIsIn.java
Patch:
@@ -24,12 +24,12 @@ public StringIsIn(ColumnReference reference, CategoryColumn filterColumn) {
 
     public StringIsIn(ColumnReference reference, Collection<String> strings) {
       super(reference);
-      this.filterColumn = CategoryColumn.create("temp", Lists.newArrayList(strings));
+      this.filterColumn = new CategoryColumn("temp", Lists.newArrayList(strings));
     }
  
     public StringIsIn(ColumnReference reference, String... strings) {
         super(reference);
-        this.filterColumn = CategoryColumn.create("temp", Lists.newArrayList(strings));
+        this.filterColumn = new CategoryColumn("temp", Lists.newArrayList(strings));
     }
 
     public Selection apply(Table relation) {

File: core/src/main/java/tech/tablesaw/filtering/StringIsNotIn.java
Patch:
@@ -24,12 +24,12 @@ public StringIsNotIn(ColumnReference reference, CategoryColumn filterColumn) {
 
     public StringIsNotIn(ColumnReference reference, Collection<String> strings) {
       super(reference);
-      this.filterColumn = CategoryColumn.create("temp", Lists.newArrayList(strings));
+      this.filterColumn = new CategoryColumn("temp", Lists.newArrayList(strings));
     }
  
     public StringIsNotIn(ColumnReference reference, String... strings) {
         super(reference);
-        this.filterColumn = CategoryColumn.create("temp", Lists.newArrayList(strings));
+        this.filterColumn = new CategoryColumn("temp", Lists.newArrayList(strings));
     }
 
     public Selection apply(Table relation) {

File: core/src/main/java/tech/tablesaw/mapping/BooleanMapUtils.java
Patch:
@@ -12,7 +12,7 @@ public interface BooleanMapUtils extends Column {
      * TODO(lwhite): Replace this implementation with a roaring bitmap version
      */
     default BooleanColumn and(BooleanColumn... columns) {
-        BooleanColumn newColumn = BooleanColumn.create("");
+        BooleanColumn newColumn = new BooleanColumn("");
         BooleanColumn thisColumn = (BooleanColumn) this;
         for (int i = 0; i < this.size(); i++) {
             boolean booleanValue = thisColumn.get(i);
@@ -34,7 +34,7 @@ default BooleanColumn and(BooleanColumn... columns) {
     }
 
     default BooleanColumn or(BooleanColumn... columns) {
-        BooleanColumn newColumn = BooleanColumn.create("");
+        BooleanColumn newColumn = new BooleanColumn("");
         BooleanColumn thisColumn = (BooleanColumn) this;
 
         for (int i = 0; i < this.size(); i++) {

File: core/src/main/java/tech/tablesaw/mapping/LongMapUtils.java
Patch:
@@ -15,7 +15,7 @@ default LongColumn plus(LongColumn... columns) {
         // TODO(lwhite): Assert all columns are the same size.
         String nString = names(columns);
         String name = String.format("sum(%s)", nString);
-        LongColumn newColumn = LongColumn.create(name);
+        LongColumn newColumn = new LongColumn(name);
 
         for (int r = 0; r < columns[0].size(); r++) {
             long result = 0;
@@ -80,7 +80,7 @@ default FloatColumn asPercent() {
     long get(int index);
 
     default LongColumn difference(LongColumn column2) {
-        LongColumn result = LongColumn.create(name() + " - " + column2.name(), size());
+        LongColumn result = new LongColumn(name() + " - " + column2.name(), size());
         for (int r = 0; r < size(); r++) {
             result.append(get(r) - column2.get(r));
         }

File: core/src/main/java/tech/tablesaw/mapping/ShortMapUtils.java
Patch:
@@ -16,7 +16,7 @@ default IntColumn plus(ShortColumn... columns) {
         // TODO(lwhite): Assert all columns are the same size.
         String nString = names(columns);
         String name = String.format("sum(%s)", nString);
-        IntColumn newColumn = IntColumn.create(name);
+        IntColumn newColumn = new IntColumn(name);
 
         for (int r = 0; r < columns[0].size(); r++) {
             int result = 0;

File: core/src/main/java/tech/tablesaw/store/StorageManager.java
Patch:
@@ -160,7 +160,7 @@ private static FloatColumn readFloatColumn(String fileName, ColumnMetadata metad
     }
 
     private static IntColumn readIntColumn(String fileName, ColumnMetadata metadata) throws IOException {
-        IntColumn ints = IntColumn.create(metadata);
+        IntColumn ints = new IntColumn(metadata);
         try (FileInputStream fis = new FileInputStream(fileName);
              SnappyFramedInputStream sis = new SnappyFramedInputStream(fis, true);
              DataInputStream dis = new DataInputStream(sis)) {

File: core/src/test/java/tech/tablesaw/api/LocalDateColumnTest.java
Patch:
@@ -17,7 +17,7 @@ public class LocalDateColumnTest {
     @Before
     public void setUp() throws Exception {
         Table table = Table.create("Test");
-        column1 = DateColumn.create("Game date");
+        column1 = new DateColumn("Game date");
         table.addColumn(column1);
     }
 

File: core/src/test/java/tech/tablesaw/api/LocalDateTimeColumnTest.java
Patch:
@@ -17,7 +17,7 @@ public class LocalDateTimeColumnTest  {
     @Before
     public void setUp() throws Exception {
         Table table = Table.create("Test");
-        column1 = DateTimeColumn.create("Game date");
+        column1 = new DateTimeColumn("Game date");
         table.addColumn(column1);
     }
 

File: core/src/test/java/tech/tablesaw/api/ml/association/FrequentItemsetExample.java
Patch:
@@ -7,7 +7,6 @@
 import tech.tablesaw.api.CategoryColumn;
 import tech.tablesaw.api.ShortColumn;
 import tech.tablesaw.api.Table;
-import tech.tablesaw.api.ml.association.FrequentItemset;
 
 import java.util.List;
 
@@ -22,7 +21,7 @@ public static void main(String[] args) throws Exception {
         out(table.structure().print());
         out(table.shape());
         ShortColumn movie = table.shortColumn("movie");
-        CategoryColumn moviecat = CategoryColumn.create("MovieCat");
+        CategoryColumn moviecat = new CategoryColumn("MovieCat");
         for (int i = 0; i < movie.size(); i++) {
             moviecat.appendCell(movie.getString(i));
         }

File: core/src/test/java/tech/tablesaw/filters/LocalDateFilterTest.java
Patch:
@@ -25,8 +25,8 @@
  */
 public class LocalDateFilterTest {
 
-    DateColumn localDateColumn = DateColumn.create("testing");
-    Table table = Table.create("test");
+    private DateColumn localDateColumn = new DateColumn("testing");
+    private Table table = Table.create("test");
 
     @Before
     public void setUp() throws Exception {

File: core/src/test/java/tech/tablesaw/mapping/DateTimeMapUtilsTest.java
Patch:
@@ -17,9 +17,9 @@
  */
 public class DateTimeMapUtilsTest {
 
-    DateTimeColumn startCol = DateTimeColumn.create("start");
-    DateTimeColumn stopCol = DateTimeColumn.create("stop");
-    LocalDateTime start = LocalDateTime.now();
+    private DateTimeColumn startCol = new DateTimeColumn("start");
+    private DateTimeColumn stopCol = new DateTimeColumn("stop");
+    private LocalDateTime start = LocalDateTime.now();
 
 
     @Test

File: core/src/test/java/tech/tablesaw/store/SnappyCompressionBenchmark.java
Patch:
@@ -58,7 +58,7 @@ public void testInt() {
 
         File TEST_FOLDER = Paths.get("testfolder").toFile();
         Table t = Table.create("Test");
-        final IntColumn c = IntColumn.create("fc", 10_000_000);
+        final IntColumn c = new IntColumn("fc", 10_000_000);
         t.addColumn(c);
         RandomDataGenerator randomDataGenerator = new RandomDataGenerator();
 

File: core/src/test/java/tech/tablesaw/util/StatUtilTest.java
Patch:
@@ -17,7 +17,7 @@ public class StatUtilTest {
     public void testSum() {
         Random random = new Random();
         float sum = 0.0f;
-        FloatColumn column = FloatColumn.create("c1");
+        FloatColumn column = new FloatColumn("c1");
         for (int i = 0; i < 100; i++) {
             float f = random.nextFloat();
             column.append(f);
@@ -30,7 +30,7 @@ public void testSum() {
     public void testMin() {
         Random random = new Random();
         float min = Float.MAX_VALUE;
-        FloatColumn column = FloatColumn.create("c1");
+        FloatColumn column = new FloatColumn("c1");
         for (int i = 0; i < 100; i++) {
             float f = random.nextFloat();
             column.append(f);
@@ -45,7 +45,7 @@ public void testMin() {
     public void testMax() {
         Random random = new Random();
         float max = Float.MIN_VALUE;
-        FloatColumn column = FloatColumn.create("c1");
+        FloatColumn column = new FloatColumn("c1");
         for (int i = 0; i < 100; i++) {
             float f = random.nextFloat();
             column.append(f);

File: core/src/main/java/tech/tablesaw/api/DoubleColumn.java
Patch:
@@ -41,7 +41,7 @@ public class DoubleColumn extends AbstractColumn implements DoubleIterable, Nume
     /**
      * Compares two doubles, such that a sort based on this comparator would sort in descending order
      */
-    DoubleComparator reverseDoubleComparator = new DoubleComparator() {
+    private DoubleComparator reverseDoubleComparator = new DoubleComparator() {
 
         @Override
         public int compare(Double o2, Double o1) {
@@ -50,7 +50,7 @@ public int compare(Double o2, Double o1) {
 
         @Override
         public int compare(double o2, double o1) {
-            return (o1 < o2 ? -1 : (o1 == o2 ? 0 : 1));
+            return (Double.compare(o1, o2));
         }
     };
     private DoubleArrayList data;
@@ -631,7 +631,7 @@ public double getDouble(int index) {
         return data.getDouble(index);
     }
 
-    public void set(int r, float value) {
+    public void set(int r, double value) {
         data.set(r, value);
     }
 

File: src/main/java/com/github/lwhite1/tablesaw/io/csv/CsvReader.java
Patch:
@@ -317,7 +317,7 @@ private static String[] selectColumnNames(List<String> names, ColumnType types[]
         List<String> header = new ArrayList<>();
         for (int i = 0; i < types.length; i++) {
             if (types[i] != ColumnType.SKIP) {
-                header.add(names.get(i));
+                header.add(names.get(i).trim());
             }
         }
         String[] result = new String[header.size()];

File: src/main/java/com/github/lwhite1/tablesaw/table/Relation.java
Patch:
@@ -78,7 +78,8 @@ default int columnIndex(String columnName) {
     default Column column(String columnName) {
         Column result = null;
         for (Column column : columns()) {
-            if (column.name().equalsIgnoreCase(columnName)) {
+            String name = column.name().trim();
+            if (name.equalsIgnoreCase(columnName)) {
                 result = column;
                 break;
             }

File: src/main/java/com/github/lwhite1/tablesaw/api/DateColumn.java
Patch:
@@ -299,7 +299,7 @@ public ShortColumn year() {
             if (c1 == MISSING_VALUE) {
                 newColumn.add(ShortColumn.MISSING_VALUE);
             } else {
-                newColumn.add(PackedLocalDateTime.getYear(PackedLocalDateTime.date(c1)));
+                newColumn.add(PackedLocalDate.getYear(c1));
             }
         }
         return newColumn;

File: src/test/java/com/github/lwhite1/tablesaw/examples/TornadoExample.java
Patch:
@@ -87,6 +87,8 @@ public static void main(String[] args) throws Exception {
 
         //TODO(lwhite): Provide a param for title of the new table (or auto-generate a better one).
         Table injuriesByScale = tornadoes.median("Injuries").by("Scale");
+        Table fob = tornadoes.minimum("Injuries").by("Scale", "State");
+        out(fob.print());
         injuriesByScale.setName("Median injuries by Tornado Scale");
         out(injuriesByScale.print());
 

File: src/main/java/com/github/lwhite1/tablesaw/api/DateColumn.java
Patch:
@@ -5,7 +5,6 @@
 import com.github.lwhite1.tablesaw.columns.IntColumnUtils;
 import com.github.lwhite1.tablesaw.columns.packeddata.PackedLocalDate;
 import com.github.lwhite1.tablesaw.columns.packeddata.PackedLocalDateTime;
-import com.github.lwhite1.tablesaw.columns.packeddata.PackedLocalTime;
 import com.github.lwhite1.tablesaw.filtering.IntBiPredicate;
 import com.github.lwhite1.tablesaw.filtering.IntPredicate;
 import com.github.lwhite1.tablesaw.filtering.LocalDatePredicate;
@@ -26,7 +25,6 @@
 
 import java.nio.ByteBuffer;
 import java.time.LocalDate;
-import java.time.LocalTime;
 import java.time.format.DateTimeFormatter;
 import java.time.format.DateTimeParseException;
 import java.util.ArrayList;
@@ -437,6 +435,7 @@ public Table summary() {
    * Returns a DateTime column where each value consists of the dates from this column combined with the corresponding
    * times from the other column
    */
+/*
   public DateTimeColumn atTime(TimeColumn c) {
     DateTimeColumn newColumn = DateTimeColumn.create(this.name() + " " + c.name());
     for (int r = 0; r < this.size(); r++) {
@@ -452,6 +451,7 @@ public DateTimeColumn atTime(TimeColumn c) {
     }
     return newColumn;
   }
+*/
 
   public Selection isAfter(int value) {
     return select(PackedLocalDate::isAfter, value);
@@ -739,6 +739,7 @@ public Set<LocalDate> asSet() {
     return dates;
   }
 
+  // TODO(lwhite): Is this duplicating the functionality of at()?
   public DateTimeColumn with(TimeColumn timeColumn) {
     String dateTimeColumnName = name() + " : " + timeColumn.name();
     DateTimeColumn dateTimeColumn = new DateTimeColumn(dateTimeColumnName, size());

File: src/main/java/com/github/lwhite1/tablesaw/io/csv/CsvWriter.java
Patch:
@@ -26,7 +26,7 @@ private CsvWriter() {
   /**
    * Writes the given table to a file with the given filename
    *
-   * @throws IOException
+   * @throws IOException if the write fails
    */
   public static void write(String fileName, Table table) throws IOException {
     write(fileName, table, null);
@@ -35,7 +35,7 @@ public static void write(String fileName, Table table) throws IOException {
   /**
    * Writes the given table to a file with the given filename, using the given string to represent missing data
    *
-   * @throws IOException
+   * @throws IOException if the write fails
    */
   public static void write(String fileName, Table table, String missing) throws IOException {
     try (CSVWriter writer = new CSVWriter(new FileWriter(fileName))) {
@@ -58,7 +58,7 @@ public static void write(String fileName, Table table, String missing) throws IO
   /**
    * Writes the given column to a file with the given fileName as a single column CSV file
    *
-   * @throws IOException
+   * @throws IOException if the write fails
    */
   public static void write(String fileName, Column column) throws IOException {
     try (CSVWriter writer = new CSVWriter(new FileWriter(fileName))) {

File: src/main/java/com/github/lwhite1/tablesaw/io/jdbc/SqlResultSetReader.java
Patch:
@@ -22,6 +22,7 @@ public class SqlResultSetReader {
       new ImmutableMap.Builder<Integer, ColumnType>()
           .put(Types.BINARY, ColumnType.BOOLEAN)
           .put(Types.BOOLEAN, ColumnType.BOOLEAN)
+          .put(Types.BIT, ColumnType.BOOLEAN)
 
           .put(Types.DATE, ColumnType.LOCAL_DATE)
           .put(Types.TIME, ColumnType.LOCAL_TIME)
@@ -37,7 +38,6 @@ public class SqlResultSetReader {
           .put(Types.SMALLINT, ColumnType.SHORT_INT)
           .put(Types.TINYINT, ColumnType.SHORT_INT)
           .put(Types.BIGINT, ColumnType.LONG_INT)
-          .put(Types.BIT, ColumnType.SHORT_INT)
 
           .put(Types.CHAR, ColumnType.CATEGORY)
           .put(Types.LONGVARCHAR, ColumnType.CATEGORY)

File: src/main/java/com/github/lwhite1/tablesaw/io/csv/CsvReader.java
Patch:
@@ -342,7 +342,7 @@ private static String[] makeColumnNames(ColumnType types[]) {
    * The method {@code printColumnTypes()} can be used to print a list of the detected columns that can be corrected and
    * used to explicitely specify the correct column types.
    */
-  static ColumnType[] detectColumnTypes(String file, boolean header, char delimiter)
+  public static ColumnType[] detectColumnTypes(String file, boolean header, char delimiter)
       throws IOException {
 
     int linesToSkip = header ? 1 : 0;

File: src/main/java/com/github/lwhite1/tablesaw/mapping/DateMapUtils.java
Patch:
@@ -46,11 +46,11 @@ default FloatColumn difference(DateColumn column1, DateColumn column2, ChronoUni
       int c1 = column1.getInt(r);
       int c2 = column2.getInt(r);
       if (c1 == FloatColumn.MISSING_VALUE || c2 == FloatColumn.MISSING_VALUE) {
-        newColumn.set(r, FloatColumn.MISSING_VALUE);
+        newColumn.add(FloatColumn.MISSING_VALUE);
       } else {
         LocalDate value1 = PackedLocalDate.asLocalDate(c1);
         LocalDate value2 = PackedLocalDate.asLocalDate(c2);
-        newColumn.set(r, unit.between(value1, value2));
+        newColumn.add(unit.between(value1, value2));
       }
     }
     return newColumn;

File: src/main/java/com/github/lwhite1/tablesaw/mapping/IntMapUtils.java
Patch:
@@ -154,15 +154,15 @@ default FloatColumn asPercent() {
   default IntColumn difference(IntColumn column2) {
     IntColumn result = IntColumn.create(name() + " - " + column2.name());
     for (int r = 0; r < size(); r++) {
-      result.set(r, get(r) - column2.get(r));
+      result.add(get(r) - column2.get(r));
     }
     return result;
   }
 
   default IntColumn difference(int value) {
     IntColumn result = IntColumn.create(name() + " - " + value);
     for (int r = 0; r < size(); r++) {
-      result.set(r, get(r) - value);
+      result.add(get(r) - value);
     }
     return result;
   }

File: src/main/java/com/github/lwhite1/tablesaw/store/StorageManager.java
Patch:
@@ -52,7 +52,7 @@ public class StorageManager {
 
   private static final String FILE_EXTENSION = "saw";
   private static final Pattern WHITE_SPACE_PATTERN = Pattern.compile("\\s+");
-  private static final Pattern SEPARATOR_PATTERN = Pattern.compile(separator());
+  private static final Pattern SEPARATOR_PATTERN = Pattern.compile(Pattern.quote(separator()));
 
   private static final int READER_POOL_SIZE = 4;
 

File: src/main/java/com/github/lwhite1/tablesaw/store/StorageManager.java
Patch:
@@ -52,7 +52,7 @@ public class StorageManager {
 
   private static final String FILE_EXTENSION = "saw";
   private static final Pattern WHITE_SPACE_PATTERN = Pattern.compile("\\s+");
-  private static final Pattern SEPARATOR_PATTERN = Pattern.compile(separator());
+  private static final Pattern SEPARATOR_PATTERN = Pattern.compile(Pattern.quote(separator()));
 
   private static final int READER_POOL_SIZE = 4;
 

File: src/main/java/com/github/lwhite1/tablesaw/api/DateColumn.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.github.lwhite1.tablesaw.columns.AbstractColumn;
 import com.github.lwhite1.tablesaw.columns.Column;
-import com.github.lwhite1.tablesaw.columns.DateColumnUtils;
 import com.github.lwhite1.tablesaw.columns.IntColumnUtils;
 import com.github.lwhite1.tablesaw.columns.packeddata.PackedLocalDate;
 import com.github.lwhite1.tablesaw.columns.packeddata.PackedLocalDateTime;
@@ -11,6 +10,7 @@
 import com.github.lwhite1.tablesaw.filtering.IntPredicate;
 import com.github.lwhite1.tablesaw.filtering.LocalDatePredicate;
 import com.github.lwhite1.tablesaw.io.TypeUtils;
+import com.github.lwhite1.tablesaw.mapping.DateMapUtils;
 import com.github.lwhite1.tablesaw.store.ColumnMetadata;
 import com.github.lwhite1.tablesaw.util.BitmapBackedSelection;
 import com.github.lwhite1.tablesaw.util.ReverseIntComparator;
@@ -39,7 +39,7 @@
 /**
  * A column in a base table that contains float values
  */
-public class DateColumn extends AbstractColumn implements DateColumnUtils {
+public class DateColumn extends AbstractColumn implements DateMapUtils {
 
   public static final int MISSING_VALUE = (int) ColumnType.LOCAL_DATE.getMissingValue();
 

File: src/main/java/com/github/lwhite1/tablesaw/columns/DateTimeColumnUtils.java
Patch:
@@ -7,7 +7,7 @@
 /**
  *
  */
-public interface DateTImeColumnUtils extends Column {
+public interface DateTimeColumnUtils extends Column {
 
   LongArrayList data();
 

File: src/main/java/com/github/lwhite1/tablesaw/mapping/DateTimeMapUtils.java
Patch:
@@ -1,6 +1,6 @@
 package com.github.lwhite1.tablesaw.mapping;
 
-import com.github.lwhite1.tablesaw.columns.DateTImeColumnUtils;
+import com.github.lwhite1.tablesaw.columns.DateTimeColumnUtils;
 import com.github.lwhite1.tablesaw.api.DateTimeColumn;
 import com.github.lwhite1.tablesaw.api.IntColumn;
 import com.github.lwhite1.tablesaw.api.LongColumn;
@@ -10,7 +10,7 @@
 import java.time.LocalDateTime;
 import java.time.temporal.ChronoUnit;
 
-public interface DateTimeMapUtils extends DateTImeColumnUtils {
+public interface DateTimeMapUtils extends DateTimeColumnUtils {
 
   default LongColumn differenceInMilliseconds(DateTimeColumn column2) {
     return difference(column2, ChronoUnit.MILLIS);

File: src/main/java/com/github/lwhite1/tablesaw/api/CategoryColumn.java
Patch:
@@ -385,7 +385,7 @@ public List<BooleanColumn> getDummies() {
 
     // iterate over the values, updating the dummy variable columns as appropriate
     for (int next : values) {
-      String category = get(next);
+      String category = lookupTable.get(next);
       for (BooleanColumn column : results) {
         if (category.equals(column.name())) {
           //TODO(lwhite): update the correct row more efficiently, by using set rather than add & only updating true

File: src/main/java/com/github/lwhite1/tablesaw/util/DictionaryMap.java
Patch:
@@ -30,6 +30,7 @@ public DictionaryMap(DictionaryMap original) {
       keyToValue.put(entry.getIntKey(), entry.getValue());
       valueToKey.put(entry.getValue(), entry.getIntKey());
     }
+    valueToKey.defaultReturnValue(-1);
   }
 
   public void put(int key, String value) {

File: src/main/java/com/github/lwhite1/tablesaw/api/BooleanColumn.java
Patch:
@@ -194,7 +194,9 @@ public void clear() {
 
   @Override
   public BooleanColumn copy() {
-    return BooleanColumn.create(name(), data);
+    BooleanColumn column = BooleanColumn.create(name(), data);
+    column.setComment(comment());
+    return column;
   }
 
   @Override

File: src/main/java/com/github/lwhite1/tablesaw/api/CategoryColumn.java
Patch:
@@ -551,6 +551,7 @@ public CategoryColumn copy() {
     CategoryColumn newCol = CategoryColumn.create(name(), size());
     newCol.lookupTable = new DictionaryMap(lookupTable);
     newCol.values.addAll(values);
+    newCol.setComment(comment());
     return newCol;
   }
 

File: src/main/java/com/github/lwhite1/tablesaw/api/DateColumn.java
Patch:
@@ -116,7 +116,9 @@ public void clear() {
 
   @Override
   public DateColumn copy() {
-    return DateColumn.create(name(), data);
+    DateColumn column = DateColumn.create(name(), data);
+    column.setComment(comment());
+    return column;
   }
 
   @Override

File: src/main/java/com/github/lwhite1/tablesaw/api/DateTimeColumn.java
Patch:
@@ -156,7 +156,9 @@ public void clear() {
 
   @Override
   public DateTimeColumn copy() {
-    return DateTimeColumn.create(name(), data);
+    DateTimeColumn column = DateTimeColumn.create(name(), data);
+    column.setComment(comment());
+    return column;
   }
 
   @Override

File: src/main/java/com/github/lwhite1/tablesaw/api/FloatColumn.java
Patch:
@@ -324,7 +324,9 @@ public void clear() {
 
   @Override
   public FloatColumn copy() {
-    return FloatColumn.create(name(), data);
+    FloatColumn column = FloatColumn.create(name(), data);
+    column.setComment(comment());
+    return column;
   }
 
   @Override

File: src/main/java/com/github/lwhite1/tablesaw/api/IntColumn.java
Patch:
@@ -205,7 +205,9 @@ public void sortDescending() {
 
   @Override
   public IntColumn copy() {
-    return create(name(), data);
+    IntColumn column = create(name(), data);
+    column.setComment(comment());
+    return column;
   }
 
   @Override

File: src/main/java/com/github/lwhite1/tablesaw/api/LongColumn.java
Patch:
@@ -263,6 +263,7 @@ public void sortDescending() {
   public LongColumn copy() {
     LongColumn copy = emptyCopy(size());
     copy.data.addAll(data);
+    copy.setComment(comment());
     return copy;
   }
 

File: src/main/java/com/github/lwhite1/tablesaw/api/ShortColumn.java
Patch:
@@ -203,6 +203,7 @@ public void sortDescending() {
   public ShortColumn copy() {
     ShortColumn copy = emptyCopy(size());
     copy.data.addAll(data);
+    copy.setComment(comment());
     return copy;
   }
 

File: src/main/java/com/github/lwhite1/tablesaw/api/TimeColumn.java
Patch:
@@ -109,7 +109,9 @@ public void clear() {
 
   @Override
   public TimeColumn copy() {
-    return TimeColumn.create(name(), data);
+    TimeColumn column = TimeColumn.create(name(), data);
+    column.setComment(comment());
+    return column;
   }
 
   @Override

File: src/main/java/com/github/lwhite1/tablesaw/api/CategoryColumn.java
Patch:
@@ -260,8 +260,9 @@ public void add(String stringValue) {
    * Initializes this Column with the given values for performance
    */
   public void initializeWith(IntArrayList list, DictionaryMap map) {
-    values = list;
-    lookupTable = map;
+    for (int key : list) {
+      add(map.get(key));
+    }
   }
 
   /**

File: src/test/java/com/github/lwhite1/tablesaw/api/ml/association/AssociationRuleMiningExample.java
Patch:
@@ -22,8 +22,7 @@ public static void main(String[] args) throws Exception {
     FrequentItemset frequentItemsetModel = new FrequentItemset(table.shortColumn("user"), table.shortColumn("movie"), supportThreshold);
     Object2DoubleOpenHashMap<IntRBTreeSet> confidenceMap = frequentItemsetModel.confidenceMap();
 
-    Table interestingRuleTable =
-        model.interest(confidenceThreshold, interestThreshold, confidenceMap);
+    Table interestingRuleTable = model.interest(confidenceThreshold, interestThreshold, confidenceMap);
 
     interestingRuleTable = interestingRuleTable.sortDescendingOn("Interest", "Antecedent");
     out(interestingRuleTable.print());

File: src/main/java/com/github/lwhite1/tablesaw/api/ml/classification/AbstractClassifier.java
Patch:
@@ -10,14 +10,13 @@ public abstract class AbstractClassifier {
   abstract int predictFromModel(double[] data);
 
   void populateMatrix(int[] labels, ConfusionMatrix confusion, NumericColumn[] predictors) {
+    double[] data = new double[predictors.length];
     for (int row = 0; row < predictors[0].size(); row++) {
-      double[] data = new double[predictors.length];
       for (int col = 0; col < predictors.length; col++) {
         data[col] = predictors[col].getFloat(row);
       }
       int prediction = predictFromModel(data);
       confusion.increment(prediction, labels[row]);
     }
   }
-
 }

File: src/main/java/com/github/lwhite1/tablesaw/api/ml/classification/DecisionTree.java
Patch:
@@ -46,7 +46,7 @@ public ConfusionMatrix predictMatrix(ShortColumn labels, NumericColumn ... predi
     Preconditions.checkArgument(predictors.length > 0);
 
     SortedSet<Object> labelSet = new TreeSet<>(labels.asSet());
-    ConfusionMatrix confusion = new ConfusionMatrix(labelSet);
+    ConfusionMatrix confusion = new StandardConfusionMatrix(labelSet);
 
     populateMatrix(labels.toIntArray(), confusion, predictors);
     return confusion;
@@ -55,8 +55,8 @@ public ConfusionMatrix predictMatrix(ShortColumn labels, NumericColumn ... predi
   public ConfusionMatrix predictMatrix(CategoryColumn labels, NumericColumn ... predictors) {
     Preconditions.checkArgument(predictors.length > 0);
 
-    SortedSet<Object> labelSet = new TreeSet<>(labels.asSet());
-    ConfusionMatrix confusion = new ConfusionMatrix(labelSet);
+    SortedSet<String> labelSet = new TreeSet<>(labels.asSet());
+    ConfusionMatrix confusion = new CategoryConfusionMatrix(labels, labelSet);
 
     populateMatrix(labels.data().toIntArray(), confusion, predictors);
     return confusion;

File: src/main/java/com/github/lwhite1/tablesaw/api/ml/classification/RandomForest.java
Patch:
@@ -46,7 +46,7 @@ public ConfusionMatrix predictMatrix(ShortColumn labels, NumericColumn ... predi
     Preconditions.checkArgument(predictors.length > 0);
 
     SortedSet<Object> labelSet = new TreeSet<>(labels.asSet());
-    ConfusionMatrix confusion = new ConfusionMatrix(labelSet);
+    ConfusionMatrix confusion = new StandardConfusionMatrix(labelSet);
 
     populateMatrix(labels.toIntArray(), confusion, predictors);
     return confusion;
@@ -55,8 +55,8 @@ public ConfusionMatrix predictMatrix(ShortColumn labels, NumericColumn ... predi
   public ConfusionMatrix predictMatrix(CategoryColumn labels, NumericColumn ... predictors) {
     Preconditions.checkArgument(predictors.length > 0);
 
-    SortedSet<Object> labelSet = new TreeSet<>(labels.asSet());
-    ConfusionMatrix confusion = new ConfusionMatrix(labelSet);
+    SortedSet<String> labelSet = new TreeSet<>(labels.asSet());
+    ConfusionMatrix confusion = new CategoryConfusionMatrix(labels, labelSet);
 
     populateMatrix(labels.data().toIntArray(), confusion, predictors);
     return confusion;

File: src/main/java/com/github/lwhite1/tablesaw/columns/Column.java
Patch:
@@ -170,5 +170,4 @@ default double[] toDoubleArray() {
      * (e.g. IntColumn.MISSING_VALUE)
      */
     E difference();
-
 }

File: src/main/java/com/github/lwhite1/tablesaw/plotting/xchart/TablesawTheme.java
Patch:
@@ -1,5 +1,6 @@
 package com.github.lwhite1.tablesaw.plotting.xchart;
 
+import com.github.lwhite1.tablesaw.plotting.StandardColors;
 import org.knowm.xchart.style.GGPlot2Theme;
 import org.knowm.xchart.style.PieStyler;
 import org.knowm.xchart.style.Styler;
@@ -306,7 +307,7 @@ public Font getAnnotationFont() {
 
   @Override
   public Color[] getSeriesColors() {
-    return ggPlot2Theme.getSeriesColors();
+    return StandardColors.standardColorArray();
   }
 
   @Override

File: src/main/java/com/github/lwhite1/tablesaw/plotting/xchart/XchartScatter.java
Patch:
@@ -49,6 +49,7 @@ public static void show(String chartTitle, NumericColumn xColumn, NumericColumn
     for (TemporaryView view : group) {
       double[] xData = view.numericColumn(xColumn.name()).toDoubleArray();
       double[] yData = view.numericColumn(yColumn.name()).toDoubleArray();
+
       chart.addSeries(view.name(), Arrays.copyOf(xData, xData.length), Arrays.copyOf(yData, yData.length));
     }
     new SwingWrapper<>(chart).displayChart(WINDOW_TITLE);

File: src/main/java/com/github/lwhite1/tablesaw/plotting/fx/FxBar.java
Patch:
@@ -17,7 +17,7 @@
 /**
  *
  */
-public class BarBuilder extends FxBuilder{
+public class FxBar extends FxBuilder{
 
   public static BarChart<String, Number> chart(String title, Table table, String categoryColumnName, String numericColumnName) {
 

File: src/main/java/com/github/lwhite1/tablesaw/plotting/fx/FxHorizontalBar.java
Patch:
@@ -19,7 +19,7 @@
 /**
  * A JavaFx-based Horizontal bar chart
  */
-public class HorizontalBarBuilder extends FxBuilder {
+public class FxHorizontalBar extends FxBuilder {
 
   public static BarChart<Number, String> chart(
       String title,

File: src/main/java/com/github/lwhite1/tablesaw/plotting/fx/FxPareto.java
Patch:
@@ -19,7 +19,7 @@
 /**
  *
  */
-public class ParetoBuilder extends FxBuilder {
+public class FxPareto extends FxBuilder {
 
   public static BarChart<String, Number> chart(
       String title,

File: src/main/java/com/github/lwhite1/tablesaw/plotting/fx/FxPlot.java
Patch:
@@ -1,4 +1,4 @@
-package com.github.lwhite1.tablesaw.api.plot;
+package com.github.lwhite1.tablesaw.plotting.fx;
 
 import javafx.embed.swing.JFXPanel;
 
@@ -7,9 +7,9 @@
 /**
  *
  */
-abstract class FxPlot {
+public abstract class FxPlot {
 
-  static JFXPanel getJfxPanel(String title, int width, int height) {
+  public static JFXPanel getJfxPanel(String title, int width, int height) {
     JFrame frame = new JFrame(title);
     final JFXPanel fxPanel = new JFXPanel();
     frame.add(fxPanel);

File: src/main/java/com/github/lwhite1/tablesaw/plotting/xchart/Bar.java
Patch:
@@ -1,4 +1,4 @@
-package com.github.lwhite1.tablesaw.api.plot.swing;
+package com.github.lwhite1.tablesaw.plotting.xchart;
 
 import com.github.lwhite1.tablesaw.api.CategoryColumn;
 import com.github.lwhite1.tablesaw.api.Table;

File: src/main/java/com/github/lwhite1/tablesaw/plotting/xchart/TablesawTheme.java
Patch:
@@ -1,4 +1,4 @@
-package com.github.lwhite1.tablesaw.api.plot.swing;
+package com.github.lwhite1.tablesaw.plotting.xchart;
 
 import org.knowm.xchart.style.GGPlot2Theme;
 import org.knowm.xchart.style.PieStyler;
@@ -11,7 +11,6 @@
 /**
  *
  */
-@Deprecated
 public class TablesawTheme implements Theme {
 
   GGPlot2Theme ggPlot2Theme = new GGPlot2Theme();

File: src/test/java/com/github/lwhite1/tablesaw/api/plot/HistogramExample.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.github.lwhite1.tablesaw.api.NumericColumn;
 import com.github.lwhite1.tablesaw.api.Table;
-import com.github.lwhite1.tablesaw.api.plot.Histogram;
 
 /**
  *

File: src/test/java/com/github/lwhite1/tablesaw/api/plot/LinePlotExample.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.github.lwhite1.tablesaw.api.NumericColumn;
 import com.github.lwhite1.tablesaw.api.Table;
-import com.github.lwhite1.tablesaw.api.plot.Line;
 
 /**
  *

File: src/test/java/com/github/lwhite1/tablesaw/api/plot/TimeSeriesExample.java
Patch:
@@ -3,12 +3,12 @@
 import com.github.lwhite1.tablesaw.api.DateColumn;
 import com.github.lwhite1.tablesaw.api.NumericColumn;
 import com.github.lwhite1.tablesaw.api.Table;
-import com.github.lwhite1.tablesaw.api.plot.TimeSeries;
+import com.github.lwhite1.tablesaw.plotting.glimpse.GlimpseTimeSeries;
 
 import static com.github.lwhite1.tablesaw.api.QueryHelper.column;
 
 /**
- *
+ * NOTE: Times series plotting is not yet a supported feature, and may be removed at any time
  */
 public class TimeSeriesExample {
 
@@ -18,7 +18,7 @@ public static void main(String[] args) throws Exception {
     System.out.println(air.shape());
     DateColumn dates = air.dateColumn("date");
     NumericColumn approval = air.nCol("approval");
-    TimeSeries.show("Fox news poll: George W Bush", dates, approval);
+    GlimpseTimeSeries.show("Fox news poll: George W Bush", dates, approval);
   }
 
 }

File: src/test/java/com/github/lwhite1/tablesaw/examples/MoneyballExample.java
Patch:
@@ -3,7 +3,7 @@
 import com.github.lwhite1.tablesaw.api.IntColumn;
 import com.github.lwhite1.tablesaw.api.ShortColumn;
 import com.github.lwhite1.tablesaw.api.Table;
-import com.github.lwhite1.tablesaw.api.plot.swing.Scatter;
+import com.github.lwhite1.tablesaw.plotting.xchart.XchartScatter;
 import com.github.lwhite1.tablesaw.smile.regression.LeastSquares;
 
 import static com.github.lwhite1.tablesaw.api.QueryHelper.column;
@@ -23,7 +23,7 @@ public static void main(String[] args) throws Exception {
     Table moneyball = baseball.selectWhere(column("year").isLessThan(2002));
 
     // plot regular season wins against year, segregating on whether the team made the plays
-    Scatter.show("Regular season wins by year",
+    XchartScatter.show("Regular season wins by year",
         baseball.numericColumn("W"),
         baseball.numericColumn("Year"),
         baseball.splitOn(baseball.column("Playoffs")));
@@ -34,7 +34,7 @@ public static void main(String[] args) throws Exception {
     runDifference.setName("RD");
 
     // Plot RD vs Wins to see if the relationship looks linear
-    Scatter.show("RD x Wins", moneyball.numericColumn("RD"), moneyball.numericColumn("W"), 3);
+    XchartScatter.show("RD x Wins", moneyball.numericColumn("RD"), moneyball.numericColumn("W"), 3);
 
     // Create the regression model
     ShortColumn wins = moneyball.shortColumn("W");

File: src/test/java/com/github/lwhite1/tablesaw/plotting/xchart/BarTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.github.lwhite1.tablesaw.api.plot.swing;
+package com.github.lwhite1.tablesaw.plotting.xchart;
 
 import com.github.lwhite1.tablesaw.api.Table;
 

File: src/main/java/com/github/lwhite1/tablesaw/filtering/AnyOf.java
Patch:
@@ -36,7 +36,7 @@ public Selection apply(Table relation) {
       if (selection == null) {
         selection = filter.apply(relation);
       } else {
-        selection.toBitmap().or(filter.apply(relation).toBitmap());
+        selection.or(filter.apply(relation));
       }
     }
     return selection;

File: src/test/java/com/github/lwhite1/tablesaw/api/LocalDateColumnTest.java
Patch:
@@ -23,6 +23,7 @@ public void setUp() throws Exception {
 
   @Test
   public void testAddCell() throws Exception {
+    column1.addCell("2013-10-23");
     column1.addCell("12/23/1924");
     column1.addCell("12-May-2015");
     column1.addCell("12-Jan-2015");

File: src/main/java/com/github/lwhite1/tablesaw/api/FloatColumn.java
Patch:
@@ -471,15 +471,15 @@ public FloatColumn remainder(FloatColumn column2) {
   public FloatColumn add(FloatColumn column2) {
     FloatColumn result = FloatColumn.create(name() + " + " + column2.name(), size());
     for (int r = 0; r < size(); r++) {
-      result.add(get(r) - column2.get(r));
+      result.add(get(r) + column2.get(r));
     }
     return result;
   }
 
   public FloatColumn subtract(FloatColumn column2) {
     FloatColumn result = FloatColumn.create(name() + " - " + column2.name(), size());
     for (int r = 0; r < size(); r++) {
-      result.add(get(r) + column2.get(r));
+      result.add(get(r) - column2.get(r));
     }
     return result;
   }

File: src/main/java/com/github/lwhite1/tablesaw/api/IntColumn.java
Patch:
@@ -494,15 +494,15 @@ public IntColumn remainder(IntColumn column2) {
   public IntColumn add(IntColumn column2) {
     IntColumn result = IntColumn.create(name() + " + " + column2.name(), size());
     for (int r = 0; r < size(); r++) {
-      result.add(get(r) - column2.get(r));
+      result.add(get(r) + column2.get(r));
     }
     return result;
   }
 
   public IntColumn subtract(IntColumn column2) {
     IntColumn result = IntColumn.create(name() + " - " + column2.name(), size());
     for (int r = 0; r < size(); r++) {
-      result.add(get(r) + column2.get(r));
+      result.add(get(r) - column2.get(r));
     }
     return result;
   }

File: src/main/java/com/github/lwhite1/tablesaw/api/LongColumn.java
Patch:
@@ -163,15 +163,15 @@ public LongColumn remainder(LongColumn column2) {
   public LongColumn add(LongColumn column2) {
     LongColumn result = LongColumn.create(name() + " + " + column2.name(), size());
     for (int r = 0; r < size(); r++) {
-      result.add(get(r) - column2.get(r));
+      result.add(get(r) + column2.get(r));
     }
     return result;
   }
 
   public LongColumn subtract(LongColumn column2) {
     LongColumn result = LongColumn.create(name() + " - " + column2.name(), size());
     for (int r = 0; r < size(); r++) {
-      result.add(get(r) + column2.get(r));
+      result.add(get(r) - column2.get(r));
     }
     return result;
   }

File: src/main/java/com/github/lwhite1/tablesaw/api/NumericColumn.java
Patch:
@@ -1,9 +1,11 @@
 package com.github.lwhite1.tablesaw.api;
 
+import com.github.lwhite1.tablesaw.columns.Column;
+
 /**
  *
  */
-public interface NumericColumn {
+public interface NumericColumn extends Column {
 
   double[] toDoubleArray();
 

File: src/main/java/com/github/lwhite1/tablesaw/api/ShortColumn.java
Patch:
@@ -428,15 +428,15 @@ public IntColumn remainder(ShortColumn column2) {
   public IntColumn add(ShortColumn column2) {
     IntColumn result = IntColumn.create(name() + " + " + column2.name(), size());
     for (int r = 0; r < size(); r++) {
-      result.add(get(r) - column2.get(r));
+      result.add(get(r) + column2.get(r));
     }
     return result;
   }
 
   public IntColumn subtract(ShortColumn column2) {
     IntColumn result = IntColumn.create(name() + " - " + column2.name(), size());
     for (int r = 0; r < size(); r++) {
-      result.add(get(r) + column2.get(r));
+      result.add(get(r) - column2.get(r));
     }
     return result;
   }

File: src/test/java/com/github/lwhite1/tablesaw/examples/TornadoExample.java
Patch:
@@ -25,7 +25,7 @@ public static void main(String[] args) throws Exception {
     tornadoes.exportToCsv("data/tornadoes_1950-2014.csv");
 
     //tornadoes = Table.createFromCsv(COLUMN_TYPES, "data/tornadoes_1950-2014.csv");
-    tornadoes = Table.create("data/tornadoes_1950-2014.csv");
+    tornadoes = Table.createFromCsv("data/tornadoes_1950-2014.csv");
     assert(tornadoes != null);
 
     out(tornadoes.structure().print());

File: src/main/java/com/github/lwhite1/tablesaw/columns/DateTImeColumnUtils.java
Patch:
@@ -3,12 +3,11 @@
 import com.github.lwhite1.tablesaw.api.DateTimeColumn;
 import com.github.lwhite1.tablesaw.filtering.LongPredicate;
 import it.unimi.dsi.fastutil.longs.LongArrayList;
-import it.unimi.dsi.fastutil.longs.LongIterable;
 
 /**
  *
  */
-public interface DateTImeColumnUtils extends Column, LongIterable {
+public interface DateTImeColumnUtils extends Column {
 
   LongArrayList data();
 

File: src/main/java/com/github/lwhite1/tablesaw/columns/TimeColumnUtils.java
Patch:
@@ -3,12 +3,13 @@
 import com.github.lwhite1.tablesaw.api.TimeColumn;
 import com.github.lwhite1.tablesaw.filtering.IntPredicate;
 import it.unimi.dsi.fastutil.ints.IntArrayList;
-import it.unimi.dsi.fastutil.ints.IntIterable;
+
+import java.time.LocalTime;
 
 /**
  *
  */
-public interface TimeColumnUtils extends Column, IntIterable {
+public interface TimeColumnUtils extends Column, Iterable<LocalTime> {
 
   IntArrayList data();
 

File: src/main/java/com/github/lwhite1/tablesaw/columns/DateColumnUtils.java
Patch:
@@ -3,12 +3,13 @@
 import com.github.lwhite1.tablesaw.api.DateColumn;
 import com.github.lwhite1.tablesaw.filtering.IntPredicate;
 import it.unimi.dsi.fastutil.ints.IntArrayList;
-import it.unimi.dsi.fastutil.ints.IntIterable;
+
+import java.time.LocalDate;
 
 /**
  *
  */
-public interface DateColumnUtils extends Column, IntIterable {
+public interface DateColumnUtils extends Column, Iterable<LocalDate> {
 
   IntArrayList data();
 

File: src/main/java/com/github/lwhite1/tablesaw/api/IntColumn.java
Patch:
@@ -12,7 +12,6 @@
 import com.github.lwhite1.tablesaw.util.BitmapBackedSelection;
 import com.github.lwhite1.tablesaw.util.ReverseIntComparator;
 import com.github.lwhite1.tablesaw.util.Selection;
-import com.github.lwhite1.tablesaw.util.StatUtil;
 import com.github.lwhite1.tablesaw.util.Stats;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Strings;
@@ -139,7 +138,7 @@ public Selection isEqualTo(IntColumn other) {
 
   @Override
   public Table summary() {
-    return StatUtil.stats(this).asTable("Column: " + name());
+    return Stats.create(this).asTable();
   }
 
   /**
@@ -581,7 +580,7 @@ public IntIterator iterator() {
 
   public Stats stats() {
     FloatColumn values = FloatColumn.create(name(), toFloatArray());
-    return StatUtil.stats(values);
+    return Stats.create(values);
   }
 
   public boolean contains(int i) {

File: src/main/java/com/github/lwhite1/tablesaw/api/ShortColumn.java
Patch:
@@ -13,7 +13,6 @@
 import com.github.lwhite1.tablesaw.util.BitmapBackedSelection;
 import com.github.lwhite1.tablesaw.util.ReverseShortComparator;
 import com.github.lwhite1.tablesaw.util.Selection;
-import com.github.lwhite1.tablesaw.util.StatUtil;
 import com.github.lwhite1.tablesaw.util.Stats;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Strings;
@@ -130,7 +129,7 @@ public Selection isEqualTo(ShortColumn f) {
 
   @Override
   public Table summary() {
-    return StatUtil.stats(this).asTable("Column: " + name());
+    return stats().asTable();
   }
 
   /**
@@ -553,7 +552,7 @@ public boolean contains(short value) {
 
   public Stats stats() {
     FloatColumn values = FloatColumn.create(name(), toFloatArray());
-    return StatUtil.stats(values);
+    return Stats.create(values);
   }
 
   public ShortArrayList data() {

File: src/test/java/com/github/lwhite1/tablesaw/api/FloatColumnTest.java
Patch:
@@ -41,7 +41,7 @@ public void testApplyFilter() {
     table.sortOn("test");
     System.out.println("Sort time in ms = " + stopwatch.elapsed(TimeUnit.MILLISECONDS));
     stopwatch.reset().start();
-    System.out.println(floatColumn.describe());
+    System.out.println(floatColumn.summary().print());
     stopwatch.reset().start();
     floatColumn.isLessThan(.5f);
     System.out.println("Search time in ms = " + stopwatch.elapsed(TimeUnit.MILLISECONDS));

File: src/test/java/com/github/lwhite1/tablesaw/examples/TornadoExample.java
Patch:
@@ -76,7 +76,7 @@ public static void main(String[] args) throws Exception {
 
     out("");
     out("Calculating basic descriptive statistics on Fatalities");
-    out(fatal.shortColumn("Fatalities").stats().asTable("").print());
+    out(fatal.shortColumn("Fatalities").summary().print());
 
 
     //TODO(lwhite): Provide a param for title of the new table (or auto-generate a better one).

File: src/test/java/com/github/lwhite1/tablesaw/integration/ExamplesTest.java
Patch:
@@ -39,7 +39,7 @@ public static void main(String[] args) throws Exception {
 
     // Lets take a look at the latitude and longitude columns
     // out(table.realColumn("stop_lat").rowSummary().out());
-    out(table.floatColumn("stop_lat").describe());
+    out(table.floatColumn("stop_lat").summary().print());
 
     // Now lets fill a column based on data in the existing columns
 

File: src/main/java/com/github/lwhite1/tablesaw/table/Relation.java
Patch:
@@ -81,7 +81,7 @@ default Column column(String columnName) {
       }
     }
     if (result == null) {
-      throw new RuntimeException(String.format("Column %s does not exist in table %s", columnName, name()));
+      throw new IllegalStateException(String.format("Column %s does not exist in table %s", columnName, name()));
     }
     return result;
   }

File: src/main/java/com/github/lwhite1/tablesaw/api/Table.java
Patch:
@@ -659,9 +659,7 @@ public Average average(String summarizedColumnName) {
   public void append(Table tableToAppend) {
     for (Column column : columnList) {
       Column columnToAppend = tableToAppend.column(column.name());
-      for (int i = 0; i < columnToAppend.size(); i++) {
-        column.append(columnToAppend);
-      }
+      column.append(columnToAppend);
     }
   }
 

File: src/main/java/com/github/lwhite1/tablesaw/columns/AbstractColumn.java
Patch:
@@ -18,11 +18,13 @@ public abstract class AbstractColumn implements Column {
 
   public AbstractColumn(String name) {
     this.name = name;
+    this.comment = "";
     this.id = UUID.randomUUID().toString();
   }
 
   public AbstractColumn(ColumnMetadata metadata) {
     this.name = metadata.getName();
+    this.comment = "";
     this.id = metadata.getId();
   }
 

File: src/test/java/com/github/lwhite1/tablesaw/api/BooleanColumnTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.github.lwhite1.tablesaw.columns;
+package com.github.lwhite1.tablesaw.api;
 
 import com.github.lwhite1.tablesaw.api.BooleanColumn;
 import com.github.lwhite1.tablesaw.api.Table;

File: src/test/java/com/github/lwhite1/tablesaw/api/CategoryColumnTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.github.lwhite1.tablesaw.columns;
+package com.github.lwhite1.tablesaw.api;
 
 import com.github.lwhite1.tablesaw.TestDataUtil;
 import com.github.lwhite1.tablesaw.api.BooleanColumn;

File: src/test/java/com/github/lwhite1/tablesaw/api/IntColumnTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.github.lwhite1.tablesaw.columns;
+package com.github.lwhite1.tablesaw.api;
 
 import com.github.lwhite1.tablesaw.api.FloatColumn;
 import com.github.lwhite1.tablesaw.api.IntColumn;

File: src/test/java/com/github/lwhite1/tablesaw/api/LocalDateColumnTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.github.lwhite1.tablesaw.columns;
+package com.github.lwhite1.tablesaw.api;
 
 import com.github.lwhite1.tablesaw.api.DateColumn;
 import com.github.lwhite1.tablesaw.api.IntColumn;

File: src/main/java/com/github/lwhite1/tablesaw/api/BooleanColumn.java
Patch:
@@ -123,7 +123,7 @@ public Table summary() {
    * Returns the count of missing values in this column
    */
   @Override
-  public int countEmpty() {
+  public int countMissing() {
     int count = 0;
     for (int i = 0; i < size(); i++) {
       if (getByte(i) == MISSING_VALUE) {

File: src/main/java/com/github/lwhite1/tablesaw/api/CategoryColumn.java
Patch:
@@ -548,7 +548,7 @@ public void append(Column column) {
    * Returns the count of missing values in this column
    */
   @Override
-  public int countEmpty() {
+  public int countMissing() {
     int count = 0;
     for (int i = 0; i < size(); i++) {
       if (MISSING_VALUE.equals(get(i))) {

File: src/main/java/com/github/lwhite1/tablesaw/api/DateColumn.java
Patch:
@@ -592,7 +592,7 @@ public RoaringBitmap isMissing() {
    * Returns the count of missing values in this column
    */
   @Override
-  public int countEmpty() {
+  public int countMissing() {
     int count = 0;
     for (int i = 0; i < size(); i++) {
       if (getInt(i) == MISSING_VALUE) {

File: src/main/java/com/github/lwhite1/tablesaw/api/DateTimeColumn.java
Patch:
@@ -383,7 +383,7 @@ public static DateTimeColumn create(String fileName, LongArrayList dateTimes) {
    * Returns the count of missing values in this column
    */
   @Override
-  public int countEmpty() {
+  public int countMissing() {
     int count = 0;
     for (int i = 0; i < size(); i++) {
       if (getLong(i) == MISSING_VALUE) {

File: src/main/java/com/github/lwhite1/tablesaw/api/FloatColumn.java
Patch:
@@ -272,7 +272,7 @@ public int compare(float o2, float o1) {
    * Returns the count of missing values in this column
    */
   @Override
-  public int countEmpty() {
+  public int countMissing() {
     int count = 0;
     for (int i = 0; i < size(); i++) {
       if (get(i) == MISSING_VALUE) {

File: src/main/java/com/github/lwhite1/tablesaw/api/IntColumn.java
Patch:
@@ -150,7 +150,7 @@ public Table summary() {
    * Returns the count of missing values in this column
    */
   @Override
-  public int countEmpty() {
+  public int countMissing() {
     int count = 0;
     for (int i = 0; i < size(); i++) {
       if (get(i) == MISSING_VALUE) {

File: src/main/java/com/github/lwhite1/tablesaw/api/LongColumn.java
Patch:
@@ -248,7 +248,7 @@ public LongColumn copy() {
    * Returns the count of missing values in this column
    */
   @Override
-  public int countEmpty() {
+  public int countMissing() {
     int count = 0;
     for (int i = 0; i < size(); i++) {
       if (get(i) == MISSING_VALUE) {

File: src/main/java/com/github/lwhite1/tablesaw/api/ShortColumn.java
Patch:
@@ -140,7 +140,7 @@ public Table summary() {
    * Returns the count of missing values in this column
    */
   @Override
-  public int countEmpty() {
+  public int countMissing() {
     int count = 0;
     for (int i = 0; i < size(); i++) {
       if (get(i) == MISSING_VALUE) {

File: src/main/java/com/github/lwhite1/tablesaw/api/TimeColumn.java
Patch:
@@ -172,7 +172,7 @@ public Table summary() {
    * Returns the count of missing values in this column
    */
   @Override
-  public int countEmpty() {
+  public int countMissing() {
     int count = 0;
     for (int i = 0; i < size(); i++) {
       if (getInt(i) == MISSING_VALUE) {

File: src/main/java/com/github/lwhite1/tablesaw/columns/Column.java
Patch:
@@ -29,7 +29,7 @@ default Column subset(RoaringBitmap rows) {
   /**
    * Returns the count of missing values in this column
    */
-  int countEmpty();
+  int countMissing();
 
   /**
    * Returns the count of unique values in this column

File: src/test/java/com/github/lwhite1/tablesaw/reducing/CrossTabTest.java
Patch:
@@ -13,7 +13,7 @@ public void testXCount() throws Exception {
 
     Table t = Table.createFromCsv("data/tornadoes_1950-2014.csv");
 
-    Table xtab = CrossTab.xCount(t, t.categoryColumn("State"), t.shortColumn("Scale"));
+    Table xtab = CrossTab.xCount(t, t.column("Scale"), t.column("Scale"));
     //System.out.println(xtab.print());
 
     Table rPct = CrossTab.rowPercents(xtab);

File: src/main/java/com/github/lwhite1/tablesaw/plotting/plotly/XySeries.java
Patch:
@@ -101,9 +101,10 @@ static String arrayStringBuilder(DateColumn dateColumn) {
     StringBuilder xValuesBuilder = new StringBuilder();
     for (int i = 0; i < dateColumn.size(); i++) {
       String xVal = dateColumn.getString(i);
+      xValuesBuilder.append("'");
       xValuesBuilder.append(xVal);
       if (i < dateColumn.size() -1) {
-        xValuesBuilder.append(", ");
+        xValuesBuilder.append("', ");
       }
     }
     return xValuesBuilder.toString();

File: src/main/java/com/github/lwhite1/tablesaw/api/ColumnType.java
Patch:
@@ -8,7 +8,7 @@
  */
 public enum ColumnType {
 
-  BOOLEAN(false),
+  BOOLEAN(Byte.MIN_VALUE),
   CATEGORY(""),
   FLOAT(Float.NaN),
   SHORT_INT(Short.MIN_VALUE),

File: src/main/java/com/github/lwhite1/tablesaw/api/Table.java
Patch:
@@ -486,7 +486,7 @@ public Table selectWhere(RoaringBitmap map) {
   }
 
   public BooleanColumn selectIntoColumn(String newColumnName, RoaringBitmap map) {
-    return BooleanColumn.create(newColumnName, rowCount(), map);
+    return BooleanColumn.create(newColumnName, map, rowCount());
   }
 
   public Table selectWhere(Filter filter) {
@@ -497,7 +497,7 @@ public Table selectWhere(Filter filter) {
   }
 
   public BooleanColumn selectIntoColumn(String newColumnName, Filter filter) {
-    return BooleanColumn.create(newColumnName, rowCount(), filter.apply(this));
+    return BooleanColumn.create(newColumnName, filter.apply(this), rowCount());
   }
 
   public Table structure() {

File: src/main/java/com/github/lwhite1/tablesaw/filtering/BooleanPredicate.java
Patch:
@@ -5,6 +5,5 @@
  */
 public interface BooleanPredicate {
 
-  boolean test(boolean i);
-
+  boolean test(byte i);
 }

File: src/main/java/com/github/lwhite1/tablesaw/api/FloatColumn.java
Patch:
@@ -383,7 +383,7 @@ public FloatColumn remainder(FloatColumn column2) {
   }
 
   public FloatColumn add(FloatColumn column2) {
-    FloatColumn result = FloatColumn.create(name() + " - " + column2.name(), size());
+    FloatColumn result = FloatColumn.create(name() + " + " + column2.name(), size());
     for (int r = 0; r < size(); r++) {
       result.add(get(r) - column2.get(r));
     }
@@ -399,15 +399,15 @@ public FloatColumn subtract(FloatColumn column2) {
   }
 
   public FloatColumn multiply(FloatColumn column2) {
-    FloatColumn result = FloatColumn.create(name() + " - " + column2.name(), size());
+    FloatColumn result = FloatColumn.create(name() + " * " + column2.name(), size());
     for (int r = 0; r < size(); r++) {
       result.add(get(r) * column2.get(r));
     }
     return result;
   }
 
   public FloatColumn divide(FloatColumn column2) {
-    FloatColumn result = FloatColumn.create(name() + " - " + column2.name(), size());
+    FloatColumn result = FloatColumn.create(name() + " / " + column2.name(), size());
     for (int r = 0; r < size(); r++) {
       result.add(get(r) / column2.get(r));
     }

File: src/main/java/com/github/lwhite1/tablesaw/table/Relation.java
Patch:
@@ -70,7 +70,7 @@ default int columnIndex(String columnName) {
   }
 
   /**
-   * Returns the column with the given columnName
+   * Returns the column with the given columnName, ignoring case
    */
   default Column column(String columnName) {
     Column result = null;

File: src/main/java/com/github/lwhite1/tablesaw/table/TableGroup.java
Patch:
@@ -94,17 +94,17 @@ private List<SubTable> splitOn(String... columnNames) {
       if (columnCount == 1) {
         tables.add(newView);
       } else {
-        tables.add(splitGroupingColumn(newView, columns));
+        tables.add(newView);
       }
     }
     return tables;
   }
 
-  private SubTable splitGroupingColumn(SubTable subTable, List<Column> columnNames) {
+  private SubTable splitGroupingColumn(SubTable subTable, List<Column> columns) {
 
     List<Column> newColumns = new ArrayList<>();
 
-    for (Column column : columnNames) {
+    for (Column column : columns) {
       Column newColumn = column.emptyCopy();
       newColumns.add(newColumn);
     }

File: src/test/java/com/github/lwhite1/tablesaw/columns/LocalDateColumnTest.java
Patch:
@@ -20,8 +20,8 @@ public class LocalDateColumnTest {
   @Before
   public void setUp() throws Exception {
     Table table = Table.create("Test");
-    table.addColumn(column1);
     column1 = DateColumn.create("Game date");
+    table.addColumn(column1);
   }
 
   @Test

File: src/main/java/com/github/lwhite1/tablesaw/columns/ShortColumn.java
Patch:
@@ -95,7 +95,7 @@ public void set(int index, short value) {
     data.set(index, value);
   }
 
-  public RoaringBitmap isLessThan(short i) {
+  public RoaringBitmap isLessThan(int i) {
     return apply(ShortColumnUtils.isLessThan, i);
   }
 

File: src/main/java/com/github/lwhite1/tablesaw/filter/ShortBiPredicate.java
Patch:
@@ -14,5 +14,5 @@ public interface ShortBiPredicate {
    * @param valueToTest           the value you're checking. Often this is the value of a cell in a short column
    * @param valueToCompareAgainst the value to compare against. Often this is a single value for all comparisions
    */
-  boolean test(short valueToTest, short valueToCompareAgainst);
+  boolean test(short valueToTest, int valueToCompareAgainst);
 }

File: src/main/java/com/github/lwhite1/tablesaw/columns/FloatColumn.java
Patch:
@@ -268,7 +268,7 @@ public void addCell(String object) {
    */
   public static float convert(String stringValue) {
     if (Strings.isNullOrEmpty(stringValue) || TypeUtils.MISSING_INDICATORS.contains(stringValue)) {
-      return Float.NaN;
+      return MISSING_VALUE;
     }
     Matcher matcher = COMMA_PATTERN.matcher(stringValue);
     return Float.parseFloat(matcher.replaceAll(""));

File: src/main/java/com/github/lwhite1/tablesaw/columns/BooleanColumn.java
Patch:
@@ -325,4 +325,7 @@ public BooleanSet asSet() {
     return new BooleanOpenHashSet(data);
   }
 
+  public boolean contains(boolean aBoolean) {
+    return data().contains(aBoolean);
+  }
 }

File: src/test/java/com/github/lwhite1/tablesaw/examples/TornadoExample.java
Patch:
@@ -4,6 +4,7 @@
 import com.github.lwhite1.tablesaw.aggregator.NumericReduceUtils;
 import com.github.lwhite1.tablesaw.api.ColumnType;
 import com.github.lwhite1.tablesaw.columns.CategoryColumn;
+import com.github.lwhite1.tablesaw.io.CsvReader;
 
 import static com.github.lwhite1.tablesaw.api.ColumnType.*;
 import static com.github.lwhite1.tablesaw.api.QueryHelper.*;
@@ -16,6 +17,7 @@ public class TornadoExample {
   public static void main(String[] args) throws Exception {
 
     Table tornadoes = Table.create(COLUMN_TYPES_OLD, "data/1950-2014_torn.csv");
+    //Table tornadoes = CsvReader.read("data/1950-2014_torn.csv");
     assert(tornadoes != null);
 
     out(tornadoes.structure().print());

File: src/main/java/com/github/lwhite1/tablesaw/mapper/DateMapUtils.java
Patch:
@@ -6,7 +6,6 @@
 import com.github.lwhite1.tablesaw.columns.LocalDateColumn;
 import com.github.lwhite1.tablesaw.columns.LocalDateTimeColumn;
 import com.github.lwhite1.tablesaw.columns.packeddata.PackedLocalDate;
-import it.unimi.dsi.fastutil.ints.IntIterable;
 import org.roaringbitmap.RoaringBitmap;
 
 import java.time.LocalDate;
@@ -167,7 +166,7 @@ default LocalDateTimeColumn atTime(LocalTime time) {
   }
 
   static String dateColumnName(Column column1, int value, TemporalUnit unit) {
-    return column1.name() + " - " + value + " " + unit.toString() + "(s)";
+    return column1.name() + ": " + value + " " + unit.toString() + "(s)";
   }
 
   LocalDate get(int index);

File: src/main/java/com/github/lwhite1/tablesaw/columns/FloatColumn.java
Patch:
@@ -13,12 +13,10 @@
 import it.unimi.dsi.fastutil.floats.FloatArrayList;
 import it.unimi.dsi.fastutil.floats.FloatArrays;
 import it.unimi.dsi.fastutil.floats.FloatComparator;
-import it.unimi.dsi.fastutil.floats.FloatHeapSemiIndirectPriorityQueue;
 import it.unimi.dsi.fastutil.floats.FloatIterable;
 import it.unimi.dsi.fastutil.floats.FloatIterator;
 import it.unimi.dsi.fastutil.floats.FloatOpenHashSet;
 import it.unimi.dsi.fastutil.floats.FloatSet;
-import it.unimi.dsi.fastutil.ints.IntArrays;
 import it.unimi.dsi.fastutil.ints.IntComparator;
 import org.roaringbitmap.RoaringBitmap;
 
@@ -585,5 +583,4 @@ public RoaringBitmap apply(FloatBiPredicate predicate, float value) {
     }
     return bitmap;
   }
-
 }

File: src/main/java/com/github/lwhite1/tablesaw/columns/IntColumnUtils.java
Patch:
@@ -28,6 +28,4 @@ public interface IntColumnUtils extends Column, IntIterable {
   IntBiPredicate isLessThanOrEqualTo = (valueToTest, valueToCompareAgainst) -> valueToTest <= valueToCompareAgainst;
 
   IntBiPredicate isEqualTo = (valueToTest, valueToCompareAgainst) -> valueToTest == valueToCompareAgainst;
-
-
 }

File: src/main/java/com/github/lwhite1/tablesaw/mapper/IntMapUtils.java
Patch:
@@ -54,7 +54,6 @@ default FloatColumn asRatio() {
       } else {
         pctColumn.add(FloatColumn.MISSING_VALUE);
       }
-
     }
     return pctColumn;
   }

File: src/test/java/com/github/lwhite1/tablesaw/TableFilteringTest.java
Patch:
@@ -8,17 +8,17 @@
 import static com.github.lwhite1.tablesaw.api.QueryHelper.*;
 
 /**
- *
+ * Tests for filtering on the Table class
  */
 public class TableFilteringTest {
 
-  ColumnType[] types = {
+  private final ColumnType[] types = {
       ColumnType.LOCAL_DATE,     // date of poll
       ColumnType.INTEGER,        // approval rating (pct)
       ColumnType.CATEGORY             // polling org
   };
 
-  Table table;
+  private Table table;
 
   @Before
   public void setUp() throws Exception {

File: src/test/java/com/github/lwhite1/tablesaw/TableGroupTest.java
Patch:
@@ -15,13 +15,13 @@
  */
 public class TableGroupTest {
 
-  ColumnType[] types = {
+  private static ColumnType[] types = {
       ColumnType.LOCAL_DATE,     // date of poll
       ColumnType.INTEGER,        // approval rating (pct)
-      ColumnType.CATEGORY             // polling org
+      ColumnType.CATEGORY        // polling org
   };
 
-  Table table;
+  private Table table;
 
   @Before
   public void setUp() throws Exception {

File: src/main/java/com/github/lwhite1/tablesaw/Table.java
Patch:
@@ -7,7 +7,7 @@
 import com.github.lwhite1.tablesaw.sorting.Sort;
 import com.github.lwhite1.tablesaw.store.TableMetadata;
 import com.github.lwhite1.tablesaw.util.IntComparatorChain;
-import com.github.lwhite1.tablesaw.util.ReverseIntComparator;
+import com.github.lwhite1.tablesaw.util.ReversingIntComparator;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
 import it.unimi.dsi.fastutil.ints.IntArrayList;
@@ -397,7 +397,7 @@ private IntComparator rowComparator(String columnName, boolean reverse) {
     IntComparator rowComparator = column.rowComparator();
 
     if (reverse) {
-      return ReverseIntComparator.reverse(rowComparator);
+      return ReversingIntComparator.reverse(rowComparator);
     } else {
       return rowComparator;
     }

File: src/main/java/com/github/lwhite1/tablesaw/View.java
Patch:
@@ -40,7 +40,7 @@ public View(Table table, int headRows) {
     rowMap.add(0, headRows);
     mask = rowMap.toArray();
   }
-  
+
   public View(View view, int headRows) {
     this.table = view;
 
@@ -160,6 +160,7 @@ public int row(int r) {
 
   /**
    * Adds the given index to the rowmap for this view.
+   *
    * @param index an index representing a row in the backing table
    */
   public void addIndex(int index) {

File: src/main/java/com/github/lwhite1/tablesaw/columns/FloatColumnUtils.java
Patch:
@@ -18,7 +18,8 @@ public interface FloatColumnUtils extends Column, IntIterable {
   FloatPredicate isNonNegative = i -> i >= 0f;
 
   FloatBiPredicate isGreaterThan = (valueToTest, valueToCompareAgainst) -> valueToTest > valueToCompareAgainst;
-  FloatBiPredicate isGreaterThanOrEqualTo = (valueToTest, valueToCompareAgainst) -> valueToTest >= valueToCompareAgainst;
+  FloatBiPredicate isGreaterThanOrEqualTo = (valueToTest, valueToCompareAgainst) -> valueToTest >=
+      valueToCompareAgainst;
 
   FloatBiPredicate isLessThan = (valueToTest, valueToCompareAgainst) -> valueToTest < valueToCompareAgainst;
   FloatBiPredicate isLessThanOrEqualTo = (valueToTest, valueToCompareAgainst) -> valueToTest <= valueToCompareAgainst;

File: src/main/java/com/github/lwhite1/tablesaw/columns/ShortColumnUtils.java
Patch:
@@ -8,7 +8,7 @@
  *
  */
 public interface ShortColumnUtils extends Column, ShortIterable {
-  
+
   ShortPredicate isZero = i -> i == 0;
 
   ShortPredicate isNegative = i -> i < 0;
@@ -23,7 +23,8 @@ public interface ShortColumnUtils extends Column, ShortIterable {
 
   ShortBiPredicate isGreaterThan = (valueToTest, valueToCompareAgainst) -> valueToTest > valueToCompareAgainst;
 
-  ShortBiPredicate isGreaterThanOrEqualTo = (valueToTest, valueToCompareAgainst) -> valueToTest >= valueToCompareAgainst;
+  ShortBiPredicate isGreaterThanOrEqualTo = (valueToTest, valueToCompareAgainst) -> valueToTest >=
+      valueToCompareAgainst;
 
   ShortBiPredicate isLessThan = (valueToTest, valueToCompareAgainst) -> valueToTest < valueToCompareAgainst;
 

File: src/main/java/com/github/lwhite1/tablesaw/columns/packeddata/PackedLocalDate.java
Patch:
@@ -169,12 +169,14 @@ public static boolean isInQ2(int packedDate) {
         month == Month.MAY ||
         month == Month.JUNE;
   }
+
   public static boolean isInQ3(int packedDate) {
     Month month = getMonth(packedDate);
     return month == Month.JULY ||
         month == Month.AUGUST ||
         month == Month.SEPTEMBER;
   }
+
   public static boolean isInQ4(int packedDate) {
     Month month = getMonth(packedDate);
     return month == Month.OCTOBER ||

File: src/main/java/com/github/lwhite1/tablesaw/columns/packeddata/PackedLocalDateTime.java
Patch:
@@ -179,12 +179,14 @@ public static boolean isInQ2(long packedDateTime) {
         month == Month.MAY ||
         month == Month.JUNE;
   }
+
   public static boolean isInQ3(long packedDateTime) {
     Month month = getMonth(packedDateTime);
     return month == Month.JULY ||
         month == Month.AUGUST ||
         month == Month.SEPTEMBER;
   }
+
   public static boolean isInQ4(long packedDateTime) {
     Month month = getMonth(packedDateTime);
     return month == Month.OCTOBER ||

File: src/main/java/com/github/lwhite1/tablesaw/filter/AllOf.java
Patch:
@@ -9,7 +9,7 @@
 import java.util.List;
 
 /**
- *  A composite filter that only returns {@code true} if all component filters return true
+ * A composite filter that only returns {@code true} if all component filters return true
  */
 public class AllOf extends Filter {
 

File: src/main/java/com/github/lwhite1/tablesaw/filter/AnyOf.java
Patch:
@@ -9,7 +9,7 @@
 import java.util.List;
 
 /**
- *  A composite filter that only returns {@code true} if all component filters return true
+ * A composite filter that only returns {@code true} if all component filters return true
  */
 public class AnyOf extends Filter {
 

File: src/main/java/com/github/lwhite1/tablesaw/filter/Either.java
Patch:
@@ -19,7 +19,7 @@ public Either(Filter a, Filter b) {
 
   @Override
   public RoaringBitmap apply(Table relation) {
-    RoaringBitmap rb =  a.apply(relation);
+    RoaringBitmap rb = a.apply(relation);
     rb.or(b.apply(relation));
     return rb;
   }

File: src/main/java/com/github/lwhite1/tablesaw/filter/FloatBiPredicate.java
Patch:
@@ -7,12 +7,12 @@ public interface FloatBiPredicate {
 
   /**
    * Returns true if valueToTest meets the criteria of this predicate when valueToCompareAgainst is considered
-   *
+   * <p>
    * Example (to compare all the values v in a column such that v > 4.0, v is the value to test and 4.0 is the value to
    * compare against
    *
-   * @param valueToTest             the value you're checking. Often this is the value of a cell in a floatt column
-   * @param valueToCompareAgainst   the value to compare against. Often this is a single value for all comparisions
+   * @param valueToTest           the value you're checking. Often this is the value of a cell in a floatt column
+   * @param valueToCompareAgainst the value to compare against. Often this is a single value for all comparisions
    */
   boolean test(float valueToTest, float valueToCompareAgainst);
 }

File: src/main/java/com/github/lwhite1/tablesaw/filter/IntBiPredicate.java
Patch:
@@ -7,12 +7,12 @@ public interface IntBiPredicate {
 
   /**
    * Returns true if valueToTest meets the criteria of this predicate when valueToCompareAgainst is considered
-   *
+   * <p>
    * Example (to compare all the values v in a column such that v > 4, v is the value to test and 4 is the value to
    * compare against
    *
-   * @param valueToTest             the value you're checking. Often this is the value of a cell in an int column
-   * @param valueToCompareAgainst   the value to compare against. Often this is a single value for all comparisions
+   * @param valueToTest           the value you're checking. Often this is the value of a cell in an int column
+   * @param valueToCompareAgainst the value to compare against. Often this is a single value for all comparisions
    */
   boolean test(int valueToTest, int valueToCompareAgainst);
 }

File: src/main/java/com/github/lwhite1/tablesaw/filter/IsFalse.java
Patch:
@@ -23,6 +23,7 @@ public static IsFalse isFalse(Filter filter) {
 
   /**
    * Returns true if the element in the given row in my {@code column} is true
+   *
    * @param relation
    */
   @Override

File: src/main/java/com/github/lwhite1/tablesaw/filter/IsTrue.java
Patch:
@@ -23,6 +23,7 @@ public static IsTrue isTrue(Filter filter) {
 
   /**
    * Returns true if the element in the given row in my {@code column} is true
+   *
    * @param relation
    */
   @Override

File: src/main/java/com/github/lwhite1/tablesaw/filter/ShortBiPredicate.java
Patch:
@@ -7,12 +7,12 @@ public interface ShortBiPredicate {
 
   /**
    * Returns true if valueToTest meets the criteria of this predicate when valueToCompareAgainst is considered
-   *
+   * <p>
    * Example (to compare all the values v in a column such that v > 4, v is the value to test and 4 is the value to
    * compare against
    *
-   * @param valueToTest             the value you're checking. Often this is the value of a cell in a short column
-   * @param valueToCompareAgainst   the value to compare against. Often this is a single value for all comparisions
+   * @param valueToTest           the value you're checking. Often this is the value of a cell in a short column
+   * @param valueToCompareAgainst the value to compare against. Often this is a single value for all comparisions
    */
   boolean test(short valueToTest, short valueToCompareAgainst);
 }

File: src/main/java/com/github/lwhite1/tablesaw/filter/text/TextIsNumeric.java
Patch:
@@ -23,6 +23,6 @@ public TextIsNumeric(ColumnReference reference) {
   public RoaringBitmap apply(Table relation) {
     Column column = relation.column(columnReference().getColumnName());
     CategoryColumn textColumn = (CategoryColumn) column;
-      return textColumn.isNumeric();
+    return textColumn.isNumeric();
   }
 }

File: src/main/java/com/github/lwhite1/tablesaw/io/CsvCombiner.java
Patch:
@@ -17,7 +17,8 @@
 @Immutable
 public class CsvCombiner {
 
-  private CsvCombiner() {}
+  private CsvCombiner() {
+  }
 
   public static void combineAll(String foldername, String newFileName, char columnSeparator, boolean headers)
       throws IOException {

File: src/main/java/com/github/lwhite1/tablesaw/io/TypeUtils.java
Patch:
@@ -31,7 +31,8 @@ public final class TypeUtils {
   /**
    * Private constructor to prevent instantiation
    */
-  private TypeUtils() {}
+  private TypeUtils() {
+  }
 
   // These Strings will convert to true booleans
   public static final List<String> TRUE_STRINGS =
@@ -76,6 +77,7 @@ private TypeUtils() {}
   private static final DateTimeFormatter dtTimef5 = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
 
   private static final DateTimeFormatter dtTimef6;
+
   static {
     dtTimef6 = new DateTimeFormatterBuilder()
         .parseCaseInsensitive()

File: src/main/java/com/github/lwhite1/tablesaw/mapper/BooleanMapUtils.java
Patch:
@@ -4,7 +4,7 @@
 import com.github.lwhite1.tablesaw.columns.Column;
 
 /**
- *   An interface for mapping operations unique to Boolean columns
+ * An interface for mapping operations unique to Boolean columns
  */
 public interface BooleanMapUtils extends Column {
 

File: src/main/java/com/github/lwhite1/tablesaw/mapper/DateMapUtils.java
Patch:
@@ -166,7 +166,7 @@ default LocalDateTimeColumn atTime(LocalTime time) {
   }
 
   static String dateColumnName(Column column1, int value, TemporalUnit unit) {
-    return column1.name() + " - " + value + " " + unit.toString() +"(s)";
+    return column1.name() + " - " + value + " " + unit.toString() + "(s)";
   }
 
   LocalDate get(int index);

File: src/main/java/com/github/lwhite1/tablesaw/mapper/LongMapUtils.java
Patch:
@@ -31,7 +31,7 @@ default LongColumn plus(LongColumn... columns) {
   default String names(LongColumn[] columns) {
     StringBuilder builder = new StringBuilder();
     int count = 0;
-    for (Column column: columns) {
+    for (Column column : columns) {
       builder.append(column.name());
       if (count < columns.length - 1) {
         builder.append(", ");

File: src/main/java/com/github/lwhite1/tablesaw/mapper/ShortMapUtils.java
Patch:
@@ -32,7 +32,7 @@ default IntColumn plus(ShortColumn... columns) {
   default String names(ShortColumn[] columns) {
     StringBuilder builder = new StringBuilder();
     int count = 0;
-    for (Column column: columns) {
+    for (Column column : columns) {
       builder.append(column.name());
       if (count < columns.length - 1) {
         builder.append(", ");

File: src/main/java/com/github/lwhite1/tablesaw/sorting/IntComparisonUtil.java
Patch:
@@ -11,7 +11,8 @@ public static IntComparisonUtil getInstance() {
     return instance;
   }
 
-  private IntComparisonUtil() {}
+  private IntComparisonUtil() {
+  }
 
   public int compare(int a, int b) {
     return a - b;

File: src/main/java/com/github/lwhite1/tablesaw/sorting/LongComparisonUtil.java
Patch:
@@ -11,7 +11,8 @@ public static LongComparisonUtil getInstance() {
     return instance;
   }
 
-  private LongComparisonUtil() {}
+  private LongComparisonUtil() {
+  }
 
   public int compare(long a, long b) {
     if (a > b)

File: src/main/java/com/github/lwhite1/tablesaw/sorting/StringComparator.java
Patch:
@@ -11,7 +11,8 @@ public static StringComparator getInstance() {
     return instance;
   }
 
-  private StringComparator() {}
+  private StringComparator() {
+  }
 
   public int compare(String a, String b) {
     return a.compareTo(b);

File: src/main/java/com/github/lwhite1/tablesaw/util/IntComparatorChain.java
Patch:
@@ -97,7 +97,8 @@ public boolean isLocked() {
 
   private void checkLocked() {
     if (this.isLocked) {
-      throw new UnsupportedOperationException("Comparator ordering cannot be changed after the first comparison is performed");
+      throw new UnsupportedOperationException("Comparator ordering cannot be changed after the first comparison is " +
+          "performed");
     }
   }
 

File: src/main/java/com/github/lwhite1/tablesaw/util/ReverseLongComparator.java
Patch:
@@ -5,12 +5,12 @@
 import javax.annotation.concurrent.Immutable;
 
 /**
- * A comparator for long primatives for sorting in descending order
+ * A comparator for long primitives for sorting in descending order
  */
 @Immutable
 public final class ReverseLongComparator {
 
-  static final LongComparator reverseLongComparator =  new LongComparator() {
+  static final LongComparator reverseLongComparator = new LongComparator() {
 
     @Override
     public int compare(Long o2, Long o1) {

File: src/main/java/com/github/lwhite1/tablesaw/util/StatUtil.java
Patch:
@@ -18,7 +18,8 @@
  */
 public class StatUtil {
 
-  private StatUtil() {}
+  private StatUtil() {
+  }
 
   public static float sum(final FloatColumn values) {
     float sum;
@@ -147,7 +148,7 @@ public static float mean(FloatColumn values) {
     return (float) (values.sum()) / (float) values.size();
   }
 
-  public static Stats stats(final FloatColumn  values) {
+  public static Stats stats(final FloatColumn values) {
     Stats stats = new Stats();
     stats.min = min(values);
     stats.max = max(values);

File: src/main/java/com/deathrayresearch/outlier/columns/DateColumnUtils.java
Patch:
@@ -6,5 +6,6 @@
  *
  */
 public interface DateColumnUtils extends Column {
-    IntArrayList data();
+
+  IntArrayList data();
 }

File: src/main/java/com/deathrayresearch/outlier/filter/IntPredicate.java
Patch:
@@ -6,5 +6,4 @@
 public interface IntPredicate {
 
   boolean test(int i);
-
 }

File: src/main/java/com/deathrayresearch/outlier/columns/packeddata/PackedLocalDateTime.java
Patch:
@@ -91,11 +91,11 @@ public static long pack(short yr, byte m, byte d, byte hr, byte min, byte s, byt
     return (((long) date) << 32) | (time & 0xffffffffL);
   }
 
-  static int date(long packedDateTIme) {
+  public static int date(long packedDateTIme) {
     return (int) (packedDateTIme >> 32);
   }
 
-  static int time(long packedDateTIme) {
+  public static int time(long packedDateTIme) {
     return (int) packedDateTIme;
   }
 

File: src/test/java/com/deathrayresearch/outlier/integration/ExamplesTest.java
Patch:
@@ -32,7 +32,7 @@ public void simpleExample() throws Exception {
     print(table.head(5).print());
 
     // Remove the description column
-    table.removeColumn("stop_desc");
+    table.removeColumns("stop_desc");
 
     // Check the column names to see that it's gone
     print(table.columnNames());

File: src/test/java/com/deathrayresearch/outlier/io/IoTest1.java
Patch:
@@ -27,7 +27,7 @@ public void testWithBusData() throws Exception {
 
     table = table.sortDescendingOn("stop_id");
     print(table.head(3).print());
-    table.removeColumn("stop_desc");
+    table.removeColumns("stop_desc");
     print(table.columnNames());
 
     Column c = table.floatColumn("stop_lat");

File: src/main/java/com/deathrayresearch/outlier/columns/LongColumn.java
Patch:
@@ -68,7 +68,7 @@ public int size() {
 
   @Override
   public ColumnType type() {
-    return ColumnType.SHORT_INT;
+    return ColumnType.LONG_INT;
   }
 
   public long sum() {

File: src/main/java/com/deathrayresearch/outlier/store/StorageManager.java
Patch:
@@ -364,7 +364,7 @@ public static void writeColumn(String fileName, FloatColumn column) throws IOExc
          SnappyFramedOutputStream sos = new SnappyFramedOutputStream(fos);
          DataOutputStream dos = new DataOutputStream(sos)) {
       int i = 0;
-      for (float d : column.data()) {
+      for (float d : column) {
         dos.writeFloat(d);
         if (i % FLUSH_AFTER_ITERATIONS == 0) {
           dos.flush();

File: src/test/java/com/deathrayresearch/outlier/examples/LargeDataTest.java
Patch:
@@ -69,7 +69,7 @@ public static void main(String[] args) throws Exception {
     System.out.println(t.structure().print());
     System.out.println("Time to print structure " + stopwatch.elapsed(TimeUnit.SECONDS) + " seconds");
     System.out.println();
-    
+
     stopwatch.reset().start();
     CsvWriter.write("bigdata/shortpeople2.csv", t);
     System.out.println("Time to write csv file " + stopwatch.elapsed(TimeUnit.SECONDS));

File: src/main/java/com/deathrayresearch/outlier/columns/IntColumn.java
Patch:
@@ -153,7 +153,7 @@ public RoaringBitmap isEqualTo(int f) {
 
   @Override
   public Table summary() {
-    return StatUtil.stats(this).asTable();
+    return StatUtil.stats(this).asTable(name());
   }
 
   @Override

File: src/main/java/com/deathrayresearch/outlier/columns/ShortColumn.java
Patch:
@@ -151,7 +151,7 @@ public RoaringBitmap isEqualTo(short f) {
 
   @Override
   public Table summary() {
-    return StatUtil.stats(this).asTable();
+    return StatUtil.stats(this).asTable(name());
   }
 
   @Override

File: src/main/java/com/deathrayresearch/outlier/util/IntStats.java
Patch:
@@ -109,8 +109,8 @@ public String printString() {
     return buffer.toString();
   }
 
-  public Table asTable() {
-    Table t = new Table("");
+  public Table asTable(String name) {
+    Table t = new Table(name);
     CategoryColumn measure = CategoryColumn.create("Measure");
     FloatColumn value = FloatColumn.create("Value");
     t.addColumn(measure);

File: src/main/java/com/deathrayresearch/outlier/columns/LongColumn.java
Patch:
@@ -82,7 +82,7 @@ public void add(long i) {
     data.add(i);
   }
 
-  public void set(int index, short value) {
+  public void set(int index, long value) {
     data.set(index, value);
   }
 

File: src/main/java/com/deathrayresearch/outlier/mapper/DateTimeMapUtils.java
Patch:
@@ -56,9 +56,9 @@ default CategoryColumn hour() {
       String value;
       if (c1 != null) {
         value = String.valueOf(c1.getHour());
-        newColumn.set(r, value);
+        newColumn.add(value);
       }
-        newColumn.set(r, CategoryColumn.MISSING_VALUE);
+        newColumn.add(CategoryColumn.MISSING_VALUE);
     }
     return newColumn;
   }

File: src/main/java/com/deathrayresearch/outlier/columns/ColumnType.java
Patch:
@@ -11,6 +11,7 @@ public enum ColumnType {
   FLOAT(Float.NaN),
   SHORT_INT(Short.MIN_VALUE),
   INTEGER(Integer.MIN_VALUE),
+  LONG_INT(Long.MIN_VALUE),
   TEXT(""),
   LOCAL_DATE(Integer.MIN_VALUE),
   LOCAL_DATE_TIME(Long.MIN_VALUE),

File: src/main/java/com/deathrayresearch/outlier/Rows.java
Patch:
@@ -46,6 +46,8 @@ public static void copyRowsToTable(IntArrayList rows, Table oldTable, Table newT
         case PERIOD:
           copy(rows, (PeriodColumn) oldTable.column(columnIndex), (PeriodColumn) newTable.column(columnIndex));
           break;
+        default:
+          throw new RuntimeException("Unhandled column type in case statement");
       }
     }
   }

File: src/main/java/com/deathrayresearch/outlier/Table.java
Patch:
@@ -323,7 +323,7 @@ public int[] rows() {
    * @param columnName The name of the column to sort
    * @param reverse    {@code true} if the column should be sorted in reverse
    */
-  private IntComparator rowComparator(String columnName, Boolean reverse) {
+  private IntComparator rowComparator(String columnName, boolean reverse) {
 
     Column column = this.column(columnName);
     IntComparator rowComparator = column.rowComparator();

File: src/main/java/com/deathrayresearch/outlier/aggregator/StringReduceUtils.java
Patch:
@@ -12,7 +12,7 @@ public interface StringReduceUtils extends StringColumnUtils {
     default String appendAll(String lineBreak) {
         StringBuilder builder = new StringBuilder();
         int count = 0;
-        for (String next : data()) {
+        for (String next : this) {
             builder.append(next);
             if (count < size() - 1) {
                 builder.append(lineBreak);

File: src/main/java/com/deathrayresearch/outlier/columns/IntColumn.java
Patch:
@@ -175,7 +175,7 @@ public IntColumn unique() {
 
   @Override
   public String getString(int row) {
-    return String.valueOf(data.get(row));
+    return String.valueOf(data.getInt(row));
   }
 
   @Override

File: src/main/java/com/deathrayresearch/outlier/columns/LocalDateTimeColumn.java
Patch:
@@ -23,7 +23,7 @@
  */
 public class LocalDateTimeColumn extends AbstractColumn implements DateTimeMapUtils {
 
-  public static final Long MISSING_VALUE = Long.MIN_VALUE;
+  public static final long MISSING_VALUE = Long.MIN_VALUE;
 
   private static int DEFAULT_ARRAY_SIZE = 128;
 

File: src/main/java/com/deathrayresearch/outlier/columns/PeriodColumn.java
Patch:
@@ -18,7 +18,6 @@
 import java.time.LocalDate;
 import java.time.Period;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.Map;
 
 /**

File: src/main/java/com/deathrayresearch/outlier/columns/StringList.java
Patch:
@@ -20,7 +20,7 @@ public class StringList implements List<String> {
 
     ShortArrayList values;
 
-    DictionaryMap dictionaryMap;
+    DictionaryMap dictionaryMap = new DictionaryMap();
     /**
      * Returns the number of elements in this list.  If this list contains
      * more than <tt>Integer.MAX_VALUE</tt> elements, returns

File: src/main/java/com/deathrayresearch/outlier/filter/dates/LocalDateIsAfter.java
Patch:
@@ -8,7 +8,6 @@
 import org.roaringbitmap.RoaringBitmap;
 
 import javax.annotation.concurrent.Immutable;
-import java.time.LocalDate;
 
 /**
  *
@@ -26,7 +25,7 @@ public LocalDateIsAfter(ColumnReference reference, int value) {
   @Override
   public RoaringBitmap apply(Relation relation) {
 
-    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());;
+    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());
     return dateColumn.isAfter(value);
   }
 }

File: src/main/java/com/deathrayresearch/outlier/filter/dates/LocalDateIsBefore.java
Patch:
@@ -21,7 +21,7 @@ public LocalDateIsBefore(ColumnReference reference, int value) {
   @Override
   public RoaringBitmap apply(Relation relation) {
 
-    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());;
+    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());
     return dateColumn.isBefore(value);
   }
 }

File: src/main/java/com/deathrayresearch/outlier/filter/dates/LocalDateIsFirstDayOfTheMonth.java
Patch:
@@ -18,7 +18,7 @@ public LocalDateIsFirstDayOfTheMonth(ColumnReference columnReference) {
   @Override
   public RoaringBitmap apply(Relation relation) {
 
-    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());;
+    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());
     return dateColumn.isFirstDayOfMonth();
   }
 }

File: src/main/java/com/deathrayresearch/outlier/filter/dates/LocalDateIsFriday.java
Patch:
@@ -18,7 +18,7 @@ public LocalDateIsFriday(ColumnReference columnReference) {
   @Override
   public RoaringBitmap apply(Relation relation) {
 
-    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());;
+    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());
     return dateColumn.isFriday();
   }
 }

File: src/main/java/com/deathrayresearch/outlier/filter/dates/LocalDateIsInQ1.java
Patch:
@@ -17,7 +17,7 @@ public LocalDateIsInQ1(ColumnReference reference) {
 
   @Override
   public RoaringBitmap apply(Relation relation) {
-    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());;
+    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());
     return dateColumn.isInQ1();
   }
 }

File: src/main/java/com/deathrayresearch/outlier/filter/dates/LocalDateIsInQ2.java
Patch:
@@ -18,7 +18,7 @@ public LocalDateIsInQ2(ColumnReference reference) {
   @Override
   public RoaringBitmap apply(Relation relation) {
 
-    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());;
+    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());
     return dateColumn.isInQ2();
   }
 }

File: src/main/java/com/deathrayresearch/outlier/filter/dates/LocalDateIsInQ3.java
Patch:
@@ -19,7 +19,7 @@ public LocalDateIsInQ3(ColumnReference reference) {
   @Override
   public RoaringBitmap apply(Relation relation) {
 
-    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());;
+    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());
     return dateColumn.isInQ3();
   }
 }

File: src/main/java/com/deathrayresearch/outlier/filter/dates/LocalDateIsInQ4.java
Patch:
@@ -18,7 +18,7 @@ public LocalDateIsInQ4(ColumnReference reference) {
   @Override
   public RoaringBitmap apply(Relation relation) {
 
-    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());;
+    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());
     return dateColumn.isInQ4();
   }
 }

File: src/main/java/com/deathrayresearch/outlier/filter/dates/LocalDateIsInYear.java
Patch:
@@ -21,7 +21,7 @@ public LocalDateIsInYear(ColumnReference reference, int year) {
   @Override
   public RoaringBitmap apply(Relation relation) {
 
-    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());;
+    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());
     return dateColumn.isInYear(year);
   }
 }

File: src/main/java/com/deathrayresearch/outlier/filter/dates/LocalDateIsMonday.java
Patch:
@@ -18,7 +18,7 @@ public LocalDateIsMonday(ColumnReference reference) {
   @Override
   public RoaringBitmap apply(Relation relation) {
 
-    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());;
+    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());
     return dateColumn.isMonday();
   }
 }

File: src/main/java/com/deathrayresearch/outlier/filter/dates/LocalDateIsSaturday.java
Patch:
@@ -18,7 +18,7 @@ public LocalDateIsSaturday(ColumnReference columnReference) {
   @Override
   public RoaringBitmap apply(Relation relation) {
 
-    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());;
+    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());
     return dateColumn.isSaturday();
   }
 }

File: src/main/java/com/deathrayresearch/outlier/filter/dates/LocalDateIsSunday.java
Patch:
@@ -18,7 +18,7 @@ public LocalDateIsSunday(ColumnReference columnReference) {
   @Override
   public RoaringBitmap apply(Relation relation) {
 
-    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());;
+    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());
     return dateColumn.isSunday();
   }
 }

File: src/main/java/com/deathrayresearch/outlier/filter/dates/LocalDateIsThursday.java
Patch:
@@ -18,7 +18,7 @@ public LocalDateIsThursday(ColumnReference columnReference) {
   @Override
   public RoaringBitmap apply(Relation relation) {
 
-    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());;
+    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());
     return dateColumn.isThursday();
   }
 }

File: src/main/java/com/deathrayresearch/outlier/filter/dates/LocalDateIsTuesday.java
Patch:
@@ -18,7 +18,7 @@ public LocalDateIsTuesday(ColumnReference columnReference) {
   @Override
   public RoaringBitmap apply(Relation relation) {
 
-    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());;
+    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());
     return dateColumn.isTuesday();
   }
 }

File: src/main/java/com/deathrayresearch/outlier/filter/dates/LocalDateIsWednesday.java
Patch:
@@ -18,7 +18,7 @@ public LocalDateIsWednesday(ColumnReference columnReference) {
   @Override
   public RoaringBitmap apply(Relation relation) {
 
-    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());;
+    LocalDateColumn dateColumn = (LocalDateColumn) relation.column(columnReference().getColumnName());
     return dateColumn.isWednesday();
   }
 }

File: src/main/java/com/deathrayresearch/outlier/mapper/BooleanMapUtils.java
Patch:
@@ -38,8 +38,7 @@ default BooleanColumn or(BooleanColumn... columns) {
     BooleanColumn thisColumn = (BooleanColumn) this;
 
     for (int i = 0; i < this.size(); i++) {
-      Comparable value = thisColumn.get(i);
-      boolean booleanValue = (Boolean) value;
+      boolean booleanValue = thisColumn.get(i);
       if (booleanValue) {
         newColumn.set(i, true);
       } else {

File: src/main/java/com/deathrayresearch/outlier/mapper/StringMapUtils.java
Patch:
@@ -194,7 +194,7 @@ default IntColumn countOccurrences(String ... value) {
     Preconditions.checkArgument(value.length != 0, "Parameter array must not be empty");
     IntColumn intColumn = IntColumn.create("Occurrences of " + value[0]);
 
-    for (String str : data()) {
+    for (String str : this) {
       int count = 0;
       for (String findStr : value) {
         int lastIndex = 0;
@@ -227,7 +227,7 @@ default CategoryColumn extractFirstMatch(String regex, int regexGroup) {
     CategoryColumn column = CategoryColumn.create(name() + " matches of \"" + regex + "\"");
     Pattern pattern = Pattern.compile(regex);
 
-    for (String myData : data()) {
+    for (String myData : this) {
       Matcher matcher = pattern.matcher(myData);
       if (matcher.find()) {
         column.add(matcher.group(regexGroup));

File: src/main/java/com/deathrayresearch/outlier/util/IntStats.java
Patch:
@@ -77,7 +77,7 @@ public int missing() {
   }
 
   public String printString() {
-    StringBuffer buffer = new StringBuffer();
+    StringBuilder buffer = new StringBuilder();
     buffer.append("Descriptive Stats \n");
     buffer.append("n: ");
     buffer.append(n);

File: src/main/java/com/deathrayresearch/outlier/util/Stats.java
Patch:
@@ -77,7 +77,7 @@ public int missing() {
   }
 
   public String printString() {
-    StringBuffer buffer = new StringBuffer();
+    StringBuilder buffer = new StringBuilder();
     buffer.append("Descriptive Stats \n");
     buffer.append("n: ");
     buffer.append(n);

File: src/test/java/com/deathrayresearch/outlier/TableTest.java
Patch:
@@ -43,7 +43,7 @@ public void testColumnCount() throws Exception {
   @Test
   public void testRowCount() throws Exception {
     assertEquals(0, table.rowCount());
-    FloatColumn floatColumn = (FloatColumn) column;
+    FloatColumn floatColumn = column;
     floatColumn.add(2f);
     assertEquals(1, table.rowCount());
 

File: src/main/java/com/deathrayresearch/outlier/columns/BooleanColumn.java
Patch:
@@ -281,6 +281,7 @@ public String print() {
     StringBuilder builder = new StringBuilder();
     for (boolean next : data) {
       builder.append(String.valueOf(next));
+      builder.append('\n');
     }
     return builder.toString();
   }

File: src/main/java/com/deathrayresearch/outlier/columns/CategoryColumn.java
Patch:
@@ -370,6 +370,7 @@ public String print() {
     StringBuilder builder = new StringBuilder();
     for (short next : values) {
       builder.append(get(next));
+      builder.append('\n');
     }
     return builder.toString();
   }

File: src/main/java/com/deathrayresearch/outlier/columns/IntColumn.java
Patch:
@@ -364,6 +364,7 @@ public String print() {
     StringBuilder builder = new StringBuilder();
     for (int i : data){
       builder.append(String.valueOf(i));
+      builder.append('\n');
     }
     return builder.toString();
   }

File: src/main/java/com/deathrayresearch/outlier/columns/LocalDateColumn.java
Patch:
@@ -691,6 +691,7 @@ public String print() {
     StringBuilder builder = new StringBuilder();
     for (int next : data) {
       builder.append(String.valueOf(PackedLocalDate.asLocalDate(next)));
+      builder.append('\n');
     }
     return builder.toString();
   }

File: src/main/java/com/deathrayresearch/outlier/columns/LocalDateTimeColumn.java
Patch:
@@ -286,6 +286,7 @@ public String print() {
     StringBuilder builder = new StringBuilder();
     for (long next : data) {
       builder.append(String.valueOf(PackedLocalDateTime.asLocalDateTime(next)));
+      builder.append('\n');
     }
     return builder.toString();
   }

File: src/main/java/com/deathrayresearch/outlier/columns/LocalTimeColumn.java
Patch:
@@ -218,6 +218,7 @@ public String print() {
     StringBuilder builder = new StringBuilder();
     for (int next : data) {
       builder.append(String.valueOf(PackedLocalTime.asLocalTime(next)));
+      builder.append('\n');
     }
     return builder.toString();
   }

File: src/main/java/com/deathrayresearch/outlier/columns/PeriodColumn.java
Patch:
@@ -365,6 +365,7 @@ public String print() {
     StringBuilder builder = new StringBuilder();
     for (int next : data) {
       builder.append(String.valueOf(PackedPeriod.asPeriod(next)));
+      builder.append('\n');
     }
     return builder.toString();
   }

File: src/main/java/com/deathrayresearch/outlier/columns/TextColumn.java
Patch:
@@ -225,6 +225,7 @@ public String print() {
     StringBuilder builder = new StringBuilder();
     for (String next : data) {
       builder.append(String.valueOf(next));
+      builder.append('\n');
     }
     return builder.toString();
   }

File: src/main/java/com/deathrayresearch/outlier/TableGroup.java
Patch:
@@ -55,6 +55,7 @@ private List<SubTable> splitOn(String... columnNames) {
 
     SubTable newView = new SubTable(empty);
     String lastKey = "";
+    newView.setName(lastKey);
 
     for (int row = 0; row < original.rowCount(); row++) {
 
@@ -75,7 +76,7 @@ private List<SubTable> splitOn(String... columnNames) {
         }
 
         newView = new SubTable(empty);
-        newView.setName(String.valueOf(newKey));
+        newView.setName(newKey);
         newView.setValues(values);
         lastKey = newKey;
       }

File: src/test/java/com/deathrayresearch/outlier/examples/SfCrimeTest.java
Patch:
@@ -35,7 +35,6 @@ public void setUp() throws Exception {
     table = CsvReader.read("bigdata/train.csv", heading);
   }
 
-
   @Test
   @Ignore
   public void test() {

File: src/test/java/com/deathrayresearch/outlier/columns/BooleanColumnTest.java
Patch:
@@ -72,7 +72,7 @@ public void testCountUnique() throws Exception {
 
   @Test
   public void testRoaringBitmapConstructor() throws Exception {
-    BooleanColumn bc = new BooleanColumn("Is false", column.isFalse());
+    BooleanColumn bc = new BooleanColumn("Is false", column.isFalse(), column.size());
     System.out.println(bc);
   }
 

File: src/main/java/com/deathrayresearch/outlier/Table.java
Patch:
@@ -159,7 +159,9 @@ public String id() {
    * Returns a new table containing the first {@code nrows} of data in this table
    */
   public View head(int nRows) {
-    return new View(this, Math.min(nRows, rowCount()));
+    View view = new View(this, Math.min(nRows, rowCount()));
+    view.setName(name);
+    return view;
   }
 
   /**

File: src/main/java/com/deathrayresearch/outlier/View.java
Patch:
@@ -168,7 +168,9 @@ public void removeColumn(Column column) {
   }
 
   public View head(int i) {
-    return new View(this, Math.min(i, rowCount()));
+    View view = new View(this, Math.min(i, rowCount()));
+    view.setName(name());
+    return view;
   }
 
   @Override

File: src/main/java/com/deathrayresearch/outlier/Table.java
Patch:
@@ -26,14 +26,15 @@
  */
 public class Table implements Relation {
 
-  private String id = UUID.randomUUID().toString();
+  private final String id;
 
   private String name;
 
   private final List<Column> columnList = new ArrayList<>();
 
   public Table(String name) {
     this.name = name;
+    this.id = UUID.randomUUID().toString();
   }
 
   public Table(TableMetadata metadata) {

File: src/test/java/com/deathrayresearch/outlier/columns/CategoryColumnTest.java
Patch:
@@ -12,7 +12,7 @@
  */
 public class CategoryColumnTest {
 
-  CategoryColumn column = new CategoryColumn("testing");
+  CategoryColumn column = CategoryColumn.create("testing");
 
   @Before
   public void setUp() throws Exception {

File: src/test/java/com/deathrayresearch/outlier/sorting/SortTest.java
Patch:
@@ -7,6 +7,7 @@
 import it.unimi.dsi.fastutil.ints.IntArrays;
 import it.unimi.dsi.fastutil.ints.IntComparator;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.util.Collections;
@@ -33,6 +34,7 @@ public void setUp() throws Exception {
     column2 = table2.categoryColumn("ORIGIN");
   }
 
+  @Ignore
   @Test
   public void sort() {
 
@@ -50,6 +52,7 @@ public void sort() {
     assertTrue(java.util.Arrays.equals(values, rows1.elements()));
   }
 
+  @Ignore
   @Test
   public void sortColumn() {
 

File: src/main/java/com/deathrayresearch/outlier/store/StorageManager.java
Patch:
@@ -78,7 +78,7 @@ public static Table readTable(String fileName) throws IOException {
     } catch (InterruptedException | ExecutionException e) {
       throw new RuntimeException(e);
     }
-    READER_SERVICE.shutdown();
+    //READER_SERVICE.shutdown();
     return table;
   }
 

File: src/test/java/com/deathrayresearch/outlier/integration/AirlineDelays2.java
Patch:
@@ -23,6 +23,7 @@ public static void main(String[] args) throws Exception {
     Table sorted = flights2015.sortAscendingOn("ORIGIN", "UNIQUE_CARRIER");
     System.out.println("Sorting " + stopwatch.elapsed(TimeUnit.SECONDS));
     System.out.println(sorted.head(1000).print());
+    System.exit(0);
   }
 
   private AirlineDelays2() throws Exception {
@@ -37,8 +38,7 @@ private AirlineDelays2() throws Exception {
 
     out(flights2015.shape());
     out(flights2015.columnNames().toString());
-    flights2015.head(10).print();
-    stopwatch.reset().start();
+    out(flights2015.head(10).print());
   }
 
   private static void out(Object obj) {

File: src/main/java/com/deathrayresearch/outlier/columns/BooleanColumn.java
Patch:
@@ -3,7 +3,6 @@
 import com.deathrayresearch.outlier.Table;
 import com.deathrayresearch.outlier.io.TypeUtils;
 import com.deathrayresearch.outlier.mapper.BooleanMapUtils;
-import com.google.common.base.MoreObjects;
 import com.google.common.base.Strings;
 import it.unimi.dsi.fastutil.booleans.BooleanArrayList;
 import it.unimi.dsi.fastutil.ints.IntComparator;
@@ -196,6 +195,7 @@ public boolean isEmpty() {
   public static BooleanColumn create(String fileName, BooleanArrayList bools) {
     BooleanColumn booleanColumn = new BooleanColumn(fileName, bools.size());
     booleanColumn.data = bools.elements();
+    booleanColumn.N = bools.size();
     return booleanColumn;
   }
 

File: src/main/java/com/deathrayresearch/outlier/columns/LocalDateColumn.java
Patch:
@@ -283,6 +283,7 @@ public int compare(int r1, int r2) {
   public static LocalDateColumn create(String columnName, IntArrayList dates) {
     LocalDateColumn column = new LocalDateColumn(columnName, dates.size());
     column.data = dates.elements();
+    column.N = dates.size();
     return column;
   }
 

File: src/main/java/com/deathrayresearch/outlier/Relation.java
Patch:
@@ -36,6 +36,8 @@ default void removeColumn(String columnName) {
     removeColumn(column(columnName));
   }
 
+  View head(int nRows);
+
   /**
    * Returns the index of the column with the given columnName
    */

File: src/main/java/com/deathrayresearch/outlier/columns/LocalDateColumn.java
Patch:
@@ -273,8 +273,8 @@ public int compare(Integer r1, Integer r2) {
     }
   };
 
-  public static LocalDateColumn create(String fileName, IntArrayList dates) {
-    LocalDateColumn column = new LocalDateColumn(fileName, dates.size());
+  public static LocalDateColumn create(String columnName, IntArrayList dates) {
+    LocalDateColumn column = new LocalDateColumn(columnName, dates.size());
     column.data = dates.elements();
     return column;
   }

File: src/main/java/com/deathrayresearch/outlier/app/ui/MainMenu.java
Patch:
@@ -8,14 +8,13 @@
 import javafx.scene.control.MenuBar;
 import javafx.scene.control.MenuItem;
 import javafx.scene.control.SeparatorMenuItem;
-import javafx.stage.Stage;
 
 /**
  *
  */
 public class MainMenu extends MenuBar {
 
-  MainMenu(Stage stage) {
+  MainMenu() {
     Menu project = new Menu("Project");
     MenuItem newProject = new MenuItem("New Project");
 
@@ -44,7 +43,7 @@ public class MainMenu extends MenuBar {
     Menu table = new Menu("Table");
     MenuItem loadTable = new MenuItem("Import Table...");
 
-    loadTable.setOnAction(event -> new ImportTableDialog(stage));
+    loadTable.setOnAction(event -> new ImportTableDialog());
 
     MenuItem openTable = new MenuItem("Open Table...");
     MenuItem renameTable = new MenuItem("Rename Table...");

File: src/main/java/com/deathrayresearch/outlier/app/ui/Outlier.java
Patch:
@@ -15,7 +15,7 @@ public static void main(String[] args) {
   @Override
   public void start(Stage primaryStage) {
     primaryStage.setTitle("Outlier!");
-    MenuBar menuBar = new MainMenu(primaryStage);
+    MenuBar menuBar = new MainMenu();
     VBox root = new VBox();
     root.getChildren().add(menuBar);
 

File: src/main/java/com/deathrayresearch/outlier/app/ui/project/NewProjectDialog.java
Patch:
@@ -88,9 +88,7 @@ private GridPane getProjectForm() {
 
     btnOpenDirectoryChooser.setOnAction(event -> {
       DirectoryChooser directoryChooser = new DirectoryChooser();
-
       File selectedDirectory = directoryChooser.showDialog(this.getOwner());
-
       if(selectedDirectory != null) {
         selectedDirectoryText.setText(selectedDirectory.getAbsolutePath());
       }

