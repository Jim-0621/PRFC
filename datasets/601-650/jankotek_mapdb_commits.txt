File: src/main/java/org/mapdb/store/FileHeapBufStore.java
Patch:
@@ -82,7 +82,8 @@ public void close() {
 
     private void clear() {
         //-AWLOCK
-        freeRecids.clear();  //TODO compact internal array
+        freeRecids.clear();
+        freeRecids.trimToSize();
         records.clear();
         records.compact();
     }

File: src/main/java/org/mapdb/store/ReadonlyStore.java
Patch:
@@ -1,8 +1,9 @@
 package org.mapdb.store;
 
 import org.mapdb.ser.Serializer;
+import java.io.Closeable;
 
-public interface ReadonlyStore extends Closable {
+public interface ReadonlyStore extends Closeable {
 
 
     /**

File: src/test/java/org/mapdb/jsr166Tests/BlockingQueueTest.java
Patch:
@@ -181,7 +181,7 @@ public void testDrainToNonPositiveMaxElements() {
             for (int n : ns)
                 assertEquals(0, q.drainTo(sink, n));
             assertEquals(1, q.size());
-            assertSame(one, q.poll());
+            assertEquals(one, q.poll());
             assertTrue(sink.isEmpty());
         }
     }
@@ -202,7 +202,7 @@ public void realRun() throws InterruptedException {
 
                 barrier.await();
 
-                assertSame(zero, q.poll(LONG_DELAY_MS, MILLISECONDS));
+                assertEquals(zero, q.poll(LONG_DELAY_MS, MILLISECONDS));
 
                 Thread.currentThread().interrupt();
                 try {

File: src/test/java/org/mapdb/kotlin/Issue888_JavaI.java
Patch:
@@ -46,7 +46,8 @@ public int aa() {
         }
 
 
-        //FIXME this should not be here
+        //See Issue 888, if this is removed, compilation fails
+        // for now we define all interfaces in java
         @Override
         public int bb() {
             return 1;

File: src/main/java/org/mapdb/CC.java
Patch:
@@ -13,7 +13,7 @@ public interface CC{
     boolean LOG = true;
 
     /** compile MapDB with assertions enabled*/
-    boolean PARANOID = true;
+    boolean PARANOID = false;
 
     /**
      * If enabled store space is filled with zeroes on allocation, deletion and update.

File: src/main/java/org/mapdb/Serializer.java
Patch:
@@ -305,11 +305,11 @@ public interface Serializer<A /*extends Comparable<? super A>*/> extends Compara
 
     /**
      * A predefined {@link Serializer} that always throws an
-     * {@link IllegalAccessError} when invoked.
+     * {@link UnsupportedOperationException} when invoked.
      * <p>
      * This serializer can be used for testing and assertions.
      */
-    GroupSerializer<Object> ILLEGAL_ACCESS = new SerializerIllegalAccess();
+    GroupSerializer<Object> SERIALIZER_UNSUPPORTED = new SerializerUnsupported();
 
     /**
      * Serializes {@code byte[]} it adds header which contains size information

File: src/main/java/org/mapdb/WriteAheadLog.java
Patch:
@@ -890,7 +890,7 @@ synchronized public byte[] walGetRecord(long walPointer, long expectedRecid) {
             try {
                 in.readFully(data);
             } catch (IOException e) {
-                throw new DBException.VolumeIOError(e);
+                throw new DBException.VolumeIOException(e);
             }
             return data;
         }

File: src/main/java/org/mapdb/serializer/SerializerClass.java
Patch:
@@ -32,7 +32,7 @@ public Class<?> deserialize(DataInput2 in, int available) throws IOException {
         try {
             return classLoader.loadClass(in.readUTF());
         } catch (ClassNotFoundException e) {
-            throw new DBException.SerializationError(e);
+            throw new DBException.SerializationException(e);
         }
     }
 

File: src/main/java/org/mapdb/serializer/SerializerUnsupported.java
Patch:
@@ -9,15 +9,15 @@
 /**
  * Created by jan on 2/28/16.
  */
-public class SerializerIllegalAccess extends GroupSerializerObjectArray<Object> {
+public class SerializerUnsupported extends GroupSerializerObjectArray<Object> {
     @Override
     public void serialize(DataOutput2 out, Object value) throws IOException {
-        throw new IllegalAccessError();
+        throw new UnsupportedOperationException();
     }
 
     @Override
     public Object deserialize(DataInput2 in, int available) throws IOException {
-        throw new IllegalAccessError();
+        throw new UnsupportedOperationException();
     }
 
     @Override

File: src/main/java/org/mapdb/tree/IndexTreeListJava.java
Patch:
@@ -348,7 +348,7 @@ static final void treePut(
 
             if (oldIndex == -1) {
                 if (oldVal == 0) {
-                    throw new AssertionError(); //empty pos, but that should be already covered by dirPos<0
+                    throw new IllegalStateException(); //empty pos, but that should be already covered by dirPos<0
                 } else {
                     //dive deeper
                     recid = oldVal;
@@ -432,7 +432,7 @@ static boolean treeRemove(int dirShift,
 
         if (oldIndex == -1) {
             if (oldVal == 0) {
-                throw new AssertionError(); //this was already covered by negative pos
+                throw new IllegalStateException(); //this was already covered by negative pos
             } else {
                 //dive deeper
                 return treeRemove(dirShift, oldVal, store, level-1, index, expectedValue);
@@ -487,7 +487,7 @@ static long[] treeRemoveCollapsing(
 
         if (oldIndex == -1) {
             if (oldVal == 0) {
-                throw new AssertionError(); //this was already covered by negative pos
+                throw new IllegalStateException(); //this was already covered by negative pos
             } else {
                 //dive deeper
                 long[] result =  treeRemoveCollapsing(dirShift, oldVal, store, level-1, false, index, expectedValue);

File: src/main/java/org/mapdb/volume/MappedFileVolSingle.java
Patch:
@@ -105,7 +105,7 @@ public MappedFileVolSingle(File file, boolean readOnly, long fileLockWait, long
                 buffer = buffer.asReadOnlyBuffer();
             //TODO assert endianess
         } catch (IOException e) {
-            throw new DBException.VolumeIOError(e);
+            throw new DBException.VolumeIOException(e);
         }
     }
 
@@ -125,7 +125,7 @@ synchronized public void close() {
             }
             raf.close();
         } catch (IOException e) {
-            throw new DBException.VolumeIOError(e);
+            throw new DBException.VolumeIOException(e);
         }
 
         if (cleanerHackEnabled && buffer != null && (buffer instanceof MappedByteBuffer)) {

File: src/main/java/org/mapdb/volume/UnsafeVolume.java
Patch:
@@ -160,7 +160,7 @@ public void ensureAvailable(long offset) {
         //*LOG*/ System.err.flush();
         if(hasLimit && offset>sizeLimit) {
             //return false;
-            throw new IllegalAccessError("too big"); //TODO size limit here
+            throw new IllegalStateException("too big"); //TODO size limit here
         }
 
 

File: src/test/java/org/mapdb/tree/indexTreeLongLongMapTests_GS_GENERATED/LongLongHashMapValuesTest.java
Patch:
@@ -153,7 +153,6 @@ public void remove()
 
     @Override
     @Test
-    @Ignore //TODO reenable once implemented
     public void asSynchronized()
     {
         MutableLongCollection collection = this.classUnderTest();
@@ -163,7 +162,6 @@ public void asSynchronized()
 
     @Override
     @Test
-    @Ignore //TODO reenable once implemented
     public void asUnmodifiable()
     {
         MutableLongCollection collection = this.classUnderTest();

File: src/main/java/org/mapdb/tree/IndexTreeListJava.java
Patch:
@@ -348,7 +348,7 @@ static final void treePut(
 
             if (oldIndex == -1) {
                 if (oldVal == 0) {
-                    throw new AssertionError(); //empty pos, but that should be already covered by dirPos<0
+                    throw new IllegalStateException(); //empty pos, but that should be already covered by dirPos<0
                 } else {
                     //dive deeper
                     recid = oldVal;
@@ -432,7 +432,7 @@ static boolean treeRemove(int dirShift,
 
         if (oldIndex == -1) {
             if (oldVal == 0) {
-                throw new AssertionError(); //this was already covered by negative pos
+                throw new IllegalStateException(); //this was already covered by negative pos
             } else {
                 //dive deeper
                 return treeRemove(dirShift, oldVal, store, level-1, index, expectedValue);
@@ -487,7 +487,7 @@ static long[] treeRemoveCollapsing(
 
         if (oldIndex == -1) {
             if (oldVal == 0) {
-                throw new AssertionError(); //this was already covered by negative pos
+                throw new IllegalStateException(); //this was already covered by negative pos
             } else {
                 //dive deeper
                 long[] result =  treeRemoveCollapsing(dirShift, oldVal, store, level-1, false, index, expectedValue);

File: src/main/java/org/mapdb/volume/Volume.java
Patch:
@@ -58,7 +58,7 @@ static int sliceShiftFromSize(long sizeIncrement) {
                 return i;
             }
         }
-        throw new AssertionError("Could not find sliceShift");
+        throw new IllegalStateException("Could not find sliceShift");
     }
 
     static boolean isEmptyFile(String fileName) {

File: src/main/java/org/mapdb/volume/Volume.java
Patch:
@@ -406,7 +406,7 @@ public void copyFrom(InputStream input) {
                 offset+=read;
             }
         } catch (IOException e) {
-            throw new IOError(e);
+            throw new DBException.VolumeIOException(e);
         }
     }
 
@@ -427,7 +427,7 @@ public void copyTo(OutputStream output) {
             try {
                 output.write(buf, 0, size);
             } catch (IOException e) {
-                throw new IOError(e);
+                throw new DBException.VolumeIOException(e);
             }
         }
     }

File: src/main/java/org/mapdb/Serializer.java
Patch:
@@ -305,11 +305,11 @@ public interface Serializer<A /*extends Comparable<? super A>*/> extends Compara
 
     /**
      * A predefined {@link Serializer} that always throws an
-     * {@link IllegalAccessError} when invoked.
+     * {@link UnsupportedOperationException} when invoked.
      * <p>
      * This serializer can be used for testing and assertions.
      */
-    GroupSerializer<Object> ILLEGAL_ACCESS = new SerializerIllegalAccess();
+    GroupSerializer<Object> SERIALIZER_UNSUPPORTED = new SerializerUnsupported();
 
     /**
      * Serializes {@code byte[]} it adds header which contains size information

File: src/main/java/org/mapdb/serializer/SerializerUnsupported.java
Patch:
@@ -9,15 +9,15 @@
 /**
  * Created by jan on 2/28/16.
  */
-public class SerializerIllegalAccess extends GroupSerializerObjectArray<Object> {
+public class SerializerUnsupported extends GroupSerializerObjectArray<Object> {
     @Override
     public void serialize(DataOutput2 out, Object value) throws IOException {
-        throw new IllegalAccessError();
+        throw new UnsupportedOperationException();
     }
 
     @Override
     public Object deserialize(DataInput2 in, int available) throws IOException {
-        throw new IllegalAccessError();
+        throw new UnsupportedOperationException();
     }
 
     @Override

File: src/main/java/org/mapdb/volume/UnsafeVolume.java
Patch:
@@ -160,7 +160,7 @@ public void ensureAvailable(long offset) {
         //*LOG*/ System.err.flush();
         if(hasLimit && offset>sizeLimit) {
             //return false;
-            throw new IllegalAccessError("too big"); //TODO size limit here
+            throw new IllegalStateException("too big"); //TODO size limit here
         }
 
 

File: src/main/java/org/mapdb/WriteAheadLog.java
Patch:
@@ -890,7 +890,7 @@ synchronized public byte[] walGetRecord(long walPointer, long expectedRecid) {
             try {
                 in.readFully(data);
             } catch (IOException e) {
-                throw new DBException.VolumeIOError(e);
+                throw new DBException.VolumeIOException(e);
             }
             return data;
         }

File: src/main/java/org/mapdb/serializer/SerializerClass.java
Patch:
@@ -32,7 +32,7 @@ public Class<?> deserialize(DataInput2 in, int available) throws IOException {
         try {
             return classLoader.loadClass(in.readUTF());
         } catch (ClassNotFoundException e) {
-            throw new DBException.SerializationError(e);
+            throw new DBException.SerializationException(e);
         }
     }
 

File: src/main/java/org/mapdb/volume/MappedFileVolSingle.java
Patch:
@@ -105,7 +105,7 @@ public MappedFileVolSingle(File file, boolean readOnly, long fileLockWait, long
                 buffer = buffer.asReadOnlyBuffer();
             //TODO assert endianess
         } catch (IOException e) {
-            throw new DBException.VolumeIOError(e);
+            throw new DBException.VolumeIOException(e);
         }
     }
 
@@ -125,7 +125,7 @@ synchronized public void close() {
             }
             raf.close();
         } catch (IOException e) {
-            throw new DBException.VolumeIOError(e);
+            throw new DBException.VolumeIOException(e);
         }
 
         if (cleanerHackEnabled && buffer != null && (buffer instanceof MappedByteBuffer)) {

File: src/main/java/org/mapdb/volume/Volume.java
Patch:
@@ -333,7 +333,7 @@ public void copyTo(long inputOffset, Volume target, long targetOffset, long size
         try {
             getDataInput(inputOffset, (int) size).readFully(data);
         }catch(IOException e){
-            throw new DBException.VolumeIOError(e);
+            throw new DBException.VolumeIOException(e);
         }
         target.putData(targetOffset,data,0, (int) size);
     }
@@ -495,7 +495,7 @@ static FileLock lockFile(File file, FileChannel channel, boolean readOnly, long
                     throw new DBException.FileLocked(file.toPath(), e);
                 }
             } catch (IOException e) {
-                throw new DBException.VolumeIOError(e);
+                throw new DBException.VolumeIOException(e);
             }
 
             if (fileLockWait <= 0) {

File: src/test/java/org/mapdb/JavaProcess.java
Patch:
@@ -26,7 +26,8 @@ public static Process exec(Class klass, String[] args) throws IOException,
         commandArgs.addAll(Arrays.asList(args));
 
         ProcessBuilder builder = new ProcessBuilder(commandArgs);
-
+        // redirects output to console for debug
+        //builder.inheritIO();
         return builder.start();
     }
 }

File: src/test/java/org/mapdb/elsa/ElsaIssues.java
Patch:
@@ -211,7 +211,7 @@ public int hashCode() {
 
         db.close();
 
-        db = DBMaker.fileDB(f).deleteFilesAfterClose().make();
+        db = DBMaker.fileDB(f).fileDeleteAfterClose().make();
         set = db.hashSet("testSerializerPojo").open();
         set.add(new test_pojo_reload_TestClass("test2"));
         db.commit();

File: src/test/java/org/mapdb/issues/Issue743Test.java
Patch:
@@ -3,7 +3,7 @@
 import org.junit.Test;
 import org.mapdb.*;
 
-import static junit.framework.Assert.assertEquals;
+import static org.junit.Assert.assertEquals;
 
 public class Issue743Test {
 

File: src/test/java/org/mapdb/elsa/Bean1.java
Patch:
@@ -45,11 +45,11 @@ public void setField2(String field2) {
             this.field2 = field2;
         }
 
-        Bean1(String field1, String field2) {
+        public Bean1(String field1, String field2) {
             this.field1 = field1;
             this.field2 = field2;
         }
 
-        Bean1() {
+        public Bean1() {
         }
     }

File: src/main/java/org/mapdb/serializer/SerializerArrayTuple.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * Serializer for tuples. It serializes fixed size array, where each array index can use different serializer.
- *
+ * <p/>
  * It takes array of serializes in constructor parameter. All tuples (arrays) must have the same size.
  */
 public class SerializerArrayTuple implements GroupSerializer<Object[]>, DB.DBAware {

File: src/main/java/org/mapdb/serializer/SerializerByte.java
Patch:
@@ -2,12 +2,11 @@
 
 import org.mapdb.DataInput2;
 import org.mapdb.DataOutput2;
-import org.mapdb.Serializer;
 
 import java.io.IOException;
 
 /**
- * Created by jan on 2/28/16.
+ * Single byte serializer
  */
 public class SerializerByte extends GroupSerializerObjectArray<Byte> {
     @Override

File: src/main/java/org/mapdb/serializer/SerializerByteArrayDelta.java
Patch:
@@ -6,7 +6,7 @@
 import java.io.IOException;
 
 /**
- * Created by jan on 2/29/16.
+ * Serializes group of {@code byte[]} with delta compression.
  */
 public class SerializerByteArrayDelta extends SerializerByteArray {
 

File: src/main/java/org/mapdb/serializer/SerializerArray.java
Patch:
@@ -20,7 +20,7 @@
  *   See {@link java.lang.reflect.Array#newInstance(Class, int)}
  *
  */
-public class SerializerArray<T> extends GroupSerializerObjectArray<T[]>, DB.DBAware{
+public class SerializerArray<T> extends GroupSerializerObjectArray<T[]> implements DB.DBAware {
 
     private static final long serialVersionUID = -982394293898234253L;
     protected Serializer<T> serializer;
@@ -29,7 +29,7 @@ public class SerializerArray<T> extends GroupSerializerObjectArray<T[]>, DB.DBAw
 
     public SerializerArray(){
         this.serializer = null;
-        this.componentType = (Class<T>)Object.class
+        this.componentType = (Class<T>)Object.class;
     }
 
     /**
@@ -150,6 +150,6 @@ public int compare(Object[] o1, Object[] o2) {
     @Override
     public void callbackDB(@NotNull DB db) {
         if(this.serializer==null)
-            this.serializer = db.getDefaultSerializer()
+            this.serializer = db.getDefaultSerializer();
     }
 }

File: src/main/java/org/mapdb/serializer/SerializerArrayTuple.java
Patch:
@@ -19,7 +19,7 @@ public class SerializerArrayTuple implements GroupSerializer<Object[]>, DB.DBAwa
     protected final int size;
 
     public SerializerArrayTuple(int size) {
-        this.size = size
+        this.size = size;
         ser = new Serializer[size];
         comp = new Comparator[size];
     }

File: src/test/java/org/mapdb/ClosedThrowsExceptionTest.java
Patch:
@@ -94,7 +94,7 @@ public void closed_remove(){
         m.remove("aa");
     }
 
-    @Test(expected = IllegalAccessError.class)
+    @Test
     public void closed_close(){
         Map m = db.hashMap("test").create();
         m.put("aa","bb");

File: src/main/java/org/mapdb/CC.java
Patch:
@@ -44,8 +44,7 @@ public interface CC{
 
     boolean LOG_WAL_CONTENT = false;
 
-    //TODO setting to use unsafe hashing
-    XXHashFactory HASH_FACTORY = XXHashFactory.safeInstance();
+    XXHashFactory HASH_FACTORY = XXHashFactory.fastestInstance();
 
     /** first byte on every file */
     long FILE_HEADER = 0x4A;

File: src/main/java/org/mapdb/WriteAheadLog.java
Patch:
@@ -116,7 +116,7 @@ public void seal() {
     public void startNextFile() {
         fileNum++;
         String filewal = getWalFileName(""+fileNum);
-        Volume nextVol = volumeFactory.makeVolume(filewal, false, true);
+        Volume nextVol = volumeFactory.makeVolume(filewal, false, -1L);
 
         nextVol.ensureAvailable(16);
 
@@ -340,7 +340,7 @@ void open(WALReplay replay){
                 String wname = getWalFileName(""+i);
                 if(!new File(wname).exists())
                     break;
-                volumes.add(volumeFactory.makeVolume(wname, false, true));
+                volumes.add(volumeFactory.makeVolume(wname, false, -1L));
             }
 
             long walId = replayWALSkipRollbacks(replay);

File: src/main/java/org/mapdb/volume/ByteArrayVol.java
Patch:
@@ -20,7 +20,7 @@ public final class ByteArrayVol extends Volume {
     public static final VolumeFactory FACTORY = new VolumeFactory() {
 
         @Override
-        public Volume makeVolume(String file, boolean readOnly, boolean fileLockDisable, int sliceShift, long initSize, boolean fixedSize) {
+        public Volume makeVolume(String file, boolean readOnly, long fileLockWait, int sliceShift, long initSize, boolean fixedSize) {
             //TODO optimize for fixedSize if bellow 2GB
             return new org.mapdb.volume.ByteArrayVol(sliceShift, initSize);
         }

File: src/main/java/org/mapdb/volume/ByteBufferMemoryVol.java
Patch:
@@ -22,7 +22,7 @@ public final class ByteBufferMemoryVol extends ByteBufferVol {
      */
     public static final VolumeFactory FACTORY = new VolumeFactory() {
         @Override
-        public Volume makeVolume(String file, boolean readOnly, boolean fileLockDisabled, int sliceShift, long initSize, boolean fixedSize) {
+        public Volume makeVolume(String file, boolean readOnly, long fileLockWait, int sliceShift, long initSize, boolean fixedSize) {
             //TODO optimize for fixedSize smaller than 2GB
             return new ByteBufferMemoryVol(true, sliceShift, false, initSize);
         }
@@ -45,7 +45,7 @@ public boolean handlesReadonly() {
      */
     public static final VolumeFactory FACTORY_WITH_CLEANER_HACK = new VolumeFactory() {
         @Override
-        public Volume makeVolume(String file, boolean readOnly, boolean fileLockDisabled, int sliceShift, long initSize, boolean fixedSize) {//TODO prealocate initSize
+        public Volume makeVolume(String file, boolean readOnly, long fileLockWait, int sliceShift, long initSize, boolean fixedSize) {//TODO prealocate initSize
             //TODO optimize for fixedSize smaller than 2GB
             return new ByteBufferMemoryVol(true, sliceShift, true, initSize);
         }

File: src/main/java/org/mapdb/volume/SingleByteArrayVol.java
Patch:
@@ -17,7 +17,7 @@ public final class SingleByteArrayVol extends Volume {
 
     protected final static VolumeFactory FACTORY = new VolumeFactory() {
         @Override
-        public Volume makeVolume(String file, boolean readOnly, boolean fileLockDisabled, int sliceShift, long initSize, boolean fixedSize) {
+        public Volume makeVolume(String file, boolean readOnly, long fileLockWait, int sliceShift, long initSize, boolean fixedSize) {
             if(initSize>Integer.MAX_VALUE)
                 throw new IllegalArgumentException("startSize larger 2GB");
             return new org.mapdb.volume.SingleByteArrayVol((int) initSize);

File: src/test/java/org/mapdb/DBBrokenTest.java
Patch:
@@ -64,7 +64,7 @@ public void canDeleteDBOnBrokenLog() throws IOException {
         DBMaker.fileDB(index.getPath()).make().close();
 
         // corrupt file
-        Volume physVol = new RandomAccessFileVol(index, false, false, 0L);
+        Volume physVol = new RandomAccessFileVol(index, false, 0L, 0L);
         physVol.ensureAvailable(32);
         physVol.putLong(16, 123456789L);
         physVol.sync();

File: src/main/java/org/mapdb/CC.java
Patch:
@@ -36,10 +36,10 @@ public interface CC{
     int BTREEMAP_MAX_NODE_SIZE = 32;
 
     int HTREEMAP_CONC_SHIFT = 3;
-    int HTREEMAP_DIR_SHIFT = 6;
+    int HTREEMAP_DIR_SHIFT = 7;
     int HTREEMAP_LEVELS = 4;
 
-    int INDEX_TREE_LONGLONGMAP_DIR_SHIFT = 6;
+    int INDEX_TREE_LONGLONGMAP_DIR_SHIFT = 7;
     int INDEX_TREE_LONGLONGMAP_LEVELS = 4;
 
     boolean LOG_WAL_CONTENT = false;

File: src/main/java/org/mapdb/CC.java
Patch:
@@ -36,10 +36,10 @@ public interface CC{
     int BTREEMAP_MAX_NODE_SIZE = 32;
 
     int HTREEMAP_CONC_SHIFT = 3;
-    int HTREEMAP_DIR_SHIFT = 4;
+    int HTREEMAP_DIR_SHIFT = 6;
     int HTREEMAP_LEVELS = 4;
 
-    int INDEX_TREE_LONGLONGMAP_DIR_SHIFT = 7;
+    int INDEX_TREE_LONGLONGMAP_DIR_SHIFT = 6;
     int INDEX_TREE_LONGLONGMAP_LEVELS = 4;
 
     boolean LOG_WAL_CONTENT = false;

File: src/main/java/org/mapdb/CC.java
Patch:
@@ -51,7 +51,7 @@ public interface CC{
     long FILE_HEADER = 0x4A;
 
     /** second byte in {@link org.mapdb.StoreDirect} file format */
-    long FILE_TYPE_STOREDIRECT  = 1;
+    long FILE_TYPE_STOREDIRECT  = 3;
 
     /** second byte in {@link org.mapdb.StoreWAL} write ahead log */
     long FILE_TYPE_STOREWAL_WAL = 2;

File: src/main/java/org/mapdb/serializer/SerializerArrayTuple.java
Patch:
@@ -119,8 +119,8 @@ public Object valueArrayUpdateVal(Object vals, int pos, Object[] newValue) {
         if(CC.ASSERT && newValue.length!=size)
             throw new AssertionError();
         Object[] ret = cast(vals).clone();
-        System.arraycopy(newValue,0, ret, pos*size, size);
-        return vals;
+        System.arraycopy(newValue, 0, ret, pos*size, size);
+        return ret;
     }
 
     @Override

File: src/test/java/org/mapdb/jsr166Tests/BlockingQueueTest.java
Patch:
@@ -35,7 +35,6 @@ public abstract class BlockingQueueTest extends JSR166TestCase {
 
     /** Like suite(), but non-static */
     public Test testSuite() {
-        // TODO: filter the returned tests using the configuration
         // information provided by the subclass via protected methods.
         return new TestSuite(this.getClass());
     }
@@ -334,7 +333,7 @@ public void realRun() {
 
     /**
      * remove(x) removes x and returns true if present
-     * TODO: move to superclass CollectionTest.java
+     *
      */
     public void testRemoveElement() {
         final BlockingQueue q = emptyCollection();

File: src/main/java/org/mapdb/volume/RandomAccessFileVol.java
Patch:
@@ -343,7 +343,7 @@ public synchronized void putSixLong(long pos, long value) {
     }
 
     @Override
-    public int putPackedLong(long pos, long value) {
+    public synchronized int putPackedLong(long pos, long value) {
         try {
             raf.seek(pos);
 
@@ -367,7 +367,7 @@ public int putPackedLong(long pos, long value) {
 
 
     @Override
-    public long getPackedLong(long pos) {
+    public synchronized long getPackedLong(long pos) {
         try {
             raf.seek(pos);
 

File: src/main/java/org/mapdb/Serializer.java
Patch:
@@ -132,7 +132,7 @@ public interface Serializer<A> extends Comparator<A>{
     ;
 
 
-    /** Packs recid + it adds 3bits checksum. */
+    /** Packs recid + it adds 1bit checksum. */
 
     GroupSerializer<Long> RECID = new SerializerRecid();
 

File: src/main/java/org/mapdb/WriteAheadLog.java
Patch:
@@ -15,7 +15,7 @@
 import java.util.logging.Logger;
 
 /**
- * WAL shared between {@link StoreWAL} and {@link StoreAppend}
+ * WAL shared between {@link StoreWAL}
  */
 public class WriteAheadLog {
 

File: src/main/java/org/mapdb/CC.java
Patch:
@@ -37,4 +37,7 @@ public interface CC{
     int HTREEMAP_CONC_SHIFT = 3;
     int HTREEMAP_DIR_SHIFT = 4;
     int HTREEMAP_LEVELS = 4;
+
+    int INDEX_TREE_LONGLONGMAP_DIR_SHIFT = 7;
+    int INDEX_TREE_LONGLONGMAP_LEVELS = 4;
 }
\ No newline at end of file

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -543,7 +543,7 @@ private long recursiveDirCount(Engine engine,final long dirRecid) {
     public boolean isEmpty() {
         if(counterRecids!=null){
             for(int i=0;i<counterRecids.length;i++){
-                if(0==engines[i].get(counterRecids[i],Serializer.LONG))
+                if(0L!=engines[i].get(counterRecids[i],Serializer.LONG).longValue())
                     return false;
             }
             return true;

File: src/main/java/org/mapdb/Store.java
Patch:
@@ -1019,8 +1019,8 @@ public void close() {
             try{
                 //TODO howto correctly shutdown queue? possible memory leak here?
                 items.clear();
-                items = null;
                 flushGCed();
+                items = null;
                 queue = null;
             }finally {
                 if(lock!=null)

File: src/main/java/org/mapdb/SerializerPojo.java
Patch:
@@ -384,7 +384,7 @@ private static ObjectStreamField[] makeFieldsForClass(Class<?> clazz) {
                 fieldsList.add(f);
             }
             clazz = clazz.getSuperclass();
-            streamClass = ObjectStreamClass.lookup(clazz);
+            streamClass = clazz!=null? ObjectStreamClass.lookup(clazz) : null;
         }
         fields = new ObjectStreamField[fieldsList
                 .size];

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -544,9 +544,9 @@ public boolean isEmpty() {
         if(counterRecids!=null){
             for(int i=0;i<counterRecids.length;i++){
                 if(0==engines[i].get(counterRecids[i],Serializer.LONG))
-                    return true;
+                    return false;
             }
-            return false;
+            return true;
         }
 
         //search tree, until we find first non null

File: src/main/java/org/mapdb/DBMaker.java
Patch:
@@ -1519,6 +1519,9 @@ public Engine makeEngine(){
             if(readOnly)
                 engine = new Engine.ReadOnlyWrapper(engine);
 
+            if (!readOnly && propsGetBool(Keys.deleteFilesAfterClose)) {
+            	engine = new Engine.DeleteFileEngine(engine, file);
+            }
 
             if(propsGetBool(Keys.closeOnJvmShutdown)){
                 engine = new Engine.CloseOnJVMShutdown(engine);

File: src/main/java/org/mapdb/DBMaker.java
Patch:
@@ -1519,6 +1519,9 @@ public Engine makeEngine(){
             if(readOnly)
                 engine = new Engine.ReadOnlyWrapper(engine);
 
+            if (!readOnly && propsGetBool(Keys.deleteFilesAfterClose)) {
+            	engine = new Engine.DeleteFileEngine(engine, file);
+            }
 
             if(propsGetBool(Keys.closeOnJvmShutdown)){
                 engine = new Engine.CloseOnJVMShutdown(engine);

File: src/test/java/org/mapdb/SerializerBaseTest.java
Patch:
@@ -574,6 +574,8 @@ <E> E clone(E value) throws IOException {
             Object a = f.get(null);
             assertTrue("field: "+f.getName(), b.mapdb_all.containsKey(a));
             assertTrue("field: "+f.getName(),a == clone(a));
+
+            assertTrue("field: "+f.getName(),((BTreeKeySerializer)a).isTrusted());
         }
     }
     @Test public void test_Named(){

File: src/test/java/org/mapdb/StoreCachedTest.java
Patch:
@@ -36,7 +36,7 @@
         long recid = e.put(1L, Serializer.LONG);
         int pos = e.lockPos(recid);
         assertEquals(1, e.writeCache[pos].size);
-        e.update(2L, recid,Serializer.LONG);
+        e.update(recid,2L,Serializer.LONG);
         assertEquals(1,e.writeCache[pos].size);
         e.delete(recid,Serializer.LONG);
         assertEquals(1,e.writeCache[pos].size);

File: src/main/java/org/mapdb/SerializerPojo.java
Patch:
@@ -407,7 +407,7 @@ protected void assertClassSerializable(ClassInfo[] classes, Class<?> clazz) thro
             return;
 
         if (!Serializable.class.isAssignableFrom(clazz))
-            throw new NotSerializableException(clazz.getName());
+            throw new DBException.ClassNotSerializable(clazz);
 
     }
 

File: src/main/java/org/mapdb/Store.java
Patch:
@@ -380,7 +380,7 @@ protected <A> DataIO.DataOutputByteArray serialize(A value, Serializer<A> serial
 
             return out;
         } catch (IOException e) {
-            throw new IOError(e);
+            throw new DBException.SerializationIOError(e);
         }
 
     }
@@ -425,7 +425,7 @@ protected <A> A deserialize(Serializer<A> serializer, int size, DataInput input)
 
             return ret;
         }catch(IOException e){
-            throw new IOError(e);
+            throw new DBException.SerializationIOError(e);
         }
     }
 

File: src/main/java/org/mapdb/DataIO.java
Patch:
@@ -1155,6 +1155,7 @@ public static long parity4Get(long i) {
     public static long parity16Set(long i) {
         if(CC.ASSERT && (i&0xFFFF)!=0)
             throw new DBException.PointerChecksumBroken();
+        //TODO parity of 0 is 0, but we should not allow zero values, format change???
         return i | (DataIO.longHash(i)&0xFFFFL);
     }
 

File: src/test/java/examples/CacheOffHeap.java
Patch:
@@ -48,7 +48,7 @@ public static void main(String[] args) {
             cache.put(key,value);
 
             if(counter%1e5==0){
-                System.out.printf("Map size: %,d, counter %,d, store size: %,d, store free size: %,d\n",
+                System.out.printf("Map size: %,d, counter %,d, store size: %,d, store free size: %,d%n",
                         cache.sizeLong(), counter, store.getCurrSize(),  store.getFreeSize());
             }
 

File: src/test/java/examples/CacheOffHeapAdvanced.java
Patch:
@@ -58,7 +58,7 @@ public static void main(String[] args) {
             cache.put(key,value);
 
             if(counter%1e5==0){
-                System.out.printf("Map size: %,d, counter %,d, curr store size: %,d, store free size: %,d\n",
+                System.out.printf("Map size: %,d, counter %,d, curr store size: %,d, store free size: %,d%n",
                         cache.sizeLong(), counter, store.getCurrSize(),  store.getFreeSize());
             }
 

File: src/test/java/org/mapdb/issues/Issue148Test.java
Patch:
@@ -104,7 +104,7 @@ public static void dumpUserDB(HTreeMap<String, CustomValue> users){
 
         for( String key : keyset ){
             CustomValue cv = users.get(key);
-            System.out.format("%s(%b) : %d\n", key, key.equals(cv.name), cv.age);
+            System.out.format("%s(%b) : %d%n", key, key.equals(cv.name), cv.age);
         }
 
         System.out.println("");

File: src/main/java/org/mapdb/DBException.java
Patch:
@@ -95,7 +95,7 @@ public VolumeEOF(String s) {
     public static class OutOfMemory extends VolumeIOError{
         public OutOfMemory(Throwable e){
             super(
-                    e.getMessage().equals("Direct buffer memory")?
+                    "Direct buffer memory".equals(e.getMessage())?
                             "Out of Direct buffer memory. Increase it with JVM option '-XX:MaxDirectMemorySize=10G'":
                             e.getMessage(),
                     e);

File: src/test/java/examples/CacheOffHeap.java
Patch:
@@ -48,7 +48,7 @@ public static void main(String[] args) {
             cache.put(key,value);
 
             if(counter%1e5==0){
-                System.out.printf("Map size: %,d, counter %,d, store size: %,d, store free size: %,d\n",
+                System.out.printf("Map size: %,d, counter %,d, store size: %,d, store free size: %,d%n",
                         cache.sizeLong(), counter, store.getCurrSize(),  store.getFreeSize());
             }
 

File: src/test/java/examples/CacheOffHeapAdvanced.java
Patch:
@@ -58,7 +58,7 @@ public static void main(String[] args) {
             cache.put(key,value);
 
             if(counter%1e5==0){
-                System.out.printf("Map size: %,d, counter %,d, curr store size: %,d, store free size: %,d\n",
+                System.out.printf("Map size: %,d, counter %,d, curr store size: %,d, store free size: %,d%n",
                         cache.sizeLong(), counter, store.getCurrSize(),  store.getFreeSize());
             }
 

File: src/test/java/org/mapdb/issues/Issue148Test.java
Patch:
@@ -104,7 +104,7 @@ public static void dumpUserDB(HTreeMap<String, CustomValue> users){
 
         for( String key : keyset ){
             CustomValue cv = users.get(key);
-            System.out.format("%s(%b) : %d\n", key, key.equals(cv.name), cv.age);
+            System.out.format("%s(%b) : %d%n", key, key.equals(cv.name), cv.age);
         }
 
         System.out.println("");

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -308,7 +308,7 @@ protected int headChecksum(Volume vol2) {
     @Override
     protected <A> A get2(long recid, Serializer<A> serializer) {
         if (CC.ASSERT)
-            assertReadLocked(recid);
+            assertReadLocked(lockPos(recid));
 
         long[] offsets = offsetsGet(lockPos(recid),indexValGet(recid));
         return getFromOffset(serializer, offsets);
@@ -1601,7 +1601,7 @@ private void updateFromCompact(long recid, long indexVal, Volume oldVol) {
 
     protected long indexValGet(long recid) {
         if(CC.ASSERT)
-            assertReadLocked(recid);
+            assertReadLocked(lockPos(recid));
 
         long offset = recidToOffset(recid);
         long indexVal = vol.getLong(offset);
@@ -1615,7 +1615,7 @@ protected long indexValGet(long recid) {
 
     protected long indexValGetRaw(long recid) {
         if(CC.ASSERT)
-            assertReadLocked(recid);
+            assertReadLocked(lockPos(recid));
 
         long offset = recidToOffset(recid);
         return vol.getLong(offset);

File: src/main/java/org/mapdb/StoreHeap.java
Patch:
@@ -61,7 +61,7 @@ public StoreHeap(boolean txDisabled, int lockScale, int lockingStrategy, boolean
     @Override
     protected <A> A get2(long recid, Serializer<A> serializer) {
         if(CC.ASSERT)
-            assertReadLocked(recid);
+            assertReadLocked(lockPos(recid));
 
         int pos = lockPos(recid);
         A ret =  (A) data[pos].get(recid);

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -283,7 +283,7 @@ protected DataInput walGetData(long offset, int segment) {
     @Override
     protected long indexValGet(long recid) {
         if(CC.ASSERT)
-            assertReadLocked(recid);
+            assertReadLocked(lockPos(recid));
         int segment = lockPos(recid);
         long offset = recidToOffset(recid);
         long ret = uncommittedIndexTable[segment].get(offset);
@@ -299,7 +299,7 @@ protected long indexValGet(long recid) {
     @Override
     protected long indexValGetRaw(long recid) {
         if(CC.ASSERT)
-            assertReadLocked(recid);
+            assertReadLocked(lockPos(recid));
         int segment = lockPos(recid);
         long offset = recidToOffset(recid);
         long ret = uncommittedIndexTable[segment].get(offset);
@@ -433,7 +433,7 @@ protected byte[] loadLongStackPage(long pageOffset, boolean willBeModified) {
     @Override
     protected <A> A get2(long recid, Serializer<A> serializer) {
         if (CC.ASSERT)
-            assertReadLocked(recid);
+            assertReadLocked(lockPos(recid));
         int segment = lockPos(recid);
 
         //is in write cache?

File: src/test/java/doc/htreemap_cache_space_limit2.java
Patch:
@@ -10,7 +10,7 @@ public class htreemap_cache_space_limit2 {
     public static void main(String[] args) {
         DB db = DBMaker.memoryDB().make();
         //a
-        HTreeMap cache = db.createHashMap("cache")
+        HTreeMap cache = db.hashMapCreate("cache")
                 .expireStoreSize(128)
                 .makeOrGet();
         //z

File: src/main/java/org/mapdb/WriteAheadLog.java
Patch:
@@ -461,7 +461,7 @@ long replayWALSkipRollbacks(WALReplay replay) {
         Volume vol = volumes.get((int) walPointerToFileNum(ret));
         long offset = walPointerToOffset(ret);
         if(offset!=0 && offset!=vol.length()) {
-            vol.clear(offset, vol.length());
+            vol.clearOverlap(offset, vol.length());
             vol.sync();
         }
         return ret;

File: src/test/java/org/mapdb/issues/IssuesTest.java
Patch:
@@ -32,7 +32,7 @@ public class IssuesTest {
         DB db = DBMaker
                 .fileDB(file)
                 .fileMmapEnable()
-
+                .fileMmapCleanerHackEnable()
                 .transactionDisable()
                 .cacheSize(128)
                 .closeOnJvmShutdown()

File: src/test/java/org/mapdb/BrokenDBTest.java
Patch:
@@ -60,7 +60,7 @@ public void canDeleteDBOnBrokenLog() throws IOException {
         DBMaker.fileDB(index).make().close();
 
         // corrupt file
-        MappedFileVol physVol = new Volume.MappedFileVol(index, false, false, CC.VOLUME_PAGE_SHIFT,false, 0L);
+        Volume physVol = new Volume.RandomAccessFileVol(index, false, false, 0L);
         physVol.ensureAvailable(32);
         //TODO corrupt file somehow
 //        physVol.putInt(0, StoreDirect.HEADER);

File: src/test/java/org/mapdb/issues/Issue254Test.java
Patch:
@@ -41,8 +41,9 @@ public void test(){
 
     {
         File f = TT.tempDbFile();
-        ro = DBMaker.fileDB(f).transactionDisable().transactionDisable().make();
-        ro = DBMaker.fileDB(f).transactionDisable().transactionDisable().readOnly().make();
+        ro = DBMaker.fileDB(f).transactionDisable().make();
+        ro.close();
+        ro = DBMaker.fileDB(f).transactionDisable().readOnly().make();
     }
 
     @Test

File: src/test/java/org/mapdb/issues/Issue523Test.java
Patch:
@@ -22,7 +22,7 @@ public void  MapDbReadOnlyTest() throws IOException {
     }
 
     private void testCreate(File dbFile) {
-        DB db = DBMaker.fileDB(dbFile).transactionDisable().mmapFileEnable().make();
+        DB db = DBMaker.fileDB(dbFile).transactionDisable().fileMmapEnable().fileMmapCleanerHackEnable().make();
 
             BTreeMap<Integer, String> map = db.treeMapCreate("aa").makeOrGet();
             for (int i = 0; i < NUM_ENTRIES; i++) {
@@ -36,7 +36,7 @@ private void testCreate(File dbFile) {
     }
 
     private void testRead(File dbFile) {
-        DB db = DBMaker.fileDB(dbFile).transactionDisable().readOnly().mmapFileEnable().make();
+        DB db = DBMaker.fileDB(dbFile).transactionDisable().readOnly().fileMmapCleanerHackEnable().make();
 
             BTreeMap<Integer, String> map = db.treeMapCreate("aa").makeOrGet();
             for (int i = 0; i < NUM_ENTRIES; i++) {

File: src/test/java/org/mapdb/issues/IssuesTest.java
Patch:
@@ -32,6 +32,7 @@ public class IssuesTest {
         DB db = DBMaker
                 .fileDB(file)
                 .fileMmapEnable()
+
                 .transactionDisable()
                 .cacheSize(128)
                 .closeOnJvmShutdown()

File: src/test/java/org/mapdb/CrashTest.java
Patch:
@@ -107,7 +107,7 @@ public void test() throws IOException, InterruptedException {
         File seedEndDir = new File(dir,"seedEnd");
 
 
-        long end = TT.nowPlusMinutes(1+TT.scale()*9);
+        long end = TT.nowPlusMinutes(0.5+TT.scale()*9);
         if(dir.getFreeSpace()<10e9)
             fail("not enough free disk space, at least 10GB needed: "+dir.getFreeSpace());
 

File: src/test/java/org/mapdb/WALCrash.java
Patch:
@@ -23,7 +23,7 @@ public class WALCrash {
     public void crash() throws InterruptedException, IOException {
     dir = TT.tempDbDir();
 
-        long end = TT.nowPlusMinutes(1+TT.scale()*9);
+        long end = TT.nowPlusMinutes(0.5+TT.scale()*9);
         if(dir.getFreeSpace()<10e9)
             fail("not enough free disk space, at least 10GB needed: "+dir.getFreeSpace());
 

File: src/test/java/org/mapdb/CrashTest.java
Patch:
@@ -24,8 +24,8 @@
 @RunWith(Parameterized.class)
 public class CrashTest {
 
-    static final int MIN_RUNTIME = 1000*3;
-    static final int MAX_RUNTIME = 1000*10;
+    static final int MIN_RUNTIME = 3000;
+    static final int MAX_RUNTIME = 10000;
 
 
     public static File DIR;

File: src/test/java/org/mapdb/StoreAppendTest.java
Patch:
@@ -171,11 +171,11 @@ public void commit_huge() {
                 e.update(recids.get(i), TT.randomByteArray(20, i+loop), Serializer.BYTE_ARRAY_NOSIZE);
             }
             e.commit();
-            long initOffset = e.wal.walOffset.get();
+            long initOffset = e.wal.fileOffset;
             for (int i = 0; i < recids.size(); i++) {
                 e.update(recids.get(i), TT.randomByteArray(30, i+loop), Serializer.BYTE_ARRAY_NOSIZE);
             }
-            long preCommitOffset = e.wal.walOffset.get();
+            long preCommitOffset = e.wal.fileOffset;
             File file = e.wal.curVol.getFile();
             e.commit();
             e.close();
@@ -187,7 +187,7 @@ public void commit_huge() {
             vol.close();
 
             e = openEngine();
-            assertEquals(initOffset, e.wal.walOffset.get());
+            assertEquals(initOffset, e.wal.fileOffset);
             for (int i = 0; i < recids.size(); i++) {
                 byte[] b = e.get(recids.get(i), Serializer.BYTE_ARRAY_NOSIZE);
                 assertEquals(20, b.length);

File: src/main/java/org/mapdb/StoreCached.java
Patch:
@@ -229,7 +229,7 @@ masterLinkOffset > longStackMasterLinkOffset(round16Up(MAX_REC_SIZE)) ||
 
         //release old page, size is stored as part of prev page value
         uncommittedStackPages.remove(pageOffset);
-        freeDataPut(pageOffset, currPageSize);
+        freeDataPut(-1, pageOffset, currPageSize);
         //TODO how TX should handle this
 
         return ret;

File: src/test/java/org/mapdb/issues/Issue381Test.java
Patch:
@@ -18,8 +18,9 @@ public void testCorruption()
     {
 
         File f = TT.tempDbFile();
+        int max = 10+TT.scale()*1000;
 
-        for(int j=0;j<10;j++) {
+        for(int j=0;j<max;j++) {
             final int INSTANCES = 1000;
             TxMaker txMaker  = DBMaker.fileDB(f).makeTxMaker();
           

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -793,7 +793,7 @@ public void close() {
                 }
 
                 if(hasUncommitedData()){
-                    LOG.warning("Closing storage with uncommited data, those data will be discarded.");
+                    LOG.warning("Closing storage with uncommited data, this data will be discarded.");
                 }
                 wal.rollback();
                 //TODO do not replay if not dirty

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -793,7 +793,7 @@ public void close() {
                 }
 
                 if(hasUncommitedData()){
-                    LOG.warning("Closing storage with uncommited data, those data will be discarded.");
+                    LOG.warning("Closing storage with uncommited data, this data will be discarded.");
                 }
                 wal.rollback();
                 //TODO do not replay if not dirty

File: src/main/java/org/mapdb/DBException.java
Patch:
@@ -145,7 +145,7 @@ public PumpSourceDuplicate(Object key) {
 
     public static class PumpSourceNotSorted extends DBException {
         public PumpSourceNotSorted() {
-            super("Source iterator not sorted, use .pumpPresort(10000000) to sort keys.");
+            super("Source iterator not sorted in reverse order, use .pumpPresort(10000000) to sort keys.");
         }
     }
 

File: src/test/java/org/mapdb/StoreDirectTest2.java
Patch:
@@ -153,7 +153,7 @@ DataOutputByteArray newBuf(int size){
         StoreDirect st = newStore();
         st.structuralLock.lock();
         int totalSize = round16Up(1000);
-        long o = st.freeDataTakeSingle(totalSize)&MOFFSET;
+        long o = st.freeDataTakeSingle(totalSize,false)&MOFFSET;
 
         //write data
         long recid = RECID_FIRST;
@@ -174,7 +174,7 @@ DataOutputByteArray newBuf(int size){
         StoreDirect st = newStore();
         st.structuralLock.lock();
         int totalSize = round16Up(1000);
-        long o = st.freeDataTakeSingle(totalSize)&MOFFSET;
+        long o = st.freeDataTakeSingle(totalSize,false)&MOFFSET;
 
         //write data
         long recid = RECID_FIRST;
@@ -207,7 +207,7 @@ DataOutputByteArray newBuf(int size){
         StoreDirect st = newStore();
         st.structuralLock.lock();
         int totalSize = round16Up(1000);
-        long o = st.freeDataTakeSingle(totalSize)&MOFFSET;
+        long o = st.freeDataTakeSingle(totalSize,false)&MOFFSET;
 
         //write data
         long recid = RECID_FIRST;

File: src/test/java/org/mapdb/HTreeMap3Test.java
Patch:
@@ -67,7 +67,7 @@ protected String getSecondValueNotInPopulatedMap() throws UnsupportedOperationEx
     protected ConcurrentMap<Integer, String> makeEmptyMap() throws UnsupportedOperationException {
         Engine[] engines = HTreeMap.fillEngineArray(r);
         return new HTreeMap(engines,
-                false, null,0, HTreeMap.preallocateSegments(engines), Serializer.INTEGER, Serializer.STRING,0,0,0,0,0,null,null,null,null, 0L,false,null);
+                false, null,0, HTreeMap.preallocateSegments(engines), Serializer.INTEGER, Serializer.STRING,0,0,0,0,0,0,null,null,null,null, 0L,false,null);
     }
 
     @Override

File: src/test/java/org/mapdb/HTreeSetTest.java
Patch:
@@ -55,15 +55,15 @@ public class HTreeSetTest{
         engine.init();
         Engine[] engines = HTreeMap.fillEngineArray(engine);
         hs = new HTreeMap(engines,
-                false, null, 0,HTreeMap.preallocateSegments(engines),Serializer.BASIC,null,0,0,0,0,0,null,null,null,null, 0L, false, null).keySet();
+                false, null, 0,HTreeMap.preallocateSegments(engines),Serializer.BASIC,null,0,0,0,0,0,0,null,null,null,null, 0L, false, null).keySet();
         Collections.addAll(hs, objArray);
     }
 
     @Test public void test_Constructor() {
         // Test for method java.util.HashSet()
         Engine[] engines = HTreeMap.fillEngineArray(engine);
         Set hs2 = new HTreeMap(engines,
-                false, null,0,HTreeMap.preallocateSegments(engines),Serializer.BASIC,null,0,0,0,0,0,null,null,null,null,0L, false, null).keySet();
+                false, null,0,HTreeMap.preallocateSegments(engines),Serializer.BASIC,null,0,0,0,0,0,0,null,null,null,null,0L, false, null).keySet();
         assertEquals("Created incorrect HashSet", 0, hs2.size());
     }
 
@@ -107,7 +107,7 @@ public void close(){
         // Test for method boolean java.util.HashSet.isEmpty()
         Engine[] engines = HTreeMap.fillEngineArray(engine);
         assertTrue("Empty set returned false", new HTreeMap(engines,
-                false, null,0,HTreeMap.preallocateSegments(engines),Serializer.BASIC,null,0,0,0,0,0,null,null,null,null,0L, false,null).keySet().isEmpty());
+                false, null,0,HTreeMap.preallocateSegments(engines),Serializer.BASIC,null,0,0,0,0,0,0,null,null,null,null,0L, false,null).keySet().isEmpty());
         assertTrue("Non-empty set returned true", !hs.isEmpty());
     }
 

File: src/test/java/org/mapdb/issues/Issue583Test.java
Patch:
@@ -50,6 +50,7 @@ public void testGettingFromMemoryMapReturnsNull() {
         HTreeMap<Integer, Value> memoryMap = memoryDb.hashMapCreate(MAP)
                 .expireMaxSize(1)
                 .expireOverflow(diskMap, true)
+                .expireTick(0)
                 .make();
 
 

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -587,7 +587,7 @@ public V get(final Object o){
         if(expireSingleThreadFlag)
             expirePurge();
 
-        if(valueCreator==null){
+        if(valueCreator==null || ln!=null){
             if(ln==null)
                 return null;
             return ln.value;

File: src/test/java/org/mapdb/issues/Issue114Test.java
Patch:
@@ -1,7 +1,9 @@
-package org.mapdb;
+package org.mapdb.issues;
 
 
 import org.junit.Test;
+import org.mapdb.DB;
+import org.mapdb.DBMaker;
 
 public class Issue114Test {
 

File: src/test/java/org/mapdb/issues/Issue148Test.java
Patch:
@@ -1,9 +1,10 @@
-package org.mapdb;
+package org.mapdb.issues;
 
 
 
 
 import org.junit.Test;
+import org.mapdb.*;
 
 import java.io.*;
 import java.util.Set;
@@ -17,7 +18,7 @@ public class Issue148Test {
 
         String str = TT.randomString(1000);
         Engine engine = DBMaker.appendFileDB(mapdbFile).closeOnJvmShutdown().makeEngine();
-        long recid = engine.put(str,Serializer.STRING_NOSIZE);
+        long recid = engine.put(str, Serializer.STRING_NOSIZE);
         engine.commit();
         engine.close();
 

File: src/test/java/org/mapdb/issues/Issue154Test.java
Patch:
@@ -1,7 +1,8 @@
-package org.mapdb;
+package org.mapdb.issues;
 
 
 import org.junit.Test;
+import org.mapdb.*;
 
 import java.util.Map;
 
@@ -49,7 +50,7 @@ public void HTreeMap(){
     @Test public void simple(){
         TxMaker txMaker = DBMaker.memoryDB().makeTxMaker();
         Engine engine = txMaker.makeTx().getEngine();
-        long recid = engine.put("aa",Serializer.STRING_NOSIZE);
+        long recid = engine.put("aa", Serializer.STRING_NOSIZE);
         engine.commit();
         engine = txMaker.makeTx().getEngine();
         assertEquals("aa",engine.get(recid,Serializer.STRING_NOSIZE));

File: src/test/java/org/mapdb/issues/Issue170Test.java
Patch:
@@ -1,6 +1,8 @@
-package org.mapdb;
+package org.mapdb.issues;
 
 import org.junit.Test;
+import org.mapdb.DBMaker;
+import org.mapdb.TT;
 
 import java.util.Map;
 import java.util.UUID;

File: src/test/java/org/mapdb/issues/Issue183Test.java
Patch:
@@ -1,6 +1,7 @@
-package org.mapdb;
+package org.mapdb.issues;
 
 import org.junit.Test;
+import org.mapdb.*;
 
 import java.io.*;
 import java.util.Map;

File: src/test/java/org/mapdb/issues/Issue258Test.java
Patch:
@@ -1,7 +1,8 @@
-package org.mapdb;
+package org.mapdb.issues;
 
 
 import org.junit.Test;
+import org.mapdb.*;
 
 import java.io.File;
 import java.io.IOException;
@@ -119,7 +120,7 @@ public void testWithChecksumEmpty() throws IOException {
 
         Map<Long,Integer> m = new HashMap();
         for(int i=0;i<max;i++){
-            long recid = e.put(i,Serializer.INTEGER);
+            long recid = e.put(i, Serializer.INTEGER);
             m.put(recid,i);
         }
 

File: src/test/java/org/mapdb/issues/Issue265Test.java
Patch:
@@ -1,7 +1,9 @@
-package org.mapdb;
+package org.mapdb.issues;
 
 import org.junit.Assert;
 import org.junit.Test;
+import org.mapdb.DB;
+import org.mapdb.DBMaker;
 
 import java.util.Map;
 

File: src/test/java/org/mapdb/issues/Issue308Test.java
Patch:
@@ -1,6 +1,7 @@
-package org.mapdb;
+package org.mapdb.issues;
 
 import org.junit.Test;
+import org.mapdb.*;
 
 import java.util.Iterator;
 import java.util.concurrent.atomic.AtomicLong;

File: src/test/java/org/mapdb/issues/Issue321Test.java
Patch:
@@ -1,6 +1,8 @@
-package org.mapdb;
+package org.mapdb.issues;
 
 import org.junit.Test;
+import org.mapdb.DB;
+import org.mapdb.DBMaker;
 
 import java.util.Arrays;
 import java.util.List;

File: src/test/java/org/mapdb/issues/Issue37Test.java
Patch:
@@ -1,7 +1,9 @@
-package org.mapdb;
+package org.mapdb.issues;
 
 
 import org.junit.Test;
+import org.mapdb.DB;
+import org.mapdb.DBMaker;
 
 import java.util.Iterator;
 import java.util.LinkedHashSet;

File: src/test/java/org/mapdb/issues/Issue90Test.java
Patch:
@@ -1,6 +1,7 @@
-package org.mapdb;
+package org.mapdb.issues;
 
 import org.junit.Test;
+import org.mapdb.*;
 
 import java.io.File;
 
@@ -11,7 +12,7 @@ public void testCounter() throws Exception {
         File file = TT.tempDbFile();
 
 
-        final DB mapDb =DBMaker.appendFileDB(file)
+        final DB mapDb = DBMaker.appendFileDB(file)
                 .closeOnJvmShutdown()
                 .compressionEnable()  //This is the cause of the exception. If compression is not used, no exception occurs.
                 .make();

File: src/test/java/org/mapdb/issues/IssuesTest.java
Patch:
@@ -1,6 +1,7 @@
-package org.mapdb;
+package org.mapdb.issues;
 
 import org.junit.Test;
+import org.mapdb.*;
 
 import java.io.File;
 import java.util.Map;

File: src/test/java/org/mapdb/BrokenDBTest.java
Patch:
@@ -34,9 +34,9 @@ public void canDeleteDBOnBrokenIndex() throws FileNotFoundException, IOException
         try {
             DBMaker.fileDB(index).make();
             Assert.fail("Expected exception not thrown");
-        } catch (final DBException.DataCorruption e) {
+        } catch (final DBException.WrongConfig e) {
             // will fail!
-            Assert.assertTrue("Wrong message", e.getMessage().contains("wrong header in file"));
+            Assert.assertTrue("Wrong message", e.getMessage().contains("This is not MapDB file"));
         }
 
         index.delete();

File: src/test/java/org/mapdb/StoreDirectTest2.java
Patch:
@@ -425,15 +425,15 @@ protected void verifyIndexPageChecksum(StoreDirect st) {
         ((StoreDirect)db.engine).storeCheck();
         Map map = db.hashMap("map", Serializer.INTEGER, Serializer.BYTE_ARRAY);
         ((StoreDirect)db.engine).storeCheck();
-        long n = (long) (1000 + 1e7*TT.scale());
+        long n = (long) (1000 + 1e5*TT.scale());
         Random r = new Random(1);
         while(n-->0){  //LOL :)
             int key = r.nextInt(10000);
             map.put(key, new byte[r.nextInt(100000)]);
             if(r.nextInt(10)<2)
                 map.remove(key);
 
-            //if(n%1000==0)
+            if(!TT.shortTest())
                 ((StoreDirect)db.engine).storeCheck();
         }
         ((StoreDirect)db.engine).storeCheck();

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -91,8 +91,7 @@
  * Concurrent operations on B∗-trees with overtaking</a>
  * written by Yehoshua Sagiv.
  * More practical aspects of BTreeMap implementation are based on
- * <a href="http://cs.au.dk/~tyoung/~td202/">notes</a>
- * and <a href="http://cs.au.dk/~tyoung/~td202/btree/">demo application</a> from Thomas Dinsdale-Young.
+ * <a href="http://cs.au.dk/~tyoung/btree/index.html">demo application</a> from Thomas Dinsdale-Young.
  * Also more work from Thomas: <a href="http://www.doc.ic.ac.uk/research/technicalreports/2011/#10">A Simple Abstraction for Complex Concurrent Indexes</a>
  * </p><p>
  *

File: src/test/java/org/mapdb/IssuesTest.java
Patch:
@@ -67,7 +67,7 @@ public class IssuesTest {
         if(scale==0)
             return;
         File f = TT.tempDbFile();
-        for(int j=0;j<10000*scale;j++) {
+        for(int j=0;j<100*scale;j++) {
             DB db = DBMaker.fileDB(f)
                     .checksumEnable()
                     .make();

File: src/main/java/org/mapdb/TxEngine.java
Patch:
@@ -453,7 +453,8 @@ public <A> boolean compareAndSwap(long recid, A expectedOldValue, A newValue, Se
                 lock.lock();
                 try{
                     A oldVal = getNoLock(recid, serializer);
-                    boolean ret = oldVal!=null && oldVal.equals(expectedOldValue);
+                    boolean ret = oldVal==expectedOldValue ||
+                            (oldVal!=null && oldVal.equals(expectedOldValue));
                     if(ret){
                         mod.put(recid,new Fun.Pair(newValue,serializer));
                     }

File: src/main/java/org/mapdb/DataIO.java
Patch:
@@ -233,7 +233,7 @@ public static int intHash(int h) {
         return h ^ h >> 16;
     }
 
-    public static final long PACK_LONG_RESULT_MASK = 0xFFFFFFFFFFFFFFL;
+    public static final long PACK_LONG_RESULT_MASK = 0xFFFFFFFFFFFFFFFL;
 
 
     public static int packLongBidi(DataOutput out, long value) throws IOException {
@@ -287,7 +287,7 @@ public static long unpackLongBidi(byte[] bb, int pos){
             offset += 7;
         }while((b & 0x80) == 0);
         //$DELAY$
-        return (((long)(offset/7))<<56) | result;
+        return (((long)(offset/7))<<60) | result;
     }
 
 
@@ -307,7 +307,7 @@ public static long unpackLongBidiReverse(byte[] bb, int pos){
             counter++;
         }while((b & 0x80) == 0);
         //$DELAY$
-        return (((long)counter)<<56) | result;
+        return (((long)counter)<<60) | result;
     }
 
     public static long getLong(byte[] buf, int pos) {

File: src/main/java/org/mapdb/StoreCached.java
Patch:
@@ -179,7 +179,7 @@ protected long longStackTake(long masterLinkOffset, boolean recursive) {
         long ret = DataIO.unpackLongBidiReverse(page, (int) currSize);
         //extract number of read bytes
         long oldCurrSize = currSize;
-        currSize -= ret >>> 56;
+        currSize -= ret >>> 60;
         //clear bytes occupied by prev value
         Arrays.fill(page, (int) currSize, (int) oldCurrSize, (byte) 0);
         //and finally set return value
@@ -280,7 +280,7 @@ protected long longStackCount(final long masterLinkOffset){
             while(currSize>8){
                 long read = DataIO.unpackLongBidiReverse(page,currSize);
                 //extract number of read bytes
-                currSize-= read >>>56;
+                currSize-= read >>>60;
                 ret++;
             }
 

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -946,7 +946,7 @@ protected long longStackTake(long masterLinkOffset, boolean recursive){
         long ret = vol.getLongPackBidiReverse(pageOffset+currSize);
         //extract number of read bytes
         long oldCurrSize = currSize;
-        currSize-= ret >>>56;
+        currSize-= ret >>>60;
         //clear bytes occupied by prev value
         vol.clear(pageOffset+currSize, pageOffset+oldCurrSize);
         //and finally set return value
@@ -1025,7 +1025,7 @@ protected long longStackCount(final long masterLinkOffset){
             while(currSize>8){
                 long read = vol.getLongPackBidiReverse(pageOffset+currSize);
                 //extract number of read bytes
-                currSize-= read >>>56;
+                currSize-= read >>>60;
                 ret++;
             }
 

File: src/test/java/org/mapdb/DataIOTest.java
Patch:
@@ -44,8 +44,8 @@ public void testPackLongBidi() throws Exception {
             long size = packLongBidi(b,i);
             assertTrue(i>100000 || size<6);
             assertEquals(b.pos,size);
-            assertEquals(i | (size<<56), unpackLongBidi(b.buf,0));
-            assertEquals(i | (size<<56), unpackLongBidiReverse(b.buf, (int) size));
+            assertEquals(i | (size<<60), unpackLongBidi(b.buf,0));
+            assertEquals(i | (size<<60), unpackLongBidiReverse(b.buf, (int) size));
         }
     }
 

File: src/test/java/org/mapdb/StoreDirectTest.java
Patch:
@@ -482,7 +482,7 @@ protected List<Long> getLongStack(long masterLinkOffset) {
         for(int i=111;i<=115;i++){
             long val = e.vol.getLongPackBidi(offset);
             assertEquals(i, DataIO.parity1Get(val & DataIO.PACK_LONG_RESULT_MASK)>>>1);
-            offset += val >>> 56;
+            offset += val >>> 60;
         }
         assertEquals(currPageSize, offset-pageId);
 
@@ -578,7 +578,7 @@ protected List<Long> getLongStack(long masterLinkOffset) {
         for(long i=1000,pos=8;;i++){
             long val = e.vol.getLongPackBidi(pageId+pos);
             assertEquals(i, DataIO.parity1Get(val&DataIO.PACK_LONG_RESULT_MASK)>>>1);
-            pos+=val>>>56;
+            pos+=val>>>60;
             if(pos==actualChunkSize){
                 break;
             }

File: src/test/java/org/mapdb/VolumeTest.java
Patch:
@@ -117,8 +117,8 @@ public void testPackLongBidi() throws Exception {
                 long size = v.putLongPackBidi(10, i);
                 assertTrue(i > 100000 || size < 6);
 
-                assertEquals(i | (size << 56), v.getLongPackBidi(10));
-                assertEquals(i | (size << 56), v.getLongPackBidiReverse(10 + size));
+                assertEquals(i | (size << 60), v.getLongPackBidi(10));
+                assertEquals(i | (size << 60), v.getLongPackBidiReverse(10 + size));
             }
             v.close();
         }

File: src/main/java/org/mapdb/Pump.java
Patch:
@@ -923,7 +923,7 @@ public static void archiveTreeMap(NavigableMap source, File target, DB.BTreeMapM
 
         s.close();
     }
-Po
+
     public static void archiveTreeMap(Iterator<Fun.Pair> source, String file, Volume.VolumeFactory factory, DB.BTreeMapMaker config) {
         //init store
         StoreArchive s = new StoreArchive(

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -1132,7 +1132,7 @@ public void backup(OutputStream out, boolean incremental) {
                     throw new DBException.ChecksumBroken();
                 }
 
-                //check if was discarted
+                //check if was discarded
                 if((indexVal&MUNUSED)!=0||indexVal == 0){
                     continue recidLoop;
                 }
@@ -1489,7 +1489,7 @@ protected void compactIndexPage(StoreDirect target, int indexPageI, long maxReci
                 throw new DBException.ChecksumBroken();
             }
 
-            //check if was discarted
+            //check if was discarded
             if((indexVal&MUNUSED)!=0||indexVal == 0){
                 //mark rec id as free, so it can be reused
                 target.structuralLock.lock();

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -1345,7 +1345,7 @@ public void close() {
                 }
 
                 if(hasUncommitedData()){
-                    LOG.warning("Closing storage with uncommited data, those data will be discarted.");
+                    LOG.warning("Closing storage with uncommited data, those data will be discarded.");
                 }
 
 

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -1132,7 +1132,7 @@ public void backup(OutputStream out, boolean incremental) {
                     throw new DBException.ChecksumBroken();
                 }
 
-                //check if was discarted
+                //check if was discarded
                 if((indexVal&MUNUSED)!=0||indexVal == 0){
                     continue recidLoop;
                 }
@@ -1489,7 +1489,7 @@ protected void compactIndexPage(StoreDirect target, int indexPageI, long maxReci
                 throw new DBException.ChecksumBroken();
             }
 
-            //check if was discarted
+            //check if was discarded
             if((indexVal&MUNUSED)!=0||indexVal == 0){
                 //mark rec id as free, so it can be reused
                 target.structuralLock.lock();

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -1345,7 +1345,7 @@ public void close() {
                 }
 
                 if(hasUncommitedData()){
-                    LOG.warning("Closing storage with uncommited data, those data will be discarted.");
+                    LOG.warning("Closing storage with uncommited data, those data will be discarded.");
                 }
 
 

File: src/main/java/org/mapdb/Queues.java
Patch:
@@ -107,7 +107,7 @@ public E poll() {
                 //update head
                 if(head.compareAndSet(head2,n.next)){
                     //updated fine, so we can take a value
-                    engine.delete(head2,nodeSerializer);
+                    engine.update(head2,null, nodeSerializer);
                     return n.value;
                 }
             }
@@ -352,7 +352,7 @@ public Queue(Engine engine, Serializer<E> serializer, long headerRecid,
 
         @Override
         public boolean add(E e) {
-            long nextTail = engine.preallocate(); //nodeSerializer
+            long nextTail = engine.put(null, nodeSerializer);
 
             long tail2 = tail.get();
             while(!tail.compareAndSet(tail2,nextTail)){

File: src/main/java/org/mapdb/Fun.java
Patch:
@@ -412,8 +412,10 @@ Object[] moveToNext() {
                         Object[] next = iter.next();
                         if(next==null)
                             return null;
+                        Object[] next2 = next.length<=keys.length? next :
+                                Arrays.copyOf(next,keys.length); //TODO optimize away arrayCopy
                         //check all elements are equal
-                        if(comparator.compare(next,keys)<0){
+                        if(comparator.compare(next2,keys)!=0){
                             return null;
                         }
                         return next;

File: src/main/java/org/mapdb/DataIO.java
Patch:
@@ -1491,7 +1491,8 @@ public static long hash(byte[] buf, int off, int len, long seed) {
         if (len < 0) {
             throw new IllegalArgumentException("lengths must be >= 0");
         }
-        if(off<0 || off>=buf.length || off+len<0 || off+len>buf.length){
+
+        if(off<0 || off>buf.length || off+len<0 || off+len>buf.length){
             throw new IndexOutOfBoundsException();
         }
 
@@ -1603,7 +1604,7 @@ public static long hash(char[] buf, int off, int len, long seed) {
         if (len < 0) {
             throw new IllegalArgumentException("lengths must be >= 0");
         }
-        if(off<0 || off>=buf.length || off+len<0 || off+len>buf.length){
+        if(off<0 || off>buf.length || off+len<0 || off+len>buf.length){
             throw new IndexOutOfBoundsException();
         }
 

File: src/main/java/org/mapdb/UnsafeStuff.java
Patch:
@@ -678,7 +678,7 @@ public static long hash(byte[] buf, int off, int len, long seed) {
         if (len < 0) {
             throw new IllegalArgumentException("lengths must be >= 0");
         }
-        if(off<0 || off>=buf.length || off+len<0 || off+len>buf.length){
+        if(off<0 || off>buf.length || off+len<0 || off+len>buf.length){
             throw new IndexOutOfBoundsException();
         }
 
@@ -793,7 +793,7 @@ public static long hash(char[] buf, int off, int len, long seed) {
         if (len < 0) {
             throw new IllegalArgumentException("lengths must be >= 0");
         }
-        if(off<0 || off>=buf.length || off+len<0 || off+len>buf.length){
+        if(off<0 || off>buf.length || off+len<0 || off+len>buf.length){
             throw new IndexOutOfBoundsException();
         }
 

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -162,7 +162,8 @@ public LinkedNode<K,V> deserialize(DataInput in, int available) throws IOExcepti
 
         @Override
         public boolean isTrusted() {
-            return keySerializer.isTrusted() && valueSerializer.isTrusted();
+            return keySerializer.isTrusted() &&
+                    (valueSerializer==null || valueSerializer.isTrusted());
         }
     };
 

File: src/main/java/org/mapdb/Serializer.java
Patch:
@@ -1430,7 +1430,8 @@ public void serialize(DataOutput out, Class<?> value) throws IOException {
 
         @Override
         public Class<?> deserialize(DataInput in, int available) throws IOException {
-            return SerializerPojo.classForName(in.readUTF());
+            //TODO this should respect registered ClassLoaders from DBMaker.serializerRegisterClasses()
+            return SerializerPojo.DEFAULT_CLASS_LOADER.run(in.readUTF());
         }
 
         @Override

File: src/main/java/org/mapdb/SerializerBase.java
Patch:
@@ -1671,7 +1671,7 @@ protected Engine getEngine(){
 
 
     protected Class deserializeClass(DataInput is) throws IOException {
-        return SerializerPojo.classForName(is.readUTF());
+        return SerializerPojo.DEFAULT_CLASS_LOADER.run(is.readUTF());
     }
 
 

File: src/main/java/org/mapdb/Volume.java
Patch:
@@ -809,7 +809,7 @@ protected static boolean unmap(MappedByteBuffer b){
         static{
             try{
                 unmapHackSupported =
-                        SerializerPojo.classForName("sun.nio.ch.DirectBuffer")!=null;
+                        SerializerPojo.DEFAULT_CLASS_LOADER.run("sun.nio.ch.DirectBuffer")!=null;
             }catch(Exception e){
                 unmapHackSupported = false;
             }

File: src/test/java/org/mapdb/EngineTest.java
Patch:
@@ -306,6 +306,8 @@ public void large_record(){
         long recid = e.put("aaa", Serializer.STRING);
         e.delete(recid, Serializer.STRING);
         assertNull(e.get(recid, Serializer.ILLEGAL_ACCESS));
+        e.commit();
+        reopen();
         long recid2 = e.put("bbb", Serializer.STRING);
         if(e instanceof StoreHeap || e instanceof StoreAppend)
             return; //TODO implement it at those two

File: src/main/java/org/mapdb/StoreCached.java
Patch:
@@ -47,14 +47,14 @@ public StoreCached(
             ScheduledExecutorService executor,
             long startSize,
             long sizeIncrement,
-            boolean recidReuse,
+            boolean recidReuseDisable,
             long executorScheduledRate,
             final int writeQueueSize) {
         super(fileName, volumeFactory, cache,
                 lockScale,
                 lockingStrategy,
                 checksum, compress, password, readonly, snapshotEnable, fileLockDisable, fileLockHeartbeat,
-                executor,startSize, sizeIncrement, recidReuse);
+                executor,startSize, sizeIncrement, recidReuseDisable);
 
         this.writeQueueSize = writeQueueSize;
         this.writeQueueSizePerSegment = writeQueueSize/lockScale;

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -130,7 +130,7 @@ public StoreWAL(
             ScheduledExecutorService executor,
             long startSize,
             long sizeIncrement,
-            boolean recidReuse,
+            boolean recidReuseDisable,
             long executorScheduledRate,
             int writeQueueSize
         ) {
@@ -141,7 +141,7 @@ public StoreWAL(
                 executor,
                 startSize,
                 sizeIncrement,
-                recidReuse,
+                recidReuseDisable,
                 executorScheduledRate,
                 writeQueueSize);
         prevLongLongs = new LongLongMap[this.lockScale];

File: src/test/java/org/mapdb/EngineTest.java
Patch:
@@ -307,7 +307,9 @@ public void large_record(){
         e.delete(recid, Serializer.STRING);
         assertNull(e.get(recid, Serializer.ILLEGAL_ACCESS));
         long recid2 = e.put("bbb", Serializer.STRING);
-        assertNotEquals(recid, recid2);
+        if(e instanceof StoreHeap || e instanceof StoreAppend)
+            return; //TODO implement it at those two
+        assertEquals(recid, recid2);
         e.close();
     }
 

File: src/main/java/org/mapdb/Atomic.java
Patch:
@@ -721,7 +721,7 @@ public Var(Engine engine, long recid, Serializer<E> serializer) {
             this.serializer = serializer;
         }
 
-        /** used for deserialization */
+        /* used for deserialization */
         protected Var(Engine engine, SerializerBase serializerBase, DataInput is, SerializerBase.FastArrayList<Object> objectStack) throws IOException {
             objectStack.add(this);
             this.engine = engine;

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -163,7 +163,7 @@ public class BTreeMap<K,V>
     protected final boolean closeEngine;
 
 
-    /** hack used for DB Catalog*/
+    /* hack used for DB Catalog*/
     protected static SortedMap<String, Object> preinitCatalog(DB db) {
 
         Long rootRef = db.getEngine().get(Engine.RECID_NAME_CATALOG, Serializer.RECID);
@@ -937,7 +937,7 @@ public BTreeMap(
         leftEdges = Collections.synchronizedList(leftEdges2);
     }
 
-    /** creates empty root node and returns recid of its reference*/
+    /* creates empty root node and returns recid of its reference*/
     static protected long createRootRef(Engine engine, BTreeKeySerializer keySer, Serializer valueSer, int numberOfNodeMetas){
         Object emptyArray = valueSer!=null?
                 valueSer.valueArrayEmpty():
@@ -3483,7 +3483,7 @@ private static void printRecur(BTreeMap m, long recid, String s) {
 
 
 
-    /** expand array size by 1, and put value at given position. No items from original array are lost*/
+    /* expand array size by 1, and put value at given position. No items from original array are lost*/
     protected static Object[] arrayPut(final Object[] array, final int pos, final Object value){
         final Object[] ret = Arrays.copyOf(array, array.length+1);
         if(pos<array.length){

File: src/main/java/org/mapdb/Bind.java
Patch:
@@ -127,7 +127,8 @@ public interface MapWithModificationListener<K,V> extends ConcurrentMap<K,V> {
      * {@link DB#hashMapCreate(String)} and
      * {@link DB#treeMapCreate(String)}
      *
-     *
+     * @param <K> type of key in map
+     * @param <V> type of value in map
      * @param map primary map whose size needs to be tracked
      * @param sizeCounter number updated when Map Entry is added or removed.
      */

File: src/main/java/org/mapdb/DBMaker.java
Patch:
@@ -166,7 +166,7 @@ public static Maker newMemoryDB(){
      * <p>
      * Creates new in-memory database. Changes are lost after JVM exits.
      * </p><p>
-     * This will use {@code DirectByteBuffer{} outside of HEAP, so Garbage Collector is not affected
+     * This will use {@code DirectByteBuffer} outside of HEAP, so Garbage Collector is not affected
      * You should increase ammount of direct memory with
      * {@code -XX:MaxDirectMemorySize=10G} JVM param
      * </p>

File: src/main/java/org/mapdb/Serializer.java
Patch:
@@ -2030,6 +2030,8 @@ public boolean isTrusted() {
      *
      * @param out ObjectOutput to save object into
      * @param value Object to serialize
+     *
+     * @throws java.io.IOException in case of IO error
      */
     abstract public void serialize(DataOutput out, A value)
             throws IOException;
@@ -2041,7 +2043,7 @@ abstract public void serialize(DataOutput out, A value)
      * @param in to read serialized data from
      * @param available how many bytes are available in DataInput for reading, may be -1 (in streams) or 0 (null).
      * @return deserialized object
-     * @throws java.io.IOException
+     * @throws java.io.IOException in case of IO error
      */
     abstract public A deserialize( DataInput in, int available)
             throws IOException;

File: src/main/java/org/mapdb/StoreCached.java
Patch:
@@ -47,13 +47,14 @@ public StoreCached(
             ScheduledExecutorService executor,
             long startSize,
             long sizeIncrement,
+            boolean recidReuse,
             long executorScheduledRate,
             final int writeQueueSize) {
         super(fileName, volumeFactory, cache,
                 lockScale,
                 lockingStrategy,
                 checksum, compress, password, readonly, snapshotEnable, fileLockDisable, fileLockHeartbeat,
-                executor,startSize, sizeIncrement);
+                executor,startSize, sizeIncrement, recidReuse);
 
         this.writeQueueSize = writeQueueSize;
         this.writeQueueSizePerSegment = writeQueueSize/lockScale;
@@ -101,7 +102,7 @@ public StoreCached(String fileName) {
                 CC.DEFAULT_LOCK_SCALE,
                 0,
                 false, false, null, false, false, false, null,
-                null, 0L, 0L, 0L, 0);
+                null, 0L, 0L, false, 0L, 0);
     }
 
 

File: src/test/java/examples/CacheOffHeapAdvanced.java
Patch:
@@ -24,7 +24,9 @@ public static void main(String[] args) {
         //first create store
         DB db = DBMaker
                 .memoryDirectDB()
+            // make it faster
                 .transactionDisable()
+                .allocateRecidReuseEnable()
             //some additional options for DB
                // .asyncWriteEnable()
                // .cacheSize(100000)

File: src/test/java/org/mapdb/StoreCacheHashTableTest.java
Patch:
@@ -22,7 +22,8 @@ public class StoreCacheHashTableTest<E extends StoreDirect> extends EngineTest<E
                 null,
                 null,
                 0L,
-                0L
+                0L,
+                false
                 );
         e.init();
         return (E)e;

File: src/test/java/org/mapdb/StoreCachedTest.java
Patch:
@@ -68,6 +68,7 @@ public void flush_write_cache(){
                     E,
                     0L,
                     0L,
+                    false,
                     1024,
                     M
             );

File: src/test/java/org/mapdb/StoreDirectTest.java
Patch:
@@ -761,7 +761,7 @@ public Volume makeVolume(String file, boolean readOnly, boolean fileLockDisable,
                     0,
                     false,false,null,
                     false,false,false,null,
-                    null, 0L, 0L);
+                    null, 0L, 0L, false);
             e.init();
 
             //fill with some data

File: src/test/java/org/mapdb/StoreDirectTest2.java
Patch:
@@ -72,7 +72,7 @@ protected StoreDirect newStore() {
         File f = TT.tempDbFile();
 
         StoreDirect st = new StoreDirect(f.getPath(), CC.DEFAULT_FILE_VOLUME_FACTORY,
-                null, CC.DEFAULT_LOCK_SCALE, 0, false, false,null, false,false, false, null, null, 0L, 0L);
+                null, CC.DEFAULT_LOCK_SCALE, 0, false, false,null, false,false, false, null, null, 0L, 0L, false);
         st.init();
 
         Map<Long,String> recids = new HashMap();
@@ -86,7 +86,7 @@ protected StoreDirect newStore() {
         st.close();
 
         st = new StoreDirect(f.getPath(), CC.DEFAULT_FILE_VOLUME_FACTORY,
-                null, CC.DEFAULT_LOCK_SCALE, 0, false, false,null, false, false, false, null, null, 0L, 0L);
+                null, CC.DEFAULT_LOCK_SCALE, 0, false, false,null, false, false, false, null, null, 0L, 0L, false);
         st.init();
 
         for(Map.Entry<Long,String> e:recids.entrySet()){

File: src/test/java/org/mapdb/StoreDirectTest.java
Patch:
@@ -253,7 +253,8 @@ public void deleteFile(){
         }
 
         //second list should be reverse of first, as Linked Offset List is LIFO
-        Collections.reverse(recids);
+        Collections.sort(recids);
+        Collections.sort(recids);
         assertEquals(recids, recids2);
     }
 //

File: src/test/java/examples/CacheOffHeap.java
Patch:
@@ -54,7 +54,7 @@ public static void main(String[] args) {
 
         }
 
-        // and release memory. Only necessary with `DBMaker.newCacheDirect()`
+        // and release memory. Only necessary with `DBMaker.memoryDirect()`
         cache.close();
 
     }

File: src/main/java/org/mapdb/Volume.java
Patch:
@@ -914,7 +914,7 @@ public final void ensureAvailable(long offset) {
 
                 // fill with zeroes from  old size to new size
                 // this will prevent file from growing via mmap operation
-                RandomAccessFileVol.clearRAF(raf, oldSize*sliceSize, offset);
+                RandomAccessFileVol.clearRAF(raf, 1L*oldSize*sliceSize, offset);
                 raf.getFD().sync();
 
                 //grow slices

File: src/test/java/org/mapdb/CrashTest.java
Patch:
@@ -174,6 +174,8 @@ public void test() throws IOException, InterruptedException {
                 assertTrue(dbSeed.get()==getSeed(seedStartDir, 0) || dbSeed.get()==getSeed(seedStartDir, 1));
             }
 
+            if(dbSeed.get()!=oldSeed)
+                commitCount++;
 
             Map<Long,byte[]> m = map(p,db);
             //check content of map

File: src/test/java/org/mapdb/CrashWithInterruptTest.java
Patch:
@@ -48,7 +48,7 @@ public static Iterable params() throws IOException {
                         for (boolean largeVals : BOOLS) {
                             for (boolean clearMap : BOOLS) {
                                 for (boolean hashMap : BOOLS) {
-                                    File f = File.createTempFile("mapdb", "mapdb");
+                                    File f = File.createTempFile("mapdbTest", "mapdb");
                                     DBMaker.Maker maker = !notAppend ?
                                             DBMaker.appendFileDB(f) :
                                             DBMaker.fileDB(f);

File: src/test/java/org/mapdb/CrashWithJVMKillTest.java
Patch:
@@ -27,7 +27,7 @@ public void test() throws IOException, InterruptedException {
         long end = System.currentTimeMillis()+1000*60*10*UtilsTest.scale();
 
         String tmpDir = System.getProperty("java.io.tmpdir");
-        String wal = tmpDir+"/mapdb"+Math.random();
+        String wal = tmpDir+"/mapdbTest"+Math.random();
         String props = wal+"props";
         while(end>System.currentTimeMillis()) {
             ProcessBuilder b = new ProcessBuilder("java",

File: src/test/java/org/mapdb/DBHeaderTest.java
Patch:
@@ -37,7 +37,7 @@ DBMaker.Maker maker() {
     File file;
     {
         try {
-            file = File.createTempFile("mapdb","mapdb");
+            file = File.createTempFile("mapdbTest","mapdb");
         } catch (IOException e) {
             throw new RuntimeException(e);
         }

File: src/test/java/org/mapdb/HTreeMap2Test.java
Patch:
@@ -1123,7 +1123,7 @@ public void expiration_overflow() throws InterruptedException {
             return;
         final long endTime = System.currentTimeMillis()+time;
 
-        File f = File.createTempFile("mapdb","mapdb");
+        File f = File.createTempFile("mapdbTest","mapdb");
         //TODO mutate to include other types of engines
         final DB db = DBMaker.fileDB(f).transactionDisable().deleteFilesAfterClose().make();
 

File: src/test/java/org/mapdb/HeartbeatFileLockTest.java
Patch:
@@ -20,7 +20,7 @@ public void testFutureModificationDate() throws Exception {
         if(UtilsTest.scale()==0)
             return;
 
-        File f = File.createTempFile("mapdb","madpb");
+        File f = File.createTempFile("mapdbTest","madpb");
         f.delete();
         f.createNewFile();
         f.setLastModified(System.currentTimeMillis() + 10000);
@@ -33,7 +33,7 @@ public void testFutureModificationDate() throws Exception {
     public void testSimple() throws IOException {
         if(UtilsTest.scale()==0)
             return;
-        File f = File.createTempFile("mapdb","madpb");
+        File f = File.createTempFile("mapdbTest","madpb");
         f.delete();
 
         DataIO.HeartbeatFileLock lock1 = new DataIO.HeartbeatFileLock(f,CC.FILE_LOCK_HEARTBEAT);
@@ -63,7 +63,7 @@ public void test_parallel() throws InterruptedException, IOException, ExecutionE
         if(count==0)
             return;
 
-        final File f = File.createTempFile("mapdb","mapdb");
+        final File f = File.createTempFile("mapdbTest","mapdb");
         f.delete();
 
         final AtomicInteger counter = new AtomicInteger();

File: src/test/java/org/mapdb/Issue266Test.java
Patch:
@@ -40,7 +40,7 @@ public class Issue266Test {
     @Test
     public void testEnum() throws IOException {
 
-        File f = File.createTempFile("mapdb","asdas");
+        File f = File.createTempFile("mapdbTest","asdas");
         DB db = DBMaker.fileDB(f).make();
 
         AdvancedEnum testEnumValue = AdvancedEnum.C;

File: src/test/java/org/mapdb/Issue312Test.java
Patch:
@@ -13,7 +13,7 @@ public void test() throws IOException{
         if(UtilsTest.scale()==0)
             return;
 
-        File f = File.createTempFile("mapdb","test");
+        File f = File.createTempFile("mapdbTest","test");
         DB db = DBMaker.fileDB(f)
                 .mmapFileEnableIfSupported()
                 .transactionDisable()

File: src/test/java/org/mapdb/Issue332Test.java
Patch:
@@ -66,7 +66,7 @@ public int fixedSize() {
 
     @Test
     public void run() throws IOException {
-        File f = File.createTempFile("mapdb","mapdb");
+        File f = File.createTempFile("mapdbTest","mapdb");
         DB db = DBMaker.fileDB(f)
                 .closeOnJvmShutdown()
                 .make();

File: src/test/java/org/mapdb/Issue523Test.java
Patch:
@@ -13,7 +13,7 @@ public class Issue523Test {
 
     @Test
     public void  MapDbReadOnlyTest() throws IOException {
-        File dbFile = File.createTempFile("mapdb","mapdb");
+        File dbFile = File.createTempFile("mapdbTest","mapdb");
         testCreate(dbFile);
         testRead(dbFile);
     }

File: src/test/java/org/mapdb/QueuesTest.java
Patch:
@@ -100,7 +100,7 @@ public void testMapDb() throws InterruptedException {
 
     @Test(timeout=100000)
     public void queueTakeRollback() throws IOException, InterruptedException {
-        File f = File.createTempFile("mapdb","aa");
+        File f = File.createTempFile("mapdbTest","aa");
         {
             DB db = DBMaker.fileDB(f).make();
             boolean newQueue = !db.exists("test");

File: src/test/java/org/mapdb/SerializerPojoTest.java
Patch:
@@ -463,7 +463,7 @@ public void testWriteReplace() throws ObjectStreamException {
 
     @Test
     public void testWriteReplace2() throws IOException {
-        File f = File.createTempFile("mapdb","mapdb");
+        File f = File.createTempFile("mapdbTest","mapdb");
         Map m = new MM();
         m.put("11", "111");
         DB db = DBMaker.fileDB(f).transactionDisable().make();
@@ -487,7 +487,7 @@ public void testWriteReplaceWrap() throws ObjectStreamException {
 
     @Test
     public void testWriteReplace2Wrap() throws IOException {
-        File f = File.createTempFile("mapdb", "mapdb");
+        File f = File.createTempFile("mapdbTest", "mapdb");
         SS m = new SS(new MM());
         m.mm.put("11", "111");
         DB db = DBMaker.fileDB(f).transactionDisable().make();

File: src/test/java/org/mapdb/SerializerTest.java
Patch:
@@ -206,7 +206,7 @@ public StringS deserialize(DataInput in, int available) throws IOException {
         }
     }
     @Test public void issue546() throws IOException {
-        File f = File.createTempFile("mapdb","mapdb");
+        File f = File.createTempFile("mapdbTest","mapdb");
         DB db = DBMaker
                 .fileDB(f)
                 .transactionDisable()

File: src/test/java/org/mapdb/StoreDirectTest2.java
Patch:
@@ -241,7 +241,7 @@ DataOutputByteArray newBuf(int size){
     }
 
     @Test public void zero_index_page_checksum() throws IOException {
-        File f = File.createTempFile("mapdb", "mapdb");
+        File f = File.createTempFile("mapdbTest", "mapdb");
         StoreDirect st = (StoreDirect) DBMaker.fileDB(f)
                 .transactionDisable()
                 .checksumEnable()

File: src/test/java/org/mapdb/UtilsTest.java
Patch:
@@ -152,7 +152,7 @@ public int fixedSize() {
      */
     public static File tempDbFile() {
         try{
-            File index = File.createTempFile("mapdb","db");
+            File index = File.createTempFile("mapdbTest","db");
             index.deleteOnExit();
 
             return index;

File: src/test/java/org/mapdb/VolumeTest.java
Patch:
@@ -176,7 +176,6 @@ void putGetOverlap(Volume vol, long offset, int size) throws IOException {
             vol.getDataInputOverlap(offset, size).readFully(b2, 0, size);
 
             assertTrue(Serializer.BYTE_ARRAY.equals(b, b2));
-            vol.close();
         }
 
 
@@ -200,7 +199,6 @@ void putGetOverlapUnalligned(Volume vol) throws IOException {
             for (int i = 0; i < size; i++) {
                 assertEquals(b2[i + 1000], b3[i + 100]);
             }
-            vol.close();
         }
     }
 

File: src/test/java/org/mapdb/CrashWithJVMKillTest.java
Patch:
@@ -34,9 +34,7 @@ public void test() throws IOException, InterruptedException {
                     this.getClass().getName(),
                     tmpDir+"/mapdb"+Math.random(), tmpDir+"/mapdb"+Math.random());
             Process p = b.start();
-            while (p.isAlive()) {
-                Thread.sleep(1);
-            }
+            p.waitFor();
             String out = outStreamToString(p.getInputStream());
             assertTrue(out.startsWith("started_"));
             assertTrue(out.endsWith("_killed"));

File: src/main/java/org/mapdb/StoreAppend.java
Patch:
@@ -323,7 +323,9 @@ protected <A> A get2(long recid, Serializer<A> serializer) {
         if(CC.ASSERT)
             assertReadLocked(recid);
 
-        long offset = modified[lockPos(recid)].get(recid);
+        long offset = tx?
+                modified[lockPos(recid)].get(recid):
+                0;
         if(offset==0) {
             try {
                 offset = indexTable.getLong(recid * 8);

File: src/test/java/org/mapdb/EngineTest.java
Patch:
@@ -711,7 +711,7 @@ public void run() {
                     try {
                         for (; ; ) {
                             long A = a.incrementAndGet();
-                            Random r = new Random();
+                            Random r = new Random(A);
                             e.update(counterRecid, A, Serializer.LONG);
 
                             for (long recid : recids) {
@@ -727,7 +727,7 @@ public void run() {
                 }
             };
             t.start();
-            t.sleep(5000);
+            Thread.sleep(5000);
             t.stop();
             latch.await();
             if(!e.isClosed()){

File: src/main/java/org/mapdb/StoreCached.java
Patch:
@@ -42,6 +42,7 @@ public StoreCached(
             byte[] password,
             boolean readonly,
             boolean snapshotEnable,
+            boolean fileLockDisable,
             int freeSpaceReclaimQ,
             boolean commitFileSyncDisable,
             int sizeIncrement,
@@ -51,7 +52,7 @@ public StoreCached(
         super(fileName, volumeFactory, cache,
                 lockScale,
                 lockingStrategy,
-                checksum, compress, password, readonly, snapshotEnable,
+                checksum, compress, password, readonly, snapshotEnable, fileLockDisable,
                 freeSpaceReclaimQ, commitFileSyncDisable, sizeIncrement,executor);
 
         this.writeQueueSize = writeQueueSize;
@@ -99,7 +100,7 @@ public StoreCached(String fileName) {
                 null,
                 CC.DEFAULT_LOCK_SCALE,
                 0,
-                false, false, null, false, false, 0,
+                false, false, null, false, false, false, 0,
                 false, 0,
                 null, 0L, 0);
     }

File: src/main/java/org/mapdb/StoreHeap.java
Patch:
@@ -26,7 +26,7 @@ public class StoreHeap extends Store{
 
 
     public StoreHeap(boolean txDisabled, int lockScale, int lockingStrategy, boolean snapshotEnable){
-        super(null,null,null,lockScale, 0, false,false,null,false, snapshotEnable);
+        super(null,null,null,lockScale, 0, false,false,null,false,false, snapshotEnable);
         data = new LongObjectMap[this.lockScale];
         for(int i=0;i<data.length;i++){
             data[i] = new LongObjectMap();

File: src/test/java/org/mapdb/BrokenDBTest.java
Patch:
@@ -61,7 +61,7 @@ public void canDeleteDBOnBrokenLog() throws IOException {
         DBMaker.fileDB(index).make().close();
 
         // corrupt file
-        MappedFileVol physVol = new Volume.MappedFileVol(index, false, CC.VOLUME_PAGE_SHIFT,false);
+        MappedFileVol physVol = new Volume.MappedFileVol(index, false, false, CC.VOLUME_PAGE_SHIFT,false);
         physVol.ensureAvailable(32);
         //TODO corrupt file somehow
 //        physVol.putInt(0, StoreDirect.HEADER);

File: src/test/java/org/mapdb/DBHeaderTest.java
Patch:
@@ -47,7 +47,7 @@ DBMaker.Maker maker() {
 
 
     public long getBitField() {
-        Volume v = new Volume.RandomAccessFileVol(file,true);
+        Volume v = new Volume.RandomAccessFileVol(file,true,false);
         long ret = v.getLong(8);
         v.close();
         return ret;
@@ -172,7 +172,7 @@ public void crc32_(){
         db.close();
 
         //fake bitfield
-        Volume r = new Volume.RandomAccessFileVol(file,false);
+        Volume r = new Volume.RandomAccessFileVol(file,false,false);
         r.putLong(8, 2L << 32);
         r.sync();
         r.close();

File: src/test/java/org/mapdb/StoreAppendTest.java
Patch:
@@ -23,6 +23,7 @@ protected StoreAppend openEngine() {
                     false,
                     false,
                     false,
+                    false,
                     null
             );
             s.init();

File: src/test/java/org/mapdb/StoreCacheHashTableTest.java
Patch:
@@ -20,6 +20,7 @@ public class StoreCacheHashTableTest<E extends StoreDirect> extends EngineTest<E
                 null,
                 false,
                 false,
+                false,
                 0,
                 false,
                 0,

File: src/test/java/org/mapdb/StoreCachedTest.java
Patch:
@@ -66,6 +66,7 @@ public void flush_write_cache(){
                     null,
                     false,
                     false,
+                    false,
                     0,
                     false,
                     0,

File: src/test/java/org/mapdb/StoreDirectTest.java
Patch:
@@ -743,7 +743,7 @@ protected void clearEverything(){
         for(final Fun.Function1<Volume,String> fab : VolumeTest.VOL_FABS){
             Volume.VolumeFactory fac = new Volume.VolumeFactory() {
                 @Override
-                public Volume makeVolume(String file, boolean readOnly, int sliceShift, long initSize, boolean fixedSize) {
+                public Volume makeVolume(String file, boolean readOnly, boolean fileLockDisable, int sliceShift, long initSize, boolean fixedSize) {
                     return fab.run(file);
                 }
             };
@@ -754,7 +754,7 @@ public Volume makeVolume(String file, boolean readOnly, int sliceShift, long ini
                     CC.DEFAULT_LOCK_SCALE,
                     0,
                     false,false,null,
-                    false,false,0,
+                    false,false,false,0,
                     false,0,
                     null);
             e.init();

File: src/test/java/org/mapdb/StoreDirectTest2.java
Patch:
@@ -70,11 +70,11 @@ protected StoreDirect newStore() {
 
         Volume.VolumeFactory fab = new Volume.VolumeFactory() {
             @Override
-            public Volume makeVolume(String file, boolean readOnly, int sliceShift, long initSize, boolean fixedSize) {
+            public Volume makeVolume(String file, boolean readOnly, boolean fileLockDisable, int sliceShift, long initSize, boolean fixedSize) {
                 return vol;
             }
         };
-        StoreDirect st = new StoreDirect(null, fab, null, CC.DEFAULT_LOCK_SCALE, 0, false, false,null, false,false,  0,false,0, null);
+        StoreDirect st = new StoreDirect(null, fab, null, CC.DEFAULT_LOCK_SCALE, 0, false, false,null, false,false, false, 0,false,0, null);
         st.init();
 
         Map<Long,String> recids = new HashMap();
@@ -87,7 +87,7 @@ public Volume makeVolume(String file, boolean readOnly, int sliceShift, long ini
         //close would destroy Volume,so this will do
         st.commit();
 
-        st = new StoreDirect(null, fab, null, CC.DEFAULT_LOCK_SCALE, 0, false, false,null, false, false, 0,false,0, null);
+        st = new StoreDirect(null, fab, null, CC.DEFAULT_LOCK_SCALE, 0, false, false,null, false, false, false, 0,false,0, null);
         st.init();
 
         for(Map.Entry<Long,String> e:recids.entrySet()){

File: src/main/java/org/mapdb/Volume.java
Patch:
@@ -846,11 +846,11 @@ private static Volume factory(String file, boolean readOnly, int sliceShift, boo
             if(readOnly){
                 long flen = f.length();
                 if(flen <= Integer.MAX_VALUE) {
-                    return new MappedFileVolSingle(f, readOnly, flen, false);
+                    return new MappedFileVolSingle(f, readOnly, flen, cleanerHackEnabled);
                 }
             }
             //TODO prealocate initsize
-            return new MappedFileVol(f,readOnly,sliceShift,false);
+            return new MappedFileVol(f,readOnly,sliceShift,cleanerHackEnabled);
         }
 
 

File: src/test/java/org/mapdb/EngineTest.java
Patch:
@@ -669,7 +669,7 @@ public Object call() throws Exception {
         if(scale==0)
             return;
         e = openEngine();
-        if(!e.canRollback()) //TODO engine might have crash recovery, but no rollbacks
+        if(!e.canRollback() || e instanceof StoreHeap) //TODO engine might have crash recovery, but no rollbacks
             return;
 
         final long counterRecid = e.put(0L, Serializer.LONG);
@@ -679,6 +679,7 @@ public Object call() throws Exception {
         final ArrayList<Long> recids = new ArrayList<Long>();
         for(int j=0;j<max;j++){
             long recid = e.put(new byte[0],Serializer.BYTE_ARRAY_NOSIZE);
+            recids.add(recid);
         }
 
         final AtomicLong a = new AtomicLong(10);

File: src/test/java/org/mapdb/StoreDirectTest.java
Patch:
@@ -417,6 +417,7 @@ protected List<Long> getLongStack(long masterLinkOffset) {
         for(long i =max-1;i>=1;i--){
             assertEquals(i, e.longStackTake(FREE_RECID_STACK,false));
         }
+        e.structuralLock.unlock();
     }
 
 

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -486,7 +486,7 @@ public <A> long put(A value, Serializer<A> serializer) {
         long[] offsets;
         DataOutputByteArray out = serialize(value,serializer);
         boolean notalloc = out==null || out.pos==0;
-        final int posHigher = new Random().nextInt(locks.length+1);
+        final int posHigher = new Random().nextInt(locks.length);
 
         final Lock lockHigher = locks[posHigher].writeLock();
         lockHigher.lock();

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -486,7 +486,7 @@ public <A> long put(A value, Serializer<A> serializer) {
         long[] offsets;
         DataOutputByteArray out = serialize(value,serializer);
         boolean notalloc = out==null || out.pos==0;
-        final int posHigher = new Random().nextInt(lockMask);
+        final int posHigher = new Random().nextInt(locks.length+1);
 
         final Lock lockHigher = locks[posHigher].writeLock();
         lockHigher.lock();

File: src/main/java/org/mapdb/DBException.java
Patch:
@@ -20,7 +20,7 @@ public DBException(String message, Throwable cause) {
     }
 
     public DBException() {
-
+        super();
     }
 
 

File: src/main/java/org/mapdb/Serializer.java
Patch:
@@ -1042,7 +1042,7 @@ public void serialize(DataOutput out, Object value) throws IOException {
         @Override
         public Object deserialize(DataInput in, int available) throws IOException {
             try {
-                ObjectInputStream in2 = new ObjectInputStream((InputStream) in);
+                ObjectInputStream in2 = new ObjectInputStream(new DataIO.DataInputToStream(in));
                 return in2.readObject();
             } catch (ClassNotFoundException e) {
                 throw new IOException(e);

File: src/main/java/org/mapdb/DB.java
Patch:
@@ -2143,7 +2143,7 @@ synchronized public <E> E get(String name){
         if("Queue".equals(type)) return (E) getQueue(name);
         if("Stack".equals(type)) return (E) getStack(name);
         if("CircularQueue".equals(type)) return (E) getCircularQueue(name);
-        throw new AssertionError("Unknown type: "+name);
+        throw new DBException.DataCorruption("Unknown type: "+name);
     }
 
     synchronized public boolean exists(String name){

File: src/main/java/org/mapdb/Serializer.java
Patch:
@@ -1533,7 +1533,7 @@ public E deserialize(DataInput in, int available) throws IOException {
             DataIO.DataInputByteArray in2 = new DataIO.DataInputByteArray(unpacked);
             E ret =  serializer.deserialize(in2,unpackedSize);
             if(CC.ASSERT && ! (in2.pos==unpackedSize))
-                throw new AssertionError( "data were not fully read");
+                throw new DBException.DataCorruption( "data were not fully read");
             return ret;
         }
 

File: src/main/java/org/mapdb/SerializerBase.java
Patch:
@@ -1751,11 +1751,11 @@ private Properties deserializeProperties(DataInput is, FastArrayList<Object> obj
 
     /** override this method to extend SerializerBase functionality*/
     protected void serializeUnknownObject(DataOutput out, Object obj, FastArrayList<Object> objectStack) throws IOException {
-        throw new AssertionError("Could not serialize unknown object: "+obj.getClass().getName());
+        throw new NotSerializableException("Could not serialize unknown object: "+obj.getClass().getName());
     }
     /** override this method to extend SerializerBase functionality*/
     protected Object deserializeUnknownHeader(DataInput is, int head, FastArrayList<Object> objectStack) throws IOException {
-        throw new AssertionError("Unknown serialization header: " + head);
+        throw new DBException.DataCorruption("Unknown serialization header: " + head);
     }
 
     /**

File: src/main/java/org/mapdb/SerializerPojo.java
Patch:
@@ -497,12 +497,13 @@ protected Object deserializeUnknownHeader(DataInput in, int head, FastArrayList<
             String name = in.readUTF();
             Object o = getNamedObject.run(name);
             if(o==null)
-                throw new AssertionError("Named object was not found: "+name);
+                throw new DBException.DataCorruption("Named object was not found: "+name);
             objectStack.add(o);
             return o;
         }
 
-        if(head!= Header.POJO) throw new AssertionError();
+        if(head!= Header.POJO)
+            throw new DBException.DataCorruption("wrong header");
         try{
             int classId = DataIO.unpackInt(in);
             ClassInfo classInfo = getClassInfo.run(classId);

File: src/test/java/org/mapdb/PumpTest.java
Patch:
@@ -502,15 +502,15 @@ class Source implements Iterator<Fun.Pair<Integer, String>> {
 
             @Override public boolean hasNext()
             {
-                mapIndex--;
+
                 return counter <= 16737175;
             }
 
             @Override
             public Fun.Pair<Integer, String> next()
             {
                 counter++;
-
+                mapIndex--;
                 return new Fun.Pair(mapIndex, "foobar"+mapIndex);
             }
 

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -1870,7 +1870,8 @@ public K firstKey() {
         LeafNode l = (LeafNode) n;
         //follow link until necessary
         while(l.keysLen(keySerializer)==2){
-            if(l.next==0) return null;
+            if(l.next==0)
+                throw new NoSuchElementException();
             //$DELAY$
             l = (LeafNode) engine.get(l.next, nodeSerializer);
         }

File: src/main/java/org/mapdb/Fun.java
Patch:
@@ -48,7 +48,7 @@ public static <T> Comparator<T> comparator(){
 	/**
 	 * A utility method for getting a type-safe reversed Comparator (the negation of {@link Fun#comparator()}).
 	 * Use this method instead of {@link Fun#REVERSE_COMPARATOR} in order to insure type-safety
-	 * ex: Comparator<Integer> comparator = getReversedComparator();
+	 * ex: {@code Comparator<Integer> comparator = getReversedComparator();}
 	 * @return comparator
 	 */
 	public static <T> Comparator<T> reverseComparator(){

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -844,7 +844,7 @@ public void commit() {
                 long finalOffset = walOffset.get();
                 curVol.ensureAvailable(finalOffset + 1); //TODO overlap here
                 //put EOF instruction
-                curVol.putUnsignedByte(finalOffset, (0 << 4) | (Long.bitCount(finalOffset)));
+                curVol.putUnsignedByte(finalOffset, (0 << 4) | (Long.bitCount(finalOffset)&15));
                 curVol.sync();
                 //put wal seal
                 curVol.putLong(8, WAL_SEAL);
@@ -945,7 +945,7 @@ protected void commitFullWALReplay() {
                 long finalOffset = walOffset.get();
                 curVol.ensureAvailable(finalOffset+1); //TODO overlap here
                 //put EOF instruction
-                curVol.putUnsignedByte(finalOffset, (0<<4) | (Long.bitCount(finalOffset)));
+                curVol.putUnsignedByte(finalOffset, (0<<4) | (Long.bitCount(finalOffset)&15));
                 curVol.sync();
                 //put wal seal
                 curVol.putLong(8, WAL_SEAL);

File: src/main/java/org/mapdb/StoreHeap.java
Patch:
@@ -312,7 +312,7 @@ public void compact() {
                             }
 
                             //put into list of free recids
-                            m.remove(m.set[i]);
+                            m.remove(m.set[j]);
 
                             if(freeRecid.length==freeRecidTail){
                                 freeRecid = Arrays.copyOf(freeRecid, freeRecid.length*2);

File: src/main/java/org/mapdb/DataIO.java
Patch:
@@ -1078,12 +1078,12 @@ public static long parity4Get(long i) {
     public static long parity16Set(long i) {
         if(CC.ASSERT && (i&0xFFFF)!=0)
             throw new DBException.PointerChecksumBroken();
-        return i | (Long.hashCode(i)&0xFFFFL);
+        return i | (DataIO.longHash(i)&0xFFFFL);
     }
 
     public static long parity16Get(long i) {
         long ret = i&0xFFFFFFFFFFFF0000L;
-        if((Long.hashCode(ret)&0xFFFFL) != (i&0xFFFFL)){
+        if((DataIO.longHash(ret)&0xFFFFL) != (i&0xFFFFL)){
             throw new DBException.PointerChecksumBroken();
         }
         return ret;

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -1343,7 +1343,7 @@ public void compact() {
                 commitLock.unlock();
             }
 
-            final long maxRecidOffset = parity3Get(headVol.getLong(MAX_RECID_OFFSET));
+            final long maxRecidOffset = parity1Get(headVol.getLong(MAX_RECID_OFFSET));
 
             //open target file
             final String targetFile = getWalFileName("c.compact");
@@ -1366,7 +1366,7 @@ public void compact() {
             }
 
 
-            target.vol.putLong(MAX_RECID_OFFSET, parity3Set(maxRecid.get() * 8));
+            target.vol.putLong(MAX_RECID_OFFSET, parity1Set(maxRecid.get() * indexValSize));
 
             //compaction finished fine, so now flush target file, and seal log file. This makes compaction durable
             target.commit(); //sync all files, that is durable since there are no background tasks

File: src/test/java/org/mapdb/StoreDirectTest2.java
Patch:
@@ -24,7 +24,7 @@ public class StoreDirectTest2 {
         assertEquals(st.headChecksum(st.vol), st.vol.getInt(StoreDirect.HEAD_CHECKSUM));
         assertEquals(parity16Set(st.PAGE_SIZE), st.vol.getLong(StoreDirect.STORE_SIZE));
         assertEquals(parity16Set(0), st.vol.getLong(StoreDirect.HEAD_END)); //pointer to next page
-        assertEquals(parity3Set(st.RECID_LAST_RESERVED * 8), st.vol.getLong(StoreDirect.MAX_RECID_OFFSET));
+        assertEquals(parity1Set(st.RECID_LAST_RESERVED * 8), st.vol.getLong(StoreDirect.MAX_RECID_OFFSET));
     }
 
     @Test public void constants(){
@@ -36,7 +36,7 @@ public class StoreDirectTest2 {
         long recid = st.preallocate();
         assertEquals(Engine.RECID_FIRST,recid);
         assertEquals(st.composeIndexVal(0,0,true,true,true),st.vol.getLong(st.recidToOffset(recid)));
-        assertEquals(parity3Set(8 * Engine.RECID_FIRST), st.vol.getLong(st.MAX_RECID_OFFSET));
+        assertEquals(parity1Set(8 * Engine.RECID_FIRST), st.vol.getLong(st.MAX_RECID_OFFSET));
     }
 
 
@@ -46,7 +46,7 @@ public class StoreDirectTest2 {
             long recid = st.preallocate();
             assertEquals(Engine.RECID_FIRST+i, recid);
             assertEquals(st.composeIndexVal(0, 0, true, true, true), st.vol.getLong(st.recidToOffset(recid)));
-            assertEquals(parity3Set(8 * (Engine.RECID_FIRST + i)), st.vol.getLong(st.MAX_RECID_OFFSET));
+            assertEquals(parity1Set(8 * (Engine.RECID_FIRST + i)), st.vol.getLong(st.MAX_RECID_OFFSET));
         }
     }
 

File: src/test/java/org/mapdb/BTreeMapParTest.java
Patch:
@@ -21,7 +21,7 @@ public void parInsert() throws InterruptedException {
                 .treeMapCreate("test")
                 .valueSerializer(Serializer.LONG)
                 .keySerializer(BTreeKeySerializer.LONG)
-                .makeLongMap();
+                .make();
 
         long t = System.currentTimeMillis();
         final AtomicLong counter = new AtomicLong();

File: src/test/java/org/mapdb/HTreeMap2Test.java
Patch:
@@ -684,7 +684,7 @@ public void inconsistentHash(){
     public void test()
     {
         DB db = DBMaker.memoryDB().transactionDisable().make();
-        Map<String, Integer> map = db.hashMap("map", new Fun.Function1<Integer, String>() {
+        Map<String, Integer> map = db.hashMap("map",null,null, new Fun.Function1<Integer, String>() {
             @Override
             public Integer run(String s) {
                 return Integer.MIN_VALUE;

File: src/main/java/org/mapdb/StoreAppend.java
Patch:
@@ -410,7 +410,7 @@ public void close() {
         try {
             if(closed)
                 return;
-            closed = true;
+
             if(isSnapshot){
                 snapshots.remove(this);
                 return;
@@ -426,6 +426,7 @@ public void close() {
                 }
                 Arrays.fill(caches,null);
             }
+            closed = true;
         }finally{
             commitLock.unlock();
         }

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -783,7 +783,6 @@ public void close() {
         try {
             if(closed==true)
                 return;
-            closed = true;
             flush();
             vol.close();
             vol = null;
@@ -796,7 +795,7 @@ public void close() {
                 }
                 Arrays.fill(caches,null);
             }
-
+            closed = true;
         }finally{
             commitLock.unlock();
         }

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -1213,7 +1213,6 @@ public void close() {
                     LOG.warning("Closing storage with uncommited data, those data will be discarted.");
                 }
 
-                closed = true;
 
                 //TODO do not replay if not dirty
                 if(!readonly) {
@@ -1259,6 +1258,7 @@ public void close() {
                     }
                     Arrays.fill(caches,null);
                 }
+                closed = true;
             }finally {
                 commitLock.unlock();
             }

File: src/main/java/org/mapdb/SerializerBase.java
Patch:
@@ -1586,6 +1586,7 @@ public boolean needsObjectStack() {
             mapdb_add(68, Serializer.LONG_PACKED_ZIGZAG);
             mapdb_add(69, Serializer.INTEGER_PACKED);
             mapdb_add(70, Serializer.INTEGER_PACKED_ZIGZAG);
+            mapdb_add(71, Serializer.RECID_ARRAY);
         }
 
 

File: src/test/java/org/mapdb/Serialization2Test.java
Patch:
@@ -92,7 +92,7 @@ static class AAA implements Serializable {
         map.put(1,new AAA());
 
         db.compact();
-        System.out.println(db.getEngine().get(Engine.RECID_CLASS_CATALOG, SerializerPojo.CLASS_CATALOG_SERIALIZER));
+        System.out.println(db.getEngine().get(Engine.RECID_CLASS_CATALOG, Serializer.RECID_ARRAY));
         db.close();
 
         db = DBMaker.fileDB(f)

File: src/test/java/org/mapdb/SerializerPojoTest.java
Patch:
@@ -18,7 +18,7 @@
 @SuppressWarnings({ "unchecked", "rawtypes" })
 public class SerializerPojoTest{
 
-    SerializerPojo p = new SerializerPojo(null,null,null,null, null);
+    SerializerPojo p = new SerializerPojo(null,null,null,null, null, null);
 
     enum Order
     {

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -221,7 +221,7 @@ public int hashCode() {
 
         @Override
         public String toString() {
-            return "BTreeMap-ValRer["+recid+"]";
+            return "BTreeMap-ValRef["+recid+"]";
         }
     }
 

File: src/main/java/org/mapdb/StoreCached.java
Patch:
@@ -110,6 +110,8 @@ protected void initHeadVol() {
         if (CC.ASSERT && !structuralLock.isHeldByCurrentThread())
             throw new AssertionError();
 
+        if(this.headVol!=null && !this.headVol.isClosed())
+            headVol.close();
         this.headVol = new Volume.SingleByteArrayVol((int) HEAD_END);
         //TODO limit size
         //TODO introduce SingleByteArrayVol which uses only single byte[]

File: src/main/java/org/mapdb/UnsafeStuff.java
Patch:
@@ -343,6 +343,7 @@ public DataInput getDataInputOverlap(long offset, int size) {
 
         @Override
         public void close() {
+            closed = true;
             sun.nio.ch.DirectBuffer[] buf2 = buffers;
             buffers=null;
             addresses = null;

File: src/main/java/org/mapdb/Bind.java
Patch:
@@ -88,7 +88,7 @@ public interface MapListener<K,V>{
      * @param <K> key type  in map
      * @param <V> value type in map
      */
-    public interface MapWithModificationListener<K,V> extends Map<K,V> {
+    public interface MapWithModificationListener<K,V> extends ConcurrentMap<K,V> {
         /**
          * Add new modification listener notified when Map has been updated
          * @param listener callback interface notified when map changes

File: src/main/java/org/mapdb/SerializerBase.java
Patch:
@@ -1482,7 +1482,6 @@ protected void initMapdb(){
             mapdb_add(37, Fun.LONG_ARRAY_COMPARATOR);
             mapdb_add(38, Fun.DOUBLE_ARRAY_COMPARATOR);
             mapdb_add(39, Fun.COMPARABLE_ARRAY_COMPARATOR);
-
             mapdb_add(40, Fun.RECORD_ALWAYS_TRUE);
 
             mapdb_add(41, BTreeKeySerializer.ARRAY2);

File: src/main/java/org/mapdb/SerializerPojo.java
Patch:
@@ -536,7 +536,7 @@ protected Object deserializeUnknownHeader(DataInput in, int head, FastArrayList<
 
     static{
         try{
-            Class clazz = classForName("sun.reflect.ReflectionFactory");
+            Class<?> clazz = classForName("sun.reflect.ReflectionFactory");
             if(clazz!=null){
                 Method getReflectionFactory = clazz.getMethod("getReflectionFactory");
                 sunReflFac = getReflectionFactory.invoke(null);
@@ -691,7 +691,7 @@ protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, Clas
             if (desc == lastDescriptor) return lastDescriptorClass;
 
             ClassLoader loader = SerializerPojo.classForNameClassLoader();
-            Class clazz = Class.forName(desc.getName(), false, loader);
+            Class<?> clazz = Class.forName(desc.getName(), false, loader);
             if (clazz != null)
                 return clazz;
             return super.resolveClass(desc);

File: src/main/java/org/mapdb/TxEngine.java
Patch:
@@ -382,7 +382,7 @@ public <A> long put(A value, Serializer<A> serializer) {
             commitLock.writeLock().lock();
             try{
                 Long recid = preallocRecidTake();
-                mod.put(recid, new Fun.Pair(value,serializer));
+                mod.put(recid, new Fun.Pair<A,Serializer<A>>(value,serializer));
                 return recid;
             }finally {
                 commitLock.writeLock().unlock();

File: src/main/java/org/mapdb/BTreeKeySerializer.java
Patch:
@@ -437,7 +437,7 @@ public final int findChildren2(final BTreeMap.BNode node, final Object key) {
         @Override
         public void serialize(DataOutput out, int[] keys) throws IOException {
             int prev = keys[0];
-            DataIO.packInt(out, prev);
+            DataIO.packIntBigger(out, prev);
             //$DELAY$
             for(int i=1;i<keys.length;i++){
                 int curr = keys[i];

File: src/main/java/org/mapdb/Serializer.java
Patch:
@@ -522,7 +522,7 @@ public Integer deserialize(DataInput in, int available) throws IOException {
         public void valueArraySerialize(DataOutput out, Object vals) throws IOException {
             DataIO.DataOutputByteArray out2 = (DataIO.DataOutputByteArray) out;
             for(int o:(int[]) vals){
-                out2.packInt(o);
+                out2.packIntBigger(o);
             }
         }
 

File: src/main/java/org/mapdb/DB.java
Patch:
@@ -55,8 +55,7 @@ public class DB implements Closeable {
     protected Map<String, WeakReference<?>> namesInstanciated = new HashMap<String, WeakReference<?>>();
 
     protected Map<IdentityWrapper, String> namesLookup =
-            Collections.synchronizedMap( //TODO remove synchronized map, after DB locking is resolved
-            new HashMap<IdentityWrapper, String>());
+            new ConcurrentHashMap<IdentityWrapper, String>();
 
     /** view over named records */
     protected SortedMap<String, Object> catalog;
@@ -73,6 +72,7 @@ public class DB implements Closeable {
     //TODO collection get/create should be under consistencyLock.readLock()
     protected final ReadWriteLock consistencyLock;
 
+    /** changes object hash and equals method to use identity */
     protected static class IdentityWrapper{
 
         final Object o;
@@ -228,7 +228,7 @@ public <A> A catPut(String name, A value, A retValueIfNull){
     }
 
     /** returns name for this object, if it has name and was instanciated by this DB*/
-    public synchronized  String getNameForObject(Object obj) {
+    public String getNameForObject(Object obj) {
         return namesLookup.get(new IdentityWrapper(obj));
     }
 

File: src/test/java/doc/dbmaker_txmaker_basic.java
Patch:
@@ -35,8 +35,7 @@ public static void main(String[] args) {
         tx1.commit();
         tx2.commit();
         // second commit fails  with write conflict, both maps share single BTree node,
-        // this does not happend on large maps with sufficent number of BTree nodes.
-
+        // this does not happen on large maps with sufficient number of BTree nodes.
         //z
     }
 }

File: src/main/java/org/mapdb/DBMaker.java
Patch:
@@ -1337,7 +1337,7 @@ protected Volume.VolumeFactory  extendStoreVolumeFactory(boolean index) {
         else if(Keys.volume_directByteBuffer.equals(volume))
             return Volume.MemoryVol.FACTORY;
         else if(Keys.volume_unsafe.equals(volume))
-            return Volume.UnsafeVolume.FACTORY;
+            return Volume.UNSAFE_VOL_FACTORY;
 
         int rafMode = propsGetRafMode();
         if(rafMode == 3)

File: src/test/java/org/mapdb/VolumeTest.java
Patch:
@@ -41,7 +41,7 @@ public Volume run(String file) {
                     new Fun.Function1<Volume,String>() {
                         @Override
                         public Volume run(String file) {
-                            return new Volume.UnsafeVolume(-1, CC.VOLUME_PAGE_SHIFT);
+                            return Volume.UNSAFE_VOL_FACTORY.makeVolume(null, false, CC.VOLUME_PAGE_SHIFT, 0, false);
                         }
                     },
                     new Fun.Function1<Volume,String>() {

File: src/main/java/org/mapdb/DBMaker.java
Patch:
@@ -1363,9 +1363,9 @@ public static DB.HTreeMapMaker hashMapSegmented(DBMaker.Maker maker){
 
 
         DB db = maker.make();
-        Engine[] engines = new Engine[16];
+        Engine[] engines = new Engine[HTreeMap.SEG];
         engines[0] = db.engine;
-        for(int i=1;i<16;i++){
+        for(int i=1;i<HTreeMap.SEG;i++){
             engines[i] = maker.makeEngine();
         }
         return new DB.HTreeMapMaker(db,"hashMapSegmented", engines)

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -469,7 +469,7 @@ protected void putData(long recid, long[] offsets, byte[] src, int srcLen) {
 
                 long offset = (offsets[i] & MOFFSET);
                 if(CC.ASSERT && offset%16!=0)
-                    throw new AssertionError("not alligned to 16");
+                    throw new AssertionError("not aligned to 16");
 
                 int plus = (last?0:8);
                 int size = (int) ((offsets[i]>>>48) - plus);

File: src/main/java/org/mapdb/CC.java
Patch:
@@ -127,6 +127,8 @@ public interface CC {
     int DEFAULT_ASYNC_WRITE_QUEUE_SIZE = 1024;
 
     Volume.VolumeFactory DEFAULT_MEMORY_VOLUME_FACTORY = Volume.ByteArrayVol.FACTORY;
-    Volume.VolumeFactory DEFAULT_FILE_VOLUME_FACTORY = Volume.FileChannelVol.FACTORY;
+
+    //TODO AppendStoreTest par* test fails if this changes  to FileChannelVol
+    Volume.VolumeFactory DEFAULT_FILE_VOLUME_FACTORY = Volume.RandomAccessFileVol.FACTORY;
 }
 

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -1016,6 +1016,7 @@ protected void replayWAL(){
                     //TODO this should be closed earlier
                     walCCompact.sync();
                     walCCompact.close();
+                    walCCompact = null;
                 }
                 walC.close();
                 walC.deleteFile();

File: src/main/java/org/mapdb/Bind.java
Patch:
@@ -124,8 +124,8 @@ public interface MapWithModificationListener<K,V> extends Map<K,V> {
      *
      * NOTE: {@link BTreeMap} and {@link HTreeMap} already supports this directly as optional parameter named {@code counter}.
      * In that case all calls to {@code Map.size()} are forwarded to underlying counter. Check parameters at
-     * {@link DB#createHashMap(String)} and
-     * {@link DB#createTreeMap(String)}
+     * {@link DB#hashMapCreate(String)} and
+     * {@link DB#treeMapCreate(String)}
      *
      *
      * @param map primary map whose size needs to be tracked

File: src/test/java/examples/CacheEntryExpiry.java
Patch:
@@ -28,7 +28,7 @@ public static void main(String[] args) {
         //create map, entries are expired if not accessed (get,iterate) for 10 seconds or 30 seconds after 'put'
         //There is also maximal size limit to prevent OutOfMemoryException
         HTreeMap map = db
-                .createHashMap("cache")
+                .hashMapCreate("cache")
                 .expireMaxSize(1000000)
                 .expireAfterWrite(30, TimeUnit.SECONDS)
                 .expireAfterAccess(10, TimeUnit.SECONDS)

File: src/test/java/examples/CacheOffHeapAdvanced.java
Patch:
@@ -32,7 +32,7 @@ public static void main(String[] args) {
 
 
         HTreeMap cache = db
-                .createHashMap("cache")
+                .hashMapCreate("cache")
                 .expireStoreSize(cacheSizeInGB)
                 .counterEnable() //disable this if cache.size() is not used
                 //use proper serializers to and improve performance

File: src/test/java/examples/Compression.java
Patch:
@@ -22,7 +22,7 @@ public static void main(String[] args) {
                 .compressionEnable() //this settings enables compression
                 .make();
         //and now create and use map as usual
-        Map map = db.getTreeMap("test");
+        Map map = db.treeMap("test");
         map.put("some","stuff");
 
 
@@ -40,7 +40,7 @@ public static void main(String[] args) {
         valueSerializer = new Serializer.CompressionWrapper(valueSerializer);
 
         //now construct map, with additional options
-        Map map2 = db2.createTreeMap("test")
+        Map map2 = db2.treeMapCreate("test")
                 .valuesOutsideNodesEnable() // store values outside of BTree Nodes. Faster reads if values are large.
                 .valueSerializer(valueSerializer) //set our value serializer.
                 .make();

File: src/test/java/examples/Custom_Value.java
Patch:
@@ -69,7 +69,7 @@ public static void main(String[] args) throws IOException {
 				.make();
 		
 		// Open or create table
-		Map<String,Person> dbMap = db.getTreeMap("personAndCity");
+		Map<String,Person> dbMap = db.treeMap("personAndCity");
 		
 		// Add data
 		Person bilbo = new Person("Bilbo","The Shire");
@@ -115,7 +115,7 @@ public int fixedSize() {
 
         DB db2 = DBMaker.tempFileDB().make();
 
-        Map<String,Person> map2 = db2.createHashMap("map").valueSerializer(serializer).make();
+        Map<String,Person> map2 = db2.hashMapCreate("map").valueSerializer(serializer).make();
 
         map2.put("North", new Person("Yet another dwarf","Somewhere"));
 

File: src/test/java/examples/Huge_Insert.java
Patch:
@@ -90,7 +90,7 @@ public String next() {
         /**
          * Create BTreeMap and fill it with data
          */
-        Map<String,Integer> map = db.createTreeMap("map")
+        Map<String,Integer> map = db.treeMapCreate("map")
                 .pumpSource(source,valueExtractor)
                 //.pumpPresort(100000) // for presorting data we could also use this method
                 .keySerializer(keySerializer)

File: src/test/java/examples/Lazily_Loaded_Records.java
Patch:
@@ -28,7 +28,7 @@ public static void main(String[] args) {
         // use DB.createTreeMap to create TreeMap with non-default parameters
 
 
-        Map map = db.createTreeMap("name").valuesOutsideNodesEnable().make();
+        Map map = db.treeMapCreate("name").valuesOutsideNodesEnable().make();
         map.put("key","this string is loaded lazily with 'map.get(key)' ");
 
 
@@ -38,7 +38,7 @@ public static void main(String[] args) {
         // As bonus you can update reference in thread-safe atomic manner.
         //
         Atomic.Var<String> record =
-                db.createAtomicVar("lazyRecord", "aaa", db.getDefaultSerializer());
+                db.atomicVarCreate("lazyRecord", "aaa", db.getDefaultSerializer());
 
         record.set("some value");
         System.out.println(record.get());

File: src/test/java/examples/MultiMap.java
Patch:
@@ -21,10 +21,10 @@ public static void main(String[] args) {
         //  Map<String,List<Long>> map
 
         //correct way is to use composite set, where 'map key' is primary key and 'map value' is secondary value
-        NavigableSet<Object[]> multiMap = db.getTreeSet("test");
+        NavigableSet<Object[]> multiMap = db.treeSet("test");
 
         //optionally you can use set with Delta Encoding. This may save lot of space
-        multiMap = db.createTreeSet("test2")
+        multiMap = db.treeSetCreate("test2")
                 .serializer(BTreeKeySerializer.ARRAY2)
                 .make();
 

File: src/test/java/examples/SQL_Auto_Incremental_Unique_Key.java
Patch:
@@ -17,11 +17,11 @@ public static void main(String[] args) {
         DB db = DBMaker.tempFileDB().make();
 
         //open or create new map
-        Map<Long, String> map = db.getTreeMap("map");
+        Map<Long, String> map = db.treeMap("map");
 
         // open existing or create new Atomic record with given name
         // if no record with given name exist, new recid is created with value `0`
-        Atomic.Long keyinc = db.getAtomicLong("map_keyinc");
+        Atomic.Long keyinc = db.atomicLong("map_keyinc");
 
 
         // Allocate new unique key to use in map

File: src/test/java/examples/Secondary_Map.java
Patch:
@@ -15,7 +15,7 @@
 public class Secondary_Map {
 
     public static void main(String[] args) {
-        HTreeMap<Long, String> primary = DBMaker.memoryDB().make().getHashMap("test");
+        HTreeMap<Long, String> primary = DBMaker.memoryDB().make().hashMap("test");
 
         // secondary map will hold String.size() from primary map as its value
         Map<Long,Integer> secondary = new HashMap(); //can be normal java map, or MapDB map

File: src/test/java/examples/Secondary_Values.java
Patch:
@@ -30,10 +30,10 @@ static class Person implements Serializable{
     public static void main(String[] args) {
         DB db = DBMaker.memoryDB().make();
         //list if friends
-        BTreeMap<Integer,Person> friends = db.getTreeMap("friends");
+        BTreeMap<Integer,Person> friends = db.treeMap("friends");
 
         //secondary collections which lists all friends for given id
-        NavigableSet<Object[]> id2friends = db.createTreeSet("id2friends")
+        NavigableSet<Object[]> id2friends = db.treeSetCreate("id2friends")
                 .serializer(BTreeKeySerializer.ARRAY2)
                 .makeOrGet();
 

File: src/test/java/examples/Transactions2.java
Patch:
@@ -15,14 +15,14 @@ public static void main(String[] args) {
         // Execute transaction within single block.
         txMaker.execute(new TxBlock(){
             @Override public void tx(DB db) throws TxRollbackException {
-                Map m = db.getHashMap("test");
+                Map m = db.hashMap("test");
                 m.put("test","test");
             }
         });
 
         //show result of block execution
         DB tx1 = txMaker.makeTx();
-        Object val = tx1.getHashMap("test").get("test");
+        Object val = tx1.hashMap("test").get("test");
         System.out.println(val);
 
         tx1.close();

File: src/test/java/examples/TreeMap_Performance_Tunning.java
Patch:
@@ -65,8 +65,8 @@ public static void main(String[] args) {
 
                 Map<Long,String> map =
                         (valueOutsideOfNodes?
-                                (db.createTreeMap("test").valuesOutsideNodesEnable()):
-                                db.createTreeMap("test"))
+                                (db.treeMapCreate("test").valuesOutsideNodesEnable()):
+                                db.treeMapCreate("test"))
                     .nodeSize(nodeSize)
                     .make();
 

File: src/test/java/examples/_HelloWorld.java
Patch:
@@ -24,7 +24,7 @@ public static void main(String[] args) throws IOException {
                 .make();
 
         //open an collection, TreeMap has better performance then HashMap
-        ConcurrentNavigableMap<Integer,String> map = db.getTreeMap("collectionName");
+        ConcurrentNavigableMap<Integer,String> map = db.treeMap("collectionName");
 
         map.put(1,"one");
         map.put(2,"two");

File: src/test/java/org/mapdb/AtomicIntegerTest.java
Patch:
@@ -17,7 +17,7 @@ public class AtomicIntegerTest extends TestCase {
     @Override
     protected void setUp() throws Exception {
         db = DBMaker.memoryDB().transactionDisable().make();
-        ai = db.createAtomicInteger("test", 1);
+        ai = db.atomicIntegerCreate("test", 1);
     }
 
     @Override
@@ -37,7 +37,7 @@ public void testConstructor(){
      * default constructed initializes to zero
      */
     public void testConstructor2(){
-        Atomic.Integer  ai = db.getAtomicInteger("test2");
+        Atomic.Integer  ai = db.atomicInteger("test2");
         assertEquals(0,ai.get());
     }
 

File: src/test/java/org/mapdb/BTreeKeySerializerTest.java
Patch:
@@ -18,7 +18,7 @@ public class BTreeKeySerializerTest {
         DB db = DBMaker.memoryDB()
                 .transactionDisable()
                 .make();
-        Map m = db.createTreeMap("test")
+        Map m = db.treeMapCreate("test")
                 .keySerializer(BTreeKeySerializer.LONG)
                 .make();
 
@@ -76,7 +76,7 @@ void checkKeyClone(BTreeKeySerializer ser, Object[] keys) throws IOException {
         DB db = DBMaker.memoryDB()
                 .transactionDisable()
                 .make();
-        Map m =  db.createTreeMap("test")
+        Map m =  db.treeMapCreate("test")
                 .keySerializer(BTreeKeySerializer.STRING)
                 .make();
 

File: src/test/java/org/mapdb/BTreeMapExtendTest.java
Patch:
@@ -65,14 +65,14 @@ public class BTreeMapExtendTest extends TestCase {
     Object objArray[] = new Object[1000];
 
     protected BTreeMap newBTreeMap() {
-        return DBMaker.memoryDB().transactionDisable().make().getTreeMap("Test");
+        return DBMaker.memoryDB().transactionDisable().make().treeMap("Test");
     }
 
 
     public static class Outside extends BTreeMapExtendTest{
         @Override protected BTreeMap newBTreeMap() {
             return DBMaker.memoryDB().transactionDisable().make()
-                    .createTreeMap("Test").valuesOutsideNodesEnable().make();
+                    .treeMapCreate("Test").valuesOutsideNodesEnable().make();
         }
 
     }

File: src/test/java/org/mapdb/BTreeMapNavigable2Test.java
Patch:
@@ -1,7 +1,6 @@
 package org.mapdb;
 
 import junit.framework.TestCase;
-import org.junit.After;
 
 import java.util.*;
 
@@ -32,13 +31,13 @@ protected void tearDown() throws Exception {
     }
 
     protected NavigableMap<Integer, String> newMap() {
-        return DBMaker.memoryDB().transactionDisable().make().createTreeMap("map").make();
+        return DBMaker.memoryDB().transactionDisable().make().treeMapCreate("map").make();
     }
 
 
     public static class Outside extends BTreeMapNavigable2Test{
         @Override protected NavigableMap<Integer, String> newMap() {
-            return DBMaker.memoryDB().transactionDisable().make().createTreeMap("map").valuesOutsideNodesEnable().make();
+            return DBMaker.memoryDB().transactionDisable().make().treeMapCreate("map").valuesOutsideNodesEnable().make();
         }
     }
 

File: src/test/java/org/mapdb/BTreeMapNavigableSubMapExclusiveTest.java
Patch:
@@ -6,7 +6,7 @@ public class BTreeMapNavigableSubMapExclusiveTest extends BTreeMapNavigable2Test
 
     public static class Outside extends BTreeMapNavigableSubMapExclusiveTest{
         @Override protected NavigableMap<Integer, String> newMap() {
-            return DBMaker.memoryDB().transactionDisable().make().createTreeMap("map").valuesOutsideNodesEnable()
+            return DBMaker.memoryDB().transactionDisable().make().treeMapCreate("map").valuesOutsideNodesEnable()
                     .make();
         }
 

File: src/test/java/org/mapdb/BTreeMapNavigableSubMapInclusiveTest.java
Patch:
@@ -6,7 +6,7 @@ public class BTreeMapNavigableSubMapInclusiveTest extends BTreeMapNavigable2Test
 
     public static class Outside extends BTreeMapNavigableSubMapInclusiveTest{
         @Override protected NavigableMap<Integer, String> newMap() {
-            return DBMaker.memoryDB().transactionDisable().make().createTreeMap("map").valuesOutsideNodesEnable().make();
+            return DBMaker.memoryDB().transactionDisable().make().treeMapCreate("map").valuesOutsideNodesEnable().make();
         }
     }
 

File: src/test/java/org/mapdb/BTreeMapNavigableTest.java
Patch:
@@ -77,12 +77,12 @@ public class BTreeMapNavigableTest extends TestCase {
 
 
     protected NavigableMap<String, String> newMap() {
-            return DBMaker.memoryDB().transactionDisable().make().createTreeMap("map").make();
+            return DBMaker.memoryDB().transactionDisable().make().treeMapCreate("map").make();
     }
 
     public static class Outside extends BTreeMapNavigableTest{
         @Override protected NavigableMap<String, String> newMap() {
-            return DBMaker.memoryDB().transactionDisable().make().createTreeMap("map").valuesOutsideNodesEnable().make();
+            return DBMaker.memoryDB().transactionDisable().make().treeMapCreate("map").valuesOutsideNodesEnable().make();
         }
     }
 

File: src/test/java/org/mapdb/BTreeMapParTest.java
Patch:
@@ -18,7 +18,7 @@ public void parInsert() throws InterruptedException {
 
 
         final ConcurrentMap m = DBMaker.memoryDB().transactionDisable().make()
-                .createTreeMap("test")
+                .treeMapCreate("test")
                 .valueSerializer(Serializer.LONG)
                 .keySerializer(BTreeKeySerializer.LONG)
                 .makeLongMap();

File: src/test/java/org/mapdb/BTreeMapTest3.java
Patch:
@@ -38,13 +38,13 @@ protected String getSecondValueNotInPopulatedMap() throws UnsupportedOperationEx
 
     @Override
     protected ConcurrentNavigableMap<Integer, String> makeEmptyMap() throws UnsupportedOperationException {
-        return DBMaker.memoryDB().transactionDisable().make().getTreeMap("test");
+        return DBMaker.memoryDB().transactionDisable().make().treeMap("test");
     }
 
     public static class Outside extends BTreeMapTest3{
         @Override
         protected ConcurrentNavigableMap<Integer, String> makeEmptyMap() throws UnsupportedOperationException {
-            return DBMaker.memoryDB().transactionDisable().make().createTreeMap("test").valuesOutsideNodesEnable().make();
+            return DBMaker.memoryDB().transactionDisable().make().treeMapCreate("test").valuesOutsideNodesEnable().make();
         }
 
     }

File: src/test/java/org/mapdb/BTreeMapTest5.java
Patch:
@@ -14,12 +14,12 @@ public class BTreeMapTest5 extends JSR166TestCase {
     public static class Outside extends BTreeMapTest5{
         @Override
         protected BTreeMap newMap() {
-            return DBMaker.memoryDB().transactionDisable().make().createTreeMap("test").valuesOutsideNodesEnable().make();
+            return DBMaker.memoryDB().transactionDisable().make().treeMapCreate("test").valuesOutsideNodesEnable().make();
         }
     }
 
     protected  BTreeMap newMap() {
-        return DBMaker.memoryDB().transactionDisable().make().createTreeMap("test").make();
+        return DBMaker.memoryDB().transactionDisable().make().treeMapCreate("test").make();
     }
 
 

File: src/test/java/org/mapdb/BindTest.java
Patch:
@@ -20,7 +20,7 @@ public class BindTest {
 
     @Before
     public void init(){
-        m = DBMaker.memoryDB().transactionDisable().make().getTreeMap("test");
+        m = DBMaker.memoryDB().transactionDisable().make().treeMap("test");
     }
 
 
@@ -133,11 +133,11 @@ public String[] run(Integer integer, String s) {
     }
 
     @Test public void htreemap_listeners(){
-        mapListeners(DBMaker.memoryDB().transactionDisable().make().getHashMap("test"));
+        mapListeners(DBMaker.memoryDB().transactionDisable().make().hashMap("test"));
     }
 
     @Test public void btreemap_listeners(){
-        mapListeners(DBMaker.memoryDB().transactionDisable().make().getTreeMap("test"));
+        mapListeners(DBMaker.memoryDB().transactionDisable().make().treeMap("test"));
     }
 
 

File: src/test/java/org/mapdb/BrokenDBTest.java
Patch:
@@ -114,7 +114,7 @@ public static class SomeDataObject implements Serializable {
     public void canDeleteDBOnBrokenContent() throws IOException {
         // init empty, but valid DB
         DB db = DBMaker.fileDB(index).make();
-        db.getHashMap("foo").put("foo", new SomeDataObject());
+        db.hashMap("foo").put("foo", new SomeDataObject());
         db.commit();
         db.close();
 

File: src/test/java/org/mapdb/DBMakerTest.java
Patch:
@@ -20,7 +20,7 @@ public class DBMakerTest{
 
     
     private void verifyDB(DB db) {
-        Map m = db.getHashMap("test");
+        Map m = db.hashMap("test");
         m.put(1,2);
         assertEquals(2, m.get(1));
     }
@@ -368,7 +368,7 @@ public void nonExistingFolder2(){
         List unsorted = Arrays.asList(4,7,5,12,9,10,11,0);
 
         NavigableSet<Integer> s = DBMaker.memoryDB().transactionDisable().make()
-                .createTreeSet("t")
+                .treeSetCreate("t")
                 .pumpPresort(10)
                 .pumpSource(unsorted.iterator())
                 .make();
@@ -381,7 +381,7 @@ public void nonExistingFolder2(){
         List unsorted = Arrays.asList(4,7,5,12,9,10,11,0);
 
         NavigableMap<Integer,Integer> s = DBMaker.memoryDB().transactionDisable().make()
-                .createTreeMap("t")
+                .treeMapCreate("t")
                 .pumpPresort(10)
                 .pumpSource(unsorted.iterator(), Fun.extractNoTransform())
                 .make();

File: src/test/java/org/mapdb/HTreeSetTest.java
Patch:
@@ -140,7 +140,7 @@ public void close(){
         Set s = DBMaker.fileDB(UtilsTest.tempDbFile())
                 .transactionDisable()
                 .make()
-                .getHashSet("name");
+                .hashSet("name");
         assertTrue(s.isEmpty());
         assertEquals(0,s.size());
         s.add("aa");

File: src/test/java/org/mapdb/Issue132Test.java
Patch:
@@ -33,7 +33,7 @@ public  void test_full() {
 
 
 
-            Set<Long> set = db.getHashSet("test");
+            Set<Long> set = db.hashSet("test");
             db.commit();
 
             for (int i = 0; i < count; i++) {
@@ -70,7 +70,7 @@ public  void test_isolate() {
                 .checksumEnable().make();
 
 
-        Set<Long> set = db.getHashSet("test");
+        Set<Long> set = db.hashSet("test");
         db.commit();
 
         for (int i = 0; i < count; i++) {

File: src/test/java/org/mapdb/Issue148Test.java
Patch:
@@ -42,7 +42,7 @@ public void test(){
         DB mapdb = DBMaker.appendFileDB(mapdbFile).closeOnJvmShutdown().make();
 
         Serializer<CustomValue> valueSerializer = new CustomValueSerializer();
-        HTreeMap<String, CustomValue> users = mapdb.createHashMap("users").counterEnable().make();
+        HTreeMap<String, CustomValue> users = mapdb.hashMapCreate("users").counterEnable().make();
         users.put("jhon", new CustomValue("jhon",  32));
         users.put("mike", new CustomValue("mike",  30));
         mapdb.commit();
@@ -61,7 +61,7 @@ public void test(){
 
         // 2 : Open HTreeMap, replace some values , Commit and Close;
         mapdb = DBMaker.appendFileDB(mapdbFile).closeOnJvmShutdown().make();
-        users = mapdb.getHashMap("users");
+        users = mapdb.hashMap("users");
 
         System.out.println("Just Reopen : all values ar good");
         dumpUserDB(users);
@@ -84,7 +84,7 @@ public void test(){
 
         // 3 : Open HTreeMap, Dump
         mapdb = DBMaker.appendFileDB(mapdbFile).closeOnJvmShutdown().make();
-        users = mapdb.getHashMap("users");
+        users = mapdb.hashMap("users");
 
         System.out.println("But final value is not changed");
         dumpUserDB(users);

File: src/test/java/org/mapdb/Issue150Test.java
Patch:
@@ -25,13 +25,13 @@ public void test() {
         x.setName("nameXXX");
 
         Serializer<EntityA> valueSerializer = new CustomSerializer();
-        Map<Long, EntityA> map = db.createHashMap("entitya").valueSerializer(valueSerializer).make();
+        Map<Long, EntityA> map = db.hashMapCreate("entitya").valueSerializer(valueSerializer).make();
 
         map.put(x.getId(), x);
 
         db.commit();
 
-        EntityA y = (EntityA) txMaker.makeTx().getHashMap("entitya")
+        EntityA y = (EntityA) txMaker.makeTx().hashMap("entitya")
                 .get(x.getId());
         System.out.println(x.equals(y));
 

File: src/test/java/org/mapdb/Issue157Test.java
Patch:
@@ -11,7 +11,7 @@ public class Issue157Test {
     @Test
     public void concurrent_BTreeMap() throws InterruptedException {
         DB db = DBMaker.memoryDB().make();
-        final BTreeMap<Integer, String> map = db.getTreeMap("COL_2");
+        final BTreeMap<Integer, String> map = db.treeMap("COL_2");
         map.clear();
 
         Thread t1 = new Thread() {

File: src/test/java/org/mapdb/Issue164Test.java
Patch:
@@ -84,7 +84,7 @@ public void main() {
                     .closeOnJvmShutdown()
                     .make();
 // the following test shows that the db is opened if it always exists
-            map = db.getTreeMap("test");
+            map = db.treeMap("test");
             if (!map.containsKey("t1")) {
                 map.put("t1", new Scenario());
                 db.commit();

File: src/test/java/org/mapdb/Issue170Test.java
Patch:
@@ -13,7 +13,7 @@ public void test(){
         Map m = DBMaker.memoryDB()
                 .compressionEnable()
                 .transactionDisable()
-                .make().createTreeMap("test").make();
+                .make().treeMapCreate("test").make();
         for(int i=0;i<1e5;i++){
             m.put(UUID.randomUUID().toString(),UUID.randomUUID().toString());
         }

File: src/test/java/org/mapdb/Issue183Test.java
Patch:
@@ -23,7 +23,7 @@ public void main(){
 
         DB db = txMaker.makeTx();
 
-        map1 = db.createTreeMap("map1")
+        map1 = db.treeMapCreate("map1")
                 .valueSerializer(new StringSerializer())
                 .makeOrGet();
 
@@ -40,7 +40,7 @@ public void main(){
 
         db = txMaker.makeTx();
 
-        map1 = db.createTreeMap("map1")
+        map1 = db.treeMapCreate("map1")
                 .valueSerializer(new StringSerializer())
                 .makeOrGet();
 

File: src/test/java/org/mapdb/Issue198Test.java
Patch:
@@ -12,7 +12,7 @@ public class Issue198Test {
                 .closeOnJvmShutdown()
                 //.randomAccessFileEnable()
                 .make();
-        BTreeMap<Integer, Integer> map = db.createTreeMap("testmap").makeOrGet();
+        BTreeMap<Integer, Integer> map = db.treeMapCreate("testmap").makeOrGet();
         for(int i = 1; i <= 3000; ++i)
             map.put(i, i);
         db.commit();

File: src/test/java/org/mapdb/Issue241.java
Patch:
@@ -13,15 +13,15 @@ public void main()
     {
         DB db = getDb();
         final String mapName = "map"; //$NON-NLS-1$
-        Map<Long, CustomClass> map = db.createTreeMap(mapName).make();
+        Map<Long, CustomClass> map = db.treeMapCreate(mapName).make();
 //                db.createTreeMap(mapName)
 //                .valueSerializer(new CustomSerializer()).make();
         map.put(1L, new CustomClass("aString", 1001L)); //$NON-NLS-1$
         db.commit();
         db.close();
 
         db = getDb();
-        map = db.getTreeMap(mapName);
+        map = db.treeMap(mapName);
         map.get(1L);
     }
 

File: src/test/java/org/mapdb/Issue247Test.java
Patch:
@@ -9,7 +9,7 @@
 public class Issue247Test {
 
         private Map getMap(DB db){
-                return db.createTreeMap("test")
+                return db.treeMapCreate("test")
                              .counterEnable()
                              .valuesOutsideNodesEnable()
                              .makeOrGet();

File: src/test/java/org/mapdb/Issue249Test.java
Patch:
@@ -18,14 +18,14 @@ public void main() {
         x.setId(1L);
         x.setTitle("nameXXX");
 
-        Map<Long, UploadInfo> map = db.getTreeMap(UploadInfo.class.getName());
+        Map<Long, UploadInfo> map = db.treeMap(UploadInfo.class.getName());
         map.put(x.getId(), x);
 
         db = commit(db);
         db = rollback(db);
 
         DB db2 = txMaker.makeTx();
-        Map<Long, UploadInfo> map2 = db2.getTreeMap(UploadInfo.class.getName());
+        Map<Long, UploadInfo> map2 = db2.treeMap(UploadInfo.class.getName());
         map2.get(x.getId());
 
         txMaker.close();

File: src/test/java/org/mapdb/Issue265Test.java
Patch:
@@ -13,7 +13,7 @@ public void compact(){
                 .transactionDisable()
                 .make(); // breaks functionality even in version 0.9.7
 
-            Map<Integer, String> map = db.getHashMap("HashMap");
+            Map<Integer, String> map = db.hashMap("HashMap");
             map.put(1, "one");
             map.put(2, "two");
             map.remove(1);
@@ -29,7 +29,7 @@ public void compact(){
     public void compact_no_tx(){
             DB db = DBMaker.memoryDB().make();
 
-            Map<Integer, String> map = db.getHashMap("HashMap");
+            Map<Integer, String> map = db.hashMap("HashMap");
             map.put(1, "one");
             map.put(2, "two");
             map.remove(1);

File: src/test/java/org/mapdb/Issue266Test.java
Patch:
@@ -45,7 +45,7 @@ public void testEnum() throws IOException {
 
         AdvancedEnum testEnumValue = AdvancedEnum.C;
 
-        Set<Object> set = db.createTreeSet("set").makeOrGet();
+        Set<Object> set = db.treeSetCreate("set").makeOrGet();
         set.clear();
 
         set.add(testEnumValue);
@@ -55,7 +55,7 @@ public void testEnum() throws IOException {
 
         db = DBMaker.fileDB(f).make();
 
-        set = db.createTreeSet("set").makeOrGet();
+        set = db.treeSetCreate("set").makeOrGet();
         AdvancedEnum enumValue = (AdvancedEnum)set.iterator().next();
 
         Assert.assertNotNull(enumValue);

File: src/test/java/org/mapdb/Issue308Test.java
Patch:
@@ -35,6 +35,6 @@ public void remove() {
 
             }
         };
-        BTreeMap<Long, String> cubeData = db.createTreeMap("data").pumpSource(newIterator).make();
+        BTreeMap<Long, String> cubeData = db.treeMapCreate("data").pumpSource(newIterator).make();
     }
 }

File: src/test/java/org/mapdb/Issue312Test.java
Patch:
@@ -16,7 +16,7 @@ public void test() throws IOException{
                 .transactionDisable()
                 .make();
 
-        Map<Long, String> map = db.createTreeMap("data").make();
+        Map<Long, String> map = db.treeMapCreate("data").make();
         for(long i = 0; i<100000;i++){
             map.put(i,i + "hi my friend " + i);
         }

File: src/test/java/org/mapdb/Issue321Test.java
Patch:
@@ -15,7 +15,7 @@ public void npe(){
 
         List l = Arrays.asList(19,10,9,8,2);
 
-        Map m = db.createTreeMap("aa")
+        Map m = db.treeMapCreate("aa")
                 .pumpPresort(100)
                 .make();
 

File: src/test/java/org/mapdb/Issue332Test.java
Patch:
@@ -71,7 +71,7 @@ public void run() throws IOException {
                 .closeOnJvmShutdown()
                 .make();
 
-        Map<Integer, String> testMap = db.createHashMap("testmap")
+        Map<Integer, String> testMap = db.hashMapCreate("testmap")
                 .valueSerializer(VALUE_SERIALIZER)
                         //.valueSerializer(new TestSerializer())
                 .makeOrGet();
@@ -87,7 +87,7 @@ public void run() throws IOException {
         db = DBMaker.fileDB(f)
                 .closeOnJvmShutdown()
                 .make();
-        testMap = db.createHashMap("testmap")
+        testMap = db.hashMapCreate("testmap")
                 .valueSerializer(VALUE_SERIALIZER)
                 .makeOrGet();
         String deserialized = testMap.get(1);

File: src/test/java/org/mapdb/Issue37Test.java
Patch:
@@ -18,7 +18,7 @@ public class Issue37Test {
     @Test public void test3(){
 
         DB db = DBMaker.memoryDirectDB().transactionDisable().asyncWriteFlushDelay(100).make();
-        ConcurrentMap<Long, Long> orders = db.createHashMap("order").make();
+        ConcurrentMap<Long, Long> orders = db.hashMapCreate("order").make();
         for(int i = 0; i < 10000; i++) {
             orders.put((long)i, (long)i);
         }

File: src/test/java/org/mapdb/Issue381Test.java
Patch:
@@ -22,7 +22,7 @@ public void testCorruption()
             DB tx = txMaker.makeTx();
             byte[] data = new byte[128];
 
-            ConcurrentMap<Long, byte[]> map = tx.getHashMap("persons");
+            ConcurrentMap<Long, byte[]> map = tx.hashMap("persons");
             map.clear();
             for (int i = 0; i < INSTANCES; i++) {
                 map.put((long) i, data);

File: src/test/java/org/mapdb/Issue400Test.java
Patch:
@@ -14,7 +14,7 @@ public void expire_maxSize_with_TTL() throws InterruptedException {
         File f = UtilsTest.tempDbFile();
         for (int o = 0; o < 2; o++) {
             final DB db = DBMaker.fileDB(f).transactionDisable().make();
-            final HTreeMap<Object, Object> map = db.createHashMap("foo")
+            final HTreeMap<Object, Object> map = db.hashMapCreate("foo")
                     .expireMaxSize(1000).expireAfterWrite(1, TimeUnit.DAYS)
                     .makeOrGet();
 
@@ -36,7 +36,7 @@ public void expire_maxSize_with_TTL_short() throws InterruptedException {
         File f = UtilsTest.tempDbFile();
         for (int o = 0; o < 2; o++) {
             final DB db = DBMaker.fileDB(f).transactionDisable().make();
-            final HTreeMap<Object, Object> map = db.createHashMap("foo")
+            final HTreeMap<Object, Object> map = db.hashMapCreate("foo")
                     .expireMaxSize(1000).expireAfterWrite(3, TimeUnit.SECONDS)
                     .makeOrGet();
 
@@ -60,7 +60,7 @@ public void expire_maxSize_with_TTL_get() throws InterruptedException {
         File f = UtilsTest.tempDbFile();
         for (int o = 0; o < 2; o++) {
             final DB db = DBMaker.fileDB(f).transactionDisable().make();
-            final HTreeMap<Object, Object> map = db.createHashMap("foo")
+            final HTreeMap<Object, Object> map = db.hashMapCreate("foo")
                     .expireMaxSize(1000).expireAfterAccess(3, TimeUnit.SECONDS)
                     .makeOrGet();
 

File: src/test/java/org/mapdb/Issue418Test.java
Patch:
@@ -18,7 +18,7 @@ public void test(){
         long[] expireTails = null;
         for (int o = 0; o < 2; o++) {
             final DB db = DBMaker.fileDB(tmp).transactionDisable().make();
-            final HTreeMap<Object, Object> map = db.createHashMap("foo").expireMaxSize(100).makeOrGet();
+            final HTreeMap<Object, Object> map = db.hashMapCreate("foo").expireMaxSize(100).makeOrGet();
 
             if(expireHeads!=null)
                 assertTrue(Serializer.LONG_ARRAY.equals(expireHeads, map.expireHeads));
@@ -48,7 +48,7 @@ public void test_set(){
 
         for (int o = 0; o < 2; o++) {
             final DB db = DBMaker.fileDB(tmp).transactionDisable().make();
-            final Set<Object> map = db.createHashSet("foo").expireMaxSize(100).makeOrGet();
+            final Set<Object> map = db.hashSetCreate("foo").expireMaxSize(100).makeOrGet();
 
             for (int i = 0; i < 1000; i++)
                 map.add("foo" + i);

File: src/test/java/org/mapdb/Issue41Test.java
Patch:
@@ -42,7 +42,7 @@ public void setUp() {
                         .make();
 
         map =
-                db.createHashMap(MAP_NAME)
+                db.hashMapCreate(MAP_NAME)
                         .keySerializer(new Key.Serializer())
                         .valueSerializer(new Value.Serializer())
                         .make();

File: src/test/java/org/mapdb/Issue440Test.java
Patch:
@@ -10,21 +10,21 @@ public class Issue440Test {
     public void first(){
         DB db = DBMaker.memoryDB().make();
 
-        NavigableSet<Object[]> set1 = db.createTreeSet("set1")
+        NavigableSet<Object[]> set1 = db.treeSetCreate("set1")
                 .serializer(BTreeKeySerializer.ARRAY2)
                 .makeOrGet();
 
         db = DBMaker.memoryDB().transactionDisable().make();
 
-        NavigableSet<Object[]> set2 = db.createTreeSet("set2")
+        NavigableSet<Object[]> set2 = db.treeSetCreate("set2")
                 .serializer(BTreeKeySerializer.ARRAY2)
                 .makeOrGet();
     }
 
     @Test public void second(){
         DB db = DBMaker.tempFileDB().make();
 
-        NavigableSet<Object[]> set1 = db.createTreeSet("set1")
+        NavigableSet<Object[]> set1 = db.treeSetCreate("set1")
                 .serializer(BTreeKeySerializer.ARRAY2)
                 .makeOrGet();
 

File: src/test/java/org/mapdb/Issue69Test.java
Patch:
@@ -36,7 +36,7 @@ public void tearDown() throws InterruptedException {
 	public void testStackOverflowError() throws Exception {
 
         try{
-		Map<String, String> map = db.getHashMap("test");
+		Map<String, String> map = db.hashMap("test");
 
 		StringBuilder buff = new StringBuilder();
 

File: src/test/java/org/mapdb/Issue77Test.java
Patch:
@@ -36,7 +36,7 @@ DB open(boolean readOnly) {
      void create() {
          dir.mkdirs();
         DB db = open(false);
-        ConcurrentNavigableMap<Integer, byte[]> map = db.getTreeMap("bytes");
+        ConcurrentNavigableMap<Integer, byte[]> map = db.treeMap("bytes");
         int n = 10;
         int m = 10;
         for (int i = 0; i < n; i++) {

File: src/test/java/org/mapdb/Issue78Test.java
Patch:
@@ -24,7 +24,7 @@ public void tearDown() {
     @Test(expected = IOError.class, timeout = 10000)
     public void testIssue() {
         DB db = DBMaker.tempFileDB().make();
-        HTreeMap<String, NotSerializable> usersMap = db.getHashMap("values");
+        HTreeMap<String, NotSerializable> usersMap = db.hashMap("values");
         usersMap.put("thisKillsTheAsyncWriteThread", new NotSerializable());
         db.commit();
     }

File: src/test/java/org/mapdb/Issue86Test.java
Patch:
@@ -20,7 +20,7 @@ public static DB createFileStore() {
     @Test
     public void Array() {
         DB createFileStore = createFileStore();
-        Map map = createFileStore.getTreeMap("testMap");
+        Map map = createFileStore.treeMap("testMap");
         int maxSize = 1000;
         for (int i = 1; i < maxSize; i++) {
             String[] array = new String[i];
@@ -34,7 +34,7 @@ public void Array() {
     @Test
     public void FieldArray() {
         DB createFileStore = createFileStore();
-        Map map = createFileStore.getTreeMap("testMap");
+        Map map = createFileStore.treeMap("testMap");
         int maxSize = 1000;
         for (int i = 1; i < maxSize; i++) {
             map.put(i, new StringContainer(i));

File: src/test/java/org/mapdb/Issue89Test.java
Patch:
@@ -44,7 +44,7 @@ private void appendToDataFile() {
 
 
         private void addData(DB myTestDataFile) {
-            final NavigableSet<Object> testTreeSet = myTestDataFile.getTreeSet(TEST_TREE_SET);
+            final NavigableSet<Object> testTreeSet = myTestDataFile.treeSet(TEST_TREE_SET);
             testTreeSet.add(DUMMY_CONTENT);
             myTestDataFile.commit();
 

File: src/test/java/org/mapdb/Issue90Test.java
Patch:
@@ -15,9 +15,9 @@ public void testCounter() throws Exception {
                 .closeOnJvmShutdown()
                 .compressionEnable()  //This is the cause of the exception. If compression is not used, no exception occurs.
                 .make();
-        final Atomic.Long myCounter = mapDb.getAtomicLong("MyCounter");
+        final Atomic.Long myCounter = mapDb.atomicLong("MyCounter");
 
-        final BTreeMap<String, Fun.Pair<String, Integer>> treeMap = mapDb.getTreeMap("map");
+        final BTreeMap<String, Fun.Pair<String, Integer>> treeMap = mapDb.treeMap("map");
         Bind.size(treeMap, myCounter);
 
         for (int i = 0; i < 3; i++) {

File: src/test/java/org/mapdb/IssuesTest.java
Patch:
@@ -11,7 +11,7 @@ public class IssuesTest {
                 .closeOnJvmShutdown()
                 .make();
 
-        Map store = db.getTreeMap("collectionName");
+        Map store = db.treeMap("collectionName");
 
 
     }

File: src/test/java/org/mapdb/MapListenerTest.java
Patch:
@@ -12,11 +12,11 @@
 public class MapListenerTest {
 
         @Test public void hashMap(){
-            tt(DBMaker.memoryDB().transactionDisable().cacheHashTableEnable().make().getHashMap("test"));
+            tt(DBMaker.memoryDB().transactionDisable().cacheHashTableEnable().make().hashMap("test"));
         }
 
         @Test public void treeMap(){
-            tt(DBMaker.memoryDB().transactionDisable().cacheHashTableEnable().make().getTreeMap("test"));
+            tt(DBMaker.memoryDB().transactionDisable().cacheHashTableEnable().make().treeMap("test"));
         }
 
 

File: src/test/java/org/mapdb/PumpComparableValueTest.java
Patch:
@@ -51,7 +51,7 @@ public boolean hasNext() {
 
 
 
-                BTreeMap<String,String> map2 = mapDBStore.createTreeMap("non comparable values")
+                BTreeMap<String,String> map2 = mapDBStore.treeMapCreate("non comparable values")
                                 .pumpSource(entriesSourceNonComp)
                                 .pumpPresort(pumpSize)
                                 .pumpIgnoreDuplicates()
@@ -97,7 +97,7 @@ public boolean hasNext() {
 
 
 
-        BTreeMap<String,String> map2 = db.createTreeMap("non comparable values")
+        BTreeMap<String,String> map2 = db.treeMapCreate("non comparable values")
                 .pumpSource(entriesSourceNonComp)
                 .pumpPresort(pumpSize)
                 .pumpIgnoreDuplicates()

File: src/test/java/org/mapdb/StoreDirectTest.java
Patch:
@@ -1,15 +1,13 @@
 package org.mapdb;
 
 
-import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.File;
 import java.io.IOError;
 import java.io.IOException;
 import java.util.*;
-import java.util.concurrent.Callable;
 import java.util.concurrent.locks.Lock;
 
 import static org.junit.Assert.*;
@@ -573,7 +571,7 @@ protected List<Long> getLongStack(long masterLinkOffset) {
 
         DB db = DBMaker.fileDB(f).transactionDisable().deleteFilesAfterClose().make();
 
-        db.getHashMap("test").put("aa","bb");
+        db.hashMap("test").put("aa","bb");
         db.commit();
         assertTrue(f.exists());
         assertTrue(phys.exists());

File: src/test/java/org/mapdb/TxEngineTest.java
Patch:
@@ -77,7 +77,7 @@ public class TxEngineTest {
     @Test public void BTreeMap_snapshot(){
         BTreeMap map =
                 DBMaker.memoryDB().transactionDisable().snapshotEnable()
-                .make().getTreeMap("aaa");
+                .make().treeMap("aaa");
         map.put("aa","aa");
         Map map2 = map.snapshot();
         map.put("aa","bb");
@@ -87,7 +87,7 @@ public class TxEngineTest {
     @Test public void HTreeMap_snapshot(){
         HTreeMap map =
                 DBMaker.memoryDB().transactionDisable().snapshotEnable()
-                .make().getHashMap("aaa");
+                .make().hashMap("aaa");
         map.put("aa","aa");
         Map map2 = map.snapshot();
         map.put("aa", "bb");

File: src/test/java/examples/Bidi_Map.java
Patch:
@@ -15,7 +15,7 @@ public class Bidi_Map {
 
     public static void main(String[] args) {
         //primary map
-        HTreeMap<Long,String> map = DBMaker.newTempHashMap();
+        HTreeMap<Long,String> map = DBMaker.tempHashMap();
 
         // inverse mapping for primary map
         NavigableSet<Object[]> inverseMapping = new TreeSet<Object[]>(Fun.COMPARABLE_ARRAY_COMPARATOR);

File: src/test/java/examples/CacheEntryExpiry.java
Patch:
@@ -21,7 +21,7 @@ public class CacheEntryExpiry {
     public static void main(String[] args) {
         //init off-heap store with 2GB size limit
         DB db = DBMaker
-                .newMemoryDirectDB()    //use off-heap memory, on-heap is `.newMemoryDB()`
+                .memoryDirectDB()    //use off-heap memory, on-heap is `.memoryDB()`
                 .transactionDisable()   //better performance
                 .make();
 

File: src/test/java/examples/CacheOffHeapAdvanced.java
Patch:
@@ -23,7 +23,7 @@ public static void main(String[] args) {
 
         //first create store
         DB db = DBMaker
-                .newMemoryDirectDB()
+                .memoryDirectDB()
                 .transactionDisable()
             //some additional options for DB
                // .asyncWriteEnable()

File: src/test/java/examples/Compression.java
Patch:
@@ -18,7 +18,7 @@ public static void main(String[] args) {
         /*
          * first case, just enable storage wide compression for all records.
          */
-        DB db = DBMaker.newMemoryDB()
+        DB db = DBMaker.memoryDB()
                 .compressionEnable() //this settings enables compression
                 .make();
         //and now create and use map as usual
@@ -32,7 +32,7 @@ public static void main(String[] args) {
          * you have large values, you may want to compress them. It may make sense
          * not to compress BTree Nodes and Keys.
          */
-        DB db2 = DBMaker.newMemoryDB().make(); //no store wide compression this time
+        DB db2 = DBMaker.memoryDB().make(); //no store wide compression this time
 
         //construct value serializier, use default serializier
         Serializer valueSerializer = db2.getDefaultSerializer();

File: src/test/java/examples/Custom_Value.java
Patch:
@@ -65,7 +65,7 @@ public static void main(String[] args) throws IOException {
 
         // Open db in temp directory
         File f = File.createTempFile("mapdb","temp");
-		DB db = DBMaker.newFileDB(f)
+		DB db = DBMaker.fileDB(f)
 				.make();
 		
 		// Open or create table
@@ -113,7 +113,7 @@ public int fixedSize() {
 
         Serializer<Person> serializer = new CustomSerializer();
 
-        DB db2 = DBMaker.newTempFileDB().make();
+        DB db2 = DBMaker.tempFileDB().make();
 
         Map<String,Person> map2 = db2.createHashMap("map").valueSerializer(serializer).make();
 

File: src/test/java/examples/Histogram.java
Patch:
@@ -17,7 +17,7 @@
 public class Histogram {
 
     public static void main(String[] args) {
-        HTreeMap<Long, Double> map = DBMaker.newTempHashMap();
+        HTreeMap<Long, Double> map = DBMaker.tempHashMap();
 
         // histogram, category is a key, count is a value
         ConcurrentMap<String, Long> histogram = new ConcurrentHashMap<String, Long>(); //any map will do

File: src/test/java/examples/Huge_Insert.java
Patch:
@@ -27,7 +27,7 @@ public static void main(String[] args) throws IOException {
          */
         File dbFile = File.createTempFile("mapdb","temp");
         DB db = DBMaker
-                .newFileDB(dbFile)
+                .fileDB(dbFile)
                 /** disabling Write Ahead Log makes import much faster */
                 .transactionDisable()
                 .make();

File: src/test/java/examples/Lazily_Loaded_Records.java
Patch:
@@ -19,7 +19,7 @@ public class Lazily_Loaded_Records {
 
     public static void main(String[] args) {
 
-        DB db = DBMaker.newMemoryDB().make();
+        DB db = DBMaker.memoryDB().make();
         //
         // TreeMap has build in support for lazily loaded values.
         // In that case each value are not stored inside node,

File: src/test/java/examples/Map_Size_Counter.java
Patch:
@@ -15,7 +15,7 @@ public class Map_Size_Counter {
     public static void main(String[] args) {
 
         //first option, create Map with counter (NOTE: counter is not on by default)
-        DB db1 = DBMaker.newTempFileDB().make();
+        DB db1 = DBMaker.tempFileDB().make();
         //hashMap
         Map m = db1.createHashMap("map1a")
                 .counterEnable() /**<<here is counter argument*/
@@ -31,7 +31,7 @@ public static void main(String[] args) {
 
 
         //second option, create external Atomic.Long and bind it to map */
-        DB db2 = DBMaker.newTempFileDB().make();
+        DB db2 = DBMaker.tempFileDB().make();
 
         BTreeMap primary = db2.getTreeMap("map2");
         Atomic.Long sizeCounter = db1.getAtomicLong("mapSize");

File: src/test/java/examples/MultiMap.java
Patch:
@@ -15,7 +15,7 @@
 public class MultiMap {
 
     public static void main(String[] args) {
-        DB db = DBMaker.newMemoryDB().make();
+        DB db = DBMaker.memoryDB().make();
 
         // this is wrong, do not do it !!!
         //  Map<String,List<Long>> map

File: src/test/java/examples/SQL_Auto_Incremental_Unique_Key.java
Patch:
@@ -14,7 +14,7 @@
  */
 public class SQL_Auto_Incremental_Unique_Key {
     public static void main(String[] args) {
-        DB db = DBMaker.newTempFileDB().make();
+        DB db = DBMaker.tempFileDB().make();
 
         //open or create new map
         Map<Long, String> map = db.getTreeMap("map");

File: src/test/java/examples/Secondary_Key.java
Patch:
@@ -16,7 +16,7 @@ public class Secondary_Key {
     public static void main(String[] args) {
 
         // stores string under id
-        BTreeMap<Long, String> primary = DBMaker.newTempTreeMap();
+        BTreeMap<Long, String> primary = DBMaker.tempTreeMap();
 
 
         // stores value hash from primary map

File: src/test/java/examples/Secondary_Map.java
Patch:
@@ -15,7 +15,7 @@
 public class Secondary_Map {
 
     public static void main(String[] args) {
-        HTreeMap<Long, String> primary = DBMaker.newMemoryDB().make().getHashMap("test");
+        HTreeMap<Long, String> primary = DBMaker.memoryDB().make().getHashMap("test");
 
         // secondary map will hold String.size() from primary map as its value
         Map<Long,Integer> secondary = new HashMap(); //can be normal java map, or MapDB map

File: src/test/java/examples/Secondary_Values.java
Patch:
@@ -28,7 +28,7 @@ static class Person implements Serializable{
     }
 
     public static void main(String[] args) {
-        DB db = DBMaker.newMemoryDB().make();
+        DB db = DBMaker.memoryDB().make();
         //list if friends
         BTreeMap<Integer,Person> friends = db.getTreeMap("friends");
 

File: src/test/java/examples/Transactions.java
Patch:
@@ -18,7 +18,7 @@ public static void main(String[] args) {
 
         //Open Transaction Factory. DBMaker shares most options with single-transaction mode.
         TxMaker txMaker = DBMaker
-                .newMemoryDB()
+                .memoryDB()
                 .makeTxMaker();
 
         // Now open first transaction and get map from first transaction

File: src/test/java/examples/Transactions2.java
Patch:
@@ -10,7 +10,7 @@
 public class Transactions2 {
 
     public static void main(String[] args) {
-        TxMaker txMaker = DBMaker.newMemoryDB().makeTxMaker();
+        TxMaker txMaker = DBMaker.memoryDB().makeTxMaker();
 
         // Execute transaction within single block.
         txMaker.execute(new TxBlock(){

File: src/test/java/examples/TreeMap_Composite_Key.java
Patch:
@@ -39,7 +39,7 @@ public static void main(String[] args) {
 //        String[] streets = {"Main Street", "Shop Street", "Second Street", "Silver Strands"};
 //        int[] houseNums = {1,2,3,4,5,6,7,8,9,10};
 //
-//        DB db = DBMaker.newMemoryDB().make();
+//        DB db = DBMaker.memoryDB().make();
 //        //initialize map
 //        // note that it uses BTreeKeySerializer.TUPLE3 to minimise disk space used by Map
 //        ConcurrentNavigableMap<Fun.Tuple3, Integer> map =

File: src/test/java/examples/TreeMap_Performance_Tunning.java
Patch:
@@ -55,7 +55,7 @@ public static void main(String[] args) {
                 boolean valueOutsideOfNodes = (j==2);
 
                 DB db = DBMaker
-                        .newFileDB(new File("/mnt/big/adsasd"))
+                        .fileDB(new File("/mnt/big/adsasd"))
                         .deleteFilesAfterClose()
                         .closeOnJvmShutdown()
                         .transactionDisable()

File: src/test/java/examples/_HelloWorld.java
Patch:
@@ -18,7 +18,7 @@ public static void main(String[] args) throws IOException {
         //Configure and open database using builder pattern.
         //All options are available with code auto-completion.
         File dbFile = File.createTempFile("mapdb","db");
-        DB db = DBMaker.newFileDB(dbFile)
+        DB db = DBMaker.fileDB(dbFile)
                 .closeOnJvmShutdown()
                 .encryptionEnable("password")
                 .make();

File: src/test/java/examples/_TempMap.java
Patch:
@@ -15,7 +15,7 @@ public static void main(String[] args) {
 
         // open new empty map
         // DBMaker will create files in temporary folder and opens it
-        Map<String, String> map = DBMaker.newTempTreeMap();
+        Map<String, String> map = DBMaker.tempTreeMap();
 
         //put some stuff into map
         //all data are stored in file in temp folder

File: src/test/java/org/mapdb/AsyncWriteEngineTest.java
Patch:
@@ -29,7 +29,7 @@ public class AsyncWriteEngineTest{
         if(engine !=null)
            engine.close();
         engine =  new AsyncWriteEngine(
-                DBMaker.newFileDB(index).transactionDisable().cacheDisable().makeEngine()
+                DBMaker.fileDB(index).transactionDisable().cacheDisable().makeEngine()
         );
     }
 
@@ -128,7 +128,7 @@ public <A> void  update(long recid, A value, Serializer<A> serializer) {
         a.close();
 
         //now reopen db and check ths
-        t = (StoreWAL) DBMaker.newFileDB(index).cacheDisable().makeEngine();
+        t = (StoreWAL) DBMaker.fileDB(index).cacheDisable().makeEngine();
         a = new AsyncWriteEngine(t);
         for(Long recid : l){
             assertArrayEquals(b, (byte[]) a.get(recid, Serializer.BASIC));

File: src/test/java/org/mapdb/AtomicBooleanTest.java
Patch:
@@ -16,7 +16,7 @@ public class AtomicBooleanTest extends TestCase{
 
     @Override
     protected void setUp() throws Exception {
-        db = DBMaker.newMemoryDB().transactionDisable().make();
+        db = DBMaker.memoryDB().transactionDisable().make();
         ai= db.createAtomicBoolean("test", true);;
     }
 

File: src/test/java/org/mapdb/AtomicIntegerTest.java
Patch:
@@ -16,7 +16,7 @@ public class AtomicIntegerTest extends TestCase {
 
     @Override
     protected void setUp() throws Exception {
-        db = DBMaker.newMemoryDB().transactionDisable().make();
+        db = DBMaker.memoryDB().transactionDisable().make();
         ai = db.createAtomicInteger("test", 1);
     }
 

File: src/test/java/org/mapdb/AtomicLongTest.java
Patch:
@@ -15,7 +15,7 @@ public class AtomicLongTest extends TestCase {
 
     @Override
     protected void setUp() throws Exception {
-        db = DBMaker.newMemoryDB().transactionDisable().make();
+        db = DBMaker.memoryDB().transactionDisable().make();
         ai = db.createAtomicLong("test", 1);
     }
 
@@ -204,7 +204,7 @@ public void testDoubleValue() {
 
 
     public void testTX(){
-        TxMaker txMaker = DBMaker.newMemoryDB().makeTxMaker();
+        TxMaker txMaker = DBMaker.memoryDB().makeTxMaker();
 
         DB db = txMaker.makeTx();
         System.out.println(db.getAtomicLong("counter").incrementAndGet());

File: src/test/java/org/mapdb/BTreeKeySerializerTest.java
Patch:
@@ -15,7 +15,7 @@
 public class BTreeKeySerializerTest {
 
     @Test public void testLong(){
-        DB db = DBMaker.newMemoryDB()
+        DB db = DBMaker.memoryDB()
                 .transactionDisable()
                 .make();
         Map m = db.createTreeMap("test")
@@ -73,7 +73,7 @@ void checkKeyClone(BTreeKeySerializer ser, Object[] keys) throws IOException {
     @Test public void testString(){
 
 
-        DB db = DBMaker.newMemoryDB()
+        DB db = DBMaker.memoryDB()
                 .transactionDisable()
                 .make();
         Map m =  db.createTreeMap("test")

File: src/test/java/org/mapdb/BTreeMapContainsKeyTest.java
Patch:
@@ -27,7 +27,7 @@ public static class OutsideNot extends BTreeMapContainsKeyTest{
 
     @Override
     protected void setUp() throws Exception {
-        r = DBMaker.newMemoryDB().transactionDisable().makeEngine();
+        r = DBMaker.memoryDB().transactionDisable().makeEngine();
         map = new BTreeMap(
                 r,false,
                 createRootRef(r,BASIC, Serializer.BASIC,0),

File: src/test/java/org/mapdb/BTreeMapExtendTest.java
Patch:
@@ -65,13 +65,13 @@ public class BTreeMapExtendTest extends TestCase {
     Object objArray[] = new Object[1000];
 
     protected BTreeMap newBTreeMap() {
-        return DBMaker.newMemoryDB().transactionDisable().make().getTreeMap("Test");
+        return DBMaker.memoryDB().transactionDisable().make().getTreeMap("Test");
     }
 
 
     public static class Outside extends BTreeMapExtendTest{
         @Override protected BTreeMap newBTreeMap() {
-            return DBMaker.newMemoryDB().transactionDisable().make()
+            return DBMaker.memoryDB().transactionDisable().make()
                     .createTreeMap("Test").valuesOutsideNodesEnable().make();
         }
 

File: src/test/java/org/mapdb/BTreeMapNavigable2Test.java
Patch:
@@ -32,13 +32,13 @@ protected void tearDown() throws Exception {
     }
 
     protected NavigableMap<Integer, String> newMap() {
-        return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("map").make();
+        return DBMaker.memoryDB().transactionDisable().make().createTreeMap("map").make();
     }
 
 
     public static class Outside extends BTreeMapNavigable2Test{
         @Override protected NavigableMap<Integer, String> newMap() {
-            return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("map").valuesOutsideNodesEnable().make();
+            return DBMaker.memoryDB().transactionDisable().make().createTreeMap("map").valuesOutsideNodesEnable().make();
         }
     }
 

File: src/test/java/org/mapdb/BTreeMapNavigableSubMapExclusiveTest.java
Patch:
@@ -6,7 +6,7 @@ public class BTreeMapNavigableSubMapExclusiveTest extends BTreeMapNavigable2Test
 
     public static class Outside extends BTreeMapNavigableSubMapExclusiveTest{
         @Override protected NavigableMap<Integer, String> newMap() {
-            return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("map").valuesOutsideNodesEnable()
+            return DBMaker.memoryDB().transactionDisable().make().createTreeMap("map").valuesOutsideNodesEnable()
                     .make();
         }
 

File: src/test/java/org/mapdb/BTreeMapNavigableSubMapInclusiveTest.java
Patch:
@@ -6,7 +6,7 @@ public class BTreeMapNavigableSubMapInclusiveTest extends BTreeMapNavigable2Test
 
     public static class Outside extends BTreeMapNavigableSubMapInclusiveTest{
         @Override protected NavigableMap<Integer, String> newMap() {
-            return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("map").valuesOutsideNodesEnable().make();
+            return DBMaker.memoryDB().transactionDisable().make().createTreeMap("map").valuesOutsideNodesEnable().make();
         }
     }
 

File: src/test/java/org/mapdb/BTreeMapNavigableTest.java
Patch:
@@ -77,12 +77,12 @@ public class BTreeMapNavigableTest extends TestCase {
 
 
     protected NavigableMap<String, String> newMap() {
-            return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("map").make();
+            return DBMaker.memoryDB().transactionDisable().make().createTreeMap("map").make();
     }
 
     public static class Outside extends BTreeMapNavigableTest{
         @Override protected NavigableMap<String, String> newMap() {
-            return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("map").valuesOutsideNodesEnable().make();
+            return DBMaker.memoryDB().transactionDisable().make().createTreeMap("map").valuesOutsideNodesEnable().make();
         }
     }
 

File: src/test/java/org/mapdb/BTreeMapParTest.java
Patch:
@@ -17,7 +17,7 @@ public class BTreeMapParTest {
     public void parInsert() throws InterruptedException {
 
 
-        final ConcurrentMap m = DBMaker.newMemoryDB().transactionDisable().make()
+        final ConcurrentMap m = DBMaker.memoryDB().transactionDisable().make()
                 .createTreeMap("test")
                 .valueSerializer(Serializer.LONG)
                 .keySerializer(BTreeKeySerializer.LONG)

File: src/test/java/org/mapdb/BTreeMapSubSetTest.java
Patch:
@@ -41,7 +41,7 @@ private NavigableSet<Integer> populatedSet(int n) {
     }
 
     protected <E> NavigableSet<E> newNavigableSet() {
-        return DBMaker.newMemoryDB().transactionDisable()
+        return DBMaker.memoryDB().transactionDisable()
                 .make().getTreeSet("test");
     }
 

File: src/test/java/org/mapdb/BTreeMapTest3.java
Patch:
@@ -38,13 +38,13 @@ protected String getSecondValueNotInPopulatedMap() throws UnsupportedOperationEx
 
     @Override
     protected ConcurrentNavigableMap<Integer, String> makeEmptyMap() throws UnsupportedOperationException {
-        return DBMaker.newMemoryDB().transactionDisable().make().getTreeMap("test");
+        return DBMaker.memoryDB().transactionDisable().make().getTreeMap("test");
     }
 
     public static class Outside extends BTreeMapTest3{
         @Override
         protected ConcurrentNavigableMap<Integer, String> makeEmptyMap() throws UnsupportedOperationException {
-            return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("test").valuesOutsideNodesEnable().make();
+            return DBMaker.memoryDB().transactionDisable().make().createTreeMap("test").valuesOutsideNodesEnable().make();
         }
 
     }

File: src/test/java/org/mapdb/BTreeMapTest5.java
Patch:
@@ -14,12 +14,12 @@ public class BTreeMapTest5 extends JSR166TestCase {
     public static class Outside extends BTreeMapTest5{
         @Override
         protected BTreeMap newMap() {
-            return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("test").valuesOutsideNodesEnable().make();
+            return DBMaker.memoryDB().transactionDisable().make().createTreeMap("test").valuesOutsideNodesEnable().make();
         }
     }
 
     protected  BTreeMap newMap() {
-        return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("test").make();
+        return DBMaker.memoryDB().transactionDisable().make().createTreeMap("test").make();
     }
 
 

File: src/test/java/org/mapdb/BTreeMapTest6.java
Patch:
@@ -31,12 +31,12 @@ ConcurrentNavigableMap map5() {
     }
 
     protected BTreeMap newEmptyMap() {
-        return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("test").make();
+        return DBMaker.memoryDB().transactionDisable().make().createTreeMap("test").make();
     }
 
     public static class Outside extends BTreeMapTest6{
         @Override protected BTreeMap newEmptyMap() {
-            return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("test").valuesOutsideNodesEnable().make();
+            return DBMaker.memoryDB().transactionDisable().make().createTreeMap("test").valuesOutsideNodesEnable().make();
         }
 
     }

File: src/test/java/org/mapdb/BindTest.java
Patch:
@@ -20,7 +20,7 @@ public class BindTest {
 
     @Before
     public void init(){
-        m = DBMaker.newMemoryDB().transactionDisable().make().getTreeMap("test");
+        m = DBMaker.memoryDB().transactionDisable().make().getTreeMap("test");
     }
 
 
@@ -133,11 +133,11 @@ public String[] run(Integer integer, String s) {
     }
 
     @Test public void htreemap_listeners(){
-        mapListeners(DBMaker.newMemoryDB().transactionDisable().make().getHashMap("test"));
+        mapListeners(DBMaker.memoryDB().transactionDisable().make().getHashMap("test"));
     }
 
     @Test public void btreemap_listeners(){
-        mapListeners(DBMaker.newMemoryDB().transactionDisable().make().getTreeMap("test"));
+        mapListeners(DBMaker.memoryDB().transactionDisable().make().getTreeMap("test"));
     }
 
 

File: src/test/java/org/mapdb/CacheWeakSoftRefTest.java
Patch:
@@ -14,7 +14,7 @@ public class CacheWeakSoftRefTest {
     @Test
     public void weak_htree_inserts_delete() throws InterruptedException {
         DB db = DBMaker
-                .newMemoryDB()
+                .memoryDB()
                 .cacheWeakRefEnable()
                 .make();
         testMap(db);
@@ -23,7 +23,7 @@ public void weak_htree_inserts_delete() throws InterruptedException {
     @Test
     public void soft_htree_inserts_delete() throws InterruptedException {
         DB db = DBMaker
-                .newMemoryDB()
+                .memoryDB()
                 .cacheSoftRefEnable()
                 .make();
         testMap(db);

File: src/test/java/org/mapdb/CompressTest.java
Patch:
@@ -14,7 +14,7 @@ public class CompressTest{
 
     @Before public void init(){
         db = DBMaker
-                .newMemoryDB()
+                .memoryDB()
                 .transactionDisable()
                 .compressionEnable()
                 .make();

File: src/test/java/org/mapdb/HTreeSetTest.java
Patch:
@@ -137,7 +137,7 @@ public void close(){
 
 
     @Test public void issue116_isEmpty(){
-        Set s = DBMaker.newFileDB(UtilsTest.tempDbFile())
+        Set s = DBMaker.fileDB(UtilsTest.tempDbFile())
                 .transactionDisable()
                 .make()
                 .getHashSet("name");

File: src/test/java/org/mapdb/Issue112Test.java
Patch:
@@ -10,7 +10,7 @@ public class Issue112Test {
 
         @Test(timeout=10000)
         public void testDoubleCommit() throws Exception {
-            final DB myTestDataFile = DBMaker.newFileDB(UtilsTest.tempDbFile())
+            final DB myTestDataFile = DBMaker.fileDB(UtilsTest.tempDbFile())
                     .checksumEnable()
                     .make();
             myTestDataFile.commit();

File: src/test/java/org/mapdb/Issue114Test.java
Patch:
@@ -7,7 +7,7 @@ public class Issue114Test {
 
     @Test
     public void test(){
-        DB db = DBMaker.newTempFileDB()
+        DB db = DBMaker.tempFileDB()
                 //.randomAccessFileEnable()
                 .transactionDisable().make();
         db.getCircularQueue("test");

File: src/test/java/org/mapdb/Issue132Test.java
Patch:
@@ -28,7 +28,7 @@ public  void test_full() {
         for(int count = 0; count < 50; count++) {
 
 
-            DB db = DBMaker.newMemoryDB()
+            DB db = DBMaker.memoryDB()
                     .checksumEnable().make();
 
 
@@ -66,7 +66,7 @@ public  void test_isolate() {
         int count = 18;
 
 
-        DB db = DBMaker.newMemoryDB()
+        DB db = DBMaker.memoryDB()
                 .checksumEnable().make();
 
 

File: src/test/java/org/mapdb/Issue150Test.java
Patch:
@@ -13,9 +13,9 @@ public class Issue150Test {
 
     @Test
     public void test() {
-        // TxMaker txMaker = DBMaker.newFileDB(new File("/tmp/mapdb.test"))
+        // TxMaker txMaker = DBMaker.fileDB(new File("/tmp/mapdb.test"))
         // .closeOnJvmShutdown().asyncWriteDisable().makeTxMaker();
-        TxMaker txMaker = DBMaker.newMemoryDB().closeOnJvmShutdown()
+        TxMaker txMaker = DBMaker.memoryDB().closeOnJvmShutdown()
                 .makeTxMaker();
 
         DB db = txMaker.makeTx();

File: src/test/java/org/mapdb/Issue154Test.java
Patch:
@@ -11,7 +11,7 @@ public class Issue154Test {
 
     @Test
     public void HTreeMap(){
-        TxMaker txMaker = DBMaker.newMemoryDB().makeTxMaker();
+        TxMaker txMaker = DBMaker.memoryDB().makeTxMaker();
 
         /* Add the item */
 
@@ -47,7 +47,7 @@ public void HTreeMap(){
     }
 
     @Test public void simple(){
-        TxMaker txMaker = DBMaker.newMemoryDB().makeTxMaker();
+        TxMaker txMaker = DBMaker.memoryDB().makeTxMaker();
         Engine engine = txMaker.makeTx().getEngine();
         long recid = engine.put("aa",Serializer.STRING_NOSIZE);
         engine.commit();
@@ -63,7 +63,7 @@ public void HTreeMap(){
 
     @Test
     public void BTreeMap(){
-        TxMaker txMaker = DBMaker.newMemoryDB().makeTxMaker();
+        TxMaker txMaker = DBMaker.memoryDB().makeTxMaker();
 
         /* Add the item */
 

File: src/test/java/org/mapdb/Issue157Test.java
Patch:
@@ -10,7 +10,7 @@ public class Issue157Test {
 
     @Test
     public void concurrent_BTreeMap() throws InterruptedException {
-        DB db = DBMaker.newMemoryDB().make();
+        DB db = DBMaker.memoryDB().make();
         final BTreeMap<Integer, String> map = db.getTreeMap("COL_2");
         map.clear();
 

File: src/test/java/org/mapdb/Issue164Test.java
Patch:
@@ -80,7 +80,7 @@ public void main() {
         int rc = 0;
         BTreeMap map=null;
         try {
-            DB db = DBMaker.newMemoryDB()
+            DB db = DBMaker.memoryDB()
                     .closeOnJvmShutdown()
                     .make();
 // the following test shows that the db is opened if it always exists

File: src/test/java/org/mapdb/Issue170Test.java
Patch:
@@ -10,7 +10,7 @@ public class Issue170Test {
 
     @Test
     public void test(){
-        Map m = DBMaker.newMemoryDB()
+        Map m = DBMaker.memoryDB()
                 .compressionEnable()
                 .transactionDisable()
                 .make().createTreeMap("test").make();

File: src/test/java/org/mapdb/Issue183Test.java
Patch:
@@ -17,7 +17,7 @@ public void main(){
         Map<String, String> map1;
 
         TxMaker txMaker = DBMaker
-                .newFileDB(f)
+                .fileDB(f)
                 .closeOnJvmShutdown()
                 .makeTxMaker();
 
@@ -34,7 +34,7 @@ public void main(){
 
 
         txMaker = DBMaker
-                .newFileDB(f)
+                .fileDB(f)
                 .closeOnJvmShutdown()
                 .makeTxMaker();
 

File: src/test/java/org/mapdb/Issue198Test.java
Patch:
@@ -8,7 +8,7 @@ public class Issue198Test {
 
     @Test public void main() {
 
-        DB db = DBMaker.newFileDB(UtilsTest.tempDbFile())
+        DB db = DBMaker.fileDB(UtilsTest.tempDbFile())
                 .closeOnJvmShutdown()
                 //.randomAccessFileEnable()
                 .make();

File: src/test/java/org/mapdb/Issue241.java
Patch:
@@ -28,7 +28,7 @@ public void main()
     private static DB getDb()
     {
         final File dbFile = UtilsTest.tempDbFile();
-        return DBMaker.newAppendFileDB(dbFile).make();
+        return DBMaker.appendFileDB(dbFile).make();
     }
 
     private static final class CustomClass implements Serializable

File: src/test/java/org/mapdb/Issue247Test.java
Patch:
@@ -19,7 +19,7 @@ private Map getMap(DB db){
     @Test
     public void test(){
         File f = UtilsTest.tempDbFile();
-        DB db = DBMaker.newFileDB(f)
+        DB db = DBMaker.fileDB(f)
                 .transactionDisable()
                 .make();
 
@@ -28,7 +28,7 @@ public void test(){
 
         db.close();
 
-        db = DBMaker.newFileDB(f)
+        db = DBMaker.fileDB(f)
                 .readOnly()
                 .make();
         getMap(db).size();

File: src/test/java/org/mapdb/Issue249Test.java
Patch:
@@ -10,7 +10,7 @@ public class Issue249Test {
 
     @Test
     public void main() {
-        TxMaker txMaker = DBMaker.newMemoryDB().closeOnJvmShutdown()
+        TxMaker txMaker = DBMaker.memoryDB().closeOnJvmShutdown()
                 .makeTxMaker();
         DB db = txMaker.makeTx();
 

File: src/test/java/org/mapdb/Issue258Test.java
Patch:
@@ -17,7 +17,7 @@ public void test() throws IOException {
 
 
         for(int i=0;i<10;i++){
-        DB db = DBMaker.newFileDB(tmp)
+        DB db = DBMaker.fileDB(tmp)
                 .mmapFileEnable()
 //                .closeOnJvmShutdown()
 //                .compressionEnable()

File: src/test/java/org/mapdb/Issue265Test.java
Patch:
@@ -9,7 +9,7 @@ public class Issue265Test {
 
     @Test
     public void compact(){
-            DB db = DBMaker.newMemoryDB()
+            DB db = DBMaker.memoryDB()
                 .transactionDisable()
                 .make(); // breaks functionality even in version 0.9.7
 
@@ -27,7 +27,7 @@ public void compact(){
 
     @Test
     public void compact_no_tx(){
-            DB db = DBMaker.newMemoryDB().make();
+            DB db = DBMaker.memoryDB().make();
 
             Map<Integer, String> map = db.getHashMap("HashMap");
             map.put(1, "one");

File: src/test/java/org/mapdb/Issue266Test.java
Patch:
@@ -41,7 +41,7 @@ public class Issue266Test {
     public void testEnum() throws IOException {
 
         File f = File.createTempFile("mapdb","asdas");
-        DB db = DBMaker.newFileDB(f).make();
+        DB db = DBMaker.fileDB(f).make();
 
         AdvancedEnum testEnumValue = AdvancedEnum.C;
 
@@ -53,7 +53,7 @@ public void testEnum() throws IOException {
 
         db.close();
 
-        db = DBMaker.newFileDB(f).make();
+        db = DBMaker.fileDB(f).make();
 
         set = db.createTreeSet("set").makeOrGet();
         AdvancedEnum enumValue = (AdvancedEnum)set.iterator().next();
@@ -68,7 +68,7 @@ public void testEnum() throws IOException {
         assertEquals(AdvancedEnum.A, AdvancedEnum.class.getEnumConstants()[0]);
 
 
-        DB db = DBMaker.newMemoryDB().make();
+        DB db = DBMaker.memoryDB().make();
         AdvancedEnum a = (AdvancedEnum) UtilsTest.clone(AdvancedEnum.A, db.getDefaultSerializer());
         assertEquals(a.toString(),AdvancedEnum.A.toString());
         assertEquals(a.ordinal(),AdvancedEnum.A.ordinal());

File: src/test/java/org/mapdb/Issue308Test.java
Patch:
@@ -9,7 +9,7 @@ public class Issue308Test {
 
     @Test
     public void test() {
-        DB db = DBMaker.newTempFileDB()
+        DB db = DBMaker.tempFileDB()
                 .mmapFileEnableIfSupported()
                 .compressionEnable()
                 .transactionDisable()

File: src/test/java/org/mapdb/Issue312Test.java
Patch:
@@ -11,7 +11,7 @@ public class Issue312Test {
     @Test
     public void test() throws IOException{
         File f = File.createTempFile("mapdb","test");
-        DB db = DBMaker.newFileDB(f)
+        DB db = DBMaker.fileDB(f)
                 .mmapFileEnableIfSupported()
                 .transactionDisable()
                 .make();
@@ -23,7 +23,7 @@ public void test() throws IOException{
         db.commit();
         db.close();
 
-        db = DBMaker.newFileDB(f)
+        db = DBMaker.fileDB(f)
                 .mmapFileEnableIfSupported()
                 .transactionDisable()
                 .readOnly()

File: src/test/java/org/mapdb/Issue321Test.java
Patch:
@@ -11,7 +11,7 @@ public class Issue321Test {
     @Test
     public void npe(){
 
-        DB db = DBMaker.newMemoryDB().make();
+        DB db = DBMaker.memoryDB().make();
 
         List l = Arrays.asList(19,10,9,8,2);
 

File: src/test/java/org/mapdb/Issue332Test.java
Patch:
@@ -67,7 +67,7 @@ public int fixedSize() {
     @Test
     public void run() throws IOException {
         File f = File.createTempFile("mapdb","mapdb");
-        DB db = DBMaker.newFileDB(f)
+        DB db = DBMaker.fileDB(f)
                 .closeOnJvmShutdown()
                 .make();
 
@@ -84,7 +84,7 @@ public void run() throws IOException {
         testMap = null;
 
         //-------------------------
-        db = DBMaker.newFileDB(f)
+        db = DBMaker.fileDB(f)
                 .closeOnJvmShutdown()
                 .make();
         testMap = db.createHashMap("testmap")

File: src/test/java/org/mapdb/Issue353Test.java
Patch:
@@ -25,7 +25,7 @@ public class Issue353Test {
 
     @Before
     public void setupDb() {
-        db = DBMaker.newFileDB(UtilsTest.tempDbFile()).closeOnJvmShutdown().mmapFileEnableIfSupported()
+        db = DBMaker.fileDB(UtilsTest.tempDbFile()).closeOnJvmShutdown().mmapFileEnableIfSupported()
                 .commitFileSyncDisable().transactionDisable().compressionEnable().freeSpaceReclaimQ(0).make();
         HTreeMapMaker maker = db.createHashMap("products")
                 .valueSerializer(Serializer.BYTE_ARRAY)

File: src/test/java/org/mapdb/Issue37Test.java
Patch:
@@ -17,7 +17,7 @@ public class Issue37Test {
 
     @Test public void test3(){
 
-        DB db = DBMaker.newMemoryDirectDB().transactionDisable().asyncWriteFlushDelay(100).make();
+        DB db = DBMaker.memoryDirectDB().transactionDisable().asyncWriteFlushDelay(100).make();
         ConcurrentMap<Long, Long> orders = db.createHashMap("order").make();
         for(int i = 0; i < 10000; i++) {
             orders.put((long)i, (long)i);

File: src/test/java/org/mapdb/Issue381Test.java
Patch:
@@ -17,7 +17,7 @@ public void testCorruption()
 
         for(int j=0;j<10;j++) {
             final int INSTANCES = 1000;
-            TxMaker txMaker  = DBMaker.newFileDB(f).makeTxMaker();
+            TxMaker txMaker  = DBMaker.fileDB(f).makeTxMaker();
           
             DB tx = txMaker.makeTx();
             byte[] data = new byte[128];

File: src/test/java/org/mapdb/Issue400Test.java
Patch:
@@ -13,7 +13,7 @@ public class Issue400Test {
     public void expire_maxSize_with_TTL() throws InterruptedException {
         File f = UtilsTest.tempDbFile();
         for (int o = 0; o < 2; o++) {
-            final DB db = DBMaker.newFileDB(f).transactionDisable().make();
+            final DB db = DBMaker.fileDB(f).transactionDisable().make();
             final HTreeMap<Object, Object> map = db.createHashMap("foo")
                     .expireMaxSize(1000).expireAfterWrite(1, TimeUnit.DAYS)
                     .makeOrGet();
@@ -35,7 +35,7 @@ public void expire_maxSize_with_TTL() throws InterruptedException {
     public void expire_maxSize_with_TTL_short() throws InterruptedException {
         File f = UtilsTest.tempDbFile();
         for (int o = 0; o < 2; o++) {
-            final DB db = DBMaker.newFileDB(f).transactionDisable().make();
+            final DB db = DBMaker.fileDB(f).transactionDisable().make();
             final HTreeMap<Object, Object> map = db.createHashMap("foo")
                     .expireMaxSize(1000).expireAfterWrite(3, TimeUnit.SECONDS)
                     .makeOrGet();
@@ -59,7 +59,7 @@ public void expire_maxSize_with_TTL_short() throws InterruptedException {
     public void expire_maxSize_with_TTL_get() throws InterruptedException {
         File f = UtilsTest.tempDbFile();
         for (int o = 0; o < 2; o++) {
-            final DB db = DBMaker.newFileDB(f).transactionDisable().make();
+            final DB db = DBMaker.fileDB(f).transactionDisable().make();
             final HTreeMap<Object, Object> map = db.createHashMap("foo")
                     .expireMaxSize(1000).expireAfterAccess(3, TimeUnit.SECONDS)
                     .makeOrGet();

File: src/test/java/org/mapdb/Issue418Test.java
Patch:
@@ -17,7 +17,7 @@ public void test(){
         long[] expireHeads = null;
         long[] expireTails = null;
         for (int o = 0; o < 2; o++) {
-            final DB db = DBMaker.newFileDB(tmp).transactionDisable().make();
+            final DB db = DBMaker.fileDB(tmp).transactionDisable().make();
             final HTreeMap<Object, Object> map = db.createHashMap("foo").expireMaxSize(100).makeOrGet();
 
             if(expireHeads!=null)
@@ -47,7 +47,7 @@ public void test_set(){
         final File tmp = UtilsTest.tempDbFile();
 
         for (int o = 0; o < 2; o++) {
-            final DB db = DBMaker.newFileDB(tmp).transactionDisable().make();
+            final DB db = DBMaker.fileDB(tmp).transactionDisable().make();
             final Set<Object> map = db.createHashSet("foo").expireMaxSize(100).makeOrGet();
 
             for (int i = 0; i < 1000; i++)

File: src/test/java/org/mapdb/Issue41Test.java
Patch:
@@ -34,7 +34,7 @@ public class Issue41Test {
     @Before
     public void setUp() {
         db =
-                DBMaker.newFileDB(DB_PATH)
+                DBMaker.fileDB(DB_PATH)
                         .cacheSoftRefEnable()
                         .closeOnJvmShutdown()
                         .deleteFilesAfterClose()

File: src/test/java/org/mapdb/Issue440Test.java
Patch:
@@ -8,21 +8,21 @@ public class Issue440Test {
 
     @Test
     public void first(){
-        DB db = DBMaker.newMemoryDB().make();
+        DB db = DBMaker.memoryDB().make();
 
         NavigableSet<Object[]> set1 = db.createTreeSet("set1")
                 .serializer(BTreeKeySerializer.ARRAY2)
                 .makeOrGet();
 
-        db = DBMaker.newMemoryDB().transactionDisable().make();
+        db = DBMaker.memoryDB().transactionDisable().make();
 
         NavigableSet<Object[]> set2 = db.createTreeSet("set2")
                 .serializer(BTreeKeySerializer.ARRAY2)
                 .makeOrGet();
     }
 
     @Test public void second(){
-        DB db = DBMaker.newTempFileDB().make();
+        DB db = DBMaker.tempFileDB().make();
 
         NavigableSet<Object[]> set1 = db.createTreeSet("set1")
                 .serializer(BTreeKeySerializer.ARRAY2)

File: src/test/java/org/mapdb/Issue69Test.java
Patch:
@@ -20,7 +20,7 @@ public class Issue69Test {
 
 	@Before
 	public void setUp() {
-		db = DBMaker.newTempFileDB()
+		db = DBMaker.tempFileDB()
 				.transactionDisable()
 				.checksumEnable()
 				.deleteFilesAfterClose()

File: src/test/java/org/mapdb/Issue77Test.java
Patch:
@@ -21,9 +21,9 @@ public void run(){
 
     DB open(boolean readOnly) {
         // This works:
-        // DBMaker maker = DBMaker.newFileDB(new File(dir + "/test"));
+        // DBMaker maker = DBMaker.fileDB(new File(dir + "/test"));
         // This is faster, but fails if read() is called for the second time:
-        DBMaker.Maker maker = DBMaker.newAppendFileDB(new File(dir + "/test"));
+        DBMaker.Maker maker = DBMaker.appendFileDB(new File(dir + "/test"));
         if (readOnly) {
             maker.readOnly();
         }

File: src/test/java/org/mapdb/Issue78Test.java
Patch:
@@ -23,7 +23,7 @@ public void tearDown() {
 
     @Test(expected = IOError.class, timeout = 10000)
     public void testIssue() {
-        DB db = DBMaker.newTempFileDB().make();
+        DB db = DBMaker.tempFileDB().make();
         HTreeMap<String, NotSerializable> usersMap = db.getHashMap("values");
         usersMap.put("thisKillsTheAsyncWriteThread", new NotSerializable());
         db.commit();

File: src/test/java/org/mapdb/Issue86Test.java
Patch:
@@ -12,7 +12,7 @@
 public class Issue86Test {
     public static DB createFileStore() {
         return DBMaker
-                .newTempFileDB()
+                .tempFileDB()
                 .transactionDisable()
                 .make();
     }

File: src/test/java/org/mapdb/Issue89Test.java
Patch:
@@ -58,7 +58,7 @@ private DB createMapDB(String fileName) {
 
 
         private DB createMapDB(File file) {
-            return DBMaker.newAppendFileDB(file)
+            return DBMaker.appendFileDB(file)
                     .closeOnJvmShutdown()
                     .make();
         }

File: src/test/java/org/mapdb/Issue90Test.java
Patch:
@@ -11,7 +11,7 @@ public void testCounter() throws Exception {
         File file = UtilsTest.tempDbFile();
 
 
-        final DB mapDb =DBMaker.newAppendFileDB(file)
+        final DB mapDb =DBMaker.appendFileDB(file)
                 .closeOnJvmShutdown()
                 .compressionEnable()  //This is the cause of the exception. If compression is not used, no exception occurs.
                 .make();

File: src/test/java/org/mapdb/IssuesTest.java
Patch:
@@ -7,7 +7,7 @@
 public class IssuesTest {
 
     @Test public void issue130(){
-        DB db = DBMaker.newAppendFileDB(UtilsTest.tempDbFile())
+        DB db = DBMaker.appendFileDB(UtilsTest.tempDbFile())
                 .closeOnJvmShutdown()
                 .make();
 

File: src/test/java/org/mapdb/MapListenerTest.java
Patch:
@@ -12,11 +12,11 @@
 public class MapListenerTest {
 
         @Test public void hashMap(){
-            tt(DBMaker.newMemoryDB().transactionDisable().cacheHashTableEnable().make().getHashMap("test"));
+            tt(DBMaker.memoryDB().transactionDisable().cacheHashTableEnable().make().getHashMap("test"));
         }
 
         @Test public void treeMap(){
-            tt(DBMaker.newMemoryDB().transactionDisable().cacheHashTableEnable().make().getTreeMap("test"));
+            tt(DBMaker.memoryDB().transactionDisable().cacheHashTableEnable().make().getTreeMap("test"));
         }
 
 

File: src/test/java/org/mapdb/PumpComparableValueTest.java
Patch:
@@ -18,7 +18,7 @@ public class PumpComparableValueTest {
          */
         @Test
         public void run(){
-                DB mapDBStore = DBMaker.newMemoryDB()
+                DB mapDBStore = DBMaker.memoryDB()
                                 .transactionDisable()
                                 .make();
 
@@ -64,7 +64,7 @@ public boolean hasNext() {
 
     @Test
     public void run2(){
-        DB db = DBMaker.newMemoryDB()
+        DB db = DBMaker.memoryDB()
                 .transactionDisable().make();
 
 

File: src/test/java/org/mapdb/Pump_InMemory_Import_Then_Save_To_Disk.java
Patch:
@@ -27,7 +27,7 @@ public static void main(String[] args) {
 //
 //        //now create on-disk store, it needs to be completely empty
 //        File targetFile = UtilsTest.tempDbFile();
-//        DB target = DBMaker.newFileDB(targetFile).make();
+//        DB target = DBMaker.fileDB(targetFile).make();
 //
 //        Pump.copy(inMemory, target);
 //

File: src/test/java/org/mapdb/StoreDirectFreeSpaceTest.java
Patch:
@@ -116,8 +116,8 @@
 //    }
 //
 //    @Test public void in_memory_compact(){
-//        for(DB d: Arrays.asList(DBMaker.newMemoryDB().cacheDisable().make(),
-//                DBMaker.newMemoryDB().transactionDisable().cacheDisable().make())){
+//        for(DB d: Arrays.asList(DBMaker.memoryDB().cacheDisable().make(),
+//                DBMaker.memoryDB().transactionDisable().cacheDisable().make())){
 //            Map m = d.getTreeMap("aa");
 //            for(Integer i=0;i<10000;i++){
 //                m.put(i,i*10);

File: src/test/java/org/mapdb/StoreDirectTest.java
Patch:
@@ -571,7 +571,7 @@ protected List<Long> getLongStack(long masterLinkOffset) {
         File f = UtilsTest.tempDbFile();
         File phys = new File(f.getPath());
 
-        DB db = DBMaker.newFileDB(f).transactionDisable().deleteFilesAfterClose().make();
+        DB db = DBMaker.fileDB(f).transactionDisable().deleteFilesAfterClose().make();
 
         db.getHashMap("test").put("aa","bb");
         db.commit();

File: src/test/java/org/mapdb/StoreTest.java
Patch:
@@ -11,7 +11,7 @@
 public class StoreTest {
 
     @Test public void compression(){
-        Store s = (Store)DBMaker.newMemoryDB()
+        Store s = (Store)DBMaker.memoryDB()
                 .transactionDisable()
                 .compressionEnable()
                 .makeEngine();
@@ -27,7 +27,7 @@ public class StoreTest {
         Random r = new Random();
 
         for(int i=100;i<100000;i=i*2){
-        Store s = (Store)DBMaker.newMemoryDB()
+        Store s = (Store)DBMaker.memoryDB()
                 .transactionDisable()
                 .compressionEnable()
                 .makeEngine();

File: src/test/java/org/mapdb/TxMakerTest.java
Patch:
@@ -18,7 +18,7 @@ public class TxMakerTest{
     @Before public void init(){
         tx  =
                 //new TxMaker(new TxEngine(new DB(new StoreHeap()).getEngine(),true));
-                DBMaker.newMemoryDB().makeTxMaker();
+                DBMaker.memoryDB().makeTxMaker();
     }
 
     @Test public void simple_commit(){
@@ -219,7 +219,7 @@ public void tx(DB db) throws TxRollbackException {
     public void txSnapshot(){
 
         TxMaker txMaker = DBMaker
-                .newMemoryDB()
+                .memoryDB()
                 .snapshotEnable()
                 .makeTxMaker();
 
@@ -236,7 +236,7 @@ public void txSnapshot(){
     public void txSnapshot2(){
 
         TxMaker txMaker = DBMaker
-                .newMemoryDB()
+                .memoryDB()
                 .snapshotEnable()
                 .makeTxMaker();
 

File: src/main/java/org/mapdb/DB.java
Patch:
@@ -121,7 +121,7 @@ public DB(
         this.deleteFilesAfterClose = deleteFilesAfterClose;
         this.executor = executor;
         this.sequentialLock = lockDisable ?
-                new Store.ReadWriteSingleLock(new Store.NoLock()) :
+                new Store.ReadWriteSingleLock(Store.NOLOCK) :
                 new ReentrantReadWriteLock();
 
         this.metricsExecutor = metricsExecutor==null ? executor : metricsExecutor;

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -348,7 +348,7 @@ public HTreeMap(
         this.segmentRecids = Arrays.copyOf(segmentRecids,16);
         this.keySerializer = keySerializer;
         this.valueSerializer = valueSerializer;
-        this.sequentialLock = sequentialLock==null? new Store.NoLock() : sequentialLock;
+        this.sequentialLock = sequentialLock==null? Store.NOLOCK : sequentialLock;
 
         if(expire==0 && expireAccess!=0){
             expire = expireAccess;

File: src/main/java/org/mapdb/StoreHeap.java
Patch:
@@ -40,7 +40,7 @@ public StoreHeap(boolean txDisabled, int lockScale, int lockingStrategy){
         }
 
         newRecidLock = lockingStrategy==LOCKING_STRATEGY_NOLOCK?
-                new NoLock() : new ReentrantLock(CC.FAIR_LOCKS);
+               NOLOCK : new ReentrantLock(CC.FAIR_LOCKS);
         freeRecid = new long[16];
         freeRecidTail=0;
 

File: src/main/java/org/mapdb/DB.java
Patch:
@@ -1876,10 +1876,12 @@ public void checkNameNotExists(String name) {
 
 
     /**
+     * <p>
      * Closes database.
      * All other methods will throw 'IllegalAccessError' after this method was called.
-     * <p>
+     * </p><p>
      * !! it is necessary to call this method before JVM exits!!
+     * </p>
      */
     synchronized public void close(){
         if(engine == null)

File: src/main/java/org/mapdb/DataIO.java
Patch:
@@ -810,7 +810,6 @@ public void unpackIntArray(int[] array, int start, int end) {
 
     /**
      * Provides {@link java.io.DataOutput} implementation on top of growable {@code byte[]}
-     * <p>
      *  {@link java.io.ByteArrayOutputStream} is not used as it requires {@code byte[]} copying
      *
      * @author Jan Kotek

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -37,7 +37,7 @@ public class StoreDirect extends Store {
     protected static final long HEAD_CHECKSUM = 4;
     protected static final long FORMAT_FEATURES = 8*1;
     protected static final long STORE_SIZE = 8*2;
-    /** offset of maximal allocated recid. It is <<3 parity1*/
+    /** offset of maximal allocated recid. It is {@code <<3 parity1}*/
     protected static final long MAX_RECID_OFFSET = 8*3;
     protected static final long LAST_PHYS_ALLOCATED_DATA_OFFSET = 8*4; //TODO update doc
     protected static final long INDEX_PAGE = 8*5;

File: src/main/java/org/mapdb/TxEngine.java
Patch:
@@ -25,9 +25,10 @@
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 /**
+ * <p>
  * Naive implementation of Snapshots on top of StorageEngine.
  * On update it takes old value and stores it aside.
- * <p>
+ * </p>
  * TODO merge snapshots down with Storage for best performance
  *
  * @author Jan Kotek

File: src/test/java/examples/TreeMap_Performance_Tunning.java
Patch:
@@ -7,7 +7,7 @@
 import java.util.Map;
 import java.util.Random;
 
-/**
+/*
  * Demonstrates how BTree parameters affects performance. BTreeMap has two key parameters
  * which affects its performance:
  * <h4>Maximal node size</h4>
@@ -22,7 +22,6 @@
  *
  *
  *
- * <p>
  * Sample output
  * <pre>
  *  Node size |  small vals  |  large vals  |  large vals outside node

File: src/test/java/org/mapdb/AsyncWriteEngineTest.java
Patch:
@@ -14,7 +14,7 @@
 
 import static org.junit.Assert.*;
 
-/**
+/*
 * @author Jan Kotek
 */
 /*

File: src/test/java/org/mapdb/BTreeMapContainsKeyTest.java
Patch:
@@ -40,7 +40,7 @@ public void close(){
         r.close();
     }
 
-    /**
+    /*
      * When valsOutsideNodes is true should not deserialize value during .containsKey
      */
     public void testContainsKeySkipsValueDeserialisation() {

File: src/test/java/org/mapdb/BTreeMapLargeValsTest.java
Patch:
@@ -1,4 +1,4 @@
-/*******************************************************************************
+/******************************************************************************
  * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: src/test/java/org/mapdb/BTreeMapNavigableTest.java
Patch:
@@ -49,7 +49,7 @@
 import java.util.*;
 import java.util.Map.Entry;
 
-/**
+/*
  * to test {@link java.util.NavigableMap} implementation
  * 
  * @author luc peuvrier

File: src/test/java/org/mapdb/BTreeMapTest2.java
Patch:
@@ -1,4 +1,4 @@
-/*******************************************************************************
+/******************************************************************************
  * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: src/test/java/org/mapdb/BTreeMapTest3.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.*;
 import java.util.concurrent.ConcurrentNavigableMap;
 
-/**
+/*
  * This code comes from GoogleCollections, was modified for JDBM by Jan Kotek
  *
  * Tests representing the contract of {@link java.util.SortedMap}. Concrete subclasses of

File: src/test/java/org/mapdb/BrokenDBTest.java
Patch:
@@ -16,7 +16,7 @@ public void before() throws IOException {
         log = new File(index.getPath() + "wal.0");
     }
 
-    /**
+    /*
      * Verify that DB files are properly closed when opening the database fails, allowing an
      * application to recover by purging the database and starting over.
      *
@@ -48,7 +48,7 @@ public void canDeleteDBOnBrokenIndex() throws FileNotFoundException, IOException
         Assert.assertFalse("Can't delete log", log.exists());
     }
 
-    /**
+    /*
      * Verify that DB files are properly closed when opening the database fails, allowing an
      * application to recover by purging the database and starting over.
      *
@@ -101,7 +101,7 @@ public static class SomeDataObject implements Serializable {
         public int someField = 42;
     }
 
-    /**
+    /*
      * Verify that DB files are properly closed when opening the database fails, allowing an
      * application to recover by purging the database and starting over.
      *

File: src/test/java/org/mapdb/ClosedThrowsExceptionTest.java
Patch:
@@ -8,7 +8,7 @@
 
 import static org.junit.Assert.assertEquals;
 
-/**
+/*
  * check that `IllegalAccessError` is thrown after DB was closed
  */
 public abstract class ClosedThrowsExceptionTest {

File: src/test/java/org/mapdb/ConcurrentMapInterfaceTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.util.concurrent.ConcurrentMap;
 
-/**
+/*
  * Tests representing the contract of {@link ConcurrentMap}. Concrete
  * subclasses of this base class test conformance of concrete
  * {@link ConcurrentMap} subclasses to that contract.
@@ -39,7 +39,7 @@ protected ConcurrentMapInterfaceTest(boolean allowsNullKeys,
         supportsClear,supportsIteratorRemove, supportsEntrySetValue);
   }
 
-  /**
+  /*
    * Creates a new value that is not expected to be found in
    * {@link #makePopulatedMap()} and differs from the value returned by
    * {@link #getValueNotInPopulatedMap()}.

File: src/test/java/org/mapdb/EngineTest.java
Patch:
@@ -15,7 +15,7 @@
 import static org.junit.Assert.*;
 import static org.mapdb.Serializer.BYTE_ARRAY_NOSIZE;
 
-/**
+/*
  * Tests contract of various implementations of Engine interface
  */
 public abstract class EngineTest<ENGINE extends Engine>{
@@ -245,7 +245,7 @@ public void large_record(){
         assertEquals("aaa",e.get(recid, Serializer.STRING_NOSIZE));
     }
 
-    /** after deletion it enters preallocated state */
+    /* after deletion it enters preallocated state */
     @Test public void delete_and_get(){
         long recid = e.put("aaa", Serializer.STRING);
         e.delete(recid, Serializer.STRING);

File: src/test/java/org/mapdb/Exec.java
Patch:
@@ -4,7 +4,7 @@
 import java.util.List;
 import java.util.concurrent.*;
 
-/**
+/*
  *
  */
 public class Exec {

File: src/test/java/org/mapdb/HTreeMap3Test.java
Patch:
@@ -1,4 +1,4 @@
-/*******************************************************************************
+/******************************************************************************
  * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

File: src/test/java/org/mapdb/HTreeSetTest.java
Patch:
@@ -31,7 +31,7 @@
 import static org.junit.Assert.assertTrue;
 
 
-/**
+/*
  * Tests for HashSet which comes with JDBM. Original code comes from Apache Harmony,
  * Modified by Jan Kotek for use in JDBM
  */

File: src/test/java/org/mapdb/Issue148Test.java
Patch:
@@ -109,7 +109,7 @@ public static void dumpUserDB(HTreeMap<String, CustomValue> users){
         System.out.println("");
     }
 
-    /** Custom Value and Serializer **/
+    /* Custom Value and Serializer **/
 
     public static class CustomValue implements Serializable {
 

File: src/test/java/org/mapdb/Issue332Test.java
Patch:
@@ -7,7 +7,7 @@
 
 import static org.junit.Assert.assertEquals;
 
-/**
+/*
  * Created by paspi on 26.05.2014.
  */
 public class Issue332Test {

File: src/test/java/org/mapdb/Issue41Test.java
Patch:
@@ -9,7 +9,7 @@
 import java.util.UUID;
 import java.util.concurrent.*;
 
-/**
+/*
  * https://github.com/jankotek/MapDB/issues/41
  * @author Laurent Pellegrino
  *

File: src/test/java/org/mapdb/Issue69Test.java
Patch:
@@ -8,7 +8,7 @@
 
 import static org.junit.Assert.fail;
 
-/**
+/*
  * https://github.com/jankotek/MapDB/issues/69
  *
  * @author Konstantin Zadorozhny

File: src/test/java/org/mapdb/Issue78Test.java
Patch:
@@ -6,7 +6,7 @@
 
 import java.io.IOError;
 
-/**
+/*
  * https://github.com/jankotek/MapDB/issues/78
  *
  * @author Nandor Kracser

File: src/test/java/org/mapdb/Issue86Test.java
Patch:
@@ -5,7 +5,7 @@
 import java.io.Serializable;
 import java.util.Map;
 
-/**
+/*
  *
  * @author M.Y. Developers
  */

File: src/test/java/org/mapdb/JSR166TestCase.java
Patch:
@@ -4,7 +4,7 @@
 
 abstract public class JSR166TestCase extends TestCase {
 
-    /**
+    /*
      * The number of elements to place in collections, arrays, etc.
      */
     public static final int SIZE = 20;
@@ -29,7 +29,7 @@ abstract public class JSR166TestCase extends TestCase {
     public static final Integer m6  = new Integer(-6);
     public static final Integer m10 = new Integer(-10);
 
-    /**
+    /*
      * Fails with message "should throw exception".
      */
     public void shouldThrow() {

File: src/test/java/org/mapdb/PumpComparableValueTest.java
Patch:
@@ -12,7 +12,7 @@
 public class PumpComparableValueTest {
 
 
-        /**
+        /*
          * Test mapDB data pump mechanize 
          * 
          */

File: src/test/java/org/mapdb/Pump_InMemory_Import_Then_Save_To_Disk.java
Patch:
@@ -4,7 +4,7 @@
 import java.util.Map;
 import java.util.Random;
 
-/**
+/*
  * This demonstrates using Data Pump to first create store in-memory at maximal speed,
  * and than copy the store into memory
  */

File: src/test/java/org/mapdb/SerializerBaseTest.java
Patch:
@@ -1,4 +1,4 @@
-/*******************************************************************************
+/******************************************************************************
  * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -478,12 +478,12 @@ void serSize(int expected, Object val) throws IOException {
         }
     }
 
-    /** clone value using serialization */
+    /* clone value using serialization */
     <E> E clone(E value) throws IOException {
         return clone2(value,(Serializer<E>)Serializer.BASIC);
     }
 
-    /** clone value using serialization */
+    /* clone value using serialization */
     public static <E> E clone2(E value, Serializer<E> serializer) {
         try{
             DataIO.DataOutputByteArray out = new DataIO.DataOutputByteArray();

File: src/test/java/org/mapdb/SerializerPojoTest.java
Patch:
@@ -312,7 +312,7 @@ public int hashCode() {
         }
     }
 
-    /** @author Jan Sileny */
+    /* @author Jan Sileny */
 /* TODO reenable test
 @Test  public  void test_pojo_reload() throws IOException {
 
@@ -367,7 +367,7 @@ public static class test_transient implements Serializable{
         assertEquals(13,t.bb);
     }
 
-    /** clone value using serialization */
+    /* clone value using serialization */
     public static <E> E outputStreamClone(E value){
         try{
             ByteArrayOutputStream out = new ByteArrayOutputStream();

File: src/test/java/org/mapdb/StoreDirectFreeSpaceTest.java
Patch:
@@ -13,7 +13,7 @@
 //
 //    final Map<Long,Deque<Long>> longStacks = new TreeMap <Long,Deque<Long>>();
 //
-//    /** mock longStacks so their page allocations wont mess up tests */
+//    /* mock longStacks so their page allocations wont mess up tests */
 //    StoreDirect stub = new  StoreDirect(null){
 //        {
 //            structuralLock.lock();

File: src/test/java/org/mapdb/TestTransactions.java
Patch:
@@ -5,7 +5,7 @@
 
 import java.util.Map;
 
-/**
+/*
  *
  * @author Alan Franzoni
  */

File: src/test/java/org/mapdb/UtilsTest.java
Patch:
@@ -70,7 +70,7 @@ public void testNextPowTwo() throws Exception {
 
 
 
-    /** clone value using serialization */
+    /* clone value using serialization */
     public static <E> E clone(E value, Serializer<E> serializer){
         try{
             DataIO.DataOutputByteArray out = new DataIO.DataOutputByteArray();
@@ -108,7 +108,7 @@ public int fixedSize() {
         assertTrue(Serializer.BYTE_ARRAY.equals(b, DBMaker.fromHexa(DBMaker.toHexa(b))));
     }
 
-    /**
+    /*
      * Create temporary file in temp folder. All associated db files will be deleted on JVM exit.
      */
     public static File tempDbFile() {
@@ -136,7 +136,7 @@ public static String randomString(int size) {
         return b.toString();
     }
 
-    /** faster version of Random.nextBytes() */
+    /* faster version of Random.nextBytes() */
     public static byte[] randomByteArray(int size){
         int seed = (int) (100000*Math.random());
         byte[] ret = new byte[size];

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -915,12 +915,13 @@ public BTreeMap(
             //$DELAY$
             BNode n= engine.get(r,nodeSerializer);
             leftEdges2.add(r);
-            if(n.isLeaf()) break;
+            if(n.isLeaf())
+                break;
             r = n.child(0);
         }
         //$DELAY$
         Collections.reverse(leftEdges2);
-        leftEdges = new CopyOnWriteArrayList<Long>(leftEdges2);
+        leftEdges = Collections.synchronizedList(leftEdges2);
     }
 
     /** creates empty root node and returns recid of its reference*/

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -24,6 +24,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.ScheduledExecutorService;
@@ -63,7 +64,7 @@ public class StoreWAL extends StoreCached {
     protected final LongLongMap[] currDataLongs;
 
     protected final LongLongMap pageLongStack = new LongLongMap();
-    protected final List<Volume> volumes = new CopyOnWriteArrayList<Volume>();
+    protected final List<Volume> volumes = Collections.synchronizedList(new ArrayList<Volume>());
 
     /** WAL file sealed after compaction is completed, if no valid seal, compaction file should be destroyed */
     protected volatile Volume walC;
@@ -72,7 +73,7 @@ public class StoreWAL extends StoreCached {
     protected volatile Volume walCCompact;
 
     /** record WALs, store recid-record pairs. Created during compaction when memory allocator is not available */
-    protected final List<Volume> walRec = new CopyOnWriteArrayList<Volume>();
+    protected final List<Volume> walRec = Collections.synchronizedList(new ArrayList<Volume>());
 
     protected final ReentrantLock compactLock = new ReentrantLock(CC.FAIR_LOCKS);
     /** protected by commitLock */

File: src/test/java/org/mapdb/TxMakerTest.java
Patch:
@@ -136,7 +136,7 @@ public void increment() throws Throwable {
         DB db = tx.makeTx();
         final long recid = db.getEngine().put(1L,Serializer.LONG);
         db.commit();
-        final List<Throwable> ex = new CopyOnWriteArrayList<Throwable>();
+        final List<Throwable> ex = Collections.synchronizedList(new ArrayList<Throwable>());
         final CountDownLatch l = new CountDownLatch(threads);
         for(int i=0;i<threads;i++){
             new Thread(){
@@ -179,7 +179,7 @@ public void cas() throws Throwable {
         DB db = tx.makeTx();
         final long recid = db.getEngine().put(1L,Serializer.LONG);
         db.commit();
-        final List<Throwable> ex = new CopyOnWriteArrayList<Throwable>();
+        final List<Throwable> ex = Collections.synchronizedList(new ArrayList<Throwable>());
         final CountDownLatch l = new CountDownLatch(threads);
         for(int i=0;i<threads;i++){
             new Thread(){

File: src/main/java/org/mapdb/DB.java
Patch:
@@ -804,7 +804,7 @@ public <V> BTreeMap<String, V> makeStringMap() {
 
         /** creates map optimized for using zero or positive `Long` keys */
         public <V> BTreeMap<Long, V> makeLongMap() {
-            keySerializer = BTreeKeySerializer.ZERO_OR_POSITIVE_LONG;
+            keySerializer = BTreeKeySerializer.LONG;
             return make();
         }
 
@@ -894,7 +894,7 @@ public NavigableSet<String> makeStringSet() {
 
         /** creates set optimized for using zero or positive `Long` */
         public NavigableSet<Long> makeLongSet() {
-            serializer = BTreeKeySerializer.ZERO_OR_POSITIVE_LONG;
+            serializer = BTreeKeySerializer.LONG;
             return make();
         }
 

File: src/test/java/org/mapdb/BTreeMapTest.java
Patch:
@@ -604,7 +604,7 @@ public void run() {
     @Test public void randomStructuralCheck(){
         Random r = new Random();
         BTreeMap map = DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("aa")
-                .keySerializer(BTreeKeySerializer.ZERO_OR_POSITIVE_INT)
+                .keySerializer(BTreeKeySerializer.INTEGER)
                 .valueSerializer(Serializer.INTEGER)
                 .make();
 
@@ -631,7 +631,7 @@ public void large_node_size(){
             Map m = db
                     .createTreeMap("map")
                     .nodeSize(i)
-                    .keySerializer(BTreeKeySerializer.ZERO_OR_POSITIVE_INT)
+                    .keySerializer(BTreeKeySerializer.INTEGER)
                     .valueSerializer(Serializer.INTEGER)
                     .make();
 

File: src/test/java/org/mapdb/DBMakerTest.java
Patch:
@@ -209,7 +209,6 @@ public void reopen_wrong_checksum() throws IOException {
         db = DBMaker
                 .newFileDB(f)
                 .deleteFilesAfterClose()
-                .cacheDisable()
 
                 .checksumEnable()
                 .make();

File: src/test/java/org/mapdb/StoreCacheHashTableTest.java
Patch:
@@ -21,7 +21,8 @@ public class StoreCacheHashTableTest<E extends StoreDirect> extends EngineTest<E
                 false,
                 0,
                 false,
-                0
+                0,
+                null
                 );
         e.init();
         return (E)e;

File: src/test/java/org/mapdb/StoreDirectTest.java
Patch:
@@ -694,7 +694,8 @@ protected void clearEverything(){
                     CC.DEFAULT_LOCK_SCALE,
                     0,
                     false,false,null,false,0,
-                    false,0);
+                    false,0,
+                    null);
             s.init();
 
             //fill with some data

File: src/test/java/org/mapdb/StoreDirectTest2.java
Patch:
@@ -73,7 +73,7 @@ protected StoreDirect newStore() {
                 return vol;
             }
         };
-        StoreDirect st = new StoreDirect(null, fab, null, CC.DEFAULT_LOCK_SCALE, 0, false, false,null, false, 0,false,0);
+        StoreDirect st = new StoreDirect(null, fab, null, CC.DEFAULT_LOCK_SCALE, 0, false, false,null, false, 0,false,0, null);
         st.init();
 
         Map<Long,String> recids = new HashMap();
@@ -86,7 +86,7 @@ protected StoreDirect newStore() {
         //close would destroy Volume,so this will do
         st.commit();
 
-        st = new StoreDirect(null, fab, null, CC.DEFAULT_LOCK_SCALE, 0, false, false,null, false, 0,false,0);
+        st = new StoreDirect(null, fab, null, CC.DEFAULT_LOCK_SCALE, 0, false, false,null, false, 0,false,0, null);
         st.init();
 
         for(Map.Entry<Long,String> e:recids.entrySet()){

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -336,7 +336,8 @@ public HTreeMap(Engine engine, long counterRecid, int hashSalt, long[] segmentRe
         }
 
         expireSingleThreadFlag = (expireFlag && executor==null);
-        if(!expireSingleThreadFlag){
+
+        if(expireFlag && executor!=null){
             if(executor!=null) {
                 LOG.warning("HTreeMap Expiration should not be used with transaction enabled. It can lead to data corruption, commit might happen while background thread works, and only part of expiration data will be commited.");
             }

File: src/main/java/org/mapdb/CC.java
Patch:
@@ -89,7 +89,7 @@ public interface CC {
 
     int DEFAULT_CACHE_SIZE = 2048;
 
-    String DEFAULT_CACHE = DBMaker.Keys.cache_hashTable;
+    String DEFAULT_CACHE = DBMaker.Keys.cache_disable;
 
     int DEFAULT_FREE_SPACE_RECLAIM_Q = 5;
 

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -616,7 +616,9 @@ public void rollback() throws UnsupportedOperationException {
                 lock.lock();
                 try {
                     writeCache[segment].clear();
-                    caches[segment].clear();
+                    if(caches!=null) {
+                        caches[segment].clear();
+                    }
                 } finally {
                     lock.unlock();
                 }

File: src/test/java/org/mapdb/BTreeKeySerializerTest.java
Patch:
@@ -17,7 +17,6 @@ public class BTreeKeySerializerTest {
     @Test public void testLong(){
         DB db = DBMaker.newMemoryDB()
                 .transactionDisable()
-                .cacheDisable()
                 .make();
         Map m = db.createTreeMap("test")
                 .keySerializer(BTreeKeySerializer.LONG)
@@ -75,7 +74,6 @@ void checkKeyClone(BTreeKeySerializer ser, Object[] keys) throws IOException {
 
 
         DB db = DBMaker.newMemoryDB()
-                .cacheDisable()
                 .transactionDisable()
                 .make();
         Map m =  db.createTreeMap("test")

File: src/test/java/org/mapdb/BTreeMapContainsKeyTest.java
Patch:
@@ -27,7 +27,7 @@ public static class OutsideNot extends BTreeMapContainsKeyTest{
 
     @Override
     protected void setUp() throws Exception {
-        r = DBMaker.newMemoryDB().transactionDisable().cacheDisable().makeEngine();
+        r = DBMaker.newMemoryDB().transactionDisable().makeEngine();
         map = new BTreeMap(r, createRootRef(r,BASIC, Serializer.BASIC,0),
                 6, valsOutsideNodes, 0, BASIC, valueSerializer, 0);
     }

File: src/test/java/org/mapdb/BTreeMapExtendTest.java
Patch:
@@ -65,13 +65,13 @@ public class BTreeMapExtendTest extends TestCase {
     Object objArray[] = new Object[1000];
 
     protected BTreeMap newBTreeMap() {
-        return DBMaker.newMemoryDB().cacheDisable().transactionDisable().make().getTreeMap("Test");
+        return DBMaker.newMemoryDB().transactionDisable().make().getTreeMap("Test");
     }
 
 
     public static class Outside extends BTreeMapExtendTest{
         @Override protected BTreeMap newBTreeMap() {
-            return DBMaker.newMemoryDB().cacheDisable().transactionDisable().make()
+            return DBMaker.newMemoryDB().transactionDisable().make()
                     .createTreeMap("Test").valuesOutsideNodesEnable().make();
         }
 

File: src/test/java/org/mapdb/BTreeMapSubSetTest.java
Patch:
@@ -42,7 +42,6 @@ private NavigableSet<Integer> populatedSet(int n) {
 
     protected <E> NavigableSet<E> newNavigableSet() {
         return DBMaker.newMemoryDB().transactionDisable()
-                .cacheDisable()
                 .make().getTreeSet("test");
     }
 

File: src/test/java/org/mapdb/BTreeMapTest.java
Patch:
@@ -397,7 +397,7 @@ Object[] nodeKeysToArray(BTreeMap.BNode n){
         DB db = DBMaker.newMemoryDB().transactionDisable().make();
         final BTreeMap m = db.getTreeMap("name");
 
-        final long rootRecid = db.getEngine().get(m.rootRecidRef, Serializer.LONG);
+        final long rootRecid = db.getEngine().get(m.rootRecidRef, Serializer.RECID);
         final AtomicInteger counter = new AtomicInteger();
 
         m.modificationListenerAdd(new Bind.MapListener() {

File: src/test/java/org/mapdb/ClosedThrowsExceptionTest.java
Patch:
@@ -40,7 +40,7 @@ static public class Async extends ClosedThrowsExceptionTest{
 
     static public class NoCache extends ClosedThrowsExceptionTest{
         @Override DB db() {
-            return DBMaker.newMemoryDB().cacheDisable().make();
+            return DBMaker.newMemoryDB().make();
         }
     }
 

File: src/test/java/org/mapdb/CompressTest.java
Patch:
@@ -16,7 +16,6 @@ public class CompressTest{
         db = DBMaker
                 .newMemoryDB()
                 .transactionDisable()
-                .cacheDisable()
                 .compressionEnable()
                 .make();
     }

File: src/test/java/org/mapdb/DBTest.java
Patch:
@@ -117,7 +117,7 @@ public void testAtomicExists(){
 
     @Test
     public void test_issue_315() {
-        DB db = DBMaker.newMemoryDB().cacheDisable().make();
+        DB db = DBMaker.newMemoryDB().make();
 
         final String item1 = "ITEM_ONE";
         final String item2 = "ITEM_ONE_TWO";

File: src/test/java/org/mapdb/HTreeMap2Test.java
Patch:
@@ -22,7 +22,7 @@ public class HTreeMap2Test {
     DB db;
 
     @Before public void init2(){
-        engine = DBMaker.newMemoryDB().transactionDisable().cacheDisable().makeEngine();
+        engine = DBMaker.newMemoryDB().transactionDisable().makeEngine();
         db = new DB(engine);
     }
 
@@ -463,7 +463,6 @@ public void cache_load_time_expire(){
         DB db =
                 DBMaker.newMemoryDB()
                         .transactionDisable()
-                        .cacheDisable()
                         .make();
 
         HTreeMap m = db.createHashMap("test")
@@ -557,7 +556,7 @@ public void update(Object key, Object oldVal, Object newVal) {
     public void test_iterate_and_remove(){
         final long max= (long) 1e5;
 
-        Set m = DBMaker.newMemoryDB().cacheDisable().transactionDisable().make().getHashSet("test");
+        Set m = DBMaker.newMemoryDB().transactionDisable().make().getHashSet("test");
 
         for(long i=0;i<max;i++){
             m.add(i);

File: src/test/java/org/mapdb/Issue132Test.java
Patch:
@@ -28,7 +28,7 @@ public  void test_full() {
         for(int count = 0; count < 50; count++) {
 
 
-            DB db = DBMaker.newMemoryDB().cacheDisable()
+            DB db = DBMaker.newMemoryDB()
                     .checksumEnable().make();
 
 
@@ -66,7 +66,7 @@ public  void test_isolate() {
         int count = 18;
 
 
-        DB db = DBMaker.newMemoryDB().cacheDisable()
+        DB db = DBMaker.newMemoryDB()
                 .checksumEnable().make();
 
 

File: src/test/java/org/mapdb/Issue157Test.java
Patch:
@@ -10,7 +10,7 @@ public class Issue157Test {
 
     @Test
     public void concurrent_BTreeMap() throws InterruptedException {
-        DBMaker dbMaker = DBMaker.newMemoryDB().cacheDisable();
+        DBMaker dbMaker = DBMaker.newMemoryDB();
         DB db = dbMaker.make();
         final BTreeMap<Integer, String> map = db.getTreeMap("COL_2");
         map.clear();

File: src/test/java/org/mapdb/Issue183Test.java
Patch:
@@ -19,7 +19,6 @@ public void main(){
         TxMaker txMaker = DBMaker
                 .newFileDB(f)
                 .closeOnJvmShutdown()
-                .cacheDisable()
                 .makeTxMaker();
 
         DB db = txMaker.makeTx();
@@ -37,7 +36,6 @@ public void main(){
         txMaker = DBMaker
                 .newFileDB(f)
                 .closeOnJvmShutdown()
-                .cacheDisable()
                 .makeTxMaker();
 
         db = txMaker.makeTx();

File: src/test/java/org/mapdb/Issue89Test.java
Patch:
@@ -60,7 +60,6 @@ private DB createMapDB(String fileName) {
         private DB createMapDB(File file) {
             return DBMaker.newAppendFileDB(file)
                     .closeOnJvmShutdown()
-                    .cacheDisable()
                     .make();
         }
 

File: src/test/java/org/mapdb/Issue90Test.java
Patch:
@@ -14,8 +14,6 @@ public void testCounter() throws Exception {
         final DB mapDb =DBMaker.newAppendFileDB(file)
                 .closeOnJvmShutdown()
                 .compressionEnable()  //This is the cause of the exception. If compression is not used, no exception occurs.
-
-                .cacheDisable()
                 .make();
         final Atomic.Long myCounter = mapDb.getAtomicLong("MyCounter");
 

File: src/test/java/org/mapdb/MapListenerTest.java
Patch:
@@ -12,11 +12,11 @@
 public class MapListenerTest {
 
         @Test public void hashMap(){
-            tt(DBMaker.newMemoryDB().transactionDisable().make().getHashMap("test"));
+            tt(DBMaker.newMemoryDB().transactionDisable().cacheHashTableEnable().make().getHashMap("test"));
         }
 
         @Test public void treeMap(){
-            tt(DBMaker.newMemoryDB().transactionDisable().make().getTreeMap("test"));
+            tt(DBMaker.newMemoryDB().transactionDisable().cacheHashTableEnable().make().getTreeMap("test"));
         }
 
 

File: src/test/java/org/mapdb/SerializerPojoTest.java
Patch:
@@ -381,7 +381,7 @@ public static <E> E outputStreamClone(E value){
 
 
     @Test public void testIssue177() throws UnknownHostException {
-        DB db = DBMaker.newMemoryDB().cacheDisable().make();
+        DB db = DBMaker.newMemoryDB().make();
         InetAddress value = InetAddress.getByName("127.0.0.1");
         long recid = db.engine.put(value, db.getDefaultSerializer());
         Object value2 = db.engine.get(recid,db.getDefaultSerializer());

File: src/test/java/org/mapdb/StoreTest.java
Patch:
@@ -12,7 +12,6 @@ public class StoreTest {
 
     @Test public void compression(){
         Store s = (Store)DBMaker.newMemoryDB()
-                .cacheDisable()
                 .transactionDisable()
                 .compressionEnable()
                 .makeEngine();
@@ -29,7 +28,6 @@ public class StoreTest {
 
         for(int i=100;i<100000;i=i*2){
         Store s = (Store)DBMaker.newMemoryDB()
-                .cacheDisable()
                 .transactionDisable()
                 .compressionEnable()
                 .makeEngine();

File: src/main/java/org/mapdb/CC.java
Patch:
@@ -19,7 +19,7 @@
 /**
  * Compiler Configuration. There are some static final boolean fields, which describe features MapDB was compiled with.
  * <p>
- * MapDB can be compiled with/without some features. For example fine logging is useful for debuging,
+ * MapDB can be compiled with/without some features. For example fine logging is useful for debugging,
  * but should not be present in production version. Java does not have preprocessor so
  * we use <a href="http://en.wikipedia.org/wiki/Dead_code_elimination">Dead code elimination</a> to achieve it.
  * <p>

File: src/main/java/org/mapdb/DataIO.java
Patch:
@@ -57,7 +57,6 @@ static public long unpackLong(DataInput in) throws IOException {
 
 
     /**
-     * Pack long into output stream.
      * Pack long into output stream.
      * It will occupy 1-10 bytes depending on value (lower values occupy smaller space)
      *
@@ -79,7 +78,7 @@ static public void packLong(DataOutput out, long value) throws IOException {
     }
 
     /**
-     * Pack  int into output stream.
+     * Pack int into an output stream.
      * It will occupy 1-5 bytes depending on value (lower values occupy smaller space)
      *
      * This method originally comes from Kryo Framework, author Nathan Sweet.

File: src/main/java/org/mapdb/CC.java
Patch:
@@ -19,7 +19,7 @@
 /**
  * Compiler Configuration. There are some static final boolean fields, which describe features MapDB was compiled with.
  * <p>
- * MapDB can be compiled with/without some features. For example fine logging is useful for debuging,
+ * MapDB can be compiled with/without some features. For example fine logging is useful for debugging,
  * but should not be present in production version. Java does not have preprocessor so
  * we use <a href="http://en.wikipedia.org/wiki/Dead_code_elimination">Dead code elimination</a> to achieve it.
  * <p>

File: src/main/java/org/mapdb/DataIO.java
Patch:
@@ -57,7 +57,6 @@ static public long unpackLong(DataInput in) throws IOException {
 
 
     /**
-     * Pack long into output stream.
      * Pack long into output stream.
      * It will occupy 1-10 bytes depending on value (lower values occupy smaller space)
      *
@@ -79,7 +78,7 @@ static public void packLong(DataOutput out, long value) throws IOException {
     }
 
     /**
-     * Pack  int into output stream.
+     * Pack int into an output stream.
      * It will occupy 1-5 bytes depending on value (lower values occupy smaller space)
      *
      * This method originally comes from Kryo Framework, author Nathan Sweet.

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -339,6 +339,9 @@ public HTreeMap(Engine engine, long counterRecid, int hashSalt, long[] segmentRe
 
         if(expireFlag){
             expirationThreadNum = new CountDownLatch(1);
+            if(engine.canRollback()) {
+                LOG.warning("HTreeMap Expiration should not be used with transaction enabled. It can lead to data corruption, commit might happen while background thread works, and only part of expiration data will be commited.");
+            }
             threadFactory.newThread("HTreeMap expirator", new ExpireRunnable(this));
         }else{
             expirationThreadNum = null;

File: src/test/java/org/mapdb/Issue418Test.java
Patch:
@@ -16,7 +16,7 @@ public void test(){
         long[] expireHeads = null;
         long[] expireTails = null;
         for (int o = 0; o < 2; o++) {
-            final DB db = DBMaker.newFileDB(tmp).make();
+            final DB db = DBMaker.newFileDB(tmp).transactionDisable().make();
             final HTreeMap<Object, Object> map = db.createHashMap("foo").expireMaxSize(100).makeOrGet();
 
             if(expireHeads!=null)
@@ -46,7 +46,7 @@ public void test_set(){
         final File tmp = UtilsTest.tempDbFile();
 
         for (int o = 0; o < 2; o++) {
-            final DB db = DBMaker.newFileDB(tmp).make();
+            final DB db = DBMaker.newFileDB(tmp).transactionDisable().make();
             final Set<Object> map = db.createHashSet("foo").expireMaxSize(100).makeOrGet();
 
             for (int i = 0; i < 1000; i++)

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -808,6 +808,7 @@ protected void replayWAL(){
         //destroy old wal files
         for(Volume wal:volumes){
             wal.truncate(0);
+            wal.close();
             wal.deleteFile();
         }
         fileNum = -1;

File: src/main/java/org/mapdb/TxEngine.java
Patch:
@@ -91,7 +91,7 @@ public static Engine createSnapshotFor(Engine engine) {
         if(engine instanceof TxEngine)
             return ((TxEngine)engine).snapshot();
         if(engine.getWrappedEngine()!=null)
-            createSnapshotFor(engine.getWrappedEngine());
+            return createSnapshotFor(engine.getWrappedEngine());
         throw new UnsupportedOperationException("Snapshots are not enabled, use DBMaker.snapshotEnable()");
     }
 

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -1619,8 +1619,8 @@ protected void expireLinkBump(int segment, long nodeRecid, boolean access){
         ExpireLinkNode n = engine.get(nodeRecid,ExpireLinkNode.SERIALIZER);
         long newTime =
                 access?
-                        (expireAccess==0?0 : expireAccess+System.currentTimeMillis()-expireTimeStart):
-                        (expire==0?0 : expire+System.currentTimeMillis()-expireTimeStart);
+                        (expireAccess==0? n.time : expireAccess+System.currentTimeMillis()-expireTimeStart):
+                        (expire==0?n.time : expire+System.currentTimeMillis()-expireTimeStart);
 
         //TODO optimize bellow, but what if there is only size limit?
         //if(n.time>newTime) return; // older time greater than new one, do not update

File: src/main/java/org/mapdb/DB.java
Patch:
@@ -537,7 +537,7 @@ synchronized protected <K,V> HTreeMap<K,V> createHashMap(HTreeMapMaker m){
                 expireTails[i] = engine.put(0L,Serializer.LONG);
             }
             catPut(name+".expireHeads",expireHeads);
-            catPut(name+".expireTails",expireHeads);
+            catPut(name+".expireTails",expireTails);
         }
         //$DELAY$
 
@@ -652,7 +652,7 @@ synchronized protected <K> Set<K> createHashSet(HTreeSetMaker m){
                 expireTails[i] = engine.put(0L,Serializer.LONG);
             }
             catPut(name+".expireHeads",expireHeads);
-            catPut(name+".expireTails",expireHeads);
+            catPut(name+".expireTails",expireTails);
         }
 
         //$DELAY$

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -470,8 +470,9 @@ protected void putData(long recid, long[] offsets, DataOutputByteArray out) {
         boolean firstLinked =
                 (offsets!=null && offsets.length>1) || //too large record
                 (out==null); //null records
-        int firstSize = (int) (offsets==null? 0L : offsets[0]>>>48);
-        long firstOffset =  offsets==null? 0L : offsets[0]&MOFFSET;
+        boolean empty = offsets==null || offsets.length==0;
+        int firstSize = (int) (empty ? 0L : offsets[0]>>>48);
+        long firstOffset =  empty? 0L : offsets[0]&MOFFSET;
         indexValPut(recid,firstSize,firstOffset,firstLinked,false);
     }
 

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -365,9 +365,7 @@ public boolean containsKey(final Object o){
 
     @Override
     public int size() {
-        long size = sizeLong();
-        if(size>Integer.MAX_VALUE) return Integer.MAX_VALUE;
-        return (int) size;
+        return (int) Math.min(sizeLong(), Integer.MAX_VALUE);
     }
 
 

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -737,7 +737,7 @@ public void serialize(DataOutput out, BNode value) throws IOException {
         protected void serializeChildArray(DataOutput out, Object childArray) throws IOException {
             if(childArray instanceof int[]){
                 int[] cc = (int[]) childArray;
-                DataIO.packLong(out, (cc[0] << 1) | 1); //pack first value mixed with int flag
+                DataIO.packLong(out, (((long)cc[0]) << 1) | 1L); //pack first value mixed with int flag
                 for(int i=1;i<cc.length;i++){
                     DataIO.packInt(out,cc[i]);
                 }

File: src/test/java/org/mapdb/DBMakerTest.java
Patch:
@@ -84,7 +84,7 @@ public void testMake() throws Exception {
         Engine w =  db.engine;
         Store store = Store.forDB(db);
         assertTrue(store.caches[0] instanceof Store.Cache.HashTable);
-        assertEquals(1024 * 32, ((Store.Cache.HashTable) store.caches[0] ).items.length* store.caches.length);
+        assertEquals(1024 * 2, ((Store.Cache.HashTable) store.caches[0] ).items.length* store.caches.length);
         StoreDirect s = (StoreDirect) store;
         assertTrue(s.vol instanceof Volume.FileChannelVol);
     }
@@ -101,7 +101,7 @@ public void testMakeMapped() throws Exception {
         Engine w = db.engine;
         Store store = Store.forDB(db);
         assertTrue(store.caches[0] instanceof Store.Cache.HashTable);
-        assertEquals(1024 * 32, ((Store.Cache.HashTable) store.caches[0]).items.length * store.caches.length);
+        assertEquals(1024 * 2, ((Store.Cache.HashTable) store.caches[0]).items.length * store.caches.length);
         StoreDirect s = (StoreDirect) store;
         assertTrue(s.vol instanceof Volume.MappedFileVol);
     }

File: src/main/java/org/mapdb/CC.java
Patch:
@@ -87,7 +87,7 @@ public interface CC {
 //    int BTREE_DEFAULT_MAX_NODE_SIZE = 32;
 
 
-    int DEFAULT_CACHE_SIZE = 1024 * 32;
+    int DEFAULT_CACHE_SIZE = 2048;
 
     String DEFAULT_CACHE = DBMaker.Keys.cache_hashTable;
 

File: src/test/java/org/mapdb/VolumeTest.java
Patch:
@@ -35,7 +35,7 @@ public void run() {
         Thread.sleep(100);
         t.interrupt();
         Thread.sleep(100);
-        assertTrue(ref.get() instanceof DBException.VolumeClosedByInterrupt);
+        assertTrue(ref.get() instanceof DBException.VolumeClosed);
         //now channel should be closed
         assertFalse(v.channel.isOpen());
         try {

File: src/test/java/org/mapdb/DataIOTest.java
Patch:
@@ -60,7 +60,7 @@ public void testPackLongBidi() throws Exception {
 
     @Test public void testSixLong(){
         byte[] b = new byte[8];
-        for(long i=0;i>>>48==0;i=i+1+1/10000){
+        for(long i=0;i>>>48==0;i=i+1+i/10000){
             DataIO.putSixLong(b,2,i);
             assertEquals(i, DataIO.getSixLong(b,2));
         }

File: src/test/java/org/mapdb/DataIOTest.java
Patch:
@@ -60,7 +60,7 @@ public void testPackLongBidi() throws Exception {
 
     @Test public void testSixLong(){
         byte[] b = new byte[8];
-        for(long i=0;i>>>48==0;i=i+1+1/10000){
+        for(long i=0;i>>>48==0;i=i+1+i/10000){
             DataIO.putSixLong(b,2,i);
             assertEquals(i, DataIO.getSixLong(b,2));
         }

File: src/test/java/org/mapdb/DataIOTest.java
Patch:
@@ -60,7 +60,7 @@ public void testPackLongBidi() throws Exception {
 
     @Test public void testSixLong(){
         byte[] b = new byte[8];
-        for(long i=0;i>>48==0;i=i+1+1/10000){
+        for(long i=0;i>>>48==0;i=i+1+1/10000){
             DataIO.putSixLong(b,2,i);
             assertEquals(i, DataIO.getSixLong(b,2));
         }

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -372,7 +372,7 @@ protected byte[] loadLongStackPage(long pageOffset) {
             Volume vol = volumes.get(fileNum);
             vol.getData(dataOffset, b, 0, arraySize);
             //page is going to be modified, so put it back into dirtyStackPages)
-            dirtyStackPages.put(pageOffset, page);
+            dirtyStackPages.put(pageOffset, b);
             return b;
         }
 

File: src/main/java/org/mapdb/DBMaker.java
Patch:
@@ -643,10 +643,11 @@ public DBMaker commitFileSyncDisable(){
     /** constructs DB using current settings */
     public DB make(){
         boolean strictGet = propsGetBool(Keys.strictDBGet);
+        boolean deleteFilesAfterClose = propsGetBool(Keys.deleteFilesAfterClose);
         Engine engine = makeEngine();
         boolean dbCreated = false;
         try{
-            DB db =  new  DB(engine, strictGet,false);
+            DB db =  new  DB(engine, strictGet, deleteFilesAfterClose);
             dbCreated = true;
             return db;
         }finally {
@@ -911,7 +912,6 @@ protected Engine extendStoreDirect(
                 compressionEnabled,
                 propsGetXteaEncKey(),
                 propsGetBool(Keys.readOnly),
-                propsGetBool(Keys.deleteFilesAfterClose),
                 propsGetInt(Keys.freeSpaceReclaimQ,CC.DEFAULT_FREE_SPACE_RECLAIM_Q),
                 propsGetBool(Keys.commitFileSyncDisable),
                 0);
@@ -929,7 +929,6 @@ protected Engine extendStoreWAL(
                 compressionEnabled,
                 propsGetXteaEncKey(),
                 propsGetBool(Keys.readOnly),
-                propsGetBool(Keys.deleteFilesAfterClose),
                 propsGetInt(Keys.freeSpaceReclaimQ, CC.DEFAULT_FREE_SPACE_RECLAIM_Q),
                 propsGetBool(Keys.commitFileSyncDisable),
                 0);

File: src/main/java/org/mapdb/StoreCached.java
Patch:
@@ -21,9 +21,9 @@ public class StoreCached extends StoreDirect {
     protected final static Fun.Pair<Object, Serializer> TOMBSTONE = new Fun.Pair(null, null);
 
     public StoreCached(String fileName, Fun.Function1<Volume, String> volumeFactory, boolean checksum,
-                       boolean compress, byte[] password, boolean readonly, boolean deleteFilesAfterClose,
+                       boolean compress, byte[] password, boolean readonly,
                        int freeSpaceReclaimQ, boolean commitFileSyncDisable, int sizeIncrement) {
-        super(fileName, volumeFactory, checksum, compress, password, readonly, deleteFilesAfterClose,
+        super(fileName, volumeFactory, checksum, compress, password, readonly,
                 freeSpaceReclaimQ, commitFileSyncDisable, sizeIncrement);
 
         writeCache = new LongMap[CC.CONCURRENCY];
@@ -36,7 +36,7 @@ public StoreCached(String fileName, Fun.Function1<Volume, String> volumeFactory,
     public StoreCached(String fileName) {
         this(fileName,
                 fileName == null ? Volume.memoryFactory() : Volume.fileFactory(),
-                false, false, null, false, false, 0,
+                false, false, null, false,  0,
                 false, 0);
     }
 

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -66,7 +66,6 @@ public StoreDirect(String fileName,
                        boolean compress,
                        byte[] password,
                        boolean readonly,
-                       boolean deleteFilesAfterClose,
                        int freeSpaceReclaimQ,
                        boolean commitFileSyncDisable,
                        int sizeIncrement
@@ -183,7 +182,7 @@ protected void initHeadVol() {
 
     public StoreDirect(String fileName) {
         this(fileName, fileName==null? Volume.memoryFactory() : Volume.fileFactory(),
-                false,false,null,false,false,0,
+                false,false,null,false,0,
                 false,0);
     }
 

File: src/test/java/org/mapdb/EngineTest.java
Patch:
@@ -2,6 +2,7 @@
 
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.DataInput;
@@ -265,7 +266,8 @@ public void large_record(){
         }
     }
 
-    @Test public void get_non_existent_after_delete_and_compact(){
+    @Test @Ignore //TODO reenable after compaction
+    public void get_non_existent_after_delete_and_compact(){
         long recid = e.put(1L,Serializer.LONG);
         e.delete(recid,Serializer.LONG);
         assertNull(e.get(recid,Serializer.ILLEGAL_ACCESS));

File: src/test/java/org/mapdb/StoreDirectTest.java
Patch:
@@ -581,10 +581,12 @@ protected List<Long> getLongStack(long masterLinkOffset) {
         assertTrue(phys.exists());
         db.close();
         assertFalse(f.exists());
+        assertFalse(new File(f+".0.wal").exists());
         assertFalse(phys.exists());
     }
 
-    @Test public void freeSpaceWorks(){
+    @Test @Ignore //TODO free space stats
+    public void freeSpaceWorks(){
         long oldFree = e.getFreeSize();
         long recid = e.put(new byte[10000],Serializer.BYTE_ARRAY_NOSIZE);
         e.commit();

File: src/test/java/org/mapdb/StoreDirectTest2.java
Patch:
@@ -73,7 +73,7 @@ protected StoreDirect newStore() {
                 return vol;
             }
         };
-        StoreDirect st = new StoreDirect(null, fab, false, false,null, false,false, 0,false,0);
+        StoreDirect st = new StoreDirect(null, fab, false, false,null, false, 0,false,0);
         st.init();
 
         Map<Long,String> recids = new HashMap();
@@ -86,7 +86,7 @@ protected StoreDirect newStore() {
         //close would destroy Volume,so this will do
         st.commit();
 
-        st = new StoreDirect(null, fab, false, false,null, false,false, 0,false,0);
+        st = new StoreDirect(null, fab, false, false,null, false, 0,false,0);
         st.init();
 
         for(Map.Entry<Long,String> e:recids.entrySet()){

File: src/test/java/org/mapdb/StoreWALTest.java
Patch:
@@ -60,6 +60,7 @@ public void WAL_created(){
         e.walPutLong(offset,v);
         e.commit();
         e.structuralLock.lock();
+        e.commitLock.lock();
         e.replayWAL();
         assertEquals(v,e.vol.getLong(offset));
     }
@@ -77,6 +78,7 @@ public void WAL_created(){
         }
         e.commit();
         e.structuralLock.lock();
+        e.commitLock.lock();
         e.replayWAL();
 
         for(int i=0;i<3;i++) {

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -90,7 +90,7 @@ public void init() {
                 structuralLock.unlock();
             }
         }finally {
-            commitLock.lock();
+            commitLock.unlock();
         }
     }
 

File: src/main/java/org/mapdb/StoreCached.java
Patch:
@@ -194,7 +194,8 @@ protected void longStackNewPage(long masterLinkOffset, long prevPageOffset, long
 
         long newPageOffset = freeDataTakeSingle((int) CHUNKSIZE);
         byte[] page = new byte[(int) CHUNKSIZE];
-        vol.getData(newPageOffset, page, 0, page.length);
+//TODO this is new page, so data should be clear, no need to read them, but perhaps check data are really zero, handle EOF
+//        vol.getData(newPageOffset, page, 0, page.length);
         dirtyStackPages.put(newPageOffset, page);
         //write size of current chunk with link to prev page
         DataIO.putLong(page, 4, parity4Set((CHUNKSIZE << 48) | prevPageOffset));

File: src/main/java/org/mapdb/DBMaker.java
Patch:
@@ -749,7 +749,7 @@ public Engine makeEngine(){
         }
 
 
-        //try to read one record from DB, to make sure encryption and compression are correctly set.
+        //try to readrt one record from DB, to make sure encryption and compression are correctly set.
         Fun.Pair<Integer,byte[]> check = null;
         try{
             check = (Fun.Pair<Integer, byte[]>) engine.get(Engine.RECID_RECORD_CHECK, Serializer.BASIC);
@@ -830,8 +830,7 @@ protected int propsGetRafMode(){
 
 
     protected Engine extendSnapshotEngine(Engine engine) {
-        return null; //TODO tx
-//        return new TxEngine(engine,propsGetBool(Keys.fullTx));
+        return new TxEngine(engine,propsGetBool(Keys.fullTx));
     }
 
     protected Engine extendCacheLRU(Engine engine) {

File: src/test/java/org/mapdb/TxEngineTest.java
Patch:
@@ -13,7 +13,9 @@ public class TxEngineTest {
 
 
     @Before public void init(){
-        e = new TxEngine(new StoreWAL(null));
+        Store store = new StoreWAL(null);
+        store.init();
+        e = new TxEngine(store,true);
     }
 
     @Test public void update(){

File: src/test/java/org/mapdb/EngineWrapper_ImmutabilityCheckEngine.java
Patch:
@@ -14,6 +14,7 @@ public class EngineWrapper_ImmutabilityCheckEngine {
     @Test
     public void test(){
         Engine e = new StoreDirect(null);
+        ((StoreDirect)e).init();
         e = new EngineWrapper.ImmutabilityCheckEngine(e);
 
         List rec = new ArrayList();

File: src/test/java/org/mapdb/DBMakerTest.java
Patch:
@@ -344,6 +344,7 @@ public void nonExistingFolder(){
         DBMaker.newFileDB(folderDoesNotExist).make();
     }
 
+    @Test(expected = IOError.class)
     public void nonExistingFolder3(){
         DBMaker.newFileDB(folderDoesNotExist).mmapFileEnable().make();
     }

File: src/main/java/org/mapdb/StoreCached.java
Patch:
@@ -243,6 +243,7 @@ protected void flushWriteCache() {
                         update2(recid,buf);
                         recycledDataOuts.offer(buf);
                     }
+                    iter.remove();
                 }
 
             }finally {

File: src/test/java/org/mapdb/CompressTest.java
Patch:
@@ -15,6 +15,7 @@ public class CompressTest{
     @Before public void init(){
         db = DBMaker
                 .newMemoryDB()
+                .transactionDisable()
                 .cacheDisable()
                 .compressionEnable()
                 .make();

File: src/test/java/org/mapdb/HTreeMap2Test.java
Patch:
@@ -566,7 +566,7 @@ public void cache_load_size_expire(){
 
     @Test public void hasher(){
         HTreeMap m =
-                DBMaker.newMemoryDB().make()
+                DBMaker.newMemoryDB().transactionDisable().make()
                         .createHashMap("test")
                         .keySerializer(Serializer.INT_ARRAY)
                         .make();
@@ -581,7 +581,7 @@ public void cache_load_size_expire(){
     }
 
     @Test public void mod_listener_lock(){
-        DB db = DBMaker.newMemoryDB().make();
+        DB db = DBMaker.newMemoryDB().transactionDisable().make();
         final HTreeMap m = db.getHashMap("name");
 
         final int seg =  m.hash("aa")>>>28;

File: src/main/java/org/mapdb/DB.java
Patch:
@@ -86,12 +86,13 @@ public DB(Engine engine, boolean strictDBGet, boolean disableLocks) {
         }
         this.engine = engine;
         this.strictDBGet = strictDBGet;
-        reinit();
+
         final CopyOnWriteArrayList<SerializerPojo.ClassInfo> classInfos =
                 engine.get(Engine.RECID_CLASS_CATALOG,
                 SerializerPojo.serializer);
         serializerPojo = new SerializerPojo(classInfos);
         serializerPojo.setDb(this);
+        reinit();
     }
 
     protected void reinit() {

File: src/test/java/org/mapdb/HTreeMap2Test.java
Patch:
@@ -724,7 +724,7 @@ public void inconsistentHash(){
     @Test
     public void test()
     {
-        DB db = DBMaker.newMemoryDB().make();
+        DB db = DBMaker.newMemoryDB().transactionDisable().make();
         Map<String, Integer> map = db.getHashMap("map", new Fun.Function1<Integer, String>() {
             @Override
             public Integer run(String s) {

File: src/main/java/org/mapdb/DBMaker.java
Patch:
@@ -888,7 +888,7 @@ protected Engine extendHeapStore() {
 
     protected Engine extendStoreAppend(String fileName, Fun.Function1<Volume,String> volumeFactory) {
         boolean compressionEnabled = Keys.compression_lzf.equals(props.getProperty(Keys.compression));
-        return null;
+        throw new RuntimeException("StoreAppend");
 //        return new StoreAppend(fileName, volumeFactory,
 //                propsGetRafMode()>0, propsGetBool(Keys.readOnly),
 //                propsGetBool(Keys.transactionDisable),
@@ -919,7 +919,7 @@ protected Engine extendStoreWAL(
             String fileName,
             Fun.Function1<Volume,String> volumeFactory) {
         boolean compressionEnabled = Keys.compression_lzf.equals(props.getProperty(Keys.compression));
-        return null;
+        throw new RuntimeException("StoreWAL");
 
 //        return new StoreWAL(
 //                fileName,

File: src/test/java/org/mapdb/BTreeKeySerializerTest.java
Patch:
@@ -16,6 +16,7 @@ public class BTreeKeySerializerTest {
 
     @Test public void testLong(){
         DB db = DBMaker.newMemoryDB()
+                .transactionDisable()
                 .cacheDisable()
                 .make();
         Map m = db.createTreeMap("test")
@@ -75,6 +76,7 @@ void checkKeyClone(BTreeKeySerializer ser, Object[] keys) throws IOException {
 
         DB db = DBMaker.newMemoryDB()
                 .cacheDisable()
+                .transactionDisable()
                 .make();
         Map m =  db.createTreeMap("test")
                 .keySerializer(BTreeKeySerializer.STRING)

File: src/test/java/org/mapdb/BTreeMapNavigable2Test.java
Patch:
@@ -32,13 +32,13 @@ protected void tearDown() throws Exception {
     }
 
     protected NavigableMap<Integer, String> newMap() {
-        return DBMaker.newMemoryDB().make().createTreeMap("map").make();
+        return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("map").make();
     }
 
 
     public static class Outside extends BTreeMapNavigable2Test{
         @Override protected NavigableMap<Integer, String> newMap() {
-            return DBMaker.newMemoryDB().make().createTreeMap("map").valuesOutsideNodesEnable().make();
+            return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("map").valuesOutsideNodesEnable().make();
         }
     }
 

File: src/test/java/org/mapdb/BTreeMapNavigableSubMapExclusiveTest.java
Patch:
@@ -6,7 +6,8 @@ public class BTreeMapNavigableSubMapExclusiveTest extends BTreeMapNavigable2Test
 
     public static class Outside extends BTreeMapNavigableSubMapExclusiveTest{
         @Override protected NavigableMap<Integer, String> newMap() {
-            return DBMaker.newMemoryDB().make().createTreeMap("map").valuesOutsideNodesEnable().make();
+            return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("map").valuesOutsideNodesEnable()
+                    .make();
         }
 
     }

File: src/test/java/org/mapdb/BTreeMapNavigableSubMapInclusiveTest.java
Patch:
@@ -6,7 +6,7 @@ public class BTreeMapNavigableSubMapInclusiveTest extends BTreeMapNavigable2Test
 
     public static class Outside extends BTreeMapNavigableSubMapInclusiveTest{
         @Override protected NavigableMap<Integer, String> newMap() {
-            return DBMaker.newMemoryDB().make().createTreeMap("map").valuesOutsideNodesEnable().make();
+            return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("map").valuesOutsideNodesEnable().make();
         }
     }
 

File: src/test/java/org/mapdb/BTreeMapNavigableTest.java
Patch:
@@ -77,12 +77,12 @@ public class BTreeMapNavigableTest extends TestCase {
 
 
     protected NavigableMap<String, String> newMap() {
-            return DBMaker.newMemoryDB().make().createTreeMap("map").make();
+            return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("map").make();
     }
 
     public static class Outside extends BTreeMapNavigableTest{
         @Override protected NavigableMap<String, String> newMap() {
-            return DBMaker.newMemoryDB().make().createTreeMap("map").valuesOutsideNodesEnable().make();
+            return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("map").valuesOutsideNodesEnable().make();
         }
     }
 

File: src/test/java/org/mapdb/BTreeMapTest3.java
Patch:
@@ -38,13 +38,13 @@ protected String getSecondValueNotInPopulatedMap() throws UnsupportedOperationEx
 
     @Override
     protected ConcurrentNavigableMap<Integer, String> makeEmptyMap() throws UnsupportedOperationException {
-        return DBMaker.newMemoryDB().make().getTreeMap("test");
+        return DBMaker.newMemoryDB().transactionDisable().make().getTreeMap("test");
     }
 
     public static class Outside extends BTreeMapTest3{
         @Override
         protected ConcurrentNavigableMap<Integer, String> makeEmptyMap() throws UnsupportedOperationException {
-            return DBMaker.newMemoryDB().make().createTreeMap("test").valuesOutsideNodesEnable().make();
+            return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("test").valuesOutsideNodesEnable().make();
         }
 
     }

File: src/test/java/org/mapdb/BTreeMapTest5.java
Patch:
@@ -14,12 +14,12 @@ public class BTreeMapTest5 extends JSR166TestCase {
     public static class Outside extends BTreeMapTest5{
         @Override
         protected BTreeMap newMap() {
-            return DBMaker.newMemoryDB().make().createTreeMap("test").valuesOutsideNodesEnable().make();
+            return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("test").valuesOutsideNodesEnable().make();
         }
     }
 
     protected  BTreeMap newMap() {
-        return DBMaker.newMemoryDB().make().createTreeMap("test").make();
+        return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("test").make();
     }
 
 

File: src/test/java/org/mapdb/BTreeMapTest6.java
Patch:
@@ -31,12 +31,12 @@ ConcurrentNavigableMap map5() {
     }
 
     protected BTreeMap newEmptyMap() {
-        return DBMaker.newMemoryDB().make().createTreeMap("test").make();
+        return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("test").make();
     }
 
     public static class Outside extends BTreeMapTest6{
         @Override protected BTreeMap newEmptyMap() {
-            return DBMaker.newMemoryDB().make().createTreeMap("test").valuesOutsideNodesEnable().make();
+            return DBMaker.newMemoryDB().transactionDisable().make().createTreeMap("test").valuesOutsideNodesEnable().make();
         }
 
     }

File: src/test/java/org/mapdb/BindTest.java
Patch:
@@ -20,7 +20,7 @@ public class BindTest {
 
     @Before
     public void init(){
-        m = DBMaker.newMemoryDB().make().getTreeMap("test");
+        m = DBMaker.newMemoryDB().transactionDisable().make().getTreeMap("test");
     }
 
 

File: src/test/java/org/mapdb/HTreeMap2Test.java
Patch:
@@ -23,7 +23,7 @@ public class HTreeMap2Test {
     DB db;
 
     @Before public void init2(){
-        engine = DBMaker.newMemoryDB().cacheDisable().makeEngine();
+        engine = DBMaker.newMemoryDB().transactionDisable().cacheDisable().makeEngine();
         db = new DB(engine);;
     }
 

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -133,7 +133,9 @@ public StoreDirect(String fileName,
     }
 
     public StoreDirect(String fileName) {
-        super(fileName, fileName==null? Volume.memoryFactory() : Volume.fileFactory(),false,false,null,false);
+        this(fileName, fileName==null? Volume.memoryFactory() : Volume.fileFactory(),
+                false,false,null,false,false,0,
+                false,0);
     }
 
     protected int headChecksum() {

File: src/main/java/org/mapdb/SerializerPojo.java
Patch:
@@ -492,7 +492,7 @@ protected Object deserializeUnknownHeader(DataInput in, int head, FastArrayList<
     static protected Object sunReflFac = null;
     static protected Method androidConstructor = null;
     static private Method androidConstructorGinger = null;
-    static private int constructorId;
+    static private Object constructorId;
 
     static{
         try{
@@ -524,9 +524,9 @@ protected Object deserializeUnknownHeader(DataInput in, int head, FastArrayList<
             //try android post ginger way
             Method getConstructorId = ObjectStreamClass.class.getDeclaredMethod("getConstructorId", Class.class);
             getConstructorId.setAccessible(true);
-            constructorId = (Integer) getConstructorId.invoke(null, Object.class);
+            constructorId = getConstructorId.invoke(null, Object.class);
 
-            Method newInstance = ObjectStreamClass.class.getDeclaredMethod("newInstance", Class.class, int.class);
+            Method newInstance = ObjectStreamClass.class.getDeclaredMethod("newInstance", Class.class, getConstructorId.getReturnType());
             newInstance.setAccessible(true);
             androidConstructorGinger = newInstance;
 

File: src/test/java/org/mapdb/EngineTest.java
Patch:
@@ -270,7 +270,8 @@ public void large_record(){
         e.compact();
         try{
             e.get(recid,Serializer.STRING);
-            fail();
+            if(!(e instanceof StoreAppend)) //TODO remove after compact on StoreAppend
+                fail();
         }catch(DBException e){
             assertEquals(DBException.Code.ENGINE_GET_VOID, e.getCode());
         }

File: src/main/java/org/mapdb/StoreHeap.java
Patch:
@@ -51,7 +51,7 @@ public class StoreHeap extends Store implements Serializable{
     protected final AtomicLong maxRecid = new AtomicLong(LAST_RESERVED_RECID);
 
     public StoreHeap(boolean disableLocks){
-        super(false,false,null,disableLocks);
+        super(null, null, false,false,null,disableLocks);
         for(long recid=1;recid<=LAST_RESERVED_RECID;recid++){
             records.put(recid, Fun.t2(null, (Serializer)null));
         }

File: src/test/java/org/mapdb/AtomicBooleanTest.java
Patch:
@@ -7,13 +7,13 @@
  */
 
 import junit.framework.TestCase;
+import org.junit.After;
 
 public class AtomicBooleanTest extends TestCase{
 
     DB db;
     Atomic.Boolean ai;
 
-
     @Override
     protected void setUp() throws Exception {
         db = DBMaker.newMemoryDB().transactionDisable().make();

File: src/test/java/org/mapdb/BTreeMapExtendTest.java
Patch:
@@ -68,6 +68,7 @@ protected BTreeMap newBTreeMap() {
         return DBMaker.newMemoryDB().cacheDisable().transactionDisable().make().getTreeMap("Test");
     }
 
+
     public static class Outside extends BTreeMapExtendTest{
         @Override protected BTreeMap newBTreeMap() {
             return DBMaker.newMemoryDB().cacheDisable().transactionDisable().make()
@@ -7502,6 +7503,7 @@ protected void setUp() {
 
     @Override
     protected void tearDown() {
+        tm.engine.close();
         tm = null;
         tm_comparator = null;
 

File: src/test/java/org/mapdb/EngineWrapper_ImmutabilityCheckEngine.java
Patch:
@@ -13,8 +13,7 @@ public class EngineWrapper_ImmutabilityCheckEngine {
 
     @Test
     public void test(){
-        Volume.Factory fab = Volume.memoryFactory(false,0L,CC.VOLUME_SLICE_SHIFT);
-        Engine e = new StoreDirect(fab);
+        Engine e = new StoreDirect(null);
         e = new EngineWrapper.ImmutabilityCheckEngine(e);
 
         List rec = new ArrayList();

File: src/test/java/org/mapdb/StoreAppendTest.java
Patch:
@@ -17,13 +17,12 @@ public class StoreAppendTest<E extends StoreAppend> extends EngineTest<E>{
 
     @Override
     protected E openEngine() {
-        return (E) new StoreAppend(f);
+        return (E) new StoreAppend(f.getPath());
     }
 
     @Test
     public void compact_file_deleted(){
-        File f = UtilsTest.tempDbFile();
-        StoreAppend engine = new StoreAppend(f);
+        StoreAppend engine = new StoreAppend(f.getPath());
         File f1 = engine.getFileFromNum(0);
         File f2 = engine.getFileFromNum(1);
         long recid = engine.put(111L, Serializer.LONG);

File: src/test/java/org/mapdb/StoreDirectFreeSpaceTest.java
Patch:
@@ -13,7 +13,7 @@ public class StoreDirectFreeSpaceTest {
     final Map<Long,Deque<Long>> longStacks = new TreeMap <Long,Deque<Long>>();
 
     /** mock longStacks so their page allocations wont mess up tests */
-    StoreDirect stub = new  StoreDirect(Volume.memoryFactory(false,max,CC.VOLUME_SLICE_SHIFT),false,false,5,false,max,false,false,null,false,0){
+    StoreDirect stub = new  StoreDirect(null){
         {
             structuralLock.lock();
         }

File: src/test/java/org/mapdb/TxEngineTest.java
Patch:
@@ -13,7 +13,7 @@ public class TxEngineTest {
 
 
     @Before public void init(){
-        e = new TxEngine(new StoreWAL(Volume.memoryFactory(false, 0L,CC.VOLUME_SLICE_SHIFT)),false);
+        e = new TxEngine(new StoreWAL(null),false);
     }
 
     @Test public void update(){

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -1232,7 +1232,9 @@ public void clear() {
             int size = A.keysLen()-1;
             if(hasListeners) {
                 for (int i = 1; i < size; i++) {
-                    notify((K) A.key(i), (V) A.vals()[i - 1], null);
+                    Object val = (V) A.vals()[i - 1];
+                    val = valExpand(val);
+                    notify((K) A.key(i),(V) val, null);
                 }
             }
 

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -849,6 +849,7 @@ protected boolean verifyLogFile() {
                     crc |= crc32.getValue();
 
                     log.getDataInput(logSize, size).readFully(b);
+                    logSize+=size;
                 } else if (ins == WAL_SKIP_REST_OF_BLOCK) {
                     logSize += SLICE_SIZE - (logSize & SLICE_SIZE_MOD_MASK);
                 } else {

File: src/main/java/org/mapdb/DB.java
Patch:
@@ -373,7 +373,7 @@ synchronized public <K,V> HTreeMap<K,V> getHashMap(String name, Fun.Function1<V,
                 (long[])catGet(name+".expireHeads",null),
                 (long[])catGet(name+".expireTails",null),
                 valueCreator,
-                null,
+                catGet(name+".hasher", Hasher.BASIC),
                 false);
 
 

File: src/test/java/org/mapdb/QueuesTest.java
Patch:
@@ -98,7 +98,7 @@ public void testMapDb() throws InterruptedException {
         database.close();
     }
 
-    @Test(timeout=1000)
+    @Test(timeout=10000)
     public void queueTakeRollback() throws IOException, InterruptedException {
         File f = File.createTempFile("mapdb","aa");
         {

File: src/test/java/org/mapdb/BTreeMapTest.java
Patch:
@@ -347,7 +347,7 @@ public void update(Object key, Object oldVal, Object newVal) {
         //fill
         final int c = 1000000;
         for(int i=0;i<=c;i++){
-            m.put(c,c);
+            m.put(i,i);
         }
 
         Thread t = new Thread(){
@@ -371,7 +371,7 @@ public void run() {
         //fill
         final int c = 1000000;
         for(int i=0;i<=c;i++){
-            m.put(c,c);
+            m.put(i,i);
         }
 
         Thread t = new Thread(){

File: src/test/java/org/mapdb/AsyncWriteEngineTest.java
Patch:
@@ -113,15 +113,15 @@ public <A> void  update(long recid, A value, Serializer<A> serializer) {
         a.commit();
         assertEquals(max, putCounter.longValue() );
         assertTrue(a.writeCache.isEmpty());
-        t.close();
+        a.close();
 
         //now reopen db and check ths
         t = new StoreWAL(fac);
         a = new AsyncWriteEngine(t);
-        for(Integer i=0;i<max;i++){
-            long recid = l.get(i);
+        for(Long recid : l){
             assertArrayEquals(b, (byte[]) a.get(recid, Serializer.BASIC));
         }
+        a.close();
     }
 
 }

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -86,7 +86,6 @@ public StoreWAL(Volume.Factory volFac, boolean readOnly, boolean deleteFilesAfte
             }
             replayPending = false;
             checkHeaders();
-            log = volFac.createTransLogVolume();
             if(!readOnly)
                 logReset();
             allGood = true;

File: src/main/java/org/mapdb/Volume.java
Patch:
@@ -284,7 +284,7 @@ public final boolean tryAvailable(long offset) {
                 int oldSize = chunks.length;
                 ByteBuffer[] chunks2 = chunks;
 
-                chunks2 = Arrays.copyOf(chunks2, Math.max(chunkPos+1, chunks2.length * 2));
+                chunks2 = Arrays.copyOf(chunks2, Math.max(chunkPos+1, chunks2.length + chunks2.length/1000));
 
                 for(int pos=oldSize;pos<chunks2.length;pos++) {
                     chunks2[pos]=makeNewBuffer(1L*chunkSize*pos);

File: src/main/java/org/mapdb/DB.java
Patch:
@@ -827,7 +827,7 @@ synchronized protected <K,V> BTreeMap<K,V> createTreeMap(BTreeMapMaker m){
 
         m.comparator = catPut(name+".comparator",m.comparator);
 
-        if(m.pumpPresortBatchSize!=-1){
+        if(m.pumpPresortBatchSize!=-1 && m.pumpSource!=null){
             m.pumpSource = Pump.sort(m.pumpSource,m.pumpIgnoreDuplicates, m.pumpPresortBatchSize,Collections.reverseOrder(m.comparator),getDefaultSerializer());
         }
 

File: src/main/java/org/mapdb/Pump.java
Patch:
@@ -47,11 +47,13 @@ static void copy(Store s1, Store s2){
      * @param serializer used to store data in temporary files
      * @return iterator over sorted data set
      */
-    public static <E> Iterator<E> sort(final Iterator<E> source, boolean mergeDuplicates, final int batchSize,
+    public static <E> Iterator<E> sort(Iterator<E> source, boolean mergeDuplicates, final int batchSize,
             Comparator comparator, final Serializer serializer){
         if(batchSize<=0) throw new IllegalArgumentException();
         if(comparator==null)
             comparator=BTreeMap.COMPARABLE_COMPARATOR;
+        if(source==null)
+            source = Fun.EMPTY_ITERATOR;
 
         int counter = 0;
         final Object[] presort = new Object[batchSize];

File: src/main/java/org/mapdb/Caches.java
Patch:
@@ -1,7 +1,5 @@
 package org.mapdb;
 
-import com.sun.deploy.cache.CacheEntry;
-
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.SoftReference;
 import java.lang.ref.WeakReference;

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -68,7 +68,6 @@ public StoreWAL(Volume.Factory volFac, boolean readOnly, boolean deleteFilesAfte
             }
             replayPending = false;
             checkHeaders();
-            log = volFac.createTransLogVolume();
             if(!readOnly)
                 logReset();
             allGood = true;

File: src/main/java/org/mapdb/Volume.java
Patch:
@@ -427,7 +427,7 @@ public MappedFileVol(File file, boolean readOnly, long sizeLimit, int chunkShift
                     //map existing data
                     chunks = new ByteBuffer[(int) ((fileSize>>> chunkShift))];
                     for(int i=0;i<chunks.length;i++){
-                        chunks[i] = makeNewBuffer(i*chunkSize);
+                        chunks[i] = makeNewBuffer(1L*i*chunkSize);
                     }
                 }else{
                     chunks = new ByteBuffer[0];

File: src/main/java/org/mapdb/Fun.java
Patch:
@@ -882,8 +882,6 @@ private static int intCompare(int x, int y) {
      *
      * @param secondaryKeys Secondary Set or 'MultiMap' to find values in
      * @param secondaryKey key to look from
-     * @param <K2> Secondary Key type
-     * @param <K1> Primary Key type
      * @return all keys where primary value equals to `secondaryKey`
      */
     public static <K2,K1> Iterable<K1> filter(final NavigableSet<Fun.Tuple2<K2, K1>> secondaryKeys, final K2 secondaryKey) {

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -1598,7 +1598,6 @@ protected void expirePurgeSegment(int seg, long removePerSegment) {
             // patch linked list
             if(last ==null ){
                 //no items removed
-                return;
             }else if(recid == 0){
                 //all items were taken, so zero items
                 engine.update(expireTails[seg],0L, Serializer.LONG);

File: src/main/java/org/mapdb/DBMaker.java
Patch:
@@ -769,7 +769,7 @@ public Engine makeEngine(){
         try{
             check = (Fun.Tuple2<Integer, byte[]>) engine.get(Engine.CHECK_RECORD, Serializer.BASIC);
             if(check!=null){
-                if(check.a.intValue()!= Arrays.hashCode(check.b))
+                if(check.a != Arrays.hashCode(check.b))
                     throw new RuntimeException("invalid checksum");
             }
         }catch(Throwable e){

File: src/main/java/org/mapdb/EncryptionXTEA.java
Patch:
@@ -158,9 +158,7 @@ public static byte[] getHash(byte[] data, boolean nullData) {
         int[] hh = { 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
                 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 };
         for (int block = 0; block < intLen; block += 16) {
-            for (int i = 0; i < 16; i++) {
-                w[i] = buff[block + i];
-            }
+            System.arraycopy(buff, block + 0, w, 0, 16);
             for (int i = 16; i < 64; i++) {
                 int x = w[i - 2];
                 int theta1 = rot(x, 17) ^ rot(x, 19) ^ (x >>> 10);

File: src/main/java/org/mapdb/EngineWrapper.java
Patch:
@@ -21,8 +21,6 @@
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Iterator;
-import java.util.Queue;
-import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 

File: src/main/java/org/mapdb/SerializerBase.java
Patch:
@@ -1867,9 +1867,9 @@ protected static boolean[] readBooleanArray(int numBools,DataInput is) throws IO
         boolean[] tmp = new boolean[boolBytes.length*8];
         int len = boolBytes.length;
         int boolIndex = 0;
-        for (int x=0; x<len; x++) {
-            for (int y=0; y<8; y++) {
-                tmp[boolIndex++] = (boolBytes[x] & (0x01 << y)) != 0x00;
+        for (byte boolByte : boolBytes) {
+            for (int y = 0; y < 8; y++) {
+                tmp[boolIndex++] = (boolByte & (0x01 << y)) != 0x00;
             }
         }
 

File: src/main/java/org/mapdb/LongHashMap.java
Patch:
@@ -180,7 +180,7 @@ public long key() {
 
         @Override
         public V value() {
-            return (V) currentEntry.value;
+            return currentEntry.value;
         }
     }
 

File: src/main/java/org/mapdb/Serializer.java
Patch:
@@ -498,6 +498,7 @@ public int fixedSize() {
     /** wraps another serializer and (de)compresses its output/input*/
     public final static class CompressionWrapper<E> implements Serializer<E>, Serializable {
 
+        private static final long serialVersionUID = 4440826457939614346L;
         protected final Serializer<E> serializer;
         protected final ThreadLocal<CompressLZF> LZF = new ThreadLocal<CompressLZF>() {
                 @Override protected CompressLZF initialValue() {

File: src/main/java/org/mapdb/SerializerPojo.java
Patch:
@@ -84,6 +84,7 @@ public int fixedSize() {
         }
 
     };
+    private static final long serialVersionUID = 3181417366609199703L;
 
     protected final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(CC.FAIR_LOCKS);
 

File: src/main/java/org/mapdb/StoreHeap.java
Patch:
@@ -17,6 +17,7 @@ public class StoreHeap extends Store implements Serializable{
     protected final static Fun.Tuple2 TOMBSTONE = Fun.t2(null,null);
 
     protected final static Object NULL = new Object();
+    private static final long serialVersionUID = 150060834534309445L;
 
     /** All commited records in store */
     protected final ConcurrentNavigableMap<Long,Fun.Tuple2> records

File: src/main/java/org/mapdb/Fun.java
Patch:
@@ -80,7 +80,7 @@ public int compareTo(final Object o) {
     };
 
     /** autocast version of `HI`*/
-    public static final <A> A HI(){
+    public static <A> A HI(){
         return (A) HI;
     }
 

File: src/main/java/org/mapdb/LongConcurrentLRUMap.java
Patch:
@@ -573,7 +573,7 @@ public final void clear() {
             size = 0;
         }
 
-        private final void upHeap() {
+        private void upHeap() {
             int i = size;
             T node = heap[i];          // save bottom node
             int j = i >>> 1;
@@ -585,7 +585,7 @@ private final void upHeap() {
             heap[i] = node;            // install saved node
         }
 
-        private final void downHeap() {
+        private void downHeap() {
             int i = 1;
             T node = heap[i];          // save top node
             int j = i << 1;            // find smaller child

File: src/main/java/org/mapdb/LongHashMap.java
Patch:
@@ -235,7 +235,7 @@ public LongHashMap(int capacity) {
      *            number of elements
      * @return storage size
      */
-    private static final int calculateCapacity(int x) {
+    private static int calculateCapacity(int x) {
         if(x >= 1 << 30){
             return 1 << 30;
         }

File: src/main/java/org/mapdb/Pump.java
Patch:
@@ -451,9 +451,7 @@ public static  <E,K,V> long buildTreeMap(Iterator<E> source,
 
         BTreeMap.DirNode dir = new BTreeMap.DirNode(dirKeys.get(len).toArray(), dirRecids.get(len));
         long rootRecid = engine.put(dir, nodeSerializer);
-        long rootRecidRef = engine.put(rootRecid,Serializer.LONG);
-
-        return rootRecidRef;
+        return engine.put(rootRecid,Serializer.LONG); //root recid
     }
 
     /** create array list with single element*/

File: src/main/java/org/mapdb/BTreeKeySerializer.java
Patch:
@@ -61,6 +61,8 @@ public abstract class BTreeKeySerializer<K>{
      */
     public static final class BasicKeySerializer extends BTreeKeySerializer<Object> implements Serializable {
 
+        private static final long serialVersionUID = 1654710710946309279L;
+
         protected final Serializer defaultSerializer;
 
         public BasicKeySerializer(Serializer defaultSerializer) {

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -136,7 +136,7 @@ public LinkedNode<K,V> deserialize(DataInput in, int available) throws IOExcepti
                     DataInput2.unpackLong(in),
                     expireFlag?DataInput2.unpackLong(in):0L,
                     keySerializer.deserialize(in,-1),
-                    hasValues? (V) valueSerializer.deserialize(in,-1) : (V) BTreeMap.EMPTY
+                    hasValues? valueSerializer.deserialize(in,-1) : (V) BTreeMap.EMPTY
             );
         }
 

File: src/main/java/org/mapdb/TxRollbackException.java
Patch:
@@ -6,4 +6,5 @@
  */
 public class TxRollbackException extends RuntimeException {
 
+    private static final long serialVersionUID = -708303624605410767L;
 }

File: src/test/java/org/mapdb/BTreeKeySerializerTest.java
Patch:
@@ -10,6 +10,7 @@
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 
+@SuppressWarnings({"rawtypes","unchecked"})
 public class BTreeKeySerializerTest {
 
     @Test public void testLong(){

File: src/test/java/org/mapdb/BTreeSet2Test.java
Patch:
@@ -18,6 +18,8 @@ public class BTreeSet2Test extends JSR166TestCase {
 //    }
 //
     static class MyReverseComparator implements Comparator,Serializable {
+        private static final long serialVersionUID = 6921783514838686569L;
+
         public int compare(Object x, Object y) {
             return ((Comparable)y).compareTo(x);
         }

File: src/test/java/org/mapdb/BindTest.java
Patch:
@@ -12,6 +12,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.mapdb.Fun.*;
 
+@SuppressWarnings({"rawtypes","unchecked"})
 public class BindTest {
 
     BTreeMap<Integer,String> m;

File: src/test/java/org/mapdb/Issue170Test.java
Patch:
@@ -5,6 +5,7 @@
 import java.util.Map;
 import java.util.UUID;
 
+@SuppressWarnings({"rawtypes","unchecked"})
 public class Issue170Test {
 
     @Test

File: src/test/java/org/mapdb/Issue254Test.java
Patch:
@@ -8,6 +8,7 @@
 
 import static org.junit.Assert.*;
 
+@SuppressWarnings({"rawtypes","unchecked"})
 public class Issue254Test {
 
     @Test

File: src/test/java/org/mapdb/MapListenerTest.java
Patch:
@@ -8,6 +8,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
+@SuppressWarnings({"rawtypes","unchecked"})
 public class MapListenerTest {
 
         @Test public void hashMap(){

File: src/test/java/org/mapdb/PumpTest.java
Patch:
@@ -8,6 +8,7 @@
 
 import static org.junit.Assert.*;
 
+@SuppressWarnings({"rawtypes","unchecked"})
 public class PumpTest {
 
     @Test

File: src/test/java/org/mapdb/QueuesTest.java
Patch:
@@ -11,6 +11,7 @@
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.*;
 
+@SuppressWarnings({"rawtypes","unchecked"})
 public class QueuesTest {
 
 

File: src/test/java/org/mapdb/SerializerTest.java
Patch:
@@ -9,6 +9,7 @@
 
 import static org.junit.Assert.*;
 
+@SuppressWarnings({"rawtypes","unchecked"})
 public class SerializerTest {
 
     @Test public void UUID2(){

File: src/test/java/org/mapdb/StoreAppendTest.java
Patch:
@@ -10,6 +10,7 @@
 
 import static org.junit.Assert.*;
 
+@SuppressWarnings({"rawtypes","unchecked"})
 public class StoreAppendTest<E extends StoreAppend> extends EngineTest<E>{
 
 

File: src/test/java/org/mapdb/StoreDirectTest.java
Patch:
@@ -14,6 +14,7 @@
 import static org.junit.Assert.*;
 import static org.mapdb.StoreDirect.*;
 
+@SuppressWarnings({"rawtypes","unchecked"})
 public class StoreDirectTest <E extends StoreDirect> extends EngineTest<E>{
 
     @Override boolean canRollback(){return false;}
@@ -137,7 +138,7 @@ public void phys_append_alloc_link3(){
         long recid = e.put(1000L, Serializer.LONG);
         e.commit();
         assertEquals(1, countIndexRecords());
-        assertEquals(e.LAST_RESERVED_RECID+1, recid);
+        assertEquals(LAST_RESERVED_RECID+1, recid);
         e.delete(recid,Serializer.LONG);
         e.commit();
         assertEquals(0, countIndexRecords());

File: src/test/java/org/mapdb/TreeMapExtendTest.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.Map.Entry;
 
 
-// 
+@SuppressWarnings({"rawtypes","unchecked"})
 public class TreeMapExtendTest extends TestCase {
 
 

File: src/main/java/org/mapdb/SerializerBase.java
Patch:
@@ -550,7 +550,7 @@ private void serializeString(DataOutput out, Object obj) throws IOException {
     }
 
     private void serializeLongArray(DataOutput out, long[] obj) throws IOException {
-        long[] val = (long[]) obj;
+        long[] val =  obj;
         long max = Long.MIN_VALUE;
         long min = Long.MAX_VALUE;
         for (long i : val) {
@@ -582,7 +582,7 @@ private void serializeLongArray(DataOutput out, long[] obj) throws IOException {
     }
 
     private void serializeIntArray(DataOutput out, int[] obj) throws IOException {
-        int[] val = (int[]) obj;
+        int[] val = obj;
         int max = Integer.MIN_VALUE;
         int min = Integer.MAX_VALUE;
         for (int i : val) {

File: src/test/java/org/mapdb/BTreeMapSubSetTest.java
Patch:
@@ -9,6 +9,7 @@
 
 import java.util.*;
 
+@SuppressWarnings({ "unchecked", "rawtypes" })
 public class BTreeMapSubSetTest extends JSR166TestCase {
     public static void main(String[] args) {
         junit.textui.TestRunner.run(suite());

File: src/test/java/org/mapdb/BTreeMapTest4.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.Map.Entry;
 
 
+@SuppressWarnings({ "unchecked", "rawtypes" })
 public class BTreeMapTest4 extends junit.framework.TestCase {
 
     protected <K,V> BTreeMap<K,V> newBTreeMap(Map map) {

File: src/test/java/org/mapdb/BTreeSet2Test.java
Patch:
@@ -8,6 +8,7 @@
 import java.io.Serializable;
 import java.util.*;
 
+@SuppressWarnings({ "unchecked", "rawtypes" })
 public class BTreeSet2Test extends JSR166TestCase {
 //    public static void main(String[] args) {
 //        junit.textui.TestRunner.run(suite());

File: src/test/java/org/mapdb/BTreeSet3Test.java
Patch:
@@ -11,6 +11,7 @@
 
 import java.util.*;
 
+@SuppressWarnings({ "unchecked", "rawtypes" })
 public class BTreeSet3Test extends JSR166TestCase {
     public static void main(String[] args) {
         junit.textui.TestRunner.run(suite());

File: src/main/java/org/mapdb/AsyncWriteEngine.java
Patch:
@@ -20,7 +20,6 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;

File: src/main/java/org/mapdb/BTreeKeySerializer.java
Patch:
@@ -5,7 +5,6 @@
 import java.io.IOException;
 import java.io.Serializable;
 import java.nio.charset.Charset;
-import java.util.Arrays;
 import java.util.Comparator;
 
 /**
@@ -210,7 +209,7 @@ public Comparator<String> getComparator() {
     /**
      * Read previously written data from {@code leadingValuePackWrite()} method.
      *
-     * @author Kevin Day
+     * author: Kevin Day
      */
     public static byte[] leadingValuePackRead(DataInput in, byte[] previous, int ignoreLeadingCount) throws IOException {
         int len = DataInput2.unpackInt(in) - 1;  // 0 indicates null
@@ -239,7 +238,7 @@ public static byte[] leadingValuePackRead(DataInput in, byte[] previous, int ign
      * Writes the contents of buf to the DataOutput out, with special encoding if
      * there are common leading bytes in the previous group stored by this compressor.
      *
-     * @author Kevin Day
+     * author: Kevin Day
      */
     public static void leadingValuePackWrite(DataOutput out, byte[] buf, byte[] previous, int ignoreLeadingCount) throws IOException {
         if (buf == null) {

File: src/main/java/org/mapdb/DataOutput2.java
Patch:
@@ -24,7 +24,7 @@
 /**
   * Provides {@link DataOutput} implementation on top of growable {@code byte[]}
  * <p/>
- *  {@link ByteArrayOutputStream} is not used as it requires {@code byte[]} copying
+ *  {@link java.io.ByteArrayOutputStream} is not used as it requires {@code byte[]} copying
  *
  * @author Jan Kotek
  */

File: src/main/java/org/mapdb/Serializer.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.io.*;
 import java.nio.charset.Charset;
-import java.util.*;
+import java.util.UUID;
 
 /**
  * Provides serialization and deserialization

File: src/main/java/org/mapdb/SerializerBase.java
Patch:
@@ -28,7 +28,7 @@
  * @author Jan Kotek
  */
 @SuppressWarnings({ "unchecked", "rawtypes" })
-public class SerializerBase implements Serializer{
+public class SerializerBase implements Serializer<Object>{
 
 
     protected static final String EMPTY_STRING = "";
@@ -151,7 +151,7 @@ public void serialize(final DataOutput out, final Object obj, FastArrayList<Obje
 
     }
 
-    private void serialize2(DataOutput out, Object obj, FastArrayList<Object> objectStack, Class clazz) throws IOException {
+    private void serialize2(DataOutput out, Object obj, FastArrayList<Object> objectStack, Class<?> clazz) throws IOException {
         if (obj instanceof byte[]) {
             byte[] b = (byte[]) obj;
             serializeByteArray(out, b);
@@ -261,7 +261,7 @@ private void serialize2(DataOutput out, Object obj, FastArrayList<Object> object
         }
 
 
-        /** classes bellow need object stack, so initialize it if not alredy initialized*/
+        /** classes bellow need object stack, so initialize it if not already initialized*/
         if (objectStack == null) {
             objectStack = new FastArrayList();
             objectStack.add(obj);

File: src/main/java/org/mapdb/StoreHeap.java
Patch:
@@ -8,8 +8,6 @@
 import java.util.concurrent.ConcurrentSkipListMap;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 /**
  * Store which keeps all instances on heap. It does not use serialization.

File: src/main/java/org/mapdb/Volume.java
Patch:
@@ -21,7 +21,7 @@
 import java.nio.ByteBuffer;
 import java.nio.MappedByteBuffer;
 import java.nio.channels.FileChannel;
-import java.util.*;
+import java.util.Arrays;
 import java.util.concurrent.locks.ReentrantLock;
 
 /**

File: src/test/java/examples/Secondary_Values.java
Patch:
@@ -3,7 +3,7 @@
 import org.mapdb.*;
 
 import java.io.Serializable;
-import java.util.*;
+import java.util.NavigableSet;
 
 /**
  * Example demonstrate 1:N relation between two collections.

File: src/test/java/org/mapdb/AtomicBooleanTest.java
Patch:
@@ -7,7 +7,6 @@
  */
 
 import junit.framework.TestCase;
-import org.junit.Before;
 
 public class AtomicBooleanTest extends TestCase{
 

File: src/test/java/org/mapdb/AtomicIntegerTest.java
Patch:
@@ -7,7 +7,6 @@
  */
 
 import junit.framework.TestCase;
-import org.junit.Before;
 
 public class AtomicIntegerTest extends TestCase {
 

File: src/test/java/org/mapdb/AtomicLongTest.java
Patch:
@@ -7,7 +7,6 @@
  */
 
 import junit.framework.TestCase;
-import org.junit.Before;
 
 public class AtomicLongTest extends TestCase {
 

File: src/test/java/org/mapdb/BTreeMapLargeValsTest.java
Patch:
@@ -17,8 +17,6 @@
 
 package org.mapdb;
 
-import org.junit.Before;
-
 import java.util.concurrent.ConcurrentMap;
 
 public class BTreeMapLargeValsTest extends ConcurrentMapInterfaceTest<Integer, String> {

File: src/test/java/org/mapdb/BTreeMapNavigable2Test.java
Patch:
@@ -1,7 +1,6 @@
 package org.mapdb;
 
 import junit.framework.TestCase;
-import org.junit.Before;
 
 import java.util.*;
 

File: src/test/java/org/mapdb/BTreeMapTest2.java
Patch:
@@ -17,8 +17,6 @@
 
 package org.mapdb;
 
-import org.junit.Before;
-
 import java.util.concurrent.ConcurrentMap;
 
 public class BTreeMapTest2 extends ConcurrentMapInterfaceTest<Integer, String> {

File: src/test/java/org/mapdb/BTreeMapTest6.java
Patch:
@@ -11,6 +11,7 @@
 import java.util.*;
 import java.util.concurrent.ConcurrentNavigableMap;
 
+@SuppressWarnings({"rawtypes","unchecked"})
 public class BTreeMapTest6 extends JSR166TestCase {
     public static void main(String[] args) {
         junit.textui.TestRunner.run(suite());

File: src/test/java/org/mapdb/BrokenDBTest.java
Patch:
@@ -1,14 +1,14 @@
 package org.mapdb;
 
-import java.io.*;
-import java.util.Arrays;
-
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import org.mapdb.Volume.MappedFileVol;
 
+import java.io.*;
+import java.util.Arrays;
+
 public class BrokenDBTest {
     File index;
     File data;

File: src/test/java/org/mapdb/CompressTest.java
Patch:
@@ -5,9 +5,7 @@
 
 import java.io.IOException;
 
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 
 public class CompressTest{
 

File: src/test/java/org/mapdb/EngineWrapper_ImmutabilityCheckEngine.java
Patch:
@@ -8,6 +8,7 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+@SuppressWarnings({"rawtypes","unchecked"})
 public class EngineWrapper_ImmutabilityCheckEngine {
 
     @Test

File: src/test/java/org/mapdb/HTreeMap2Test.java
Patch:
@@ -12,7 +12,6 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import static org.junit.Assert.*;
-import static org.junit.Assert.assertEquals;
 
 @SuppressWarnings({ "unchecked", "rawtypes" })
 public class HTreeMap2Test {

File: src/test/java/org/mapdb/Issue241.java
Patch:
@@ -2,7 +2,6 @@
 
 import org.junit.Test;
 
-
 import java.io.File;
 import java.io.Serializable;
 import java.util.Map;

File: src/test/java/org/mapdb/Issue247Test.java
Patch:
@@ -6,8 +6,6 @@
 import java.io.File;
 import java.util.Map;
 
-import static org.junit.Assert.assertEquals;
-
 public class Issue247Test {
 
         private Map getMap(DB db){

File: src/test/java/org/mapdb/Issue249Test.java
Patch:
@@ -1,10 +1,10 @@
 package org.mapdb;
 
+import org.junit.Test;
+
 import java.io.Serializable;
 import java.util.Map;
 
-import org.junit.Test;
-
 
 public class Issue249Test {
 

File: src/test/java/org/mapdb/Pump_InMemory_Import_Then_Save_To_Disk.java
Patch:
@@ -1,7 +1,5 @@
 package org.mapdb;
 
-import org.mapdb.*;
-
 import java.io.File;
 import java.util.Map;
 import java.util.Random;

File: src/test/java/org/mapdb/QueuesTest.java
Patch:
@@ -9,9 +9,7 @@
 import java.util.concurrent.BlockingQueue;
 
 import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertThat;
+import static org.junit.Assert.*;
 
 public class QueuesTest {
 

File: src/test/java/org/mapdb/StoreDirectTest.java
Patch:
@@ -4,7 +4,9 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import java.io.*;
+import java.io.File;
+import java.io.IOError;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;

File: src/test/java/org/mapdb/TestTransactions.java
Patch:
@@ -1,9 +1,10 @@
 package org.mapdb;
 
 
-import java.util.Map;
 import org.junit.Test;
 
+import java.util.Map;
+
 /**
  *
  * @author Alan Franzoni

File: src/test/java/org/mapdb/UtilsTest.java
Patch:
@@ -6,10 +6,10 @@
 import java.io.*;
 import java.nio.ByteBuffer;
 import java.util.Random;
-import java.util.Set;
 
 import static java.util.Arrays.asList;
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
 
 public class UtilsTest {
 

File: src/main/java/org/mapdb/Volume.java
Patch:
@@ -282,7 +282,7 @@ public final boolean tryAvailable(long offset) {
                 chunks2 = Arrays.copyOf(chunks2, Math.max(chunkPos+1, chunks2.length * 2));
 
                 for(int pos=oldSize;pos<chunks2.length;pos++) {
-                    chunks2[pos]=makeNewBuffer(chunkSize*pos);
+                    chunks2[pos]=makeNewBuffer(1L*chunkSize*pos);
                 }
 
 

File: src/main/java/org/mapdb/Volume.java
Patch:
@@ -420,7 +420,7 @@ public MappedFileVol(File file, boolean readOnly, long sizeLimit, int chunkShift
                 final long fileSize = fileChannel.size();
                 if(fileSize>0){
                     //map existing data
-                    chunks = new ByteBuffer[(int) (1+(fileSize>>> chunkShift))];
+                    chunks = new ByteBuffer[(int) ((fileSize>>> chunkShift))];
                     for(int i=0;i<chunks.length;i++){
                         chunks[i] = makeNewBuffer(i*chunkSize);
                     }
@@ -481,6 +481,7 @@ public void sync() {
         protected ByteBuffer makeNewBuffer(long offset) {
             try {
                 assert((offset&chunkSizeModMask)==0);
+                assert(offset>=0);
                 ByteBuffer ret = fileChannel.map(mapMode,offset,chunkSize);
                 if(mapMode == FileChannel.MapMode.READ_ONLY) {
                     ret = ret.asReadOnlyBuffer();

File: src/main/java/org/mapdb/AsyncWriteEngine.java
Patch:
@@ -495,7 +495,8 @@ public void close() {
                 throw new AssertionError();
 
             //wait for background threads to shutdown
-            activeThreadsCount.await();
+
+            activeThreadsCount.await(1000,TimeUnit.MILLISECONDS);
 
             //put preallocated recids back to store
             newRecidsLock.lock();

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -175,11 +175,9 @@ protected static SortedMap<String, Object> preinitCatalog(DB db) {
             db.getEngine().update(Engine.CATALOG_RECID,rootRef, Serializer.LONG);
             db.getEngine().commit();
         }
-        Serializer valSer = db.getDefaultSerializer();
-        assert(valSer!=null);
         return new BTreeMap<String, Object>(db.engine,Engine.CATALOG_RECID,32,false,0,
                 BTreeKeySerializer.STRING,
-                valSer,
+                db.getDefaultSerializer(),
                 COMPARABLE_COMPARATOR,0);
     }
 

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -94,7 +94,7 @@ public class HTreeMap<K,V>   extends AbstractMap<K,V> implements ConcurrentMap<K
             }
 
 
-            HTreeMap.this.engine.closeListenerUnregister(HTreeMap.this.closeListener);
+            HTreeMap.this.engine.unregisterCloseListener(HTreeMap.this.closeListener);
         }
     };
 
@@ -278,7 +278,7 @@ public HTreeMap(Engine engine, long counterRecid, int hashSalt, long[] segmentRe
             t.setDaemon(true);
             t.start();
             
-            engine.closeListenerRegister(closeListener);
+            engine.registerCloseListener(closeListener);
         }
 
     }

File: src/test/java/org/mapdb/Issue249Test.java
Patch:
@@ -5,8 +5,6 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.assertTrue;
-
 
 public class Issue249Test {
 
@@ -24,7 +22,6 @@ public void main() {
         map.put(x.getId(), x);
 
         db = commit(db);
-        assertTrue(db.isClosed());
         db = rollback(db);
 
         DB db2 = txMaker.makeTx();

File: src/main/java/org/mapdb/CC.java
Patch:
@@ -84,6 +84,6 @@ public interface CC {
     boolean FAIR_LOCKS = false;
 
 
-    int VOLUME_CHUNK_SHIFT = 24; // 16 MB
+    int VOLUME_CHUNK_SHIFT = 20; // 1 MB
 }
 

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -123,7 +123,7 @@ public class StoreDirect extends Store{
     protected static final long MASK_ARCHIVE = 0x2L;
 
     /** 4 byte file header */
-    protected static final int HEADER = 234222482;
+    protected static final int HEADER = 234243482;
 
     /** 2 byte store version*/
     protected static final short STORE_VERSION = 10000;

File: src/main/java/org/mapdb/Volume.java
Patch:
@@ -660,8 +660,8 @@ protected static void checkFolder(File file, boolean readOnly) throws IOExceptio
                 throw new IOException("Parent folder does not exist: "+file);
             if(!parent.canRead())
                 throw new IOException("Parent folder is not readable: "+file);
-            if(readOnly && !parent.canWrite())
-                throw new IOException("Parent folder is not writeable: "+file);
+            if(!readOnly && !parent.canWrite())
+                throw new IOException("Parent folder is not writable: "+file);
         }
 
         @Override

File: src/main/java/org/mapdb/Volume.java
Patch:
@@ -477,7 +477,8 @@ public void sync() {
         @Override
         protected ByteBuffer makeNewBuffer(long offset) {
             try {
-                ByteBuffer ret = fileChannel.map(mapMode,0,CHUNK_SIZE);
+                assert((offset&CHUNK_SIZE_MOD_MASK)==0);
+                ByteBuffer ret = fileChannel.map(mapMode,offset,CHUNK_SIZE);
                 if(mapMode == FileChannel.MapMode.READ_ONLY) {
                     ret = ret.asReadOnlyBuffer();
                 }

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -175,9 +175,11 @@ protected static SortedMap<String, Object> preinitCatalog(DB db) {
             db.getEngine().update(Engine.CATALOG_RECID,rootRef, Serializer.LONG);
             db.getEngine().commit();
         }
+        Serializer valSer = db.getDefaultSerializer();
+        assert(valSer!=null);
         return new BTreeMap<String, Object>(db.engine,Engine.CATALOG_RECID,32,false,0,
                 BTreeKeySerializer.STRING,
-                db.getDefaultSerializer(),
+                valSer,
                 COMPARABLE_COMPARATOR,0);
     }
 

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -94,7 +94,7 @@ public class HTreeMap<K,V>   extends AbstractMap<K,V> implements ConcurrentMap<K
             }
 
 
-            HTreeMap.this.engine.unregisterCloseListener(HTreeMap.this.closeListener);
+            HTreeMap.this.engine.closeListenerUnregister(HTreeMap.this.closeListener);
         }
     };
 
@@ -278,7 +278,7 @@ public HTreeMap(Engine engine, long counterRecid, int hashSalt, long[] segmentRe
             t.setDaemon(true);
             t.start();
             
-            engine.registerCloseListener(closeListener);
+            engine.closeListenerRegister(closeListener);
         }
 
     }

File: src/test/java/org/mapdb/Issue249Test.java
Patch:
@@ -5,6 +5,8 @@
 
 import org.junit.Test;
 
+import static org.junit.Assert.assertTrue;
+
 
 public class Issue249Test {
 
@@ -22,6 +24,7 @@ public void main() {
         map.put(x.getId(), x);
 
         db = commit(db);
+        assertTrue(db.isClosed());
         db = rollback(db);
 
         DB db2 = txMaker.makeTx();

File: src/test/java/org/mapdb/BTreeMapTest4.java
Patch:
@@ -1836,9 +1836,10 @@ public void test_empty_subMap() throws Exception {
         assertTrue(sm.values().size() == 0);
     }
     
-        public static BTreeMap treeMap = newBTreeMap();
+
 
         public void test_values_1(){
+            BTreeMap treeMap = newBTreeMap();
             treeMap.put("firstKey", "firstValue");
             treeMap.put("secondKey", "secondValue");
             treeMap.put("thirdKey", "thirdValue");

File: src/test/java/org/mapdb/BTreeSetTest.java
Patch:
@@ -8,10 +8,8 @@
 @SuppressWarnings({ "unchecked", "rawtypes" })
 public class BTreeSetTest extends HTreeSetTest{
 
-    @Override
 	@Before
     public void setUp() throws Exception {
-        super.setUp();
 
         hs = new BTreeMap(engine,BTreeMap.createRootRef(engine,BTreeKeySerializer.BASIC,null,BTreeMap.COMPARABLE_COMPARATOR,0),
                 6,false,0, BTreeKeySerializer.BASIC,null,

File: src/test/java/org/mapdb/Issue132Test.java
Patch:
@@ -22,13 +22,13 @@ static int count(final Iterator<?> iterator) {
         return counter;
     }
 
-    @Test(timeout=10000)
+    @Test(timeout=50000)
     public  void test_full() {
         long id= 0;
         for(int count = 0; count < 50; count++) {
 
 
-            DB db = DBMaker.newMemoryDirectDB().cacheDisable()
+            DB db = DBMaker.newMemoryDB().cacheDisable()
                     .checksumEnable().make();
 
 
@@ -66,7 +66,7 @@ public  void test_isolate() {
         int count = 18;
 
 
-        DB db = DBMaker.newMemoryDirectDB().cacheDisable()
+        DB db = DBMaker.newMemoryDB().cacheDisable()
                 .checksumEnable().make();
 
 

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -49,13 +49,13 @@ public class StoreWAL extends StoreDirect {
     protected final AtomicInteger logChecksum = new AtomicInteger();
 
     public StoreWAL(Volume.Factory volFac) {
-        this(volFac, false, false, 5, false, 0L, false, false, null, false);
+        this(volFac, false, false, 5, false, 0L, false, false, null);
     }
     public StoreWAL(Volume.Factory volFac, boolean readOnly, boolean deleteFilesAfterClose,
                     int spaceReclaimMode, boolean syncOnCommitDisabled, long sizeLimit,
-                    boolean checksum, boolean compress, byte[] password, boolean fullChunkAllocation) {
+                    boolean checksum, boolean compress, byte[] password) {
         super(volFac, readOnly, deleteFilesAfterClose, spaceReclaimMode, syncOnCommitDisabled, sizeLimit,
-                checksum, compress, password, fullChunkAllocation);
+                checksum, compress, password);
         this.volFac = volFac;
         this.log = volFac.createTransLogVolume();
 

File: src/test/java/org/mapdb/BTreeMapContainsKeyTest.java
Patch:
@@ -12,7 +12,7 @@
 public class BTreeMapContainsKeyTest extends JSR166TestCase {
 
 	boolean valsOutsideNodes = true;
-	Engine r = new StoreDirect(Volume.memoryFactory(false, 0L, false));
+	Engine r = new StoreDirect(Volume.memoryFactory(false, 0L));
 	RecordingSerializer valueSerializer = new RecordingSerializer();
 
     Map<Integer, String> map = new BTreeMap(r, createRootRef(r,BASIC, Serializer.BASIC, COMPARABLE_COMPARATOR,0),

File: src/test/java/org/mapdb/BTreeMapLargeValsTest.java
Patch:
@@ -27,7 +27,7 @@ public BTreeMapLargeValsTest() {
         super(false, false, true, true, true, true,false);
     }
 
-    Engine r = new StoreDirect(Volume.memoryFactory(false, 0L, false));
+    Engine r = new StoreDirect(Volume.memoryFactory(false, 0L));
 
 
     @Override

File: src/test/java/org/mapdb/BTreeMapTest.java
Patch:
@@ -12,7 +12,7 @@
 @SuppressWarnings({ "unchecked", "rawtypes" })
 public class BTreeMapTest{
 
-    Engine engine = new StoreDirect(Volume.memoryFactory(false,0L, false));
+    Engine engine = new StoreDirect(Volume.memoryFactory(false,0L));
 
 
     BTreeMap m = new BTreeMap(engine,BTreeMap.createRootRef(engine,BTreeKeySerializer.BASIC,Serializer.BASIC,BTreeMap.COMPARABLE_COMPARATOR,0),

File: src/test/java/org/mapdb/BTreeMapTest2.java
Patch:
@@ -25,7 +25,7 @@ public BTreeMapTest2() {
         super(false, false, true, true, true, true, false);
     }
 
-    Engine r = new StoreDirect(Volume.memoryFactory(false,0L, false));
+    Engine r = new StoreDirect(Volume.memoryFactory(false,0L));
 
 
     @Override

File: src/test/java/org/mapdb/BrokenDBTest.java
Patch:
@@ -67,7 +67,7 @@ public void canDeleteDBOnBrokenLog() throws IOException {
         DBMaker.newFileDB(index).make().close();
 
         // trash the log
-        MappedFileVol logVol = new Volume.MappedFileVol(log, false, 0, false);
+        MappedFileVol logVol = new Volume.MappedFileVol(log, false, 0);
         logVol.ensureAvailable(32);
         logVol.putInt(0, StoreWAL.HEADER);
         logVol.putUnsignedShort(4, StoreWAL.STORE_VERSION);

File: src/test/java/org/mapdb/DBTest.java
Patch:
@@ -13,7 +13,7 @@
 @SuppressWarnings({ "unchecked", "rawtypes" })
 public class DBTest {
 
-    Engine engine = new StoreDirect(Volume.memoryFactory(false,0L, false));
+    Engine engine = new StoreDirect(Volume.memoryFactory(false,0L));
     DB db = new DB(engine);
 
     @Test

File: src/test/java/org/mapdb/EngineWrapper_ImmutabilityCheckEngine.java
Patch:
@@ -12,7 +12,7 @@ public class EngineWrapper_ImmutabilityCheckEngine {
 
     @Test
     public void test(){
-        Volume.Factory fab = Volume.memoryFactory(false,0L, false);
+        Volume.Factory fab = Volume.memoryFactory(false,0L);
         Engine e = new StoreDirect(fab);
         e = new EngineWrapper.ImmutabilityCheckEngine(e);
 

File: src/test/java/org/mapdb/HTreeMap3Test.java
Patch:
@@ -23,7 +23,7 @@ public HTreeMap3Test() {
         super(false, false, true, true, true, true,true);
     }
 
-    StoreDirect r = new StoreDirect(Volume.memoryFactory(false,0L, false));
+    StoreDirect r = new StoreDirect(Volume.memoryFactory(false,0L));
 
     @Override
     protected Integer getKeyNotInPopulatedMap() throws UnsupportedOperationException {

File: src/test/java/org/mapdb/HTreeSetTest.java
Patch:
@@ -37,7 +37,7 @@
 @SuppressWarnings({"unchecked","rawtypes"})
 public class HTreeSetTest{
 
-    Engine engine = new StoreDirect(Volume.memoryFactory(false,0L, false));
+    Engine engine = new StoreDirect(Volume.memoryFactory(false,0L));
 
     Set hs;
 

File: src/test/java/org/mapdb/StoreAppendTest.java
Patch:
@@ -1,6 +1,7 @@
 package org.mapdb;
 
 
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.File;
@@ -20,7 +21,7 @@ protected E openEngine() {
         return (E) new StoreAppend(f);
     }
 
-    @Test
+    @Test @Ignore
     public void compact_file_deleted(){
         File f = UtilsTest.tempDbFile();
         StoreAppend engine = new StoreAppend(f);

File: src/test/java/org/mapdb/StoreDirectFreeSpaceTest.java
Patch:
@@ -13,7 +13,7 @@ public class StoreDirectFreeSpaceTest {
     final Map<Long,Deque<Long>> longStacks = new TreeMap <Long,Deque<Long>>();
 
     /** mock longStacks so their page allocations wont mess up tests */
-    StoreDirect stub = new  StoreDirect(Volume.memoryFactory(false,max, false),false,false,5,false,max,false,false,null, false){
+    StoreDirect stub = new  StoreDirect(Volume.memoryFactory(false,max),false,false,5,false,max,false,false,null){
         {
             structuralLock.lock();
         }

File: src/test/java/org/mapdb/StoreDirectTest.java
Patch:
@@ -16,7 +16,7 @@ public class StoreDirectTest <E extends StoreDirect> extends EngineTest<E>{
     @Override boolean canRollback(){return false;}
 
     File f = UtilsTest.tempDbFile();
-    Volume.Factory fac = Volume.fileFactory(false,0,f, 0L,false);
+    Volume.Factory fac = Volume.fileFactory(false,0,f, 0L);
 
     static final long IO_RECID = StoreDirect.IO_FREE_RECID+32;
 
@@ -417,7 +417,7 @@ public void phys_append_alloc_link3(){
         e.close();
 
         //increment store version
-        Volume v = Volume.volumeForFile(f,true,false,0,false);
+        Volume v = Volume.volumeForFile(f,true,false,0);
         v.putUnsignedShort(4,StoreDirect.STORE_VERSION+1);
         v.sync();
         v.close();
@@ -444,7 +444,7 @@ public void phys_append_alloc_link3(){
 
         //increment store version
         File phys = new File(f.getPath()+StoreDirect.DATA_FILE_EXT);
-        Volume v = Volume.volumeForFile(phys,true,false,0,false);
+        Volume v = Volume.volumeForFile(phys,true,false,0);
         v.putUnsignedShort(4,StoreDirect.STORE_VERSION+1);
         v.sync();
         v.close();

File: src/test/java/org/mapdb/StoreWALTest.java
Patch:
@@ -13,7 +13,7 @@
 
 public class StoreWALTest extends StoreDirectTest<StoreWAL>{
 
-    Volume.Factory fac = Volume.fileFactory(false,0,f, 0L,false);
+    Volume.Factory fac = Volume.fileFactory(false,0,f, 0L);
 
     @Override
     protected StoreWAL openEngine() {
@@ -55,7 +55,7 @@ public void delete_files_after_close2(){
 
         //increment store version
         File index = new File(f.getPath()+StoreWAL.TRANS_LOG_FILE_EXT);
-        Volume v = Volume.volumeForFile(index,true,false,0,false);
+        Volume v = Volume.volumeForFile(index,true,false,0);
         v.ensureAvailable(100);
         v.putInt(0,StoreWAL.HEADER);
         v.putUnsignedShort(4,StoreDirect.STORE_VERSION+1);

File: src/test/java/org/mapdb/TestFile.java
Patch:
@@ -14,7 +14,7 @@ abstract public class TestFile {
     protected final File data = new File(index.getPath()+ StoreDirect.DATA_FILE_EXT);
     protected final File log = new File(index.getPath()+ StoreWAL.TRANS_LOG_FILE_EXT);
 
-    protected Volume.Factory fac = Volume.fileFactory(false, 0, 0L, false, index, data, log);
+    protected Volume.Factory fac = Volume.fileFactory(false, 0, 0L, index, data, log);
 
 
     @After public void after() throws IOException {

File: src/test/java/org/mapdb/TxEngineTest.java
Patch:
@@ -8,7 +8,7 @@
 
 public class TxEngineTest {
 
-    TxEngine e = new TxEngine(new StoreWAL(Volume.memoryFactory(false, 0L, false)),false);
+    TxEngine e = new TxEngine(new StoreWAL(Volume.memoryFactory(false, 0L)),false);
 
     @Test public void update(){
         long recid = e.put(111, Serializer.INTEGER);

File: src/main/java/org/mapdb/DBMaker.java
Patch:
@@ -687,7 +687,7 @@ public TxMaker makeTxMaker(){
         //init catalog if needed
         DB db = new DB(e);
         db.commit();
-        return new TxMaker(e);
+        return new TxMaker(e, propsGetBool(Keys.strictDBGet), propsGetBool(Keys.snapshots));
     }
 
     /** constructs Engine using current settings */

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -225,7 +225,7 @@ public StoreDirect(Volume.Factory volFac, boolean readOnly, boolean deleteFilesA
                     index = null;
                 }
                 if(phys!=null){
-                    index.sync();
+                    phys.sync();
                     phys.close();
                     phys = null;
                 }

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -782,7 +782,7 @@ protected void replayLogFile(){
 
         //read headers
         if(log.isEmpty() || log.getInt(0)!=HEADER ||
-                log.getUnsignedShort(4)>STORE_VERSION || log.getLong(8) !=LOG_SEAL | 
+                log.getUnsignedShort(4)>STORE_VERSION || log.getLong(8) !=LOG_SEAL ||
                 log.getUnsignedShort(6)!=expectedMasks()){
             //wrong headers, discard log
             log.close();

File: src/main/java/org/mapdb/BTreeKeySerializer.java
Patch:
@@ -9,8 +9,8 @@
 import java.util.Comparator;
 
 /**
- * Custom serializer for BTreeMap keys which enables <a href='https://en.wikipedia.org/wiki/Delta_encoding'>Delta encoding</a>.
- * <p/>
+ * Custom serializer for BTreeMap keys which enables [Delta encoding](https://en.wikipedia.org/wiki/Delta_encoding).
+ *
  * Keys in BTree Nodes are sorted, this enables number of tricks to save disk space.
  * For example for numbers we may store only difference between subsequent numbers, for string we can only take suffix, etc...
  *

File: src/main/java/org/mapdb/Store.java
Patch:
@@ -293,7 +293,7 @@ public static Store forEngine(Engine e){
     protected int expectedMasks(){
         return (encrypt?ENCRYPT_FLAG_MASK:0) |
                 (checksum?CHECKSUM_FLAG_MASK:0) |
-                (checksum?COMPRESS_FLAG_MASK:0);
+                (compress?COMPRESS_FLAG_MASK:0);
     }
 
     private static final int LOCK_MASK = CC.CONCURRENCY-1;

File: src/main/java/org/mapdb/Store.java
Patch:
@@ -293,7 +293,7 @@ public static Store forEngine(Engine e){
     protected int expectedMasks(){
         return (encrypt?ENCRYPT_FLAG_MASK:0) |
                 (checksum?CHECKSUM_FLAG_MASK:0) |
-                (checksum?COMPRESS_FLAG_MASK:0);
+                (compress?COMPRESS_FLAG_MASK:0);
     }
 
     private static final int LOCK_MASK = CC.CONCURRENCY-1;

File: src/main/java/org/mapdb/DBMaker.java
Patch:
@@ -558,7 +558,7 @@ public DBMakerT encryptionEnable(byte[] password){
 
 
     /**
-     * Adds Adler32 checksum at end of each record to check data integrity.
+     * Adds CRC32 checksum at end of each record to check data integrity.
      * It throws 'IOException("Checksum does not match, data broken")' on de-serialization if data are corrupted
      * <p/>
      * Make sure you enable this every time you reopen store, otherwise record de-serialization fails.

File: src/main/java/org/mapdb/DB.java
Patch:
@@ -1460,7 +1460,7 @@ synchronized public void rename(String oldName, String newName){
      * @throws IllegalArgumentException if name is already used
      */
     protected void checkNameNotExists(String name) {
-        if(catalog.get(name)!=null)
+        if(catalog.get(name+".type")!=null)
             throw new IllegalArgumentException("Name already used: "+name);
     }
 

File: src/main/java/org/mapdb/EngineWrapper.java
Patch:
@@ -588,7 +588,7 @@ public void run() {
 
         public CloseOnJVMShutdown(Engine engine) {
             super(engine);
-            hook = new Thread(hookRunnable,"MapDB shudown hook");
+            hook = new Thread(hookRunnable,"MapDB shutdown hook");
             Runtime.getRuntime().addShutdownHook(hook);
         }
 

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -23,7 +23,6 @@
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
-import java.util.logging.Level;
 
 /**
  * Thread safe concurrent HashMap
@@ -1531,12 +1530,12 @@ protected void expirePurge(){
         }
 
         for(int seg=0;seg<16;seg++){
-            exirePurgeSegment(seg,removePerSegment);
+            expirePurgeSegment(seg, removePerSegment);
         }
 
     }
 
-    protected void exirePurgeSegment(int seg, long removePerSegment) {
+    protected void expirePurgeSegment(int seg, long removePerSegment) {
         segmentLocks[seg].writeLock().lock();
         try{
 //            expireCheckSegment(seg);

File: src/main/java/org/mapdb/CC.java
Patch:
@@ -58,6 +58,7 @@ public interface CC {
 
 
     int ASYNC_WRITE_FLUSH_DELAY = 100;
+    int ASYNC_WRITE_QUEUE_SIZE = 32000;
 
     int ASYNC_RECID_PREALLOC_QUEUE_SIZE = 128;
 

File: src/test/java/examples/TreeMap_Composite_Key.java
Patch:
@@ -35,7 +35,7 @@ public static void main(String[] args) {
 
         //initial values
         String[] towns = {"Galway", "Ennis", "Gort", "Cong", "Tuam"};
-        String[] streets = {"Main street", "Shop street", "Second street", "Silver Strands"};
+        String[] streets = {"Main Street", "Shop Street", "Second Street", "Silver Strands"};
         int[] houseNums = {1,2,3,4,5,6,7,8,9,10};
 
         DB db = DBMaker.newMemoryDB().make();

File: src/main/java/org/mapdb/SerializerBase.java
Patch:
@@ -1170,7 +1170,7 @@ private Object deserialize2(int head, DataInput is) throws IOException {
                 break;
 
             case Header.ARRAY_BOOLEAN:
-                ret = readBooleanArray(is);
+                ret = readBooleanArray(DataInput2.unpackInt(is),is);
                 break;
             case Header.ARRAY_SHORT:
                 int size = DataInput2.unpackInt(is);
@@ -1780,8 +1780,7 @@ protected static byte[] booleanToByteArray(boolean[] bool) {
      * @return The boolean array decompressed from the bytes read in.
      * @throws IOException If an error occurred while reading.
      */
-    protected static boolean[] readBooleanArray(DataInput is) throws IOException {
-        int numBools = DataInput2.unpackInt(is);
+    protected static boolean[] readBooleanArray(int numBools,DataInput is) throws IOException {
         int length = (numBools/8)+((numBools%8 == 0)?0:1);
         byte[] boolBytes = new byte[length];
         is.readFully(boolBytes);

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -181,12 +181,12 @@ public ValRef(long recid) {
 
         @Override
         public boolean equals(Object obj) {
-            throw new InternalError();
+            throw new IllegalAccessError();
         }
 
         @Override
         public int hashCode() {
-            throw new InternalError();
+            throw new IllegalAccessError();
         }
 
         @Override

File: src/main/java/org/mapdb/DB.java
Patch:
@@ -1313,7 +1313,7 @@ synchronized public <E> E get(String name){
         if("Queue".equals(type)) return (E) getQueue(name);
         if("Stack".equals(type)) return (E) getStack(name);
         if("CircularQueue".equals(type)) return (E) getCircularQueue(name);
-        throw new InternalError("Unknown type: "+name);
+        throw new AssertionError("Unknown type: "+name);
     }
 
     synchronized public boolean exists(String name){

File: src/main/java/org/mapdb/SerializerBase.java
Patch:
@@ -1263,7 +1263,7 @@ private Object deserialize2(int head, DataInput is) throws IOException {
                 ret = Fun.HI;
                 break;
             case Header.JAVA_SERIALIZATION:
-                throw new InternalError("Wrong header, data were probably serialized with java.lang.ObjectOutputStream, not with MapDB serialization");
+                throw new AssertionError("Wrong header, data were probably serialized with java.lang.ObjectOutputStream, not with MapDB serialization");
             case Header.ARRAY_OBJECT_PACKED_LONG:
                 ret = deserializeArrayObjectPackedLong(is);
                 break;
@@ -1633,11 +1633,11 @@ private Properties deserializeProperties(DataInput is, FastArrayList<Object> obj
 
     /** override this method to extend SerializerBase functionality*/
     protected void serializeUnknownObject(DataOutput out, Object obj, FastArrayList<Object> objectStack) throws IOException {
-        throw new InternalError("Could not serialize unknown object: "+obj.getClass().getName());
+        throw new AssertionError("Could not serialize unknown object: "+obj.getClass().getName());
     }
     /** override this method to extend SerializerBase functionality*/
     protected Object deserializeUnknownHeader(DataInput is, int head, FastArrayList<Object> objectStack) throws IOException {
-        throw new InternalError("Unknown serialization header: " + head);
+        throw new AssertionError("Unknown serialization header: " + head);
     }
 
     /**

File: src/main/java/org/mapdb/StoreAppend.java
Patch:
@@ -208,7 +208,7 @@ protected File getFileFromNum(long fileNumber){
     }
 
     protected void rollover(){
-        if(currVolume.getLong(0)!=HEADER) throw new InternalError();
+        if(currVolume.getLong(0)!=HEADER) throw new AssertionError();
         if(currPos<=FILE_MASK || readOnly) return;
         //beyond usual file size, so create new file
         currVolume.sync();

File: src/main/java/org/mapdb/Volume.java
Patch:
@@ -157,6 +157,7 @@ public int putPackedLong(long pos, long value) {
     abstract public File getFile();
 
     public long getPackedLong(long pos){
+        //TODO unrolled version?
         long result = 0;
         for (int offset = 0; offset < 64; offset += 7) {
             long b = getUnsignedByte(pos++);
@@ -165,7 +166,7 @@ public long getPackedLong(long pos){
                 return result;
             }
         }
-        throw new Error("Malformed long.");
+        throw new AssertionError("Malformed long.");
     }
 
 

File: src/test/java/org/mapdb/Pump_InMemory_Import_Then_Save_To_Disk.java
Patch:
@@ -14,6 +14,7 @@
 public class Pump_InMemory_Import_Then_Save_To_Disk {
 
     public static void main(String[] args) {
+        if(1==1) return;
 
         //create inMemory store which does not use serialization,
         //and has speed comparable to `java.util` collections

File: src/test/java/org/mapdb/DBMakerTest.java
Patch:
@@ -309,7 +309,7 @@ public void reopen_wrong_compress() throws IOException {
 
     @Test public void rafEnableKeepIndexMapped(){
         DB db = DBMaker.newFileDB(Utils.tempDbFile())
-                .randomAccessFileEnableKeepIndexMapped()
+                .mmapFileEnablePartial()
                 .make();
         Engine e = db.getEngine();
         while(e instanceof EngineWrapper)

File: src/test/java/org/mapdb/Issue114Test.java
Patch:
@@ -7,7 +7,9 @@ public class Issue114Test {
 
     @Test
     public void test(){
-        DB db = DBMaker.newTempFileDB().randomAccessFileEnable().transactionDisable().make();
+        DB db = DBMaker.newTempFileDB()
+                //.randomAccessFileEnable()
+                .transactionDisable().make();
         db.getCircularQueue("test");
     }
 }

File: src/test/java/org/mapdb/Issue198Test.java
Patch:
@@ -10,7 +10,7 @@ public class Issue198Test {
 
         DB db = DBMaker.newFileDB(Utils.tempDbFile())
                 .closeOnJvmShutdown()
-                .randomAccessFileEnable()
+                //.randomAccessFileEnable()
                 .make();
         BTreeMap<Integer, Integer> map = db.createTreeMap("testmap").makeOrGet();
         for(int i = 1; i <= 3000; ++i)

File: src/test/java/org/mapdb/Issue77Test.java
Patch:
@@ -27,7 +27,7 @@ DB open(boolean readOnly) {
         if (readOnly) {
             maker.readOnly();
         }
-        maker.randomAccessFileEnableIfNeeded();
+//        maker.randomAccessFileEnableIfNeeded();
         maker.closeOnJvmShutdown();
         DB db = maker.make(); // InternalError, UnsupportedOperationException
         return db;

File: src/test/java/examples/CacheEntryExpiry.java
Patch:
@@ -37,10 +37,10 @@ public static void main(String[] args) {
         //one can monitor two space usage numbers:
 
         //free space in store
-        long freeSize = Pump.storeForDB(db).getFreeSize();
+        long freeSize = Store.forDB(db).getFreeSize();
 
         //current size of store (how much memory it has allocated
-        long currentSize = Pump.storeForDB(db).getCurrSize();
+        long currentSize = Store.forDB(db).getCurrSize();
 
 
     }

File: src/test/java/org/mapdb/CompressTest.java
Patch:
@@ -19,7 +19,7 @@ public class CompressTest{
 
     @Test
     public void check_instance() throws Exception {
-        Store s = Pump.storeForDB(db);
+        Store s = Store.forDB(db);
         assertTrue(s.compress);
     }
 

File: src/test/java/org/mapdb/Pump_InMemory_Import_Then_Save_To_Disk.java
Patch:
@@ -1,4 +1,4 @@
-package examples;
+package org.mapdb;
 
 import org.mapdb.*;
 
@@ -10,6 +10,7 @@
  * This demonstrates using Data Pump to first create store in-memory at maximal speed,
  * and than copy the store into memory
  */
+//TODO Pump between stores is disabled for now, copy this back to examples  once enabled
 public class Pump_InMemory_Import_Then_Save_To_Disk {
 
     public static void main(String[] args) {

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -1611,6 +1611,7 @@ public void removeModificationListener(Bind.MapListener<K,V> listener) {
     }
 
     protected void notify(K key, V oldValue, V newValue) {
+        assert(segmentLocks[hash(key)>>>28].isWriteLockedByCurrentThread());
         Bind.MapListener<K,V>[] modListeners2  = modListeners;
         for(Bind.MapListener<K,V> listener:modListeners2){
             if(listener!=null)

File: src/test/java/org/mapdb/Issue241.java
Patch:
@@ -22,7 +22,6 @@ public void main()
         map.put(1L, new CustomClass("aString", 1001L)); //$NON-NLS-1$
         db.commit();
         db.close();
-        db.close();
 
         db = getDb();
         map = db.getTreeMap(mapName);

File: src/main/java/org/mapdb/TxEngine.java
Patch:
@@ -522,11 +522,11 @@ public void commit() {
                 }
             }
 
-            superCommit();
-
-            //commit was sucessfull, so update the POJO in parent
+            //there are no conflicts, so update the POJO in parent
             //TODO sort of hack, is it thread safe?
             getWrappedEngine().getSerializerPojo().registered = pojo.registered;
+            superCommit();
+
             close();
         }finally {
             commitLock.writeLock().unlock();

File: src/main/java/org/mapdb/Fun.java
Patch:
@@ -31,7 +31,7 @@
 public final class Fun {
 
 
-	public static final Comparator<Comparable> COMPARATOR = new Comparator<Comparable>() {
+	public static final Comparator COMPARATOR = new Comparator<Comparable>() {
         @Override
         public int compare(Comparable o1, Comparable o2) {
             if(o1 == null)

File: src/main/java/org/mapdb/Utils.java
Patch:
@@ -39,7 +39,7 @@ final public class Utils {
 
 
     @SuppressWarnings("rawtypes")
-	public static final Comparator<Comparable> COMPARABLE_COMPARATOR = new Comparator<Comparable>() {
+	public static final Comparator COMPARABLE_COMPARATOR = new Comparator<Comparable>() {
         @Override
         public int compare(Comparable o1, Comparable o2) {
             return o1.compareTo(o2);

File: src/main/java/org/mapdb/Store.java
Patch:
@@ -98,15 +98,15 @@ public  SerializerPojo getSerializerPojo() {
 
 
     protected void lockAllWrite() {
-        for(ReentrantReadWriteLock l:locks)l.writeLock().lock();
         newRecidLock.writeLock().lock();
+        for(ReentrantReadWriteLock l:locks)l.writeLock().lock();
         structuralLock.lock();
     }
 
     protected void unlockAllWrite() {
         structuralLock.unlock();
-        newRecidLock.writeLock().unlock();
         for(ReentrantReadWriteLock l:locks)l.writeLock().unlock();
+        newRecidLock.writeLock().unlock();
     }
 
 

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -433,7 +433,7 @@ public <A> boolean compareAndSwap(long recid, A expectedOldValue, A newValue, Se
                 openLogIfNeeded();
 
                 //free first record pointed from indexVal
-                if(indexVal!=0)
+                if((indexVal>>>48)>0)
                     freePhysPut(indexVal,false);
 
                 //if there are more linked records, free those as well
@@ -494,7 +494,7 @@ public <A> void delete(long recid, Serializer<A> serializer) {
                 longStackPut(IO_FREE_RECID, ioRecid,false);
 
                 //free first record pointed from indexVal
-                if(indexVal!=0)
+                if((indexVal>>>48)>0)
                     freePhysPut(indexVal,false);
 
                 //if there are more linked records, free those as well

File: src/main/java/org/mapdb/AsyncWriteEngine.java
Patch:
@@ -35,7 +35,7 @@
  *
  * This feature is enabled by default and can be disabled by calling {@link DBMaker#asyncWriteDisable()}.
  * Write Cache is flushed in regular intervals or when it becomes full. Flush interval is 100 ms by default and
- * can be controlled by {@link DBMaker#asyncFlushDelay(int)}. Increasing this interval may improve performance
+ * can be controlled by {@link DBMaker#asyncWriteFlushDelay(int)}. Increasing this interval may improve performance
  * in scenarios where frequently modified items should be cached, typically {@link BTreeMap} import where keys
  * are presorted.
  *

File: src/test/java/examples/Compression.java
Patch:
@@ -18,7 +18,7 @@ public static void main(String[] args) {
         /*
          * first case, just enable storage wide compression for all records.
          */
-        DB db = DBMaker.newMemoryDB().asyncWriteDisable()
+        DB db = DBMaker.newMemoryDB()
                 .compressionEnable() //this settings enables compression
                 .make();
         //and now create and use map as usual
@@ -32,7 +32,7 @@ public static void main(String[] args) {
          * you have large values, you may want to compress them. It may make sense
          * not to compress BTree Nodes and Keys.
          */
-        DB db2 = DBMaker.newMemoryDB().asyncWriteDisable().make(); //no store wide compression this time
+        DB db2 = DBMaker.newMemoryDB().make(); //no store wide compression this time
 
         //construct value serializier, use default serializier
         Serializer valueSerializer = db2.getDefaultSerializer();

File: src/test/java/examples/DBMakerExtend.java
Patch:
@@ -42,7 +42,6 @@ public static void main(String[] args) {
         File dbFile = new File("db");
         DB db = new ExtendedDBMaker() //static constructors can not be used on extended class
                 ._newFileDB(dbFile) //so use constructor and call method with underscore
-                .asyncWriteDisable()
                 .compressionEnable()
                 .loggingDisable() //this option does not exist in original DBMaker
                 .make();

File: src/test/java/org/mapdb/BTreeMapExtendTest.java
Patch:
@@ -65,7 +65,7 @@ public class BTreeMapExtendTest extends TestCase {
     Object objArray[] = new Object[1000];
 
     protected static BTreeMap newBTreeMap() {
-        return DBMaker.newMemoryDB().cacheDisable().transactionDisable().asyncWriteDisable().make().getTreeMap("Test");
+        return DBMaker.newMemoryDB().cacheDisable().transactionDisable().make().getTreeMap("Test");
     }
 
 

File: src/test/java/org/mapdb/BTreeMapSubSetTest.java
Patch:
@@ -46,7 +46,7 @@ private NavigableSet<Integer> populatedSet(int n) {
 
     protected <E> NavigableSet<E> newNavigableSet() {
         return DBMaker.newMemoryDB().transactionDisable()
-                .cacheDisable().asyncWriteDisable()
+                .cacheDisable()
                 .make().getTreeSet("test");
     }
 

File: src/test/java/org/mapdb/BTreeMapTest4.java
Patch:
@@ -29,7 +29,7 @@ public class BTreeMapTest4 extends junit.framework.TestCase {
     protected <K,V> BTreeMap<K,V> newBTreeMap(Map map) {
         BTreeMap ret = DBMaker.newMemoryDB()
                 .cacheDisable()
-                .asyncWriteDisable().transactionDisable().make()
+                .transactionDisable().make()
                 .createTreeMap("test").nodeSize(6).make();
         ret.putAll(map);
         return ret;
@@ -38,14 +38,14 @@ protected <K,V> BTreeMap<K,V> newBTreeMap(Map map) {
     protected <K,V> BTreeMap<K,V> newBTreeMap(Comparator comp) {
         return DBMaker.newMemoryDB()
                 .cacheDisable()
-                .asyncWriteDisable().transactionDisable().make()
+                .transactionDisable().make()
                 .createTreeMap("test").nodeSize(6).comparator(comp).make();
     }
 
     protected static <K,V> BTreeMap<K,V> newBTreeMap() {
         return DBMaker.newMemoryDB()
                 .cacheDisable()
-                .asyncWriteDisable().transactionDisable().make()
+                .transactionDisable().make()
                 .getTreeMap("test");
     }
 

File: src/test/java/org/mapdb/CacheWeakSoftRefTest.java
Patch:
@@ -15,7 +15,6 @@ public void weak_htree_inserts_delete() throws InterruptedException {
         DB db = DBMaker
                 .newMemoryDB()
                 .cacheWeakRefEnable()
-                .asyncWriteDisable()
                 .make();
         testMap(db);
     }

File: src/test/java/org/mapdb/HTreeMap2Test.java
Patch:
@@ -14,7 +14,7 @@
 @SuppressWarnings({ "unchecked", "rawtypes" })
 public class HTreeMap2Test {
 
-    Engine engine = DBMaker.newMemoryDB().cacheDisable().asyncWriteDisable().makeEngine();
+    Engine engine = DBMaker.newMemoryDB().cacheDisable().makeEngine();
 
     DB db = new DB(engine);
 
@@ -507,7 +507,6 @@ public void cache_load_time_expire(){
                 DBMaker.newMemoryDB()
                 .sizeLimit(1)
                 .transactionDisable()
-                .asyncWriteDisable()
                 .cacheDisable()
                 .make();
 
@@ -528,7 +527,6 @@ public void cache_load_size_expire(){
         DB db = DBMaker.newMemoryDB()
                 .sizeLimit(1)
                 .transactionDisable()
-                .asyncWriteDisable()
                 .make();
 
         HTreeMap m = db.createHashMap("test")

File: src/test/java/org/mapdb/Issue114Test.java
Patch:
@@ -7,7 +7,7 @@ public class Issue114Test {
 
     @Test
     public void test(){
-        DB db = DBMaker.newTempFileDB().randomAccessFileEnable().transactionDisable().asyncWriteDisable().make();
+        DB db = DBMaker.newTempFileDB().randomAccessFileEnable().transactionDisable().make();
         db.getCircularQueue("test");
     }
 }

File: src/test/java/org/mapdb/Issue132Test.java
Patch:
@@ -28,7 +28,7 @@ public  void test_full() {
         for(int count = 0; count < 50; count++) {
 
 
-            DB db = DBMaker.newDirectMemoryDB().asyncWriteDisable().cacheDisable()
+            DB db = DBMaker.newDirectMemoryDB().cacheDisable()
                     .checksumEnable().make();
 
 
@@ -66,7 +66,7 @@ public  void test_isolate() {
         int count = 18;
 
 
-        DB db = DBMaker.newDirectMemoryDB().asyncWriteDisable().cacheDisable()
+        DB db = DBMaker.newDirectMemoryDB().cacheDisable()
                 .checksumEnable().make();
 
 

File: src/test/java/org/mapdb/Issue150Test.java
Patch:
@@ -16,7 +16,7 @@ public void test() {
         // TxMaker txMaker = DBMaker.newFileDB(new File("/tmp/mapdb.test"))
         // .closeOnJvmShutdown().asyncWriteDisable().makeTxMaker();
         TxMaker txMaker = DBMaker.newMemoryDB().closeOnJvmShutdown()
-                .asyncWriteDisable().makeTxMaker();
+                .makeTxMaker();
 
         DB db = txMaker.makeTx();
 

File: src/test/java/org/mapdb/Issue154Test.java
Patch:
@@ -11,7 +11,7 @@ public class Issue154Test {
 
     @Test
     public void HTreeMap(){
-        TxMaker txMaker = DBMaker.newMemoryDB().asyncWriteDisable().makeTxMaker();
+        TxMaker txMaker = DBMaker.newMemoryDB().makeTxMaker();
 
         /* Add the item */
 

File: src/test/java/org/mapdb/Issue157Test.java
Patch:
@@ -10,7 +10,7 @@ public class Issue157Test {
 
     @Test
     public void concurrent_BTreeMap() throws InterruptedException {
-        DBMaker dbMaker = DBMaker.newMemoryDB().cacheDisable().asyncWriteDisable();
+        DBMaker dbMaker = DBMaker.newMemoryDB().cacheDisable();
         DB db = dbMaker.make();
         final BTreeMap<Integer, String> map = db.getTreeMap("COL_2");
         map.clear();

File: src/test/java/org/mapdb/Issue162Test.java
Patch:
@@ -68,7 +68,7 @@ private static void printEntries(Map<Long, MyValue> map) {
     @Test public void testHashMap() {
         System.out.println("--- Testing HashMap with custom serializer");
 
-        DB db = DBMaker.newFileDB(path).asyncWriteDisable().make();
+        DB db = DBMaker.newFileDB(path).make();
         Map<Long, MyValue> map = db.createHashMap("map")
                 .valueSerializer(new MyValueSerializer())
                 .make();
@@ -92,7 +92,7 @@ private static void printEntries(Map<Long, MyValue> map) {
     @Test public void testBTreeMap() {
         System.out.println("--- Testing BTreeMap with custom serializer");
 
-        DB db = DBMaker.newFileDB(path).asyncWriteDisable().make();
+        DB db = DBMaker.newFileDB(path).make();
         Map<Long, MyValue> map = db.createTreeMap("map")
                 .valueSerializer(new MyValueSerializer())
                 .make();

File: src/test/java/org/mapdb/Issue170Test.java
Patch:
@@ -10,7 +10,6 @@ public class Issue170Test {
     @Test
     public void test(){
         Map m = DBMaker.newMemoryDB()
-                .asyncWriteDisable()
                 .compressionEnable()
                 .transactionDisable()
                 .make().createTreeMap("test").make();

File: src/test/java/org/mapdb/Issue183Test.java
Patch:
@@ -19,7 +19,6 @@ public void main(){
         TxMaker txMaker = DBMaker
                 .newFileDB(f)
                 .closeOnJvmShutdown()
-                .asyncWriteDisable()
                 .cacheDisable()
                 .makeTxMaker();
 
@@ -38,7 +37,6 @@ public void main(){
         txMaker = DBMaker
                 .newFileDB(f)
                 .closeOnJvmShutdown()
-                .asyncWriteDisable()
                 .cacheDisable()
                 .makeTxMaker();
 

File: src/test/java/org/mapdb/Issue37Test.java
Patch:
@@ -17,7 +17,7 @@ public class Issue37Test {
 
     @Test public void test3(){
 
-        DB db = DBMaker.newDirectMemoryDB().transactionDisable().asyncFlushDelay(100).make();
+        DB db = DBMaker.newDirectMemoryDB().transactionDisable().asyncWriteFlushDelay(100).make();
         ConcurrentMap<Long, Long> orders = db.createHashMap("order").make();
         for(int i = 0; i < 10000; i++) {
             orders.put((long)i, (long)i);

File: src/test/java/org/mapdb/Issue69Test.java
Patch:
@@ -23,7 +23,6 @@ public void setUp() {
 		db = DBMaker.newTempFileDB()
 				.transactionDisable()
 				.checksumEnable()
-                .asyncWriteDisable()
 				.deleteFilesAfterClose()
 				.make();
 	}

File: src/test/java/org/mapdb/Issue78Test.java
Patch:
@@ -4,6 +4,8 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import java.io.IOError;
+
 /**
  * https://github.com/jankotek/MapDB/issues/78
  *
@@ -19,7 +21,7 @@ public void setUp() {
     public void tearDown() {
     }
 
-    @Test(expected = RuntimeException.class, timeout = 10000)
+    @Test(expected = IOError.class, timeout = 10000)
     public void testIssue() {
         DB db = DBMaker.newTempFileDB().make();
         HTreeMap<String, NotSerializable> usersMap = db.getHashMap("values");

File: src/test/java/org/mapdb/Issue89Test.java
Patch:
@@ -61,7 +61,6 @@ private DB createMapDB(File file) {
             return DBMaker.newAppendFileDB(file)
                     .closeOnJvmShutdown()
                     .cacheDisable()
-                    .asyncWriteDisable()
                     .make();
         }
 

File: src/test/java/org/mapdb/PumpTest.java
Patch:
@@ -28,9 +28,9 @@ public void copy(){
     }
 
     DB makeDB(int i){
-        if(i==0) return DBMaker.newAppendFileDB(Utils.tempDbFile()).asyncWriteDisable().deleteFilesAfterClose().make();
-        if(i==1) return DBMaker.newMemoryDB().asyncWriteDisable().make();
-        if(i==2) return DBMaker.newMemoryDB().asyncWriteDisable().transactionDisable().make();
+        if(i==0) return DBMaker.newAppendFileDB(Utils.tempDbFile()).deleteFilesAfterClose().make();
+        if(i==1) return DBMaker.newMemoryDB().make();
+        if(i==2) return DBMaker.newMemoryDB().transactionDisable().make();
         return new DB(new StoreHeap());
     }
     final int dbmax = 4;

File: src/test/java/org/mapdb/StoreDirectFreeSpaceTest.java
Patch:
@@ -115,8 +115,8 @@ void assertLongStacksEmpty() {
     }
 
     @Test public void in_memory_compact(){
-        for(DB d: Arrays.asList(DBMaker.newMemoryDB().cacheDisable().asyncWriteDisable().make(),
-                DBMaker.newMemoryDB().transactionDisable().cacheDisable().asyncWriteDisable().make())){
+        for(DB d: Arrays.asList(DBMaker.newMemoryDB().cacheDisable().make(),
+                DBMaker.newMemoryDB().transactionDisable().cacheDisable().make())){
             Map m = d.getTreeMap("aa");
             for(Integer i=0;i<10000;i++){
                 m.put(i,i*10);

File: src/test/java/org/mapdb/StoreDirectTest.java
Patch:
@@ -381,7 +381,7 @@ public void phys_append_alloc_link3(){
         File f = Utils.tempDbFile();
         File phys = new File(f.getPath()+StoreDirect.DATA_FILE_EXT);
 
-        DB db = DBMaker.newFileDB(f).transactionDisable().asyncWriteDisable().deleteFilesAfterClose().make();
+        DB db = DBMaker.newFileDB(f).transactionDisable().deleteFilesAfterClose().make();
 
         db.getHashMap("test").put("aa","bb");
         db.commit();

File: src/test/java/org/mapdb/StoreTest.java
Patch:
@@ -12,7 +12,6 @@ public class StoreTest {
 
     @Test public void compression(){
         Store s = (Store)DBMaker.newMemoryDB()
-                .asyncWriteDisable()
                 .cacheDisable()
                 .transactionDisable()
                 .compressionEnable()
@@ -30,7 +29,6 @@ public class StoreTest {
 
         for(int i=100;i<100000;i=i*2){
         Store s = (Store)DBMaker.newMemoryDB()
-                .asyncWriteDisable()
                 .cacheDisable()
                 .transactionDisable()
                 .compressionEnable()

File: src/test/java/org/mapdb/StoreWALTest.java
Patch:
@@ -27,7 +27,7 @@ public void delete_files_after_close2(){
         File phys = new File(f.getPath()+StoreDirect.DATA_FILE_EXT);
         File wal = new File(f.getPath()+StoreWAL.TRANS_LOG_FILE_EXT);
 
-        DB db = DBMaker.newFileDB(f).asyncWriteDisable().deleteFilesAfterClose().make();
+        DB db = DBMaker.newFileDB(f).deleteFilesAfterClose().make();
 
         db.getHashMap("test").put("aa","bb");
         db.commit();

File: src/test/java/org/mapdb/TxEngineTest.java
Patch:
@@ -48,7 +48,7 @@ public class TxEngineTest {
     }
 
     @Test public void DB_snapshot(){
-        DB db = DBMaker.newMemoryDB().snapshotEnable().asyncFlushDelay(100).transactionDisable().make();
+        DB db = DBMaker.newMemoryDB().snapshotEnable().asyncWriteFlushDelay(100).transactionDisable().make();
         long recid = db.getEngine().put("aa", Serializer.STRING_NOSIZE);
         DB db2 = db.snapshot();
         assertEquals("aa", db2.getEngine().get(recid,Serializer.STRING_NOSIZE));

File: src/main/java/org/mapdb/TxEngine.java
Patch:
@@ -60,9 +60,9 @@ protected Long preallocRecidTake() {
     public static Engine createSnapshotFor(Engine engine) {
         if(engine.isReadOnly())
             return engine;
-        if (engine instanceof EngineWrapper)
-            return createSnapshotFor(((EngineWrapper) engine).getWrappedEngine());
-        return((TxEngine)engine).snapshot();
+        if(engine instanceof TxEngine)
+            return ((TxEngine)engine).snapshot();
+        return createSnapshotFor(((EngineWrapper) engine).getWrappedEngine());
     }
 
     public Engine snapshot() {

File: src/test/java/org/mapdb/SerializerBaseTest.java
Patch:
@@ -708,7 +708,7 @@ public void tuple4_comparators() throws IOException {
     }
 
     @Test public void object_stack_set() throws IOException {
-        for(Set c : Arrays.asList(new HashSet(), new LinkedHashSet(), new TreeSet())){
+        for(Set c : Arrays.asList(new HashSet(), new LinkedHashSet())){
             c.add(c);
             c = clone(c);
             assertTrue(c.iterator().next()==c);

File: src/main/java/org/mapdb/Store.java
Patch:
@@ -146,7 +146,7 @@ protected <A> DataOutput2 serialize(A value, Serializer<A> serializer){
                         final int decompSize = out.pos;
                         out.pos=0;
                         Utils.packInt(out,decompSize);
-                        out.write(tmp.buf,0,decompSize);
+                        out.write(tmp.buf,0,newLen);
                         recycledDataOuts.offer(tmp);
                     }
 

File: src/main/java/org/mapdb/SerializerBase.java
Patch:
@@ -1347,6 +1347,8 @@ protected interface HeaderMapDB{
         int COMPARATOR_COMPARABLE_ARRAY = 44;
         int COMPARATOR_ARRAY = 45;
 
+        int SERIALIZER_STRING_ASCII = 46;
+
     }
 
     protected static final class singletons{
@@ -1366,6 +1368,7 @@ protected static final class singletons{
             all.put(Fun.TUPLE4_COMPARATOR,HeaderMapDB.TUPLE4_COMPARATOR_STATIC);
 
             all.put(Serializer.STRING_NOSIZE,HeaderMapDB.SERIALIZER_STRING_NOSIZE);
+            all.put(Serializer.STRING_ASCII,HeaderMapDB.SERIALIZER_STRING_ASCII);
             all.put(Serializer.LONG,HeaderMapDB.SERIALIZER_LONG);
             all.put(Serializer.INTEGER,HeaderMapDB.SERIALIZER_INT);
             all.put(Serializer.ILLEGAL_ACCESS,HeaderMapDB.SERIALIZER_ILLEGAL_ACCESS);

File: src/test/java/org/mapdb/AtomicBooleanTest.java
Patch:
@@ -68,7 +68,7 @@ public void run() {
 
             t.start();
             assertTrue(ai.compareAndSet(true, false));
-            t.join(10);
+            t.join(0);
             assertFalse(t.isAlive());
 
     }

File: src/test/java/org/mapdb/AtomicIntegerTest.java
Patch:
@@ -65,7 +65,7 @@ public void run() {
 
         t.start();
         assertTrue(ai.compareAndSet(1, 2));
-        t.join(10);
+        t.join(0);
         assertFalse(t.isAlive());
         assertEquals(ai.get(), 3);
 

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -161,6 +161,7 @@ protected static SortedMap<String, Object> preinitCatalog(DB db) {
             BNode root = new LeafNode(new Object[]{null, null}, new Object[]{}, 0);
             rootRef = db.getEngine().put(root, rootSerializer);
             db.getEngine().update(Engine.CATALOG_RECID,rootRef, Serializer.LONG);
+            db.getEngine().commit();
         }
         return new BTreeMap<String, Object>(db.engine,Engine.CATALOG_RECID,32,false,0,
                 BTreeKeySerializer.STRING,

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -587,6 +587,9 @@ public void commit() {
     protected void replayLogFile(){
         assert(structuralLock.isHeldByCurrentThread());
 
+        if(readOnly && log==null)
+            return;
+
         logSize = 0;
 
         if(log !=null && !syncOnCommitDisabled){

File: src/main/java/org/mapdb/Volume.java
Patch:
@@ -212,6 +212,8 @@ public Volume createPhysVolume() {
 
             @Override
             public Volume createTransLogVolume() {
+                if(readOnly && !transLogFile.exists())
+                    return null;
                 return volumeForFile(transLogFile, rafMode>0, readOnly, sizeLimit, fullChunkAllocation);
             }
         };

File: src/test/java/examples/CacheEntryExpiry.java
Patch:
@@ -34,7 +34,7 @@ public static void main(String[] args) {
             map.put(i, Utils.randomString(1000));
         }
 
-        //one can monitor three space usage numbers:
+        //one can monitor two space usage numbers:
 
         //free space in store
         long freeSize = Pump.storeForDB(db).getFreeSize();

File: src/test/java/org/mapdb/BTreeMapLargeValsTest.java
Patch:
@@ -27,7 +27,7 @@ public BTreeMapLargeValsTest() {
         super(false, false, true, true, true, true,false);
     }
 
-    Engine r = new StoreDirect(Volume.memoryFactory(false, 0L));
+    Engine r = new StoreDirect(Volume.memoryFactory(false, 0L, false));
 
 
     @Override

File: src/test/java/org/mapdb/BTreeMapTest.java
Patch:
@@ -13,7 +13,7 @@
 @SuppressWarnings({ "unchecked", "rawtypes" })
 public class BTreeMapTest{
 
-    Engine engine = new StoreDirect(Volume.memoryFactory(false,0L));
+    Engine engine = new StoreDirect(Volume.memoryFactory(false,0L, false));
 
 
     BTreeMap m = new BTreeMap(engine,BTreeMap.createRootRef(engine,BTreeKeySerializer.BASIC,Serializer.BASIC,Utils.COMPARABLE_COMPARATOR),

File: src/test/java/org/mapdb/BTreeMapTest2.java
Patch:
@@ -25,7 +25,7 @@ public BTreeMapTest2() {
         super(false, false, true, true, true, true, false);
     }
 
-    Engine r = new StoreDirect(Volume.memoryFactory(false,0L));
+    Engine r = new StoreDirect(Volume.memoryFactory(false,0L, false));
 
 
     @Override

File: src/test/java/org/mapdb/DBTest.java
Patch:
@@ -13,7 +13,7 @@
 @SuppressWarnings({ "unchecked", "rawtypes" })
 public class DBTest {
 
-    Engine engine = new StoreDirect(Volume.memoryFactory(false,0L));
+    Engine engine = new StoreDirect(Volume.memoryFactory(false,0L, false));
     DB db = new DB(engine);
 
     @Test

File: src/test/java/org/mapdb/EngineWrapper_ImmutabilityCheckEngine.java
Patch:
@@ -12,7 +12,7 @@ public class EngineWrapper_ImmutabilityCheckEngine {
 
     @Test
     public void test(){
-        Volume.Factory fab = Volume.memoryFactory(false,0L);
+        Volume.Factory fab = Volume.memoryFactory(false,0L, false);
         Engine e = new StoreDirect(fab);
         e = new EngineWrapper.ImmutabilityCheckEngine(e);
 

File: src/test/java/org/mapdb/HTreeMap3Test.java
Patch:
@@ -23,7 +23,7 @@ public HTreeMap3Test() {
         super(false, false, true, true, true, true,true);
     }
 
-    StoreDirect r = new StoreDirect(Volume.memoryFactory(false,0L));
+    StoreDirect r = new StoreDirect(Volume.memoryFactory(false,0L, false));
 
     @Override
     protected Integer getKeyNotInPopulatedMap() throws UnsupportedOperationException {

File: src/test/java/org/mapdb/HTreeSetTest.java
Patch:
@@ -37,7 +37,7 @@
 @SuppressWarnings({"unchecked","rawtypes"})
 public class HTreeSetTest{
 
-    Engine engine = new StoreDirect(Volume.memoryFactory(false,0L));
+    Engine engine = new StoreDirect(Volume.memoryFactory(false,0L, false));
 
     Set hs;
 

File: src/test/java/org/mapdb/StoreDirectFreeSpaceTest.java
Patch:
@@ -13,7 +13,7 @@ public class StoreDirectFreeSpaceTest {
     final Map<Long,Deque<Long>> longStacks = new TreeMap <Long,Deque<Long>>();
 
     /** mock longStacks so their page allocations wont mess up tests */
-    StoreDirect stub = new  StoreDirect(Volume.memoryFactory(false,max),false,false,5,false,max,false,false,null){
+    StoreDirect stub = new  StoreDirect(Volume.memoryFactory(false,max, false),false,false,5,false,max,false,false,null, false){
         {
             structuralLock.lock();
         }

File: src/test/java/org/mapdb/StoreDirectTest.java
Patch:
@@ -16,7 +16,7 @@ public class StoreDirectTest <E extends StoreDirect> extends EngineTest<E>{
 
     @Override boolean canRollback(){return false;}
 
-    Volume.Factory fac = Volume.fileFactory(false,0,Utils.tempDbFile(), 0L);
+    Volume.Factory fac = Volume.fileFactory(false,0,Utils.tempDbFile(), 0L,false);
 
     static final long IO_RECID = StoreDirect.IO_FREE_RECID+32;
 

File: src/test/java/org/mapdb/StoreWALTest.java
Patch:
@@ -9,7 +9,7 @@
 
 public class StoreWALTest extends StoreDirectTest<StoreWAL>{
 
-    Volume.Factory fac = Volume.fileFactory(false,0,Utils.tempDbFile(), 0L);
+    Volume.Factory fac = Volume.fileFactory(false,0,Utils.tempDbFile(), 0L,false);
 
     @Override
     protected StoreWAL openEngine() {

File: src/test/java/org/mapdb/TestFile.java
Patch:
@@ -14,7 +14,7 @@ abstract public class TestFile {
     protected final File data = new File(index.getPath()+ StoreDirect.DATA_FILE_EXT);
     protected final File log = new File(index.getPath()+ StoreWAL.TRANS_LOG_FILE_EXT);
 
-    protected Volume.Factory fac = Volume.fileFactory(false, 0, 0L, index, data, log);
+    protected Volume.Factory fac = Volume.fileFactory(false, 0, 0L, false, index, data, log);
 
 
     @After public void after() throws IOException {

File: src/test/java/org/mapdb/TxEngineTest.java
Patch:
@@ -8,7 +8,7 @@
 
 public class TxEngineTest {
 
-    TxEngine e = new TxEngine(new StoreWAL(Volume.memoryFactory(false, 0L)),false);
+    TxEngine e = new TxEngine(new StoreWAL(Volume.memoryFactory(false, 0L, false)),false);
 
     @Test public void update(){
         long recid = e.put(111, Serializer.INTEGER);

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -815,7 +815,7 @@ public void compact() {
 
 
     protected long longStackTake(final long ioList, boolean recursive) {
-        assert(structuralLock.isLocked());
+        assert(structuralLock.isHeldByCurrentThread());
         assert(ioList>=IO_FREE_RECID && ioList<IO_USER_START) :"wrong ioList: "+ioList;
 
         long dataOffset = index.getLong(ioList);
@@ -865,7 +865,7 @@ protected long longStackTake(final long ioList, boolean recursive) {
 
 
     protected void longStackPut(final long ioList, long offset, boolean recursive){
-        assert(structuralLock.isLocked());
+        assert(structuralLock.isHeldByCurrentThread());
         assert(offset>>>48==0);
         assert(ioList>=IO_FREE_RECID && ioList<=IO_USER_START): "wrong ioList: "+ioList;
 
@@ -951,7 +951,7 @@ protected void freePhysPut(long indexVal, boolean recursive) {
     }
 
     protected long freePhysTake(int size, boolean ensureAvail, boolean recursive) {
-        assert(structuralLock.isLocked());
+        assert(structuralLock.isHeldByCurrentThread());
         assert(size>0);
         //check free space
         if(spaceReclaimReuse){

File: src/test/java/org/mapdb/VolumeTest.java
Patch:
@@ -24,12 +24,12 @@ public static class MemoryVolumeTest extends VolumeTest{
 
         @Test public void transfer(){
             long max = (long) (Volume.BUF_SIZE*1.5);
-            Volume from = new Volume.MemoryVol(false,0);
+            Volume from = new Volume.MemoryVol(true,0);
             for(long i=0;i<max;i+=8){
                 from.ensureAvailable(i+8);
                 from.putLong(i,i);
             }
-            Volume to = new Volume.MemoryVol(false,0);
+            Volume to = new Volume.MemoryVol(true,0);
             Volume.volumeTransfer(max,from,to);
             for(long i=0;i<max;i+=8){
                 assertEquals(i, to.getLong(i));

File: src/main/java/org/mapdb/Volume.java
Patch:
@@ -123,7 +123,7 @@ public long getSixLong(long pos) {
      * Writes a long to the indicated position
      */
     public void putSixLong(long pos, long value) {
-        assert(value>0 && (value>>>6*8)==0): "value does not fit";
+        assert(value>=0 && (value>>>6*8)==0): "value does not fit";
         //TODO read/write as integer+short, might be faster
         putByte(pos + 0, (byte) (0xff & (value >> 40)));
         putByte(pos + 1, (byte) (0xff & (value >> 32)));
@@ -643,7 +643,7 @@ protected void writeFully(long offset, ByteBuffer buf) throws IOException {
 
         @Override
         public final void putSixLong(long offset, long value) {
-            assert(value>0 && (value>>>6*8)==0): "value does not fit";
+            assert(value>=0 && (value>>>6*8)==0): "value does not fit";
 
             try{
 

File: src/main/java/org/mapdb/SerializerBase.java
Patch:
@@ -245,7 +245,7 @@ private void serialize2(DataOutput out, Object obj, FastArrayList<Object> object
         } else if(clazz == BTreeKeySerializer.BasicKeySerializer.class){
             out.write(Header.MAPDB);
             Utils.packInt(out, HeaderMapDB.B_TREE_BASIC_KEY_SERIALIZER);
-            assert(((BTreeKeySerializer.BasicKeySerializer)obj).defaultSerializer==this);
+            serialize(out,((BTreeKeySerializer.BasicKeySerializer)obj).defaultSerializer);
             return;
         } else if(obj == BTreeKeySerializer.ZERO_OR_POSITIVE_LONG){
             out.write(Header.MAPDB);
@@ -328,7 +328,7 @@ private void serialize2(DataOutput out, Object obj, FastArrayList<Object> object
             Atomic.Var v = (Atomic.Var) obj;
             Utils.packLong(out,v.recid);
             //TODO objectStack
-            serialize(out,v.serializer);
+            serialize(out, v.serializer);
             return;
         } else if(obj == this){
             out.write(Header.MAPDB);
@@ -1402,7 +1402,7 @@ protected Object deserializeMapDB(DataInput is, FastArrayList<Object> objectStac
                 return Utils.COMPARABLE_COMPARATOR_WITH_NULLS;
 
             case HeaderMapDB.B_TREE_BASIC_KEY_SERIALIZER:
-                return new BTreeKeySerializer.BasicKeySerializer(this);
+                return new BTreeKeySerializer.BasicKeySerializer((Serializer) deserialize(is,objectStack)); //TODO objectStack here
             case HeaderMapDB.THIS_SERIALIZER:
                 return this;
             case HeaderMapDB.BASIC_SERIALIZER:

File: src/main/java/org/mapdb/SerializerBase.java
Patch:
@@ -874,7 +874,7 @@ public Object deserialize(DataInput is, FastArrayList<Object> objectStack) throw
             case Header.INT_MF1:
             case Header.INT_F1:
                 ir = (ir<<8) | (is.readUnsignedByte()&0xFF);
-                if(head%2==0) ir=-ir;
+                if(head%2==0) ir=0x80000000;
                 ret = ir;
                 break;
 
@@ -938,7 +938,7 @@ public Object deserialize(DataInput is, FastArrayList<Object> objectStack) throw
             case Header.LONG_MF1:
             case Header.LONG_F1:
                 lr = (lr<<8) | (is.readUnsignedByte()&0xFFL);
-                if(head%2==1) lr=-lr;
+                if(head%2==1) lr|=0x8000000000000000L;
                 ret = lr;
                 break;
 

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -556,8 +556,6 @@ protected V valExpand(Object ret) {
     protected long nextDir(DirNode d, Object key) {
         int pos = findChildren(key, d.keys) - 1;
         if(pos<0) pos = 0;
-        if(d.child[pos]==0)
-            System.out.println("aa");
         return d.child[pos];
     }
 

File: src/test/java/examples/Transactions.java
Patch:
@@ -60,7 +60,8 @@ public static void main(String[] args) {
         // so far there was no conflict, since modified Map values lie far away from each other in tree.
         // `map2` has new key -10, so inserting -11 into map3 should update the same node and trigger rollback
         try{
-            map3.put(-11, "exists"); //will throw TxRollbackException
+            map3.put(-11, "exists");
+            tx3.commit();  //will throw TxRollbackException
             System.out.println("Insert -11 into map3 was fine"); //this will be skipped by exception
         }catch(TxRollbackException e){
             System.out.println("Could not insert -11 into map3 thanks to conflict, tx3 was rolled back");

File: src/test/java/org/mapdb/CacheWeakSoftRefTest.java
Patch:
@@ -16,7 +16,6 @@ public void weak_htree_inserts_delete() throws InterruptedException {
                 .newMemoryDB()
                 .cacheWeakRefEnable()
                 .asyncWriteDisable()
-                .snapshotDisable()
                 .make();
         testMap(db);
     }
@@ -26,7 +25,6 @@ public void soft_htree_inserts_delete() throws InterruptedException {
         DB db = DBMaker
                 .newMemoryDB()
                 .cacheSoftRefEnable()
-                .snapshotDisable()
                 .make();
         testMap(db);
     }

File: src/test/java/org/mapdb/HTreeMap2Test.java
Patch:
@@ -508,7 +508,6 @@ public void cache_load_time_expire(){
                 .sizeLimit(1)
                 .transactionDisable()
                 .asyncWriteDisable()
-                .snapshotDisable()
                 .cacheDisable()
                 .make();
 
@@ -530,7 +529,6 @@ public void cache_load_size_expire(){
                 .sizeLimit(1)
                 .transactionDisable()
                 .asyncWriteDisable()
-                .snapshotDisable()
                 .make();
 
         HTreeMap m = db.createHashMap("test")

File: src/main/java/org/mapdb/TxEngine.java
Patch:
@@ -325,8 +325,9 @@ public void commit() {
                     }else {
                         TxEngine.this.updateNoLock(recid, val.a, val.b);
                     }
-                    TxEngine.this.commit();
                 }
+                TxEngine.this.commit();
+                close();
             }finally{
                 lock.writeLock().unlock();
             }
@@ -338,6 +339,7 @@ public void rollback() throws UnsupportedOperationException {
             lock.writeLock().lock();
             try{
                 modified.clear();
+                close();
             }finally{
                 lock.writeLock().unlock();
             }

File: src/test/java/org/mapdb/Issue198Test.java
Patch:
@@ -1,11 +1,12 @@
 package org.mapdb;
 
 
-import java.io.File;
+import org.junit.Test;
+
 
 public class Issue198Test {
 
-    public static void main(String[] args) {
+    @Test public void main() {
 
         DB db = DBMaker.newFileDB(Utils.tempDbFile())
                 .closeOnJvmShutdown()

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -617,9 +617,7 @@ protected V put2(K v, V value2, final boolean putOnlyIfAbsent){
                         //is not absent, so quit
                         Utils.unlock(nodeLocks, current);
                         if(CC.PARANOID) Utils.assertNoLocks(nodeLocks);
-                        V ret =  valExpand(oldVal);
-                        notify(v,ret, value2);
-                        return ret;
+                        return valExpand(oldVal);
                     }
                     //insert new
                     Object[] vals = null;

File: src/main/java/org/mapdb/Volume.java
Patch:
@@ -579,7 +579,7 @@ public MemoryVol(boolean useDirectBuffer, long sizeLimit) {
                 }
                 buffers = null;
             }finally{
-                growLock.lock();
+                growLock.unlock();
             }
         }
 

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -529,8 +529,9 @@ public <A> void delete(long recid, Serializer<A> serializer) {
             try{
                 //free recid
                 freeIoRecidPut(ioRecid);
-                //free first record pointed from indexVal
-                freePhysPut(indexVal,false);
+                //free first record pointed from indexVal\
+                if((indexVal>>>48)>0)
+                    freePhysPut(indexVal,false);
 
                 //if there are more linked records, free those as well
                 if(linkedRecords!=null){

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -343,7 +343,7 @@ public <A> void update(long recid, A value, Serializer<A> serializer) {
                 openLogIfNeeded();
 
                 //free first record pointed from indexVal
-                if(indexVal!=0)
+                if((indexVal>>>48)>0)
                     freePhysPut(indexVal,false);
 
                 //if there are more linked records, free those as well

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -782,7 +782,6 @@ public void compact() {
     protected long longStackTake(final long ioList, boolean recursive) {
         assert(structuralLock.isLocked());
         assert(ioList>=IO_FREE_RECID && ioList<IO_USER_START) :"wrong ioList: "+ioList;
-        if(ioList>maxUsedIoList) return 0;
 
         long dataOffset = index.getLong(ioList);
         if(dataOffset == 0) return 0; //there is no such list, so just return 0

File: src/main/java/org/mapdb/StoreHeap.java
Patch:
@@ -204,7 +204,7 @@ public long getMaxRecid() {
     public ByteBuffer getRaw(long recid) {
         Fun.Tuple2 t = records.get(recid);
         if(t==null||t.a == null) return null;
-        return ByteBuffer.wrap(serialize(t.b, (Serializer<Object>) t.a).copyBytes());
+        return ByteBuffer.wrap(serialize(t.a, (Serializer<Object>) t.b).copyBytes());
     }
 
     @Override

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -2665,7 +2665,7 @@ public Entry<K, V> next() {
      * @return snapshot
      */
     public NavigableMap<K,V> snapshot(){
-        Engine snapshot = SnapshotEngine.createSnapshotFor(engine);
+        Engine snapshot = TxEngine.createSnapshotFor(engine);
 
         return new BTreeMap<K, V>(snapshot, rootRecidRef, maxNodeSize, valsOutsideNodes,
                 counter==null?0L:counter.recid,

File: src/main/java/org/mapdb/Queues.java
Patch:
@@ -230,7 +230,7 @@ public E poll() {
                 n = engine.get(head2, nodeSerializer);
             }while(n==null || !head.compareAndSet(head2, n.next));
             if(useLocks && head2!=0){
-                engine.delete(head2,Serializer.LONG);
+                engine.delete(head2,nodeSerializer);
                 locks[Utils.longHash(head2)&Utils.LOCK_MASK].unlock();
             }else{
                 engine.update(head2, null, nodeSerializer);

File: src/test/java/org/mapdb/SerializerPojoTest.java
Patch:
@@ -350,15 +350,15 @@ public  void test_pojo_reload() throws IOException {
         set.add(new test_pojo_reload_TestClass("test"));
         db.commit();
 //        System.out.println(((SerializerPojo)db.defaultSerializer).registered);
-        int prevsize = ((SerializerPojo)db.defaultSerializer).registered.size();
+        int prevsize = ((SerializerPojo)db.getDefaultSerializer()).registered.size();
 
         db.close();
 
         db = DBMaker.newFileDB(f).deleteFilesAfterClose().make();
         set = db.getHashSet("testSerializerPojo");
         set.add(new test_pojo_reload_TestClass("test2"));
         db.commit();
-        int newsize = ((SerializerPojo)db.defaultSerializer).registered.size();
+        int newsize = ((SerializerPojo)db.getDefaultSerializer()).registered.size();
 //        System.out.println(((SerializerPojo)db.defaultSerializer).registered);
         db.close();
 

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -401,7 +401,7 @@ public <A> void delete(long recid, Serializer<A> serializer) {
         }finally {
             lock.unlock();
         }
-        }
+    }
 
     @Override
     public void commit() {

File: src/main/java/org/mapdb/TxMaker.java
Patch:
@@ -155,7 +155,8 @@ public <A> void update(long recid, A value, Serializer<A> serializer) {
 
         @Override
         public <A> boolean compareAndSwap(long recid, A expectedOldValue, A newValue, Serializer<A> serializer) {
-            if(globalMods.get(recid)!=this){
+            final Object other = globalMods.get(recid);
+            if(other!=null && other !=this){
                 rollback();
                 throw new TxRollbackException();
             }

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -453,6 +453,7 @@ public void commit() {
             }
 
             //seal log file
+            log.ensureAvailable(logSize + 1);
             log.putByte(logSize, WAL_SEAL);
             logSize+=1;
             //flush log file

File: src/main/java/org/mapdb/StoreAppend.java
Patch:
@@ -90,14 +90,14 @@ public StoreAppend(final File file, final boolean useRandomAccessFile, final boo
         this.tx = !transactionDisabled;
         indexInTx = tx?new LongConcurrentHashMap<Long>() : null;
 
-
-        if(!file.getParentFile().exists() || !file.getParentFile().isDirectory())
+        final File parent = file.getAbsoluteFile().getParentFile();
+        if(!parent.exists() || !parent.isDirectory())
             throw new IllegalArgumentException("Parent dir does not exist: "+file);
 
         //list all matching files and sort them by number
         final SortedSet<Fun.Tuple2<Long,File>> sortedFiles = new TreeSet<Fun.Tuple2<Long, File>>();
         final String prefix = file.getName();
-        for(File f:file.getParentFile().listFiles()){
+        for(File f:parent.listFiles()){
             String name= f.getName();
             if(!name.startsWith(prefix) || name.length()<=prefix.length()+1) continue;
             String number = name.substring(prefix.length()+1, name.length());

File: src/main/java/org/mapdb/SerializerBase.java
Patch:
@@ -40,7 +40,9 @@ static final class knownSerializable{
 
             Serializer.STRING_NOSIZE, Serializer.LONG, Serializer.INTEGER,
             Serializer.EMPTY_SERIALIZER, Serializer.BASIC, Serializer.BOOLEAN,
-            Serializer.BYTE_ARRAY_NOSIZE
+            Serializer.BYTE_ARRAY_NOSIZE,
+            Serializer.JAVA
+
     ));
     }
 

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -197,7 +197,7 @@ public StoreDirect(Volume.Factory volFac, boolean readOnly, boolean deleteFilesA
             checkHeaders();
             indexSize = index.getLong(IO_INDEX_SIZE);
             physSize = index.getLong(IO_PHYS_SIZE);
-            indexSize = index.getLong(IO_FREE_SIZE);
+            freeSize = index.getLong(IO_FREE_SIZE);
         }
 
     }
@@ -214,6 +214,7 @@ protected void checkHeaders() {
 
     protected void createStructure() {
         indexSize = IO_USER_START+LAST_RESERVED_RECID*8+8;
+        assert(indexSize>IO_USER_START);
         index.ensureAvailable(indexSize);
         for(int i=0;i<indexSize;i+=8) index.putLong(i,0L);
         index.putLong(0, HEADER);

File: src/main/java/org/mapdb/DB.java
Patch:
@@ -180,7 +180,7 @@ public <K,V> HTreeMap<K,V> make(){
 
         public <K,V> HTreeMap<K,V> makeOrGet(){
             //TODO add parameter check
-            return (HTreeMap<K, V>) (catGet(name+"type")==null?
+            return (HTreeMap<K, V>) (catGet(name+".type")==null?
                                 make():getHashMap(name));
         }
 
@@ -457,7 +457,7 @@ public <K,V> BTreeMap<K,V> make(){
 
         public <K,V> BTreeMap<K,V> makeOrGet(){
             //TODO add parameter check
-            return (BTreeMap<K, V>) (catGet(name+"type")==null?
+            return (BTreeMap<K, V>) (catGet(name+".type")==null?
                     make():getTreeMap(name));
         }
 
@@ -535,7 +535,7 @@ public <K> NavigableSet<K> make(){
 
         public <K> NavigableSet<K> makeOrGet(){
             //TODO add parameter check
-            return (NavigableSet<K>) (catGet(name+"type")==null?
+            return (NavigableSet<K>) (catGet(name+".type")==null?
                     make():getTreeSet(name));
 
         }

File: src/main/java/org/mapdb/Pump.java
Patch:
@@ -58,6 +58,7 @@ public static <E> Iterator<E> sort(final Iterator<E> source, final int batchSize
         int counter = 0;
         final SortedSet<E> presort = new TreeSet<E>(comparator);
         final List<File> presortFiles = new ArrayList<File>();
+        final List<Integer> presortCount2 = new ArrayList<Integer>();
 
         try{
             while(source.hasNext()){
@@ -74,6 +75,7 @@ public static <E> Iterator<E> sort(final Iterator<E> source, final int batchSize
                         serializer.serialize(out,e);
                     }
                     out.close();
+                    presortCount2.add(presort.size());
                     presort.clear();
                     counter = 0;
                 }
@@ -85,7 +87,7 @@ public static <E> Iterator<E> sort(final Iterator<E> source, final int batchSize
             }
 
             final int[] presortCount = new int[presortFiles.size()];
-            Arrays.fill(presortCount, batchSize);
+            for(int i=0;i<presortCount.length;i++) presortCount[i] = presortCount2.get(i);
             //compose iterators which will iterate over data saved in files
             Iterator[] iterators = new Iterator[presortFiles.size()+1];
             final DataInputStream[] ins = new DataInputStream[presortFiles.size()];

File: src/test/java/org/mapdb/DBMakerTest.java
Patch:
@@ -151,7 +151,7 @@ public void testCacheSize() throws Exception {
                 .cacheSize(1000)
                 .make();
         verifyDB(db);
-        assertEquals(1000, ((CacheHashTable) db.engine).cacheMaxSize);
+        assertEquals(1024, ((CacheHashTable) db.engine).cacheMaxSize);
     }
 
     @Test public void read_only() throws IOException {

File: src/test/java/org/mapdb/BTreeMapLargeValsTest.java
Patch:
@@ -47,7 +47,7 @@ protected String getSecondValueNotInPopulatedMap() throws UnsupportedOperationEx
 
     @Override
     protected ConcurrentMap<Integer, String> makeEmptyMap() throws UnsupportedOperationException {
-        return new BTreeMap(r,BTreeMap.createRootRef(r,BTreeKeySerializer.BASIC, Serializer.BASIC_SERIALIZER),
+        return new BTreeMap(r,BTreeMap.createRootRef(r,BTreeKeySerializer.BASIC, Serializer.BASIC_SERIALIZER,Utils.COMPARABLE_COMPARATOR),
                 6,false,0, BTreeKeySerializer.BASIC,Serializer.BASIC_SERIALIZER,
                 Utils.COMPARABLE_COMPARATOR);
 

File: src/test/java/org/mapdb/BTreeMapTest.java
Patch:
@@ -16,7 +16,7 @@ public class BTreeMapTest{
     Engine engine = new StoreDirect(Volume.memoryFactory(false,0L));
 
 
-    BTreeMap m = new BTreeMap(engine,BTreeMap.createRootRef(engine,BTreeKeySerializer.BASIC,Serializer.BASIC_SERIALIZER),
+    BTreeMap m = new BTreeMap(engine,BTreeMap.createRootRef(engine,BTreeKeySerializer.BASIC,Serializer.BASIC_SERIALIZER,Utils.COMPARABLE_COMPARATOR),
             6,false,0, BTreeKeySerializer.BASIC,Serializer.BASIC_SERIALIZER,
             Utils.COMPARABLE_COMPARATOR);
     

File: src/test/java/org/mapdb/BTreeMapTest2.java
Patch:
@@ -46,7 +46,7 @@ protected String getSecondValueNotInPopulatedMap() throws UnsupportedOperationEx
     @Override
     protected ConcurrentMap<Integer, String> makeEmptyMap() throws UnsupportedOperationException {
 
-        return new BTreeMap(r,BTreeMap.createRootRef(r,BTreeKeySerializer.BASIC, Serializer.BASIC_SERIALIZER),
+        return new BTreeMap(r,BTreeMap.createRootRef(r,BTreeKeySerializer.BASIC, Serializer.BASIC_SERIALIZER, Utils.COMPARABLE_COMPARATOR),
                 6,false,0, BTreeKeySerializer.BASIC,Serializer.BASIC_SERIALIZER,
                 Utils.COMPARABLE_COMPARATOR);
     }

File: src/test/java/org/mapdb/BTreeSetTest.java
Patch:
@@ -13,7 +13,7 @@ public class BTreeSetTest extends HTreeSetTest{
     public void setUp() throws Exception {
         super.setUp();
 
-        hs = new BTreeMap(engine,BTreeMap.createRootRef(engine,BTreeKeySerializer.BASIC,null),
+        hs = new BTreeMap(engine,BTreeMap.createRootRef(engine,BTreeKeySerializer.BASIC,null,Utils.COMPARABLE_COMPARATOR),
                 6,false,0, BTreeKeySerializer.BASIC,null,
                 Utils.COMPARABLE_COMPARATOR).keySet();
 

File: src/test/java/org/mapdb/HTreeMap2Test.java
Patch:
@@ -538,6 +538,7 @@ public void cache_load_size_expire(){
         long counter = 0;
         while(time+5000>System.currentTimeMillis()){
             m.put(counter++,counter++);
+//            if(counter%1000<2) System.out.println(m.size());
         }
         m.clear();
     }

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -331,8 +331,8 @@ protected <A> A get2(long ioRecid,Serializer<A> serializer) throws IOException {
         }
         int start = di.pos;
         A ret = serializer.deserialize(di,size);
-        if(size+start>di.pos)throw new InternalError("data were not fully read, check your serializier "+ioRecid);
-        if(size+start<di.pos)throw new InternalError("data were read beyond record size, check your serializier");
+        if(size+start>di.pos)throw new InternalError("data were not fully read, check your serializer "+ioRecid);
+        if(size+start<di.pos)throw new InternalError("data were read beyond record size, check your serializer");
         return ret;
     }
 

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -834,6 +834,7 @@ protected long freePhysTake(int size, boolean ensureAvail, boolean recursive) {
                     long markFree = (remaining<<48) | (offset+s-remaining);
                     freePhysPut(markFree,recursive);
 
+                    freeSize-=roundTo16(s);
                     return (((long)size)<<48) |offset;
                 }
             }

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -1392,7 +1392,7 @@ public long getMaxExpireTime(){
      */
     public long getMinExpireTime(){
         if(!expireFlag) return 0;
-        long ret = 0;
+        long ret = Long.MAX_VALUE;
         for(int segment = 0;segment<16;segment++){
             segmentLocks[segment].readLock().lock();
             try{
@@ -1405,6 +1405,7 @@ public long getMinExpireTime(){
                 segmentLocks[segment].readLock().unlock();
             }
         }
+        if(ret == Long.MAX_VALUE) ret =0;
         return ret;
     }
 

File: src/test/java/org/mapdb/HTreeMap2Test.java
Patch:
@@ -441,7 +441,7 @@ int[] getExpireList(HTreeMap m, int segment){
 
 
 
-    @Test (timeout = 10000)
+    @Test (timeout = 20000)
     public void expire_put() {
         HTreeMap m = db.createHashMap("test")
                 .expireAfterWrite(100)
@@ -452,7 +452,7 @@ public void expire_put() {
         }
     }
 
-    @Test (timeout = 10000)
+    @Test (timeout = 20000)
     public void expire_max_size() throws InterruptedException {
         HTreeMap m = db.createHashMap("test")
                 .expireMaxSize(1000)

File: src/main/java/org/mapdb/CacheLRU.java
Patch:
@@ -90,7 +90,7 @@ public <A> boolean compareAndSwap(long recid, A expectedOldValue, A newValue, Se
             Engine engine = getWrappedEngine();
             LongMap cache2 = checkClosed(cache);
             Object oldValue = cache.get(recid);
-            if(oldValue == expectedOldValue || oldValue.equals(expectedOldValue)){
+            if(oldValue == expectedOldValue || (oldValue!=null&&oldValue.equals(expectedOldValue))){
                 //found matching entry in cache, so just update and return true
                 cache2.put(recid, newValue);
                 engine.update(recid, newValue, serializer);

File: src/main/java/org/mapdb/CacheWeakSoftRef.java
Patch:
@@ -189,7 +189,7 @@ public <A> boolean compareAndSwap(long recid, A expectedOldValue, A newValue, Se
             CacheItem item = checkClosed(items).get(recid);
             Object oldValue = item==null? null: item.get() ;
             if(item!=null && item.getRecid() == recid &&
-                    (oldValue == expectedOldValue || oldValue.equals(expectedOldValue))){
+                    (oldValue == expectedOldValue || (oldValue!=null && oldValue.equals(expectedOldValue)))){
                 //found matching entry in cache, so just update and return true
                 putItemIntoCache(recid, newValue);
                 getWrappedEngine().update(recid, newValue, serializer);

File: src/test/java/org/mapdb/HTreeMap2Test.java
Patch:
@@ -125,7 +125,7 @@ DataInput2 swap(DataOutput2 d){
         HTreeMap.LinkedNode n2  = (HTreeMap.LinkedNode) serializer.deserialize(in, -1);
 
         assertEquals(123456, n2.next);
-        assertEquals(1111L, n2.expireLinkNodeRecid);
+        assertEquals(0L, n2.expireLinkNodeRecid);
         assertEquals(123L,n2.key);
         assertEquals(456L,n2.value);
     }

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -477,7 +477,7 @@ public V put(final K key, final V value){
 
                     {
                         final long expireNodeRecid = expireFlag? engine.put(null, ExpireLinkNode.SERIALIZER):0L;
-                        final LinkedNode node = new LinkedNode<K, V>(0, expireNodeRecid, key, value);
+                        final LinkedNode<K,V> node = new LinkedNode<K, V>(0, expireNodeRecid, key, value);
                         final long newRecid = engine.put(node, LN_SERIALIZER);
                         //add newly inserted record
                         int pos =(h >>>(7*(level-1) )) & 0x7F;

File: src/test/java/org/mapdb/HTreeMap3Test.java
Patch:
@@ -42,7 +42,7 @@ protected String getSecondValueNotInPopulatedMap() throws UnsupportedOperationEx
 
     @Override
     protected ConcurrentMap<Integer, String> makeEmptyMap() throws UnsupportedOperationException {
-        return new HTreeMap(r,0,0, HTreeMap.preallocateSegments(r), Serializer.BASIC_SERIALIZER, Serializer.BASIC_SERIALIZER);
+        return new HTreeMap(r,0,0, HTreeMap.preallocateSegments(r), Serializer.BASIC_SERIALIZER, Serializer.BASIC_SERIALIZER,0,0,0,0);
     }
 
     @Override

File: src/test/java/org/mapdb/HTreeSetTest.java
Patch:
@@ -51,7 +51,7 @@ public class HTreeSetTest{
 
     @Test public void test_Constructor() {
         // Test for method java.util.HashSet()
-        Set hs2 = new HTreeMap(engine, 0,0,HTreeMap.preallocateSegments(engine),Serializer.BASIC_SERIALIZER,null).keySet();
+        Set hs2 = new HTreeMap(engine, 0,0,HTreeMap.preallocateSegments(engine),Serializer.BASIC_SERIALIZER,null,0,0,0,0).keySet();
         assertEquals("Created incorrect HashSet", 0, hs2.size());
     }
 
@@ -88,7 +88,7 @@ public class HTreeSetTest{
 
     @Test public void test_isEmpty() {
         // Test for method boolean java.util.HashSet.isEmpty()
-        assertTrue("Empty set returned false", new HTreeMap(engine, 0,0,HTreeMap.preallocateSegments(engine),Serializer.BASIC_SERIALIZER,null).keySet().isEmpty());
+        assertTrue("Empty set returned false", new HTreeMap(engine, 0,0,HTreeMap.preallocateSegments(engine),Serializer.BASIC_SERIALIZER,null,0,0,0,0).keySet().isEmpty());
         assertTrue("Non-empty set returned true", !hs.isEmpty());
     }
 
@@ -127,7 +127,7 @@ public class HTreeSetTest{
      * is called before a test is executed.
      */
     @Before public void setUp() throws Exception {
-        hs = new HTreeMap(engine, 0,0,HTreeMap.preallocateSegments(engine),Serializer.BASIC_SERIALIZER,null).keySet();
+        hs = new HTreeMap(engine, 0,0,HTreeMap.preallocateSegments(engine),Serializer.BASIC_SERIALIZER,null,0,0,0,0).keySet();
         Collections.addAll(hs, objArray);
     }
 

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -138,12 +138,13 @@ public class BTreeMap<K,V> extends AbstractMap<K,V>
     protected final Atomic.Long counter;
 
     /** hack used for DB Catalog*/
-    protected static BTreeMap<String, Object> preinitCatalog(DB db) {
+    protected static SortedMap<String, Object> preinitCatalog(DB db) {
 
         Long rootRef = db.getEngine().get(Engine.CATALOG_RECID, Serializer.LONG_SERIALIZER);
 
         if(rootRef==null){
-            if(db.getEngine().isReadOnly()) return null;
+            if(db.getEngine().isReadOnly())
+                return Collections.unmodifiableSortedMap(new TreeMap<String, Object>());
 
             NodeSerializer rootSerializer = new NodeSerializer(false,BTreeKeySerializer.STRING,
                     db.getDefaultSerializer(),Utils.COMPARABLE_COMPARATOR);

File: src/test/java/examples/Lazily_Loaded_Records.java
Patch:
@@ -38,7 +38,7 @@ public static void main(String[] args) {
         // As bonus you can update reference in thread-safe atomic manner.
         //
         Atomic.Var<String> record =
-                Atomic.createVar(db, "lazyRecord", "aaa", db.getDefaultSerializer());
+                db.createAtomicVar("lazyRecord", "aaa", db.getDefaultSerializer());
 
         record.set("some value");
         System.out.println(record.get());

File: src/test/java/examples/Map_Size_Counter.java
Patch:
@@ -30,7 +30,7 @@ public static void main(String[] args) {
         DB db2 = DBMaker.newTempFileDB().make();
 
         BTreeMap primary = db2.getTreeMap("map2");
-        Atomic.Long sizeCounter = Atomic.getLong(db2, "mapSize");
+        Atomic.Long sizeCounter = db1.getAtomicLong("mapSize");
 
         Bind.size(primary, sizeCounter);
 

File: src/test/java/examples/SQL_Auto_Incremental_Unique_Key.java
Patch:
@@ -21,7 +21,7 @@ public static void main(String[] args) {
 
         // open existing or create new Atomic record with given name
         // if no record with given name exist, new recid is created with value `0`
-        Atomic.Long keyinc = Atomic.getLong(db, "map_keyinc");
+        Atomic.Long keyinc = db.getAtomicLong("map_keyinc");
 
 
         // Allocate new unique key to use in map

File: src/test/java/org/mapdb/AtomicBooleanTest.java
Patch:
@@ -11,7 +11,7 @@
 public class AtomicBooleanTest extends TestCase{
 
     DB db = DBMaker.newMemoryDB().writeAheadLogDisable().make();
-    Atomic.Boolean ai = Atomic.createBoolean(db,"test", true);
+    Atomic.Boolean ai = db.createAtomicBoolean("test", true);
 
     /**
      * constructor initializes to given value
@@ -24,7 +24,7 @@ public void testConstructor() {
      * default constructed initializes to false
      */
     public void testConstructor2() {
-        Atomic.Boolean ai = Atomic.getBoolean(db, "test2");
+        Atomic.Boolean ai = db.getAtomicBoolean("test2");
         assertEquals(false,ai.get());
     }
 
@@ -86,7 +86,7 @@ public void testGetAndSet() {
      * toString returns current value.
      */
     public void testToString() {
-        Atomic.Boolean ai = Atomic.getBoolean(db, "test2");
+        Atomic.Boolean ai = db.getAtomicBoolean( "test2");
         assertEquals(ai.toString(), Boolean.toString(false));
         ai.set(true);
         assertEquals(ai.toString(), Boolean.toString(true));

File: src/test/java/org/mapdb/AtomicIntegerTest.java
Patch:
@@ -11,7 +11,7 @@
 public class AtomicIntegerTest extends TestCase {
 
     DB db = DBMaker.newMemoryDB().writeAheadLogDisable().make();
-    Atomic.Integer ai = Atomic.createInteger(db,"test", 1);
+    Atomic.Integer ai = db.createAtomicInteger("test", 1);
 
     /**
      * constructor initializes to given value
@@ -24,7 +24,7 @@ public void testConstructor(){
      * default constructed initializes to zero
      */
     public void testConstructor2(){
-        Atomic.Integer  ai = Atomic.getInteger(db, "test2");
+        Atomic.Integer  ai = db.getAtomicInteger("test2");
         assertEquals(0,ai.get());
     }
 

File: src/test/java/org/mapdb/AtomicLongTest.java
Patch:
@@ -11,7 +11,7 @@
 public class AtomicLongTest extends TestCase {
 
     DB db = DBMaker.newMemoryDB().writeAheadLogDisable().make();
-    Atomic.Long ai = Atomic.createLong(db,"test", 1);
+    Atomic.Long ai = db.createAtomicLong("test", 1);
 
     /**
      * constructor initializes to given value
@@ -24,7 +24,7 @@ public void testConstructor(){
      * default constructed initializes to zero
      */
     public void testConstructor2(){
-        Atomic.Long ai = Atomic.getLong(db, "test2");
+        Atomic.Long ai = db.getAtomicLong("test2");
         assertEquals(0,ai.get());
     }
 

File: src/test/java/org/mapdb/Issue90Test.java
Patch:
@@ -17,7 +17,7 @@ public void testCounter() throws Exception {
 
                 .cacheDisable()
                 .make();
-        final Atomic.Long myCounter = Atomic.getLong(mapDb, "MyCounter");
+        final Atomic.Long myCounter = mapDb.getAtomicLong("MyCounter");
 
         final BTreeMap<String, Fun.Tuple2<String, Integer>> treeMap = mapDb.getTreeMap("map");
         Bind.size(treeMap, myCounter);

File: src/main/java/org/mapdb/TxMaker.java
Patch:
@@ -1,5 +1,6 @@
 package org.mapdb;
 
+import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.Set;
 
@@ -59,7 +60,7 @@ protected class TxEngine extends EngineWrapper{
         protected LongMap<Fun.Tuple2<?, Serializer>> modItems =
                 new LongConcurrentHashMap<Fun.Tuple2<?, Serializer>>();
 
-        protected Set<Long> newItems = new LinkedHashSet<Long>();
+        protected Set<Long> newItems = Collections.synchronizedSet(new LinkedHashSet<Long>()); //TODO replace with different structure
 
 
         protected TxEngine(Engine engine) {

File: src/main/java/org/mapdb/TxMaker.java
Patch:
@@ -16,7 +16,7 @@ public class TxMaker {
 
     protected final Object lock = new Object();
 
-    protected final LongMap<TxEngine> globalMod = new LongHashMap<TxEngine>();
+    protected final LongMap<TxEngine> globalMod = new LongConcurrentHashMap<TxEngine>();
 
 
     public TxMaker(Engine engine) {
@@ -57,7 +57,7 @@ public void execute(TxBlock txBlock) {
     protected class TxEngine extends EngineWrapper{
 
         protected LongMap<Fun.Tuple2<?, Serializer>> modItems =
-                new LongHashMap<Fun.Tuple2<?, Serializer>>();
+                new LongConcurrentHashMap<Fun.Tuple2<?, Serializer>>();
 
         protected Set<Long> newItems = new LinkedHashSet<Long>();
 
@@ -134,6 +134,7 @@ public void commit() {
 
                 //remove locally modified items from global list
                 LongMap.LongMapIterator<Fun.Tuple2<?, Serializer>> iter = modItems.longMapIterator();
+                long counter = modItems.size();
                 while(iter.moveToNext()){
                     TxEngine other = globalMod.remove(iter.key());
                     if(other!=TxEngine.this) throw new InternalError();

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -767,7 +767,8 @@ public void updateRaw(long recid, ByteBuffer data) {
 
         byte[] b = null;
 
-        if(data!=null) synchronized (data){
+        if(data!=null){
+            data = data.duplicate();
             b = new byte[data.remaining()];
             data.get(b);
         }

File: src/test/java/org/mapdb/StoreDirectTest.java
Patch:
@@ -14,6 +14,7 @@
 
 public class StoreDirectTest <E extends StoreDirect> extends EngineTest<E>{
 
+    @Override boolean canRollback(){return false;}
 
     Volume.Factory fac = Volume.fileFactory(false,0,Utils.tempDbFile());
 

File: src/test/java/org/mapdb/StoreHeapTest.java
Patch:
@@ -11,4 +11,7 @@ protected StoreHeap openEngine() {
 
     @Override boolean canReopen(){return false;}
 
+    @Override boolean canRollback(){return false;}
+
+
 }

File: src/main/java/org/mapdb/Engine.java
Patch:
@@ -66,6 +66,7 @@ public interface Engine {
 
     long NAME_DIR_RECID = 1;
     long CLASS_INFO_RECID = 2;
+    long CHECK_RECORD = 3;
     long LAST_RESERVED_RECID = 7;
 
 

File: src/main/java/org/mapdb/SerializerPojo.java
Patch:
@@ -368,9 +368,9 @@ protected ObjectStreamField[] getFields(Class<?> clazz) {
                 streamClass = ObjectStreamClass.lookup(clazz);
             }
             fields = new ObjectStreamField[fieldsList
-                    .size()];
+                    .size];
             for (int i = 0; i < fields.length; i++) {
-                fields[i] = fieldsList.get(i);
+                fields[i] = fieldsList.data[i];
             }
             if(classInfo != null)
                 classInfo.setObjectStreamFields(fields);

File: src/main/java/org/mapdb/SerializerBase.java
Patch:
@@ -480,7 +480,7 @@ else if (val == 1)
             Fun.Tuple2 t = (Fun.Tuple2) obj;
             serialize(out, t.a, objectStack);
             serialize(out, t.b, objectStack);
-        } else if (clazz == Fun.Tuple2.class){
+        } else if (clazz == Fun.Tuple3.class){
             out.write(TUPLE3);
             Fun.Tuple3 t = (Fun.Tuple3) obj;
             serialize(out, t.a, objectStack);

File: src/test/java/examples/TreeMap_Composite_Key.java
Patch:
@@ -81,13 +81,13 @@ public static void main(String[] args) {
         //Lets iterate over 'Main Street' in all towns.
         total = 0;
         for(String town:towns){
-            @SuppressWarnings("unused")
+
 			Map<Fun.Tuple3, Integer> mainStreetHouses =
                     map.subMap(
                             Fun.t3(town, "Main Street", null), //use null as LOWEST boundary for house number
                             Fun.t3(town, "Main Street", Fun.HI)
                     );
-            for(Integer salary:housesInCong.values()){
+            for(Integer salary:mainStreetHouses.values()){
                 total+=salary;
             }
         }

File: src/main/java/org/mapdb/TxMaker.java
Patch:
@@ -171,7 +171,7 @@ public void rollback() {
 
         @Override
         public void close() {
-            if(modItems==null) return; //already closed
+            if(modItems==null || engine == null) return; //already closed
             rollback();
         }
     }

File: src/main/java/org/mapdb/AsyncWriteEngine.java
Patch:
@@ -392,7 +392,9 @@ public void close() {
             closeInProgress = true;
             //notify background threads
             if(!action.compareAndSet(null,new CountDownLatch(0)))throw new InternalError();
-            super.delete(newRecids.take(), Serializer.EMPTY_SERIALIZER);
+            Long last = newRecids.take();
+            if(last!=null)
+                super.delete(last, Serializer.EMPTY_SERIALIZER);
 
             //wait for background threads to shutdown
             activeThreadsCount.await();

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -55,6 +55,7 @@ public StoreWAL(Volume.Factory volFac, boolean readOnly, boolean deleteFilesAfte
     protected void reloadIndexFile() {
         logSize = 0;
         modified.clear();
+        longStackPages.clear();
         indexSize = index.getLong(IO_INDEX_SIZE);
         physSize = index.getLong(IO_PHYS_SIZE);
         for(int i = IO_FREE_RECID;i<IO_USER_START;i+=8){
@@ -545,9 +546,6 @@ public void rollback() throws UnsupportedOperationException {
                 log = null;
             }
 
-            modified.clear();
-            longStackPages.clear();
-
             reloadIndexFile();
         }finally {
             for(ReentrantReadWriteLock lock:locks) lock.writeLock().unlock();

File: src/main/java/org/mapdb/SerializerPojo.java
Patch:
@@ -94,9 +94,8 @@ protected static Class<?> classForName(String className) {
 
     public SerializerPojo(CopyOnWriteArrayList<ClassInfo> registered){
         if(registered == null)
-            this.registered = new CopyOnWriteArrayList<ClassInfo>();
-        else
-            this.registered = registered;
+            registered = new CopyOnWriteArrayList<ClassInfo>();
+        this.registered = registered;
 
         for(int i=0;i<registered.size();i++)
         {

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -542,6 +542,9 @@ public void rollback() throws UnsupportedOperationException {
                 log = null;
             }
 
+            modified.clear();
+            longStackPages.clear();
+
             reloadIndexFile();
         }finally {
             for(ReentrantReadWriteLock lock:locks) lock.writeLock().unlock();

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -98,9 +98,6 @@ public class BTreeMap<K,V> extends AbstractMap<K,V>
 
 
 
-    /** default maximal node size */
-    protected static final int DEFAULT_MAX_NODE_SIZE = 32;
-
 
     /** recid under which reference to rootRecid is stored */
     protected final long rootRecidRef;

File: src/main/java/org/mapdb/DB.java
Patch:
@@ -183,7 +183,7 @@ synchronized public <K,V> BTreeMap<K,V> getTreeMap(String name){
             if(!ret.hasValues) throw new ClassCastException("Collection is Set, not Map");
         }else{
             //create new map
-            ret = new BTreeMap<K,V>(engine,BTreeMap.DEFAULT_MAX_NODE_SIZE, true, false,false, defaultSerializer, null, null, null);
+            ret = new BTreeMap<K,V>(engine,CC.BTREE_DEFAULT_MAX_NODE_SIZE, true, false,false, defaultSerializer, null, null, null);
             nameDir.put(name, ret.treeRecid);
         }
         collections.put(name, new WeakReference<Object>(ret));
@@ -279,7 +279,7 @@ synchronized public <K> NavigableSet<K> getTreeSet(String name){
             ret = m.keySet();
         }else{
             //create new map
-            BTreeMap<K,Object> m =  new BTreeMap<K,Object>(engine,BTreeMap.DEFAULT_MAX_NODE_SIZE,
+            BTreeMap<K,Object> m =  new BTreeMap<K,Object>(engine,CC.BTREE_DEFAULT_MAX_NODE_SIZE,
                     false, false,false, defaultSerializer, null, null, null);
             nameDir.put(name, m.treeRecid);
             ret = m.keySet();

File: src/main/java/org/mapdb/SerializerPojo.java
Patch:
@@ -33,7 +33,7 @@
  *
  * @author  Jan Kotek
  */
-public class SerializerPojo extends SerializerBase{
+public class SerializerPojo extends SerializerBase implements Serializable{
 
 
     protected static final Serializer<CopyOnWriteArrayList<ClassInfo>> serializer = new Serializer<CopyOnWriteArrayList<ClassInfo>>() {

File: src/main/java/org/mapdb/Engine.java
Patch:
@@ -187,5 +187,8 @@ public interface Engine {
      */
     boolean isReadOnly();
 
+    /** clears any underlying cache */
+    void clearCache();
+
     void compact();
 }

File: src/main/java/org/mapdb/SnapshotEngine.java
Patch:
@@ -124,6 +124,7 @@ public  <A> void delete(long recid, Serializer<A> serializer) {
         }
     }
 
+
     public static Engine createSnapshotFor(Engine engine) {
         SnapshotEngine se = null;
         while(true){

File: src/test/java/org/mapdb/ExamplesTest.java
Patch:
@@ -70,6 +70,9 @@ public class ExamplesTest {
         TreeMap_Composite_Key.main(args);
     }
 
+    @Test public void Pump_InMemory_Import_Than_Save_To_Disk(){
+        Pump_InMemory_Import_Than_Save_To_Disk.main(args);
+    }
 
 
 

File: src/main/java/org/mapdb/SerializerBase.java
Patch:
@@ -514,7 +514,7 @@ else if (val == 1)
             serialize(out, s.bSerializer);
             serialize(out, s.cSerializer);
         } else if (clazz == BTreeKeySerializer.Tuple4KeySerializer.class){
-            out.write(KEY_TUPLE3_SERIALIZER);
+            out.write(KEY_TUPLE4_SERIALIZER);
             BTreeKeySerializer.Tuple4KeySerializer s = (BTreeKeySerializer.Tuple4KeySerializer) obj;
             serialize(out, s.aComparator);
             serialize(out, s.bComparator);

File: src/test/java/examples/Bidi_Map.java
Patch:
@@ -19,6 +19,7 @@ public static void main(String[] args) {
 
         // inverse mapping for primary map
         NavigableSet<Fun.Tuple2<String, Long>> inverseMapping = new TreeSet<Fun.Tuple2<String, Long>>();
+        //NOTE: you may also use Set provided by MapDB to make it persistent
 
         // bind inverse mapping to primary map, so it is auto-updated
         Bind.mapInverse(map, inverseMapping);

File: src/main/java/org/mapdb/AsyncWriteEngine.java
Patch:
@@ -221,8 +221,8 @@ public <A> void delete(long recid, Serializer<A> serializer) {
     public void close() {
         commitLock.writeLock().lock();
         try {
-            checkState();
             if(closeInProgress) return;
+            checkState();
             closeInProgress = true;
             //notify background threads
             itemsQueue.put(new CountDownLatch(0));

File: src/test/java/org/mapdb/StoreDirectTest.java
Patch:
@@ -15,12 +15,12 @@
 public class StoreDirectTest <E extends StoreDirect> extends EngineTest<E>{
 
 
-    Volume.Factory fac = Volume.fileFactory(false,false,Utils.tempDbFile());
+    Volume.Factory fac = Volume.fileFactory(false,0,Utils.tempDbFile());
 
     static final long IO_RECID = StoreDirect.IO_FREE_RECID+32;
 
     @Override protected E openEngine() {
-        return (E) new StoreDirect(fac,false,false);
+        return (E) new StoreDirect(fac);
     }
 
     int countIndexRecords(){

File: src/test/java/org/mapdb/StoreWALTest.java
Patch:
@@ -9,11 +9,11 @@
 
 public class StoreWALTest extends StoreDirectTest<StoreWAL>{
 
-    Volume.Factory fac = Volume.fileFactory(false,false,Utils.tempDbFile());
+    Volume.Factory fac = Volume.fileFactory(false,0,Utils.tempDbFile());
 
     @Override
     protected StoreWAL openEngine() {
-        return new StoreWAL(fac,false,false);
+        return new StoreWAL(fac);
     }
 
     @Test

File: src/test/java/org/mapdb/TestFile.java
Patch:
@@ -14,7 +14,7 @@ abstract public class TestFile {
     protected final File data = new File(index.getPath()+ StoreDirect.DATA_FILE_EXT);
     protected final File log = new File(index.getPath()+ StoreWAL.TRANS_LOG_FILE_EXT);
 
-    protected Volume.Factory fac = Volume.fileFactory(false, false, index, data, log);
+    protected Volume.Factory fac = Volume.fileFactory(false, 0, index, data, log);
 
 
     @After public void after() throws IOException {

File: src/main/java/org/mapdb/Utils.java
Patch:
@@ -364,7 +364,8 @@ public static void unlock(LongConcurrentHashMap<Thread> locks,final long recid)
     }
 
     public static void assertNoLocks(LongConcurrentHashMap<Thread> locks){
-        if(CC.PARANOID){
+        //if(CC.PARANOID) //TODO restore to paranoid
+        {
             LongMap.LongMapIterator<Thread> i = locks.longMapIterator();
             while(i.moveToNext()){
                 if(i.value()==Thread.currentThread()){

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -144,11 +144,11 @@ protected long[] logAllocate(long[] physPos) {
         for(int i=0;i<physPos.length;i++){
             long size = (physPos[i]&MASK_SIZE)>>>48;
             //would overlaps Volume Block?
-            checkLogRounding();
             logSize+=1+8; //space used for WAL_PHYS_ARRAY
             ret[i] = (size<<48) | logSize;
 
             logSize+=size;
+            checkLogRounding();
 
         }
 

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -341,7 +341,7 @@ public <A> void delete(long recid, Serializer<A> serializer) {
         }
     }
 
-    private long[] getLinkedRecordsIndexVals(long indexVal) {
+    protected long[] getLinkedRecordsIndexVals(long indexVal) {
         long[] linkedRecords = null;
 
         int linkedPos = 0;

File: src/main/java/org/mapdb/Serializer.java
Patch:
@@ -178,11 +178,13 @@ public byte[] deserialize(DataInput in, int available) throws IOException {
 
         @Override
         public void serialize(DataOutput out, byte[] value) throws IOException {
+            if(value==null||value.length==0) return;
             out.write(value);
         }
 
         @Override
         public byte[] deserialize(DataInput in, int available) throws IOException {
+            if(available==0) return null;
             byte[] ret = new byte[available];
             in.readFully(ret);
             return ret;

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -385,7 +385,7 @@ public boolean isEmpty() {
                 for(long[] d:dir){
                     if(d!=null) return false;
                 }
-                return true;
+
             }finally {
                 segmentLocks[i].readLock().unlock();
             }

File: src/main/java/org/mapdb/CacheWeakSoftRef.java
Patch:
@@ -96,6 +96,7 @@ public CacheWeakSoftRef(Engine engine, boolean useWeakRef){
     protected void runRefQueue(){
         try{
             final ReferenceQueue<?> queue = this.queue;
+            if(queue == null)return;
             final LongConcurrentHashMap<CacheItem> items = this.items;
 
             while(true){

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -311,6 +311,7 @@ public void commit() {
         structuralLock.lock();
         for(ReentrantReadWriteLock l:locks) l.writeLock().lock();
         try{
+            if(log==null) return; //no modifications
             //update physical and logical filesize
 
             log.ensureAvailable(logSize + 17 + 17 + 1);

File: src/main/java/org/mapdb/BTreeKeySerializer.java
Patch:
@@ -82,7 +82,7 @@ public void serialize(DataOutput out, int start, int end, Object[] keys) throws
 
         @Override
         public Object[] deserialize(DataInput in, int start, int end, int size) throws IOException {
-            Object[] ret = new Long[size];
+            Object[] ret = new Integer[size];
             int prev = 0 ;
             for(int i = start; i<end; i++){
                 ret[i] = prev = prev + Utils.unpackInt(in);

File: src/main/java/org/mapdb/AsyncWriteEngine.java
Patch:
@@ -276,8 +276,8 @@ public void rollback() {
         commitLock.writeLock().lock();
         try{
             while(!items.isEmpty()) LockSupport.parkNanos(100);
-
-            super.commit();
+            newRecids.clear();
+            super.rollback();
         }finally {
             commitLock.writeLock().unlock();
         }

File: src/main/java/org/mapdb/StoreDirect.java
Patch:
@@ -477,6 +477,7 @@ public void compact() {
                 DataOutput2 out = new DataOutput2();
                 out.buf = bb;
                 out.pos = bb.length;
+                store2.index.ensureAvailable(ioRecid+8);
                 store2.put2(out, ioRecid,indexVals);
             }
 

File: src/main/java/org/mapdb/Volume.java
Patch:
@@ -239,7 +239,7 @@ public final void ensureAvailable(long offset) {
                     //make sure previous buffer is fully expanded
                     if(buffersPos>0){
                         ByteBuffer oldPrev = buffers2[buffersPos-1];
-                        if(oldPrev.capacity()!=BUF_SIZE){
+                        if(oldPrev == null || oldPrev.capacity()!=BUF_SIZE){
                             buffers2[buffersPos-1]  = makeNewBuffer(1L*buffersPos*BUF_SIZE-1,buffers2);
                         }
                     }

File: src/main/java/org/mapdb/StoreWAL.java
Patch:
@@ -152,6 +152,7 @@ protected long[] logAllocate(long[] physPos) {
 
     protected void checkLogRounding() {
         if(logSize% Volume.BUF_SIZE+MAX_REC_SIZE*2>Volume.BUF_SIZE){
+            log.ensureAvailable(logSize+1);
             log.putByte(logSize, WAL_SKIP_REST_OF_BLOCK);
             logSize += Volume.BUF_SIZE - logSize%Volume.BUF_SIZE;
         }

File: src/main/java/org/mapdb/Volume.java
Patch:
@@ -492,6 +492,7 @@ protected ByteBuffer makeNewBuffer(long offset, ByteBuffer[] buffers2) {
                     if(oldBuffer!=null)
                         unreleasedBuffers.put(oldBuffer, "");
                 }
+
                 long newBufSize =  offset% BUF_SIZE;
                 newBufSize = newBufSize + newBufSize%BUF_SIZE_INC; //round to BUF_SIZE_INC
                 return fileChannel.map(

File: src/main/java/org/mapdb/AsyncWriteEngine.java
Patch:
@@ -172,7 +172,7 @@ public <A> A get(long recid, Serializer<A> serializer) {
     @Override
     public <A> void update(long recid, A value, Serializer<A> serializer) {
         checkState();
-        if(commitLock!=null) commitLock.readLock().lock();
+        if(commitLock!=null && serializer!=SerializerPojo.serializer) commitLock.readLock().lock();
         try{
 
             writeLocks.lock(recid);
@@ -182,7 +182,7 @@ public <A> void update(long recid, A value, Serializer<A> serializer) {
                 writeLocks.unlock(recid);
             }
         }finally{
-            if(commitLock!=null) commitLock.readLock().unlock();
+            if(commitLock!=null&& serializer!=SerializerPojo.serializer) commitLock.readLock().unlock();
         }
 
     }

File: src/main/java/org/mapdb/DBMaker.java
Patch:
@@ -558,7 +558,7 @@ public Engine makeEngine(){
         if(_readOnly && _file==null)
             throw new UnsupportedOperationException("Can not open in-memory DB in read-only mode.");
 
-        if(_readOnly && !_file.exists()){
+        if(_readOnly && !_file.exists() && !_appendStorage){
             throw new UnsupportedOperationException("Can not open non-existing file in read-only mode.");
         }
 

File: src/main/java/org/mapdb/StorageAppend.java
Patch:
@@ -263,6 +263,8 @@ public <A> void delete(long recid, Serializer<A> serializer){
 
     @Override
     public void close() {
+        currentVolume.sync();
+        currentVolume.close();
         currentVolume = null;
         volumes = null;
     }

File: src/test/java/org/mapdb/SerializerBaseTest.java
Patch:
@@ -453,7 +453,7 @@ public void test_multi_dim_array2(){
 
 
     public void test_static_objects(){
-        for(Object o:SerializerBase.knownSerializable){
+        for(Object o:SerializerBase.knownSerializable.get){
             assertTrue(o==Utils.clone(o, Serializer.BASIC_SERIALIZER));
         }
     }

File: src/main/java/org/mapdb/LongHashMap.java
Patch:
@@ -62,9 +62,9 @@ public class LongHashMap<V> extends LongMap<V> implements Serializable {
     /**
      * Salt added to keys before hashing, so it is harder to trigger hash collision attack.
      */
-    protected final long hashSalt = hashHashValue();
+    protected final long hashSalt = hashSaltValue();
 
-    protected long hashHashValue() {
+    protected long hashSaltValue() {
         return Utils.RANDOM.nextLong();
     }
 

File: src/test/java/org/mapdb/LongHashMapTest.java
Patch:
@@ -25,7 +25,7 @@ public class LongHashMapTest extends TestCase {
 
     public void testAll() {
         LongHashMap<String> t = new LongHashMap<String>(){
-            protected long hashSaltValue(){return 0;}
+            @Override protected long hashSaltValue(){return 0;}
         };
         t.put(1, "aa");
         t.put(2, "bb");
@@ -45,11 +45,11 @@ public void testAll() {
 
         Iterator<String> vals = t.valuesIterator();
         assertTrue(vals.hasNext());
-        assertEquals(vals.next(), "FF");
+        assertEquals(vals.next(), "bb");
         assertTrue(vals.hasNext());
         assertEquals(vals.next(), "cc");
         assertTrue(vals.hasNext());
-        assertEquals(vals.next(), "bb");
+        assertEquals(vals.next(), "FF");
 
         assertFalse(vals.hasNext());
 

File: src/test/java/org/mapdb/LongHashMapTest.java
Patch:
@@ -56,7 +56,6 @@ public void testAll() {
         t.put(2, "bb");
         assertEquals(1, t.size());
         assertEquals(t.get(1), null);
-        assertEquals(t.get(2), "bb");
         assertEquals(t.get(3), null);
 
     }

File: src/main/java/org/mapdb/DBMaker.java
Patch:
@@ -49,7 +49,7 @@ public class DBMaker {
     protected boolean _journalEnabled = true;
 
     protected boolean _asyncWriteEnabled = true;
-    protected int _asyncFlushDelay = 0;
+    protected int _asyncFlushDelay = 100;
 
     protected boolean _deleteFilesAfterClose = false;
     protected boolean _readOnly = false;
@@ -180,7 +180,7 @@ public static <K> Set<K> newTempHashSet(){
      */
     public static DBMaker newTempFileDB() {
         try {
-            return newFileDB(File.createTempFile("JDBM-temp","db")).randomAccessFileEnableIfNeeded();
+            return newFileDB(File.createTempFile("mapdb-temp","db"));
         } catch (IOException e) {
             throw new IOError(e);
         }
@@ -284,7 +284,7 @@ public DBMaker cacheLRUEnable(){
      * Use this if you are experiencing <b>java.lang.OutOfMemoryError: Map failed</b> exceptions
      */
     public DBMaker randomAccessFileEnable() {
-        this._RAF = !Utils.JVMSupportsLargeMappedFiles();
+        this._RAF = true;
         return this;
     }
 

File: src/main/java/org/mapdb/SerializationHeader.java
Patch:
@@ -171,6 +171,7 @@ interface SerializationHeader {
     int CRC32_SERIALIZER = 153;
     int MAPDB_STACK = 154;
     int MAPDB_QUEUE = 155;
+    int MAPDB_CIRCULAR_QUEUE = 156;
 
     /**
      * used for reference to already serialized object in object graph

File: src/main/java/org/mapdb/DBMaker.java
Patch:
@@ -598,7 +598,7 @@ public Engine makeEngine(){
 
         AsyncWriteEngine engineAsync = null;
         if(_asyncWriteEnabled && !_readOnly){
-            engineAsync = new AsyncWriteEngine(engine,  _asyncThreadDaemon, _powerSavingMode, _asyncFlushDelay);
+            engineAsync = new AsyncWriteEngine(engine,  _asyncThreadDaemon,!_journalEnabled,  _powerSavingMode, _asyncFlushDelay);
             engine = engineAsync;
         }
 

File: src/test/java/org/mapdb/BTreeMapTest6.java
Patch:
@@ -853,7 +853,7 @@ public void testTailMapContents() {
      * Submaps of submaps subdivide correctly
      */
     public void testRecursiveSubMaps() throws Exception {
-        int mapSize = 10000;
+        int mapSize = 1000;
 
         NavigableMap<Integer, Integer> map = newBTreeMap();
         bs = new BitSet(mapSize);

File: src/test/java/org/mapdb/BTreeSet2Test.java
Patch:
@@ -609,7 +609,7 @@ public void testTailSetContents() {
      * Subsets of subsets subdivide correctly
      */
     public void testRecursiveSubSets() throws Exception {
-        int setSize = 10000;
+        int setSize = 1000;
 
 
         NavigableSet<Integer> set = newNavigableSet();

File: src/main/java/org/mapdb/CacheHashTable.java
Patch:
@@ -109,7 +109,6 @@ public <A> boolean compareAndSwap(long recid, A expectedOldValue, A newValue, Se
             locks.lock(pos);
             HashItem item = items2[pos];
             if(item!=null && item.key == recid){
-                if(item.val == null && expectedOldValue!=null) return false;
                 //found in cache, so compare values
                 if(item.val == expectedOldValue || item.val.equals(expectedOldValue)){
                     //found matching entry in cache, so just update and return true

File: src/main/java/org/mapdb/CacheWeakSoftRef.java
Patch:
@@ -177,7 +177,7 @@ public <A> boolean compareAndSwap(long recid, A expectedOldValue, A newValue, Se
             locks.lock(recid);
             CacheItem item = checkClosed(items).get(recid);
             Object oldValue = item==null? null: item.get() ;
-            if(item!=null && oldValue!=null && item.getRecid() == recid &&
+            if(item!=null && item.getRecid() == recid &&
                     (oldValue == expectedOldValue || oldValue.equals(expectedOldValue))){
                 //found matching entry in cache, so just update and return true
                 putItemIntoCache(recid, newValue);

File: src/main/java/org/mapdb/DBMaker.java
Patch:
@@ -653,4 +653,6 @@ public void run() {
     }
 
 
+
+
 }

File: src/main/java/org/mapdb/SerializerPojo.java
Patch:
@@ -58,6 +58,7 @@ public void serialize(DataOutput out, CopyOnWriteArrayList<ClassInfo> obj) throw
 
         @Override
 		public CopyOnWriteArrayList<ClassInfo> deserialize(DataInput in, int available) throws IOException{
+            if(available==0) return new CopyOnWriteArrayList<ClassInfo>();
 
             int size = Utils.unpackInt(in);
             ArrayList<ClassInfo> ret = new ArrayList<ClassInfo>(size);

File: src/main/java/org/mapdb/TxMaker.java
Patch:
@@ -71,7 +71,7 @@ protected TxEngine(Engine engine) {
         public <A> long put(A value, Serializer<A> serializer) {
             if(isClosed()) throw new IllegalAccessError("already closed");
             synchronized (lock){
-                long recid = engine.put(null, Serializer.NULL_SERIALIZER);
+                long recid = engine.put(Utils.EMPTY_STRING, Serializer.NULL_SERIALIZER);
                 newItems.add(recid);
                 modItems.put(recid, Fun.t2(value, (Serializer)serializer));
                 globalMod.put(recid, TxEngine.this);
@@ -158,7 +158,7 @@ public void rollback() {
                 }
                 //delete preallocated items
                 for(long recid:newItems){
-                    engine.delete(recid, null); //TODO store serializer somewhere
+                    engine.delete(recid, Serializer.NULL_SERIALIZER);
                 }
                 modItems = null;
                 newItems = null;

File: src/test/java/org/mapdb/SnapshotEngineTest.java
Patch:
@@ -10,7 +10,7 @@
 
 public class SnapshotEngineTest{
 
-    SnapshotEngine e = new SnapshotEngine(new StorageDirect(Volume.memoryFactory(false)),1024);
+    SnapshotEngine e = new SnapshotEngine(new StorageDirect(Volume.memoryFactory(false)));
 
     @Test public void update(){
         long recid = e.put(111, Serializer.INTEGER_SERIALIZER);

File: src/main/java/org/mapdb/AsyncWriteEngine.java
Patch:
@@ -92,7 +92,7 @@ public void run() {
                         synchronized ( item){
                             if(item.value == DONE) throw new InternalError();
                             if(item.value == DELETED){
-                                getWrappedEngine().delete(recid); //item was deleted in main thread
+                                getWrappedEngine().delete(recid,item.serializer); //item was deleted in main thread
                             }else{
                                 getWrappedEngine().update(recid, item.value, item.serializer);
                             }
@@ -301,8 +301,8 @@ public <A> boolean compareAndSwap(long recid, A expectedOldValue, A newValue, Se
     }
 
     @Override
-    public void delete(long recid) {
-        update(recid, DELETED, null );
+    public <A> void delete(long recid, Serializer<A> serializer){
+        update(recid, (A) DELETED, serializer );
     }
 
     @Override

File: src/main/java/org/mapdb/CacheHardRef.java
Patch:
@@ -69,9 +69,9 @@ public <A> void update(long recid, A value, Serializer<A> serializer) {
     }
 
     @Override
-    public void delete(long recid) {
+    public <A> void delete(long recid, Serializer<A> serializer){
         checkFreeMem();
-        super.delete(recid);
+        super.delete(recid,serializer);
     }
 
     @Override

File: src/main/java/org/mapdb/CacheLRU.java
Patch:
@@ -62,11 +62,11 @@ public <A> void update(long recid, A value, Serializer<A> serializer) {
     }
 
     @Override
-    public void delete(long recid) {
+    public <A> void delete(long recid, Serializer<A> serializer){
         try{
             locks.lock(recid);
             checkClosed(cache).remove(recid);
-            super.delete(recid);
+            super.delete(recid,serializer);
         }finally {
             locks.unlock(recid);
         }

File: src/main/java/org/mapdb/CacheWeakSoftRef.java
Patch:
@@ -160,11 +160,11 @@ private <A> void putItemIntoCache(long recid, A value) {
     }
 
     @Override
-    public void delete(long recid) {
+    public <A> void delete(long recid, Serializer<A> serializer){
         try{
             locks.lock(recid);
             checkClosed(items).remove(recid);
-            getWrappedEngine().delete(recid);
+            getWrappedEngine().delete(recid,serializer);
         }finally {
             locks.unlock(recid);
         }

File: src/main/java/org/mapdb/Engine.java
Patch:
@@ -138,8 +138,9 @@ public interface Engine {
      * but it may also corrupt store.
      *
      * @param recid (record identifier) under which was record persisted
+     * @param serializer which may be used in some circumstances to deserialize and store old object
      */
-    void delete(long recid);
+    <A> void delete(long recid, Serializer<A>  serializer);
 
 
 

File: src/main/java/org/mapdb/Queue2.java
Patch:
@@ -194,7 +194,7 @@ public E poll() {
                 n = engine.get(head2, nodeSerializer);
             }while(n==null || !head.compareAndSet(head2, n.next));
             if(useLocks && head2!=0){
-                engine.delete(head2);
+                engine.delete(head2, Serializer.LONG_SERIALIZER);
                 locks.unlock(head2);
             }else{
                 engine.update(head2, null, nodeSerializer);

File: src/main/java/org/mapdb/StorageAppend.java
Patch:
@@ -225,7 +225,7 @@ public <A> boolean compareAndSwap(long recid, A expectedOldValue, A newValue, Se
     }
 
     @Override
-    public void delete(long recid) {
+    public <A> void delete(long recid, Serializer<A> serializer){
         //put thumbstone into log
         synchronized (APPEND_LOCK){
             currentVolume.ensureAvailable(currentFileOffset+8+4);

File: src/main/java/org/mapdb/StorageDirect.java
Patch:
@@ -260,8 +260,8 @@ public <A> void update(long recid, A value, Serializer<A> serializer){
     }
 
 
-    @Override
-   public void delete(long recid){
+   @Override
+   public <A> void delete(long recid, Serializer<A> serializer){
         if(recid<=0) throw new IllegalArgumentException("recid");
         recid+=INDEX_OFFSET_START;
         try{

File: src/main/java/org/mapdb/StorageWriteAhead.java
Patch:
@@ -336,7 +336,7 @@ private long getIndexLong(long recid) {
     }
 
     @Override
-    public void delete(long recid){
+    public <A> void delete(long recid, Serializer<A>  serializer){
         if(recid<=0) throw new IllegalArgumentException("recid");
         recid+=INDEX_OFFSET_START;
 

File: src/main/java/org/mapdb/TxMaker.java
Patch:
@@ -115,7 +115,7 @@ public <A> boolean compareAndSwap(long recid, A expectedOldValue, A newValue, Se
         }
 
         @Override
-        public void delete(long recid) {
+        public <A> void delete(long recid, Serializer<A> serializer){
             if(isClosed()) throw new IllegalAccessError("already closed");
             synchronized (lock){
                 TxEngine other = globalMod.get(recid);
@@ -158,7 +158,7 @@ public void rollback() {
                 }
                 //delete preallocated items
                 for(long recid:newItems){
-                    engine.delete(recid);
+                    engine.delete(recid, null); //TODO store serializer somewhere
                 }
                 modItems = null;
                 newItems = null;

File: src/test/java/org/mapdb/CompressTest.java
Patch:
@@ -37,7 +37,7 @@ public void put_get_update() throws Exception {
         assertEquals("aaaa",db.engine.get(recid, Serializer.STRING_SERIALIZER));
         db.engine.update(recid, "bbbb", Serializer.STRING_SERIALIZER);
         assertEquals("bbbb",db.engine.get(recid, Serializer.STRING_SERIALIZER));
-        db.engine.delete(recid);
+        db.engine.delete(recid,Serializer.STRING_SERIALIZER);
         assertEquals(null,db.engine.get(recid, Serializer.STRING_SERIALIZER));
 
     }

File: src/test/java/org/mapdb/StorageTestCase.java
Patch:
@@ -90,7 +90,7 @@ public void large_record(){
         byte[] b = new byte[100000];
         Arrays.fill(b, (byte) 111);
         long recid = engine.put(b, Serializer.BYTE_ARRAY_SERIALIZER);
-        engine.delete(recid);
+        engine.delete(recid,Serializer.BYTE_ARRAY_SERIALIZER);
     }
 
 

File: src/test/java/org/mapdb/StorageWriteAheadTest.java
Patch:
@@ -47,8 +47,8 @@ public class StorageWriteAheadTest extends TestFile {
         t.update(recid2, "ZZZ", Serializer.STRING_SERIALIZER);
         assertEquals("ZZZ", t.get(recid2, Serializer.STRING_SERIALIZER));
 
-        t.delete(recid);
-        t.delete(recid2);
+        t.delete(recid, Serializer.STRING_SERIALIZER);
+        t.delete(recid2, Serializer.STRING_SERIALIZER);
         assertEquals(null, t.get(recid, Serializer.STRING_SERIALIZER));
         assertEquals(null, t.get(recid2, Serializer.STRING_SERIALIZER));
     }
@@ -68,7 +68,7 @@ public class StorageWriteAheadTest extends TestFile {
         t = new StorageWriteAhead(fac);
         assertEquals("bb", t.get(recid, Serializer.STRING_SERIALIZER));
 
-        t.delete(recid);
+        t.delete(recid,Serializer.STRING_SERIALIZER);
         t.commit();
         t.close();
         t = new StorageWriteAhead(fac);

File: src/main/java/org/mapdb/AsyncWriteEngine.java
Patch:
@@ -92,9 +92,9 @@ public void run() {
                         synchronized ( item){
                             if(item.value == DONE) throw new InternalError();
                             if(item.value == DELETED){
-                                engine.delete(recid); //item was deleted in main thread
+                                getWrappedEngine().delete(recid); //item was deleted in main thread
                             }else{
-                                engine.update(recid, item.value, item.serializer);
+                                getWrappedEngine().update(recid, item.value, item.serializer);
                             }
                             item.value = DONE;
                             iter.remove();

File: src/main/java/org/mapdb/CacheHardRef.java
Patch:
@@ -57,7 +57,7 @@ private void checkFreeMem() {
                 Utils.LOG.fine("DBCache: freemem = " +free + " = "+(free/max)+"%");
 
             if(free<1e7 || free*4 <max){
-                cache.clear();
+                checkClosed(cache).clear();
             }
         }
     }

File: src/main/java/org/mapdb/CompressLZF.java
Patch:
@@ -52,6 +52,7 @@
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
+import java.io.Serializable;
 import java.util.Arrays;
 
 /**
@@ -344,7 +345,7 @@ public static <E> Serializer<E> serializerCompressWrapper(Serializer<E> serializ
     }
 
 
-    protected static class SerializerCompressWrapper<E> implements Serializer<E>{
+    protected static class SerializerCompressWrapper<E> implements Serializer<E>, Serializable {
         protected final Serializer<E> serializer;
         public SerializerCompressWrapper(Serializer<E> serializer) {
             this.serializer = serializer;

File: src/main/java/org/mapdb/Utils.java
Patch:
@@ -227,4 +227,5 @@ public static boolean JVMSupportsLargeMappedFiles() {
         //TODO better check for 32bit JVM
         return false;
     }
+
 }

File: src/test/java/org/mapdb/AsyncWriteEngineTest.java
Patch:
@@ -107,8 +107,6 @@ public <A> long put(A value, Serializer<A> serializer) {
         //TODO reenable when newRecids are introduced
         //assertEquals(max, putCounter.longValue() - a.newRecids.size());
         assertTrue(a.writeCache.isEmpty());
-        //'crash' async engine, destroy its write queue
-        a.engine = null;
         t.close();
 
         //now reopen db and check ths

File: src/test/java/org/mapdb/DBMakerTest.java
Patch:
@@ -68,7 +68,7 @@ public void testDisableAsyncWrite() throws Exception {
                 .make();
         verifyDB(db);
         assertTrue(db.engine.getClass() == CacheHashTable.class);
-        assertTrue(((CacheHashTable)db.engine).engine.getClass() == SnapshotEngine.class);
+        assertTrue(((CacheHashTable)db.engine).getWrappedEngine().getClass() == SnapshotEngine.class);
 
     }
 
@@ -82,7 +82,7 @@ public void testMake() throws Exception {
         //check default values are set
         assertTrue(db.engine.getClass() == CacheHashTable.class);
         assertEquals(1024 * 32, ((CacheHashTable) db.engine).cacheMaxSize);
-        EngineWrapper w = (EngineWrapper) ((CacheHashTable) db.engine).engine;
+        EngineWrapper w = (EngineWrapper) ((CacheHashTable) db.engine).getWrappedEngine();
         assertTrue(w instanceof SnapshotEngine);
         assertTrue(w.getWrappedEngine().getClass() == AsyncWriteEngine.class);
         AsyncWriteEngine r = (AsyncWriteEngine) w.getWrappedEngine();

File: src/main/java/org/mapdb/Volume.java
Patch:
@@ -197,7 +197,7 @@ public final void ensureAvailable(long offset) {
 
         protected final java.nio.ByteBuffer internalByteBuffer(long offset) {
             final int pos = ((int) (offset / BUF_SIZE));
-            if(pos>=buffers.length) throw new IOError(new EOFException());
+            if(pos>=buffers.length) throw new IOError(new EOFException("offset: "+offset));
             return buffers[pos];
         }
 

File: src/main/java/org/mapdb/Engine.java
Patch:
@@ -182,4 +182,6 @@ public interface Engine {
      * @return true if engine is read-only
      */
     boolean isReadOnly();
+
+    void compact();
 }

File: src/test/java/org/mapdb/TestFile.java
Patch:
@@ -14,7 +14,7 @@ abstract public class TestFile {
     protected final File data = new File(index.getPath()+ Storage.DATA_FILE_EXT);
     protected final File log = new File(index.getPath()+ StorageJournaled.TRANS_LOG_FILE_EXT);
 
-    protected final Volume.Factory fac = Volume.fileFactory(false, false, index, data, log);
+    protected Volume.Factory fac = Volume.fileFactory(false, false, index, data, log);
 
 
     @After public void after() throws IOException {

File: src/main/java/org/mapdb/Storage.java
Patch:
@@ -297,7 +297,7 @@ public boolean isReadOnly() {
     }
 
 
-    protected void unlinkPhysRecord(long indexVal) throws IOException {
+    protected void unlinkPhysRecord(long indexVal, long recid) throws IOException {
         int size = (int) (indexVal >>>48);
         if(size==0) return;
         if(size<MAX_RECORD_SIZE){

File: src/main/java/org/mapdb/StorageDirect.java
Patch:
@@ -162,12 +162,12 @@ public <A> void update(long recid, A value, Serializer<A> serializer){
                         index.putLong(recid * 8, newIndexValue);
 
                         //and set old phys record as free
-                        unlinkPhysRecord(oldIndexVal);
+                        unlinkPhysRecord(oldIndexVal,recid);
                     }
                 }else{
                     putLargeLinkedRecord(out, recid);
                     //and set old phys record as free
-                    unlinkPhysRecord(oldIndexVal);
+                    unlinkPhysRecord(oldIndexVal,recid);
                 }
             }finally {
                 lock.writeLock().unlock();
@@ -185,7 +185,7 @@ public void delete(long recid){
             final long oldIndexVal = index.getLong(recid * 8);
             index.putLong(recid * 8, 0L);
             longStackPut(RECID_FREE_INDEX_SLOTS,recid);
-            unlinkPhysRecord(oldIndexVal);
+            unlinkPhysRecord(oldIndexVal,recid);
         }catch(IOException e){
             throw new IOError(e);
         }finally {

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -1205,8 +1205,9 @@ protected Entry<K, V> findLarger(K key, boolean inclusive) {
             for(int i=0;i<leaf.keys.length;i++){
                 if(leaf.vals[i] == null|| leaf.keys[i]==null) continue;
 
-                if(comparator.compare(key, leaf.keys[i])<comp)
-                    return makeEntry(leaf.keys[i], leaf.vals[i]);
+                if(comparator.compare(key, leaf.keys[i])<comp){
+                    return makeEntry(leaf.keys[i], valExpand(leaf.vals[i]));
+                }
             }
             if(leaf.next==0) return null; //reached end
             leaf = (LeafNode) engine.get(leaf.next, nodeSerializer);

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -1101,7 +1101,9 @@ private Entry<K, V> findSmallerRecur(final BNode n, final K key, final boolean i
             for(int i=0;i<n.keys().length;i++){
                 //find first item not matching condition
                 Object key2 = n.keys()[i];
-                if(key2!=null && comparator.compare(key, key2) <p){
+                if((key2!=null && comparator.compare(key, key2) <p) ||
+                        (key2==null && i==n.keys().length-1) //special case for tree left most node
+                        ){
                     //and return previous
                     return makeEntry(n.keys()[i-1], valExpand(n.vals()[i-1]));
                 }

File: src/test/java/org/mapdb/BTreeMapTest.java
Patch:
@@ -228,13 +228,13 @@ private static void printRecur(BTreeMap m, long recid, String s) {
 
 
 
-    @Ignore //TODO floorKey is broken with right most leaf
     @Test public void floorTestFill() {
         BTreeMap map = new BTreeMap(engine,6,true,false, null,null,null,null);
         map.put(1, "val1");
         map.put(2, "val2");
         map.put(5, "val3");
 
+        assertEquals(5,map.floorKey(5));
         assertEquals(1,map.floorKey(1));
         assertEquals(2,map.floorKey(2));
         assertEquals(2,map.floorKey(3));

File: src/test/java/org/mapdb/BTreeMapTest.java
Patch:
@@ -122,7 +122,7 @@ private static void printRecur(BTreeMap m, long recid, String s) {
                 new Object[]{null, 10,20,30, null},
                 0);
         long rootRecid = engine.put(l, m.nodeSerializer);
-        long rootRecidRef = engine.put(rootRecid, Serializer.LONG_SERIALIZER);
+        engine.update(m.rootRecidRef, rootRecid,  Serializer.LONG_SERIALIZER);
 
         assertEquals(null, m.get(1));
         assertEquals(null, m.get(9));

File: src/main/java/org/mapdb/CC.java
Patch:
@@ -25,8 +25,8 @@
  * <p/>
  * Typical usage:
  * <pre>
- *     if(arg==null){
- *         throw new IllegalArgumentException("Argument is null");
+ *     if(CC.PARANOID && arg.calculateSize()!=33){  //calculateSize may take long time
+ *         throw new IllegalArgumentException("wrong size");
  *     }
  * </pre>
  *
@@ -53,3 +53,4 @@ public interface CC {
     boolean LOG_LOCKS = false;
 
 }
+

File: src/main/java/org/mapdb/StorageJournaled.java
Patch:
@@ -170,7 +170,7 @@ private void putLargeLinkedRecord(DataOutput2 out, long recid) throws IOExceptio
             final Long transLogReference = (((long)currentChunkSize)<<48)|(transLogOffset+8);
             journalRefs.add(transLogReference);
             transLog.putData(transLogOffset,b, b.length);
-            transLogOffset+=out.pos;
+            transLogOffset+=b.length;
 
             checkBufferRounding();
 

File: src/main/java/org/mapdb/BTreeMap.java
Patch:
@@ -2033,7 +2033,7 @@ public void addModificationListener(Bind.MapListener<K,V> listener) {
     public void removeModificationListener(Bind.MapListener<K,V> listener) {
         synchronized (modListenersLock){
             for(int i=0;i<modListeners.length;i++){
-                if(modListeners[i]==listener) modListeners=null;
+                if(modListeners[i]==listener) modListeners[i]=null;
             }
         }
     }

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -1152,7 +1152,7 @@ public void addModificationListener(Bind.MapListener<K,V> listener) {
     public void removeModificationListener(Bind.MapListener<K,V> listener) {
         synchronized (modListenersLock){
             for(int i=0;i<modListeners.length;i++){
-                if(modListeners[i]==listener) modListeners=null;
+                if(modListeners[i]==listener) modListeners[i]=null;
             }
         }
     }

File: src/main/java/org/mapdb/SerializerBase.java
Patch:
@@ -984,7 +984,7 @@ public Object deserialize(DataInput is, FastArrayList<Object> objectStack) throw
                 ret = deserializeArrayObjectPackedLong(is);
                 break;
             case ARRAY_OBJECT_ALL_NULL:
-                ret = deserializeArrayObjectAllNull(is, objectStack);
+                ret = deserializeArrayObjectAllNull(is);
                 break;
             case ARRAY_OBJECT_NO_REFS:
                 ret = deserializeArrayObjectNoRefs(is);
@@ -1216,11 +1216,10 @@ private Object[] deserializeArrayObjectNoRefs(DataInput is) throws IOException {
     }
 
 
-    private Object[] deserializeArrayObjectAllNull(DataInput is, FastArrayList<Object> objectStack) throws IOException {
+    private Object[] deserializeArrayObjectAllNull(DataInput is) throws IOException {
         int size = Utils.unpackInt(is);
         Class clazz = deserializeClass(is);
         Object[] s = (Object[]) Array.newInstance(clazz, size);
-        objectStack.add(s);
         return s;
     }
 

File: src/main/java/org/mapdb/HTreeMap.java
Patch:
@@ -898,11 +898,11 @@ private Object[] advance(int lastHash){
                         //increase hash by 1
                         if(level!=0){
                             lastHash = ((lastHash>>>(7 * level)) + 1) << (7*level); //should use mask and XOR
-                            if(lastHash==0){
-                                return null;
-                            }
                         }else
                             lastHash +=1;
+                        if(lastHash==0){
+                            return null;
+                        }
                         break;
                     }
 

File: src/main/java/org/mapdb/Storage.java
Patch:
@@ -94,7 +94,7 @@ public Storage(Volume.Factory volFac, boolean appendOnly,
             phys.ensureAvailable(8);
             index.ensureAvailable(INDEX_OFFSET_START*8);
 
-            final long header = index.getLong(0);
+            final long header = index.isEmpty()? 0 : index.getLong(0);
             if(header!=HEADER){
                 if(failOnWrongHeader) throw new IOError(new IOException("Wrong file header"));
                 else writeInitValues();
@@ -118,6 +118,8 @@ private void writeInitValues() {
         //write headers
         phys.putLong(0, HEADER);
         index.putLong(0L,HEADER);
+        if(CC.ASSERT && index.getLong(0L)!=HEADER)
+            throw new InternalError();
 
 
         //and set current sizes

File: src/test/java/org/mapdb/AsyncWriteEngineTest.java
Patch:
@@ -129,13 +129,13 @@ public void trans_deadlock_issue5() {
         Map map = db.getTreeMap("treemap");
 
         for (int i = 0; i < COUNT; i++) {
-            if (i % 100000 == 0) {
+            if (i % 10000 == 0) {
                 db.commit();
             }
             map.put(i, (double) i);
         }
         for (int i = 0; i < COUNT; i++) {
-            if (i % 100000 == 0) {
+            if (i % 1000 == 0) {
                 db.commit();
             }
             assertEquals(map.get(i), (double) i);

File: src/main/java/org/mapdb/DB.java
Patch:
@@ -154,7 +154,7 @@ synchronized public <K> Set<K> getHashSet(String name){
     @NotNull
     synchronized public <K> Set<K> createHashSet(String name, Serializer<K> serializer){
         checkNameNotExists(name);
-        HTreeMap<K,Object> ret = new HTreeMap<K,Object>(engine, true, defaultSerializer, serializer, null);
+        HTreeMap<K,Object> ret = new HTreeMap<K,Object>(engine, false, defaultSerializer, serializer, null);
         nameDir.put(name, ret.rootRecid);
         Set<K> ret2 = ret.keySet();
         collections.put(name, new WeakReference<Object>(ret2));
@@ -269,7 +269,7 @@ synchronized public <K> NavigableSet<K> getTreeSet(String name){
     @NotNull
     synchronized public <K> NavigableSet<K> createTreeSet(String name, int nodeSize, Serializer<K[]> serializer, Comparator<K> comparator){
         checkNameNotExists(name);
-        BTreeMap<K,Object> ret = new BTreeMap<K,Object>(engine, nodeSize, true, false, defaultSerializer, serializer, null, comparator);
+        BTreeMap<K,Object> ret = new BTreeMap<K,Object>(engine, nodeSize, false, false, defaultSerializer, serializer, null, comparator);
         nameDir.put(name, ret.treeRecid);
         NavigableSet<K> ret2 = ret.keySet();
         collections.put(name, new WeakReference<Object>(ret2));

File: src/test/java/org/mapdb/Issue41Test.java
Patch:
@@ -82,7 +82,7 @@ public void run() {
                         map.put(key, value);
                     } finally {
                         doneSignal.countDown();
-                        System.out.println("OP " + j);
+//                        System.out.println("OP " + j);
                     }
                 }
             });
@@ -117,7 +117,7 @@ public void run() {
                         }
                     } finally {
                         doneSignal.countDown();
-                        System.out.println("OP " + j);
+//                        System.out.println("OP " + j);
                     }
                 }
             });

File: src/test/java/examples/E01_BasicExample.java
Patch:
@@ -2,6 +2,7 @@
 
 import org.mapdb.DB;
 import org.mapdb.DBMaker;
+import org.mapdb.Utils;
 
 import java.io.File;
 import java.util.concurrent.ConcurrentNavigableMap;
@@ -13,7 +14,8 @@ public static void main(String[] args){
 
         //Configure and open database using builder pattern.
         //All options are available with code auto-completion.
-        DB db = DBMaker.newFileDB(new File("testdb"))
+        File dbFile = Utils.tempDbFile();
+        DB db = DBMaker.newFileDB(dbFile)
                 .closeOnJvmShutdown()
                 .encryptionEnable("password")
                 .make();

File: src/main/java/org/mapdb/DB.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.lang.ref.WeakReference;
 import java.util.*;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 /**
  * A database with easy access to named maps and other collections.
@@ -47,7 +48,7 @@ public class DB {
     public DB(final Engine engine){
         this.engine = engine;
         // load serializer
-        final ArrayList<SerializerPojo.ClassInfo> classInfos = engine.get(engine.serializerRecid(), SerializerPojo.serializer);
+        final CopyOnWriteArrayList<SerializerPojo.ClassInfo> classInfos = engine.get(engine.serializerRecid(), SerializerPojo.serializer);
         this.defaultSerializer = new SerializerPojo(classInfos){
             @Override
             protected void saveClassInfo() {

File: src/test/java/org/mapdb/SerializerPojoTest.java
Patch:
@@ -6,11 +6,12 @@
 import java.io.Serializable;
 import java.util.AbstractMap;
 import java.util.ArrayList;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 @SuppressWarnings({ "unchecked", "rawtypes" })
 public class SerializerPojoTest extends TestCase {
 
-    SerializerPojo p = new SerializerPojo(new ArrayList<SerializerPojo.ClassInfo>());
+    SerializerPojo p = new SerializerPojo(new CopyOnWriteArrayList<SerializerPojo.ClassInfo>());
 
     enum Order
     {

File: src/main/java/org/mapdb/DB.java
Patch:
@@ -209,7 +209,7 @@ synchronized public <K,V> BTreeMap<K,V> createTreeMap(
             Serializer<K[]> keySerializer, Serializer<V> valueSerializer, Comparator<K> comparator){
         checkNameNotExists(name);
         BTreeMap<K,V> ret = new BTreeMap<K,V>(engine, nodeSize, true,valuesStoredOutsideNodes, defaultSerializer, keySerializer, valueSerializer, comparator);
-        nameDir.put(name, ret.rootRecid);
+        nameDir.put(name, ret.treeRecid);
         collections.put(name, new WeakReference<Object>(ret));
         return ret;
     }
@@ -269,7 +269,7 @@ synchronized public <K> NavigableSet<K> getTreeSet(String name){
     synchronized public <K> NavigableSet<K> createTreeSet(String name, int nodeSize, Serializer<K[]> serializer, Comparator<K> comparator){
         checkNameNotExists(name);
         BTreeMap<K,Object> ret = new BTreeMap<K,Object>(engine, nodeSize, true, false, defaultSerializer, serializer, null, comparator);
-        nameDir.put(name, ret.rootRecid);
+        nameDir.put(name, ret.treeRecid);
         NavigableSet<K> ret2 = ret.keySet();
         collections.put(name, new WeakReference<Object>(ret2));
         return ret2;

File: src/main/java/org/mapdb/CacheWeakSoftRef.java
Patch:
@@ -174,7 +174,7 @@ public <A> boolean compareAndSwap(long recid, A expectedOldValue, A newValue, Se
         try{
             locks.lock(recid);
             CacheItem item = items.get(recid);
-            Object oldValue = item.get();
+            Object oldValue = item==null? null: item.get() ;
             if(item!=null && oldValue!=null && item.getRecid() == recid &&
                     (oldValue == expectedOldValue || oldValue.equals(expectedOldValue))){
                 //found matching entry in cache, so just update and return true

File: src/main/java/org/mapdb/LinkedQueueLifo.java
Patch:
@@ -41,7 +41,7 @@ public LinkedQueueLifo(Engine engine, Serializer<E> serializer, boolean useLocks
         this.engine = engine;
         this.serializer = serializer;
         this.useLocks = useLocks;
-        this.locks = useLocks? new Locks.SegmentedRecidLocks(16) : null;
+        this.locks = useLocks? new Locks.LongHashMapRecidLocks() : null;
         this.headRecid = engine.put(ZERO, Serializer.LONG_SERIALIZER);
     }
 

File: src/main/java/org/mapdb/DBMaker.java
Patch:
@@ -597,8 +597,8 @@ public Engine makeEngine(){
             Runtime.getRuntime().addShutdownHook(new Thread("JDBM shutdown") {
                 @Override
 				public void run() {
-                    //TODO handle already closed engine
-                    engine2.close();
+                    if(!engine2.isClosed())
+                        engine2.close();
                 }
             });
         }

File: src/main/java/org/mapdb/CacheHashTable.java
Patch:
@@ -16,8 +16,6 @@
 
 package org.mapdb;
 
-import com.sun.org.apache.bcel.internal.generic.ACONST_NULL;
-
 /**
  * Fixed size cache which uses hash table.
  * Is thread-safe and requires only minimal locking.

File: src/main/java/org/mapdb/LongMap.java
Patch:
@@ -86,6 +86,7 @@ public abstract class LongMap<V> {
     public abstract LongMapIterator<V> longMapIterator();
 
 
+    /** Iterates over LongMap key and values without boxing long keys */
     public interface LongMapIterator<V>{
         boolean moveToNext();
         long key();

File: src/main/java/org/mapdb/SnapshotEngine.java
Patch:
@@ -1,5 +1,7 @@
 package org.mapdb;
 
+import org.jetbrains.annotations.NotNull;
+
 import java.io.IOError;
 import java.io.IOException;
 import java.util.*;
@@ -83,6 +85,7 @@ public void delete(long recid) {
     }
 
 
+    @NotNull
     public Engine snapshot(){
         snapshotsLock.writeLock().lock();
         try{

File: src/test/java/benchmark/MassiveInsert.java
Patch:
@@ -9,11 +9,11 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
-import java.util.logging.Logger;
 
 /**
  * Tests massive concurrent insert
  */
+@SuppressWarnings({ "unchecked", "rawtypes" })
 public class MassiveInsert {
 
     final static int threads = 4 ;
@@ -42,7 +42,7 @@ public static void main(String[] args) throws InterruptedException {
         final AtomicLong counter = new AtomicLong(0);
 
 
-        final Logger log = Logger.getLogger("test");
+        //final Logger log = Logger.getLogger("test");
         final AtomicLong order = new AtomicLong(10000000);
 
         for(int i=0;i<threads;i++){

File: src/test/java/benchmark/SimpleBench.java
Patch:
@@ -15,7 +15,7 @@ public class SimpleBench extends AbstractBenchmark{
 
     static final int size = (int) 1e5;
 
-    protected void testMap(Map m){
+    protected void testMap(Map<Object,Object> m){
         for(int i=0;i<size;i++){
             m.put(i, ""+i);
         }
@@ -75,14 +75,14 @@ protected void testMap(Map m){
     @Test public void SkipList(){
         assumeTrue(CC.FULL_TEST);
         testMap(
-                new ConcurrentSkipListMap()
+                new ConcurrentSkipListMap<Object, Object>()
         );
     }
 
     @Test public void HashMap(){
         assumeTrue(CC.FULL_TEST);
         testMap(
-                new ConcurrentHashMap()
+                new ConcurrentHashMap<Object, Object>()
         );
     }
 

File: src/test/java/benchmark/Synchronized_Versus_ReentrantLock.java
Patch:
@@ -8,7 +8,6 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.locks.LockSupport;
 import java.util.concurrent.locks.ReentrantLock;
 
 import static org.junit.Assert.assertEquals;

File: src/test/java/org/mapdb/AsyncWriteEngineTest.java
Patch:
@@ -17,6 +17,7 @@
 /**
  * @author Jan Kotek
  */
+@SuppressWarnings({ "unchecked", "rawtypes" })
 public class AsyncWriteEngineTest extends TestFile{
     AsyncWriteEngine engine;
 

File: src/test/java/org/mapdb/BTreeMapNavigableSubMapExclusiveTest.java
Patch:
@@ -1,8 +1,5 @@
 package org.mapdb;
 
-
-import org.junit.Ignore;
-
 public class BTreeMapNavigableSubMapExclusiveTest extends BTreeMapNavigable2Test{
 
     @Override

File: src/test/java/org/mapdb/BTreeMapNavigableSubMapInclusiveTest.java
Patch:
@@ -1,8 +1,5 @@
 package org.mapdb;
 
-
-import org.junit.Ignore;
-
 public class BTreeMapNavigableSubMapInclusiveTest extends BTreeMapNavigable2Test{
 
     @Override

File: src/test/java/org/mapdb/BTreeMapNavigableTest.java
Patch:
@@ -45,7 +45,6 @@
 package org.mapdb;
 
 import junit.framework.TestCase;
-import org.junit.Ignore;
 import org.mapdb.DBMaker;
 
 import java.util.NavigableMap;

File: src/test/java/org/mapdb/BTreeMapTest3.java
Patch:
@@ -1,7 +1,5 @@
 package org.mapdb;
 
-import org.junit.Ignore;
-
 import java.util.*;
 import java.util.concurrent.ConcurrentNavigableMap;
 
@@ -62,7 +60,7 @@ protected ConcurrentNavigableMap<Integer, String> makeEitherMap() {
         }
     }
 
-    @SuppressWarnings("unchecked") // Needed for null comparator
+    @SuppressWarnings({ "unchecked", "rawtypes" }) // Needed for null comparator
     public void testOrdering() {
         final SortedMap<Integer, String> map;
         try {

File: src/test/java/org/mapdb/BTreeSetTest.java
Patch:
@@ -5,7 +5,7 @@
 
 import java.util.Collections;
 
-@SuppressWarnings("unchecked")
+@SuppressWarnings({ "unchecked", "rawtypes" })
 public class BTreeSetTest extends HTreeSetTest{
 
     @Override

File: src/test/java/org/mapdb/CacheWeakSoftRefTest.java
Patch:
@@ -4,8 +4,8 @@
 
 import java.util.Map;
 
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertTrue;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 public class CacheWeakSoftRefTest {
 

File: src/test/java/org/mapdb/DBMakerTest.java
Patch:
@@ -13,9 +13,10 @@
 import static org.junit.Assert.*;
 import org.mapdb.EngineWrapper.*;
 
+@SuppressWarnings({ "unchecked", "rawtypes" })
 public class DBMakerTest{
 
-    @SuppressWarnings("unchecked")
+    
     private void verifyDB(DB db) {
         Map m = db.getHashMap("test");
         m.put(1,2);
@@ -84,6 +85,7 @@ public void testMake() throws Exception {
         assertTrue(w instanceof SnapshotEngine);
         assertTrue(w.getWrappedEngine().getClass() == AsyncWriteEngine.class);
         AsyncWriteEngine r = (AsyncWriteEngine) w.getWrappedEngine();
+        assertTrue(r.getWrappedEngine() instanceof Storage);
 
     }
 

File: src/test/java/org/mapdb/DBTest.java
Patch:
@@ -1,15 +1,14 @@
 package org.mapdb;
 
 import org.junit.Test;
+import static org.junit.Assert.*;
 
 import java.util.Map;
 import java.util.Set;
 
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertTrue;
 
 
-@SuppressWarnings("unchecked")
+@SuppressWarnings({ "unchecked", "rawtypes" })
 public class DBTest {
 
     Engine engine = new StorageDirect(Volume.memoryFactory(false));

File: src/test/java/org/mapdb/FunTest.java
Patch:
@@ -3,14 +3,13 @@
 
 import org.junit.Test;
 
-import java.util.Map;
 import java.util.concurrent.ConcurrentNavigableMap;
 import java.util.concurrent.ConcurrentSkipListMap;
 
 import static org.junit.Assert.*;
-import static org.junit.Assert.assertEquals;
 import static org.mapdb.Fun.*;
 
+@SuppressWarnings({ "unchecked", "rawtypes" })
 public class FunTest {
 
     public int compare(int[] o1, int[] o2) {

File: src/test/java/org/mapdb/HTreeMap2Test.java
Patch:
@@ -7,7 +7,7 @@
 
 import static org.junit.Assert.*;
 
-@SuppressWarnings("unchecked")
+@SuppressWarnings({ "unchecked", "rawtypes" })
 public class HTreeMap2Test extends StorageTestCase {
 
 

File: src/test/java/org/mapdb/HTreeSetTest.java
Patch:
@@ -33,7 +33,7 @@
  * Tests for HashSet which comes with JDBM. Original code comes from Apache Harmony,
  * Modified by Jan Kotek for use in JDBM
  */
-@SuppressWarnings("unchecked")
+@SuppressWarnings({"unchecked","rawtypes"})
 public class HTreeSetTest{
 
     Engine engine = new StorageDirect(Volume.memoryFactory(false));
@@ -130,4 +130,4 @@ public class HTreeSetTest{
         Collections.addAll(hs, objArray);
     }
 
-}
\ No newline at end of file
+}

File: src/test/java/org/mapdb/LoggerVolume.java
Patch:
@@ -2,7 +2,6 @@
 
 import java.io.ByteArrayOutputStream;
 import java.io.PrintStream;
-import java.nio.ByteBuffer;
 
 
 /**

File: src/test/java/org/mapdb/LongConcurrentHashMapTest.java
Patch:
@@ -13,7 +13,7 @@
 
 import java.util.Iterator;
 
-@SuppressWarnings("unchecked")
+@SuppressWarnings({ "unchecked", "rawtypes" })
 public class LongConcurrentHashMapTest extends TestCase{
 
     /**
@@ -245,4 +245,4 @@ public void shouldThrow() {
         fail("Should throw exception");
     }
 
-}
\ No newline at end of file
+}

File: src/test/java/org/mapdb/RecidLocksTest.java
Patch:
@@ -21,7 +21,7 @@ public RecidLocksTest(Locks.RecidLocks locks) {
     }
 
     @Parameterized.Parameters
-    public static List params(){
+    public static List<?> params(){
         return Arrays.asList(new Object[][]{{new Locks.LongHashMapRecidLocks()}});
     }
 

File: src/test/java/org/mapdb/SerializationHeaderTest.java
Patch:
@@ -10,7 +10,7 @@
 
 public class SerializationHeaderTest extends TestCase {
 
-    @SuppressWarnings("unchecked")
+	@SuppressWarnings({  "rawtypes" })
     public void testUnique() throws IllegalAccessException {
         Class c = SerializationHeader.class;
         Set<Integer> s = new TreeSet<Integer>();

File: src/test/java/org/mapdb/SerializerBaseTest.java
Patch:
@@ -25,9 +25,8 @@
 import java.util.*;
 
 import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertTrue;
 
-@SuppressWarnings("unchecked")
+@SuppressWarnings({ "unchecked", "rawtypes" })
 public class SerializerBaseTest extends TestCase {
 
     SerializerBase ser = new SerializerBase();

File: src/test/java/org/mapdb/StorageJournaledTest.java
Patch:
@@ -9,7 +9,6 @@
 import java.util.Collections;
 
 import static org.junit.Assert.*;
-import static org.junit.Assert.assertEquals;
 
 
 public class StorageJournaledTest extends TestFile {

File: src/test/java/org/mapdb/StorageTestCase.java
Patch:
@@ -3,7 +3,6 @@
 
 import org.junit.Before;
 
-import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.*;
 

File: src/test/java/org/mapdb/TestUtils.java
Patch:
@@ -6,7 +6,7 @@
 @Ignore
 public class TestUtils {
 
-    public static void perfResult(Class clazz, String key, Object value){
+    public static void perfResult(Class<?> clazz, String key, Object value){
         System.out.println("PERF: "+clazz.getSimpleName()+"-"+key+" = "+value);
     }
 

File: src/test/java/stress/LoopHelpers.java
Patch:
@@ -8,7 +8,6 @@
  * Misc utilities in JSR166 performance tests
  */
 
-import java.util.concurrent.*;
 import java.util.concurrent.atomic.*;
 
 class LoopHelpers {
@@ -200,4 +199,4 @@ public static String rightJustify(long n) {
         return b.toString();
     }
 
-}
\ No newline at end of file
+}

File: src/test/java/stress/MapLoops.java
Patch:
@@ -9,6 +9,7 @@
 import java.util.*;
 import java.util.concurrent.*;
 
+@SuppressWarnings({ "unchecked", "rawtypes" })
 public class MapLoops {
     static int nkeys       = 100000;
     static int pinsert     = 60;
@@ -185,4 +186,4 @@ public void run() {
             }
         }
     }
-}
\ No newline at end of file
+}

File: src/test/java/org/mapdb/AtomicBooleanTest.java
Patch:
@@ -86,6 +86,7 @@ public void testGetAndSet() {
      * toString returns current value.
      */
     public void testToString() {
+        Atomic.Boolean ai = Atomic.getBoolean(db, "test2");
         assertEquals(ai.toString(), Boolean.toString(false));
         ai.set(true);
         assertEquals(ai.toString(), Boolean.toString(true));

File: src/main/java/org/mapdb/SerializationHeader.java
Patch:
@@ -105,6 +105,7 @@ interface SerializationHeader {
     //special cases for BTree values which stores references
     int  ARRAY_OBJECT_PACKED_LONG = 74;
     int  ARRAYLIST_PACKED_LONG = 75;
+    int ARRAY_OBJECT_ALL_NULL = 76;
 
     int  STRING_EMPTY = 101;
     int  STRING = 103;

File: src/main/java/org/mapdb/CacheLRU.java
Patch:
@@ -4,6 +4,7 @@
  * Least Recently Used cache.
  * If cache is full it removes less used items to make a space
  */
+//TODO check all caches for null values
 public class CacheLRU extends EngineWrapper {
 
     protected LongMap cache;
@@ -25,7 +26,8 @@ public <A> long recordPut(A value, Serializer<A> serializer) {
         long recid =  super.recordPut(value, serializer);
         try{
             locks.lock(recid);
-            cache.put(recid, value);
+            if(value!=null)
+                cache.put(recid, value);
         }finally {
             locks.unlock(recid);
         }

File: src/main/java/org/mapdb/DBMaker.java
Patch:
@@ -457,7 +457,7 @@ public DBMaker readOnly(){
      * to traverse list of free records to find and reuse existing position.
      * <p/>
      * It also decreases chance for store corruption, as existing data
-     * are not overwriten with new record.
+     * are not overwritten with new record.
      * <p/>
      * When this mode is used for longer time, store becomes fragmented.
      * It is necessary to run defragmentation then.

File: src/test/java/examples/E24_BTreeMap_MultiKey.java
Patch:
@@ -38,8 +38,7 @@ public static void main(String[] args) {
 
         //initialize map
         ConcurrentNavigableMap<Fun.Tuple3, Integer> map =
-                 new ConcurrentSkipListMap<Fun.Tuple3, Integer>();
-                //DBMaker.newTempTreeMap();
+                DBMaker.newTempTreeMap();
 
 
         //fill with values, use simple permutation so we dont have to include large test data.

File: src/test/java/org/mapdb/BTreeMapTest.java
Patch:
@@ -196,6 +196,8 @@ private static void printRecur(BTreeMap m, long recid, String s) {
         assertEquals(10, m.remove(10));
         assertEquals(20, m.remove(20));
         assertEquals(42, m.remove(42));
+
+        assertEquals(null, m.remove(42999));
     }
 
 

File: src/main/java/org/mapdb/SerializerPojo.java
Patch:
@@ -128,7 +128,7 @@ public String getName() {
         }
 
         public FieldInfo[] getFields() {
-            return (FieldInfo[]) fields.toArray();
+            return fields.toArray(new FieldInfo[fields.size()]);
         }
 
         public FieldInfo getField(String name) {

File: src/main/java/org/mapdb/DB.java
Patch:
@@ -194,6 +194,7 @@ protected void checkNameNotExists(String name) {
      * !! it is necessary to call this method before JVM exits!!
      */
     synchronized public void close(){
+        if(engine == null) return;
         engine.close();
         //dereference db to prevent memory leaks
         engine = null;

File: src/main/java/org/mapdb/ByteBuffer2.java
Patch:
@@ -226,6 +226,7 @@ public void close() throws IOException {
     }
 
     public void sync() {
+        if(inMemory) return;
         for(ByteBuffer b:buffers){
             if(b!=null && (b instanceof MappedByteBuffer)){
                 ((MappedByteBuffer)b).force();

File: src/main/java/org/mapdb/SerializationHeader.java
Patch:
@@ -80,7 +80,8 @@ interface SerializationHeader {
     int  ARRAY_LONG_PACKED = 69;
 
     int  CHAR_ARRAY = 70;
-    int  ARRAY_BYTE_INT = 71;
+    int ARRAY_BYTE = 71;
+    int ARRAY_BYTE_ALL_EQUAL = 72;
 
     int  ARRAY_OBJECT = 73;
     //special cases for BTree values which stores references
@@ -108,7 +109,7 @@ interface SerializationHeader {
 
     int  LINKEDLIST = 119;
 
-    int  LAZY_REF = 120;
+    int  SERIALIZER_COMPRESSION_WRAPPER = 120;
 
     int  VECTOR = 121;
     int  IDENTITYHASHMAP = 122;

File: src/test/java/org/mapdb/AsyncWriteEngineTest.java
Patch:
@@ -25,7 +25,7 @@ public class AsyncWriteEngineTest extends TestFile{
         assertNotNull(index);
         if(engine !=null)
            engine.close();
-        engine =  new AsyncWriteEngine(new StorageDirect(index,false,false,false,false), true);
+        engine =  new AsyncWriteEngine(new StorageDirect(index), true);
     }
 
 

File: src/test/java/org/mapdb/BTreeMapLargeValsTest.java
Patch:
@@ -27,7 +27,7 @@ public BTreeMapLargeValsTest() {
         super(false, false, true, true, true, true,false);
     }
 
-    Engine r = new StorageDirect(null,false,true,false,false);
+    Engine r = new StorageDirect(null);
 
 
     @Override
@@ -47,7 +47,7 @@ protected String getSecondValueNotInPopulatedMap() throws UnsupportedOperationEx
 
     @Override
     protected ConcurrentMap<Integer, String> makeEmptyMap() throws UnsupportedOperationException {
-        return new BTreeMap<Integer,String>(r,6,true,null,null,null,null);
+        return new BTreeMap<Integer,String>(r,6,true,true, null,null,null,null);
     }
 
     @Override

File: src/test/java/org/mapdb/BTreeMapTest2.java
Patch:
@@ -25,7 +25,7 @@ public BTreeMapTest2() {
         super(false, false, true, true, true, true, false);
     }
 
-    Engine r = new StorageDirect(null,false,true,false,false);
+    Engine r = new StorageDirect(null);
 
 
     @Override
@@ -45,7 +45,7 @@ protected String getSecondValueNotInPopulatedMap() throws UnsupportedOperationEx
 
     @Override
     protected ConcurrentMap<Integer, String> makeEmptyMap() throws UnsupportedOperationException {
-        return new BTreeMap<Integer,String>(r,6,true,null,null,null,null);
+        return new BTreeMap<Integer,String>(r,6,true,false, null,null,null,null);
     }
 
     @Override

File: src/test/java/org/mapdb/BTreeSetTest.java
Patch:
@@ -11,7 +11,7 @@ public class BTreeSetTest extends HTreeSetTest{
     @Before
     public void setUp() throws Exception {
         super.setUp();
-        hs = new BTreeMap(engine, 6, false,null,null,null,null).keySet();
+        hs = new BTreeMap(engine, 6, false,false, null,null,null,null).keySet();
         Collections.addAll(hs, objArray);
     }
 }

File: src/test/java/org/mapdb/ByteBuffer2Test.java
Patch:
@@ -23,7 +23,7 @@ public class ByteBuffer2Test {
         File ff = File.createTempFile("byte-buffer-test","");
         ff.deleteOnExit();
         FileChannel ff2 = new RandomAccessFile(ff,"rw").getChannel();
-        b = new ByteBuffer2(false, ff2, FileChannel.MapMode.READ_WRITE,"test");
+        b = new ByteBuffer2(false, ff2, FileChannel.MapMode.READ_WRITE,"test", false);
     }
 
     @Test

File: src/test/java/org/mapdb/StorageDirectTest.java
Patch:
@@ -349,7 +349,7 @@ protected void commit(){
     }
 
     @Test public void in_memory_test(){
-        StorageDirect engine = new StorageDirect(null,false,true,false,false);
+        StorageDirect engine = new StorageDirect(null);
         Map<Long, Integer> recids = new HashMap<Long,Integer>();
         for(int i = 0;i<1000;i++){
             long recid = engine.recordPut(i, Serializer.BASIC_SERIALIZER);

File: src/main/java/org/mapdb/AsyncWriteEngine.java
Patch:
@@ -59,8 +59,7 @@ private void writerThreadRun() {
                 }
 
                 synchronized (writerNotify){
-                    writerNotify.wait();
-                    //writerNotify.wait(1000); //check write conditions every N seconds to prevent possible deadlock
+                    writerNotify.wait(1000); //check write conditions every N seconds to prevent possible deadlock
                 }
             }
 

File: src/main/java/net/kotek/jdbm/LongHashMap.java
Patch:
@@ -31,7 +31,7 @@
  * <p/>
  * Author of JDBM modifications: Jan Kotek
  */
-class LongHashMap<V> implements Serializable, LongMap<V> {
+public class LongHashMap<V> extends LongMap<V> implements Serializable  {
     private static final long serialVersionUID = 362499999763181265L;
 
     private int elementCount;

File: src/main/java/net/kotek/jdbm/StorageDirect.java
Patch:
@@ -280,7 +280,7 @@ protected long freePhysRecTake(final int requiredSize) throws IOException {
             index.putLong(RECID_CURRENT_PHYS_FILE_SIZE * 8, physFileSize + freeSizeToCreate + requiredSize);
 
             //mark 'padding' free record
-            freePhysRecPut(freeSizeToCreate<<48|physFileSize);
+            freePhysRecPut((freeSizeToCreate<<48)|physFileSize);
 
             //and finally return position at beginning of new buffer
             return (((long)requiredSize)<<48) | nextBufferStartOffset;

File: src/main/java/net/kotek/jdbm/CC.java
Patch:
@@ -26,7 +26,7 @@ interface CC {
      * JDBM has some long running acceptance tests. For daily development it makes sense to skip those.
      * This flag controls whatever all tests are run.
      */
-    boolean FULL_TEST = true;
+    boolean FULL_TEST = false;
 
 
     /**

File: src/main/java/net/kotek/jdbm/StorageDirect.java
Patch:
@@ -12,6 +12,9 @@ public StorageDirect(File indexFile, boolean enableLocks,
                          boolean deleteFilesAfterClose,
                          boolean readOnly, boolean appendOnly) {
         super(indexFile, enableLocks, deleteFilesAfterClose, readOnly, appendOnly);
+        if(indexFile!=null && new File(indexFile.getPath()+StorageTrans.TRANS_LOG_FILE_EXT).exists()){
+            throw new IllegalAccessError("Log file found. Reopen with transaction enabled, to finish transaction log replay!");
+        }
     }
 
     @Override

File: src/test/java/net/kotek/jdbm/DBMakerTest.java
Patch:
@@ -149,7 +149,6 @@ public void testCacheSize() throws Exception {
                 .newFileDB(f)
                 .deleteFilesAfterClose()
                 .readOnly()
-                .transactionDisable()
                 .make();
         assertTrue(db.recman instanceof ReadOnlyWrapper);
         db.close();

File: src/test/java/net/kotek/jdbm/JdbmTestCase.java
Patch:
@@ -26,6 +26,7 @@ abstract public class JdbmTestCase {
 
      @Before
      public void setUp() throws Exception {
+        testDir = new File(new File(System.getProperty("java.io.tmpdir")), "testdb");
         testDir.mkdirs();
         fileName = new File(testDir.getPath()+"test"+Math.random());
 

File: src/test/java/net/kotek/jdbm/StorageDirectTest.java
Patch:
@@ -321,6 +321,7 @@ protected void commit(){
     @Test public void test_store_reopen(){
         long recid = recman.recordPut("aaa", Serializer.STRING_SERIALIZER);
 
+        recman.commit();
         reopenStore();
 
         String aaa = recman.recordGet(recid, Serializer.STRING_SERIALIZER);

File: src/test/java/net/kotek/jdbm/JunkTest.java
Patch:
@@ -1,7 +1,6 @@
 package net.kotek.jdbm;
 
 import org.junit.Assert;
-import org.junit.Assume;
 import org.junit.Test;
 
 import java.io.File;
@@ -18,7 +17,6 @@ public class JunkTest  extends JdbmTestCase{
     @Test
     public void test_mapped_byte_buffer_reopen() throws IOException {
 
-        Assume.assumeTrue(false);
 
         File f = File.createTempFile("whatever","ads");
         f.deleteOnExit();

File: src/main/java/net/kotek/jdbm/DBMaker.java
Patch:
@@ -305,8 +305,8 @@ public DB make(){
         }
 
         RecordManager recman = _transactionsEnabled?
-                new StorageTrans(_file, !_asyncSerializationEnabled, _deleteFilesAfterClose,_readOnly):
-                new StorageDirect(_file, !_asyncSerializationEnabled, _deleteFilesAfterClose,_readOnly);
+                new StorageTrans(_file, !_asyncWriteEnabled, _deleteFilesAfterClose,_readOnly):
+                new StorageDirect(_file, !_asyncWriteEnabled, _deleteFilesAfterClose,_readOnly);
 
         if(_asyncWriteEnabled && !_readOnly)
             recman = new AsyncWriteWrapper(recman, _asyncSerializationEnabled);

File: src/main/java/net/kotek/jdbm/BTreeMap.java
Patch:
@@ -39,7 +39,6 @@ public class BTreeMap<K,V> extends  AbstractMap<K,V> implements
 
     protected final boolean hasValues;
 
-
     protected long treeRecid;
 
 

File: src/main/java/net/kotek/jdbm/ConcurrentSortedMap.java
Patch:
@@ -1,7 +1,8 @@
 package net.kotek.jdbm;
 
-import java.util.*;
-import java.util.concurrent.*;
+import java.util.SortedMap;
+import java.util.SortedSet;
+import java.util.concurrent.ConcurrentMap;
 
 /**
  * Interface which mixes ConcurrentMap and SortedMap together.

File: src/main/java/net/kotek/jdbm/SerializerBase.java
Patch:
@@ -193,7 +193,7 @@ else if (val == 0)
             else if (val == 1)
                 out.write(BYTE_1);
             else {
-                out.write(SHORT_FULL);
+                out.write(BYTE_FULL);
                 out.writeByte(val);
             }
             return;

File: src/main/java/net/kotek/jdbm/ByteBuffer2.java
Patch:
@@ -65,11 +65,12 @@ public void ensureAvailable(long offset) throws IOException {
         int buffersPos = (int) (offset/BUF_SIZE);
 
         //check for most common case, this is already mapped
-        if(buffers[buffersPos]!=null && buffers[buffersPos].capacity()>=offset%BUF_SIZE)
+        if(buffersPos<buffers.length && buffers[buffersPos]!=null &&
+                buffers[buffersPos].capacity()>=offset%BUF_SIZE)
             return;
 
         //grow array if necessary
-        if(buffers.length<buffersPos){
+        if(buffersPos>=buffers.length){
             buffers = Arrays.copyOf(buffers, Math.max(buffersPos,  buffers.length*2));
         }
 

File: src/main/java/net/kotek/jdbm/DBMaker.java
Patch:
@@ -65,7 +65,7 @@ public DBMaker cacheDisable(){
      * By default all modifications are queued and written into disk on Background Writer Thread.
      * So all modifications are performed in asynchronous mode and do not block.
      * <p/>
-     * It is possible to disable Backround Writer Thread, but this greatly hurts concurrency.
+     * It is possible to disable Background Writer Thread, but this greatly hurts concurrency.
      * Without async writes, all threads blocks until all previous writes are not finished (single big lock).
      *
      * <p/>

File: src/main/java/net/kotek/jdbm/RecordStoreAsyncWrite.java
Patch:
@@ -54,7 +54,7 @@ private void writerThreadRun() {
                 }
 
                 //TODO this just sucks, proper notify()
-                Thread.sleep(100);
+                Thread.yield();
             }
 
 

File: src/main/java/net/kotek/jdbm/DataInput2.java
Patch:
@@ -61,8 +61,8 @@ public short readShort() throws IOException {
 
     @Override
     public int readUnsignedShort() throws IOException {
-        return (((int) (buf.get(pos++) & 0xff) << 8) |
-                ((int) (buf.get(pos++) & 0xff)));
+        return (( (buf.get(pos++) & 0xff) << 8) |
+                ( (buf.get(pos++) & 0xff)));
     }
 
     @Override

File: src/main/java/net/kotek/jdbm/LongMap.java
Patch:
@@ -61,7 +61,7 @@ interface LongMap<V> {
 
 
     /**
-     * @returns iterator over values in map
+     * @return iterator over values in map
      */
     Iterator<V> valuesIterator();
 

File: src/test/java/net/kotek/jdbm/BTreeMapTest.java
Patch:
@@ -5,6 +5,7 @@
 import java.io.*;
 import java.util.*;
 
+@SuppressWarnings("unchecked")
 public class BTreeMapTest{
 
     RecordManager recman = new RecordStore(null);

File: src/test/java/net/kotek/jdbm/HTreeMap2Test.java
Patch:
@@ -6,8 +6,8 @@
 import java.util.*;
 
 import static org.junit.Assert.*;
-import static org.junit.Assert.assertEquals;
 
+@SuppressWarnings("unchecked")
 public class HTreeMap2Test extends JdbmTestCase {
 
 
@@ -267,7 +267,7 @@ public void testIteration(){
         HTreeMap m = new HTreeMap<Integer, Integer>(recman, true){
             @Override
             protected int hash(Object key) {
-                return ((Integer)key).intValue();
+                return (Integer) key;
             }
         };
 

File: src/test/java/net/kotek/jdbm/JdbmTestCase.java
Patch:
@@ -41,7 +41,7 @@ protected RecordStore openRecordManager() {
     public void tearDown() throws Exception {
         recman.close();
         for(File f:testDir.listFiles()){
-            if(!f.delete())f.deleteOnExit();
+            if(f!=null && !f.delete())f.deleteOnExit();
         }
     }
 
@@ -99,8 +99,8 @@ List<Long> getLongStack(long recid){
     }
 
     int readUnsignedShort(ByteBuffer buf, long pos) throws IOException {
-        return (((int) (buf.get((int) pos) & 0xff) << 8) |
-                ((int) (buf.get((int) (pos+1)) & 0xff)));
+        return (( (buf.get((int) pos) & 0xff) << 8) |
+                ( (buf.get((int) (pos+1)) & 0xff)));
     }
 
 

File: src/test/java/net/kotek/jdbm/JunkTest.java
Patch:
@@ -11,6 +11,7 @@
 import java.nio.channels.FileChannel;
 
 
+@SuppressWarnings("unchecked")
 public class JunkTest  extends JdbmTestCase{
 
 

File: src/test/java/net/kotek/jdbm/MapInterfaceTest.java
Patch:
@@ -28,7 +28,6 @@
 import java.util.Set;
 import java.util.Map.Entry;
 
-import com.sun.servicetag.SystemEnvironment;
 import junit.framework.TestCase;
 
 /**
@@ -871,7 +870,7 @@ public void testGet() {
             assertEquals(entry.getValue(), map.get(entry.getKey()));
         }
 
-        K unmappedKey = null;
+        K unmappedKey;
         try {
             unmappedKey = getKeyNotInPopulatedMap();
         } catch (UnsupportedOperationException e) {
@@ -882,7 +881,7 @@ public void testGet() {
 
     public void testGetForEmptyMap() {
         final Map<K, V> map;
-        K unmappedKey = null;
+        K unmappedKey;
         try {
             map = makeEmptyMap();
             unmappedKey = getKeyNotInPopulatedMap();

File: src/test/java/net/kotek/jdbm/RecordStoreAsyncWriteTest.java
Patch:
@@ -65,7 +65,7 @@ public void concurrent_updates_test() throws InterruptedException {
 
         Assert.assertEquals(recids.size(),threadNum);
         for(int i = 0;i<threadNum; i++){
-            long recid = recids.get(Integer.valueOf(i));
+            long recid = recids.get(i);
 
             String expectedStr ="";
             for(int j=0;j<updates;j++)

File: src/test/java/net/kotek/jdbm/SerializationHeaderTest.java
Patch:
@@ -9,6 +9,7 @@
 
 public class SerializationHeaderTest extends TestCase {
 
+    @SuppressWarnings("unchecked")
     public void testUnique() throws IllegalAccessException {
         Class c = SerializationHeader.class;
         Set<Integer> s = new TreeSet<Integer>();

File: src/test/java/net/kotek/jdbm/SerializerBaseTest.java
Patch:
@@ -118,13 +118,13 @@ public void testChar() throws IOException{
     public void testLong() throws IOException{
         long[] vals = {
                 Long.MIN_VALUE,
-                Integer.MIN_VALUE, Integer.MIN_VALUE - 1, Integer.MIN_VALUE + 1,
+                Integer.MIN_VALUE, (long)Integer.MIN_VALUE - 1, (long)Integer.MIN_VALUE + 1,
                 -Short.MIN_VALUE * 2,
                 -Short.MIN_VALUE + 1,
                 -Short.MIN_VALUE,
                 -10, -9, -8, -7, -6, -5, -4, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
                 127, 254, 255, 256, Short.MAX_VALUE, Short.MAX_VALUE + 1,
-                Short.MAX_VALUE * 2, Integer.MAX_VALUE, Integer.MAX_VALUE + 1, Long.MAX_VALUE
+                Short.MAX_VALUE * 2, Integer.MAX_VALUE, (long)Integer.MAX_VALUE + 1, Long.MAX_VALUE
         };
         for (long i : vals) {
             byte[] buf = serialize(i);

File: src/main/java/net/kotek/jdbm/JdbmUtil.java
Patch:
@@ -159,4 +159,5 @@ public static long[] arrayLongPut(final long[] array, final int pos, final long
         ret[pos] = value;
         return ret;
     }
+
 }

File: src/test/java/net/kotek/jdbm/HTreeMap2Test.java
Patch:
@@ -254,7 +254,7 @@ protected int hash(Object key) {
 
     @Test public void clear(){
         HTreeMap m = new HTreeMap(recman,true);
-        for(Integer i=0;i<1e5;i++){
+        for(Integer i=0;i<100;i++){
             m.put(i,i);
         }
         m.clear();

File: src/test/java/net/kotek/jdbm/HTreeSetTest.java
Patch:
@@ -32,7 +32,9 @@
  * Tests for HashSet which comes with JDBM. Original code comes from Apache Harmony,
  * Modified by Jan Kotek for use in JDBM
  */
-public class HTreeSetTest extends JdbmTestCase {
+public class HTreeSetTest{
+
+    RecordManager recman = new RecordStore(null);
 
     Set hs;
 
@@ -146,7 +148,6 @@ public class HTreeSetTest extends JdbmTestCase {
      * is called before a test is executed.
      */
     @Before public void setUp() throws Exception {
-        super.setUp();
         hs = new HTreeMap(recman, false).keySet();
         for (int i = 0; i < objArray.length; i++)
             hs.add(objArray[i]);

File: src/test/java/net/kotek/jdbm/JdbmTestCase.java
Patch:
@@ -39,6 +39,7 @@ protected RecordStore openRecordManager() {
 
     @After
     public void tearDown() throws Exception {
+        recman.close();
         for(File f:testDir.listFiles()){
             if(!f.delete())f.deleteOnExit();
         }

File: src/test/java/net/kotek/jdbm/JunkTest.java
Patch:
@@ -37,15 +37,15 @@ public void test_mapped_byte_buffer_reopen() throws IOException {
 
     @Test public void test2(){
 
-        RecordStore db = new RecordStoreCache("filename",true);
+        RecordStore db = new RecordStoreAsyncWrite("filename",true);
         HTreeMap map = new HTreeMap(db, true);
         map.put(11,222);
 //do something with map
         db.close();
 
         long rootRecid = map.rootRecid; //save this number somewhere
 //restart JVM or whatever, and latter reopen map:
-        db = new RecordStoreCache("filename",true);
+        db = new RecordStoreAsyncWrite("filename",true);
         map = new HTreeMap(db,rootRecid);
         System.out.println(map.get(11));
 //do something with map, it is populated with previous data

File: src/main/java/net/kotek/jdbm/ConcurrentSortedMap.java
Patch:
@@ -1,5 +1,6 @@
 package net.kotek.jdbm;
 
+import java.util.SortedMap;
 import java.util.concurrent.ConcurrentMap;
 
 /**
@@ -10,5 +11,5 @@
  * Also NavigableMap requires bidirectional iterators which B-Linked-Tree
  * used in BTreeMap does not provide
  */
-public interface ConcurrentSortedMap<K, V> extends ConcurrentMap<K,V>{
+public interface ConcurrentSortedMap<K, V> extends ConcurrentMap<K,V>, SortedMap<K,V>{
 }

File: src/main/java/net/kotek/jdbm/HTreeMap.java
Patch:
@@ -705,7 +705,6 @@ public boolean remove(Object o) {
                 return HTreeMap.this.remove(key, e.getValue());
             }
             return false;
-
         }
 
 

File: src/test/java/net/kotek/jdbm/HTreeSetTest.java
Patch:
@@ -32,7 +32,7 @@
  * Tests for HashSet which comes with JDBM. Original code comes from Apache Harmony,
  * Modified by Jan Kotek for use in JDBM
  */
-public class HTreeSet2Test extends JdbmTestCase {
+public class HTreeSetTest extends JdbmTestCase {
 
     Set hs;
 
@@ -89,7 +89,7 @@ public class HTreeSet2Test extends JdbmTestCase {
         // Test for method boolean java.util.HashSet.contains(java.lang.Object)
         assertTrue("Returned false for valid object", hs.contains(objArray[90]));
         assertTrue("Returned true for invalid Object", !hs
-                .contains(new Object()));
+                .contains(-111111));
 
     }
 

File: src/test/java/net/kotek/jdbm/MapInterfaceTest.java
Patch:
@@ -28,6 +28,7 @@
 import java.util.Set;
 import java.util.Map.Entry;
 
+import com.sun.servicetag.SystemEnvironment;
 import junit.framework.TestCase;
 
 /**

