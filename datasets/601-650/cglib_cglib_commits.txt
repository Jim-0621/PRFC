File: cglib/src/main/java/net/sf/cglib/reflect/MethodDelegate.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.lang.reflect.*;
 import java.security.ProtectionDomain;
-import net.sf.cglib.*;
 import net.sf.cglib.core.*;
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.Type;

File: cglib/src/main/java/net/sf/cglib/beans/BeanCopier.java
Patch:
@@ -99,7 +99,7 @@ public void generateClass(ClassVisitor v) {
             Type sourceType = Type.getType(source);
             Type targetType = Type.getType(target);
             ClassEmitter ce = new ClassEmitter(v);
-            ce.begin_class(Constants.V1_2,
+            ce.begin_class(Constants.V1_8,
                            Constants.ACC_PUBLIC,
                            getClassName(),
                            BEAN_COPIER,

File: cglib/src/main/java/net/sf/cglib/beans/BeanGenerator.java
Patch:
@@ -102,7 +102,7 @@ public void generateClass(ClassVisitor v) throws Exception {
             types[i] = (Type)props.get(names[i]);
         }
         ClassEmitter ce = new ClassEmitter(v);
-        ce.begin_class(Constants.V1_2,
+        ce.begin_class(Constants.V1_8,
                        Constants.ACC_PUBLIC,
                        getClassName(),
                        superclass != null ? Type.getType(superclass) : Constants.TYPE_OBJECT,

File: cglib/src/main/java/net/sf/cglib/beans/BeanMapEmitter.java
Patch:
@@ -45,7 +45,7 @@ class BeanMapEmitter extends ClassEmitter {
     public BeanMapEmitter(ClassVisitor v, String className, Class type, int require) {
         super(v);
 
-        begin_class(Constants.V1_2, Constants.ACC_PUBLIC, className, BEAN_MAP, null, Constants.SOURCE_FILE);
+        begin_class(Constants.V1_8, Constants.ACC_PUBLIC, className, BEAN_MAP, null, Constants.SOURCE_FILE);
         EmitUtils.null_constructor(this);
         EmitUtils.factory_method(this, NEW_INSTANCE);
         generateConstructor();

File: cglib/src/main/java/net/sf/cglib/beans/BulkBeanEmitter.java
Patch:
@@ -47,7 +47,7 @@ public BulkBeanEmitter(ClassVisitor v,
         Method[] setters = new Method[setterNames.length];
         validate(target, getterNames, setterNames, types, getters, setters);
 
-        begin_class(Constants.V1_2, Constants.ACC_PUBLIC, className, BULK_BEAN, null, Constants.SOURCE_FILE);
+        begin_class(Constants.V1_8, Constants.ACC_PUBLIC, className, BULK_BEAN, null, Constants.SOURCE_FILE);
         EmitUtils.null_constructor(this);
         generateGet(target, getters);
         generateSet(target, setters);

File: cglib/src/main/java/net/sf/cglib/beans/ImmutableBean.java
Patch:
@@ -73,7 +73,7 @@ public Object create() {
         public void generateClass(ClassVisitor v) {
             Type targetType = Type.getType(target);
             ClassEmitter ce = new ClassEmitter(v);
-            ce.begin_class(Constants.V1_2,
+            ce.begin_class(Constants.V1_8,
                            Constants.ACC_PUBLIC,
                            getClassName(),
                            targetType,

File: cglib/src/main/java/net/sf/cglib/core/KeyFactory.java
Patch:
@@ -246,7 +246,7 @@ public void generateClass(ClassVisitor v) {
             }
 
             Type[] parameterTypes = TypeUtils.getTypes(newInstance.getParameterTypes());
-            ce.begin_class(Constants.V1_2,
+            ce.begin_class(Constants.V1_8,
                            Constants.ACC_PUBLIC,
                            getClassName(),
                            KEY_FACTORY,

File: cglib/src/main/java/net/sf/cglib/proxy/Enhancer.java
Patch:
@@ -591,7 +591,7 @@ public Object transform(Object value) {
 
         ClassEmitter e = new ClassEmitter(v);
         if (currentData == null) {
-        e.begin_class(Constants.V1_2,
+        e.begin_class(Constants.V1_8,
                       Constants.ACC_PUBLIC,
                       getClassName(),
                       Type.getType(sc),
@@ -600,7 +600,7 @@ public Object transform(Object value) {
                        TypeUtils.getTypes(interfaces)),
                       Constants.SOURCE_FILE);
         } else {
-            e.begin_class(Constants.V1_2,
+            e.begin_class(Constants.V1_8,
                     Constants.ACC_PUBLIC,
                     getClassName(),
                     null,

File: cglib/src/main/java/net/sf/cglib/proxy/InterfaceMaker.java
Patch:
@@ -100,8 +100,8 @@ protected Object nextInstance(Object instance) {
 
     public void generateClass(ClassVisitor v) throws Exception {
         ClassEmitter ce = new ClassEmitter(v);
-        ce.begin_class(Constants.V1_2,
-                       Constants.ACC_PUBLIC | Constants.ACC_INTERFACE,
+        ce.begin_class(Constants.V1_8,
+                       Constants.ACC_PUBLIC | Constants.ACC_INTERFACE | Constants.ACC_ABSTRACT,
                        getClassName(),
                        null,
                        null,

File: cglib/src/main/java/net/sf/cglib/proxy/MixinEmitter.java
Patch:
@@ -37,7 +37,7 @@ class MixinEmitter extends ClassEmitter {
     public MixinEmitter(ClassVisitor v, String className, Class[] classes, int[] route) {
         super(v);
 
-        begin_class(Constants.V1_2,
+        begin_class(Constants.V1_8,
                     Constants.ACC_PUBLIC,
                     className,
                     MIXIN,

File: cglib/src/main/java/net/sf/cglib/reflect/ConstructorDelegate.java
Patch:
@@ -92,7 +92,7 @@ public void generateClass(ClassVisitor v) {
             }
 
             ClassEmitter ce = new ClassEmitter(v);
-            ce.begin_class(Constants.V1_2,
+            ce.begin_class(Constants.V1_8,
                            Constants.ACC_PUBLIC,
                            getClassName(),
                            CONSTRUCTOR_DELEGATE,

File: cglib/src/main/java/net/sf/cglib/reflect/FastClassEmitter.java
Patch:
@@ -53,7 +53,7 @@ public FastClassEmitter(ClassVisitor v, String className, Class type) {
         super(v);
 
         Type base = Type.getType(type);
-        begin_class(Constants.V1_2, Constants.ACC_PUBLIC, className, FAST_CLASS, null, Constants.SOURCE_FILE);
+        begin_class(Constants.V1_8, Constants.ACC_PUBLIC, className, FAST_CLASS, null, Constants.SOURCE_FILE);
 
         // constructor
         CodeEmitter e = begin_method(Constants.ACC_PUBLIC, CSTRUCT_CLASS, null);

File: cglib/src/main/java/net/sf/cglib/reflect/MethodDelegate.java
Patch:
@@ -218,7 +218,7 @@ public void generateClass(ClassVisitor v) throws NoSuchMethodException {
 
             ClassEmitter ce = new ClassEmitter(v);
             CodeEmitter e;
-            ce.begin_class(Constants.V1_2,
+            ce.begin_class(Constants.V1_8,
                            Constants.ACC_PUBLIC,
                            getClassName(),
                            METHOD_DELEGATE,

File: cglib/src/main/java/net/sf/cglib/reflect/MulticastDelegate.java
Patch:
@@ -102,7 +102,7 @@ public void generateClass(ClassVisitor cv) {
             final MethodInfo method = ReflectUtils.getMethodInfo(ReflectUtils.findInterfaceMethod(iface));
 
             ClassEmitter ce = new ClassEmitter(cv);
-            ce.begin_class(Constants.V1_2,
+            ce.begin_class(Constants.V1_8,
                            Constants.ACC_PUBLIC,
                            getClassName(),
                            MULTICAST_DELEGATE,

File: cglib/src/main/java/net/sf/cglib/util/ParallelSorterEmitter.java
Patch:
@@ -33,7 +33,7 @@ class ParallelSorterEmitter extends ClassEmitter {
 
     public ParallelSorterEmitter(ClassVisitor v, String className, Object[] arrays) {
         super(v);
-        begin_class(Constants.V1_2, Constants.ACC_PUBLIC, className, PARALLEL_SORTER, null, Constants.SOURCE_FILE);
+        begin_class(Constants.V1_8, Constants.ACC_PUBLIC, className, PARALLEL_SORTER, null, Constants.SOURCE_FILE);
         EmitUtils.null_constructor(this);
         EmitUtils.factory_method(this, NEW_INSTANCE);
         generateConstructor(arrays);

File: cglib/src/main/java/net/sf/cglib/util/StringSwitcher.java
Patch:
@@ -118,7 +118,7 @@ public StringSwitcher create() {
 
         public void generateClass(ClassVisitor v) throws Exception {
             ClassEmitter ce = new ClassEmitter(v);
-            ce.begin_class(Constants.V1_2,
+            ce.begin_class(Constants.V1_8,
                            Constants.ACC_PUBLIC,
                            getClassName(),
                            STRING_SWITCHER,

File: cglib/src/main/java/net/sf/cglib/core/CodeEmitter.java
Patch:
@@ -849,10 +849,10 @@ public void invoke(MethodInfo method, Type virtualType) {
         Signature sig = method.getSignature();
         if (sig.getName().equals(Constants.CONSTRUCTOR_NAME)) {
             invoke_constructor(type, sig);
-        } else if (TypeUtils.isInterface(classInfo.getModifiers())) {
-            invoke_interface(type, sig);
         } else if (TypeUtils.isStatic(method.getModifiers())) {
             invoke_static(type, sig);
+        } else if (TypeUtils.isInterface(classInfo.getModifiers())) {
+            invoke_interface(type, sig);
         } else {
             invoke_virtual(virtualType, sig);
         }

File: cglib/src/main/java/net/sf/cglib/beans/BulkBeanEmitter.java
Patch:
@@ -56,7 +56,7 @@ public BulkBeanEmitter(ClassVisitor v,
 
     private void generateGet(final Class target, final Method[] getters) {
         CodeEmitter e = begin_method(Constants.ACC_PUBLIC, GET_PROPERTY_VALUES, null);
-        if (getters.length >= 0) {
+        if (getters.length > 0) {
             e.load_arg(0);
             e.checkcast(Type.getType(target));
             Local bean = e.make_local();

File: cglib/src/main/java/net/sf/cglib/beans/BulkBeanEmitter.java
Patch:
@@ -56,7 +56,7 @@ public BulkBeanEmitter(ClassVisitor v,
 
     private void generateGet(final Class target, final Method[] getters) {
         CodeEmitter e = begin_method(Constants.ACC_PUBLIC, GET_PROPERTY_VALUES, null);
-        if (getters.length >= 0) {
+        if (getters.length > 0) {
             e.load_arg(0);
             e.checkcast(Type.getType(target));
             Local bean = e.make_local();

File: cglib/src/main/java/net/sf/cglib/proxy/CallbackGenerator.java
Patch:
@@ -31,6 +31,6 @@ interface Context
         int getIndex(MethodInfo method);
         void emitCallback(CodeEmitter ce, int index);
         Signature getImplSignature(MethodInfo method);
-        void emitInvoke(CodeEmitter e, MethodInfo method);
+        void emitLoadArgsAndInvoke(CodeEmitter e, MethodInfo method);
     }
 }

File: cglib/src/main/java/net/sf/cglib/proxy/MethodInterceptorGenerator.java
Patch:
@@ -139,8 +139,7 @@ private static void superHelper(CodeEmitter e, MethodInfo method, Context contex
             e.throw_exception(ABSTRACT_METHOD_ERROR, method.toString() + " is abstract" );
         } else {
             e.load_this();
-            e.load_args();
-            context.emitInvoke(e, method);
+            context.emitLoadArgsAndInvoke(e, method);
         }
     }
 

File: cglib/src/main/java/net/sf/cglib/proxy/NoOpGenerator.java
Patch:
@@ -32,8 +32,7 @@ public void generate(ClassEmitter ce, Context context, List methods) {
                     TypeUtils.isPublic(method.getModifiers()))) {
                 CodeEmitter e = EmitUtils.begin_method(ce, method);
                 e.load_this();
-                e.load_args();
-                context.emitInvoke(e, method);
+                context.emitLoadArgsAndInvoke(e, method);
                 e.return_value();
                 e.end_method();
             }

File: cglib/src/main/java/net/sf/cglib/beans/BeanMap.java
Patch:
@@ -221,7 +221,7 @@ public boolean containsKey(Object key) {
     public boolean containsValue(Object value) {
         for (Iterator it = keySet().iterator(); it.hasNext();) {
             Object v = get(it.next());
-            if (((value == null) && (v == null)) || value.equals(v))
+            if (((value == null) && (v == null)) || (value != null && value.equals(v)))
                 return true;
         }
         return false;

File: cglib/src/main/java/net/sf/cglib/reflect/MethodDelegate.java
Patch:
@@ -134,7 +134,7 @@ public static MethodDelegate create(Object target, String methodName, Class ifac
 
     public boolean equals(Object obj) {
         MethodDelegate other = (MethodDelegate)obj;
-        return target == other.target && eqMethod.equals(other.eqMethod);
+        return (other != null && target == other.target) && eqMethod.equals(other.eqMethod);
     }
 
     public int hashCode() {

File: cglib/src/main/java/net/sf/cglib/core/AbstractClassGenerator.java
Patch:
@@ -305,7 +305,7 @@ protected Class generate(ClassLoaderData data) {
                         getClassName() + ". It seems that the loader has been expired from a weak reference somehow. " +
                         "Please file an issue at cglib's issue tracker.");
             }
-            synchronized(data) {
+            synchronized (classLoader) {
               String name = generateClassName(data.getUniqueNamePredicate());              
               data.reserveName(name);
               this.setClassName(name);

File: cglib/src/main/java/net/sf/cglib/core/Constants.java
Patch:
@@ -53,7 +53,8 @@ public interface Constants extends org.objectweb.asm.Opcodes {
     public static final Type TYPE_ERROR = TypeUtils.parseType("Error");
     public static final Type TYPE_SYSTEM = TypeUtils.parseType("System");
     public static final Type TYPE_SIGNATURE = TypeUtils.parseType("net.sf.cglib.core.Signature");
-    
+    public static final Type TYPE_TYPE = Type.getType(Type.class);
+
     public static final String CONSTRUCTOR_NAME = "<init>";
     public static final String STATIC_NAME = "<clinit>";
     public static final String SOURCE_FILE = "<generated>";

File: cglib/src/main/java/net/sf/cglib/proxy/Enhancer.java
Patch:
@@ -66,7 +66,7 @@ public int accept(Method method) {
 
     private static final Source SOURCE = new Source(Enhancer.class.getName());
     private static final EnhancerKey KEY_FACTORY =
-      (EnhancerKey)KeyFactory.create(EnhancerKey.class);
+      (EnhancerKey)KeyFactory.create(EnhancerKey.class, KeyFactory.HASH_ASM_TYPE, null);
 
     private static final String BOUND_FIELD = "CGLIB$BOUND";
     private static final String THREAD_CALLBACKS_FIELD = "CGLIB$THREAD_CALLBACKS";

File: cglib/src/main/java/net/sf/cglib/core/Constants.java
Patch:
@@ -53,7 +53,8 @@ public interface Constants extends org.objectweb.asm.Opcodes {
     public static final Type TYPE_ERROR = TypeUtils.parseType("Error");
     public static final Type TYPE_SYSTEM = TypeUtils.parseType("System");
     public static final Type TYPE_SIGNATURE = TypeUtils.parseType("net.sf.cglib.core.Signature");
-    
+    public static final Type TYPE_TYPE = Type.getType(Type.class);
+
     public static final String CONSTRUCTOR_NAME = "<init>";
     public static final String STATIC_NAME = "<clinit>";
     public static final String SOURCE_FILE = "<generated>";

File: cglib/src/main/java/net/sf/cglib/core/ClassEmitter.java
Patch:
@@ -44,7 +44,7 @@ public ClassEmitter(ClassVisitor cv) {
     }
 
     public ClassEmitter() {
-        super(Opcodes.ASM4);
+        super(Opcodes.ASM5);
     }
 
     public void setTarget(ClassVisitor cv) {
@@ -148,7 +148,7 @@ public CodeEmitter begin_method(int access, Signature sig, Type[] exceptions) {
                                          TypeUtils.toInternalNames(exceptions));
         if (sig.equals(Constants.SIG_STATIC) && !TypeUtils.isInterface(getAccess())) {
             rawStaticInit = v;
-            MethodVisitor wrapped = new MethodVisitor(Opcodes.ASM4, v) {
+            MethodVisitor wrapped = new MethodVisitor(Opcodes.ASM5, v) {
                 public void visitMaxs(int maxStack, int maxLocals) {
                     // ignore
                 }

File: cglib/src/main/java/net/sf/cglib/core/ClassNameReader.java
Patch:
@@ -38,7 +38,7 @@ public static String getClassName(ClassReader r) {
     public static String[] getClassInfo(ClassReader r) {
         final List array = new ArrayList();
         try {
-            r.accept(new ClassVisitor(Opcodes.ASM4, null) {
+            r.accept(new ClassVisitor(Opcodes.ASM5, null) {
                 public void visit(int version,
                                   int access,
                                   String name,

File: cglib/src/main/java/net/sf/cglib/core/CodeEmitter.java
Patch:
@@ -500,7 +500,8 @@ private void emit_invoke(int opcode, Type type, Signature sig) {
         mv.visitMethodInsn(opcode,
                            type.getInternalName(),
                            sig.getName(),
-                           sig.getDescriptor());
+                           sig.getDescriptor(),
+                           opcode == Opcodes.INVOKEINTERFACE);
     }
     
     public void invoke_interface(Type owner, Signature sig) {

File: cglib/src/main/java/net/sf/cglib/core/DebuggingClassWriter.java
Patch:
@@ -46,7 +46,7 @@ public class DebuggingClassWriter extends ClassVisitor {
     }
     
     public DebuggingClassWriter(int flags) {
-	super(Opcodes.ASM4, new ClassWriter(flags));
+	super(Opcodes.ASM5, new ClassWriter(flags));
     }
 
     public void visit(int version,

File: cglib/src/main/java/net/sf/cglib/core/DefaultGeneratorStrategy.java
Patch:
@@ -27,7 +27,7 @@ public byte[] generate(ClassGenerator cg) throws Exception {
     }
 
     protected DebuggingClassWriter getClassVisitor() throws Exception {
-      return new DebuggingClassWriter(ClassWriter.COMPUTE_MAXS);
+      return new DebuggingClassWriter(ClassWriter.COMPUTE_FRAMES);
     }
 
     protected final ClassWriter getClassWriter() {

File: cglib/src/main/java/net/sf/cglib/core/LocalVariablesSorter.java
Patch:
@@ -63,7 +63,7 @@ public LocalVariablesSorter(
         final String desc,
         final MethodVisitor mv)
     {
-        super(Opcodes.ASM4, mv);
+        super(Opcodes.ASM5, mv);
         state = new State();
         Type[] args = Type.getArgumentTypes(desc);
         state.nextLocal = ((Opcodes.ACC_STATIC & access) != 0) ? 0 : 1;
@@ -74,7 +74,7 @@ public LocalVariablesSorter(
     }
 
     public LocalVariablesSorter(LocalVariablesSorter lvs) {
-        super(Opcodes.ASM4, lvs.mv);
+        super(Opcodes.ASM5, lvs.mv);
         state = lvs.state;
         firstLocal = lvs.firstLocal;
     }

File: cglib/src/main/java/net/sf/cglib/proxy/BridgeMethodResolver.java
Patch:
@@ -73,7 +73,7 @@ private static class BridgedFinder extends ClassVisitor {
         private Signature currentMethod = null;
 
         BridgedFinder(Set eligableMethods, Map resolved) {
-            super(Opcodes.ASM4);
+            super(Opcodes.ASM5);
             this.resolved = resolved;
             this.eligableMethods = eligableMethods;
         }
@@ -87,9 +87,9 @@ public MethodVisitor visitMethod(int access, String name, String desc,
             Signature sig = new Signature(name, desc);
             if (eligableMethods.remove(sig)) {
                 currentMethod = sig;
-                return new MethodVisitor(Opcodes.ASM4) {
+                return new MethodVisitor(Opcodes.ASM5) {
                     public void visitMethodInsn(int opcode, String owner, String name,
-                                                String desc) {
+                                                String desc, boolean itf) {
                         if (opcode == Opcodes.INVOKESPECIAL && currentMethod != null) {
                             Signature target = new Signature(name, desc);
                             // If the target signature is the same as the current,

File: cglib/src/main/java/net/sf/cglib/transform/AbstractClassLoader.java
Patch:
@@ -86,7 +86,7 @@ public Class loadClass(String name) throws ClassNotFoundException {
 
         try {
             DebuggingClassWriter w = 
-        	    new DebuggingClassWriter(ClassWriter.COMPUTE_MAXS);
+        	    new DebuggingClassWriter(ClassWriter.COMPUTE_FRAMES);
             getGenerator(r).generateClass(w);
             byte[] b = w.toByteArray();
             Class c = super.defineClass(name, b, 0, b.length, DOMAIN);

File: cglib/src/main/java/net/sf/cglib/transform/AbstractClassTransformer.java
Patch:
@@ -20,7 +20,7 @@
 
 abstract public class AbstractClassTransformer extends ClassTransformer {
     protected AbstractClassTransformer() {
-        super(Opcodes.ASM4);
+        super(Opcodes.ASM5);
     }
 
     public void setTarget(ClassVisitor target) {

File: cglib/src/main/java/net/sf/cglib/transform/AbstractTransformTask.java
Patch:
@@ -84,7 +84,7 @@ private void processClassFile(File file) throws Exception,
         ClassReader reader = getClassReader(file);
         String name[] = ClassNameReader.getClassInfo(reader);
         DebuggingClassWriter w =
-        	new DebuggingClassWriter(ClassWriter.COMPUTE_MAXS);
+        	new DebuggingClassWriter(ClassWriter.COMPUTE_FRAMES);
         ClassTransformer t = getClassTransformer(name);
         if (t != null) {
 
@@ -223,7 +223,7 @@ private byte[] process(byte[] bytes) throws Exception {
         ClassReader reader = new ClassReader(new ByteArrayInputStream(bytes));
         String name[] = ClassNameReader.getClassInfo(reader);
         DebuggingClassWriter w =
-        	new DebuggingClassWriter(ClassWriter.COMPUTE_MAXS);
+        	new DebuggingClassWriter(ClassWriter.COMPUTE_FRAMES);
         ClassTransformer t = getClassTransformer(name);
         if (t != null) {
             if (verbose) {
@@ -269,4 +269,4 @@ protected boolean isJarFile(File file) throws IOException {
         return checkMagic(file, ZIP_MAGIC);
     }
 
-}
\ No newline at end of file
+}

File: cglib/src/main/java/net/sf/cglib/transform/AnnotationVisitorTee.java
Patch:
@@ -30,7 +30,7 @@ public static AnnotationVisitor getInstance(AnnotationVisitor av1, AnnotationVis
     }
 
     public AnnotationVisitorTee(AnnotationVisitor av1, AnnotationVisitor av2) {
-	super(Opcodes.ASM4);
+	super(Opcodes.ASM5);
         this.av1 = av1;
         this.av2 = av2;
     }

File: cglib/src/main/java/net/sf/cglib/transform/ClassTransformer.java
Patch:
@@ -20,7 +20,7 @@
 
 public abstract class ClassTransformer extends ClassVisitor {
     public ClassTransformer() {
-	super(Opcodes.ASM4);
+	super(Opcodes.ASM5);
     }
     public ClassTransformer(int opcode) {
 	super(opcode);

File: cglib/src/main/java/net/sf/cglib/transform/ClassTransformerTee.java
Patch:
@@ -22,7 +22,7 @@ public class ClassTransformerTee extends ClassTransformer {
     private ClassVisitor branch;
     
     public ClassTransformerTee(ClassVisitor branch) {
-        super(Opcodes.ASM4);
+        super(Opcodes.ASM5);
         this.branch = branch;
     }
     

File: cglib/src/main/java/net/sf/cglib/transform/impl/AddDelegateTransformer.java
Patch:
@@ -75,8 +75,8 @@ public CodeEmitter begin_method(int access, Signature sig, Type[] exceptions) {
         if (sig.getName().equals(Constants.CONSTRUCTOR_NAME)) {
             return new CodeEmitter(e) {
                 private boolean transformInit = true;
-                public void visitMethodInsn(int opcode, String owner, String name, String desc) {
-                    super.visitMethodInsn(opcode, owner, name, desc);
+                public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {
+                    super.visitMethodInsn(opcode, owner, name, desc, itf);
                     if (transformInit && opcode == Constants.INVOKESPECIAL) {
                         load_this();
                         new_instance(delegateType);

File: cglib/src/main/java/net/sf/cglib/proxy/BridgeMethodResolver.java
Patch:
@@ -89,7 +89,7 @@ public MethodVisitor visitMethod(int access, String name, String desc,
                 currentMethod = sig;
                 return new MethodVisitor(Opcodes.ASM5) {
                     public void visitMethodInsn(int opcode, String owner, String name,
-                                                String desc) {
+                                                String desc, boolean itf) {
                         if (opcode == Opcodes.INVOKESPECIAL && currentMethod != null) {
                             Signature target = new Signature(name, desc);
                             // If the target signature is the same as the current,

File: cglib/src/main/java/net/sf/cglib/transform/MethodVisitorTee.java
Patch:
@@ -84,9 +84,9 @@ public void visitFieldInsn(int opcode, String owner, String name, String desc) {
         mv2.visitFieldInsn(opcode, owner, name, desc);
     }
     
-    public void visitMethodInsn(int opcode, String owner, String name, String desc) {
-        mv1.visitMethodInsn(opcode, owner, name, desc);
-        mv2.visitMethodInsn(opcode, owner, name, desc);
+    public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {
+        mv1.visitMethodInsn(opcode, owner, name, desc, itf);
+        mv2.visitMethodInsn(opcode, owner, name, desc, itf);
     }
     
     public void visitJumpInsn(int opcode, Label label) {

File: cglib/src/main/java/net/sf/cglib/transform/impl/AddDelegateTransformer.java
Patch:
@@ -75,8 +75,8 @@ public CodeEmitter begin_method(int access, Signature sig, Type[] exceptions) {
         if (sig.getName().equals(Constants.CONSTRUCTOR_NAME)) {
             return new CodeEmitter(e) {
                 private boolean transformInit = true;
-                public void visitMethodInsn(int opcode, String owner, String name, String desc) {
-                    super.visitMethodInsn(opcode, owner, name, desc);
+                public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {
+                    super.visitMethodInsn(opcode, owner, name, desc, itf);
                     if (transformInit && opcode == Constants.INVOKESPECIAL) {
                         load_this();
                         new_instance(delegateType);

File: cglib/src/main/java/net/sf/cglib/beans/BeanCopier.java
Patch:
@@ -109,7 +109,7 @@ public void generateClass(ClassVisitor v) {
             EmitUtils.null_constructor(ce);
             CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, COPY, null);
             PropertyDescriptor[] getters = ReflectUtils.getBeanGetters(source);
-            PropertyDescriptor[] setters = ReflectUtils.getBeanGetters(target);
+            PropertyDescriptor[] setters = ReflectUtils.getBeanSetters(target);
 
             Map names = new HashMap();
             for (int i = 0; i < getters.length; i++) {

File: cglib/src/main/java/net/sf/cglib/beans/BeanCopier.java
Patch:
@@ -109,7 +109,7 @@ public void generateClass(ClassVisitor v) {
             EmitUtils.null_constructor(ce);
             CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, COPY, null);
             PropertyDescriptor[] getters = ReflectUtils.getBeanGetters(source);
-            PropertyDescriptor[] setters = ReflectUtils.getBeanGetters(target);
+            PropertyDescriptor[] setters = ReflectUtils.getBeanSetters(target);
 
             Map names = new HashMap();
             for (int i = 0; i < getters.length; i++) {

File: src/test/net/sf/cglib/beans/TestBeanMapProxy.java
Patch:
@@ -24,7 +24,7 @@
  */
 public class TestBeanMapProxy extends net.sf.cglib.CodeGenTestCase {
     public void testBeanMap() throws Exception {
-        HashMap identity = new HashMap();
+        HashMap identity = new HashMap() {}; // use anonymous class for correct class loader
         Person person = (Person)BeanMapProxy.newInstance(identity, new Class[]{ Person.class });
         person.setName("Chris");
         assertTrue("Chris".equals(person.getName()));

File: src/proxy/net/sf/cglib/transform/AbstractClassLoader.java
Patch:
@@ -86,7 +86,8 @@ public Class loadClass(String name) throws ClassNotFoundException {
         }
 
         try {
-            ClassWriter w =  new DebuggingClassWriter(ClassWriter.COMPUTE_MAXS);
+            DebuggingClassWriter w = 
+        	    new DebuggingClassWriter(ClassWriter.COMPUTE_MAXS);
             getGenerator(r).generateClass(w);
             byte[] b = w.toByteArray();
             Class c = super.defineClass(name, b, 0, b.length, DOMAIN);

File: src/proxy/net/sf/cglib/transform/AnnotationVisitorTee.java
Patch:
@@ -16,8 +16,9 @@
 package net.sf.cglib.transform;
 
 import org.objectweb.asm.AnnotationVisitor;
+import org.objectweb.asm.Opcodes;
 
-public class AnnotationVisitorTee implements AnnotationVisitor {
+public class AnnotationVisitorTee extends AnnotationVisitor {
     private AnnotationVisitor av1, av2;
 
     public static AnnotationVisitor getInstance(AnnotationVisitor av1, AnnotationVisitor av2) {
@@ -29,6 +30,7 @@ public static AnnotationVisitor getInstance(AnnotationVisitor av1, AnnotationVis
     }
 
     public AnnotationVisitorTee(AnnotationVisitor av1, AnnotationVisitor av2) {
+	super(Opcodes.ASM4);
         this.av1 = av1;
         this.av2 = av2;
     }

File: src/proxy/net/sf/cglib/transform/ClassEmitterTransformer.java
Patch:
@@ -17,5 +17,5 @@
 
 import net.sf.cglib.core.ClassEmitter;
 
-abstract public class ClassEmitterTransformer extends ClassEmitter implements ClassTransformer {
+abstract public class ClassEmitterTransformer extends ClassEmitter {
 }

File: src/proxy/net/sf/cglib/transform/ClassTransformerTee.java
Patch:
@@ -15,14 +15,14 @@
  */
 package net.sf.cglib.transform;
 
-import org.objectweb.asm.ClassAdapter;
 import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.Opcodes;
 
-public class ClassTransformerTee extends ClassAdapter implements ClassTransformer {
+public class ClassTransformerTee extends ClassTransformer {
     private ClassVisitor branch;
     
     public ClassTransformerTee(ClassVisitor branch) {
-        super(null);
+        super(Opcodes.ASM4);
         this.branch = branch;
     }
     

File: src/proxy/net/sf/cglib/transform/ClassVisitorTee.java
Patch:
@@ -17,11 +17,12 @@
 
 import org.objectweb.asm.*;
 
-public class ClassVisitorTee implements ClassVisitor {
+public class ClassVisitorTee extends ClassVisitor {
     private ClassVisitor cv1, cv2;
     
     public ClassVisitorTee(ClassVisitor cv1, ClassVisitor cv2) {
-        this.cv1 = cv1;
+	super(Opcodes.ASM4);
+	this.cv1 = cv1;
         this.cv2 = cv2;
     }
 

File: src/proxy/net/sf/cglib/transform/MethodVisitorTee.java
Patch:
@@ -17,12 +17,13 @@
 
 import org.objectweb.asm.*;
 
-public class MethodVisitorTee implements MethodVisitor {
+public class MethodVisitorTee extends MethodVisitor {
     private final MethodVisitor mv1;
     private final MethodVisitor mv2;
     
     public MethodVisitorTee(MethodVisitor mv1, MethodVisitor mv2) {
-        this.mv1 = mv1;
+	super(Opcodes.ASM4);
+	this.mv1 = mv1;
         this.mv2 = mv2;
     }
 

File: src/proxy/net/sf/cglib/proxy/CallbackGenerator.java
Patch:
@@ -31,5 +31,6 @@ interface Context
         int getIndex(MethodInfo method);
         void emitCallback(CodeEmitter ce, int index);
         Signature getImplSignature(MethodInfo method);
+        void emitInvoke(CodeEmitter e, MethodInfo method);
     }
 }

File: src/proxy/net/sf/cglib/transform/AbstractTransformTask.java
Patch:
@@ -137,7 +137,7 @@ protected void processJarFile(File file) throws Exception {
             
             ZipInputStream zip = new ZipInputStream(new FileInputStream(file));
             try {
-                FileOutputStream fout = new FileOutputStream(tempFile, false);
+                FileOutputStream fout = new FileOutputStream(tempFile);
                 try{
                  ZipOutputStream out = new ZipOutputStream(fout);
                                 

File: src/proxy/net/sf/cglib/proxy/MixinEmitter.java
Patch:
@@ -23,16 +23,16 @@
 
 /**
  * @author Chris Nokleberg
- * @version $Id: MixinEmitter.java,v 1.8 2006/03/05 02:43:19 herbyderby Exp $
+ * @version $Id: MixinEmitter.java,v 1.9 2006/08/27 21:04:37 herbyderby Exp $
  */
 class MixinEmitter extends ClassEmitter {
     private static final String FIELD_NAME = "CGLIB$DELEGATES";
     private static final Signature CSTRUCT_OBJECT_ARRAY =
       TypeUtils.parseConstructor("Object[]");
-    private static final Signature NEW_INSTANCE =
-      TypeUtils.parseSignature("net.sf.cglib.proxy.Mixin newInstance(Object[])"); // JARJAR
     private static final Type MIXIN =
       TypeUtils.parseType("net.sf.cglib.proxy.Mixin");
+    private static final Signature NEW_INSTANCE =
+      new Signature("newInstance", MIXIN, new Type[]{ Constants.TYPE_OBJECT_ARRAY });
 
     public MixinEmitter(ClassVisitor v, String className, Class[] classes, int[] route) {
         super(v);

File: src/proxy/net/sf/cglib/proxy/Enhancer.java
Patch:
@@ -87,7 +87,7 @@ public int accept(Method method) {
     private static final Type CALLBACK =
       TypeUtils.parseType("net.sf.cglib.proxy.Callback");
     private static final Type CALLBACK_ARRAY =
-      Type.getType("[Lnet/sf/cglib/proxy/Callback;");
+      TypeUtils.parseType("net.sf.cglib.proxy.Callback[]");
     private static final Signature CSTRUCT_NULL =
       TypeUtils.parseConstructor("");
     private static final Signature SET_THREAD_CALLBACKS =

File: src/proxy/net/sf/cglib/proxy/Enhancer.java
Patch:
@@ -861,6 +861,8 @@ public void processDefault() {
                 e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, "Constructor not found");
             }
         });
+        e.aconst_null();
+        e.invoke_static_this(SET_THREAD_CALLBACKS);
         e.return_value();
         e.end_method();
     }

File: src/proxy/net/sf/cglib/proxy/Enhancer.java
Patch:
@@ -809,6 +809,8 @@ private void emitCommonNewInstance(CodeEmitter e) {
         e.new_instance_this();
         e.dup();
         e.invoke_constructor_this();
+        e.aconst_null();
+        e.invoke_static_this(SET_THREAD_CALLBACKS);
         e.return_value();
         e.end_method();
     }

File: src/proxy/net/sf/cglib/core/ClassNameReader.java
Patch:
@@ -44,7 +44,9 @@ public void visit(int version,
                                   String[] interfaces,
                                   String sourceFile) {
                     array.add( name.replace('/', '.') );
-                    array.add( superName.replace('/', '.') );
+                    if(superName != null){
+                      array.add( superName.replace('/', '.') );
+                    }
                     for(int i = 0; i < interfaces.length; i++  ){
                        array.add( interfaces[i].replace('/', '.') );
                     }

File: src/proxy/net/sf/cglib/beans/BeanCopier.java
Patch:
@@ -39,7 +39,7 @@ abstract public class BeanCopier
       TypeUtils.parseSignature("Object convert(Object, Class, Object)");
     
     interface BeanCopierKey {
-        public Object newInstance(Class source, Class target, boolean useConverter);
+        public Object newInstance(String source, String target, boolean useConverter);
     }
 
     public static BeanCopier create(Class source, Class target, boolean useConverter) {
@@ -86,7 +86,7 @@ protected ClassLoader getDefaultClassLoader() {
         }
 
         public BeanCopier create() {
-            Object key = KEY_FACTORY.newInstance(source, target, useConverter);
+            Object key = KEY_FACTORY.newInstance(source.getName(), target.getName(), useConverter);
             return (BeanCopier)super.create(key);
         }
 

File: src/proxy/net/sf/cglib/reflect/ConstructorDelegate.java
Patch:
@@ -22,14 +22,14 @@
 
 /**
  * @author Chris Nokleberg
- * @version $Id: ConstructorDelegate.java,v 1.18 2004/09/18 21:22:22 herbyderby Exp $
+ * @version $Id: ConstructorDelegate.java,v 1.19 2005/09/27 11:42:27 baliuka Exp $
  */
 abstract public class ConstructorDelegate {
     private static final ConstructorKey KEY_FACTORY =
       (ConstructorKey)KeyFactory.create(ConstructorKey.class, KeyFactory.CLASS_BY_NAME);
     
     interface ConstructorKey {
-        public Object newInstance(Class declaring, Class iface);
+        public Object newInstance(String declaring, String iface);
     }
 
     protected ConstructorDelegate() {
@@ -64,7 +64,7 @@ public void setTargetClass(Class targetClass) {
 
         public ConstructorDelegate create() {
             setNamePrefix(targetClass.getName());
-            Object key = KEY_FACTORY.newInstance(iface, targetClass);
+            Object key = KEY_FACTORY.newInstance(iface.getName(), targetClass.getName());
             return (ConstructorDelegate)super.create(key);
         }
 

File: src/proxy/net/sf/cglib/beans/BeanGenerator.java
Patch:
@@ -84,7 +84,8 @@ private Object createHelper() {
         if (superclass != null) {
             setNamePrefix(superclass.getName());
         }
-        Object key = KEY_FACTORY.newInstance(superclass.getName(), props);
+        String superName = (superclass != null) ? superclass.getName() : "java.lang.Object";
+        Object key = KEY_FACTORY.newInstance(superName, props);
         return super.create(key);
     }
 

File: src/test/net/sf/cglib/transform/impl/MA.java
Patch:
@@ -2,7 +2,7 @@
 
 import java.io.ObjectStreamException;
 
-public class MA {
+public class MA extends Base{
     private Long id;
     private String name;
     private String privateName;

File: src/proxy/net/sf/cglib/beans/BeanGenerator.java
Patch:
@@ -31,7 +31,7 @@ public class BeanGenerator extends AbstractClassGenerator
       (BeanGeneratorKey)KeyFactory.create(BeanGeneratorKey.class);
     
     interface BeanGeneratorKey {
-        public Object newInstance(Class superclass, Map props);
+        public Object newInstance(String superclass, Map props);
     }
 
     private Class superclass;
@@ -84,7 +84,7 @@ private Object createHelper() {
         if (superclass != null) {
             setNamePrefix(superclass.getName());
         }
-        Object key = KEY_FACTORY.newInstance(superclass, props);
+        Object key = KEY_FACTORY.newInstance(superclass.getName(), props);
         return super.create(key);
     }
 

File: src/proxy/net/sf/cglib/core/AbstractClassGenerator.java
Patch:
@@ -43,7 +43,7 @@ abstract public class AbstractClassGenerator
     private Object key;
     private boolean useCache = true;
     private String className;
-    protected boolean attemptLoad;
+    private boolean attemptLoad;
 
     protected static class Source {
         String name;

File: src/proxy/net/sf/cglib/core/EmitUtils.java
Patch:
@@ -794,7 +794,7 @@ public Object transform(Object value) {
                     index = i;
                 }
             }
-            if (buckets == null) {
+            if (buckets == null || buckets.size() == 1) {
                 // TODO: switch by returnType
                 // must have two methods with same name, types, and different return types
                 e.goTo(def);

File: src/proxy/net/sf/cglib/core/EmitUtils.java
Patch:
@@ -308,6 +308,8 @@ public void processCase(int key, Label ignore_end) throws Exception {
                 List bucket = (List)buckets.get(new Integer(key));
                 Label next = null;
                 if (skipEquals && bucket.size() == 1) {
+                    if (skipEquals)
+                        e.pop();
                     callback.processCase((String)bucket.get(0), end);
                 } else {
                     for (Iterator it = bucket.iterator(); it.hasNext();) {

File: src/proxy/net/sf/cglib/proxy/Enhancer.java
Patch:
@@ -370,7 +370,7 @@ private void validate(boolean transforming) {
             }
             Type[] check = CallbackInfo.determineTypes(callbacks);
             for (int i = 0; i < check.length; i++) {
-                if (check[i] != callbackTypes[i]) {
+                if (!check[i].equals(callbackTypes[i])) {
                     throw new IllegalStateException("Callback " + check[i] + " is not assignable to " + callbackTypes[i]);
                 }
             }

File: src/test/net/sf/cglib/TestAll.java
Patch:
@@ -65,7 +65,7 @@
 /**
  *@author     Gerhard Froehlich <a href="mailto:g-froehlich@gmx.de">
  *      g-froehlich@gmx.de</a>
- *@version    $Id: TestAll.java,v 1.60 2004/04/07 07:00:57 herbyderby Exp $
+ *@version    $Id: TestAll.java,v 1.61 2004/04/07 23:22:11 herbyderby Exp $
  */
 public class TestAll extends TestCase {
     
@@ -86,6 +86,7 @@ public static Test suite() throws Exception{
         //security
         
         // proxy
+        /*
         suite.addTest(TestEnhancer.suite());
         suite.addTest(TestProxy.suite());
         suite.addTest(TestDispatcher.suite());
@@ -119,6 +120,7 @@ public static Test suite() throws Exception{
         suite.addTest(TestAddDelegate.suite());
         suite.addTest(TestInterceptFields.suite());
         suite.addTest(TestDemo.suite());
+        */
         suite.addTest(TestEnhancerTransform.suite());
 
         // performance

File: src/proxy/net/sf/cglib/core/EmitUtils.java
Patch:
@@ -806,7 +806,7 @@ private static void member_helper_type(final CodeEmitter e,
                     e.dup();
                     e.aaload(i);
                     e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);
-                    e.push(types[i].getClassName());
+                    e.push(TypeUtils.emulateClassGetName(types[i]));
                     e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);
                     e.if_jump(e.EQ, def);
                 }
@@ -822,7 +822,7 @@ private static void member_helper_type(final CodeEmitter e,
                 final int j = i;
                 Map test = CollectionUtils.bucket(members, new Transformer() {
                     public Object transform(Object value) {
-                        return typer.getParameterTypes((MethodInfo)value)[j].getClassName();
+                        return TypeUtils.emulateClassGetName(typer.getParameterTypes((MethodInfo)value)[j]);
                     }
                 });
                 if (buckets == null || test.size() > buckets.size()) {

File: src/proxy/net/sf/cglib/core/TypeUtils.java
Patch:
@@ -287,10 +287,10 @@ public static boolean isPrimitive(Type type) {
     }
 
     public static String emulateClassGetName(Type type) {
-        if (isPrimitive(type) || isArray(type)) {
+        if (isArray(type)) {
             return type.getDescriptor().replace('/', '.');
         } else {
-            return type.getClassName();
+            return getClassName(type);
         }
     }
 

File: src/proxy/net/sf/cglib/proxy/Enhancer.java
Patch:
@@ -648,8 +648,6 @@ public void	visitMethodInsn(int opcode, String owner, String name, String desc)
         }
 
         public void end_class() {
-            // System.err.println("collected methods " + methods);
-            // System.err.println("collected constructors " + constructors);
             if (collect) {
                 collect = false;
                 Enhancer.this.emit(this,

File: src/proxy/net/sf/cglib/proxy/InvocationHandlerGenerator.java
Patch:
@@ -18,8 +18,6 @@ class InvocationHandlerGenerator
       TypeUtils.parseType("java.lang.reflect.Method");
     private static final Signature INVOKE =
       TypeUtils.parseSignature("Object invoke(Object, java.lang.reflect.Method, Object[])");
-    private static final Signature CSTRUCT_THROWABLE =
-      TypeUtils.parseConstructor("Throwable");
 
     private String getFieldName(Context context, Method method) {
         return "CGLIB$$METHOD_" + context.getUniqueName(method);

File: src/proxy/net/sf/cglib/beans/ImmutableBean.java
Patch:
@@ -131,7 +131,7 @@ public void generateClass(ClassVisitor v) {
 
             for (int i = 0; i < getters.length; i++) {
                 e = ce.begin_method(Constants.ACC_PUBLIC,
-                                    TypeUtils.getSignature(getters[i]),
+                                    ReflectUtils.getSignature(getters[i]),
                                     TypeUtils.getTypes(getters[i].getExceptionTypes()),
                                     null);
                 e.load_this();
@@ -143,7 +143,7 @@ public void generateClass(ClassVisitor v) {
 
             for (int i = 0; i < setters.length; i++) {
                 e = ce.begin_method(Constants.ACC_PUBLIC,
-                                    TypeUtils.getSignature(setters[i]),
+                                    ReflectUtils.getSignature(setters[i]),
                                     null,
                                     null);
                 e.throw_exception(ILLEGAL_STATE_EXCEPTION, "Bean is immutable");

File: src/proxy/net/sf/cglib/core/CodeEmitter.java
Patch:
@@ -865,7 +865,7 @@ public void visitMaxs(int maxStack, int maxLocals) {
     public void invoke(Method method) {
         Class declaring = method.getDeclaringClass();
         Type owner = Type.getType(declaring);
-        Signature sig = TypeUtils.getSignature(method);
+        Signature sig = ReflectUtils.getSignature(method);
         if (declaring.isInterface()) {
             invoke_interface(owner, sig);
         } else if (TypeUtils.isStatic(method.getModifiers())) {

File: src/test/net/sf/cglib/proxy/TestEnhancer.java
Patch:
@@ -62,7 +62,7 @@
 /**
  *@author     Juozas Baliuka <a href="mailto:baliuka@mwm.lt">
  *      baliuka@mwm.lt</a>
- *@version    $Id: TestEnhancer.java,v 1.38 2003/12/20 08:47:55 herbyderby Exp $
+ *@version    $Id: TestEnhancer.java,v 1.39 2004/01/18 13:29:41 baliuka Exp $
  */
 public class TestEnhancer extends CodeGenTestCase {
     private static final MethodInterceptor TEST_INTERCEPTOR = new TestInterceptor();
@@ -531,6 +531,7 @@ public void testMethodDeclarer() throws Exception {
         enhancer.setSuperclass(MethDecImpl.class);
         enhancer.setCallback(new MethodInterceptor() {
             public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
+                
                 result[0] = method.getDeclaringClass().getName().equals(MethDec.class.getName());
                 return null;
             }

File: src/proxy/net/sf/cglib/transform/AbstractClassTransformer.java
Patch:
@@ -9,7 +9,7 @@ protected AbstractClassTransformer() {
         super(null);
     }
 
-    public void setTarget(ClassVisitor target, ClassVisitor outer) {
+    public void setTarget(ClassVisitor target) {
         cv = target;
     }
 }

File: src/proxy/net/sf/cglib/transform/ClassTransformer.java
Patch:
@@ -3,5 +3,5 @@
 import org.objectweb.asm.ClassVisitor;
 
 public interface ClassTransformer extends ClassVisitor {
-    public void setTarget(ClassVisitor target, ClassVisitor outer);
+    public void setTarget(ClassVisitor target);
 }

File: src/proxy/net/sf/cglib/transform/ClassTransformerChain.java
Patch:
@@ -9,11 +9,11 @@ public ClassTransformerChain(ClassTransformer[] chain) {
         this.chain = (ClassTransformer[])chain.clone();
     }
 
-    public void setTarget(ClassVisitor v, ClassVisitor outer) {
-        super.setTarget(chain[0], outer);
+    public void setTarget(ClassVisitor v) {
+        super.setTarget(chain[0]);
         ClassVisitor next = v;
         for (int i = chain.length - 1; i >= 0; i--) {
-            chain[i].setTarget(next, outer);
+            chain[i].setTarget(next);
             next = chain[i];
         }
     }

File: src/proxy/net/sf/cglib/transform/ClassTransformerTee.java
Patch:
@@ -11,7 +11,7 @@ public ClassTransformerTee(ClassVisitor branch) {
         this.branch = branch;
     }
     
-    public void setTarget(ClassVisitor target, ClassVisitor outer) {
+    public void setTarget(ClassVisitor target) { 
         cv = new ClassVisitorTee(branch, target);
     }
 }

File: src/proxy/net/sf/cglib/transform/TransformingClassGenerator.java
Patch:
@@ -14,7 +14,7 @@ public TransformingClassGenerator(ClassGenerator gen, ClassTransformer t) {
     }
     
     public void generateClass(ClassVisitor v) throws Exception {
-        t.setTarget(v, t);
+        t.setTarget(v);
         gen.generateClass(t);
     }
 }

File: src/proxy/net/sf/cglib/proxy/EnhancerEmitter.java
Patch:
@@ -123,6 +123,9 @@ public EnhancerEmitter(ClassVisitor v,
                      TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :
                      TypeUtils.getTypes(interfaces)),
                     Constants.SOURCE_FILE);
+
+        if (Modifier.isFinal(superclass.getModifiers()))
+            throw new IllegalArgumentException("Cannot subclass final class " + superclass);
         
         List clist = new ArrayList(Arrays.asList(superclass.getDeclaredConstructors()));
         CollectionUtils.filter(clist, new VisibilityPredicate(superclass, true));

File: src/proxy/net/sf/cglib/proxy/Callback.java
Patch:
@@ -56,10 +56,11 @@
 /**
  * All callback interfaces used by {@link Enhancer} extend this interface.
  * @see MethodInterceptor
+ * @see NoOp
  * @see LazyLoader
  * @see Dispatcher
  * @see InvocationHandler
- * @see NoOp
+ * @see FixedValue
  */
 public interface Callback
 {

File: src/proxy/net/sf/cglib/proxy/CallbackUtils.java
Patch:
@@ -64,6 +64,7 @@ static Class determineType(Callback callback) {
         test = typeHelper(callback, test, InvocationHandler.class);
         test = typeHelper(callback, test, LazyLoader.class);
         test = typeHelper(callback, test, Dispatcher.class);
+        test = typeHelper(callback, test, FixedValue.class);
         if (test == null) {
             throw new IllegalStateException("Unknown callback " + callback.getClass());
         }
@@ -95,6 +96,8 @@ static CallbackGenerator getGenerator(Class type) {
             return LazyLoaderGenerator.INSTANCE;
         } else if (type.equals(Dispatcher.class)) {
             return DispatcherGenerator.INSTANCE;
+        } else if (type.equals(FixedValue.class)) {
+            return FixedValueGenerator.INSTANCE;
         } else {
             throw new IllegalStateException("Unknown callback " + type);
         }

File: src/proxy/net/sf/cglib/core/EmitUtils.java
Patch:
@@ -381,7 +381,7 @@ private static String getFieldName(String typeName) {
         if (arrayCount >= 0) {
             typeName = "ARRAY" + arrayCount + "$" + typeName;
         }
-        typeName = typeName.replace('[', '_');
+        typeName = typeName.replace('[', '_').replace(';','$');
         return "CGLIB$load_class$" + typeName;
     }
 

File: src/test/net/sf/cglib/proxy/TestInterceptor.java
Patch:
@@ -59,7 +59,7 @@
 
 /**
  *@author Juozas Baliuka <a href="mailto:baliuka@mwm.lt">baliuka@mwm.lt</a>
- *@version $Id: TestInterceptor.java,v 1.1 2003/10/29 03:45:38 herbyderby Exp $
+ *@version $Id: TestInterceptor.java,v 1.2 2003/12/11 17:50:04 baliuka Exp $
  */
 public class TestInterceptor implements MethodInterceptor, Serializable {
     String value;
@@ -76,6 +76,7 @@ public TestInterceptor() {
     }
 
     public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
+        System.out.println( method );
         Throwable e = null;                                                                            
         boolean invokedSuper = false;                                                                  
         Object retValFromSuper = null;

File: src/test/net/sf/cglib/beans/TestBeanMap.java
Patch:
@@ -104,6 +104,7 @@ public void setQuip(int value) {
     public void testBeanMap() {
         TestBean bean = new TestBean();
         BeanMap map = BeanMap.create(bean);
+        assertTrue(map.size() == 6);
         assertTrue(map.get("foo") == null);
         map.put("foo", "FOO");
         assertTrue("FOO".equals(map.get("foo")));

File: src/proxy/net/sf/cglib/proxy/Enhancer.java
Patch:
@@ -138,7 +138,7 @@ public Enhancer() {
     public void setSuperclass(Class superclass) {
         if (superclass != null && superclass.isInterface()) {
             setInterfaces(new Class[]{ superclass });
-        } else if (superclass.equals(Object.class)) {
+        } else if (superclass != null && superclass.equals(Object.class)) {
             // affects choice of ClassLoader
             this.superclass = null;
         } else {

File: src/test/net/sf/cglib/proxy/TestNoOp.java
Patch:
@@ -67,7 +67,7 @@ public String toString() {
     }
     
     public void testNoOp() {
-        Object obj = Enhancer.create(Foo.class, null);
+        Object obj = Enhancer.create(Foo.class, NoOp.INSTANCE);
         assertTrue("foo".equals(obj.toString()));
     }
 

File: src/proxy/net/sf/cglib/core/EmitUtils.java
Patch:
@@ -593,12 +593,12 @@ public static void append_string(final CodeEmitter e,
         final ArrayDelimiters d = (delims != null) ? delims : DEFAULT_DELIMITERS;
         ProcessArrayCallback callback =new ProcessArrayCallback() {
             public void processElement(Type type) {
-                append_string_helper(e, type, delims, customizer, this);
-                e.push(delims.inside);
+                append_string_helper(e, type, d, customizer, this);
+                e.push(d.inside);
                 e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);
             }
         };
-        append_string_helper(e, type, delims, customizer, callback);
+        append_string_helper(e, type, d, customizer, callback);
     }
 
     private static void append_string_helper(CodeEmitter e,

File: src/proxy/net/sf/cglib/proxy/MethodProxy.java
Patch:
@@ -64,11 +64,9 @@
  * registered {@link MethodInterceptor} objects when an intercepted method is invoked. It can
  * be used to either invoke the original method, or call the same method on a different
  * object of the same type.
- * @version $Id: MethodProxy.java,v 1.4 2003/11/08 20:08:05 herbyderby Exp $
+ * @version $Id: MethodProxy.java,v 1.5 2003/11/11 03:31:11 herbyderby Exp $
  */
 public class MethodProxy {
-    private static final Class[] METHOD_ARRAY = { Method.class };
-
     private FastClass f1;
     private FastClass f2;
     private int i1;

File: src/proxy/net/sf/cglib/proxy/MethodProxy.java
Patch:
@@ -64,7 +64,7 @@
  * registered {@link MethodInterceptor} objects when an intercepted method is invoked. It can
  * be used to either invoke the original method, or call the same method on a different
  * object of the same type.
- * @version $Id: MethodProxy.java,v 1.3 2003/11/08 19:18:44 herbyderby Exp $
+ * @version $Id: MethodProxy.java,v 1.4 2003/11/08 20:08:05 herbyderby Exp $
  */
 public class MethodProxy {
     private static final Class[] METHOD_ARRAY = { Method.class };
@@ -127,6 +127,7 @@ public static String getSuperName(Class type, Method method) {
         for (int i = 0; i < methods.length; i++) {
             String name = methods[i].getName();
             if (name.startsWith(MethodInterceptorGenerator.ACCESS_PREFIX) &&
+                name.substring(MethodInterceptorGenerator.ACCESS_PREFIX.length(), name.lastIndexOf('_')).equals(method.getName()) &&
                 Arrays.asList(methods[i].getParameterTypes()).equals(params)) {
                 return name;
             }

File: src/proxy/net/sf/cglib/transform/AbstractProcessTask.java
Patch:
@@ -32,7 +32,7 @@ private Collection getFiles() {
     }
 
     public void execute() throws BuildException {
-        init();
+        beforeExecute();
         for (Iterator it = getFiles().iterator(); it.hasNext();) {
             try {
                 processFile((File)it.next());
@@ -42,5 +42,6 @@ public void execute() throws BuildException {
         }
     }
 
+    protected void beforeExecute() throws BuildException { }
     abstract protected void processFile(File file) throws Exception;
 }

File: src/proxy/net/sf/cglib/transform/AbstractTransformTask.java
Patch:
@@ -25,7 +25,7 @@ public CaptureNameWriter(boolean computeMaxs) {
 
         public void visit(int access, String name, String superName, String[] interfaces, String sourceFile) {
             this.name = name.replace('/', '.');
-            if (!accept(name)) {
+            if (!accept(this.name)) {
                 throw new EarlyExitException();
             }
             super.visit(access, name, superName, interfaces, sourceFile);

File: src/test/net/sf/cglib/transform/ExampleTask.java
Patch:
@@ -13,7 +13,7 @@ protected ClassTransformer getClassTransformer() {
         return transformer;
     }
     
-    public void init() {
+    protected void beforeExecute() {
         ClassTransformer t1 = new AccessFieldTransformer(new AccessFieldTransformer.Callback() {
             public String getPropertyName(Type owner, String fieldName) {
                 return fieldName + fieldSuffix;

File: src/proxy/net/sf/cglib/beans/BeanMap.java
Patch:
@@ -113,8 +113,9 @@ protected Object nextInstance(Object instance) {
             return ((BeanMap)instance).newInstance(bean);
         }
     }
-    
+
     abstract protected BeanMap newInstance(Object bean);
+    abstract public Class getPropertyType(String name);
 
     protected Object bean;
 

File: src/proxy/net/sf/cglib/LazyLoaderGenerator.java
Patch:
@@ -67,7 +67,7 @@ class LazyLoaderGenerator implements CallbackGenerator {
     private static final Signature LOAD_PRIVATE =
       TypeUtils.parseSignature("Object CGLIB$LOAD_PRIVATE()");
     private static final Signature LOAD_OBJECT = 
-      TypeUtils.parseSignature("Object loadObject(String)");
+      TypeUtils.parseSignature("Object loadObject()");
     private static final Type LAZY_LOADER =
       TypeUtils.parseType("net.sf.cglib.LazyLoader");
 

File: src/proxy/net/sf/cglib/transform/AbstractFilterTransformer.java
Patch:
@@ -15,8 +15,8 @@ public Object clone() {
         return t;
     }
 
-    public void setTarget(ClassVisitor target) {
-        super.setTarget(target);
-        pass.setTarget(target);
+    public void setTarget(ClassVisitor target, ClassVisitor outer) {
+        super.setTarget(target, outer);
+        pass.setTarget(target, outer);
     }
 }

File: src/proxy/net/sf/cglib/transform/AbstractTransformer.java
Patch:
@@ -9,7 +9,7 @@ protected AbstractTransformer() {
         super(null);
     }
     
-    public void setTarget(ClassVisitor target) {
+    public void setTarget(ClassVisitor target, ClassVisitor outer) {
         cv = target;
     }
 

File: src/proxy/net/sf/cglib/transform/AddStaticInitTransformer.java
Patch:
@@ -23,12 +23,11 @@ public AddStaticInitTransformer(Method classInit) {
         this.classInit = classInit;
     }
 
-    public void end_class() {
+    protected void init() {
         if (!TypeUtils.isInterface(getAccess())) {
             CodeEmitter e = getStaticHook();
             ComplexOps.load_class_this(e);
             e.invoke(classInit);
         }
-        super.end_class();
     }
 }

File: src/proxy/net/sf/cglib/transform/ClassTransformer.java
Patch:
@@ -3,6 +3,6 @@
 import org.objectweb.asm.ClassVisitor;
 
 public interface ClassTransformer extends ClassVisitor, Cloneable {
-    public void setTarget(ClassVisitor target);
+    public void setTarget(ClassVisitor target, ClassVisitor outer);
     public Object clone();
 }

File: src/proxy/net/sf/cglib/transform/TransformingGenerator.java
Patch:
@@ -14,7 +14,7 @@ public TransformingGenerator(ClassGenerator gen, ClassTransformer t) {
     }
     
     public void generateClass(ClassVisitor v) throws Exception {
-        t.setTarget(v);
+        t.setTarget(v, t);
         gen.generateClass(t);
     }
 

File: src/proxy/net/sf/cglib/core/TypeUtils.java
Patch:
@@ -127,7 +127,6 @@ public static Signature parseSignature(String s) {
         String returnType = s.substring(0, space);
         String methodName = s.substring(space + 1, lparen);
         StringBuffer sb = new StringBuffer();
-        int mark = lparen + 1;
         sb.append('(');
         for (Iterator it = parseTypes(s, lparen + 1, rparen).iterator(); it.hasNext();) {
             sb.append(it.next());

File: src/proxy/net/sf/cglib/transform/AddStaticInitTransformer.java
Patch:
@@ -12,9 +12,6 @@
  * @author Juozas Baliuka, Chris Nokleberg
  */
 public class AddStaticInitTransformer extends EmittingTransformer {
-    private static final Signature FOR_NAME =
-      TypeUtils.parseSignature("Class forName(String)");
-
     private Method classInit;
     private boolean generated;
 

File: src/proxy/net/sf/cglib/transform/MethodFilterTransformer.java
Patch:
@@ -4,7 +4,6 @@
 
 public class MethodFilterTransformer extends AbstractFilterTransformer {
     private MethodFilter filter;
-    private boolean accepted;
     
     public MethodFilterTransformer(MethodFilter filter, ClassTransformer pass) {
         super(pass);

File: src/proxy/net/sf/cglib/EnhancerEmitter.java
Patch:
@@ -294,7 +294,7 @@ private void emitNewInstanceMultiarg(Constructor[] constructors) {
         e.new_instance_this();
         e.dup();
         e.load_arg(0);
-        ReflectOps.constructor_switch(e, constructors, new ObjectSwitchCallback() {
+        ComplexOps.constructor_switch(e, constructors, new ObjectSwitchCallback() {
             public void processCase(Object key, Label end) {
                 Constructor constructor = (Constructor)key;
                 Type types[] = TypeUtils.getTypes(constructor.getParameterTypes());

File: src/proxy/net/sf/cglib/reflect/FastClassEmitter.java
Patch:
@@ -103,13 +103,13 @@ public FastClassEmitter(ClassVisitor v, String className, Class type) {
         // getIndex(String, Class[])
         e = begin_method(Constants.ACC_PUBLIC, METHOD_GET_INDEX, null);
         e.load_args();
-        ReflectOps.method_switch(e, methods, new GetIndexCallback(e, methods));
+        ComplexOps.method_switch(e, methods, new GetIndexCallback(e, methods));
         e.end_method();
 
         // getIndex(Class[])
         e = begin_method(Constants.ACC_PUBLIC, CONSTRUCTOR_GET_INDEX, null);
         e.load_args();
-        ReflectOps.constructor_switch(e, constructors, new GetIndexCallback(e, constructors));
+        ComplexOps.constructor_switch(e, constructors, new GetIndexCallback(e, constructors));
         e.end_method();
 
         // invoke(int, Object, Object[])

File: src/test/net/sf/cglib/reflect/TestMemberSwitch.java
Patch:
@@ -119,7 +119,7 @@ public void generateClass(ClassVisitor v) throws Exception {
                                                   ReflectUtils.getSignature(method),
                                                   ReflectUtils.getExceptionTypes(method));
             e.load_arg(0);
-            ReflectOps.constructor_switch(e, constructors, new ObjectSwitchCallback() {
+            ComplexOps.constructor_switch(e, constructors, new ObjectSwitchCallback() {
                     public void processCase(Object key, Label end) {
                         e.push(clist.indexOf(key));
                         e.goTo(end);

File: src/proxy/net/sf/cglib/transform/AddDelegateTransformer.java
Patch:
@@ -54,7 +54,7 @@ public void begin_class(int access, String className, Type superType, Type[] int
 
             public CodeVisitor begin_method(int access, Signature sig, Type[] exceptions) {
                 CodeVisitor v = super.begin_method(access, sig, exceptions);
-                if (sig.getName().equals(Constants.STATIC_NAME)) {
+                if (sig.getName().equals(Constants.CONSTRUCTOR_NAME)) {
                     return new CodeAdapter(v) {
                         private boolean transformInit = true;
                         public void visitMethodInsn(int opcode, String owner, String name, String desc) {

File: src/proxy/net/sf/cglib/transform/FieldProviderTransformer.java
Patch:
@@ -59,7 +59,7 @@ public void begin_class(int access, String className, Type superType, Type[] int
 
             public void declare_field(int access, String name, Type type, Object value) {
                 super.declare_field(access, name, type, value);
-                if( (access & Constants.ACC_STATIC) == 0 ){
+                if( !TypeUtils.isStatic(access) ){
                     fields.put(name, type);
                 }
             }

File: src/test/net/sf/cglib/transform/PersistenceCapableImpl.java
Patch:
@@ -21,6 +21,7 @@ public PersistenceCapableImpl(Object _this) {
    public void setPersistenceManager( Object manager){
         
       persistenceManager = manager;
+      System.out.println("setPersistenceManager:" + manager);
     }
     
    public Object getPersistenceManager(){

File: src/test/net/sf/cglib/transform/TransformDemo.java
Patch:
@@ -38,6 +38,8 @@ public static void makePersistent(Object obj){
         FieldProvider provider = (FieldProvider)obj;
         System.out.println("Field Names " + Arrays.asList(provider.getFieldNames()) );
         System.out.println("Field Types " + Arrays.asList(provider.getFieldTypes()) );
+        PersistenceCapable pc = (PersistenceCapable)obj;
+        pc.setPersistenceManager("Manager");
     
     }
     

File: src/proxy/net/sf/cglib/Enhancer.java
Patch:
@@ -121,7 +121,7 @@ private Object createHelper() {
         if (superclass != null) {
             setNamePrefix(superclass.getName());
         } else if (interfaces != null) {
-            setNamePrefix(interfaces[0].getName());
+            setNamePrefix(interfaces[ReflectUtils.findPackageProtected(interfaces)].getName());
         }
         Object key = KEY_FACTORY.newInstance(superclass, interfaces, filter, classOnly);
         return super.create(key);

File: src/proxy/net/sf/cglib/Enhancer.java
Patch:
@@ -60,7 +60,7 @@
 
 public class Enhancer extends AbstractClassGenerator
 {
-    private static final Source SOURCE = new Source(Enhancer.class.getName(), true);
+    private static final Source SOURCE = new Source(Enhancer.class.getName());
     private static final EnhancerKey KEY_FACTORY =
       (EnhancerKey)KeyFactory.create(EnhancerKey.class, KeyFactory.CLASS_BY_NAME);
 

File: src/proxy/net/sf/cglib/Mixin.java
Patch:
@@ -65,7 +65,7 @@
  * methods in the generated object simply call the original methods in the
  * underlying "delegate" objects.
  * @author Chris Nokleberg
- * @version $Id: Mixin.java,v 1.11 2003/09/29 22:56:28 herbyderby Exp $
+ * @version $Id: Mixin.java,v 1.12 2003/09/29 23:08:52 herbyderby Exp $
  */
 abstract public class Mixin {
     private static final MixinKey KEY_FACTORY =
@@ -99,7 +99,7 @@ public static Mixin createBean(Object[] beans) {
     }
     
     public static class Generator extends AbstractClassGenerator {
-        private static final Source SOURCE = new Source(Mixin.class.getName(), true);
+        private static final Source SOURCE = new Source(Mixin.class.getName());
 
         private Class[] classes;
         private Object[] delegates;

File: src/proxy/net/sf/cglib/beans/BeanMap.java
Patch:
@@ -74,7 +74,7 @@ public static BeanMap create(Object bean) {
     }
 
     public static class Generator extends AbstractClassGenerator {
-        private static final Source SOURCE = new Source(BeanMap.class.getName(), true);
+        private static final Source SOURCE = new Source(BeanMap.class.getName());
 
         private Object bean;
         private int switchStyle;

File: src/proxy/net/sf/cglib/beans/BulkBean.java
Patch:
@@ -109,7 +109,7 @@ public static BulkBean create(Class target, String[] getters, String[] setters,
     }
 
     public static class Generator extends AbstractClassGenerator {
-        private static final Source SOURCE = new Source(BulkBean.class.getName(), true);
+        private static final Source SOURCE = new Source(BulkBean.class.getName());
         private Class target;
         private String[] getters;
         private String[] setters;

File: src/proxy/net/sf/cglib/core/AbstractClassGenerator.java
Patch:
@@ -84,9 +84,7 @@ public String getClassName(String prefix, String source, Object key) {
     protected static class Source {
         String name;
         Map cache = new WeakHashMap();
-
-        // TODO: get rid of useCache
-        public Source(String name, boolean useCache) {
+        public Source(String name) {
             this.name = name;
         }
     }

File: src/proxy/net/sf/cglib/core/KeyFactory.java
Patch:
@@ -96,7 +96,7 @@
  * <code>hashCode</code> equality between two keys <code>key1</code> and <code>key2</code> is guaranteed if
  * <code>key1.equals(key2)</code> <i>and</i> the keys were produced by the same factory.
  *
- * @version $Id: KeyFactory.java,v 1.6 2003/09/29 22:56:27 herbyderby Exp $
+ * @version $Id: KeyFactory.java,v 1.7 2003/09/29 23:08:52 herbyderby Exp $
  */
 abstract public class KeyFactory {
     protected int hashConstant;
@@ -134,7 +134,7 @@ public int hashCode() {
 
     public static class Generator extends AbstractClassGenerator
     {
-        private static final Source SOURCE = new Source(KeyFactory.class.getName(), true);
+        private static final Source SOURCE = new Source(KeyFactory.class.getName());
         private Class keyInterface;
         private Customizer customizer;
 
@@ -156,7 +156,7 @@ public void setInterface(Class keyInterface) {
 
         public KeyFactory create() {
             setNamePrefix(keyInterface.getName());
-            return (KeyFactory)super.create(keyInterface);
+            return (KeyFactory)super.create(keyInterface.getName());
         }
 
         public void generateClass(ClassVisitor v) throws Exception {

File: src/proxy/net/sf/cglib/reflect/ConstructorDelegate.java
Patch:
@@ -60,7 +60,7 @@
 
 /**
  * @author Chris Nokleberg
- * @version $Id: ConstructorDelegate.java,v 1.12 2003/09/29 22:56:27 herbyderby Exp $
+ * @version $Id: ConstructorDelegate.java,v 1.13 2003/09/29 23:08:52 herbyderby Exp $
  */
 abstract public class ConstructorDelegate {
     private static final ConstructorKey KEY_FACTORY =
@@ -81,7 +81,7 @@ public static ConstructorDelegate create(Class targetClass, Class iface) {
     }
 
     public static class Generator extends AbstractClassGenerator {
-        private static final Source SOURCE = new Source(ConstructorDelegate.class.getName(), true);
+        private static final Source SOURCE = new Source(ConstructorDelegate.class.getName());
         private static final Type CONSTRUCTOR_DELEGATE =
           TypeUtils.parseType("net.sf.cglib.reflect.ConstructorDelegate");
 

File: src/proxy/net/sf/cglib/reflect/FastClass.java
Patch:
@@ -73,7 +73,7 @@ public static FastClass create(Class type) {
 
     public static class Generator extends AbstractClassGenerator
     {
-        private static final Source SOURCE = new Source(FastClass.class.getName(), true);
+        private static final Source SOURCE = new Source(FastClass.class.getName());
         private Class type;
         
         public Generator() {
@@ -86,7 +86,7 @@ public void setType(Class type) {
         
         public FastClass create() {
             setNamePrefix(type.getName());
-            return (FastClass)super.create(type);
+            return (FastClass)super.create(type.getName());
         }
 
         protected ClassLoader getDefaultClassLoader() {

File: src/proxy/net/sf/cglib/reflect/MethodDelegate.java
Patch:
@@ -140,7 +140,7 @@
  *     <li>They refer to the same method as resolved by <code>Method.equals</code>.</li>
  *   </ul>
  *
- * @version $Id: MethodDelegate.java,v 1.13 2003/09/29 22:56:27 herbyderby Exp $
+ * @version $Id: MethodDelegate.java,v 1.14 2003/09/29 23:08:52 herbyderby Exp $
  */
 abstract public class MethodDelegate {
     private static final MethodDelegateKey KEY_FACTORY =
@@ -185,7 +185,7 @@ public Object getTarget() {
     abstract public MethodDelegate newInstance(Object target);
 
     public static class Generator extends AbstractClassGenerator {
-        private static final Source SOURCE = new Source(MethodDelegate.class.getName(), true);
+        private static final Source SOURCE = new Source(MethodDelegate.class.getName());
         private static final Signature NEW_INSTANCE =
           TypeUtils.parseSignature("net.sf.cglib.reflect.MethodDelegate newInstance(Object)");
         private static final Type METHOD_DELEGATE =

File: src/proxy/net/sf/cglib/reflect/MulticastDelegate.java
Patch:
@@ -101,7 +101,7 @@ public static MulticastDelegate create(Class iface) {
     }
 
     public static class Generator extends AbstractClassGenerator {
-        private static final Source SOURCE = new Source(MulticastDelegate.class.getName(), true);
+        private static final Source SOURCE = new Source(MulticastDelegate.class.getName());
         private static final Signature NEW_INSTANCE =
           TypeUtils.parseSignature("net.sf.cglib.reflect.MulticastDelegate newInstance()");
         private static final Signature ADD =
@@ -127,7 +127,7 @@ public void setInterface(Class iface) {
 
         public MulticastDelegate create() {
             setNamePrefix(MulticastDelegate.class.getName());
-            return (MulticastDelegate)super.create(iface);
+            return (MulticastDelegate)super.create(iface.getName());
         }
 
         public void generateClass(ClassVisitor v) throws NoSuchFieldException {

File: src/proxy/net/sf/cglib/util/ParallelSorter.java
Patch:
@@ -301,7 +301,7 @@ static class ByteComparer implements Comparer {
 
 
     public static class Generator extends AbstractClassGenerator {
-        private static final Source SOURCE = new Source(ParallelSorter.class.getName(), true);
+        private static final Source SOURCE = new Source(ParallelSorter.class.getName());
 
         private Object[] arrays;
 

File: src/test/net/sf/cglib/TestEnhancer.java
Patch:
@@ -61,7 +61,7 @@
 /**
  *@author     Juozas Baliuka <a href="mailto:baliuka@mwm.lt">
  *      baliuka@mwm.lt</a>
- *@version    $Id: TestEnhancer.java,v 1.42 2003/09/23 10:54:35 herbyderby Exp $
+ *@version    $Id: TestEnhancer.java,v 1.43 2003/09/29 23:08:52 herbyderby Exp $
  */
 public class TestEnhancer extends CodeGenTestCase {
     private static final MethodInterceptor TEST_INTERCEPTOR = new TestInterceptor();
@@ -248,7 +248,6 @@ public void testSystemClassLoader()throws Throwable{
         == ClassLoader.getSystemClassLoader()  );
         
     }
-
     
     public void testCustomClassLoader()throws Throwable{
         
@@ -266,7 +265,7 @@ public void testCustomClassLoader()throws Throwable{
         
         
     }
-    
+
     public void testRuntimException()throws Throwable{
     
         Source source =  (Source)Helpers.enhance(

File: src/test/net/sf/cglib/core/TestStringSwitch.java
Patch:
@@ -104,7 +104,7 @@ public void testEqualHashCodes() {
     }
 
     private static class Generator extends TestGenerator {
-        private static final Source SOURCE = new Source(TestStringSwitch.class.getName(), false);
+        private static final Source SOURCE = new Source(TestStringSwitch.class.getName());
         private String[] keys;
         private int switchStyle;
 

File: src/test/net/sf/cglib/core/TestSwitch.java
Patch:
@@ -88,7 +88,7 @@ public void testAlphabet() {
     }
 
     private static class Generator extends TestGenerator {
-        private static final Source SOURCE = new Source(TestSwitch.class.getName(), false);
+        private static final Source SOURCE = new Source(TestSwitch.class.getName());
         private int[] keys;
         private String[] values;
 

File: src/test/net/sf/cglib/reflect/TestMemberSwitch.java
Patch:
@@ -98,7 +98,7 @@ public void testSimple() {
     }
 
     private static class Generator extends TestGenerator {
-        private static final Source SOURCE = new Source(TestMemberSwitch.class.getName(), false);
+        private static final Source SOURCE = new Source(TestMemberSwitch.class.getName());
         private Constructor[] constructors;
 
         public Generator(Constructor[] constructors) {

File: src/proxy/net/sf/cglib/DispatcherGenerator.java
Patch:
@@ -72,14 +72,14 @@ public void generate(Emitter e, Context context) {
             if (Modifier.isProtected(method.getModifiers())) {
                 // ignore protected methods
             } else {
-                Ops.begin_method(e, method, context.getModifiers(method));
+                ReflectOps.begin_method(e, method, context.getModifiers(method));
                 context.emitCallback();
                 e.checkcast(DISPATCHER);
                 e.push(method.getDeclaringClass().getName());
                 e.invoke_interface(DISPATCHER, LOAD_OBJECT);
                 e.checkcast(Type.getType(method.getDeclaringClass()));
                 e.load_args();
-                Ops.invoke(e, method);
+                ReflectOps.invoke(e, method);
                 e.return_value();
             }
         }

File: src/proxy/net/sf/cglib/LazyLoaderGenerator.java
Patch:
@@ -71,7 +71,7 @@ class LazyLoaderGenerator implements CallbackGenerator {
     private static final Type LAZY_LOADER = Type.getType(LazyLoader.class);
 
     public void generate(Emitter e, Context context) {
-        e.declare_field(Modifier.PRIVATE, DELEGATE, Types.OBJECT, null);
+        e.declare_field(Modifier.PRIVATE, DELEGATE, Constants.TYPE_OBJECT, null);
 
         e.begin_method(Modifier.PRIVATE | Modifier.SYNCHRONIZED | Modifier.FINAL,
                         LOAD_PRIVATE,
@@ -96,13 +96,13 @@ public void generate(Emitter e, Context context) {
             if (Modifier.isProtected(method.getModifiers())) {
                 // ignore protected methods
             } else {
-                Ops.begin_method(e, method, context.getModifiers(method));
+                ReflectOps.begin_method(e, method, context.getModifiers(method));
                 e.load_this();
                 e.dup();
                 e.invoke_virtual_this(LOAD_PRIVATE);
                 e.checkcast(Type.getType(method.getDeclaringClass()));
                 e.load_args();
-                Ops.invoke(e, method);
+                ReflectOps.invoke(e, method);
                 e.return_value();
             }
         }

File: src/proxy/net/sf/cglib/transform/EmittingTransformer.java
Patch:
@@ -33,7 +33,7 @@ private static Type[] fromInternalNames(String[] names) {
 
     public void visit(int access, String name, String superName, String[] interfaces, String sourceFile) {
         e.begin_class(access,
-                      fromInternalName(name),
+                      name.replace('/', '.'),
                       fromInternalName(superName),
                       fromInternalNames(interfaces),
                       sourceFile);

File: src/test/net/sf/cglib/core/TestStringSwitch.java
Patch:
@@ -61,6 +61,7 @@
 import junit.framework.*;
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.Label;
+import org.objectweb.asm.Type;
 
 public class TestStringSwitch extends CodeGenTestCase {
     private static int index = 0;
@@ -115,10 +116,10 @@ public Generator(String[] keys, int switchStyle) {
 
         public void generateClass(ClassVisitor v) throws Exception {
             final Emitter e = new Emitter(v);
-            Ops.begin_class(e, Modifier.PUBLIC, getClassName(), null, new Class[]{ Indexed.class }, Constants.SOURCE_FILE);
+            e.begin_class(Constants.ACC_PUBLIC, getClassName(), null, new Type[]{ Type.getType(Indexed.class) }, Constants.SOURCE_FILE);
             e.null_constructor();
             Method method = Indexed.class.getMethod("getIndex", new Class[]{ String.class });
-            Ops.begin_method(e, method);
+            ReflectOps.begin_method(e, method);
             e.load_arg(0);
             Ops.string_switch(e, keys, switchStyle, new ObjectSwitchCallback() {
                     public void processCase(Object key, Label end) {

File: src/test/net/sf/cglib/core/TestSwitch.java
Patch:
@@ -61,6 +61,7 @@
 import junit.framework.*;
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.Label;
+import org.objectweb.asm.Type;
 
 public class TestSwitch extends CodeGenTestCase {
     private static int index = 0;
@@ -99,10 +100,10 @@ public Generator(int[] keys, String[] values) {
 
         public void generateClass(ClassVisitor v) throws Exception {
             final Emitter e = new Emitter(v);
-            Ops.begin_class(e, Modifier.PUBLIC, getClassName(), null, new Class[]{ Alphabet.class }, Constants.SOURCE_FILE);
+            e.begin_class(Constants.ACC_PUBLIC, getClassName(), null, new Type[]{ Type.getType(Alphabet.class) }, Constants.SOURCE_FILE);
             e.null_constructor();
             Method method = Alphabet.class.getMethod("getLetter", new Class[]{ Integer.TYPE });
-            Ops.begin_method(e, method);
+            ReflectOps.begin_method(e, method);
             e.load_arg(0);
             e.process_switch(keys, new ProcessSwitchCallback() {
                     public void processCase(int index, Label end) {

File: src/proxy/net/sf/cglib/EnhancerEmitter.java
Patch:
@@ -79,7 +79,7 @@ class EnhancerEmitter extends Emitter
     private static final Method CALLBACKS_GET =
       ReflectUtils.findMethod("Callbacks.get(int)");
     
-    private final BitSet usedCallbacks = new BitSet();
+    private final TinyBitSet usedCallbacks = new TinyBitSet();
 
     public EnhancerEmitter(ClassVisitor v,
                            String className,

File: src/proxy/net/sf/cglib/transform/AbstractTransformTask.java
Patch:
@@ -84,9 +84,11 @@ public String getName() {
     }
 
     private void processFile(File file) throws Exception {
+
+        boolean modified = false;
+        // if (file.getAbsolutePath().endsWith(".class")) {
         ClassReader r = new ClassReader(new BufferedInputStream(new FileInputStream(file)));
         CaptureNameWriter w = new CaptureNameWriter(true);
-        boolean modified = false;
         ClassTransformer t = getClassTransformer();
         if (t != null) {
             try {

File: src/test/net/sf/cglib/util/TestParallelSorter.java
Patch:
@@ -61,7 +61,7 @@
 
 /**
  * @author Chris Nokleberg <a href="mailto:chris@nokleberg.com">chris@nokleberg.com</a>
- * @version $Id: TestParallelSorter.java,v 1.1 2003/09/15 19:31:09 herbyderby Exp $
+ * @version $Id: TestParallelSorter.java,v 1.2 2003/09/18 17:23:29 herbyderby Exp $
  */
 public class TestParallelSorter extends CodeGenTestCase {
     public void testSorts() throws Throwable {
@@ -105,7 +105,7 @@ private int[] getIndexes(int len) {
     }
 
     private Object[] getTestData() throws IOException {
-        InputStream in = getClass().getResource("words.txt").openStream();
+        InputStream in = getClass().getResourceAsStream("words.txt");
         BufferedReader r = new BufferedReader(new InputStreamReader(in));
         List list = new ArrayList();
         String line;

File: src/proxy/net/sf/cglib/reflect/FastClass.java
Patch:
@@ -153,4 +153,6 @@ public boolean equals(Object o) {
     abstract public int getIndex(Class[] parameterTypes);
     abstract public Object invoke(int index, Object obj, Object[] args) throws Throwable;
     abstract public Object newInstance(int index, Object[] args) throws Throwable;
+
+    abstract public int getIndex(String methodSignature);
 }

File: src/proxy/net/sf/cglib/reflect/FastMethod.java
Patch:
@@ -55,7 +55,7 @@
 
 import java.lang.reflect.Method;
 
-public class FastMethod extends FastMember implements Invocable
+public class FastMethod extends FastMember
 {
     FastMethod(FastClass fc, Method method) {
         super(fc, method, helper(fc, method));

File: src/proxy/net/sf/cglib/util/ClassesKey.java
Patch:
@@ -70,7 +70,7 @@ public ClassesKey(Object[] array) {
     public boolean equals(Object o) {
         return o != null
             && (o instanceof ClassesKey)
-            && ReflectUtils.arrayEquals(array, ((ClassesKey)o).array);
+            && CollectionUtils.arrayEquals(array, ((ClassesKey)o).array);
     }
 
     public int hashCode() {

File: src/proxy/net/sf/cglib/util/MethodConstants.java
Patch:
@@ -56,7 +56,7 @@
 import java.lang.reflect.Method;
 
 /**
- * @version $Id: MethodConstants.java,v 1.5 2003/09/08 17:42:24 herbyderby Exp $
+ * @version $Id: MethodConstants.java,v 1.6 2003/09/10 20:15:29 herbyderby Exp $
  */
 public class MethodConstants {
     private MethodConstants() { }
@@ -109,4 +109,6 @@ private MethodConstants() { }
       ReflectUtils.findMethod("Method.getParameterTypes()");
     public static final Method CLASS_GET_NAME =
       ReflectUtils.findMethod("Class.getName()");
+    public static final Method GET_DECLARING_CLASS =
+      ReflectUtils.findMethod("Method.getDeclaringClass()");
 }

File: src/proxy/net/sf/cglib/util/MethodWrapper.java
Patch:
@@ -51,12 +51,13 @@
  * information on the Apache Software Foundation, please see
  * <http://www.apache.org/>.
  */
-package net.sf.cglib;
+package net.sf.cglib.util;
 
 import java.lang.reflect.Method;
 import java.util.*;
+import net.sf.cglib.KeyFactory; // TODO
 
-class MethodWrapper {
+public class MethodWrapper {
     private static final MethodWrapperKey KEY_FACTORY =
       (MethodWrapperKey)KeyFactory.create(MethodWrapperKey.class, null);
 

File: src/proxy/net/sf/cglib/util/VisibilityPredicate.java
Patch:
@@ -56,8 +56,8 @@
 import java.lang.reflect.*;
 
 public class VisibilityPredicate implements Predicate {
-    final boolean protectedOk;
-    final String pkg;
+    private boolean protectedOk;
+    private String pkg;
 
     public VisibilityPredicate(Class source, boolean protectedOk) {
         this.protectedOk = protectedOk;

File: src/proxy/net/sf/cglib/reflect/FastConstructor.java
Patch:
@@ -55,12 +55,10 @@
 
 public class FastConstructor extends FastMember
 {
-    private FastClass fc;
     private int index;
     
     FastConstructor(FastClass fc, Class[] parameterTypes) {
-        super("<init>");
-        this.fc = fc;
+        super(fc, "<init>", parameterTypes);
         index = fc.getIndex(parameterTypes);
     }
 

File: src/proxy/net/sf/cglib/util/BasicCodeGenerator.java
Patch:
@@ -209,7 +209,7 @@ public final Class define() {
             
             if (debugLocation != null) {
                 File file = new File(new File(debugLocation), className + ".class");
-                System.err.println("CGLIB writing " + file);
+                // System.err.println("CGLIB writing " + file);
                 OutputStream out = new BufferedOutputStream(new FileOutputStream(file));
                 out.write(bytes);
                 out.close();

File: src/proxy/net/sf/cglib/util/MethodConstants.java
Patch:
@@ -56,7 +56,7 @@
 import java.lang.reflect.Method;
 
 /**
- * @version $Id: MethodConstants.java,v 1.4 2003/09/05 22:59:20 herbyderby Exp $
+ * @version $Id: MethodConstants.java,v 1.5 2003/09/08 17:42:24 herbyderby Exp $
  */
 public class MethodConstants {
     private MethodConstants() { }
@@ -107,4 +107,6 @@ private MethodConstants() { }
       ReflectUtils.findMethod("ThreadLocal.set(Object)");
     public static final Method GET_PARAMETER_TYPES =
       ReflectUtils.findMethod("Method.getParameterTypes()");
+    public static final Method CLASS_GET_NAME =
+      ReflectUtils.findMethod("Class.getName()");
 }

File: src/proxy/net/sf/cglib/util/CodeGenerator.java
Patch:
@@ -293,7 +293,7 @@ static private Class findClass(String name) throws Exception {
         null);
 
         Block block = begin_block();
-        load_this();
+        load_arg(0);
         invoke(MethodConstants.FOR_NAME);
         return_value();
         end_block();

File: src/proxy/net/sf/cglib/Enhancer.java
Patch:
@@ -79,7 +79,7 @@
  * </pre>
  *@author     Juozas Baliuka <a href="mailto:baliuka@mwm.lt">
  *      baliuka@mwm.lt</a>
- *@version    $Id: Enhancer.java,v 1.36 2003/02/03 22:52:35 herbyderby Exp $
+ *@version    $Id: Enhancer.java,v 1.37 2003/03/06 19:05:59 baliuka Exp $
  */
 public class Enhancer {
     private static final FactoryCache cache = new FactoryCache();
@@ -154,7 +154,6 @@ public static Object enhance( Class cls, Class interfaces[],
      * parameter is null : static public Object InternalReplace.writeReplace( 
      *                                                       Object enhanced )
      *                 throws ObjectStreamException;
-     * @throws Throwable on error
      * @return instanse of enhanced  class
      */
     public static Object enhance(Class cls, Class[] interfaces, MethodInterceptor ih,
@@ -287,7 +286,7 @@ private Object readResolve() throws ObjectStreamException {
         }
     }
 
-    public static class ReadResolveException extends ObjectStreamException {
+     static class ReadResolveException extends ObjectStreamException {
         private Throwable cause;
 
         public ReadResolveException(Throwable cause) {

File: src/proxy/net/sf/cglib/CodeGenerator.java
Patch:
@@ -77,8 +77,6 @@
     private boolean needsFindClass;
     
     private int nextPrivateLabel;
-    private int nextPrivateLocal;
-
 	private Set labels = new HashSet();
     private Map locals = new HashMap();
     private Map localTypes = new HashMap();

File: src/proxy/net/sf/cglib/Enhancer.java
Patch:
@@ -79,10 +79,9 @@
  * </pre>
  *@author     Juozas Baliuka <a href="mailto:baliuka@mwm.lt">
  *      baliuka@mwm.lt</a>
- *@version    $Id: Enhancer.java,v 1.30 2003/01/29 18:23:21 herbyderby Exp $
+ *@version    $Id: Enhancer.java,v 1.31 2003/01/31 01:04:26 herbyderby Exp $
  */
 public class Enhancer {
-    private static final String INTERCEPTOR_NAME = MethodInterceptor.class.getName();
     private static final FactoryCache cache = new FactoryCache();
     private static final FactoryCache classCache = new FactoryCache();
     private static final ClassLoader defaultLoader = Enhancer.class.getClassLoader();

File: src/proxy/net/sf/cglib/CodeGeneratorBackend.java
Patch:
@@ -53,8 +53,6 @@
  */
 package net.sf.cglib;
 
-import java.lang.reflect.*;
-
 abstract public class CodeGeneratorBackend {
     protected String className;
     protected Class superclass;
@@ -169,4 +167,5 @@ abstract public void begin_method(int modifiers, Class returnType, String name,
     abstract public void ireturn();
     abstract public void areturn();
     abstract public void iinc(int index, int amount);
+    abstract public String getMethodSignature(Class returnType, Class[] parameterTypes);
 }

File: src/proxy/net/sf/cglib/ParallelSorter.java
Patch:
@@ -1,7 +1,7 @@
 /*
  * The Apache Software License, Version 1.1
  *
- * Copyright (c) 2002 The Apache Software Foundation.  All rights
+ * Copyright (c) 2003 The Apache Software Foundation.  All rights
  * reserved.
  *
  * Redistribution and use in source and binary forms, with or without

File: src/proxy/net/sf/cglib/Factory.java
Patch:
@@ -57,7 +57,7 @@
 /**
  * All enhanced instances implement this interface.
  * @author Juozas Baliuka <a href="mailto:baliuka@mwm.lt">baliuka@mwm.lt</a>
- * @version $Id: Factory.java,v 1.6 2003/01/25 00:12:09 herbyderby Exp $
+ * @version $Id: Factory.java,v 1.7 2003/01/25 08:22:32 herbyderby Exp $
  */
 public interface Factory {
     /**
@@ -76,6 +76,8 @@ public interface Factory {
     public Object getDelegate();
     
     public void setDelegate(Object delegate);
+
+    public void setInterceptor(MethodInterceptor ih);
 }
    
     

File: src/proxy/net/sf/cglib/ConstructorProxy.java
Patch:
@@ -57,7 +57,7 @@
 /**
  *
  * @author  baliuka
- * @version $Id: ConstructorProxy.java,v 1.3 2003/01/13 18:07:04 baliuka Exp $
+ * @version $Id: ConstructorProxy.java,v 1.4 2003/01/24 19:29:58 herbyderby Exp $
  */
 public abstract class ConstructorProxy {
     
@@ -67,11 +67,11 @@ public abstract class ConstructorProxy {
     private static final ClassNameFactory nameFactory = 
                                new ClassNameFactory("ConstructorProxiedByCGLIB");
    
-    private static final ClassKey CALSS_KEY_FACTORY =
+    private static final ClassKey CLASS_KEY_FACTORY =
       (ClassKey)KeyFactory.create(ClassKey.class, null);
   
     public static Object newClassKey(Class[] args){
-      return CALSS_KEY_FACTORY.newInstance(args);
+      return CLASS_KEY_FACTORY.newInstance(args);
     }
     
     public interface ClassKey{

File: src/proxy/net/sf/cglib/Enhancer.java
Patch:
@@ -55,7 +55,6 @@
 
 import java.io.*;
 import java.lang.reflect.*;
-import java.util.*;
 
 /**
  *
@@ -78,7 +77,7 @@
  * </pre>
  *@author     Juozas Baliuka <a href="mailto:baliuka@mwm.lt">
  *      baliuka@mwm.lt</a>
- *@version    $Id: Enhancer.java,v 1.19 2003/01/21 17:38:14 baliuka Exp $
+ *@version    $Id: Enhancer.java,v 1.20 2003/01/23 11:15:08 nemecec Exp $
  */
 public class Enhancer {
     private static final String INTERCEPTOR_NAME = MethodInterceptor.class.getName();
@@ -307,7 +306,7 @@ public static class InternalReplace implements Serializable {
         public InternalReplace() {
         }
         
-        private InternalReplace(String parentClassName, String[] interfaces,
+        private InternalReplace(String parentClassName, String[] interfaceNames,
                                 MethodInterceptor mi) {
             this.parentClassName = parentClassName;
             this.interfaceNames   = interfaceNames;

File: src/proxy/net/sf/cglib/Enhancer.java
Patch:
@@ -78,7 +78,7 @@
  * </pre>
  *@author     Juozas Baliuka <a href="mailto:baliuka@mwm.lt">
  *      baliuka@mwm.lt</a>
- *@version    $Id: Enhancer.java,v 1.14 2002/12/29 21:38:02 herbyderby Exp $
+ *@version    $Id: Enhancer.java,v 1.15 2003/01/12 13:14:52 baliuka Exp $
  */
 public class Enhancer {
     private static final String INTERCEPTOR_NAME = MethodInterceptor.class.getName();
@@ -202,6 +202,7 @@ public static Object enhance(Object obj, Class cls, Class[] interfaces,
     }
 
     
+   
     
     private static Object enhanceHelper(boolean delegating, Object obj,Class cls,
                                         Class[] interfaces, MethodInterceptor ih,

File: src/proxy/net/sf/cglib/MethodFilter.java
Patch:
@@ -58,6 +58,6 @@
 */
 public interface MethodFilter {
  
-    public boolean accept( java.lang.reflect.Method method );
+    public boolean accept( java.lang.reflect.Member method );
     
 }

File: src/proxy/net/sf/cglib/ModifierFilter.java
Patch:
@@ -53,7 +53,7 @@
  */
 package net.sf.cglib;
 
-import java.lang.reflect.Method;
+import java.lang.reflect.Member;
 import java.lang.reflect.Modifier;
 
 /* package */ class ModifierFilter implements MethodFilter {
@@ -65,7 +65,7 @@ public ModifierFilter(int mask, int value) {
         this.value = value;
     }
     
-    public boolean accept(Method method) {
+    public boolean accept(Member method) {
         return (method.getModifiers() & mask) == value;
     }
 }

File: src/proxy/net/sf/cglib/VisibilityFilter.java
Patch:
@@ -64,7 +64,7 @@ public VisibilityFilter(Class source) {
         pkg = source.getPackage();
     }
     
-    public boolean accept(Method method) {
+    public boolean accept(Member method) {
         return accept(method, pkg);
     }
 

File: src/proxy/net/sf/cglib/CodeGenerator.java
Patch:
@@ -187,9 +187,9 @@ public Object run() {
         primitiveMethods.put(Long.TYPE, MethodConstants.LONG_VALUE);
         primitiveMethods.put(Double.TYPE, MethodConstants.DOUBLE_VALUE);
         primitiveMethods.put(Float.TYPE, MethodConstants.FLOAT_VALUE);
-        primitiveMethods.put(Short.TYPE, MethodConstants.SHORT_INT_VALUE);
+        primitiveMethods.put(Short.TYPE, MethodConstants.INT_VALUE);
         primitiveMethods.put(Integer.TYPE, MethodConstants.INT_VALUE);
-        primitiveMethods.put(Byte.TYPE, MethodConstants.BYTE_INT_VALUE);
+        primitiveMethods.put(Byte.TYPE, MethodConstants.INT_VALUE);
 
         primitiveToWrapper.put(Boolean.TYPE, Boolean.class);
         primitiveToWrapper.put(Character.TYPE, Character.class);

File: src/proxy/net/sf/cglib/CodeGenerator.java
Patch:
@@ -68,7 +68,6 @@ public abstract class CodeGenerator implements Constants {
     private static final String SOURCE_FILE = "<generated>";
     private static final String STATIC_NAME = "<clinit>";
     private static final String FIND_CLASS = "CGLIB$findClass";
-    private static final String FIND_CLASS_SIG = getMethodSignature(Class.class, TYPES_STRING);
     private static final String PRIVATE_PREFIX = "PRIVATE_";
     private static final Map primitiveMethods = new HashMap();
     private static final Map primitiveToWrapper = new HashMap();

File: src/proxy/net/sf/cglib/MethodClosure.java
Patch:
@@ -58,7 +58,7 @@
 
 /**
  * @author Chris Nokleberg <a href="mailto:chris@nokleberg.com">chris@nokleberg.com</a>
- * @version $Id: MethodClosure.java,v 1.5 2002/12/21 23:45:16 herbyderby Exp $
+ * @version $Id: MethodClosure.java,v 1.6 2002/12/21 23:55:11 herbyderby Exp $
  */
 abstract public class MethodClosure {
     /* package */ static final Class TYPE = MethodClosure.class;
@@ -157,7 +157,6 @@ private static String getNextName(Class cls) {
     private static class Generator extends CodeGenerator {
         private Method method;
         private Class iface;
-        private Method proxy;
 
         public Generator(String className, Method method, Class iface, ClassLoader loader) {
             super(className, MethodClosure.class, loader);

File: src/proxy/net/sf/cglib/EnhancerGenerator.java
Patch:
@@ -197,7 +197,7 @@ protected void generate() throws NoSuchMethodException {
                 Object methodKey = MethodWrapper.newInstance(method);
                 Method other = (Method)methodMap.get(methodKey);
                 
-                if( other != null && compare( other, method ) > 0 ){
+                if( other != null && compare( other, method ) >= 0 ){
                     
                     checkReturnTypesEqual(method, other);
                    

File: src/proxy/net/sf/cglib/Delegator.java
Patch:
@@ -62,7 +62,7 @@
  * methods in the generated object simply call the original methods in the
  * underlying "delegate" objects.
  * @author Chris Nokleberg <a href="mailto:chris@nokleberg.com">chris@nokleberg.com</a>
- * @version $Id: Delegator.java,v 1.7 2002/12/06 19:16:43 herbyderby Exp $
+ * @version $Id: Delegator.java,v 1.8 2002/12/07 15:36:49 baliuka Exp $
  */
 public class Delegator {
     /* package */ static final Class TYPE = Delegator.class;
@@ -76,7 +76,8 @@ public class Delegator {
     private static final DelegatorKey keyFactory =
       (DelegatorKey)KeyFactory.makeFactory(DelegatorKey.class, null);
 
-    /* package */ interface DelegatorKey {
+    /*package doe's not work on jdk1.2 */     
+    public interface DelegatorKey {
         public Object newInstance(Class[] classes);
     }
 

File: src/proxy/net/sf/cglib/Enhancer.java
Patch:
@@ -78,7 +78,7 @@
  * </pre>
  *@author     Juozas Baliuka <a href="mailto:baliuka@mwm.lt">
  *      baliuka@mwm.lt</a>
- *@version    $Id: Enhancer.java,v 1.9 2002/12/04 00:55:46 herbyderby Exp $
+ *@version    $Id: Enhancer.java,v 1.10 2002/12/07 15:36:49 baliuka Exp $
  */
 public class Enhancer {
     private static final String CLASS_PREFIX = "net.sf.cglib";
@@ -90,7 +90,8 @@ public class Enhancer {
     private static final EnhancerKey keyFactory =
       (EnhancerKey)KeyFactory.makeFactory(EnhancerKey.class, null);
 
-    /* package */ interface EnhancerKey {
+    /*package doe's not work on jdk1.2 */     
+    public interface EnhancerKey {
         public Object newInstance(Class cls, Class[] interfaces, Method wreplace,
                                   Class interceptor, boolean delegating);
     }

File: src/proxy/net/sf/cglib/MetaClass.java
Patch:
@@ -76,7 +76,8 @@ public abstract class MetaClass  {
     protected String [] getters, setters;
     protected Class[] types;
 
-    /* package */ interface MetaClassKey {
+   /*package doe's not work on jdk1.2 */      
+    public interface MetaClassKey {
         public Object newInstance(Class target, String[] getters,
                                   String[] setters, Class[] types);
     }

File: src/proxy/net/sf/cglib/MethodProxy.java
Patch:
@@ -58,10 +58,10 @@
 
 /**
  * @author Chris Nokleberg <a href="mailto:chris@nokleberg.com">chris@nokleberg.com</a>
- * @version $Id: MethodProxy.java,v 1.4 2002/12/03 06:49:01 herbyderby Exp $
+ * @version $Id: MethodProxy.java,v 1.5 2002/12/07 15:36:49 baliuka Exp $
  */
 abstract public class MethodProxy {
-    private static final Method INVOKE_SUPER;
+    private static/* final */Method INVOKE_SUPER = null;//bug in jdk1.2 javac
     private static final String CLASS_SUFFIX = "$$ProxiedByCGLIB$$";
     private static int index = 0;
 
@@ -76,7 +76,7 @@ abstract public class MethodProxy {
 
     abstract public Object invokeSuper(Object obj, Object[] args) throws Throwable;
 
-    protected MethodProxy() {}
+    protected MethodProxy() { }
 
     public static MethodProxy generate(Method method) {
         return generate(method, null);

File: src/proxy/net/sf/cglib/MethodWrapper.java
Patch:
@@ -58,8 +58,8 @@
 /* package */ class MethodWrapper {
     private static final MethodWrapperKey keyFactory =
       (MethodWrapperKey)KeyFactory.makeFactory(MethodWrapperKey.class, null);
-
-    /* package */ interface MethodWrapperKey {
+/*package doe's not work on jdk1.2 */     
+    public interface MethodWrapperKey {
         public Object newInstance(String name, Class[] parameterTypes);
     }
     

File: src/test/net/sf/cglib/TestEnhancer.java
Patch:
@@ -60,7 +60,7 @@
 /**
  *@author     Juozas Baliuka <a href="mailto:baliuka@mwm.lt">
  *      baliuka@mwm.lt</a>
- *@version    $Id: TestEnhancer.java,v 1.9 2002/12/03 08:02:41 herbyderby Exp $
+ *@version    $Id: TestEnhancer.java,v 1.10 2002/12/07 15:36:52 baliuka Exp $
  */
 public class TestEnhancer extends CodeGenTestCase {
     private static final MethodInterceptor TEST_INTERCEPTOR = new TestInterceptor();
@@ -105,7 +105,7 @@ public void testEnhance()throws Throwable{
         assertTrue("Cache failed",vector1.getClass() == vector2.getClass());
     }
     
-    
+   
     public void testMethods()throws Throwable{
         
         MethodInterceptor interceptor =
@@ -372,4 +372,5 @@ public void testSamples() throws Throwable{
         samples.Trace.main(new String[]{});
         samples.Beans.main(new String[]{});
     }
+    
 }

File: src/proxy/net/sf/cglib/EnhancerGenerator.java
Patch:
@@ -205,7 +205,7 @@ protected void generate() throws NoSuchMethodException {
                 ( null != filter && !filter.accept(method))   ){
                 continue;
             }   
-            String fieldName = getFieldName(method, i);
+            String fieldName = getFieldName(i);
             String accessName = getAccessName(method, i);
             declare_field(privateFinalStatic, Method.class, fieldName);
             declare_field(privateFinalStatic, MethodProxy.class, accessName);
@@ -221,7 +221,7 @@ protected void generate() throws NoSuchMethodException {
         }
     }
 
-    private String getFieldName(Method method, int index) {
+    private String getFieldName(int index) {
         return "METHOD_" + index;
     }
     
@@ -429,7 +429,7 @@ private void generateClInit(List methodList) throws NoSuchMethodException {
         begin_static();
         for (int i = 0, size = methodList.size(); i < size; i++) {
             Method method = (Method)methodList.get(i);
-            String fieldName = getFieldName(method, i);
+            String fieldName = getFieldName(i);
 
             Class[] args = method.getParameterTypes();
             push(method.getDeclaringClass().getName());

File: src/proxy/net/sf/cglib/KeyFactoryGenerator.java
Patch:
@@ -58,13 +58,12 @@
 
 /**
  * @author Chris Nokleberg <a href="mailto:chris@nokleberg.com">chris@nokleberg.com</a>
- * @version $Id: KeyFactoryGenerator.java,v 1.5 2002/12/04 00:41:13 herbyderby Exp $
+ * @version $Id: KeyFactoryGenerator.java,v 1.6 2002/12/04 00:56:37 herbyderby Exp $
  */
 class KeyFactoryGenerator extends CodeGenerator {
     private static final Method HASH_CODE;
     private static final Method FLOAT_TO_INT_BITS;
     private static final Method DOUBLE_TO_LONG_BITS;
-    private static final Class TYPE_KEY_FACTORY = KeyFactory.class;
     
     static {
         try {

File: src/test/net/sf/cglib/TestEnhancer.java
Patch:
@@ -60,11 +60,11 @@
 /**
  *@author     Juozas Baliuka <a href="mailto:baliuka@mwm.lt">
  *      baliuka@mwm.lt</a>
- *@version    $Id: TestEnhancer.java,v 1.7 2002/12/01 19:05:22 baliuka Exp $
+ *@version    $Id: TestEnhancer.java,v 1.8 2002/12/03 06:49:49 herbyderby Exp $
  */
 public class TestEnhancer extends TestCase {
     public void setUp() {
-        net.sf.cglib.CodeGenerator.setDebugLocation("/tmp/");
+        // net.sf.cglib.CodeGenerator.setDebugLocation("/tmp/");
     }
     
     private static final MethodInterceptor TEST_INTERCEPTOR = new TestInterceptor();

File: src/proxy/net/sf/cglib/BeforeAfterInterceptor.java
Patch:
@@ -57,7 +57,7 @@
 
 /**
  * @author Juozas Baliuka <a href="mailto:baliuka@mwm.lt">baliuka@mwm.lt</a>
- * @version $Id: BeforeAfterInterceptor.java,v 1.5 2002/11/30 12:41:29 baliuka Exp $
+ * @version $Id: BeforeAfterInterceptor.java,v 1.6 2002/12/01 19:05:22 baliuka Exp $
  */
 abstract public class BeforeAfterInterceptor implements MethodInterceptor {
 
@@ -66,7 +66,8 @@ public Object aroundAdvice(Object obj, java.lang.reflect.Method method, Object[]
         Throwable e = null;                                                                            
         boolean invokedSuper = false;                                                                  
         Object retValFromSuper = null;
-        if (invokeSuper(obj, method, args)) {
+        if ( !java.lang.reflect.Modifier.isAbstract( method.getModifiers() ) && 
+              invokeSuper(obj, method, args)) {
             invokedSuper = true;                                                                        
             try {
                 retValFromSuper = proxy.invokeSuper(obj, args);

File: src/test/net/sf/cglib/EB.java
Patch:
@@ -1,6 +1,6 @@
 package net.sf.cglib;
 
-public class EB extends EA {
+public class EB extends EA implements Comparable{
 	private int count;
 
 	public int getCount() {

File: src/test/net/sf/cglib/EC1.java
Patch:
@@ -1,6 +1,6 @@
 package net.sf.cglib;
 
-public class EC1 extends EB {
+public class EC1 extends EB implements Comparable{
 	private String address;
 	private ED ed;
 

File: src/test/net/sf/cglib/EA.java
Patch:
@@ -25,5 +25,8 @@ public void setName(String name) {
     protected Object writeReplace() throws ObjectStreamException {
         return null;
     }
+    
+    protected void finalTest(){}
+    
 }
 

File: src/test/net/sf/cglib/EB.java
Patch:
@@ -10,5 +10,6 @@ public int getCount() {
 	public void setCount(int count) {
 		this.count = count;
 	}
+        public final  void finalTest(){} 
 }
 

File: src/test/net/sf/cglib/TestEnhancer.java
Patch:
@@ -60,7 +60,7 @@
 /**
  *@author     Juozas Baliuka <a href="mailto:baliuka@mwm.lt">
  *      baliuka@mwm.lt</a>
- *@version    $Id: TestEnhancer.java,v 1.5 2002/11/30 12:41:30 baliuka Exp $
+ *@version    $Id: TestEnhancer.java,v 1.6 2002/12/01 08:40:09 baliuka Exp $
  */
 public class TestEnhancer extends TestCase {
     public void setUp() {
@@ -342,7 +342,7 @@ public void testSerializable()throws Throwable{
    public void testABC() throws Throwable{
        Enhancer.enhance(EA.class, null, TEST_INTERCEPTOR).toString();
        Enhancer.enhance(EC1.class, null, TEST_INTERCEPTOR).toString();
-       Enhancer.enhance(EB.class, null, TEST_INTERCEPTOR).toString();
+       ((EB)Enhancer.enhance(EB.class, null, TEST_INTERCEPTOR)).finalTest();
        Enhancer.enhance(ED.class, null, TEST_INTERCEPTOR).toString();
        Enhancer.enhance(ClassLoader.class, null, TEST_INTERCEPTOR).toString();
    }

File: src/proxy/net/sf/cglib/CodeGenerator.java
Patch:
@@ -798,7 +798,6 @@ protected void putfield(Field field) {
     // --------------- Invoke method ----------------
   
     protected void invoke(Method method) {
-        Class clazz = method.getDeclaringClass();
         if (method.getDeclaringClass().isInterface()) {
             invoke_interface(method);
         } else if (Modifier.isStatic(method.getModifiers())) {

File: src/proxy/net/sf/cglib/EnhancerGenerator.java
Patch:
@@ -63,7 +63,6 @@
     private static final String DELEGATE_FIELD = "CGLIB$DELEGATE";
     private static final Class[] NORMAL_ARGS = new Class[]{ MethodInterceptor.class };
     private static final Class[] DELEGATE_ARGS = new Class[]{ MethodInterceptor.class, Object.class };
-    private static int index = 0;
 
     private Class[] interfaces;
     private Method wreplace;
@@ -317,7 +316,6 @@ private static void addDeclaredMethods(List methodList, Class clazz) {
     }
 
     private void generateMethod(String fieldName, Method method, Method invokeSuper, Method afterReturn) {
-        Class[] args = method.getParameterTypes();
         Class returnType = method.getReturnType();
         boolean returnsValue = !returnType.equals(Void.TYPE);
         int mod = method.getModifiers();

File: src/proxy/net/sf/cglib/proxy/EnhancerGenerator.java
Patch:
@@ -41,7 +41,7 @@
                 
             if (!(Modifier.isPublic(mod) ||
                   Modifier.isProtected(mod) ||
-                  isVisible(construct, clazz.getPackage().getName()))) {
+                  isVisible( construct, clazz.getPackage() ))) {
                 throw new IllegalArgumentException( clazz.getName() );
             }
 
@@ -93,7 +93,7 @@ protected void generate() throws NoSuchMethodException {
         }
 
         boolean declaresWriteReplace = false;
-        String packageName = getSuperclass().getPackage().getName();
+        Package packageName = getSuperclass().getPackage();
         Map methodMap = new HashMap();
         for (Iterator it = allMethods.iterator(); it.hasNext();) {
             Method method = (Method)it.next();

File: src/test/net/sf/cglib/metaclass/TestMetaClass.java
Patch:
@@ -119,7 +119,7 @@ public void testGetInstance() throws Throwable{
     
     public void testMetaClassPerformance()throws Throwable{
     
-       int iterations = 10000;
+       int iterations = 100000;
        
        System.out.println(); 
        System.out.println("iteration count: " + iterations);

File: src/test/net/sf/cglib/TestAll.java
Patch:
@@ -58,11 +58,12 @@
 import net.sf.cglib.proxy.*;
 import net.sf.cglib.metaclass.*;
 import net.sf.cglib.delegator.*;
+import net.sf.cglib.util.*;
 
 /**
  *@author     Gerhard Froehlich <a href="mailto:g-froehlich@gmx.de">
  *      g-froehlich@gmx.de</a>
- *@version    $Id: TestAll.java,v 1.6 2002/11/11 20:28:53 herbyderby Exp $
+ *@version    $Id: TestAll.java,v 1.7 2002/11/19 00:48:15 herbyderby Exp $
  */
 public class TestAll extends TestCase {
     public TestAll(String testName) {
@@ -76,6 +77,7 @@ public static Test suite() {
         suite.addTest(TestEnhancer.suite());
         suite.addTest(TestMetaClass.suite());
         suite.addTest(TestDelegator.suite());
+        suite.addTest(TestKeyFactory.suite());
            
         return suite;
     }

File: src/proxy/net/sf/cglib/proxy/ClassFileUtils.java
Patch:
@@ -70,7 +70,9 @@ private ClassFileUtils() {
     
     static Instruction getIntConst( int i, ConstantPoolGen cp){
         
-              if( i<= 5 ){ 
+            if( i < 0  ){
+                 return new LDC( cp.addInteger(i) ); 
+            }else if( i<= 5 ){ 
                   return ( new  ICONST( i ) );
                }else  if ( i < Byte.MAX_VALUE){
                   return ( new  BIPUSH((byte)i ) ); 

File: src/test/net/sf/cglib/proxy/Source.java
Patch:
@@ -24,7 +24,7 @@ public void callAll(){
      doubleType(1.0);
      objectType("1") ;
      voidType();
-     multiArg(1,1,1,1,"");
+     multiArg(1,1,1,1,"","","");
     }
     
     protected void protectedMethod(){}
@@ -82,7 +82,7 @@ public void voidType(){
     
     } 
     public void multiArg( int arg1, long arg2, 
-                           double arg3, float arg4, Object arg5  ){
+                           double arg3, float arg4, Object arg5, Object arg6, Object arg7  ){
     
     }
     

File: src/proxy/net/sf/cglib/proxy/ClassFileConstants.java
Patch:
@@ -80,6 +80,6 @@ interface ClassFileConstants extends org.apache.bcel.Constants{
     static final ObjectType NUMBER_OBJECT = new ObjectType(Number.class.getName());
     static final String CONSTRUCTOR_NAME = "<init>";
     static final String SOURCE_FILE = "<generated>";
-  
+    static final String FIND_CLASS = "CGLIB$findClass";
      
 }

File: proposals/baliuka/src/proxy/net/sf/cglib/proxy/ClassFileUtils.java
Patch:
@@ -689,7 +689,7 @@ static boolean equals(
     
     
     
-    static boolean isVisible(java.lang.reflect.Method m ,
+    static boolean isVisible(java.lang.reflect.Member m ,
     String packageName )throws Throwable{
         
         

File: src/proxy/net/sf/cglib/proxy/ClassFileUtils.java
Patch:
@@ -689,7 +689,7 @@ static boolean equals(
     
     
     
-    static boolean isVisible(java.lang.reflect.Method m ,
+    static boolean isVisible(java.lang.reflect.Member m ,
     String packageName )throws Throwable{
         
         
@@ -710,6 +710,7 @@ static boolean isVisible(java.lang.reflect.Method m ,
         
         return ClassFileUtils.getPackageName( m.getDeclaringClass().getName()
         ).equals( packageName );
+      
     }
     
     

File: src/test/net/sf/cglib/proxy/A.java
Patch:
@@ -74,7 +74,9 @@ public void setName(String name) {
 
 	}
 
-
+   protected Object writeReplace() throws java.io.ObjectStreamException {
+     return null;
+   }
 
 }
 

File: src/test/net/sf/cglib/proxy/Source.java
Patch:
@@ -29,6 +29,8 @@ void packageMethod(){}
     
     abstract void abstractMethod();
     
+    public synchronized void synchronizedMethod(){}
+    
     public final void finalMethod(){ }
     
     public int intType(int val){

