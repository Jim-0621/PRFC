File: tck/src/main/java/org/reactivestreams/tck/TestEnvironment.java
Patch:
@@ -1112,7 +1112,7 @@ final <E extends Throwable> E expectError(Class<E> clazz, final long totalTimeou
 
         if (env.asyncErrors.isEmpty()) {
           timeStampBNs = System.nanoTime();
-          totalTimeoutRemainingNs =- timeStampBNs - timeStampANs;
+          totalTimeoutRemainingNs -= (timeStampBNs - timeStampANs);
           timeStampANs = timeStampBNs;
 
           if (totalTimeoutRemainingNs <= 0) {

File: tck/src/main/java/org/reactivestreams/tck/TestEnvironment.java
Patch:
@@ -1112,7 +1112,7 @@ final <E extends Throwable> E expectError(Class<E> clazz, final long totalTimeou
 
         if (env.asyncErrors.isEmpty()) {
           timeStampBNs = System.nanoTime();
-          totalTimeoutRemainingNs =- timeStampBNs - timeStampANs;
+          totalTimeoutRemainingNs -= (timeStampBNs - timeStampANs);
           timeStampANs = timeStampBNs;
 
           if (totalTimeoutRemainingNs <= 0) {

File: tck/src/main/java/org/reactivestreams/tck/TestEnvironment.java
Patch:
@@ -104,7 +104,7 @@ public TestEnvironment(long defaultTimeoutMillis, long defaultNoSignalsTimeoutMi
    * @param defaultNoSignalsTimeoutMillis default timeout to be used when no further signals are expected anymore
    */
   public TestEnvironment(long defaultTimeoutMillis, long defaultNoSignalsTimeoutMillis) {
-    this(defaultTimeoutMillis, defaultTimeoutMillis, defaultNoSignalsTimeoutMillis);
+    this(defaultTimeoutMillis, defaultNoSignalsTimeoutMillis, defaultTimeoutMillis);
   }
 
   /**

File: tck/src/main/java/org/reactivestreams/tck/PublisherVerification.java
Patch:
@@ -223,7 +223,7 @@ public void run(Publisher<T> pub) throws InterruptedException {
             sub.request(2);
             sub.nextElements(3, env.defaultTimeoutMillis(), String.format("Publisher %s produced less than 3 elements after two respective `request` calls", pub));
 
-            sub.expectNone(String.format("Publisher %sproduced unrequested ", pub));
+            sub.expectNone(String.format("Publisher %s produced unrequested ", pub));
         } finally {
             sub.cancel();
         }

File: tck-flow/src/test/java/org/reactivestreams/tck/flow/SyncTriggeredDemandSubscriberTest.java
Patch:
@@ -33,6 +33,7 @@ public SyncTriggeredDemandSubscriberTest() {
     super(new TestEnvironment());
   }
 
+  @Test(enabled = false)
   @Override
   public void triggerFlowRequest(Flow.Subscriber<? super Integer> subscriber) {
     ((SyncTriggeredDemandFlowSubscriber<? super Integer>) subscriber).triggerDemand(1);

File: tck/src/main/java/org/reactivestreams/tck/IdentityProcessorVerification.java
Patch:
@@ -172,7 +172,9 @@ public long boundedDepthOfOnNextAndRequestRecursion() {
 
   /**
    * Override and return {@code true} in order to skip executing tests marked as {@code Stochastic}.
-   * Such tests MAY sometimes fail even though the impl
+   * Stochastic in this case means that the Rule is impossible or infeasible to deterministically verifyâ€”
+   * usually this means that this test case can yield false positives ("be green") even if for some case,
+   * the given implementation may violate the tested behaviour.
    */
   public boolean skipStochasticTests() {
     return false;

File: tck-flow/src/main/java/org/reactivestreams/tck/flow/IdentityFlowProcessorVerification.java
Patch:
@@ -60,7 +60,9 @@ public final Processor<T, T> createIdentityProcessor(int bufferSize) {
 
   @Override
   public final Publisher<T> createFailedPublisher() {
-    return FlowAdapters.toPublisher(createFailedFlowPublisher());
+    Flow.Publisher<T> failed = createFailedFlowPublisher();
+    if (failed == null) return null; // because `null` means "SKIP" in createFailedPublisher
+    else return FlowAdapters.toPublisher(failed);
   }
 
 }

File: tck/src/main/java/org/reactivestreams/tck/TestEnvironment.java
Patch:
@@ -908,7 +908,7 @@ public void complete(T value) {
         // we add the value to the queue such to wake up any expectCompletion which was triggered before complete() was called
         abq.add(value);
       } else {
-        env.flop(String.format("Cannot complete a promise more than once! Present value: %s, attempted to set: %s", value));
+        env.flop(String.format("Cannot complete a promise more than once! Present value: %s, attempted to set: %s", _value.get(), value));
       }
     }
 

File: tck/src/main/java/org/reactivestreams/tck/TestEnvironment.java
Patch:
@@ -908,7 +908,7 @@ public void complete(T value) {
         // we add the value to the queue such to wake up any expectCompletion which was triggered before complete() was called
         abq.add(value);
       } else {
-        env.flop(String.format("Cannot complete a promise more than once! Present value: %s", value));
+        env.flop(String.format("Cannot complete a promise more than once! Present value: %s, attempted to set: %s", value));
       }
     }
 

File: tck-flow/src/main/java/org/reactivestreams/tck/flow/IdentityFlowProcessorVerification.java
Patch:
@@ -46,7 +46,7 @@ public IdentityFlowProcessorVerification(TestEnvironment env, long publisherRefe
 
   /**
    * This is the main method you must implement in your test incarnation.
-   * It must create a {@link Flow.Publisher}, which simply forwards all stream elements from its upstream
+   * It must create a {@link Flow.Processor}, which simply forwards all stream elements from its upstream
    * to its downstream. It must be able to internally buffer the given number of elements.
    *
    * @param bufferSize number of elements the processor is required to be able to buffer.

File: tck/src/main/java/org/reactivestreams/tck/IdentityProcessorVerification.java
Patch:
@@ -128,7 +128,7 @@ public boolean skipStochasticTests() {
 
   /**
    * This is the main method you must implement in your test incarnation.
-   * It must create a Publisher, which simply forwards all stream elements from its upstream
+   * It must create a {@link Processor}, which simply forwards all stream elements from its upstream
    * to its downstream. It must be able to internally buffer the given number of elements.
    *
    * @param bufferSize number of elements the processor is required to be able to buffer.

File: tck/src/main/java/org/reactivestreams/tck/IdentityProcessorVerification.java
Patch:
@@ -424,7 +424,7 @@ public void required_spec317_mustNotSignalOnErrorWhenPendingAboveLongMaxValue()
    * <p>
    * The test is not executed if {@link IdentityProcessorVerification#maxSupportedSubscribers()} is less than 2.
    * <p>
-   * If this test fails, the following could be checked within the {@code Publisher} implementation:
+   * If this test fails, the following could be checked within the {@code Processor} implementation:
    * <ul>
    * <li>The {@code TestEnvironment} has large enough timeout specified in case the {@code Processor} has some time-delay behavior.</li>
    * <li>The {@code Processor} is able to fulfill requests of its {@code Subscriber}s independently of each other's requests or
@@ -709,7 +709,7 @@ public void untested_spec316_requestMustNotThrowExceptionAndMustOnErrorTheSubscr
    * <p>
    * The test is not executed if {@link IdentityProcessorVerification#maxSupportedSubscribers()} is less than 2.
    * <p>
-   * If this test fails, the following could be checked within the {@code Publisher} implementation:
+   * If this test fails, the following could be checked within the {@code Processor} implementation:
    * <ul>
    * <li>The {@code TestEnvironment} has large enough timeout specified in case the {@code Processor} has some time-delay behavior.</li>
    * <li>The {@code Processor} is able to fulfill requests of its {@code Subscriber}s independently of each other's requests or

File: tck/src/main/java/org/reactivestreams/tck/IdentityProcessorVerification.java
Patch:
@@ -464,13 +464,13 @@ public TestSetup apply(Long aLong) throws Throwable {
 
             expectRequest(env.defaultTimeoutMillis(),
                     "If the Processor coordinates requests/emissions when having multiple Subscribers"
-                    + " at once, please override doesCoordinatedEmission() in this "
+                    + " at once, please override doesCoordinatedEmission() to return true in this "
                     + "IdentityProcessorVerification to allow this test to pass.");
 
             final T x = sendNextTFromUpstream();
             expectNextElement(sub1, x,
                     "If the Processor coordinates requests/emissions when having multiple Subscribers"
-                            + " at once, please override doesCoordinatedEmission() in this "
+                            + " at once, please override doesCoordinatedEmission() to return true in this "
                             + "IdentityProcessorVerification to allow this test to pass.");
 
             sub1.request(1);
@@ -757,7 +757,7 @@ public TestSetup apply(Long subscribers) throws Throwable {
             final T z = sendNextTFromUpstream();
             expectNextElement(sub1, z,
                     "If the Processor coordinates requests/emissions when having multiple Subscribers"
-                            + " at once, please override doesCoordinatedEmission() in this "
+                            + " at once, please override doesCoordinatedEmission() to return true in this "
                             + "IdentityProcessorVerification to allow this test to pass.");
             sub2.expectNone(); // since sub2 hasn't requested anything yet
 

File: flow-bridge/src/test/java/org/reactivestreams/SubmissionPublisherTckTest.java
Patch:
@@ -40,14 +40,14 @@ public void run() {
                 sp.close();
             }
         }).start();
-        return ReactiveStreamsFlowBridge.toReactiveStreams(sp);
+        return ReactiveStreamsFlowBridge.toPublisher(sp);
     }
 
     @Override
     public Publisher<Integer> createFailedPublisher() {
         final SubmissionPublisher<Integer> sp = new SubmissionPublisher<Integer>();
         sp.closeExceptionally(new IOException());
-        return ReactiveStreamsFlowBridge.toReactiveStreams(sp);
+        return ReactiveStreamsFlowBridge.toPublisher(sp);
     }
 
     @Override

File: tck/src/main/java/org/reactivestreams/tck/IdentityProcessorVerification.java
Patch:
@@ -19,9 +19,9 @@
 import org.reactivestreams.tck.TestEnvironment.ManualSubscriber;
 import org.reactivestreams.tck.TestEnvironment.ManualSubscriberWithSubscriptionSupport;
 import org.reactivestreams.tck.TestEnvironment.Promise;
-import org.reactivestreams.tck.support.Function;
-import org.reactivestreams.tck.support.SubscriberWhiteboxVerificationRules;
-import org.reactivestreams.tck.support.PublisherVerificationRules;
+import org.reactivestreams.tck.flow.support.Function;
+import org.reactivestreams.tck.flow.support.SubscriberWhiteboxVerificationRules;
+import org.reactivestreams.tck.flow.support.PublisherVerificationRules;
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
 

File: tck/src/main/java/org/reactivestreams/tck/PublisherVerification.java
Patch:
@@ -18,9 +18,9 @@
 import org.reactivestreams.tck.TestEnvironment.Latch;
 import org.reactivestreams.tck.TestEnvironment.ManualSubscriber;
 import org.reactivestreams.tck.TestEnvironment.ManualSubscriberWithSubscriptionSupport;
-import org.reactivestreams.tck.support.Function;
-import org.reactivestreams.tck.support.Optional;
-import org.reactivestreams.tck.support.PublisherVerificationRules;
+import org.reactivestreams.tck.flow.support.Function;
+import org.reactivestreams.tck.flow.support.Optional;
+import org.reactivestreams.tck.flow.support.PublisherVerificationRules;
 import org.testng.SkipException;
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;

File: tck/src/main/java/org/reactivestreams/tck/TestEnvironment.java
Patch:
@@ -14,8 +14,8 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import org.reactivestreams.tck.support.SubscriberBufferOverflowException;
-import org.reactivestreams.tck.support.Optional;
+import org.reactivestreams.tck.flow.support.SubscriberBufferOverflowException;
+import org.reactivestreams.tck.flow.support.Optional;
 
 import java.util.Collections;
 import java.util.LinkedList;

File: tck/src/main/java/org/reactivestreams/tck/WithHelperPublisher.java
Patch:
@@ -12,9 +12,9 @@
 package org.reactivestreams.tck;
 
 import org.reactivestreams.Publisher;
-import org.reactivestreams.tck.support.Function;
-import org.reactivestreams.tck.support.HelperPublisher;
-import org.reactivestreams.tck.support.InfiniteHelperPublisher;
+import org.reactivestreams.tck.flow.support.Function;
+import org.reactivestreams.tck.flow.support.HelperPublisher;
+import org.reactivestreams.tck.flow.support.InfiniteHelperPublisher;
 
 import java.util.concurrent.ExecutorService;
 

File: tck/src/main/java/org/reactivestreams/tck/flow/support/Function.java
Patch:
@@ -9,7 +9,7 @@
  * work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.*
  ************************************************************************/
 
-package org.reactivestreams.tck.support;
+package org.reactivestreams.tck.flow.support;
 
 public interface Function<In, Out> {
   public Out apply(In in) throws Throwable;

File: tck/src/main/java/org/reactivestreams/tck/flow/support/InfiniteHelperPublisher.java
Patch:
@@ -9,7 +9,7 @@
  * work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.*
  ************************************************************************/
 
-package org.reactivestreams.tck.support;
+package org.reactivestreams.tck.flow.support;
 
 import org.reactivestreams.example.unicast.AsyncIterablePublisher;
 

File: tck/src/main/java/org/reactivestreams/tck/flow/support/NonFatal.java
Patch:
@@ -9,7 +9,7 @@
  * work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.*
  ************************************************************************/
 
-package org.reactivestreams.tck.support;
+package org.reactivestreams.tck.flow.support;
 
 
 /**

File: tck/src/main/java/org/reactivestreams/tck/flow/support/Optional.java
Patch:
@@ -9,7 +9,7 @@
  * work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.*
  ************************************************************************/
 
-package org.reactivestreams.tck.support;
+package org.reactivestreams.tck.flow.support;
 
 import java.util.NoSuchElementException;
 

File: tck/src/main/java/org/reactivestreams/tck/flow/support/PublisherVerificationRules.java
Patch:
@@ -9,7 +9,7 @@
  * work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.*
  ************************************************************************/
 
-package org.reactivestreams.tck.support;
+package org.reactivestreams.tck.flow.support;
 
 /**
  * Internal TCK use only.

File: tck/src/main/java/org/reactivestreams/tck/flow/support/SubscriberBlackboxVerificationRules.java
Patch:
@@ -9,7 +9,7 @@
  * work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.*
  ************************************************************************/
 
-package org.reactivestreams.tck.support;
+package org.reactivestreams.tck.flow.support;
 
 import org.reactivestreams.tck.SubscriberBlackboxVerification;
 

File: tck/src/main/java/org/reactivestreams/tck/flow/support/SubscriberBufferOverflowException.java
Patch:
@@ -9,7 +9,7 @@
  * work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.*
  ************************************************************************/
 
-package org.reactivestreams.tck.support;
+package org.reactivestreams.tck.flow.support;
 
 public final class SubscriberBufferOverflowException extends RuntimeException {
   public SubscriberBufferOverflowException() {

File: tck/src/main/java/org/reactivestreams/tck/flow/support/SubscriberWhiteboxVerificationRules.java
Patch:
@@ -9,7 +9,7 @@
  * work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.*
  ************************************************************************/
 
-package org.reactivestreams.tck.support;
+package org.reactivestreams.tck.flow.support;
 
 /**
  * Internal TCK use only.

File: tck/src/main/java/org/reactivestreams/tck/flow/support/TestException.java
Patch:
@@ -9,7 +9,7 @@
  * work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.*
  ************************************************************************/
 
-package org.reactivestreams.tck.support;
+package org.reactivestreams.tck.flow.support;
 
 /**
  * Exception used by the TCK to signal failures.

File: tck/src/test/java/org/reactivestreams/tck/IdentityProcessorVerificationTest.java
Patch:
@@ -15,7 +15,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import org.reactivestreams.tck.support.TCKVerificationSupport;
+import org.reactivestreams.tck.flow.support.TCKVerificationSupport;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;

File: tck/src/test/java/org/reactivestreams/tck/PublisherVerificationTest.java
Patch:
@@ -14,8 +14,8 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import org.reactivestreams.tck.support.TCKVerificationSupport;
-import org.reactivestreams.tck.support.TestException;
+import org.reactivestreams.tck.flow.support.TCKVerificationSupport;
+import org.reactivestreams.tck.flow.support.TestException;
 import org.testng.Assert;
 import org.testng.annotations.Test;
 

File: tck/src/test/java/org/reactivestreams/tck/SubscriberBlackboxVerificationTest.java
Patch:
@@ -13,7 +13,7 @@
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
-import org.reactivestreams.tck.support.TCKVerificationSupport;
+import org.reactivestreams.tck.flow.support.TCKVerificationSupport;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;

File: tck/src/test/java/org/reactivestreams/tck/SubscriberWhiteboxVerificationTest.java
Patch:
@@ -15,8 +15,8 @@
 import org.reactivestreams.Subscription;
 import org.reactivestreams.tck.SubscriberWhiteboxVerification.SubscriberPuppet;
 import org.reactivestreams.tck.SubscriberWhiteboxVerification.WhiteboxSubscriberProbe;
-import org.reactivestreams.tck.support.Function;
-import org.reactivestreams.tck.support.TCKVerificationSupport;
+import org.reactivestreams.tck.flow.support.Function;
+import org.reactivestreams.tck.flow.support.TCKVerificationSupport;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;

File: tck/src/test/java/org/reactivestreams/tck/flow/support/SyncTriggeredDemandSubscriber.java
Patch:
@@ -9,7 +9,7 @@
  * work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.*
  ************************************************************************/
 
-package org.reactivestreams.tck.support;
+package org.reactivestreams.tck.flow.support;
 
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;

File: tck/src/test/java/org/reactivestreams/tck/flow/support/TCKVerificationSupport.java
Patch:
@@ -9,7 +9,7 @@
  * work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.*
  ************************************************************************/
 
-package org.reactivestreams.tck.support;
+package org.reactivestreams.tck.flow.support;
 
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;

File: tck/src/main/java/org/reactivestreams/tck/IdentityProcessorVerification.java
Patch:
@@ -342,8 +342,8 @@ public void untested_spec304_requestShouldNotPerformHeavyComputations() throws E
   }
 
   @Override @Test
-  public void untested_spec305_cancelMustNotSynchronouslyPerformHeavyCompuatation() throws Exception {
-    publisherVerification.untested_spec305_cancelMustNotSynchronouslyPerformHeavyCompuatation();
+  public void untested_spec305_cancelMustNotSynchronouslyPerformHeavyComputation() throws Exception {
+    publisherVerification.untested_spec305_cancelMustNotSynchronouslyPerformHeavyComputation();
   }
 
   @Override @Test

File: tck/src/main/java/org/reactivestreams/tck/PublisherVerification.java
Patch:
@@ -804,7 +804,7 @@ public void untested_spec304_requestShouldNotPerformHeavyComputations() throws E
   }
 
   @Override @Test
-  public void untested_spec305_cancelMustNotSynchronouslyPerformHeavyCompuatation() throws Exception {
+  public void untested_spec305_cancelMustNotSynchronouslyPerformHeavyComputation() throws Exception {
     notVerified(); // cannot be meaningfully tested, or can it?
   }
 

File: tck/src/main/java/org/reactivestreams/tck/support/PublisherVerificationRules.java
Patch:
@@ -420,7 +420,7 @@ public interface PublisherVerificationRules {
    * <p>
    * <b>Verifies rule:</b> <a href='https://github.com/reactive-streams/reactive-streams-jvm#3.5'>3.5</a>
    */
-  void untested_spec305_cancelMustNotSynchronouslyPerformHeavyCompuatation() throws Exception;
+  void untested_spec305_cancelMustNotSynchronouslyPerformHeavyComputation() throws Exception;
   /**
    * Asks for a short {@code Publisher} (length 3) and verifies that cancelling without requesting anything, then requesting
    * items should result in no signals to be emitted.

File: tck/src/main/java/org/reactivestreams/tck/support/PublisherVerificationRules.java
Patch:
@@ -135,7 +135,8 @@ public interface PublisherVerificationRules {
    * <li>in the {@code Publisher.subscribe(Subscriber)} method, if there is an upstream {@code Publisher},
    * that {@code Publisher} is actually subscribed to,</li>
    * <li>if the {@code Publisher} implementation is able to emit an {@code onError} without requests,</li> 
-   * <li>if the {@code Publisher} is non-empty as this test requires a {@code Publisher} without items.</li> 
+   * <li>if the {@code Publisher} is non-empty as this test requires a {@code Publisher} to signal an
+   * {@code onError} eagerly.</li> 
    * </ul>
    */
   void optional_spec104_mustSignalOnErrorWhenFails() throws Throwable;

File: tck/src/main/java/org/reactivestreams/tck/PublisherVerification.java
Patch:
@@ -885,7 +885,7 @@ public void required_spec309_requestNegativeNumberMustSignalIllegalArgumentExcep
       public void run(Publisher<T> pub) throws Throwable {
         final ManualSubscriber<T> sub = env.newManualSubscriber(pub);
         final Random r = new Random();
-        sub.request(-r.nextInt(Integer.MAX_VALUE));
+        sub.request(-r.nextInt(Integer.MAX_VALUE) - 1);
         sub.expectErrorWithMessage(IllegalArgumentException.class, "3.9"); // we do require implementations to mention the rule number at the very least
       }
     });

File: tck/src/main/java/org/reactivestreams/tck/support/PublisherVerificationRules.java
Patch:
@@ -327,6 +327,7 @@ public interface PublisherVerificationRules {
    * <p>The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 
    * {@link #required_validate_boundedDepthOfOnNextAndRequestRecursion()} plus 1.
    * <p>If this test fails, the following could be checked within the {@code Publisher} implementation:
+   * <ul>
    * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,</li>
    * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,</li>
    * <li>the implementation doesn't allow unbounded recursion when {@code request()} is called from within {@code onNext}, i.e., the lack of
@@ -352,6 +353,7 @@ public interface PublisherVerificationRules {
    * <p>The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.
    * <p>The post-cancellation request pattern is (1, 1, 1).
    * <p>If this test fails, the following could be checked within the {@code Publisher} implementation:
+   * <ul>
    * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,</li>
    * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,</li>
    * <li>the cancellation indicator flag is properly persisted (may require volatile) and checked as part of the signal emission process.</li>
@@ -364,6 +366,7 @@ public interface PublisherVerificationRules {
    * multiple times should result in no signals to be emitted and should result in an thrown exception. 
    * <p>The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 1.
    * <p>If this test fails, the following could be checked within the {@code Publisher} implementation:
+   * <ul>
    * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,</li>
    * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,</li>
    * <li>the cancellation indicator flag is properly persisted (may require volatile) and checked as part of the signal emission process.</li>

File: tck/src/test/java/org/reactivestreams/tck/RangePublisherTest.java
Patch:
@@ -46,7 +46,7 @@ public static void afterClass() {
     }
     
     public RangePublisherTest() {
-        super(new TestEnvironment(25));
+        super(new TestEnvironment());
     }
 
     @Override

File: examples/src/main/java/org/reactivestreams/example/unicast/AsyncSubscriber.java
Patch:
@@ -199,7 +199,7 @@ else if (s instanceof OnSubscribe)
             handleOnSubscribe(((OnSubscribe)s).subscription);
           else if (s instanceof OnError) // We are always able to handle OnError, obeying rule 2.10
             handleOnError(((OnError)s).error);
-          else if (s == OnComplete.Instance) // We are always able to handle OnError, obeying rule 2.9
+          else if (s == OnComplete.Instance) // We are always able to handle OnComplete, obeying rule 2.9
             handleOnComplete();
         }
       } finally {
@@ -235,4 +235,4 @@ private final void tryScheduleToExecute() {
       }
     }
   }
-}
\ No newline at end of file
+}

File: examples/src/main/java/org/reactivestreams/example/unicast/AsyncSubscriber.java
Patch:
@@ -199,7 +199,7 @@ else if (s instanceof OnSubscribe)
             handleOnSubscribe(((OnSubscribe)s).subscription);
           else if (s instanceof OnError) // We are always able to handle OnError, obeying rule 2.10
             handleOnError(((OnError)s).error);
-          else if (s == OnComplete.Instance) // We are always able to handle OnError, obeying rule 2.9
+          else if (s == OnComplete.Instance) // We are always able to handle OnComplete, obeying rule 2.9
             handleOnComplete();
         }
       } finally {
@@ -235,4 +235,4 @@ private final void tryScheduleToExecute() {
       }
     }
   }
-}
\ No newline at end of file
+}

File: tck/src/test/java/org/reactivestreams/tck/PublisherVerificationTest.java
Patch:
@@ -241,6 +241,7 @@ public void required_spec107_mustNotEmitFurtherSignalsOnceOnCompleteHasBeenSigna
                 // but keep signalling data if more demand comes in anyway!
                 if (!completed) {
                   s.onComplete();
+                  completed = true;
                 }
 
               }

File: tck/src/test/java/org/reactivestreams/tck/PublisherVerificationTest.java
Patch:
@@ -241,6 +241,7 @@ public void required_spec107_mustNotEmitFurtherSignalsOnceOnCompleteHasBeenSigna
                 // but keep signalling data if more demand comes in anyway!
                 if (!completed) {
                   s.onComplete();
+                  completed = true;
                 }
 
               }

File: examples/src/main/java/org/reactivestreams/example/unicast/AsyncSubscriber.java
Patch:
@@ -50,7 +50,7 @@ protected AsyncSubscriber(Executor executor) {
   // herefor we also need to cancel our `Subscription`.
   private final void done() {
     //On this line we could add a guard against `!done`, but since rule 3.7 says that `Subscription.cancel()` is idempotent, we don't need to.
-    done = true; // If we `foreach` throws an exception, let's consider ourselves done (not accepting more elements)
+    done = true; // If `whenNext` throws an exception, let's consider ourselves done (not accepting more elements)
     if (subscription != null) { // If we are bailing out before we got a `Subscription` there's little need for cancelling it.
       try {
         subscription.cancel(); // Cancel the subscription

File: examples/src/main/java/org/reactivestreams/example/unicast/SyncSubscriber.java
Patch:
@@ -49,7 +49,7 @@ public abstract class SyncSubscriber<T> implements Subscriber<T> {
 
       if (!done) { // If we aren't already done
         try {
-          if (foreach(element)) {
+          if (whenNext(element)) {
             try {
               subscription.request(1); // Our Subscriber is unbuffered and modest, it requests one element at a time
             } catch (final Throwable t) {
@@ -76,7 +76,7 @@ public abstract class SyncSubscriber<T> implements Subscriber<T> {
   // herefor we also need to cancel our `Subscription`.
   private void done() {
     //On this line we could add a guard against `!done`, but since rule 3.7 says that `Subscription.cancel()` is idempotent, we don't need to.
-    done = true; // If we `foreach` throws an exception, let's consider ourselves done (not accepting more elements)
+    done = true; // If we `whenNext` throws an exception, let's consider ourselves done (not accepting more elements)
     try {
       subscription.cancel(); // Cancel the subscription
     } catch(final Throwable t) {
@@ -87,7 +87,7 @@ private void done() {
 
   // This method is left as an exercise to the reader/extension point
   // Returns whether more elements are desired or not, and if no more elements are desired
-  protected abstract boolean foreach(final T element);
+  protected abstract boolean whenNext(final T element);
 
   @Override public void onError(final Throwable t) {
     if (subscription == null) { // Technically this check is not needed, since we are expecting Publishers to conform to the spec

File: examples/src/test/java/org/reactivestreams/example/unicast/SyncSubscriberTest.java
Patch:
@@ -24,7 +24,7 @@ public SyncSubscriberTest() {
   @Override public Subscriber<Integer> createSubscriber() {
     return new SyncSubscriber<Integer>() {
       private long acc;
-      @Override protected boolean foreach(final Integer element) {
+      @Override protected boolean whenNext(final Integer element) {
         acc += element;
         return true;
       }

File: examples/src/test/java/org/reactivestreams/example/unicast/SyncSubscriberWhiteboxTest.java
Patch:
@@ -62,7 +62,7 @@ public void onComplete() {
       }
 
       @Override
-      protected boolean foreach(Integer element) {
+      protected boolean whenNext(Integer element) {
         return true;
       }
     };

File: tck/src/test/java/org/reactivestreams/tck/support/SyncTriggeredDemandSubscriber.java
Patch:
@@ -7,7 +7,7 @@
  * SyncTriggeredDemandSubscriber is an implementation of Reactive Streams `Subscriber`,
  * it runs synchronously (on the Publisher's thread) and requests demand triggered from
  * "the outside" using its `triggerDemand` method and from "the inside" using the return
- * value of its user-defined `foreach` method which is invoked to process each element.
+ * value of its user-defined `whenNext` method which is invoked to process each element.
  *
  * NOTE: The code below uses a lot of try-catches to show the reader where exceptions can be expected, and where they are forbidden.
  */
@@ -85,7 +85,7 @@ else if (need == 0) {}
   // herefor we also need to cancel our `Subscription`.
   private void done() {
     //On this line we could add a guard against `!done`, but since rule 3.7 says that `Subscription.cancel()` is idempotent, we don't need to.
-    done = true; // If we `foreach` throws an exception, let's consider ourselves done (not accepting more elements)
+    done = true; // If we `whenNext` throws an exception, let's consider ourselves done (not accepting more elements)
     try {
       subscription.cancel(); // Cancel the subscription
     } catch(final Throwable t) {

File: tck/src/main/java/org/reactivestreams/tck/SubscriberWhiteboxVerification.java
Patch:
@@ -488,7 +488,7 @@ public void subscriberTest(TestStageTestRun body) throws Throwable {
 
   /**
    * Provides a {@link WhiteboxTestStage} without performing any additional setup,
-   * like the {@link org.reactivestreams.tck.SubscriberWhiteboxVerification#subscriberTest(TestStageTestRun)} would.
+   * like the {@link #subscriberTest(SubscriberWhiteboxVerification.TestStageTestRun)} would.
    *
    * Use this method to write tests in which you need full control over when and how the initial {@code subscribe} is signalled.
    */

File: tck/src/test/java/org/reactivestreams/tck/IdentityProcessorVerificationDelegationTest.java
Patch:
@@ -1,12 +1,13 @@
 package org.reactivestreams.tck;
 
-import org.testng.AssertJUnit;
 import org.testng.annotations.Test;
 
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.List;
 
+import static org.testng.AssertJUnit.assertTrue;
+
 /**
  * The {@link org.reactivestreams.tck.IdentityProcessorVerification} must also run all tests from
  * {@link org.reactivestreams.tck.PublisherVerification} and {@link org.reactivestreams.tck.SubscriberWhiteboxVerification}.
@@ -52,7 +53,7 @@ private void assertSuiteDelegatedAllTests(Class<?> delegatingFrom, List<String>
           delegatingFrom,
           targetTest, targetClass.getSimpleName(), targetTest);
 
-      AssertJUnit.assertTrue(msg, testsInclude(allTests, targetTest));
+      assertTrue(msg, testsInclude(allTests, targetTest));
     }
   }
 

File: tck/src/main/java/org/reactivestreams/tck/IdentityProcessorVerification.java
Patch:
@@ -518,7 +518,7 @@ public void untested_spec204_mustConsiderTheSubscriptionAsCancelledInAfterReciev
   }
 
   @Override @Test
-  public void required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Exception {
+  public void required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Throwable {
     subscriberVerification.required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal();
   }
 

File: tck/src/main/java/org/reactivestreams/tck/support/SubscriberWhiteboxVerificationRules.java
Patch:
@@ -11,7 +11,7 @@ public interface SubscriberWhiteboxVerificationRules {
   void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnComplete() throws Throwable;
   void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnError() throws Throwable;
   void untested_spec204_mustConsiderTheSubscriptionAsCancelledInAfterRecievingOnCompleteOrOnError() throws Exception;
-  void required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Exception;
+  void required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Throwable;
   void untested_spec206_mustCallSubscriptionCancelIfItIsNoLongerValid() throws Exception;
   void untested_spec207_mustEnsureAllCallsOnItsSubscriptionTakePlaceFromTheSameThreadOrTakeCareOfSynchronization() throws Exception;
   void required_spec208_mustBePreparedToReceiveOnNextSignalsAfterHavingCalledSubscriptionCancel() throws Throwable;

File: tck/src/test/java/org/reactivestreams/tck/SubscriberWhiteboxVerificationTest.java
Patch:
@@ -162,7 +162,7 @@ public Subscriber<Integer> apply(WhiteboxSubscriberProbe<Integer> probe) throws
           }
         }).required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal();
       }
-    }, "illegally accepted a second Subscription");
+    }, "Expected 2nd Subscription given to subscriber to be cancelled");
   }
 
   @Test

File: examples/src/test/java/org/reactivestreams/example/unicast/IterablePublisherTest.java
Patch:
@@ -30,7 +30,7 @@ public IterablePublisherTest() {
     return new NumberIterablePublisher(0, (int)elements, e);
   }
 
-  @Override public Publisher<Integer> createErrorStatePublisher() {
+  @Override public Publisher<Integer> createFailedPublisher() {
     return new AsyncIterablePublisher<Integer>(new Iterable<Integer>() {
       @Override public Iterator<Integer> iterator() {
         throw new RuntimeException("Error state signal!");

File: examples/src/test/java/org/reactivestreams/example/unicast/UnboundedIntegerIncrementPublisherTest.java
Patch:
@@ -25,7 +25,7 @@ public UnboundedIntegerIncrementPublisherTest() {
     return new InfiniteIncrementNumberPublisher(e);
   }
 
-  @Override public Publisher<Integer> createErrorStatePublisher() {
+  @Override public Publisher<Integer> createFailedPublisher() {
     return new AsyncIterablePublisher<Integer>(new Iterable<Integer>() {
       @Override public Iterator<Integer> iterator() {
         throw new RuntimeException("Error state signal!");

File: tck/src/test/java/org/reactivestreams/tck/EmptyLazyPublisherTest.java
Patch:
@@ -31,7 +31,7 @@ public Publisher<Integer> createPublisher(long elements) {
   }
 
   @Override
-  public Publisher<Integer> createErrorStatePublisher() {
+  public Publisher<Integer> createFailedPublisher() {
     return null;
   }
 

File: tck/src/test/java/org/reactivestreams/tck/IdentityProcessorVerificationTest.java
Patch:
@@ -41,7 +41,7 @@ public void required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANo
             return SKIP;
           }
 
-          @Override public Publisher<Integer> createErrorStatePublisher() {
+          @Override public Publisher<Integer> createFailedPublisher() {
             return SKIP;
           }
 
@@ -107,7 +107,7 @@ public void required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANo
             };
           }
 
-          @Override public Publisher<Integer> createErrorStatePublisher() {
+          @Override public Publisher<Integer> createFailedPublisher() {
             return SKIP;
           }
         }.required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANonRecoverableError();

File: tck/src/test/java/org/reactivestreams/tck/SingleElementPublisherTest.java
Patch:
@@ -31,7 +31,7 @@ public Publisher<Integer> createPublisher(long elements) {
   }
 
   @Override
-  public Publisher<Integer> createErrorStatePublisher() {
+  public Publisher<Integer> createFailedPublisher() {
     return null;
   }
 

File: tck/src/main/java/org/reactivestreams/tck/IdentityProcessorVerification.java
Patch:
@@ -514,7 +514,7 @@ public void untested_spec204_mustConsiderTheSubscriptionAsCancelledInAfterReciev
   }
 
   @Override @Test
-  public void required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Exception {
+  public void required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Throwable {
     subscriberVerification.required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal();
   }
 

File: tck/src/main/java/org/reactivestreams/tck/support/SubscriberWhiteboxVerificationRules.java
Patch:
@@ -11,7 +11,7 @@ public interface SubscriberWhiteboxVerificationRules {
   void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnComplete() throws Throwable;
   void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnError() throws Throwable;
   void untested_spec204_mustConsiderTheSubscriptionAsCancelledInAfterRecievingOnCompleteOrOnError() throws Exception;
-  void required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Exception;
+  void required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Throwable;
   void untested_spec206_mustCallSubscriptionCancelIfItIsNoLongerValid() throws Exception;
   void untested_spec207_mustEnsureAllCallsOnItsSubscriptionTakePlaceFromTheSameThreadOrTakeCareOfSynchronization() throws Exception;
   void required_spec208_mustBePreparedToReceiveOnNextSignalsAfterHavingCalledSubscriptionCancel() throws Throwable;

File: tck/src/test/java/org/reactivestreams/tck/SubscriberWhiteboxVerificationTest.java
Patch:
@@ -162,7 +162,7 @@ public Subscriber<Integer> apply(WhiteboxSubscriberProbe<Integer> probe) throws
           }
         }).required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal();
       }
-    }, "illegally accepted a second Subscription");
+    }, "Expected 2nd Subscription given to subscriber to be cancelled");
   }
 
   @Test

File: examples/src/main/java/org/reactivestreams/example/unicast/AsyncSubscriber.java
Patch:
@@ -94,7 +94,7 @@ private final void handleOnSubscribe(final Subscription s) {
         s.request(1); // Our Subscriber is unbuffered and modest, it requests one element at a time
       } catch(final Throwable t) {
         // Subscription.request is not allowed to throw according to rule 3.16
-        (new IllegalStateException(s + " violated the Reactive Streams rule 3.16 by throwing an exception from cancel.", t)).printStackTrace(System.err);
+        (new IllegalStateException(s + " violated the Reactive Streams rule 3.16 by throwing an exception from request.", t)).printStackTrace(System.err);
       }
     }
   }
@@ -111,7 +111,7 @@ private final void handleOnNext(final T element) {
               subscription.request(1); // Our Subscriber is unbuffered and modest, it requests one element at a time
             } catch(final Throwable t) {
               // Subscription.request is not allowed to throw according to rule 3.16
-              (new IllegalStateException(subscription + " violated the Reactive Streams rule 3.16 by throwing an exception from cancel.", t)).printStackTrace(System.err);
+              (new IllegalStateException(subscription + " violated the Reactive Streams rule 3.16 by throwing an exception from request.", t)).printStackTrace(System.err);
             }
           } else {
             done(); // This is legal according to rule 2.6

File: examples/src/main/java/org/reactivestreams/example/unicast/SyncSubscriber.java
Patch:
@@ -35,7 +35,7 @@ public abstract class SyncSubscriber<T> implements Subscriber<T> {
         s.request(1); // Our Subscriber is unbuffered and modest, it requests one element at a time
       } catch(final Throwable t) {
         // Subscription.request is not allowed to throw according to rule 3.16
-        (new IllegalStateException(s + " violated the Reactive Streams rule 3.16 by throwing an exception from cancel.", t)).printStackTrace(System.err);
+        (new IllegalStateException(s + " violated the Reactive Streams rule 3.16 by throwing an exception from request.", t)).printStackTrace(System.err);
       }
     }
   }
@@ -54,7 +54,7 @@ public abstract class SyncSubscriber<T> implements Subscriber<T> {
               subscription.request(1); // Our Subscriber is unbuffered and modest, it requests one element at a time
             } catch (final Throwable t) {
               // Subscription.request is not allowed to throw according to rule 3.16
-              (new IllegalStateException(subscription + " violated the Reactive Streams rule 3.16 by throwing an exception from cancel.", t)).printStackTrace(System.err);
+              (new IllegalStateException(subscription + " violated the Reactive Streams rule 3.16 by throwing an exception from request.", t)).printStackTrace(System.err);
             }
           } else {
             done();

File: examples/src/test/java/org/reactivestreams/example/unicast/IterablePublisherTest.java
Patch:
@@ -30,7 +30,7 @@ public IterablePublisherTest() {
     return new NumberIterablePublisher(0, (int)elements, e);
   }
 
-  @Override public Publisher<Integer> createErrorStatePublisher() {
+  @Override public Publisher<Integer> createFailedPublisher() {
     return new AsyncIterablePublisher<Integer>(new Iterable<Integer>() {
       @Override public Iterator<Integer> iterator() {
         throw new RuntimeException("Error state signal!");

File: examples/src/test/java/org/reactivestreams/example/unicast/UnboundedIntegerIncrementPublisherTest.java
Patch:
@@ -25,7 +25,7 @@ public UnboundedIntegerIncrementPublisherTest() {
     return new InfiniteIncrementNumberPublisher(e);
   }
 
-  @Override public Publisher<Integer> createErrorStatePublisher() {
+  @Override public Publisher<Integer> createFailedPublisher() {
     return new AsyncIterablePublisher<Integer>(new Iterable<Integer>() {
       @Override public Iterator<Integer> iterator() {
         throw new RuntimeException("Error state signal!");

File: tck/src/test/java/org/reactivestreams/tck/EmptyLazyPublisherTest.java
Patch:
@@ -31,7 +31,7 @@ public Publisher<Integer> createPublisher(long elements) {
   }
 
   @Override
-  public Publisher<Integer> createErrorStatePublisher() {
+  public Publisher<Integer> createFailedPublisher() {
     return null;
   }
 

File: tck/src/test/java/org/reactivestreams/tck/IdentityProcessorVerificationTest.java
Patch:
@@ -41,7 +41,7 @@ public void required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANo
             return SKIP;
           }
 
-          @Override public Publisher<Integer> createErrorStatePublisher() {
+          @Override public Publisher<Integer> createFailedPublisher() {
             return SKIP;
           }
 
@@ -107,7 +107,7 @@ public void required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANo
             };
           }
 
-          @Override public Publisher<Integer> createErrorStatePublisher() {
+          @Override public Publisher<Integer> createFailedPublisher() {
             return SKIP;
           }
         }.required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANonRecoverableError();

File: tck/src/test/java/org/reactivestreams/tck/SingleElementPublisherTest.java
Patch:
@@ -31,7 +31,7 @@ public Publisher<Integer> createPublisher(long elements) {
   }
 
   @Override
-  public Publisher<Integer> createErrorStatePublisher() {
+  public Publisher<Integer> createFailedPublisher() {
     return null;
   }
 

File: tck/src/test/java/org/reactivestreams/tck/PublisherVerificationTest.java
Patch:
@@ -264,7 +264,7 @@ public void required_spec109_subscribeThrowNPEOnNullSubscriber_shouldFailIfDoesn
   }
 
   @Test
-  public void optional_spec109_mayRejectCallsToSubscribeIfPublisherIsUnableOrUnwillingToServeThemRejectionMustTriggerOnErrorAfterOnSubscribe_actuallyPass() throws Throwable {
+  public void required_spec109_mayRejectCallsToSubscribeIfPublisherIsUnableOrUnwillingToServeThemRejectionMustTriggerOnErrorAfterOnSubscribe_actuallyPass() throws Throwable {
     customPublisherVerification(SKIP, new Publisher<Integer>() {
       @Override public void subscribe(Subscriber<? super Integer> s) {
         s.onSubscribe(new NoopSubscription());

File: tck/src/main/java/org/reactivestreams/tck/PublisherVerification.java
Patch:
@@ -549,7 +549,7 @@ public void run(Publisher<T> pub) throws Throwable {
     });
   }
 
-  // Verifies rule: https://github.com/reactive-streams/reactive-streams#1.12
+  // Verifies rule: https://github.com/reactive-streams/reactive-streams#1.11
   @Override @Test
   public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingOneByOne() throws Throwable {
     optionalActivePublisherTest(5, true, new PublisherTestRun<T>() { // This test is skipped if the publisher is unbounded (never sends onComplete)
@@ -600,7 +600,7 @@ public void run(Publisher<T> pub) throws InterruptedException {
     });
   }
 
-  // Verifies rule: https://github.com/reactive-streams/reactive-streams#1.12
+  // Verifies rule: https://github.com/reactive-streams/reactive-streams#1.11
   @Override @Test
   public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfront() throws Throwable {
     optionalActivePublisherTest(3, false, new PublisherTestRun<T>() { // This test is skipped if the publisher cannot produce enough elements
@@ -633,7 +633,7 @@ public void run(Publisher<T> pub) throws Throwable {
     });
   }
 
-  // Verifies rule: https://github.com/reactive-streams/reactive-streams#1.12
+  // Verifies rule: https://github.com/reactive-streams/reactive-streams#1.11
   @Override @Test
   public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfrontAndCompleteAsExpected() throws Throwable {
     optionalActivePublisherTest(3, true, new PublisherTestRun<T>() { // This test is skipped if the publisher is unbounded (never sends onComplete)

File: tck/src/test/java/org/reactivestreams/tck/PublisherVerificationTest.java
Patch:
@@ -264,7 +264,7 @@ public void required_spec109_subscribeThrowNPEOnNullSubscriber_shouldFailIfDoesn
   }
 
   @Test
-  public void optional_spec109_mayRejectCallsToSubscribeIfPublisherIsUnableOrUnwillingToServeThemRejectionMustTriggerOnErrorAfterOnSubscribe_actuallyPass() throws Throwable {
+  public void required_spec109_mayRejectCallsToSubscribeIfPublisherIsUnableOrUnwillingToServeThemRejectionMustTriggerOnErrorAfterOnSubscribe_actuallyPass() throws Throwable {
     customPublisherVerification(SKIP, new Publisher<Integer>() {
       @Override public void subscribe(Subscriber<? super Integer> s) {
         s.onSubscribe(new NoopSubscription());

File: examples/src/main/java/org/reactivestreams/example/unicast/AsyncIterablePublisher.java
Patch:
@@ -106,7 +106,7 @@ private void doSubscribe() {
         if (iterator == null)
           iterator = Collections.<T>emptyList().iterator(); // So we can assume that `iterator` is never null
       } catch(final Throwable t) {
-        terminateDueTo(t); // Here we send onError, obeying rule 1.12
+        terminateDueTo(t); // Here we send onError, obeying rule 1.09
       }
 
       if (!cancelled) {
@@ -177,7 +177,7 @@ private void terminateDueTo(final Throwable t) {
       cancelled = true; // When we signal onError, the subscription must be considered as cancelled, as per rule 1.6
       try {
         subscriber.onError(t); // Then we signal the error downstream, to the `Subscriber`
-      } catch(final Throwable t2) { // If `onError` throws an exception, this is a spec violation according to rule 1.13, and all we can do is to log it.
+      } catch(final Throwable t2) { // If `onError` throws an exception, this is a spec violation according to rule 1.12, and all we can do is to log it.
         (new IllegalStateException(subscriber + " violated the Reactive Streams rule 2.13 by throwing an exception from onError.", t2)).printStackTrace(System.err);
       }
     }

File: examples/src/main/java/org/reactivestreams/example/unicast/AsyncIterablePublisher.java
Patch:
@@ -106,7 +106,7 @@ private void doSubscribe() {
         if (iterator == null)
           iterator = Collections.<T>emptyList().iterator(); // So we can assume that `iterator` is never null
       } catch(final Throwable t) {
-        terminateDueTo(t); // Here we send onError, obeying rule 1.12
+        terminateDueTo(t); // Here we send onError, obeying rule 1.09
       }
 
       if (!cancelled) {
@@ -177,7 +177,7 @@ private void terminateDueTo(final Throwable t) {
       cancelled = true; // When we signal onError, the subscription must be considered as cancelled, as per rule 1.6
       try {
         subscriber.onError(t); // Then we signal the error downstream, to the `Subscriber`
-      } catch(final Throwable t2) { // If `onError` throws an exception, this is a spec violation according to rule 1.13, and all we can do is to log it.
+      } catch(final Throwable t2) { // If `onError` throws an exception, this is a spec violation according to rule 1.12, and all we can do is to log it.
         (new IllegalStateException(subscriber + " violated the Reactive Streams rule 2.13 by throwing an exception from onError.", t2)).printStackTrace(System.err);
       }
     }

File: tck/src/main/java/org/reactivestreams/tck/IdentityProcessorVerification.java
Patch:
@@ -362,8 +362,8 @@ public void required_spec317_mustSupportACumulativePendingElementCountUpToLongMa
   }
 
   @Override @Test
-  public void required_spec317_mustSignalOnErrorWhenPendingAboveLongMaxValue() throws Throwable {
-    publisherVerification.required_spec317_mustSignalOnErrorWhenPendingAboveLongMaxValue();
+  public void required_spec317_mustNotSignalOnErrorWhenPendingAboveLongMaxValue() throws Throwable {
+    publisherVerification.required_spec317_mustNotSignalOnErrorWhenPendingAboveLongMaxValue();
   }
 
   // Verifies rule: https://github.com/reactive-streams/reactive-streams#1.4

File: tck/src/main/java/org/reactivestreams/tck/support/PublisherVerificationRules.java
Patch:
@@ -39,5 +39,5 @@ public interface PublisherVerificationRules {
   void required_spec313_cancelMustMakeThePublisherEventuallyDropAllReferencesToTheSubscriber() throws Throwable;
   void required_spec317_mustSupportAPendingElementCountUpToLongMaxValue() throws Throwable;
   void required_spec317_mustSupportACumulativePendingElementCountUpToLongMaxValue() throws Throwable;
-  void required_spec317_mustSignalOnErrorWhenPendingAboveLongMaxValue() throws Throwable;
+  void required_spec317_mustNotSignalOnErrorWhenPendingAboveLongMaxValue() throws Throwable;
 }
\ No newline at end of file

File: tck/src/main/java/org/reactivestreams/tck/TestEnvironment.java
Patch:
@@ -62,7 +62,7 @@ public TestEnvironment(long defaultTimeoutMillis) {
    * run the tests.
    *
    * The default timeout for all expect* methods will be obtained by either the env variable {@code DEFAULT_TIMEOUT_MILLIS}
-   * or the default value ({@see TestEnvironment#DEFAULT_TIMEOUT_MILLIS}) will be used.
+   * or the default value ({@link TestEnvironment#DEFAULT_TIMEOUT_MILLIS}) will be used.
    *
    * @param printlnDebug if true, signals such as OnNext / Request / OnComplete etc will be printed to standard output,
    *                     often helpful to pinpoint simple race conditions etc.
@@ -78,7 +78,7 @@ public TestEnvironment(boolean printlnDebug) {
    * run the tests.
    *
    * The default timeout for all expect* methods will be obtained by either the env variable {@code DEFAULT_TIMEOUT_MILLIS}
-   * or the default value ({@see TestEnvironment#DEFAULT_TIMEOUT_MILLIS}) will be used.
+   * or the default value ({@link TestEnvironment#DEFAULT_TIMEOUT_MILLIS}) will be used.
    */
   public TestEnvironment() {
     this(envDefaultTimeoutMillis());

File: tck/src/main/java/org/reactivestreams/tck/WithHelperPublisher.java
Patch:
@@ -23,11 +23,11 @@ public abstract class WithHelperPublisher<T> {
    * Implement this method to match your expected element type.
    * In case of implementing a simple Subscriber which is able to consume any kind of element simply return the
    * incoming {@code element} element.
-   * <p/>
+   * <p>
    * Sometimes the Subscriber may be limited in what type of element it is able to consume, this you may have to implement
    * this method such that the emitted element matches the Subscribers requirements. Simplest implementations would be
    * to simply pass in the {@code element} as payload of your custom element, such as appending it to a String or other identifier.
-   * <p/>
+   * <p>
    * <b>Warning:</b> This method may be called concurrently by the helper publisher, thus it should be implemented in a
    * thread-safe manner.
    *

File: tck/src/main/java/org/reactivestreams/tck/TestEnvironment.java
Patch:
@@ -62,7 +62,7 @@ public TestEnvironment(long defaultTimeoutMillis) {
    * run the tests.
    *
    * The default timeout for all expect* methods will be obtained by either the env variable {@code DEFAULT_TIMEOUT_MILLIS}
-   * or the default value ({@see TestEnvironment#DEFAULT_TIMEOUT_MILLIS}) will be used.
+   * or the default value ({@link TestEnvironment#DEFAULT_TIMEOUT_MILLIS}) will be used.
    *
    * @param printlnDebug if true, signals such as OnNext / Request / OnComplete etc will be printed to standard output,
    *                     often helpful to pinpoint simple race conditions etc.
@@ -78,7 +78,7 @@ public TestEnvironment(boolean printlnDebug) {
    * run the tests.
    *
    * The default timeout for all expect* methods will be obtained by either the env variable {@code DEFAULT_TIMEOUT_MILLIS}
-   * or the default value ({@see TestEnvironment#DEFAULT_TIMEOUT_MILLIS}) will be used.
+   * or the default value ({@link TestEnvironment#DEFAULT_TIMEOUT_MILLIS}) will be used.
    */
   public TestEnvironment() {
     this(envDefaultTimeoutMillis());

File: tck/src/main/java/org/reactivestreams/tck/WithHelperPublisher.java
Patch:
@@ -23,11 +23,11 @@ public abstract class WithHelperPublisher<T> {
    * Implement this method to match your expected element type.
    * In case of implementing a simple Subscriber which is able to consume any kind of element simply return the
    * incoming {@code element} element.
-   * <p/>
+   * <p>
    * Sometimes the Subscriber may be limited in what type of element it is able to consume, this you may have to implement
    * this method such that the emitted element matches the Subscribers requirements. Simplest implementations would be
    * to simply pass in the {@code element} as payload of your custom element, such as appending it to a String or other identifier.
-   * <p/>
+   * <p>
    * <b>Warning:</b> This method may be called concurrently by the helper publisher, thus it should be implemented in a
    * thread-safe manner.
    *

File: examples/src/test/java/org/reactivestreams/example/unicast/AsyncSubscriberTest.java
Patch:
@@ -60,7 +60,4 @@ public AsyncSubscriberTest() {
     return element;
   }
 
-  @Override public Publisher<Integer> createHelperPublisher(long elements) {
-    return super.createHelperPublisher(elements);
-  }
 }

File: tck/src/main/java/org/reactivestreams/tck/WithHelperPublisher.java
Patch:
@@ -38,9 +38,8 @@ public abstract class WithHelperPublisher<T> {
   /**
    * Helper method required for creating the Publisher to which the tested Subscriber will be subscribed and tested against.
    * <p>
-   * By default an <b>asynchronously signalling Publisher</b> is provided, which will use
-   * {@link org.reactivestreams.tck.SubscriberBlackboxVerification#createElement(int)} to generate elements type
-   * your Subscriber is able to consume.
+   * By default an <b>asynchronously signalling Publisher</b> is provided, which will use {@link #createElement(int)}
+   * to generate elements type your Subscriber is able to consume.
    * <p>
    * Sometimes you may want to implement your own custom custom helper Publisher - to validate behaviour of a Subscriber
    * when facing a synchronous Publisher for example. If you do, it MUST emit the exact number of elements asked for

File: examples/src/test/java/org/reactivestreams/example/unicast/AsyncSubscriberTest.java
Patch:
@@ -17,14 +17,13 @@
 
 @Test // Must be here for TestNG to find and run this, do not remove
 public class AsyncSubscriberTest extends SubscriberBlackboxVerification<Integer> {
-  final static long DEFAULT_TIMEOUT_MILLIS = 100;
 
   private ExecutorService e;
   @BeforeClass void before() { e = Executors.newFixedThreadPool(4); }
   @AfterClass void after() { if (e != null) e.shutdown(); }
 
   public AsyncSubscriberTest() {
-    super(new TestEnvironment(DEFAULT_TIMEOUT_MILLIS));
+    super(new TestEnvironment());
   }
 
   @Override public Subscriber<Integer> createSubscriber() {
@@ -53,7 +52,7 @@ public AsyncSubscriberTest() {
     };
 
     new NumberIterablePublisher(0, 10, e).subscribe(sub);
-    latch.await(DEFAULT_TIMEOUT_MILLIS * 10, TimeUnit.MILLISECONDS);
+    latch.await(env.defaultTimeoutMillis() * 10, TimeUnit.MILLISECONDS);
     assertEquals(i.get(), 45);
   }
 

File: examples/src/test/java/org/reactivestreams/example/unicast/SyncSubscriberTest.java
Patch:
@@ -13,14 +13,12 @@
 @Test // Must be here for TestNG to find and run this, do not remove
 public class SyncSubscriberTest extends SubscriberBlackboxVerification<Integer> {
 
-  final static long DefaultTimeoutMillis = 100;
-
   private ExecutorService e;
   @BeforeClass void before() { e = Executors.newFixedThreadPool(4); }
   @AfterClass void after() { if (e != null) e.shutdown(); }
 
   public SyncSubscriberTest() {
-    super(new TestEnvironment(DefaultTimeoutMillis));
+    super(new TestEnvironment());
   }
 
   @Override public Subscriber<Integer> createSubscriber() {

File: examples/src/test/java/org/reactivestreams/example/unicast/UnboundedIntegerIncrementPublisherTest.java
Patch:
@@ -11,15 +11,13 @@
 
 @Test // Must be here for TestNG to find and run this, do not remove
 public class UnboundedIntegerIncrementPublisherTest extends PublisherVerification<Integer> {
-  final static long DefaultTimeoutMillis = 200;
-  final static long PublisherReferenceGCTimeoutMillis = 500;
 
   private ExecutorService e;
   @BeforeClass void before() { e = Executors.newFixedThreadPool(4); }
   @AfterClass void after() { if (e != null) e.shutdown(); }
 
   public UnboundedIntegerIncrementPublisherTest() {
-    super(new TestEnvironment(DefaultTimeoutMillis), PublisherReferenceGCTimeoutMillis);
+    super(new TestEnvironment());
   }
 
   @Override public Publisher<Integer> createPublisher(long elements) {

File: tck/src/main/java/org/reactivestreams/tck/SubscriberBlackboxVerification.java
Patch:
@@ -6,8 +6,8 @@
 import org.reactivestreams.tck.TestEnvironment.ManualPublisher;
 import org.reactivestreams.tck.TestEnvironment.ManualSubscriber;
 import org.reactivestreams.tck.support.Optional;
-import org.reactivestreams.tck.support.TestException;
 import org.reactivestreams.tck.support.SubscriberBlackboxVerificationRules;
+import org.reactivestreams.tck.support.TestException;
 import org.testng.SkipException;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
@@ -16,7 +16,6 @@
 
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.concurrent.atomic.AtomicBoolean;
 
 import static org.reactivestreams.tck.SubscriberWhiteboxVerification.BlackboxSubscriberProxy;
 
@@ -34,7 +33,7 @@
 public abstract class SubscriberBlackboxVerification<T> extends WithHelperPublisher<T> 
   implements SubscriberBlackboxVerificationRules {
 
-  private final TestEnvironment env;
+  protected final TestEnvironment env;
 
   protected SubscriberBlackboxVerification(TestEnvironment env) {
     this.env = env;

File: tck/src/test/java/org/reactivestreams/tck/IdentityProcessorVerificationTest.java
Patch:
@@ -18,7 +18,7 @@
 */
 public class IdentityProcessorVerificationTest extends TCKVerificationSupport {
 
-  static final int DEFAULT_TIMEOUT_MILLIS = 100;
+  static final long DEFAULT_TIMEOUT_MILLIS = TestEnvironment.envDefaultTimeoutMillis();
 
   private ExecutorService ex;
   @BeforeClass void before() { ex = Executors.newFixedThreadPool(4); }

File: tck/src/test/java/org/reactivestreams/tck/SubscriberBlackboxVerificationTest.java
Patch:
@@ -16,8 +16,6 @@
 */
 public class SubscriberBlackboxVerificationTest extends TCKVerificationSupport {
 
-  static final int DEFAULT_TIMEOUT_MILLIS = 100;
-
   private ExecutorService ex;
   @BeforeClass void before() { ex = Executors.newFixedThreadPool(4); }
   @AfterClass void after() { if (ex != null) ex.shutdown(); }
@@ -223,7 +221,7 @@ static class KeepSubscriptionSubscriber extends NoopSubscriber {
   }
 
   private TestEnvironment newTestEnvironment() {
-    return new TestEnvironment(DEFAULT_TIMEOUT_MILLIS);
+    return new TestEnvironment();
   }
 
 }

File: tck/src/test/java/org/reactivestreams/tck/SubscriberWhiteboxVerificationTest.java
Patch:
@@ -20,8 +20,6 @@
  */
 public class SubscriberWhiteboxVerificationTest extends TCKVerificationSupport {
 
-  static final int DEFAULT_TIMEOUT_MILLIS = 100;
-
   private ExecutorService ex;
   @BeforeClass void before() { ex = Executors.newFixedThreadPool(4); }
   @AfterClass void after() { if (ex != null) ex.shutdown(); }
@@ -411,7 +409,7 @@ public SimpleSubscriberWithProbe(WhiteboxSubscriberProbe<Integer> probe) {
   }
 
   private TestEnvironment newTestEnvironment() {
-    return new TestEnvironment(DEFAULT_TIMEOUT_MILLIS);
+    return new TestEnvironment();
   }
 
 }

File: examples/src/main/java/org/reactivestreams/example/unicast/AsyncSubscriber.java
Patch:
@@ -1,6 +1,5 @@
 package org.reactivestreams.example.unicast;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 

File: examples/src/main/java/org/reactivestreams/example/unicast/SyncSubscriber.java
Patch:
@@ -1,6 +1,5 @@
 package org.reactivestreams.example.unicast;
 
-import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 

File: examples/src/test/java/org/reactivestreams/example/unicast/AsyncSubscriberTest.java
Patch:
@@ -60,7 +60,7 @@ public AsyncSubscriberTest() {
       }
     };
 
-    new NumberIterablePublisher<Integer>(0, 10, e).subscribe(sub);
+    new NumberIterablePublisher(0, 10, e).subscribe(sub);
     latch.await(DefaultTimeoutMillis * 10, TimeUnit.MILLISECONDS);
     assertEquals(i.get(), 45);
   }

File: examples/src/main/java/org/reactivestreams/example/unicast/AsyncIterablePublisher.java
Patch:
@@ -14,10 +14,10 @@
  * AsyncIterablePublisher is an implementation of Reactive Streams `Publisher`
  * which executes asynchronously, using a provided `Executor` and produces elements
  * from a given `Iterable` in a "unicast" configuration to its `Subscribers`.
- 
+ *
  * NOTE: The code below uses a lot of try-catches to show the reader where exceptions can be expected, and where they are forbidden.
  */
-class AsyncIterablePublisher<T> implements Publisher<T> {
+public class AsyncIterablePublisher<T> implements Publisher<T> {
   private final static int DEFAULT_BATCHSIZE = 1024;
 
   private final Iterable<T> elements; // This is our data source / generator

File: examples/src/main/java/org/reactivestreams/example/unicast/InfiniteIncrementNumberPublisher.java
Patch:
@@ -7,7 +7,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Publisher;
 
-class InfiniteIncrementNumberPublisher extends AsyncIterablePublisher<Integer> {
+public class InfiniteIncrementNumberPublisher extends AsyncIterablePublisher<Integer> {
     public InfiniteIncrementNumberPublisher(final Executor executor) {
         super(new Iterable<Integer>() {
           @Override public Iterator<Integer> iterator() {

File: examples/src/main/java/org/reactivestreams/example/unicast/NumberIterablePublisher.java
Patch:
@@ -7,7 +7,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Publisher;
 
-class NumberIterablePublisher<T> extends AsyncIterablePublisher<Integer> {
+public class NumberIterablePublisher extends AsyncIterablePublisher<Integer> {
     public NumberIterablePublisher(final int from, final int to, final Executor executor) {
         super(new Iterable<Integer>() {
           { if(from > to) throw new IllegalArgumentException("from must be equal or greater than to!"); }

File: examples/src/main/java/org/reactivestreams/example/unicast/AsyncIterablePublisher.java
Patch:
@@ -14,10 +14,10 @@
  * AsyncIterablePublisher is an implementation of Reactive Streams `Publisher`
  * which executes asynchronously, using a provided `Executor` and produces elements
  * from a given `Iterable` in a "unicast" configuration to its `Subscribers`.
- 
+ *
  * NOTE: The code below uses a lot of try-catches to show the reader where exceptions can be expected, and where they are forbidden.
  */
-class AsyncIterablePublisher<T> implements Publisher<T> {
+public class AsyncIterablePublisher<T> implements Publisher<T> {
   private final static int DEFAULT_BATCHSIZE = 1024;
 
   private final Iterable<T> elements; // This is our data source / generator

File: examples/src/main/java/org/reactivestreams/example/unicast/InfiniteIncrementNumberPublisher.java
Patch:
@@ -7,7 +7,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Publisher;
 
-class InfiniteIncrementNumberPublisher extends AsyncIterablePublisher<Integer> {
+public class InfiniteIncrementNumberPublisher extends AsyncIterablePublisher<Integer> {
     public InfiniteIncrementNumberPublisher(final Executor executor) {
         super(new Iterable<Integer>() {
           @Override public Iterator<Integer> iterator() {

File: examples/src/main/java/org/reactivestreams/example/unicast/NumberIterablePublisher.java
Patch:
@@ -7,7 +7,7 @@
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Publisher;
 
-class NumberIterablePublisher<T> extends AsyncIterablePublisher<Integer> {
+public class NumberIterablePublisher extends AsyncIterablePublisher<Integer> {
     public NumberIterablePublisher(final int from, final int to, final Executor executor) {
         super(new Iterable<Integer>() {
           { if(from > to) throw new IllegalArgumentException("from must be equal or greater than to!"); }

File: tck/src/main/java/org/reactivestreams/tck/PublisherVerification.java
Patch:
@@ -314,9 +314,8 @@ public void onError(Throwable cause) {
           env.verifyNoAsyncErrors(env.defaultTimeoutMillis());
         }
       });
-    } catch (SkipException ex) {
-      // skipping is expected, rethrow
-      throw ex;
+    } catch (SkipException se) {
+      throw se;
     } catch (Throwable ex) {
       // we also want to catch AssertionErrors and anything the publisher may have thrown inside subscribe
       // which was wrong of him - he should have signalled on error using onError

File: tck/src/main/java/org/reactivestreams/tck/IdentityProcessorVerification.java
Patch:
@@ -387,7 +387,6 @@ public TestSetup apply(Long aLong) throws Throwable {
 
           env.verifyNoAsyncErrors();
         }};
-
       }
     });
   }
@@ -719,7 +718,7 @@ public void expectError(Throwable cause) throws InterruptedException {
     @SuppressWarnings("ThrowableResultOfMethodCallIgnored")
     public void expectError(Throwable cause, long timeoutMillis) throws InterruptedException {
       error.expectCompletion(timeoutMillis, "Did not receive expected error on downstream");
-      if (!error.value().equals(cause)) {
+      if (!cause.equals(error.value())) {
         env.flop(String.format("Expected error %s but got %s", cause, error.value()));
       }
     }

File: tck/src/main/java/org/reactivestreams/tck/IdentityProcessorVerification.java
Patch:
@@ -387,7 +387,6 @@ public TestSetup apply(Long aLong) throws Throwable {
 
           env.verifyNoAsyncErrors();
         }};
-
       }
     });
   }
@@ -719,7 +718,7 @@ public void expectError(Throwable cause) throws InterruptedException {
     @SuppressWarnings("ThrowableResultOfMethodCallIgnored")
     public void expectError(Throwable cause, long timeoutMillis) throws InterruptedException {
       error.expectCompletion(timeoutMillis, "Did not receive expected error on downstream");
-      if (!error.value().equals(cause)) {
+      if (!cause.equals(error.value())) {
         env.flop(String.format("Expected error %s but got %s", cause, error.value()));
       }
     }

File: tck/src/main/java/org/reactivestreams/tck/support/Optional.java
Patch:
@@ -58,7 +58,7 @@ public boolean isEmpty() {
 
     @Override
     public String toString() {
-      return "Some(" + value + ")";
+      return String.format("Some(%s)", value);
     }
   }
 

File: tck/src/main/java/org/reactivestreams/tck/support/Optional.java
Patch:
@@ -58,7 +58,7 @@ public boolean isEmpty() {
 
     @Override
     public String toString() {
-      return "Some(" + value + ")";
+      return String.format("Some(%s)", value);
     }
   }
 

File: tck/src/main/java/org/reactivestreams/tck/TestEnvironment.java
Patch:
@@ -751,6 +751,7 @@ public Optional<T> nextOrEndOfStream(long timeoutMillis, String errorMsg) throws
 
       if (value == null) {
         env.flop(String.format("%s within %d ms", errorMsg, timeoutMillis));
+        return Optional.<T>empty();
       }
 
       return value;

File: api/src/main/java/org/reactivestreams/Processor.java
Patch:
@@ -3,6 +3,9 @@
 /**
  * A Processor represents a processing stageâ€”which is both a {@link Subscriber}
  * and a {@link Publisher} and obeys the contracts of both.
+ *
+ * @param <T> the type of element signaled to the {@link Subscriber}
+ * @param <R> the type of element signaled by the {@link Publisher}
  */
 public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
 }

File: api/src/main/java/org/reactivestreams/Subscriber.java
Patch:
@@ -13,7 +13,7 @@
  * <p>
  * Demand can be signaled via {@link Subscription#request(long)} whenever the {@link Subscriber} instance is capable of handling more.
  *
- * @param <T> the Type of element signaled.
+ * @param <T> the type of element signaled.
  */
 public interface Subscriber<T> {
     /**

File: examples/src/main/java/org/reactivestreams/example/unicast/InfiniteIncrementNumberPublisher.java
Patch:
@@ -1,6 +1,7 @@
 package org.reactivestreams.example.unicast;
 
 import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import org.reactivestreams.Subscription;
 import org.reactivestreams.Subscriber;

File: tck/src/main/java/org/reactivestreams/tck/PublisherVerification.java
Patch:
@@ -633,7 +633,7 @@ public void spec309_requestZeroMustSignalIllegalArgumentException() throws Throw
       @Override public void run(Publisher<T> pub) throws Throwable {
         final ManualSubscriber<T> sub = env.newManualSubscriber(pub);
         sub.request(0);
-        sub.expectErrorWithMessage(IllegalStateException.class, "3.9"); // we do require implementations to mention the rule number at the very least
+        sub.expectErrorWithMessage(IllegalArgumentException.class, "3.9"); // we do require implementations to mention the rule number at the very least
       }
     });
   }
@@ -647,7 +647,7 @@ public void run(Publisher<T> pub) throws Throwable {
         final ManualSubscriber<T> sub = env.newManualSubscriber(pub);
         final Random r = new Random();
         sub.request(-r.nextInt(Integer.MAX_VALUE));
-        sub.expectErrorWithMessage(IllegalStateException.class, "3.9"); // we do require implementations to mention the rule number at the very least
+        sub.expectErrorWithMessage(IllegalArgumentException.class, "3.9"); // we do require implementations to mention the rule number at the very least
       }
     });
   }

File: tck/src/main/java/org/reactivestreams/tck/PublisherVerification.java
Patch:
@@ -633,7 +633,7 @@ public void spec309_requestZeroMustSignalIllegalArgumentException() throws Throw
       @Override public void run(Publisher<T> pub) throws Throwable {
         final ManualSubscriber<T> sub = env.newManualSubscriber(pub);
         sub.request(0);
-        sub.expectErrorWithMessage(IllegalStateException.class, "3.9"); // we do require implementations to mention the rule number at the very least
+        sub.expectErrorWithMessage(IllegalArgumentException.class, "3.9"); // we do require implementations to mention the rule number at the very least
       }
     });
   }
@@ -647,7 +647,7 @@ public void run(Publisher<T> pub) throws Throwable {
         final ManualSubscriber<T> sub = env.newManualSubscriber(pub);
         final Random r = new Random();
         sub.request(-r.nextInt(Integer.MAX_VALUE));
-        sub.expectErrorWithMessage(IllegalStateException.class, "3.9"); // we do require implementations to mention the rule number at the very least
+        sub.expectErrorWithMessage(IllegalArgumentException.class, "3.9"); // we do require implementations to mention the rule number at the very least
       }
     });
   }

File: tck/src/main/java/org/reactivestreams/tck/PublisherVerification.java
Patch:
@@ -801,7 +801,7 @@ public void spec317_mustSignalOnErrorWhenPendingAboveLongMaxValue() throws Throw
             // did not get onError yet, keep spinning
           } else {
             // verify it's the kind of onError we are expecting here
-            env.assertAsyncErrorWithMessage(asyncError, IllegalStateException.class, "3.17");
+            env.assertErrorWithMessage(asyncError, IllegalStateException.class, "3.17");
             overflowSignalled = true;
           }
 

File: tck/src/main/java/org/reactivestreams/tck/PublisherVerification.java
Patch:
@@ -801,7 +801,7 @@ public void spec317_mustSignalOnErrorWhenPendingAboveLongMaxValue() throws Throw
             // did not get onError yet, keep spinning
           } else {
             // verify it's the kind of onError we are expecting here
-            env.assertAsyncErrorWithMessage(asyncError, IllegalStateException.class, "3.17");
+            env.assertErrorWithMessage(asyncError, IllegalStateException.class, "3.17");
             overflowSignalled = true;
           }
 

File: tck/src/main/java/org/reactivestreams/tck/TestEnvironment.java
Patch:
@@ -97,8 +97,7 @@ public <T extends Throwable> void expectThrowingOfWithMessage(Class<T> clazz, St
 
   }
 
-  public <T extends Throwable> void assertAsyncErrorWithMessage(Class<T> clazz, String requiredMessagePart) throws Throwable {
-    Throwable err = dropAsyncError();
+  public <T extends Throwable> void assertAsyncErrorWithMessage(Throwable err, Class<T> clazz, String requiredMessagePart) throws Throwable {
     assertNotNull(err, "Expected " + clazz.getCanonicalName() + " exception but got null!");
     assertTrue(clazz.isInstance(err), "Expected " + clazz.getCanonicalName() + " exception but got " + err.getClass().getCanonicalName() + "!");
 

File: tck/src/main/java/org/reactivestreams/tck/TestEnvironment.java
Patch:
@@ -104,8 +104,7 @@ public <T extends Throwable> void expectThrowingOfWithMessage(Class<T> clazz, St
                String.format("Got expected exception [%s] but missing message part [%s], was: %s", err.getClass(), requiredMessagePart, message));
   }
 
-  public <T extends Throwable> void assertAsyncErrorWithMessage(Class<T> clazz, String requiredMessagePart) throws Throwable {
-    Throwable err = dropAsyncError();
+  public <T extends Throwable> void assertAsyncErrorWithMessage(Throwable err, Class<T> clazz, String requiredMessagePart) throws Throwable {
     assertNotNull(err, "Expected " + clazz.getCanonicalName() + " exception but got null!");
     assertTrue(clazz.isInstance(err), "Expected " + clazz.getCanonicalName() + " exception but got " + err.getClass().getCanonicalName() + "!");
 

File: tck/src/main/java/org/reactivestreams/tck/SubscriberWhiteboxVerification.java
Patch:
@@ -749,7 +749,8 @@ public void registerOnSubscribe(SubscriberPuppet p) {
   public interface SubscriberPuppeteer {
 
     /**
-     * Must be called by the test subscriber when it has received the `onSubscribe` event.
+     * Must be called by the test subscriber when it has successfully registered a subscription
+     * inside the `onSubscribe` method.
      */
     void registerOnSubscribe(SubscriberPuppet puppet);
   }
@@ -782,4 +783,4 @@ public interface SubscriberPuppet {
   public void notVerified() {
     throw new SkipException("Not verified using this TCK.");
   }
-}
\ No newline at end of file
+}

File: api/src/main/java/org/reactivestreams/Processor.java
Patch:
@@ -3,6 +3,9 @@
 /**
  * A Processor represents a processing stageâ€”which is both a {@link Subscriber}
  * and a {@link Publisher} and obeys the contracts of both.
+ *
+ * @param <T> the type of element signaled to the {@link Subscriber}
+ * @param <R> the type of element signaled by the {@link Publisher}
  */
 public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
 }

File: api/src/main/java/org/reactivestreams/Subscriber.java
Patch:
@@ -13,7 +13,7 @@
  * <p>
  * Demand can be signaled via {@link Subscription#request(long)} whenever the {@link Subscriber} instance is capable of handling more.
  *
- * @param <T> the Type of element signaled.
+ * @param <T> the type of element signaled.
  */
 public interface Subscriber<T> {
     /**

File: tck/src/main/java/org/reactivestreams/tck/TestEnvironment.java
Patch:
@@ -158,7 +158,7 @@ public void verifyNoAsyncErrors() {
   /** If {@code TestEnvironment#printlnDebug} is true, print debug message to std out. */
   public void debug(String msg) {
     if (printlnDebug)
-      System.out.println(msg);
+      System.out.println("[TCK-DEBUG] " + msg);
   }
 
   // ---- classes ----

File: tck/src/main/java/org/reactivestreams/tck/TestEnvironment.java
Patch:
@@ -150,7 +150,7 @@ public void verifyNoAsyncErrors() {
   /** If {@code TestEnvironment#printlnDebug} is true, print debug message to std out. */
   public void debug(String msg) {
     if (printlnDebug)
-      System.out.println(msg);
+      System.out.println("[TCK-DEBUG] " + msg);
   }
 
   // ---- classes ----

File: tck/src/main/java/org/reactivestreams/tck/Annotations.java
Patch:
@@ -23,7 +23,6 @@ private Annotations() {}
   @Target(ElementType.METHOD)
   @Retention(RetentionPolicy.SOURCE)
   static @interface Stochastic {
-
   }
 
   /**

File: tck/src/main/java/org/reactivestreams/tck/SubscriberWhiteboxVerification.java
Patch:
@@ -328,7 +328,7 @@ public void spec212_mustNotCallOnSubscribeMoreThanOnceBasedOnObjectEquality() th
     subscriberTestWithoutSetup(new TestStageTestRun() {
       @Override
       public void run(WhiteboxTestStage stage) throws Exception {
-        stage.pub = stage.createHelperPublisher(10);
+        stage.pub = stage.createHelperPublisher(1);
 
         stage.tees = env.newManualSubscriber(stage.pub); // subscribed right away
 

File: api/src/examples/java/org/reactivestreams/example/multicast/NeverEndingStockStream.java
Patch:
@@ -35,7 +35,7 @@ public static synchronized void addHandler(Handler handler) {
 
     public static synchronized void removeHandler(Handler handler) {
         // too lazy to do the array handling
-        HashSet<Handler> set = new HashSet<>(Arrays.asList(INSTANCE.handlers));
+        HashSet<Handler> set = new HashSet<Handler>(Arrays.asList(INSTANCE.handlers));
         set.remove(handler);
         INSTANCE.handlers = set.toArray(new Handler[set.size()]);
     }

File: api/src/examples/java/org/reactivestreams/example/multicast/StockPriceSubscriber.java
Patch:
@@ -13,7 +13,7 @@ public class StockPriceSubscriber implements Subscriber<Stock> {
     private final int take;
 
     public StockPriceSubscriber(int bufferSize, int delayPerStock, int take) {
-        this.buffer = new ArrayBlockingQueue<>(bufferSize);
+        this.buffer = new ArrayBlockingQueue<Stock>(bufferSize);
         this.delayPerStock = delayPerStock;
         this.take = take;
     }

File: api/src/examples/java/org/reactivestreams/example/unicast/InfiniteIncrementNumberPublisher.java
Patch:
@@ -1,6 +1,5 @@
 package org.reactivestreams.example.unicast;
 
-import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 
 import org.reactivestreams.Subscription;

File: api/src/examples/java/org/reactivestreams/example/unicast/NumberSubscriberThatHopsThreads.java
Patch:
@@ -8,7 +8,7 @@
 class NumberSubscriberThatHopsThreads implements Subscriber<Integer> {
 
     final int BUFFER_SIZE = 10;
-    private final ArrayBlockingQueue<Integer> buffer = new ArrayBlockingQueue<>(BUFFER_SIZE);
+    private final ArrayBlockingQueue<Integer> buffer = new ArrayBlockingQueue<Integer>(BUFFER_SIZE);
     private volatile boolean terminated = false;
     private final String token;
 

File: tck/src/main/java/org/reactivestreams/tck/support/Optional.java
Patch:
@@ -5,7 +5,7 @@
 // simplest possible version of Scala's Option type
 public abstract class Optional<T> {
 
-  private static final Optional NONE = new Optional() {
+  private static final Optional<Object> NONE = new Optional<Object>() {
     @Override
     public Object get() {
       throw new NoSuchElementException(".get call on None!");
@@ -17,12 +17,12 @@ public boolean isEmpty() {
     }
   };
 
-  protected Optional() {
+  private Optional() {
   }
 
   @SuppressWarnings("unchecked")
   public static <T> Optional<T> empty() {
-    return NONE;
+    return (Optional<T>) NONE;
   }
 
   @SuppressWarnings("unchecked")

File: tck/src/test/java/org/reactivestreams/tck/IdentityProcessorVerificationDelegationTest.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * The {@link org.reactivestreams.tck.IdentityProcessorVerification} must also run all tests from
- * {@link org.reactivestreams.tck.PublisherVerification} and {@link org.reactivestreams.tck.SubscriberVerification}.
+ * {@link org.reactivestreams.tck.PublisherVerification} and {@link org.reactivestreams.tck.SubscriberWhiteboxVerification}.
  *
  * Since in Java this can be only achieved by delegating, we need to make sure we delegate to each of the tests,
  * so that if in the future we add more tests to these verifications we're sure to not forget to add the delegating methods.
@@ -33,7 +33,7 @@ public void shouldIncludeAllTestsFromPublisherVerification() throws Exception {
   public void shouldIncludeAllTestsFromSubscriberVerification() throws Exception {
     // given
     List<String> processorTests = getTestNames(IdentityProcessorVerification.class);
-    Class<SubscriberVerification> delegatedToClass = SubscriberVerification.class;
+    Class<SubscriberWhiteboxVerification> delegatedToClass = SubscriberWhiteboxVerification.class;
 
     // when
     List<String> publisherTests = getTestNames(delegatedToClass);

File: api/src/examples/java/org/reactivestreams/example/multicast/StockPricePublisher.java
Patch:
@@ -17,7 +17,7 @@
 public class StockPricePublisher implements Publisher<Stock> {
 
     @Override
-    public void subscribe(final Subscriber<Stock> s) {
+    public void subscribe(final Subscriber<? super Stock> s) {
         s.onSubscribe(new Subscription() {
 
             AtomicLong capacity = new AtomicLong();
@@ -46,10 +46,10 @@ public void startConsuming() {
     }
 
     private static final class EventHandler implements Handler {
-        private final Subscriber<Stock> s;
+        private final Subscriber<? super Stock> s;
         private final AtomicLong capacity;
 
-        private EventHandler(Subscriber<Stock> s, AtomicLong capacity) {
+        private EventHandler(Subscriber<? super Stock> s, AtomicLong capacity) {
             this.s = s;
             this.capacity = capacity;
         }

File: api/src/examples/java/org/reactivestreams/example/unicast/InfiniteIncrementNumberPublisher.java
Patch:
@@ -1,6 +1,7 @@
 package org.reactivestreams.example.unicast;
 
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
 
 import org.reactivestreams.Subscription;
 import org.reactivestreams.Subscriber;
@@ -9,13 +10,13 @@
 class InfiniteIncrementNumberPublisher implements Publisher<Integer> {
 
     @Override
-    public void subscribe(final Subscriber<Integer> s) {
+    public void subscribe(final Subscriber<? super Integer> s) {
 
         final AtomicInteger i = new AtomicInteger();
 
         Subscription subscription = new Subscription() {
 
-            AtomicInteger capacity = new AtomicInteger();
+            AtomicLong capacity = new AtomicLong();
 
             @Override
             public void request(long n) {

File: api/src/main/java/org/reactivestreams/Publisher.java
Patch:
@@ -16,5 +16,5 @@ public interface Publisher<T> {
      * 
      * @param s the {@link Subscriber} that will consume signals from this {@link Publisher}
      */
-    public void subscribe(Subscriber<T> s);
+    public void subscribe(Subscriber<? super T> s);
 }

File: api/src/main/java/org/reactivestreams/Subscription.java
Patch:
@@ -12,7 +12,8 @@ public interface Subscription {
     /**
      * No events will be sent by a {@link Publisher} until demand is signaled via this method.
      * <p>
-     * It can be called however often and whenever needed.
+     * It can be called however often and whenever neededâ€”but the outstanding cumulative demand must never exceed Long.MAX_VALUE.
+     * An outstanding cumulative demand of Long.MAX_VALUE may be treated by the {@link Publisher} as "effectively unbounded".
      * <p>
      * Whatever has been requested can be sent by the {@link Publisher} so only signal demand for what can be safely handled.
      * <p>
@@ -21,7 +22,7 @@ public interface Subscription {
      * 
      * @param n the strictly positive number of elements to requests to the upstream {@link Publisher}
      */
-    public void request(int n);
+    public void request(long n);
 
     /**
      * Request the {@link Publisher} to stop sending data and clean up resources.

File: api/src/main/java/org/reactivestreams/Publisher.java
Patch:
@@ -14,7 +14,7 @@ public interface Publisher<T> {
      * If the {@link Publisher} rejects the subscription attempt or otherwise fails it will 
      * signal the error via {@link Subscriber#onError}.
      * 
-     * @param s
+     * @param s the {@link Subscriber} that will consume signals from this {@link Publisher}
      */
     public void subscribe(Subscriber<T> s);
 }

File: api/src/main/java/org/reactivestreams/Subscription.java
Patch:
@@ -19,7 +19,7 @@ public interface Subscription {
      * A {@link Publisher} can send less than is requested if the stream ends but
      * then must emit either {@link Subscriber#onError(Throwable)} or {@link Subscriber#onComplete()}.
      * 
-     * @param n
+     * @param n the strictly positive number of elements to requests to the upstream {@link Publisher}
      */
     public void request(int n);
 

File: api/src/main/java/org/reactivestreams/Publisher.java
Patch:
@@ -14,7 +14,7 @@ public interface Publisher<T> {
      * If the {@link Publisher} rejects the subscription attempt or otherwise fails it will 
      * signal the error via {@link Subscriber#onError}.
      * 
-     * @param s
+     * @param s the {@link Subscriber} that will consume signals from this {@link Publisher}
      */
     public void subscribe(Subscriber<T> s);
 }

File: api/src/main/java/org/reactivestreams/Subscription.java
Patch:
@@ -19,7 +19,7 @@ public interface Subscription {
      * A {@link Publisher} can send less than is requested if the stream ends but
      * then must emit either {@link Subscriber#onError(Throwable)} or {@link Subscriber#onComplete()}.
      * 
-     * @param n
+     * @param n the strictly positive number of elements to requests to the upstream {@link Publisher}
      */
     public void request(int n);
 

