File: src/main/java/com/googlecode/aviator/AviatorEvaluatorInstance.java
Patch:
@@ -404,7 +404,7 @@ private Map<String, Object> loadScript0(final String abPath) throws IOException
   @SuppressWarnings("unchecked")
   private Map<String, Object> executeModule(final Expression exp, final String abPath) {
     final Env exports = new Env();
-    exports.configure(this, exp, -1);
+    exports.configure(this, exp, -1, null);
     final Map<String, Object> module = exp.newEnv("exports", exports, "path", abPath);
     Map<String, Object> env = exp.newEnv("__MODULE__", module, "exports", exports);
     ((BaseExpression) exp).execute(env, false);

File: src/main/java/com/googlecode/aviator/BaseExpression.java
Patch:
@@ -341,13 +341,13 @@ protected Env newEnv(final Map<String, Object> map, final boolean direct,
     } else {
       env = new Env(map);
     }
-    env.configure(this.instance, this, getExecutionStartNs(checkExecutionTimeout));
+    env.configure(this.instance, this, getExecutionStartNs(checkExecutionTimeout), null);
     return env;
   }
 
   protected Env genTopEnv(final Map<String, Object> map, boolean checkExecutionTimeout) {
     if (map instanceof Env) {
-      ((Env) map).configure(this.instance, this, getExecutionStartNs(checkExecutionTimeout));
+      ((Env) map).configure(this.instance, this, getExecutionStartNs(checkExecutionTimeout), null);
     }
     Env env =
         newEnv(map, this.instance.getOptionValue(Options.USE_USER_ENV_AS_TOP_ENV_DIRECTLY).bool,

File: src/main/java/com/googlecode/aviator/code/asm/ASMCodeGenerator.java
Patch:
@@ -56,7 +56,6 @@
 import java.util.Stack;
 import java.util.concurrent.atomic.AtomicLong;
 import com.googlecode.aviator.AviatorEvaluatorInstance;
-import com.googlecode.aviator.BaseExpression;
 import com.googlecode.aviator.ClassExpression;
 import com.googlecode.aviator.Expression;
 import com.googlecode.aviator.Options;
@@ -414,6 +413,7 @@ public void onAndRight(final Token<?> lookhead) {
 
   private void visitRightBranch(final Token<?> lookhead, final int ints,
       final OperatorType opType) {
+    this.checkExecutionTimeout();
     if (!OperationRuntime.hasRuntimeContext(this.compileEnv, opType)) {
       this.mv.visitInsn(DUP);
       loadEnv();
@@ -541,6 +541,7 @@ public void onJoinLeft(final Token<?> lookhead) {
   }
 
   private void visitLeftBranch(final Token<?> lookhead, final int ints, final OperatorType opType) {
+    this.checkExecutionTimeout();
     if (!OperationRuntime.hasRuntimeContext(this.compileEnv, opType)) {
       visitBoolean();
       Label l0 = makeLabel();

File: src/main/java/com/googlecode/aviator/code/interpreter/InterpretContext.java
Patch:
@@ -2,9 +2,7 @@
 
 import java.util.ArrayDeque;
 import java.util.List;
-import java.util.concurrent.TimeUnit;
 import com.googlecode.aviator.InterpretExpression;
-import com.googlecode.aviator.exception.TimeoutException;
 import com.googlecode.aviator.lexer.token.Token;
 import com.googlecode.aviator.parser.VariableMeta;
 import com.googlecode.aviator.runtime.RuntimeUtils;

File: src/test/java/com/googlecode/aviator/SimpleELPerformanceTest.java
Patch:
@@ -8,7 +8,7 @@
 public class SimpleELPerformanceTest extends TestCase {
   public void test_perf() throws Exception {
 
-    // AviatorEvaluator.setTrace(true);
+    // AviatorEvaluator.setOption(Options.EVAL_TIMEOUT_MS, 100);
     for (int i = 0; i < 10; ++i) {
       perf();
       perfVarAccess();

File: src/main/java/com/googlecode/aviator/code/asm/ASMCodeGenerator.java
Patch:
@@ -56,7 +56,6 @@
 import java.util.Stack;
 import java.util.concurrent.atomic.AtomicLong;
 import com.googlecode.aviator.AviatorEvaluatorInstance;
-import com.googlecode.aviator.BaseExpression;
 import com.googlecode.aviator.ClassExpression;
 import com.googlecode.aviator.Expression;
 import com.googlecode.aviator.Options;
@@ -414,6 +413,7 @@ public void onAndRight(final Token<?> lookhead) {
 
   private void visitRightBranch(final Token<?> lookhead, final int ints,
       final OperatorType opType) {
+    this.checkExecutionTimeout();
     if (!OperationRuntime.hasRuntimeContext(this.compileEnv, opType)) {
       this.mv.visitInsn(DUP);
       loadEnv();
@@ -541,6 +541,7 @@ public void onJoinLeft(final Token<?> lookhead) {
   }
 
   private void visitLeftBranch(final Token<?> lookhead, final int ints, final OperatorType opType) {
+    this.checkExecutionTimeout();
     if (!OperationRuntime.hasRuntimeContext(this.compileEnv, opType)) {
       visitBoolean();
       Label l0 = makeLabel();

File: src/main/java/com/googlecode/aviator/code/interpreter/InterpretContext.java
Patch:
@@ -2,9 +2,7 @@
 
 import java.util.ArrayDeque;
 import java.util.List;
-import java.util.concurrent.TimeUnit;
 import com.googlecode.aviator.InterpretExpression;
-import com.googlecode.aviator.exception.TimeoutException;
 import com.googlecode.aviator.lexer.token.Token;
 import com.googlecode.aviator.parser.VariableMeta;
 import com.googlecode.aviator.runtime.RuntimeUtils;

File: src/main/java/com/googlecode/aviator/AviatorEvaluatorInstance.java
Patch:
@@ -407,7 +407,7 @@ private Map<String, Object> executeModule(final Expression exp, final String abP
     final Map<String, Object> module = exp.newEnv("exports", exports, "path", abPath);
     Map<String, Object> env = exp.newEnv("__MODULE__", module, "exports", exports);
     exp.execute(env);
-    exports.configure(this, exp);
+    exports.configure(this, exp, Utils.currentTimeNanos());
     return (Map<String, Object>) module.get("exports");
   }
 

File: src/main/java/com/googlecode/aviator/BaseExpression.java
Patch:
@@ -28,6 +28,7 @@
 import com.googlecode.aviator.utils.Constants;
 import com.googlecode.aviator.utils.Env;
 import com.googlecode.aviator.utils.Reflector;
+import com.googlecode.aviator.utils.Utils;
 
 /**
  * Base expression
@@ -334,13 +335,13 @@ protected Env newEnv(final Map<String, Object> map, final boolean direct) {
     } else {
       env = new Env(map);
     }
-    env.configure(this.instance, this);
+    env.configure(this.instance, this, Utils.currentTimeNanos());
     return env;
   }
 
   protected Env genTopEnv(final Map<String, Object> map) {
     if (map instanceof Env) {
-      ((Env) map).configure(this.instance, this);
+      ((Env) map).configure(this.instance, this, Utils.currentTimeNanos());
     }
     Env env =
         newEnv(map, this.instance.getOptionValue(Options.USE_USER_ENV_AS_TOP_ENV_DIRECTLY).bool);

File: src/main/java/com/googlecode/aviator/runtime/function/LambdaFunction.java
Patch:
@@ -241,9 +241,9 @@ protected Map<String, Object> newEnv(final Map<String, Object> parentEnv,
     Env env = null;
     if (!this.inheritEnv) {
       final Env contextEnv = new Env(parentEnv, this.context);
-      contextEnv.configure(this.context.getInstance(), this.expression);
+      contextEnv.configure(this.context.getInstance(), this.expression, this.context.getStartNs());
       env = new Env(contextEnv);
-      env.configure(this.context.getInstance(), this.expression);
+      env.configure(this.context.getInstance(), this.expression, this.context.getStartNs());
     } else {
       // assert (parentEnv == this.context);
       env = (Env) parentEnv;

File: src/test/java/com/googlecode/aviator/AviatorEvaluatorInstanceInterpreteUnitTest.java
Patch:
@@ -12,6 +12,7 @@ public class AviatorEvaluatorInstanceInterpreteUnitTest extends AviatorEvaluator
   public void setup() {
     super.setup();
     this.instance.setOption(Options.EVAL_MODE, EvalMode.INTERPRETER);
+    this.instance.setOption(Options.EVAL_TIMEOUT_MS, 50);
   }
 
   @Test
@@ -21,8 +22,6 @@ public void testTraceEval() throws Exception {
 
   @Test(expected = TimeoutException.class)
   public void testEvalTimeout() {
-    this.instance.setOption(Options.EVAL_TIMEOUT_MS, 1);
-
     this.instance.execute("while(true) { }");
   }
 

File: src/main/java/com/googlecode/aviator/parser/ExpressionParser.java
Patch:
@@ -1602,6 +1602,7 @@ private void className() {
     if (expectChar('*')) {
       wildcard();
     } else {
+      checkVariableName(this.lookhead);
       getCodeGenerator().onConstant(this.lookhead.withMeta(Constants.USE_CLASS_PKG, true));
     }
     move(true);

File: src/main/java/com/googlecode/aviator/parser/ExpressionParser.java
Patch:
@@ -1602,8 +1602,7 @@ private void className() {
     if (expectChar('*')) {
       wildcard();
     } else {
-      checkVariableName(this.lookhead);
-      getCodeGenerator().onConstant(this.lookhead);
+      getCodeGenerator().onConstant(this.lookhead.withMeta(Constants.USE_CLASS_PKG, true));
     }
     move(true);
   }

File: src/main/java/com/googlecode/aviator/utils/Constants.java
Patch:
@@ -44,6 +44,7 @@ public class Constants {
   // Whether string has interpolation point.
   public static final String INTER_META = "hasInterpolation";
   public static final String UNPACK_ARGS = "unpackingArgs";
+  public static final String USE_CLASS_PKG = "useClassOrPkg";
   public static final Pattern SPLIT_PAT = Pattern.compile("\\.");
 
   // runtime metadata keys

File: src/main/java/com/googlecode/aviator/runtime/function/system/BigIntFunction.java
Patch:
@@ -36,7 +36,7 @@ public AviatorObject call(final Map<String, Object> env, final AviatorObject arg
         } else if (obj instanceof Character) {
           return AviatorBigInt.valueOf(new BigInteger(String.valueOf(obj)));
         } else {
-          throw new ClassCastException("Could not cast " + obj.getClass().getName() + " to bigint");
+          throw new ClassCastException("Could not cast " + (obj != null ? obj.getClass().getName() : "null")  + " to bigint, AviatorObject is " + arg1);
         }
       case String:
         return AviatorBigInt.valueOf(new BigInteger((String) arg1.getValue(env)));

File: src/main/java/com/googlecode/aviator/runtime/function/system/DoubleFunction.java
Patch:
@@ -34,7 +34,7 @@ public AviatorObject call(Map<String, Object> env, AviatorObject arg1) {
         } else if (obj instanceof Character) {
           return new AviatorDouble(Double.parseDouble(String.valueOf(obj)));
         } else {
-          throw new ClassCastException("Could not cast " + obj.getClass().getName() + " to double");
+          throw new ClassCastException("Could not cast " + (obj != null ? obj.getClass().getName() : "null")  + " to double, AviatorObject is" + arg1 );
         }
       case String:
         return new AviatorDouble(Double.parseDouble((String) arg1.getValue(env)));

File: src/main/java/com/googlecode/aviator/runtime/function/system/LongFunction.java
Patch:
@@ -34,7 +34,7 @@ public AviatorObject call(Map<String, Object> env, AviatorObject arg1) {
         } else if (obj instanceof Character) {
           return AviatorLong.valueOf(Long.valueOf(String.valueOf(obj)));
         } else {
-          throw new ClassCastException("Could not cast " + obj.getClass().getName() + " to long");
+          throw new ClassCastException("Could not cast " + (obj != null ? obj.getClass().getName() : "null")  + " to long, AviatorObject is " + arg1);
         }
       case String:
         return AviatorLong.valueOf(Long.valueOf((String) arg1.getValue(env)));

File: src/main/java/com/googlecode/aviator/runtime/function/system/BigIntFunction.java
Patch:
@@ -36,7 +36,7 @@ public AviatorObject call(final Map<String, Object> env, final AviatorObject arg
         } else if (obj instanceof Character) {
           return AviatorBigInt.valueOf(new BigInteger(String.valueOf(obj)));
         } else {
-          throw new ClassCastException("Could not cast " + obj.getClass().getName() + " to bigint");
+          throw new ClassCastException("Could not cast " + (obj != null ? obj.getClass().getName() : "null")  + " to bigint, AviatorObject is " + arg1);
         }
       case String:
         return AviatorBigInt.valueOf(new BigInteger((String) arg1.getValue(env)));

File: src/main/java/com/googlecode/aviator/runtime/function/system/DoubleFunction.java
Patch:
@@ -34,7 +34,7 @@ public AviatorObject call(Map<String, Object> env, AviatorObject arg1) {
         } else if (obj instanceof Character) {
           return new AviatorDouble(Double.parseDouble(String.valueOf(obj)));
         } else {
-          throw new ClassCastException("Could not cast " + obj.getClass().getName() + " to double");
+          throw new ClassCastException("Could not cast " + (obj != null ? obj.getClass().getName() : "null")  + " to double, AviatorObject is" + arg1 );
         }
       case String:
         return new AviatorDouble(Double.parseDouble((String) arg1.getValue(env)));

File: src/main/java/com/googlecode/aviator/runtime/function/system/LongFunction.java
Patch:
@@ -34,7 +34,7 @@ public AviatorObject call(Map<String, Object> env, AviatorObject arg1) {
         } else if (obj instanceof Character) {
           return AviatorLong.valueOf(Long.valueOf(String.valueOf(obj)));
         } else {
-          throw new ClassCastException("Could not cast " + obj.getClass().getName() + " to long");
+          throw new ClassCastException("Could not cast " + (obj != null ? obj.getClass().getName() : "null")  + " to long, AviatorObject is " + arg1);
         }
       case String:
         return AviatorLong.valueOf(Long.valueOf((String) arg1.getValue(env)));

File: src/main/java/com/googlecode/aviator/code/LambdaGenerator.java
Patch:
@@ -52,7 +52,7 @@ public LambdaGenerator(final AviatorEvaluatorInstance instance,
     this.inheritEnv = inheritEnv;
     // Generate lambda class name
     this.className =
-        "Lambda_" + System.currentTimeMillis() + "_" + LAMBDA_COUNTER.getAndIncrement();
+        "AviatorScript_" + System.currentTimeMillis() + "_" + LAMBDA_COUNTER.getAndIncrement();
     // Auto compute frames
     // this.classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
     // visitClass();

File: src/main/java/com/googlecode/aviator/serialize/AviatorObjectOutputStream.java
Patch:
@@ -40,8 +40,8 @@ protected void annotateClass(Class<?> cl) throws IOException {
     if (ClassExpression.class.isAssignableFrom(cl) && cl != ClassExpression.class) {
       byte[] classBytes = this.classBytesCache.get(cl.getName());
       if (classBytes == null) {
-        throw new IllegalArgumentException(
-            "Class bytes not found, forgot to enable Options.SERIALIZABLE before compiling the script?");
+        throw new IllegalArgumentException("Class bytes not found: " + cl.getName()
+            + ", forgot to enable Options.SERIALIZABLE before compiling the script?");
       }
       this.writeInt(classBytes.length);
       this.write(classBytes);

File: src/main/java/com/googlecode/aviator/utils/ArrayHashMap.java
Patch:
@@ -13,7 +13,9 @@ public class ArrayHashMap<K, V> extends AbstractMap<K, V>
 
   private static final long serialVersionUID = 362498820763181265L;
 
-  private static class MapEntry<K, V> implements Map.Entry<K, V> {
+  private static class MapEntry<K, V> implements Map.Entry<K, V>, Serializable {
+
+    private static final long serialVersionUID = 1759214536880718767L;
     K key;
     V value;
     int hash;

File: src/test/java/com/googlecode/aviator/scripts/TestScripts.java
Patch:
@@ -402,6 +402,7 @@ public void testFunctions() {
     assertEquals(610, testScript("fibonacci.av", "n", 15));
     assertEquals(6765, testScript("fibonacci.av", "n", 20));
     testScript("unpacking_arguments.av");
+    assertEquals(Arrays.asList(3L, 2L, 4L, 1L), testScript("recusive_fn.av"));
   }
 
   @Test

File: src/main/java/com/googlecode/aviator/runtime/function/LambdaFunction.java
Patch:
@@ -245,7 +245,7 @@ protected Map<String, Object> newEnv(final Map<String, Object> parentEnv,
       env = new Env(contextEnv);
       env.configure(this.context.getInstance(), this.expression);
     } else {
-      assert (parentEnv == this.context);
+      // assert (parentEnv == this.context);
       env = (Env) parentEnv;
     }
 

File: src/test/java/com/googlecode/aviator/example/SerializeExample.java
Patch:
@@ -1,7 +1,5 @@
 package com.googlecode.aviator.example;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotSame;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.ObjectInputStream;

File: src/main/java/com/googlecode/aviator/utils/Reflector.java
Patch:
@@ -801,6 +801,9 @@ public static Object fastGetProperty(final String name, final String[] names,
 
       if (target.innerClazz != null) {
         final AviatorEvaluatorInstance instance = RuntimeUtils.getInstance(env);
+        // check innerClazz is allowed
+        instance.checkIfClassIsAllowed(true, target.innerClazz);
+
         if (tryResolveStaticMethod && instance.isFeatureEnabled(Feature.StaticMethods)
             && names.length == 2) {
           val = fastGetProperty(target.innerClazz, rName, PropertyType.StaticMethod);

File: src/main/java/com/googlecode/aviator/BaseExpression.java
Patch:
@@ -49,7 +49,7 @@ public abstract class BaseExpression implements Expression {
   private Map<Integer, List<FunctionArgument>> funcsArgs = Collections.emptyMap();
   protected SymbolTable symbolTable;
   // cached compiled string segments for string interpolation.
-  private transient final ConcurrentHashMap<String, FutureTask<StringSegments>> stringSegs =
+  private transient ConcurrentHashMap<String, FutureTask<StringSegments>> stringSegs =
       new ConcurrentHashMap<String, FutureTask<StringSegments>>();
 
   protected String sourceFile;
@@ -383,6 +383,7 @@ public void customReadObject(ObjectInputStream input) throws ClassNotFoundExcept
     this.symbolTable = (SymbolTable) input.readObject();
     this.sourceFile = (String) input.readObject();
     this.lambdaBootstraps = (Map<String, LambdaFunctionBootstrap>) input.readObject();
+    this.stringSegs = new ConcurrentHashMap<String, FutureTask<StringSegments>>();
   }
 
   public void customWriteObject(ObjectOutputStream output) throws IOException {

File: src/main/java/com/googlecode/aviator/FunctionMissing.java
Patch:
@@ -8,6 +8,7 @@
  *
  */
 
+import java.io.Serializable;
 import java.util.Map;
 import com.googlecode.aviator.runtime.type.AviatorObject;
 
@@ -22,7 +23,7 @@
  * @since 4.2.5
  *
  */
-public interface FunctionMissing {
+public interface FunctionMissing extends Serializable {
   /**
    * Called when function not found, return the invocation result.
    *

File: src/main/java/com/googlecode/aviator/runtime/JavaMethodReflectionFunctionMissing.java
Patch:
@@ -18,6 +18,8 @@
  */
 public class JavaMethodReflectionFunctionMissing implements FunctionMissing {
 
+  private static final long serialVersionUID = -7829608231403725185L;
+
   private JavaMethodReflectionFunctionMissing() {
 
   }

File: src/main/java/com/googlecode/aviator/runtime/function/internal/ReducerFunction.java
Patch:
@@ -54,7 +54,6 @@ private AviatorObject reduce(final Map<String, Object> env, final AviatorObject
     long c = 0;
 
     if (coll != Range.LOOP) {
-
       long arities = (long) arg2.meta(Constants.ARITIES_META);
       long index = 0;
       boolean unboxEntry =

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorBoolean.java
Patch:
@@ -51,6 +51,9 @@ public final boolean booleanValue(final Map<String, Object> env) {
     return this.value.booleanValue();
   }
 
+  public boolean getBooleanValue() {
+    return this.value;
+  }
 
   @Override
   public AviatorObject add(final AviatorObject other, final Map<String, Object> env) {

File: src/main/java/com/googlecode/aviator/serialize/AviatorObjectOutputStream.java
Patch:
@@ -7,6 +7,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import com.googlecode.aviator.ClassExpression;
+import com.googlecode.aviator.runtime.type.Range;
 
 /**
  * A special ObjectOutputStream that will write the generated script class byte array.
@@ -30,6 +31,7 @@ protected Object replaceObject(Object obj) throws IOException {
     if (obj instanceof ClassExpression) {
       this.classBytesCache.put(obj.getClass().getName(), ((ClassExpression) obj).getClassBytes());
     }
+
     return super.replaceObject(obj);
   }
 

File: src/main/java/com/googlecode/aviator/BaseExpression.java
Patch:
@@ -49,7 +49,7 @@ public abstract class BaseExpression implements Expression {
   private Map<Integer, List<FunctionArgument>> funcsArgs = Collections.emptyMap();
   protected SymbolTable symbolTable;
   // cached compiled string segments for string interpolation.
-  private transient final ConcurrentHashMap<String, FutureTask<StringSegments>> stringSegs =
+  private transient ConcurrentHashMap<String, FutureTask<StringSegments>> stringSegs =
       new ConcurrentHashMap<String, FutureTask<StringSegments>>();
 
   protected String sourceFile;
@@ -383,6 +383,7 @@ public void customReadObject(ObjectInputStream input) throws ClassNotFoundExcept
     this.symbolTable = (SymbolTable) input.readObject();
     this.sourceFile = (String) input.readObject();
     this.lambdaBootstraps = (Map<String, LambdaFunctionBootstrap>) input.readObject();
+    this.stringSegs = new ConcurrentHashMap<String, FutureTask<StringSegments>>();
   }
 
   public void customWriteObject(ObjectOutputStream output) throws IOException {

File: src/main/java/com/googlecode/aviator/FunctionMissing.java
Patch:
@@ -8,6 +8,7 @@
  *
  */
 
+import java.io.Serializable;
 import java.util.Map;
 import com.googlecode.aviator.runtime.type.AviatorObject;
 
@@ -22,7 +23,7 @@
  * @since 4.2.5
  *
  */
-public interface FunctionMissing {
+public interface FunctionMissing extends Serializable {
   /**
    * Called when function not found, return the invocation result.
    *

File: src/main/java/com/googlecode/aviator/runtime/JavaMethodReflectionFunctionMissing.java
Patch:
@@ -18,6 +18,8 @@
  */
 public class JavaMethodReflectionFunctionMissing implements FunctionMissing {
 
+  private static final long serialVersionUID = -7829608231403725185L;
+
   private JavaMethodReflectionFunctionMissing() {
 
   }

File: src/main/java/com/googlecode/aviator/runtime/function/internal/ReducerFunction.java
Patch:
@@ -54,7 +54,6 @@ private AviatorObject reduce(final Map<String, Object> env, final AviatorObject
     long c = 0;
 
     if (coll != Range.LOOP) {
-
       long arities = (long) arg2.meta(Constants.ARITIES_META);
       long index = 0;
       boolean unboxEntry =

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorBoolean.java
Patch:
@@ -51,6 +51,9 @@ public final boolean booleanValue(final Map<String, Object> env) {
     return this.value.booleanValue();
   }
 
+  public boolean getBooleanValue() {
+    return this.value;
+  }
 
   @Override
   public AviatorObject add(final AviatorObject other, final Map<String, Object> env) {

File: src/main/java/com/googlecode/aviator/serialize/AviatorObjectOutputStream.java
Patch:
@@ -7,6 +7,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import com.googlecode.aviator.ClassExpression;
+import com.googlecode.aviator.runtime.type.Range;
 
 /**
  * A special ObjectOutputStream that will write the generated script class byte array.
@@ -30,6 +31,7 @@ protected Object replaceObject(Object obj) throws IOException {
     if (obj instanceof ClassExpression) {
       this.classBytesCache.put(obj.getClass().getName(), ((ClassExpression) obj).getClassBytes());
     }
+
     return super.replaceObject(obj);
   }
 

File: src/main/java/com/googlecode/aviator/InterpretExpression.java
Patch:
@@ -17,8 +17,11 @@
 import com.googlecode.aviator.parser.VariableMeta;
 import com.googlecode.aviator.runtime.LambdaFunctionBootstrap;
 import com.googlecode.aviator.runtime.RuntimeUtils;
+import com.googlecode.aviator.runtime.function.internal.ReducerResult;
 import com.googlecode.aviator.runtime.type.AviatorJavaType;
+import com.googlecode.aviator.runtime.type.AviatorNil;
 import com.googlecode.aviator.runtime.type.AviatorObject;
+import com.googlecode.aviator.utils.Constants;
 import com.googlecode.aviator.utils.Env;
 
 public class InterpretExpression extends BaseExpression {

File: src/main/java/com/googlecode/aviator/code/asm/ASMCodeGenerator.java
Patch:
@@ -1009,6 +1009,9 @@ public void initVariables(final Map<String, VariableMeta/* counter */> vars) {
     this.variables = vars;
     this.innerVars = new HashMap<>(this.variables.size());
     for (String outterVarName : this.variables.keySet()) {
+      if (outterVarName.equals(Constants.REDUCER_EMPTY_VAR)) {
+        continue;
+      }
       // Use inner variable name instead of outter variable name
       String innerVarName = getInnerName(outterVarName);
       this.innerVars.put(outterVarName, innerVarName);

File: src/main/java/com/googlecode/aviator/runtime/function/internal/IfCallccFunction.java
Patch:
@@ -35,15 +35,16 @@ public AviatorObject call(final Map<String, Object> env, final AviatorObject arg
       return arg1;
     } else {
       final Object nextClauseVal = arg2.getValue(env);
-      if (nextClauseVal == Constants.REDUCER_EMPTY) {
+      if ((nextClauseVal instanceof ReducerResult)
+          && ((ReducerResult) nextClauseVal).isEmptyState()) {
         return arg1;
       }
 
       AviatorFunction otherClausesFn = (AviatorFunction) nextClauseVal;
       try {
         AviatorObject result = otherClausesFn.call(env);
         // No remaining statements, return the if statement result.
-        if (result == Constants.REDUCER_EMPTY) {
+        if ((result instanceof ReducerResult) && ((ReducerResult) result).isEmptyState()) {
           return arg1;
         }
         return result;

File: src/main/java/com/googlecode/aviator/runtime/function/internal/ReducerFunction.java
Patch:
@@ -130,12 +130,12 @@ private AviatorObject reduce(final Map<String, Object> env, final AviatorObject
     }
 
     Object contObj = arg3.getValue(env);
-    if (contObj == Constants.REDUCER_EMPTY) {
+    if ((contObj instanceof ReducerResult) && ((ReducerResult) contObj).isEmptyState()) {
       return result;
     }
 
     AviatorObject contResult = ((AviatorFunction) contObj).call(env);
-    if (contResult == Constants.REDUCER_EMPTY) {
+    if ((contResult instanceof ReducerResult) && ((ReducerResult) contResult).isEmptyState()) {
       // empty continuation, return current result.
       return result;
     } else {

File: src/main/java/com/googlecode/aviator/runtime/function/internal/TryCatchFunction.java
Patch:
@@ -72,13 +72,13 @@ public AviatorObject call(final Map<String, Object> env, final AviatorObject arg
     }
 
     Object val = arg4.getValue(env);
-    if (val == Constants.REDUCER_EMPTY) {
+    if ((val instanceof ReducerResult) && ((ReducerResult) val).isEmptyState()) {
       return result;
     }
     AviatorFunction continueFn = (AviatorFunction) val;
     try {
       AviatorObject contResult = continueFn.call(env);
-      if (contResult == Constants.REDUCER_EMPTY) {
+      if ((contResult instanceof ReducerResult) && ((ReducerResult) contResult).isEmptyState()) {
         return result;
       } else {
         return contResult;

File: src/main/java/com/googlecode/aviator/utils/Constants.java
Patch:
@@ -25,7 +25,6 @@ public class Constants {
   public static final String DEFINE_META = "define";
   public static final Variable REDUCER_LOOP = new Variable("__reducer_loop", 0, -1);
   public static final String NEWLINE = "\r\n";
-  public static final ReducerResult REDUCER_EMPTY = ReducerResult.withEmpty(AviatorNil.NIL);
   public static final String REQUIRE_FN = "require";
   public static final String LOAD_FN = "load";
   public static final Variable CATCH_HANDLER_VAR = new Variable("__catch_handler", 0, -1);

File: src/main/java/com/googlecode/aviator/utils/Env.java
Patch:
@@ -38,6 +38,8 @@
 import com.googlecode.aviator.Options;
 import com.googlecode.aviator.exception.ExpressionRuntimeException;
 import com.googlecode.aviator.runtime.function.FunctionUtils;
+import com.googlecode.aviator.runtime.function.internal.ReducerResult;
+import com.googlecode.aviator.runtime.type.AviatorNil;
 import com.googlecode.aviator.runtime.type.Range;
 
 /**
@@ -336,7 +338,7 @@ public Object get(final Object key) {
       return Range.LOOP;
     }
     if (Constants.REDUCER_EMPTY_VAR == key) {
-      return Constants.REDUCER_EMPTY;
+      return ReducerResult.withEmpty(AviatorNil.NIL);
     }
 
     if (Constants.ENV_VAR == key) {

File: src/main/java/com/googlecode/aviator/utils/Reflector.java
Patch:
@@ -797,6 +797,9 @@ public static Object fastGetProperty(final String name, final String[] names,
 
       if (target.innerClazz != null) {
         final AviatorEvaluatorInstance instance = RuntimeUtils.getInstance(env);
+        // check innerClazz is allowed
+        instance.checkIfClassIsAllowed(true, target.innerClazz);
+
         if (tryResolveStaticMethod && instance.isFeatureEnabled(Feature.StaticMethods)
             && names.length == 2) {
           val = fastGetProperty(target.innerClazz, rName, PropertyType.StaticMethod);

File: src/main/java/com/googlecode/aviator/script/AviatorScriptEngineFactory.java
Patch:
@@ -31,7 +31,7 @@ public class AviatorScriptEngineFactory implements ScriptEngineFactory {
   static {
     PARAM_MAP.put(ScriptEngine.ENGINE, "Aviator");
     PARAM_MAP.put(ScriptEngine.ENGINE_VERSION, AviatorEvaluator.VERSION);
-    PARAM_MAP.put(ScriptEngine.LANGUAGE, "aviator");
+    PARAM_MAP.put(ScriptEngine.LANGUAGE, "AviatorScript");
     PARAM_MAP.put(ScriptEngine.LANGUAGE_VERSION, AviatorEvaluator.VERSION);
   }
 

File: src/main/java/com/googlecode/aviator/BaseExpression.java
Patch:
@@ -17,6 +17,7 @@
 import com.googlecode.aviator.exception.ExpressionNotFoundException;
 import com.googlecode.aviator.lexer.SymbolTable;
 import com.googlecode.aviator.lexer.token.Variable;
+import com.googlecode.aviator.parser.CompileTypes;
 import com.googlecode.aviator.parser.VariableMeta;
 import com.googlecode.aviator.runtime.FunctionArgument;
 import com.googlecode.aviator.runtime.LambdaFunctionBootstrap;
@@ -149,8 +150,8 @@ public Map<String, VariableMeta> getFullNameMetas() {
     for (VariableMeta m : this.vars) {
       final String name = m.getName();
       String[] tmps = Constants.SPLIT_PAT.split(name);
-      if (!m.isInit() && !definedVars.contains(tmps[0]) && !definedVars.contains(name)
-          && m.getFirstIndex() >= 0) {
+      if (!m.isInit() && m.getType() != CompileTypes.Class && !definedVars.contains(tmps[0])
+          && !definedVars.contains(name) && m.getFirstIndex() >= 0) {
         fullNames.put(name, m);
       } else if (m.getFirstIndex() >= 0) {
         // It's defined in current scope

File: src/main/java/com/googlecode/aviator/parser/CompileTypes.java
Patch:
@@ -7,5 +7,5 @@
  *
  */
 public enum CompileTypes {
-  Function, Array;
+  Function, Array, Class,
 }

File: src/main/java/com/googlecode/aviator/parser/ExpressionParser.java
Patch:
@@ -1565,7 +1565,8 @@ private void newStatement() {
       reportSyntaxError("invalid class name");
     }
     checkVariableName(this.lookhead);
-    getCodeGeneratorWithTimes().onConstant(this.lookhead);
+    getCodeGeneratorWithTimes()
+        .onConstant(this.lookhead.withMeta(Constants.TYPE_META, CompileTypes.Class));
     getCodeGeneratorWithTimes().onMethodParameter(this.lookhead);
     move(true);
 

File: src/main/java/com/googlecode/aviator/lexer/token/Token.java
Patch:
@@ -48,5 +48,7 @@ enum TokenType {
 
   int getStartIndex();
 
+  int getEndIndex();
+
   int getLineNo();
 }

File: src/main/java/com/googlecode/aviator/utils/ArrayUtils.java
Patch:
@@ -36,7 +36,7 @@ public static int getLength(final Object a) {
       return ((Object[]) a).length;
     }
 
-    return ArrayUtils.getLength(a);
+    return Array.getLength(a);
   }
 
   public static Object get(final Object a, final int index) {
@@ -62,7 +62,7 @@ public static Object get(final Object a, final int index) {
       return ((Object[]) a)[index];
     }
 
-    return ArrayUtils.get(a, index);
+    return Array.get(a, index);
   }
 
   public static void set(final Object a, final int index, final Object val) {
@@ -87,7 +87,7 @@ public static void set(final Object a, final int index, final Object val) {
     } else if (a instanceof Object[]) {
       ((Object[]) a)[index] = val;
     } else {
-      ArrayUtils.set(a, index, val);
+      Array.set(a, index, val);
     }
   }
 }

File: src/main/java/com/googlecode/aviator/AviatorEvaluator.java
Patch:
@@ -541,7 +541,7 @@ public static Object execute(final String expression, final Map<String, Object>
    * @return
    */
   public static Object execute(final String expression, final Map<String, Object> env) {
-    return execute(expression, env, false);
+    return getInstance().execute(expression, env);
   }
 
 

File: src/main/java/com/googlecode/aviator/AviatorEvaluator.java
Patch:
@@ -541,7 +541,7 @@ public static Object execute(final String expression, final Map<String, Object>
    * @return
    */
   public static Object execute(final String expression, final Map<String, Object> env) {
-    return execute(expression, env, false);
+    return getInstance().execute(expression,env);
   }
 
 

File: src/main/java/com/googlecode/aviator/InterpretExpression.java
Patch:
@@ -47,7 +47,9 @@ private void loadVars(final List<VariableMeta> vars) {
   }
 
   private void loadConstants(final Set<Token<?>> constants, final List<IR> instruments) {
-    InterpretContext ctx = new InterpretContext(this, instruments, getCompileEnv());
+    final Env env = new Env();
+    env.setInstance(this.instance);
+    InterpretContext ctx = new InterpretContext(this, instruments, env);
     for (Token<?> token : constants) {
       final LoadIR loadConstantIR = new LoadIR(this.sourceFile, token, null, false);
       loadConstantIR.evalWithoutDispatch(ctx);

File: src/main/java/com/googlecode/aviator/code/interpreter/InterpretCodeGenerator.java
Patch:
@@ -246,7 +246,7 @@ public void onTernaryLeft(final Token<?> lookhead) {
     this.instruments
         .add(new GotoIR(peekLabel1(), new SourceInfo(this.sourceFile, lookhead.getLineNo())));
 
-    emit(PopIR.INSTANCE);
+    // emit(PopIR.INSTANCE);
     Label label0 = popLabel0();
     visitLabel(label0);
     emit(PopIR.INSTANCE);

File: src/main/java/com/googlecode/aviator/code/asm/ASMCodeGenerator.java
Patch:
@@ -505,10 +505,8 @@ private void visitRightBranch(final Token<?> lookhead, final int ints,
     if (!OperationRuntime.hasRuntimeContext(this.compileEnv, opType)) {
       this.mv.visitInsn(DUP);
       loadEnv();
-      String first = "TRUE";
       String second = "FALSE";
       if (opType == OperatorType.OR) {
-        first = "FALSE";
         second = "TRUE";
       }
 

File: src/test/java/com/googlecode/aviator/test/function/GrammarUnitTestWithInterpreter.java
Patch:
@@ -7,16 +7,14 @@
 import com.googlecode.aviator.Options;
 
 public class GrammarUnitTestWithInterpreter extends GrammarUnitTest {
-  private static EvalMode oldMode;
 
   @BeforeClass
   public static void setup() {
-    oldMode = AviatorEvaluator.getOptionValue(Options.EVAL_MODE).evalMode;
     AviatorEvaluator.setOption(Options.EVAL_MODE, EvalMode.INTERPRETER);
   }
 
   @AfterClass
   public static void tearDown() {
-    AviatorEvaluator.setOption(Options.EVAL_MODE, oldMode);
+    AviatorEvaluator.setOption(Options.EVAL_MODE, EvalMode.ASM);
   }
 }

File: src/main/java/com/googlecode/aviator/lexer/token/DelegateToken.java
Patch:
@@ -52,6 +52,9 @@ public DelegateToken(final Token<?> token, final DelegateTokenType type) {
         token != null ? token.getStartIndex() : -1);
     this.token = token;
     this.delegateTokenType = type;
+    if (token != null) {
+      setMetaMap(token.getMetaMap());
+    }
   }
 
 

File: src/main/java/com/googlecode/aviator/lexer/token/OperatorType.java
Patch:
@@ -20,7 +20,6 @@
 import com.googlecode.aviator.runtime.type.AviatorBoolean;
 import com.googlecode.aviator.runtime.type.AviatorJavaType;
 import com.googlecode.aviator.runtime.type.AviatorObject;
-import com.googlecode.aviator.utils.Env;
 
 
 /**
@@ -114,13 +113,13 @@ public AviatorObject eval(final AviatorObject[] args, final Map<String, Object>
         if (!(args[0] instanceof AviatorJavaType)) {
           throw new IllegalArgumentException(args[0].desc(env) + " can't be as a left value.");
         }
-        ((Env) env).override(((AviatorJavaType) args[0]).getName(), args[1].getValue(env));
+        args[0].defineValue(args[1], env);
         return args[1];
       case ASSIGNMENT:
         if (!(args[0] instanceof AviatorJavaType)) {
           throw new IllegalArgumentException(args[0].desc(env) + " can't be as a left value.");
         }
-        env.put(((AviatorJavaType) args[0]).getName(), args[1].getValue(env));
+        args[0].setValue(args[1], env);
         return args[1];
       case DIV:
         return args[0].div(args[1], env);

File: src/main/java/com/googlecode/aviator/runtime/function/internal/ReducerFunction.java
Patch:
@@ -7,6 +7,7 @@
 import com.googlecode.aviator.runtime.function.AbstractFunction;
 import com.googlecode.aviator.runtime.type.AviatorFunction;
 import com.googlecode.aviator.runtime.type.AviatorLong;
+import com.googlecode.aviator.runtime.type.AviatorNil;
 import com.googlecode.aviator.runtime.type.AviatorObject;
 import com.googlecode.aviator.runtime.type.AviatorRuntimeJavaType;
 import com.googlecode.aviator.runtime.type.Range;
@@ -41,7 +42,7 @@ public final AviatorObject call(final Map<String, Object> env, final AviatorObje
     AviatorFunction iteratorFn = (AviatorFunction) arg2;
 
     int maxLoopCount = RuntimeUtils.getInstance(env).getOptionValue(Options.MAX_LOOP_COUNT).number;
-    AviatorObject result = null;
+    AviatorObject result = AviatorNil.NIL;
     long c = 0;
 
     if (coll != Range.LOOP) {

File: src/main/java/com/googlecode/aviator/runtime/function/seq/SeqGetFunction.java
Patch:
@@ -35,7 +35,8 @@ public AviatorObject call(final Map<String, Object> env, final AviatorObject arg
     Object coll = arg1.getValue(env);
     Object key = arg2.getValue(env);
     if (coll == null) {
-      throw new NullPointerException("the collection of seq.get is null, which the value of key/index is `" + key + "`");
+      throw new NullPointerException(
+          "the collection of seq.get is null, which the value of key/index is `" + key + "`");
     }
     Class<?> clazz = coll.getClass();
 

File: src/main/java/com/googlecode/aviator/runtime/function/internal/IfCallccFunction.java
Patch:
@@ -31,13 +31,14 @@ public String getName() {
   @Override
   public AviatorObject call(final Map<String, Object> env, final AviatorObject arg1,
       final AviatorObject arg2) {
-    if (arg1 instanceof ReducerResult && ((ReducerResult) arg1).state != ReducerState.Cont) {
+    if (arg1 instanceof ReducerResult) {
       return arg1;
     } else {
       final Object nextClauseVal = arg2.getValue(env);
       if (nextClauseVal == Constants.REDUCER_EMPTY) {
         return arg1;
       }
+
       AviatorFunction otherClausesFn = (AviatorFunction) nextClauseVal;
       AviatorObject result = otherClausesFn.call(env);
       // No remaining statements, return the if statement result.

File: src/main/java/com/googlecode/aviator/utils/Reflector.java
Patch:
@@ -318,7 +318,7 @@ private static PropertyFoundResult retrieveGetterHandle(
     if (methods != null && !methods.isEmpty()) {
       Method method = methods.get(0);
       for (Method m : methods) {
-        if (method.getParameterTypes().length == 0) {
+        if (m.getParameterTypes().length == 0) {
           method = m;
           break;
         }
@@ -342,7 +342,7 @@ private static PropertyFoundResult retrieveSetterHandle(
     if (methods != null && !methods.isEmpty()) {
       Method method = methods.get(0);
       for (Method m : methods) {
-        if (method.getParameterTypes().length == 0) {
+        if (m.getParameterTypes().length == 1) {
           method = m;
           break;
         }

File: src/test/java/com/googlecode/aviator/test/function/FunctionTest.java
Patch:
@@ -14,8 +14,8 @@
  **/
 package com.googlecode.aviator.test.function;
 
-import static com.googlecode.aviator.TestUtils.assertEquals;
 import static com.googlecode.aviator.TestUtils.assertArrayEquals;
+import static com.googlecode.aviator.TestUtils.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNotSame;
@@ -1214,7 +1214,7 @@ public void testSeqNewArray() {
     Assert.assertArrayEquals(new short[] {-2, 3, 100},
         (short[]) AviatorEvaluator.execute("seq.array(short, -2, 3, 100)"));
 
-    assertEquals(101,
+    assertEquals(101L,
         (long) AviatorEvaluator.execute("reduce(seq.array(short, -2, 3, 100), +, 0)"));
   }
 

File: src/test/java/com/googlecode/aviator/test/function/GrammarUnitTest.java
Patch:
@@ -393,7 +393,7 @@ public void testIssue175() {
   @Test
   public void testIssue87() {
     AviatorEvaluator.setOption(Options.ALWAYS_PARSE_FLOATING_POINT_NUMBER_INTO_DECIMAL, true);
-    assertEquals(1, (long) AviatorEvaluator.execute("long(1.2)"));
+    assertEquals(1L, (long) AviatorEvaluator.execute("long(1.2)"));
     AviatorEvaluator.setOption(Options.ALWAYS_PARSE_FLOATING_POINT_NUMBER_INTO_DECIMAL, false);
   }
 

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorStringBuilder.java
Patch:
@@ -24,7 +24,7 @@ public AviatorStringBuilder(final String lexeme) {
   }
 
   @Override
-  public String getLexeme(final Map<String, Object> env) {
+  public String getLexeme(final Map<String, Object> env, final boolean warnOnCompile) {
     return this.sb.toString();
   }
 

File: src/main/java/com/googlecode/aviator/lexer/token/AbstractToken.java
Patch:
@@ -41,7 +41,7 @@ public int getLineNo() {
   }
 
 
-  protected final String lexeme;
+  protected String lexeme;
   private Map<String, Object> metaMap;
 
 

File: src/main/java/com/googlecode/aviator/lexer/token/Variable.java
Patch:
@@ -368,6 +368,9 @@ public Object getValue(final Map<String, Object> env) {
     }
   }
 
+  public void setLexeme(final String lexeme) {
+    this.lexeme = lexeme;
+  }
 
   public Variable(final String name, final int lineNo, final int startIndex) {
     super(name, lineNo, startIndex);

File: src/main/java/com/googlecode/aviator/LiteralExpression.java
Patch:
@@ -17,6 +17,7 @@
  **/
 import java.util.List;
 import java.util.Map;
+import com.googlecode.aviator.parser.VariableMeta;
 import com.googlecode.aviator.runtime.RuntimeUtils;
 
 
@@ -32,8 +33,8 @@ public class LiteralExpression extends BaseExpression {
 
 
   public LiteralExpression(final AviatorEvaluatorInstance instance, final Object result,
-      final List<String> varNames) {
-    super(instance, varNames, null);
+      final List<VariableMeta> vars) {
+    super(instance, vars, null);
     this.result = result;
   }
 

File: src/main/java/com/googlecode/aviator/lexer/token/Token.java
Patch:
@@ -36,6 +36,8 @@ enum TokenType {
 
   <V> V getMeta(final String name, final V defaultVal);
 
+  <V> V getMeta(final String name);
+
   T getValue(Map<String, Object> env);
 
   TokenType getType();

File: src/main/java/com/googlecode/aviator/utils/Constants.java
Patch:
@@ -34,6 +34,8 @@ public class Constants {
   public static final Variable THROWABLE_VAR = new Variable("Throwable", 0, -1);
   public static final String EXP_VAR = "__exp__";
   public static final Variable USE_VAR = new Variable("__use", 0, -1);
+  public static final String INIT_META = "isInitialized";
+  public static final String TYPE_META = "type";
 
   private Constants() {
 

File: src/main/java/com/googlecode/aviator/utils/Reflector.java
Patch:
@@ -161,7 +161,7 @@ public String toString() {
 
   }
 
-  public static Map<Class<?>, Reference<Map<String, MethodHandleResult>>> cachedHandles =
+  public static ConcurrentHashMap<Class<?>, Reference<Map<String, MethodHandleResult>>> cachedHandles =
       new ConcurrentHashMap<Class<?>, Reference<Map<String, MethodHandleResult>>>();
 
   private static final ReferenceQueue<Map<String, MethodHandleResult>> cacheHandleRq =

File: src/main/java/com/googlecode/aviator/parser/ExpressionParser.java
Patch:
@@ -1552,6 +1552,7 @@ private StatementType statement() {
         return StatementType.Other;
       }
     } else if (this.lookhead == Variable.USE) {
+      ensureFeatureEnabled(Feature.Use);
       useStatement();
       return StatementType.Other;
     } else {

File: src/main/java/com/googlecode/aviator/AviatorEvaluatorInstance.java
Patch:
@@ -1049,7 +1049,7 @@ public AviatorClassLoader getAviatorClassLoader(final boolean cached) {
     if (cached) {
       return this.aviatorClassLoader;
     } else {
-      return new AviatorClassLoader(Thread.currentThread().getContextClassLoader());
+      return new AviatorClassLoader(this.getClass().getClassLoader());
     }
   }
 

File: src/main/java/com/googlecode/aviator/code/CodeGenerator.java
Patch:
@@ -61,6 +61,8 @@ public interface CodeGenerator {
 
   public void onMult(Token<?> lookhead);
 
+  public void onExponent(Token<?> loohead);
+
 
   public void onDiv(Token<?> lookhead);
 

File: src/main/java/com/googlecode/aviator/runtime/function/seq/SeqNewArrayFunction.java
Patch:
@@ -46,13 +46,13 @@ public AviatorObject call(final Map<String, Object> env, final AviatorObject arg
 
     try {
       String name = ((AviatorJavaType) clazzVar).getName();
-      if (!name.contains(".")) {
-        name = "java.lang." + name;
-      }
       Class<?> clazz = null;
       if (TypeUtils.PRIMITIVE_TYPES.containsKey(name)) {
         clazz = TypeUtils.PRIMITIVE_TYPES.get(name);
       } else {
+        if (!name.contains(".")) {
+          name = "java.lang." + name;
+        }
         clazz = Class.forName(name);
       }
       return AviatorRuntimeJavaType.valueOf(Array.newInstance(clazz, len.intValue()));

File: src/test/java/com/googlecode/aviator/AviatorEvaluatorInstanceCompatibleUnitTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.googlecode.aviator;
 
-import static org.junit.Assert.assertEquals;
+import static com.googlecode.aviator.TestUtils.assertEquals;
 import static org.junit.Assert.fail;
 import java.math.MathContext;
 import org.junit.Before;

File: src/test/java/com/googlecode/aviator/AviatorEvaluatorUnitTest.java
Patch:
@@ -15,7 +15,7 @@
  **/
 package com.googlecode.aviator;
 
-import static org.junit.Assert.assertEquals;
+import static com.googlecode.aviator.TestUtils.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertSame;

File: src/test/java/com/googlecode/aviator/LambdaUnitTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.googlecode.aviator;
 
-import static org.junit.Assert.assertEquals;
+import static com.googlecode.aviator.TestUtils.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;

File: src/test/java/com/googlecode/aviator/ScriptEngineTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.googlecode.aviator;
 
-import static org.junit.Assert.assertEquals;
+import static com.googlecode.aviator.TestUtils.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import java.io.FileReader;

File: src/test/java/com/googlecode/aviator/example/SimpleExample.java
Patch:
@@ -5,7 +5,8 @@
 
 public class SimpleExample {
   public static void main(final String[] args) throws Exception {
-    Long result = (Long) AviatorEvaluator.execute("1+2+3");
-    System.out.println(result);
+    boolean result1 = (Boolean) AviatorEvaluator.execute("1.8620639E7==18620639");
+    boolean result2 = (Boolean) AviatorEvaluator.execute("1.9455127E7==19455127");
+    System.out.println(result2);
   }
 }

File: src/test/java/com/googlecode/aviator/test/function/OperatorFunctionTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.googlecode.aviator.test.function;
 
-import static org.junit.Assert.assertEquals;
+import static com.googlecode.aviator.TestUtils.assertEquals;
 import static org.junit.Assert.fail;
 import java.util.Arrays;
 import java.util.HashMap;

File: src/main/java/com/googlecode/aviator/AviatorEvaluatorInstance.java
Patch:
@@ -211,7 +211,7 @@ public void addFunctionLoader(final FunctionLoader loader) {
 
   /**
    * Retrieve current env processor, default is null.
-   * 
+   *
    * @since 5.2.0
    * @return
    */
@@ -1340,7 +1340,7 @@ private Expression getCompiledExpression(final String cacheKey,
       final Throwable cause = t.getCause();
       if (cause instanceof ExpressionSyntaxErrorException
           || cause instanceof CompileExpressionErrorException) {
-        Reflector.sneakyThrow(cause);
+        throw Reflector.sneakyThrow(cause);
       }
       throw new CompileExpressionErrorException("Compile expression failure, cacheKey=" + cacheKey,
           t);

File: src/test/java/com/googlecode/aviator/AviatorEvaluatorInstanceCompatibleUnitTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.googlecode.aviator;
 
-import static org.junit.Assert.assertEquals;
+import static com.googlecode.aviator.TestUtils.assertEquals;
 import static org.junit.Assert.fail;
 import java.math.MathContext;
 import org.junit.Before;

File: src/test/java/com/googlecode/aviator/AviatorEvaluatorInstanceUnitTest.java
Patch:
@@ -15,7 +15,7 @@
  **/
 package com.googlecode.aviator;
 
-import static org.junit.Assert.assertEquals;
+import static com.googlecode.aviator.TestUtils.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNotSame;

File: src/test/java/com/googlecode/aviator/AviatorEvaluatorUnitTest.java
Patch:
@@ -15,7 +15,7 @@
  **/
 package com.googlecode.aviator;
 
-import static org.junit.Assert.assertEquals;
+import static com.googlecode.aviator.TestUtils.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertSame;

File: src/test/java/com/googlecode/aviator/LambdaUnitTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.googlecode.aviator;
 
-import static org.junit.Assert.assertEquals;
+import static com.googlecode.aviator.TestUtils.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;

File: src/test/java/com/googlecode/aviator/ScriptEngineTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.googlecode.aviator;
 
-import static org.junit.Assert.assertEquals;
+import static com.googlecode.aviator.TestUtils.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import java.io.FileReader;

File: src/test/java/com/googlecode/aviator/scripts/TestScripts.java
Patch:
@@ -1,6 +1,6 @@
 package com.googlecode.aviator.scripts;
 
-import static org.junit.Assert.assertEquals;
+import static com.googlecode.aviator.TestUtils.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;

File: src/test/java/com/googlecode/aviator/test/function/OperatorFunctionTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.googlecode.aviator.test.function;
 
-import static org.junit.Assert.assertEquals;
+import static com.googlecode.aviator.TestUtils.assertEquals;
 import static org.junit.Assert.fail;
 import java.util.Arrays;
 import java.util.HashMap;

File: src/test/java/com/googlecode/aviator/scripts/TestScripts.java
Patch:
@@ -14,6 +14,7 @@
 import com.googlecode.aviator.Expression;
 import com.googlecode.aviator.exception.ExpressionSyntaxErrorException;
 import com.googlecode.aviator.exception.StandardError;
+import com.googlecode.aviator.runtime.module.IoModule;
 import com.googlecode.aviator.runtime.type.Range;
 import com.googlecode.aviator.utils.Reflector;
 
@@ -30,6 +31,8 @@ public void setup() throws Exception {
   public Object testScript(final String name, final Object... args) {
     try {
       System.out.println("Testing script " + name + " with args: " + Arrays.toString(args));
+      this.instance
+          .validate(IoModule.slurp(TestScripts.class.getResource("/scripts/" + name).getFile()));
       Expression exp = this.instance
           .compileScript(TestScripts.class.getResource("/scripts/" + name).getFile(), true);
       return exp.execute(AviatorEvaluator.newEnv(args));

File: src/main/java/com/googlecode/aviator/runtime/function/seq/SeqNewArrayFunction.java
Patch:
@@ -46,13 +46,13 @@ public AviatorObject call(final Map<String, Object> env, final AviatorObject arg
 
     try {
       String name = ((AviatorJavaType) clazzVar).getName();
-      if (!name.contains(".")) {
-        name = "java.lang." + name;
-      }
       Class<?> clazz = null;
       if (TypeUtils.PRIMITIVE_TYPES.containsKey(name)) {
         clazz = TypeUtils.PRIMITIVE_TYPES.get(name);
       } else {
+        if (!name.contains(".")) {
+          name = "java.lang." + name;
+        }
         clazz = Class.forName(name);
       }
       return AviatorRuntimeJavaType.valueOf(Array.newInstance(clazz, len.intValue()));

File: src/main/java/com/googlecode/aviator/runtime/function/LambdaFunction.java
Patch:
@@ -50,7 +50,7 @@ protected Map<String, Object> newEnv(final Map<String, Object> parentEnv,
     Env env = null;
     if (!this.inheritEnv) {
       final Env contextEnv = new Env(parentEnv, this.context);
-      contextEnv.setInstance(this.context.getInstance());
+      contextEnv.configure(this.context.getInstance(), this.expression);
       env = new Env(contextEnv);
       env.setInstance(this.context.getInstance());
     } else {

File: src/test/java/com/googlecode/aviator/LambdaUnitTest.java
Patch:
@@ -107,7 +107,7 @@ public void testSpecialVars() {
 
     Map<String, Object> result = (Map<String, Object>) AviatorEvaluator.execute("#__env__", env);
 
-    assertEquals(4, result.size());
+    assertEquals(3, result.size());
     assertEquals("a", result.get("a"));
     assertEquals(3.2, result.get("b"));
     assertSame(c, result.get("c"));

File: src/test/java/com/googlecode/aviator/test/function/GrammarUnitTest.java
Patch:
@@ -211,7 +211,7 @@ public void testIfElseVar() {
     String r1 = "result=true;v1='test1';if(!result) {return 'ok';} v2='test2'; result";
     Map<String, Object> env = new HashMap<>();
     Assert.assertTrue((boolean) AviatorEvaluator.execute(r1, env));
-    assertEquals(4, env.size());
+    assertEquals(3, env.size());
     assertEquals(true, env.get("result"));
     assertEquals("test1", env.get("v1"));
     assertEquals("test2", env.get("v2"));

File: src/main/java/com/googlecode/aviator/RuntimeFunctionDelegator.java
Patch:
@@ -1,6 +1,7 @@
 package com.googlecode.aviator;
 
 import java.util.Map;
+import com.googlecode.aviator.exception.CompareNotSupportedException;
 import com.googlecode.aviator.exception.FunctionNotFoundException;
 import com.googlecode.aviator.lexer.SymbolTable;
 import com.googlecode.aviator.runtime.function.system.ConstantFunction;
@@ -33,7 +34,7 @@ public void run() {
 
   @Override
   public int innerCompare(final AviatorObject other, final Map<String, Object> env) {
-    throw new UnsupportedOperationException("Lambda function can't be compared.");
+    throw new CompareNotSupportedException("Lambda function can't be compared.");
   }
 
   @Override

File: src/main/java/com/googlecode/aviator/runtime/function/AbstractFunction.java
Patch:
@@ -1,6 +1,7 @@
 package com.googlecode.aviator.runtime.function;
 
 import java.util.Map;
+import com.googlecode.aviator.exception.CompareNotSupportedException;
 import com.googlecode.aviator.runtime.type.AviatorFunction;
 import com.googlecode.aviator.runtime.type.AviatorObject;
 import com.googlecode.aviator.runtime.type.AviatorType;
@@ -45,7 +46,7 @@ public AviatorObject call(final Map<String, Object> env) {
 
   @Override
   public int innerCompare(final AviatorObject other, final Map<String, Object> env) {
-    throw new UnsupportedOperationException("Lambda function can't be compared.");
+    throw new CompareNotSupportedException("Lambda function can't be compared.");
   }
 
 

File: src/main/java/com/googlecode/aviator/runtime/function/AbstractVariadicFunction.java
Patch:
@@ -1,6 +1,7 @@
 package com.googlecode.aviator.runtime.function;
 
 import java.util.Map;
+import com.googlecode.aviator.exception.CompareNotSupportedException;
 import com.googlecode.aviator.runtime.type.AviatorFunction;
 import com.googlecode.aviator.runtime.type.AviatorObject;
 import com.googlecode.aviator.runtime.type.AviatorType;
@@ -49,7 +50,7 @@ public Object getValue(final Map<String, Object> env) {
 
   @Override
   public int innerCompare(final AviatorObject other, final Map<String, Object> env) {
-    throw new UnsupportedOperationException("Lambda function can't be compared.");
+    throw new CompareNotSupportedException("Lambda function can't be compared.");
   }
 
   @Override

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorBoolean.java
Patch:
@@ -16,7 +16,7 @@
 package com.googlecode.aviator.runtime.type;
 
 import java.util.Map;
-import com.googlecode.aviator.exception.ExpressionRuntimeException;
+import com.googlecode.aviator.exception.CompareNotSupportedException;
 import com.googlecode.aviator.utils.TypeUtils;
 
 
@@ -113,13 +113,13 @@ public int innerCompare(final AviatorObject other, final Map<String, Object> env
         if (otherValue instanceof Boolean) {
           return this.value.compareTo((Boolean) otherValue);
         } else {
-          throw new ExpressionRuntimeException(
+          throw new CompareNotSupportedException(
               "Could not compare " + desc(env) + " with " + other.desc(env));
         }
       case Nil:
         return 1;
       default:
-        throw new ExpressionRuntimeException(
+        throw new CompareNotSupportedException(
             "Could not compare " + desc(env) + " with " + other.desc(env));
     }
 

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorNumber.java
Patch:
@@ -18,7 +18,7 @@
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Map;
-import com.googlecode.aviator.exception.ExpressionRuntimeException;
+import com.googlecode.aviator.exception.CompareNotSupportedException;
 import com.googlecode.aviator.runtime.RuntimeUtils;
 import com.googlecode.aviator.utils.TypeUtils;
 
@@ -229,13 +229,13 @@ public int innerCompare(final AviatorObject other, final Map<String, Object> env
         if (otherValue instanceof Number) {
           return innerCompare(env, AviatorNumber.valueOf(otherValue));
         } else {
-          throw new ExpressionRuntimeException(
+          throw new CompareNotSupportedException(
               "Could not compare " + desc(env) + " with " + other.desc(env));
         }
       case Nil:
         return 1;
       default:
-        throw new ExpressionRuntimeException(
+        throw new CompareNotSupportedException(
             "Could not compare " + desc(env) + " with " + other.desc(env));
 
     }

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorString.java
Patch:
@@ -22,6 +22,7 @@
 import com.googlecode.aviator.AviatorEvaluatorInstance.StringSegments;
 import com.googlecode.aviator.BaseExpression;
 import com.googlecode.aviator.Feature;
+import com.googlecode.aviator.exception.CompareNotSupportedException;
 import com.googlecode.aviator.exception.ExpressionRuntimeException;
 import com.googlecode.aviator.runtime.RuntimeUtils;
 import com.googlecode.aviator.utils.Constants;
@@ -121,7 +122,7 @@ public int innerCompare(final AviatorObject other, final Map<String, Object> env
         } else if (otherJavaValue instanceof Date) {
           return tryCompareDate(env, (Date) otherJavaValue);
         } else {
-          throw new ExpressionRuntimeException(
+          throw new CompareNotSupportedException(
               "Could not compare " + desc(env) + " with " + other.desc(env));
         }
       case Nil:
@@ -131,7 +132,7 @@ public int innerCompare(final AviatorObject other, final Map<String, Object> env
           return 1;
         }
       default:
-        throw new ExpressionRuntimeException(
+        throw new CompareNotSupportedException(
             "Could not compare " + desc(env) + " with " + other.desc(env));
     }
   }

File: src/main/java/com/googlecode/aviator/runtime/type/Range.java
Patch:
@@ -6,6 +6,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.NoSuchElementException;
+import com.googlecode.aviator.exception.CompareNotSupportedException;
 import com.googlecode.aviator.utils.Env;
 
 /**
@@ -42,7 +43,7 @@ public String desc(final Map<String, Object> env) {
 
   @Override
   public int innerCompare(final AviatorObject other, final Map<String, Object> env) {
-    throw new UnsupportedOperationException();
+    throw new CompareNotSupportedException();
   }
 
 

File: src/main/java/com/googlecode/aviator/RuntimeFunctionDelegator.java
Patch:
@@ -1,6 +1,7 @@
 package com.googlecode.aviator;
 
 import java.util.Map;
+import com.googlecode.aviator.exception.CompareNotSupportedException;
 import com.googlecode.aviator.exception.FunctionNotFoundException;
 import com.googlecode.aviator.lexer.SymbolTable;
 import com.googlecode.aviator.runtime.function.system.ConstantFunction;
@@ -33,7 +34,7 @@ public void run() {
 
   @Override
   public int innerCompare(final AviatorObject other, final Map<String, Object> env) {
-    throw new UnsupportedOperationException("Lambda function can't be compared.");
+    throw new CompareNotSupportedException("Lambda function can't be compared.");
   }
 
   @Override

File: src/main/java/com/googlecode/aviator/runtime/function/AbstractFunction.java
Patch:
@@ -1,6 +1,7 @@
 package com.googlecode.aviator.runtime.function;
 
 import java.util.Map;
+import com.googlecode.aviator.exception.CompareNotSupportedException;
 import com.googlecode.aviator.runtime.type.AviatorFunction;
 import com.googlecode.aviator.runtime.type.AviatorObject;
 import com.googlecode.aviator.runtime.type.AviatorType;
@@ -45,7 +46,7 @@ public AviatorObject call(final Map<String, Object> env) {
 
   @Override
   public int innerCompare(final AviatorObject other, final Map<String, Object> env) {
-    throw new UnsupportedOperationException("Lambda function can't be compared.");
+    throw new CompareNotSupportedException("Lambda function can't be compared.");
   }
 
 

File: src/main/java/com/googlecode/aviator/runtime/function/AbstractVariadicFunction.java
Patch:
@@ -1,6 +1,7 @@
 package com.googlecode.aviator.runtime.function;
 
 import java.util.Map;
+import com.googlecode.aviator.exception.CompareNotSupportedException;
 import com.googlecode.aviator.runtime.type.AviatorFunction;
 import com.googlecode.aviator.runtime.type.AviatorObject;
 import com.googlecode.aviator.runtime.type.AviatorType;
@@ -49,7 +50,7 @@ public Object getValue(final Map<String, Object> env) {
 
   @Override
   public int innerCompare(final AviatorObject other, final Map<String, Object> env) {
-    throw new UnsupportedOperationException("Lambda function can't be compared.");
+    throw new CompareNotSupportedException("Lambda function can't be compared.");
   }
 
   @Override

File: src/main/java/com/googlecode/aviator/runtime/function/seq/AbstractSeqMinMaxFunction.java
Patch:
@@ -1,7 +1,7 @@
 package com.googlecode.aviator.runtime.function.seq;
 
 import java.util.Map;
-import com.googlecode.aviator.exception.ExpressionRuntimeException;
+import com.googlecode.aviator.exception.CompareNotSupportedException;
 import com.googlecode.aviator.runtime.RuntimeUtils;
 import com.googlecode.aviator.runtime.function.AbstractFunction;
 import com.googlecode.aviator.runtime.type.AviatorNil;
@@ -84,8 +84,8 @@ private boolean compare(final Object result, final Object obj) {
       }
       return false;
     } catch (RuntimeException e) {
-      throw new ExpressionRuntimeException("Could not compare `" + obj + "` with `" + result + "`",
-          e);
+      throw new CompareNotSupportedException(
+          "Could not compare `" + obj + "` with `" + result + "`", e);
     }
   }
 

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorBoolean.java
Patch:
@@ -16,7 +16,7 @@
 package com.googlecode.aviator.runtime.type;
 
 import java.util.Map;
-import com.googlecode.aviator.exception.ExpressionRuntimeException;
+import com.googlecode.aviator.exception.CompareNotSupportedException;
 import com.googlecode.aviator.utils.TypeUtils;
 
 
@@ -113,13 +113,13 @@ public int innerCompare(final AviatorObject other, final Map<String, Object> env
         if (otherValue instanceof Boolean) {
           return this.value.compareTo((Boolean) otherValue);
         } else {
-          throw new ExpressionRuntimeException(
+          throw new CompareNotSupportedException(
               "Could not compare " + desc(env) + " with " + other.desc(env));
         }
       case Nil:
         return 1;
       default:
-        throw new ExpressionRuntimeException(
+        throw new CompareNotSupportedException(
             "Could not compare " + desc(env) + " with " + other.desc(env));
     }
 

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorNumber.java
Patch:
@@ -18,7 +18,7 @@
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Map;
-import com.googlecode.aviator.exception.ExpressionRuntimeException;
+import com.googlecode.aviator.exception.CompareNotSupportedException;
 import com.googlecode.aviator.runtime.RuntimeUtils;
 import com.googlecode.aviator.utils.TypeUtils;
 
@@ -229,13 +229,13 @@ public int innerCompare(final AviatorObject other, final Map<String, Object> env
         if (otherValue instanceof Number) {
           return innerCompare(env, AviatorNumber.valueOf(otherValue));
         } else {
-          throw new ExpressionRuntimeException(
+          throw new CompareNotSupportedException(
               "Could not compare " + desc(env) + " with " + other.desc(env));
         }
       case Nil:
         return 1;
       default:
-        throw new ExpressionRuntimeException(
+        throw new CompareNotSupportedException(
             "Could not compare " + desc(env) + " with " + other.desc(env));
 
     }

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorString.java
Patch:
@@ -22,6 +22,7 @@
 import com.googlecode.aviator.AviatorEvaluatorInstance.StringSegments;
 import com.googlecode.aviator.BaseExpression;
 import com.googlecode.aviator.Feature;
+import com.googlecode.aviator.exception.CompareNotSupportedException;
 import com.googlecode.aviator.exception.ExpressionRuntimeException;
 import com.googlecode.aviator.runtime.RuntimeUtils;
 import com.googlecode.aviator.utils.Constants;
@@ -121,7 +122,7 @@ public int innerCompare(final AviatorObject other, final Map<String, Object> env
         } else if (otherJavaValue instanceof Date) {
           return tryCompareDate(env, (Date) otherJavaValue);
         } else {
-          throw new ExpressionRuntimeException(
+          throw new CompareNotSupportedException(
               "Could not compare " + desc(env) + " with " + other.desc(env));
         }
       case Nil:
@@ -131,7 +132,7 @@ public int innerCompare(final AviatorObject other, final Map<String, Object> env
           return 1;
         }
       default:
-        throw new ExpressionRuntimeException(
+        throw new CompareNotSupportedException(
             "Could not compare " + desc(env) + " with " + other.desc(env));
     }
   }

File: src/main/java/com/googlecode/aviator/runtime/type/Range.java
Patch:
@@ -6,6 +6,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.NoSuchElementException;
+import com.googlecode.aviator.exception.CompareNotSupportedException;
 import com.googlecode.aviator.utils.Env;
 
 /**
@@ -42,7 +43,7 @@ public String desc(final Map<String, Object> env) {
 
   @Override
   public int innerCompare(final AviatorObject other, final Map<String, Object> env) {
-    throw new UnsupportedOperationException();
+    throw new CompareNotSupportedException();
   }
 
 

File: src/main/java/com/googlecode/aviator/AviatorEvaluatorInstance.java
Patch:
@@ -1551,7 +1551,8 @@ public StringSegments compileStringSegments(final String lexeme) {
 
             Expression exp = parser.parse(false);
             final Token<?> lookhead = parser.getLookhead();
-            if (lookhead.getType() != TokenType.Char || ((CharToken) lookhead).getCh() != '}') {
+            if (lookhead == null || (lookhead.getType() != TokenType.Char
+                || ((CharToken) lookhead).getCh() != '}')) {
               parser.reportSyntaxError("expect '}' to complete string interpolation");
             }
             int expStrLen = lookhead.getStartIndex() + 1;

File: src/main/java/com/googlecode/aviator/lexer/token/OperatorType.java
Patch:
@@ -118,7 +118,7 @@ public AviatorObject eval(final AviatorObject[] args, final Map<String, Object>
         if (!(args[0] instanceof AviatorJavaType)) {
           throw new IllegalArgumentException(args[0].desc(env) + " can't be as a left value.");
         }
-        env.put((String) args[0].getValue(env), args[1].getValue(env));
+        env.put(((AviatorJavaType) args[0]).getName(), args[1].getValue(env));
         return args[1];
       case DIV:
         return args[0].div(args[1], env);

File: src/main/java/com/googlecode/aviator/parser/ExpressionParser.java
Patch:
@@ -538,7 +538,7 @@ public void unary() {
           }
         }
         if (expectChar(')')) {
-          cg.onMethodInvoke(this.lookhead.withMeta(Constants.PARAMS_META, params));
+          cg.onMethodInvoke(currentToken().withMeta(Constants.PARAMS_META, params));
           this.scope.leaveParen();
           move(true);
         }
@@ -800,7 +800,7 @@ private void method() {
       }
       if (expectChar(')')) {
         getCodeGeneratorWithTimes()
-            .onMethodInvoke(this.lookhead.withMeta(Constants.PARAMS_META, params));
+            .onMethodInvoke(currentToken().withMeta(Constants.PARAMS_META, params));
         move(true);
         this.scope.leaveParen();
       }

File: src/main/java/com/googlecode/aviator/parser/ExpressionParser.java
Patch:
@@ -1046,7 +1046,7 @@ private void letStatement() {
       reportSyntaxError("invalid value to define");
     }
     ensureFeatureEnabled(Feature.Assignment);
-    getCodeGeneratorWithTimes().onAssignment(this.lookhead.withMeta(Constants.DEFINE_META, true));
+    getCodeGeneratorWithTimes().onAssignment(currentToken().withMeta(Constants.DEFINE_META, true));
     if (!expectChar(';')) {
       reportSyntaxError("missing ';' for let statement");
     }

File: src/main/java/com/googlecode/aviator/runtime/function/internal/NewInstanceFunction.java
Patch:
@@ -48,8 +48,8 @@ public AviatorObject variadicCall(final Map<String, Object> env, final AviatorOb
       }
       Constructor<?> bestMatch = null;
       for (Constructor<?> constructor : constructors) {
-        if (constructor.getParameters().length == constructArgs.length) {
-          final Class<?>[] pTypes = constructor.getParameterTypes();
+        final Class<?>[] pTypes = constructor.getParameterTypes();
+        if (pTypes.length == constructArgs.length) {
           if (Reflector.isCongruent(pTypes, constructArgs)) {
             bestMatch = constructor;
             for (int i = 0; i < constructArgs.length; i++) {

File: src/main/java/com/googlecode/aviator/lexer/token/OperatorType.java
Patch:
@@ -121,10 +121,10 @@ public AviatorObject eval(final AviatorObject[] args, final Map<String, Object>
       case MULT:
         return args[0].mult(args[1], env);
       case EQ:
-        int result = args[0].compare(args[1], env);
+        int result = args[0].compareEq(args[1], env);
         return AviatorBoolean.valueOf(result == 0);
       case NEQ:
-        result = args[0].compare(args[1], env);
+        result = args[0].compareEq(args[1], env);
         return AviatorBoolean.valueOf(result != 0);
       case LT:
         result = args[0].compare(args[1], env);

File: src/main/java/com/googlecode/aviator/runtime/function/internal/ReducerState.java
Patch:
@@ -6,5 +6,5 @@
  * @since 5.0.0
  */
 public enum ReducerState {
-  Cont, Break, Return, Empty
+  Empty, Cont, Break, Return
 }

File: src/main/java/com/googlecode/aviator/runtime/function/seq/SeqArrayFunction.java
Patch:
@@ -47,6 +47,9 @@ public AviatorObject variadicCall(final Map<String, Object> env, final AviatorOb
       if (TypeUtils.PRIMITIVE_TYPES.containsKey(name)) {
         clazz = TypeUtils.PRIMITIVE_TYPES.get(name);
       } else {
+        if (!name.contains(".")) {
+          name = "java.lang." + name;
+        }
         clazz = Class.forName(name);
       }
       Object ret = Array.newInstance(clazz, args.length - 1);

File: src/main/java/com/googlecode/aviator/runtime/function/seq/SeqNewArrayFunction.java
Patch:
@@ -46,6 +46,9 @@ public AviatorObject call(final Map<String, Object> env, final AviatorObject arg
 
     try {
       String name = ((AviatorJavaType) clazzVar).getName();
+      if (!name.contains(".")) {
+        name = "java.lang." + name;
+      }
       Class<?> clazz = null;
       if (TypeUtils.PRIMITIVE_TYPES.containsKey(name)) {
         clazz = TypeUtils.PRIMITIVE_TYPES.get(name);

File: src/main/java/com/googlecode/aviator/utils/Reflector.java
Patch:
@@ -336,7 +336,7 @@ static public boolean paramArgTypeMatch(final Class paramType, final Class argTy
     return false;
   }
 
-  static boolean isCongruent(final Class[] params, final Object[] args) {
+  public static boolean isCongruent(final Class[] params, final Object[] args) {
     boolean ret = false;
     if (args == null) {
       return params.length == 0;

File: src/main/java/com/googlecode/aviator/code/LambdaGenerator.java
Patch:
@@ -213,7 +213,7 @@ public LambdaFunctionBootstrap getLmabdaBootstrap() {
     try {
 
       Class<?> defineClass = null;
-      if (ClassDefiner.isJDK7()) {
+      if (ClassDefiner.IS_JDK7 || ClassDefiner.IS_IBM_SDK) {
         defineClass =
             ClassDefiner.defineClassByClassLoader(this.className, bytes, this.classLoader);
       } else {

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorJavaType.java
Patch:
@@ -30,6 +30,7 @@
 import com.googlecode.aviator.runtime.type.AviatorRuntimeJavaElementType.ContainerType;
 import com.googlecode.aviator.utils.Constants;
 import com.googlecode.aviator.utils.Env;
+import com.googlecode.aviator.utils.Reflector;
 import com.googlecode.aviator.utils.TypeUtils;
 
 /**
@@ -394,12 +395,12 @@ private static Object getProperty(final String name, final Map<String, Object> e
 
         // fallback to property utils
         if (!(val instanceof Map)) {
-          return PropertyUtils.getProperty(env, name);
+          return Reflector.getProperty(name, env);
         }
 
         innerEnv = (Map<String, Object>) val;
       }
-      return PropertyUtils.getProperty(env, name);
+      return Reflector.getProperty(name, env);
 
     } catch (Throwable t) {
       if (RuntimeUtils.getInstance(env).getOptionValue(Options.TRACE_EVAL).bool) {

File: src/main/java/com/googlecode/aviator/runtime/function/LambdaFunction.java
Patch:
@@ -2,6 +2,7 @@
 
 import java.util.List;
 import java.util.Map;
+import com.googlecode.aviator.BaseExpression;
 import com.googlecode.aviator.Expression;
 import com.googlecode.aviator.runtime.type.AviatorObject;
 import com.googlecode.aviator.utils.Env;
@@ -18,7 +19,7 @@ public abstract class LambdaFunction extends AbstractFunction {
   protected List<String> arguments;
 
   // the compiled lambda body expression
-  protected Expression expression;
+  protected BaseExpression expression;
 
   // closure context
   protected Env context;
@@ -35,7 +36,7 @@ public LambdaFunction(final List<String> arguments, final Expression expression,
     super();
     this.arguments = arguments;
     this.context = context;
-    this.expression = expression;
+    this.expression = (BaseExpression) expression;
   }
 
   protected Map<String, Object> newEnv(final Map<String, Object> parentEnv,

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorJavaType.java
Patch:
@@ -558,6 +558,7 @@ private boolean isInteger(final Object value) {
   @Override
   public AviatorObject add(final AviatorObject other, final Map<String, Object> env) {
     final Object value = getValue(env);
+    Object otherValue;
     if (value instanceof Number) {
       AviatorNumber aviatorNumber = AviatorNumber.valueOf(value);
       return aviatorNumber.add(other, env);
@@ -566,6 +567,8 @@ public AviatorObject add(final AviatorObject other, final Map<String, Object> en
       return aviatorString.add(other, env);
     } else if (value instanceof Boolean) {
       return AviatorBoolean.valueOf((Boolean) value).add(other, env);
+    } else if (value == null && (otherValue = other.getValue(env)) instanceof CharSequence) {
+      return new AviatorString("null" + otherValue);
     } else {
       return super.add(other, env);
     }

File: src/main/java/com/googlecode/aviator/runtime/RuntimeUtils.java
Patch:
@@ -88,5 +88,4 @@ public static void printStackTrace(final Map<String, Object> env, final Exceptio
       e.printStackTrace();
     }
   }
-
 }

File: src/main/java/com/googlecode/aviator/runtime/function/FunctionUtils.java
Patch:
@@ -177,7 +177,7 @@ public static AviatorObject wrapReturn(final Object ret) {
     } else if (ret instanceof AviatorObject) {
       return (AviatorObject) ret;
     } else {
-      return new AviatorRuntimeJavaType(ret);
+      return AviatorRuntimeJavaType.valueOf(ret);
     }
   }
 

File: src/main/java/com/googlecode/aviator/runtime/function/seq/SeqCompsitePredFunFunction.java
Patch:
@@ -44,7 +44,7 @@ public SeqCompsitePredFunFunction(String name, LogicOp op) {
   public AviatorObject variadicCall(Map<String, Object> env, AviatorObject... args) {
     if (args == null || args.length == 0)
       return AviatorBoolean.valueOf(op == LogicOp.AND);
-    return new AviatorRuntimeJavaType(createFunction(env, args, op));
+    return AviatorRuntimeJavaType.valueOf(createFunction(env, args, op));
   }
 
 

File: src/main/java/com/googlecode/aviator/runtime/function/seq/SeqEveryFunction.java
Patch:
@@ -34,15 +34,15 @@ public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorOb
 
     if (Collection.class.isAssignableFrom(clazz)) {
       for (Object obj : (Collection<?>) first) {
-        if (!fun.call(env, new AviatorRuntimeJavaType(obj)).booleanValue(env)) {
+        if (!fun.call(env, AviatorRuntimeJavaType.valueOf(obj)).booleanValue(env)) {
           return AviatorBoolean.FALSE;
         }
       }
     } else if (clazz.isArray()) {
       int length = Array.getLength(first);
       for (int i = 0; i < length; i++) {
         Object obj = Array.get(first, i);
-        if (!fun.call(env, new AviatorRuntimeJavaType(obj)).booleanValue(env)) {
+        if (!fun.call(env, AviatorRuntimeJavaType.valueOf(obj)).booleanValue(env)) {
           return AviatorBoolean.FALSE;
         }
       }

File: src/main/java/com/googlecode/aviator/runtime/function/seq/SeqIncludeFunction.java
Patch:
@@ -46,7 +46,7 @@ public AviatorObject call(final Map<String, Object> env, final AviatorObject arg
       Collection<?> seq = (Collection<?>) first;
       try {
         for (Object obj : seq) {
-          if (new AviatorRuntimeJavaType(obj).compare(arg2, env) == 0) {
+          if (AviatorRuntimeJavaType.valueOf(obj).compare(arg2, env) == 0) {
             contains = true;
             break;
           }
@@ -61,7 +61,7 @@ public AviatorObject call(final Map<String, Object> env, final AviatorObject arg
         int length = Array.getLength(first);
         for (int i = 0; i < length; i++) {
           Object obj = Array.get(first, i);
-          if (new AviatorRuntimeJavaType(obj).compare(arg2, env) == 0) {
+          if (AviatorRuntimeJavaType.valueOf(obj).compare(arg2, env) == 0) {
             contains = true;
             break;
           }

File: src/main/java/com/googlecode/aviator/runtime/function/seq/SeqNewArrayFunction.java
Patch:
@@ -65,7 +65,7 @@ public AviatorObject variadicCall(final Map<String, Object> env, final AviatorOb
         Array.set(ret, i - 1, Reflector.boxArg(clazz, args[i].getValue(env)));
       }
 
-      return new AviatorRuntimeJavaType(ret);
+      return AviatorRuntimeJavaType.valueOf(ret);
     } catch (Throwable t) {
       throw Reflector.sneakyThrow(t);
     }

File: src/main/java/com/googlecode/aviator/runtime/function/seq/SeqNewListFunction.java
Patch:
@@ -29,7 +29,7 @@ public AviatorObject variadicCall(Map<String, Object> env, AviatorObject... args
       list.add(obj.getValue(env));
     }
 
-    return new AviatorRuntimeJavaType(list);
+    return AviatorRuntimeJavaType.valueOf(list);
   }
 
 

File: src/main/java/com/googlecode/aviator/runtime/function/seq/SeqNewMapFunction.java
Patch:
@@ -33,7 +33,7 @@ public AviatorObject variadicCall(Map<String, Object> env, AviatorObject... args
       i += 2;
     }
 
-    return new AviatorRuntimeJavaType(map);
+    return AviatorRuntimeJavaType.valueOf(map);
   }
 
 }

File: src/main/java/com/googlecode/aviator/runtime/function/seq/SeqNewSetFunction.java
Patch:
@@ -29,7 +29,7 @@ public AviatorObject variadicCall(Map<String, Object> env, AviatorObject... args
       set.add(obj.getValue(env));
     }
 
-    return new AviatorRuntimeJavaType(set);
+    return AviatorRuntimeJavaType.valueOf(set);
   }
 
 

File: src/main/java/com/googlecode/aviator/runtime/function/seq/SeqNotAnyFunction.java
Patch:
@@ -34,15 +34,15 @@ public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorOb
 
     if (Collection.class.isAssignableFrom(clazz)) {
       for (Object obj : (Collection<?>) first) {
-        if (fun.call(env, new AviatorRuntimeJavaType(obj)).booleanValue(env)) {
+        if (fun.call(env, AviatorRuntimeJavaType.valueOf(obj)).booleanValue(env)) {
           return AviatorBoolean.FALSE;
         }
       }
     } else if (clazz.isArray()) {
       int length = Array.getLength(first);
       for (int i = 0; i < length; i++) {
         Object obj = Array.get(first, i);
-        if (fun.call(env, new AviatorRuntimeJavaType(obj)).booleanValue(env)) {
+        if (fun.call(env, AviatorRuntimeJavaType.valueOf(obj)).booleanValue(env)) {
           return AviatorBoolean.FALSE;
         }
       }

File: src/main/java/com/googlecode/aviator/runtime/function/seq/SeqPredicateFunction.java
Patch:
@@ -55,7 +55,7 @@ public AviatorObject call(Map<String, Object> env, AviatorObject arg1) {
       Object target = arg1.getValue(env);
       try {
         Object property = PropertyUtils.getNestedProperty(target, propertyNameStr);
-        arg1 = new AviatorRuntimeJavaType(property);
+        arg1 = AviatorRuntimeJavaType.valueOf(property);
       } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
         throw new IllegalArgumentException(
             "Fail to get property <" + propertyNameStr + "> from <" + arg1.desc(env) + ">", e);

File: src/main/java/com/googlecode/aviator/runtime/function/seq/SeqPutFunction.java
Patch:
@@ -58,7 +58,7 @@ public AviatorObject call(final Map<String, Object> env, final AviatorObject arg
     } else {
       throw new IllegalArgumentException(arg1.desc(env) + " is not a collection.");
     }
-    return new AviatorRuntimeJavaType(previousVal);
+    return AviatorRuntimeJavaType.valueOf(previousVal);
   }
 
 }

File: src/main/java/com/googlecode/aviator/runtime/function/seq/SeqReduceFunction.java
Patch:
@@ -52,17 +52,17 @@ public AviatorObject call(final Map<String, Object> env, final AviatorObject arg
 
     if (Collection.class.isAssignableFrom(clazz)) {
       for (Object obj : (Collection<?>) first) {
-        result = fun.call(env, result, new AviatorRuntimeJavaType(obj));
+        result = fun.call(env, result, AviatorRuntimeJavaType.valueOf(obj));
       }
     } else if (Map.class.isAssignableFrom(clazz)) {
       for (Object obj : ((Map<?, ?>) first).entrySet()) {
-        result = fun.call(env, result, new AviatorRuntimeJavaType(obj));
+        result = fun.call(env, result, AviatorRuntimeJavaType.valueOf(obj));
       }
     } else if (clazz.isArray()) {
       int length = Array.getLength(first);
       for (int i = 0; i < length; i++) {
         Object obj = Array.get(first, i);
-        result = fun.call(env, result, new AviatorRuntimeJavaType(obj));
+        result = fun.call(env, result, AviatorRuntimeJavaType.valueOf(obj));
       }
     } else {
       throw new IllegalArgumentException(arg1.desc(env) + " is not a seq");

File: src/main/java/com/googlecode/aviator/runtime/function/seq/SeqSortFunction.java
Patch:
@@ -45,7 +45,7 @@ public AviatorObject call(Map<String, Object> env, AviatorObject arg1) {
       List<?> list = (List<?>) first;
       Object[] a = list.toArray();
       Arrays.sort(a);
-      return new AviatorRuntimeJavaType(Arrays.asList(a));
+      return AviatorRuntimeJavaType.valueOf(Arrays.asList(a));
     } else if (clazz.isArray()) {
       int length = Array.getLength(first);
       Object[] dup = (Object[]) Array.newInstance(first.getClass().getComponentType(), length);
@@ -54,7 +54,7 @@ public AviatorObject call(Map<String, Object> env, AviatorObject arg1) {
       }
       // System.arraycopy(array, 0, dup, 0, dup.length);
       Arrays.sort(dup);
-      return new AviatorRuntimeJavaType(dup);
+      return AviatorRuntimeJavaType.valueOf(dup);
     } else {
       throw new IllegalArgumentException(arg1.desc(env) + " is not a seq");
     }

File: src/main/java/com/googlecode/aviator/runtime/function/string/StringSplitFunction.java
Patch:
@@ -29,7 +29,7 @@ public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorOb
       throw new ExpressionRuntimeException("Could not split with null string");
     String regex = FunctionUtils.getStringValue(arg2, env);
     int limit = FunctionUtils.getNumberValue(arg3, env).intValue();
-    return new AviatorRuntimeJavaType(target.split(regex, limit));
+    return AviatorRuntimeJavaType.valueOf(target.split(regex, limit));
   }
 
 
@@ -39,6 +39,6 @@ public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorOb
     if (target == null)
       throw new ExpressionRuntimeException("Could not replace with null string");
     String regex = FunctionUtils.getStringValue(arg2, env);
-    return new AviatorRuntimeJavaType(target.split(regex));
+    return AviatorRuntimeJavaType.valueOf(target.split(regex));
   }
 }

File: src/main/java/com/googlecode/aviator/runtime/function/system/String2DateFunction.java
Patch:
@@ -30,7 +30,7 @@ public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorOb
     String format = FunctionUtils.getStringValue(arg2, env);
     SimpleDateFormat dateFormat = DateFormatCache.getOrCreateDateFormat(format);
     try {
-      return new AviatorRuntimeJavaType(dateFormat.parse(source));
+      return AviatorRuntimeJavaType.valueOf(dateFormat.parse(source));
     } catch (ParseException e) {
       throw new ExpressionRuntimeException("Cast string to date failed", e);
     }

File: src/main/java/com/googlecode/aviator/runtime/function/system/SysDateFunction.java
Patch:
@@ -38,7 +38,7 @@ public String getName() {
 
   @Override
   public AviatorObject call(Map<String, Object> env) {
-    return new AviatorRuntimeJavaType(new Date());
+    return AviatorRuntimeJavaType.valueOf(new Date());
   }
 
 }

File: src/main/java/com/googlecode/aviator/runtime/function/system/TupleFunction.java
Patch:
@@ -25,7 +25,7 @@ public AviatorObject variadicCall(Map<String, Object> env, AviatorObject... args
     for (int i = 0; i < args.length; i++) {
       tuple[i] = args[i].getValue(env);
     }
-    return new AviatorRuntimeJavaType(tuple);
+    return AviatorRuntimeJavaType.valueOf(tuple);
   }
 
 }

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorJavaType.java
Patch:
@@ -273,7 +273,7 @@ public AviatorObject setValue(final AviatorObject value, final Map<String, Objec
 
     Object v = value.getValue(env);
     env.put(this.name, v);
-    return new AviatorRuntimeJavaType(v);
+    return AviatorRuntimeJavaType.valueOf(v);
   }
 
   private AviatorObject setProperty(final AviatorObject value, final Map<String, Object> env) {
@@ -287,7 +287,7 @@ private AviatorObject setProperty(final AviatorObject value, final Map<String, O
         }
         throw new ExpressionRuntimeException("Can't assign value to " + this.name, t);
       }
-      return new AviatorRuntimeJavaType(v);
+      return AviatorRuntimeJavaType.valueOf(v);
     } else {
       throw new ExpressionRuntimeException("Can't assign value to " + this.name
           + ", Options.ENABLE_PROPERTY_SYNTAX_SUGAR is disabled.");

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorRuntimeJavaElementType.java
Patch:
@@ -45,6 +45,6 @@ public AviatorObject setValue(final AviatorObject value, final Map<String, Objec
       default:
         throw new ExpressionRuntimeException("Unknown container type: " + this.containerType);
     }
-    return new AviatorRuntimeJavaType(val);
+    return AviatorRuntimeJavaType.valueOf(val);
   }
 }

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorType.java
Patch:
@@ -22,5 +22,5 @@
  *
  */
 public enum AviatorType {
-  Long, Double, String, JavaType, Boolean, Pattern, Nil, Method, BigInt, Decimal, Lambda;
+  Long, Double, String, JavaType, Boolean, Pattern, Nil, Method, BigInt, Decimal, Lambda, Range;
 }

File: src/test/java/com/googlecode/aviator/example/SimpleExample.java
Patch:
@@ -11,5 +11,7 @@ public static void main(final String[] args) throws Exception {
         .compileScript(SimpleExample.class.getResource("/test.aviator").getFile());
 
     System.out.println(exp.execute());
+
+    System.out.println(AviatorEvaluator.execute("map(range(1,10), lambda(x) -> x+1 end)"));
   }
 }

File: src/test/java/com/googlecode/aviator/runtime/function/seq/SeqSortFunctionUnitTest.java
Patch:
@@ -22,7 +22,7 @@ public void testSort_Array() {
     }
 
     SeqSortFunction fun = new SeqSortFunction();
-    AviatorObject result = fun.call(null, new AviatorRuntimeJavaType(a));
+    AviatorObject result = fun.call(null, AviatorRuntimeJavaType.valueOf(a));
     index = 0;
     Integer[] dup = (Integer[]) result.getValue(null);
     assertFalse(Arrays.equals(a, dup));
@@ -41,7 +41,7 @@ public void testSort_List() {
     }
 
     SeqSortFunction fun = new SeqSortFunction();
-    AviatorObject result = fun.call(null, new AviatorRuntimeJavaType(a));
+    AviatorObject result = fun.call(null, AviatorRuntimeJavaType.valueOf(a));
     index = 0;
     List<Integer> dup = (List<Integer>) result.getValue(null);
     assertFalse(a.equals(dup));
@@ -62,6 +62,6 @@ public void testSort_HashSet() {
     }
 
     SeqSortFunction fun = new SeqSortFunction();
-    AviatorObject result = fun.call(null, new AviatorRuntimeJavaType(a));
+    AviatorObject result = fun.call(null, AviatorRuntimeJavaType.valueOf(a));
   }
 }

File: src/test/java/com/googlecode/aviator/runtime/function/string/StringSplitJointFunctionUnitTest.java
Patch:
@@ -26,9 +26,9 @@ public void testSplitJoin() {
     assertArrayEquals(new String[] {"a", "b", "c", "d", "e", "f", "g"}, tmps);
 
     assertEquals("a b c d e f g", (String) joinFn
-        .call(null, new AviatorRuntimeJavaType(tmps), new AviatorString(" ")).getValue(null));
+        .call(null, AviatorRuntimeJavaType.valueOf(tmps), new AviatorString(" ")).getValue(null));
     assertEquals("abcdefg",
-        (String) joinFn.call(null, new AviatorRuntimeJavaType(tmps)).getValue(null));
+        (String) joinFn.call(null, AviatorRuntimeJavaType.valueOf(tmps)).getValue(null));
   }
 
 
@@ -40,7 +40,7 @@ public void testJoinWithCollection() {
     list.add("world");
     list.add("aviator");
     assertEquals("hello world aviator", (String) joinFn
-        .call(null, new AviatorRuntimeJavaType(list), new AviatorString(" ")).getValue(null));
+        .call(null, AviatorRuntimeJavaType.valueOf(list), new AviatorString(" ")).getValue(null));
   }
 
 }

File: src/test/java/com/googlecode/aviator/runtime/function/system/Date2StringFunctionUnitTest.java
Patch:
@@ -17,11 +17,11 @@ public void testCall() {
     assertEquals("date_to_string", function.getName());
     Date date = new Date();
     assertEquals(DateFormatCache.getOrCreateDateFormat("yyyyMMdd").format(date),
-        function.call(null, new AviatorRuntimeJavaType(date), new AviatorString("yyyyMMdd"))
+        function.call(null, AviatorRuntimeJavaType.valueOf(date), new AviatorString("yyyyMMdd"))
             .getValue(null));
 
     assertEquals(DateFormatCache.getOrCreateDateFormat("yyyy--MM--dd").format(date),
-        function.call(null, new AviatorRuntimeJavaType(date), new AviatorString("yyyy--MM--dd"))
+        function.call(null, AviatorRuntimeJavaType.valueOf(date), new AviatorString("yyyy--MM--dd"))
             .getValue(null));
 
   }
@@ -30,6 +30,6 @@ public void testCall() {
   @Test(expected = ClassCastException.class)
   public void testCall_NotDate() {
     assertEquals("date_to_string", function.getName());
-    function.call(null, new AviatorRuntimeJavaType(1), new AviatorString("yyyyMMdd"));
+    function.call(null, AviatorRuntimeJavaType.valueOf(1), new AviatorString("yyyyMMdd"));
   }
 }

File: src/test/java/com/googlecode/aviator/runtime/function/system/NowFunctionUnitTest.java
Patch:
@@ -20,7 +20,7 @@ public void testCall() {
   @Test(expected = IllegalArgumentException.class)
   public void testCall_WithOneArgument() {
     NowFunction now = new NowFunction();
-    now.call(null, new AviatorRuntimeJavaType(1));
+    now.call(null, AviatorRuntimeJavaType.valueOf(1));
   }
 
 }

File: src/test/java/com/googlecode/aviator/runtime/function/system/PrintFunctionUnitTest.java
Patch:
@@ -66,8 +66,8 @@ public void testCall_WithTwoArgument() throws Exception {
 
   @Test(expected = IllegalArgumentException.class)
   public void testCall_WithFourArgument() throws Exception {
-    this.fun.call(null, new AviatorRuntimeJavaType(0), new AviatorRuntimeJavaType(0),
-        new AviatorRuntimeJavaType(0), new AviatorRuntimeJavaType(0));
+    this.fun.call(null, AviatorRuntimeJavaType.valueOf(0), AviatorRuntimeJavaType.valueOf(0),
+        AviatorRuntimeJavaType.valueOf(0), AviatorRuntimeJavaType.valueOf(0));
 
   }
 

File: src/test/java/com/googlecode/aviator/runtime/function/system/RandomFunctionUnitTest.java
Patch:
@@ -20,7 +20,7 @@ public void testCall() {
 
   public void testCallWithOneArg() {
     RandomFunction rand = new RandomFunction();
-    AviatorObject result = rand.call(null, new AviatorRuntimeJavaType(1));
+    AviatorObject result = rand.call(null, AviatorRuntimeJavaType.valueOf(1));
     assertTrue(((Integer) result.getValue(null)) < 1);
     assertTrue(((Integer) result.getValue(null)) >= 0);
   }
@@ -30,6 +30,6 @@ public void testCallWithOneArg() {
   public void testCallIllegalArgument() {
     RandomFunction rand = new RandomFunction();
     AviatorObject result =
-        rand.call(null, new AviatorRuntimeJavaType(1), new AviatorRuntimeJavaType(2));
+        rand.call(null, AviatorRuntimeJavaType.valueOf(1), AviatorRuntimeJavaType.valueOf(2));
   }
 }

File: src/test/java/com/googlecode/aviator/runtime/function/system/String2DateFunctionUnitTest.java
Patch:
@@ -17,7 +17,7 @@ public void testCall() {
     assertEquals("string_to_date", function.getName());
     String source = "2011-09-17";
     Date date = (Date) function
-        .call(null, new AviatorRuntimeJavaType(source), new AviatorString("yyyy-MM-dd"))
+        .call(null, AviatorRuntimeJavaType.valueOf(source), new AviatorString("yyyy-MM-dd"))
         .getValue(null);
 
     assertNotNull(date);
@@ -31,6 +31,6 @@ public void testCall() {
   @Test(expected = ClassCastException.class)
   public void testCall_NotDate() {
     assertEquals("string_to_date", function.getName());
-    function.call(null, new AviatorRuntimeJavaType(1), new AviatorString("yyyyMMdd"));
+    function.call(null, AviatorRuntimeJavaType.valueOf(1), new AviatorString("yyyyMMdd"));
   }
 }

File: src/main/java/com/googlecode/aviator/AviatorEvaluatorInstance.java
Patch:
@@ -172,7 +172,6 @@ public Expression compileScript(final String path) throws IOException {
       while ((line = reader.readLine()) != null) {
         script.append(line).append("\r\n");
       }
-      System.out.println(script);
       return compile(script.toString());
     }
   }

File: src/test/java/com/googlecode/aviator/example/SimpleExample.java
Patch:
@@ -7,8 +7,8 @@
 public class SimpleExample {
   public static void main(final String[] args) throws Exception {
     // AviatorEvaluator.setOption(Options.TRACE_EVAL, true);
-    Expression exp = AviatorEvaluator.getInstance().compileScript(
-        "/Users/boyan/programming/java/others/aviator/src/test/java/com/googlecode/aviator/example/test.aviator");
+    Expression exp = AviatorEvaluator.getInstance()
+        .compileScript(SimpleExample.class.getResource("/test.aviator").getFile());
 
     System.out.println(exp.execute());
   }

File: src/main/java/com/googlecode/aviator/code/LambdaGenerator.java
Patch:
@@ -150,7 +150,7 @@ public void compileCallMethod() {
       this.mv = this.classWriter.visitMethod(ACC_PUBLIC + +ACC_FINAL, "call",
           "(Ljava/util/Map;" + argsDec + ")Lcom/googlecode/aviator/runtime/type/AviatorObject;",
           "(Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;" + argsDec
-          + ")Lcom/googlecode/aviator/runtime/type/AviatorObject;",
+              + ")Lcom/googlecode/aviator/runtime/type/AviatorObject;",
           null);
       this.mv.visitCode();
 

File: src/main/java/com/googlecode/aviator/code/asm/ASMCodeGenerator.java
Patch:
@@ -996,7 +996,7 @@ public void initConstants(final Set<Token<?>> constants) {
       String fieldName = getInnerName(token.getLexeme());
       this.constantPool.put(token, fieldName);
       this.classWriter.visitField(ACC_PRIVATE + ACC_FINAL, fieldName, OBJECT_DESC, null, null)
-      .visitEnd();
+          .visitEnd();
     }
   }
 

File: src/main/java/com/googlecode/aviator/parser/ScopeInfo.java
Patch:
@@ -14,8 +14,7 @@ public class ScopeInfo {
   Deque<DepthState> depthState;
 
   public ScopeInfo(final int parenDepth, final int bracketDepth, final int lambdaDepth,
-      final int braceDepth,
-      final Deque<DepthState> depthState) {
+      final int braceDepth, final Deque<DepthState> depthState) {
     super();
     this.parenDepth = parenDepth;
     this.bracketDepth = bracketDepth;

File: src/test/java/com/googlecode/aviator/example/SimpleExample.java
Patch:
@@ -6,8 +6,10 @@
 
 public class SimpleExample {
   public static void main(final String[] args) throws Exception {
+    // AviatorEvaluator.setOption(Options.TRACE_EVAL, true);
     Expression exp = AviatorEvaluator.getInstance().compileScript(
         "/Users/boyan/programming/java/others/aviator/src/test/java/com/googlecode/aviator/example/test.aviator");
-    exp.execute();
+
+    System.out.println(exp.execute());
   }
 }

File: src/main/java/com/googlecode/aviator/lexer/ExpressionLexer.java
Patch:
@@ -221,6 +221,7 @@ public Token<?> scan(final boolean analyse) {
             int n = digit;
             nextChar();
             while (Character.isDigit(this.peek)) {
+              sb.append(this.peek);
               n = 10 * n + Character.digit(this.peek, 10);
               nextChar();
             }
@@ -250,6 +251,8 @@ public Token<?> scan(final boolean analyse) {
 
       } while (Character.isDigit(this.peek) || this.peek == '.' || this.peek == 'E'
           || this.peek == 'e' || this.peek == 'M' || this.peek == 'N');
+
+
       Number value;
       if (isBigDecimal) {
         value = new BigDecimal(getBigNumberLexeme(sb), this.mathContext);

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorJavaType.java
Patch:
@@ -256,6 +256,7 @@ public Object getValue(final Map<String, Object> env) {
     return null;
   }
 
+  @Override
   public AviatorObject setValue(final AviatorObject value, final Map<String, Object> env) {
     if (this.name.contains(".")) {
       throw new ExpressionRuntimeException("Can't assignment value to `" + this.name + "`");

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorJavaType.java
Patch:
@@ -256,6 +256,7 @@ public Object getValue(final Map<String, Object> env) {
     return null;
   }
 
+  @Override
   public AviatorObject setValue(final AviatorObject value, final Map<String, Object> env) {
     if (this.name.contains(".")) {
       throw new ExpressionRuntimeException("Can't assignment value to `" + this.name + "`");

File: src/main/java/com/googlecode/aviator/utils/Reflector.java
Patch:
@@ -138,7 +138,7 @@ public static Object invokeInstanceMethod(final Class c, final String methodName
   }
 
 
-  static Object boxArg(final Class paramType, final Object arg) {
+  public static Object boxArg(final Class paramType, final Object arg) {
     if (!paramType.isPrimitive()) {
       return paramType.cast(arg);
     } else if (paramType == boolean.class) {

File: src/main/java/com/googlecode/aviator/AviatorEvaluatorInstance.java
Patch:
@@ -68,6 +68,7 @@
 import com.googlecode.aviator.runtime.function.seq.SeqMapFunction;
 import com.googlecode.aviator.runtime.function.seq.SeqMaxFunction;
 import com.googlecode.aviator.runtime.function.seq.SeqMinFunction;
+import com.googlecode.aviator.runtime.function.seq.SeqNewArrayFunction;
 import com.googlecode.aviator.runtime.function.seq.SeqNewListFunction;
 import com.googlecode.aviator.runtime.function.seq.SeqNewMapFunction;
 import com.googlecode.aviator.runtime.function.seq.SeqNewSetFunction;
@@ -500,6 +501,7 @@ private void loadLib() {
     addFunction(new MathTanFunction());
 
     // seq lib
+    addFunction(new SeqNewArrayFunction());
     addFunction(new SeqNewListFunction());
     addFunction(new SeqNewMapFunction());
     addFunction(new SeqNewSetFunction());

File: src/main/java/com/googlecode/aviator/runtime/function/ClassMethodFunction.java
Patch:
@@ -39,7 +39,7 @@ public ClassMethodFunction(final Class<?> clazz, final boolean isStatic, final S
 
     if (methods.size() == 1) {
       // fast path by method handle.
-      this.handle = MethodHandles.lookup().unreflect(methods.get(0));
+      this.handle = MethodHandles.lookup().unreflect(methods.get(0)).asFixedArity();
       this.pTypes = methods.get(0).getParameterTypes();
       if (!isStatic) {
         Class<?>[] newTypes = new Class<?>[this.pTypes.length + 1];

File: src/main/java/com/googlecode/aviator/runtime/function/ClassStaticFunction.java
Patch:
@@ -35,14 +35,14 @@ public ClassStaticFunction(final Class<?> clazz, final String name, final String
     this.methodName = methodName;
 
     if (methods.size() == 1) {
-      // fast path for on e-arity function.
+      // fast path by method handle.
       this.handle = MethodHandles.lookup().unreflect(methods.get(0));
       this.pTypes = methods.get(0).getParameterTypes();
       if (this.handle == null) {
         throw new NoSuchMethodException("Method handle for " + methodName + " not found");
       }
     } else {
-      // Slow path by reflections.
+      // Slow path by reflection
       this.methods = methods;
     }
   }

File: src/test/java/com/googlecode/aviator/code/asm/ASMCodeGeneratorUnitTest.java
Patch:
@@ -25,6 +25,7 @@
 import java.util.Date;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.regex.Pattern;
 import org.junit.Before;
 import org.junit.Test;
 import com.googlecode.aviator.AviatorEvaluator;
@@ -122,7 +123,8 @@ public void testOnConstant_Pattern() throws Exception {
     this.codeGenerator.onConstant(new PatternToken("[a-z_A-Z]+", 0));
     Expression exp = this.codeGenerator.getResult();
     Object result = exp.execute();
-    assertEquals("/[a-z_A-Z]+/", result);
+    assertTrue(result instanceof Pattern);
+    assertEquals("[a-z_A-Z]+", result.toString());
   }
 
 

File: src/main/java/com/googlecode/aviator/runtime/FunctionArgument.java
Patch:
@@ -37,7 +37,7 @@ public String getExpression() {
 
   @Override
   public String toString() {
-    return "FunctionParameter [index=" + this.index + ", expression=" + this.expression + "]";
+    return "FunctionArgument [index=" + this.index + ", expression=" + this.expression + "]";
   }
 
   public static FunctionArgument from(final int index, final String name) {

File: src/main/java/com/googlecode/aviator/Options.java
Patch:
@@ -63,8 +63,8 @@ public enum Options {
   PUT_CAPTURING_GROUPS_INTO_ENV,
 
   /**
-   * Whether to capture the function arguments(invocation) into env, the parameter list will be
-   * stored in __args__ variable in function body. Default is false(disabled).
+   * Whether to capture the function arguments(at invocation) into env, the argument list will be
+   * stored in __args__ variable in env valid for function body. Default is false(disabled).
    *
    * @since 4.2.0
    */

File: src/main/java/com/googlecode/aviator/runtime/FunctionArgument.java
Patch:
@@ -1,8 +1,9 @@
 package com.googlecode.aviator.runtime;
 
 /**
- * A function parameter
+ * A function argument.
  *
+ * @since 4.2.0
  * @author dennis(killme2008@gmail.com)
  *
  */

File: src/main/java/com/googlecode/aviator/Options.java
Patch:
@@ -41,12 +41,12 @@ public enum Options {
    */
   TRACE,
   /**
-   * Always parsing floating-point number into BigDecial, default is false.It replaces
+   * When true, always parsing floating-point number into BigDecial, default is false.It replaces
    * {@link #ALWAYS_USE_DOUBLE_AS_DECIMAL} option.
    */
   ALWAYS_PARSE_FLOATING_POINT_NUMBER_INTO_DECIMAL,
   /**
-   * Always parsing long number into BigDecial, default is false.It replaces
+   * When true, always parsing long number into BigDecial, default is false.
    */
   ALWAYS_PARSE_INTEGRAL_NUMBER_INTO_DECIMAL,
   /**

File: src/main/java/com/googlecode/aviator/lexer/ExpressionLexer.java
Patch:
@@ -260,6 +260,8 @@ public Token<?> scan(boolean analyse) {
           // we make integral number as a BigDecimal.
           value = new BigDecimal(sb.toString(), this.mathContext);
         } else {
+          // if the long value is out of range,then it must be negative, so
+          // we make it as a big integer.
           if (lval < 0) {
             value = new BigInteger(sb.toString());
           } else {

File: src/main/java/com/googlecode/aviator/lexer/ExpressionLexer.java
Patch:
@@ -257,8 +257,7 @@ public Token<?> scan(boolean analyse) {
         }
       } else {
         if (this.parseLongIntoDecimal) {
-          // if the long value is out of range,then it must be negative,so
-          // we make it as a big integer.
+          // we make integral number as a BigDecimal.
           value = new BigDecimal(sb.toString(), this.mathContext);
         } else {
           if (lval < 0) {

File: src/test/java/com/googlecode/aviator/lexer/ExpressionLexerUnitTest.java
Patch:
@@ -267,7 +267,6 @@ public void testParseIntegralAsDecimal() {
       assertEquals(new BigDecimal("3"), token.getValue(null));
       assertEquals(0, token.getStartIndex());
     } finally {
-
       this.instance.setOption(Options.ALWAYS_PARSE_INTEGRAL_NUMBER_INTO_DECIMAL, false);
     }
   }

File: src/test/java/com/googlecode/aviator/lexer/ExpressionLexerUnitTest.java
Patch:
@@ -267,6 +267,7 @@ public void testParseIntegralAsDecimal() {
       assertEquals(new BigDecimal("3"), token.getValue(null));
       assertEquals(0, token.getStartIndex());
     } finally {
+
       this.instance.setOption(Options.ALWAYS_PARSE_INTEGRAL_NUMBER_INTO_DECIMAL, false);
     }
   }

File: src/main/java/com/googlecode/aviator/lexer/ExpressionLexer.java
Patch:
@@ -63,7 +63,7 @@ public ExpressionLexer(AviatorEvaluatorInstance instance, String expression) {
     this.parseFloatIntoDecimal =
         this.instance.getOptionValue(Options.ALWAYS_PARSE_FLOATING_POINT_NUMBER_INTO_DECIMAL).bool;
     this.parseLongIntoDecimal =
-        this.instance.getOptionValue(Options.ALWAYS_PARSE_LONG_NUMBER_INTO_DECIMAL).bool;
+        this.instance.getOptionValue(Options.ALWAYS_PARSE_INTEGRAL_NUMBER_INTO_DECIMAL).bool;
 
   }
 
@@ -256,9 +256,9 @@ public Token<?> scan(boolean analyse) {
           value = dval;
         }
       } else {
-        // if the long value is out of range,then it must be negative,so
-        // we make it as a big integer.
         if (this.parseLongIntoDecimal) {
+          // if the long value is out of range,then it must be negative,so
+          // we make it as a big integer.
           value = new BigDecimal(sb.toString(), this.mathContext);
         } else {
           if (lval < 0) {

File: src/main/java/com/googlecode/aviator/parser/ExpressionParser.java
Patch:
@@ -757,8 +757,9 @@ private void pattern() {
 
 
   private void reportSyntaxError(String message) {
-    int index = this.lookhead != null && this.lookhead.getStartIndex() > 0
-        ? this.lookhead.getStartIndex() : this.lexer.getCurrentIndex();
+    int index =
+        this.lookhead != null && this.lookhead.getStartIndex() > 0 ? this.lookhead.getStartIndex()
+            : this.lexer.getCurrentIndex();
     throw new ExpressionSyntaxErrorException(
         "Syntax error:" + message + " at " + index + ", current token: " + this.lookhead
             + ". Parsing expression: `" + this.lexer.getScanString() + "^^`");

File: src/test/java/com/googlecode/aviator/LambdaUnitTest.java
Patch:
@@ -60,7 +60,7 @@ public void testLambdaClosure() {
   @Test(expected = ExpressionRuntimeException.class)
   public void testIssue101() {
     String exp = "a=1; b = lambda(x) -> a+ x end ; a=4 ; b(5)";
-    AviatorEvaluator.execute(exp); // output 6
+    AviatorEvaluator.execute(exp); // throw exception
   }
 
   @Test

File: src/test/java/com/googlecode/aviator/example/LambdaExample.java
Patch:
@@ -8,7 +8,7 @@ public class LambdaExample {
 
   public static void main(String[] args) {
 
-    String exp = "a=1; b = lambda(x) -> a+ x end ; b(5)";
+    String exp = "a=1; b = lambda(x) -> a+ x end ; a=4 ; b(5)";
     System.out.println(AviatorEvaluator.execute(exp)); // output 6
 
 

File: src/test/java/com/googlecode/aviator/parser/ExpressionParserUnitTest.java
Patch:
@@ -689,9 +689,8 @@ public void testParseReduceFunction() {
 
   @Test
   public void testParseFunctionNested() {
-    this.parser = new ExpressionParser(this.instance,
-        new ExpressionLexer(this.instance,
-            "string.contains(string.substring(\"hello\",3,4),string.substring(\"hello\",1)) && 3>2"),
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance,
+        "string.contains(string.substring(\"hello\",3,4),string.substring(\"hello\",1)) && 3>2"),
         this.codeGenerator);
     this.parser.parse();
 

File: src/main/java/com/googlecode/aviator/runtime/op/OperationRuntime.java
Patch:
@@ -166,7 +166,7 @@ private static void trace(Map<String, Object> env, OperatorType opType, AviatorO
       case 3:
         RuntimeUtils.printTrace(env,
             TRACE_PREFIX + args[0].desc(env) + WHITE_SPACE + "?" + WHITE_SPACE + args[0].desc(env)
-            + WHITE_SPACE + ":" + WHITE_SPACE + args[1].desc(env) + " => " + result.desc(env));
+                + WHITE_SPACE + ":" + WHITE_SPACE + args[1].desc(env) + " => " + result.desc(env));
         break;
     }
   }

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorJavaType.java
Patch:
@@ -259,6 +259,7 @@ public AviatorObject setValue(AviatorObject value, Map<String, Object> env) {
     if (this.name.contains(".")) {
       throw new IllegalArgumentException("Can't assignment value to `" + this.name + "`");
     }
+
     Object v = value.getValue(env);
     env.put(this.name, v);
     return new AviatorRuntimeJavaType(v);

File: src/main/java/com/googlecode/aviator/runtime/op/OperationRuntime.java
Patch:
@@ -45,7 +45,7 @@ public static AviatorObject eval(Map<String, Object> env, AviatorObject[] args,
     AviatorFunction func = RuntimeUtils.getInstance(env).getOpFunction(opType);
     AviatorObject ret = eval0(env, args, opType, func);
     if (RuntimeUtils.isTracedEval(env)) {
-      trace(null, opType, ret, args);
+      trace(env, opType, ret, args);
     }
     return ret;
   }
@@ -166,7 +166,7 @@ private static void trace(Map<String, Object> env, OperatorType opType, AviatorO
       case 3:
         RuntimeUtils.printTrace(env,
             TRACE_PREFIX + args[0].desc(env) + WHITE_SPACE + "?" + WHITE_SPACE + args[0].desc(env)
-                + WHITE_SPACE + ":" + WHITE_SPACE + args[1].desc(env) + " => " + result.desc(env));
+            + WHITE_SPACE + ":" + WHITE_SPACE + args[1].desc(env) + " => " + result.desc(env));
         break;
     }
   }

File: src/main/java/com/googlecode/aviator/runtime/function/LambdaFunction.java
Patch:
@@ -26,7 +26,7 @@ public abstract class LambdaFunction extends AbstractFunction {
   public LambdaFunction(List<String> arguments, Expression expression, Env context) {
     super();
     this.arguments = arguments;
-    this.context = context;
+    this.context = context.clone();
     this.expression = expression;
   }
 

File: src/main/java/com/googlecode/aviator/runtime/function/FunctionUtils.java
Patch:
@@ -64,7 +64,7 @@ public static Object getJavaObject(AviatorObject arg, Map<String, Object> env) {
     if (arg.getAviatorType() != AviatorType.JavaType) {
       throw new ExpressionRuntimeException(arg.desc(env) + " is not a javaType");
     }
-    return env.get(((AviatorJavaType) arg).getName());
+    return ((AviatorJavaType) arg).getValue(env);
   }
 
 

File: src/main/java/com/googlecode/aviator/runtime/function/FunctionUtils.java
Patch:
@@ -64,7 +64,7 @@ public static Object getJavaObject(AviatorObject arg, Map<String, Object> env) {
     if (arg.getAviatorType() != AviatorType.JavaType) {
       throw new ExpressionRuntimeException(arg.desc(env) + " is not a javaType");
     }
-    return env.get(((AviatorJavaType) arg).getName());
+    return ((AviatorJavaType) arg).getValue(env);
   }
 
 

File: src/main/java/com/googlecode/aviator/parser/ExpressionParser.java
Patch:
@@ -757,8 +757,9 @@ private void pattern() {
 
 
   private void reportSyntaxError(String message) {
-    int index = this.lookhead != null && this.lookhead.getStartIndex() > 0
-        ? this.lookhead.getStartIndex() : this.lexer.getCurrentIndex();
+    int index =
+        this.lookhead != null && this.lookhead.getStartIndex() > 0 ? this.lookhead.getStartIndex()
+            : this.lexer.getCurrentIndex();
     throw new ExpressionSyntaxErrorException(
         "Syntax error:" + message + " at " + index + ", current token: " + this.lookhead
             + ". Parsing expression: `" + this.lexer.getScanString() + "^^`");

File: src/test/java/com/googlecode/aviator/LambdaUnitTest.java
Patch:
@@ -60,7 +60,7 @@ public void testLambdaClosure() {
   @Test(expected = ExpressionRuntimeException.class)
   public void testIssue101() {
     String exp = "a=1; b = lambda(x) -> a+ x end ; a=4 ; b(5)";
-    AviatorEvaluator.execute(exp); // output 6
+    AviatorEvaluator.execute(exp); // throw exception
   }
 
   @Test

File: src/test/java/com/googlecode/aviator/example/LambdaExample.java
Patch:
@@ -8,7 +8,7 @@ public class LambdaExample {
 
   public static void main(String[] args) {
 
-    String exp = "a=1; b = lambda(x) -> a+ x end ; b(5)";
+    String exp = "a=1; b = lambda(x) -> a+ x end ; a=4 ; b(5)";
     System.out.println(AviatorEvaluator.execute(exp)); // output 6
 
 

File: src/test/java/com/googlecode/aviator/parser/ExpressionParserUnitTest.java
Patch:
@@ -689,9 +689,8 @@ public void testParseReduceFunction() {
 
   @Test
   public void testParseFunctionNested() {
-    this.parser = new ExpressionParser(this.instance,
-        new ExpressionLexer(this.instance,
-            "string.contains(string.substring(\"hello\",3,4),string.substring(\"hello\",1)) && 3>2"),
+    this.parser = new ExpressionParser(this.instance, new ExpressionLexer(this.instance,
+        "string.contains(string.substring(\"hello\",3,4),string.substring(\"hello\",1)) && 3>2"),
         this.codeGenerator);
     this.parser.parse();
 

File: src/main/java/com/googlecode/aviator/runtime/op/OperationRuntime.java
Patch:
@@ -166,7 +166,7 @@ private static void trace(Map<String, Object> env, OperatorType opType, AviatorO
       case 3:
         RuntimeUtils.printTrace(env,
             TRACE_PREFIX + args[0].desc(env) + WHITE_SPACE + "?" + WHITE_SPACE + args[0].desc(env)
-            + WHITE_SPACE + ":" + WHITE_SPACE + args[1].desc(env) + " => " + result.desc(env));
+                + WHITE_SPACE + ":" + WHITE_SPACE + args[1].desc(env) + " => " + result.desc(env));
         break;
     }
   }

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorJavaType.java
Patch:
@@ -259,6 +259,7 @@ public AviatorObject setValue(AviatorObject value, Map<String, Object> env) {
     if (this.name.contains(".")) {
       throw new IllegalArgumentException("Can't assignment value to `" + this.name + "`");
     }
+
     Object v = value.getValue(env);
     env.put(this.name, v);
     return new AviatorRuntimeJavaType(v);

File: src/main/java/com/googlecode/aviator/runtime/op/OperationRuntime.java
Patch:
@@ -45,7 +45,7 @@ public static AviatorObject eval(Map<String, Object> env, AviatorObject[] args,
     AviatorFunction func = RuntimeUtils.getInstance(env).getOpFunction(opType);
     AviatorObject ret = eval0(env, args, opType, func);
     if (RuntimeUtils.isTracedEval(env)) {
-      trace(null, opType, ret, args);
+      trace(env, opType, ret, args);
     }
     return ret;
   }
@@ -166,7 +166,7 @@ private static void trace(Map<String, Object> env, OperatorType opType, AviatorO
       case 3:
         RuntimeUtils.printTrace(env,
             TRACE_PREFIX + args[0].desc(env) + WHITE_SPACE + "?" + WHITE_SPACE + args[0].desc(env)
-                + WHITE_SPACE + ":" + WHITE_SPACE + args[1].desc(env) + " => " + result.desc(env));
+            + WHITE_SPACE + ":" + WHITE_SPACE + args[1].desc(env) + " => " + result.desc(env));
         break;
     }
   }

File: src/main/java/com/googlecode/aviator/runtime/function/LambdaFunction.java
Patch:
@@ -26,7 +26,7 @@ public abstract class LambdaFunction extends AbstractFunction {
   public LambdaFunction(List<String> arguments, Expression expression, Env context) {
     super();
     this.arguments = arguments;
-    this.context = context;
+    this.context = context.clone();
     this.expression = expression;
   }
 

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorPattern.java
Patch:
@@ -76,7 +76,7 @@ public AviatorObject match(AviatorObject other, Map<String, Object> env) {
         if (m.matches()) {
           boolean captureGroups = RuntimeUtils.getInstance(env)
               .getOptionValue(Options.PUT_CAPTURING_GROUPS_INTO_ENV).bool;
-          if (captureGroups && env != null && env != Collections.EMPTY_MAP) {
+          if (captureGroups && env != Collections.EMPTY_MAP) {
             int groupCount = m.groupCount();
             for (int i = 0; i <= groupCount; i++) {
               env.put("$" + i, m.group(i));

File: src/main/java/com/googlecode/aviator/utils/Env.java
Patch:
@@ -66,7 +66,7 @@ public void setInstance(AviatorEvaluatorInstance instance) {
     this.instance = instance;
   }
 
-  private static final Map<String, Object> EMPTY_ENV = Collections.emptyMap();
+  public static final Map<String, Object> EMPTY_ENV = Collections.emptyMap();
 
   /**
    * Constructs an env instance with empty state.

File: src/main/java/com/googlecode/aviator/Options.java
Patch:
@@ -129,7 +129,7 @@ public Object getDefaultValue() {
       case PUT_CAPTURING_GROUPS_INTO_ENV:
         return true;
       case USE_USER_ENV_AS_TOP_ENV_DIRECTLY:
-        return false;
+        return true;
     }
     return null;
   }

File: src/main/java/com/googlecode/aviator/parser/ExpressionParser.java
Patch:
@@ -284,7 +284,6 @@ public void equality() {
           this.rel();
           this.codeGenerator.onMatch(this.lookhead);
         } else {
-          System.out.println(this.lookhead);
           // this.back();
           // assignment
           this.ternary();

File: src/test/java/com/googlecode/aviator/AviatorEvaluatorInstanceUnitTest.java
Patch:
@@ -28,6 +28,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import com.googlecode.aviator.exception.CompileExpressionErrorException;
+import com.googlecode.aviator.exception.ExpressionRuntimeException;
 import com.googlecode.aviator.lexer.token.OperatorType;
 import com.googlecode.aviator.runtime.type.AviatorFunction;
 
@@ -54,15 +55,15 @@ public void testInstanceCustomFunctions() {
     try {
       AviatorEvaluator.newInstance().exec("add(3,4)");
       fail();
-    } catch (CompileExpressionErrorException e) {
+    } catch (ExpressionRuntimeException e) {
       assertTrue(true);
     }
     assertEquals(17, this.instance.execute("add(8,9)"));
     assertEquals(17, this.instance.exec("add(x,9)", 8));
     try {
       AviatorEvaluator.newInstance().exec("add(1,y)", 3);
       fail();
-    } catch (CompileExpressionErrorException e) {
+    } catch (ExpressionRuntimeException e) {
       assertTrue(true);
     }
   }

File: src/test/java/com/googlecode/aviator/lexer/ExpressionLexerUnitTest.java
Patch:
@@ -41,7 +41,6 @@ public void setup() {
     this.instance = AviatorEvaluator.newInstance();
   }
 
-
   @Test
   public void testSimpleExpression() {
     this.lexer = new ExpressionLexer(this.instance, "1+2");
@@ -588,7 +587,7 @@ public void testExpressionHasPattern() {
     assertEquals("\\", token.getLexeme());
 
     token = this.lexer.scan();
-    assertEquals(TokenType.Number, token.getType());
+    assertEquals(TokenType.Char, token.getType());
     assertEquals(".", token.getLexeme());
 
     token = this.lexer.scan();

File: src/test/java/com/googlecode/aviator/test/function/FunctionTest.java
Patch:
@@ -164,7 +164,7 @@ public void testSystemFunction() {
       Object now = AviatorEvaluator.execute("now()");
       assertNotNull(now);
       assertTrue(now instanceof Long);
-      assertEquals((Long) now, System.currentTimeMillis(), 5L);
+      assertEquals((Long) now, System.currentTimeMillis(), 10L);
 
       // rand()
       Object rand1 = AviatorEvaluator.execute("rand()");

File: src/main/java/com/googlecode/aviator/Options.java
Patch:
@@ -20,7 +20,7 @@ public enum Options {
   ALWAYS_USE_DOUBLE_AS_DECIMAL,
 
   /**
-   * Optimize level, default is {@link AviatorEvaluator#EVA}
+   * Optimize level, default is {@link AviatorEvaluator#EVAL}
    *
    * @see AviatorEvaluator#EVAL
    * @see AviatorEvaluator#COMPILE

File: src/test/java/com/googlecode/aviator/example/SayHello.java
Patch:
@@ -9,7 +9,7 @@
 public class SayHello {
     public static void main(String[] args) {
         if (args.length < 1) {
-            System.err.print("Usesage: Java SayHello yourname");
+            System.err.print("Usage: Java SayHello yourname");
             System.exit(1);
         }
         String yourname = args[0];

File: src/test/java/com/googlecode/aviator/example/SimpleExample.java
Patch:
@@ -5,7 +5,7 @@
 
 public class SimpleExample {
     public static void main(String[] args) {
-        Long result = (Long) AviatorEvaluator.execute("4( * ssss");
+        Long result = (Long) AviatorEvaluator.execute("1+2+3");
         System.out.println(result);
     }
 }

File: src/test/java/com/googlecode/aviator/example/SimpleExample.java
Patch:
@@ -5,7 +5,7 @@
 
 public class SimpleExample {
     public static void main(String[] args) {
-        Long result = (Long) AviatorEvaluator.execute("1+2+3");
+        Long result = (Long) AviatorEvaluator.execute("4( * ssss");
         System.out.println(result);
     }
 }

File: src/test/java/com/googlecode/aviator/test/function/FunctionTest.java
Patch:
@@ -362,7 +362,7 @@ public void testBitOperationsWithVariable() {
                     ^ ~j + k << i >> j >> 1000L,
             AviatorEvaluator
                 .execute(
-                    "4 / 2 * 3 - 4 + (5 ^ 5 - 2 & 3) == 4000 ? (!false && true ? 1 & 4 : 0) :i >> j * k / i ^ ~j + k << i >> j >> 1000,",
+                    "4 / 2 * 3 - 4 + (5 ^ 5 - 2 & 3) == 4000 ? (!false && true ? 1 & 4 : 0) :i >> j * k / i ^ ~j + k << i >> j >> 1000",
                     env));
 
         assertEquals((i & 7) == (i & 7) && false, AviatorEvaluator.execute("(i & 7) == (i & 7) && false ", env));

File: src/test/java/com/googlecode/aviator/test/function/GrammarUnitTest.java
Patch:
@@ -38,6 +38,7 @@
 import com.googlecode.aviator.AviatorEvaluator;
 import com.googlecode.aviator.exception.CompileExpressionErrorException;
 import com.googlecode.aviator.exception.ExpressionRuntimeException;
+import com.googlecode.aviator.exception.ExpressionSyntaxErrorException;
 
 
 /**
@@ -840,14 +841,14 @@ public void testTernaryOperator() {
             AviatorEvaluator.execute("!t? (i>0? f:ch) : f>3?email:ch)", env);
             Assert.fail();
         }
-        catch (CompileExpressionErrorException e) {
+        catch (ExpressionSyntaxErrorException e) {
 
         }
         try {
             AviatorEvaluator.execute("!t? (i>0? f:ch : (f>3?email:ch)", env);
             Assert.fail();
         }
-        catch (CompileExpressionErrorException e) {
+        catch (ExpressionSyntaxErrorException e) {
 
         }
     }

File: src/main/java/com/googlecode/aviator/runtime/type/AviatorLong.java
Patch:
@@ -22,6 +22,7 @@
 
 import com.googlecode.aviator.AviatorEvaluator;
 import com.googlecode.aviator.exception.ExpressionRuntimeException;
+import com.googlecode.aviator.utils.TypeUtils;
 
 
 /**
@@ -80,7 +81,7 @@ public int innerCompare(AviatorNumber other) {
         case Decimal:
             return this.toDecimal().compareTo(other.toDecimal());
         case Long:
-            return Long.compare(this.longValue(), other.longValue());
+            return TypeUtils.comapreLong(this.longValue(), other.longValue());
         case Double:
             return Double.compare(this.number.doubleValue(), other.doubleValue());
         default:

File: src/test/java/com/googlecode/aviator/test/function/FunctionTest.java
Patch:
@@ -452,6 +452,8 @@ public void testParseBigNumbers() {
             AviatorEvaluator.exec("99999999999999999999999999999999"));
         assertEquals(new BigInteger("99999999999999999999999999999999"),
             AviatorEvaluator.exec("99999999999999999999999999999999N"));
+        assertEquals(new BigInteger("199999999999999999999999999999998"),
+            AviatorEvaluator.exec("99999999999999999999999999999999+99999999999999999999999999999999"));
 
         assertEquals(new BigDecimal("99999999999999999999999999999999.99999999", AviatorEvaluator.getMathContext()),
             AviatorEvaluator.exec("99999999999999999999999999999999.99999999M"));

File: src/main/java/com/googlecode/aviator/AviatorEvaluator.java
Patch:
@@ -106,7 +106,7 @@ public final class AviatorEvaluator {
     /**
      * Aviator version
      */
-    public static final String VERSION = "1.1.1";
+    public static final String VERSION = "2.1.1";
 
     /**
      * Generated java class version,default 1.5

File: src/main/java/com/googlecode/aviator/code/OptimizeCodeGenerator.java
Patch:
@@ -284,7 +284,7 @@ else if (lookhead == Variable.NIL) {
             }
             break;
         case Char:
-            result = new AviatorPattern(String.valueOf(lookhead.getValue(null)));
+            result = new AviatorString(String.valueOf(lookhead.getValue(null)));
             break;
         }
         return result;

