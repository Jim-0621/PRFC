File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/TransitiveDependencyCondition.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.Set;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.core.domain.JavaClass;
@@ -41,7 +42,7 @@ public final class TransitiveDependencyCondition extends ArchCondition<JavaClass
 
     private final DescribedPredicate<? super JavaClass> conditionPredicate;
     private final TransitiveDependencyPath transitiveDependencyPath = new TransitiveDependencyPath();
-    private Collection<JavaClass> allClasses;
+    private Set<JavaClass> allClasses;
 
     public TransitiveDependencyCondition(DescribedPredicate<? super JavaClass> conditionPredicate) {
         super("transitively depend on classes that " + conditionPredicate.getDescription());
@@ -51,7 +52,7 @@ public TransitiveDependencyCondition(DescribedPredicate<? super JavaClass> condi
 
     @Override
     public void init(Collection<JavaClass> allObjectsToTest) {
-        this.allClasses = allObjectsToTest;
+        this.allClasses = ImmutableSet.copyOf(allObjectsToTest);
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/TransitiveDependencyCondition.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.Set;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.core.domain.JavaClass;
@@ -41,7 +42,7 @@ public final class TransitiveDependencyCondition extends ArchCondition<JavaClass
 
     private final DescribedPredicate<? super JavaClass> conditionPredicate;
     private final TransitiveDependencyPath transitiveDependencyPath = new TransitiveDependencyPath();
-    private Collection<JavaClass> allClasses;
+    private Set<JavaClass> allClasses;
 
     public TransitiveDependencyCondition(DescribedPredicate<? super JavaClass> conditionPredicate) {
         super("transitively depend on classes that " + conditionPredicate.getDescription());
@@ -51,7 +52,7 @@ public TransitiveDependencyCondition(DescribedPredicate<? super JavaClass> condi
 
     @Override
     public void init(Collection<JavaClass> allObjectsToTest) {
-        this.allClasses = allObjectsToTest;
+        this.allClasses = ImmutableSet.copyOf(allObjectsToTest);
     }
 
     @Override

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/internal/ArchUnitSystemPropertyTestFilterJUnit5.java
Patch:
@@ -48,7 +48,7 @@ private void removeNonMatching(TestDescriptor descriptor, Predicate<TestDescript
         ImmutableSet.copyOf(descriptor.getChildren())
                 .forEach(child -> removeNonMatching(child, shouldRunPredicate));
 
-        if (descriptor.getChildren().isEmpty() && !shouldRunPredicate.test(descriptor)) {
+        if (!descriptor.isRoot() && descriptor.getChildren().isEmpty() && !shouldRunPredicate.test(descriptor)) {
             descriptor.removeFromHierarchy();
         }
     }

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/internal/ArchUnitSystemPropertyTestFilterJUnit5.java
Patch:
@@ -48,7 +48,7 @@ private void removeNonMatching(TestDescriptor descriptor, Predicate<TestDescript
         ImmutableSet.copyOf(descriptor.getChildren())
                 .forEach(child -> removeNonMatching(child, shouldRunPredicate));
 
-        if (descriptor.getChildren().isEmpty() && !shouldRunPredicate.test(descriptor)) {
+        if (!descriptor.isRoot() && descriptor.getChildren().isEmpty() && !shouldRunPredicate.test(descriptor)) {
             descriptor.removeFromHierarchy();
         }
     }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/ArchUnitArchitectureTest.java
Patch:
@@ -21,7 +21,6 @@
 import com.tngtech.archunit.junit.ArchTests;
 import com.tngtech.archunit.junit.ArchUnitRunner;
 import com.tngtech.archunit.lang.ArchRule;
-import org.junit.runner.RunWith;
 
 import static com.tngtech.archunit.base.DescribedPredicate.not;
 import static com.tngtech.archunit.core.domain.JavaAccess.Predicates.origin;
@@ -35,7 +34,6 @@
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
 import static com.tngtech.archunit.library.Architectures.layeredArchitecture;
 
-@RunWith(ArchUnitRunner.class)
 @AnalyzeClasses(
         packagesOf = ArchUnitArchitectureTest.class,
         importOptions = ArchUnitArchitectureTest.ArchUnitProductionCode.class)

File: archunit-integration-test/src/test/java/com/tngtech/archunit/ArchUnitExampleArchitectureTest.java
Patch:
@@ -5,13 +5,10 @@
 import com.tngtech.archunit.core.importer.Location;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
-import com.tngtech.archunit.junit.ArchUnitRunner;
 import com.tngtech.archunit.lang.ArchRule;
-import org.junit.runner.RunWith;
 
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
 
-@RunWith(ArchUnitRunner.class)
 @AnalyzeClasses(packages = "com.tngtech.archunit", importOptions = ArchUnitExampleLocations.class)
 public class ArchUnitExampleArchitectureTest {
     @ArchTest

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/internal/ArchTestMethodExecution.java
Patch:
@@ -23,7 +23,6 @@
 import com.tngtech.archunit.junit.ArchTest;
 import org.junit.runner.Description;
 
-import static com.tngtech.archunit.junit.internal.DisplayNameResolver.determineDisplayName;
 import static com.tngtech.archunit.junit.internal.ReflectionUtils.invokeMethod;
 
 class ArchTestMethodExecution extends ArchTestExecution {
@@ -55,8 +54,7 @@ private void executeTestMethod(JavaClasses classes) {
 
     @Override
     Description describeSelf() {
-        String testName = formatWithPath(testMethod.getName());
-        return Description.createTestDescription(getTestClass(), determineDisplayName(testName), testMethod.getAnnotations());
+        return createDescription(testMethod);
     }
 
     @Override

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/subtwo/SimpleRules.java
Patch:
@@ -32,5 +32,6 @@ public static void simple_rule_method_two(JavaClasses classes) {
     public static final String SIMPLE_RULE_FIELD_TWO_NAME = "simple_rule_field_two";
     public static final Set<String> RULE_FIELD_NAMES = ImmutableSet.of(SIMPLE_RULE_FIELD_ONE_NAME, SIMPLE_RULE_FIELD_TWO_NAME);
     public static final String SIMPLE_RULE_METHOD_ONE_NAME = "simple_rule_method_one";
-    public static final Set<String> RULE_METHOD_NAMES = ImmutableSet.of(SIMPLE_RULE_METHOD_ONE_NAME, "simple_rule_method_two");
+    public static final String SIMPLE_RULE_METHOD_TWO_NAME = "simple_rule_method_two";
+    public static final Set<String> RULE_METHOD_NAMES = ImmutableSet.of(SIMPLE_RULE_METHOD_ONE_NAME, SIMPLE_RULE_METHOD_TWO_NAME);
 }

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/internal/ArchUnitRunnerInternal.java
Patch:
@@ -92,7 +92,7 @@ private Collection<ArchTestExecution> findArchRuleFields() {
     }
 
     private Set<ArchTestExecution> findArchRulesIn(FrameworkField ruleField) {
-        boolean ignore = elementShouldBeIgnored(ruleField.getField());
+        boolean ignore = elementShouldBeIgnored(getTestClass().getJavaClass(), ruleField.getField());
         if (ruleField.getType() == ArchTests.class) {
             return asTestExecutions(getArchRules(ruleField.getField()), ignore);
         }
@@ -114,7 +114,7 @@ private ArchTests getArchRules(Field field) {
     private Collection<ArchTestExecution> findArchRuleMethods() {
         List<ArchTestExecution> result = new ArrayList<>();
         for (FrameworkMethod testMethod : getTestClass().getAnnotatedMethods(ArchTest.class)) {
-            boolean ignore = elementShouldBeIgnored(testMethod.getMethod());
+            boolean ignore = elementShouldBeIgnored(getTestClass().getJavaClass(), testMethod.getMethod());
             result.add(new ArchTestMethodExecution(getTestClass().getJavaClass(), testMethod.getMethod(), ignore));
         }
         return result;

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/internal/ArchUnitRunnerInternal.java
Patch:
@@ -92,7 +92,7 @@ private Collection<ArchTestExecution> findArchRuleFields() {
     }
 
     private Set<ArchTestExecution> findArchRulesIn(FrameworkField ruleField) {
-        boolean ignore = elementShouldBeIgnored(ruleField.getField());
+        boolean ignore = elementShouldBeIgnored(getTestClass().getJavaClass(), ruleField.getField());
         if (ruleField.getType() == ArchTests.class) {
             return asTestExecutions(getArchRules(ruleField.getField()), ignore);
         }
@@ -114,7 +114,7 @@ private ArchTests getArchRules(Field field) {
     private Collection<ArchTestExecution> findArchRuleMethods() {
         List<ArchTestExecution> result = new ArrayList<>();
         for (FrameworkMethod testMethod : getTestClass().getAnnotatedMethods(ArchTest.class)) {
-            boolean ignore = elementShouldBeIgnored(testMethod.getMethod());
+            boolean ignore = elementShouldBeIgnored(getTestClass().getJavaClass(), testMethod.getMethod());
             result.add(new ArchTestMethodExecution(getTestClass().getJavaClass(), testMethod.getMethod(), ignore));
         }
         return result;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -45,6 +45,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.Sets.immutableEnumSet;
 import static com.google.common.collect.Sets.union;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 import static com.tngtech.archunit.base.ClassLoaders.getCurrentClassLoader;
@@ -138,7 +139,7 @@ public final class JavaClass
         isRecord = builder.isRecord();
         isAnonymousClass = builder.isAnonymousClass();
         isMemberClass = builder.isMemberClass();
-        modifiers = checkNotNull(builder.getModifiers());
+        modifiers = immutableEnumSet(builder.getModifiers());
         reflectSupplier = Suppliers.memoize(new ReflectClassSupplier());
         sourceCodeLocation = SourceCodeLocation.of(this);
         javaPackage = JavaPackage.simple(this);

File: archunit-integration-test/src/test/java/com/tngtech/archunit/PublicAPIRules.java
Patch:
@@ -42,6 +42,7 @@
 import static com.tngtech.archunit.core.domain.JavaMember.Predicates.declaredIn;
 import static com.tngtech.archunit.core.domain.JavaModifier.FINAL;
 import static com.tngtech.archunit.core.domain.JavaModifier.PUBLIC;
+import static com.tngtech.archunit.core.domain.JavaModifier.SYNTHETIC;
 import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
 import static com.tngtech.archunit.core.domain.properties.HasModifiers.Predicates.modifier;
 import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
@@ -95,6 +96,7 @@ public class PublicAPIRules {
     public static final ArchRule all_public_API_members_are_accessible =
             members()
                     .that().areAnnotatedWith(PublicAPI.class)
+                    .and().doNotHaveModifier(SYNTHETIC)
                     .should(bePubliclyAccessible());
 
     @ArchTest

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/ExpectedRelation.java
Patch:
@@ -3,7 +3,7 @@
 import com.tngtech.archunit.core.domain.JavaAccess;
 import com.tngtech.archunit.lang.ConditionEvent;
 
-interface ExpectedRelation {
+public interface ExpectedRelation {
 
     void addTo(HandlingAssertion assertion);
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/ExpectedTestFailures.java
Patch:
@@ -372,9 +372,7 @@ void by(ExpectedDependency inheritance) {
 
         void by(MessageAssertionChain.Link assertion) {
             expectedViolation.by(assertion);
-            if (assertion instanceof ExpectedRelation) {
-                ((ExpectedRelation) assertion).addTo(handlingAssertion);
-            }
+            assertion.addTo(handlingAssertion);
         }
 
         ExpectedViolationToAssign copy() {

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/MessageAssertionChain.java
Patch:
@@ -189,6 +189,9 @@ public interface Link {
 
         String getDescription();
 
+        default void addTo(HandlingAssertion handlingAssertion) {
+        }
+
         @Internal
         class Result {
             private final boolean matches;

File: archunit/src/main/java/com/tngtech/archunit/lang/ViolationHandler.java
Patch:
@@ -22,6 +22,9 @@
 import static com.tngtech.archunit.PublicAPI.State.EXPERIMENTAL;
 import static com.tngtech.archunit.PublicAPI.Usage.INHERITANCE;
 
+/**
+ * @see EvaluationResult#handleViolations(ViolationHandler, Object[])
+ */
 @PublicAPI(usage = INHERITANCE, state = EXPERIMENTAL)
 public interface ViolationHandler<T> {
     void handle(Collection<T> violatingObjects, String message);

File: archunit/src/main/java/com/tngtech/archunit/library/Architectures.java
Patch:
@@ -452,7 +452,7 @@ private ArchCondition<JavaClass> beContainedInLayers(LayerDefinitions layerDefin
                         @Override
                         public void check(JavaClass javaClass, ConditionEvents events) {
                             if (!ignorePredicate.test(javaClass) && !classContainedInLayers.test(javaClass)) {
-                                events.add(violated(this, String.format("Class <%s> is not contained in architecture", javaClass.getName())));
+                                events.add(violated(javaClass, String.format("Class <%s> is not contained in architecture", javaClass.getName())));
                             }
                         }
                     };

File: archunit/src/test/java/com/tngtech/archunit/library/modules/syntax/testexamples/test_modules/one/one/ClassOneOne.java
Patch:
@@ -1,5 +1,8 @@
 package com.tngtech.archunit.library.modules.syntax.testexamples.test_modules.one.one;
 
+import com.tngtech.archunit.library.modules.syntax.testexamples.test_modules.two.one.ClassTwoOne;
+
 @SuppressWarnings("unused")
 public class ClassOneOne {
+    ClassTwoOne twoOne;
 }

File: archunit/src/test/java/com/tngtech/archunit/library/modules/syntax/testexamples/test_modules/two/one/ClassTwoOne.java
Patch:
@@ -1,5 +1,8 @@
 package com.tngtech.archunit.library.modules.syntax.testexamples.test_modules.two.one;
 
+import com.tngtech.archunit.library.modules.syntax.testexamples.test_modules.one.one.ClassOneOne;
+
 @SuppressWarnings("unused")
 public class ClassTwoOne {
+    ClassOneOne oneOne;
 }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/PublicAPIRules.java
Patch:
@@ -42,6 +42,7 @@
 import static com.tngtech.archunit.core.domain.JavaMember.Predicates.declaredIn;
 import static com.tngtech.archunit.core.domain.JavaModifier.FINAL;
 import static com.tngtech.archunit.core.domain.JavaModifier.PUBLIC;
+import static com.tngtech.archunit.core.domain.JavaModifier.SYNTHETIC;
 import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
 import static com.tngtech.archunit.core.domain.properties.HasModifiers.Predicates.modifier;
 import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
@@ -95,6 +96,7 @@ public class PublicAPIRules {
     public static final ArchRule all_public_API_members_are_accessible =
             members()
                     .that().areAnnotatedWith(PublicAPI.class)
+                    .and().doNotHaveModifier(SYNTHETIC)
                     .should(bePubliclyAccessible());
 
     @ArchTest

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/ExpectedRelation.java
Patch:
@@ -3,7 +3,7 @@
 import com.tngtech.archunit.core.domain.JavaAccess;
 import com.tngtech.archunit.lang.ConditionEvent;
 
-interface ExpectedRelation {
+public interface ExpectedRelation {
 
     void addTo(HandlingAssertion assertion);
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/ExpectedTestFailures.java
Patch:
@@ -372,9 +372,7 @@ void by(ExpectedDependency inheritance) {
 
         void by(MessageAssertionChain.Link assertion) {
             expectedViolation.by(assertion);
-            if (assertion instanceof ExpectedRelation) {
-                ((ExpectedRelation) assertion).addTo(handlingAssertion);
-            }
+            assertion.addTo(handlingAssertion);
         }
 
         ExpectedViolationToAssign copy() {

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/MessageAssertionChain.java
Patch:
@@ -189,6 +189,9 @@ public interface Link {
 
         String getDescription();
 
+        default void addTo(HandlingAssertion handlingAssertion) {
+        }
+
         @Internal
         class Result {
             private final boolean matches;

File: archunit/src/main/java/com/tngtech/archunit/lang/ViolationHandler.java
Patch:
@@ -22,6 +22,9 @@
 import static com.tngtech.archunit.PublicAPI.State.EXPERIMENTAL;
 import static com.tngtech.archunit.PublicAPI.Usage.INHERITANCE;
 
+/**
+ * @see EvaluationResult#handleViolations(ViolationHandler, Object[])
+ */
 @PublicAPI(usage = INHERITANCE, state = EXPERIMENTAL)
 public interface ViolationHandler<T> {
     void handle(Collection<T> violatingObjects, String message);

File: archunit/src/test/java/com/tngtech/archunit/library/modules/syntax/testexamples/test_modules/one/one/ClassOneOne.java
Patch:
@@ -1,5 +1,8 @@
 package com.tngtech.archunit.library.modules.syntax.testexamples.test_modules.one.one;
 
+import com.tngtech.archunit.library.modules.syntax.testexamples.test_modules.two.one.ClassTwoOne;
+
 @SuppressWarnings("unused")
 public class ClassOneOne {
+    ClassTwoOne twoOne;
 }

File: archunit/src/test/java/com/tngtech/archunit/library/modules/syntax/testexamples/test_modules/two/one/ClassTwoOne.java
Patch:
@@ -1,5 +1,8 @@
 package com.tngtech.archunit.library.modules.syntax.testexamples.test_modules.two.one;
 
+import com.tngtech.archunit.library.modules.syntax.testexamples.test_modules.one.one.ClassOneOne;
+
 @SuppressWarnings("unused")
 public class ClassTwoOne {
+    ClassOneOne oneOne;
 }

File: archunit/src/main/java/com/tngtech/archunit/library/Architectures.java
Patch:
@@ -452,7 +452,7 @@ private ArchCondition<JavaClass> beContainedInLayers(LayerDefinitions layerDefin
                         @Override
                         public void check(JavaClass javaClass, ConditionEvents events) {
                             if (!ignorePredicate.test(javaClass) && !classContainedInLayers.test(javaClass)) {
-                                events.add(violated(this, String.format("Class <%s> is not contained in architecture", javaClass.getName())));
+                                events.add(violated(javaClass, String.format("Class <%s> is not contained in architecture", javaClass.getName())));
                             }
                         }
                     };

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileImportRecord.java
Patch:
@@ -264,7 +264,7 @@ void forEachRawMethodCallRecord(Consumer<RawAccessRecord> doWithRecord) {
     }
 
     void forEachRawConstructorCallRecord(Consumer<RawAccessRecord> doWithRecord) {
-        resolveSyntheticOrigins(rawConstructorCallRecords, COPY_RAW_ACCESS_RECORD, syntheticLambdaAccessRecorder)
+        resolveSyntheticOrigins(rawConstructorCallRecords, COPY_RAW_ACCESS_RECORD, syntheticPrivateAccessRecorder, syntheticLambdaAccessRecorder)
                 .forEach(doWithRecord);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileImportRecord.java
Patch:
@@ -264,7 +264,7 @@ void forEachRawMethodCallRecord(Consumer<RawAccessRecord> doWithRecord) {
     }
 
     void forEachRawConstructorCallRecord(Consumer<RawAccessRecord> doWithRecord) {
-        resolveSyntheticOrigins(rawConstructorCallRecords, COPY_RAW_ACCESS_RECORD, syntheticLambdaAccessRecorder)
+        resolveSyntheticOrigins(rawConstructorCallRecords, COPY_RAW_ACCESS_RECORD, syntheticPrivateAccessRecorder, syntheticLambdaAccessRecorder)
                 .forEach(doWithRecord);
     }
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -200,7 +200,7 @@ public static DependencyAssertion assertThatDependency(Dependency dependency) {
         return new DependencyAssertion(dependency);
     }
 
-    public static DependenciesAssertion assertThatDependencies(Iterable<Dependency> dependencies) {
+    public static DependenciesAssertion assertThatDependencies(Collection<Dependency> dependencies) {
         return new DependenciesAssertion(dependencies);
     }
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/PublicAPIRules.java
Patch:
@@ -125,6 +125,7 @@ public class PublicAPIRules {
     public static final ArchRule parameters_of_public_API_are_public =
             codeUnits()
                     .that().areDeclaredInClassesThat().arePublic()
+                    .and().areDeclaredInClassesThat(not(enclosedInANonPublicClass()))
                     .and().areDeclaredInClassesThat().areNotAnnotatedWith(Internal.class)
                     .and().arePublic()
                     .and().doNotHaveName("adhereToPlantUmlDiagram")
@@ -267,6 +268,7 @@ private static DescribedPredicate<JavaMember> withoutAPIMarking() {
         return not(annotatedWith(PublicAPI.class)).<JavaMember>forSubtype()
                 .and(not(annotatedWith(Internal.class)).forSubtype())
                 .and(declaredIn(modifier(PUBLIC)))
+                .and(not(declaredIn(enclosedInANonPublicClass())))
                 .as("without API marking");
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaCodeUnit.java
Patch:
@@ -277,7 +277,7 @@ void completeFrom(ImportContext context) {
         methodReferences = context.createMethodReferencesFor(this, tryCatchBlockBuilders);
         constructorReferences = context.createConstructorReferencesFor(this, tryCatchBlockBuilders);
         tryCatchBlocks = tryCatchBlockBuilders.stream()
-                .map(builder -> builder.build(this, context))
+                .map(builder -> builder.build(this))
                 .collect(toImmutableSet());
         referencedClassObjects = context.createReferencedClassObjectsFor(this);
         instanceofChecks = context.createInstanceofChecksFor(this);

File: archunit/src/main/java/com/tngtech/archunit/core/importer/RawAccessRecord.java
Patch:
@@ -230,7 +230,7 @@ public RawAccessRecord build() {
         }
     }
 
-    abstract static class BaseBuilder<ACCESS extends RawAccessRecord, SELF extends BaseBuilder<ACCESS, SELF>> implements RawCodeUnitDependencyBuilder<ACCESS, TargetInfo> {
+    abstract static class BaseBuilder<ACCESS extends RawAccessRecord, SELF extends BaseBuilder<ACCESS, SELF>> implements RawCodeUnitDependency.Builder<ACCESS, TargetInfo> {
         CodeUnit origin;
         TargetInfo target;
         int lineNumber = -1;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/RawInstanceofCheck.java
Patch:
@@ -63,7 +63,7 @@ public String toString() {
                 .toString();
     }
 
-    static class Builder implements RawCodeUnitDependencyBuilder<RawInstanceofCheck, JavaClassDescriptor> {
+    static class Builder implements RawCodeUnitDependency.Builder<RawInstanceofCheck, JavaClassDescriptor> {
         private RawAccessRecord.CodeUnit origin;
         private JavaClassDescriptor target;
         private int lineNumber;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/RawReferencedClassObject.java
Patch:
@@ -66,7 +66,7 @@ public String toString() {
                 .toString();
     }
 
-    static class Builder implements RawCodeUnitDependencyBuilder<RawReferencedClassObject, JavaClassDescriptor> {
+    static class Builder implements RawCodeUnitDependency.Builder<RawReferencedClassObject, JavaClassDescriptor> {
         private CodeUnit origin;
         private JavaClassDescriptor target;
         private int lineNumber;

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/TextFileBasedViolationStore.java
Patch:
@@ -267,7 +267,7 @@ private void syncFileSystem() {
     /**
      * Allows to adjust the rule violation file names of {@link TextFileBasedViolationStore}
      *
-     * @see #TextFileBasedViolationStore(RuleViolationFileNameStrategy)
+     * @see TextFileBasedViolationStore#TextFileBasedViolationStore(RuleViolationFileNameStrategy)
      */
     @FunctionalInterface
     @PublicAPI(usage = INHERITANCE)

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterAccessesTest.java
Patch:
@@ -118,7 +118,7 @@
 import static com.tngtech.archunit.testutil.ReflectionTestUtils.method;
 import static com.tngtech.archunit.testutil.TestUtils.relativeResourceUri;
 import static com.tngtech.archunit.testutil.assertion.AccessesAssertion.access;
-import static com.tngtech.archunit.testutil.assertion.TryCatchBlocksAssertion.tryCatchBlock;
+import static com.tngtech.archunit.testutil.assertion.TryCatchBlockAssertion.tryCatchBlock;
 import static java.util.Collections.singleton;
 import static java.util.stream.Collectors.groupingBy;
 import static java.util.stream.Collectors.toSet;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -178,7 +178,8 @@ private void processTryCatchBlock(RawTryCatchBlock rawTryCatchBlock) {
                                 .collect(toImmutableSet())
                 )
                 .withLineNumber(rawTryCatchBlock.getLineNumber())
-                .withRawAccessesContainedInTryBlock(rawTryCatchBlock.getAccessesInTryBlock());
+                .withRawAccessesContainedInTryBlock(rawTryCatchBlock.getAccessesInTryBlock())
+                .withDeclaredInLambda(rawTryCatchBlock.isDeclaredInLambda());
         processedTryCatchBlocks.put(declaringCodeUnit, tryCatchBlockBuilder);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaCodeUnit.java
Patch:
@@ -277,7 +277,7 @@ void completeFrom(ImportContext context) {
         methodReferences = context.createMethodReferencesFor(this, tryCatchBlockBuilders);
         constructorReferences = context.createConstructorReferencesFor(this, tryCatchBlockBuilders);
         tryCatchBlocks = tryCatchBlockBuilders.stream()
-                .map(builder -> builder.build(this, context))
+                .map(builder -> builder.build(this))
                 .collect(toImmutableSet());
         referencedClassObjects = context.createReferencedClassObjectsFor(this);
         instanceofChecks = context.createInstanceofChecksFor(this);

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/TextFileBasedViolationStore.java
Patch:
@@ -267,7 +267,7 @@ private void syncFileSystem() {
     /**
      * Allows to adjust the rule violation file names of {@link TextFileBasedViolationStore}
      *
-     * @see #TextFileBasedViolationStore(RuleViolationFileNameStrategy)
+     * @see TextFileBasedViolationStore#TextFileBasedViolationStore(RuleViolationFileNameStrategy)
      */
     @FunctionalInterface
     @PublicAPI(usage = INHERITANCE)

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -2235,7 +2235,7 @@ public static DescribedPredicate<JavaClass> assignableTo(DescribedPredicate<? su
          * Same as {@link #assignableFrom(Class)}, but returns {@code true} whenever the tested {@link JavaClass}
          * is assignable from a class that matches the supplied predicate.<br>
          * This is the opposite of {@link #assignableTo(DescribedPredicate)}:
-         * some class {@code B} is assignable from a class {@code A} if and only if {@code A} is assignable to {@code A}.
+         * some class {@code B} is assignable from a class {@code A} if and only if {@code A} is assignable to {@code B}.
          *
          * @see #assignableFrom(Class)
          * @see #assignableFrom(String)

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -2235,7 +2235,7 @@ public static DescribedPredicate<JavaClass> assignableTo(DescribedPredicate<? su
          * Same as {@link #assignableFrom(Class)}, but returns {@code true} whenever the tested {@link JavaClass}
          * is assignable from a class that matches the supplied predicate.<br>
          * This is the opposite of {@link #assignableTo(DescribedPredicate)}:
-         * some class {@code B} is assignable from a class {@code A} if and only if {@code A} is assignable to {@code A}.
+         * some class {@code B} is assignable from a class {@code A} if and only if {@code A} is assignable to {@code B}.
          *
          * @see #assignableFrom(Class)
          * @see #assignableFrom(String)

File: archunit/src/test/java/com/tngtech/archunit/library/freeze/TextFileBasedViolationStoreTest.java
Patch:
@@ -10,7 +10,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.io.Files;
 import com.tngtech.archunit.lang.ArchRule;
-import com.tngtech.archunit.library.freeze.ViolationStoreFactory.TextFileBasedViolationStore;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;

File: archunit/src/test/java/com/tngtech/archunit/library/freeze/TextFileBasedViolationStoreTest.java
Patch:
@@ -10,7 +10,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.io.Files;
 import com.tngtech.archunit.lang.ArchRule;
-import com.tngtech.archunit.library.freeze.ViolationStoreFactory.TextFileBasedViolationStore;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/DependencyResolutionProcess.java
Patch:
@@ -124,7 +124,7 @@ void resolve(ImportedClasses classes) {
     }
 
     private void logConfiguration() {
-        log.debug("Automatically resolving transitive class dependencies with the following configuration:{}{}{}{}{}{}",
+        log.trace("Automatically resolving transitive class dependencies with the following configuration:{}{}{}{}{}{}",
                 formatConfigProperty(MAX_ITERATIONS_FOR_MEMBER_TYPES_PROPERTY_NAME, maxRunsForMemberTypes),
                 formatConfigProperty(MAX_ITERATIONS_FOR_ACCESSES_TO_TYPES_PROPERTY_NAME, maxRunsForAccessesToTypes),
                 formatConfigProperty(MAX_ITERATIONS_FOR_SUPERTYPES_PROPERTY_NAME, maxRunsForSupertypes),

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/JohnsonCycleFinder.java
Patch:
@@ -119,7 +119,7 @@ static class Result implements Iterable<int[]> {
         private boolean maxNumberOfCyclesReached = false;
 
         private Result() {
-            log.debug("Maximum number of cycles to detect is set to {}; "
+            log.trace("Maximum number of cycles to detect is set to {}; "
                             + "this limit can be adapted using the `archunit.properties` value `{}=xxx`",
                     configuration.getMaxNumberOfCyclesToDetect(), MAX_NUMBER_OF_CYCLES_TO_DETECT_PROPERTY_NAME);
         }

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceCycleArchCondition.java
Patch:
@@ -174,7 +174,7 @@ private static class EventRecorder {
         private final CycleConfiguration cycleConfiguration = new CycleConfiguration();
 
         private EventRecorder() {
-            log.debug("Maximum number of dependencies to report per edge is set to {}; "
+            log.trace("Maximum number of dependencies to report per edge is set to {}; "
                             + "this limit can be adapted using the `archunit.properties` value `{}=xxx`",
                     cycleConfiguration.getMaxNumberOfDependenciesToShowPerEdge(), MAX_NUMBER_OF_DEPENDENCIES_TO_SHOW_PER_EDGE_PROPERTY_NAME);
         }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/DependencyResolutionProcess.java
Patch:
@@ -124,7 +124,7 @@ void resolve(ImportedClasses classes) {
     }
 
     private void logConfiguration() {
-        log.debug("Automatically resolving transitive class dependencies with the following configuration:{}{}{}{}{}{}",
+        log.trace("Automatically resolving transitive class dependencies with the following configuration:{}{}{}{}{}{}",
                 formatConfigProperty(MAX_ITERATIONS_FOR_MEMBER_TYPES_PROPERTY_NAME, maxRunsForMemberTypes),
                 formatConfigProperty(MAX_ITERATIONS_FOR_ACCESSES_TO_TYPES_PROPERTY_NAME, maxRunsForAccessesToTypes),
                 formatConfigProperty(MAX_ITERATIONS_FOR_SUPERTYPES_PROPERTY_NAME, maxRunsForSupertypes),

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/JohnsonCycleFinder.java
Patch:
@@ -119,7 +119,7 @@ static class Result implements Iterable<int[]> {
         private boolean maxNumberOfCyclesReached = false;
 
         private Result() {
-            log.debug("Maximum number of cycles to detect is set to {}; "
+            log.trace("Maximum number of cycles to detect is set to {}; "
                             + "this limit can be adapted using the `archunit.properties` value `{}=xxx`",
                     configuration.getMaxNumberOfCyclesToDetect(), MAX_NUMBER_OF_CYCLES_TO_DETECT_PROPERTY_NAME);
         }

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceCycleArchCondition.java
Patch:
@@ -174,7 +174,7 @@ private static class EventRecorder {
         private final CycleConfiguration cycleConfiguration = new CycleConfiguration();
 
         private EventRecorder() {
-            log.debug("Maximum number of dependencies to report per edge is set to {}; "
+            log.trace("Maximum number of dependencies to report per edge is set to {}; "
                             + "this limit can be adapted using the `archunit.properties` value `{}=xxx`",
                     cycleConfiguration.getMaxNumberOfDependenciesToShowPerEdge(), MAX_NUMBER_OF_DEPENDENCIES_TO_SHOW_PER_EDGE_PROPERTY_NAME);
         }

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/AnalyzeClasses.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchUnitRunner.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/internal/ArchRuleDeclaration.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/internal/ArchRuleExecution.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/internal/ArchTestExecution.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/internal/ArchTestMethodExecution.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/internal/ArchUnitRunnerInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit5/api/src/main/java/com/tngtech/archunit/junit/AnalyzeClasses.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit5/api/src/main/java/com/tngtech/archunit/junit/ArchTag.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit5/api/src/main/java/com/tngtech/archunit/junit/ArchTags.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit5/api/src/main/java/com/tngtech/archunit/junit/ArchTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit5/engine-api/src/main/java/com/tngtech/archunit/junit/engine_api/FieldSelector.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit5/engine-api/src/main/java/com/tngtech/archunit/junit/engine_api/FieldSource.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/internal/AbstractArchUnitTestDescriptor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/internal/ArchUnitEngineDescriptor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/internal/ArchUnitEngineExecutionContext.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/internal/ArchUnitTestDescriptor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/internal/ArchUnitTestEngine.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/internal/CreatesChildren.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/internal/ElementResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/jdk9main/java/com/tngtech/archunit/core/domain/Java9DomainPlugin.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/jdk9main/java/com/tngtech/archunit/core/importer/ModuleImportPlugin.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/jdk9main/java/com/tngtech/archunit/core/importer/ModuleLocationFactory.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/jdk9main/java/com/tngtech/archunit/core/importer/ModuleLocationResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/ArchConfiguration.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/Internal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/PublicAPI.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/base/ArchUnitException.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/base/ChainableFunction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/base/ClassLoaders.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/base/DescribedIterable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/base/DescribedPredicate.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/base/ForwardingCollection.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/base/ForwardingList.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/base/ForwardingSet.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/base/HasDescription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/base/MayResolveTypesViaReflection.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/base/Optionals.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/base/Predicates.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/base/ReflectionUtils.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/base/ResolvesTypesViaReflection.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/base/Suppliers.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/InitialConfiguration.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/PluginLoader.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AccessTarget.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AnnotationPropertiesFormatter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AnnotationProxy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Dependency.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/DomainObjectCreationContext.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/DomainPlugin.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Formatters.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/InstanceofCheck.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Java14DomainPlugin.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaAccess.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaAnnotation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaAnnotationParameterVisitorAcceptor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaCall.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassDependencies.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassDescriptor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassMembers.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassTransitiveDependencies.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClasses.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaCodeUnit.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaCodeUnitAccess.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaCodeUnitReference.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaConstructor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaConstructorCall.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaConstructorReference.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaEnumConstant.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaField.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaFieldAccess.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaGenericArrayType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMember.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMethod.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMethodCall.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMethodReference.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaModifier.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaPackage.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaParameter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaParameterizedType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaStaticInitializer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaTypeVariable.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaWildcardType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/PackageMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/PackageMatchers.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ReferencedClassObject.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ReverseDependencies.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Source.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/SourceCodeLocation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ThrowsClause.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ThrowsDeclaration.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/TryCatchBlock.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/CanBeAnnotated.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/CanOverrideDescription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasAnnotations.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasDescriptor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasModifiers.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasName.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasOwner.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasParameterTypes.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasReturnType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasSourceCodeLocation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasThrowsClause.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasType.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasTypeParameters.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasUpperBounds.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/AccessRecord.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileImportRecord.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileImporter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileLocation.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileProcessor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileSource.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/DeclarationHandler.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/DependencyResolutionProcess.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/DomainBuilders.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/GenericMemberTypeProcessor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ImportOption.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ImportOptions.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ImportPlugin.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ImportedClasses.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassDescriptorImporter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassSignatureImporter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaCodeUnitSignatureImporter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaFieldTypeSignatureImporter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/Location.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/LocationResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/Locations.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/NormalizedResourceName.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/NormalizedUri.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/RawAccessRecord.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/RawCodeUnitDependency.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/RawCodeUnitDependencyBuilder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/RawInstanceofCheck.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/RawReferencedClassObject.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/SignatureTypeArgumentProcessor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/SignatureTypeParameterProcessor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/SourceDescriptor.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/TryCatchRecorder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/UrlSource.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/ClassResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/ClassResolverFromClasspath.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/SelectedClassResolverFromClasspath.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/AbstractClassesTransformer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/AllowEmptyShould.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/ArchCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/ArchRule.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/CanBeEvaluated.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/ClassesTransformer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/CompositeArchRule.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/ConditionEvent.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/ConditionEvents.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/EvaluationResult.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/FailureDisplayFormat.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/FailureDisplayFormatFactory.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/FailureDisplayFormatInitializationFailedException.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/FailureMessages.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/FailureReport.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/Priority.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/SimpleConditionEvent.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/SimpleConditionEvents.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/ViolationHandler.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AllAccessesCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AllAttributesMatchCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AllDependenciesCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AndCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AnyAttributeMatchesCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AnyDependencyCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ArchConditions.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ArchPredicates.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ClassAccessesCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ClassAccessesFieldCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ClassOnlyAccessesCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/CodeUnitOnlyCallsCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ContainAnyCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ContainsOnlyCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/DelegatingConditionEvents.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/DependencyCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/EventsDescription.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/FieldAccessCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/JavaAccessCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/JavaAccessPackagePredicate.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/JoinCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/NeverCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/OrCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/TransitiveDependencyCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ViolatedAndSatisfiedConditionEvents.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/extension/ArchUnitExtension.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/extension/ArchUnitExtensionLoader.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/extension/ArchUnitExtensions.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/extension/EvaluatedRule.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/extension/ExtensionLoadingException.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractCodeUnitsShouldInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenCodeUnitsInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenMembersInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenObjects.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractMembersShouldInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ArchRuleDefinition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ClassesShouldInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ClassesThatInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/CodeUnitsThatInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ConstructorsShouldInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/FieldsShouldInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/FieldsThatInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassesInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenConstructorsInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenFieldsInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenMethodsInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenObjectsInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/MembersDeclaredInClassesThat.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/MembersThatInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/MethodsShouldInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/MethodsThatInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ObjectsShouldInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/OnlyBeAccessedSpecificationInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/OnlyBeCalledSpecificationInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/PredicateAggregator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/SyntaxPredicates.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/Transformers.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/ClassesShould.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/ClassesShouldConjunction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/ClassesThat.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/CodeUnitsShould.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/CodeUnitsShouldConjunction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/CodeUnitsThat.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/FieldsShould.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/FieldsShouldConjunction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/FieldsThat.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenClass.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenClasses.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenClassesConjunction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenCodeUnits.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenCodeUnitsConjunction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenConjunction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenConstructors.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenConstructorsConjunction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenFields.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenFieldsConjunction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenMembers.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenMembersConjunction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenMethods.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenMethodsConjunction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenObjects.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MembersShould.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MembersShouldConjunction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MembersThat.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MethodsShould.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MethodsShouldConjunction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MethodsThat.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/OnlyBeAccessedSpecification.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/OnlyBeCalledSpecification.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/Architectures.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/DependencyRules.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/GeneralCodingRules.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/ProxyRules.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Cycle.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/CycleConfiguration.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Edge.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/GivenSlicesInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Graph.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/JohnsonComponent.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/JohnsonCycleFinder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Path.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/PrimitiveDataTypes.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/PrimitiveGraph.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Slice.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceAssignment.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceCycleArchCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceDependency.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceIdentifier.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceRule.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Slices.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SlicesRuleDefinition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/TarjanComponentFinder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/TarjanGraph.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/syntax/GivenNamedSlices.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/syntax/GivenSlices.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/syntax/GivenSlicesConjunction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/syntax/SlicesShould.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/FreezingArchRule.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/StoreInitializationFailedException.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/StoreReadException.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/StoreUpdateFailedException.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/ViolationLineMatcher.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/ViolationLineMatcherFactory.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/ViolationLineMatcherInitializationFailedException.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/ViolationStore.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/ViolationStoreFactory.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/metrics/ArchitectureMetrics.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/metrics/ComponentDependencyMetrics.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/metrics/LakosMetrics.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/library/metrics/MetricsComponent.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2022 TNG Technology Consulting GmbH
+ * Copyright 2014-2023 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/SlicesIsolationTest.java
Patch:
@@ -38,7 +38,7 @@ public class SlicesIsolationTest {
                     .ignoreDependency(UseCaseOneTwoController.class, UseCaseTwoController.class)
                     .ignoreDependency(nameMatching(".*controller\\.three.*"), alwaysTrue());
 
-    private static DescribedPredicate<Slice> containDescription(final String descriptionPart) {
+    private static DescribedPredicate<Slice> containDescription(String descriptionPart) {
         return new DescribedPredicate<Slice>("contain description '%s'", descriptionPart) {
             @Override
             public boolean test(Slice input) {

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/SlicesIsolationTest.java
Patch:
@@ -35,7 +35,7 @@ public class SlicesIsolationTest {
                     .ignoreDependency(UseCaseOneTwoController.class, UseCaseTwoController.class)
                     .ignoreDependency(nameMatching(".*controller\\.three.*"), alwaysTrue());
 
-    private static DescribedPredicate<Slice> containDescription(final String descriptionPart) {
+    private static DescribedPredicate<Slice> containDescription(String descriptionPart) {
         return new DescribedPredicate<Slice>("contain description '%s'", descriptionPart) {
             @Override
             public boolean test(Slice input) {

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/persistence/first/dao/domain/PersistentObject.java
Patch:
@@ -31,7 +31,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final PersistentObject other = (PersistentObject) obj;
+        PersistentObject other = (PersistentObject) obj;
         return Objects.equals(this.id, other.id);
     }
 }

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/persistence/second/dao/domain/OtherPersistentObject.java
Patch:
@@ -38,7 +38,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final OtherPersistentObject other = (OtherPersistentObject) obj;
+        OtherPersistentObject other = (OtherPersistentObject) obj;
         return Objects.equals(this.id, other.id);
     }
 }

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/SlicesIsolationTest.java
Patch:
@@ -43,7 +43,7 @@ public void controllers_should_only_use_their_own_slice_with_custom_ignore() {
                 .check(classes);
     }
 
-    private static DescribedPredicate<Slice> containDescription(final String descriptionPart) {
+    private static DescribedPredicate<Slice> containDescription(String descriptionPart) {
         return new DescribedPredicate<Slice>("contain description '%s'", descriptionPart) {
             @Override
             public boolean test(Slice input) {

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/extension/NewConfigurationEvent.java
Patch:
@@ -35,7 +35,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final NewConfigurationEvent other = (NewConfigurationEvent) obj;
+        NewConfigurationEvent other = (NewConfigurationEvent) obj;
         return Objects.equals(this.properties, other.properties);
     }
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/ArchUnitArchitectureTest.java
Patch:
@@ -83,11 +83,11 @@ private static DescribedPredicate<JavaCall<?>> typeIsIllegallyResolvedViaReflect
         return classIsResolvedViaReflection().and(not(explicitlyAllowedUsage));
     }
 
-    private static DescribedPredicate<JavaAccess<?>> contextIsAnnotatedWith(final Class<? extends Annotation> annotationType) {
+    private static DescribedPredicate<JavaAccess<?>> contextIsAnnotatedWith(Class<? extends Annotation> annotationType) {
         return origin(With.owner(withAnnotation(annotationType)));
     }
 
-    private static DescribedPredicate<JavaClass> withAnnotation(final Class<? extends Annotation> annotationType) {
+    private static DescribedPredicate<JavaClass> withAnnotation(Class<? extends Annotation> annotationType) {
         return new DescribedPredicate<JavaClass>("annotated with @" + annotationType.getName()) {
             @Override
             public boolean test(JavaClass input) {

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/ExamplesIntegrationTest.java
Patch:
@@ -1263,8 +1263,8 @@ Stream<DynamicTest> RestrictNumberOfClassesWithACertainPropertyTest() {
 
     }
 
-    private static MessageAssertionChain.Link classesContaining(final Class<?>... classes) {
-        final String expectedLine = String.format("there is/are %d element(s) in %s", classes.length, formatNamesOf(classes));
+    private static MessageAssertionChain.Link classesContaining(Class<?>... classes) {
+        String expectedLine = String.format("there is/are %d element(s) in %s", classes.length, formatNamesOf(classes));
         return new MessageAssertionChain.Link() {
             @Override
             public Result filterMatching(List<String> lines) {

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/ExtensionIntegrationTest.java
Patch:
@@ -65,7 +65,7 @@ void evaluation_results_are_only_dispatched_to_enabled_extensions() {
         assertThat(ExampleExtension.getEvaluatedRuleEvents()).isEmpty();
     }
 
-    private static Condition<Object> containingEntry(final String propKey, final String propValue) {
+    private static Condition<Object> containingEntry(String propKey, String propValue) {
         return new Condition<Object>(String.format("containing entry {%s=%s}", propKey, propValue)) {
             @Override
             public boolean matches(Object value) {

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/CyclicErrorMatcher.java
Patch:
@@ -58,7 +58,7 @@ public CyclicErrorMatcher by(ExpectedRelation dependency) {
 
     @Override
     public MessageAssertionChain.Link.Result filterMatching(List<String> lines) {
-        final Result.Builder builder = new Result.Builder()
+        Result.Builder builder = new Result.Builder()
                 .containsText(cycleText());
 
         for (String sliceName : details.asMap().keySet()) {

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/internal/ArchUnitRunnerInternal.java
Patch:
@@ -64,7 +64,7 @@ private static AnalyzeClasses checkAnnotation(Class<?> testClass) {
 
     @Override
     public Statement classBlock(RunNotifier notifier) {
-        final Statement statement = super.classBlock(notifier);
+        Statement statement = super.classBlock(notifier);
         return new Statement() {
             @Override
             public void evaluate() throws Throwable {

File: archunit-junit/junit4/src/test/java/com/tngtech/archunit/junit/internal/ArchUnitRunnerRunsRuleSetsTest.java
Patch:
@@ -201,7 +201,7 @@ private Runnable verifyTestRan() {
     }
 
     // extractingResultOf(..) only looks for public methods
-    private Extractor<Object, Object> resultOf(final String methodName) {
+    private Extractor<Object, Object> resultOf(String methodName) {
         return input -> {
             Collection<Method> candidates = getAllMethods(input.getClass(), method -> method.getName().equals(methodName));
             checkState(!candidates.isEmpty(),

File: archunit-junit/junit5/engine-api/src/main/java/com/tngtech/archunit/junit/engine_api/FieldSelector.java
Patch:
@@ -59,7 +59,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final FieldSelector other = (FieldSelector) obj;
+        FieldSelector other = (FieldSelector) obj;
         return Objects.equals(this.clazz, other.clazz)
                 && Objects.equals(this.field, other.field);
     }

File: archunit-junit/junit5/engine-api/src/main/java/com/tngtech/archunit/junit/engine_api/FieldSource.java
Patch:
@@ -62,7 +62,7 @@ public boolean equals(Object obj) {
 		if (obj == null || getClass() != obj.getClass()) {
 			return false;
 		}
-        final FieldSource other = (FieldSource) obj;
+        FieldSource other = (FieldSource) obj;
         return Objects.equals(this.javaClass, other.javaClass)
                 && Objects.equals(this.fieldName, other.fieldName);
     }

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/internal/ClassCache.java
Patch:
@@ -149,7 +149,7 @@ public boolean equals(Object obj) {
             if (obj == null || getClass() != obj.getClass()) {
                 return false;
             }
-            final LocationsKey other = (LocationsKey) obj;
+            LocationsKey other = (LocationsKey) obj;
             return Objects.equals(this.importOptionTypes, other.importOptionTypes)
                     && Objects.equals(this.locations, other.locations);
         }

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/internal/ReflectionUtils.java
Patch:
@@ -121,7 +121,7 @@ private static <T extends Throwable> void rethrowUnchecked(Throwable throwable)
         throw (T) throwable;
     }
 
-    static Predicate<AnnotatedElement> withAnnotation(final Class<? extends Annotation> annotationType) {
+    static Predicate<AnnotatedElement> withAnnotation(Class<? extends Annotation> annotationType) {
         return input -> input.isAnnotationPresent(annotationType);
     }
 }

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/internal/ClassCacheConcurrencyTest.java
Patch:
@@ -67,7 +67,7 @@ public void concurrent_access() throws Exception {
         verifyNoMoreInteractions(classFileImporter);
     }
 
-    private Runnable repeatGetClassesToAnalyze(final int times) {
+    private Runnable repeatGetClassesToAnalyze(int times) {
         return () -> {
             for (int j = 0; j < times; j++) {
                 cache.getClassesToAnalyzeFor(TEST_CLASSES.get(j % TEST_CLASSES.size()),

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/internal/ClassCacheTest.java
Patch:
@@ -246,7 +246,7 @@ private void verifyNumberOfImports(int number) {
         verifyNoMoreInteractions(cacheClassFileImporter);
     }
 
-    private static Condition<Iterable<? extends Location>> locationContaining(final String part) {
+    private static Condition<Iterable<? extends Location>> locationContaining(String part) {
         return new Condition<Iterable<? extends Location>>() {
             @Override
             public boolean matches(Iterable<? extends Location> locations) {

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/internal/ReflectionUtilsTest.java
Patch:
@@ -62,7 +62,7 @@ public void getAllFields_of_interface() {
                         field(OtherInterface.class, "OTHER_CONSTANT"));
     }
 
-    private Predicate<Member> named(final String name) {
+    private Predicate<Member> named(String name) {
         return input -> input.getName().equals(name);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/base/ChainableFunction.java
Patch:
@@ -23,7 +23,7 @@
 
 @PublicAPI(usage = INHERITANCE)
 public abstract class ChainableFunction<F, T> implements Function<F, T> {
-    public <E> ChainableFunction<E, T> after(final Function<? super E, ? extends F> function) {
+    public <E> ChainableFunction<E, T> after(Function<? super E, ? extends F> function) {
         return new ChainableFunction<E, T>() {
             @Override
             public T apply(E input) {
@@ -32,7 +32,7 @@ public T apply(E input) {
         };
     }
 
-    public <U> ChainableFunction<F, U> then(final Function<? super T, ? extends U> function) {
+    public <U> ChainableFunction<F, U> then(Function<? super T, ? extends U> function) {
         return new ChainableFunction<F, U>() {
             @Override
             public U apply(F input) {

File: archunit/src/main/java/com/tngtech/archunit/base/DescribedIterable.java
Patch:
@@ -30,7 +30,7 @@ private From() {
         }
 
         @PublicAPI(usage = ACCESS)
-        public static <T> DescribedIterable<T> iterable(final Iterable<T> iterable, final String description) {
+        public static <T> DescribedIterable<T> iterable(Iterable<T> iterable, String description) {
             return new DescribedIterable<T>() {
                 @Override
                 public String getDescription() {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AnnotationProxy.java
Patch:
@@ -364,7 +364,7 @@ public boolean equals(Object obj) {
             if (obj == null || getClass() != obj.getClass()) {
                 return false;
             }
-            final MethodKey other = (MethodKey) obj;
+            MethodKey other = (MethodKey) obj;
             return Objects.equals(this.name, other.name)
                     && Objects.equals(this.paramTypeNames, other.paramTypeNames);
         }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Dependency.java
Patch:
@@ -288,7 +288,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final Dependency other = (Dependency) obj;
+        Dependency other = (Dependency) obj;
         return Objects.equals(this.originClass, other.originClass)
                 && Objects.equals(this.targetClass, other.targetClass)
                 && Objects.equals(this.lineNumber, other.lineNumber)
@@ -372,7 +372,7 @@ public static DescribedPredicate<Dependency> dependencyOrigin(String className)
         }
 
         @PublicAPI(usage = ACCESS)
-        public static DescribedPredicate<Dependency> dependencyOrigin(final DescribedPredicate<? super JavaClass> predicate) {
+        public static DescribedPredicate<Dependency> dependencyOrigin(DescribedPredicate<? super JavaClass> predicate) {
             return Functions.GET_ORIGIN_CLASS.is(predicate).as("origin " + predicate.getDescription());
         }
 
@@ -387,7 +387,7 @@ public static DescribedPredicate<Dependency> dependencyTarget(String className)
         }
 
         @PublicAPI(usage = ACCESS)
-        public static DescribedPredicate<Dependency> dependencyTarget(final DescribedPredicate<? super JavaClass> predicate) {
+        public static DescribedPredicate<Dependency> dependencyTarget(DescribedPredicate<? super JavaClass> predicate) {
             return Functions.GET_TARGET_CLASS.is(predicate).as("target " + predicate.getDescription());
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaAccess.java
Patch:
@@ -155,12 +155,12 @@ public static DescribedPredicate<JavaAccess<?>> originOwnerEqualsTargetOwner() {
         }
 
         @PublicAPI(usage = ACCESS)
-        public static DescribedPredicate<JavaAccess<?>> targetOwner(final DescribedPredicate<? super JavaClass> predicate) {
+        public static DescribedPredicate<JavaAccess<?>> targetOwner(DescribedPredicate<? super JavaClass> predicate) {
             return target(Get.<JavaClass>owner().is(predicate));
         }
 
         @PublicAPI(usage = ACCESS)
-        public static DescribedPredicate<JavaAccess<?>> target(final DescribedPredicate<? super AccessTarget> predicate) {
+        public static DescribedPredicate<JavaAccess<?>> target(DescribedPredicate<? super AccessTarget> predicate) {
             return new TargetPredicate<>(predicate);
         }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaCall.java
Patch:
@@ -39,7 +39,7 @@ private Predicates() {
         }
 
         @PublicAPI(usage = ACCESS)
-        public static DescribedPredicate<JavaCall<?>> target(final DescribedPredicate<? super CodeUnitCallTarget> predicate) {
+        public static DescribedPredicate<JavaCall<?>> target(DescribedPredicate<? super CodeUnitCallTarget> predicate) {
             return new TargetPredicate<>(predicate);
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassDependencies.java
Patch:
@@ -247,8 +247,8 @@ private <T extends HasDescription & HasAnnotations<?>> Stream<Dependency> annota
     }
 
     private <T extends HasDescription & HasAnnotations<?>> Stream<Dependency> annotationDependencies(T annotated) {
-        final Stream.Builder<Dependency> addToStream = Stream.builder();
-        for (final JavaAnnotation<?> annotation : annotated.getAnnotations()) {
+        Stream.Builder<Dependency> addToStream = Stream.builder();
+        for (JavaAnnotation<?> annotation : annotated.getAnnotations()) {
             Dependency.tryCreateFromAnnotation(annotation).forEach(addToStream);
             annotation.accept(new DefaultParameterVisitor() {
                 @Override

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassDescriptor.java
Patch:
@@ -200,7 +200,7 @@ public boolean equals(Object obj) {
                 if (obj == null || getClass() != obj.getClass()) {
                     return false;
                 }
-                final JavaClassDescriptor other = (JavaClassDescriptor) obj;
+                JavaClassDescriptor other = (JavaClassDescriptor) obj;
                 return Objects.equals(this.getFullyQualifiedClassName(), other.getFullyQualifiedClassName());
             }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassMembers.java
Patch:
@@ -55,7 +55,7 @@ class JavaClassMembers {
             .addAll(getAllConstructors())
             .build());
 
-    JavaClassMembers(final JavaClass owner, Set<JavaField> fields, Set<JavaMethod> methods, Set<JavaConstructor> constructors, Optional<JavaStaticInitializer> staticInitializer) {
+    JavaClassMembers(JavaClass owner, Set<JavaField> fields, Set<JavaMethod> methods, Set<JavaConstructor> constructors, Optional<JavaStaticInitializer> staticInitializer) {
         this.owner = owner;
         this.fields = fields;
         this.methods = methods;
@@ -318,9 +318,9 @@ void completeAnnotations(ImportContext context) {
         }
     }
 
-    void completeAccessesFrom(ImportContext context) {
+    void completeFrom(ImportContext context) {
         for (JavaCodeUnit codeUnit : codeUnits) {
-            codeUnit.completeAccessesFrom(context);
+            codeUnit.completeFrom(context);
         }
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClasses.java
Patch:
@@ -164,7 +164,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final JavaClasses other = (JavaClasses) obj;
+        JavaClasses other = (JavaClasses) obj;
         return Objects.equals(this.classes.keySet(), other.classes.keySet())
                 && Objects.equals(this.description, other.description);
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaCodeUnitAccess.java
Patch:
@@ -39,7 +39,7 @@ private Predicates() {
         }
 
         @PublicAPI(usage = ACCESS)
-        public static DescribedPredicate<JavaCodeUnitAccess<?>> target(final DescribedPredicate<? super CodeUnitAccessTarget> predicate) {
+        public static DescribedPredicate<JavaCodeUnitAccess<?>> target(DescribedPredicate<? super CodeUnitAccessTarget> predicate) {
             return new TargetPredicate<>(predicate);
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaCodeUnitReference.java
Patch:
@@ -39,7 +39,7 @@ private Predicates() {
         }
 
         @PublicAPI(usage = ACCESS)
-        public static DescribedPredicate<JavaCodeUnitReference<?>> target(final DescribedPredicate<? super CodeUnitReferenceTarget> predicate) {
+        public static DescribedPredicate<JavaCodeUnitReference<?>> target(DescribedPredicate<? super CodeUnitReferenceTarget> predicate) {
             return new TargetPredicate<>(predicate);
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaEnumConstant.java
Patch:
@@ -60,7 +60,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final JavaEnumConstant other = (JavaEnumConstant) obj;
+        JavaEnumConstant other = (JavaEnumConstant) obj;
         return Objects.equals(this.declaringClass, other.declaringClass)
                 && Objects.equals(this.name, other.name);
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaFieldAccess.java
Patch:
@@ -93,12 +93,12 @@ private Predicates() {
         }
 
         @PublicAPI(usage = ACCESS)
-        public static DescribedPredicate<JavaFieldAccess> accessType(final AccessType accessType) {
+        public static DescribedPredicate<JavaFieldAccess> accessType(AccessType accessType) {
             return new AccessTypePredicate(accessType);
         }
 
         @PublicAPI(usage = ACCESS)
-        public static DescribedPredicate<JavaFieldAccess> target(final DescribedPredicate<? super FieldAccessTarget> predicate) {
+        public static DescribedPredicate<JavaFieldAccess> target(DescribedPredicate<? super FieldAccessTarget> predicate) {
             return new TargetPredicate<>(predicate);
         }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ReverseDependencies.java
Patch:
@@ -66,7 +66,7 @@ private ReverseDependencies(ReverseDependencies.Creation creation) {
         this.directDependenciesToClass = createDirectDependenciesToClassSupplier(creation.allDependencies);
     }
 
-    private static Supplier<SetMultimap<JavaClass, Dependency>> createDirectDependenciesToClassSupplier(final List<JavaClassDependencies> allDependencies) {
+    private static Supplier<SetMultimap<JavaClass, Dependency>> createDirectDependenciesToClassSupplier(List<JavaClassDependencies> allDependencies) {
         return Suppliers.memoize(() -> {
             ImmutableSetMultimap.Builder<JavaClass, Dependency> result = ImmutableSetMultimap.builder();
             for (JavaClassDependencies dependencies : allDependencies) {
@@ -221,7 +221,7 @@ private void registerConstructors(JavaClass clazz) {
         }
 
         private void registerAnnotations(JavaClass clazz) {
-            for (final JavaAnnotation<?> annotation : findAnnotations(clazz)) {
+            for (JavaAnnotation<?> annotation : findAnnotations(clazz)) {
                 annotationTypeDependencies.put(annotation.getRawType(), annotation);
                 annotation.accept(new JavaAnnotation.DefaultParameterVisitor() {
                     @Override
@@ -277,7 +277,7 @@ private ResolvingAccessLoader(SetMultimap<JavaClass, ACCESS> accessesToSelf) {
         @Override
         public Set<ACCESS> load(MEMBER member) {
             ImmutableSet.Builder<ACCESS> result = ImmutableSet.builder();
-            for (final JavaClass javaClass : getPossibleTargetClassesForAccess(member.getOwner())) {
+            for (JavaClass javaClass : getPossibleTargetClassesForAccess(member.getOwner())) {
                 for (ACCESS access : this.accessesToSelf.get(javaClass)) {
                     Optional<? extends JavaMember> target = access.getTarget().resolveMember();
                     if (target.isPresent() && target.get().equals(member)) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Source.java
Patch:
@@ -83,7 +83,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final Source other = (Source) obj;
+        Source other = (Source) obj;
         return Objects.equals(this.uri, other.uri)
                 && Objects.equals(this.md5sum, other.md5sum);
     }
@@ -151,7 +151,7 @@ public boolean equals(Object obj) {
             if (obj == null || getClass() != obj.getClass()) {
                 return false;
             }
-            final Md5sum other = (Md5sum) obj;
+            Md5sum other = (Md5sum) obj;
             return Arrays.equals(this.md5Bytes, other.md5Bytes)
                     && Objects.equals(this.text, other.text);
         }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/SourceCodeLocation.java
Patch:
@@ -110,7 +110,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final SourceCodeLocation other = (SourceCodeLocation) obj;
+        SourceCodeLocation other = (SourceCodeLocation) obj;
         return Objects.equals(this.sourceClass, other.sourceClass)
                 && Objects.equals(this.lineNumber, other.lineNumber);
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ThrowsClause.java
Patch:
@@ -110,7 +110,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final ThrowsClause<?> other = (ThrowsClause<?>) obj;
+        ThrowsClause<?> other = (ThrowsClause<?>) obj;
         return Objects.equals(this.location, other.location)
                 && Objects.equals(this.getTypes(), other.getTypes());
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ThrowsDeclaration.java
Patch:
@@ -124,7 +124,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final ThrowsDeclaration<?> other = (ThrowsDeclaration<?>) obj;
+        ThrowsDeclaration<?> other = (ThrowsDeclaration<?>) obj;
         return Objects.equals(this.getLocation(), other.getLocation())
                 && Objects.equals(this.type, other.type);
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasModifiers.java
Patch:
@@ -37,7 +37,7 @@ private Predicates() {
         }
 
         @PublicAPI(usage = ACCESS)
-        public static DescribedPredicate<HasModifiers> modifier(final JavaModifier modifier) {
+        public static DescribedPredicate<HasModifiers> modifier(JavaModifier modifier) {
             return new ModifierPredicate(modifier);
         }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasOwner.java
Patch:
@@ -54,7 +54,7 @@ private With() {
             }
 
             @PublicAPI(usage = ACCESS)
-            public static <T> DescribedPredicate<HasOwner<T>> owner(final DescribedPredicate<? super T> predicate) {
+            public static <T> DescribedPredicate<HasOwner<T>> owner(DescribedPredicate<? super T> predicate) {
                 return new OwnerPredicate<>(predicate);
             }
         }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileImporter.java
Patch:
@@ -334,7 +334,7 @@ private void tryAdd(List<ClassFileSource> sources, Location location) {
         }
     }
 
-    private ClassFileSource unify(final List<ClassFileSource> sources) {
+    private ClassFileSource unify(List<ClassFileSource> sources) {
         return Iterables.concat(sources)::iterator;
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/Location.java
Patch:
@@ -168,7 +168,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final Location other = (Location) obj;
+        Location other = (Location) obj;
         return Objects.equals(this.uri, other.uri);
     }
 
@@ -375,8 +375,8 @@ private List<NormalizedResourceName> getAllFilesBeneath(NormalizedUri uri) throw
             return getAllFilesBeneath(rootFile.toPath());
         }
 
-        private List<NormalizedResourceName> getAllFilesBeneath(final Path root) throws IOException {
-            final ImmutableList.Builder<NormalizedResourceName> result = ImmutableList.builder();
+        private List<NormalizedResourceName> getAllFilesBeneath(Path root) throws IOException {
+            ImmutableList.Builder<NormalizedResourceName> result = ImmutableList.builder();
             Files.walkFileTree(root, new SimpleFileVisitor<Path>() {
                 @Override
                 public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/NormalizedResourceName.java
Patch:
@@ -80,7 +80,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final NormalizedResourceName other = (NormalizedResourceName) obj;
+        NormalizedResourceName other = (NormalizedResourceName) obj;
         return Objects.equals(this.resourceName, other.resourceName);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/NormalizedUri.java
Patch:
@@ -66,7 +66,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final NormalizedUri other = (NormalizedUri) obj;
+        NormalizedUri other = (NormalizedUri) obj;
         return Objects.equals(this.uri, other.uri);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/UrlSource.java
Patch:
@@ -59,7 +59,7 @@ class From {
         private static final String BOOT_CLASS_PATH_PROPERTY_NAME = "sun.boot.class.path";
 
         static UrlSource iterable(Iterable<URL> urls) {
-            final Iterable<URL> uniqueUrls = unique(urls);
+            Iterable<URL> uniqueUrls = unique(urls);
             return new UrlSource() {
                 @Override
                 public Iterator<URL> iterator() {

File: archunit/src/main/java/com/tngtech/archunit/lang/AbstractClassesTransformer.java
Patch:
@@ -44,7 +44,7 @@ public final DescribedIterable<T> transform(JavaClasses collection) {
     public abstract Iterable<T> doTransform(JavaClasses collection);
 
     @Override
-    public final ClassesTransformer<T> that(final DescribedPredicate<? super T> predicate) {
+    public final ClassesTransformer<T> that(DescribedPredicate<? super T> predicate) {
         return new AbstractClassesTransformer<T>(description + " that " + predicate.getDescription()) {
             @Override
             public Iterable<T> doTransform(JavaClasses collection) {

File: archunit/src/main/java/com/tngtech/archunit/lang/ArchRule.java
Patch:
@@ -125,7 +125,7 @@ public EvaluationResult getResult() {
 
     @Internal
     class Factory {
-        public static <T> ArchRule create(final ClassesTransformer<T> classesTransformer, final ArchCondition<T> condition, final Priority priority) {
+        public static <T> ArchRule create(ClassesTransformer<T> classesTransformer, ArchCondition<T> condition, Priority priority) {
             return new SimpleArchRule<>(priority, classesTransformer, condition, Optional.empty(), AllowEmptyShould.AS_CONFIGURED);
         }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/EvaluationResult.java
Patch:
@@ -129,7 +129,7 @@ public void add(EvaluationResult part) {
     public final <T> void handleViolations(ViolationHandler<T> violationHandler, T... __ignored_parameter_to_reify_type__) {
         Class<T> correspondingObjectType = componentTypeOf(__ignored_parameter_to_reify_type__);
         ConditionEvent.Handler eventHandler = convertToEventHandler(correspondingObjectType, violationHandler);
-        for (final ConditionEvent event : violations) {
+        for (ConditionEvent event : violations) {
             event.handleWith(eventHandler);
         }
     }
@@ -189,7 +189,7 @@ private static ArrayList<ConditionEvent> createViolations(ArrayList<ConditionEve
         return patterns.isEmpty() ? violations : filterEvents(violations, notMatchedByAny(patterns));
     }
 
-    private static Predicate<String> notMatchedByAny(final Set<Pattern> patterns) {
+    private static Predicate<String> notMatchedByAny(Set<Pattern> patterns) {
         return message -> {
             String normalizedMessage = message.replaceAll("\r*\n", " ");
             return patterns.stream().noneMatch(pattern -> pattern.matcher(normalizedMessage).matches());

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AllDependenciesCondition.java
Patch:
@@ -36,15 +36,15 @@ public final class AllDependenciesCondition extends AllAttributesMatchCondition<
 
     AllDependenciesCondition(
             String description,
-            final DescribedPredicate<? super Dependency> predicate,
+            DescribedPredicate<? super Dependency> predicate,
             Function<JavaClass, ? extends Collection<Dependency>> javaClassToRelevantDependencies) {
 
         this(description, predicate, javaClassToRelevantDependencies, alwaysFalse());
     }
 
     private AllDependenciesCondition(
             String description,
-            final DescribedPredicate<? super Dependency> conditionPredicate,
+            DescribedPredicate<? super Dependency> conditionPredicate,
             Function<JavaClass, ? extends Collection<Dependency>> javaClassToRelevantDependencies,
             DescribedPredicate<Dependency> ignorePredicate) {
 

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AndCondition.java
Patch:
@@ -54,7 +54,7 @@ public List<String> getDescriptionLines() {
         }
 
         @Override
-        public void handleWith(final ConditionEvent.Handler handler) {
+        public void handleWith(ConditionEvent.Handler handler) {
             for (ConditionWithEvents<T> condition : evaluatedConditions) {
                 condition.getEvents().getViolating().forEach(event -> event.handleWith(handler));
             }

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AnyDependencyCondition.java
Patch:
@@ -36,15 +36,15 @@ public final class AnyDependencyCondition extends AnyAttributeMatchesCondition<D
 
     AnyDependencyCondition(
             String description,
-            final DescribedPredicate<? super Dependency> predicate,
+            DescribedPredicate<? super Dependency> predicate,
             Function<JavaClass, ? extends Collection<Dependency>> javaClassToRelevantDependencies) {
 
         this(description, predicate, javaClassToRelevantDependencies, alwaysFalse());
     }
 
     private AnyDependencyCondition(
             String description,
-            final DescribedPredicate<? super Dependency> conditionPredicate,
+            DescribedPredicate<? super Dependency> conditionPredicate,
             Function<JavaClass, ? extends Collection<Dependency>> javaClassToRelevantDependencies,
             DescribedPredicate<Dependency> ignorePredicate) {
 

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/JavaAccessPackagePredicate.java
Patch:
@@ -53,7 +53,7 @@ private Creator(Function<JavaAccess<?>, String> getPackageName) {
             this.getPackageName = getPackageName;
         }
 
-        JavaAccessPackagePredicate matching(final String... packageIdentifiers) {
+        JavaAccessPackagePredicate matching(String... packageIdentifiers) {
             return new JavaAccessPackagePredicate(packageIdentifiers, getPackageName);
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/JoinCondition.java
Patch:
@@ -107,7 +107,7 @@ abstract static class JoinConditionEvent<T> implements ConditionEvent {
         }
 
         List<String> getUniqueLinesOfViolations() {
-            final Set<String> result = new TreeSet<>();
+            Set<String> result = new TreeSet<>();
             for (ConditionWithEvents<T> evaluation : evaluatedConditions) {
                 for (ConditionEvent event : evaluation.events.getViolating()) {
                     result.addAll(event.getDescriptionLines());

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/OrCondition.java
Patch:
@@ -61,7 +61,7 @@ private String createMessage() {
         }
 
         @Override
-        public void handleWith(final Handler handler) {
+        public void handleWith(Handler handler) {
             handler.handle(singleton(correspondingObject), createMessage());
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ClassesShouldInternal.java
Patch:
@@ -65,12 +65,12 @@ private ClassesShouldInternal(ClassesTransformer<JavaClass> classesTransformer,
     }
 
     @Override
-    public ClassesShouldConjunction be(final Class<?> clazz) {
+    public ClassesShouldConjunction be(Class<?> clazz) {
         return addCondition(ArchConditions.be(clazz));
     }
 
     @Override
-    public ClassesShouldConjunction notBe(final Class<?> clazz) {
+    public ClassesShouldConjunction notBe(Class<?> clazz) {
         return addCondition(ArchConditions.notBe(clazz));
     }
 
@@ -85,7 +85,7 @@ public ClassesShouldConjunction notBe(String className) {
     }
 
     @Override
-    public ClassesShouldConjunction haveFullyQualifiedName(final String name) {
+    public ClassesShouldConjunction haveFullyQualifiedName(String name) {
         return addCondition(ArchConditions.haveFullyQualifiedName(name));
     }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/MembersDeclaredInClassesThat.java
Patch:
@@ -443,7 +443,7 @@ public CONJUNCTION areNotLocalClasses() {
     }
 
     @Override
-    public CONJUNCTION belongToAnyOf(final Class<?>... classes) {
+    public CONJUNCTION belongToAnyOf(Class<?>... classes) {
         return givenWith(JavaClass.Predicates.belongToAnyOf(classes));
     }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ObjectsShouldInternal.java
Patch:
@@ -153,7 +153,7 @@ static <T> AddMode<T> and() {
             return and(Function.identity());
         }
 
-        static <T> AddMode<T> and(final Function<ArchCondition<T>, ArchCondition<T>> prepareCondition) {
+        static <T> AddMode<T> and(Function<ArchCondition<T>, ArchCondition<T>> prepareCondition) {
             return new AddMode<T>() {
                 @Override
                 ArchCondition<T> apply(Optional<ArchCondition<T>> first, ArchCondition<? super T> other) {
@@ -163,7 +163,7 @@ ArchCondition<T> apply(Optional<ArchCondition<T>> first, ArchCondition<? super T
             };
         }
 
-        static <T> AddMode<T> or(final Function<ArchCondition<T>, ArchCondition<T>> prepareCondition) {
+        static <T> AddMode<T> or(Function<ArchCondition<T>, ArchCondition<T>> prepareCondition) {
             return new AddMode<T>() {
                 @Override
                 ArchCondition<T> apply(Optional<ArchCondition<T>> first, ArchCondition<? super T> other) {
@@ -176,7 +176,7 @@ ArchCondition<T> apply(Optional<ArchCondition<T>> first, ArchCondition<? super T
         abstract ArchCondition<T> apply(Optional<ArchCondition<T>> first, ArchCondition<? super T> other);
     }
 
-    static <T> Function<ArchCondition<T>, ArchCondition<T>> prependDescription(final String prefix) {
+    static <T> Function<ArchCondition<T>, ArchCondition<T>> prependDescription(String prefix) {
         return input -> input.as(prefix + " " + input.getDescription());
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/library/DependencyRules.java
Patch:
@@ -123,7 +123,7 @@ private static class DependOnUpperPackagesCondition extends ArchCondition<JavaCl
         }
 
         @Override
-        public void check(final JavaClass clazz, final ConditionEvents events) {
+        public void check(JavaClass clazz, ConditionEvents events) {
             for (Dependency dependency : clazz.getDirectDependenciesFromSelf()) {
                 boolean dependencyOnUpperPackage = isDependencyOnUpperPackage(dependency.getOriginClass(), dependency.getTargetClass());
                 events.add(new SimpleConditionEvent(dependency, dependencyOnUpperPackage, dependency.getDescription()));

File: archunit/src/main/java/com/tngtech/archunit/library/ProxyRules.java
Patch:
@@ -162,7 +162,7 @@ public static ArchCondition<JavaClass> directly_call_other_methods_declared_in_t
      * </p>
      */
     @PublicAPI(usage = ACCESS)
-    public static ArchCondition<JavaClass> directly_call_other_methods_declared_in_the_same_class_that(final DescribedPredicate<? super MethodCallTarget> predicate) {
+    public static ArchCondition<JavaClass> directly_call_other_methods_declared_in_the_same_class_that(DescribedPredicate<? super MethodCallTarget> predicate) {
         return new ArchCondition<JavaClass>("directly call other methods declared in the same class that " + predicate.getDescription()) {
             @Override
             public void check(JavaClass javaClass, ConditionEvents events) {

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Cycle.java
Patch:
@@ -70,7 +70,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final Cycle<?, ?> other = (Cycle<?, ?>) obj;
+        Cycle<?, ?> other = (Cycle<?, ?>) obj;
         return Objects.equals(this.path.getSetOfEdges(), other.path.getSetOfEdges());
     }
 

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Edge.java
Patch:
@@ -59,7 +59,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final Edge<?, ?> other = (Edge<?, ?>) obj;
+        Edge<?, ?> other = (Edge<?, ?>) obj;
         return Objects.equals(this.from, other.from)
                 && Objects.equals(this.to, other.to);
     }

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Path.java
Patch:
@@ -111,7 +111,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final Path<?, ?> other = (Path<?, ?>) obj;
+        Path<?, ?> other = (Path<?, ?>) obj;
         return Objects.equals(this.edges, other.edges);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Slice.java
Patch:
@@ -169,7 +169,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final Slice other = (Slice) obj;
+        Slice other = (Slice) obj;
         return Objects.equals(this.matchingGroups, other.matchingGroups);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceDependency.java
Patch:
@@ -46,7 +46,7 @@ private SliceDependency(Slice origin, Iterable<Dependency> dependenciesToConside
         this.target = target;
     }
 
-    private SortedSet<Dependency> filterTarget(Iterable<Dependency> dependenciesToConsider, final Slice target) {
+    private SortedSet<Dependency> filterTarget(Iterable<Dependency> dependenciesToConsider, Slice target) {
         return stream(dependenciesToConsider.spliterator(), false)
                 .filter(input -> target.contains(input.getTargetClass()))
                 .collect(toCollection(TreeSet::new));
@@ -92,7 +92,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final SliceDependency other = (SliceDependency) obj;
+        SliceDependency other = (SliceDependency) obj;
         return Objects.equals(this.origin, other.origin)
                 && Objects.equals(this.target, other.target);
     }

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceIdentifier.java
Patch:
@@ -60,7 +60,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final SliceIdentifier other = (SliceIdentifier) obj;
+        SliceIdentifier other = (SliceIdentifier) obj;
         return Objects.equals(this.parts, other.parts);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Slices.java
Patch:
@@ -242,7 +242,7 @@ private Slices createSlices(JavaClasses classes) {
         }
 
         @Override
-        public Slices.Transformer that(final DescribedPredicate<? super Slice> predicate) {
+        public Slices.Transformer that(DescribedPredicate<? super Slice> predicate) {
             String newDescription = this.predicate.joinDescription(getDescription(), predicate.getDescription());
             return new Transformer(sliceAssignment, newDescription, namingPattern, this.predicate.add(predicate));
         }

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/FreezingArchRule.java
Patch:
@@ -141,7 +141,7 @@ private EvaluationResult storeViolationsAndReturnSuccess(EvaluationResultLineBre
 
     private EvaluationResult removeObsoleteViolationsFromStoreAndReturnNewViolations(EvaluationResultLineBreakAdapter result) {
         log.debug("Found frozen result for rule '{}'", delegate.getDescription());
-        final List<String> knownViolations = store.getViolations(delegate);
+        List<String> knownViolations = store.getViolations(delegate);
         CategorizedViolations categorizedViolations = new CategorizedViolations(matcher, result, knownViolations);
         removeObsoleteViolationsFromStore(categorizedViolations);
         return filterOutKnownViolations(result, categorizedViolations.getKnownActualViolations());
@@ -155,7 +155,7 @@ private void removeObsoleteViolationsFromStore(CategorizedViolations categorized
         }
     }
 
-    private EvaluationResult filterOutKnownViolations(EvaluationResultLineBreakAdapter result, final Set<String> knownActualViolations) {
+    private EvaluationResult filterOutKnownViolations(EvaluationResultLineBreakAdapter result, Set<String> knownActualViolations) {
         log.debug("Filtering out known violations: {}", knownActualViolations);
         return result.filterDescriptionsMatching(violation -> !knownActualViolations.contains(violation));
     }
@@ -293,7 +293,7 @@ Priority getPriority() {
             return result.getPriority();
         }
 
-        EvaluationResult filterDescriptionsMatching(final Predicate<String> predicate) {
+        EvaluationResult filterDescriptionsMatching(Predicate<String> predicate) {
             return result.filterDescriptionsMatching(input -> predicate.test(ensureUnixLineBreaks(input)));
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/ViolationLineMatcherFactory.java
Patch:
@@ -97,7 +97,7 @@ private int nextIndexOfCharacterOrEndOfString(char ch) {
             }
 
             private int findStartIndexOfNextRelevantPart() {
-                final int startOfIgnoredPart = end + 1;
+                int startOfIgnoredPart = end + 1;
                 int indexOfNonDigit = findIndexOfNextNonDigitChar(startOfIgnoredPart);
                 if (str.charAt(end) == ':') {
                     boolean foundNumber = indexOfNonDigit > startOfIgnoredPart;

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/rules/Alias.java
Patch:
@@ -46,7 +46,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final Alias other = (Alias) obj;
+        Alias other = (Alias) obj;
         return Objects.equals(this.value, other.value);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/rules/ComponentIdentifier.java
Patch:
@@ -52,7 +52,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final ComponentIdentifier other = (ComponentIdentifier) obj;
+        ComponentIdentifier other = (ComponentIdentifier) obj;
         return Objects.equals(this.componentName, other.componentName)
                 && Objects.equals(this.alias, other.alias);
     }

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/rules/ComponentName.java
Patch:
@@ -43,7 +43,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final ComponentName other = (ComponentName) obj;
+        ComponentName other = (ComponentName) obj;
         return Objects.equals(this.value, other.value);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/rules/JavaClassDiagramAssociation.java
Patch:
@@ -48,7 +48,7 @@ private void validateStereotypes(PlantUmlDiagram plantUmlDiagram) {
         }
     }
 
-    Set<String> getTargetPackageIdentifiers(final JavaClass javaClass) {
+    Set<String> getTargetPackageIdentifiers(JavaClass javaClass) {
         ImmutableSet.Builder<String> result = ImmutableSet.builder();
         for (PlantUmlComponent target : getComponentOf(javaClass).getDependencies()) {
             result.addAll(getPackageIdentifiersFromComponentOf(target));
@@ -68,7 +68,7 @@ private Set<String> getPackageIdentifiersFromComponentOf(PlantUmlComponent compo
         return result.build();
     }
 
-    private PlantUmlComponent getComponentOf(final JavaClass javaClass) {
+    private PlantUmlComponent getComponentOf(JavaClass javaClass) {
         return getOnlyElement(getAssociatedComponents(javaClass));
     }
 

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/rules/ParsedDependency.java
Patch:
@@ -47,7 +47,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final ParsedDependency other = (ParsedDependency) obj;
+        ParsedDependency other = (ParsedDependency) obj;
         return Objects.equals(this.origin, other.origin)
                 && Objects.equals(this.target, other.target);
     }

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/rules/PlantUmlComponent.java
Patch:
@@ -79,7 +79,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final PlantUmlComponent other = (PlantUmlComponent) obj;
+        PlantUmlComponent other = (PlantUmlComponent) obj;
         return Objects.equals(this.componentName, other.componentName)
                 && Objects.equals(this.stereotypes, other.stereotypes)
                 && Objects.equals(this.alias, other.alias);

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/rules/PlantUmlComponentDependency.java
Patch:
@@ -45,7 +45,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final PlantUmlComponentDependency other = (PlantUmlComponentDependency) obj;
+        PlantUmlComponentDependency other = (PlantUmlComponentDependency) obj;
         return Objects.equals(this.origin, other.origin)
                 && Objects.equals(this.target, other.target);
     }

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/rules/PlantUmlPatterns.java
Patch:
@@ -73,7 +73,7 @@ PlantUmlComponentMatcher matchComponent(String input) {
         return new PlantUmlComponentMatcher(input);
     }
 
-    private Predicate<String> matches(final Pattern pattern) {
+    private Predicate<String> matches(Pattern pattern) {
         return input -> pattern.matcher(input).matches();
     }
 

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/rules/Stereotype.java
Patch:
@@ -43,7 +43,7 @@ public boolean equals(Object obj) {
         if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
-        final Stereotype other = (Stereotype) obj;
+        Stereotype other = (Stereotype) obj;
         return Objects.equals(this.value, other.value);
     }
 

File: archunit/src/test/java/com/tngtech/archunit/base/ChainableFunctionTest.java
Patch:
@@ -26,7 +26,7 @@ public void is() {
                 .accepts("8");
     }
 
-    private DescribedPredicate<Integer> greaterThan(final int number) {
+    private DescribedPredicate<Integer> greaterThan(int number) {
         return new DescribedPredicate<Integer>("greater than " + number) {
             @Override
             public boolean test(Integer input) {
@@ -44,7 +44,7 @@ public Integer apply(String input) {
         };
     }
 
-    private ChainableFunction<Integer, Integer> plus(final int number) {
+    private ChainableFunction<Integer, Integer> plus(int number) {
         return new ChainableFunction<Integer, Integer>() {
             @Override
             public Integer apply(Integer input) {

File: archunit/src/test/java/com/tngtech/archunit/base/DescribedPredicateTest.java
Patch:
@@ -273,7 +273,7 @@ public void allElements_works() {
                 .accepts(ImmutableList.of());
     }
 
-    private Function<Object, Integer> constant(final int integer) {
+    private Function<Object, Integer> constant(int integer) {
         return input -> integer;
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/domain/AnnotationProxyTest.java
Patch:
@@ -294,7 +294,7 @@ private String formatSubAnnotation(AnnotationPropertiesFormatter formatter, Stri
     }
 
     // NOTE: We do not want this value to be treated as a string by the formatter, and e.g. quoted -> Object
-    private Object subAnnotationFormatter(final AnnotationPropertiesFormatter formatter, final String value) {
+    private Object subAnnotationFormatter(AnnotationPropertiesFormatter formatter, String value) {
         return new Object() {
             @Override
             public String toString() {
@@ -396,7 +396,7 @@ private List<String> valuesOf(SubAnnotation[] subAnnotations) {
         return stream(subAnnotations).map(SubAnnotation::value).collect(toList());
     }
 
-    private Condition<String> matching(final Class<?> annotationType, final Map<String, String> properties) {
+    private Condition<String> matching(Class<?> annotationType, Map<String, String> properties) {
         return new Condition<String>("matching " + properties) {
             @Override
             public boolean matches(String value) {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassesTest.java
Patch:
@@ -112,7 +112,7 @@ public void trying_to_get_a_missing_class_causes_IllegalArgumentException() {
                 .hasMessage("JavaClasses do not contain JavaClass of type %s", String.class.getName());
     }
 
-    private DescribedPredicate<JavaClass> haveTheNameOf(final Class<?> clazz) {
+    private DescribedPredicate<JavaClass> haveTheNameOf(Class<?> clazz) {
         return new DescribedPredicate<JavaClass>("have the name " + clazz.getSimpleName()) {
             @Override
             public boolean test(JavaClass input) {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaCodeUnitTest.java
Patch:
@@ -116,7 +116,7 @@ public void creates_parameters_when_raw_parameter_types_do_not_match_generic_par
 
     @Test
     public void falls_back_to_creating_parameters_with_only_generic_types_if_match_between_raw_types_and_generic_types_cannot_be_made() {
-        final List<String> nonConstant = newArrayList(getClass().getName());
+        List<String> nonConstant = newArrayList(getClass().getName());
         class LocalClassReferencingNonConstantFromOuterScope {
             @SuppressWarnings("unused")
             LocalClassReferencingNonConstantFromOuterScope(List<String> someParameterizedType) {
@@ -262,7 +262,7 @@ void method(@SomeParameterAnnotation("test") String param) {
             }
         }
 
-        final JavaParameter parameter = new ClassFileImporter().importClass(SomeClass.class)
+        JavaParameter parameter = new ClassFileImporter().importClass(SomeClass.class)
                 .getMethod("method", String.class).getParameters().get(0);
 
         SomeParameterAnnotation annotation = parameter.getAnnotationOfType(SomeParameterAnnotation.class);
@@ -284,7 +284,7 @@ void method(@SomeParameterAnnotation("test") String param) {
             }
         }
 
-        final JavaParameter parameter = new ClassFileImporter().importClass(SomeClass.class)
+        JavaParameter parameter = new ClassFileImporter().importClass(SomeClass.class)
                 .getMethod("method", String.class).getParameters().get(0);
 
         assertThat(parameter.tryGetAnnotationOfType(SomeParameterAnnotation.class).get()).isInstanceOf(SomeParameterAnnotation.class);

File: archunit/src/test/java/com/tngtech/archunit/core/domain/TestUtils.java
Patch:
@@ -85,7 +85,7 @@ public static JavaClass importClassWithContext(Class<?> owner) {
 
     public static JavaClasses importClassesWithContext(Class<?>... classes) {
         JavaClasses importedHierarchy = importHierarchies(classes);
-        final List<String> classNames = formatNamesOf(classes);
+        List<String> classNames = formatNamesOf(classes);
         return importedHierarchy.that(new DescribedPredicate<JavaClass>("") {
             @Override
             public boolean test(JavaClass input) {
@@ -166,7 +166,7 @@ private JavaMethodCall to(MethodCallTarget methodCallTarget) {
             ImportContext context = mock(ImportContext.class);
             Set<JavaMethodCall> calls = targets.stream().map(target -> newMethodCall(method, target, lineNumber)).collect(toSet());
             when(context.createMethodCallsFor(eq(method), anySet())).thenReturn(ImmutableSet.copyOf(calls));
-            method.completeAccessesFrom(context);
+            method.completeFrom(context);
             return getCallToTarget(methodCallTarget);
         }
 
@@ -190,7 +190,7 @@ public void to(JavaField target, AccessType accessType) {
                     .thenReturn(ImmutableSet.of(
                             newFieldAccess(method, target, lineNumber, accessType)
                     ));
-            method.completeAccessesFrom(context);
+            method.completeFrom(context);
         }
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasModifiersTest.java
Patch:
@@ -16,7 +16,7 @@ public void modifier_predicate() {
                 .hasDescription("modifier PRIVATE");
     }
 
-    private static HasModifiers hasModifiers(final JavaModifier... modifiers) {
+    private static HasModifiers hasModifiers(JavaModifier... modifiers) {
         return () -> ImmutableSet.copyOf(modifiers);
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasNameTest.java
Patch:
@@ -74,11 +74,11 @@ private AbstractBooleanAssert<?> assertNameMatches(String input, String regex) {
                 .as(input + " =~ " + regex);
     }
 
-    private HasName newHasName(final String name) {
+    private HasName newHasName(String name) {
         return newHasNameAndFullName(name, "full " + name);
     }
 
-    private HasName.AndFullName newHasNameAndFullName(final String name, final String fullName) {
+    private HasName.AndFullName newHasNameAndFullName(String name, String fullName) {
         return new HasName.AndFullName() {
             @Override
             public String getName() {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasOwnerTest.java
Patch:
@@ -25,7 +25,7 @@ public void function_get_owner() {
         assertThat(Get.<String>owner().apply(hasOwner)).isEqualTo("owner");
     }
 
-    private DescribedPredicate<String> startsWith(final String prefix) {
+    private DescribedPredicate<String> startsWith(String prefix) {
         return new DescribedPredicate<String>("starts with " + prefix) {
             @Override
             public boolean test(String input) {
@@ -34,7 +34,7 @@ public boolean test(String input) {
         };
     }
 
-    private <T> HasOwner<T> hasOwner(final T owner) {
+    private <T> HasOwner<T> hasOwner(T owner) {
         return () -> owner;
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasParameterTypesTest.java
Patch:
@@ -50,7 +50,7 @@ public void predicate_on_parameters_by_Predicate() {
                 .hasDescription("raw parameter types some text");
     }
 
-    private HasParameterTypes newHasParameterTypes(final Class<?>... parameters) {
+    private HasParameterTypes newHasParameterTypes(Class<?>... parameters) {
         return new HasParameterTypes() {
 
             @Override

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasReturnTypeTest.java
Patch:
@@ -70,11 +70,11 @@ abstract class TestClass implements Iterable<String> {
                 .as("result of GET_RAW_RETURN_TYPE").isEqualTo(expectedType);
     }
 
-    private HasReturnType newHasReturnType(final JavaClass rawReturnType) {
+    private HasReturnType newHasReturnType(JavaClass rawReturnType) {
         return newHasReturnType(rawReturnType, rawReturnType);
     }
 
-    private HasReturnType newHasReturnType(final JavaType genericReturnType, final JavaClass rawReturnType) {
+    private HasReturnType newHasReturnType(JavaType genericReturnType, JavaClass rawReturnType) {
         return new HasReturnType() {
 
             @Override

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasThrowsClauseTest.java
Patch:
@@ -74,7 +74,7 @@ public void predicate_on_parameters_by_Predicate() {
     }
 
     @SafeVarargs
-    private final HasThrowsClause<?> newHasThrowsClause(final Class<? extends Throwable>... throwsDeclarations) {
+    private final HasThrowsClause<?> newHasThrowsClause(Class<? extends Throwable>... throwsDeclarations) {
         return new HasThrowsClause() {
             @Override
             public ThrowsClause<?> getThrowsClause() {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasTypeTest.java
Patch:
@@ -50,7 +50,7 @@ public void function_getType() {
         assertThatType(GET_RAW_TYPE.apply(newHasType(String.class))).matches(String.class);
     }
 
-    private HasType newHasType(final Class<?> owner) {
+    private HasType newHasType(Class<?> owner) {
         return new HasType() {
 
             @Override

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterTest.java
Patch:
@@ -921,7 +921,7 @@ private void copyClassFile(Class<?> clazz, File targetFolder) throws IOException
         Files.copy(Paths.get(uriOf(clazz)), new File(targetFolder, clazz.getSimpleName() + ".class").toPath());
     }
 
-    private Condition<CodeUnitAccessTarget> targetWithFullName(final String name) {
+    private Condition<CodeUnitAccessTarget> targetWithFullName(String name) {
         return new Condition<CodeUnitAccessTarget>(String.format("target with name '%s'", name)) {
             @Override
             public boolean matches(CodeUnitAccessTarget value) {
@@ -930,7 +930,7 @@ public boolean matches(CodeUnitAccessTarget value) {
         };
     }
 
-    private static ImportOption importOnly(final Class<?>... classes) {
+    private static ImportOption importOnly(Class<?>... classes) {
         return location -> stream(classes).anyMatch(c -> location.contains(urlOf(c).getFile()));
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileSourceTest.java
Patch:
@@ -59,7 +59,7 @@ public static Object[][] expected_classes() {
 
     @Test
     @UseDataProvider("expected_classes")
-    public void classes_in_JAR_are_filtered(Set<String> givenEntries, ImportOptions importOptions, final Set<String> expectedIncluded) {
+    public void classes_in_JAR_are_filtered(Set<String> givenEntries, ImportOptions importOptions, Set<String> expectedIncluded) {
         TestJarFile testJarFile = new TestJarFile();
         for (String entry : givenEntries) {
             testJarFile.withEntry(entry);
@@ -74,7 +74,7 @@ public void classes_in_JAR_are_filtered(Set<String> givenEntries, ImportOptions
     @Test
     @UseDataProvider("expected_classes")
     public void classes_from_file_path_are_filtered(
-            Set<String> givenFiles, ImportOptions importOptions, final Set<String> expectedIncluded) throws IOException {
+            Set<String> givenFiles, ImportOptions importOptions, Set<String> expectedIncluded) throws IOException {
 
         File dir = tempDir.newFolder();
         for (String file : givenFiles) {
@@ -172,7 +172,7 @@ private void assertSourceMatches(ClassFileSource source, Set<String> expectedInc
                 .hasSameElementsAs(expectedIncluded);
     }
 
-    private static ImportOptions locationContains(final String part) {
+    private static ImportOptions locationContains(String part) {
         return new ImportOptions().with(location -> location.contains(part));
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/LocationTest.java
Patch:
@@ -160,7 +160,7 @@ private NormalizedResourceName oneLevelBelow(Class<ClassResolverFactoryTest> cla
         return NormalizedResourceName.from(parentFolder.relativize(absolutePath).toString());
     }
 
-    private Condition<Object> elementWithSubstring(final String substring) {
+    private Condition<Object> elementWithSubstring(String substring) {
         return new Condition<Object>(String.format("element with substring '%s'", substring)) {
             @Override
             public boolean matches(Object value) {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/UrlSourceTest.java
Patch:
@@ -167,15 +167,15 @@ private String subpath(String... parts) {
         return Joiner.on(File.separator).join(parts);
     }
 
-    private WrittenJarFile writeJarWithManifestClasspathAttribute(final File folder, String identifier, ManifestClasspathEntry... additionalClasspathManifestClasspathEntries) {
+    private WrittenJarFile writeJarWithManifestClasspathAttribute(File folder, String identifier, ManifestClasspathEntry... additionalClasspathManifestClasspathEntries) {
         Set<ManifestClasspathEntry> classpathManifestEntries = union(createManifestClasspathEntries(identifier), ImmutableSet.copyOf(additionalClasspathManifestClasspathEntries));
         String jarFileName = new TestJarFile()
                 .withManifestAttribute(CLASS_PATH, Joiner.on(" ").join(classpathManifestEntries.stream().map(resolveTo(folder)).collect(toSet())))
                 .createAndReturnName(new File(folder, identifier.replace(File.separator, "-") + ".jar"));
         return new WrittenJarFile(Paths.get(jarFileName), classpathManifestEntries);
     }
 
-    private Function<ManifestClasspathEntry, String> resolveTo(final File folder) {
+    private Function<ManifestClasspathEntry, String> resolveTo(File folder) {
         return manifestClasspathEntry -> manifestClasspathEntry.create(folder);
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/resolvers/ClassResolverFromClassPathTest.java
Patch:
@@ -73,12 +73,12 @@ public static Object[][] urls_with_spaces() throws MalformedURLException, URISyn
 
     @Test
     @UseDataProvider("urls_with_spaces")
-    public void is_resilient_against_wrongly_encoded_ClassLoader_resource_URLs(final URL urlReturnedByClassLoader, URI expectedUriDerivedFromUrl) {
+    public void is_resilient_against_wrongly_encoded_ClassLoader_resource_URLs(URL urlReturnedByClassLoader, URI expectedUriDerivedFromUrl) {
         // it seems like some OSGI ClassLoaders incorrectly return URLs with unencoded spaces.
         // This lead to `url.toURI()` throwing an exception -> https://github.com/TNG/ArchUnit/issues/683
         verifyUrlCannotBeConvertedToUriInTheCurrentForm(urlReturnedByClassLoader);
 
-        final JavaClass expectedJavaClass = importClassWithContext(Object.class);
+        JavaClass expectedJavaClass = importClassWithContext(Object.class);
         when(uriImporter.tryImport(expectedUriDerivedFromUrl)).thenReturn(Optional.of(expectedJavaClass));
 
         Optional<JavaClass> resolvedClass = withMockedContextClassLoader(classLoaderMock -> {
@@ -103,7 +103,7 @@ private <T> T withMockedContextClassLoader(Function<ClassLoader, T> doWithClassL
         }
     }
 
-    private void verifyUrlCannotBeConvertedToUriInTheCurrentForm(final URL url) {
+    private void verifyUrlCannotBeConvertedToUriInTheCurrentForm(URL url) {
         assertThatThrownBy(url::toURI).isInstanceOf(URISyntaxException.class);
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/resolvers/SelectedClassResolverFromClasspathTest.java
Patch:
@@ -58,7 +58,7 @@ private void assertResolved(Optional<JavaClass> resolved, Class<?> expected) {
                 .isTrue();
     }
 
-    private URI uriFor(final Class<?> clazz) {
+    private URI uriFor(Class<?> clazz) {
         return argThat(argument -> argument.toString().contains(clazz.getSimpleName()));
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/innerclassimport/ClassWithInnerClass.java
Patch:
@@ -3,7 +3,7 @@
 @SuppressWarnings("unused")
 public class ClassWithInnerClass {
     void callInsideOfAnonymous() {
-        final CalledClass calledClass = null;
+        CalledClass calledClass = null;
 
         new CanBeCalled() {
             @Override
@@ -14,7 +14,7 @@ public void call() {
     }
 
     void callInsideOfLocalClass() {
-        final CalledClass calledClass = null;
+        CalledClass calledClass = null;
 
         class LocalCaller {
             void call() {

File: archunit/src/test/java/com/tngtech/archunit/lang/ArchRuleTest.java
Patch:
@@ -200,7 +200,7 @@ private void removeFirstActualMessageContaining(String message, List<String> act
         };
     }
 
-    private ArchCondition<JavaClass> conditionThatReportsErrors(final String... messages) {
+    private ArchCondition<JavaClass> conditionThatReportsErrors(String... messages) {
         return new ArchCondition<JavaClass>("not have errors " + Joiner.on(", ").join(messages)) {
             @Override
             public void check(JavaClass item, ConditionEvents events) {
@@ -211,7 +211,7 @@ public void check(JavaClass item, ConditionEvents events) {
         };
     }
 
-    private static ArchCondition<JavaClass> addFixedNumberOfViolations(final int number) {
+    private static ArchCondition<JavaClass> addFixedNumberOfViolations(int number) {
         return new ArchCondition<JavaClass>("be violated exactly %d times", number) {
             @Override
             public void check(JavaClass item, ConditionEvents events) {

File: archunit/src/test/java/com/tngtech/archunit/lang/CompositeArchRuleTest.java
Patch:
@@ -130,7 +130,7 @@ private static ArchRule archRuleThatFails() {
         return createArchRuleWithSatisfied(false);
     }
 
-    private static ArchRule createArchRuleWithSatisfied(final boolean satisfied) {
+    private static ArchRule createArchRuleWithSatisfied(boolean satisfied) {
         return ArchRule.Factory.create(new AbstractClassesTransformer<JavaClass>("irrelevant") {
             @Override
             public Iterable<JavaClass> doTransform(JavaClasses collection) {

File: archunit/src/test/java/com/tngtech/archunit/lang/EvaluationResultTest.java
Patch:
@@ -75,7 +75,7 @@ public void allows_clients_to_handle_violations() {
                 new SimpleConditionEvent(ImmutableList.of("yet another message"), false, "not expected"),
                 new SimpleConditionEvent(ImmutableSet.of("second message"), false, "also expected"));
 
-        final Set<String> actual = new HashSet<>();
+        Set<String> actual = new HashSet<>();
         result.handleViolations((Collection<Set<String>> violatingObject, String message) ->
                 actual.add(getOnlyElement(getOnlyElement(violatingObject)) + ": " + message));
 
@@ -119,7 +119,7 @@ public void handleViolations_reports_only_violations_referring_to_the_correct_ty
                 SimpleConditionEvent.violated(new CorrectType("handle type"), "I'm violated and correct type"),
                 SimpleConditionEvent.violated(new CorrectSubtype("handle sub type"), "I'm violated and correct sub type"));
 
-        final Set<String> handledFailures = new HashSet<>();
+        Set<String> handledFailures = new HashSet<>();
         result.handleViolations((Collection<CorrectType> violatingObjects, String message) ->
                 handledFailures.add(Joiner.on(", ").join(violatingObjects) + ": " + message));
 
@@ -204,7 +204,7 @@ private ConditionEvents events(ConditionEvent... events) {
         return result;
     }
 
-    private HasDescription hasDescription(final String description) {
+    private HasDescription hasDescription(String description) {
         return () -> description;
     }
 

File: archunit/src/test/java/com/tngtech/archunit/lang/FailureDisplayFormatFactoryTest.java
Patch:
@@ -40,7 +40,7 @@ public String formatFailure(HasDescription rule, FailureMessages failureMessages
     }
 
     @SuppressWarnings("SameParameterValue")
-    private HasDescription hasDescription(final String description) {
+    private HasDescription hasDescription(String description) {
         return () -> description;
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/lang/SimpleConditionEventTest.java
Patch:
@@ -11,7 +11,7 @@
 public class SimpleConditionEventTest {
     @Test
     public void passes_corresponding_object_as_single_element_collection_with_message() {
-        final List<String> messages = new ArrayList<>();
+        List<String> messages = new ArrayList<>();
         ConditionEvent.Handler handler = (correspondingObjects, message) ->
                 messages.add(getOnlyElement(correspondingObjects) + ": " + message);
 

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/ClassAccessesFieldConditionTest.java
Patch:
@@ -110,7 +110,7 @@ Set<String> violationMessageParts() {
             return parts;
         }
 
-        SELF accessInfo(final AccessInfo accessInfo) {
+        SELF accessInfo(AccessInfo accessInfo) {
             this.accessInfo = accessInfo;
             return self();
         }

File: archunit/src/test/java/com/tngtech/archunit/lang/extension/ArchUnitExtensionLoaderTest.java
Patch:
@@ -114,8 +114,8 @@ private String expectedExtensionLoadedMessage(String identifier) {
         return "Loaded " + ArchUnitExtension.class.getSimpleName() + " with id '" + identifier + "'";
     }
 
-    private Condition<Throwable> containingWord(final String word) {
-        final Pattern wordPattern = Pattern.compile(" " + quote(word) + "[: ]");
+    private Condition<Throwable> containingWord(String word) {
+        Pattern wordPattern = Pattern.compile(" " + quote(word) + "[: ]");
         return new Condition<Throwable>(String.format("containing word '%s'", word)) {
             @Override
             public boolean matches(Throwable value) {

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/ClassesShouldTest.java
Patch:
@@ -1802,7 +1802,7 @@ static String singleLineFailureReportOf(EvaluationResult result) {
     }
 
     @SuppressWarnings("SameParameterValue")
-    private static DescribedPredicate<JavaAnnotation<?>> annotation(final Class<? extends Annotation> type) {
+    private static DescribedPredicate<JavaAnnotation<?>> annotation(Class<? extends Annotation> type) {
         return new DescribedPredicate<JavaAnnotation<?>>("@" + type.getSimpleName()) {
             @Override
             public boolean test(JavaAnnotation<?> input) {

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/CodeUnitsShouldTest.java
Patch:
@@ -624,7 +624,7 @@ public void restricted_constructors_calls_by_code_units_predicate(ArchRule rule)
                         quote(CONSTRUCTOR_ONE_ARG)));
     }
 
-    private static DescribedPredicate<JavaCodeUnit> doNotHaveParametersOfType(final Class<?> type) {
+    private static DescribedPredicate<JavaCodeUnit> doNotHaveParametersOfType(Class<?> type) {
         return new DescribedPredicate<JavaCodeUnit>("do not have parameters of type " + type.getSimpleName()) {
             @Override
             public boolean test(JavaCodeUnit codeUnit) {

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/GivenClassesThatTest.java
Patch:
@@ -932,7 +932,7 @@ static class Evaluator<T> {
         }
 
         public List<T> on(Class<?>... toCheck) {
-            final List<T> result = new ArrayList<>();
+            List<T> result = new ArrayList<>();
             JavaClasses classes = importClassesWithContext(toCheck);
             ArchCondition<T> condition = new ArchCondition<T>("ignored") {
                 @Override

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/GivenCodeUnitsTest.java
Patch:
@@ -278,7 +278,7 @@ public void throwable_type_predicates(DescribedRuleStart ruleStart, Collection<S
         assertThat(result.getFailureReport().getDetails()).hasSameElementsAs(expectedMembers);
     }
 
-    static DescribedPredicate<List<JavaClass>> oneParameterOfType(final Class<?> type) {
+    static DescribedPredicate<List<JavaClass>> oneParameterOfType(Class<?> type) {
         return new DescribedPredicate<List<JavaClass>>("one parameter of type " + type.getName()) {
             @Override
             public boolean test(List<JavaClass> input) {

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/GivenMembersTest.java
Patch:
@@ -448,7 +448,7 @@ public void check(JavaMember item, ConditionEvents events) {
         };
     }
 
-    static DescribedPredicate<JavaMember> areNoFieldsWithType(final Class<?> type) {
+    static DescribedPredicate<JavaMember> areNoFieldsWithType(Class<?> type) {
         return new DescribedPredicate<JavaMember>("are no fields with type " + type.getSimpleName()) {
             @Override
             public boolean test(JavaMember member) {
@@ -457,7 +457,7 @@ public boolean test(JavaMember member) {
         };
     }
 
-    static ArchCondition<JavaMember> beAnnotatedWith(final Class<? extends Annotation> annotationType) {
+    static ArchCondition<JavaMember> beAnnotatedWith(Class<? extends Annotation> annotationType) {
         return new ArchCondition<JavaMember>("be annotated with @%s", annotationType.getSimpleName()) {
             @Override
             public void check(JavaMember member, ConditionEvents events) {

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/GivenSlicesTest.java
Patch:
@@ -75,7 +75,7 @@ private GivenSlices testSlices() {
         return slices().matching(TEST_CLASSES_PACKAGE + ".(*)..");
     }
 
-    private DescribedPredicate<Slice> descriptionMatching(final String regex) {
+    private DescribedPredicate<Slice> descriptionMatching(String regex) {
         return new DescribedPredicate<Slice>("description matching '%s'", regex) {
             @Override
             public boolean test(Slice input) {
@@ -85,7 +85,7 @@ public boolean test(Slice input) {
     }
 
     private Set<Slice> getSlicesMatchedByFilter(GivenConjunction<Slice> givenSlices) {
-        final Set<Slice> matched = new HashSet<>();
+        Set<Slice> matched = new HashSet<>();
         givenSlices.should(new ArchCondition<Slice>("") {
             @Override
             public void check(Slice item, ConditionEvents events) {

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/SlicesShouldTest.java
Patch:
@@ -110,7 +110,7 @@ private ViolationsAssertion assertViolations(JavaClasses classes, SliceRule rule
         return new ViolationsAssertion(rule.evaluate(classes));
     }
 
-    private DescribedPredicate<JavaClass> classIn(final String packageRegex) {
+    private DescribedPredicate<JavaClass> classIn(String packageRegex) {
         return new DescribedPredicate<JavaClass>("class in " + packageRegex) {
             @Override
             public boolean test(JavaClass input) {

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/SlicesTest.java
Patch:
@@ -122,7 +122,7 @@ private Optional<Slice> tryGetSliceOf(Class<?> clazz, Slices slices) {
         return Optional.empty();
     }
 
-    private SliceAssignment assignmentOfJavaLangAndUtil(final String description) {
+    private SliceAssignment assignmentOfJavaLangAndUtil(String description) {
         return new SliceAssignment() {
             @Override
             public String getDescription() {

File: archunit/src/test/java/com/tngtech/archunit/library/freeze/FreezingArchRuleTest.java
Patch:
@@ -544,16 +544,16 @@ RuleCreator withoutViolations() {
             return new RuleCreator(description, new ArrayList<>(), textModifier);
         }
 
-        RuleCreator withViolations(final String... messages) {
+        RuleCreator withViolations(String... messages) {
             List<ViolatedEvent> newEvents = Arrays.stream(messages).map(ViolatedEvent::new).collect(toList());
             return new RuleCreator(description, newEvents, textModifier);
         }
 
-        RuleCreator withViolations(final ViolatedEvent... events) {
+        RuleCreator withViolations(ViolatedEvent... events) {
             return new RuleCreator(description, ImmutableList.copyOf(events), textModifier);
         }
 
-        RuleCreator withStringReplace(final String toReplace, final String replaceWith) {
+        RuleCreator withStringReplace(String toReplace, String replaceWith) {
             return new RuleCreator(description, events, input -> input.replace(toReplace, replaceWith));
         }
 

File: archunit/src/test/java/com/tngtech/archunit/library/metrics/ComponentDependencyMetricsTest.java
Patch:
@@ -129,7 +129,7 @@ public void normalized_distance_from_main_sequence_is_calculated_as_distance_fro
 
     @Test
     public void rejects_requesting_metrics_of_unknown_component() {
-        final ComponentDependencyMetrics metrics = ArchitectureMetrics.componentDependencyMetrics(MetricsComponents.of());
+        ComponentDependencyMetrics metrics = ArchitectureMetrics.componentDependencyMetrics(MetricsComponents.of());
 
         List<ThrowingCallable> callables = ImmutableList.of(
                 () -> metrics.getEfferentCoupling("unknown"),

File: archunit/src/test/java/com/tngtech/archunit/library/metrics/LakosMetricsTest.java
Patch:
@@ -198,17 +198,17 @@ private Builder(int ccd) {
                 this.ccd = ccd;
             }
 
-            Builder acd(final double acd) {
+            Builder acd(double acd) {
                 this.acd = acd;
                 return this;
             }
 
-            Builder racd(final double racd) {
+            Builder racd(double racd) {
                 this.racd = racd;
                 return this;
             }
 
-            ExpectedMetrics nccd(final double nccd) {
+            ExpectedMetrics nccd(double nccd) {
                 this.nccd = nccd;
                 return new ExpectedMetrics(this);
             }

File: archunit/src/test/java/com/tngtech/archunit/library/plantuml/rules/PlantUmlArchConditionTest.java
Patch:
@@ -259,7 +259,7 @@ private ListAssert<String> assertThatEvaluatedConditionWithConfiguration(
         return assertThat(result.getFailureReport().getDetails());
     }
 
-    private Condition<List<? extends String>> lineMatching(final String pattern) {
+    private Condition<List<? extends String>> lineMatching(String pattern) {
         return new Condition<List<? extends String>>(String.format("line matching '%s'", pattern)) {
             @Override
             public boolean matches(List<? extends String> lines) {

File: archunit/src/test/java/com/tngtech/archunit/library/plantuml/rules/PlantUmlParserTest.java
Patch:
@@ -167,7 +167,7 @@ public static Object[][] color_testcases() {
     @Test
     @UseDataProvider("color_testcases")
     public void parses_various_colored_components(String color) {
-        final File diagramFile = TestDiagram.in(temporaryFolder)
+        File diagramFile = TestDiagram.in(temporaryFolder)
                 .component("SomeComponent").withColor(color).withStereoTypes("..stereotype..")
                 .write();
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/ArchConfigurationRule.java
Patch:
@@ -13,12 +13,12 @@ public class ArchConfigurationRule extends ExternalResource {
     private boolean beforeHasBeenExecuted = false;
     private final List<Runnable> configurationInitializers = new ArrayList<>();
 
-    public ArchConfigurationRule resolveAdditionalDependenciesFromClassPath(final boolean enabled) {
+    public ArchConfigurationRule resolveAdditionalDependenciesFromClassPath(boolean enabled) {
         addConfigurationInitializer(() -> ArchConfiguration.get().setResolveMissingDependenciesFromClassPath(enabled));
         return this;
     }
 
-    public ArchConfigurationRule setFailOnEmptyShould(final boolean allowEmptyShould) {
+    public ArchConfigurationRule setFailOnEmptyShould(boolean allowEmptyShould) {
         addConfigurationInitializer(() -> ArchConfiguration.get().setProperty(FAIL_ON_EMPTY_SHOULD_PROPERTY_NAME, String.valueOf(allowEmptyShould)));
         return this;
     }

File: archunit/src/test/java/com/tngtech/archunit/testutil/Conditions.java
Patch:
@@ -10,7 +10,7 @@ public final class Conditions {
     private Conditions() {
     }
 
-    public static <T> Condition<Iterable<? extends T>> containing(final Condition<T> condition) {
+    public static <T> Condition<Iterable<? extends T>> containing(Condition<T> condition) {
         return new Condition<Iterable<? extends T>>() {
             @Override
             public boolean matches(Iterable<? extends T> value) {
@@ -23,7 +23,7 @@ public boolean matches(Iterable<? extends T> value) {
         }.as("containing an element that " + condition.description());
     }
 
-    public static Condition<JavaCodeUnit> codeUnitWithSignature(final String name, final Class<?>... parameters) {
+    public static Condition<JavaCodeUnit> codeUnitWithSignature(String name, Class<?>... parameters) {
         return new Condition<JavaCodeUnit>() {
             @Override
             public boolean matches(JavaCodeUnit value) {

File: archunit/src/test/java/com/tngtech/archunit/testutil/TestLogRecorder.java
Patch:
@@ -32,7 +32,7 @@ public void append(LogEvent event) {
             }
         };
         appender.start();
-        final LoggerContext ctx = getLoggerContext();
+        LoggerContext ctx = getLoggerContext();
         LoggerConfig loggerConfig = ctx.getConfiguration().getLoggerConfig(loggerClass.getName());
         oldLevel = loggerConfig.getLevel();
         loggerConfig.setLevel(level);
@@ -49,7 +49,7 @@ public void reset() {
             return;
         }
 
-        final LoggerContext ctx = getLoggerContext();
+        LoggerContext ctx = getLoggerContext();
         LoggerConfig loggerConfig = ctx.getConfiguration().getLoggerConfig(loggerClass.getName());
         loggerConfig.setLevel(oldLevel);
         loggerConfig.removeAppender(APPENDER_NAME);

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/AccessToFieldAssertion.java
Patch:
@@ -18,7 +18,7 @@ protected AccessToFieldAssertion newAssertion(JavaFieldAccess access) {
         return new AccessToFieldAssertion(access);
     }
 
-    public AccessToFieldAssertion isTo(final String name) {
+    public AccessToFieldAssertion isTo(String name) {
         return isTo(new Condition<FieldAccessTarget>("field with name '" + name + "'") {
             @Override
             public boolean matches(FieldAccessTarget fieldAccessTarget) {
@@ -27,7 +27,7 @@ public boolean matches(FieldAccessTarget fieldAccessTarget) {
         });
     }
 
-    public AccessToFieldAssertion isTo(final Class<?> owner, final String name) {
+    public AccessToFieldAssertion isTo(Class<?> owner, String name) {
         return isTo(new Condition<FieldAccessTarget>("field " + owner.getName() + "." + name) {
             @Override
             public boolean matches(FieldAccessTarget fieldAccessTarget) {

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/DependenciesAssertion.java
Patch:
@@ -68,13 +68,13 @@ public DependenciesAssertion doesNotContain(Class<?> expectedOrigin, Class<?> ex
         return this;
     }
 
-    public DependenciesAssertion contain(final ExpectedDependencies expectedDependencies) {
+    public DependenciesAssertion contain(ExpectedDependencies expectedDependencies) {
         matchExpectedDependencies(expectedDependencies)
                 .assertNoMissingDependencies();
         return this;
     }
 
-    public DependenciesAssertion containOnly(final ExpectedDependencies expectedDependencies) {
+    public DependenciesAssertion containOnly(ExpectedDependencies expectedDependencies) {
         ExpectedDependenciesMatchResult result = matchExpectedDependencies(expectedDependencies);
         result.assertNoMissingDependencies();
         result.assertAllDependenciesMatched();
@@ -84,7 +84,7 @@ public DependenciesAssertion containOnly(final ExpectedDependencies expectedDepe
     private ExpectedDependenciesMatchResult matchExpectedDependencies(ExpectedDependencies expectedDependencies) {
         List<Dependency> rest = newArrayList(actual);
         List<ExpectedDependency> missingDependencies = new ArrayList<>();
-        for (final ExpectedDependency expectedDependency : expectedDependencies) {
+        for (ExpectedDependency expectedDependency : expectedDependencies) {
             if (rest.stream().noneMatch(expectedDependency::matches)) {
                 missingDependencies.add(expectedDependency);
             }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/ExpectedAccessCreation.java
Patch:
@@ -31,15 +31,15 @@ private Step2(Class<?> originClass, String originCodeUnitName) {
             this.originCodeUnitName = originCodeUnitName;
         }
 
-        public ExpectedAccessCondition to(final Class<?> targetClass, final String targetName) {
+        public ExpectedAccessCondition to(Class<?> targetClass, String targetName) {
             return new ExpectedAccessCondition(originClass, originCodeUnitName, targetClass, targetName);
         }
 
-        public ExpectedFieldAccessCondition toField(AccessType accessType, final Class<?> targetClass, final String targetName) {
+        public ExpectedFieldAccessCondition toField(AccessType accessType, Class<?> targetClass, String targetName) {
             return new ExpectedFieldAccessCondition(originClass, originCodeUnitName, accessType, targetClass, targetName);
         }
 
-        public ExpectedConstructorCallCondition toConstructor(final Class<?> targetClass, final Class<?>... paramTypes) {
+        public ExpectedConstructorCallCondition toConstructor(Class<?> targetClass, Class<?>... paramTypes) {
             return new ExpectedConstructorCallCondition(originClass, originCodeUnitName, targetClass, formatNamesOf(paramTypes));
         }
     }

File: archunit/src/test/java/com/tngtech/archunit/testutil/syntax/MethodChoiceStrategy.java
Patch:
@@ -37,7 +37,7 @@ public MethodChoiceStrategy exceptMethodsWithName(String string) {
         return new MethodChoiceStrategy(ignorePredicate.or(methodWithName(string)));
     }
 
-    private Predicate<Method> methodWithName(final String methodName) {
+    private Predicate<Method> methodWithName(String methodName) {
         return input -> input.getName().equals(methodName);
     }
 
@@ -137,7 +137,7 @@ public boolean equals(Object obj) {
             if (obj == null || getClass() != obj.getClass()) {
                 return false;
             }
-            final MethodKey other = (MethodKey) obj;
+            MethodKey other = (MethodKey) obj;
             return Objects.equals(this.name, other.name)
                     && Objects.equals(this.parameterTypes, other.parameterTypes);
         }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/DomainObjectCreationContext.java
Patch:
@@ -180,8 +180,8 @@ public static <CODE_UNIT extends JavaCodeUnit> ThrowsClause<CODE_UNIT> createThr
         return ThrowsClause.from(codeUnit, types);
     }
 
-    public static InstanceofCheck createInstanceofCheck(JavaCodeUnit codeUnit, JavaClass target, int lineNumber) {
-        return InstanceofCheck.from(codeUnit, target, lineNumber);
+    public static InstanceofCheck createInstanceofCheck(JavaCodeUnit codeUnit, JavaClass type, int lineNumber, boolean declaredInLambda) {
+        return InstanceofCheck.from(codeUnit, type, lineNumber, declaredInLambda);
     }
 
     public static <OWNER extends HasDescription> JavaTypeVariable<OWNER> createTypeVariable(String name, OWNER owner, JavaClass erasure) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -65,5 +65,7 @@ public interface ImportContext {
 
     Set<ReferencedClassObject> createReferencedClassObjectsFor(JavaCodeUnit codeUnit);
 
+    Set<InstanceofCheck> createInstanceofChecksFor(JavaCodeUnit codeUnit);
+
     JavaClass resolveClass(String fullyQualifiedClassName);
 }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaCodeUnit.java
Patch:
@@ -63,7 +63,6 @@ public abstract class JavaCodeUnit
     private final Parameters parameters;
     private final String fullName;
     private final List<JavaTypeVariable<JavaCodeUnit>> typeParameters;
-    private final Set<InstanceofCheck> instanceofChecks;
 
     private Set<JavaFieldAccess> fieldAccesses = Collections.emptySet();
     private Set<JavaMethodCall> methodCalls = Collections.emptySet();
@@ -72,14 +71,14 @@ public abstract class JavaCodeUnit
     private Set<JavaConstructorReference> constructorReferences = Collections.emptySet();
     private Set<TryCatchBlock> tryCatchBlocks = Collections.emptySet();
     private Set<ReferencedClassObject> referencedClassObjects;
+    private Set<InstanceofCheck> instanceofChecks;
 
     JavaCodeUnit(JavaCodeUnitBuilder<?, ?> builder) {
         super(builder);
         typeParameters = builder.getTypeParameters(this);
         returnType = new ReturnType(this, builder);
         parameters = new Parameters(this, builder);
         fullName = formatMethod(getOwner().getName(), getName(), namesOf(getRawParameterTypes()));
-        instanceofChecks = ImmutableSet.copyOf(builder.getInstanceofChecks(this));
     }
 
     /**
@@ -281,6 +280,7 @@ void completeFrom(ImportContext context) {
                 .map(builder -> builder.build(this, context))
                 .collect(toImmutableSet());
         referencedClassObjects = context.createReferencedClassObjectsFor(this);
+        instanceofChecks = context.createInstanceofChecksFor(this);
     }
 
     @ResolvesTypesViaReflection

File: archunit/src/main/java/com/tngtech/archunit/core/domain/DomainObjectCreationContext.java
Patch:
@@ -172,8 +172,8 @@ public static Source createSource(URI uri, Optional<String> sourceFileName, bool
         return new Source(uri, sourceFileName, md5InClassSourcesEnabled);
     }
 
-    public static ReferencedClassObject createReferencedClassObject(JavaCodeUnit codeUnit, JavaClass javaClass, int lineNumber) {
-        return ReferencedClassObject.from(codeUnit, javaClass, lineNumber);
+    public static ReferencedClassObject createReferencedClassObject(JavaCodeUnit codeUnit, JavaClass javaClass, int lineNumber, boolean declaredInLambda) {
+        return ReferencedClassObject.from(codeUnit, javaClass, lineNumber, declaredInLambda);
     }
 
     public static <CODE_UNIT extends JavaCodeUnit> ThrowsClause<CODE_UNIT> createThrowsClause(CODE_UNIT codeUnit, List<JavaClass> types) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -63,5 +63,7 @@ public interface ImportContext {
 
     Set<TryCatchBlockBuilder> createTryCatchBlockBuilders(JavaCodeUnit codeUnit);
 
+    Set<ReferencedClassObject> createReferencedClassObjectsFor(JavaCodeUnit codeUnit);
+
     JavaClass resolveClass(String fullyQualifiedClassName);
 }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -1480,7 +1480,7 @@ void completeAnnotations(ImportContext context) {
 
     JavaClassDependencies completeFrom(ImportContext context) {
         completeComponentType(context);
-        members.completeAccessesFrom(context);
+        members.completeFrom(context);
         javaClassDependencies = new JavaClassDependencies(this);
         return javaClassDependencies;
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassMembers.java
Patch:
@@ -318,9 +318,9 @@ void completeAnnotations(ImportContext context) {
         }
     }
 
-    void completeAccessesFrom(ImportContext context) {
+    void completeFrom(ImportContext context) {
         for (JavaCodeUnit codeUnit : codeUnits) {
-            codeUnit.completeAccessesFrom(context);
+            codeUnit.completeFrom(context);
         }
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaCodeUnit.java
Patch:
@@ -63,7 +63,6 @@ public abstract class JavaCodeUnit
     private final Parameters parameters;
     private final String fullName;
     private final List<JavaTypeVariable<JavaCodeUnit>> typeParameters;
-    private final Set<ReferencedClassObject> referencedClassObjects;
     private final Set<InstanceofCheck> instanceofChecks;
 
     private Set<JavaFieldAccess> fieldAccesses = Collections.emptySet();
@@ -72,14 +71,14 @@ public abstract class JavaCodeUnit
     private Set<JavaMethodReference> methodReferences = Collections.emptySet();
     private Set<JavaConstructorReference> constructorReferences = Collections.emptySet();
     private Set<TryCatchBlock> tryCatchBlocks = Collections.emptySet();
+    private Set<ReferencedClassObject> referencedClassObjects;
 
     JavaCodeUnit(JavaCodeUnitBuilder<?, ?> builder) {
         super(builder);
         typeParameters = builder.getTypeParameters(this);
         returnType = new ReturnType(this, builder);
         parameters = new Parameters(this, builder);
         fullName = formatMethod(getOwner().getName(), getName(), namesOf(getRawParameterTypes()));
-        referencedClassObjects = ImmutableSet.copyOf(builder.getReferencedClassObjects(this));
         instanceofChecks = ImmutableSet.copyOf(builder.getInstanceofChecks(this));
     }
 
@@ -271,7 +270,7 @@ public List<Set<JavaAnnotation<JavaParameter>>> getParameterAnnotations() {
         return parameters.getAnnotations();
     }
 
-    void completeAccessesFrom(ImportContext context) {
+    void completeFrom(ImportContext context) {
         Set<TryCatchBlockBuilder> tryCatchBlockBuilders = context.createTryCatchBlockBuilders(this);
         fieldAccesses = context.createFieldAccessesFor(this, tryCatchBlockBuilders);
         methodCalls = context.createMethodCallsFor(this, tryCatchBlockBuilders);
@@ -281,6 +280,7 @@ void completeAccessesFrom(ImportContext context) {
         tryCatchBlocks = tryCatchBlockBuilders.stream()
                 .map(builder -> builder.build(this, context))
                 .collect(toImmutableSet());
+        referencedClassObjects = context.createReferencedClassObjectsFor(this);
     }
 
     @ResolvesTypesViaReflection

File: archunit/src/test/java/com/tngtech/archunit/core/domain/TestUtils.java
Patch:
@@ -166,7 +166,7 @@ private JavaMethodCall to(MethodCallTarget methodCallTarget) {
             ImportContext context = mock(ImportContext.class);
             Set<JavaMethodCall> calls = targets.stream().map(target -> newMethodCall(method, target, lineNumber)).collect(toSet());
             when(context.createMethodCallsFor(eq(method), anySet())).thenReturn(ImmutableSet.copyOf(calls));
-            method.completeAccessesFrom(context);
+            method.completeFrom(context);
             return getCallToTarget(methodCallTarget);
         }
 
@@ -190,7 +190,7 @@ public void to(JavaField target, AccessType accessType) {
                     .thenReturn(ImmutableSet.of(
                             newFieldAccess(method, target, lineNumber, accessType)
                     ));
-            method.completeAccessesFrom(context);
+            method.completeFrom(context);
         }
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileProcessor.java
Patch:
@@ -301,7 +301,7 @@ public void onTryCatchBlocksFinished(Set<TryCatchBlockBuilder> tryCatchBlocks) {
 
         private <BUILDER extends RawAccessRecord.BaseBuilder<?, BUILDER>> BUILDER filled(BUILDER builder, TargetInfo target) {
             return builder
-                    .withCaller(codeUnit)
+                    .withOrigin(codeUnit)
                     .withTarget(target)
                     .withLineNumber(lineNumber);
         }

File: archunit/src/main/java/com/tngtech/archunit/library/Architectures.java
Patch:
@@ -90,6 +90,7 @@ private Architectures() {
      * <br><br>
      * A layered architecture can for example be defined like this:
      * <pre><code>layeredArchitecture()
+     * .consideringAllDependencies()
      * .layer("UI").definedBy("my.application.ui..")
      * .layer("Business Logic").definedBy("my.application.domain..")
      * .layer("Persistence").definedBy("my.application.persistence..")

File: archunit/src/main/java/com/tngtech/archunit/library/Architectures.java
Patch:
@@ -90,6 +90,7 @@ private Architectures() {
      * <br><br>
      * A layered architecture can for example be defined like this:
      * <pre><code>layeredArchitecture()
+     * .consideringAllDependencies()
      * .layer("UI").definedBy("my.application.ui..")
      * .layer("Business Logic").definedBy("my.application.domain..")
      * .layer("Persistence").definedBy("my.application.persistence..")

File: archunit/src/main/java/com/tngtech/archunit/library/metrics/MetricsComponents.java
Patch:
@@ -121,7 +121,7 @@ public static <T> MetricsComponents<T> from(Collection<T> elements, Function<? s
     public static MetricsComponents<JavaClass> fromPackages(Collection<JavaPackage> packages) {
         ImmutableSet.Builder<MetricsComponent<JavaClass>> components = ImmutableSet.builder();
         for (JavaPackage javaPackage : packages) {
-            components.add(MetricsComponent.of(javaPackage.getName(), javaPackage.getAllClasses()));
+            components.add(MetricsComponent.of(javaPackage.getName(), javaPackage.getClassesInPackageTree()));
         }
         return MetricsComponents.of(components.build());
     }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassesTest.java
Patch:
@@ -40,14 +40,14 @@ public void restriction_on_classes_should_keep_the_original_package_tree() {
     public void creation_of_JavaClasses_from_existing_classes_should_keep_the_original_package_tree() {
         JavaClasses classes = JavaClasses.of(singletonList(ALL_CLASSES.get(SomeClass.class)));
 
-        assertThat(classes.getDefaultPackage().getAllClasses()).hasSameElementsAs(ALL_CLASSES.getDefaultPackage().getAllClasses());
+        assertThat(classes.getDefaultPackage().getClassesInPackageTree()).hasSameElementsAs(ALL_CLASSES.getDefaultPackage().getClassesInPackageTree());
     }
 
     @Test
     public void creation_of_JavaClasses_from_empty_classes_should_create_empty_default_package() {
         JavaClasses classes = JavaClasses.of(emptySet());
 
-        assertThat(classes.getDefaultPackage().getAllClasses()).isEmpty();
+        assertThat(classes.getDefaultPackage().getClassesInPackageTree()).isEmpty();
     }
 
     @Test

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaPackageTest.java
Patch:
@@ -221,7 +221,7 @@ public void iterates_all_classes() {
 
         JavaPackage javaLang = defaultPackage.getPackage("java.lang");
 
-        assertThatTypes(javaLang.getAllClasses()).contain(Object.class, String.class, Annotation.class, Field.class);
+        assertThatTypes(javaLang.getClassesInPackageTree()).contain(Object.class, String.class, Annotation.class, Field.class);
     }
 
     @Test

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterSlowTest.java
Patch:
@@ -171,7 +171,7 @@ public void creates_JavaPackages() {
 
         JavaPackage javaPackage = defaultPackage.getPackage("java.lang");
         assertThatTypes(javaPackage.getClasses()).contain(Object.class, String.class, Integer.class);
-        assertThatTypes(javaPackage.getAllClasses()).contain(Object.class, Annotation.class, Field.class);
+        assertThatTypes(javaPackage.getClassesInPackageTree()).contain(Object.class, Annotation.class, Field.class);
 
         assertThat(javaClasses.containPackage("java.util"))
                 .as("Classes contain package 'java.util'").isTrue();

File: archunit/src/main/java/com/tngtech/archunit/library/metrics/MetricsComponents.java
Patch:
@@ -121,7 +121,7 @@ public static <T> MetricsComponents<T> from(Collection<T> elements, Function<? s
     public static MetricsComponents<JavaClass> fromPackages(Collection<JavaPackage> packages) {
         ImmutableSet.Builder<MetricsComponent<JavaClass>> components = ImmutableSet.builder();
         for (JavaPackage javaPackage : packages) {
-            components.add(MetricsComponent.of(javaPackage.getName(), javaPackage.getAllClasses()));
+            components.add(MetricsComponent.of(javaPackage.getName(), javaPackage.getClassesInPackageTree()));
         }
         return MetricsComponents.of(components.build());
     }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassesTest.java
Patch:
@@ -40,14 +40,14 @@ public void restriction_on_classes_should_keep_the_original_package_tree() {
     public void creation_of_JavaClasses_from_existing_classes_should_keep_the_original_package_tree() {
         JavaClasses classes = JavaClasses.of(singletonList(ALL_CLASSES.get(SomeClass.class)));
 
-        assertThat(classes.getDefaultPackage().getAllClasses()).hasSameElementsAs(ALL_CLASSES.getDefaultPackage().getAllClasses());
+        assertThat(classes.getDefaultPackage().getClassesInPackageTree()).hasSameElementsAs(ALL_CLASSES.getDefaultPackage().getClassesInPackageTree());
     }
 
     @Test
     public void creation_of_JavaClasses_from_empty_classes_should_create_empty_default_package() {
         JavaClasses classes = JavaClasses.of(emptySet());
 
-        assertThat(classes.getDefaultPackage().getAllClasses()).isEmpty();
+        assertThat(classes.getDefaultPackage().getClassesInPackageTree()).isEmpty();
     }
 
     @Test

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaPackageTest.java
Patch:
@@ -221,7 +221,7 @@ public void iterates_all_classes() {
 
         JavaPackage javaLang = defaultPackage.getPackage("java.lang");
 
-        assertThatTypes(javaLang.getAllClasses()).contain(Object.class, String.class, Annotation.class, Field.class);
+        assertThatTypes(javaLang.getClassesInPackageTree()).contain(Object.class, String.class, Annotation.class, Field.class);
     }
 
     @Test

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterSlowTest.java
Patch:
@@ -171,7 +171,7 @@ public void creates_JavaPackages() {
 
         JavaPackage javaPackage = defaultPackage.getPackage("java.lang");
         assertThatTypes(javaPackage.getClasses()).contain(Object.class, String.class, Integer.class);
-        assertThatTypes(javaPackage.getAllClasses()).contain(Object.class, Annotation.class, Field.class);
+        assertThatTypes(javaPackage.getClassesInPackageTree()).contain(Object.class, Annotation.class, Field.class);
 
         assertThat(javaClasses.containPackage("java.util"))
                 .as("Classes contain package 'java.util'").isTrue();

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/internal/ArchUnitTestEngine.java
Patch:
@@ -71,6 +71,7 @@
 public final class ArchUnitTestEngine extends HierarchicalTestEngine<ArchUnitEngineExecutionContext> {
     static final String UNIQUE_ID = "archunit";
 
+    @SuppressWarnings("FieldMayBeFinal")
     private SharedCache cache = new SharedCache(); // NOTE: We want to change this in tests -> no static/final reference
 
     @Override

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/internal/ClassCache.java
Patch:
@@ -67,6 +67,7 @@ public LazyJavaClasses load(LocationsKey key) {
                 }
             });
 
+    @SuppressWarnings("FieldMayBeFinal") // We want to change this in tests
     private CacheClassFileImporter cacheClassFileImporter = new CacheClassFileImporter();
 
     JavaClasses getClassesToAnalyzeFor(Class<?> testClass, ClassAnalysisRequest classAnalysisRequest) {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/DomainBuilders.java
Patch:
@@ -670,7 +670,7 @@ String getFinishedName(String name) {
                 };
             }
 
-            static JavaTypeFinisher IDENTITY = new JavaTypeFinisher() {
+            static final JavaTypeFinisher IDENTITY = new JavaTypeFinisher() {
                 @Override
                 JavaType finish(JavaType input, ImportedClasses classes) {
                     return input;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/RawAccessRecord.java
Patch:
@@ -29,7 +29,7 @@ class RawAccessRecord {
     final CodeUnit caller;
     final TargetInfo target;
     final int lineNumber;
-    public boolean declaredInLambda;
+    final boolean declaredInLambda;
 
     RawAccessRecord(CodeUnit caller, TargetInfo target, int lineNumber, boolean declaredInLambda) {
         this.caller = checkNotNull(caller);

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenObjectsInternal.java
Patch:
@@ -22,9 +22,8 @@
 import com.tngtech.archunit.lang.ArchRule;
 import com.tngtech.archunit.lang.ClassesTransformer;
 import com.tngtech.archunit.lang.Priority;
-import com.tngtech.archunit.lang.syntax.elements.GivenObjects;
 
-class GivenObjectsInternal<T> extends AbstractGivenObjects<T, GivenObjectsInternal<T>> implements GivenObjects<T> {
+class GivenObjectsInternal<T> extends AbstractGivenObjects<T, GivenObjectsInternal<T>> {
 
     GivenObjectsInternal(Priority priority, ClassesTransformer<T> classesTransformer) {
         this(priority, classesTransformer, Function.identity());

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/JohnsonCycleFinder.java
Patch:
@@ -115,7 +115,7 @@ private boolean findCycles(Result result, int originNodeIndex, JohnsonComponent
 
     static class Result implements Iterable<int[]> {
         private final CycleConfiguration configuration = new CycleConfiguration();
-        private List<int[]> cycles = new ArrayList<>();
+        private final List<int[]> cycles = new ArrayList<>();
         private boolean maxNumberOfCyclesReached = false;
 
         private Result() {

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/ViolationStoreFactory.java
Patch:
@@ -19,6 +19,7 @@
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.nio.file.Files;
 import java.util.List;
 import java.util.Properties;
 import java.util.UUID;
@@ -27,7 +28,6 @@
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Joiner;
 import com.google.common.base.Splitter;
-import com.google.common.io.Files;
 import com.tngtech.archunit.ArchConfiguration;
 import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.lang.ArchRule;
@@ -133,7 +133,7 @@ public void save(ArchRule rule, List<String> violations) {
         private void write(List<String> violations, File ruleDetails) {
             String updatedViolations = Joiner.on("\n").join(escape(violations));
             try {
-                Files.write(updatedViolations, ruleDetails, UTF_8);
+                Files.write(ruleDetails.toPath(), updatedViolations.getBytes(UTF_8));
             } catch (IOException e) {
                 throw new StoreUpdateFailedException(e);
             }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaCodeUnitTest.java
Patch:
@@ -32,7 +32,7 @@ public void offers_all_calls_from_Self() {
 
         assertThat(method.getCallsFromSelf())
                 .hasSize(4)
-                .containsOnlyElementsOf(union(method.getConstructorCallsFromSelf(), method.getMethodCallsFromSelf()));
+                .hasSameElementsAs(union(method.getConstructorCallsFromSelf(), method.getMethodCallsFromSelf()));
     }
 
     @Test
@@ -41,7 +41,7 @@ public void offers_all_accesses_from_Self() {
 
         assertThat(method.getAccessesFromSelf())
                 .hasSize(6)
-                .containsOnlyElementsOf(ImmutableList.<JavaAccess<?>>builder()
+                .hasSameElementsAs(ImmutableList.<JavaAccess<?>>builder()
                         .addAll(method.getConstructorCallsFromSelf())
                         .addAll(method.getMethodCallsFromSelf())
                         .addAll(method.getFieldAccesses())

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterAnnotationsTest.java
Patch:
@@ -580,7 +580,7 @@ void notToFind() {
                 classes.get(Dependent.class).getConstructor(getClass()).getAnnotationOfType(ParameterAnnotation.class.getName()),
                 classes.get(Dependent.class).getMethod("method").getAnnotationOfType(ParameterAnnotation.class.getName())
         );
-        assertThat(annotations).as("annotations with parameter type " + String.class.getSimpleName()).containsOnlyElementsOf(expected);
+        assertThat(annotations).as("annotations with parameter type " + String.class.getSimpleName()).hasSameElementsAs(expected);
     }
 
     @SuppressWarnings({"unchecked", "unused"})

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterGenericSuperclassTest.java
Patch:
@@ -302,7 +302,6 @@ class Child extends BaseClass<OUTER> {
             ArchConfiguration.get().setResolveMissingDependenciesFromClassPath(false);
             return importClassWithOnlyGenericTypeResolution(OuterWithTypeParameter.SomeInner.Child.class).getSuperclass().get();
         });
-        ;
 
         assertThatType(genericSuperclass).as("generic superclass").hasActualTypeArguments(
                 typeVariable("OUTER").withoutUpperBounds()

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileSourceTest.java
Patch:
@@ -169,7 +169,7 @@ private void assertSourceMatches(ClassFileSource source, Set<String> expectedInc
                 .extracting("uri")
                 .extractingResultOf("toString")
                 .usingElementComparator(MATCH_IF_EXPECTED_IS_SUBSTRING)
-                .containsOnlyElementsOf(expectedIncluded);
+                .hasSameElementsAs(expectedIncluded);
     }
 
     private static ImportOptions locationContains(final String part) {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportOptionsTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import java.io.File;
 import java.io.IOException;
-import java.net.URISyntaxException;
 import java.nio.file.Files;
 import java.util.ArrayList;
 import java.util.List;
@@ -169,7 +168,7 @@ public static Object[][] do_not_include_package_info_classes() {
 
     @Test
     @UseDataProvider("do_not_include_package_info_classes")
-    public void detect_package_info_class(ImportOption doNotIncludePackageInfoClasses) throws URISyntaxException {
+    public void detect_package_info_class(ImportOption doNotIncludePackageInfoClasses) {
         Location packageInfoLocation = Location.of(relativeResourceUri(getClass(), "testexamples/package-info.class"));
         assertThat(doNotIncludePackageInfoClasses.includes(packageInfoLocation))
                 .as("doNotIncludePackageInfoClasses includes package-info.class")

File: archunit/src/test/java/com/tngtech/archunit/core/importer/LocationTest.java
Patch:
@@ -69,7 +69,7 @@ public void iterate_entries_of_whole_jar() {
 
         assertThat(location.streamEntries())
                 .as("entries of JAR")
-                .containsOnlyElementsOf(Sets.difference(entries, singleton(packageEntry(DescribedPredicate.class))));
+                .hasSameElementsAs(Sets.difference(entries, singleton(packageEntry(DescribedPredicate.class))));
     }
 
     @Test
@@ -86,7 +86,7 @@ public void iterate_entries_of_package_of_jar_url() {
 
         assertThat(location.streamEntries())
                 .as("entries of JAR")
-                .containsOnlyElementsOf(Sets.difference(entries, singleton(packageEntry(DescribedPredicate.class))));
+                .hasSameElementsAs(Sets.difference(entries, singleton(packageEntry(DescribedPredicate.class))));
 
         location = Location.of(jarUriOfEntry(jarFile, packageEntry(getClass())));
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/TestClassFile.java
Patch:
@@ -2,8 +2,7 @@
 
 import java.io.File;
 import java.io.IOException;
-
-import com.google.common.io.Files;
+import java.nio.file.Files;
 
 import static com.google.common.base.Preconditions.checkState;
 import static com.tngtech.archunit.testutil.TestUtils.newTemporaryFolder;
@@ -26,7 +25,7 @@ public TestClassFile create() {
 
             checkState(sourceFile.getParentFile().exists() || sourceFile.getParentFile().mkdirs(),
                     "Can't create directory %s", sourceFile.getParentFile().getAbsolutePath());
-            Files.write(sourceCode, sourceFile, UTF_8);
+            Files.write(sourceFile.toPath(), sourceCode.getBytes(UTF_8));
 
             int result = getSystemJavaCompiler().run(null, null, null, sourceFile.getAbsolutePath());
             checkState(result == 0, "Compiler exit code should be 0, but it was " + result);

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/TransformersTest.java
Patch:
@@ -30,7 +30,7 @@ public void test_classes() {
 
         DescribedIterable<JavaClass> output = Transformers.classes().transform(input);
 
-        assertThat(output).containsOnlyElementsOf(input);
+        assertThat(output).hasSameElementsAs(input);
     }
 
     @DataProvider

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/CodeUnitsShouldTest.java
Patch:
@@ -176,7 +176,7 @@ public void parameter_types_predicates(ArchRule rule, Collection<String> expecte
         EvaluationResult result = rule.evaluate(importClasses(ClassWithVariousMembers.class));
 
         Set<String> actualMembers = parseMembers(ClassWithVariousMembers.class, result.getFailureReport().getDetails());
-        assertThat(actualMembers).containsOnlyElementsOf(expectedMembers);
+        assertThat(actualMembers).hasSameElementsAs(expectedMembers);
     }
 
     @DataProvider
@@ -229,7 +229,7 @@ public void return_type_predicates(ArchRule rule, Collection<String> expectedMem
         EvaluationResult result = rule.evaluate(importClasses(ClassWithVariousMembers.class));
 
         Set<String> actualMembers = parseMembers(ClassWithVariousMembers.class, result.getFailureReport().getDetails());
-        assertThat(actualMembers).containsOnlyElementsOf(expectedMembers);
+        assertThat(actualMembers).hasSameElementsAs(expectedMembers);
     }
 
     @DataProvider
@@ -282,7 +282,7 @@ public void throwable_type_predicates(ArchRule rule, Collection<String> expected
         EvaluationResult result = rule.evaluate(importClasses(ClassWithVariousMembers.class));
 
         Set<String> actualMembers = parseMembers(ClassWithVariousMembers.class, result.getFailureReport().getDetails());
-        assertThat(actualMembers).containsOnlyElementsOf(expectedMembers);
+        assertThat(actualMembers).hasSameElementsAs(expectedMembers);
     }
 
     @DataProvider

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/FieldsShouldTest.java
Patch:
@@ -68,7 +68,7 @@ public void property_predicates(ArchRule rule, Collection<String> expectedViolat
                 .evaluate(importClasses(ClassWithVariousMembers.class));
 
         Set<String> actualFields = parseMembers(ClassWithVariousMembers.class, result.getFailureReport().getDetails());
-        assertThat(actualFields).containsOnlyElementsOf(expectedViolatingFields);
+        assertThat(actualFields).hasSameElementsAs(expectedViolatingFields);
     }
 
     private static final String FIELD_A = "fieldA";

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/GivenCodeUnitsTest.java
Patch:
@@ -176,7 +176,7 @@ public void parameter_types_predicates(DescribedRuleStart ruleStart, Collection<
         EvaluationResult result = ruleStart.should(everythingViolationPrintMemberName())
                 .evaluate(importClasses(ClassWithVariousMembers.class));
 
-        assertThat(result.getFailureReport().getDetails()).containsOnlyElementsOf(expectedMembers);
+        assertThat(result.getFailureReport().getDetails()).hasSameElementsAs(expectedMembers);
     }
 
     @DataProvider
@@ -219,7 +219,7 @@ public void return_type_predicates(DescribedRuleStart ruleStart, Collection<Stri
         EvaluationResult result = ruleStart.should(everythingViolationPrintMemberName())
                 .evaluate(importClasses(ClassWithVariousMembers.class));
 
-        assertThat(result.getFailureReport().getDetails()).containsOnlyElementsOf(expectedMembers);
+        assertThat(result.getFailureReport().getDetails()).hasSameElementsAs(expectedMembers);
     }
 
     @DataProvider
@@ -275,7 +275,7 @@ public void throwable_type_predicates(DescribedRuleStart ruleStart, Collection<S
         EvaluationResult result = ruleStart.should(everythingViolationPrintMemberName())
                 .evaluate(importClasses(ClassWithVariousMembers.class));
 
-        assertThat(result.getFailureReport().getDetails()).containsOnlyElementsOf(expectedMembers);
+        assertThat(result.getFailureReport().getDetails()).hasSameElementsAs(expectedMembers);
     }
 
     static DescribedPredicate<List<JavaClass>> oneParameterOfType(final Class<?> type) {

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/GivenFieldsTest.java
Patch:
@@ -72,7 +72,7 @@ public void property_predicates(DescribedRuleStart ruleStart, Collection<String>
         EvaluationResult result = ruleStart.should(everythingViolationPrintMemberName())
                 .evaluate(importClasses(ClassWithVariousMembers.class));
 
-        assertThat(result.getFailureReport().getDetails()).containsOnlyElementsOf(expectedMembers);
+        assertThat(result.getFailureReport().getDetails()).hasSameElementsAs(expectedMembers);
     }
 
     private static Set<String> allFieldsExcept(String... fieldNames) {

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/GivenMembersTest.java
Patch:
@@ -132,7 +132,7 @@ public void test_members(GivenMembers<JavaMember> members, String ruleStart, Arc
         EvaluationResult result = rule.evaluate(importClasses(ClassWithVariousMembers.class));
 
         assertViolation(result);
-        assertThat(result.getFailureReport().getDetails()).containsOnlyElementsOf(expectedViolationDetails);
+        assertThat(result.getFailureReport().getDetails()).hasSameElementsAs(expectedViolationDetails);
     }
 
     @Test
@@ -381,7 +381,7 @@ public void property_predicates(DescribedRuleStart conjunction, Set<String> expe
         EvaluationResult result = conjunction.should(everythingViolationPrintMemberName())
                 .evaluate(importClasses(ClassWithVariousMembers.class, A.class, B.class, C.class, MetaAnnotation.class));
 
-        assertThat(result.getFailureReport().getDetails()).containsOnlyElementsOf(expectedMessages);
+        assertThat(result.getFailureReport().getDetails()).hasSameElementsAs(expectedMessages);
     }
 
     @DataProvider
@@ -432,7 +432,7 @@ public void declaration_predicates(DescribedRuleStart conjunction, Set<String> e
         EvaluationResult result = conjunction.should(everythingViolationPrintMemberName())
                 .evaluate(importClasses(ClassWithVariousMembers.class, OtherClassWithMembers.class));
 
-        assertThat(result.getFailureReport().getDetails()).containsOnlyElementsOf(expectedMessages);
+        assertThat(result.getFailureReport().getDetails()).hasSameElementsAs(expectedMessages);
     }
 
     static void assertViolation(EvaluationResult result) {

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/GivenMethodsTest.java
Patch:
@@ -38,7 +38,7 @@ public void property_predicates(DescribedRuleStart ruleStart, Collection<String>
         EvaluationResult result = ruleStart.should(everythingViolationPrintMemberName())
                 .evaluate(importClasses(ClassWithVariousMembers.class));
 
-        assertThat(result.getFailureReport().getDetails()).containsOnlyElementsOf(expectedMembers);
+        assertThat(result.getFailureReport().getDetails()).hasSameElementsAs(expectedMembers);
     }
 
     private static final String METHOD_A = "methodA([I)";

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/MethodsShouldTest.java
Patch:
@@ -40,7 +40,7 @@ public void property_predicates(ArchRule ruleStart, Collection<String> expectedM
         EvaluationResult result = ruleStart.evaluate(importClasses(ClassWithVariousMembers.class));
 
         Set<String> actualMethods = parseMembers(ClassWithVariousMembers.class, result.getFailureReport().getDetails());
-        assertThat(actualMethods).containsOnlyElementsOf(expectedMembers);
+        assertThat(actualMethods).hasSameElementsAs(expectedMembers);
     }
 
     private static final String METHOD_A = "methodA([I)";

File: archunit/src/test/java/com/tngtech/archunit/testutil/OutsideOfClassPathRule.java
Patch:
@@ -129,7 +129,7 @@ private static class ClassNameRetrievingVisitor extends SimpleFileVisitor<Path>
         private String className;
 
         @Override
-        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
+        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
             if (file.toString().endsWith(".class")) {
                 className = getClassName(file.toAbsolutePath().toString());
                 return FileVisitResult.TERMINATE;

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/DependenciesAssertion.java
Patch:
@@ -85,7 +85,7 @@ private ExpectedDependenciesMatchResult matchExpectedDependencies(ExpectedDepend
         List<Dependency> rest = newArrayList(actual);
         List<ExpectedDependency> missingDependencies = new ArrayList<>();
         for (final ExpectedDependency expectedDependency : expectedDependencies) {
-            if (!rest.stream().anyMatch(expectedDependency::matches)) {
+            if (rest.stream().noneMatch(expectedDependency::matches)) {
                 missingDependencies.add(expectedDependency);
             }
             rest = rest.stream().filter(dependency -> !expectedDependency.matches(dependency)).collect(toList());

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaTypesAssertion.java
Patch:
@@ -34,7 +34,7 @@ public JavaTypesAssertion(Iterable<? extends JavaType> actual) {
     }
 
     public void matchInAnyOrder(Iterable<Class<?>> classes) {
-        assertThat(HasName.Utils.namesOf(actual)).as(descriptionText()).containsOnlyElementsOf(formatNamesOf(classes));
+        assertThat(HasName.Utils.namesOf(actual)).as(descriptionText()).hasSameElementsAs(formatNamesOf(classes));
 
         JavaType[] actualSorted = sortedJavaTypes(actual);
         Class<?>[] expectedSorted = sortedClasses(classes);

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/rules/JavaClassDiagramAssociation.java
Patch:
@@ -79,8 +79,6 @@ private PlantUmlComponent getComponentOf(final JavaClass javaClass) {
                     String.format("Class %s may not be contained in more than one component, but is contained in [%s]",
                             javaClass.getName(),
                             Joiner.on(", ").join(getComponentNames(associatedComponents))));
-        } else if (associatedComponents.isEmpty()) {
-            throw new IllegalStateException(String.format("Class %s is not contained in any component", javaClass.getName()));
         }
 
         return getOnlyElement(associatedComponents);

File: archunit/src/test/java/com/tngtech/archunit/library/plantuml/rules/JavaClassDiagramAssociationTest.java
Patch:
@@ -3,6 +3,7 @@
 import java.io.File;
 import java.net.MalformedURLException;
 import java.net.URL;
+import java.util.NoSuchElementException;
 
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.library.diagramtests.confusingpackagenames.foopackage.barpackage.ClassInFooAndBarPackage;
@@ -64,8 +65,7 @@ public void rejects_class_not_contained_in_any_component() {
                 .write());
         JavaClass classNotContained = importClassWithContext(Object.class);
 
-        thrown.expect(IllegalStateException.class);
-        thrown.expectMessage(String.format("Class %s is not contained in any component", Object.class.getName()));
+        thrown.expect(NoSuchElementException.class);
 
         javaClassDiagramAssociation.getTargetPackageIdentifiers(classNotContained);
     }

File: archunit/src/jdk9main/java/com/tngtech/archunit/core/importer/ModuleLocationFactory.java
Patch:
@@ -26,10 +26,10 @@
 import java.util.Iterator;
 import java.util.Optional;
 import java.util.Set;
-import java.util.function.Function;
 import java.util.stream.Stream;
 
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.function.Function.identity;
 import static java.util.stream.Collectors.toList;
 import static java.util.stream.Collectors.toSet;
 
@@ -129,7 +129,7 @@ private static class ModuleClassFileSource implements ClassFileSource {
             locations = entries.stream()
                     .map(entry -> new ModuleClassFileLocation(moduleReference, entry))
                     .filter(classFileLocation -> classFileLocation.isIncludedBy(importOptions))
-                    .map(Function.identity()); // thanks Java type system :-(
+                    .map(identity());
         }
 
         private Set<String> loadEntries(ModuleReference moduleReference, NormalizedResourceName resourceName) {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/NormalizedResourceName.java
Patch:
@@ -38,8 +38,8 @@ boolean isStartOf(String string) {
         return string.startsWith(resourceName);
     }
 
-    public boolean startsWith(NormalizedResourceName prefix) {
-        return equals(prefix) || isAncestorPath(prefix);
+    boolean startsWith(NormalizedResourceName prefix) {
+        return prefix.resourceName.isEmpty() || equals(prefix) || isAncestorPath(prefix);
     }
 
     private boolean isAncestorPath(NormalizedResourceName prefix) {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/packageexamples/second/Second1.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.tngtech.archunit.core.domain.packageexamples.first.First2;
 
+@SuppressWarnings("unused")
 public class Second1 {
     First2 first2;
     // Since we meanwhile consider arrays to be within the package of their component type, we will always run into the problem

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/MembersShouldTest.java
Patch:
@@ -342,7 +342,7 @@ public void property_predicates(MembersShouldConjunction<?> conjunction, Set<Str
                 .evaluate(importClasses(ClassWithVariousMembers.class, A.class, B.class, C.class, MetaAnnotation.class));
 
         Set<String> actualMembers = parseMembers(result.getFailureReport().getDetails());
-        assertThat(actualMembers).containsOnlyElementsOf(expectedMembers);
+        assertThat(actualMembers).hasSameElementsAs(expectedMembers);
     }
 
     @DataProvider
@@ -394,7 +394,7 @@ public void declaration_predicates(MembersShouldConjunction<?> conjunction, Set<
                 .evaluate(importClasses(ClassWithVariousMembers.class, OtherClassWithMembers.class));
 
         Set<String> actualMembers = parseMembers(result.getFailureReport().getDetails());
-        assertThat(actualMembers).containsOnlyElementsOf(expectedMessages);
+        assertThat(actualMembers).hasSameElementsAs(expectedMessages);
     }
 
     @DataProvider

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/CyclicDependencyRulesTest.java
Patch:
@@ -1,6 +1,5 @@
 package com.tngtech.archunit.exampletest.junit4;
 
-import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.example.cycles.complexcycles.slice1.SliceOneCallingConstructorInSliceTwoAndMethodInSliceThree;
 import com.tngtech.archunit.example.cycles.complexcycles.slice3.ClassCallingConstructorInSliceFive;
@@ -13,6 +12,7 @@
 import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.resideInAPackage;
 import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
 
@@ -55,7 +55,7 @@ public class CyclicDependencyRulesTest {
                     .as("Slices of complex scenario ignoring some violations")
                     .should().beFreeOfCycles()
                     .ignoreDependency(SliceOneCallingConstructorInSliceTwoAndMethodInSliceThree.class, ClassCallingConstructorInSliceFive.class)
-                    .ignoreDependency(resideInAPackage("..slice4.."), DescribedPredicate.<JavaClass>alwaysTrue());
+                    .ignoreDependency(resideInAPackage("..slice4.."), alwaysTrue());
 
     @ArchTest
     public static final ArchRule no_cycles_in_freely_customized_slices =

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/SessionBeanRulesTest.java
Patch:
@@ -49,7 +49,7 @@ public class SessionBeanRulesTest {
 
     private static DescribedPredicate<JavaFieldAccess> targetIsStatelessSessionBean() {
         return Get.<JavaFieldAccess, FieldAccessTarget>target()
-                .then(HasOwner.Functions.Get.<JavaClass>owner())
+                .then(HasOwner.Functions.Get.owner())
                 .is(annotatedWith(Stateless.class));
     }
 

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/SlicesIsolationTest.java
Patch:
@@ -1,7 +1,6 @@
 package com.tngtech.archunit.exampletest.junit4;
 
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.example.layers.controller.one.UseCaseOneTwoController;
 import com.tngtech.archunit.example.layers.controller.two.UseCaseTwoController;
 import com.tngtech.archunit.junit.AnalyzeClasses;
@@ -12,6 +11,7 @@
 import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.core.domain.properties.HasName.Predicates.nameMatching;
 import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
 
@@ -36,7 +36,7 @@ public class SlicesIsolationTest {
             slices().matching("..controller.(*)..").namingSlices("Controller $1")
                     .as("Controllers").should().notDependOnEachOther()
                     .ignoreDependency(UseCaseOneTwoController.class, UseCaseTwoController.class)
-                    .ignoreDependency(nameMatching(".*controller\\.three.*"), DescribedPredicate.<JavaClass>alwaysTrue());
+                    .ignoreDependency(nameMatching(".*controller\\.three.*"), alwaysTrue());
 
     private static DescribedPredicate<Slice> containDescription(final String descriptionPart) {
         return new DescribedPredicate<Slice>("contain description '%s'", descriptionPart) {

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/SessionBeanRulesTest.java
Patch:
@@ -50,7 +50,7 @@ public void business_interface_implementations_should_be_unique() {
 
     private static final DescribedPredicate<JavaFieldAccess> TARGET_IS_STATELESS_SESSION_BEAN =
             Get.<JavaFieldAccess, FieldAccessTarget>target()
-                    .then(HasOwner.Functions.Get.<JavaClass>owner())
+                    .then(HasOwner.Functions.Get.owner())
                     .is(annotatedWith(Stateless.class));
 
     private static final DescribedPredicate<JavaAccess<?>> ACCESS_ORIGIN_IS_OUTSIDE_OF_CONSTRUCTION =

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/SlicesIsolationTest.java
Patch:
@@ -1,7 +1,6 @@
 package com.tngtech.archunit.exampletest;
 
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
 import com.tngtech.archunit.example.layers.controller.one.UseCaseOneTwoController;
@@ -10,6 +9,7 @@
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.core.domain.properties.HasName.Predicates.nameMatching;
 import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
 
@@ -39,7 +39,7 @@ public void controllers_should_only_use_their_own_slice_with_custom_ignore() {
         slices().matching("..controller.(*)..").namingSlices("Controller $1")
                 .as("Controllers").should().notDependOnEachOther()
                 .ignoreDependency(UseCaseOneTwoController.class, UseCaseTwoController.class)
-                .ignoreDependency(nameMatching(".*controller\\.three.*"), DescribedPredicate.<JavaClass>alwaysTrue())
+                .ignoreDependency(nameMatching(".*controller\\.three.*"), alwaysTrue())
                 .check(classes);
     }
 

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/extension/ExampleExtension.java
Patch:
@@ -21,7 +21,7 @@ public class ExampleExtension implements ArchUnitExtension {
     public static final String UNIQUE_IDENTIFIER = "archunit-example-extension";
 
     private static final ConcurrentHashMap<NewConfigurationEvent, Object> configurationEvents = new ConcurrentHashMap<>();
-    private static final List<EvaluatedRuleEvent> evaluatedRuleEvents = synchronizedList(new ArrayList<EvaluatedRuleEvent>());
+    private static final List<EvaluatedRuleEvent> evaluatedRuleEvents = synchronizedList(new ArrayList<>());
 
     @Override
     public String getUniqueIdentifier() {

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/internal/ArchRuleDeclaration.java
Patch:
@@ -20,7 +20,6 @@
 import java.lang.reflect.Field;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
-import java.util.Collections;
 import java.util.Set;
 
 import com.google.common.collect.ImmutableSet;
@@ -32,6 +31,7 @@
 import static com.tngtech.archunit.junit.internal.ReflectionUtils.getAllFields;
 import static com.tngtech.archunit.junit.internal.ReflectionUtils.getAllMethods;
 import static com.tngtech.archunit.junit.internal.ReflectionUtils.withAnnotation;
+import static java.util.Collections.singleton;
 
 abstract class ArchRuleDeclaration<T extends AnnotatedElement> {
     private final Class<?> testClass;
@@ -88,7 +88,7 @@ private static Set<ArchRuleDeclaration<?>> archRuleDeclarationsFrom(Class<?> tes
 
         return ArchTests.class.isAssignableFrom(field.getType()) ?
                 toDeclarations(getArchRulesIn(field, fieldOwner), testClass, archTestAnnotationType, forceIgnore || elementShouldBeIgnored(field)) :
-                Collections.<ArchRuleDeclaration<?>>singleton(ArchRuleDeclaration.from(testClass, field, fieldOwner, forceIgnore));
+                singleton(ArchRuleDeclaration.from(testClass, field, fieldOwner, forceIgnore));
     }
 
     private static ArchTests getArchRulesIn(Field field, Class<?> fieldOwner) {

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/internal/ArchUnitRunnerInternal.java
Patch:
@@ -19,7 +19,6 @@
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
@@ -43,6 +42,7 @@
 import static com.tngtech.archunit.junit.internal.ArchRuleDeclaration.elementShouldBeIgnored;
 import static com.tngtech.archunit.junit.internal.ArchRuleDeclaration.toDeclarations;
 import static com.tngtech.archunit.junit.internal.ArchTestExecution.getValue;
+import static java.util.Collections.singleton;
 import static java.util.stream.Collectors.toList;
 
 final class ArchUnitRunnerInternal extends ParentRunner<ArchTestExecution> implements ArchUnitRunner.InternalRunner<ArchTestExecution> {
@@ -96,7 +96,7 @@ private Set<ArchTestExecution> findArchRulesIn(FrameworkField ruleField) {
         if (ruleField.getType() == ArchTests.class) {
             return asTestExecutions(getArchRules(ruleField.getField()), ignore);
         }
-        return Collections.<ArchTestExecution>singleton(new ArchRuleExecution(getTestClass().getJavaClass(), ruleField.getField(), ignore));
+        return singleton(new ArchRuleExecution(getTestClass().getJavaClass(), ruleField.getField(), ignore));
     }
 
     private Set<ArchTestExecution> asTestExecutions(ArchTests archTests, boolean forceIgnore) {

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/internal/ClassCache.java
Patch:
@@ -16,7 +16,6 @@
 package com.tngtech.archunit.junit.internal;
 
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
@@ -40,6 +39,7 @@
 import static com.tngtech.archunit.junit.CacheMode.FOREVER;
 import static com.tngtech.archunit.junit.internal.ReflectionUtils.newInstanceOf;
 import static java.util.Arrays.stream;
+import static java.util.Collections.emptySet;
 import static java.util.stream.Collectors.toSet;
 
 /**
@@ -182,7 +182,7 @@ private Specific(ClassAnalysisRequest classAnalysisRequest, Class<?> testClass)
                 declaredLocations = ImmutableSet.<Location>builder()
                         .addAll(getLocationsOfPackages(classAnalysisRequest))
                         .addAll(getLocationsOfProviders(classAnalysisRequest, testClass))
-                        .addAll(classAnalysisRequest.scanWholeClasspath() ? Locations.inClassPath() : Collections.<Location>emptySet())
+                        .addAll(classAnalysisRequest.scanWholeClasspath() ? Locations.inClassPath() : emptySet())
                         .build();
             }
 

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/internal/ClassCacheConcurrencyTest.java
Patch:
@@ -9,21 +9,20 @@
 
 import com.tngtech.archunit.Slow;
 import com.tngtech.archunit.core.importer.ImportOptions;
-import com.tngtech.archunit.core.importer.Location;
 import com.tngtech.archunit.junit.internal.ClassCache.CacheClassFileImporter;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
-import org.mockito.ArgumentMatchers;
 import org.mockito.InjectMocks;
 import org.mockito.Spy;
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
 import static java.util.concurrent.TimeUnit.MINUTES;
 import static java.util.stream.Collectors.toList;
+import static org.mockito.ArgumentMatchers.anyCollection;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.atMost;
 import static org.mockito.Mockito.verify;
@@ -65,7 +64,7 @@ public void concurrent_access() throws Exception {
         for (Future<?> future : futures) {
             future.get(1, MINUTES);
         }
-        verify(classFileImporter, atMost(TEST_CLASSES.size())).importClasses(any(ImportOptions.class), ArgumentMatchers.<Location>anyCollection());
+        verify(classFileImporter, atMost(TEST_CLASSES.size())).importClasses(any(ImportOptions.class), anyCollection());
         verifyNoMoreInteractions(classFileImporter);
     }
 

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/internal/ClassCacheTest.java
Patch:
@@ -23,7 +23,6 @@
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
-import org.mockito.ArgumentMatchers;
 import org.mockito.Captor;
 import org.mockito.InjectMocks;
 import org.mockito.Spy;
@@ -35,6 +34,7 @@
 import static com.tngtech.java.junit.dataprovider.DataProviders.testForEach;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyCollection;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
@@ -152,7 +152,7 @@ public void if_whole_classpath_is_set_true_then_the_whole_classpath_is_imported(
         TestAnalysisRequest defaultOptions = new TestAnalysisRequest().withWholeClasspath(true);
         Class<?>[] expectedImportResult = new Class[]{getClass()};
         doReturn(new ClassFileImporter().importClasses(expectedImportResult))
-                .when(cacheClassFileImporter).importClasses(any(ImportOptions.class), ArgumentMatchers.<Location>anyCollection());
+                .when(cacheClassFileImporter).importClasses(any(ImportOptions.class), anyCollection());
 
         JavaClasses classes = cache.getClassesToAnalyzeFor(TestClass.class, defaultOptions);
 
@@ -245,7 +245,7 @@ private ClassAnalysisRequest analyzeLocation(Class<? extends LocationProvider> p
     }
 
     private void verifyNumberOfImports(int number) {
-        verify(cacheClassFileImporter, times(number)).importClasses(any(ImportOptions.class), ArgumentMatchers.<Location>anyCollection());
+        verify(cacheClassFileImporter, times(number)).importClasses(any(ImportOptions.class), anyCollection());
         verifyNoMoreInteractions(cacheClassFileImporter);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassDescriptor.java
Patch:
@@ -232,7 +232,7 @@ public JavaClassDescriptor toArrayDescriptor() {
 
         private static class PrimitiveClassDescriptor extends AbstractClassDescriptor {
             PrimitiveClassDescriptor(String fullName) {
-                super(fullName, fullName, "");
+                super(fullName, fullName, "java.lang");
                 checkArgument(primitiveClassesByName.containsKey(fullName), "'%s' must be a primitive name", fullName);
             }
 
@@ -268,7 +268,7 @@ private ArrayClassDescriptor(String fullName, String simpleName, String packageN
 
             private static String createPackageOfComponentType(String fullName) {
                 String componentType = getCanonicalName(fullName).replace("[]", "");
-                return createPackage(componentType);
+                return JavaClassDescriptor.From.name(componentType).getPackageName();
             }
 
             private static String createSimpleName(String fullName) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaModifier.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.tngtech.archunit.core.domain;
 
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.Set;
 
@@ -25,6 +24,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 import static java.util.Arrays.stream;
+import static java.util.Collections.emptySet;
 import static java.util.stream.Collectors.toSet;
 
 public enum JavaModifier {
@@ -83,7 +83,7 @@ private static Set<JavaModifier> getModifiersFor(ApplicableType type, int asmAcc
                 .filter(modifier -> modifier.applicableTo.contains(type))
                 .filter(modifier -> modifierPresent(modifier, asmAccess))
                 .collect(toSet());
-        return result.isEmpty() ? Collections.<JavaModifier>emptySet() : Sets.immutableEnumSet(result);
+        return result.isEmpty() ? emptySet() : Sets.immutableEnumSet(result);
     }
 
     private static boolean modifierPresent(JavaModifier modifier, int asmAccess) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaPackage.java
Patch:
@@ -361,7 +361,7 @@ private Optional<JavaClass> tryGetClassWithSimpleName(String className) {
 
     private Optional<JavaClass> tryGetClassWith(DescribedPredicate<? super JavaClass> predicate) {
         Set<JavaClass> matching = getClassesWith(predicate);
-        return matching.size() == 1 ? Optional.of(getOnlyElement(matching)) : Optional.<JavaClass>empty();
+        return matching.size() == 1 ? Optional.of(getOnlyElement(matching)) : Optional.empty();
     }
 
     private Set<JavaClass> getClassesWith(Predicate<? super JavaClass> predicate) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ReverseDependencies.java
Patch:
@@ -244,7 +244,7 @@ public void visitAnnotation(String propertyName, JavaAnnotation<?> memberAnnotat
         }
 
         private Set<JavaAnnotation<?>> findAnnotations(JavaClass clazz) {
-            Set<JavaAnnotation<?>> result = Sets.<JavaAnnotation<?>>newHashSet(clazz.getAnnotations());
+            Set<JavaAnnotation<?>> result = Sets.newHashSet(clazz.getAnnotations());
             for (JavaMember member : clazz.getMembers()) {
                 result.addAll(member.getAnnotations());
             }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/SourceCodeLocation.java
Patch:
@@ -58,7 +58,7 @@ private static String formatLocation(String sourceFileName, int lineNumber) {
     private static String resolveSourceFileName(JavaClass sourceClass) {
         Optional<String> recordedSourceFileName = sourceClass.getSource().isPresent()
                 ? sourceClass.getSource().get().getFileName()
-                : Optional.<String>empty();
+                : Optional.empty();
         return recordedSourceFileName.isPresent() ? recordedSourceFileName.get() : guessSourceFileName(sourceClass);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/GenericMemberTypeProcessor.java
Patch:
@@ -45,7 +45,7 @@ Optional<JavaTypeCreationProcess<T>> getType() {
 
     @Override
     public void visitClassType(String internalObjectName) {
-        updateType(new JavaParameterizedTypeBuilder<T>(JavaClassDescriptorImporter.createFromAsmObjectTypeName(internalObjectName)));
+        updateType(new JavaParameterizedTypeBuilder<>(JavaClassDescriptorImporter.createFromAsmObjectTypeName(internalObjectName)));
     }
 
     @Override
@@ -60,7 +60,7 @@ public void visitInnerClassType(String name) {
 
     @Override
     public void visitTypeArgument() {
-        parameterizedType.addTypeArgument(new NewJavaTypeCreationProcess<>(new DomainBuilders.JavaWildcardTypeBuilder<T>()));
+        parameterizedType.addTypeArgument(new NewJavaTypeCreationProcess<>(new DomainBuilders.JavaWildcardTypeBuilder<>()));
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ImportOptions.java
Patch:
@@ -15,14 +15,14 @@
  */
 package com.tngtech.archunit.core.importer;
 
-import java.util.Collections;
 import java.util.Set;
 
 import com.google.common.collect.ImmutableSet;
 import com.tngtech.archunit.PublicAPI;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
+import static java.util.Collections.emptySet;
 
 /**
  * A collection of {@link ImportOption} to filter class locations. All supplied {@link ImportOption}s will be joined
@@ -34,7 +34,7 @@ public final class ImportOptions {
 
     @PublicAPI(usage = ACCESS)
     public ImportOptions() {
-        this(Collections.<ImportOption>emptySet());
+        this(emptySet());
     }
 
     private ImportOptions(Set<ImportOption> options) {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/SignatureTypeArgumentProcessor.java
Patch:
@@ -71,15 +71,15 @@ public void visitBaseType(char descriptor) {
     @Override
     public void visitTypeArgument() {
         log.trace("Encountered wildcard for {}", currentTypeArgument.getTypeName());
-        currentTypeArgument.addTypeArgument(new NewJavaTypeCreationProcess<>(new JavaWildcardTypeBuilder<TYPE>(), JavaTypeFinisher.IDENTITY));
+        currentTypeArgument.addTypeArgument(new NewJavaTypeCreationProcess<>(new JavaWildcardTypeBuilder<>(), JavaTypeFinisher.IDENTITY));
     }
 
     @Override
     public void visitTypeVariable(String name) {
         if (log.isTraceEnabled()) {
             log.trace("Encountered {} for {}: Type variable {}", typeArgumentType.description, parameterizedType.getTypeName(), typeFinisher.getFinishedName(name));
         }
-        typeArgumentType.addTypeArgumentToBuilder(parameterizedType, new ReferenceCreationProcess<TYPE>(name, typeFinisher));
+        typeArgumentType.addTypeArgumentToBuilder(parameterizedType, new ReferenceCreationProcess<>(name, typeFinisher));
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/core/importer/SignatureTypeParameterProcessor.java
Patch:
@@ -66,13 +66,13 @@ public void visitClassType(String internalObjectName) {
     @Override
     public void visitTypeArgument() {
         log.trace("Encountered wildcard for {}", currentBound.getTypeName());
-        currentBound.addTypeArgument(new NewJavaTypeCreationProcess<>(new JavaWildcardTypeBuilder<OWNER>()));
+        currentBound.addTypeArgument(new NewJavaTypeCreationProcess<>(new JavaWildcardTypeBuilder<>()));
     }
 
     @Override
     public void visitTypeVariable(String name) {
         log.trace("Encountered upper bound for {}: Type variable {}", currentType.getName(), name);
-        currentType.addBound(new ReferenceCreationProcess<OWNER>(name));
+        currentType.addBound(new ReferenceCreationProcess<>(name));
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/core/importer/UrlSource.java
Patch:
@@ -231,7 +231,7 @@ private static Optional<URL> newJarUrl(String path) {
             Optional<URL> fileUri = newFileUri(path);
 
             try {
-                return fileUri.isPresent() ? Optional.of(new URL("jar:" + fileUri.get() + "!/")) : Optional.<URL>empty();
+                return fileUri.isPresent() ? Optional.of(new URL("jar:" + fileUri.get() + "!/")) : Optional.empty();
             } catch (MalformedURLException e) {
                 LOG.warn("Cannot parse URL from path " + path, e);
                 return Optional.empty();

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/ClassResolverFromClasspath.java
Patch:
@@ -48,7 +48,7 @@ public Optional<JavaClass> tryResolve(String typeName) {
 
         Optional<URI> uri = tryGetUriOf(typeFile);
 
-        return uri.isPresent() ? classUriImporter.tryImport(uri.get()) : Optional.<JavaClass>empty();
+        return uri.isPresent() ? classUriImporter.tryImport(uri.get()) : Optional.empty();
     }
 
     private Optional<URI> tryGetUriOf(String typeFile) {

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AllDependenciesCondition.java
Patch:
@@ -26,6 +26,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysFalse;
 
 @PublicAPI(usage = ACCESS)
 public final class AllDependenciesCondition extends AllAttributesMatchCondition<Dependency, JavaClass> {
@@ -38,7 +39,7 @@ public final class AllDependenciesCondition extends AllAttributesMatchCondition<
             final DescribedPredicate<? super Dependency> predicate,
             Function<JavaClass, ? extends Collection<Dependency>> javaClassToRelevantDependencies) {
 
-        this(description, predicate, javaClassToRelevantDependencies, DescribedPredicate.<Dependency>alwaysFalse());
+        this(description, predicate, javaClassToRelevantDependencies, alwaysFalse());
     }
 
     private AllDependenciesCondition(

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AnyDependencyCondition.java
Patch:
@@ -26,6 +26,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysFalse;
 
 @PublicAPI(usage = ACCESS)
 public final class AnyDependencyCondition extends AnyAttributeMatchesCondition<Dependency> {
@@ -38,7 +39,7 @@ public final class AnyDependencyCondition extends AnyAttributeMatchesCondition<D
             final DescribedPredicate<? super Dependency> predicate,
             Function<JavaClass, ? extends Collection<Dependency>> javaClassToRelevantDependencies) {
 
-        this(description, predicate, javaClassToRelevantDependencies, DescribedPredicate.<Dependency>alwaysFalse());
+        this(description, predicate, javaClassToRelevantDependencies, alwaysFalse());
     }
 
     private AnyDependencyCondition(

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenCodeUnitsInternal.java
Patch:
@@ -71,8 +71,8 @@ static class GivenCodeUnitsInternal extends AbstractGivenCodeUnitsInternal<JavaC
                     priority,
                     classesTransformer,
                     prepareCondition,
-                    new PredicateAggregator<JavaCodeUnit>(),
-                    Optional.<String>empty());
+                    new PredicateAggregator<>(),
+                    Optional.empty());
         }
 
         private GivenCodeUnitsInternal(
@@ -93,7 +93,7 @@ public CodeUnitsShouldInternal should() {
 
         @Override
         public CodeUnitsShouldInternal should(ArchCondition<? super JavaCodeUnit> condition) {
-            return new CodeUnitsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaCodeUnit>forSubtype(), prepareCondition);
+            return new CodeUnitsShouldInternal(finishedClassesTransformer(), priority, condition.forSubtype(), prepareCondition);
         }
 
         private static class GivenCodeUnitsFactory implements Factory<JavaCodeUnit, GivenCodeUnitsInternal> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenMembersInternal.java
Patch:
@@ -73,8 +73,8 @@ static class GivenMembersInternal extends AbstractGivenMembersInternal<JavaMembe
                     priority,
                     classesTransformer,
                     prepareCondition,
-                    new PredicateAggregator<JavaMember>(),
-                    Optional.<String>empty());
+                    new PredicateAggregator<>(),
+                    Optional.empty());
         }
 
         private GivenMembersInternal(
@@ -90,7 +90,7 @@ private GivenMembersInternal(
 
         @Override
         public MembersShouldConjunction<JavaMember> should(ArchCondition<? super JavaMember> condition) {
-            return new MembersShouldInternal(finishedClassesTransformer(), priority, condition.<JavaMember>forSubtype(), prepareCondition);
+            return new MembersShouldInternal(finishedClassesTransformer(), priority, condition.forSubtype(), prepareCondition);
         }
 
         @Override

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassInternal.java
Patch:
@@ -44,6 +44,6 @@ public ClassesShould should() {
 
     @Override
     public ClassesShouldConjunction should(ArchCondition<? super JavaClass> condition) {
-        return new ClassesShouldInternal(classesTransformer, priority, condition.<JavaClass>forSubtype(), prepareCondition);
+        return new ClassesShouldInternal(classesTransformer, priority, condition.forSubtype(), prepareCondition);
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassesInternal.java
Patch:
@@ -37,7 +37,7 @@ class GivenClassesInternal extends AbstractGivenObjects<JavaClass, GivenClassesI
 
     GivenClassesInternal(Priority priority, ClassesTransformer<JavaClass> classesTransformer,
             Function<ArchCondition<JavaClass>, ArchCondition<JavaClass>> prepareCondition) {
-        this(priority, classesTransformer, prepareCondition, new PredicateAggregator<JavaClass>(), Optional.<String>empty());
+        this(priority, classesTransformer, prepareCondition, new PredicateAggregator<>(), Optional.empty());
     }
 
     private GivenClassesInternal(
@@ -74,7 +74,7 @@ public ClassesThat<GivenClassesConjunction> that() {
 
     @Override
     public ClassesShouldConjunction should(ArchCondition<? super JavaClass> condition) {
-        return new ClassesShouldInternal(finishedClassesTransformer(), priority, condition.<JavaClass>forSubtype(), prepareCondition);
+        return new ClassesShouldInternal(finishedClassesTransformer(), priority, condition.forSubtype(), prepareCondition);
     }
 
     private static class GivenClassesFactory implements Factory<JavaClass, GivenClassesInternal> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenConstructorsInternal.java
Patch:
@@ -41,8 +41,8 @@ class GivenConstructorsInternal extends AbstractGivenCodeUnitsInternal<JavaConst
                 priority,
                 classesTransformer,
                 prepareCondition,
-                new PredicateAggregator<JavaConstructor>(),
-                Optional.<String>empty());
+                new PredicateAggregator<>(),
+                Optional.empty());
     }
 
     private GivenConstructorsInternal(
@@ -63,7 +63,7 @@ public ConstructorsShouldInternal should() {
 
     @Override
     public ConstructorsShouldInternal should(ArchCondition<? super JavaConstructor> condition) {
-        return new ConstructorsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaConstructor>forSubtype(), prepareCondition);
+        return new ConstructorsShouldInternal(finishedClassesTransformer(), priority, condition.forSubtype(), prepareCondition);
     }
 
     private static class GivenConstructorsFactory implements Factory<JavaConstructor, GivenConstructorsInternal> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenFieldsInternal.java
Patch:
@@ -42,8 +42,8 @@ class GivenFieldsInternal
                 priority,
                 classesTransformer,
                 prepareCondition,
-                new PredicateAggregator<JavaField>(),
-                Optional.<String>empty());
+                new PredicateAggregator<>(),
+                Optional.empty());
     }
 
     private GivenFieldsInternal(
@@ -64,7 +64,7 @@ public FieldsShouldInternal should() {
 
     @Override
     public FieldsShouldInternal should(ArchCondition<? super JavaField> condition) {
-        return new FieldsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaField>forSubtype(), prepareCondition);
+        return new FieldsShouldInternal(finishedClassesTransformer(), priority, condition.forSubtype(), prepareCondition);
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenMethodsInternal.java
Patch:
@@ -42,8 +42,8 @@ class GivenMethodsInternal
                 priority,
                 classesTransformer,
                 prepareCondition,
-                new PredicateAggregator<JavaMethod>(),
-                Optional.<String>empty());
+                new PredicateAggregator<>(),
+                Optional.empty());
     }
 
     private GivenMethodsInternal(
@@ -79,7 +79,7 @@ public MethodsShouldInternal should() {
 
     @Override
     public MethodsShouldInternal should(ArchCondition<? super JavaMethod> condition) {
-        return new MethodsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaMethod>forSubtype(), prepareCondition);
+        return new MethodsShouldInternal(finishedClassesTransformer(), priority, condition.forSubtype(), prepareCondition);
     }
 
     private static class GivenMethodsFactory implements Factory<JavaMethod, GivenMethodsInternal> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenObjectsInternal.java
Patch:
@@ -33,7 +33,7 @@ class GivenObjectsInternal<T> extends AbstractGivenObjects<T, GivenObjectsIntern
     GivenObjectsInternal(Priority priority,
             ClassesTransformer<T> classesTransformer,
             Function<ArchCondition<T>, ArchCondition<T>> prepareCondition) {
-        this(priority, classesTransformer, prepareCondition, new PredicateAggregator<T>(), Optional.<String>empty());
+        this(priority, classesTransformer, prepareCondition, new PredicateAggregator<>(), Optional.empty());
     }
 
     private GivenObjectsInternal(
@@ -43,13 +43,13 @@ private GivenObjectsInternal(
             PredicateAggregator<T> relevantObjectsPredicates,
             Optional<String> overriddenDescription) {
 
-        super(new GivenObjectsFactory<T>(),
+        super(new GivenObjectsFactory<>(),
                 priority, classesTransformer, prepareCondition, relevantObjectsPredicates, overriddenDescription);
     }
 
     @Override
     public ArchRule should(ArchCondition<? super T> condition) {
-        return new ObjectsShouldInternal<>(finishedClassesTransformer(), priority, condition.<T>forSubtype(), prepareCondition);
+        return new ObjectsShouldInternal<>(finishedClassesTransformer(), priority, condition.forSubtype(), prepareCondition);
     }
 
     private static class GivenObjectsFactory<T> implements AbstractGivenObjects.Factory<T, GivenObjectsInternal<T>> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/PredicateAggregator.java
Patch:
@@ -26,7 +26,7 @@ public final class PredicateAggregator<T> {
     private final Optional<DescribedPredicate<T>> predicate;
 
     public PredicateAggregator() {
-        this(AddMode.<T>and(), Optional.<DescribedPredicate<T>>empty());
+        this(AddMode.and(), Optional.empty());
     }
 
     private PredicateAggregator(AddMode<T> addMode, Optional<DescribedPredicate<T>> predicate) {
@@ -47,11 +47,11 @@ public DescribedPredicate<T> get() {
     }
 
     public PredicateAggregator<T> thatANDs() {
-        return new PredicateAggregator<>(AddMode.<T>and(), predicate);
+        return new PredicateAggregator<>(AddMode.and(), predicate);
     }
 
     public PredicateAggregator<T> thatORs() {
-        return new PredicateAggregator<>(AddMode.<T>or(), predicate);
+        return new PredicateAggregator<>(AddMode.or(), predicate);
     }
 
     private abstract static class AddMode<T> {

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/GivenSlicesInternal.java
Patch:
@@ -41,7 +41,7 @@ class GivenSlicesInternal implements GivenSlices, SlicesShould, GivenSlicesConju
 
     @Override
     public ArchRule should(ArchCondition<? super Slice> condition) {
-        return ArchRule.Factory.create(classesTransformer, condition.<Slice>forSubtype(), priority);
+        return ArchRule.Factory.create(classesTransformer, condition.forSubtype(), priority);
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Path.java
Patch:
@@ -16,7 +16,6 @@
 package com.tngtech.archunit.library.dependencies;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.Objects;
@@ -26,12 +25,13 @@
 import com.google.common.collect.ImmutableSet;
 
 import static com.google.common.collect.Iterables.getLast;
+import static java.util.Collections.emptyList;
 
 class Path<T, ATTACHMENT> {
     private final List<Edge<T, ATTACHMENT>> edges;
 
     Path() {
-        this(Collections.<Edge<T, ATTACHMENT>>emptyList());
+        this(emptyList());
     }
 
     Path(Path<T, ATTACHMENT> other) {

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceIdentifier.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.tngtech.archunit.library.dependencies;
 
-import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 
@@ -27,6 +26,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
+import static java.util.Collections.emptyList;
 
 /**
  * A unique identifier of a {@link Slice}. All {@link JavaClasses} that are assigned to the same
@@ -85,6 +85,6 @@ public static SliceIdentifier of(List<String> parts) {
 
     @PublicAPI(usage = ACCESS)
     public static SliceIdentifier ignore() {
-        return new SliceIdentifier(Collections.<String>emptyList());
+        return new SliceIdentifier(emptyList());
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/ComponentIdentifier.java
Patch:
@@ -23,7 +23,7 @@ class ComponentIdentifier {
     private final Optional<Alias> alias;
 
     ComponentIdentifier(ComponentName componentName) {
-        this(componentName, Optional.<Alias>empty());
+        this(componentName, Optional.empty());
     }
 
     ComponentIdentifier(ComponentName componentName, Alias alias) {

File: archunit/src/test/java/com/tngtech/archunit/base/DescribedPredicateTest.java
Patch:
@@ -259,7 +259,7 @@ public void anyElementThat_works() {
                 .accepts(ImmutableList.of(-1, 0, 5, 6))
                 .accepts(ImmutableList.of(-1, 0, 5, 5, 6))
                 .rejects(ImmutableList.of(-1, 0, 6))
-                .rejects(ImmutableList.<Integer>of());
+                .rejects(ImmutableList.of());
     }
 
     @Test

File: archunit/src/test/java/com/tngtech/archunit/core/domain/FormattersTest.java
Patch:
@@ -3,7 +3,6 @@
 import java.io.Serializable;
 import java.lang.reflect.Array;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
@@ -26,6 +25,7 @@
 import static com.tngtech.java.junit.dataprovider.DataProviders.$;
 import static com.tngtech.java.junit.dataprovider.DataProviders.$$;
 import static java.util.Arrays.stream;
+import static java.util.Collections.emptyList;
 import static java.util.Collections.singleton;
 import static java.util.stream.Collectors.toList;
 
@@ -41,7 +41,7 @@ public void formatNamesOf() {
         assertThat(Formatters.formatNamesOf(List.class, Iterable.class, String.class))
                 .containsExactly(List.class.getName(), Iterable.class.getName(), String.class.getName());
 
-        assertThat(Formatters.formatNamesOf(Collections.<Class<?>>emptyList())).isEmpty();
+        assertThat(Formatters.formatNamesOf(emptyList())).isEmpty();
 
         assertThat(Formatters.formatNamesOf(of(List.class, Iterable.class, String.class)))
                 .containsExactly(List.class.getName(), Iterable.class.getName(), String.class.getName());

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaAccessTest.java
Patch:
@@ -7,6 +7,7 @@
 import com.tngtech.archunit.core.importer.testexamples.SomeEnum;
 import org.junit.Test;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysFalse;
 import static com.tngtech.archunit.core.domain.TestUtils.importClassWithContext;
 import static com.tngtech.archunit.core.domain.TestUtils.importClassesWithContext;
 import static com.tngtech.archunit.core.domain.TestUtils.newMethodCallBuilder;
@@ -53,7 +54,7 @@ public void origin_predicate() {
                 .hasDescription("origin some text")
                 .accepts(anyAccess());
 
-        predicate = JavaAccess.Predicates.origin(DescribedPredicate.<JavaCodeUnit>alwaysFalse());
+        predicate = JavaAccess.Predicates.origin(alwaysFalse());
         assertThat(predicate).rejects(anyAccess());
     }
 
@@ -105,4 +106,4 @@ TestJavaAccess inLineNumber(int lineNumber) {
             }
         }
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaAnnotationTest.java
Patch:
@@ -349,7 +349,7 @@ private static class ParametersStoringVisitor implements JavaAnnotation.Paramete
         private final Multimap<String, Object> visitedParameters;
 
         ParametersStoringVisitor() {
-            this("", HashMultimap.<String, Object>create());
+            this("", HashMultimap.create());
         }
 
         private ParametersStoringVisitor(String prefix, Multimap<String, Object> visitedParameters) {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassesTest.java
Patch:
@@ -1,6 +1,5 @@
 package com.tngtech.archunit.core.domain;
 
-import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
@@ -13,6 +12,7 @@
 import static com.tngtech.archunit.core.domain.TestUtils.importClassWithContext;
 import static com.tngtech.archunit.core.domain.TestUtils.importClassesWithContext;
 import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
+import static java.util.Collections.emptySet;
 import static java.util.Collections.singletonList;
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -49,7 +49,7 @@ public void creation_of_JavaClasses_from_existing_classes_should_keep_the_origin
 
     @Test
     public void creation_of_JavaClasses_from_empty_classes_should_create_empty_default_package() {
-        JavaClasses classes = JavaClasses.of(Collections.<JavaClass>emptySet());
+        JavaClasses classes = JavaClasses.of(emptySet());
 
         assertThat(classes.getDefaultPackage().getAllClasses()).isEmpty();
     }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaFieldAccessTest.java
Patch:
@@ -13,6 +13,7 @@
 import org.junit.runner.RunWith;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.core.domain.JavaFieldAccess.AccessType.GET;
 import static com.tngtech.archunit.core.domain.JavaFieldAccess.AccessType.SET;
 import static com.tngtech.archunit.core.domain.JavaFieldAccess.Predicates.accessType;
@@ -67,7 +68,7 @@ public void predicate_access_type(AccessType accessType) throws Exception {
 
     @Test
     public void predicate_field_access_target_by_predicate() throws Exception {
-        assertThat(target(DescribedPredicate.<FieldAccessTarget>alwaysTrue()))
+        assertThat(target(alwaysTrue()))
                 .accepts(stringFieldAccess(GET));
         assertThat(target(DescribedPredicate.<FieldAccessTarget>alwaysFalse().as("any message")))
                 .rejects(stringFieldAccess(GET))

File: archunit/src/test/java/com/tngtech/archunit/core/domain/SourceTest.java
Patch:
@@ -45,7 +45,7 @@ public void source_file_name() {
         Source source = new Source(uriOf(Object.class), Optional.of("SomeClass.java"), false);
         assertThat(source.getFileName()).as("source file name").contains("SomeClass.java");
 
-        source = new Source(uriOf(Object.class), Optional.<String>empty(), false);
+        source = new Source(uriOf(Object.class), Optional.empty(), false);
         assertThat(source.getFileName()).as("source file name").isEmpty();
     }
 
@@ -163,7 +163,7 @@ private Source newSource(URL url) throws URISyntaxException {
     }
 
     private Source newSource(URI uri) {
-        return new Source(uri, Optional.<String>empty(), true);
+        return new Source(uri, Optional.empty(), true);
     }
 
     private static Md5sum md5sumOf(String data) {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/TestUtils.java
Patch:
@@ -73,7 +73,7 @@ public static Md5sum md5sumOf(byte[] bytes) {
         File file = newTemporaryFile();
         try {
             Files.write(bytes, file);
-            return new Source(file.toURI(), Optional.<String>empty(), true).getMd5sum();
+            return new Source(file.toURI(), Optional.empty(), true).getMd5sum();
         } catch (IOException e) {
             throw new RuntimeException(e);
         }
@@ -111,7 +111,7 @@ public static MethodCallTarget resolvedTargetFrom(JavaMethod target) {
     }
 
     private static MethodCallTarget unresolvedTargetFrom(JavaMethod target) {
-        return ImportTestUtils.targetFrom(target, Optional::<JavaMethod>empty);
+        return ImportTestUtils.targetFrom(target, Optional::empty);
     }
 
     public static Class<?>[] asClasses(List<JavaClass> parameters) {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/CanBeAnnotatedTest.java
Patch:
@@ -12,6 +12,7 @@
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.core.domain.TestUtils.importClassWithContext;
 import static com.tngtech.archunit.core.domain.TestUtils.importClassesWithContext;
 import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
@@ -38,7 +39,7 @@ public void matches_annotation_by_type() {
 
     @Test
     public void matches_annotation_by_predicate() {
-        assertThat(annotatedWith(DescribedPredicate.<JavaAnnotation<?>>alwaysTrue()))
+        assertThat(annotatedWith(alwaysTrue()))
                 .accepts(importClassWithContext(AnnotatedClass.class));
         assertThat(annotatedWith(DescribedPredicate.<JavaAnnotation<?>>alwaysFalse().as("Something")))
                 .rejects(importClassWithContext(AnnotatedClass.class))
@@ -77,7 +78,7 @@ public void matches_meta_annotation_by_type() {
     public void matches_meta_annotation_by_predicate() {
         JavaClass clazz = importClassesWithContext(MetaAnnotatedClass.class, MetaRuntimeRetentionAnnotation.class).get(MetaAnnotatedClass.class);
 
-        assertThat(metaAnnotatedWith(DescribedPredicate.<JavaAnnotation<?>>alwaysTrue()))
+        assertThat(metaAnnotatedWith(alwaysTrue()))
                 .accepts(clazz);
         assertThat(metaAnnotatedWith(DescribedPredicate.<JavaAnnotation<?>>alwaysFalse().as("Something")))
                 .rejects(clazz)

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasParameterTypesTest.java
Patch:
@@ -9,6 +9,7 @@
 import com.tngtech.archunit.core.domain.JavaType;
 import org.junit.Test;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.core.domain.TestUtils.importClassesWithContext;
 import static com.tngtech.archunit.core.domain.properties.HasParameterTypes.Predicates.rawParameterTypes;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
@@ -42,7 +43,7 @@ public void predicate_on_parameters_by_String() {
     public void predicate_on_parameters_by_Predicate() {
         HasParameterTypes hasParameterTypes = newHasParameterTypes(String.class, Serializable.class);
 
-        assertThat(rawParameterTypes(DescribedPredicate.<List<JavaClass>>alwaysTrue()))
+        assertThat(rawParameterTypes(alwaysTrue()))
                 .accepts(hasParameterTypes);
         assertThat(rawParameterTypes(DescribedPredicate.<List<JavaClass>>alwaysFalse().as("some text")))
                 .rejects(hasParameterTypes)

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasReturnTypeTest.java
Patch:
@@ -5,6 +5,7 @@
 import com.tngtech.archunit.core.domain.JavaType;
 import org.junit.Test;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.core.domain.TestUtils.importClassWithContext;
 import static com.tngtech.archunit.core.domain.properties.HasReturnType.Functions.GET_RAW_RETURN_TYPE;
 import static com.tngtech.archunit.core.domain.properties.HasReturnType.Functions.GET_RETURN_TYPE;
@@ -38,7 +39,7 @@ public void predicate_on_return_type_by_String() {
     public void predicate_on_return_type_by_Predicate() {
         HasReturnType hasReturnTypeString = newHasReturnType(importClassWithContext(String.class));
 
-        assertThat(rawReturnType(DescribedPredicate.<JavaClass>alwaysTrue()))
+        assertThat(rawReturnType(alwaysTrue()))
                 .accepts(hasReturnTypeString);
         assertThat(rawReturnType(DescribedPredicate.<JavaClass>alwaysFalse().as("some text")))
                 .rejects(hasReturnTypeString)

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasThrowsClauseTest.java
Patch:
@@ -10,6 +10,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.core.domain.Formatters.formatNamesOf;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.equivalentTo;
 import static com.tngtech.archunit.core.domain.TestUtils.throwsClause;
@@ -65,7 +66,7 @@ public void predicate_containing_type(DescribedPredicate<HasThrowsClause<?>> pre
     public void predicate_on_parameters_by_Predicate() {
         HasThrowsClause<?> hasThrowsClause = newHasThrowsClause(FirstException.class, SecondException.class);
 
-        assertThat(HasThrowsClause.Predicates.throwsClause(DescribedPredicate.<ThrowsClause<?>>alwaysTrue()))
+        assertThat(HasThrowsClause.Predicates.throwsClause(alwaysTrue()))
                 .accepts(hasThrowsClause);
         assertThat(HasThrowsClause.Predicates.throwsClause(DescribedPredicate.<ThrowsClause<?>>alwaysFalse().as("some text")))
                 .rejects(hasThrowsClause)

File: archunit/src/test/java/com/tngtech/archunit/core/domain/testobjects/DependenciesOnClassObjects.java
Patch:
@@ -16,7 +16,7 @@ public class DependenciesOnClassObjects {
         List<Class<?>> referencedClassObjectsInStaticInitializer = ImmutableList.of(FilterInputStream.class, Buffer.class);
     }
 
-    List<Class<?>> referencedClassObjectsInConstructor = ImmutableList.<Class<?>>of(File.class, Path.class);
+    List<Class<?>> referencedClassObjectsInConstructor = ImmutableList.of(File.class, Path.class);
 
     List<Class<?>> referencedClassObjectsInMethod() {
         return ImmutableList.of(FileSystem.class, Charset.class);

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterAnnotationsTest.java
Patch:
@@ -3,7 +3,6 @@
 import java.io.Serializable;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
@@ -47,6 +46,7 @@
 import static com.tngtech.archunit.testutil.Assertions.assertThatAnnotation;
 import static com.tngtech.archunit.testutil.Assertions.assertThatAnnotations;
 import static com.tngtech.archunit.testutil.Assertions.assertThatType;
+import static java.util.Collections.emptySet;
 
 @RunWith(DataProviderRunner.class)
 public class ClassFileImporterAnnotationsTest {
@@ -400,7 +400,7 @@ public void imports_empty_parameter_annotations_for_method_without_annotated_par
             assertThat(parameter.getAnnotations()).isEmpty();
         }
         assertThat(method.getParameterAnnotations()).containsExactly(
-                Collections.<JavaAnnotation<JavaParameter>>emptySet(), Collections.<JavaAnnotation<JavaParameter>>emptySet());
+                emptySet(), emptySet());
     }
 
     @Test
@@ -574,7 +574,7 @@ void notToFind() {
             assertThatAnnotation(annotation).hasType(ParameterAnnotation.class);
         }
 
-        Set<JavaAnnotation<?>> expected = ImmutableSet.<JavaAnnotation<?>>of(
+        Set<JavaAnnotation<?>> expected = ImmutableSet.of(
                 classes.get(Dependent.class).getAnnotationOfType(ParameterAnnotation.class.getName()),
                 classes.get(Dependent.class).getField("field").getAnnotationOfType(ParameterAnnotation.class.getName()),
                 classes.get(Dependent.class).getConstructor(getClass()).getAnnotationOfType(ParameterAnnotation.class.getName()),

File: archunit/src/test/java/com/tngtech/archunit/core/importer/DependencyResolutionProcessTestUtils.java
Patch:
@@ -43,7 +43,7 @@ private ImporterWithAdjustedResolutionRuns(Set<String> propertyNames, Optional<I
         }
 
         static ImporterWithAdjustedResolutionRuns disableAllIterationsExcept(String... propertyNames) {
-            return new ImporterWithAdjustedResolutionRuns(ImmutableSet.copyOf(propertyNames), Optional.<Integer>empty());
+            return new ImporterWithAdjustedResolutionRuns(ImmutableSet.copyOf(propertyNames), Optional.empty());
         }
 
         static ImporterWithAdjustedResolutionRuns disableAllIterationsExcept(String propertyName, int number) {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/referencedclassobjects/ReferencingClassObjects.java
Patch:
@@ -16,7 +16,7 @@ public class ReferencingClassObjects {
         List<Class<?>> referencedClassObjectsInStaticInitializer = ImmutableList.of(FilterInputStream.class, Buffer.class);
     }
 
-    List<Class<?>> referencedClassObjectsInConstructor = ImmutableList.<Class<?>>of(File.class, Path.class);
+    List<Class<?>> referencedClassObjectsInConstructor = ImmutableList.of(File.class, Path.class);
 
     List<Class<?>> referencedClassObjectsInMethod() {
         return ImmutableList.of(FileSystem.class, Charset.class);

File: archunit/src/test/java/com/tngtech/archunit/lang/ArchRuleTest.java
Patch:
@@ -9,7 +9,6 @@
 import com.google.common.base.Joiner;
 import com.google.common.base.Splitter;
 import com.google.common.io.Files;
-import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.domain.JavaClassesTest;
@@ -26,6 +25,7 @@
 import org.junit.rules.ExpectedException;
 
 import static com.google.common.collect.Lists.newArrayList;
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysFalse;
 import static com.tngtech.archunit.core.domain.Formatters.joinSingleQuoted;
 import static com.tngtech.archunit.core.domain.TestUtils.importClasses;
 import static com.tngtech.archunit.core.domain.TestUtils.importClassesWithContext;
@@ -182,7 +182,7 @@ public void evaluation_fails_because_of_empty_set_of_elements_after_that_clause_
         thrown.expectMessage("failed to check any classes");
         thrown.expectMessage(FAIL_ON_EMPTY_SHOULD_PROPERTY_NAME);
 
-        createPassingArchRule(strings().that(DescribedPredicate.<String>alwaysFalse())).evaluate(importClasses(SomeClass.class));
+        createPassingArchRule(strings().that(alwaysFalse())).evaluate(importClasses(SomeClass.class));
     }
 
     @Test
@@ -208,7 +208,7 @@ private ArchRule createPassingArchRule() {
     }
 
     private <T> ArchRule createPassingArchRule(ClassesTransformer<T> classesTransformer) {
-        return ArchRule.Factory.create(classesTransformer, ALWAYS_BE_VALID.<T>forSubtype(), Priority.MEDIUM);
+        return ArchRule.Factory.create(classesTransformer, ALWAYS_BE_VALID.forSubtype(), Priority.MEDIUM);
     }
 
     private ClassesTransformer<String> strings() {

File: archunit/src/test/java/com/tngtech/archunit/lang/CompositeArchRuleTest.java
Patch:
@@ -3,7 +3,6 @@
 import java.util.List;
 
 import com.google.common.collect.ImmutableList;
-import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
@@ -15,6 +14,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysFalse;
 import static com.tngtech.archunit.core.domain.TestUtils.importClasses;
 import static com.tngtech.archunit.lang.Priority.HIGH;
 import static com.tngtech.archunit.lang.Priority.MEDIUM;
@@ -115,7 +115,7 @@ public void allows_empty_should_if_overridden_by_rule() {
     private static CompositeArchRule compositeRuleWithPartialEmptyShould() {
         return CompositeArchRule
                 .of(classes().should().bePublic())
-                .and(classes().that(DescribedPredicate.<JavaClass>alwaysFalse()).should().bePublic());
+                .and(classes().that(alwaysFalse()).should().bePublic());
     }
 
     private void assertPriority(String failureMessage, Priority priority) {

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/ArchConditionsTest.java
Patch:
@@ -14,6 +14,7 @@
 import com.tngtech.archunit.lang.ConditionEvents;
 import org.junit.Test;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysFalse;
 import static com.tngtech.archunit.core.domain.JavaCall.Predicates.target;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.type;
@@ -106,7 +107,7 @@ public void only_have_dependents_where() {
         JavaClasses classes = importClasses(CallingClass.class, SomeClass.class);
         JavaClass accessedClass = classes.get(SomeClass.class);
 
-        assertThat(onlyHaveDependentsWhere(DescribedPredicate.<Dependency>alwaysFalse()))
+        assertThat(onlyHaveDependentsWhere(alwaysFalse()))
                 .checking(accessedClass)
                 .haveAtLeastOneViolationMessageMatching(String.format(".*%s.*%s.*",
                         quote(CallingClass.class.getName()), quote(SomeClass.class.getName())));

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/GraphTest.java
Patch:
@@ -1,7 +1,6 @@
 package com.tngtech.archunit.library.dependencies;
 
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import java.util.Random;
 import java.util.Set;
@@ -20,6 +19,7 @@
 import static com.google.common.collect.Sets.cartesianProduct;
 import static com.tngtech.archunit.library.dependencies.CycleConfiguration.MAX_NUMBER_OF_CYCLES_TO_DETECT_PROPERTY_NAME;
 import static java.util.Arrays.asList;
+import static java.util.Collections.emptySet;
 import static java.util.Collections.singleton;
 import static java.util.Collections.singletonList;
 import static java.util.stream.Collectors.toSet;
@@ -237,6 +237,6 @@ static Set<Edge<String, String>> singleEdge(String from, String to) {
     }
 
     static <NODE, ATTACHMENT> Edge<NODE, ATTACHMENT> newEdge(NODE from, NODE to) {
-        return new Edge<>(from, to, Collections.<ATTACHMENT>emptySet());
+        return new Edge<>(from, to, emptySet());
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/SlicesShouldTest.java
Patch:
@@ -21,6 +21,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.library.dependencies.GivenSlicesTest.TEST_CLASSES_PACKAGE;
 import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
 import static com.tngtech.java.junit.dataprovider.DataProviders.$;
@@ -49,7 +50,7 @@ public void slice_rules_should_ignore_configured_dependencies(SliceRule rule) {
                 .contain(SecondAnyClass.class, FirstAnyPkgClass.class)
                 .contain(SecondThreeAnyClass.class, SomePkgClass.class);
 
-        rule = rule.ignoreDependency(classIn(".*\\.first\\.three\\..*"), DescribedPredicate.<JavaClass>alwaysTrue());
+        rule = rule.ignoreDependency(classIn(".*\\.first\\.three\\..*"), alwaysTrue());
         assertViolations(classes, rule)
                 .doNotContain(FirstThreeAnyClass.class, SecondThreeAnyClass.class)
                 .contain(FirstAnyPkgClass.class, SomePkgSubclass.class)
@@ -70,7 +71,7 @@ public void slice_rules_should_ignore_configured_dependencies(SliceRule rule) {
                 .doNotContain(SecondAnyClass.class, FirstAnyPkgClass.class)
                 .contain(SecondThreeAnyClass.class, SomePkgClass.class);
 
-        rule = rule.ignoreDependency(DescribedPredicate.<JavaClass>alwaysTrue(), classIn(".*\\.some\\.pkg\\..*"));
+        rule = rule.ignoreDependency(alwaysTrue(), classIn(".*\\.some\\.pkg\\..*"));
         assertViolations(classes, rule)
                 .doNotContain(FirstThreeAnyClass.class, SecondThreeAnyClass.class)
                 .doNotContain(FirstAnyPkgClass.class, SomePkgSubclass.class)

File: archunit/src/test/java/com/tngtech/archunit/library/freeze/TextFileBasedViolationStoreTest.java
Patch:
@@ -92,7 +92,7 @@ public void reads_violations_of_single_rule_from_configured_folder() {
 
     @Test
     public void reads_empty_list_of_violations() {
-        store.save(defaultRule(), ImmutableList.<String>of());
+        store.save(defaultRule(), ImmutableList.of());
 
         List<String> storedViolations = store.getViolations(defaultRule());
 

File: archunit/src/test/java/com/tngtech/archunit/library/metrics/ComponentDependencyMetricsTest.java
Patch:
@@ -129,7 +129,7 @@ public void normalized_distance_from_main_sequence_is_calculated_as_distance_fro
 
     @Test
     public void rejects_requesting_metrics_of_unknown_component() {
-        final ComponentDependencyMetrics metrics = ArchitectureMetrics.componentDependencyMetrics(MetricsComponents.<JavaClass>of());
+        final ComponentDependencyMetrics metrics = ArchitectureMetrics.componentDependencyMetrics(MetricsComponents.of());
 
         List<ThrowingCallable> callables = ImmutableList.of(
                 () -> metrics.getEfferentCoupling("unknown"),

File: archunit/src/test/java/com/tngtech/archunit/testutil/OutsideOfClassPathRule.java
Patch:
@@ -8,7 +8,6 @@
 import java.nio.file.Path;
 import java.nio.file.SimpleFileVisitor;
 import java.nio.file.attribute.BasicFileAttributes;
-import java.util.Collections;
 import java.util.List;
 import java.util.function.Predicate;
 
@@ -24,6 +23,7 @@
 import static com.tngtech.archunit.testutil.TestUtils.newTemporaryFolder;
 import static com.tngtech.archunit.testutil.TestUtils.toUri;
 import static java.nio.file.Files.createDirectories;
+import static java.util.Collections.emptyList;
 
 public class OutsideOfClassPathRule extends ExternalResource {
     private final TemporaryFolder temporaryFolder = new TemporaryFolder(newTemporaryFolder());
@@ -43,7 +43,7 @@ public OutsideOfClassPathRule onlyKeep(Predicate<? super String> fileNamePredica
     }
 
     public Path setUp(URL folder) throws IOException {
-        return setUp(folder, Collections.<String>emptyList());
+        return setUp(folder, emptyList());
     }
 
     public Path setUp(URL folder, List<String> subfolder) throws IOException {

File: archunit/src/test/java/com/tngtech/archunit/testutil/syntax/MethodCallChainTest.java
Patch:
@@ -1,7 +1,5 @@
 package com.tngtech.archunit.testutil.syntax;
 
-import java.util.Collections;
-
 import com.tngtech.archunit.testutil.syntax.callchainexamples.fivestepswithgenericshierarchy.FiveStepsHierarchyImplementationStep1;
 import com.tngtech.archunit.testutil.syntax.callchainexamples.fivestepswithgenericshierarchy.FiveStepsHierarchyImplementationStep2;
 import com.tngtech.archunit.testutil.syntax.callchainexamples.fivestepswithgenericshierarchy.FiveStepsHierarchyImplementationStep3;
@@ -38,6 +36,7 @@
 
 import static com.tngtech.archunit.testutil.syntax.MethodChoiceStrategy.chooseAllArchUnitSyntaxMethods;
 import static com.tngtech.java.junit.dataprovider.DataProviders.testForEach;
+import static java.util.Collections.emptyList;
 import static org.assertj.core.api.Assertions.assertThat;
 
 @RunWith(DataProviderRunner.class)
@@ -115,7 +114,7 @@ private <T> MethodCallChain createCallChainStart(Class<T> startInterface, T star
     }
 
     private void invokeNext(MethodCallChain callChain) {
-        callChain.invokeNextMethodCandidate(new Parameters(Collections.<Parameter>emptyList()), false);
+        callChain.invokeNextMethodCandidate(new Parameters(emptyList()), false);
     }
 
     private static class CallChainTestCase<T> {

File: archunit/src/test/java/com/tngtech/archunit/testutil/syntax/PropagatedType.java
Patch:
@@ -3,13 +3,13 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
-import java.util.Collections;
 import java.util.Map;
 
 import com.google.common.collect.ImmutableMap;
 import com.google.common.reflect.TypeToken;
 
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Collections.emptyMap;
 
 class PropagatedType {
     private final Type type;
@@ -30,7 +30,7 @@ private Map<String, Type> getTypeVariables(Type type, Context context) {
         } else if (type instanceof ParameterizedType) {
             return resolveTypeVariables((ParameterizedType) type, context);
         } else {
-            return Collections.emptyMap();
+            return emptyMap();
         }
     }
 
@@ -104,7 +104,7 @@ static Context forType(PropagatedType type) {
         }
 
         static Context empty() {
-            return new Context(Collections.<String, Type>emptyMap());
+            return new Context(emptyMap());
         }
 
         Type resolve(Type type) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassDescriptor.java
Patch:
@@ -232,7 +232,7 @@ public JavaClassDescriptor toArrayDescriptor() {
 
         private static class PrimitiveClassDescriptor extends AbstractClassDescriptor {
             PrimitiveClassDescriptor(String fullName) {
-                super(fullName, fullName, "");
+                super(fullName, fullName, "java.lang");
                 checkArgument(primitiveClassesByName.containsKey(fullName), "'%s' must be a primitive name", fullName);
             }
 
@@ -268,7 +268,7 @@ private ArrayClassDescriptor(String fullName, String simpleName, String packageN
 
             private static String createPackageOfComponentType(String fullName) {
                 String componentType = getCanonicalName(fullName).replace("[]", "");
-                return createPackage(componentType);
+                return JavaClassDescriptor.From.name(componentType).getPackageName();
             }
 
             private static String createSimpleName(String fullName) {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassDescriptorTest.java
Patch:
@@ -136,7 +136,7 @@ public void convert_primitive_descriptor_to_array_descriptor() {
 
         assertThat(arrayDescriptor.getFullyQualifiedClassName()).isEqualTo(int[].class.getName());
         assertThat(arrayDescriptor.getSimpleClassName()).isEqualTo(int[].class.getSimpleName());
-        assertThat(arrayDescriptor.getPackageName()).isEmpty();
+        assertThat(arrayDescriptor.getPackageName()).isEqualTo("java.lang");
     }
 
     @Test

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/CyclicDependencyRulesTest.java
Patch:
@@ -1,6 +1,5 @@
 package com.tngtech.archunit.exampletest.junit4;
 
-import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.example.cycles.complexcycles.slice1.SliceOneCallingConstructorInSliceTwoAndMethodInSliceThree;
 import com.tngtech.archunit.example.cycles.complexcycles.slice3.ClassCallingConstructorInSliceFive;
@@ -13,6 +12,7 @@
 import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.resideInAPackage;
 import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
 
@@ -55,7 +55,7 @@ public class CyclicDependencyRulesTest {
                     .as("Slices of complex scenario ignoring some violations")
                     .should().beFreeOfCycles()
                     .ignoreDependency(SliceOneCallingConstructorInSliceTwoAndMethodInSliceThree.class, ClassCallingConstructorInSliceFive.class)
-                    .ignoreDependency(resideInAPackage("..slice4.."), DescribedPredicate.<JavaClass>alwaysTrue());
+                    .ignoreDependency(resideInAPackage("..slice4.."), alwaysTrue());
 
     @ArchTest
     public static final ArchRule no_cycles_in_freely_customized_slices =

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/SessionBeanRulesTest.java
Patch:
@@ -49,7 +49,7 @@ public class SessionBeanRulesTest {
 
     private static DescribedPredicate<JavaFieldAccess> targetIsStatelessSessionBean() {
         return Get.<JavaFieldAccess, FieldAccessTarget>target()
-                .then(HasOwner.Functions.Get.<JavaClass>owner())
+                .then(HasOwner.Functions.Get.owner())
                 .is(annotatedWith(Stateless.class));
     }
 

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/SlicesIsolationTest.java
Patch:
@@ -1,7 +1,6 @@
 package com.tngtech.archunit.exampletest.junit4;
 
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.example.layers.controller.one.UseCaseOneTwoController;
 import com.tngtech.archunit.example.layers.controller.two.UseCaseTwoController;
 import com.tngtech.archunit.junit.AnalyzeClasses;
@@ -12,6 +11,7 @@
 import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.core.domain.properties.HasName.Predicates.nameMatching;
 import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
 
@@ -36,7 +36,7 @@ public class SlicesIsolationTest {
             slices().matching("..controller.(*)..").namingSlices("Controller $1")
                     .as("Controllers").should().notDependOnEachOther()
                     .ignoreDependency(UseCaseOneTwoController.class, UseCaseTwoController.class)
-                    .ignoreDependency(nameMatching(".*controller\\.three.*"), DescribedPredicate.<JavaClass>alwaysTrue());
+                    .ignoreDependency(nameMatching(".*controller\\.three.*"), alwaysTrue());
 
     private static DescribedPredicate<Slice> containDescription(final String descriptionPart) {
         return new DescribedPredicate<Slice>("contain description '%s'", descriptionPart) {

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/SessionBeanRulesTest.java
Patch:
@@ -50,7 +50,7 @@ public void business_interface_implementations_should_be_unique() {
 
     private static final DescribedPredicate<JavaFieldAccess> TARGET_IS_STATELESS_SESSION_BEAN =
             Get.<JavaFieldAccess, FieldAccessTarget>target()
-                    .then(HasOwner.Functions.Get.<JavaClass>owner())
+                    .then(HasOwner.Functions.Get.owner())
                     .is(annotatedWith(Stateless.class));
 
     private static final DescribedPredicate<JavaAccess<?>> ACCESS_ORIGIN_IS_OUTSIDE_OF_CONSTRUCTION =

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/SlicesIsolationTest.java
Patch:
@@ -1,7 +1,6 @@
 package com.tngtech.archunit.exampletest;
 
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
 import com.tngtech.archunit.example.layers.controller.one.UseCaseOneTwoController;
@@ -10,6 +9,7 @@
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.core.domain.properties.HasName.Predicates.nameMatching;
 import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
 
@@ -39,7 +39,7 @@ public void controllers_should_only_use_their_own_slice_with_custom_ignore() {
         slices().matching("..controller.(*)..").namingSlices("Controller $1")
                 .as("Controllers").should().notDependOnEachOther()
                 .ignoreDependency(UseCaseOneTwoController.class, UseCaseTwoController.class)
-                .ignoreDependency(nameMatching(".*controller\\.three.*"), DescribedPredicate.<JavaClass>alwaysTrue())
+                .ignoreDependency(nameMatching(".*controller\\.three.*"), alwaysTrue())
                 .check(classes);
     }
 

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/extension/ExampleExtension.java
Patch:
@@ -21,7 +21,7 @@ public class ExampleExtension implements ArchUnitExtension {
     public static final String UNIQUE_IDENTIFIER = "archunit-example-extension";
 
     private static final ConcurrentHashMap<NewConfigurationEvent, Object> configurationEvents = new ConcurrentHashMap<>();
-    private static final List<EvaluatedRuleEvent> evaluatedRuleEvents = synchronizedList(new ArrayList<EvaluatedRuleEvent>());
+    private static final List<EvaluatedRuleEvent> evaluatedRuleEvents = synchronizedList(new ArrayList<>());
 
     @Override
     public String getUniqueIdentifier() {

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/internal/ArchRuleDeclaration.java
Patch:
@@ -20,7 +20,6 @@
 import java.lang.reflect.Field;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
-import java.util.Collections;
 import java.util.Set;
 
 import com.google.common.collect.ImmutableSet;
@@ -32,6 +31,7 @@
 import static com.tngtech.archunit.junit.internal.ReflectionUtils.getAllFields;
 import static com.tngtech.archunit.junit.internal.ReflectionUtils.getAllMethods;
 import static com.tngtech.archunit.junit.internal.ReflectionUtils.withAnnotation;
+import static java.util.Collections.singleton;
 
 abstract class ArchRuleDeclaration<T extends AnnotatedElement> {
     private final Class<?> testClass;
@@ -88,7 +88,7 @@ private static Set<ArchRuleDeclaration<?>> archRuleDeclarationsFrom(Class<?> tes
 
         return ArchTests.class.isAssignableFrom(field.getType()) ?
                 toDeclarations(getArchRulesIn(field, fieldOwner), testClass, archTestAnnotationType, forceIgnore || elementShouldBeIgnored(field)) :
-                Collections.<ArchRuleDeclaration<?>>singleton(ArchRuleDeclaration.from(testClass, field, fieldOwner, forceIgnore));
+                singleton(ArchRuleDeclaration.from(testClass, field, fieldOwner, forceIgnore));
     }
 
     private static ArchTests getArchRulesIn(Field field, Class<?> fieldOwner) {

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/internal/ArchUnitRunnerInternal.java
Patch:
@@ -19,7 +19,6 @@
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
@@ -43,6 +42,7 @@
 import static com.tngtech.archunit.junit.internal.ArchRuleDeclaration.elementShouldBeIgnored;
 import static com.tngtech.archunit.junit.internal.ArchRuleDeclaration.toDeclarations;
 import static com.tngtech.archunit.junit.internal.ArchTestExecution.getValue;
+import static java.util.Collections.singleton;
 import static java.util.stream.Collectors.toList;
 
 final class ArchUnitRunnerInternal extends ParentRunner<ArchTestExecution> implements ArchUnitRunner.InternalRunner<ArchTestExecution> {
@@ -96,7 +96,7 @@ private Set<ArchTestExecution> findArchRulesIn(FrameworkField ruleField) {
         if (ruleField.getType() == ArchTests.class) {
             return asTestExecutions(getArchRules(ruleField.getField()), ignore);
         }
-        return Collections.<ArchTestExecution>singleton(new ArchRuleExecution(getTestClass().getJavaClass(), ruleField.getField(), ignore));
+        return singleton(new ArchRuleExecution(getTestClass().getJavaClass(), ruleField.getField(), ignore));
     }
 
     private Set<ArchTestExecution> asTestExecutions(ArchTests archTests, boolean forceIgnore) {

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/internal/ClassCache.java
Patch:
@@ -16,7 +16,6 @@
 package com.tngtech.archunit.junit.internal;
 
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
@@ -40,6 +39,7 @@
 import static com.tngtech.archunit.junit.CacheMode.FOREVER;
 import static com.tngtech.archunit.junit.internal.ReflectionUtils.newInstanceOf;
 import static java.util.Arrays.stream;
+import static java.util.Collections.emptySet;
 import static java.util.stream.Collectors.toSet;
 
 /**
@@ -182,7 +182,7 @@ private Specific(ClassAnalysisRequest classAnalysisRequest, Class<?> testClass)
                 declaredLocations = ImmutableSet.<Location>builder()
                         .addAll(getLocationsOfPackages(classAnalysisRequest))
                         .addAll(getLocationsOfProviders(classAnalysisRequest, testClass))
-                        .addAll(classAnalysisRequest.scanWholeClasspath() ? Locations.inClassPath() : Collections.<Location>emptySet())
+                        .addAll(classAnalysisRequest.scanWholeClasspath() ? Locations.inClassPath() : emptySet())
                         .build();
             }
 

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/internal/ClassCacheConcurrencyTest.java
Patch:
@@ -9,21 +9,20 @@
 
 import com.tngtech.archunit.Slow;
 import com.tngtech.archunit.core.importer.ImportOptions;
-import com.tngtech.archunit.core.importer.Location;
 import com.tngtech.archunit.junit.internal.ClassCache.CacheClassFileImporter;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
-import org.mockito.ArgumentMatchers;
 import org.mockito.InjectMocks;
 import org.mockito.Spy;
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
 import static java.util.concurrent.TimeUnit.MINUTES;
 import static java.util.stream.Collectors.toList;
+import static org.mockito.ArgumentMatchers.anyCollection;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.atMost;
 import static org.mockito.Mockito.verify;
@@ -65,7 +64,7 @@ public void concurrent_access() throws Exception {
         for (Future<?> future : futures) {
             future.get(1, MINUTES);
         }
-        verify(classFileImporter, atMost(TEST_CLASSES.size())).importClasses(any(ImportOptions.class), ArgumentMatchers.<Location>anyCollection());
+        verify(classFileImporter, atMost(TEST_CLASSES.size())).importClasses(any(ImportOptions.class), anyCollection());
         verifyNoMoreInteractions(classFileImporter);
     }
 

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/internal/ClassCacheTest.java
Patch:
@@ -23,7 +23,6 @@
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
-import org.mockito.ArgumentMatchers;
 import org.mockito.Captor;
 import org.mockito.InjectMocks;
 import org.mockito.Spy;
@@ -35,6 +34,7 @@
 import static com.tngtech.java.junit.dataprovider.DataProviders.testForEach;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyCollection;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
@@ -152,7 +152,7 @@ public void if_whole_classpath_is_set_true_then_the_whole_classpath_is_imported(
         TestAnalysisRequest defaultOptions = new TestAnalysisRequest().withWholeClasspath(true);
         Class<?>[] expectedImportResult = new Class[]{getClass()};
         doReturn(new ClassFileImporter().importClasses(expectedImportResult))
-                .when(cacheClassFileImporter).importClasses(any(ImportOptions.class), ArgumentMatchers.<Location>anyCollection());
+                .when(cacheClassFileImporter).importClasses(any(ImportOptions.class), anyCollection());
 
         JavaClasses classes = cache.getClassesToAnalyzeFor(TestClass.class, defaultOptions);
 
@@ -245,7 +245,7 @@ private ClassAnalysisRequest analyzeLocation(Class<? extends LocationProvider> p
     }
 
     private void verifyNumberOfImports(int number) {
-        verify(cacheClassFileImporter, times(number)).importClasses(any(ImportOptions.class), ArgumentMatchers.<Location>anyCollection());
+        verify(cacheClassFileImporter, times(number)).importClasses(any(ImportOptions.class), anyCollection());
         verifyNoMoreInteractions(cacheClassFileImporter);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaModifier.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.tngtech.archunit.core.domain;
 
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.Set;
 
@@ -25,6 +24,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 import static java.util.Arrays.stream;
+import static java.util.Collections.emptySet;
 import static java.util.stream.Collectors.toSet;
 
 public enum JavaModifier {
@@ -83,7 +83,7 @@ private static Set<JavaModifier> getModifiersFor(ApplicableType type, int asmAcc
                 .filter(modifier -> modifier.applicableTo.contains(type))
                 .filter(modifier -> modifierPresent(modifier, asmAccess))
                 .collect(toSet());
-        return result.isEmpty() ? Collections.<JavaModifier>emptySet() : Sets.immutableEnumSet(result);
+        return result.isEmpty() ? emptySet() : Sets.immutableEnumSet(result);
     }
 
     private static boolean modifierPresent(JavaModifier modifier, int asmAccess) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaPackage.java
Patch:
@@ -361,7 +361,7 @@ private Optional<JavaClass> tryGetClassWithSimpleName(String className) {
 
     private Optional<JavaClass> tryGetClassWith(DescribedPredicate<? super JavaClass> predicate) {
         Set<JavaClass> matching = getClassesWith(predicate);
-        return matching.size() == 1 ? Optional.of(getOnlyElement(matching)) : Optional.<JavaClass>empty();
+        return matching.size() == 1 ? Optional.of(getOnlyElement(matching)) : Optional.empty();
     }
 
     private Set<JavaClass> getClassesWith(Predicate<? super JavaClass> predicate) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ReverseDependencies.java
Patch:
@@ -244,7 +244,7 @@ public void visitAnnotation(String propertyName, JavaAnnotation<?> memberAnnotat
         }
 
         private Set<JavaAnnotation<?>> findAnnotations(JavaClass clazz) {
-            Set<JavaAnnotation<?>> result = Sets.<JavaAnnotation<?>>newHashSet(clazz.getAnnotations());
+            Set<JavaAnnotation<?>> result = Sets.newHashSet(clazz.getAnnotations());
             for (JavaMember member : clazz.getMembers()) {
                 result.addAll(member.getAnnotations());
             }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/SourceCodeLocation.java
Patch:
@@ -58,7 +58,7 @@ private static String formatLocation(String sourceFileName, int lineNumber) {
     private static String resolveSourceFileName(JavaClass sourceClass) {
         Optional<String> recordedSourceFileName = sourceClass.getSource().isPresent()
                 ? sourceClass.getSource().get().getFileName()
-                : Optional.<String>empty();
+                : Optional.empty();
         return recordedSourceFileName.isPresent() ? recordedSourceFileName.get() : guessSourceFileName(sourceClass);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/GenericMemberTypeProcessor.java
Patch:
@@ -45,7 +45,7 @@ Optional<JavaTypeCreationProcess<T>> getType() {
 
     @Override
     public void visitClassType(String internalObjectName) {
-        updateType(new JavaParameterizedTypeBuilder<T>(JavaClassDescriptorImporter.createFromAsmObjectTypeName(internalObjectName)));
+        updateType(new JavaParameterizedTypeBuilder<>(JavaClassDescriptorImporter.createFromAsmObjectTypeName(internalObjectName)));
     }
 
     @Override
@@ -60,7 +60,7 @@ public void visitInnerClassType(String name) {
 
     @Override
     public void visitTypeArgument() {
-        parameterizedType.addTypeArgument(new NewJavaTypeCreationProcess<>(new DomainBuilders.JavaWildcardTypeBuilder<T>()));
+        parameterizedType.addTypeArgument(new NewJavaTypeCreationProcess<>(new DomainBuilders.JavaWildcardTypeBuilder<>()));
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ImportOptions.java
Patch:
@@ -15,14 +15,14 @@
  */
 package com.tngtech.archunit.core.importer;
 
-import java.util.Collections;
 import java.util.Set;
 
 import com.google.common.collect.ImmutableSet;
 import com.tngtech.archunit.PublicAPI;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
+import static java.util.Collections.emptySet;
 
 /**
  * A collection of {@link ImportOption} to filter class locations. All supplied {@link ImportOption}s will be joined
@@ -34,7 +34,7 @@ public final class ImportOptions {
 
     @PublicAPI(usage = ACCESS)
     public ImportOptions() {
-        this(Collections.<ImportOption>emptySet());
+        this(emptySet());
     }
 
     private ImportOptions(Set<ImportOption> options) {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/SignatureTypeArgumentProcessor.java
Patch:
@@ -71,15 +71,15 @@ public void visitBaseType(char descriptor) {
     @Override
     public void visitTypeArgument() {
         log.trace("Encountered wildcard for {}", currentTypeArgument.getTypeName());
-        currentTypeArgument.addTypeArgument(new NewJavaTypeCreationProcess<>(new JavaWildcardTypeBuilder<TYPE>(), JavaTypeFinisher.IDENTITY));
+        currentTypeArgument.addTypeArgument(new NewJavaTypeCreationProcess<>(new JavaWildcardTypeBuilder<>(), JavaTypeFinisher.IDENTITY));
     }
 
     @Override
     public void visitTypeVariable(String name) {
         if (log.isTraceEnabled()) {
             log.trace("Encountered {} for {}: Type variable {}", typeArgumentType.description, parameterizedType.getTypeName(), typeFinisher.getFinishedName(name));
         }
-        typeArgumentType.addTypeArgumentToBuilder(parameterizedType, new ReferenceCreationProcess<TYPE>(name, typeFinisher));
+        typeArgumentType.addTypeArgumentToBuilder(parameterizedType, new ReferenceCreationProcess<>(name, typeFinisher));
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/core/importer/SignatureTypeParameterProcessor.java
Patch:
@@ -66,13 +66,13 @@ public void visitClassType(String internalObjectName) {
     @Override
     public void visitTypeArgument() {
         log.trace("Encountered wildcard for {}", currentBound.getTypeName());
-        currentBound.addTypeArgument(new NewJavaTypeCreationProcess<>(new JavaWildcardTypeBuilder<OWNER>()));
+        currentBound.addTypeArgument(new NewJavaTypeCreationProcess<>(new JavaWildcardTypeBuilder<>()));
     }
 
     @Override
     public void visitTypeVariable(String name) {
         log.trace("Encountered upper bound for {}: Type variable {}", currentType.getName(), name);
-        currentType.addBound(new ReferenceCreationProcess<OWNER>(name));
+        currentType.addBound(new ReferenceCreationProcess<>(name));
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/core/importer/UrlSource.java
Patch:
@@ -231,7 +231,7 @@ private static Optional<URL> newJarUrl(String path) {
             Optional<URL> fileUri = newFileUri(path);
 
             try {
-                return fileUri.isPresent() ? Optional.of(new URL("jar:" + fileUri.get() + "!/")) : Optional.<URL>empty();
+                return fileUri.isPresent() ? Optional.of(new URL("jar:" + fileUri.get() + "!/")) : Optional.empty();
             } catch (MalformedURLException e) {
                 LOG.warn("Cannot parse URL from path " + path, e);
                 return Optional.empty();

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/ClassResolverFromClasspath.java
Patch:
@@ -48,7 +48,7 @@ public Optional<JavaClass> tryResolve(String typeName) {
 
         Optional<URI> uri = tryGetUriOf(typeFile);
 
-        return uri.isPresent() ? classUriImporter.tryImport(uri.get()) : Optional.<JavaClass>empty();
+        return uri.isPresent() ? classUriImporter.tryImport(uri.get()) : Optional.empty();
     }
 
     private Optional<URI> tryGetUriOf(String typeFile) {

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AllDependenciesCondition.java
Patch:
@@ -26,6 +26,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysFalse;
 
 @PublicAPI(usage = ACCESS)
 public final class AllDependenciesCondition extends AllAttributesMatchCondition<Dependency, JavaClass> {
@@ -38,7 +39,7 @@ public final class AllDependenciesCondition extends AllAttributesMatchCondition<
             final DescribedPredicate<? super Dependency> predicate,
             Function<JavaClass, ? extends Collection<Dependency>> javaClassToRelevantDependencies) {
 
-        this(description, predicate, javaClassToRelevantDependencies, DescribedPredicate.<Dependency>alwaysFalse());
+        this(description, predicate, javaClassToRelevantDependencies, alwaysFalse());
     }
 
     private AllDependenciesCondition(

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AnyDependencyCondition.java
Patch:
@@ -26,6 +26,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysFalse;
 
 @PublicAPI(usage = ACCESS)
 public final class AnyDependencyCondition extends AnyAttributeMatchesCondition<Dependency> {
@@ -38,7 +39,7 @@ public final class AnyDependencyCondition extends AnyAttributeMatchesCondition<D
             final DescribedPredicate<? super Dependency> predicate,
             Function<JavaClass, ? extends Collection<Dependency>> javaClassToRelevantDependencies) {
 
-        this(description, predicate, javaClassToRelevantDependencies, DescribedPredicate.<Dependency>alwaysFalse());
+        this(description, predicate, javaClassToRelevantDependencies, alwaysFalse());
     }
 
     private AnyDependencyCondition(

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenCodeUnitsInternal.java
Patch:
@@ -71,8 +71,8 @@ static class GivenCodeUnitsInternal extends AbstractGivenCodeUnitsInternal<JavaC
                     priority,
                     classesTransformer,
                     prepareCondition,
-                    new PredicateAggregator<JavaCodeUnit>(),
-                    Optional.<String>empty());
+                    new PredicateAggregator<>(),
+                    Optional.empty());
         }
 
         private GivenCodeUnitsInternal(
@@ -93,7 +93,7 @@ public CodeUnitsShouldInternal should() {
 
         @Override
         public CodeUnitsShouldInternal should(ArchCondition<? super JavaCodeUnit> condition) {
-            return new CodeUnitsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaCodeUnit>forSubtype(), prepareCondition);
+            return new CodeUnitsShouldInternal(finishedClassesTransformer(), priority, condition.forSubtype(), prepareCondition);
         }
 
         private static class GivenCodeUnitsFactory implements Factory<JavaCodeUnit, GivenCodeUnitsInternal> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenMembersInternal.java
Patch:
@@ -73,8 +73,8 @@ static class GivenMembersInternal extends AbstractGivenMembersInternal<JavaMembe
                     priority,
                     classesTransformer,
                     prepareCondition,
-                    new PredicateAggregator<JavaMember>(),
-                    Optional.<String>empty());
+                    new PredicateAggregator<>(),
+                    Optional.empty());
         }
 
         private GivenMembersInternal(
@@ -90,7 +90,7 @@ private GivenMembersInternal(
 
         @Override
         public MembersShouldConjunction<JavaMember> should(ArchCondition<? super JavaMember> condition) {
-            return new MembersShouldInternal(finishedClassesTransformer(), priority, condition.<JavaMember>forSubtype(), prepareCondition);
+            return new MembersShouldInternal(finishedClassesTransformer(), priority, condition.forSubtype(), prepareCondition);
         }
 
         @Override

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassInternal.java
Patch:
@@ -44,6 +44,6 @@ public ClassesShould should() {
 
     @Override
     public ClassesShouldConjunction should(ArchCondition<? super JavaClass> condition) {
-        return new ClassesShouldInternal(classesTransformer, priority, condition.<JavaClass>forSubtype(), prepareCondition);
+        return new ClassesShouldInternal(classesTransformer, priority, condition.forSubtype(), prepareCondition);
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassesInternal.java
Patch:
@@ -37,7 +37,7 @@ class GivenClassesInternal extends AbstractGivenObjects<JavaClass, GivenClassesI
 
     GivenClassesInternal(Priority priority, ClassesTransformer<JavaClass> classesTransformer,
             Function<ArchCondition<JavaClass>, ArchCondition<JavaClass>> prepareCondition) {
-        this(priority, classesTransformer, prepareCondition, new PredicateAggregator<JavaClass>(), Optional.<String>empty());
+        this(priority, classesTransformer, prepareCondition, new PredicateAggregator<>(), Optional.empty());
     }
 
     private GivenClassesInternal(
@@ -74,7 +74,7 @@ public ClassesThat<GivenClassesConjunction> that() {
 
     @Override
     public ClassesShouldConjunction should(ArchCondition<? super JavaClass> condition) {
-        return new ClassesShouldInternal(finishedClassesTransformer(), priority, condition.<JavaClass>forSubtype(), prepareCondition);
+        return new ClassesShouldInternal(finishedClassesTransformer(), priority, condition.forSubtype(), prepareCondition);
     }
 
     private static class GivenClassesFactory implements Factory<JavaClass, GivenClassesInternal> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenConstructorsInternal.java
Patch:
@@ -41,8 +41,8 @@ class GivenConstructorsInternal extends AbstractGivenCodeUnitsInternal<JavaConst
                 priority,
                 classesTransformer,
                 prepareCondition,
-                new PredicateAggregator<JavaConstructor>(),
-                Optional.<String>empty());
+                new PredicateAggregator<>(),
+                Optional.empty());
     }
 
     private GivenConstructorsInternal(
@@ -63,7 +63,7 @@ public ConstructorsShouldInternal should() {
 
     @Override
     public ConstructorsShouldInternal should(ArchCondition<? super JavaConstructor> condition) {
-        return new ConstructorsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaConstructor>forSubtype(), prepareCondition);
+        return new ConstructorsShouldInternal(finishedClassesTransformer(), priority, condition.forSubtype(), prepareCondition);
     }
 
     private static class GivenConstructorsFactory implements Factory<JavaConstructor, GivenConstructorsInternal> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenFieldsInternal.java
Patch:
@@ -42,8 +42,8 @@ class GivenFieldsInternal
                 priority,
                 classesTransformer,
                 prepareCondition,
-                new PredicateAggregator<JavaField>(),
-                Optional.<String>empty());
+                new PredicateAggregator<>(),
+                Optional.empty());
     }
 
     private GivenFieldsInternal(
@@ -64,7 +64,7 @@ public FieldsShouldInternal should() {
 
     @Override
     public FieldsShouldInternal should(ArchCondition<? super JavaField> condition) {
-        return new FieldsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaField>forSubtype(), prepareCondition);
+        return new FieldsShouldInternal(finishedClassesTransformer(), priority, condition.forSubtype(), prepareCondition);
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenMethodsInternal.java
Patch:
@@ -42,8 +42,8 @@ class GivenMethodsInternal
                 priority,
                 classesTransformer,
                 prepareCondition,
-                new PredicateAggregator<JavaMethod>(),
-                Optional.<String>empty());
+                new PredicateAggregator<>(),
+                Optional.empty());
     }
 
     private GivenMethodsInternal(
@@ -79,7 +79,7 @@ public MethodsShouldInternal should() {
 
     @Override
     public MethodsShouldInternal should(ArchCondition<? super JavaMethod> condition) {
-        return new MethodsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaMethod>forSubtype(), prepareCondition);
+        return new MethodsShouldInternal(finishedClassesTransformer(), priority, condition.forSubtype(), prepareCondition);
     }
 
     private static class GivenMethodsFactory implements Factory<JavaMethod, GivenMethodsInternal> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenObjectsInternal.java
Patch:
@@ -33,7 +33,7 @@ class GivenObjectsInternal<T> extends AbstractGivenObjects<T, GivenObjectsIntern
     GivenObjectsInternal(Priority priority,
             ClassesTransformer<T> classesTransformer,
             Function<ArchCondition<T>, ArchCondition<T>> prepareCondition) {
-        this(priority, classesTransformer, prepareCondition, new PredicateAggregator<T>(), Optional.<String>empty());
+        this(priority, classesTransformer, prepareCondition, new PredicateAggregator<>(), Optional.empty());
     }
 
     private GivenObjectsInternal(
@@ -43,13 +43,13 @@ private GivenObjectsInternal(
             PredicateAggregator<T> relevantObjectsPredicates,
             Optional<String> overriddenDescription) {
 
-        super(new GivenObjectsFactory<T>(),
+        super(new GivenObjectsFactory<>(),
                 priority, classesTransformer, prepareCondition, relevantObjectsPredicates, overriddenDescription);
     }
 
     @Override
     public ArchRule should(ArchCondition<? super T> condition) {
-        return new ObjectsShouldInternal<>(finishedClassesTransformer(), priority, condition.<T>forSubtype(), prepareCondition);
+        return new ObjectsShouldInternal<>(finishedClassesTransformer(), priority, condition.forSubtype(), prepareCondition);
     }
 
     private static class GivenObjectsFactory<T> implements AbstractGivenObjects.Factory<T, GivenObjectsInternal<T>> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/PredicateAggregator.java
Patch:
@@ -26,7 +26,7 @@ public final class PredicateAggregator<T> {
     private final Optional<DescribedPredicate<T>> predicate;
 
     public PredicateAggregator() {
-        this(AddMode.<T>and(), Optional.<DescribedPredicate<T>>empty());
+        this(AddMode.and(), Optional.empty());
     }
 
     private PredicateAggregator(AddMode<T> addMode, Optional<DescribedPredicate<T>> predicate) {
@@ -47,11 +47,11 @@ public DescribedPredicate<T> get() {
     }
 
     public PredicateAggregator<T> thatANDs() {
-        return new PredicateAggregator<>(AddMode.<T>and(), predicate);
+        return new PredicateAggregator<>(AddMode.and(), predicate);
     }
 
     public PredicateAggregator<T> thatORs() {
-        return new PredicateAggregator<>(AddMode.<T>or(), predicate);
+        return new PredicateAggregator<>(AddMode.or(), predicate);
     }
 
     private abstract static class AddMode<T> {

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/GivenSlicesInternal.java
Patch:
@@ -41,7 +41,7 @@ class GivenSlicesInternal implements GivenSlices, SlicesShould, GivenSlicesConju
 
     @Override
     public ArchRule should(ArchCondition<? super Slice> condition) {
-        return ArchRule.Factory.create(classesTransformer, condition.<Slice>forSubtype(), priority);
+        return ArchRule.Factory.create(classesTransformer, condition.forSubtype(), priority);
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Path.java
Patch:
@@ -16,7 +16,6 @@
 package com.tngtech.archunit.library.dependencies;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.Objects;
@@ -26,12 +25,13 @@
 import com.google.common.collect.ImmutableSet;
 
 import static com.google.common.collect.Iterables.getLast;
+import static java.util.Collections.emptyList;
 
 class Path<T, ATTACHMENT> {
     private final List<Edge<T, ATTACHMENT>> edges;
 
     Path() {
-        this(Collections.<Edge<T, ATTACHMENT>>emptyList());
+        this(emptyList());
     }
 
     Path(Path<T, ATTACHMENT> other) {

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceIdentifier.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.tngtech.archunit.library.dependencies;
 
-import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 
@@ -27,6 +26,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
+import static java.util.Collections.emptyList;
 
 /**
  * A unique identifier of a {@link Slice}. All {@link JavaClasses} that are assigned to the same
@@ -85,6 +85,6 @@ public static SliceIdentifier of(List<String> parts) {
 
     @PublicAPI(usage = ACCESS)
     public static SliceIdentifier ignore() {
-        return new SliceIdentifier(Collections.<String>emptyList());
+        return new SliceIdentifier(emptyList());
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/ComponentIdentifier.java
Patch:
@@ -23,7 +23,7 @@ class ComponentIdentifier {
     private final Optional<Alias> alias;
 
     ComponentIdentifier(ComponentName componentName) {
-        this(componentName, Optional.<Alias>empty());
+        this(componentName, Optional.empty());
     }
 
     ComponentIdentifier(ComponentName componentName, Alias alias) {

File: archunit/src/test/java/com/tngtech/archunit/base/DescribedPredicateTest.java
Patch:
@@ -259,7 +259,7 @@ public void anyElementThat_works() {
                 .accepts(ImmutableList.of(-1, 0, 5, 6))
                 .accepts(ImmutableList.of(-1, 0, 5, 5, 6))
                 .rejects(ImmutableList.of(-1, 0, 6))
-                .rejects(ImmutableList.<Integer>of());
+                .rejects(ImmutableList.of());
     }
 
     @Test

File: archunit/src/test/java/com/tngtech/archunit/core/domain/FormattersTest.java
Patch:
@@ -3,7 +3,6 @@
 import java.io.Serializable;
 import java.lang.reflect.Array;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
@@ -26,6 +25,7 @@
 import static com.tngtech.java.junit.dataprovider.DataProviders.$;
 import static com.tngtech.java.junit.dataprovider.DataProviders.$$;
 import static java.util.Arrays.stream;
+import static java.util.Collections.emptyList;
 import static java.util.Collections.singleton;
 import static java.util.stream.Collectors.toList;
 
@@ -41,7 +41,7 @@ public void formatNamesOf() {
         assertThat(Formatters.formatNamesOf(List.class, Iterable.class, String.class))
                 .containsExactly(List.class.getName(), Iterable.class.getName(), String.class.getName());
 
-        assertThat(Formatters.formatNamesOf(Collections.<Class<?>>emptyList())).isEmpty();
+        assertThat(Formatters.formatNamesOf(emptyList())).isEmpty();
 
         assertThat(Formatters.formatNamesOf(of(List.class, Iterable.class, String.class)))
                 .containsExactly(List.class.getName(), Iterable.class.getName(), String.class.getName());

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaAccessTest.java
Patch:
@@ -7,6 +7,7 @@
 import com.tngtech.archunit.core.importer.testexamples.SomeEnum;
 import org.junit.Test;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysFalse;
 import static com.tngtech.archunit.core.domain.TestUtils.importClassWithContext;
 import static com.tngtech.archunit.core.domain.TestUtils.importClassesWithContext;
 import static com.tngtech.archunit.core.domain.TestUtils.newMethodCallBuilder;
@@ -53,7 +54,7 @@ public void origin_predicate() {
                 .hasDescription("origin some text")
                 .accepts(anyAccess());
 
-        predicate = JavaAccess.Predicates.origin(DescribedPredicate.<JavaCodeUnit>alwaysFalse());
+        predicate = JavaAccess.Predicates.origin(alwaysFalse());
         assertThat(predicate).rejects(anyAccess());
     }
 
@@ -105,4 +106,4 @@ TestJavaAccess inLineNumber(int lineNumber) {
             }
         }
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaAnnotationTest.java
Patch:
@@ -349,7 +349,7 @@ private static class ParametersStoringVisitor implements JavaAnnotation.Paramete
         private final Multimap<String, Object> visitedParameters;
 
         ParametersStoringVisitor() {
-            this("", HashMultimap.<String, Object>create());
+            this("", HashMultimap.create());
         }
 
         private ParametersStoringVisitor(String prefix, Multimap<String, Object> visitedParameters) {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassesTest.java
Patch:
@@ -1,6 +1,5 @@
 package com.tngtech.archunit.core.domain;
 
-import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
@@ -13,6 +12,7 @@
 import static com.tngtech.archunit.core.domain.TestUtils.importClassWithContext;
 import static com.tngtech.archunit.core.domain.TestUtils.importClassesWithContext;
 import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
+import static java.util.Collections.emptySet;
 import static java.util.Collections.singletonList;
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -49,7 +49,7 @@ public void creation_of_JavaClasses_from_existing_classes_should_keep_the_origin
 
     @Test
     public void creation_of_JavaClasses_from_empty_classes_should_create_empty_default_package() {
-        JavaClasses classes = JavaClasses.of(Collections.<JavaClass>emptySet());
+        JavaClasses classes = JavaClasses.of(emptySet());
 
         assertThat(classes.getDefaultPackage().getAllClasses()).isEmpty();
     }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaFieldAccessTest.java
Patch:
@@ -13,6 +13,7 @@
 import org.junit.runner.RunWith;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.core.domain.JavaFieldAccess.AccessType.GET;
 import static com.tngtech.archunit.core.domain.JavaFieldAccess.AccessType.SET;
 import static com.tngtech.archunit.core.domain.JavaFieldAccess.Predicates.accessType;
@@ -67,7 +68,7 @@ public void predicate_access_type(AccessType accessType) throws Exception {
 
     @Test
     public void predicate_field_access_target_by_predicate() throws Exception {
-        assertThat(target(DescribedPredicate.<FieldAccessTarget>alwaysTrue()))
+        assertThat(target(alwaysTrue()))
                 .accepts(stringFieldAccess(GET));
         assertThat(target(DescribedPredicate.<FieldAccessTarget>alwaysFalse().as("any message")))
                 .rejects(stringFieldAccess(GET))

File: archunit/src/test/java/com/tngtech/archunit/core/domain/SourceTest.java
Patch:
@@ -45,7 +45,7 @@ public void source_file_name() {
         Source source = new Source(uriOf(Object.class), Optional.of("SomeClass.java"), false);
         assertThat(source.getFileName()).as("source file name").contains("SomeClass.java");
 
-        source = new Source(uriOf(Object.class), Optional.<String>empty(), false);
+        source = new Source(uriOf(Object.class), Optional.empty(), false);
         assertThat(source.getFileName()).as("source file name").isEmpty();
     }
 
@@ -163,7 +163,7 @@ private Source newSource(URL url) throws URISyntaxException {
     }
 
     private Source newSource(URI uri) {
-        return new Source(uri, Optional.<String>empty(), true);
+        return new Source(uri, Optional.empty(), true);
     }
 
     private static Md5sum md5sumOf(String data) {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/TestUtils.java
Patch:
@@ -73,7 +73,7 @@ public static Md5sum md5sumOf(byte[] bytes) {
         File file = newTemporaryFile();
         try {
             Files.write(bytes, file);
-            return new Source(file.toURI(), Optional.<String>empty(), true).getMd5sum();
+            return new Source(file.toURI(), Optional.empty(), true).getMd5sum();
         } catch (IOException e) {
             throw new RuntimeException(e);
         }
@@ -111,7 +111,7 @@ public static MethodCallTarget resolvedTargetFrom(JavaMethod target) {
     }
 
     private static MethodCallTarget unresolvedTargetFrom(JavaMethod target) {
-        return ImportTestUtils.targetFrom(target, Optional::<JavaMethod>empty);
+        return ImportTestUtils.targetFrom(target, Optional::empty);
     }
 
     public static Class<?>[] asClasses(List<JavaClass> parameters) {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/CanBeAnnotatedTest.java
Patch:
@@ -12,6 +12,7 @@
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.core.domain.TestUtils.importClassWithContext;
 import static com.tngtech.archunit.core.domain.TestUtils.importClassesWithContext;
 import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
@@ -38,7 +39,7 @@ public void matches_annotation_by_type() {
 
     @Test
     public void matches_annotation_by_predicate() {
-        assertThat(annotatedWith(DescribedPredicate.<JavaAnnotation<?>>alwaysTrue()))
+        assertThat(annotatedWith(alwaysTrue()))
                 .accepts(importClassWithContext(AnnotatedClass.class));
         assertThat(annotatedWith(DescribedPredicate.<JavaAnnotation<?>>alwaysFalse().as("Something")))
                 .rejects(importClassWithContext(AnnotatedClass.class))
@@ -77,7 +78,7 @@ public void matches_meta_annotation_by_type() {
     public void matches_meta_annotation_by_predicate() {
         JavaClass clazz = importClassesWithContext(MetaAnnotatedClass.class, MetaRuntimeRetentionAnnotation.class).get(MetaAnnotatedClass.class);
 
-        assertThat(metaAnnotatedWith(DescribedPredicate.<JavaAnnotation<?>>alwaysTrue()))
+        assertThat(metaAnnotatedWith(alwaysTrue()))
                 .accepts(clazz);
         assertThat(metaAnnotatedWith(DescribedPredicate.<JavaAnnotation<?>>alwaysFalse().as("Something")))
                 .rejects(clazz)

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasParameterTypesTest.java
Patch:
@@ -9,6 +9,7 @@
 import com.tngtech.archunit.core.domain.JavaType;
 import org.junit.Test;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.core.domain.TestUtils.importClassesWithContext;
 import static com.tngtech.archunit.core.domain.properties.HasParameterTypes.Predicates.rawParameterTypes;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
@@ -42,7 +43,7 @@ public void predicate_on_parameters_by_String() {
     public void predicate_on_parameters_by_Predicate() {
         HasParameterTypes hasParameterTypes = newHasParameterTypes(String.class, Serializable.class);
 
-        assertThat(rawParameterTypes(DescribedPredicate.<List<JavaClass>>alwaysTrue()))
+        assertThat(rawParameterTypes(alwaysTrue()))
                 .accepts(hasParameterTypes);
         assertThat(rawParameterTypes(DescribedPredicate.<List<JavaClass>>alwaysFalse().as("some text")))
                 .rejects(hasParameterTypes)

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasReturnTypeTest.java
Patch:
@@ -5,6 +5,7 @@
 import com.tngtech.archunit.core.domain.JavaType;
 import org.junit.Test;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.core.domain.TestUtils.importClassWithContext;
 import static com.tngtech.archunit.core.domain.properties.HasReturnType.Functions.GET_RAW_RETURN_TYPE;
 import static com.tngtech.archunit.core.domain.properties.HasReturnType.Functions.GET_RETURN_TYPE;
@@ -38,7 +39,7 @@ public void predicate_on_return_type_by_String() {
     public void predicate_on_return_type_by_Predicate() {
         HasReturnType hasReturnTypeString = newHasReturnType(importClassWithContext(String.class));
 
-        assertThat(rawReturnType(DescribedPredicate.<JavaClass>alwaysTrue()))
+        assertThat(rawReturnType(alwaysTrue()))
                 .accepts(hasReturnTypeString);
         assertThat(rawReturnType(DescribedPredicate.<JavaClass>alwaysFalse().as("some text")))
                 .rejects(hasReturnTypeString)

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasThrowsClauseTest.java
Patch:
@@ -10,6 +10,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.core.domain.Formatters.formatNamesOf;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.equivalentTo;
 import static com.tngtech.archunit.core.domain.TestUtils.throwsClause;
@@ -65,7 +66,7 @@ public void predicate_containing_type(DescribedPredicate<HasThrowsClause<?>> pre
     public void predicate_on_parameters_by_Predicate() {
         HasThrowsClause<?> hasThrowsClause = newHasThrowsClause(FirstException.class, SecondException.class);
 
-        assertThat(HasThrowsClause.Predicates.throwsClause(DescribedPredicate.<ThrowsClause<?>>alwaysTrue()))
+        assertThat(HasThrowsClause.Predicates.throwsClause(alwaysTrue()))
                 .accepts(hasThrowsClause);
         assertThat(HasThrowsClause.Predicates.throwsClause(DescribedPredicate.<ThrowsClause<?>>alwaysFalse().as("some text")))
                 .rejects(hasThrowsClause)

File: archunit/src/test/java/com/tngtech/archunit/core/domain/testobjects/DependenciesOnClassObjects.java
Patch:
@@ -16,7 +16,7 @@ public class DependenciesOnClassObjects {
         List<Class<?>> referencedClassObjectsInStaticInitializer = ImmutableList.of(FilterInputStream.class, Buffer.class);
     }
 
-    List<Class<?>> referencedClassObjectsInConstructor = ImmutableList.<Class<?>>of(File.class, Path.class);
+    List<Class<?>> referencedClassObjectsInConstructor = ImmutableList.of(File.class, Path.class);
 
     List<Class<?>> referencedClassObjectsInMethod() {
         return ImmutableList.of(FileSystem.class, Charset.class);

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterAnnotationsTest.java
Patch:
@@ -3,7 +3,6 @@
 import java.io.Serializable;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
@@ -47,6 +46,7 @@
 import static com.tngtech.archunit.testutil.Assertions.assertThatAnnotation;
 import static com.tngtech.archunit.testutil.Assertions.assertThatAnnotations;
 import static com.tngtech.archunit.testutil.Assertions.assertThatType;
+import static java.util.Collections.emptySet;
 
 @RunWith(DataProviderRunner.class)
 public class ClassFileImporterAnnotationsTest {
@@ -400,7 +400,7 @@ public void imports_empty_parameter_annotations_for_method_without_annotated_par
             assertThat(parameter.getAnnotations()).isEmpty();
         }
         assertThat(method.getParameterAnnotations()).containsExactly(
-                Collections.<JavaAnnotation<JavaParameter>>emptySet(), Collections.<JavaAnnotation<JavaParameter>>emptySet());
+                emptySet(), emptySet());
     }
 
     @Test
@@ -574,7 +574,7 @@ void notToFind() {
             assertThatAnnotation(annotation).hasType(ParameterAnnotation.class);
         }
 
-        Set<JavaAnnotation<?>> expected = ImmutableSet.<JavaAnnotation<?>>of(
+        Set<JavaAnnotation<?>> expected = ImmutableSet.of(
                 classes.get(Dependent.class).getAnnotationOfType(ParameterAnnotation.class.getName()),
                 classes.get(Dependent.class).getField("field").getAnnotationOfType(ParameterAnnotation.class.getName()),
                 classes.get(Dependent.class).getConstructor(getClass()).getAnnotationOfType(ParameterAnnotation.class.getName()),

File: archunit/src/test/java/com/tngtech/archunit/core/importer/DependencyResolutionProcessTestUtils.java
Patch:
@@ -43,7 +43,7 @@ private ImporterWithAdjustedResolutionRuns(Set<String> propertyNames, Optional<I
         }
 
         static ImporterWithAdjustedResolutionRuns disableAllIterationsExcept(String... propertyNames) {
-            return new ImporterWithAdjustedResolutionRuns(ImmutableSet.copyOf(propertyNames), Optional.<Integer>empty());
+            return new ImporterWithAdjustedResolutionRuns(ImmutableSet.copyOf(propertyNames), Optional.empty());
         }
 
         static ImporterWithAdjustedResolutionRuns disableAllIterationsExcept(String propertyName, int number) {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/referencedclassobjects/ReferencingClassObjects.java
Patch:
@@ -16,7 +16,7 @@ public class ReferencingClassObjects {
         List<Class<?>> referencedClassObjectsInStaticInitializer = ImmutableList.of(FilterInputStream.class, Buffer.class);
     }
 
-    List<Class<?>> referencedClassObjectsInConstructor = ImmutableList.<Class<?>>of(File.class, Path.class);
+    List<Class<?>> referencedClassObjectsInConstructor = ImmutableList.of(File.class, Path.class);
 
     List<Class<?>> referencedClassObjectsInMethod() {
         return ImmutableList.of(FileSystem.class, Charset.class);

File: archunit/src/test/java/com/tngtech/archunit/lang/ArchRuleTest.java
Patch:
@@ -9,7 +9,6 @@
 import com.google.common.base.Joiner;
 import com.google.common.base.Splitter;
 import com.google.common.io.Files;
-import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.domain.JavaClassesTest;
@@ -26,6 +25,7 @@
 import org.junit.rules.ExpectedException;
 
 import static com.google.common.collect.Lists.newArrayList;
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysFalse;
 import static com.tngtech.archunit.core.domain.Formatters.joinSingleQuoted;
 import static com.tngtech.archunit.core.domain.TestUtils.importClasses;
 import static com.tngtech.archunit.core.domain.TestUtils.importClassesWithContext;
@@ -182,7 +182,7 @@ public void evaluation_fails_because_of_empty_set_of_elements_after_that_clause_
         thrown.expectMessage("failed to check any classes");
         thrown.expectMessage(FAIL_ON_EMPTY_SHOULD_PROPERTY_NAME);
 
-        createPassingArchRule(strings().that(DescribedPredicate.<String>alwaysFalse())).evaluate(importClasses(SomeClass.class));
+        createPassingArchRule(strings().that(alwaysFalse())).evaluate(importClasses(SomeClass.class));
     }
 
     @Test
@@ -208,7 +208,7 @@ private ArchRule createPassingArchRule() {
     }
 
     private <T> ArchRule createPassingArchRule(ClassesTransformer<T> classesTransformer) {
-        return ArchRule.Factory.create(classesTransformer, ALWAYS_BE_VALID.<T>forSubtype(), Priority.MEDIUM);
+        return ArchRule.Factory.create(classesTransformer, ALWAYS_BE_VALID.forSubtype(), Priority.MEDIUM);
     }
 
     private ClassesTransformer<String> strings() {

File: archunit/src/test/java/com/tngtech/archunit/lang/CompositeArchRuleTest.java
Patch:
@@ -3,7 +3,6 @@
 import java.util.List;
 
 import com.google.common.collect.ImmutableList;
-import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
@@ -15,6 +14,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysFalse;
 import static com.tngtech.archunit.core.domain.TestUtils.importClasses;
 import static com.tngtech.archunit.lang.Priority.HIGH;
 import static com.tngtech.archunit.lang.Priority.MEDIUM;
@@ -115,7 +115,7 @@ public void allows_empty_should_if_overridden_by_rule() {
     private static CompositeArchRule compositeRuleWithPartialEmptyShould() {
         return CompositeArchRule
                 .of(classes().should().bePublic())
-                .and(classes().that(DescribedPredicate.<JavaClass>alwaysFalse()).should().bePublic());
+                .and(classes().that(alwaysFalse()).should().bePublic());
     }
 
     private void assertPriority(String failureMessage, Priority priority) {

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/ArchConditionsTest.java
Patch:
@@ -14,6 +14,7 @@
 import com.tngtech.archunit.lang.ConditionEvents;
 import org.junit.Test;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysFalse;
 import static com.tngtech.archunit.core.domain.JavaCall.Predicates.target;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.type;
@@ -106,7 +107,7 @@ public void only_have_dependents_where() {
         JavaClasses classes = importClasses(CallingClass.class, SomeClass.class);
         JavaClass accessedClass = classes.get(SomeClass.class);
 
-        assertThat(onlyHaveDependentsWhere(DescribedPredicate.<Dependency>alwaysFalse()))
+        assertThat(onlyHaveDependentsWhere(alwaysFalse()))
                 .checking(accessedClass)
                 .haveAtLeastOneViolationMessageMatching(String.format(".*%s.*%s.*",
                         quote(CallingClass.class.getName()), quote(SomeClass.class.getName())));

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/GraphTest.java
Patch:
@@ -1,7 +1,6 @@
 package com.tngtech.archunit.library.dependencies;
 
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import java.util.Random;
 import java.util.Set;
@@ -20,6 +19,7 @@
 import static com.google.common.collect.Sets.cartesianProduct;
 import static com.tngtech.archunit.library.dependencies.CycleConfiguration.MAX_NUMBER_OF_CYCLES_TO_DETECT_PROPERTY_NAME;
 import static java.util.Arrays.asList;
+import static java.util.Collections.emptySet;
 import static java.util.Collections.singleton;
 import static java.util.Collections.singletonList;
 import static java.util.stream.Collectors.toSet;
@@ -237,6 +237,6 @@ static Set<Edge<String, String>> singleEdge(String from, String to) {
     }
 
     static <NODE, ATTACHMENT> Edge<NODE, ATTACHMENT> newEdge(NODE from, NODE to) {
-        return new Edge<>(from, to, Collections.<ATTACHMENT>emptySet());
+        return new Edge<>(from, to, emptySet());
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/SlicesShouldTest.java
Patch:
@@ -21,6 +21,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.library.dependencies.GivenSlicesTest.TEST_CLASSES_PACKAGE;
 import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
 import static com.tngtech.java.junit.dataprovider.DataProviders.$;
@@ -49,7 +50,7 @@ public void slice_rules_should_ignore_configured_dependencies(SliceRule rule) {
                 .contain(SecondAnyClass.class, FirstAnyPkgClass.class)
                 .contain(SecondThreeAnyClass.class, SomePkgClass.class);
 
-        rule = rule.ignoreDependency(classIn(".*\\.first\\.three\\..*"), DescribedPredicate.<JavaClass>alwaysTrue());
+        rule = rule.ignoreDependency(classIn(".*\\.first\\.three\\..*"), alwaysTrue());
         assertViolations(classes, rule)
                 .doNotContain(FirstThreeAnyClass.class, SecondThreeAnyClass.class)
                 .contain(FirstAnyPkgClass.class, SomePkgSubclass.class)
@@ -70,7 +71,7 @@ public void slice_rules_should_ignore_configured_dependencies(SliceRule rule) {
                 .doNotContain(SecondAnyClass.class, FirstAnyPkgClass.class)
                 .contain(SecondThreeAnyClass.class, SomePkgClass.class);
 
-        rule = rule.ignoreDependency(DescribedPredicate.<JavaClass>alwaysTrue(), classIn(".*\\.some\\.pkg\\..*"));
+        rule = rule.ignoreDependency(alwaysTrue(), classIn(".*\\.some\\.pkg\\..*"));
         assertViolations(classes, rule)
                 .doNotContain(FirstThreeAnyClass.class, SecondThreeAnyClass.class)
                 .doNotContain(FirstAnyPkgClass.class, SomePkgSubclass.class)

File: archunit/src/test/java/com/tngtech/archunit/library/freeze/TextFileBasedViolationStoreTest.java
Patch:
@@ -92,7 +92,7 @@ public void reads_violations_of_single_rule_from_configured_folder() {
 
     @Test
     public void reads_empty_list_of_violations() {
-        store.save(defaultRule(), ImmutableList.<String>of());
+        store.save(defaultRule(), ImmutableList.of());
 
         List<String> storedViolations = store.getViolations(defaultRule());
 

File: archunit/src/test/java/com/tngtech/archunit/library/metrics/ComponentDependencyMetricsTest.java
Patch:
@@ -129,7 +129,7 @@ public void normalized_distance_from_main_sequence_is_calculated_as_distance_fro
 
     @Test
     public void rejects_requesting_metrics_of_unknown_component() {
-        final ComponentDependencyMetrics metrics = ArchitectureMetrics.componentDependencyMetrics(MetricsComponents.<JavaClass>of());
+        final ComponentDependencyMetrics metrics = ArchitectureMetrics.componentDependencyMetrics(MetricsComponents.of());
 
         List<ThrowingCallable> callables = ImmutableList.of(
                 () -> metrics.getEfferentCoupling("unknown"),

File: archunit/src/test/java/com/tngtech/archunit/testutil/OutsideOfClassPathRule.java
Patch:
@@ -8,7 +8,6 @@
 import java.nio.file.Path;
 import java.nio.file.SimpleFileVisitor;
 import java.nio.file.attribute.BasicFileAttributes;
-import java.util.Collections;
 import java.util.List;
 import java.util.function.Predicate;
 
@@ -24,6 +23,7 @@
 import static com.tngtech.archunit.testutil.TestUtils.newTemporaryFolder;
 import static com.tngtech.archunit.testutil.TestUtils.toUri;
 import static java.nio.file.Files.createDirectories;
+import static java.util.Collections.emptyList;
 
 public class OutsideOfClassPathRule extends ExternalResource {
     private final TemporaryFolder temporaryFolder = new TemporaryFolder(newTemporaryFolder());
@@ -43,7 +43,7 @@ public OutsideOfClassPathRule onlyKeep(Predicate<? super String> fileNamePredica
     }
 
     public Path setUp(URL folder) throws IOException {
-        return setUp(folder, Collections.<String>emptyList());
+        return setUp(folder, emptyList());
     }
 
     public Path setUp(URL folder, List<String> subfolder) throws IOException {

File: archunit/src/test/java/com/tngtech/archunit/testutil/syntax/MethodCallChainTest.java
Patch:
@@ -1,7 +1,5 @@
 package com.tngtech.archunit.testutil.syntax;
 
-import java.util.Collections;
-
 import com.tngtech.archunit.testutil.syntax.callchainexamples.fivestepswithgenericshierarchy.FiveStepsHierarchyImplementationStep1;
 import com.tngtech.archunit.testutil.syntax.callchainexamples.fivestepswithgenericshierarchy.FiveStepsHierarchyImplementationStep2;
 import com.tngtech.archunit.testutil.syntax.callchainexamples.fivestepswithgenericshierarchy.FiveStepsHierarchyImplementationStep3;
@@ -38,6 +36,7 @@
 
 import static com.tngtech.archunit.testutil.syntax.MethodChoiceStrategy.chooseAllArchUnitSyntaxMethods;
 import static com.tngtech.java.junit.dataprovider.DataProviders.testForEach;
+import static java.util.Collections.emptyList;
 import static org.assertj.core.api.Assertions.assertThat;
 
 @RunWith(DataProviderRunner.class)
@@ -115,7 +114,7 @@ private <T> MethodCallChain createCallChainStart(Class<T> startInterface, T star
     }
 
     private void invokeNext(MethodCallChain callChain) {
-        callChain.invokeNextMethodCandidate(new Parameters(Collections.<Parameter>emptyList()), false);
+        callChain.invokeNextMethodCandidate(new Parameters(emptyList()), false);
     }
 
     private static class CallChainTestCase<T> {

File: archunit/src/test/java/com/tngtech/archunit/testutil/syntax/PropagatedType.java
Patch:
@@ -3,13 +3,13 @@
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
-import java.util.Collections;
 import java.util.Map;
 
 import com.google.common.collect.ImmutableMap;
 import com.google.common.reflect.TypeToken;
 
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Collections.emptyMap;
 
 class PropagatedType {
     private final Type type;
@@ -30,7 +30,7 @@ private Map<String, Type> getTypeVariables(Type type, Context context) {
         } else if (type instanceof ParameterizedType) {
             return resolveTypeVariables((ParameterizedType) type, context);
         } else {
-            return Collections.emptyMap();
+            return emptyMap();
         }
     }
 
@@ -104,7 +104,7 @@ static Context forType(PropagatedType type) {
         }
 
         static Context empty() {
-            return new Context(Collections.<String, Type>emptyMap());
+            return new Context(emptyMap());
         }
 
         Type resolve(Type type) {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileProcessor.java
Patch:
@@ -299,7 +299,7 @@ public void onTryCatchBlocksFinished(Set<TryCatchBlockBuilder> tryCatchBlocks) {
             importRecord.addTryCatchBlocks(codeUnit.getDeclaringClassName(), codeUnit.getName(), codeUnit.getDescriptor(), tryCatchBlocks);
         }
 
-        private <BUILDER extends RawAccessRecord.BaseBuilder<BUILDER>> BUILDER filled(BUILDER builder, TargetInfo target) {
+        private <BUILDER extends RawAccessRecord.BaseBuilder<?, BUILDER>> BUILDER filled(BUILDER builder, TargetInfo target) {
             return builder
                     .withCaller(codeUnit)
                     .withTarget(target)

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/AccessesAssertion.java
Patch:
@@ -25,7 +25,7 @@ public AccessesAssertion contain(Condition<? super JavaAccess<?>> condition) {
                 return this;
             }
         }
-        throw new AssertionError("No access matches " + condition);
+        throw new AssertionError("No access matches " + condition + " within " + actualRemaining);
     }
 
     @SafeVarargs

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/AccessesAssertion.java
Patch:
@@ -25,7 +25,7 @@ public AccessesAssertion contain(Condition<? super JavaAccess<?>> condition) {
                 return this;
             }
         }
-        throw new AssertionError("No access matches " + condition);
+        throw new AssertionError("No access matches " + condition + " within " + actualRemaining);
     }
 
     @SafeVarargs

File: archunit/src/test/java/com/tngtech/archunit/lang/ArchConditionTest.java
Patch:
@@ -69,7 +69,7 @@ public void and_handles_each_violating_object_separately() {
         ConditionEvents events = new ConditionEvents();
         condition.check(2, events);
         final List<HandledViolation> handledViolations = new ArrayList<>();
-        evaluationResultOf(events).handleViolations((ViolationHandler<Integer>) (violatingObjects, message) ->
+        evaluationResultOf(events).handleViolations((Collection<Integer> violatingObjects, String message) ->
                 handledViolations.add(new HandledViolation(violatingObjects, message)));
 
         assertThat(handledViolations).containsOnly(
@@ -113,7 +113,7 @@ public void or_handles_all_violated_conditions_as_unit() {
         ConditionEvents events = new ConditionEvents();
         condition.check(1, events);
         final List<HandledViolation> handledViolations = new ArrayList<>();
-        evaluationResultOf(events).handleViolations((ViolationHandler<Integer>) (violatingObjects, message) ->
+        evaluationResultOf(events).handleViolations((Collection<Integer> violatingObjects, String message) ->
                 handledViolations.add(new HandledViolation(violatingObjects, message)));
 
         assertThat(handledViolations).containsOnly(new HandledViolation(

File: archunit/src/test/java/com/tngtech/archunit/lang/handling/ViolationHandlingTest.java
Patch:
@@ -121,6 +121,7 @@ private Condition<JavaAccess<?>> accessToTargetField(String fieldOne) {
                 .to(Target.class, fieldOne);
     }
 
+    @SuppressWarnings("unused")
     private static class Origin {
         Target target;
 
@@ -141,6 +142,7 @@ void callConstructor() {
         }
     }
 
+    @SuppressWarnings("unused")
     private static class Target {
         String fieldOne;
         Object fieldTwo;

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MembersThat.java
Patch:
@@ -469,13 +469,13 @@ public interface MembersThat<CONJUNCTION> {
      * E.g. <code>someField</code> in
      *
      * <pre><code>
-     * class Example {
+     * class Example implements Serializable {
      *     Object someField;
      * }</code></pre>
      *
      * will be matched by
      * <pre><code>
-     * {@link ArchRuleDefinition#members() members()}.{@link GivenMembers#that() that()}.{@link MembersThat#areDeclaredInClassesThat(DescribedPredicate) areDeclaredInClassesThat(areSubtypeOf(Object.class))}
+     * {@link ArchRuleDefinition#members() members()}.{@link GivenMembers#that() that()}.{@link MembersThat#areDeclaredInClassesThat(DescribedPredicate) areDeclaredInClassesThat(are(assignableTo(Serializable.class)))}
      * </code></pre>
      *
      * @param predicate A predicate which matches classes where members have to be declared in

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/LayeredArchitectureTest.java
Patch:
@@ -16,7 +16,7 @@
 @AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class LayeredArchitectureTest {
     @ArchTest
-    public static final ArchRule layer_dependencies_are_respected = layeredArchitecture()
+    public static final ArchRule layer_dependencies_are_respected = layeredArchitecture().consideringAllDependencies()
 
             .layer("Controllers").definedBy("com.tngtech.archunit.example.layers.controller..")
             .layer("Services").definedBy("com.tngtech.archunit.example.layers.service..")
@@ -27,7 +27,7 @@ public class LayeredArchitectureTest {
             .whereLayer("Persistence").mayOnlyBeAccessedByLayers("Services");
 
     @ArchTest
-    public static final ArchRule layer_dependencies_are_respected_with_exception = layeredArchitecture()
+    public static final ArchRule layer_dependencies_are_respected_with_exception = layeredArchitecture().consideringAllDependencies()
 
             .layer("Controllers").definedBy("com.tngtech.archunit.example.layers.controller..")
             .layer("Services").definedBy("com.tngtech.archunit.example.layers.service..")

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/LayeredArchitectureTest.java
Patch:
@@ -13,7 +13,7 @@
 @AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class LayeredArchitectureTest {
     @ArchTest
-    static final ArchRule layer_dependencies_are_respected = layeredArchitecture()
+    static final ArchRule layer_dependencies_are_respected = layeredArchitecture().consideringAllDependencies()
 
             .layer("Controllers").definedBy("com.tngtech.archunit.example.layers.controller..")
             .layer("Services").definedBy("com.tngtech.archunit.example.layers.service..")
@@ -24,7 +24,7 @@ public class LayeredArchitectureTest {
             .whereLayer("Persistence").mayOnlyBeAccessedByLayers("Services");
 
     @ArchTest
-    static final ArchRule layer_dependencies_are_respected_with_exception = layeredArchitecture()
+    static final ArchRule layer_dependencies_are_respected_with_exception = layeredArchitecture().consideringAllDependencies()
 
             .layer("Controllers").definedBy("com.tngtech.archunit.example.layers.controller..")
             .layer("Services").definedBy("com.tngtech.archunit.example.layers.service..")

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/LayeredArchitectureTest.java
Patch:
@@ -15,7 +15,7 @@ public class LayeredArchitectureTest {
 
     @Test
     public void layer_dependencies_are_respected() {
-        layeredArchitecture()
+        layeredArchitecture().consideringAllDependencies()
 
                 .layer("Controllers").definedBy("com.tngtech.archunit.example.layers.controller..")
                 .layer("Services").definedBy("com.tngtech.archunit.example.layers.service..")
@@ -30,7 +30,7 @@ public void layer_dependencies_are_respected() {
 
     @Test
     public void layer_dependencies_are_respected_with_exception() {
-        layeredArchitecture()
+        layeredArchitecture().consideringAllDependencies()
 
                 .layer("Controllers").definedBy("com.tngtech.archunit.example.layers.controller..")
                 .layer("Services").definedBy("com.tngtech.archunit.example.layers.service..")

File: archunit-integration-test/src/test/java/com/tngtech/archunit/ArchUnitArchitectureTest.java
Patch:
@@ -43,7 +43,7 @@ public class ArchUnitArchitectureTest {
     static final String THIRDPARTY_PACKAGE_IDENTIFIER = "..thirdparty..";
 
     @ArchTest
-    public static final ArchRule layers_are_respected = layeredArchitecture()
+    public static final ArchRule layers_are_respected = layeredArchitecture().consideringAllDependencies()
             .layer("Root").definedBy("com.tngtech.archunit")
             .layer("Base").definedBy("com.tngtech.archunit.base..")
             .layer("Core").definedBy("com.tngtech.archunit.core..")

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/ExamplesIntegrationTest.java
Patch:
@@ -935,7 +935,7 @@ Stream<DynamicTest> LayeredArchitectureTest() {
                 (memberName, expectedTestFailures) ->
                         expectedTestFailures
                                 .ofRule(memberName,
-                                        "Layered architecture consisting of" + lineSeparator() +
+                                        "Layered architecture considering all dependencies, consisting of" + lineSeparator() +
                                                 "layer 'Controllers' ('com.tngtech.archunit.example.layers.controller..')" + lineSeparator() +
                                                 "layer 'Services' ('com.tngtech.archunit.example.layers.service..')" + lineSeparator() +
                                                 "layer 'Persistence' ('com.tngtech.archunit.example.layers.persistence..')" + lineSeparator() +

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/PlantUmlArchitectureTest.java
Patch:
@@ -17,9 +17,9 @@
 import static com.tngtech.archunit.core.domain.JavaClass.Functions.GET_PACKAGE_NAME;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.equivalentTo;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringAllDependencies;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringOnlyDependenciesInAnyPackage;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringOnlyDependenciesInDiagram;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringAllDependencies;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringOnlyDependenciesInAnyPackage;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringOnlyDependenciesInDiagram;
 import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.adhereToPlantUmlDiagram;
 
 @Category(Example.class)

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/PlantUmlArchitectureTest.java
Patch:
@@ -15,9 +15,9 @@
 import static com.tngtech.archunit.core.domain.JavaClass.Functions.GET_PACKAGE_NAME;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.equivalentTo;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringAllDependencies;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringOnlyDependenciesInAnyPackage;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringOnlyDependenciesInDiagram;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringAllDependencies;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringOnlyDependenciesInAnyPackage;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringOnlyDependenciesInDiagram;
 import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.adhereToPlantUmlDiagram;
 
 @ArchTag("example")

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/PlantUmlArchitectureTest.java
Patch:
@@ -15,9 +15,9 @@
 import static com.tngtech.archunit.core.domain.JavaClass.Functions.GET_PACKAGE_NAME;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.equivalentTo;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringAllDependencies;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringOnlyDependenciesInAnyPackage;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringOnlyDependenciesInDiagram;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringAllDependencies;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringOnlyDependenciesInAnyPackage;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringOnlyDependenciesInDiagram;
 import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.adhereToPlantUmlDiagram;
 
 @Category(Example.class)

File: archunit/src/test/java/com/tngtech/archunit/library/plantuml/PlantUmlArchConditionTest.java
Patch:
@@ -35,9 +35,9 @@
 import static com.tngtech.archunit.core.domain.TestUtils.importClasses;
 import static com.tngtech.archunit.lang.ArchRule.Assertions.assertNoViolation;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringAllDependencies;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringOnlyDependenciesInAnyPackage;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringOnlyDependenciesInDiagram;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringAllDependencies;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringOnlyDependenciesInAnyPackage;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringOnlyDependenciesInDiagram;
 import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.adhereToPlantUmlDiagram;
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.assertj.core.api.Assertions.assertThat;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/PlantUmlArchitectureTest.java
Patch:
@@ -17,9 +17,9 @@
 import static com.tngtech.archunit.core.domain.JavaClass.Functions.GET_PACKAGE_NAME;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.equivalentTo;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringAllDependencies;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringOnlyDependenciesInAnyPackage;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringOnlyDependenciesInDiagram;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringAllDependencies;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringOnlyDependenciesInAnyPackage;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringOnlyDependenciesInDiagram;
 import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.adhereToPlantUmlDiagram;
 
 @Category(Example.class)

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/PlantUmlArchitectureTest.java
Patch:
@@ -15,9 +15,9 @@
 import static com.tngtech.archunit.core.domain.JavaClass.Functions.GET_PACKAGE_NAME;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.equivalentTo;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringAllDependencies;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringOnlyDependenciesInAnyPackage;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringOnlyDependenciesInDiagram;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringAllDependencies;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringOnlyDependenciesInAnyPackage;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringOnlyDependenciesInDiagram;
 import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.adhereToPlantUmlDiagram;
 
 @ArchTag("example")

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/PlantUmlArchitectureTest.java
Patch:
@@ -15,9 +15,9 @@
 import static com.tngtech.archunit.core.domain.JavaClass.Functions.GET_PACKAGE_NAME;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.equivalentTo;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringAllDependencies;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringOnlyDependenciesInAnyPackage;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringOnlyDependenciesInDiagram;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringAllDependencies;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringOnlyDependenciesInAnyPackage;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringOnlyDependenciesInDiagram;
 import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.adhereToPlantUmlDiagram;
 
 @Category(Example.class)

File: archunit/src/test/java/com/tngtech/archunit/library/plantuml/PlantUmlArchConditionTest.java
Patch:
@@ -35,9 +35,9 @@
 import static com.tngtech.archunit.core.domain.TestUtils.importClasses;
 import static com.tngtech.archunit.lang.ArchRule.Assertions.assertNoViolation;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringAllDependencies;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringOnlyDependenciesInAnyPackage;
-import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configurations.consideringOnlyDependenciesInDiagram;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringAllDependencies;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringOnlyDependenciesInAnyPackage;
+import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.Configuration.consideringOnlyDependenciesInDiagram;
 import static com.tngtech.archunit.library.plantuml.PlantUmlArchCondition.adhereToPlantUmlDiagram;
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.assertj.core.api.Assertions.assertThat;

File: archunit/src/test/java/com/tngtech/archunit/core/domain/testobjects/AReferencingB.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.domain.testexamples;
+package com.tngtech.archunit.core.domain.testobjects;
 
 import java.util.function.Function;
 import java.util.function.Supplier;

File: archunit/src/test/java/com/tngtech/archunit/core/domain/testobjects/BReferencedByA.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.domain.testexamples;
+package com.tngtech.archunit.core.domain.testobjects;
 
 public class BReferencedByA {
     String someField;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/annotationresolution/AnotherAnnotationWithAnnotationParameter.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.importer.testexamples.annotations;
+package com.tngtech.archunit.core.importer.testexamples.annotationresolution;
 
 public @interface AnotherAnnotationWithAnnotationParameter {
     SomeAnnotationWithAnnotationParameter value();

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/annotationresolution/SomeAnnotationWithAnnotationParameter.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.importer.testexamples.annotations;
+package com.tngtech.archunit.core.importer.testexamples.annotationresolution;
 
 public @interface SomeAnnotationWithAnnotationParameter {
     SomeAnnotationWithClassParameter value();

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/annotationresolution/SomeAnnotationWithClassParameter.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.importer.testexamples.annotations;
+package com.tngtech.archunit.core.importer.testexamples.annotationresolution;
 
 public @interface SomeAnnotationWithClassParameter {
     Class<?> value();

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyresolution/Child.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.importer.testexamples.classhierarchy;
+package com.tngtech.archunit.core.importer.testexamples.classhierarchyresolution;
 
 public class Child extends Parent implements ParentInterfaceDirect {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyresolution/GrandParent.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.importer.testexamples.classhierarchy;
+package com.tngtech.archunit.core.importer.testexamples.classhierarchyresolution;
 
 public class GrandParent implements ParentInterfaceIndirect {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyresolution/GrandParentInterfaceDirect.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.importer.testexamples.classhierarchy;
+package com.tngtech.archunit.core.importer.testexamples.classhierarchyresolution;
 
 public interface GrandParentInterfaceDirect {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyresolution/GrandParentInterfaceIndirect.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.importer.testexamples.classhierarchy;
+package com.tngtech.archunit.core.importer.testexamples.classhierarchyresolution;
 
 public interface GrandParentInterfaceIndirect {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyresolution/Parent.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.importer.testexamples.classhierarchy;
+package com.tngtech.archunit.core.importer.testexamples.classhierarchyresolution;
 
 public class Parent extends GrandParent {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyresolution/ParentInterfaceDirect.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.importer.testexamples.classhierarchy;
+package com.tngtech.archunit.core.importer.testexamples.classhierarchyresolution;
 
 public interface ParentInterfaceDirect extends GrandParentInterfaceDirect {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyresolution/ParentInterfaceIndirect.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.importer.testexamples.classhierarchy;
+package com.tngtech.archunit.core.importer.testexamples.classhierarchyresolution;
 
 public interface ParentInterfaceIndirect extends GrandParentInterfaceIndirect {
 }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/RawAccessRecord.java
Patch:
@@ -49,7 +49,6 @@ static class CodeUnit {
         private final String name;
         private final String descriptor;
         private final List<JavaClassDescriptor> rawParameterTypes;
-        private final JavaClassDescriptor returnType;
         private final List<String> rawParameterTypeNames;
         private final String declaringClassName;
         private final int hashCode;
@@ -58,7 +57,6 @@ static class CodeUnit {
             this.name = name;
             this.descriptor = descriptor;
             this.rawParameterTypes = JavaClassDescriptorImporter.importAsmMethodArgumentTypes(descriptor);
-            this.returnType = JavaClassDescriptorImporter.importAsmMethodReturnType(descriptor);
             this.rawParameterTypeNames = namesOf(rawParameterTypes);
             this.declaringClassName = declaringClassName;
             this.hashCode = Objects.hash(name, descriptor, declaringClassName);

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Formatters.java
Patch:
@@ -89,7 +89,7 @@ public static List<String> formatNamesOf(Class<?>... paramTypes) {
      * @return A {@link List} of fully qualified class names of the passed {@link Class} objects
      */
     @PublicAPI(usage = ACCESS)
-    public static List<String> formatNamesOf(Iterable<Class<?>> paramTypes) {
+    public static List<String> formatNamesOf(Iterable<? extends Class<?>> paramTypes) {
         ImmutableList.Builder<String> result = ImmutableList.builder();
         for (Class<?> paramType : paramTypes) {
             result.add(paramType.getName());

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Formatters.java
Patch:
@@ -89,7 +89,7 @@ public static List<String> formatNamesOf(Class<?>... paramTypes) {
      * @return A {@link List} of fully qualified class names of the passed {@link Class} objects
      */
     @PublicAPI(usage = ACCESS)
-    public static List<String> formatNamesOf(Iterable<Class<?>> paramTypes) {
+    public static List<String> formatNamesOf(Iterable<? extends Class<?>> paramTypes) {
         ImmutableList.Builder<String> result = ImmutableList.builder();
         for (Class<?> paramType : paramTypes) {
             result.add(paramType.getName());

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/SlicesIsolationTest.java
Patch:
@@ -41,7 +41,7 @@ public class SlicesIsolationTest {
     private static DescribedPredicate<Slice> containDescription(final String descriptionPart) {
         return new DescribedPredicate<Slice>("contain description '%s'", descriptionPart) {
             @Override
-            public boolean apply(Slice input) {
+            public boolean test(Slice input) {
                 return input.getDescription().contains(descriptionPart);
             }
         };

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/SlicesIsolationTest.java
Patch:
@@ -38,7 +38,7 @@ public class SlicesIsolationTest {
     private static DescribedPredicate<Slice> containDescription(final String descriptionPart) {
         return new DescribedPredicate<Slice>("contain description '%s'", descriptionPart) {
             @Override
-            public boolean apply(Slice input) {
+            public boolean test(Slice input) {
                 return input.getDescription().contains(descriptionPart);
             }
         };

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/SlicesIsolationTest.java
Patch:
@@ -46,7 +46,7 @@ public void controllers_should_only_use_their_own_slice_with_custom_ignore() {
     private static DescribedPredicate<Slice> containDescription(final String descriptionPart) {
         return new DescribedPredicate<Slice>("contain description '%s'", descriptionPart) {
             @Override
-            public boolean apply(Slice input) {
+            public boolean test(Slice input) {
                 return input.getDescription().contains(descriptionPart);
             }
         };

File: archunit-integration-test/src/test/java/com/tngtech/archunit/ArchUnitArchitectureTest.java
Patch:
@@ -90,7 +90,7 @@ private static DescribedPredicate<JavaAccess<?>> contextIsAnnotatedWith(final Cl
     private static DescribedPredicate<JavaClass> withAnnotation(final Class<? extends Annotation> annotationType) {
         return new DescribedPredicate<JavaClass>("annotated with @" + annotationType.getName()) {
             @Override
-            public boolean apply(JavaClass input) {
+            public boolean test(JavaClass input) {
                 return input.isAnnotatedWith(annotationType)
                         || enclosingClassIsAnnotated(input);
             }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/ImporterRules.java
Patch:
@@ -34,7 +34,7 @@ public class ImporterRules {
     private static DescribedPredicate<JavaClass> belong_to_the_import_context() {
         return new DescribedPredicate<JavaClass>("belong to the import context") {
             @Override
-            public boolean apply(JavaClass input) {
+            public boolean test(JavaClass input) {
                 return input.getPackageName().startsWith(ClassFileImporter.class.getPackage().getName())
                         && !input.getName().contains(DomainBuilders.class.getSimpleName());
             }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/CustomClassLoaderIntegrationTest.java
Patch:
@@ -82,7 +82,7 @@ public List<String> run(Class<?> testClass, String ruleName) throws Exception {
 
         @SuppressWarnings({"unchecked", "SameParameterValue"}) // Access through Reflection can never be typesafe, the caller needs to decide
         private <T> T invoke(Object owner, String methodName, Object... params) throws Exception {
-            Class<?>[] parameterTypes = Arrays.stream(params).map(Object::getClass).toArray(Class[]::new);
+            Class<?>[] parameterTypes = Arrays.stream(params).map(Object::getClass).toArray(Class<?>[]::new);
             Method runMethod = owner.getClass().getDeclaredMethod(methodName, parameterTypes);
             return (T) accessible(runMethod).invoke(owner, params);
         }

File: archunit-java-modules-test/src/test/java/com/tngtech/archunit/example/ModulePathTest.java
Patch:
@@ -30,8 +30,7 @@ private void assertNotOnClasspath(Class<?> clazz) throws Exception {
         classPathSystemProperties.setAccessible(true);
         Iterable<URL> classpathUrls = (Iterable<URL>) classPathSystemProperties.invoke(null);
         URL[] classpath = stream(classpathUrls.spliterator(), false).toArray(URL[]::new);
-        URLClassLoader classpathClassLoader = new URLClassLoader(classpath, null);
-        try {
+        try (URLClassLoader classpathClassLoader = new URLClassLoader(classpath, null)) {
             classpathClassLoader.loadClass(clazz.getName());
             fail("Class " + clazz.getName() + " can be loaded from the classpath -> the test can't reliably show us, if this class can be found on the modulepath. "
                     + "The reason for this might be a wrongly configured test environment, like IntelliJ does "
@@ -40,4 +39,4 @@ private void assertNotOnClasspath(Class<?> clazz) throws Exception {
         } catch (ClassNotFoundException ignored) {
         }
     }
-}
\ No newline at end of file
+}

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/internal/ArchTestExecution.java
Patch:
@@ -22,7 +22,6 @@
 import org.junit.runner.notification.Failure;
 import org.junit.runner.notification.RunNotifier;
 
-import static com.tngtech.archunit.junit.internal.ArchTestInitializationException.WRAP_CAUSE;
 import static com.tngtech.archunit.junit.internal.ReflectionUtils.getValueOrThrowException;
 
 abstract class ArchTestExecution {
@@ -50,7 +49,7 @@ boolean ignore() {
     }
 
     static <T> T getValue(Field field, Class<?> fieldOwner) {
-        return getValueOrThrowException(field, fieldOwner, WRAP_CAUSE);
+        return getValueOrThrowException(field, fieldOwner, ArchTestInitializationException::new);
     }
 
     abstract static class Result {

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/internal/ArchUnitTestDescriptor.java
Patch:
@@ -37,7 +37,6 @@
 import org.slf4j.LoggerFactory;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.tngtech.archunit.junit.internal.ArchTestInitializationException.WRAP_CAUSE;
 import static com.tngtech.archunit.junit.internal.DisplayNameResolver.determineDisplayName;
 import static com.tngtech.archunit.junit.internal.ReflectionUtils.getAllFields;
 import static com.tngtech.archunit.junit.internal.ReflectionUtils.getAllMethods;
@@ -114,7 +113,7 @@ private static void resolveChildren(
     }
 
     private static <T> T getValue(Field field) {
-        return getValueOrThrowException(field, field.getDeclaringClass(), WRAP_CAUSE);
+        return getValueOrThrowException(field, field.getDeclaringClass(), ArchTestInitializationException::new);
     }
 
     private static void resolveArchRules(

File: archunit/src/jdk9main/java/com/tngtech/archunit/core/importer/ModuleLocationFactory.java
Patch:
@@ -21,6 +21,7 @@
 import java.lang.module.ModuleReader;
 import java.lang.module.ModuleReference;
 import java.net.URI;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.Optional;
@@ -100,7 +101,7 @@ public boolean isArchive() {
         }
 
         @Override
-        Iterable<NormalizedResourceName> iterateEntriesInternal() {
+        Collection<NormalizedResourceName> readResourceEntries() {
             return doWithModuleReader(moduleReference, moduleReader -> moduleReader.list()
                     .filter(resourceName::isStartOf)
                     .map(NormalizedResourceName::from)

File: archunit/src/jdk9test/java/com/tngtech/archunit/core/domain/testexamples/AReferencingB.java
Patch:
@@ -1,7 +1,7 @@
 package com.tngtech.archunit.core.domain.testexamples;
 
-import com.tngtech.archunit.base.Function;
-import com.tngtech.archunit.base.Supplier;
+import java.util.function.Function;
+import java.util.function.Supplier;
 
 @SuppressWarnings("unused")
 public class AReferencingB {

File: archunit/src/jdk9test/java/com/tngtech/archunit/core/importer/ModuleLocationFactoryTest.java
Patch:
@@ -24,7 +24,7 @@ public void reads_single_entry_of_jrt() {
         URI jrtJavaIoFile = uriOf(File.class);
         Location jrtJavaIo = locationFactory.create(jrtJavaIoFile);
 
-        assertThat(jrtJavaIo.iterateEntries())
+        assertThat(jrtJavaIo.streamEntries())
                 .containsOnly(NormalizedResourceName.from(File.class.getName().replace('.', '/') + ".class"));
     }
 
@@ -33,15 +33,15 @@ public void iterates_package_of_jrt() {
         URI jrtJavaIoFile = uriOf(File.class);
         Location jrtJavaIo = locationFactory.create(parentOf(jrtJavaIoFile));
 
-        assertThat(jrtJavaIo.iterateEntries())
+        assertThat(jrtJavaIo.streamEntries())
                 .contains(NormalizedResourceName.from(File.class.getName().replace('.', '/') + ".class"));
     }
 
     @Test
     public void iterates_entire_jrt() {
         Location jrtContainingFile = locationFactory.create(createModuleUriContaining(File.class));
 
-        assertThat(jrtContainingFile.iterateEntries())
+        assertThat(jrtContainingFile.streamEntries())
                 .contains(NormalizedResourceName.from(File.class.getName().replace('.', '/') + ".class"));
     }
 

File: archunit/src/main/java/com/tngtech/archunit/base/ChainableFunction.java
Patch:
@@ -15,6 +15,8 @@
  */
 package com.tngtech.archunit.base;
 
+import java.util.function.Function;
+
 import com.tngtech.archunit.PublicAPI;
 
 import static com.tngtech.archunit.PublicAPI.Usage.INHERITANCE;

File: archunit/src/main/java/com/tngtech/archunit/base/PackageMatchers.java
Patch:
@@ -49,7 +49,7 @@ public static PackageMatchers of(Collection<String> packageIdentifiers) {
 
     @Override
     @PublicAPI(usage = ACCESS)
-    public boolean apply(String aPackage) {
+    public boolean test(String aPackage) {
         boolean matches = false;
         for (PackageMatcher matcher : packageMatchers) {
             matches = matches || matcher.matches(aPackage);

File: archunit/src/main/java/com/tngtech/archunit/core/PluginLoader.java
Patch:
@@ -19,18 +19,18 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.function.Supplier;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import com.google.common.base.Supplier;
 import com.google.common.collect.Ordering;
 import com.tngtech.archunit.Internal;
 import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Suppliers.memoize;
+import static com.tngtech.archunit.base.Suppliers.memoize;
 
 @Internal
 public class PluginLoader<T> {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/DomainObjectCreationContext.java
Patch:
@@ -19,11 +19,11 @@
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
+import java.util.function.Function;
 
 import com.tngtech.archunit.Internal;
-import com.tngtech.archunit.base.Function;
 import com.tngtech.archunit.base.HasDescription;
-import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.AccessTarget.ConstructorCallTarget;
 import com.tngtech.archunit.core.domain.AccessTarget.ConstructorReferenceTarget;
 import com.tngtech.archunit.core.domain.AccessTarget.MethodCallTarget;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -17,10 +17,10 @@
 
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 
 import com.tngtech.archunit.Internal;
-import com.tngtech.archunit.base.Optional;
 
 @Internal
 public interface ImportContext {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaAccess.java
Patch:
@@ -163,7 +163,7 @@ private static class OriginOwnerEqualsTargetOwnerPredicate extends DescribedPred
             }
 
             @Override
-            public boolean apply(JavaAccess<?> input) {
+            public boolean test(JavaAccess<?> input) {
                 return input.getOriginOwner().equals(input.getTargetOwner());
             }
         }
@@ -177,8 +177,8 @@ static class TargetPredicate<ACCESS extends JavaAccess<? extends TARGET>, TARGET
             }
 
             @Override
-            public boolean apply(ACCESS input) {
-                return predicate.apply(input.getTarget());
+            public boolean test(ACCESS input) {
+                return predicate.test(input.getTarget());
             }
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaAnnotation.java
Patch:
@@ -17,11 +17,11 @@
 
 import java.lang.annotation.Annotation;
 import java.util.Map;
+import java.util.Optional;
 
 import com.google.common.collect.ImmutableMap;
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.HasDescription;
-import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
 import com.tngtech.archunit.core.domain.properties.HasOwner;
 import com.tngtech.archunit.core.domain.properties.HasType;
@@ -255,7 +255,7 @@ public Object getExplicitlyDeclaredProperty(String propertyName) {
     /**
      * @param propertyName The name of the annotation property, i.e. the declared method name
      * @return the same value as {@link #get(String)}, if the property is explicitly declared
-     *         (compare {@link #hasExplicitlyDeclaredProperty(String)}), otherwise {@link Optional#absent()}
+     *         (compare {@link #hasExplicitlyDeclaredProperty(String)}), otherwise {@link Optional#empty()}
      */
     @PublicAPI(usage = ACCESS)
     public Optional<Object> tryGetExplicitlyDeclaredProperty(String propertyName) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaConstructor.java
Patch:
@@ -17,15 +17,15 @@
 
 import java.lang.reflect.Constructor;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
+import java.util.function.Supplier;
 
-import com.google.common.base.Supplier;
-import com.google.common.base.Suppliers;
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.ArchUnitException.InconsistentClassPathException;
 import com.tngtech.archunit.base.MayResolveTypesViaReflection;
-import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.base.ResolvesTypesViaReflection;
+import com.tngtech.archunit.base.Suppliers;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaConstructorBuilder;
 
 import static com.google.common.collect.Sets.union;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaField.java
Patch:
@@ -16,15 +16,15 @@
 package com.tngtech.archunit.core.domain;
 
 import java.lang.reflect.Field;
+import java.util.Optional;
 import java.util.Set;
+import java.util.function.Supplier;
 
-import com.google.common.base.Supplier;
-import com.google.common.base.Suppliers;
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.ArchUnitException.InconsistentClassPathException;
 import com.tngtech.archunit.base.MayResolveTypesViaReflection;
-import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.base.ResolvesTypesViaReflection;
+import com.tngtech.archunit.base.Suppliers;
 import com.tngtech.archunit.core.domain.properties.HasType;
 import com.tngtech.archunit.core.importer.DomainBuilders;
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaFieldAccess.java
Patch:
@@ -122,7 +122,7 @@ private static class AccessTypePredicate extends DescribedPredicate<JavaFieldAcc
             }
 
             @Override
-            public boolean apply(JavaFieldAccess input) {
+            public boolean test(JavaFieldAccess input) {
                 return accessType == input.getAccessType();
             }
         }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMember.java
Patch:
@@ -19,13 +19,13 @@
 import java.lang.reflect.Member;
 import java.util.Collections;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 
 import com.google.common.collect.ImmutableSet;
 import com.tngtech.archunit.Internal;
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
 import com.tngtech.archunit.core.domain.properties.HasAnnotations;
 import com.tngtech.archunit.core.domain.properties.HasDescriptor;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Source.java
Patch:
@@ -22,11 +22,11 @@
 import java.security.NoSuchAlgorithmException;
 import java.util.Arrays;
 import java.util.Objects;
+import java.util.Optional;
 
 import com.google.common.io.ByteStreams;
 import com.tngtech.archunit.ArchConfiguration;
 import com.tngtech.archunit.PublicAPI;
-import com.tngtech.archunit.base.Optional;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/SourceCodeLocation.java
Patch:
@@ -16,9 +16,9 @@
 package com.tngtech.archunit.core.domain;
 
 import java.util.Objects;
+import java.util.Optional;
 
 import com.tngtech.archunit.PublicAPI;
-import com.tngtech.archunit.base.Optional;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasAnnotations.java
Patch:
@@ -16,11 +16,11 @@
 package com.tngtech.archunit.core.domain.properties;
 
 import java.lang.annotation.Annotation;
+import java.util.Optional;
 import java.util.Set;
 
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.HasDescription;
-import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.JavaAnnotation;
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasModifiers.java
Patch:
@@ -46,7 +46,7 @@ private static class ModifierPredicate extends DescribedPredicate<HasModifiers>
             }
 
             @Override
-            public boolean apply(HasModifiers input) {
+            public boolean test(HasModifiers input) {
                 return input.getModifiers().contains(modifier);
             }
         }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasOwner.java
Patch:
@@ -63,8 +63,8 @@ private static class OwnerPredicate<T> extends DescribedPredicate<HasOwner<T>> {
             }
 
             @Override
-            public boolean apply(HasOwner<T> input) {
-                return predicate.apply(input.getOwner());
+            public boolean test(HasOwner<T> input) {
+                return predicate.test(input.getOwner());
             }
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasParameterTypes.java
Patch:
@@ -93,8 +93,8 @@ private static class RawParameterTypesPredicate extends DescribedPredicate<HasPa
             }
 
             @Override
-            public boolean apply(HasParameterTypes input) {
-                return predicate.apply(input.getRawParameterTypes());
+            public boolean test(HasParameterTypes input) {
+                return predicate.test(input.getRawParameterTypes());
             }
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasThrowsClause.java
Patch:
@@ -88,8 +88,8 @@ private static class ThrowsTypesPredicate extends DescribedPredicate<HasThrowsCl
             }
 
             @Override
-            public boolean apply(HasThrowsClause<?> input) {
-                return predicate.apply(input.getThrowsClause());
+            public boolean test(HasThrowsClause<?> input) {
+                return predicate.test(input.getThrowsClause());
             }
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileProcessor.java
Patch:
@@ -19,10 +19,10 @@
 import java.net.URI;
 import java.util.Collection;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 
 import com.tngtech.archunit.ArchConfiguration;
-import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.domain.JavaFieldAccess.AccessType;
@@ -63,7 +63,7 @@ JavaClasses process(ClassFileSource source) {
                 JavaClassProcessor javaClassProcessor =
                         new JavaClassProcessor(new SourceDescriptor(location.getUri(), md5InClassSourcesEnabled), classDetailsRecorder, accessHandler);
                 new ClassReader(s).accept(javaClassProcessor, 0);
-                importRecord.addAll(javaClassProcessor.createJavaClass().asSet());
+                javaClassProcessor.createJavaClass().ifPresent(importRecord::add);
             } catch (Exception e) {
                 LOG.warn(String.format("Couldn't import class from %s", location.getUri()), e);
             }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/DeclarationHandler.java
Patch:
@@ -17,9 +17,9 @@
 
 import java.util.Collection;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 
-import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.JavaClass;
 
 interface DeclarationHandler {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/GenericMemberTypeProcessor.java
Patch:
@@ -15,8 +15,9 @@
  */
 package com.tngtech.archunit.core.importer;
 
+import java.util.Optional;
+
 import com.tngtech.archunit.base.HasDescription;
-import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaParameterizedTypeBuilder;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaTypeCreationProcess;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaTypeCreationProcess.JavaTypeFinisher;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ImportedClasses.java
Patch:
@@ -18,12 +18,12 @@
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Optional;
 
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedMap;
 import com.google.common.collect.Sets;
-import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClassDescriptor;
 import com.tngtech.archunit.core.domain.JavaModifier;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassSignatureImporter.java
Patch:
@@ -17,8 +17,8 @@
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Optional;
 
-import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaClassTypeParametersBuilder;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaParameterizedTypeBuilder;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaFieldTypeSignatureImporter.java
Patch:
@@ -15,7 +15,8 @@
  */
 package com.tngtech.archunit.core.importer;
 
-import com.tngtech.archunit.base.Optional;
+import java.util.Optional;
+
 import com.tngtech.archunit.core.domain.JavaField;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaTypeCreationProcess;
 import org.objectweb.asm.signature.SignatureReader;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/NormalizedUri.java
Patch:
@@ -29,7 +29,7 @@ class NormalizedUri {
 
     private NormalizedUri(URI uri) {
         String uriString = uri.normalize().toString();
-        uriString = uriString.replaceAll("://*", ":/"); // this is how getClass().getResource(..) returns URLs
+        uriString = uriString.replaceAll(":/+", ":/"); // this is how getClass().getResource(..) returns URLs
         uriString = !uriString.endsWith("/") && !uriString.endsWith(".class") ? uriString + "/" : uriString; // we always want folders to end in '/'
         this.uri = URI.create(uriString);
         List<String> path = Splitter.on("/").omitEmptyStrings().splitToList(this.uri.toString().replaceAll("^.*:", ""));

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/ClassResolverFromClasspath.java
Patch:
@@ -18,10 +18,10 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
+import java.util.Optional;
 
 import com.tngtech.archunit.base.ArchUnitException;
 import com.tngtech.archunit.base.MayResolveTypesViaReflection;
-import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.JavaClass;
 
 import static com.google.common.base.Preconditions.checkNotNull;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/SelectedClassResolverFromClasspath.java
Patch:
@@ -16,11 +16,11 @@
 package com.tngtech.archunit.core.importer.resolvers;
 
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 
 import com.google.common.collect.ImmutableSet;
 import com.tngtech.archunit.PublicAPI;
-import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.JavaClass;
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;

File: archunit/src/main/java/com/tngtech/archunit/lang/AbstractClassesTransformer.java
Patch:
@@ -18,10 +18,11 @@
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.DescribedIterable;
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.base.Guava;
 import com.tngtech.archunit.core.domain.JavaClasses;
 
 import static com.tngtech.archunit.PublicAPI.Usage.INHERITANCE;
+import static java.util.stream.Collectors.toList;
+import static java.util.stream.StreamSupport.stream;
 
 /**
  * Default base implementation of {@link ClassesTransformer}, where only {@link #doTransform(JavaClasses)}
@@ -48,7 +49,7 @@ public final ClassesTransformer<T> that(final DescribedPredicate<? super T> pred
             @Override
             public Iterable<T> doTransform(JavaClasses collection) {
                 Iterable<T> transformed = AbstractClassesTransformer.this.doTransform(collection);
-                return Guava.Iterables.filter(transformed, predicate);
+                return stream(transformed.spliterator(), false).filter(predicate).collect(toList());
             }
         };
     }

File: archunit/src/main/java/com/tngtech/archunit/lang/FailureMessages.java
Patch:
@@ -16,12 +16,12 @@
 package com.tngtech.archunit.lang;
 
 import java.util.List;
+import java.util.Optional;
+import java.util.function.Predicate;
 
-import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.ForwardingList;
-import com.tngtech.archunit.base.Optional;
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
@@ -47,7 +47,7 @@ public String getInformationAboutNumberOfViolations() {
     FailureMessages filter(Predicate<String> predicate) {
         ImmutableList.Builder<String> filtered = ImmutableList.builder();
         for (String message : failures) {
-            if (predicate.apply(message)) {
+            if (predicate.test(message)) {
                 filtered.add(message);
             }
         }

File: archunit/src/main/java/com/tngtech/archunit/lang/FailureReport.java
Patch:
@@ -16,8 +16,8 @@
 package com.tngtech.archunit.lang;
 
 import java.util.List;
+import java.util.function.Predicate;
 
-import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.HasDescription;

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AllAccessesCondition.java
Patch:
@@ -16,10 +16,10 @@
 package com.tngtech.archunit.lang.conditions;
 
 import java.util.Collection;
+import java.util.function.Function;
 
 import com.google.common.base.Joiner;
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.base.Function;
 import com.tngtech.archunit.core.domain.JavaAccess;
 import com.tngtech.archunit.core.domain.JavaClass;
 

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AllDependenciesCondition.java
Patch:
@@ -17,10 +17,10 @@
 
 import java.util.Collection;
 import java.util.HashSet;
+import java.util.function.Function;
 
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.base.Function;
 import com.tngtech.archunit.core.domain.Dependency;
 import com.tngtech.archunit.core.domain.JavaClass;
 
@@ -75,7 +75,7 @@ public AllDependenciesCondition as(String description, Object... args) {
     Collection<Dependency> relevantAttributes(JavaClass javaClass) {
         Collection<Dependency> result = new HashSet<>();
         for (Dependency dependency : javaClassToRelevantDependencies.apply(javaClass)) {
-            if (!ignorePredicate.apply(dependency)) {
+            if (!ignorePredicate.test(dependency)) {
                 result.add(dependency);
             }
         }

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AnyDependencyCondition.java
Patch:
@@ -17,10 +17,10 @@
 
 import java.util.Collection;
 import java.util.HashSet;
+import java.util.function.Function;
 
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.base.Function;
 import com.tngtech.archunit.core.domain.Dependency;
 import com.tngtech.archunit.core.domain.JavaClass;
 
@@ -75,7 +75,7 @@ public AnyDependencyCondition as(String description, Object... args) {
     Collection<Dependency> relevantAttributes(JavaClass javaClass) {
         Collection<Dependency> result = new HashSet<>();
         for (Dependency dependency : javaClassToRelevantDependencies.apply(javaClass)) {
-            if (!ignorePredicate.apply(dependency)) {
+            if (!ignorePredicate.test(dependency)) {
                 result.add(dependency);
             }
         }

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ClassAccessesCondition.java
Patch:
@@ -16,9 +16,9 @@
 package com.tngtech.archunit.lang.conditions;
 
 import java.util.Collection;
+import java.util.function.Function;
 
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.base.Function;
 import com.tngtech.archunit.core.domain.JavaAccess;
 import com.tngtech.archunit.core.domain.JavaClass;
 

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ClassOnlyAccessesCondition.java
Patch:
@@ -16,9 +16,9 @@
 package com.tngtech.archunit.lang.conditions;
 
 import java.util.Collection;
+import java.util.function.Function;
 
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.base.Function;
 import com.tngtech.archunit.core.domain.JavaAccess;
 import com.tngtech.archunit.core.domain.JavaClass;
 

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/CodeUnitOnlyCallsCondition.java
Patch:
@@ -16,9 +16,9 @@
 package com.tngtech.archunit.lang.conditions;
 
 import java.util.Collection;
+import java.util.function.Function;
 
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.base.Function;
 import com.tngtech.archunit.core.domain.JavaAccess;
 import com.tngtech.archunit.core.domain.JavaCodeUnit;
 

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/DependencyCondition.java
Patch:
@@ -31,6 +31,6 @@ class DependencyCondition extends ArchCondition<Dependency> {
 
     @Override
     public void check(Dependency item, ConditionEvents events) {
-        events.add(new SimpleConditionEvent(item, conditionPredicate.apply(item), item.getDescription()));
+        events.add(new SimpleConditionEvent(item, conditionPredicate.test(item), item.getDescription()));
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/FieldAccessCondition.java
Patch:
@@ -36,7 +36,7 @@ class FieldAccessCondition extends ArchCondition<JavaFieldAccess> {
 
     @Override
     public void check(JavaFieldAccess item, ConditionEvents events) {
-        events.add(new SimpleConditionEvent(item, fieldAccessIdentifier.apply(item), item.getDescription()));
+        events.add(new SimpleConditionEvent(item, fieldAccessIdentifier.test(item), item.getDescription()));
     }
 
     static class FieldGetAccessCondition extends FieldAccessCondition {

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/JavaAccessCondition.java
Patch:
@@ -31,6 +31,6 @@ class JavaAccessCondition<T extends JavaAccess<?>> extends ArchCondition<T> {
 
     @Override
     public void check(T item, ConditionEvents events) {
-        events.add(new SimpleConditionEvent(item, predicate.apply(item), item.getDescription()));
+        events.add(new SimpleConditionEvent(item, predicate.test(item), item.getDescription()));
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/NeverCondition.java
Patch:
@@ -15,6 +15,8 @@
  */
 package com.tngtech.archunit.lang.conditions;
 
+import java.util.Collection;
+
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ConditionEvent;
 import com.tngtech.archunit.lang.ConditionEvents;
@@ -28,7 +30,7 @@ class NeverCondition<T> extends ArchCondition<T> {
     }
 
     @Override
-    public void init(Iterable<T> allObjectsToTest) {
+    public void init(Collection<T> allObjectsToTest) {
         condition.init(allObjectsToTest);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/extension/ArchUnitExtensionLoader.java
Patch:
@@ -18,12 +18,12 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.ServiceLoader;
+import java.util.function.Supplier;
 
-import com.google.common.base.Supplier;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import static com.google.common.base.Suppliers.memoize;
+import static com.tngtech.archunit.base.Suppliers.memoize;
 
 class ArchUnitExtensionLoader {
     private static final Logger LOG = LoggerFactory.getLogger(ArchUnitExtensionLoader.class);

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractCodeUnitsShouldInternal.java
Patch:
@@ -16,9 +16,9 @@
 package com.tngtech.archunit.lang.syntax;
 
 import java.util.List;
+import java.util.function.Function;
 
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.base.Function;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaCodeUnit;
 import com.tngtech.archunit.lang.ArchCondition;

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenObjects.java
Patch:
@@ -15,9 +15,10 @@
  */
 package com.tngtech.archunit.lang.syntax;
 
+import java.util.Optional;
+import java.util.function.Function;
+
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.base.Function;
-import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ClassesTransformer;
 import com.tngtech.archunit.lang.Priority;

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ClassesThatInternal.java
Patch:
@@ -16,9 +16,9 @@
 package com.tngtech.archunit.lang.syntax;
 
 import java.lang.annotation.Annotation;
+import java.util.function.Function;
 
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.base.Function;
 import com.tngtech.archunit.core.domain.JavaAnnotation;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaCodeUnit;

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ConstructorsShouldInternal.java
Patch:
@@ -15,7 +15,8 @@
  */
 package com.tngtech.archunit.lang.syntax;
 
-import com.tngtech.archunit.base.Function;
+import java.util.function.Function;
+
 import com.tngtech.archunit.core.domain.JavaConstructor;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ClassesTransformer;

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/FieldsShouldInternal.java
Patch:
@@ -15,8 +15,9 @@
  */
 package com.tngtech.archunit.lang.syntax;
 
+import java.util.function.Function;
+
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.base.Function;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaField;
 import com.tngtech.archunit.lang.ArchCondition;

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassInternal.java
Patch:
@@ -15,7 +15,8 @@
  */
 package com.tngtech.archunit.lang.syntax;
 
-import com.tngtech.archunit.base.Function;
+import java.util.function.Function;
+
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ClassesTransformer;

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/MembersDeclaredInClassesThat.java
Patch:
@@ -16,9 +16,9 @@
 package com.tngtech.archunit.lang.syntax;
 
 import java.lang.annotation.Annotation;
+import java.util.function.Function;
 
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.base.Function;
 import com.tngtech.archunit.core.domain.JavaAnnotation;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaCodeUnit;

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/MethodsShouldInternal.java
Patch:
@@ -15,7 +15,8 @@
  */
 package com.tngtech.archunit.lang.syntax;
 
-import com.tngtech.archunit.base.Function;
+import java.util.function.Function;
+
 import com.tngtech.archunit.core.domain.JavaMethod;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ClassesTransformer;

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/PredicateAggregator.java
Patch:
@@ -15,9 +15,10 @@
  */
 package com.tngtech.archunit.lang.syntax;
 
+import java.util.Optional;
+
 import com.tngtech.archunit.Internal;
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.base.Optional;
 
 @Internal
 public final class PredicateAggregator<T> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MethodsShouldConjunction.java
Patch:
@@ -21,7 +21,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
-public interface MethodsShouldConjunction  extends CodeUnitsShouldConjunction<JavaMethod> {
+public interface MethodsShouldConjunction extends CodeUnitsShouldConjunction<JavaMethod> {
 
     @Override
     @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/library/ProxyRules.java
Patch:
@@ -167,7 +167,7 @@ public static ArchCondition<JavaClass> directly_call_other_methods_declared_in_t
             @Override
             public void check(JavaClass javaClass, ConditionEvents events) {
                 for (JavaMethodCall call : javaClass.getMethodCallsFromSelf()) {
-                    boolean satisfied = call.getOriginOwner().equals(call.getTargetOwner()) && predicate.apply(call.getTarget());
+                    boolean satisfied = call.getOriginOwner().equals(call.getTargetOwner()) && predicate.test(call.getTarget());
                     events.add(new SimpleConditionEvent(call, satisfied, call.getDescription()));
                 }
             }

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceRule.java
Patch:
@@ -17,11 +17,11 @@
 
 import java.util.Collections;
 import java.util.List;
+import java.util.Optional;
 
 import com.google.common.collect.ImmutableList;
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.Dependency;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClasses;

File: archunit/src/main/java/com/tngtech/archunit/library/metrics/MetricsComponentDependencyGraph.java
Patch:
@@ -20,11 +20,11 @@
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
+import java.util.function.Function;
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.SetMultimap;
-import com.tngtech.archunit.base.Function;
 
 class MetricsComponentDependencyGraph<T> {
     private final SetMultimap<MetricsComponent<T>, MetricsComponent<T>> outgoingComponentDependencies;

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/ComponentIdentifier.java
Patch:
@@ -16,8 +16,7 @@
 package com.tngtech.archunit.library.plantuml;
 
 import java.util.Objects;
-
-import com.tngtech.archunit.base.Optional;
+import java.util.Optional;
 
 class ComponentIdentifier {
     private final ComponentName componentName;

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/PlantUmlDiagram.java
Patch:
@@ -49,7 +49,7 @@ static class Builder {
         }
 
         Builder withDependencies(List<ParsedDependency> dependencies) {
-            originToParsedDependency = FluentIterable.from(dependencies).index(ParsedDependency.GET_ORIGIN);
+            originToParsedDependency = FluentIterable.from(dependencies).index(ParsedDependency::getOrigin);
             return this;
         }
 
@@ -69,4 +69,4 @@ private void finish(PlantUmlComponent component) {
             component.finish(dependencies.build());
         }
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/base/ChainableFunctionTest.java
Patch:
@@ -29,7 +29,7 @@ public void is() {
     private DescribedPredicate<Integer> greaterThan(final int number) {
         return new DescribedPredicate<Integer>("greater than " + number) {
             @Override
-            public boolean apply(Integer input) {
+            public boolean test(Integer input) {
                 return input > number;
             }
         };
@@ -52,4 +52,4 @@ public Integer apply(Integer input) {
             }
         };
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/base/PackageMatcherTest.java
Patch:
@@ -1,5 +1,7 @@
 package com.tngtech.archunit.base;
 
+import java.util.Optional;
+
 import com.tngtech.archunit.base.PackageMatcher.Result;
 import com.tngtech.java.junit.dataprovider.DataProvider;
 import com.tngtech.java.junit.dataprovider.DataProviderRunner;
@@ -134,6 +136,6 @@ public void transform_match_to_groups() {
     public void transform_mismatch_to_absent() {
         Optional<Result> result = PackageMatcher.of("com.(*)..").match("mycompany");
 
-        assertThat(result).isAbsent();
+        assertThat(result).isEmpty();
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/core/PluginLoaderTest.java
Patch:
@@ -22,9 +22,6 @@ public class PluginLoaderTest {
 
     @Test
     public void loads_correct_plugin_for_version() {
-        System.setProperty("java.version", "1.7.0_55");
-        assertThat(createPluginLoader().load()).isInstanceOf(pluginTypeBeforeJava9);
-
         System.setProperty("java.version", "1.8.0_122");
         assertThat(createPluginLoader().load()).isInstanceOf(pluginTypeBeforeJava9);
 

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassDescriptorTest.java
Patch:
@@ -27,7 +27,7 @@ public void primitive_types_by_name_and_descriptor(String name, Class<?> expecte
         JavaClassDescriptor primitiveType = JavaClassDescriptor.From.name(name);
         assertThat(primitiveType.isPrimitive()).isTrue();
         assertThat(primitiveType.isArray()).isFalse();
-        assertThat(primitiveType.tryGetComponentType()).isAbsent();
+        assertThat(primitiveType.tryGetComponentType()).isEmpty();
 
         assertThat(primitiveType).isEquivalentTo(expected);
     }
@@ -48,7 +48,7 @@ public void object_name() {
         JavaClassDescriptor objectType = JavaClassDescriptor.From.name(Object.class.getName());
         assertThat(objectType.isPrimitive()).isFalse();
         assertThat(objectType.isArray()).isFalse();
-        assertThat(objectType.tryGetComponentType()).isAbsent();
+        assertThat(objectType.tryGetComponentType()).isEmpty();
 
         assertThat(objectType).isEquivalentTo(Object.class);
     }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassesTest.java
Patch:
@@ -118,15 +118,15 @@ public void trying_to_get_a_missing_class_causes_IllegalArgumentException() {
     private DescribedPredicate<JavaClass> haveTheNameOf(final Class<?> clazz) {
         return new DescribedPredicate<JavaClass>("have the name " + clazz.getSimpleName()) {
             @Override
-            public boolean apply(JavaClass input) {
+            public boolean test(JavaClass input) {
                 return input.getName().equals(clazz.getName());
             }
         };
     }
 
     private static final DescribedPredicate<JavaClass> EXIST = new DescribedPredicate<JavaClass>("exist") {
         @Override
-        public boolean apply(JavaClass input) {
+        public boolean test(JavaClass input) {
             return true;
         }
     };

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaFieldAccessTest.java
Patch:
@@ -23,7 +23,6 @@
 import static com.tngtech.java.junit.dataprovider.DataProviders.$;
 import static com.tngtech.java.junit.dataprovider.DataProviders.$$;
 
-
 @RunWith(DataProviderRunner.class)
 public class JavaFieldAccessTest {
     @Test
@@ -143,4 +142,4 @@ private int accessInt() {
             return intField;
         }
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/core/domain/SourceCodeLocationTest.java
Patch:
@@ -25,7 +25,7 @@ public void format_location() {
 
         JavaClass classWithoutSource = getClassWithoutSource();
 
-        assertThat(classWithoutSource.getSource()).as("source").isAbsent();
+        assertThat(classWithoutSource.getSource()).as("source").isEmpty();
         Assertions.assertThat(SourceCodeLocation.of(classWithoutSource, 7).toString()).isEqualTo(String.format("(%s.java:7)", classWithoutSource.getSimpleName()));
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasNameTest.java
Patch:
@@ -70,7 +70,7 @@ public void Utils_namesOf() {
     }
 
     private AbstractBooleanAssert<?> assertNameMatches(String input, String regex) {
-        return assertThat(nameMatching(regex).apply(newHasName(input)))
+        return assertThat(nameMatching(regex).test(newHasName(input)))
                 .as(input + " =~ " + regex);
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileProcessorTest.java
Patch:
@@ -1,12 +1,12 @@
 package com.tngtech.archunit.core.importer;
 
 import java.lang.reflect.Field;
+import java.util.Optional;
 import java.util.SortedMap;
 import java.util.TreeMap;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.importer.resolvers.ClassResolverFromClasspath;
 import org.junit.Test;
@@ -21,7 +21,7 @@ public void ClassResolverFromClassPath_resolves_robustly() {
         Optional<JavaClass> resolved = new ClassResolverFromClasspath()
                 .tryResolve("not.There");
 
-        assertThat(resolved).isAbsent();
+        assertThat(resolved).isEmpty();
     }
 
     @Test

File: archunit/src/test/java/com/tngtech/archunit/core/importer/resolvers/ClassResolverFactoryTest.java
Patch:
@@ -6,12 +6,12 @@
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.List;
+import java.util.Optional;
 
 import com.google.common.base.Preconditions;
 import com.google.common.base.Splitter;
 import com.tngtech.archunit.ArchConfiguration;
 import com.tngtech.archunit.base.ArchUnitException.ClassResolverConfigurationException;
-import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.importer.resolvers.ClassResolver.Factory.NoOpClassResolver;
 import com.tngtech.archunit.testutil.ArchConfigurationRule;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/resolvers/testclasses/someresolver/SomeResolver.java
Patch:
@@ -1,6 +1,7 @@
 package com.tngtech.archunit.core.importer.resolvers.testclasses.someresolver;
 
-import com.tngtech.archunit.base.Optional;
+import java.util.Optional;
+
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.importer.resolvers.ClassResolver;
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/methodimport/ClassWithMultipleMethods.java
Patch:
@@ -1,7 +1,7 @@
 package com.tngtech.archunit.core.importer.testexamples.methodimport;
 
+@SuppressWarnings("unused")
 public class ClassWithMultipleMethods {
-
     static String usage = "ClassFileImporterTest's @Test imports_methods_with_correct_sourceCodeLocation";
 
     int methodDefinedInLine7() { return 7; }

File: archunit/src/test/java/com/tngtech/archunit/lang/ConditionEventsTest.java
Patch:
@@ -35,6 +35,7 @@ public void isEmpty(ConditionEvents events, boolean expectedEmpty) {
     }
 
     @Test
+    @SuppressWarnings("Convert2Lambda") // to retrieve the type information ViolationHandler may not be converted to a Lambda
     public void handleViolations_reports_only_violations_referring_to_the_correct_type() {
         ConditionEvents events = events(
                 SimpleConditionEvent.satisfied(new CorrectType("do not handle"), "I'm not violated"),
@@ -80,6 +81,7 @@ public void handles_erased_generics_as_upper_bound() {
         assertThat(handledFailureMessages).containsOnly("correct", "wrong");
     }
 
+    @SuppressWarnings("Convert2Lambda") // to retrieve the type information ViolationHandler may not be converted to a Lambda
     private <T extends CorrectType> ViolationHandler<?> genericBoundByCorrectType(final Set<String> handledFailureMessages) {
         return new ViolationHandler<T>() {
             @Override
@@ -89,6 +91,7 @@ public void handle(Collection<T> violatingObjects, String message) {
         };
     }
 
+    @SuppressWarnings("Convert2Lambda") // to retrieve the type information ViolationHandler may not be converted to a Lambda
     private <T> ViolationHandler<?> unboundGeneric(final Set<String> handledFailureMessages) {
         return new ViolationHandler<T>() {
             @Override

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/CodeUnitsShouldTest.java
Patch:
@@ -627,7 +627,7 @@ public void restricted_constructors_calls_by_code_units_predicate(ArchRule rule)
     private static DescribedPredicate<JavaCodeUnit> doNotHaveParametersOfType(final Class<?> type) {
         return new DescribedPredicate<JavaCodeUnit>("do not have parameters of type " + type.getSimpleName()) {
             @Override
-            public boolean apply(JavaCodeUnit codeUnit) {
+            public boolean test(JavaCodeUnit codeUnit) {
                 return !namesOf(codeUnit.getRawParameterTypes()).contains(type.getName());
             }
         };

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/ShouldOnlyByClassesThatTest.java
Patch:
@@ -3,9 +3,9 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Set;
+import java.util.function.Function;
 
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.base.Function;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.properties.HasName;
 import com.tngtech.archunit.core.domain.properties.HasType;
@@ -1136,6 +1136,7 @@ public void classesThat_predicate(ArchRule rule) {
     }
 
     @Test
+    @SuppressWarnings("Convert2Lambda") // the test expects an anonymous class, not a lambda
     public void onlyHaveDependentClassesThat_reports_all_dependents() {
         Function<ArchRule, Set<JavaClass>> filterViolationOriginsInFailureReport = new Function<ArchRule, Set<JavaClass>>() {
             @Override
@@ -1428,6 +1429,7 @@ void access() {
         }
     }
 
+    @SuppressWarnings({"Convert2Lambda", "Anonymous2MethodRef"}) // the test expects an anonymous class, not a lambda
     private static final Runnable anonymousClassBeingAccessed = new Runnable() {
         @Override
         public void run() {

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/GivenSlicesTest.java
Patch:
@@ -76,7 +76,7 @@ private GivenSlices testSlices() {
     private DescribedPredicate<Slice> descriptionMatching(final String regex) {
         return new DescribedPredicate<Slice>("description matching '%s'", regex) {
             @Override
-            public boolean apply(Slice input) {
+            public boolean test(Slice input) {
                 return input.getDescription().matches(regex);
             }
         };

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/SlicesTest.java
Patch:
@@ -4,13 +4,13 @@
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 import java.util.regex.Pattern;
 
 import com.google.common.collect.ImmutableSet;
 import com.tngtech.archunit.base.DescribedIterable;
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.Dependency;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClasses;
@@ -104,7 +104,7 @@ public void slices_from_identifier() {
         assertThatTypes(getSliceOf(List.class, slices)).contain(Collection.class);
         Assertions.assertThat(tryGetSliceOf(File.class, slices))
                 .as("Slice of class java.io.File (which should be missing from the assignment)")
-                .isAbsent();
+                .isEmpty();
     }
 
     private Slice getSliceOf(Class<?> clazz, Slices slices) {

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/DescribedPredicateAssertion.java
Patch:
@@ -23,7 +23,7 @@ public DescribedPredicateAssertion<T> rejects(T value) {
     }
 
     private AbstractBooleanAssert<?> assertThatPredicateAppliesTo(T value) {
-        return assertThat(actual.apply(value)).as("predicate <%s> matches <%s>", actual, value);
+        return assertThat(actual.test(value)).as("predicate <%s> matches <%s>", actual, value);
     }
 
     public DescribedPredicateAssertion<T> hasSameDescriptionAs(DescribedPredicate<T> otherPredicate) {

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaClassAssertion.java
Patch:
@@ -41,8 +41,8 @@ public JavaClassAssertion hasOnlyModifiers(JavaModifier... expectedModifiers) {
     }
 
     public JavaClassAssertion hasNoSuperclass() {
-        assertThat(actual.getRawSuperclass()).as(describeAssertion("raw superclass")).isAbsent();
-        assertThat(actual.getSuperclass()).as(describeAssertion("superclass")).isAbsent();
+        assertThat(actual.getRawSuperclass()).as(describeAssertion("raw superclass")).isEmpty();
+        assertThat(actual.getSuperclass()).as(describeAssertion("superclass")).isEmpty();
         return this;
     }
 
@@ -93,7 +93,7 @@ public JavaClassAssertion isFullyImported(boolean expectedIsFullyImported) {
     }
 
     public JavaClassAssertion hasNoEnclosingClass() {
-        assertThat(actual.getEnclosingClass()).as(describeAssertion("enclosing class")).isAbsent();
+        assertThat(actual.getEnclosingClass()).as(describeAssertion("enclosing class")).isEmpty();
         return this;
     }
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/syntax/MethodCallChain.java
Patch:
@@ -2,8 +2,7 @@
 
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-
-import com.tngtech.archunit.base.Optional;
+import java.util.Optional;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;

File: archunit/src/test/java/com/tngtech/archunit/testutil/syntax/PropagatedType.java
Patch:
@@ -113,9 +113,7 @@ Type resolve(Type type) {
             }
 
             TypeVariable<?> typeVariable = (TypeVariable<?>) type;
-            return typeVariables.containsKey(typeVariable.getName())
-                    ? typeVariables.get(typeVariable.getName())
-                    : type;
+            return typeVariables.getOrDefault(typeVariable.getName(), type);
         }
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/ArchCondition.java
Patch:
@@ -45,7 +45,7 @@ public ArchCondition(String description, Object... args) {
      *
      * @param allObjectsToTest All objects that {@link #check(Object, ConditionEvents)} will be called against
      */
-    public void init(Iterable<T> allObjectsToTest) {
+    public void init(Collection<T> allObjectsToTest) {
     }
 
     public abstract void check(T item, ConditionEvents events);
@@ -74,7 +74,7 @@ public String getDescription() {
     public ArchCondition<T> as(String description, Object... args) {
         return new ArchCondition<T>(description, args) {
             @Override
-            public void init(Iterable<T> allObjectsToTest) {
+            public void init(Collection<T> allObjectsToTest) {
                 ArchCondition.this.init(allObjectsToTest);
             }
 
@@ -113,7 +113,7 @@ private static <T> String joinDescriptionsOf(String infix, Collection<ArchCondit
         }
 
         @Override
-        public void init(Iterable<T> allObjectsToTest) {
+        public void init(Collection<T> allObjectsToTest) {
             for (ArchCondition<T> condition : conditions) {
                 condition.init(allObjectsToTest);
             }

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/NeverCondition.java
Patch:
@@ -15,6 +15,8 @@
  */
 package com.tngtech.archunit.lang.conditions;
 
+import java.util.Collection;
+
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ConditionEvent;
 import com.tngtech.archunit.lang.ConditionEvents;
@@ -28,7 +30,7 @@ class NeverCondition<T> extends ArchCondition<T> {
     }
 
     @Override
-    public void init(Iterable<T> allObjectsToTest) {
+    public void init(Collection<T> allObjectsToTest) {
         condition.init(allObjectsToTest);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceCycleArchCondition.java
Patch:
@@ -46,7 +46,6 @@
 import static java.lang.System.lineSeparator;
 import static java.util.Comparator.comparing;
 import static java.util.stream.Collectors.toCollection;
-import static java.util.stream.Collectors.toList;
 
 class SliceCycleArchCondition extends ArchCondition<Slice> {
     private static final Logger log = LoggerFactory.getLogger(SliceCycleArchCondition.class);
@@ -62,7 +61,7 @@ class SliceCycleArchCondition extends ArchCondition<Slice> {
     }
 
     @Override
-    public void init(Iterable<Slice> allSlices) {
+    public void init(Collection<Slice> allSlices) {
         initializeResources(allSlices);
         graph.addNodes(allSlices);
     }

File: archunit/src/test/java/com/tngtech/archunit/lang/ArchConditionTest.java
Patch:
@@ -264,7 +264,7 @@ public static class ConditionWithInitAndFinish extends ArchCondition<String> {
         }
 
         @Override
-        public void init(Iterable<String> allObjectsToTest) {
+        public void init(Collection<String> allObjectsToTest) {
             this.allObjectsToTest = allObjectsToTest;
         }
 

File: archunit-java-modules-test/src/test/java/com/tngtech/archunit/example/ModulePathTest.java
Patch:
@@ -30,8 +30,7 @@ private void assertNotOnClasspath(Class<?> clazz) throws Exception {
         classPathSystemProperties.setAccessible(true);
         Iterable<URL> classpathUrls = (Iterable<URL>) classPathSystemProperties.invoke(null);
         URL[] classpath = stream(classpathUrls.spliterator(), false).toArray(URL[]::new);
-        URLClassLoader classpathClassLoader = new URLClassLoader(classpath, null);
-        try {
+        try (URLClassLoader classpathClassLoader = new URLClassLoader(classpath, null)) {
             classpathClassLoader.loadClass(clazz.getName());
             fail("Class " + clazz.getName() + " can be loaded from the classpath -> the test can't reliably show us, if this class can be found on the modulepath. "
                     + "The reason for this might be a wrongly configured test environment, like IntelliJ does "
@@ -40,4 +39,4 @@ private void assertNotOnClasspath(Class<?> clazz) throws Exception {
         } catch (ClassNotFoundException ignored) {
         }
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterSlowTest.java
Patch:
@@ -115,8 +115,7 @@ public void imports_classes_from_classpath_specified_in_manifest_file() {
         String manifestClasspath = testClassFile.getClasspathRoot().getAbsolutePath();
         String jarPath = new TestJarFile()
                 .withManifestAttribute(CLASS_PATH, manifestClasspath)
-                .create()
-                .getName();
+                .createAndReturnName();
 
         verifyCantLoadWithCurrentClasspath(testClassFile);
         System.setProperty(JAVA_CLASS_PATH_PROP, jarPath);

File: archunit/src/jdk9test/java/com/tngtech/archunit/core/domain/testexamples/AReferencingB.java
Patch:
@@ -1,8 +1,7 @@
 package com.tngtech.archunit.core.domain.testexamples;
 
 import java.util.function.Function;
-
-import com.tngtech.archunit.base.Supplier;
+import java.util.function.Supplier;
 
 @SuppressWarnings("unused")
 public class AReferencingB {

File: archunit/src/test/java/com/tngtech/archunit/ArchConfigurationTest.java
Patch:
@@ -65,7 +65,7 @@ public void simple_properties_explicitly_set() {
 
         assertThat(configuration.resolveMissingDependenciesFromClassPath()).isTrue();
         assertThat(configuration.md5InClassSourcesEnabled()).isTrue();
-        assertThat(configuration.getClassResolver()).isAbsent();
+        assertThat(configuration.getClassResolver()).isEmpty();
         assertThat(configuration.getClassResolverArguments()).isEmpty();
     }
 

File: archunit/src/test/java/com/tngtech/archunit/base/PackageMatcherTest.java
Patch:
@@ -134,6 +134,6 @@ public void transform_match_to_groups() {
     public void transform_mismatch_to_absent() {
         Optional<Result> result = PackageMatcher.of("com.(*)..").match("mycompany");
 
-        assertThat(result).isAbsent();
+        assertThat(result).isEmpty();
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassDescriptorTest.java
Patch:
@@ -27,7 +27,7 @@ public void primitive_types_by_name_and_descriptor(String name, Class<?> expecte
         JavaClassDescriptor primitiveType = JavaClassDescriptor.From.name(name);
         assertThat(primitiveType.isPrimitive()).isTrue();
         assertThat(primitiveType.isArray()).isFalse();
-        assertThat(primitiveType.tryGetComponentType()).isAbsent();
+        assertThat(primitiveType.tryGetComponentType()).isEmpty();
 
         assertThat(primitiveType).isEquivalentTo(expected);
     }
@@ -48,7 +48,7 @@ public void object_name() {
         JavaClassDescriptor objectType = JavaClassDescriptor.From.name(Object.class.getName());
         assertThat(objectType.isPrimitive()).isFalse();
         assertThat(objectType.isArray()).isFalse();
-        assertThat(objectType.tryGetComponentType()).isAbsent();
+        assertThat(objectType.tryGetComponentType()).isEmpty();
 
         assertThat(objectType).isEquivalentTo(Object.class);
     }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaCodeUnitTest.java
Patch:
@@ -299,10 +299,10 @@ void method(@SomeParameterAnnotation("test") String param) {
                 .getMethod("method", String.class).getParameters().get(0);
 
         assertThat(parameter.tryGetAnnotationOfType(SomeParameterAnnotation.class).get()).isInstanceOf(SomeParameterAnnotation.class);
-        assertThat(parameter.tryGetAnnotationOfType(Deprecated.class)).isAbsent();
+        assertThat(parameter.tryGetAnnotationOfType(Deprecated.class)).isEmpty();
 
         assertThatAnnotation(parameter.tryGetAnnotationOfType(SomeParameterAnnotation.class.getName()).get()).hasType(SomeParameterAnnotation.class);
-        assertThat(parameter.tryGetAnnotationOfType(Deprecated.class.getName())).isAbsent();
+        assertThat(parameter.tryGetAnnotationOfType(Deprecated.class.getName())).isEmpty();
     }
 
     @SuppressWarnings("unused")

File: archunit/src/test/java/com/tngtech/archunit/core/domain/SourceCodeLocationTest.java
Patch:
@@ -25,7 +25,7 @@ public void format_location() {
 
         JavaClass classWithoutSource = getClassWithoutSource();
 
-        assertThat(classWithoutSource.getSource()).as("source").isAbsent();
+        assertThat(classWithoutSource.getSource()).as("source").isEmpty();
         Assertions.assertThat(SourceCodeLocation.of(classWithoutSource, 7).toString()).isEqualTo(String.format("(%s.java:7)", classWithoutSource.getSimpleName()));
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/domain/SourceTest.java
Patch:
@@ -44,7 +44,7 @@ public void source_file_name() {
         assertThat(source.getFileName()).as("source file name").contains("SomeClass.java");
 
         source = new Source(uriOf(Object.class), Optional.<String>empty(), false);
-        assertThat(source.getFileName()).as("source file name").isAbsent();
+        assertThat(source.getFileName()).as("source file name").isEmpty();
     }
 
     @DataProvider

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterTest.java
Patch:
@@ -675,7 +675,7 @@ class ClassCreatingAnonymousClassInConstructor {
         JavaClass anonymousClass = classes.get(anonymousClassName);
 
         assertThat(anonymousClass.getEnclosingClass()).contains(enclosingClass);
-        assertThat(anonymousClass.getEnclosingCodeUnit()).isAbsent();
+        assertThat(anonymousClass.getEnclosingCodeUnit()).isEmpty();
     }
 
     @Test

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileProcessorTest.java
Patch:
@@ -21,7 +21,7 @@ public void ClassResolverFromClassPath_resolves_robustly() {
         Optional<JavaClass> resolved = new ClassResolverFromClasspath()
                 .tryResolve("not.There");
 
-        assertThat(resolved).isAbsent();
+        assertThat(resolved).isEmpty();
     }
 
     @Test

File: archunit/src/test/java/com/tngtech/archunit/core/importer/resolvers/ClassResolverFromClassPathTest.java
Patch:
@@ -60,7 +60,7 @@ public void finds_uri_of_class_on_classpath() {
     public void is_resilient_if_URI_cant_be_located() {
         Optional<JavaClass> result = resolver.tryResolve("sooo.Wrong");
 
-        assertThat(result).isAbsent();
+        assertThat(result).isEmpty();
         verifyNoMoreInteractions(uriImporter);
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/resolvers/SelectedClassResolverFromClasspathTest.java
Patch:
@@ -40,7 +40,7 @@ public void resolves_exactly_the_classes_beneath_the_given_packages_from_the_cla
 
         assertResolved(resolver.tryResolve(FirstDependency.class.getName()), FirstDependency.class);
         assertResolved(resolver.tryResolve(SecondDependency.class.getName()), SecondDependency.class);
-        assertThat(resolver.tryResolve(ThirdDependency.class.getName())).isAbsent();
+        assertThat(resolver.tryResolve(ThirdDependency.class.getName())).isEmpty();
         verifyNoMoreInteractions(classUriImporter);
     }
 

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/SlicesTest.java
Patch:
@@ -104,7 +104,7 @@ public void slices_from_identifier() {
         assertThatTypes(getSliceOf(List.class, slices)).contain(Collection.class);
         Assertions.assertThat(tryGetSliceOf(File.class, slices))
                 .as("Slice of class java.io.File (which should be missing from the assignment)")
-                .isAbsent();
+                .isEmpty();
     }
 
     private Slice getSliceOf(Class<?> clazz, Slices slices) {

File: archunit/src/test/java/com/tngtech/archunit/library/plantuml/PlantUmlParserTest.java
Patch:
@@ -114,7 +114,7 @@ public void parses_dependency_of_simple_component_diagram(Function<TestDiagram,
         assertThat(target.getDependencies()).as("dependency component's dependencies").isEmpty();
         assertThat(getOnlyElement(target.getStereotypes())).as("dependency component's stereotype")
                 .isEqualTo(new Stereotype("..target.."));
-        assertThat(target.getAlias()).as("dependency component's alias is present").isAbsent();
+        assertThat(target.getAlias()).as("dependency component's alias is present").isEmpty();
     }
 
     @DataProvider

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaAnnotationAssertion.java
Patch:
@@ -90,7 +90,7 @@ public JavaAnnotationAssertion hasNoExplicitlyDeclaredProperty(final String prop
         assertThat(actual.hasExplicitlyDeclaredProperty(propertyName))
                 .as(description + " has explicitly declared value")
                 .isFalse();
-        assertThat(actual.tryGetExplicitlyDeclaredProperty(propertyName)).as(description).isAbsent();
+        assertThat(actual.tryGetExplicitlyDeclaredProperty(propertyName)).as(description).isEmpty();
         assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
             @Override
             public void call() {

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaClassAssertion.java
Patch:
@@ -41,8 +41,8 @@ public JavaClassAssertion hasOnlyModifiers(JavaModifier... expectedModifiers) {
     }
 
     public JavaClassAssertion hasNoSuperclass() {
-        assertThat(actual.getRawSuperclass()).as(describeAssertion("raw superclass")).isAbsent();
-        assertThat(actual.getSuperclass()).as(describeAssertion("superclass")).isAbsent();
+        assertThat(actual.getRawSuperclass()).as(describeAssertion("raw superclass")).isEmpty();
+        assertThat(actual.getSuperclass()).as(describeAssertion("superclass")).isEmpty();
         return this;
     }
 
@@ -93,7 +93,7 @@ public JavaClassAssertion isFullyImported(boolean expectedIsFullyImported) {
     }
 
     public JavaClassAssertion hasNoEnclosingClass() {
-        assertThat(actual.getEnclosingClass()).as(describeAssertion("enclosing class")).isAbsent();
+        assertThat(actual.getEnclosingClass()).as(describeAssertion("enclosing class")).isEmpty();
         return this;
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AnnotationProxy.java
Patch:
@@ -95,9 +95,9 @@ private ImmutableMap<MethodKey, SpecificHandler> initHandlersByMethod(
 
         @Override
         public Object invoke(Object proxy, Method method, Object[] args) {
-            MethodKey key = MethodKey.of(method);
-            if (handlersByMethod.containsKey(key)) {
-                return handlersByMethod.get(key).handle(proxy, method, args);
+            SpecificHandler handler = handlersByMethod.get(MethodKey.of(method));
+            if (handler != null) {
+                return handler.handle(proxy, method, args);
             }
 
             Object result = toProxy.get(method.getName()).orElse(method.getDefaultValue());

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/CustomClassLoaderIntegrationTest.java
Patch:
@@ -21,7 +21,7 @@
 import org.junit.platform.launcher.core.LauncherFactory;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.tngtech.archunit.junit.FieldSelector.selectField;
+import static com.tngtech.archunit.junit.engine_api.FieldSelector.selectField;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;
 

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/internal/ArchRuleExecution.java
Patch:
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 import java.lang.reflect.Field;
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.lang.ArchRule;
 import org.junit.runner.Description;
 
-import static com.tngtech.archunit.junit.DisplayNameResolver.determineDisplayName;
+import static com.tngtech.archunit.junit.internal.DisplayNameResolver.determineDisplayName;
 
 class ArchRuleExecution extends ArchTestExecution {
     private final Field ruleField;

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/internal/ArchTestExecution.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 import java.lang.reflect.Field;
 
@@ -22,8 +22,8 @@
 import org.junit.runner.notification.Failure;
 import org.junit.runner.notification.RunNotifier;
 
-import static com.tngtech.archunit.junit.ArchTestInitializationException.WRAP_CAUSE;
-import static com.tngtech.archunit.junit.ReflectionUtils.getValueOrThrowException;
+import static com.tngtech.archunit.junit.internal.ArchTestInitializationException.WRAP_CAUSE;
+import static com.tngtech.archunit.junit.internal.ReflectionUtils.getValueOrThrowException;
 
 abstract class ArchTestExecution {
     final Class<?> testClass;

File: archunit-junit/junit5/engine-api/src/test/java/com/tngtech/archunit/junit/engine_api/FieldSelectorTest.java
Patch:
@@ -1,5 +1,6 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.engine_api;
 
+import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.lang.ArchRule;
 import org.junit.jupiter.api.Test;
 

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/internal/AbstractArchUnitTestDescriptor.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 import java.lang.reflect.AnnotatedElement;
 import java.util.Arrays;
@@ -22,6 +22,8 @@
 import java.util.Optional;
 import java.util.Set;
 
+import com.tngtech.archunit.junit.ArchIgnore;
+import com.tngtech.archunit.junit.ArchTag;
 import org.junit.platform.commons.support.AnnotationSupport;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestSource;

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/internal/ArchUnitEngineDescriptor.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.support.descriptor.EngineDescriptor;

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/internal/ArchUnitEngineExecutionContext.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 import org.junit.platform.engine.support.hierarchical.EngineExecutionContext;
 

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/internal/CreatesChildren.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 interface CreatesChildren {
     void createChildren(ElementResolver resolver);

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/EngineDiscoveryTestRequest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
@@ -9,6 +9,7 @@
 import java.util.Optional;
 
 import com.tngtech.archunit.core.domain.JavaClasses;
+import com.tngtech.archunit.junit.engine_api.FieldSelector;
 import org.junit.platform.engine.ConfigurationParameters;
 import org.junit.platform.engine.DiscoveryFilter;
 import org.junit.platform.engine.DiscoverySelector;
@@ -23,7 +24,7 @@
 import org.junit.platform.engine.discovery.PackageSelector;
 import org.junit.platform.engine.discovery.UniqueIdSelector;
 
-import static com.tngtech.archunit.junit.FieldSelector.selectField;
+import static com.tngtech.archunit.junit.engine_api.FieldSelector.selectField;
 import static java.util.Collections.emptyList;
 import static java.util.stream.Collectors.toList;
 import static java.util.stream.Collectors.toSet;

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/EngineExecutionTestListener.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 import java.util.ArrayList;
 import java.util.Collection;

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/ClassWithPrivateTests.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit.testexamples;
+package com.tngtech.archunit.junit.internal.testexamples;
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.AnalyzeClasses;

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/ComplexMetaTags.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit.testexamples;
+package com.tngtech.archunit.junit.internal.testexamples;
 
 import java.lang.annotation.Inherited;
 import java.lang.annotation.Retention;

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/ComplexRuleLibrary.java
Patch:
@@ -1,9 +1,9 @@
-package com.tngtech.archunit.junit.testexamples;
+package com.tngtech.archunit.junit.internal.testexamples;
 
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchTests;
-import com.tngtech.archunit.junit.testexamples.subtwo.SimpleRules;
+import com.tngtech.archunit.junit.internal.testexamples.subtwo.SimpleRules;
 
 @AnalyzeClasses(packages = "some.dummy.package")
 public class ComplexRuleLibrary {

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/ComplexTags.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit.testexamples;
+package com.tngtech.archunit.junit.internal.testexamples;
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.AnalyzeClasses;

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/FullAnalyzeClassesSpec.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit.testexamples;
+package com.tngtech.archunit.junit.internal.testexamples;
 
 import java.io.File;
 import java.util.Collections;
@@ -11,8 +11,8 @@
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.LocationProvider;
-import com.tngtech.archunit.junit.testexamples.FullAnalyzeClassesSpec.FirstLocationProvider;
-import com.tngtech.archunit.junit.testexamples.FullAnalyzeClassesSpec.SecondLocationProvider;
+import com.tngtech.archunit.junit.internal.testexamples.FullAnalyzeClassesSpec.FirstLocationProvider;
+import com.tngtech.archunit.junit.internal.testexamples.FullAnalyzeClassesSpec.SecondLocationProvider;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ArchRule;
 import com.tngtech.archunit.lang.ConditionEvents;

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/LibraryWithPrivateTests.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit.testexamples;
+package com.tngtech.archunit.junit.internal.testexamples;
 
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/RuleThatFails.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit.testexamples;
+package com.tngtech.archunit.junit.internal.testexamples;
 
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.lang.ArchCondition;

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/SimpleRuleLibrary.java
Patch:
@@ -1,10 +1,10 @@
-package com.tngtech.archunit.junit.testexamples;
+package com.tngtech.archunit.junit.internal.testexamples;
 
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchTests;
-import com.tngtech.archunit.junit.testexamples.subone.SimpleRuleField;
-import com.tngtech.archunit.junit.testexamples.subtwo.SimpleRules;
+import com.tngtech.archunit.junit.internal.testexamples.subone.SimpleRuleField;
+import com.tngtech.archunit.junit.internal.testexamples.subtwo.SimpleRules;
 
 @AnalyzeClasses(packages = "some.dummy.package")
 public class SimpleRuleLibrary {

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/TestClassWithMetaTag.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit.testexamples;
+package com.tngtech.archunit.junit.internal.testexamples;
 
 import java.lang.annotation.Inherited;
 import java.lang.annotation.Retention;
@@ -9,7 +9,7 @@
 import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchTests;
-import com.tngtech.archunit.junit.testexamples.subone.SimpleRuleField;
+import com.tngtech.archunit.junit.internal.testexamples.subone.SimpleRuleField;
 import com.tngtech.archunit.lang.ArchRule;
 
 import static java.lang.annotation.ElementType.FIELD;

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/TestClassWithMetaTags.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit.testexamples;
+package com.tngtech.archunit.junit.internal.testexamples;
 
 import java.lang.annotation.Inherited;
 import java.lang.annotation.Retention;
@@ -10,7 +10,7 @@
 import com.tngtech.archunit.junit.ArchTags;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchTests;
-import com.tngtech.archunit.junit.testexamples.subone.SimpleRuleField;
+import com.tngtech.archunit.junit.internal.testexamples.subone.SimpleRuleField;
 import com.tngtech.archunit.lang.ArchRule;
 
 import static java.lang.annotation.ElementType.FIELD;

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/TestClassWithTags.java
Patch:
@@ -1,11 +1,11 @@
-package com.tngtech.archunit.junit.testexamples;
+package com.tngtech.archunit.junit.internal.testexamples;
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchTests;
-import com.tngtech.archunit.junit.testexamples.subone.SimpleRuleField;
+import com.tngtech.archunit.junit.internal.testexamples.subone.SimpleRuleField;
 import com.tngtech.archunit.lang.ArchRule;
 
 @ArchTag("tag-one")

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/TestFieldWithTags.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit.testexamples;
+package com.tngtech.archunit.junit.internal.testexamples;
 
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTag;

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/TestMethodWithTags.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit.testexamples;
+package com.tngtech.archunit.junit.internal.testexamples;
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.AnalyzeClasses;

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/UnwantedClass.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit.testexamples;
+package com.tngtech.archunit.junit.internal.testexamples;
 
 public class UnwantedClass {
     public static final Class<?> CLASS_SATISFYING_RULES = Object.class;

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/ignores/IgnoredClass.java
Patch:
@@ -1,13 +1,13 @@
-package com.tngtech.archunit.junit.testexamples.ignores;
+package com.tngtech.archunit.junit.internal.testexamples.ignores;
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchIgnore;
 import com.tngtech.archunit.junit.ArchTest;
-import com.tngtech.archunit.junit.testexamples.RuleThatFails;
+import com.tngtech.archunit.junit.internal.testexamples.RuleThatFails;
 import com.tngtech.archunit.lang.ArchRule;
 
-import static com.tngtech.archunit.junit.testexamples.UnwantedClass.CLASS_VIOLATING_RULES;
+import static com.tngtech.archunit.junit.internal.testexamples.UnwantedClass.CLASS_VIOLATING_RULES;
 
 @ArchIgnore
 @AnalyzeClasses(packages = "some.dummy.package")

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/ignores/IgnoredField.java
Patch:
@@ -1,12 +1,12 @@
-package com.tngtech.archunit.junit.testexamples.ignores;
+package com.tngtech.archunit.junit.internal.testexamples.ignores;
 
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchIgnore;
 import com.tngtech.archunit.junit.ArchTest;
-import com.tngtech.archunit.junit.testexamples.RuleThatFails;
+import com.tngtech.archunit.junit.internal.testexamples.RuleThatFails;
 import com.tngtech.archunit.lang.ArchRule;
 
-import static com.tngtech.archunit.junit.testexamples.UnwantedClass.CLASS_VIOLATING_RULES;
+import static com.tngtech.archunit.junit.internal.testexamples.UnwantedClass.CLASS_VIOLATING_RULES;
 
 @AnalyzeClasses(packages = "some.dummy.package")
 public class IgnoredField {

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/ignores/IgnoredLibrary.java
Patch:
@@ -1,10 +1,10 @@
-package com.tngtech.archunit.junit.testexamples.ignores;
+package com.tngtech.archunit.junit.internal.testexamples.ignores;
 
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchIgnore;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchTests;
-import com.tngtech.archunit.junit.testexamples.subtwo.SimpleRules;
+import com.tngtech.archunit.junit.internal.testexamples.subtwo.SimpleRules;
 
 @AnalyzeClasses(packages = "some.dummy.package")
 public class IgnoredLibrary {

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/ignores/IgnoredMethod.java
Patch:
@@ -1,12 +1,12 @@
-package com.tngtech.archunit.junit.testexamples.ignores;
+package com.tngtech.archunit.junit.internal.testexamples.ignores;
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchIgnore;
 import com.tngtech.archunit.junit.ArchTest;
-import com.tngtech.archunit.junit.testexamples.RuleThatFails;
+import com.tngtech.archunit.junit.internal.testexamples.RuleThatFails;
 
-import static com.tngtech.archunit.junit.testexamples.UnwantedClass.CLASS_VIOLATING_RULES;
+import static com.tngtech.archunit.junit.internal.testexamples.UnwantedClass.CLASS_VIOLATING_RULES;
 
 @AnalyzeClasses(packages = "some.dummy.package")
 public class IgnoredMethod {

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/ignores/MetaIgnoredClass.java
Patch:
@@ -1,12 +1,12 @@
-package com.tngtech.archunit.junit.testexamples.ignores;
+package com.tngtech.archunit.junit.internal.testexamples.ignores;
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
-import com.tngtech.archunit.junit.testexamples.RuleThatFails;
+import com.tngtech.archunit.junit.internal.testexamples.RuleThatFails;
 import com.tngtech.archunit.lang.ArchRule;
 
-import static com.tngtech.archunit.junit.testexamples.UnwantedClass.CLASS_VIOLATING_RULES;
+import static com.tngtech.archunit.junit.internal.testexamples.UnwantedClass.CLASS_VIOLATING_RULES;
 
 @ArchIgnoreMetaAnnotation
 @AnalyzeClasses(packages = "some.dummy.package")

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/ignores/MetaIgnoredField.java
Patch:
@@ -1,11 +1,11 @@
-package com.tngtech.archunit.junit.testexamples.ignores;
+package com.tngtech.archunit.junit.internal.testexamples.ignores;
 
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
-import com.tngtech.archunit.junit.testexamples.RuleThatFails;
+import com.tngtech.archunit.junit.internal.testexamples.RuleThatFails;
 import com.tngtech.archunit.lang.ArchRule;
 
-import static com.tngtech.archunit.junit.testexamples.UnwantedClass.CLASS_VIOLATING_RULES;
+import static com.tngtech.archunit.junit.internal.testexamples.UnwantedClass.CLASS_VIOLATING_RULES;
 
 @AnalyzeClasses(packages = "some.dummy.package")
 public class MetaIgnoredField {

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/ignores/MetaIgnoredLibrary.java
Patch:
@@ -1,9 +1,9 @@
-package com.tngtech.archunit.junit.testexamples.ignores;
+package com.tngtech.archunit.junit.internal.testexamples.ignores;
 
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchTests;
-import com.tngtech.archunit.junit.testexamples.subtwo.SimpleRules;
+import com.tngtech.archunit.junit.internal.testexamples.subtwo.SimpleRules;
 
 @AnalyzeClasses(packages = "some.dummy.package")
 public class MetaIgnoredLibrary {

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/ignores/MetaIgnoredMethod.java
Patch:
@@ -1,11 +1,11 @@
-package com.tngtech.archunit.junit.testexamples.ignores;
+package com.tngtech.archunit.junit.internal.testexamples.ignores;
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
-import com.tngtech.archunit.junit.testexamples.RuleThatFails;
+import com.tngtech.archunit.junit.internal.testexamples.RuleThatFails;
 
-import static com.tngtech.archunit.junit.testexamples.UnwantedClass.CLASS_VIOLATING_RULES;
+import static com.tngtech.archunit.junit.internal.testexamples.UnwantedClass.CLASS_VIOLATING_RULES;
 
 @AnalyzeClasses(packages = "some.dummy.package")
 public class MetaIgnoredMethod {

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/subone/SimpleRuleField.java
Patch:
@@ -1,9 +1,9 @@
-package com.tngtech.archunit.junit.testexamples.subone;
+package com.tngtech.archunit.junit.internal.testexamples.subone;
 
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
-import com.tngtech.archunit.junit.testexamples.RuleThatFails;
-import com.tngtech.archunit.junit.testexamples.UnwantedClass;
+import com.tngtech.archunit.junit.internal.testexamples.RuleThatFails;
+import com.tngtech.archunit.junit.internal.testexamples.UnwantedClass;
 import com.tngtech.archunit.lang.ArchRule;
 
 @AnalyzeClasses(packages = "some.dummy.package")

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/subone/SimpleRuleMethod.java
Patch:
@@ -1,10 +1,10 @@
-package com.tngtech.archunit.junit.testexamples.subone;
+package com.tngtech.archunit.junit.internal.testexamples.subone;
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
-import com.tngtech.archunit.junit.testexamples.RuleThatFails;
-import com.tngtech.archunit.junit.testexamples.UnwantedClass;
+import com.tngtech.archunit.junit.internal.testexamples.RuleThatFails;
+import com.tngtech.archunit.junit.internal.testexamples.UnwantedClass;
 
 @AnalyzeClasses(packages = "some.dummy.package")
 public class SimpleRuleMethod {

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/subtwo/SimpleRules.java
Patch:
@@ -1,13 +1,13 @@
-package com.tngtech.archunit.junit.testexamples.subtwo;
+package com.tngtech.archunit.junit.internal.testexamples.subtwo;
 
 import java.util.Set;
 
 import com.google.common.collect.ImmutableSet;
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
-import com.tngtech.archunit.junit.testexamples.RuleThatFails;
-import com.tngtech.archunit.junit.testexamples.UnwantedClass;
+import com.tngtech.archunit.junit.internal.testexamples.RuleThatFails;
+import com.tngtech.archunit.junit.internal.testexamples.UnwantedClass;
 import com.tngtech.archunit.lang.ArchRule;
 
 @AnalyzeClasses(packages = "some.dummy.package")

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/wrong/WrongRuleMethodNotStatic.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit.testexamples.wrong;
+package com.tngtech.archunit.junit.internal.testexamples.wrong;
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.AnalyzeClasses;

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testexamples/wrong/WrongRuleMethodWrongParameters.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit.testexamples.wrong;
+package com.tngtech.archunit.junit.internal.testexamples.wrong;
 
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/internal/testutil/MockitoExtension.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit.testutil;
+package com.tngtech.archunit.junit.internal.testutil;
 
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.TestInstancePostProcessor;

File: archunit-junit/src/api/java/com/tngtech/archunit/junit/ArchTests.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.tngtech.archunit.junit;
 
+import com.tngtech.archunit.Internal;
 import com.tngtech.archunit.PublicAPI;
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
@@ -65,7 +66,8 @@ public static ArchTests in(Class<?> definitionLocation) {
         return new ArchTests(definitionLocation);
     }
 
-    Class<?> getDefinitionLocation() {
+    @Internal
+    public Class<?> getDefinitionLocation() {
         return definitionLocation;
     }
 }

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/internal/ArchTestExecutionException.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 class ArchTestExecutionException extends RuntimeException {
     ArchTestExecutionException(String message, Throwable throwable) {

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/internal/ArchTestInitializationException.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 import com.tngtech.archunit.base.Function;
 

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/internal/ClassAnalysisRequest.java
Patch:
@@ -1,6 +1,8 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 import com.tngtech.archunit.core.importer.ImportOption;
+import com.tngtech.archunit.junit.CacheMode;
+import com.tngtech.archunit.junit.LocationProvider;
 
 /**
  * Simple adapter to separate the JUnit version specific @AnalyzeClasses from infrastructure like {@link ClassCache}.

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/internal/DisplayNameResolver.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 import com.tngtech.archunit.ArchConfiguration;
 

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/internal/ReflectionUtils.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.AnnotatedElement;

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/internal/ClassCacheConcurrencyTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -10,7 +10,7 @@
 import com.tngtech.archunit.Slow;
 import com.tngtech.archunit.core.importer.ImportOptions;
 import com.tngtech.archunit.core.importer.Location;
-import com.tngtech.archunit.junit.ClassCache.CacheClassFileImporter;
+import com.tngtech.archunit.junit.internal.ClassCache.CacheClassFileImporter;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/internal/ClassCacheTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 import java.util.Collection;
 import java.util.Collections;
@@ -11,7 +11,8 @@
 import com.tngtech.archunit.core.importer.ImportOptions;
 import com.tngtech.archunit.core.importer.Location;
 import com.tngtech.archunit.core.importer.Locations;
-import com.tngtech.archunit.junit.ClassCache.CacheClassFileImporter;
+import com.tngtech.archunit.junit.LocationProvider;
+import com.tngtech.archunit.junit.internal.ClassCache.CacheClassFileImporter;
 import com.tngtech.archunit.testutil.ArchConfigurationRule;
 import com.tngtech.java.junit.dataprovider.DataProvider;
 import com.tngtech.java.junit.dataprovider.DataProviderRunner;

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/internal/DisplayNameResolverTest.java
Patch:
@@ -1,11 +1,11 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 import com.tngtech.archunit.ArchConfiguration;
 import com.tngtech.archunit.testutil.ArchConfigurationRule;
 import org.junit.Rule;
 import org.junit.Test;
 
-import static com.tngtech.archunit.junit.DisplayNameResolver.JUNIT_DISPLAYNAME_REPLACE_UNDERSCORES_BY_SPACES_PROPERTY_NAME;
+import static com.tngtech.archunit.junit.internal.DisplayNameResolver.JUNIT_DISPLAYNAME_REPLACE_UNDERSCORES_BY_SPACES_PROPERTY_NAME;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class DisplayNameResolverTest {
@@ -51,4 +51,4 @@ public void returns_original_name_if_property_is_unset() {
         // Then
         assertThat(displayName).isEqualTo("some_element_Name");
     }
-}
\ No newline at end of file
+}

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/internal/LocationOfClass.java
Patch:
@@ -1,11 +1,12 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Set;
 
 import com.tngtech.archunit.core.importer.Location;
 import com.tngtech.archunit.core.importer.Locations;
+import com.tngtech.archunit.junit.LocationProvider;
 
 @Retention(RetentionPolicy.RUNTIME)
 @interface LocationOfClass {

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/internal/ReflectionUtilsTest.java
Patch:
@@ -1,11 +1,11 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.util.Collection;
 
-import com.tngtech.archunit.junit.ReflectionUtils.Predicate;
+import com.tngtech.archunit.junit.internal.ReflectionUtils.Predicate;
 import org.junit.Test;
 
 import static com.tngtech.archunit.testutil.ReflectionTestUtils.field;

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/internal/TestAnalysisRequest.java
Patch:
@@ -1,6 +1,8 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.junit.internal;
 
 import com.tngtech.archunit.core.importer.ImportOption;
+import com.tngtech.archunit.junit.CacheMode;
+import com.tngtech.archunit.junit.LocationProvider;
 
 @SuppressWarnings("unchecked")
 class TestAnalysisRequest implements ClassAnalysisRequest {

File: archunit-junit/junit4/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerTest.java
Patch:
@@ -66,6 +66,7 @@ public void runner_creates_correct_analysis_request() {
         assertThat(analysisRequest.getPackageNames()).isEqualTo(analyzeClasses.packages());
         assertThat(analysisRequest.getPackageRoots()).isEqualTo(analyzeClasses.packagesOf());
         assertThat(analysisRequest.getLocationProviders()).isEqualTo(analyzeClasses.locations());
+        assertThat(analysisRequest.scanWholeClasspath()).as("scan whole classpath").isTrue();
         assertThat(analysisRequest.getImportOptions()).isEqualTo(analyzeClasses.importOptions());
     }
 
@@ -149,11 +150,12 @@ public boolean includes(Location location) {
             packages = {"com.foo", "com.bar"},
             packagesOf = {ArchUnitRunner.class, ArchUnitRunnerTest.class},
             locations = {DummyLocation.class, OtherDummyLocation.class},
+            wholeClasspath = true,
             importOptions = {DummyImportOption.class, OtherDummyImportOption.class}
     )
     public static class MaxAnnotatedTest {
         @ArchTest
         public static void someTest(JavaClasses classes) {
         }
     }
-}
\ No newline at end of file
+}

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/ArchUnitTestEngineTest.java
Patch:
@@ -879,6 +879,7 @@ void passes_AnalyzeClasses_to_cache() {
             assertThat(request.getPackageNames()).isEqualTo(expected.packages());
             assertThat(request.getPackageRoots()).isEqualTo(expected.packagesOf());
             assertThat(request.getLocationProviders()).isEqualTo(expected.locations());
+            assertThat(request.scanWholeClasspath()).as("scan whole classpath").isTrue();
             assertThat(request.getImportOptions()).isEqualTo(expected.importOptions());
         }
 

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/testexamples/FullAnalyzeClassesSpec.java
Patch:
@@ -23,6 +23,7 @@
         packages = {"first.pkg", "second.pkg"},
         packagesOf = {Object.class, File.class},
         locations = {FirstLocationProvider.class, SecondLocationProvider.class},
+        wholeClasspath = true,
         importOptions = {DoNotIncludeTests.class, DoNotIncludeJars.class})
 public class FullAnalyzeClassesSpec {
     @ArchTest

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ClassAnalysisRequest.java
Patch:
@@ -15,4 +15,6 @@ interface ClassAnalysisRequest {
     Class<? extends ImportOption>[] getImportOptions();
 
     CacheMode getCacheMode();
+
+    boolean scanWholeClasspath();
 }

File: archunit-junit/junit4/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerTest.java
Patch:
@@ -66,6 +66,7 @@ public void runner_creates_correct_analysis_request() {
         assertThat(analysisRequest.getPackageNames()).isEqualTo(analyzeClasses.packages());
         assertThat(analysisRequest.getPackageRoots()).isEqualTo(analyzeClasses.packagesOf());
         assertThat(analysisRequest.getLocationProviders()).isEqualTo(analyzeClasses.locations());
+        assertThat(analysisRequest.scanWholeClasspath()).as("scan whole classpath").isTrue();
         assertThat(analysisRequest.getImportOptions()).isEqualTo(analyzeClasses.importOptions());
     }
 
@@ -149,11 +150,12 @@ public boolean includes(Location location) {
             packages = {"com.foo", "com.bar"},
             packagesOf = {ArchUnitRunner.class, ArchUnitRunnerTest.class},
             locations = {DummyLocation.class, OtherDummyLocation.class},
+            wholeClasspath = true,
             importOptions = {DummyImportOption.class, OtherDummyImportOption.class}
     )
     public static class MaxAnnotatedTest {
         @ArchTest
         public static void someTest(JavaClasses classes) {
         }
     }
-}
\ No newline at end of file
+}

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/ArchUnitTestEngineTest.java
Patch:
@@ -879,6 +879,7 @@ void passes_AnalyzeClasses_to_cache() {
             assertThat(request.getPackageNames()).isEqualTo(expected.packages());
             assertThat(request.getPackageRoots()).isEqualTo(expected.packagesOf());
             assertThat(request.getLocationProviders()).isEqualTo(expected.locations());
+            assertThat(request.scanWholeClasspath()).as("scan whole classpath").isTrue();
             assertThat(request.getImportOptions()).isEqualTo(expected.importOptions());
         }
 

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/testexamples/FullAnalyzeClassesSpec.java
Patch:
@@ -23,6 +23,7 @@
         packages = {"first.pkg", "second.pkg"},
         packagesOf = {Object.class, File.class},
         locations = {FirstLocationProvider.class, SecondLocationProvider.class},
+        wholeClasspath = true,
         importOptions = {DoNotIncludeTests.class, DoNotIncludeJars.class})
 public class FullAnalyzeClassesSpec {
     @ArchTest

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ClassAnalysisRequest.java
Patch:
@@ -15,4 +15,6 @@ interface ClassAnalysisRequest {
     Class<? extends ImportOption>[] getImportOptions();
 
     CacheMode getCacheMode();
+
+    boolean scanWholeClasspath();
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/CodeUnitsThat.java
Patch:
@@ -25,7 +25,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
-public interface CodeUnitsThat<CONJUNCTION extends GivenCodeUnitsConjunction<?>> extends MembersThat<CONJUNCTION> {
+public interface CodeUnitsThat<CONJUNCTION> extends MembersThat<CONJUNCTION> {
 
     /**
      * Matches {@link JavaCodeUnit JavaCodeUnits} that have the specified raw parameter types.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/FieldsThat.java
Patch:
@@ -22,7 +22,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
-public interface FieldsThat<CONJUNCTION extends GivenFieldsConjunction> extends MembersThat<CONJUNCTION> {
+public interface FieldsThat<CONJUNCTION> extends MembersThat<CONJUNCTION> {
 
     /**
      * Matches fields by their raw type. Take for example

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenFields.java
Patch:
@@ -26,7 +26,7 @@ public interface GivenFields extends GivenMembers<JavaField> {
 
     @Override
     @PublicAPI(usage = ACCESS)
-    FieldsThat<?> that();
+    FieldsThat<? extends GivenFieldsConjunction> that();
 
     @Override
     @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenFieldsConjunction.java
Patch:
@@ -26,11 +26,11 @@ public interface GivenFieldsConjunction extends GivenMembersConjunction<JavaFiel
 
     @Override
     @PublicAPI(usage = ACCESS)
-    FieldsThat<?> and();
+    FieldsThat<? extends GivenFieldsConjunction> and();
 
     @Override
     @PublicAPI(usage = ACCESS)
-    FieldsThat<?> or();
+    FieldsThat<? extends GivenFieldsConjunction> or();
 
     @Override
     @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenMethods.java
Patch:
@@ -26,7 +26,7 @@ public interface GivenMethods extends GivenCodeUnits<JavaMethod> {
 
     @Override
     @PublicAPI(usage = ACCESS)
-    MethodsThat<?> that();
+    MethodsThat<? extends GivenMethodsConjunction> that();
 
     @Override
     @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenMethodsConjunction.java
Patch:
@@ -26,11 +26,11 @@ public interface GivenMethodsConjunction extends GivenCodeUnitsConjunction<JavaM
 
     @Override
     @PublicAPI(usage = ACCESS)
-    MethodsThat<?> and();
+    MethodsThat<? extends GivenMethodsConjunction> and();
 
     @Override
     @PublicAPI(usage = ACCESS)
-    MethodsThat<?> or();
+    MethodsThat<? extends GivenMethodsConjunction> or();
 
     @Override
     @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MembersThat.java
Patch:
@@ -27,7 +27,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
-public interface MembersThat<CONJUNCTION extends GivenMembersConjunction<?>> {
+public interface MembersThat<CONJUNCTION> {
 
     /**
      * Matches members by their name (i.e. field name, method name or {@link JavaConstructor#CONSTRUCTOR_NAME}).

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MethodsThat.java
Patch:
@@ -19,7 +19,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
-public interface MethodsThat<CONJUNCTION extends GivenMethodsConjunction> extends CodeUnitsThat<CONJUNCTION> {
+public interface MethodsThat<CONJUNCTION> extends CodeUnitsThat<CONJUNCTION> {
 
     /**
      * Matches static methods.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/CodeUnitsThat.java
Patch:
@@ -25,7 +25,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
-public interface CodeUnitsThat<CONJUNCTION extends GivenCodeUnitsConjunction<?>> extends MembersThat<CONJUNCTION> {
+public interface CodeUnitsThat<CONJUNCTION> extends MembersThat<CONJUNCTION> {
 
     /**
      * Matches {@link JavaCodeUnit JavaCodeUnits} that have the specified raw parameter types.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/FieldsThat.java
Patch:
@@ -22,7 +22,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
-public interface FieldsThat<CONJUNCTION extends GivenFieldsConjunction> extends MembersThat<CONJUNCTION> {
+public interface FieldsThat<CONJUNCTION> extends MembersThat<CONJUNCTION> {
 
     /**
      * Matches fields by their raw type. Take for example

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenFields.java
Patch:
@@ -26,7 +26,7 @@ public interface GivenFields extends GivenMembers<JavaField> {
 
     @Override
     @PublicAPI(usage = ACCESS)
-    FieldsThat<?> that();
+    FieldsThat<? extends GivenFieldsConjunction> that();
 
     @Override
     @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenFieldsConjunction.java
Patch:
@@ -26,11 +26,11 @@ public interface GivenFieldsConjunction extends GivenMembersConjunction<JavaFiel
 
     @Override
     @PublicAPI(usage = ACCESS)
-    FieldsThat<?> and();
+    FieldsThat<? extends GivenFieldsConjunction> and();
 
     @Override
     @PublicAPI(usage = ACCESS)
-    FieldsThat<?> or();
+    FieldsThat<? extends GivenFieldsConjunction> or();
 
     @Override
     @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenMethods.java
Patch:
@@ -26,7 +26,7 @@ public interface GivenMethods extends GivenCodeUnits<JavaMethod> {
 
     @Override
     @PublicAPI(usage = ACCESS)
-    MethodsThat<?> that();
+    MethodsThat<? extends GivenMethodsConjunction> that();
 
     @Override
     @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenMethodsConjunction.java
Patch:
@@ -26,11 +26,11 @@ public interface GivenMethodsConjunction extends GivenCodeUnitsConjunction<JavaM
 
     @Override
     @PublicAPI(usage = ACCESS)
-    MethodsThat<?> and();
+    MethodsThat<? extends GivenMethodsConjunction> and();
 
     @Override
     @PublicAPI(usage = ACCESS)
-    MethodsThat<?> or();
+    MethodsThat<? extends GivenMethodsConjunction> or();
 
     @Override
     @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MembersThat.java
Patch:
@@ -27,7 +27,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
-public interface MembersThat<CONJUNCTION extends GivenMembersConjunction<?>> {
+public interface MembersThat<CONJUNCTION> {
 
     /**
      * Matches members by their name (i.e. field name, method name or {@link JavaConstructor#CONSTRUCTOR_NAME}).

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MethodsThat.java
Patch:
@@ -19,7 +19,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
-public interface MethodsThat<CONJUNCTION extends GivenMethodsConjunction> extends CodeUnitsThat<CONJUNCTION> {
+public interface MethodsThat<CONJUNCTION> extends CodeUnitsThat<CONJUNCTION> {
 
     /**
      * Matches static methods.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ImportOption.java
Patch:
@@ -91,7 +91,7 @@ public boolean includes(Location location) {
 
         static final PatternPredicate MAVEN_TEST_PATTERN = new PatternPredicate(".*/target/test-classes/.*");
         static final PatternPredicate GRADLE_TEST_PATTERN = new PatternPredicate(".*/build/classes/([^/]+/)?test/.*");
-        static final PatternPredicate INTELLIJ_TEST_PATTERN = new PatternPredicate(".*/out/test/classes/.*");
+        static final PatternPredicate INTELLIJ_TEST_PATTERN = new PatternPredicate(".*/out/test/.*");
         static final Predicate<Location> TEST_LOCATION = or(MAVEN_TEST_PATTERN, GRADLE_TEST_PATTERN, INTELLIJ_TEST_PATTERN);
         static final Predicate<Location> NO_TEST_LOCATION = not(TEST_LOCATION);
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportOptionsTest.java
Patch:
@@ -90,6 +90,7 @@ private static List<FolderPattern> getFolderPatterns() {
                 // IntelliJ
                 new FolderPattern("out", "production", "classes").expectMainFolder(),
                 new FolderPattern("out", "test", "classes").expectTestFolder(),
+                new FolderPattern("out", "test", "some-module").expectTestFolder(),
                 new FolderPattern("out", "test", "classes", "my", "test").expectTestFolder(),
                 new FolderPattern("out", "some", "classes").expectMainFolder()
         );

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -2450,11 +2450,11 @@ public static DescribedPredicate<JavaClass> containAnyConstructorsThat(Described
         }
 
         /**
-         * A predicate to determine if a {@link JavaClass} contains one or more {@link JavaConstructor constructors} matching the supplied predicate.
+         * A predicate to determine if a {@link JavaClass} contains one or more {@link JavaStaticInitializer static initializers} matching the supplied predicate.
          *
-         * @param predicate The predicate to check against the {@link JavaClass classes'} constructors.
+         * @param predicate The predicate to check against the {@link JavaClass classes'} static initializers.
          * @return A {@link DescribedPredicate} returning true, if and only if the tested {@link JavaClass} contains at least
-         * one constructor matching the given predicate.
+         * one static initializer matching the given predicate.
          */
         @PublicAPI(usage = ACCESS)
         public static DescribedPredicate<JavaClass> containAnyStaticInitializersThat(DescribedPredicate<? super JavaStaticInitializer> predicate) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -2450,11 +2450,11 @@ public static DescribedPredicate<JavaClass> containAnyConstructorsThat(Described
         }
 
         /**
-         * A predicate to determine if a {@link JavaClass} contains one or more {@link JavaConstructor constructors} matching the supplied predicate.
+         * A predicate to determine if a {@link JavaClass} contains one or more {@link JavaStaticInitializer static initializers} matching the supplied predicate.
          *
-         * @param predicate The predicate to check against the {@link JavaClass classes'} constructors.
+         * @param predicate The predicate to check against the {@link JavaClass classes'} static initializers.
          * @return A {@link DescribedPredicate} returning true, if and only if the tested {@link JavaClass} contains at least
-         * one constructor matching the given predicate.
+         * one static initializer matching the given predicate.
          */
         @PublicAPI(usage = ACCESS)
         public static DescribedPredicate<JavaClass> containAnyStaticInitializersThat(DescribedPredicate<? super JavaStaticInitializer> predicate) {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/DependencyResolutionProcess.java
Patch:
@@ -124,7 +124,7 @@ void resolve(ImportedClasses classes) {
     }
 
     private void logConfiguration() {
-        log.info("Automatically resolving transitive class dependencies with the following configuration:{}{}{}{}{}{}",
+        log.debug("Automatically resolving transitive class dependencies with the following configuration:{}{}{}{}{}{}",
                 formatConfigProperty(MAX_ITERATIONS_FOR_MEMBER_TYPES_PROPERTY_NAME, maxRunsForMemberTypes),
                 formatConfigProperty(MAX_ITERATIONS_FOR_ACCESSES_TO_TYPES_PROPERTY_NAME, maxRunsForAccessesToTypes),
                 formatConfigProperty(MAX_ITERATIONS_FOR_SUPERTYPES_PROPERTY_NAME, maxRunsForSupertypes),

File: archunit/src/main/java/com/tngtech/archunit/core/importer/RawAccessRecord.java
Patch:
@@ -22,7 +22,6 @@
 import com.tngtech.archunit.core.domain.JavaClassDescriptor;
 import com.tngtech.archunit.core.domain.JavaCodeUnit;
 import com.tngtech.archunit.core.domain.JavaFieldAccess.AccessType;
-import com.tngtech.archunit.core.domain.properties.HasName;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
@@ -139,8 +138,7 @@ public String toString() {
 
         public boolean is(JavaCodeUnit method) {
             return getName().equals(method.getName())
-                    && getRawParameterTypeNames().equals(HasName.Utils.namesOf(method.getRawParameterTypes()))
-                    && returnType.getFullyQualifiedClassName().equals(method.getRawReturnType().getName())
+                    && descriptor.equals(method.getDescriptor())
                     && getDeclaringClassName().equals(method.getOwner().getName());
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/RawAccessRecord.java
Patch:
@@ -22,7 +22,6 @@
 import com.tngtech.archunit.core.domain.JavaClassDescriptor;
 import com.tngtech.archunit.core.domain.JavaCodeUnit;
 import com.tngtech.archunit.core.domain.JavaFieldAccess.AccessType;
-import com.tngtech.archunit.core.domain.properties.HasName;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
@@ -139,8 +138,7 @@ public String toString() {
 
         public boolean is(JavaCodeUnit method) {
             return getName().equals(method.getName())
-                    && getRawParameterTypeNames().equals(HasName.Utils.namesOf(method.getRawParameterTypes()))
-                    && returnType.getFullyQualifiedClassName().equals(method.getRawReturnType().getName())
+                    && descriptor.equals(method.getDescriptor())
                     && getDeclaringClassName().equals(method.getOwner().getName());
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/DependencyResolutionProcess.java
Patch:
@@ -124,7 +124,7 @@ void resolve(ImportedClasses classes) {
     }
 
     private void logConfiguration() {
-        log.info("Automatically resolving transitive class dependencies with the following configuration:{}{}{}{}{}{}",
+        log.debug("Automatically resolving transitive class dependencies with the following configuration:{}{}{}{}{}{}",
                 formatConfigProperty(MAX_ITERATIONS_FOR_MEMBER_TYPES_PROPERTY_NAME, maxRunsForMemberTypes),
                 formatConfigProperty(MAX_ITERATIONS_FOR_ACCESSES_TO_TYPES_PROPERTY_NAME, maxRunsForAccessesToTypes),
                 formatConfigProperty(MAX_ITERATIONS_FOR_SUPERTYPES_PROPERTY_NAME, maxRunsForSupertypes),

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportTestUtils.java
Patch:
@@ -43,6 +43,7 @@
 import com.tngtech.archunit.core.domain.JavaType;
 import com.tngtech.archunit.core.domain.JavaTypeVariable;
 import com.tngtech.archunit.core.importer.DomainBuilders.FieldAccessTargetBuilder;
+import com.tngtech.archunit.core.importer.DomainBuilders.JavaAnnotationBuilder.ValueBuilder;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaMethodCallBuilder;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaTypeCreationProcess;
 import com.tngtech.archunit.core.importer.resolvers.ClassResolver;
@@ -270,7 +271,7 @@ private static DomainBuilders.JavaAnnotationBuilder javaAnnotationBuilderFrom(An
         DomainBuilders.JavaAnnotationBuilder builder = new DomainBuilders.JavaAnnotationBuilder()
                 .withType(JavaClassDescriptor.From.name(annotation.annotationType().getName()));
         for (Map.Entry<String, Object> entry : mapOf(annotation, annotatedClass, importedClasses).entrySet()) {
-            builder.addProperty(entry.getKey(), DomainBuilders.JavaAnnotationBuilder.ValueBuilder.ofFinished(entry.getValue()));
+            builder.addProperty(entry.getKey(), ValueBuilder.fromPrimitiveProperty(entry.getValue()));
         }
         return builder;
     }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/annotatedparameters/ClassWithMethodWithAnnotatedParameters.java
Patch:
@@ -78,7 +78,7 @@ <T> void methodWithAnnotatedParametersGap(
     }
 
     @Retention(RUNTIME)
-    @interface SomeParameterAnnotation {
+    public @interface SomeParameterAnnotation {
         SomeEnum value();
 
         SomeEnum valueWithDefault() default SOME_VALUE;

File: archunit/src/test/java/com/tngtech/archunit/lang/extension/ArchUnitExtensionsTest.java
Patch:
@@ -1,6 +1,5 @@
 package com.tngtech.archunit.lang.extension;
 
-import java.io.IOException;
 import java.util.Properties;
 
 import com.google.common.collect.ImmutableSet;
@@ -39,7 +38,7 @@ public class ArchUnitExtensionsTest {
     private ArchUnitExtensions extensions;
 
     @Test
-    public void extensions_are_configured() throws IOException {
+    public void extensions_are_configured() {
         TestExtension extensionOne = new TestExtension("one");
         TestExtension extensionTwo = new TestExtension("two");
         when(extensionLoader.getAll()).thenReturn(ImmutableSet.<ArchUnitExtension>of(extensionOne, extensionTwo));

File: archunit/src/main/java/com/tngtech/archunit/core/importer/DeclarationHandler.java
Patch:
@@ -58,4 +58,6 @@ interface DeclarationHandler {
     void onDeclaredInstanceofCheck(String typeName);
 
     void onDeclaredThrowsClause(Collection<String> exceptionTypeNames);
+
+    void onDeclaredGenericSignatureType(String typeName);
 }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -236,7 +236,7 @@ public FieldVisitor visitField(int access, String name, String desc, String sign
         }
 
         JavaClassDescriptor rawType = JavaClassDescriptorImporter.importAsmTypeFromDescriptor(desc);
-        Optional<JavaTypeCreationProcess<JavaField>> genericType = JavaFieldTypeSignatureImporter.parseAsmFieldTypeSignature(signature);
+        Optional<JavaTypeCreationProcess<JavaField>> genericType = JavaFieldTypeSignatureImporter.parseAsmFieldTypeSignature(signature, declarationHandler);
         DomainBuilders.JavaFieldBuilder fieldBuilder = new DomainBuilders.JavaFieldBuilder()
                 .withName(name)
                 .withType(genericType, rawType)
@@ -258,7 +258,7 @@ public MethodVisitor visitMethod(int access, String name, String desc, String si
 
         JavaClassDescriptor rawReturnType = JavaClassDescriptorImporter.importAsmMethodReturnType(desc);
         DomainBuilders.JavaCodeUnitBuilder<?, ?> codeUnitBuilder = addCodeUnitBuilder(name, codeUnit.getRawParameterTypeNames(), rawReturnType.getFullyQualifiedClassName());
-        JavaCodeUnitSignature codeUnitSignature = JavaCodeUnitSignatureImporter.parseAsmMethodSignature(signature);
+        JavaCodeUnitSignature codeUnitSignature = JavaCodeUnitSignatureImporter.parseAsmMethodSignature(signature, declarationHandler);
         List<JavaClassDescriptor> throwsDeclarations = typesFrom(exceptions);
         codeUnitBuilder
                 .withName(name)

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileProcessor.java
Patch:
@@ -168,6 +168,7 @@ public void onDeclaredAnnotationDefaultValue(String methodName, String methodDes
         @Override
         public void registerEnclosingClass(String ownerName, String enclosingClassName) {
             importRecord.setEnclosingClass(ownerName, enclosingClassName);
+            dependencyResolutionProcess.registerEnclosingType(enclosingClassName);
         }
 
         @Override

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -98,7 +98,7 @@ public Optional<JavaClass> getReturnType(String declaringClassName, String metho
     }
 
     JavaClasses complete() {
-        dependencyResolutionProcess.resolve(classes, importRecord);
+        dependencyResolutionProcess.resolve(classes);
         completeClasses();
         completeAccesses();
         return createJavaClasses(classes.getDirectlyImported(), classes.getAllWithOuterClassesSortedBeforeInnerClasses(), this);

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileProcessor.java
Patch:
@@ -92,8 +92,10 @@ public void onNewClass(String className, Optional<String> superclassName, List<S
             ownerName = className;
             if (superclassName.isPresent()) {
                 importRecord.setSuperclass(ownerName, superclassName.get());
+                dependencyResolutionProcess.registerSupertype(superclassName.get());
             }
             importRecord.addInterfaces(ownerName, interfaceNames);
+            dependencyResolutionProcess.registerSupertypes(interfaceNames);
         }
 
         @Override

File: archunit-integration-test/src/test/java/com/tngtech/archunit/ArchUnitArchitectureTest.java
Patch:
@@ -6,7 +6,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.base.MayResolveTypesViaReflection;
-import com.tngtech.archunit.core.ResolvesTypesViaReflection;
+import com.tngtech.archunit.base.ResolvesTypesViaReflection;
 import com.tngtech.archunit.core.domain.JavaAccess;
 import com.tngtech.archunit.core.domain.JavaAccess.Functions.Get;
 import com.tngtech.archunit.core.domain.JavaCall;

File: archunit/src/main/java/com/tngtech/archunit/base/ResolvesTypesViaReflection.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.base;
 
 import java.lang.annotation.Retention;
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -35,7 +35,7 @@
 import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.base.PackageMatcher;
-import com.tngtech.archunit.core.ResolvesTypesViaReflection;
+import com.tngtech.archunit.base.ResolvesTypesViaReflection;
 import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
 import com.tngtech.archunit.core.domain.properties.HasAnnotations;
 import com.tngtech.archunit.core.domain.properties.HasModifiers;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassDescriptor.java
Patch:
@@ -31,7 +31,7 @@
 import com.tngtech.archunit.base.ArchUnitException.ReflectionException;
 import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.base.Optional;
-import com.tngtech.archunit.core.ResolvesTypesViaReflection;
+import com.tngtech.archunit.base.ResolvesTypesViaReflection;
 import org.objectweb.asm.Type;
 
 import static com.google.common.base.Preconditions.checkArgument;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaCodeUnit.java
Patch:
@@ -29,7 +29,7 @@
 import com.tngtech.archunit.base.ForwardingList;
 import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.base.Optional;
-import com.tngtech.archunit.core.ResolvesTypesViaReflection;
+import com.tngtech.archunit.base.ResolvesTypesViaReflection;
 import com.tngtech.archunit.core.domain.properties.HasParameterTypes;
 import com.tngtech.archunit.core.domain.properties.HasReturnType;
 import com.tngtech.archunit.core.domain.properties.HasThrowsClause;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaConstructor.java
Patch:
@@ -25,7 +25,7 @@
 import com.tngtech.archunit.base.ArchUnitException.InconsistentClassPathException;
 import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.base.Optional;
-import com.tngtech.archunit.core.ResolvesTypesViaReflection;
+import com.tngtech.archunit.base.ResolvesTypesViaReflection;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaConstructorBuilder;
 
 import static com.google.common.collect.Sets.union;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaField.java
Patch:
@@ -24,7 +24,7 @@
 import com.tngtech.archunit.base.ArchUnitException.InconsistentClassPathException;
 import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.base.Optional;
-import com.tngtech.archunit.core.ResolvesTypesViaReflection;
+import com.tngtech.archunit.base.ResolvesTypesViaReflection;
 import com.tngtech.archunit.core.domain.properties.HasType;
 import com.tngtech.archunit.core.importer.DomainBuilders;
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMethod.java
Patch:
@@ -26,7 +26,7 @@
 import com.tngtech.archunit.base.Function;
 import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.base.Optional;
-import com.tngtech.archunit.core.ResolvesTypesViaReflection;
+import com.tngtech.archunit.base.ResolvesTypesViaReflection;
 import com.tngtech.archunit.core.importer.DomainBuilders;
 
 import static com.google.common.collect.Sets.union;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/ArchUnitArchitectureTest.java
Patch:
@@ -5,7 +5,7 @@
 
 import com.google.common.collect.ImmutableSet;
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.core.MayResolveTypesViaReflection;
+import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.core.ResolvesTypesViaReflection;
 import com.tngtech.archunit.core.domain.JavaAccess;
 import com.tngtech.archunit.core.domain.JavaAccess.Functions.Get;

File: archunit-junit/junit5/engine-api/src/main/java/com/tngtech/archunit/junit/FieldSelector.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.Objects;
 
 import com.tngtech.archunit.PublicAPI;
-import com.tngtech.archunit.core.MayResolveTypesViaReflection;
+import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import org.junit.platform.engine.DiscoverySelector;
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/ArchUnitTestEngine.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.stream.Stream;
 
 import com.tngtech.archunit.Internal;
-import com.tngtech.archunit.core.MayResolveTypesViaReflection;
+import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
 import org.junit.platform.engine.EngineDiscoveryRequest;

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/ElementResolver.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 
-import com.tngtech.archunit.core.MayResolveTypesViaReflection;
+import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.UniqueId;
 

File: archunit/src/main/java/com/tngtech/archunit/base/MayResolveTypesViaReflection.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.base;
 
 import java.lang.annotation.Retention;
 

File: archunit/src/main/java/com/tngtech/archunit/core/PluginLoader.java
Patch:
@@ -25,6 +25,7 @@
 import com.google.common.base.Supplier;
 import com.google.common.collect.Ordering;
 import com.tngtech.archunit.Internal;
+import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AnnotationProxy.java
Patch:
@@ -29,9 +29,9 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
+import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.InitialConfiguration;
-import com.tngtech.archunit.core.MayResolveTypesViaReflection;
 
 import static com.google.common.base.Preconditions.checkArgument;
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -32,9 +32,9 @@
 import com.tngtech.archunit.base.ChainableFunction;
 import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.base.Function;
+import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.base.PackageMatcher;
-import com.tngtech.archunit.core.MayResolveTypesViaReflection;
 import com.tngtech.archunit.core.ResolvesTypesViaReflection;
 import com.tngtech.archunit.core.domain.properties.CanBeAnnotated;
 import com.tngtech.archunit.core.domain.properties.HasAnnotations;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassDescriptor.java
Patch:
@@ -29,8 +29,8 @@
 import com.google.common.collect.Maps;
 import com.tngtech.archunit.Internal;
 import com.tngtech.archunit.base.ArchUnitException.ReflectionException;
+import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.base.Optional;
-import com.tngtech.archunit.core.MayResolveTypesViaReflection;
 import com.tngtech.archunit.core.ResolvesTypesViaReflection;
 import org.objectweb.asm.Type;
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaCodeUnit.java
Patch:
@@ -27,8 +27,8 @@
 import com.tngtech.archunit.base.ChainableFunction;
 import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.base.ForwardingList;
+import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.base.Optional;
-import com.tngtech.archunit.core.MayResolveTypesViaReflection;
 import com.tngtech.archunit.core.ResolvesTypesViaReflection;
 import com.tngtech.archunit.core.domain.properties.HasParameterTypes;
 import com.tngtech.archunit.core.domain.properties.HasReturnType;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaConstructor.java
Patch:
@@ -23,8 +23,8 @@
 import com.google.common.base.Suppliers;
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.ArchUnitException.InconsistentClassPathException;
+import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.base.Optional;
-import com.tngtech.archunit.core.MayResolveTypesViaReflection;
 import com.tngtech.archunit.core.ResolvesTypesViaReflection;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaConstructorBuilder;
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaField.java
Patch:
@@ -22,8 +22,8 @@
 import com.google.common.base.Suppliers;
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.ArchUnitException.InconsistentClassPathException;
+import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.base.Optional;
-import com.tngtech.archunit.core.MayResolveTypesViaReflection;
 import com.tngtech.archunit.core.ResolvesTypesViaReflection;
 import com.tngtech.archunit.core.domain.properties.HasType;
 import com.tngtech.archunit.core.importer.DomainBuilders;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMethod.java
Patch:
@@ -24,8 +24,8 @@
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.ArchUnitException.InconsistentClassPathException;
 import com.tngtech.archunit.base.Function;
+import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.base.Optional;
-import com.tngtech.archunit.core.MayResolveTypesViaReflection;
 import com.tngtech.archunit.core.ResolvesTypesViaReflection;
 import com.tngtech.archunit.core.importer.DomainBuilders;
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -36,8 +36,8 @@
 import com.google.common.primitives.Shorts;
 import com.tngtech.archunit.Internal;
 import com.tngtech.archunit.base.HasDescription;
+import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.base.Optional;
-import com.tngtech.archunit.core.MayResolveTypesViaReflection;
 import com.tngtech.archunit.core.domain.JavaAnnotation;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClassDescriptor;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/ClassResolver.java
Patch:
@@ -24,8 +24,8 @@
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.ArchUnitException.ClassResolverConfigurationException;
 import com.tngtech.archunit.base.Function;
+import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.base.Optional;
-import com.tngtech.archunit.core.MayResolveTypesViaReflection;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/ClassResolverFromClasspath.java
Patch:
@@ -20,8 +20,8 @@
 import java.net.URL;
 
 import com.tngtech.archunit.base.ArchUnitException;
+import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.base.Optional;
-import com.tngtech.archunit.core.MayResolveTypesViaReflection;
 import com.tngtech.archunit.core.domain.JavaClass;
 
 import static com.google.common.base.Preconditions.checkNotNull;

File: archunit/src/main/java/com/tngtech/archunit/lang/FailureDisplayFormatFactory.java
Patch:
@@ -18,7 +18,7 @@
 import com.google.common.base.Joiner;
 import com.tngtech.archunit.ArchConfiguration;
 import com.tngtech.archunit.base.HasDescription;
-import com.tngtech.archunit.core.MayResolveTypesViaReflection;
+import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 
 import static com.tngtech.archunit.base.ReflectionUtils.newInstanceOf;
 import static java.lang.System.lineSeparator;

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/ViolationLineMatcherFactory.java
Patch:
@@ -16,7 +16,7 @@
 package com.tngtech.archunit.library.freeze;
 
 import com.tngtech.archunit.ArchConfiguration;
-import com.tngtech.archunit.core.MayResolveTypesViaReflection;
+import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 
 import static com.tngtech.archunit.base.ReflectionUtils.newInstanceOf;
 import static java.lang.Character.isDigit;

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/ViolationStoreFactory.java
Patch:
@@ -30,7 +30,7 @@
 import com.google.common.base.Splitter;
 import com.google.common.io.Files;
 import com.tngtech.archunit.ArchConfiguration;
-import com.tngtech.archunit.core.MayResolveTypesViaReflection;
+import com.tngtech.archunit.base.MayResolveTypesViaReflection;
 import com.tngtech.archunit.lang.ArchRule;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: archunit/src/main/java/com/tngtech/archunit/lang/ConditionEvents.java
Patch:
@@ -50,9 +50,9 @@ public void add(ConditionEvent event) {
     /**
      * Can be used to override the information about the number of violations. If absent the violated rule
      * will simply report the number of violation lines as the number of violations (which is typically
-     * correct, since ArchUnit usually reports one violation per line). However in cases where
+     * correct, since ArchUnit usually reports one violation per line). However, in cases where
      * violations are omitted (e.g. because a limit of reported violations is configured), this information
-     * can be supplied here to inform users there there actually were more violations than reported.
+     * can be supplied here to inform users that there actually were more violations than reported.
      * @param informationAboutNumberOfViolations The text to be shown for the number of times a rule has been violated
      */
     @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/lang/ConditionEvents.java
Patch:
@@ -50,9 +50,9 @@ public void add(ConditionEvent event) {
     /**
      * Can be used to override the information about the number of violations. If absent the violated rule
      * will simply report the number of violation lines as the number of violations (which is typically
-     * correct, since ArchUnit usually reports one violation per line). However in cases where
+     * correct, since ArchUnit usually reports one violation per line). However, in cases where
      * violations are omitted (e.g. because a limit of reported violations is configured), this information
-     * can be supplied here to inform users there there actually were more violations than reported.
+     * can be supplied here to inform users that there actually were more violations than reported.
      * @param informationAboutNumberOfViolations The text to be shown for the number of times a rule has been violated
      */
     @PublicAPI(usage = ACCESS)

File: archunit/src/test/java/com/tngtech/archunit/library/testclasses/mayonlyaccesslayers/allowed/MayOnlyAccessLayersAllowedClass.java
Patch:
@@ -1,6 +1,9 @@
 package com.tngtech.archunit.library.testclasses.mayonlyaccesslayers.allowed;
 
+import com.tngtech.archunit.library.testclasses.mayonlyaccesslayers.origin.MayOnlyAccessLayersOriginClass;
+
 public class MayOnlyAccessLayersAllowedClass {
     public void callMe() {
+        new MayOnlyAccessLayersOriginClass();
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/base/Optional.java
Patch:
@@ -104,6 +104,7 @@ public <U> Optional<U> transform(Function<? super T, U> function) {
     /**
      * @deprecated Use {@link #orElse(Object) orElse(null)} instead.
      */
+    @Deprecated
     @PublicAPI(usage = ACCESS)
     public T orNull() {
         return orElse(null);

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaPackage.java
Patch:
@@ -239,6 +239,7 @@ public Set<JavaPackage> getSubpackages() {
     /**
      * @deprecated Use {@link #getSubpackages()} instead.
      */
+    @Deprecated
     @PublicAPI(usage = ACCESS)
     public Set<JavaPackage> getSubPackages() {
         return getSubpackages();
@@ -262,6 +263,7 @@ public Set<JavaPackage> getAllSubpackages() {
     /**
      * @deprecated Use {@link #getAllSubpackages()} instead.
      */
+    @Deprecated
     @PublicAPI(usage = ACCESS)
     public Set<JavaPackage> getAllSubPackages() {
         return getAllSubpackages();

File: archunit/src/test/java/com/tngtech/archunit/core/domain/AccessTargetTest.java
Patch:
@@ -16,6 +16,7 @@
 import static com.tngtech.archunit.core.domain.TestUtils.simulateCall;
 import static com.tngtech.archunit.core.domain.TestUtils.withinImportedClasses;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
+import static com.tngtech.archunit.testutil.Assertions.assertThatThrowsClause;
 import static com.tngtech.archunit.testutil.Assertions.assertThatType;
 import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
 
@@ -137,7 +138,7 @@ public void no_throws_clause_is_resolved() {
         CodeUnitCallTarget target = getTarget("withoutThrowsDeclaration");
 
         ThrowsClause<CodeUnitCallTarget> throwsClause = target.getThrowsClause();
-        assertThat(throwsClause).as("throws clause").isEmpty();
+        assertThatThrowsClause(throwsClause).as("throws clause").isEmpty();
         assertThat(throwsClause.getTypes()).isEmpty();
         assertThat(throwsClause.getOwner()).isEqualTo(target);
         assertThatType(throwsClause.getDeclaringClass()).matches(Target.class);
@@ -221,7 +222,7 @@ private void assertDeclarations(CodeUnitCallTarget target, Class<?>... exception
         assertThatTypes(throwsClause.getTypes()).matchExactly(exceptionTypes);
         for (ThrowsDeclaration<CodeUnitCallTarget> throwsDeclaration : throwsClause) {
             assertThatType(throwsDeclaration.getDeclaringClass()).isEqualTo(target.getOwner());
-            assertThat(throwsDeclaration.getOwner()).isEqualTo(target.getThrowsClause());
+            assertThatThrowsClause(throwsDeclaration.getOwner()).isEqualTo(target.getThrowsClause());
             assertThat(throwsDeclaration.getLocation()).isEqualTo(target);
         }
     }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterMembersTest.java
Patch:
@@ -65,6 +65,7 @@
 import static com.tngtech.archunit.core.importer.ClassFileImporterTestUtils.getMethods;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 import static com.tngtech.archunit.testutil.Assertions.assertThatReferencedClassObjects;
+import static com.tngtech.archunit.testutil.Assertions.assertThatThrowsClause;
 import static com.tngtech.archunit.testutil.Assertions.assertThatType;
 import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
 import static com.tngtech.archunit.testutil.ReflectionTestUtils.field;
@@ -173,7 +174,7 @@ public void imports_methods_with_correct_return_types() {
     public void imports_methods_with_correct_throws_declarations() {
         JavaMethod method = new ClassFileImporter().importUrl(getClass().getResource("testexamples/methodimport")).get(ClassWithThrowingMethod.class).getMethod("throwExceptions");
 
-        assertThat(method.getThrowsClause())
+        assertThatThrowsClause(method.getThrowsClause())
                 .as("Throws types of method 'throwsExceptions'")
                 .matches(FirstCheckedException.class, SecondCheckedException.class);
         assertThatTypes(method.getExceptionTypes()).matchExactly(FirstCheckedException.class, SecondCheckedException.class);
@@ -249,7 +250,7 @@ public void imports_constructor_with_correct_throws_declarations() {
         JavaClass clazz = new ClassFileImporter().importUrl(getClass().getResource("testexamples/constructorimport")).get(ClassWithThrowingConstructor.class);
 
         JavaConstructor constructor = getOnlyElement(clazz.getConstructors());
-        assertThat(constructor.getThrowsClause()).as("Throws types of sole constructor")
+        assertThatThrowsClause(constructor.getThrowsClause()).as("Throws types of sole constructor")
                 .matches(FirstCheckedException.class, SecondCheckedException.class);
         assertThatTypes(constructor.getExceptionTypes()).matchExactly(FirstCheckedException.class, SecondCheckedException.class);
     }

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -188,7 +188,7 @@ public static ThrowsDeclarationAssertion assertThat(ThrowsDeclaration<?> throwsD
         return new ThrowsDeclarationAssertion(throwsDeclaration);
     }
 
-    public static ThrowsClauseAssertion assertThat(ThrowsClause<?> throwsClause) {
+    public static ThrowsClauseAssertion assertThatThrowsClause(ThrowsClause<?> throwsClause) {
         return new ThrowsClauseAssertion(throwsClause);
     }
 
@@ -335,7 +335,7 @@ private ThrowsClauseAssertion(ThrowsClause<?> throwsClause) {
         }
 
         public void matches(Class<?>... classes) {
-            assertThat(actual).as("ThrowsClause").hasSize(classes.length);
+            assertThatThrowsClause(actual).as("ThrowsClause").hasSize(classes.length);
             for (int i = 0; i < actual.size(); i++) {
                 assertThat(Iterables.get(actual, i)).as("Element %d", i).matches(classes[i]);
             }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AccessTarget.java
Patch:
@@ -440,8 +440,9 @@ public JavaClass getRawReturnType() {
         @Override
         @PublicAPI(usage = ACCESS)
         public ThrowsClause<CodeUnitCallTarget> getThrowsClause() {
+            @SuppressWarnings("RedundantTypeArguments") // Some JDK versions need the type argument, or it will not compile
             List<ThrowsClause<JavaCodeUnit>> resolvedThrowsClauses = FluentIterable.from(resolve())
-                    .transform(toGuava(JavaCodeUnit.Functions.Get.throwsClause()))
+                    .transform(toGuava(JavaCodeUnit.Functions.Get.<JavaCodeUnit>throwsClause()))
                     .toList();
 
             if (resolvedThrowsClauses.isEmpty()) {

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/SecurityTest.java
Patch:
@@ -27,7 +27,7 @@ public void only_security_infrastructure_should_use_java_security() {
     @Test
     public void only_security_infrastructure_should_use_java_security_on_whole_classpath() {
         ArchRule rule = classes().that().resideInAPackage("java.security.cert..")
-                .should().onlyBeAccessed().byAnyPackage("..example.layers.security..", "java..", "..sun..", "javax..", "apple.security..");
+                .should().onlyBeAccessed().byAnyPackage("..example.layers.security..", "java..", "..sun..", "javax..", "apple.security..", "org.jcp..");
 
         JavaClasses classes = new ClassFileImporter().importClasspath(onlyAppAndRuntime());
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/ExamplesIntegrationTest.java
Patch:
@@ -1301,7 +1301,7 @@ Stream<DynamicTest> SecurityTest() {
                 + "because we want to have one isolated cross-cutting concern 'security'");
 
         addExpectedFailure.accept("classes that reside in a package 'java.security.cert..' "
-                + "should only be accessed by any package ['..example.layers.security..', 'java..', '..sun..', 'javax..', 'apple.security..']");
+                + "should only be accessed by any package ['..example.layers.security..', 'java..', '..sun..', 'javax..', 'apple.security..', 'org.jcp..']");
 
         return expectedTestFailures.toDynamicTests();
     }

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/PlantUmlArchCondition.java
Patch:
@@ -33,6 +33,7 @@
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ConditionEvents;
 
+import static com.google.common.base.Preconditions.checkState;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 import static com.tngtech.archunit.base.Guava.toGuava;
 import static com.tngtech.archunit.core.domain.Dependency.Functions.GET_ORIGIN_CLASS;
@@ -186,6 +187,8 @@ public static PlantUmlArchCondition adhereToPlantUmlDiagram(File file, Configura
 
     private static PlantUmlArchCondition create(URL url, Configuration configuration) {
         PlantUmlDiagram diagram = new PlantUmlParser().parse(url);
+        checkState(!diagram.getAllComponents().isEmpty(), "No components defined in diagram <%s>", url);
+
         JavaClassDiagramAssociation javaClassDiagramAssociation = new JavaClassDiagramAssociation(diagram);
         DescribedPredicate<Dependency> ignorePredicate = configuration.asIgnorePredicate(javaClassDiagramAssociation);
         return new PlantUmlArchCondition(getDescription(url, ignorePredicate.getDescription()), ignorePredicate, javaClassDiagramAssociation);

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/PlantUmlArchCondition.java
Patch:
@@ -33,6 +33,7 @@
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ConditionEvents;
 
+import static com.google.common.base.Preconditions.checkState;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 import static com.tngtech.archunit.base.Guava.toGuava;
 import static com.tngtech.archunit.core.domain.Dependency.Functions.GET_ORIGIN_CLASS;
@@ -186,6 +187,8 @@ public static PlantUmlArchCondition adhereToPlantUmlDiagram(File file, Configura
 
     private static PlantUmlArchCondition create(URL url, Configuration configuration) {
         PlantUmlDiagram diagram = new PlantUmlParser().parse(url);
+        checkState(!diagram.getAllComponents().isEmpty(), "No components defined in diagram <%s>", url);
+
         JavaClassDiagramAssociation javaClassDiagramAssociation = new JavaClassDiagramAssociation(diagram);
         DescribedPredicate<Dependency> ignorePredicate = configuration.asIgnorePredicate(javaClassDiagramAssociation);
         return new PlantUmlArchCondition(getDescription(url, ignorePredicate.getDescription()), ignorePredicate, javaClassDiagramAssociation);

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -28,9 +28,9 @@ public interface ImportContext {
 
     Optional<JavaType> createGenericSuperclass(JavaClass owner);
 
-    Optional<Set<JavaType>> createGenericInterfaces(JavaClass owner);
+    Optional<List<JavaType>> createGenericInterfaces(JavaClass owner);
 
-    Set<JavaClass> createInterfaces(JavaClass owner);
+    List<JavaClass> createInterfaces(JavaClass owner);
 
     List<JavaTypeVariable<JavaClass>> createTypeParameters(JavaClass owner);
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ReverseDependencies.java
Patch:
@@ -28,6 +28,7 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
+import com.tngtech.archunit.base.Optional;
 
 final class ReverseDependencies {
 
@@ -261,7 +262,8 @@ public Set<ACCESS> load(MEMBER member) {
             ImmutableSet.Builder<ACCESS> result = ImmutableSet.builder();
             for (final JavaClass javaClass : getPossibleTargetClassesForAccess(member.getOwner())) {
                 for (ACCESS access : this.accessesToSelf.get(javaClass)) {
-                    if (access.getTarget().resolve().contains(member)) {
+                    Optional<? extends JavaMember> target = access.getTarget().resolveMember();
+                    if (target.isPresent() && target.get().equals(member)) {
                         result.add(access);
                     }
                 }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileProcessor.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.io.InputStream;
 import java.net.URI;
+import java.util.List;
 import java.util.Set;
 
 import com.tngtech.archunit.ArchConfiguration;
@@ -77,7 +78,7 @@ public boolean isNew(String className) {
         }
 
         @Override
-        public void onNewClass(String className, Optional<String> superclassName, Set<String> interfaceNames) {
+        public void onNewClass(String className, Optional<String> superclassName, List<String> interfaceNames) {
             ownerName = className;
             if (superclassName.isPresent()) {
                 importRecord.setSuperclass(ownerName, superclassName.get());
@@ -96,7 +97,7 @@ public void onGenericSuperclass(DomainBuilders.JavaParameterizedTypeBuilder<Java
         }
 
         @Override
-        public void onGenericInterfaces(Set<DomainBuilders.JavaParameterizedTypeBuilder<JavaClass>> genericInterfaceBuilders) {
+        public void onGenericInterfaces(List<DomainBuilders.JavaParameterizedTypeBuilder<JavaClass>> genericInterfaceBuilders) {
             importRecord.addGenericInterfaces(ownerName, genericInterfaceBuilders);
         }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/RawAccessRecord.java
Patch:
@@ -145,7 +145,7 @@ && getRawParameterTypeNames().equals(HasName.Utils.namesOf(method.getRawParamete
         }
     }
 
-    static class TargetInfo {
+    static final class TargetInfo {
         final JavaClassDescriptor owner;
         final String name;
         final String desc;

File: archunit/src/test/java/com/tngtech/archunit/core/domain/TestUtils.java
Patch:
@@ -3,7 +3,6 @@
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -110,11 +109,11 @@ public static DescribedPredicate<Object> predicateWithDescription(String descrip
     }
 
     public static MethodCallTarget resolvedTargetFrom(JavaMethod target) {
-        return ImportTestUtils.targetFrom(target, Suppliers.ofInstance(Collections.singleton(target)));
+        return ImportTestUtils.targetFrom(target, Suppliers.ofInstance(Optional.of(target)));
     }
 
     private static MethodCallTarget unresolvedTargetFrom(JavaMethod target) {
-        return ImportTestUtils.targetFrom(target, Suppliers.ofInstance(Collections.<JavaMethod>emptySet()));
+        return ImportTestUtils.targetFrom(target, Suppliers.ofInstance(Optional.<JavaMethod>empty()));
     }
 
     public static Class<?>[] asClasses(List<JavaClass> parameters) {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/fieldaccesstointerfaces/unique_in_hierarchy/ClassAccessingInterfaceFields.java
Patch:
@@ -1,5 +1,6 @@
-package com.tngtech.archunit.core.importer.testexamples.fieldaccesstointerfaces;
+package com.tngtech.archunit.core.importer.testexamples.fieldaccesstointerfaces.unique_in_hierarchy;
 
+@SuppressWarnings("unused")
 public class ClassAccessingInterfaceFields {
     private ClassWithInterfacesWithFields classWithInterfacesWithFields;
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -161,7 +161,7 @@ public static JavaClassAssertion assertThat(JavaClass javaClass) {
     }
 
     public static JavaFieldAssertion assertThat(FieldAccessTarget target) {
-        return assertThat(target.resolveField().get());
+        return assertThat(target.resolveMember().get());
     }
 
     public static JavaFieldAssertion assertThat(JavaField field) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ReverseDependencies.java
Patch:
@@ -28,6 +28,7 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
+import com.tngtech.archunit.base.Optional;
 
 final class ReverseDependencies {
 
@@ -261,7 +262,8 @@ public Set<ACCESS> load(MEMBER member) {
             ImmutableSet.Builder<ACCESS> result = ImmutableSet.builder();
             for (final JavaClass javaClass : getPossibleTargetClassesForAccess(member.getOwner())) {
                 for (ACCESS access : this.accessesToSelf.get(javaClass)) {
-                    if (access.getTarget().resolve().contains(member)) {
+                    Optional<? extends JavaMember> target = access.getTarget().resolveMember();
+                    if (target.isPresent() && target.get().equals(member)) {
                         result.add(access);
                     }
                 }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/RawAccessRecord.java
Patch:
@@ -145,7 +145,7 @@ && getRawParameterTypeNames().equals(HasName.Utils.namesOf(method.getRawParamete
         }
     }
 
-    static class TargetInfo {
+    static final class TargetInfo {
         final JavaClassDescriptor owner;
         final String name;
         final String desc;

File: archunit/src/test/java/com/tngtech/archunit/core/domain/TestUtils.java
Patch:
@@ -3,7 +3,6 @@
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -110,11 +109,11 @@ public static DescribedPredicate<Object> predicateWithDescription(String descrip
     }
 
     public static MethodCallTarget resolvedTargetFrom(JavaMethod target) {
-        return ImportTestUtils.targetFrom(target, Suppliers.ofInstance(Collections.singleton(target)));
+        return ImportTestUtils.targetFrom(target, Suppliers.ofInstance(Optional.of(target)));
     }
 
     private static MethodCallTarget unresolvedTargetFrom(JavaMethod target) {
-        return ImportTestUtils.targetFrom(target, Suppliers.ofInstance(Collections.<JavaMethod>emptySet()));
+        return ImportTestUtils.targetFrom(target, Suppliers.ofInstance(Optional.<JavaMethod>empty()));
     }
 
     public static Class<?>[] asClasses(List<JavaClass> parameters) {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportTestUtils.java
Patch:
@@ -241,13 +241,13 @@ public static AccessTarget.FieldAccessTarget targetFrom(JavaField field) {
                 .build();
     }
 
-    public static MethodCallTarget targetFrom(JavaMethod target, Supplier<Set<JavaMethod>> resolveSupplier) {
+    public static MethodCallTarget targetFrom(JavaMethod target, Supplier<Optional<JavaMethod>> resolveSupplier) {
         return new DomainBuilders.MethodCallTargetBuilder()
                 .withOwner(target.getOwner())
                 .withName(target.getName())
                 .withParameters(target.getRawParameterTypes())
                 .withReturnType(target.getRawReturnType())
-                .withMethods(resolveSupplier)
+                .withMethod(resolveSupplier)
                 .build();
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/fieldaccesstointerfaces/unique_in_hierarchy/ClassAccessingInterfaceFields.java
Patch:
@@ -1,5 +1,6 @@
-package com.tngtech.archunit.core.importer.testexamples.fieldaccesstointerfaces;
+package com.tngtech.archunit.core.importer.testexamples.fieldaccesstointerfaces.unique_in_hierarchy;
 
+@SuppressWarnings("unused")
 public class ClassAccessingInterfaceFields {
     private ClassWithInterfacesWithFields classWithInterfacesWithFields;
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -161,7 +161,7 @@ public static JavaClassAssertion assertThat(JavaClass javaClass) {
     }
 
     public static JavaFieldAssertion assertThat(FieldAccessTarget target) {
-        return assertThat(target.resolveField().get());
+        return assertThat(target.resolveMember().get());
     }
 
     public static JavaFieldAssertion assertThat(JavaField field) {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -363,7 +363,7 @@ public Optional<JavaCodeUnit> createEnclosingCodeUnit(JavaClass owner) {
 
         CodeUnit codeUnit = enclosingCodeUnit.get();
         JavaClass enclosingClass = classes.getOrResolve(codeUnit.getDeclaringClassName());
-        return enclosingClass.tryGetCodeUnitWithParameterTypeNames(codeUnit.getName(), codeUnit.getParameters());
+        return enclosingClass.tryGetCodeUnitWithParameterTypeNames(codeUnit.getName(), codeUnit.getRawParameterTypeNames());
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -363,7 +363,7 @@ public Optional<JavaCodeUnit> createEnclosingCodeUnit(JavaClass owner) {
 
         CodeUnit codeUnit = enclosingCodeUnit.get();
         JavaClass enclosingClass = classes.getOrResolve(codeUnit.getDeclaringClassName());
-        return enclosingClass.tryGetCodeUnitWithParameterTypeNames(codeUnit.getName(), codeUnit.getParameters());
+        return enclosingClass.tryGetCodeUnitWithParameterTypeNames(codeUnit.getName(), codeUnit.getRawParameterTypeNames());
     }
 
     @Override

File: archunit-integration-test/src/test/java/com/tngtech/archunit/PublicAPIRules.java
Patch:
@@ -73,7 +73,7 @@ public class PublicAPIRules {
                     .and(doNot(inheritPublicAPI()))
                     .and(are(relevantArchUnitMembers()))
 
-                    .should(notBePublic())
+                    .should().notBePublic()
 
                     .because("users of ArchUnit should only access intended members, to preserve maintainability");
 

File: archunit/src/main/java/com/tngtech/archunit/base/DescribedPredicate.java
Patch:
@@ -141,7 +141,7 @@ public static DescribedPredicate<Iterable<?>> empty() {
         return new EmptyPredicate();
     }
 
-    public static <T> DescribedPredicate<Iterable<T>> anyElementThat(final DescribedPredicate<? super T> predicate) {
+    public static <T> DescribedPredicate<Iterable<? extends T>> anyElementThat(final DescribedPredicate<? super T> predicate) {
         return new AnyElementPredicate<>(predicate);
     }
 
@@ -320,7 +320,7 @@ public boolean apply(Iterable<?> input) {
         }
     }
 
-    private static class AnyElementPredicate<T> extends DescribedPredicate<Iterable<T>> {
+    private static class AnyElementPredicate<T> extends DescribedPredicate<Iterable<? extends T>> {
         private final DescribedPredicate<T> predicate;
 
         AnyElementPredicate(DescribedPredicate<? super T> predicate) {
@@ -329,7 +329,7 @@ private static class AnyElementPredicate<T> extends DescribedPredicate<Iterable<
         }
 
         @Override
-        public boolean apply(Iterable<T> iterable) {
+        public boolean apply(Iterable<? extends T> iterable) {
             for (T javaClass : iterable) {
                 if (predicate.apply(javaClass)) {
                     return true;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -57,6 +57,4 @@ public interface ImportContext {
     Set<JavaConstructorCall> createConstructorCallsFor(JavaCodeUnit codeUnit);
 
     JavaClass resolveClass(String fullyQualifiedClassName);
-
-    Optional<JavaClass> getMethodReturnType(String declaringClassName, String methodName);
 }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaAnnotation.java
Patch:
@@ -100,7 +100,7 @@ private JavaAnnotation(JavaClass type, OWNER owner, CanBeAnnotated annotatedElem
 
     private static CanBeAnnotated getAnnotatedElement(Object owner) {
         Object candiate = owner;
-        while (!(candiate instanceof JavaClass) && !(candiate instanceof JavaMember) && (candiate instanceof HasOwner<?>)) {
+        while (!(candiate instanceof CanBeAnnotated) && (candiate instanceof HasOwner<?>)) {
             candiate = ((HasOwner<?>) candiate).getOwner();
         }
         if (!(candiate instanceof CanBeAnnotated)) {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/SignatureTypeArgumentProcessor.java
Patch:
@@ -161,7 +161,7 @@ static class NewJavaTypeCreationProcess<OWNER extends HasDescription> implements
         }
 
         @Override
-        public JavaType finish(OWNER owner, Iterable<JavaTypeVariable<?>> allTypeParametersInContext, ClassesByTypeName classes) {
+        public JavaType finish(OWNER owner, Iterable<JavaTypeVariable<?>> allTypeParametersInContext, ImportedClasses classes) {
             JavaType type = builder.build(owner, allTypeParametersInContext, classes);
             return typeFinisher.finish(type, classes);
         }
@@ -181,11 +181,11 @@ static class ReferenceCreationProcess<OWNER extends HasDescription> implements J
         }
 
         @Override
-        public JavaType finish(OWNER owner, Iterable<JavaTypeVariable<?>> allTypeParametersInContext, ClassesByTypeName classes) {
+        public JavaType finish(OWNER owner, Iterable<JavaTypeVariable<?>> allTypeParametersInContext, ImportedClasses classes) {
             return finisher.finish(createTypeVariable(owner, allTypeParametersInContext, classes), classes);
         }
 
-        private JavaType createTypeVariable(OWNER owner, Iterable<JavaTypeVariable<?>> allTypeParametersInContext, ClassesByTypeName classes) {
+        private JavaType createTypeVariable(OWNER owner, Iterable<JavaTypeVariable<?>> allTypeParametersInContext, ImportedClasses classes) {
             for (JavaTypeVariable<?> existingTypeVariable : allTypeParametersInContext) {
                 if (existingTypeVariable.getName().equals(typeVariableName)) {
                     return existingTypeVariable;

File: archunit/src/main/java/com/tngtech/archunit/base/DescribedPredicate.java
Patch:
@@ -141,7 +141,7 @@ public static DescribedPredicate<Iterable<?>> empty() {
         return new EmptyPredicate();
     }
 
-    public static <T> DescribedPredicate<Iterable<T>> anyElementThat(final DescribedPredicate<? super T> predicate) {
+    public static <T> DescribedPredicate<Iterable<? extends T>> anyElementThat(final DescribedPredicate<? super T> predicate) {
         return new AnyElementPredicate<>(predicate);
     }
 
@@ -320,7 +320,7 @@ public boolean apply(Iterable<?> input) {
         }
     }
 
-    private static class AnyElementPredicate<T> extends DescribedPredicate<Iterable<T>> {
+    private static class AnyElementPredicate<T> extends DescribedPredicate<Iterable<? extends T>> {
         private final DescribedPredicate<T> predicate;
 
         AnyElementPredicate(DescribedPredicate<? super T> predicate) {
@@ -329,7 +329,7 @@ private static class AnyElementPredicate<T> extends DescribedPredicate<Iterable<
         }
 
         @Override
-        public boolean apply(Iterable<T> iterable) {
+        public boolean apply(Iterable<? extends T> iterable) {
             for (T javaClass : iterable) {
                 if (predicate.apply(javaClass)) {
                     return true;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -191,6 +191,7 @@ private Set<String> getAnnotationTypeNamesToResolveFor(JavaClass javaClass) {
         return ImmutableSet.<String>builder()
                 .addAll(importRecord.getAnnotationTypeNamesFor(javaClass))
                 .addAll(importRecord.getMemberAnnotationTypeNamesFor(javaClass))
+                .addAll(importRecord.getParameterAnnotationTypeNamesFor(javaClass))
                 .build();
     }
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/PublicAPIRules.java
Patch:
@@ -73,7 +73,7 @@ public class PublicAPIRules {
                     .and(doNot(inheritPublicAPI()))
                     .and(are(relevantArchUnitMembers()))
 
-                    .should(notBePublic())
+                    .should().notBePublic()
 
                     .because("users of ArchUnit should only access intended members, to preserve maintainability");
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -57,6 +57,4 @@ public interface ImportContext {
     Set<JavaConstructorCall> createConstructorCallsFor(JavaCodeUnit codeUnit);
 
     JavaClass resolveClass(String fullyQualifiedClassName);
-
-    Optional<JavaClass> getMethodReturnType(String declaringClassName, String methodName);
 }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/SignatureTypeArgumentProcessor.java
Patch:
@@ -161,7 +161,7 @@ static class NewJavaTypeCreationProcess<OWNER extends HasDescription> implements
         }
 
         @Override
-        public JavaType finish(OWNER owner, Iterable<JavaTypeVariable<?>> allTypeParametersInContext, ClassesByTypeName classes) {
+        public JavaType finish(OWNER owner, Iterable<JavaTypeVariable<?>> allTypeParametersInContext, ImportedClasses classes) {
             JavaType type = builder.build(owner, allTypeParametersInContext, classes);
             return typeFinisher.finish(type, classes);
         }
@@ -181,11 +181,11 @@ static class ReferenceCreationProcess<OWNER extends HasDescription> implements J
         }
 
         @Override
-        public JavaType finish(OWNER owner, Iterable<JavaTypeVariable<?>> allTypeParametersInContext, ClassesByTypeName classes) {
+        public JavaType finish(OWNER owner, Iterable<JavaTypeVariable<?>> allTypeParametersInContext, ImportedClasses classes) {
             return finisher.finish(createTypeVariable(owner, allTypeParametersInContext, classes), classes);
         }
 
-        private JavaType createTypeVariable(OWNER owner, Iterable<JavaTypeVariable<?>> allTypeParametersInContext, ClassesByTypeName classes) {
+        private JavaType createTypeVariable(OWNER owner, Iterable<JavaTypeVariable<?>> allTypeParametersInContext, ImportedClasses classes) {
             for (JavaTypeVariable<?> existingTypeVariable : allTypeParametersInContext) {
                 if (existingTypeVariable.getName().equals(typeVariableName)) {
                     return existingTypeVariable;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/GenericMemberTypeProcessor.java
Patch:
@@ -68,7 +68,7 @@ public SignatureVisitor visitArrayType() {
 
     @Override
     public void visitTypeVariable(String name) {
-        typeCreationProcess = new ReferenceCreationProcess<>(name);
+        typeCreationProcess = new ReferenceCreationProcess<>(name, typeFinisher);
     }
 
     private void updateType(JavaParameterizedTypeBuilder<T> type) {

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/ArchUnitTestDescriptor.java
Patch:
@@ -31,7 +31,6 @@
 import org.slf4j.LoggerFactory;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Suppliers.memoize;
 import static com.tngtech.archunit.junit.ArchTestInitializationException.WRAP_CAUSE;
 import static com.tngtech.archunit.junit.DisplayNameResolver.determineDisplayName;
 import static com.tngtech.archunit.junit.ReflectionUtils.getAllFields;
@@ -80,8 +79,7 @@ private static void createTestDescriptor(TestDescriptor parent, ClassCache class
 
     @Override
     public void createChildren(ElementResolver resolver) {
-        Supplier<JavaClasses> classes =
-                memoize(() -> classCache.getClassesToAnalyzeFor(testClass, new JUnit5ClassAnalysisRequest(testClass)))::get;
+        Supplier<JavaClasses> classes = () -> classCache.getClassesToAnalyzeFor(testClass, new JUnit5ClassAnalysisRequest(testClass));
 
         getAllFields(testClass, withAnnotation(ArchTest.class))
                 .forEach(field -> resolveField(resolver, classes, field));

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/ArchUnitTestDescriptor.java
Patch:
@@ -31,7 +31,6 @@
 import org.slf4j.LoggerFactory;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Suppliers.memoize;
 import static com.tngtech.archunit.junit.ArchTestInitializationException.WRAP_CAUSE;
 import static com.tngtech.archunit.junit.DisplayNameResolver.determineDisplayName;
 import static com.tngtech.archunit.junit.ReflectionUtils.getAllFields;
@@ -80,8 +79,7 @@ private static void createTestDescriptor(TestDescriptor parent, ClassCache class
 
     @Override
     public void createChildren(ElementResolver resolver) {
-        Supplier<JavaClasses> classes =
-                memoize(() -> classCache.getClassesToAnalyzeFor(testClass, new JUnit5ClassAnalysisRequest(testClass)))::get;
+        Supplier<JavaClasses> classes = () -> classCache.getClassesToAnalyzeFor(testClass, new JUnit5ClassAnalysisRequest(testClass));
 
         getAllFields(testClass, withAnnotation(ArchTest.class))
                 .forEach(field -> resolveField(resolver, classes, field));

File: archunit/src/test/java/com/tngtech/archunit/ArchConfigurationTest.java
Patch:
@@ -17,13 +17,12 @@
 import static com.google.common.base.Preconditions.checkState;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 import static com.tngtech.archunit.testutil.ReflectionTestUtils.constructor;
-import static com.tngtech.archunit.testutil.TestUtils.properties;
-import static com.tngtech.archunit.testutil.TestUtils.singleProperty;
+import static com.tngtech.archunit.testutil.TestUtils.*;
 import static org.assertj.core.api.Assertions.entry;
 
 public class ArchConfigurationTest {
     private static final String PROPERTIES_FILE_NAME = "archconfigtest.properties";
-    private final File testPropsFile = new File(getClass().getResource("/").getFile(), PROPERTIES_FILE_NAME);
+    private final File testPropsFile = new File(new File(toUri(getClass().getResource("/"))), PROPERTIES_FILE_NAME);
 
     @Rule
     public final ExpectedException thrown = ExpectedException.none();

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterSlowTest.java
Patch:
@@ -1,7 +1,6 @@
 package com.tngtech.archunit.core.importer;
 
 import java.io.File;
-import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
 import java.util.List;
@@ -21,13 +20,13 @@
 import org.junit.experimental.categories.Category;
 import org.junit.rules.TemporaryFolder;
 
-import static com.tngtech.archunit.core.domain.SourceTest.urlOf;
 import static com.tngtech.archunit.core.importer.ClassFileImporterTestUtils.jarFileOf;
 import static com.tngtech.archunit.core.importer.ImportOption.Predefined.DO_NOT_INCLUDE_TESTS;
 import static com.tngtech.archunit.core.importer.UrlSourceTest.JAVA_CLASS_PATH_PROP;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 import static com.tngtech.archunit.testutil.Assertions.assertThatType;
 import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
+import static com.tngtech.archunit.testutil.TestUtils.urlOf;
 import static java.util.jar.Attributes.Name.CLASS_PATH;
 
 @Category(Slow.class)
@@ -99,7 +98,7 @@ public void imports_jars() throws Exception {
     }
 
     @Test
-    public void imports_duplicate_classes() throws IOException {
+    public void imports_duplicate_classes() {
         String existingClass = urlOf(JavaClass.class).getFile();
         copyRule.copy(
                 new File(existingClass),

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterTestUtils.java
Patch:
@@ -16,7 +16,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getFirst;
-import static com.tngtech.archunit.core.domain.SourceTest.urlOf;
+import static com.tngtech.archunit.testutil.TestUtils.urlOf;
 
 class ClassFileImporterTestUtils {
 

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchRuleExecution.java
Patch:
@@ -21,6 +21,8 @@
 import com.tngtech.archunit.lang.ArchRule;
 import org.junit.runner.Description;
 
+import static com.tngtech.archunit.junit.DisplayNameResolver.determineDisplayName;
+
 class ArchRuleExecution extends ArchTestExecution {
     private final Field ruleField;
 
@@ -47,7 +49,7 @@ Result evaluateOn(JavaClasses classes) {
 
     @Override
     Description describeSelf() {
-        return Description.createTestDescription(testClass, ruleField.getName(), ruleField.getAnnotations());
+        return Description.createTestDescription(testClass, determineDisplayName(ruleField.getName()), ruleField.getAnnotations());
     }
 
     @Override

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchTestMethodExecution.java
Patch:
@@ -21,6 +21,7 @@
 import com.tngtech.archunit.core.domain.JavaClasses;
 import org.junit.runner.Description;
 
+import static com.tngtech.archunit.junit.DisplayNameResolver.determineDisplayName;
 import static com.tngtech.archunit.junit.ReflectionUtils.invokeMethod;
 
 class ArchTestMethodExecution extends ArchTestExecution {
@@ -52,7 +53,7 @@ private void executeTestMethod(JavaClasses classes) {
 
     @Override
     Description describeSelf() {
-        return Description.createTestDescription(testClass, testMethod.getName(), testMethod.getAnnotations());
+        return Description.createTestDescription(testClass, determineDisplayName(testMethod.getName()), testMethod.getAnnotations());
     }
 
     @Override

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchRuleExecution.java
Patch:
@@ -21,6 +21,8 @@
 import com.tngtech.archunit.lang.ArchRule;
 import org.junit.runner.Description;
 
+import static com.tngtech.archunit.junit.DisplayNameResolver.determineDisplayName;
+
 class ArchRuleExecution extends ArchTestExecution {
     private final Field ruleField;
 
@@ -47,7 +49,7 @@ Result evaluateOn(JavaClasses classes) {
 
     @Override
     Description describeSelf() {
-        return Description.createTestDescription(testClass, ruleField.getName(), ruleField.getAnnotations());
+        return Description.createTestDescription(testClass, determineDisplayName(ruleField.getName()), ruleField.getAnnotations());
     }
 
     @Override

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchTestMethodExecution.java
Patch:
@@ -21,6 +21,7 @@
 import com.tngtech.archunit.core.domain.JavaClasses;
 import org.junit.runner.Description;
 
+import static com.tngtech.archunit.junit.DisplayNameResolver.determineDisplayName;
 import static com.tngtech.archunit.junit.ReflectionUtils.invokeMethod;
 
 class ArchTestMethodExecution extends ArchTestExecution {
@@ -52,7 +53,7 @@ private void executeTestMethod(JavaClasses classes) {
 
     @Override
     Description describeSelf() {
-        return Description.createTestDescription(testClass, testMethod.getName(), testMethod.getAnnotations());
+        return Description.createTestDescription(testClass, determineDisplayName(testMethod.getName()), testMethod.getAnnotations());
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -94,7 +94,7 @@ Optional<JavaClass> createJavaClass() {
 
     @Override
     public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
-        LOG.debug("Analyzing class '{}'", name);
+        LOG.debug("Processing class '{}'", name);
         JavaClassDescriptor descriptor = JavaClassDescriptorImporter.createFromAsmObjectTypeName(name);
         if (alreadyImported(descriptor)) {
             return;

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/PlantUmlArchCondition.java
Patch:
@@ -80,6 +80,7 @@
  *     <li>Components must have a name</li>
  *     <li>Components must have at least one stereotype. Each stereotype in the diagram must be unique</li>
  *     <li>Components may have an optional alias</li>
+ *     <li>Components may have an optional color</li>
  *     <li>Components must be defined before declaring dependencies</li>
  *     <li>Dependencies must use arrows only consisting of dashes, pointing right, e.g. <code>--&gt;</code></li>
  * </ol>
@@ -297,4 +298,4 @@ public boolean apply(Dependency input) {
     interface Configuration {
         DescribedPredicate<Dependency> asIgnorePredicate(JavaClassDiagramAssociation javaClassDiagramAssociation);
     }
-}
\ No newline at end of file
+}

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/service/SpecialServiceHelper.java
Patch:
@@ -15,4 +15,7 @@ public abstract class SpecialServiceHelper extends ServiceHelper<SomeUtility, Ha
     Map<?, Map<SomeEnum, ? extends SomeUtility>> methodWithGenericReturnTypeViolatingLayerRule() {
         return null;
     }
+
+    void methodWithGenericParameterTypeViolatingLayerRule(Map<?, Map<SomeEnum, ? extends SomeUtility>> param) {
+    }
 }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/GenericMemberTypeProcessor.java
Patch:
@@ -16,6 +16,7 @@
 package com.tngtech.archunit.core.importer;
 
 import com.tngtech.archunit.base.HasDescription;
+import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaParameterizedTypeBuilder;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaTypeCreationProcess;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaTypeCreationProcess.JavaTypeFinisher;
@@ -35,8 +36,8 @@ class GenericMemberTypeProcessor<T extends HasDescription> extends SignatureVisi
         super(ASM_API_VERSION);
     }
 
-    JavaTypeCreationProcess<T> getType() {
-        return typeCreationProcess;
+    Optional<JavaTypeCreationProcess<T>> getType() {
+        return Optional.ofNullable(typeCreationProcess);
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -248,8 +248,8 @@ public MethodVisitor visitMethod(int access, String name, String desc, String si
         }
 
         LOG.trace("Analyzing method {}.{}:{}", className, name, desc);
-        List<JavaClassDescriptor> parameters = JavaClassDescriptorImporter.importAsmMethodArgumentTypes(desc);
-        accessHandler.setContext(new CodeUnit(name, namesOf(parameters), className));
+        List<JavaClassDescriptor> rawParameterTypes = JavaClassDescriptorImporter.importAsmMethodArgumentTypes(desc);
+        accessHandler.setContext(new CodeUnit(name, namesOf(rawParameterTypes), className));
 
         DomainBuilders.JavaCodeUnitBuilder<?, ?> codeUnitBuilder = addCodeUnitBuilder(name);
         JavaCodeUnitSignature codeUnitSignature = JavaCodeUnitSignatureImporter.parseAsmMethodSignature(signature);
@@ -258,7 +258,7 @@ public MethodVisitor visitMethod(int access, String name, String desc, String si
                 .withName(name)
                 .withModifiers(JavaModifier.getModifiersForMethod(access))
                 .withTypeParameters(codeUnitSignature.getTypeParameterBuilders())
-                .withParameterTypes(parameters)
+                .withParameterTypes(codeUnitSignature.getParameterTypes(), rawParameterTypes)
                 .withReturnType(codeUnitSignature.getReturnType(), rawReturnType)
                 .withDescriptor(desc)
                 .withThrowsClause(typesFrom(exceptions));

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaFieldTypeSignatureImporter.java
Patch:
@@ -37,7 +37,7 @@ static Optional<JavaTypeCreationProcess<JavaField>> parseAsmFieldTypeSignature(S
 
         SignatureProcessor signatureProcessor = new SignatureProcessor();
         new SignatureReader(signature).accept(signatureProcessor);
-        return Optional.of(signatureProcessor.getFieldType());
+        return signatureProcessor.getFieldType();
     }
 
     private static class SignatureProcessor extends SignatureVisitor {
@@ -52,7 +52,7 @@ public SignatureVisitor visitSuperclass() {
             return genericFieldTypeProcessor;
         }
 
-        JavaTypeCreationProcess<JavaField> getFieldType() {
+        Optional<JavaTypeCreationProcess<JavaField>> getFieldType() {
             return genericFieldTypeProcessor.getType();
         }
     }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterGenericMethodReturnTypesTest.java
Patch:
@@ -209,7 +209,7 @@ GenericReturnType<?> method() {
             }
         }
 
-        JavaType genericReturnType = new ClassFileImporter().importClasses(SomeClass.class, ClassParameterWithSingleTypeParameter.class)
+        JavaType genericReturnType = new ClassFileImporter().importClasses(SomeClass.class)
                 .get(SomeClass.class).getMethod("method").getReturnType();
 
         assertThatType(genericReturnType).as("generic return type").hasActualTypeArguments(wildcardType());
@@ -624,7 +624,7 @@ class SomeClass {
         }
 
         JavaClasses classes = new ClassFileImporter().importClasses(SomeClass.class,
-                List.class, Serializable.class, Map.class, String.class);
+                Serializable.class, Map.class, String.class);
 
         JavaType genericReturnType = classes.get(SomeClass.class).getMethod("method").getReturnType();
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportTestUtils.java
Patch:
@@ -79,7 +79,7 @@ private static Set<DomainBuilders.BuilderWithBuildParameter<JavaClass, JavaMetho
                     .withReturnType(
                             Optional.<JavaTypeCreationProcess<JavaCodeUnit>>empty(),
                             JavaClassDescriptor.From.name(method.getReturnType().getName()))
-                    .withParameterTypes(typesFrom(method.getParameterTypes()))
+                    .withParameterTypes(Collections.<JavaTypeCreationProcess<JavaCodeUnit>>emptyList(), typesFrom(method.getParameterTypes()))
                     .withName(method.getName())
                     .withDescriptor(Type.getMethodDescriptor(method))
                     .withModifiers(JavaModifier.getModifiersForMethod(method.getModifiers()))
@@ -95,7 +95,7 @@ private static Set<DomainBuilders.BuilderWithBuildParameter<JavaClass, JavaConst
                     .withReturnType(
                             Optional.<JavaTypeCreationProcess<JavaCodeUnit>>empty(),
                             JavaClassDescriptor.From.name(void.class.getName()))
-                    .withParameterTypes(typesFrom(constructor.getParameterTypes()))
+                    .withParameterTypes(Collections.<JavaTypeCreationProcess<JavaCodeUnit>>emptyList(), typesFrom(constructor.getParameterTypes()))
                     .withName(CONSTRUCTOR_NAME)
                     .withDescriptor(Type.getConstructorDescriptor(constructor))
                     .withModifiers(JavaModifier.getModifiersForMethod(constructor.getModifiers()))

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/service/SpecialServiceHelper.java
Patch:
@@ -15,4 +15,7 @@ public abstract class SpecialServiceHelper extends ServiceHelper<SomeUtility, Ha
     Map<?, Map<SomeEnum, ? extends SomeUtility>> methodWithGenericReturnTypeViolatingLayerRule() {
         return null;
     }
+
+    void methodWithGenericParameterTypeViolatingLayerRule(Map<?, Map<SomeEnum, ? extends SomeUtility>> param) {
+    }
 }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/GenericMemberTypeProcessor.java
Patch:
@@ -16,6 +16,7 @@
 package com.tngtech.archunit.core.importer;
 
 import com.tngtech.archunit.base.HasDescription;
+import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaParameterizedTypeBuilder;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaTypeCreationProcess;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaTypeCreationProcess.JavaTypeFinisher;
@@ -35,8 +36,8 @@ class GenericMemberTypeProcessor<T extends HasDescription> extends SignatureVisi
         super(ASM_API_VERSION);
     }
 
-    JavaTypeCreationProcess<T> getType() {
-        return typeCreationProcess;
+    Optional<JavaTypeCreationProcess<T>> getType() {
+        return Optional.ofNullable(typeCreationProcess);
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -248,8 +248,8 @@ public MethodVisitor visitMethod(int access, String name, String desc, String si
         }
 
         LOG.trace("Analyzing method {}.{}:{}", className, name, desc);
-        List<JavaClassDescriptor> parameters = JavaClassDescriptorImporter.importAsmMethodArgumentTypes(desc);
-        accessHandler.setContext(new CodeUnit(name, namesOf(parameters), className));
+        List<JavaClassDescriptor> rawParameterTypes = JavaClassDescriptorImporter.importAsmMethodArgumentTypes(desc);
+        accessHandler.setContext(new CodeUnit(name, namesOf(rawParameterTypes), className));
 
         DomainBuilders.JavaCodeUnitBuilder<?, ?> codeUnitBuilder = addCodeUnitBuilder(name);
         JavaCodeUnitSignature codeUnitSignature = JavaCodeUnitSignatureImporter.parseAsmMethodSignature(signature);
@@ -258,7 +258,7 @@ public MethodVisitor visitMethod(int access, String name, String desc, String si
                 .withName(name)
                 .withModifiers(JavaModifier.getModifiersForMethod(access))
                 .withTypeParameters(codeUnitSignature.getTypeParameterBuilders())
-                .withParameterTypes(parameters)
+                .withParameterTypes(codeUnitSignature.getParameterTypes(), rawParameterTypes)
                 .withReturnType(codeUnitSignature.getReturnType(), rawReturnType)
                 .withDescriptor(desc)
                 .withThrowsClause(typesFrom(exceptions));

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaFieldTypeSignatureImporter.java
Patch:
@@ -37,7 +37,7 @@ static Optional<JavaTypeCreationProcess<JavaField>> parseAsmFieldTypeSignature(S
 
         SignatureProcessor signatureProcessor = new SignatureProcessor();
         new SignatureReader(signature).accept(signatureProcessor);
-        return Optional.of(signatureProcessor.getFieldType());
+        return signatureProcessor.getFieldType();
     }
 
     private static class SignatureProcessor extends SignatureVisitor {
@@ -52,7 +52,7 @@ public SignatureVisitor visitSuperclass() {
             return genericFieldTypeProcessor;
         }
 
-        JavaTypeCreationProcess<JavaField> getFieldType() {
+        Optional<JavaTypeCreationProcess<JavaField>> getFieldType() {
             return genericFieldTypeProcessor.getType();
         }
     }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterGenericMethodReturnTypesTest.java
Patch:
@@ -209,7 +209,7 @@ GenericReturnType<?> method() {
             }
         }
 
-        JavaType genericReturnType = new ClassFileImporter().importClasses(SomeClass.class, ClassParameterWithSingleTypeParameter.class)
+        JavaType genericReturnType = new ClassFileImporter().importClasses(SomeClass.class)
                 .get(SomeClass.class).getMethod("method").getReturnType();
 
         assertThatType(genericReturnType).as("generic return type").hasActualTypeArguments(wildcardType());
@@ -624,7 +624,7 @@ class SomeClass {
         }
 
         JavaClasses classes = new ClassFileImporter().importClasses(SomeClass.class,
-                List.class, Serializable.class, Map.class, String.class);
+                Serializable.class, Map.class, String.class);
 
         JavaType genericReturnType = classes.get(SomeClass.class).getMethod("method").getReturnType();
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportTestUtils.java
Patch:
@@ -79,7 +79,7 @@ private static Set<DomainBuilders.BuilderWithBuildParameter<JavaClass, JavaMetho
                     .withReturnType(
                             Optional.<JavaTypeCreationProcess<JavaCodeUnit>>empty(),
                             JavaClassDescriptor.From.name(method.getReturnType().getName()))
-                    .withParameterTypes(typesFrom(method.getParameterTypes()))
+                    .withParameterTypes(Collections.<JavaTypeCreationProcess<JavaCodeUnit>>emptyList(), typesFrom(method.getParameterTypes()))
                     .withName(method.getName())
                     .withDescriptor(Type.getMethodDescriptor(method))
                     .withModifiers(JavaModifier.getModifiersForMethod(method.getModifiers()))
@@ -95,7 +95,7 @@ private static Set<DomainBuilders.BuilderWithBuildParameter<JavaClass, JavaConst
                     .withReturnType(
                             Optional.<JavaTypeCreationProcess<JavaCodeUnit>>empty(),
                             JavaClassDescriptor.From.name(void.class.getName()))
-                    .withParameterTypes(typesFrom(constructor.getParameterTypes()))
+                    .withParameterTypes(Collections.<JavaTypeCreationProcess<JavaCodeUnit>>emptyList(), typesFrom(constructor.getParameterTypes()))
                     .withName(CONSTRUCTOR_NAME)
                     .withDescriptor(Type.getConstructorDescriptor(constructor))
                     .withModifiers(JavaModifier.getModifiersForMethod(constructor.getModifiers()))

File: archunit-integration-test/src/test/java/com/tngtech/archunit/PublicAPIRules.java
Patch:
@@ -30,6 +30,7 @@
 import static com.tngtech.archunit.base.DescribedPredicate.anyElementThat;
 import static com.tngtech.archunit.base.DescribedPredicate.doNot;
 import static com.tngtech.archunit.base.DescribedPredicate.not;
+import static com.tngtech.archunit.core.domain.Formatters.formatNamesOf;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.ANONYMOUS_CLASSES;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.equivalentTo;
@@ -186,7 +187,7 @@ public boolean apply(JavaMember input) {
 
             private boolean equivalentMethod(JavaMethod method, String name, Class<?>... paramTypes) {
                 return method.getName().equals(name) &&
-                        namesOf(method.getRawParameterTypes()).equals(JavaClass.namesOf(paramTypes));
+                        namesOf(method.getRawParameterTypes()).equals(formatNamesOf(paramTypes));
             }
 
             private boolean enumMethod(JavaMethod methodToCheck, String name, Class<?>... paramTypes) {

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/ExamplesIntegrationTest.java
Patch:
@@ -156,7 +156,7 @@
 
 import static com.google.common.base.Predicates.containsPattern;
 import static com.google.common.collect.Collections2.filter;
-import static com.tngtech.archunit.core.domain.JavaClass.namesOf;
+import static com.tngtech.archunit.core.domain.Formatters.formatNamesOf;
 import static com.tngtech.archunit.example.layers.OtherClassViolatingSessionBeanRules.init;
 import static com.tngtech.archunit.example.layers.SomeMediator.violateLayerRulesIndirectly;
 import static com.tngtech.archunit.example.layers.controller.one.UseCaseOneTwoController.doSomethingOne;
@@ -1210,7 +1210,7 @@ Stream<DynamicTest> RestrictNumberOfClassesWithACertainPropertyTest() {
     }
 
     private static MessageAssertionChain.Link classesContaining(final Class<?>... classes) {
-        final String expectedLine = String.format("there is/are %d element(s) in classes %s", classes.length, namesOf(classes));
+        final String expectedLine = String.format("there is/are %d element(s) in classes %s", classes.length, formatNamesOf(classes));
         return new MessageAssertionChain.Link() {
             @Override
             public Result filterMatching(List<String> lines) {
@@ -1226,7 +1226,7 @@ public Result filterMatching(List<String> lines) {
 
             @Override
             public String getDescription() {
-                return "classes containing " + namesOf(classes);
+                return "classes containing " + formatNamesOf(classes);
             }
         };
     }

File: archunit/src/main/java/com/tngtech/archunit/ArchConfiguration.java
Patch:
@@ -122,7 +122,7 @@ public void setMd5InClassSourcesEnabled(boolean enabled) {
 
     @PublicAPI(usage = ACCESS)
     public Optional<String> getClassResolver() {
-        return Optional.fromNullable(properties.getProperty(CLASS_RESOLVER));
+        return Optional.ofNullable(properties.getProperty(CLASS_RESOLVER));
     }
 
     @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/base/PackageMatcher.java
Patch:
@@ -133,7 +133,7 @@ public boolean matches(String aPackage) {
     @PublicAPI(usage = ACCESS)
     public Optional<Result> match(String aPackage) {
         Matcher matcher = packagePattern.matcher(aPackage);
-        return matcher.matches() ? Optional.of(new Result(matcher)) : Optional.<Result>absent();
+        return matcher.matches() ? Optional.of(new Result(matcher)) : Optional.<Result>empty();
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AnnotationProxy.java
Patch:
@@ -100,7 +100,7 @@ public Object invoke(Object proxy, Method method, Object[] args) {
                 return handlersByMethod.get(key).handle(proxy, method, args);
             }
 
-            Object result = toProxy.get(method.getName()).or(method.getDefaultValue());
+            Object result = toProxy.get(method.getName()).orElse(method.getDefaultValue());
             return conversions.convertIfNecessary(result, method.getReturnType());
         }
     }
@@ -315,7 +315,7 @@ <T> Object convertIfNecessary(T result, Class<?> returnType) {
             if (returnType.isInstance(result)) {
                 return result;
             }
-            return tryFindConversionFor(returnType).or(new NoOpConversion<>()).convert(result, returnType);
+            return tryFindConversionFor(returnType).orElse(new NoOpConversion<>()).convert(result, returnType);
         }
 
         private static class NoOpConversion<T> implements Conversion<T> {
@@ -337,7 +337,7 @@ private <F> Optional<Conversion<F>> tryFindConversionFor(Class<?> returnType) {
                     return Optional.of((Conversion<F>) conversion);
                 }
             }
-            return Optional.absent();
+            return Optional.empty();
         }
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Dependency.java
Patch:
@@ -221,7 +221,7 @@ private static Set<Dependency> createComponentTypeDependencies(
 
     private static Optional<Dependency> tryCreateDependency(JavaClass originClass, JavaClass targetClass, String description, int lineNumber) {
         if (originClass.equals(targetClass) || targetClass.isPrimitive()) {
-            return Optional.absent();
+            return Optional.empty();
         }
         return Optional.of(new Dependency(originClass, targetClass, lineNumber, description));
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaAnnotation.java
Patch:
@@ -208,7 +208,7 @@ private Optional<Object> tryGetDefaultValue(String property) {
         Optional<JavaMethod> method = type.tryGetMethod(property);
         return method.isPresent()
                 ? method.get().getDefaultValue()
-                : Optional.absent();
+                : Optional.empty();
     }
 
     /**
@@ -259,7 +259,7 @@ public Object getExplicitlyDeclaredProperty(String propertyName) {
      */
     @PublicAPI(usage = ACCESS)
     public Optional<Object> tryGetExplicitlyDeclaredProperty(String propertyName) {
-        return Optional.fromNullable(values.get(propertyName));
+        return Optional.ofNullable(values.get(propertyName));
     }
 
     /**

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassDescriptor.java
Patch:
@@ -185,7 +185,7 @@ Class<?> classForName(ClassLoader classLoader) throws ClassNotFoundException {
 
             @Override
             public Optional<JavaClassDescriptor> tryGetComponentType() {
-                return Optional.absent();
+                return Optional.empty();
             }
 
             @Override

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassMembers.java
Patch:
@@ -128,7 +128,7 @@ Optional<JavaField> tryGetField(String name) {
                 return Optional.of(field);
             }
         }
-        return Optional.absent();
+        return Optional.empty();
     }
 
     Set<JavaCodeUnit> getCodeUnits() {
@@ -261,7 +261,7 @@ private <T extends JavaCodeUnit> Optional<T> tryFindMatchingCodeUnit(Set<T> code
                 return Optional.of(codeUnit);
             }
         }
-        return Optional.absent();
+        return Optional.empty();
     }
 
     void completeAnnotations(ImportContext context) {
@@ -288,7 +288,7 @@ static JavaClassMembers empty(JavaClass owner) {
                 Collections.<JavaField>emptySet(),
                 Collections.<JavaMethod>emptySet(),
                 Collections.<JavaConstructor>emptySet(),
-                Optional.<JavaStaticInitializer>absent());
+                Optional.<JavaStaticInitializer>empty());
     }
 
     static JavaClassMembers create(JavaClass owner, ImportContext context) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMember.java
Patch:
@@ -92,13 +92,13 @@ public JavaAnnotation<? extends JavaMember> getAnnotationOfType(String typeName)
     @Override
     @PublicAPI(usage = ACCESS)
     public <A extends Annotation> Optional<A> tryGetAnnotationOfType(Class<A> type) {
-        return tryGetAnnotationOfType(type.getName()).transform(toAnnotationOfType(type));
+        return tryGetAnnotationOfType(type.getName()).map(toAnnotationOfType(type));
     }
 
     @Override
     @PublicAPI(usage = ACCESS)
     public Optional<? extends JavaAnnotation<? extends JavaMember>> tryGetAnnotationOfType(String typeName) {
-        return Optional.fromNullable(annotations.get(typeName));
+        return Optional.ofNullable(annotations.get(typeName));
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Source.java
Patch:
@@ -180,7 +180,7 @@ private static Optional<byte[]> read(URI uri) {
             try (InputStream in = uri.toURL().openStream()) {
                 return Optional.of(ByteStreams.toByteArray(in));
             } catch (IOException | RuntimeException e) {
-                return Optional.absent();
+                return Optional.empty();
             }
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/SourceCodeLocation.java
Patch:
@@ -54,7 +54,7 @@ public static SourceCodeLocation of(JavaClass sourceClass, int lineNumber) {
     private static String formatLocation(JavaClass sourceClass, int lineNumber) {
         Optional<String> recordedSourceFileName = sourceClass.getSource().isPresent()
                 ? sourceClass.getSource().get().getFileName()
-                : Optional.<String>absent();
+                : Optional.<String>empty();
         String sourceFileName = recordedSourceFileName.isPresent() ? recordedSourceFileName.get() : guessSourceFileName(sourceClass);
         return "(" + sourceFileName + ":" + lineNumber + ")";
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasParameterTypes.java
Patch:
@@ -25,7 +25,7 @@
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 import static com.tngtech.archunit.base.DescribedPredicate.equalTo;
 import static com.tngtech.archunit.core.domain.Formatters.formatMethodParameterTypeNames;
-import static com.tngtech.archunit.core.domain.JavaClass.namesOf;
+import static com.tngtech.archunit.core.domain.Formatters.formatNamesOf;
 import static com.tngtech.archunit.core.domain.properties.HasName.Functions.GET_NAMES;
 
 public interface HasParameterTypes {
@@ -39,7 +39,7 @@ private Predicates() {
 
         @PublicAPI(usage = ACCESS)
         public static DescribedPredicate<HasParameterTypes> rawParameterTypes(final Class<?>... types) {
-            return rawParameterTypes(namesOf(types));
+            return rawParameterTypes(formatNamesOf(types));
         }
 
         @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasThrowsClause.java
Patch:
@@ -27,8 +27,8 @@
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 import static com.tngtech.archunit.base.DescribedPredicate.anyElementThat;
 import static com.tngtech.archunit.base.DescribedPredicate.equalTo;
+import static com.tngtech.archunit.core.domain.Formatters.formatNamesOf;
 import static com.tngtech.archunit.core.domain.Formatters.formatThrowsDeclarationTypeNames;
-import static com.tngtech.archunit.core.domain.JavaClass.namesOf;
 import static com.tngtech.archunit.core.domain.properties.HasName.Functions.GET_NAMES;
 import static com.tngtech.archunit.core.domain.properties.HasName.Predicates.name;
 import static com.tngtech.archunit.core.domain.properties.HasType.Functions.GET_RAW_TYPE;
@@ -44,7 +44,7 @@ private Predicates() {
         @PublicAPI(usage = ACCESS)
         @SafeVarargs
         public static DescribedPredicate<HasThrowsClause<?>> throwsClauseWithTypes(final Class<? extends Throwable>... types) {
-            return throwsClauseWithTypes(namesOf(types));
+            return throwsClauseWithTypes(formatNamesOf(types));
         }
 
         @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/core/importer/AccessRecord.java
Patch:
@@ -147,7 +147,7 @@ public Optional<JavaConstructor> get() {
                             return Optional.of(constructor);
                         }
                     }
-                    return Optional.absent();
+                    return Optional.empty();
                 }
             }
         }
@@ -334,7 +334,7 @@ public boolean exists(JavaClass clazz, TargetInfo target) {
         };
 
         private static <T> Optional<T> uniqueTargetIn(Collection<T> collection) {
-            return collection.size() == 1 ? Optional.of(getOnlyElement(collection)) : Optional.<T>absent();
+            return collection.size() == 1 ? Optional.of(getOnlyElement(collection)) : Optional.<T>empty();
         }
 
         private static List<JavaClass> getArgumentTypesFrom(String descriptor, ImportedClasses classes) {
@@ -359,7 +359,7 @@ private Optional<JavaClass> tryFindChildInHierarchy(JavaClassDescriptor childTyp
                         return Optional.of(subclass);
                     }
                 }
-                return Optional.absent();
+                return Optional.empty();
             }
 
             private List<JavaClass> createPath(JavaClass parent, JavaClass child) {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileProcessor.java
Patch:
@@ -220,7 +220,7 @@ public Optional<JavaClass> tryImport(URI uri) {
                 return classProcessor.createJavaClass();
             } catch (Exception e) {
                 LOG.warn(String.format("Error during import from %s, falling back to simple import", uri), e);
-                return Optional.absent();
+                return Optional.empty();
             }
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassSignatureImporter.java
Patch:
@@ -68,7 +68,7 @@ List<JavaTypeParameterBuilder<JavaClass>> getTypeParameterBuilders() {
         }
 
         Optional<JavaParameterizedTypeBuilder<JavaClass>> getGenericSuperclass() {
-            return Optional.fromNullable(superclassProcessor.superclass);
+            return Optional.ofNullable(superclassProcessor.superclass);
         }
 
         Set<JavaParameterizedTypeBuilder<JavaClass>> getGenericInterfaces() {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaCodeUnitSignatureImporter.java
Patch:
@@ -77,14 +77,14 @@ public SignatureVisitor visitReturnType() {
         public JavaCodeUnitSignature getParsedSignature() {
             return new JavaCodeUnitSignature(
                     typeParameterProcessor.getTypeParameterBuilders(),
-                    Optional.fromNullable(genericMethodReturnTypeProcessor.getType()));
+                    Optional.ofNullable(genericMethodReturnTypeProcessor.getType()));
         }
     }
 
     static class JavaCodeUnitSignature {
         static final JavaCodeUnitSignature ABSENT = new JavaCodeUnitSignature(
                 Collections.<JavaTypeParameterBuilder<JavaCodeUnit>>emptyList(),
-                Optional.<JavaTypeCreationProcess<JavaCodeUnit>>absent()
+                Optional.<JavaTypeCreationProcess<JavaCodeUnit>>empty()
         );
 
         private final List<JavaTypeParameterBuilder<JavaCodeUnit>> typeParameterBuilders;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaFieldTypeSignatureImporter.java
Patch:
@@ -30,7 +30,7 @@ class JavaFieldTypeSignatureImporter {
 
     static Optional<JavaTypeCreationProcess<JavaField>> parseAsmFieldTypeSignature(String signature) {
         if (signature == null) {
-            return Optional.absent();
+            return Optional.empty();
         }
 
         log.trace("Analyzing field signature: {}", signature);

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/ClassResolver.java
Patch:
@@ -103,7 +103,7 @@ public ClassResolver create() {
         private Optional<ClassResolver> getExplicitlyConfiguredClassResolver() {
             Optional<String> resolverClassName = ArchConfiguration.get().getClassResolver();
             if (!resolverClassName.isPresent()) {
-                return Optional.absent();
+                return Optional.empty();
             }
 
             Class<?> resolverClass = classForName(resolverClassName);
@@ -152,7 +152,7 @@ private Optional<Constructor<?>> tryGetListConstructor(Class<?> resolverClass) {
             try {
                 return Optional.<Constructor<?>>of(resolverClass.getConstructor(List.class));
             } catch (NoSuchMethodException e) {
-                return Optional.absent();
+                return Optional.empty();
             }
         }
 
@@ -179,7 +179,7 @@ public void setClassUriImporter(ClassUriImporter classUriImporter) {
 
             @Override
             public Optional<JavaClass> tryResolve(String typeName) {
-                return Optional.absent();
+                return Optional.empty();
             }
         }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/ClassResolverFromClasspath.java
Patch:
@@ -48,13 +48,13 @@ public Optional<JavaClass> tryResolve(String typeName) {
 
         Optional<URI> uri = tryGetUriOf(typeFile);
 
-        return uri.isPresent() ? classUriImporter.tryImport(uri.get()) : Optional.<JavaClass>absent();
+        return uri.isPresent() ? classUriImporter.tryImport(uri.get()) : Optional.<JavaClass>empty();
     }
 
     private Optional<URI> tryGetUriOf(String typeFile) {
         URL resource = getCurrentClassLoader(getClass()).getResource(typeFile);
         if (resource == null) {
-            return Optional.absent();
+            return Optional.empty();
         }
         try {
             return Optional.of(resource.toURI());

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/SelectedClassResolverFromClasspath.java
Patch:
@@ -55,6 +55,6 @@ public Optional<JavaClass> tryResolve(String typeName) {
                 return classResolverFromClasspath.tryResolve(typeName);
             }
         }
-        return Optional.absent();
+        return Optional.empty();
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/ArchRule.java
Patch:
@@ -163,7 +163,7 @@ public EvaluationResult getResult() {
     @Internal
     class Factory {
         public static <T> ArchRule create(final ClassesTransformer<T> classesTransformer, final ArchCondition<T> condition, final Priority priority) {
-            return new SimpleArchRule<>(priority, classesTransformer, condition, Optional.<String>absent());
+            return new SimpleArchRule<>(priority, classesTransformer, condition, Optional.<String>empty());
         }
 
         public static ArchRule withBecause(ArchRule rule, String reason) {

File: archunit/src/main/java/com/tngtech/archunit/lang/ConditionEvents.java
Patch:
@@ -40,7 +40,7 @@ public ConditionEvents() {
     }
 
     private final Multimap<Type, ConditionEvent> eventsByViolation = ArrayListMultimap.create();
-    private Optional<String> informationAboutNumberOfViolations = Optional.absent();
+    private Optional<String> informationAboutNumberOfViolations = Optional.empty();
 
     @PublicAPI(usage = ACCESS)
     public void add(ConditionEvent event) {

File: archunit/src/main/java/com/tngtech/archunit/lang/FailureMessages.java
Patch:
@@ -41,7 +41,7 @@ public class FailureMessages extends ForwardingList<String> {
      */
     @PublicAPI(usage = ACCESS)
     public String getInformationAboutNumberOfViolations() {
-        return informationAboutNumberOfViolations.or(failures.size() + " times");
+        return informationAboutNumberOfViolations.orElse(failures.size() + " times");
     }
 
     FailureMessages filter(Predicate<String> predicate) {

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ArchConditions.java
Patch:
@@ -71,6 +71,7 @@
 import static com.tngtech.archunit.core.domain.Dependency.Predicates.dependencyOrigin;
 import static com.tngtech.archunit.core.domain.Dependency.Predicates.dependencyTarget;
 import static com.tngtech.archunit.core.domain.Formatters.ensureSimpleName;
+import static com.tngtech.archunit.core.domain.Formatters.formatNamesOf;
 import static com.tngtech.archunit.core.domain.JavaClass.Functions.GET_ACCESSES_FROM_SELF;
 import static com.tngtech.archunit.core.domain.JavaClass.Functions.GET_ACCESSES_TO_SELF;
 import static com.tngtech.archunit.core.domain.JavaClass.Functions.GET_CALLS_FROM_SELF;
@@ -91,7 +92,6 @@
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.simpleNameEndingWith;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.simpleNameStartingWith;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.type;
-import static com.tngtech.archunit.core.domain.JavaClass.namesOf;
 import static com.tngtech.archunit.core.domain.JavaConstructor.CONSTRUCTOR_NAME;
 import static com.tngtech.archunit.core.domain.JavaMember.Predicates.declaredIn;
 import static com.tngtech.archunit.core.domain.JavaModifier.FINAL;
@@ -185,7 +185,7 @@ public static ArchCondition<JavaClass> callMethod(Class<?> owner, String methodN
                 .and(JavaCall.Predicates.target(name(methodName)))
                 .and(JavaCall.Predicates.target(rawParameterTypes(parameterTypes))))
                 .as("call method %s", Formatters.formatMethodSimple(
-                        owner.getSimpleName(), methodName, namesOf(parameterTypes)));
+                        owner.getSimpleName(), methodName, formatNamesOf(parameterTypes)));
     }
 
     @PublicAPI(usage = ACCESS)
@@ -218,7 +218,7 @@ public static ArchCondition<JavaClass> callConstructor(Class<?> owner, Class<?>.
                 .and(JavaCall.Predicates.target(name(CONSTRUCTOR_NAME)))
                 .and(JavaCall.Predicates.target(rawParameterTypes(parameterTypes))))
                 .as("call constructor %s", Formatters.formatMethodSimple(
-                        owner.getSimpleName(), CONSTRUCTOR_NAME, namesOf(parameterTypes)));
+                        owner.getSimpleName(), CONSTRUCTOR_NAME, formatNamesOf(parameterTypes)));
     }
 
     @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenCodeUnitsInternal.java
Patch:
@@ -72,7 +72,7 @@ static class GivenCodeUnitsInternal extends AbstractGivenCodeUnitsInternal<JavaC
                     classesTransformer,
                     prepareCondition,
                     new PredicateAggregator<JavaCodeUnit>(),
-                    Optional.<String>absent());
+                    Optional.<String>empty());
         }
 
         private GivenCodeUnitsInternal(

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenMembersInternal.java
Patch:
@@ -74,7 +74,7 @@ static class GivenMembersInternal extends AbstractGivenMembersInternal<JavaMembe
                     classesTransformer,
                     prepareCondition,
                     new PredicateAggregator<JavaMember>(),
-                    Optional.<String>absent());
+                    Optional.<String>empty());
         }
 
         private GivenMembersInternal(

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassesInternal.java
Patch:
@@ -38,7 +38,7 @@ class GivenClassesInternal extends AbstractGivenObjects<JavaClass, GivenClassesI
 
     GivenClassesInternal(Priority priority, ClassesTransformer<JavaClass> classesTransformer,
             Function<ArchCondition<JavaClass>, ArchCondition<JavaClass>> prepareCondition) {
-        this(priority, classesTransformer, prepareCondition, new PredicateAggregator<JavaClass>(), Optional.<String>absent());
+        this(priority, classesTransformer, prepareCondition, new PredicateAggregator<JavaClass>(), Optional.<String>empty());
     }
 
     private GivenClassesInternal(

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenConstructorsInternal.java
Patch:
@@ -42,7 +42,7 @@ class GivenConstructorsInternal extends AbstractGivenCodeUnitsInternal<JavaConst
                 classesTransformer,
                 prepareCondition,
                 new PredicateAggregator<JavaConstructor>(),
-                Optional.<String>absent());
+                Optional.<String>empty());
     }
 
     private GivenConstructorsInternal(

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenFieldsInternal.java
Patch:
@@ -43,7 +43,7 @@ class GivenFieldsInternal
                 classesTransformer,
                 prepareCondition,
                 new PredicateAggregator<JavaField>(),
-                Optional.<String>absent());
+                Optional.<String>empty());
     }
 
     private GivenFieldsInternal(

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenMethodsInternal.java
Patch:
@@ -43,7 +43,7 @@ class GivenMethodsInternal
                 classesTransformer,
                 prepareCondition,
                 new PredicateAggregator<JavaMethod>(),
-                Optional.<String>absent());
+                Optional.<String>empty());
     }
 
     private GivenMethodsInternal(

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenObjectsInternal.java
Patch:
@@ -33,7 +33,7 @@ class GivenObjectsInternal<T> extends AbstractGivenObjects<T, GivenObjectsIntern
     GivenObjectsInternal(Priority priority,
             ClassesTransformer<T> classesTransformer,
             Function<ArchCondition<T>, ArchCondition<T>> prepareCondition) {
-        this(priority, classesTransformer, prepareCondition, new PredicateAggregator<T>(), Optional.<String>absent());
+        this(priority, classesTransformer, prepareCondition, new PredicateAggregator<T>(), Optional.<String>empty());
     }
 
     private GivenObjectsInternal(

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ObjectsShouldInternal.java
Patch:
@@ -112,7 +112,7 @@ static class ConditionAggregator<T> {
         private final AddMode<T> addMode;
 
         ConditionAggregator() {
-            this(Optional.<ArchCondition<T>>absent(), AddMode.<T>and());
+            this(Optional.<ArchCondition<T>>empty(), AddMode.<T>and());
         }
 
         ConditionAggregator(ArchCondition<T> condition) {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/PredicateAggregator.java
Patch:
@@ -25,7 +25,7 @@ public final class PredicateAggregator<T> {
     private final Optional<DescribedPredicate<T>> predicate;
 
     public PredicateAggregator() {
-        this(AddMode.<T>and(), Optional.<DescribedPredicate<T>>absent());
+        this(AddMode.<T>and(), Optional.<DescribedPredicate<T>>empty());
     }
 
     private PredicateAggregator(AddMode<T> addMode, Optional<DescribedPredicate<T>> predicate) {

File: archunit/src/main/java/com/tngtech/archunit/library/Architectures.java
Patch:
@@ -114,7 +114,7 @@ private LayeredArchitecture() {
             this(new LayerDefinitions(),
                     new LinkedHashSet<LayerDependencySpecification>(),
                     new PredicateAggregator<Dependency>().thatORs(),
-                    Optional.<String>absent(),
+                    Optional.<String>empty(),
                     false);
         }
 
@@ -472,7 +472,7 @@ public static final class OnionArchitecture implements ArchRule {
         private List<IgnoredDependency> ignoredDependencies = new ArrayList<>();
 
         private OnionArchitecture() {
-            overriddenDescription = Optional.absent();
+            overriddenDescription = Optional.empty();
         }
 
         private OnionArchitecture(String[] domainModelPackageIdentifiers,

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Slices.java
Patch:
@@ -174,7 +174,7 @@ public static class Transformer implements ClassesTransformer<Slice> {
         }
 
         private Transformer(SliceAssignment sliceAssignment, String description, SlicesPredicateAggregator predicate) {
-            this(sliceAssignment, description, Optional.<String>absent(), predicate);
+            this(sliceAssignment, description, Optional.<String>empty(), predicate);
         }
 
         private Transformer(SliceAssignment sliceAssignment,
@@ -331,8 +331,8 @@ private PackageMatchingSliceIdentifier(String packageIdentifier) {
         @Override
         public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
             PackageMatcher matcher = PackageMatcher.of(packageIdentifier);
-            Optional<List<String>> result = matcher.match(javaClass.getPackageName()).transform(TO_GROUPS);
-            List<String> parts = result.or(Collections.<String>emptyList());
+            Optional<List<String>> result = matcher.match(javaClass.getPackageName()).map(TO_GROUPS);
+            List<String> parts = result.orElse(Collections.<String>emptyList());
             return parts.isEmpty() ? SliceIdentifier.ignore() : SliceIdentifier.of(parts);
         }
 

File: archunit/src/main/java/com/tngtech/archunit/library/metrics/MetricsComponents.java
Patch:
@@ -59,7 +59,7 @@ public String apply(MetricsComponent<T> input) {
      */
     @PublicAPI(usage = ACCESS)
     public Optional<MetricsComponent<T>> tryGetComponent(String identifier) {
-        return Optional.fromNullable(componentsByIdentifier.get(identifier));
+        return Optional.ofNullable(componentsByIdentifier.get(identifier));
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/ComponentIdentifier.java
Patch:
@@ -24,7 +24,7 @@ class ComponentIdentifier {
     private final Optional<Alias> alias;
 
     ComponentIdentifier(ComponentName componentName) {
-        this(componentName, Optional.<Alias>absent());
+        this(componentName, Optional.<Alias>empty());
     }
 
     ComponentIdentifier(ComponentName componentName, Alias alias) {

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/PlantUmlParser.java
Patch:
@@ -97,7 +97,7 @@ private PlantUmlComponent createNewComponent(String input) {
 
         ComponentName componentName = new ComponentName(matcher.matchComponentName());
         ImmutableSet<Stereotype> immutableStereotypes = identifyStereotypes(matcher, componentName);
-        Optional<Alias> alias = Optional.fromNullable(matcher.matchAlias().transform(TO_ALIAS).orNull());
+        Optional<Alias> alias = Optional.ofNullable(matcher.matchAlias().transform(TO_ALIAS).orNull());
 
         return new PlantUmlComponent.Builder()
                 .withComponentName(componentName)
@@ -134,4 +134,4 @@ public Alias apply(String value) {
             return new Alias(value);
         }
     };
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/base/PackageMatcherTest.java
Patch:
@@ -127,7 +127,7 @@ public void transform_match_to_groups() {
         Optional<Result> result = PackageMatcher.of("com.(*)..service.(**)")
                 .match("com.mycompany.some.service.special.name");
 
-        assertThat(result.transform(TO_GROUPS).get()).contains("mycompany", "special.name");
+        assertThat(result.map(TO_GROUPS).get()).contains("mycompany", "special.name");
     }
 
     @Test
@@ -136,4 +136,4 @@ public void transform_mismatch_to_absent() {
 
         assertThat(result).isAbsent();
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/core/domain/SourceTest.java
Patch:
@@ -42,7 +42,7 @@ public void source_file_name() throws URISyntaxException {
         Source source = new Source(urlOf(Object.class).toURI(), Optional.of("SomeClass.java"), false);
         assertThat(source.getFileName()).as("source file name").contains("SomeClass.java");
 
-        source = new Source(urlOf(Object.class).toURI(), Optional.<String>absent(), false);
+        source = new Source(urlOf(Object.class).toURI(), Optional.<String>empty(), false);
         assertThat(source.getFileName()).as("source file name").isAbsent();
     }
 
@@ -162,7 +162,7 @@ private Source newSource(URL url) throws URISyntaxException {
     }
 
     private Source newSource(URI uri) {
-        return new Source(uri, Optional.<String>absent(), true);
+        return new Source(uri, Optional.<String>empty(), true);
     }
 
     private static Md5sum md5sumOf(String data) {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasThrowsClauseTest.java
Patch:
@@ -10,8 +10,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import static com.tngtech.archunit.core.domain.Formatters.formatNamesOf;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.equivalentTo;
-import static com.tngtech.archunit.core.domain.JavaClass.namesOf;
 import static com.tngtech.archunit.core.domain.TestUtils.throwsClause;
 import static com.tngtech.archunit.core.domain.properties.HasThrowsClause.Predicates.throwsClauseContainingType;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
@@ -82,7 +82,7 @@ public ThrowsClause<?> getThrowsClause() {
 
             @Override
             public String toString() {
-                return HasThrowsClause.class.getSimpleName() + "{ throws " + namesOf(throwsDeclarations) + "}";
+                return HasThrowsClause.class.getSimpleName() + "{ throws " + formatNamesOf(throwsDeclarations) + "}";
             }
         };
     }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterMembersTest.java
Patch:
@@ -131,7 +131,7 @@ public void imports_fields_with_correct_modifiers() {
     @Test
     public void imports_simple_methods_with_correct_parameters() throws Exception {
         Set<JavaMethod> methods = getMethods(new ClassFileImporter().importUrl(getClass().getResource("testexamples/methodimport")));
-        assertThat(methods).extractingResultOf("getDefaultValue").containsOnly(Optional.absent());
+        assertThat(methods).extractingResultOf("getDefaultValue").containsOnly(Optional.empty());
 
         assertThat(findAnyByName(methods, "createString")).isEquivalentTo(
                 ClassWithStringStringMethod.class.getDeclaredMethod("createString", String.class));

File: archunit/src/test/java/com/tngtech/archunit/lang/FailureDisplayFormatFactoryTest.java
Patch:
@@ -25,7 +25,7 @@ public void configured_failure_display_format_is_used() {
         assertThat(failureDisplayFormat).isInstanceOf(TestFailureDisplayFormat.class);
 
         String message = failureDisplayFormat.formatFailure(hasDescription("some-rule"),
-                new FailureMessages(ImmutableList.of("some-failure"), Optional.<String>absent()),
+                new FailureMessages(ImmutableList.of("some-failure"), Optional.<String>empty()),
                 Priority.LOW);
 
         assertThat(message).isEqualTo("test-format: some-rule has [some-failure] with priority LOW");

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/ClassesShouldTest.java
Patch:
@@ -19,7 +19,6 @@
 import com.tngtech.archunit.core.domain.JavaAccess;
 import com.tngtech.archunit.core.domain.JavaAnnotation;
 import com.tngtech.archunit.core.domain.JavaCall;
-import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaModifier;
 import com.tngtech.archunit.core.domain.properties.CanBeAnnotatedTest;
 import com.tngtech.archunit.core.domain.properties.CanBeAnnotatedTest.ClassRetentionAnnotation;
@@ -47,6 +46,7 @@
 import static com.tngtech.archunit.base.DescribedPredicate.lessThan;
 import static com.tngtech.archunit.base.DescribedPredicate.lessThanOrEqualTo;
 import static com.tngtech.archunit.base.DescribedPredicate.not;
+import static com.tngtech.archunit.core.domain.Formatters.formatNamesOf;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.type;
 import static com.tngtech.archunit.core.domain.JavaClassTest.expectInvalidSyntaxUsageForClassInsteadOfInterface;
 import static com.tngtech.archunit.core.domain.JavaConstructor.CONSTRUCTOR_NAME;
@@ -1889,7 +1889,7 @@ private Pattern callCodeUnitRegex(Class<?> origin, Class<?> targetClass, String
     }
 
     private Pattern callRegex(Class<?> origin, Class<?> targetClass, String targetType, String methodName, Class<?>... paramTypes) {
-        String params = Joiner.on(", ").join(JavaClass.namesOf(paramTypes));
+        String params = Joiner.on(", ").join(formatNamesOf(paramTypes));
         String originCalls = String.format("%s[^%s]* calls", quote(origin.getName()), FAILURE_REPORT_NEWLINE_MARKER);
         String target = String.format("[^%s]*%s\\.%s\\(%s\\)",
                 FAILURE_REPORT_NEWLINE_MARKER, quote(targetClass.getName()), methodName, quote(params));

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/MembersShouldTest.java
Patch:
@@ -27,8 +27,8 @@
 
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.tngtech.archunit.base.DescribedPredicate.not;
+import static com.tngtech.archunit.core.domain.Formatters.formatNamesOf;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.equivalentTo;
-import static com.tngtech.archunit.core.domain.JavaClass.namesOf;
 import static com.tngtech.archunit.core.domain.JavaConstructor.CONSTRUCTOR_NAME;
 import static com.tngtech.archunit.core.domain.JavaModifier.PRIVATE;
 import static com.tngtech.archunit.core.domain.TestUtils.importClasses;
@@ -663,7 +663,7 @@ static Set<String> parseMembers(Class<?> possibleOwner, List<String> details) {
 
     static Set<String> parseMembers(List<Class<?>> possibleOwners, List<String> details) {
         List<String> classNamePatterns = new ArrayList<>();
-        for (String className : namesOf(possibleOwners)) {
+        for (String className : formatNamesOf(possibleOwners)) {
             classNamePatterns.add(quote(className));
         }
         String classesWithMembersRegex = String.format("(?:%s)", Joiner.on("|").join(classNamePatterns));

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/SlicesTest.java
Patch:
@@ -119,7 +119,7 @@ private Optional<Slice> tryGetSliceOf(Class<?> clazz, Slices slices) {
                 }
             }
         }
-        return Optional.absent();
+        return Optional.empty();
     }
 
     private SliceAssignment assignmentOfJavaLangAndUtil(final String description) {

File: archunit/src/test/java/com/tngtech/archunit/testutil/Conditions.java
Patch:
@@ -4,7 +4,7 @@
 import com.tngtech.archunit.core.domain.properties.HasName;
 import org.assertj.core.api.Condition;
 
-import static com.tngtech.archunit.core.domain.JavaClass.namesOf;
+import static com.tngtech.archunit.core.domain.Formatters.formatNamesOf;
 
 public final class Conditions {
     private Conditions() {
@@ -27,8 +27,8 @@ public static Condition<JavaCodeUnit> codeUnitWithSignature(final String name, f
         return new Condition<JavaCodeUnit>() {
             @Override
             public boolean matches(JavaCodeUnit value) {
-                return name.equals(value.getName()) && namesOf(parameters).equals(HasName.Utils.namesOf(value.getRawParameterTypes()));
+                return name.equals(value.getName()) && formatNamesOf(parameters).equals(HasName.Utils.namesOf(value.getRawParameterTypes()));
             }
-        }.as("matches signature <" + name + ", " + namesOf(parameters) + ">");
+        }.as("matches signature <" + name + ", " + formatNamesOf(parameters) + ">");
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaMemberAssertion.java
Patch:
@@ -9,7 +9,7 @@
 import org.assertj.core.api.AbstractObjectAssert;
 
 import static com.tngtech.archunit.core.domain.Formatters.formatMethodParameterTypeNames;
-import static com.tngtech.archunit.core.domain.JavaClass.namesOf;
+import static com.tngtech.archunit.core.domain.Formatters.formatNamesOf;
 import static com.tngtech.archunit.core.domain.JavaConstructor.CONSTRUCTOR_NAME;
 import static com.tngtech.archunit.testutil.assertion.JavaMembersAssertion.assertEquivalent;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -54,6 +54,6 @@ static <T extends Member & AnnotatedElement> String getExpectedNameOf(T member,
     }
 
     private static String expectedParametersOf(Class<?>[] parameterTypes) {
-        return String.format("(%s)", formatMethodParameterTypeNames(namesOf(parameterTypes)));
+        return String.format("(%s)", formatMethodParameterTypeNames(formatNamesOf(parameterTypes)));
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaMethodsAssertion.java
Patch:
@@ -4,7 +4,7 @@
 import org.assertj.core.api.AbstractIterableAssert;
 
 import static com.tngtech.archunit.core.domain.Formatters.formatMethod;
-import static com.tngtech.archunit.core.domain.JavaClass.namesOf;
+import static com.tngtech.archunit.core.domain.Formatters.formatNamesOf;
 import static com.tngtech.archunit.core.domain.properties.HasParameterTypes.Predicates.rawParameterTypes;
 
 public class JavaMethodsAssertion
@@ -22,7 +22,7 @@ protected JavaMethodAssertion toAssert(JavaMethod value, String description) {
     public JavaMethodsAssertion contain(Class<?> owner, String name, Class<?>... parameterTypes) {
         if (!contains(owner, name, parameterTypes)) {
             throw new AssertionError(String.format("There is no method %s contained in %s",
-                    formatMethod(owner.getName(), name, namesOf(parameterTypes)), actual));
+                    formatMethod(owner.getName(), name, formatNamesOf(parameterTypes)), actual));
         }
         return this;
     }

File: archunit/src/test/java/com/tngtech/archunit/testutil/syntax/MethodChoiceStrategy.java
Patch:
@@ -51,7 +51,7 @@ public boolean apply(Method input) {
     Optional<Method> choose(PropagatedType type, boolean tryToTerminate) {
         List<Method> methods = getPossibleMethodCandidates(type.getRawType());
         if (methods.isEmpty()) {
-            return Optional.absent();
+            return Optional.empty();
         }
 
         return tryToTerminate
@@ -65,7 +65,7 @@ private Optional<Method> findMethodWithReturnType(List<Method> methods, Class<Ar
                 return Optional.of(method);
             }
         }
-        return Optional.absent();
+        return Optional.empty();
     }
 
     private List<Method> getPossibleMethodCandidates(Class<?> clazz) {

File: archunit/src/main/java/com/tngtech/archunit/ArchConfiguration.java
Patch:
@@ -122,7 +122,7 @@ public void setMd5InClassSourcesEnabled(boolean enabled) {
 
     @PublicAPI(usage = ACCESS)
     public Optional<String> getClassResolver() {
-        return Optional.fromNullable(properties.getProperty(CLASS_RESOLVER));
+        return Optional.ofNullable(properties.getProperty(CLASS_RESOLVER));
     }
 
     @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/base/PackageMatcher.java
Patch:
@@ -133,7 +133,7 @@ public boolean matches(String aPackage) {
     @PublicAPI(usage = ACCESS)
     public Optional<Result> match(String aPackage) {
         Matcher matcher = packagePattern.matcher(aPackage);
-        return matcher.matches() ? Optional.of(new Result(matcher)) : Optional.<Result>absent();
+        return matcher.matches() ? Optional.of(new Result(matcher)) : Optional.<Result>empty();
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AnnotationProxy.java
Patch:
@@ -100,7 +100,7 @@ public Object invoke(Object proxy, Method method, Object[] args) {
                 return handlersByMethod.get(key).handle(proxy, method, args);
             }
 
-            Object result = toProxy.get(method.getName()).or(method.getDefaultValue());
+            Object result = toProxy.get(method.getName()).orElse(method.getDefaultValue());
             return conversions.convertIfNecessary(result, method.getReturnType());
         }
     }
@@ -315,7 +315,7 @@ <T> Object convertIfNecessary(T result, Class<?> returnType) {
             if (returnType.isInstance(result)) {
                 return result;
             }
-            return tryFindConversionFor(returnType).or(new NoOpConversion<>()).convert(result, returnType);
+            return tryFindConversionFor(returnType).orElse(new NoOpConversion<>()).convert(result, returnType);
         }
 
         private static class NoOpConversion<T> implements Conversion<T> {
@@ -337,7 +337,7 @@ private <F> Optional<Conversion<F>> tryFindConversionFor(Class<?> returnType) {
                     return Optional.of((Conversion<F>) conversion);
                 }
             }
-            return Optional.absent();
+            return Optional.empty();
         }
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Dependency.java
Patch:
@@ -221,7 +221,7 @@ private static Set<Dependency> createComponentTypeDependencies(
 
     private static Optional<Dependency> tryCreateDependency(JavaClass originClass, JavaClass targetClass, String description, int lineNumber) {
         if (originClass.equals(targetClass) || targetClass.isPrimitive()) {
-            return Optional.absent();
+            return Optional.empty();
         }
         return Optional.of(new Dependency(originClass, targetClass, lineNumber, description));
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaAnnotation.java
Patch:
@@ -208,7 +208,7 @@ private Optional<Object> tryGetDefaultValue(String property) {
         Optional<JavaMethod> method = type.tryGetMethod(property);
         return method.isPresent()
                 ? method.get().getDefaultValue()
-                : Optional.absent();
+                : Optional.empty();
     }
 
     /**
@@ -259,7 +259,7 @@ public Object getExplicitlyDeclaredProperty(String propertyName) {
      */
     @PublicAPI(usage = ACCESS)
     public Optional<Object> tryGetExplicitlyDeclaredProperty(String propertyName) {
-        return Optional.fromNullable(values.get(propertyName));
+        return Optional.ofNullable(values.get(propertyName));
     }
 
     /**

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassDescriptor.java
Patch:
@@ -185,7 +185,7 @@ Class<?> classForName(ClassLoader classLoader) throws ClassNotFoundException {
 
             @Override
             public Optional<JavaClassDescriptor> tryGetComponentType() {
-                return Optional.absent();
+                return Optional.empty();
             }
 
             @Override

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassMembers.java
Patch:
@@ -128,7 +128,7 @@ Optional<JavaField> tryGetField(String name) {
                 return Optional.of(field);
             }
         }
-        return Optional.absent();
+        return Optional.empty();
     }
 
     Set<JavaCodeUnit> getCodeUnits() {
@@ -261,7 +261,7 @@ private <T extends JavaCodeUnit> Optional<T> tryFindMatchingCodeUnit(Set<T> code
                 return Optional.of(codeUnit);
             }
         }
-        return Optional.absent();
+        return Optional.empty();
     }
 
     void completeAnnotations(ImportContext context) {
@@ -288,7 +288,7 @@ static JavaClassMembers empty(JavaClass owner) {
                 Collections.<JavaField>emptySet(),
                 Collections.<JavaMethod>emptySet(),
                 Collections.<JavaConstructor>emptySet(),
-                Optional.<JavaStaticInitializer>absent());
+                Optional.<JavaStaticInitializer>empty());
     }
 
     static JavaClassMembers create(JavaClass owner, ImportContext context) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMember.java
Patch:
@@ -92,13 +92,13 @@ public JavaAnnotation<? extends JavaMember> getAnnotationOfType(String typeName)
     @Override
     @PublicAPI(usage = ACCESS)
     public <A extends Annotation> Optional<A> tryGetAnnotationOfType(Class<A> type) {
-        return tryGetAnnotationOfType(type.getName()).transform(toAnnotationOfType(type));
+        return tryGetAnnotationOfType(type.getName()).map(toAnnotationOfType(type));
     }
 
     @Override
     @PublicAPI(usage = ACCESS)
     public Optional<? extends JavaAnnotation<? extends JavaMember>> tryGetAnnotationOfType(String typeName) {
-        return Optional.fromNullable(annotations.get(typeName));
+        return Optional.ofNullable(annotations.get(typeName));
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Source.java
Patch:
@@ -180,7 +180,7 @@ private static Optional<byte[]> read(URI uri) {
             try (InputStream in = uri.toURL().openStream()) {
                 return Optional.of(ByteStreams.toByteArray(in));
             } catch (IOException | RuntimeException e) {
-                return Optional.absent();
+                return Optional.empty();
             }
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/SourceCodeLocation.java
Patch:
@@ -54,7 +54,7 @@ public static SourceCodeLocation of(JavaClass sourceClass, int lineNumber) {
     private static String formatLocation(JavaClass sourceClass, int lineNumber) {
         Optional<String> recordedSourceFileName = sourceClass.getSource().isPresent()
                 ? sourceClass.getSource().get().getFileName()
-                : Optional.<String>absent();
+                : Optional.<String>empty();
         String sourceFileName = recordedSourceFileName.isPresent() ? recordedSourceFileName.get() : guessSourceFileName(sourceClass);
         return "(" + sourceFileName + ":" + lineNumber + ")";
     }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/AccessRecord.java
Patch:
@@ -147,7 +147,7 @@ public Optional<JavaConstructor> get() {
                             return Optional.of(constructor);
                         }
                     }
-                    return Optional.absent();
+                    return Optional.empty();
                 }
             }
         }
@@ -334,7 +334,7 @@ public boolean exists(JavaClass clazz, TargetInfo target) {
         };
 
         private static <T> Optional<T> uniqueTargetIn(Collection<T> collection) {
-            return collection.size() == 1 ? Optional.of(getOnlyElement(collection)) : Optional.<T>absent();
+            return collection.size() == 1 ? Optional.of(getOnlyElement(collection)) : Optional.<T>empty();
         }
 
         private static List<JavaClass> getArgumentTypesFrom(String descriptor, ImportedClasses classes) {
@@ -359,7 +359,7 @@ private Optional<JavaClass> tryFindChildInHierarchy(JavaClassDescriptor childTyp
                         return Optional.of(subclass);
                     }
                 }
-                return Optional.absent();
+                return Optional.empty();
             }
 
             private List<JavaClass> createPath(JavaClass parent, JavaClass child) {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileProcessor.java
Patch:
@@ -220,7 +220,7 @@ public Optional<JavaClass> tryImport(URI uri) {
                 return classProcessor.createJavaClass();
             } catch (Exception e) {
                 LOG.warn(String.format("Error during import from %s, falling back to simple import", uri), e);
-                return Optional.absent();
+                return Optional.empty();
             }
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassSignatureImporter.java
Patch:
@@ -68,7 +68,7 @@ List<JavaTypeParameterBuilder<JavaClass>> getTypeParameterBuilders() {
         }
 
         Optional<JavaParameterizedTypeBuilder<JavaClass>> getGenericSuperclass() {
-            return Optional.fromNullable(superclassProcessor.superclass);
+            return Optional.ofNullable(superclassProcessor.superclass);
         }
 
         Set<JavaParameterizedTypeBuilder<JavaClass>> getGenericInterfaces() {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaCodeUnitSignatureImporter.java
Patch:
@@ -77,14 +77,14 @@ public SignatureVisitor visitReturnType() {
         public JavaCodeUnitSignature getParsedSignature() {
             return new JavaCodeUnitSignature(
                     typeParameterProcessor.getTypeParameterBuilders(),
-                    Optional.fromNullable(genericMethodReturnTypeProcessor.getType()));
+                    Optional.ofNullable(genericMethodReturnTypeProcessor.getType()));
         }
     }
 
     static class JavaCodeUnitSignature {
         static final JavaCodeUnitSignature ABSENT = new JavaCodeUnitSignature(
                 Collections.<JavaTypeParameterBuilder<JavaCodeUnit>>emptyList(),
-                Optional.<JavaTypeCreationProcess<JavaCodeUnit>>absent()
+                Optional.<JavaTypeCreationProcess<JavaCodeUnit>>empty()
         );
 
         private final List<JavaTypeParameterBuilder<JavaCodeUnit>> typeParameterBuilders;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaFieldTypeSignatureImporter.java
Patch:
@@ -30,7 +30,7 @@ class JavaFieldTypeSignatureImporter {
 
     static Optional<JavaTypeCreationProcess<JavaField>> parseAsmFieldTypeSignature(String signature) {
         if (signature == null) {
-            return Optional.absent();
+            return Optional.empty();
         }
 
         log.trace("Analyzing field signature: {}", signature);

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/ClassResolver.java
Patch:
@@ -103,7 +103,7 @@ public ClassResolver create() {
         private Optional<ClassResolver> getExplicitlyConfiguredClassResolver() {
             Optional<String> resolverClassName = ArchConfiguration.get().getClassResolver();
             if (!resolverClassName.isPresent()) {
-                return Optional.absent();
+                return Optional.empty();
             }
 
             Class<?> resolverClass = classForName(resolverClassName);
@@ -152,7 +152,7 @@ private Optional<Constructor<?>> tryGetListConstructor(Class<?> resolverClass) {
             try {
                 return Optional.<Constructor<?>>of(resolverClass.getConstructor(List.class));
             } catch (NoSuchMethodException e) {
-                return Optional.absent();
+                return Optional.empty();
             }
         }
 
@@ -179,7 +179,7 @@ public void setClassUriImporter(ClassUriImporter classUriImporter) {
 
             @Override
             public Optional<JavaClass> tryResolve(String typeName) {
-                return Optional.absent();
+                return Optional.empty();
             }
         }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/ClassResolverFromClasspath.java
Patch:
@@ -48,13 +48,13 @@ public Optional<JavaClass> tryResolve(String typeName) {
 
         Optional<URI> uri = tryGetUriOf(typeFile);
 
-        return uri.isPresent() ? classUriImporter.tryImport(uri.get()) : Optional.<JavaClass>absent();
+        return uri.isPresent() ? classUriImporter.tryImport(uri.get()) : Optional.<JavaClass>empty();
     }
 
     private Optional<URI> tryGetUriOf(String typeFile) {
         URL resource = getCurrentClassLoader(getClass()).getResource(typeFile);
         if (resource == null) {
-            return Optional.absent();
+            return Optional.empty();
         }
         try {
             return Optional.of(resource.toURI());

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/SelectedClassResolverFromClasspath.java
Patch:
@@ -55,6 +55,6 @@ public Optional<JavaClass> tryResolve(String typeName) {
                 return classResolverFromClasspath.tryResolve(typeName);
             }
         }
-        return Optional.absent();
+        return Optional.empty();
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/ArchRule.java
Patch:
@@ -163,7 +163,7 @@ public EvaluationResult getResult() {
     @Internal
     class Factory {
         public static <T> ArchRule create(final ClassesTransformer<T> classesTransformer, final ArchCondition<T> condition, final Priority priority) {
-            return new SimpleArchRule<>(priority, classesTransformer, condition, Optional.<String>absent());
+            return new SimpleArchRule<>(priority, classesTransformer, condition, Optional.<String>empty());
         }
 
         public static ArchRule withBecause(ArchRule rule, String reason) {

File: archunit/src/main/java/com/tngtech/archunit/lang/ConditionEvents.java
Patch:
@@ -40,7 +40,7 @@ public ConditionEvents() {
     }
 
     private final Multimap<Type, ConditionEvent> eventsByViolation = ArrayListMultimap.create();
-    private Optional<String> informationAboutNumberOfViolations = Optional.absent();
+    private Optional<String> informationAboutNumberOfViolations = Optional.empty();
 
     @PublicAPI(usage = ACCESS)
     public void add(ConditionEvent event) {

File: archunit/src/main/java/com/tngtech/archunit/lang/FailureMessages.java
Patch:
@@ -41,7 +41,7 @@ public class FailureMessages extends ForwardingList<String> {
      */
     @PublicAPI(usage = ACCESS)
     public String getInformationAboutNumberOfViolations() {
-        return informationAboutNumberOfViolations.or(failures.size() + " times");
+        return informationAboutNumberOfViolations.orElse(failures.size() + " times");
     }
 
     FailureMessages filter(Predicate<String> predicate) {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenCodeUnitsInternal.java
Patch:
@@ -72,7 +72,7 @@ static class GivenCodeUnitsInternal extends AbstractGivenCodeUnitsInternal<JavaC
                     classesTransformer,
                     prepareCondition,
                     new PredicateAggregator<JavaCodeUnit>(),
-                    Optional.<String>absent());
+                    Optional.<String>empty());
         }
 
         private GivenCodeUnitsInternal(

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenMembersInternal.java
Patch:
@@ -74,7 +74,7 @@ static class GivenMembersInternal extends AbstractGivenMembersInternal<JavaMembe
                     classesTransformer,
                     prepareCondition,
                     new PredicateAggregator<JavaMember>(),
-                    Optional.<String>absent());
+                    Optional.<String>empty());
         }
 
         private GivenMembersInternal(

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassesInternal.java
Patch:
@@ -38,7 +38,7 @@ class GivenClassesInternal extends AbstractGivenObjects<JavaClass, GivenClassesI
 
     GivenClassesInternal(Priority priority, ClassesTransformer<JavaClass> classesTransformer,
             Function<ArchCondition<JavaClass>, ArchCondition<JavaClass>> prepareCondition) {
-        this(priority, classesTransformer, prepareCondition, new PredicateAggregator<JavaClass>(), Optional.<String>absent());
+        this(priority, classesTransformer, prepareCondition, new PredicateAggregator<JavaClass>(), Optional.<String>empty());
     }
 
     private GivenClassesInternal(

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenConstructorsInternal.java
Patch:
@@ -42,7 +42,7 @@ class GivenConstructorsInternal extends AbstractGivenCodeUnitsInternal<JavaConst
                 classesTransformer,
                 prepareCondition,
                 new PredicateAggregator<JavaConstructor>(),
-                Optional.<String>absent());
+                Optional.<String>empty());
     }
 
     private GivenConstructorsInternal(

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenFieldsInternal.java
Patch:
@@ -43,7 +43,7 @@ class GivenFieldsInternal
                 classesTransformer,
                 prepareCondition,
                 new PredicateAggregator<JavaField>(),
-                Optional.<String>absent());
+                Optional.<String>empty());
     }
 
     private GivenFieldsInternal(

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenMethodsInternal.java
Patch:
@@ -43,7 +43,7 @@ class GivenMethodsInternal
                 classesTransformer,
                 prepareCondition,
                 new PredicateAggregator<JavaMethod>(),
-                Optional.<String>absent());
+                Optional.<String>empty());
     }
 
     private GivenMethodsInternal(

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenObjectsInternal.java
Patch:
@@ -33,7 +33,7 @@ class GivenObjectsInternal<T> extends AbstractGivenObjects<T, GivenObjectsIntern
     GivenObjectsInternal(Priority priority,
             ClassesTransformer<T> classesTransformer,
             Function<ArchCondition<T>, ArchCondition<T>> prepareCondition) {
-        this(priority, classesTransformer, prepareCondition, new PredicateAggregator<T>(), Optional.<String>absent());
+        this(priority, classesTransformer, prepareCondition, new PredicateAggregator<T>(), Optional.<String>empty());
     }
 
     private GivenObjectsInternal(

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ObjectsShouldInternal.java
Patch:
@@ -112,7 +112,7 @@ static class ConditionAggregator<T> {
         private final AddMode<T> addMode;
 
         ConditionAggregator() {
-            this(Optional.<ArchCondition<T>>absent(), AddMode.<T>and());
+            this(Optional.<ArchCondition<T>>empty(), AddMode.<T>and());
         }
 
         ConditionAggregator(ArchCondition<T> condition) {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/PredicateAggregator.java
Patch:
@@ -25,7 +25,7 @@ public final class PredicateAggregator<T> {
     private final Optional<DescribedPredicate<T>> predicate;
 
     public PredicateAggregator() {
-        this(AddMode.<T>and(), Optional.<DescribedPredicate<T>>absent());
+        this(AddMode.<T>and(), Optional.<DescribedPredicate<T>>empty());
     }
 
     private PredicateAggregator(AddMode<T> addMode, Optional<DescribedPredicate<T>> predicate) {

File: archunit/src/main/java/com/tngtech/archunit/library/Architectures.java
Patch:
@@ -114,7 +114,7 @@ private LayeredArchitecture() {
             this(new LayerDefinitions(),
                     new LinkedHashSet<LayerDependencySpecification>(),
                     new PredicateAggregator<Dependency>().thatORs(),
-                    Optional.<String>absent(),
+                    Optional.<String>empty(),
                     false);
         }
 
@@ -472,7 +472,7 @@ public static final class OnionArchitecture implements ArchRule {
         private List<IgnoredDependency> ignoredDependencies = new ArrayList<>();
 
         private OnionArchitecture() {
-            overriddenDescription = Optional.absent();
+            overriddenDescription = Optional.empty();
         }
 
         private OnionArchitecture(String[] domainModelPackageIdentifiers,

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Slices.java
Patch:
@@ -174,7 +174,7 @@ public static class Transformer implements ClassesTransformer<Slice> {
         }
 
         private Transformer(SliceAssignment sliceAssignment, String description, SlicesPredicateAggregator predicate) {
-            this(sliceAssignment, description, Optional.<String>absent(), predicate);
+            this(sliceAssignment, description, Optional.<String>empty(), predicate);
         }
 
         private Transformer(SliceAssignment sliceAssignment,
@@ -331,8 +331,8 @@ private PackageMatchingSliceIdentifier(String packageIdentifier) {
         @Override
         public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
             PackageMatcher matcher = PackageMatcher.of(packageIdentifier);
-            Optional<List<String>> result = matcher.match(javaClass.getPackageName()).transform(TO_GROUPS);
-            List<String> parts = result.or(Collections.<String>emptyList());
+            Optional<List<String>> result = matcher.match(javaClass.getPackageName()).map(TO_GROUPS);
+            List<String> parts = result.orElse(Collections.<String>emptyList());
             return parts.isEmpty() ? SliceIdentifier.ignore() : SliceIdentifier.of(parts);
         }
 

File: archunit/src/main/java/com/tngtech/archunit/library/metrics/MetricsComponents.java
Patch:
@@ -59,7 +59,7 @@ public String apply(MetricsComponent<T> input) {
      */
     @PublicAPI(usage = ACCESS)
     public Optional<MetricsComponent<T>> tryGetComponent(String identifier) {
-        return Optional.fromNullable(componentsByIdentifier.get(identifier));
+        return Optional.ofNullable(componentsByIdentifier.get(identifier));
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/ComponentIdentifier.java
Patch:
@@ -24,7 +24,7 @@ class ComponentIdentifier {
     private final Optional<Alias> alias;
 
     ComponentIdentifier(ComponentName componentName) {
-        this(componentName, Optional.<Alias>absent());
+        this(componentName, Optional.<Alias>empty());
     }
 
     ComponentIdentifier(ComponentName componentName, Alias alias) {

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/PlantUmlParser.java
Patch:
@@ -97,7 +97,7 @@ private PlantUmlComponent createNewComponent(String input) {
 
         ComponentName componentName = new ComponentName(matcher.matchComponentName());
         ImmutableSet<Stereotype> immutableStereotypes = identifyStereotypes(matcher, componentName);
-        Optional<Alias> alias = Optional.fromNullable(matcher.matchAlias().transform(TO_ALIAS).orNull());
+        Optional<Alias> alias = Optional.ofNullable(matcher.matchAlias().transform(TO_ALIAS).orNull());
 
         return new PlantUmlComponent.Builder()
                 .withComponentName(componentName)
@@ -134,4 +134,4 @@ public Alias apply(String value) {
             return new Alias(value);
         }
     };
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/base/PackageMatcherTest.java
Patch:
@@ -127,7 +127,7 @@ public void transform_match_to_groups() {
         Optional<Result> result = PackageMatcher.of("com.(*)..service.(**)")
                 .match("com.mycompany.some.service.special.name");
 
-        assertThat(result.transform(TO_GROUPS).get()).contains("mycompany", "special.name");
+        assertThat(result.map(TO_GROUPS).get()).contains("mycompany", "special.name");
     }
 
     @Test
@@ -136,4 +136,4 @@ public void transform_mismatch_to_absent() {
 
         assertThat(result).isAbsent();
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/core/domain/SourceTest.java
Patch:
@@ -42,7 +42,7 @@ public void source_file_name() throws URISyntaxException {
         Source source = new Source(urlOf(Object.class).toURI(), Optional.of("SomeClass.java"), false);
         assertThat(source.getFileName()).as("source file name").contains("SomeClass.java");
 
-        source = new Source(urlOf(Object.class).toURI(), Optional.<String>absent(), false);
+        source = new Source(urlOf(Object.class).toURI(), Optional.<String>empty(), false);
         assertThat(source.getFileName()).as("source file name").isAbsent();
     }
 
@@ -162,7 +162,7 @@ private Source newSource(URL url) throws URISyntaxException {
     }
 
     private Source newSource(URI uri) {
-        return new Source(uri, Optional.<String>absent(), true);
+        return new Source(uri, Optional.<String>empty(), true);
     }
 
     private static Md5sum md5sumOf(String data) {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/TestUtils.java
Patch:
@@ -76,7 +76,7 @@ public static Md5sum md5sumOf(byte[] bytes) {
         File file = newTemporaryFile();
         try {
             Files.write(bytes, file);
-            return new Source(file.toURI(), Optional.<String>absent(), true).getMd5sum();
+            return new Source(file.toURI(), Optional.<String>empty(), true).getMd5sum();
         } catch (IOException e) {
             throw new RuntimeException(e);
         }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterMembersTest.java
Patch:
@@ -131,7 +131,7 @@ public void imports_fields_with_correct_modifiers() {
     @Test
     public void imports_simple_methods_with_correct_parameters() throws Exception {
         Set<JavaMethod> methods = getMethods(new ClassFileImporter().importUrl(getClass().getResource("testexamples/methodimport")));
-        assertThat(methods).extractingResultOf("getDefaultValue").containsOnly(Optional.absent());
+        assertThat(methods).extractingResultOf("getDefaultValue").containsOnly(Optional.empty());
 
         assertThat(findAnyByName(methods, "createString")).isEquivalentTo(
                 ClassWithStringStringMethod.class.getDeclaredMethod("createString", String.class));

File: archunit/src/test/java/com/tngtech/archunit/lang/FailureDisplayFormatFactoryTest.java
Patch:
@@ -25,7 +25,7 @@ public void configured_failure_display_format_is_used() {
         assertThat(failureDisplayFormat).isInstanceOf(TestFailureDisplayFormat.class);
 
         String message = failureDisplayFormat.formatFailure(hasDescription("some-rule"),
-                new FailureMessages(ImmutableList.of("some-failure"), Optional.<String>absent()),
+                new FailureMessages(ImmutableList.of("some-failure"), Optional.<String>empty()),
                 Priority.LOW);
 
         assertThat(message).isEqualTo("test-format: some-rule has [some-failure] with priority LOW");

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/SlicesTest.java
Patch:
@@ -119,7 +119,7 @@ private Optional<Slice> tryGetSliceOf(Class<?> clazz, Slices slices) {
                 }
             }
         }
-        return Optional.absent();
+        return Optional.empty();
     }
 
     private SliceAssignment assignmentOfJavaLangAndUtil(final String description) {

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -88,7 +88,7 @@ public static ArchRuleAssertion assertThatRule(ArchRule rule) {
     }
 
     public static <T> org.assertj.guava.api.OptionalAssert<T> assertThat(Optional<T> optional) {
-        return org.assertj.guava.api.Assertions.assertThat(com.google.common.base.Optional.fromNullable(optional.orNull()));
+        return org.assertj.guava.api.Assertions.assertThat(com.google.common.base.Optional.fromNullable(optional.orElse(null)));
     }
 
     public static <T> DescribedPredicateAssertion<T> assertThat(DescribedPredicate<T> predicate) {

File: archunit/src/test/java/com/tngtech/archunit/testutil/syntax/MethodChoiceStrategy.java
Patch:
@@ -51,7 +51,7 @@ public boolean apply(Method input) {
     Optional<Method> choose(PropagatedType type, boolean tryToTerminate) {
         List<Method> methods = getPossibleMethodCandidates(type.getRawType());
         if (methods.isEmpty()) {
-            return Optional.absent();
+            return Optional.empty();
         }
 
         return tryToTerminate
@@ -65,7 +65,7 @@ private Optional<Method> findMethodWithReturnType(List<Method> methods, Class<Ar
                 return Optional.of(method);
             }
         }
-        return Optional.absent();
+        return Optional.empty();
     }
 
     private List<Method> getPossibleMethodCandidates(Class<?> clazz) {

File: archunit-integration-test/src/test/java/com/tngtech/archunit/PublicAPIRules.java
Patch:
@@ -39,6 +39,7 @@
 import static com.tngtech.archunit.core.domain.JavaModifier.PUBLIC;
 import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
 import static com.tngtech.archunit.core.domain.properties.HasModifiers.Predicates.modifier;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 import static com.tngtech.archunit.lang.SimpleConditionEvent.violated;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.are;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.have;
@@ -185,7 +186,7 @@ public boolean apply(JavaMember input) {
 
             private boolean equivalentMethod(JavaMethod method, String name, Class<?>... paramTypes) {
                 return method.getName().equals(name) &&
-                        method.getRawParameterTypes().getNames().equals(JavaClass.namesOf(paramTypes));
+                        namesOf(method.getRawParameterTypes()).equals(JavaClass.namesOf(paramTypes));
             }
 
             private boolean enumMethod(JavaMethod methodToCheck, String name, Class<?>... paramTypes) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AccessTarget.java
Patch:
@@ -319,8 +319,8 @@ public abstract static class CodeUnitCallTarget extends AccessTarget
 
         @Override
         @PublicAPI(usage = ACCESS)
-        public JavaClassList getRawParameterTypes() {
-            return DomainObjectCreationContext.createJavaClassList(parameters);
+        public List<JavaClass> getRawParameterTypes() {
+            return parameters;
         }
 
         @Override

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassMembers.java
Patch:
@@ -28,6 +28,7 @@
 import static com.google.common.collect.Iterables.concat;
 import static com.tngtech.archunit.core.domain.JavaConstructor.CONSTRUCTOR_NAME;
 import static com.tngtech.archunit.core.domain.JavaModifier.ENUM;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 
 class JavaClassMembers {
     private final JavaClass owner;
@@ -256,7 +257,7 @@ private <T extends JavaCodeUnit> T findMatchingCodeUnit(Set<T> codeUnits, String
 
     private <T extends JavaCodeUnit> Optional<T> tryFindMatchingCodeUnit(Set<T> codeUnits, String name, List<String> parameters) {
         for (T codeUnit : codeUnits) {
-            if (name.equals(codeUnit.getName()) && parameters.equals(codeUnit.getRawParameterTypes().getNames())) {
+            if (name.equals(codeUnit.getName()) && parameters.equals(namesOf(codeUnit.getRawParameterTypes()))) {
                 return Optional.of(codeUnit);
             }
         }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaConstructor.java
Patch:
@@ -30,6 +30,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 import static com.tngtech.archunit.core.domain.Formatters.formatMethod;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 
 public final class JavaConstructor extends JavaCodeUnit {
     private final Supplier<Constructor<?>> constructorSupplier;
@@ -115,7 +116,7 @@ public Constructor<?> get() {
                 return reflectedOwner.getDeclaredConstructor(reflect(getRawParameterTypes()));
             } catch (NoSuchMethodException e) {
                 throw new InconsistentClassPathException(
-                        "Can't resolve constructor " + formatMethod(reflectedOwner.getName(), getName(), getRawParameterTypes()), e);
+                        "Can't resolve constructor " + formatMethod(reflectedOwner.getName(), getName(), namesOf(getRawParameterTypes())), e);
             }
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMethod.java
Patch:
@@ -31,6 +31,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 import static com.tngtech.archunit.core.domain.Formatters.formatMethod;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 
 public class JavaMethod extends JavaCodeUnit {
     private final Supplier<Method> methodSupplier;
@@ -121,7 +122,7 @@ public Method get() {
                 return reflectedOwner.getDeclaredMethod(getName(), reflect(getRawParameterTypes()));
             } catch (NoSuchMethodException e) {
                 throw new InconsistentClassPathException(
-                        "Can't resolve method " + formatMethod(reflectedOwner.getName(), getName(), getRawParameterTypes()), e);
+                        "Can't resolve method " + formatMethod(reflectedOwner.getName(), getName(), namesOf(getRawParameterTypes())), e);
             }
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasThrowsClause.java
Patch:
@@ -29,7 +29,7 @@
 import static com.tngtech.archunit.base.DescribedPredicate.equalTo;
 import static com.tngtech.archunit.core.domain.Formatters.formatThrowsDeclarationTypeNames;
 import static com.tngtech.archunit.core.domain.JavaClass.namesOf;
-import static com.tngtech.archunit.core.domain.JavaClassList.GET_NAMES;
+import static com.tngtech.archunit.core.domain.properties.HasName.Functions.GET_NAMES;
 import static com.tngtech.archunit.core.domain.properties.HasName.Predicates.name;
 import static com.tngtech.archunit.core.domain.properties.HasType.Functions.GET_RAW_TYPE;
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -258,7 +258,7 @@ public MethodVisitor visitMethod(int access, String name, String desc, String si
                 .withName(name)
                 .withModifiers(JavaModifier.getModifiersForMethod(access))
                 .withTypeParameters(codeUnitSignature.getTypeParameterBuilders())
-                .withParameters(parameters)
+                .withParameterTypes(parameters)
                 .withReturnType(codeUnitSignature.getReturnType(), rawReturnType)
                 .withDescriptor(desc)
                 .withThrowsClause(typesFrom(exceptions));

File: archunit/src/main/java/com/tngtech/archunit/core/importer/RawAccessRecord.java
Patch:
@@ -23,6 +23,7 @@
 import com.tngtech.archunit.core.domain.JavaFieldAccess.AccessType;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 
 class RawAccessRecord {
     final CodeUnit caller;
@@ -119,7 +120,7 @@ public String toString() {
 
         public boolean is(JavaCodeUnit method) {
             return getName().equals(method.getName())
-                    && getParameters().equals(method.getRawParameterTypes().getNames())
+                    && getParameters().equals(namesOf(method.getRawParameterTypes()))
                     && getDeclaringClassName().equals(method.getOwner().getName());
         }
     }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/AccessTargetTest.java
Patch:
@@ -15,6 +15,7 @@
 import static com.tngtech.archunit.core.domain.TestUtils.withinImportedClasses;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 import static com.tngtech.archunit.testutil.Assertions.assertThatType;
+import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
 
 public class AccessTargetTest {
     @Test
@@ -202,7 +203,7 @@ public void predicate_constructor() {
 
     private void assertDeclarations(CodeUnitCallTarget target, Class<?>... exceptionTypes) {
         ThrowsClause<CodeUnitCallTarget> throwsClause = target.getThrowsClause();
-        assertThat(throwsClause.getTypes()).matches(exceptionTypes);
+        assertThatTypes(throwsClause.getTypes()).matchExactly(exceptionTypes);
         for (ThrowsDeclaration<CodeUnitCallTarget> throwsDeclaration : throwsClause) {
             assertThatType(throwsDeclaration.getDeclaringClass()).isEqualTo(target.getOwner());
             assertThat(throwsDeclaration.getOwner()).isEqualTo(target.getThrowsClause());

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassTest.java
Patch:
@@ -89,6 +89,7 @@
 import static com.tngtech.archunit.core.domain.TestUtils.simulateCall;
 import static com.tngtech.archunit.core.domain.properties.HasName.AndFullName.Predicates.fullNameMatching;
 import static com.tngtech.archunit.core.domain.properties.HasName.Predicates.name;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 import static com.tngtech.archunit.testutil.Assertions.assertThatDependencies;
 import static com.tngtech.archunit.testutil.Assertions.assertThatType;
@@ -475,7 +476,7 @@ private Condition<JavaCodeUnit> equivalentCodeUnit(final Class<?> owner, final S
             public boolean matches(JavaCodeUnit value) {
                 return value.getOwner().isEquivalentTo(owner) &&
                         value.getName().equals(methodName) &&
-                        value.getRawParameterTypes().getNames().equals(ImmutableList.of(paramType.getName()));
+                        namesOf(value.getRawParameterTypes()).equals(ImmutableList.of(paramType.getName()));
             }
         };
     }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterMembersTest.java
Patch:
@@ -58,6 +58,7 @@
 import static com.tngtech.archunit.core.domain.JavaModifier.STATIC;
 import static com.tngtech.archunit.core.domain.JavaModifier.TRANSIENT;
 import static com.tngtech.archunit.core.domain.JavaModifier.VOLATILE;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 import static com.tngtech.archunit.core.importer.ClassFileImporterTestUtils.findAnyByName;
 import static com.tngtech.archunit.core.importer.ClassFileImporterTestUtils.getCodeUnits;
 import static com.tngtech.archunit.core.importer.ClassFileImporterTestUtils.getFields;
@@ -67,7 +68,6 @@
 import static com.tngtech.archunit.testutil.Assertions.assertThatType;
 import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
 import static com.tngtech.archunit.testutil.ReflectionTestUtils.field;
-import static com.tngtech.archunit.testutil.TestUtils.namesOf;
 import static com.tngtech.archunit.testutil.assertion.ReferencedClassObjectsAssertion.referencedClassObject;
 
 public class ClassFileImporterMembersTest {
@@ -176,7 +176,7 @@ public void imports_methods_with_correct_throws_declarations() {
         assertThat(method.getThrowsClause())
                 .as("Throws types of method 'throwsExceptions'")
                 .matches(FirstCheckedException.class, SecondCheckedException.class);
-        assertThat(method.getExceptionTypes()).matches(FirstCheckedException.class, SecondCheckedException.class);
+        assertThatTypes(method.getExceptionTypes()).matchExactly(FirstCheckedException.class, SecondCheckedException.class);
     }
 
     @Test
@@ -251,7 +251,7 @@ public void imports_constructor_with_correct_throws_declarations() {
         JavaConstructor constructor = getOnlyElement(clazz.getConstructors());
         assertThat(constructor.getThrowsClause()).as("Throws types of sole constructor")
                 .matches(FirstCheckedException.class, SecondCheckedException.class);
-        assertThat(constructor.getExceptionTypes()).matches(FirstCheckedException.class, SecondCheckedException.class);
+        assertThatTypes(constructor.getExceptionTypes()).matchExactly(FirstCheckedException.class, SecondCheckedException.class);
     }
 
     @Test

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterTest.java
Patch:
@@ -90,6 +90,7 @@
 import static com.tngtech.archunit.core.domain.SourceTest.urlOf;
 import static com.tngtech.archunit.core.domain.TestUtils.MD5_SUM_DISABLED;
 import static com.tngtech.archunit.core.domain.TestUtils.md5sumOf;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 import static com.tngtech.archunit.core.importer.ClassFileImporterTestUtils.findAnyByName;
 import static com.tngtech.archunit.core.importer.ClassFileImporterTestUtils.jarFileOf;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
@@ -99,7 +100,6 @@
 import static com.tngtech.archunit.testutil.ReflectionTestUtils.constructor;
 import static com.tngtech.archunit.testutil.ReflectionTestUtils.field;
 import static com.tngtech.archunit.testutil.ReflectionTestUtils.method;
-import static com.tngtech.archunit.testutil.TestUtils.namesOf;
 import static com.tngtech.java.junit.dataprovider.DataProviders.$;
 import static com.tngtech.java.junit.dataprovider.DataProviders.$$;
 import static com.tngtech.java.junit.dataprovider.DataProviders.testForEach;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportTestUtils.java
Patch:
@@ -79,7 +79,7 @@ private static Set<DomainBuilders.BuilderWithBuildParameter<JavaClass, JavaMetho
                     .withReturnType(
                             Optional.<JavaTypeCreationProcess<JavaCodeUnit>>absent(),
                             JavaClassDescriptor.From.name(method.getReturnType().getName()))
-                    .withParameters(typesFrom(method.getParameterTypes()))
+                    .withParameterTypes(typesFrom(method.getParameterTypes()))
                     .withName(method.getName())
                     .withDescriptor(Type.getMethodDescriptor(method))
                     .withModifiers(JavaModifier.getModifiersForMethod(method.getModifiers()))
@@ -95,7 +95,7 @@ private static Set<DomainBuilders.BuilderWithBuildParameter<JavaClass, JavaConst
                     .withReturnType(
                             Optional.<JavaTypeCreationProcess<JavaCodeUnit>>absent(),
                             JavaClassDescriptor.From.name(void.class.getName()))
-                    .withParameters(typesFrom(constructor.getParameterTypes()))
+                    .withParameterTypes(typesFrom(constructor.getParameterTypes()))
                     .withName(CONSTRUCTOR_NAME)
                     .withDescriptor(Type.getConstructorDescriptor(constructor))
                     .withModifiers(JavaModifier.getModifiersForMethod(constructor.getModifiers()))

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/CodeUnitsShouldTest.java
Patch:
@@ -31,6 +31,7 @@
 import static com.google.common.collect.Sets.union;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.equivalentTo;
 import static com.tngtech.archunit.core.domain.TestUtils.importClasses;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.codeUnits;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.constructors;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.methods;
@@ -280,7 +281,7 @@ private static DescribedPredicate<JavaCodeUnit> doNotHaveParametersOfType(final
         return new DescribedPredicate<JavaCodeUnit>("do not have parameters of type " + type.getSimpleName()) {
             @Override
             public boolean apply(JavaCodeUnit codeUnit) {
-                return !codeUnit.getRawParameterTypes().getNames().contains(type.getName());
+                return !namesOf(codeUnit.getRawParameterTypes()).contains(type.getName());
             }
         };
     }
@@ -296,4 +297,4 @@ private static Set<String> allConstructorsExcept(String... constructors) {
     private static Set<String> allCodeUnitsExcept(String... codeUnits) {
         return union(allMethodsExcept(codeUnits), allConstructorsExcept(codeUnits));
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/testutil/Conditions.java
Patch:
@@ -1,6 +1,7 @@
 package com.tngtech.archunit.testutil;
 
 import com.tngtech.archunit.core.domain.JavaCodeUnit;
+import com.tngtech.archunit.core.domain.properties.HasName;
 import org.assertj.core.api.Condition;
 
 import static com.tngtech.archunit.core.domain.JavaClass.namesOf;
@@ -26,7 +27,7 @@ public static Condition<JavaCodeUnit> codeUnitWithSignature(final String name, f
         return new Condition<JavaCodeUnit>() {
             @Override
             public boolean matches(JavaCodeUnit value) {
-                return name.equals(value.getName()) && namesOf(parameters).equals(value.getRawParameterTypes().getNames());
+                return name.equals(value.getName()) && namesOf(parameters).equals(HasName.Utils.namesOf(value.getRawParameterTypes()));
             }
         }.as("matches signature <" + name + ", " + namesOf(parameters) + ">");
     }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaConstructorAssertion.java
Patch:
@@ -8,6 +8,7 @@
 import static com.tngtech.archunit.core.domain.JavaConstructor.CONSTRUCTOR_NAME;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 import static com.tngtech.archunit.testutil.Assertions.assertThatType;
+import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
 import static com.tngtech.archunit.testutil.assertion.JavaMemberAssertion.getExpectedNameOf;
 
 public class JavaConstructorAssertion extends AbstractObjectAssert<JavaConstructorAssertion, JavaConstructor> {
@@ -19,7 +20,7 @@ public void isEquivalentTo(Constructor<?> constructor) {
         JavaMembersAssertion.assertEquivalent(actual, constructor);
         assertThat(actual.getName()).isEqualTo(CONSTRUCTOR_NAME);
         assertThat(actual.getFullName()).isEqualTo(getExpectedNameOf(constructor, CONSTRUCTOR_NAME));
-        assertThat(actual.getRawParameterTypes()).matches(constructor.getParameterTypes());
+        assertThatTypes(actual.getRawParameterTypes()).matchExactly(constructor.getParameterTypes());
         assertThatType(actual.getRawReturnType()).matches(void.class);
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaMethodAssertion.java
Patch:
@@ -7,6 +7,7 @@
 
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 import static com.tngtech.archunit.testutil.Assertions.assertThatType;
+import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
 import static com.tngtech.archunit.testutil.assertion.JavaMemberAssertion.getExpectedNameOf;
 import static com.tngtech.archunit.testutil.assertion.JavaMembersAssertion.assertEquivalent;
 
@@ -19,15 +20,15 @@ public JavaMethodAssertion isEquivalentTo(Method method) {
         assertEquivalent(actual, method);
         assertThat(actual.getFullName()).isEqualTo(getExpectedNameOf(method, method.getName()));
         assertThat(actual.getName()).isEqualTo(method.getName());
-        assertThat(actual.getRawParameterTypes()).matches(method.getParameterTypes());
+        assertThatTypes(actual.getRawParameterTypes()).matchExactly(method.getParameterTypes());
         assertThatType(actual.getRawReturnType()).matches(method.getReturnType());
         return this;
     }
 
     public JavaMethodAssertion isEquivalentTo(Class<?> owner, String methodName, Class<?>... parameterTypes) {
         assertThatType(actual.getOwner()).matches(owner);
         assertThat(actual.getName()).isEqualTo(methodName);
-        assertThat(actual.getRawParameterTypes()).matches(parameterTypes);
+        assertThatTypes(actual.getRawParameterTypes()).matchExactly(parameterTypes);
         return this;
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaTypeAssertion.java
Patch:
@@ -13,8 +13,8 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Strings.isNullOrEmpty;
 import static com.tngtech.archunit.core.domain.Formatters.ensureCanonicalArrayTypeName;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 import static com.tngtech.archunit.testutil.Assertions.assertThatTypeVariable;
-import static com.tngtech.archunit.testutil.TestUtils.namesOf;
 import static com.tngtech.archunit.testutil.assertion.JavaAnnotationAssertion.propertiesOf;
 import static com.tngtech.archunit.testutil.assertion.JavaAnnotationAssertion.runtimePropertiesOf;
 import static com.tngtech.archunit.testutil.assertion.JavaTypeVariableAssertion.getTypeVariableWithName;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/PublicAPIRules.java
Patch:
@@ -39,6 +39,7 @@
 import static com.tngtech.archunit.core.domain.JavaModifier.PUBLIC;
 import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Predicates.annotatedWith;
 import static com.tngtech.archunit.core.domain.properties.HasModifiers.Predicates.modifier;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 import static com.tngtech.archunit.lang.SimpleConditionEvent.violated;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.are;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.have;
@@ -185,7 +186,7 @@ public boolean apply(JavaMember input) {
 
             private boolean equivalentMethod(JavaMethod method, String name, Class<?>... paramTypes) {
                 return method.getName().equals(name) &&
-                        method.getRawParameterTypes().getNames().equals(JavaClass.namesOf(paramTypes));
+                        namesOf(method.getRawParameterTypes()).equals(JavaClass.namesOf(paramTypes));
             }
 
             private boolean enumMethod(JavaMethod methodToCheck, String name, Class<?>... paramTypes) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AccessTarget.java
Patch:
@@ -319,8 +319,8 @@ public abstract static class CodeUnitCallTarget extends AccessTarget
 
         @Override
         @PublicAPI(usage = ACCESS)
-        public JavaClassList getRawParameterTypes() {
-            return DomainObjectCreationContext.createJavaClassList(parameters);
+        public List<JavaClass> getRawParameterTypes() {
+            return parameters;
         }
 
         @Override

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassMembers.java
Patch:
@@ -28,6 +28,7 @@
 import static com.google.common.collect.Iterables.concat;
 import static com.tngtech.archunit.core.domain.JavaConstructor.CONSTRUCTOR_NAME;
 import static com.tngtech.archunit.core.domain.JavaModifier.ENUM;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 
 class JavaClassMembers {
     private final JavaClass owner;
@@ -256,7 +257,7 @@ private <T extends JavaCodeUnit> T findMatchingCodeUnit(Set<T> codeUnits, String
 
     private <T extends JavaCodeUnit> Optional<T> tryFindMatchingCodeUnit(Set<T> codeUnits, String name, List<String> parameters) {
         for (T codeUnit : codeUnits) {
-            if (name.equals(codeUnit.getName()) && parameters.equals(codeUnit.getRawParameterTypes().getNames())) {
+            if (name.equals(codeUnit.getName()) && parameters.equals(namesOf(codeUnit.getRawParameterTypes()))) {
                 return Optional.of(codeUnit);
             }
         }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaConstructor.java
Patch:
@@ -30,6 +30,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 import static com.tngtech.archunit.core.domain.Formatters.formatMethod;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 
 public final class JavaConstructor extends JavaCodeUnit {
     private final Supplier<Constructor<?>> constructorSupplier;
@@ -115,7 +116,7 @@ public Constructor<?> get() {
                 return reflectedOwner.getDeclaredConstructor(reflect(getRawParameterTypes()));
             } catch (NoSuchMethodException e) {
                 throw new InconsistentClassPathException(
-                        "Can't resolve constructor " + formatMethod(reflectedOwner.getName(), getName(), getRawParameterTypes()), e);
+                        "Can't resolve constructor " + formatMethod(reflectedOwner.getName(), getName(), namesOf(getRawParameterTypes())), e);
             }
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMethod.java
Patch:
@@ -31,6 +31,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 import static com.tngtech.archunit.core.domain.Formatters.formatMethod;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 
 public class JavaMethod extends JavaCodeUnit {
     private final Supplier<Method> methodSupplier;
@@ -121,7 +122,7 @@ public Method get() {
                 return reflectedOwner.getDeclaredMethod(getName(), reflect(getRawParameterTypes()));
             } catch (NoSuchMethodException e) {
                 throw new InconsistentClassPathException(
-                        "Can't resolve method " + formatMethod(reflectedOwner.getName(), getName(), getRawParameterTypes()), e);
+                        "Can't resolve method " + formatMethod(reflectedOwner.getName(), getName(), namesOf(getRawParameterTypes())), e);
             }
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasThrowsClause.java
Patch:
@@ -29,7 +29,7 @@
 import static com.tngtech.archunit.base.DescribedPredicate.equalTo;
 import static com.tngtech.archunit.core.domain.Formatters.formatThrowsDeclarationTypeNames;
 import static com.tngtech.archunit.core.domain.JavaClass.namesOf;
-import static com.tngtech.archunit.core.domain.JavaClassList.GET_NAMES;
+import static com.tngtech.archunit.core.domain.properties.HasName.Functions.GET_NAMES;
 import static com.tngtech.archunit.core.domain.properties.HasName.Predicates.name;
 import static com.tngtech.archunit.core.domain.properties.HasType.Functions.GET_RAW_TYPE;
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -258,7 +258,7 @@ public MethodVisitor visitMethod(int access, String name, String desc, String si
                 .withName(name)
                 .withModifiers(JavaModifier.getModifiersForMethod(access))
                 .withTypeParameters(codeUnitSignature.getTypeParameterBuilders())
-                .withParameters(parameters)
+                .withParameterTypes(parameters)
                 .withReturnType(codeUnitSignature.getReturnType(), rawReturnType)
                 .withDescriptor(desc)
                 .withThrowsClause(typesFrom(exceptions));

File: archunit/src/main/java/com/tngtech/archunit/core/importer/RawAccessRecord.java
Patch:
@@ -23,6 +23,7 @@
 import com.tngtech.archunit.core.domain.JavaFieldAccess.AccessType;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 
 class RawAccessRecord {
     final CodeUnit caller;
@@ -119,7 +120,7 @@ public String toString() {
 
         public boolean is(JavaCodeUnit method) {
             return getName().equals(method.getName())
-                    && getParameters().equals(method.getRawParameterTypes().getNames())
+                    && getParameters().equals(namesOf(method.getRawParameterTypes()))
                     && getDeclaringClassName().equals(method.getOwner().getName());
         }
     }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/AccessTargetTest.java
Patch:
@@ -15,6 +15,7 @@
 import static com.tngtech.archunit.core.domain.TestUtils.withinImportedClasses;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 import static com.tngtech.archunit.testutil.Assertions.assertThatType;
+import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
 
 public class AccessTargetTest {
     @Test
@@ -202,7 +203,7 @@ public void predicate_constructor() {
 
     private void assertDeclarations(CodeUnitCallTarget target, Class<?>... exceptionTypes) {
         ThrowsClause<CodeUnitCallTarget> throwsClause = target.getThrowsClause();
-        assertThat(throwsClause.getTypes()).matches(exceptionTypes);
+        assertThatTypes(throwsClause.getTypes()).matchExactly(exceptionTypes);
         for (ThrowsDeclaration<CodeUnitCallTarget> throwsDeclaration : throwsClause) {
             assertThatType(throwsDeclaration.getDeclaringClass()).isEqualTo(target.getOwner());
             assertThat(throwsDeclaration.getOwner()).isEqualTo(target.getThrowsClause());

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassTest.java
Patch:
@@ -89,6 +89,7 @@
 import static com.tngtech.archunit.core.domain.TestUtils.simulateCall;
 import static com.tngtech.archunit.core.domain.properties.HasName.AndFullName.Predicates.fullNameMatching;
 import static com.tngtech.archunit.core.domain.properties.HasName.Predicates.name;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 import static com.tngtech.archunit.testutil.Assertions.assertThatDependencies;
 import static com.tngtech.archunit.testutil.Assertions.assertThatType;
@@ -475,7 +476,7 @@ private Condition<JavaCodeUnit> equivalentCodeUnit(final Class<?> owner, final S
             public boolean matches(JavaCodeUnit value) {
                 return value.getOwner().isEquivalentTo(owner) &&
                         value.getName().equals(methodName) &&
-                        value.getRawParameterTypes().getNames().equals(ImmutableList.of(paramType.getName()));
+                        namesOf(value.getRawParameterTypes()).equals(ImmutableList.of(paramType.getName()));
             }
         };
     }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterMembersTest.java
Patch:
@@ -58,6 +58,7 @@
 import static com.tngtech.archunit.core.domain.JavaModifier.STATIC;
 import static com.tngtech.archunit.core.domain.JavaModifier.TRANSIENT;
 import static com.tngtech.archunit.core.domain.JavaModifier.VOLATILE;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 import static com.tngtech.archunit.core.importer.ClassFileImporterTestUtils.findAnyByName;
 import static com.tngtech.archunit.core.importer.ClassFileImporterTestUtils.getCodeUnits;
 import static com.tngtech.archunit.core.importer.ClassFileImporterTestUtils.getFields;
@@ -67,7 +68,6 @@
 import static com.tngtech.archunit.testutil.Assertions.assertThatType;
 import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
 import static com.tngtech.archunit.testutil.ReflectionTestUtils.field;
-import static com.tngtech.archunit.testutil.TestUtils.namesOf;
 import static com.tngtech.archunit.testutil.assertion.ReferencedClassObjectsAssertion.referencedClassObject;
 
 public class ClassFileImporterMembersTest {
@@ -176,7 +176,7 @@ public void imports_methods_with_correct_throws_declarations() {
         assertThat(method.getThrowsClause())
                 .as("Throws types of method 'throwsExceptions'")
                 .matches(FirstCheckedException.class, SecondCheckedException.class);
-        assertThat(method.getExceptionTypes()).matches(FirstCheckedException.class, SecondCheckedException.class);
+        assertThatTypes(method.getExceptionTypes()).matchExactly(FirstCheckedException.class, SecondCheckedException.class);
     }
 
     @Test
@@ -251,7 +251,7 @@ public void imports_constructor_with_correct_throws_declarations() {
         JavaConstructor constructor = getOnlyElement(clazz.getConstructors());
         assertThat(constructor.getThrowsClause()).as("Throws types of sole constructor")
                 .matches(FirstCheckedException.class, SecondCheckedException.class);
-        assertThat(constructor.getExceptionTypes()).matches(FirstCheckedException.class, SecondCheckedException.class);
+        assertThatTypes(constructor.getExceptionTypes()).matchExactly(FirstCheckedException.class, SecondCheckedException.class);
     }
 
     @Test

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterTest.java
Patch:
@@ -90,6 +90,7 @@
 import static com.tngtech.archunit.core.domain.SourceTest.urlOf;
 import static com.tngtech.archunit.core.domain.TestUtils.MD5_SUM_DISABLED;
 import static com.tngtech.archunit.core.domain.TestUtils.md5sumOf;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 import static com.tngtech.archunit.core.importer.ClassFileImporterTestUtils.findAnyByName;
 import static com.tngtech.archunit.core.importer.ClassFileImporterTestUtils.jarFileOf;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
@@ -99,7 +100,6 @@
 import static com.tngtech.archunit.testutil.ReflectionTestUtils.constructor;
 import static com.tngtech.archunit.testutil.ReflectionTestUtils.field;
 import static com.tngtech.archunit.testutil.ReflectionTestUtils.method;
-import static com.tngtech.archunit.testutil.TestUtils.namesOf;
 import static com.tngtech.java.junit.dataprovider.DataProviders.$;
 import static com.tngtech.java.junit.dataprovider.DataProviders.$$;
 import static com.tngtech.java.junit.dataprovider.DataProviders.testForEach;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportTestUtils.java
Patch:
@@ -79,7 +79,7 @@ private static Set<DomainBuilders.BuilderWithBuildParameter<JavaClass, JavaMetho
                     .withReturnType(
                             Optional.<JavaTypeCreationProcess<JavaCodeUnit>>absent(),
                             JavaClassDescriptor.From.name(method.getReturnType().getName()))
-                    .withParameters(typesFrom(method.getParameterTypes()))
+                    .withParameterTypes(typesFrom(method.getParameterTypes()))
                     .withName(method.getName())
                     .withDescriptor(Type.getMethodDescriptor(method))
                     .withModifiers(JavaModifier.getModifiersForMethod(method.getModifiers()))
@@ -95,7 +95,7 @@ private static Set<DomainBuilders.BuilderWithBuildParameter<JavaClass, JavaConst
                     .withReturnType(
                             Optional.<JavaTypeCreationProcess<JavaCodeUnit>>absent(),
                             JavaClassDescriptor.From.name(void.class.getName()))
-                    .withParameters(typesFrom(constructor.getParameterTypes()))
+                    .withParameterTypes(typesFrom(constructor.getParameterTypes()))
                     .withName(CONSTRUCTOR_NAME)
                     .withDescriptor(Type.getConstructorDescriptor(constructor))
                     .withModifiers(JavaModifier.getModifiersForMethod(constructor.getModifiers()))

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/CodeUnitsShouldTest.java
Patch:
@@ -31,6 +31,7 @@
 import static com.google.common.collect.Sets.union;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.equivalentTo;
 import static com.tngtech.archunit.core.domain.TestUtils.importClasses;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.codeUnits;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.constructors;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.methods;
@@ -280,7 +281,7 @@ private static DescribedPredicate<JavaCodeUnit> doNotHaveParametersOfType(final
         return new DescribedPredicate<JavaCodeUnit>("do not have parameters of type " + type.getSimpleName()) {
             @Override
             public boolean apply(JavaCodeUnit codeUnit) {
-                return !codeUnit.getRawParameterTypes().getNames().contains(type.getName());
+                return !namesOf(codeUnit.getRawParameterTypes()).contains(type.getName());
             }
         };
     }
@@ -296,4 +297,4 @@ private static Set<String> allConstructorsExcept(String... constructors) {
     private static Set<String> allCodeUnitsExcept(String... codeUnits) {
         return union(allMethodsExcept(codeUnits), allConstructorsExcept(codeUnits));
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/testutil/Conditions.java
Patch:
@@ -1,6 +1,7 @@
 package com.tngtech.archunit.testutil;
 
 import com.tngtech.archunit.core.domain.JavaCodeUnit;
+import com.tngtech.archunit.core.domain.properties.HasName;
 import org.assertj.core.api.Condition;
 
 import static com.tngtech.archunit.core.domain.JavaClass.namesOf;
@@ -26,7 +27,7 @@ public static Condition<JavaCodeUnit> codeUnitWithSignature(final String name, f
         return new Condition<JavaCodeUnit>() {
             @Override
             public boolean matches(JavaCodeUnit value) {
-                return name.equals(value.getName()) && namesOf(parameters).equals(value.getRawParameterTypes().getNames());
+                return name.equals(value.getName()) && namesOf(parameters).equals(HasName.Utils.namesOf(value.getRawParameterTypes()));
             }
         }.as("matches signature <" + name + ", " + namesOf(parameters) + ">");
     }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaConstructorAssertion.java
Patch:
@@ -8,6 +8,7 @@
 import static com.tngtech.archunit.core.domain.JavaConstructor.CONSTRUCTOR_NAME;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 import static com.tngtech.archunit.testutil.Assertions.assertThatType;
+import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
 import static com.tngtech.archunit.testutil.assertion.JavaMemberAssertion.getExpectedNameOf;
 
 public class JavaConstructorAssertion extends AbstractObjectAssert<JavaConstructorAssertion, JavaConstructor> {
@@ -19,7 +20,7 @@ public void isEquivalentTo(Constructor<?> constructor) {
         JavaMembersAssertion.assertEquivalent(actual, constructor);
         assertThat(actual.getName()).isEqualTo(CONSTRUCTOR_NAME);
         assertThat(actual.getFullName()).isEqualTo(getExpectedNameOf(constructor, CONSTRUCTOR_NAME));
-        assertThat(actual.getRawParameterTypes()).matches(constructor.getParameterTypes());
+        assertThatTypes(actual.getRawParameterTypes()).matchExactly(constructor.getParameterTypes());
         assertThatType(actual.getRawReturnType()).matches(void.class);
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaMethodAssertion.java
Patch:
@@ -7,6 +7,7 @@
 
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 import static com.tngtech.archunit.testutil.Assertions.assertThatType;
+import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
 import static com.tngtech.archunit.testutil.assertion.JavaMemberAssertion.getExpectedNameOf;
 import static com.tngtech.archunit.testutil.assertion.JavaMembersAssertion.assertEquivalent;
 
@@ -19,15 +20,15 @@ public JavaMethodAssertion isEquivalentTo(Method method) {
         assertEquivalent(actual, method);
         assertThat(actual.getFullName()).isEqualTo(getExpectedNameOf(method, method.getName()));
         assertThat(actual.getName()).isEqualTo(method.getName());
-        assertThat(actual.getRawParameterTypes()).matches(method.getParameterTypes());
+        assertThatTypes(actual.getRawParameterTypes()).matchExactly(method.getParameterTypes());
         assertThatType(actual.getRawReturnType()).matches(method.getReturnType());
         return this;
     }
 
     public JavaMethodAssertion isEquivalentTo(Class<?> owner, String methodName, Class<?>... parameterTypes) {
         assertThatType(actual.getOwner()).matches(owner);
         assertThat(actual.getName()).isEqualTo(methodName);
-        assertThat(actual.getRawParameterTypes()).matches(parameterTypes);
+        assertThatTypes(actual.getRawParameterTypes()).matchExactly(parameterTypes);
         return this;
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaTypeAssertion.java
Patch:
@@ -13,8 +13,8 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Strings.isNullOrEmpty;
 import static com.tngtech.archunit.core.domain.Formatters.ensureCanonicalArrayTypeName;
+import static com.tngtech.archunit.core.domain.properties.HasName.Utils.namesOf;
 import static com.tngtech.archunit.testutil.Assertions.assertThatTypeVariable;
-import static com.tngtech.archunit.testutil.TestUtils.namesOf;
 import static com.tngtech.archunit.testutil.assertion.JavaAnnotationAssertion.propertiesOf;
 import static com.tngtech.archunit.testutil.assertion.JavaAnnotationAssertion.runtimePropertiesOf;
 import static com.tngtech.archunit.testutil.assertion.JavaTypeVariableAssertion.getTypeVariableWithName;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -253,12 +253,13 @@ public MethodVisitor visitMethod(int access, String name, String desc, String si
 
         DomainBuilders.JavaCodeUnitBuilder<?, ?> codeUnitBuilder = addCodeUnitBuilder(name);
         JavaCodeUnitSignature codeUnitSignature = JavaCodeUnitSignatureImporter.parseAsmMethodSignature(signature);
+        JavaClassDescriptor rawReturnType = JavaClassDescriptorImporter.importAsmMethodReturnType(desc);
         codeUnitBuilder
                 .withName(name)
                 .withModifiers(JavaModifier.getModifiersForMethod(access))
                 .withTypeParameters(codeUnitSignature.getTypeParameterBuilders())
                 .withParameters(parameters)
-                .withReturnType(JavaClassDescriptorImporter.importAsmMethodReturnType(desc))
+                .withReturnType(codeUnitSignature.getReturnType(), rawReturnType)
                 .withDescriptor(desc)
                 .withThrowsClause(typesFrom(exceptions));
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaTypeAssertion.java
Patch:
@@ -56,7 +56,7 @@ public void matches(Class<?> clazz) {
     }
 
     public void matches(ExpectedConcreteType type) {
-        type.assertMatchWith(actual, new DescriptionContext(actual.getName()));
+        type.assertMatchWith(actual, new DescriptionContext(""));
     }
 
     private String describeAssertion(String partialAssertionDescription) {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -253,12 +253,13 @@ public MethodVisitor visitMethod(int access, String name, String desc, String si
 
         DomainBuilders.JavaCodeUnitBuilder<?, ?> codeUnitBuilder = addCodeUnitBuilder(name);
         JavaCodeUnitSignature codeUnitSignature = JavaCodeUnitSignatureImporter.parseAsmMethodSignature(signature);
+        JavaClassDescriptor rawReturnType = JavaClassDescriptorImporter.importAsmMethodReturnType(desc);
         codeUnitBuilder
                 .withName(name)
                 .withModifiers(JavaModifier.getModifiersForMethod(access))
                 .withTypeParameters(codeUnitSignature.getTypeParameterBuilders())
                 .withParameters(parameters)
-                .withReturnType(JavaClassDescriptorImporter.importAsmMethodReturnType(desc))
+                .withReturnType(codeUnitSignature.getReturnType(), rawReturnType)
                 .withDescriptor(desc)
                 .withThrowsClause(typesFrom(exceptions));
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaTypeAssertion.java
Patch:
@@ -56,7 +56,7 @@ public void matches(Class<?> clazz) {
     }
 
     public void matches(ExpectedConcreteType type) {
-        type.assertMatchWith(actual, new DescriptionContext(actual.getName()));
+        type.assertMatchWith(actual, new DescriptionContext(""));
     }
 
     private String describeAssertion(String partialAssertionDescription) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/DomainObjectCreationContext.java
Patch:
@@ -70,8 +70,8 @@ public static void completeClassHierarchy(JavaClass javaClass, ImportContext imp
         javaClass.completeClassHierarchyFrom(importContext);
     }
 
-    public static void completeEnclosingClass(JavaClass javaClass, ImportContext importContext) {
-        javaClass.completeEnclosingClassFrom(importContext);
+    public static void completeEnclosingDeclaration(JavaClass javaClass, ImportContext importContext) {
+        javaClass.completeEnclosingDeclarationFrom(importContext);
     }
 
     public static void completeTypeParameters(JavaClass javaClass, ImportContext importContext) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -48,6 +48,8 @@ public interface ImportContext {
 
     Optional<JavaClass> createEnclosingClass(JavaClass owner);
 
+    Optional<JavaCodeUnit> createEnclosingCodeUnit(JavaClass owner);
+
     Set<JavaFieldAccess> createFieldAccessesFor(JavaCodeUnit codeUnit);
 
     Set<JavaMethodCall> createMethodCallsFor(JavaCodeUnit codeUnit);

File: archunit/src/main/java/com/tngtech/archunit/core/importer/SignatureTypeArgumentProcessor.java
Patch:
@@ -185,7 +185,7 @@ public JavaType finish(OWNER owner, Iterable<JavaTypeVariable<?>> allTypeParamet
             return finisher.finish(createTypeVariable(owner, allTypeParametersInContext, classes), classes);
         }
 
-        private JavaType createTypeVariable(OWNER owner, Iterable<? extends JavaTypeVariable<?>> allTypeParametersInContext, ClassesByTypeName classes) {
+        private JavaType createTypeVariable(OWNER owner, Iterable<JavaTypeVariable<?>> allTypeParametersInContext, ClassesByTypeName classes) {
             for (JavaTypeVariable<?> existingTypeVariable : allTypeParametersInContext) {
                 if (existingTypeVariable.getName().equals(typeVariableName)) {
                     return existingTypeVariable;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileProcessor.java
Patch:
@@ -24,7 +24,7 @@
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.domain.JavaFieldAccess.AccessType;
-import com.tngtech.archunit.core.importer.DomainBuilders.TypeParametersBuilder;
+import com.tngtech.archunit.core.importer.DomainBuilders.JavaClassTypeParametersBuilder;
 import com.tngtech.archunit.core.importer.JavaClassProcessor.AccessHandler;
 import com.tngtech.archunit.core.importer.JavaClassProcessor.DeclarationHandler;
 import com.tngtech.archunit.core.importer.RawAccessRecord.CodeUnit;
@@ -86,7 +86,7 @@ public void onNewClass(String className, Optional<String> superclassName, Set<St
         }
 
         @Override
-        public void onDeclaredTypeParameters(TypeParametersBuilder typeParametersBuilder) {
+        public void onDeclaredTypeParameters(JavaClassTypeParametersBuilder typeParametersBuilder) {
             importRecord.addTypeParameters(ownerName, typeParametersBuilder);
         }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -47,11 +47,11 @@
 import com.tngtech.archunit.core.domain.JavaTypeVariable;
 import com.tngtech.archunit.core.importer.AccessRecord.FieldAccessRecord;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaAnnotationBuilder.ValueBuilder;
+import com.tngtech.archunit.core.importer.DomainBuilders.JavaClassTypeParametersBuilder;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaConstructorCallBuilder;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaFieldAccessBuilder;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaMethodCallBuilder;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaParameterizedTypeBuilder;
-import com.tngtech.archunit.core.importer.DomainBuilders.TypeParametersBuilder;
 import com.tngtech.archunit.core.importer.RawAccessRecord.CodeUnit;
 import com.tngtech.archunit.core.importer.resolvers.ClassResolver;
 
@@ -284,7 +284,7 @@ public Set<JavaClass> createInterfaces(JavaClass owner) {
 
     @Override
     public List<JavaTypeVariable<JavaClass>> createTypeParameters(JavaClass owner) {
-        TypeParametersBuilder typeParametersBuilder = importRecord.getTypeParameterBuildersFor(owner.getName());
+        JavaClassTypeParametersBuilder typeParametersBuilder = importRecord.getTypeParameterBuildersFor(owner.getName());
         return typeParametersBuilder.build(owner, classes.byTypeName());
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassSignatureImporter.java
Patch:
@@ -21,9 +21,9 @@
 
 import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.JavaClass;
+import com.tngtech.archunit.core.importer.DomainBuilders.JavaClassTypeParametersBuilder;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaParameterizedTypeBuilder;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaTypeParameterBuilder;
-import com.tngtech.archunit.core.importer.DomainBuilders.TypeParametersBuilder;
 import com.tngtech.archunit.core.importer.JavaClassProcessor.DeclarationHandler;
 import org.objectweb.asm.signature.SignatureReader;
 import org.objectweb.asm.signature.SignatureVisitor;
@@ -44,7 +44,7 @@ static void parseAsmTypeSignature(String signature, DeclarationHandler declarati
 
         SignatureProcessor signatureProcessor = new SignatureProcessor();
         new SignatureReader(signature).accept(signatureProcessor);
-        declarationHandler.onDeclaredTypeParameters(new TypeParametersBuilder(signatureProcessor.getTypeParameterBuilders()));
+        declarationHandler.onDeclaredTypeParameters(new JavaClassTypeParametersBuilder(signatureProcessor.getTypeParameterBuilders()));
 
         Optional<JavaParameterizedTypeBuilder<JavaClass>> genericSuperclass = signatureProcessor.getGenericSuperclass();
         if (genericSuperclass.isPresent()) {
@@ -55,7 +55,7 @@ static void parseAsmTypeSignature(String signature, DeclarationHandler declarati
     }
 
     private static class SignatureProcessor extends SignatureVisitor {
-        private final SignatureTypeParameterProcessor typeParameterProcessor = new SignatureTypeParameterProcessor();
+        private final SignatureTypeParameterProcessor<JavaClass> typeParameterProcessor = new SignatureTypeParameterProcessor<>();
         private final GenericSuperclassProcessor superclassProcessor = new GenericSuperclassProcessor();
         private final GenericInterfacesProcessor interfacesProcessor = new GenericInterfacesProcessor();
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/SignatureTypeArgumentProcessor.java
Patch:
@@ -185,7 +185,7 @@ public JavaType finish(OWNER owner, Iterable<JavaTypeVariable<?>> allTypeParamet
             return finisher.finish(createTypeVariable(owner, allTypeParametersInContext, classes), classes);
         }
 
-        private JavaType createTypeVariable(OWNER owner, Iterable<? extends JavaTypeVariable<?>> allTypeParametersInContext, ClassesByTypeName classes) {
+        private JavaType createTypeVariable(OWNER owner, Iterable<JavaTypeVariable<?>> allTypeParametersInContext, ClassesByTypeName classes) {
             for (JavaTypeVariable<?> existingTypeVariable : allTypeParametersInContext) {
                 if (existingTypeVariable.getName().equals(typeVariableName)) {
                     return existingTypeVariable;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/DomainObjectCreationContext.java
Patch:
@@ -70,8 +70,8 @@ public static void completeClassHierarchy(JavaClass javaClass, ImportContext imp
         javaClass.completeClassHierarchyFrom(importContext);
     }
 
-    public static void completeEnclosingClass(JavaClass javaClass, ImportContext importContext) {
-        javaClass.completeEnclosingClassFrom(importContext);
+    public static void completeEnclosingDeclaration(JavaClass javaClass, ImportContext importContext) {
+        javaClass.completeEnclosingDeclarationFrom(importContext);
     }
 
     public static void completeTypeParameters(JavaClass javaClass, ImportContext importContext) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -48,6 +48,8 @@ public interface ImportContext {
 
     Optional<JavaClass> createEnclosingClass(JavaClass owner);
 
+    Optional<JavaCodeUnit> createEnclosingCodeUnit(JavaClass owner);
+
     Set<JavaFieldAccess> createFieldAccessesFor(JavaCodeUnit codeUnit);
 
     Set<JavaMethodCall> createMethodCallsFor(JavaCodeUnit codeUnit);

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterGenericClassesTest.java
Patch:
@@ -567,7 +567,7 @@ public void imports_complex_type_with_multiple_nested_parameters_with_concrete_a
         class ClassWithComplexTypeParametersWithConcreteArrayBounds<
                 A extends List<Serializable[]>,
                 B extends List<? extends Serializable[][]>,
-                C extends Map<? super String[], Map<Map<? super String[][][], ?>, Serializable[][]>>
+                C extends Map<? super String[], Map<Map<? super String[][][], ?>, int[][]>>
                 > {
         }
 
@@ -591,7 +591,7 @@ class ClassWithComplexTypeParametersWithConcreteArrayBounds<
                                         parameterizedType(Map.class).withTypeArguments(
                                                 wildcardType().withLowerBound(String[][][].class),
                                                 wildcardType()),
-                                        concreteClass(Serializable[][].class)))
+                                        concreteClass(int[][].class)))
                 );
     }
 

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchRuleExecution.java
Patch:
@@ -47,7 +47,7 @@ Result evaluateOn(JavaClasses classes) {
 
     @Override
     Description describeSelf() {
-        return Description.createTestDescription(testClass, ruleField.getName());
+        return Description.createTestDescription(testClass, ruleField.getName(), ruleField.getAnnotations());
     }
 
     @Override

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchTestMethodExecution.java
Patch:
@@ -52,7 +52,7 @@ private void executeTestMethod(JavaClasses classes) {
 
     @Override
     Description describeSelf() {
-        return Description.createTestDescription(testClass, testMethod.getName());
+        return Description.createTestDescription(testClass, testMethod.getName(), testMethod.getAnnotations());
     }
 
     @Override

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchRuleExecution.java
Patch:
@@ -47,7 +47,7 @@ Result evaluateOn(JavaClasses classes) {
 
     @Override
     Description describeSelf() {
-        return Description.createTestDescription(testClass, ruleField.getName());
+        return Description.createTestDescription(testClass, ruleField.getName(), ruleField.getAnnotations());
     }
 
     @Override

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchTestMethodExecution.java
Patch:
@@ -52,7 +52,7 @@ private void executeTestMethod(JavaClasses classes) {
 
     @Override
     Description describeSelf() {
-        return Description.createTestDescription(testClass, testMethod.getName());
+        return Description.createTestDescription(testClass, testMethod.getName(), testMethod.getAnnotations());
     }
 
     @Override

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/service/SpecialServiceHelper.java
Patch:
@@ -2,10 +2,13 @@
 
 import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 import com.tngtech.archunit.example.layers.controller.SomeUtility;
 import com.tngtech.archunit.example.layers.controller.one.SomeEnum;
 
+@SuppressWarnings("unused")
 public abstract class SpecialServiceHelper extends ServiceHelper<SomeUtility, HashMap<?, Set<? super SomeEnum>>> implements List<Set<? super SomeUtility>> {
+    Map<?, Map<SomeEnum, ? extends SomeUtility>> fieldWithGenericTypeViolatingLayerRule;
 }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaField.java
Patch:
@@ -31,12 +31,12 @@
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
 public class JavaField extends JavaMember implements HasType {
-    private final JavaClass type;
+    private final JavaType type;
     private final Supplier<Field> fieldSupplier;
 
     JavaField(DomainBuilders.JavaFieldBuilder builder) {
         super(builder);
-        type = builder.getType();
+        type = builder.getType(this);
         fieldSupplier = Suppliers.memoize(new ReflectFieldSupplier());
     }
 
@@ -62,7 +62,7 @@ public JavaType getType() {
     @Override
     @PublicAPI(usage = ACCESS)
     public JavaClass getRawType() {
-        return type;
+        return type.toErasure();
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaGenericArrayType.java
Patch:
@@ -25,8 +25,8 @@
  * E.g. for {@code MyClass<A, T extends List<A[]>>} the upper bound {@code List<A[]>}
  * would have one {@link JavaGenericArrayType} {@code A[]} as its type parameter.<br>
  * Like its concrete counterpart a {@link JavaGenericArrayType} can be queried for its
- * {@link #getComponentType() component type}, which will by definition be a
- * {@link JavaTypeVariable} or a {@link JavaGenericArrayType} corresponding to a lower dimensional array.
+ * {@link #getComponentType() component type}, which can be a {@link JavaParameterizedType},
+ * a {@link JavaTypeVariable} or a {@link JavaGenericArrayType} corresponding to a lower dimensional array.
  */
 @PublicAPI(usage = ACCESS)
 public final class JavaGenericArrayType implements JavaType {

File: archunit/src/test/java/com/tngtech/archunit/ArchUnitTestStructureTest.java
Patch:
@@ -21,15 +21,15 @@ public void only_TestUtils_accesses_ImportTestUtils() {
                 .should(onlyBeAccessedByClassesThat(
                         have(nameMatching(TestUtils.class.getName() + ".*"))
                                 .or(have(nameMatching(ImportTestUtils.class.getName() + ".*")))))
-                .because("we wan't one central TestUtils for all tests")
+                .because("we want one central TestUtils for all tests")
                 .check(archUnitClasses);
     }
 
     @Test
     public void ImportTestUtils_doesnt_access_TestUtils() {
         noClasses().that().haveNameMatching(ImportTestUtils.class.getName() + ".*")
                 .should().accessClassesThat().haveNameMatching(TestUtils.class.getName() + ".*")
-                .because("we wan't one central TestUtils for all tests")
+                .because("we want one central TestUtils for all tests")
                 .check(archUnitClasses);
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportTestUtils.java
Patch:
@@ -41,6 +41,7 @@
 import com.tngtech.archunit.core.domain.JavaType;
 import com.tngtech.archunit.core.domain.JavaTypeVariable;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaMethodCallBuilder;
+import com.tngtech.archunit.core.importer.DomainBuilders.JavaTypeCreationProcess;
 import org.objectweb.asm.Type;
 
 import static com.tngtech.archunit.core.domain.JavaConstructor.CONSTRUCTOR_NAME;
@@ -66,7 +67,7 @@ private static Set<DomainBuilders.BuilderWithBuildParameter<JavaClass, JavaField
                     .withName(field.getName())
                     .withDescriptor(Type.getDescriptor(field.getType()))
                     .withModifiers(JavaModifier.getModifiersForField(field.getModifiers()))
-                    .withType(JavaClassDescriptor.From.name(field.getType().getName())));
+                    .withType(Optional.<JavaTypeCreationProcess<JavaField>>absent(), JavaClassDescriptor.From.name(field.getType().getName())));
         }
         return fieldBuilders;
     }

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/service/SpecialServiceHelper.java
Patch:
@@ -2,10 +2,13 @@
 
 import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 import com.tngtech.archunit.example.layers.controller.SomeUtility;
 import com.tngtech.archunit.example.layers.controller.one.SomeEnum;
 
+@SuppressWarnings("unused")
 public abstract class SpecialServiceHelper extends ServiceHelper<SomeUtility, HashMap<?, Set<? super SomeEnum>>> implements List<Set<? super SomeUtility>> {
+    Map<?, Map<SomeEnum, ? extends SomeUtility>> fieldWithGenericTypeViolatingLayerRule;
 }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaField.java
Patch:
@@ -31,12 +31,12 @@
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
 public class JavaField extends JavaMember implements HasType {
-    private final JavaClass type;
+    private final JavaType type;
     private final Supplier<Field> fieldSupplier;
 
     JavaField(DomainBuilders.JavaFieldBuilder builder) {
         super(builder);
-        type = builder.getType();
+        type = builder.getType(this);
         fieldSupplier = Suppliers.memoize(new ReflectFieldSupplier());
     }
 
@@ -62,7 +62,7 @@ public JavaType getType() {
     @Override
     @PublicAPI(usage = ACCESS)
     public JavaClass getRawType() {
-        return type;
+        return type.toErasure();
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassSignatureImporter.java
Patch:
@@ -24,7 +24,6 @@
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClassDescriptor;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaParameterizedTypeBuilder;
-import com.tngtech.archunit.core.importer.DomainBuilders.JavaTypeCreationProcess.JavaTypeFinisher;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaTypeParameterBuilder;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaWildcardTypeBuilder;
 import com.tngtech.archunit.core.importer.DomainBuilders.TypeParametersBuilder;
@@ -140,7 +139,7 @@ public void visitTypeArgument() {
             @Override
             public void visitTypeVariable(String name) {
                 log.trace("Encountered upper bound for {}: Type variable {}", currentType.getName(), name);
-                currentType.addBound(new ReferenceCreationProcess<JavaClass>(name, JavaTypeFinisher.IDENTITY));
+                currentType.addBound(new ReferenceCreationProcess<JavaClass>(name));
             }
 
             @Override

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportTestUtils.java
Patch:
@@ -41,6 +41,7 @@
 import com.tngtech.archunit.core.domain.JavaType;
 import com.tngtech.archunit.core.domain.JavaTypeVariable;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaMethodCallBuilder;
+import com.tngtech.archunit.core.importer.DomainBuilders.JavaTypeCreationProcess;
 import org.objectweb.asm.Type;
 
 import static com.tngtech.archunit.core.domain.JavaConstructor.CONSTRUCTOR_NAME;
@@ -66,7 +67,7 @@ private static Set<DomainBuilders.BuilderWithBuildParameter<JavaClass, JavaField
                     .withName(field.getName())
                     .withDescriptor(Type.getDescriptor(field.getType()))
                     .withModifiers(JavaModifier.getModifiersForField(field.getModifiers()))
-                    .withType(JavaClassDescriptor.From.name(field.getType().getName())));
+                    .withType(Optional.<JavaTypeCreationProcess<JavaField>>absent(), JavaClassDescriptor.From.name(field.getType().getName())));
         }
         return fieldBuilders;
     }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/ExpectedConcreteType.java
Patch:
@@ -245,7 +245,7 @@ public ExpectedConcreteGenericArray withComponentType(ExpectedConcreteType compo
         public void assertMatchWith(JavaType actual, DescriptionContext context) {
             assertThat(actual).as(context.step("JavaType").toString()).isInstanceOf(JavaGenericArrayType.class);
             JavaGenericArrayType actualArrayType = (JavaGenericArrayType) actual;
-            assertThat(actualArrayType.getName()).as(context.step("type variable name").toString()).isEqualTo(name);
+            assertThat(actualArrayType.getName()).as(context.step("array type name").toString()).isEqualTo(name);
 
             if (componentType != null) {
                 DescriptionContext newContext = context.describe(actual.getName()).step("component type").metaInfo();

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaGenericArrayType.java
Patch:
@@ -25,8 +25,8 @@
  * E.g. for {@code MyClass<A, T extends List<A[]>>} the upper bound {@code List<A[]>}
  * would have one {@link JavaGenericArrayType} {@code A[]} as its type parameter.<br>
  * Like its concrete counterpart a {@link JavaGenericArrayType} can be queried for its
- * {@link #getComponentType() component type}, which will by definition be a
- * {@link JavaTypeVariable} or a {@link JavaGenericArrayType} corresponding to a lower dimensional array.
+ * {@link #getComponentType() component type}, which can be a {@link JavaParameterizedType},
+ * a {@link JavaTypeVariable} or a {@link JavaGenericArrayType} corresponding to a lower dimensional array.
  */
 @PublicAPI(usage = ACCESS)
 public final class JavaGenericArrayType implements JavaType {

File: archunit/src/test/java/com/tngtech/archunit/ArchUnitTestStructureTest.java
Patch:
@@ -21,15 +21,15 @@ public void only_TestUtils_accesses_ImportTestUtils() {
                 .should(onlyBeAccessedByClassesThat(
                         have(nameMatching(TestUtils.class.getName() + ".*"))
                                 .or(have(nameMatching(ImportTestUtils.class.getName() + ".*")))))
-                .because("we wan't one central TestUtils for all tests")
+                .because("we want one central TestUtils for all tests")
                 .check(archUnitClasses);
     }
 
     @Test
     public void ImportTestUtils_doesnt_access_TestUtils() {
         noClasses().that().haveNameMatching(ImportTestUtils.class.getName() + ".*")
                 .should().accessClassesThat().haveNameMatching(TestUtils.class.getName() + ".*")
-                .because("we wan't one central TestUtils for all tests")
+                .because("we want one central TestUtils for all tests")
                 .check(archUnitClasses);
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/ExpectedConcreteType.java
Patch:
@@ -135,7 +135,7 @@ public void assertMatchWith(JavaType actual, DescriptionContext context) {
 
             assertThat(actual).as(context.toString()).isInstanceOf(JavaWildcardType.class);
             JavaWildcardType wildcardType = (JavaWildcardType) actual;
-            assertThat(wildcardType.getName()).as(context.toString()).isEqualTo("?");
+            assertThat(wildcardType.getName()).as(context.toString()).startsWith("?");
 
             assertUpperBoundsMatch(wildcardType, context);
             assertLowerBoundMatch(wildcardType, context);

File: archunit/src/main/java/com/tngtech/archunit/lang/FailureDisplayFormat.java
Patch:
@@ -24,7 +24,7 @@
  * Allows to customize violation messages and rule text of {@link ArchRule ArchRules}.
  */
 @PublicAPI(usage = INHERITANCE)
-public interface MessageFormat {
+public interface FailureDisplayFormat {
 
     /**
      * Formats the failure of an {@link ArchRule}, i.e. constructs the text to display

File: archunit/src/main/java/com/tngtech/archunit/lang/FailureDisplayFormatInitializationFailedException.java
Patch:
@@ -15,8 +15,8 @@
  */
 package com.tngtech.archunit.lang;
 
-class MessageFormatInitializationFailedException extends RuntimeException {
-    MessageFormatInitializationFailedException(String message, Throwable cause) {
+class FailureDisplayFormatInitializationFailedException extends RuntimeException {
+    FailureDisplayFormatInitializationFailedException(String message, Throwable cause) {
         super(message, cause);
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/FailureReport.java
Patch:
@@ -47,7 +47,7 @@ public List<String> getDetails() {
 
     @Override
     public String toString() {
-        return MessageFormatFactory.create().formatFailure(rule, failureMessages, priority);
+        return FailureDisplayFormatFactory.create().formatFailure(rule, failureMessages, priority);
     }
 
     FailureReport filter(Predicate<String> predicate) {

File: archunit/src/main/java/com/tngtech/archunit/lang/MessageFormatFactory.java
Patch:
@@ -17,9 +17,9 @@
 
 class MessageFormatFactory {
 
-    private static final ConfiguredMessageFormat instance = new ConfiguredMessageFormat();
+    private static final MessageFormat instance = new ConfiguredMessageFormat();
 
-    static ConfiguredMessageFormat create() {
+    static MessageFormat create() {
         return instance;
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/FailureReport.java
Patch:
@@ -47,7 +47,7 @@ public List<String> getDetails() {
 
     @Override
     public String toString() {
-        return ConfiguredMessageFormat.get().formatFailure(rule, failureMessages, priority);
+        return MessageFormatFactory.create().formatFailure(rule, failureMessages, priority);
     }
 
     FailureReport filter(Predicate<String> predicate) {

File: archunit/src/main/java/com/tngtech/archunit/lang/ArchRule.java
Patch:
@@ -219,7 +219,7 @@ public EvaluationResult evaluate(JavaClasses classes) {
             public String getDescription() {
                 return overriddenDescription.isPresent() ?
                         overriddenDescription.get() :
-                        ConfiguredMessageFormat.get().formatRuleText(classesTransformer, condition);
+                        classesTransformer.getDescription() + " should " + condition.getDescription();
             }
 
             @Override

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -593,7 +593,7 @@ public boolean isMetaAnnotatedWith(DescribedPredicate<? super JavaAnnotation<?>>
     /**
      * @param type A given annotation type to match {@link JavaAnnotation JavaAnnotations} against
      * @return An {@link Annotation} of the given annotation type
-     * @throws IllegalArgumentException if the class is note annotated with the given type
+     * @throws IllegalArgumentException if the class is not annotated with the given type
      * @see #isAnnotatedWith(Class)
      * @see #tryGetAnnotationOfType(Class)
      */

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -593,7 +593,7 @@ public boolean isMetaAnnotatedWith(DescribedPredicate<? super JavaAnnotation<?>>
     /**
      * @param type A given annotation type to match {@link JavaAnnotation JavaAnnotations} against
      * @return An {@link Annotation} of the given annotation type
-     * @throws IllegalArgumentException if the class is note annotated with the given type
+     * @throws IllegalArgumentException if the class is not annotated with the given type
      * @see #isAnnotatedWith(Class)
      * @see #tryGetAnnotationOfType(Class)
      */

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassSignatureImporter.java
Patch:
@@ -353,11 +353,11 @@ static TypeArgumentProcessor create(
                 ReferenceCreationProcess.JavaTypeVariableFinisher typeVariableFinisher) {
 
             switch (identifier) {
-                case '=':
+                case INSTANCEOF:
                     return new TypeArgumentProcessor(PARAMETERIZED_TYPE, parameterizedType, typeMapping, typeVariableFinisher);
-                case '+':
+                case EXTENDS:
                     return new TypeArgumentProcessor(WILDCARD_WITH_UPPER_BOUND, parameterizedType, typeMapping, typeVariableFinisher);
-                case '-':
+                case SUPER:
                     return new TypeArgumentProcessor(WILDCARD_WITH_LOWER_BOUND, parameterizedType, typeMapping, typeVariableFinisher);
                 default:
                     throw new IllegalStateException(String.format("Cannot handle asm type argument identifier '%s'", identifier));

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/service/SpecialServiceHelper.java
Patch:
@@ -1,10 +1,11 @@
 package com.tngtech.archunit.example.layers.service;
 
 import java.util.HashMap;
+import java.util.List;
 import java.util.Set;
 
 import com.tngtech.archunit.example.layers.controller.SomeUtility;
 import com.tngtech.archunit.example.layers.controller.one.SomeEnum;
 
-public class SpecialServiceHelper extends ServiceHelper<SomeUtility, HashMap<?, Set<? super SomeEnum>>> {
+public abstract class SpecialServiceHelper extends ServiceHelper<SomeUtility, HashMap<?, Set<? super SomeEnum>>> implements List<Set<? super SomeUtility>> {
 }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -28,6 +28,8 @@ public interface ImportContext {
 
     Optional<JavaType> createGenericSuperclass(JavaClass owner);
 
+    Optional<Set<JavaType>> createGenericInterfaces(JavaClass owner);
+
     Set<JavaClass> createInterfaces(JavaClass owner);
 
     List<JavaTypeVariable<JavaClass>> createTypeParameters(JavaClass owner);

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassMembers.java
Patch:
@@ -69,7 +69,7 @@ public Set<JavaMember> get() {
             @Override
             public Set<JavaField> get() {
                 ImmutableSet.Builder<JavaField> result = ImmutableSet.builder();
-                for (JavaClass javaClass : concat(owner.getClassHierarchy(), owner.getAllInterfaces())) {
+                for (JavaClass javaClass : concat(owner.getClassHierarchy(), owner.getAllRawInterfaces())) {
                     result.addAll(javaClass.getFields());
                 }
                 return result.build();
@@ -79,7 +79,7 @@ public Set<JavaField> get() {
             @Override
             public Set<JavaMethod> get() {
                 ImmutableSet.Builder<JavaMethod> result = ImmutableSet.builder();
-                for (JavaClass javaClass : concat(owner.getClassHierarchy(), owner.getAllInterfaces())) {
+                for (JavaClass javaClass : concat(owner.getClassHierarchy(), owner.getAllRawInterfaces())) {
                     result.addAll(javaClass.getMethods());
                 }
                 return result.build();

File: archunit/src/main/java/com/tngtech/archunit/core/importer/AccessRecord.java
Patch:
@@ -461,7 +461,7 @@ private static class Node {
 
                 private Node(JavaClass child) {
                     this.child = child;
-                    for (JavaClass i : child.getInterfaces()) {
+                    for (JavaClass i : child.getRawInterfaces()) {
                         parents.add(new Node(i));
                     }
                 }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -454,6 +454,8 @@ interface DeclarationHandler {
 
         void onGenericSuperclass(DomainBuilders.JavaParameterizedTypeBuilder<JavaClass> genericSuperclassBuilder);
 
+        void onGenericInterfaces(Set<DomainBuilders.JavaParameterizedTypeBuilder<JavaClass>> genericInterfaceBuilders);
+
         void onDeclaredField(DomainBuilders.JavaFieldBuilder fieldBuilder);
 
         void onDeclaredConstructor(DomainBuilders.JavaConstructorBuilder constructorBuilder);

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaClassAssertion.java
Patch:
@@ -53,17 +53,17 @@ public JavaClassAssertion hasRawSuperclassMatching(Class<?> expectedSuperclass)
     }
 
     public JavaClassAssertion hasNoInterfaces() {
-        assertThat(actual.getInterfaces()).as(describeAssertion("interfaces")).isEmpty();
+        assertThat(actual.getRawInterfaces()).as(describeAssertion("interfaces")).isEmpty();
         return this;
     }
 
     public JavaClassAssertion hasInterfacesMatchingInAnyOrder(Class<?>... expectedInterfaces) {
-        assertThatTypes(actual.getInterfaces()).as(describeAssertion("interfaces")).matchInAnyOrder(expectedInterfaces);
+        assertThatTypes(actual.getRawInterfaces()).as(describeAssertion("interfaces")).matchInAnyOrder(expectedInterfaces);
         return this;
     }
 
     public JavaClassAssertion hasAllInterfacesMatchingInAnyOrder(Class<?>... expectedAllInterfaces) {
-        assertThatTypes(actual.getAllInterfaces()).as(describeAssertion("all interfaces")).matchInAnyOrder(expectedAllInterfaces);
+        assertThatTypes(actual.getAllRawInterfaces()).as(describeAssertion("all interfaces")).matchInAnyOrder(expectedAllInterfaces);
         return this;
     }
 

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/service/SpecialServiceHelper.java
Patch:
@@ -1,10 +1,11 @@
 package com.tngtech.archunit.example.layers.service;
 
 import java.util.HashMap;
+import java.util.List;
 import java.util.Set;
 
 import com.tngtech.archunit.example.layers.controller.SomeUtility;
 import com.tngtech.archunit.example.layers.controller.one.SomeEnum;
 
-public class SpecialServiceHelper extends ServiceHelper<SomeUtility, HashMap<?, Set<? super SomeEnum>>> {
+public abstract class SpecialServiceHelper extends ServiceHelper<SomeUtility, HashMap<?, Set<? super SomeEnum>>> implements List<Set<? super SomeUtility>> {
 }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -28,6 +28,8 @@ public interface ImportContext {
 
     Optional<JavaType> createGenericSuperclass(JavaClass owner);
 
+    Optional<Set<JavaType>> createGenericInterfaces(JavaClass owner);
+
     Set<JavaClass> createInterfaces(JavaClass owner);
 
     List<JavaTypeVariable<JavaClass>> createTypeParameters(JavaClass owner);

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -454,6 +454,8 @@ interface DeclarationHandler {
 
         void onGenericSuperclass(DomainBuilders.JavaParameterizedTypeBuilder<JavaClass> genericSuperclassBuilder);
 
+        void onGenericInterfaces(Set<DomainBuilders.JavaParameterizedTypeBuilder<JavaClass>> genericInterfaceBuilders);
+
         void onDeclaredField(DomainBuilders.JavaFieldBuilder fieldBuilder);
 
         void onDeclaredConstructor(DomainBuilders.JavaConstructorBuilder constructorBuilder);

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassDependencies.java
Patch:
@@ -73,7 +73,7 @@ private Set<Dependency> dependenciesFromAccesses(Set<JavaAccess<?>> accesses) {
 
     private Set<Dependency> inheritanceDependenciesFromSelf() {
         ImmutableSet.Builder<Dependency> result = ImmutableSet.builder();
-        for (JavaClass supertype : FluentIterable.from(javaClass.getInterfaces()).append(javaClass.getRawSuperclass().asSet())) {
+        for (JavaClass supertype : FluentIterable.from(javaClass.getRawInterfaces()).append(javaClass.getRawSuperclass().asSet())) {
             result.add(Dependency.fromInheritance(javaClass, supertype));
         }
         result.addAll(genericSuperclassTypeArgumentDependencies());

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassMembers.java
Patch:
@@ -69,7 +69,7 @@ public Set<JavaMember> get() {
             @Override
             public Set<JavaField> get() {
                 ImmutableSet.Builder<JavaField> result = ImmutableSet.builder();
-                for (JavaClass javaClass : concat(owner.getClassHierarchy(), owner.getAllInterfaces())) {
+                for (JavaClass javaClass : concat(owner.getClassHierarchy(), owner.getAllRawInterfaces())) {
                     result.addAll(javaClass.getFields());
                 }
                 return result.build();
@@ -79,7 +79,7 @@ public Set<JavaField> get() {
             @Override
             public Set<JavaMethod> get() {
                 ImmutableSet.Builder<JavaMethod> result = ImmutableSet.builder();
-                for (JavaClass javaClass : concat(owner.getClassHierarchy(), owner.getAllInterfaces())) {
+                for (JavaClass javaClass : concat(owner.getClassHierarchy(), owner.getAllRawInterfaces())) {
                     result.addAll(javaClass.getMethods());
                 }
                 return result.build();

File: archunit/src/main/java/com/tngtech/archunit/core/importer/AccessRecord.java
Patch:
@@ -461,7 +461,7 @@ private static class Node {
 
                 private Node(JavaClass child) {
                     this.child = child;
-                    for (JavaClass i : child.getInterfaces()) {
+                    for (JavaClass i : child.getRawInterfaces()) {
                         parents.add(new Node(i));
                     }
                 }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaClassAssertion.java
Patch:
@@ -53,17 +53,17 @@ public JavaClassAssertion hasRawSuperclassMatching(Class<?> expectedSuperclass)
     }
 
     public JavaClassAssertion hasNoInterfaces() {
-        assertThat(actual.getInterfaces()).as(describeAssertion("interfaces")).isEmpty();
+        assertThat(actual.getRawInterfaces()).as(describeAssertion("interfaces")).isEmpty();
         return this;
     }
 
     public JavaClassAssertion hasInterfacesMatchingInAnyOrder(Class<?>... expectedInterfaces) {
-        assertThatTypes(actual.getInterfaces()).as(describeAssertion("interfaces")).matchInAnyOrder(expectedInterfaces);
+        assertThatTypes(actual.getRawInterfaces()).as(describeAssertion("interfaces")).matchInAnyOrder(expectedInterfaces);
         return this;
     }
 
     public JavaClassAssertion hasAllInterfacesMatchingInAnyOrder(Class<?>... expectedAllInterfaces) {
-        assertThatTypes(actual.getAllInterfaces()).as(describeAssertion("all interfaces")).matchInAnyOrder(expectedAllInterfaces);
+        assertThatTypes(actual.getAllRawInterfaces()).as(describeAssertion("all interfaces")).matchInAnyOrder(expectedAllInterfaces);
         return this;
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileProcessor.java
Patch:
@@ -36,12 +36,12 @@
 import org.slf4j.LoggerFactory;
 
 import static com.tngtech.archunit.core.domain.JavaConstructor.CONSTRUCTOR_NAME;
-import static org.objectweb.asm.Opcodes.ASM7;
+import static org.objectweb.asm.Opcodes.ASM8;
 
 class ClassFileProcessor {
     private static final Logger LOG = LoggerFactory.getLogger(ClassFileProcessor.class);
 
-    static final int ASM_API_VERSION = ASM7;
+    static final int ASM_API_VERSION = ASM8;
 
     private final boolean md5InClassSourcesEnabled = ArchConfiguration.get().md5InClassSourcesEnabled();
     private final ClassResolver.Factory classResolverFactory = new ClassResolver.Factory();

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterAnnotationsTest.java
Patch:
@@ -66,7 +66,8 @@ public void imports_simple_annotation() {
                 .hasInterfacesMatchingInAnyOrder(Annotation.class)
                 .isInterface(true)
                 .isEnum(false)
-                .isAnnotation(true);
+                .isAnnotation(true)
+                .isRecord(false);
         assertThat(getAnnotationDefaultValue(javaClass, "someStringMethod", String.class)).isEqualTo("DEFAULT");
         assertThatType(getAnnotationDefaultValue(javaClass, "someTypeMethod", JavaClass.class)).matches(List.class);
         assertThat(getAnnotationDefaultValue(javaClass, "someEnumMethod", JavaEnumConstant.class)).isEquivalentTo(EnumToImport.SECOND);

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/ClassesShouldTest.java
Patch:
@@ -72,6 +72,7 @@
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.are;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
+import static com.tngtech.archunit.testutil.Assertions.assertThatRule;
 import static com.tngtech.java.junit.dataprovider.DataProviders.$;
 import static com.tngtech.java.junit.dataprovider.DataProviders.$$;
 import static com.tngtech.java.junit.dataprovider.DataProviders.testForEach;
@@ -1718,7 +1719,7 @@ public static Object[][] onlyAccessRules_rules() {
     public void onlyCall_should_report_success_if_targets_are_non_resolvable(ArchRule rule, Class<?> classCallingUnresolvableTarget) {
         ArchConfiguration.get().setResolveMissingDependenciesFromClassPath(false);
 
-        assertThat(rule).checking(importClasses(classCallingUnresolvableTarget)).hasNoViolation();
+        assertThatRule(rule).checking(importClasses(classCallingUnresolvableTarget)).hasNoViolation();
     }
 
     static String locationPattern(Class<?> clazz) {

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -84,7 +84,7 @@ public static ConditionEventsAssertion assertThat(ConditionEvents events) {
         return new ConditionEventsAssertion(events);
     }
 
-    public static ArchRuleAssertion assertThat(ArchRule rule) {
+    public static ArchRuleAssertion assertThatRule(ArchRule rule) {
         return new ArchRuleAssertion(rule);
     }
 

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/ClassesShouldTest.java
Patch:
@@ -72,6 +72,7 @@
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.are;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
+import static com.tngtech.archunit.testutil.Assertions.assertThatRule;
 import static com.tngtech.java.junit.dataprovider.DataProviders.$;
 import static com.tngtech.java.junit.dataprovider.DataProviders.$$;
 import static com.tngtech.java.junit.dataprovider.DataProviders.testForEach;
@@ -1718,7 +1719,7 @@ public static Object[][] onlyAccessRules_rules() {
     public void onlyCall_should_report_success_if_targets_are_non_resolvable(ArchRule rule, Class<?> classCallingUnresolvableTarget) {
         ArchConfiguration.get().setResolveMissingDependenciesFromClassPath(false);
 
-        assertThat(rule).checking(importClasses(classCallingUnresolvableTarget)).hasNoViolation();
+        assertThatRule(rule).checking(importClasses(classCallingUnresolvableTarget)).hasNoViolation();
     }
 
     static String locationPattern(Class<?> clazz) {

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -84,7 +84,7 @@ public static ConditionEventsAssertion assertThat(ConditionEvents events) {
         return new ConditionEventsAssertion(events);
     }
 
-    public static ArchRuleAssertion assertThat(ArchRule rule) {
+    public static ArchRuleAssertion assertThatRule(ArchRule rule) {
         return new ArchRuleAssertion(rule);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaCodeUnit.java
Patch:
@@ -163,7 +163,7 @@ public Optional<? extends JavaAnnotation<? extends JavaCodeUnit>> tryGetAnnotati
         return (Optional<? extends JavaAnnotation<? extends JavaCodeUnit>>) super.tryGetAnnotationOfType(typeName);
     }
 
-    void completeFrom(ImportContext context) {
+    void completeAccessesFrom(ImportContext context) {
         fieldAccesses = context.createFieldAccessesFor(this);
         methodCalls = context.createMethodCallsFor(this);
         constructorCalls = context.createConstructorCallsFor(this);

File: archunit/src/test/java/com/tngtech/archunit/core/domain/TestUtils.java
Patch:
@@ -182,7 +182,7 @@ private JavaMethodCall to(MethodCallTarget methodCallTarget) {
                 calls.add(newMethodCall(method, target, lineNumber));
             }
             when(context.createMethodCallsFor(method)).thenReturn(ImmutableSet.copyOf(calls));
-            method.completeFrom(context);
+            method.completeAccessesFrom(context);
             return getCallToTarget(methodCallTarget);
         }
 
@@ -210,7 +210,7 @@ public void to(JavaField target, AccessType accessType) {
                     .thenReturn(ImmutableSet.of(
                             newFieldAccess(method, target, lineNumber, accessType)
                     ));
-            method.completeFrom(context);
+            method.completeAccessesFrom(context);
         }
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterSlowTest.java
Patch:
@@ -22,7 +22,7 @@
 import org.junit.rules.TemporaryFolder;
 
 import static com.tngtech.archunit.core.domain.SourceTest.urlOf;
-import static com.tngtech.archunit.core.importer.ClassFileImporterTest.jarFileOf;
+import static com.tngtech.archunit.core.importer.ClassFileImporterTestUtils.jarFileOf;
 import static com.tngtech.archunit.core.importer.ImportOption.Predefined.DO_NOT_INCLUDE_TESTS;
 import static com.tngtech.archunit.core.importer.UrlSourceTest.JAVA_CLASS_PATH_PROP;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterSlowTest.java
Patch:
@@ -22,7 +22,7 @@
 import org.junit.rules.TemporaryFolder;
 
 import static com.tngtech.archunit.core.domain.SourceTest.urlOf;
-import static com.tngtech.archunit.core.importer.ClassFileImporterTest.jarFileOf;
+import static com.tngtech.archunit.core.importer.ClassFileImporterTestUtils.jarFileOf;
 import static com.tngtech.archunit.core.importer.ImportOption.Predefined.DO_NOT_INCLUDE_TESTS;
 import static com.tngtech.archunit.core.importer.UrlSourceTest.JAVA_CLASS_PATH_PROP;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/ExamplesIntegrationTest.java
Patch:
@@ -972,6 +972,9 @@ Stream<DynamicTest> OnionArchitectureTest() {
                                 .by(field(ShoppingService.class, "productRepository").ofType(ProductRepository.class))
                                 .by(field(ShoppingService.class, "shoppingCartRepository").ofType(ShoppingCartRepository.class))
 
+                                .by(method(AdministrationCLI.class, "handle")
+                                        .referencingClassObject(ProductRepository.class)
+                                        .inLine(16))
                                 .by(callFromMethod(AdministrationCLI.class, "handle", String[].class, AdministrationPort.class)
                                         .toMethod(ProductRepository.class, "getTotalCount")
                                         .inLine(17).asDependency())

File: archunit/src/main/java/com/tngtech/archunit/core/importer/AccessRecord.java
Patch:
@@ -233,7 +233,7 @@ public JavaCodeUnit getCaller() {
             @Override
             public FieldAccessTarget getTarget() {
                 Supplier<Optional<JavaField>> fieldSupplier = new FieldTargetSupplier(targetOwner.getAllFields(), record.target);
-                JavaClass fieldType = classes.getOrResolve(JavaClassDescriptorImporter.importAsmType(record.target.desc).getFullyQualifiedClassName());
+                JavaClass fieldType = classes.getOrResolve(JavaClassDescriptorImporter.importAsmTypeFromDescriptor(record.target.desc).getFullyQualifiedClassName());
                 return new FieldAccessTargetBuilder()
                         .withOwner(targetOwner)
                         .withName(record.target.name)

File: archunit/src/main/java/com/tngtech/archunit/core/importer/AccessRecord.java
Patch:
@@ -233,7 +233,7 @@ public JavaCodeUnit getCaller() {
             @Override
             public FieldAccessTarget getTarget() {
                 Supplier<Optional<JavaField>> fieldSupplier = new FieldTargetSupplier(targetOwner.getAllFields(), record.target);
-                JavaClass fieldType = classes.getOrResolve(JavaClassDescriptorImporter.importAsmType(record.target.desc).getFullyQualifiedClassName());
+                JavaClass fieldType = classes.getOrResolve(JavaClassDescriptorImporter.importAsmTypeFromDescriptor(record.target.desc).getFullyQualifiedClassName());
                 return new FieldAccessTargetBuilder()
                         .withOwner(targetOwner)
                         .withName(record.target.name)

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassDescriptorImporter.java
Patch:
@@ -42,7 +42,7 @@ static Object importAsmTypeIfPossible(Object value) {
         return isAsmType(value) ? importAsmType((Type) value) : value;
     }
 
-    static JavaClassDescriptor importAsmType(String typeDescriptor) {
+    static JavaClassDescriptor importAsmTypeFromDescriptor(String typeDescriptor) {
         return importAsmType(Type.getType(typeDescriptor));
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -206,7 +206,7 @@ public FieldVisitor visitField(int access, String name, String desc, String sign
 
         DomainBuilders.JavaFieldBuilder fieldBuilder = new DomainBuilders.JavaFieldBuilder()
                 .withName(name)
-                .withType(JavaClassDescriptorImporter.importAsmType(desc))
+                .withType(JavaClassDescriptorImporter.importAsmTypeFromDescriptor(desc))
                 .withModifiers(JavaModifier.getModifiersForField(access))
                 .withDescriptor(desc);
         declarationHandler.onDeclaredField(fieldBuilder);
@@ -500,7 +500,7 @@ public void visitEnd() {
     }
 
     private static DomainBuilders.JavaAnnotationBuilder annotationBuilderFor(String desc) {
-        return new DomainBuilders.JavaAnnotationBuilder().withType(JavaClassDescriptorImporter.importAsmType(desc));
+        return new DomainBuilders.JavaAnnotationBuilder().withType(JavaClassDescriptorImporter.importAsmTypeFromDescriptor(desc));
     }
 
     private static class AnnotationProcessor extends AnnotationVisitor {
@@ -736,7 +736,7 @@ private static ValueBuilder javaEnumBuilder(final String desc, final String valu
             public <T extends HasDescription> Optional<Object> build(T owner, ImportContext importContext) {
                 return Optional.<Object>of(
                         new DomainBuilders.JavaEnumConstantBuilder()
-                                .withDeclaringClass(importContext.resolveClass(JavaClassDescriptorImporter.importAsmType(desc).getFullyQualifiedClassName()))
+                                .withDeclaringClass(importContext.resolveClass(JavaClassDescriptorImporter.importAsmTypeFromDescriptor(desc).getFullyQualifiedClassName()))
                                 .withName(value)
                                 .build());
             }

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/ThirdPartyRulesTest.java
Patch:
@@ -42,10 +42,10 @@ private static ArchCondition<JavaClass> notCreateProblematicClassesOutsideOfWork
                 target(is(constructor())).and(targetOwner(is(assignableTo(ThirdPartyClassWithProblem.class))));
 
         DescribedPredicate<JavaCall<?>> notFromWithinThirdPartyClass =
-                originOwner(is(not(assignableTo(ThirdPartyClassWithProblem.class)))).forSubType();
+                originOwner(is(not(assignableTo(ThirdPartyClassWithProblem.class)))).forSubtype();
 
         DescribedPredicate<JavaCall<?>> notFromWorkaroundFactory =
-                originOwner(is(not(equivalentTo(ThirdPartyClassWorkaroundFactory.class)))).forSubType();
+                originOwner(is(not(equivalentTo(ThirdPartyClassWorkaroundFactory.class)))).forSubtype();
 
         DescribedPredicate<JavaCall<?>> targetIsIllegalConstructorOfThirdPartyClass =
                 constructorCallOfThirdPartyClass.

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/ThirdPartyRulesTest.java
Patch:
@@ -39,10 +39,10 @@ private static ArchCondition<JavaClass> notCreateProblematicClassesOutsideOfWork
                 target(is(constructor())).and(targetOwner(is(assignableTo(ThirdPartyClassWithProblem.class))));
 
         DescribedPredicate<JavaCall<?>> notFromWithinThirdPartyClass =
-                originOwner(is(not(assignableTo(ThirdPartyClassWithProblem.class)))).forSubType();
+                originOwner(is(not(assignableTo(ThirdPartyClassWithProblem.class)))).forSubtype();
 
         DescribedPredicate<JavaCall<?>> notFromWorkaroundFactory =
-                originOwner(is(not(equivalentTo(ThirdPartyClassWorkaroundFactory.class)))).forSubType();
+                originOwner(is(not(equivalentTo(ThirdPartyClassWorkaroundFactory.class)))).forSubtype();
 
         DescribedPredicate<JavaCall<?>> targetIsIllegalConstructorOfThirdPartyClass =
                 constructorCallOfThirdPartyClass.

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/thirdparty/ThirdPartyClassWorkaroundFactory.java
Patch:
@@ -9,8 +9,8 @@ public ThirdPartyClassWithProblem create() {
         return new ThirdPartyClassWithProblem();
     }
 
-    public ThirdPartySubClassWithProblem createSubClass() {
+    public ThirdPartySubclassWithProblem createSubclass() {
         // some workaround here
-        return new ThirdPartySubClassWithProblem();
+        return new ThirdPartySubclassWithProblem();
     }
 }

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/thirdparty/ThirdPartySubclassWithProblem.java
Patch:
@@ -1,4 +1,4 @@
 package com.tngtech.archunit.example.layers.thirdparty;
 
-public class ThirdPartySubClassWithProblem extends ThirdPartyClassWithProblem {
+public class ThirdPartySubclassWithProblem extends ThirdPartyClassWithProblem {
 }

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/ThirdPartyRulesTest.java
Patch:
@@ -43,10 +43,10 @@ private ArchCondition<JavaClass> notCreateProblematicClassesOutsideOfWorkaroundF
                 target(is(constructor())).and(targetOwner(is(assignableTo(ThirdPartyClassWithProblem.class))));
 
         DescribedPredicate<JavaCall<?>> notFromWithinThirdPartyClass =
-                originOwner(is(not(assignableTo(ThirdPartyClassWithProblem.class)))).forSubType();
+                originOwner(is(not(assignableTo(ThirdPartyClassWithProblem.class)))).forSubtype();
 
         DescribedPredicate<JavaCall<?>> notFromWorkaroundFactory =
-                originOwner(is(not(equivalentTo(ThirdPartyClassWorkaroundFactory.class)))).forSubType();
+                originOwner(is(not(equivalentTo(ThirdPartyClassWorkaroundFactory.class)))).forSubtype();
 
         DescribedPredicate<JavaCall<?>> targetIsIllegalConstructorOfThirdPartyClass =
                 constructorCallOfThirdPartyClass.

File: archunit-integration-test/src/test/java/com/tngtech/archunit/ArchUnitArchitectureTest.java
Patch:
@@ -71,7 +71,7 @@ public class ArchUnitArchitectureTest {
     private static DescribedPredicate<JavaCall<?>> typeIsIllegallyResolvedViaReflection() {
         DescribedPredicate<JavaCall<?>> explicitlyAllowedUsage =
                 origin(is(annotatedWith(MayResolveTypesViaReflection.class)))
-                        .or(contextIsAnnotatedWith(MayResolveTypesViaReflection.class)).forSubType();
+                        .or(contextIsAnnotatedWith(MayResolveTypesViaReflection.class)).forSubtype();
 
         return classIsResolvedViaReflection().and(not(explicitlyAllowedUsage));
     }
@@ -100,7 +100,7 @@ private static DescribedPredicate<JavaCall<?>> classIsResolvedViaReflection() {
                 target(HasOwner.Functions.Get.<JavaClass>owner()
                         .is(equivalentTo(Class.class)))
                         .and(target(has(name("forName"))))
-                        .forSubType();
+                        .forSubtype();
         DescribedPredicate<JavaCall<?>> targetIsMarked =
                 annotatedWith(ResolvesTypesViaReflection.class).onResultOf(Get.target());
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AccessTarget.java
Patch:
@@ -522,7 +522,7 @@ public static DescribedPredicate<AccessTarget> declaredIn(String className) {
         public static DescribedPredicate<AccessTarget> declaredIn(DescribedPredicate<? super JavaClass> predicate) {
             return Get.<JavaClass>owner().is(predicate)
                     .as("declared in %s", predicate.getDescription())
-                    .forSubType();
+                    .forSubtype();
         }
 
         @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -24,7 +24,9 @@
 
 @Internal
 public interface ImportContext {
-    Optional<JavaClass> createSuperClass(JavaClass owner);
+    Optional<JavaClass> createSuperclass(JavaClass owner);
+
+    Optional<JavaType> createGenericSuperclass(JavaClass owner);
 
     Set<JavaClass> createInterfaces(JavaClass owner);
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMember.java
Patch:
@@ -215,7 +215,7 @@ public static DescribedPredicate<JavaMember> declaredIn(String className) {
         public static DescribedPredicate<JavaMember> declaredIn(DescribedPredicate<? super JavaClass> predicate) {
             return Get.<JavaClass>owner().is(predicate)
                     .as("declared in %s", predicate.getDescription())
-                    .forSubType();
+                    .forSubtype();
         }
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ReverseDependencies.java
Patch:
@@ -272,7 +272,7 @@ public Set<ACCESS> load(MEMBER member) {
         private Set<JavaClass> getPossibleTargetClassesForAccess(JavaClass owner) {
             return ImmutableSet.<JavaClass>builder()
                     .add(owner)
-                    .addAll(owner.getAllSubClasses())
+                    .addAll(owner.getAllSubclasses())
                     .build();
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasThrowsClause.java
Patch:
@@ -70,7 +70,7 @@ public static DescribedPredicate<HasThrowsClause<?>> throwsClauseContainingType(
 
         @PublicAPI(usage = ACCESS)
         public static DescribedPredicate<HasThrowsClause<?>> throwsClauseContainingType(DescribedPredicate<? super JavaClass> predicate) {
-            DescribedPredicate<ThrowsDeclaration<?>> declarationPredicate = GET_RAW_TYPE.is(predicate).forSubType();
+            DescribedPredicate<ThrowsDeclaration<?>> declarationPredicate = GET_RAW_TYPE.is(predicate).forSubtype();
             return throwsClause(anyElementThat(declarationPredicate)).as("throws clause containing type " + predicate.getDescription());
         }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/AccessRecord.java
Patch:
@@ -356,7 +356,7 @@ public ClassHierarchyPath(JavaClassDescriptor childType, JavaClass parent) {
             }
 
             private Optional<JavaClass> tryFindChildInHierarchy(JavaClassDescriptor childType, JavaClass parent) {
-                for (JavaClass subclass : parent.getAllSubClasses()) {
+                for (JavaClass subclass : parent.getAllSubclasses()) {
                     if (subclass.getName().equals(childType.getFullyQualifiedClassName())) {
                         return Optional.of(subclass);
                     }
@@ -413,12 +413,12 @@ private ClassHierarchyResolutionStrategy(JavaClass child, JavaClass parent) {
 
                 @Override
                 public boolean hasNext() {
-                    return !current.equals(parent) && current.getSuperClass().isPresent();
+                    return !current.equals(parent) && current.getRawSuperclass().isPresent();
                 }
 
                 @Override
                 public JavaClass next() {
-                    current = current.getSuperClass().get();
+                    current = current.getRawSuperclass().get();
                     return current;
                 }
             }

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/FieldAccessCondition.java
Patch:
@@ -41,13 +41,13 @@ public void check(JavaFieldAccess item, ConditionEvents events) {
 
     static class FieldGetAccessCondition extends FieldAccessCondition {
         FieldGetAccessCondition(DescribedPredicate<? super JavaFieldAccess> predicate) {
-            super(predicate.<JavaFieldAccess>forSubType().and(accessType(GET)));
+            super(predicate.<JavaFieldAccess>forSubtype().and(accessType(GET)));
         }
     }
 
     static class FieldSetAccessCondition extends FieldAccessCondition {
         FieldSetAccessCondition(DescribedPredicate<? super JavaFieldAccess> predicate) {
-            super(predicate.<JavaFieldAccess>forSubType().and(accessType(SET)));
+            super(predicate.<JavaFieldAccess>forSubtype().and(accessType(SET)));
         }
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenCodeUnitsInternal.java
Patch:
@@ -93,7 +93,7 @@ public CodeUnitsShouldInternal should() {
 
         @Override
         public CodeUnitsShouldInternal should(ArchCondition<? super JavaCodeUnit> condition) {
-            return new CodeUnitsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaCodeUnit>forSubType(), prepareCondition);
+            return new CodeUnitsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaCodeUnit>forSubtype(), prepareCondition);
         }
 
         private static class GivenCodeUnitsFactory implements Factory<JavaCodeUnit, GivenCodeUnitsInternal> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenMembersInternal.java
Patch:
@@ -90,7 +90,7 @@ private GivenMembersInternal(
 
         @Override
         public MembersShouldConjunction<JavaMember> should(ArchCondition<? super JavaMember> condition) {
-            return new MembersShouldInternal(finishedClassesTransformer(), priority, condition.<JavaMember>forSubType(), prepareCondition);
+            return new MembersShouldInternal(finishedClassesTransformer(), priority, condition.<JavaMember>forSubtype(), prepareCondition);
         }
 
         @Override

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractMembersShouldInternal.java
Patch:
@@ -295,7 +295,7 @@ public SELF apply(DescribedPredicate<? super JavaClass> predicate) {
     }
 
     private SELF copyWithNewCondition(ArchCondition<? super MEMBER> newCondition) {
-        return copyWithNewCondition(new ConditionAggregator<>(newCondition.<MEMBER>forSubType()));
+        return copyWithNewCondition(new ConditionAggregator<>(newCondition.<MEMBER>forSubtype()));
     }
 
     abstract SELF copyWithNewCondition(ConditionAggregator<MEMBER> newCondition);

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassInternal.java
Patch:
@@ -43,6 +43,6 @@ public ClassesShould should() {
 
     @Override
     public ClassesShouldConjunction should(ArchCondition<? super JavaClass> condition) {
-        return new ClassesShouldInternal(classesTransformer, priority, condition.<JavaClass>forSubType(), prepareCondition);
+        return new ClassesShouldInternal(classesTransformer, priority, condition.<JavaClass>forSubtype(), prepareCondition);
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassesInternal.java
Patch:
@@ -90,7 +90,7 @@ public GivenClassesConjunction apply(DescribedPredicate<? super JavaClass> input
 
     @Override
     public ClassesShouldConjunction should(ArchCondition<? super JavaClass> condition) {
-        return new ClassesShouldInternal(finishedClassesTransformer(), priority, condition.<JavaClass>forSubType(), prepareCondition);
+        return new ClassesShouldInternal(finishedClassesTransformer(), priority, condition.<JavaClass>forSubtype(), prepareCondition);
     }
 
     private static class GivenClassesFactory implements Factory<JavaClass, GivenClassesInternal> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenConstructorsInternal.java
Patch:
@@ -63,7 +63,7 @@ public ConstructorsShouldInternal should() {
 
     @Override
     public ConstructorsShouldInternal should(ArchCondition<? super JavaConstructor> condition) {
-        return new ConstructorsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaConstructor>forSubType(), prepareCondition);
+        return new ConstructorsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaConstructor>forSubtype(), prepareCondition);
     }
 
     private static class GivenConstructorsFactory implements Factory<JavaConstructor, GivenConstructorsInternal> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenFieldsInternal.java
Patch:
@@ -64,7 +64,7 @@ public FieldsShouldInternal should() {
 
     @Override
     public FieldsShouldInternal should(ArchCondition<? super JavaField> condition) {
-        return new FieldsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaField>forSubType(), prepareCondition);
+        return new FieldsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaField>forSubtype(), prepareCondition);
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenMethodsInternal.java
Patch:
@@ -79,7 +79,7 @@ public MethodsShouldInternal should() {
 
     @Override
     public MethodsShouldInternal should(ArchCondition<? super JavaMethod> condition) {
-        return new MethodsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaMethod>forSubType(), prepareCondition);
+        return new MethodsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaMethod>forSubtype(), prepareCondition);
     }
 
     private static class GivenMethodsFactory implements Factory<JavaMethod, GivenMethodsInternal> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenObjectsInternal.java
Patch:
@@ -49,7 +49,7 @@ private GivenObjectsInternal(
 
     @Override
     public ArchRule should(ArchCondition<? super T> condition) {
-        return new ObjectsShouldInternal<>(finishedClassesTransformer(), priority, condition.<T>forSubType(), prepareCondition);
+        return new ObjectsShouldInternal<>(finishedClassesTransformer(), priority, condition.<T>forSubtype(), prepareCondition);
     }
 
     private static class GivenObjectsFactory<T> implements AbstractGivenObjects.Factory<T, GivenObjectsInternal<T>> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ObjectsShouldInternal.java
Patch:
@@ -152,7 +152,7 @@ static <T> AddMode<T> and(final Function<ArchCondition<T>, ArchCondition<T>> pre
             return new AddMode<T>() {
                 @Override
                 ArchCondition<T> apply(Optional<ArchCondition<T>> first, ArchCondition<? super T> other) {
-                    ArchCondition<T> second = prepareCondition.apply(other.<T>forSubType());
+                    ArchCondition<T> second = prepareCondition.apply(other.<T>forSubtype());
                     return first.isPresent() ? first.get().and(second) : second;
                 }
             };
@@ -162,7 +162,7 @@ static <T> AddMode<T> or(final Function<ArchCondition<T>, ArchCondition<T>> prep
             return new AddMode<T>() {
                 @Override
                 ArchCondition<T> apply(Optional<ArchCondition<T>> first, ArchCondition<? super T> other) {
-                    ArchCondition<T> second = prepareCondition.apply(other.<T>forSubType());
+                    ArchCondition<T> second = prepareCondition.apply(other.<T>forSubtype());
                     return first.isPresent() ? first.get().or(second) : second;
                 }
             };

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/PredicateAggregator.java
Patch:
@@ -58,7 +58,7 @@ static <T> AddMode<T> and() {
             return new AddMode<T>() {
                 @Override
                 DescribedPredicate<T> apply(Optional<DescribedPredicate<T>> first, DescribedPredicate<? super T> other) {
-                    DescribedPredicate<T> second = other.forSubType();
+                    DescribedPredicate<T> second = other.forSubtype();
                     return first.isPresent() ? first.get().and(second) : second;
                 }
             };
@@ -68,7 +68,7 @@ static <T> AddMode<T> or() {
             return new AddMode<T>() {
                 @Override
                 DescribedPredicate<T> apply(Optional<DescribedPredicate<T>> first, DescribedPredicate<? super T> other) {
-                    DescribedPredicate<T> second = other.forSubType();
+                    DescribedPredicate<T> second = other.forSubtype();
                     return first.isPresent() ? first.get().or(second) : second;
                 }
             };

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MembersShould.java
Patch:
@@ -440,7 +440,7 @@ public interface MembersShould<CONJUNCTION extends MembersShouldConjunction<?>>
      * <br><br>
      * E.g.
      * <pre><code>
-     * {@link ArchRuleDefinition#members() members()}.{@link GivenMembers#should() should()}.{@link MembersShould#beDeclaredInClassesThat(DescribedPredicate) beDeclaredInClassesThat(areSubTypeOf(Example.class))}
+     * {@link ArchRuleDefinition#members() members()}.{@link GivenMembers#should() should()}.{@link MembersShould#beDeclaredInClassesThat(DescribedPredicate) beDeclaredInClassesThat(areSubtypeOf(Example.class))}
      * </code></pre>
      * would be violated by <code>someField</code> in
      *

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MembersThat.java
Patch:
@@ -451,7 +451,7 @@ public interface MembersThat<CONJUNCTION extends GivenMembersConjunction<?>> {
      *
      * will be matched by
      * <pre><code>
-     * {@link ArchRuleDefinition#members() members()}.{@link GivenMembers#that() that()}.{@link MembersThat#areDeclaredInClassesThat(DescribedPredicate) areDeclaredInClassesThat(areSubTypeOf(Object.class))}
+     * {@link ArchRuleDefinition#members() members()}.{@link GivenMembers#that() that()}.{@link MembersThat#areDeclaredInClassesThat(DescribedPredicate) areDeclaredInClassesThat(areSubtypeOf(Object.class))}
      * </code></pre>
      *
      * @param predicate A predicate which matches classes where members have to be declared in

File: archunit/src/main/java/com/tngtech/archunit/library/Architectures.java
Patch:
@@ -362,7 +362,7 @@ private LayerDefinition(String name, boolean optional) {
             @PublicAPI(usage = ACCESS)
             public LayeredArchitecture definedBy(DescribedPredicate<? super JavaClass> predicate) {
                 checkNotNull(predicate, "Supplied predicate must not be null");
-                this.containsPredicate = predicate.forSubType();
+                this.containsPredicate = predicate.forSubtype();
                 return LayeredArchitecture.this.addLayerDefinition(this);
             }
 

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/GivenSlicesInternal.java
Patch:
@@ -43,7 +43,7 @@ class GivenSlicesInternal implements GivenSlices, SlicesShould, GivenSlicesConju
 
     @Override
     public ArchRule should(ArchCondition<? super Slice> condition) {
-        return ArchRule.Factory.create(classesTransformer, condition.<Slice>forSubType(), priority);
+        return ArchRule.Factory.create(classesTransformer, condition.<Slice>forSubtype(), priority);
     }
 
     @Override

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaTypeVariableTest.java
Patch:
@@ -9,7 +9,7 @@
 
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 import static com.tngtech.archunit.testutil.Assertions.assertThatType;
-import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
+import static com.tngtech.archunit.testutil.Assertions.assertThatTypeErasuresOf;
 
 public class JavaTypeVariableTest {
 
@@ -45,8 +45,8 @@ class ClassWithUnboundTypeParameter<T extends HashMap<Object, Object> & Serializ
 
         JavaTypeVariable<JavaClass> type = new ClassFileImporter().importClass(ClassWithUnboundTypeParameter.class).getTypeParameters().get(0);
 
-        assertThatTypes(type.getBounds()).matchExactly(HashMap.class, Serializable.class);
-        assertThatTypes(type.getUpperBounds()).matchExactly(HashMap.class, Serializable.class);
+        assertThatTypeErasuresOf(type.getBounds()).matchExactly(HashMap.class, Serializable.class);
+        assertThatTypeErasuresOf(type.getUpperBounds()).matchExactly(HashMap.class, Serializable.class);
     }
 
     @Test

File: archunit/src/test/java/com/tngtech/archunit/core/domain/testobjects/InterfaceForA.java
Patch:
@@ -1,4 +1,4 @@
 package com.tngtech.archunit.core.domain.testobjects;
 
-public interface InterfaceForA extends SuperInterface {
+public interface InterfaceForA extends Superinterface {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/testobjects/Superinterface.java
Patch:
@@ -1,4 +1,4 @@
 package com.tngtech.archunit.core.domain.testobjects;
 
-public interface SuperInterface {
+public interface Superinterface {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterAnnotationsTest.java
Patch:
@@ -66,7 +66,7 @@ public void imports_simple_annotation() {
         assertThat(javaClass.getSimpleName()).as("simple name").isEqualTo(AnnotationToImport.class.getSimpleName());
         assertThat(javaClass.getPackageName()).as("package name").isEqualTo(AnnotationToImport.class.getPackage().getName());
         assertThat(javaClass.getModifiers()).as("modifiers").containsOnly(JavaModifier.PUBLIC, JavaModifier.ABSTRACT);
-        assertThat(javaClass.getSuperClass()).as("super class").isAbsent();
+        assertThat(javaClass.getRawSuperclass()).as("super class").isAbsent();
         assertThatTypes(javaClass.getInterfaces()).as("interfaces").matchInAnyOrder(Annotation.class);
         assertThat(javaClass.isInterface()).as("is interface").isTrue();
         assertThat(javaClass.isEnum()).as("is enum").isFalse();

File: archunit/src/test/java/com/tngtech/archunit/core/importer/IndependentClasspathRule.java
Patch:
@@ -21,7 +21,7 @@ class IndependentClasspathRule extends ExternalResource {
     private final SystemPropertiesRule systemPropertiesRule = new SystemPropertiesRule();
 
     @Override
-    protected void before() throws Throwable {
+    protected void before() {
         systemPropertiesRule.before();
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/resolvers/SelectedClassResolverFromClasspathTest.java
Patch:
@@ -68,11 +68,11 @@ public boolean matches(URI argument) {
         });
     }
 
-    private ImmutableList<String> packages(String... subPackages) {
+    private ImmutableList<String> packages(String... subpackages) {
         ImmutableList.Builder<String> result = ImmutableList.builder();
-        for (String pkg : subPackages) {
+        for (String pkg : subpackages) {
             result.add(getClass().getPackage().getName() + ".testclasses." + pkg);
         }
         return result.build();
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/callimport/ExternalSubtypeConstructorCall.java
Patch:
@@ -4,7 +4,7 @@
 
 import com.tngtech.archunit.core.importer.testexamples.complexexternal.ChildClass;
 
-public class ExternalSubTypeConstructorCall {
+public class ExternalSubtypeConstructorCall {
     void call() {
         new ChildClass();
     }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/OtherSubclass.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
-public class OtherSubClass extends BaseClass implements ParentInterface {
+public class OtherSubclass extends BaseClass implements ParentInterface {
     private int foo = 5;
 
     void soSthOtherSub() {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/SomeCollection.java
Patch:
@@ -1,4 +1,4 @@
 package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
-public abstract class SomeCollection implements CollectionInterface, OtherInterface, SubInterface {
+public abstract class SomeCollection implements CollectionInterface, OtherInterface, Subinterface {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/SubSubSubSubclass.java
Patch:
@@ -1,4 +1,4 @@
 package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
-public class SubSubSubSubClass extends SubSubSubClass {
+public class SubSubSubSubclass extends SubSubSubclass {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/SubSubSubclass.java
Patch:
@@ -1,4 +1,4 @@
 package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
-public class SubSubSubClass extends SubSubClass {
+public class SubSubSubclass extends SubSubclass {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/SubSubclass.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
-public class SubSubClass extends SubClass implements SubInterface, YetAnotherInterface {
+public class SubSubclass extends Subclass implements Subinterface, YetAnotherInterface {
     private String printMe = "NoOp";
 
     void doSomethingSubSub() {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/Subinterface.java
Patch:
@@ -1,4 +1,4 @@
 package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
-public interface SubInterface extends ParentInterface {
+public interface Subinterface extends ParentInterface {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/hierarchicalfieldaccess/SubclassWithAccessedField.java
Patch:
@@ -1,5 +1,5 @@
 package com.tngtech.archunit.core.importer.testexamples.hierarchicalfieldaccess;
 
-public class SubClassWithAccessedField extends SuperClassWithAccessedField {
+public class SubclassWithAccessedField extends SuperclassWithAccessedField {
     int maskedField;
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/hierarchicalfieldaccess/SuperclassWithAccessedField.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.core.importer.testexamples.hierarchicalfieldaccess;
 
-public class SuperClassWithAccessedField {
+public class SuperclassWithAccessedField {
     String field;
     int maskedField;
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/hierarchicalmethodcall/SubclassWithCalledMethod.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.core.importer.testexamples.hierarchicalmethodcall;
 
-public class SubClassWithCalledMethod extends SuperClassWithCalledMethod {
+public class SubclassWithCalledMethod extends SuperclassWithCalledMethod {
     public static final String maskedMethod = "maskedMethod";
 
     @Override

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/hierarchicalmethodcall/SuperclassWithCalledMethod.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.core.importer.testexamples.hierarchicalmethodcall;
 
-public class SuperClassWithCalledMethod {
+public class SuperclassWithCalledMethod {
     public static final String method = "method";
 
     String method() {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/integration/ClassCDependingOnClassB_SuperclassOfX.java
Patch:
@@ -1,10 +1,10 @@
 package com.tngtech.archunit.core.importer.testexamples.integration;
 
-public class ClassCDependingOnClassB_SuperClassOfX {
+public class ClassCDependingOnClassB_SuperclassOfX {
     private ClassBDependingOnClassA classB;
     private int cState;
 
-    public ClassCDependingOnClassB_SuperClassOfX(int a, int b, int c) {
+    public ClassCDependingOnClassB_SuperclassOfX(int a, int b, int c) {
         this.cState = a + b + c;
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/integration/ClassXDependingOnClassesABCD.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.core.importer.testexamples.integration;
 
-public class ClassXDependingOnClassesABCD extends ClassCDependingOnClassB_SuperClassOfX implements InterfaceOfClassX {
+public class ClassXDependingOnClassesABCD extends ClassCDependingOnClassB_SuperclassOfX implements InterfaceOfClassX {
     private ClassA classA;
     private ClassBDependingOnClassA classB;
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/outsideofclasspath/MiddleClass.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.core.importer.testexamples.outsideofclasspath;
 
-public class MiddleClass extends MissingSuperClass {
+public class MiddleClass extends MissingSuperclass {
     public String someField;
     private MissingDependency missingDependency = new MissingDependency();
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/outsideofclasspath/MissingSuperclass.java
Patch:
@@ -1,9 +1,9 @@
 package com.tngtech.archunit.core.importer.testexamples.outsideofclasspath;
 
-public class MissingSuperClass {
+public class MissingSuperclass {
     public String parentField;
 
-    public MissingSuperClass() {
+    public MissingSuperclass() {
     }
 
     public void overrideMe() {

File: archunit/src/test/java/com/tngtech/archunit/library/testclasses/first/any/pkg/FirstAnyPkgClass.java
Patch:
@@ -1,11 +1,11 @@
 package com.tngtech.archunit.library.testclasses.first.any.pkg;
 
 import com.tngtech.archunit.library.testclasses.second.three.any.SecondThreeAnyClass;
-import com.tngtech.archunit.library.testclasses.some.pkg.sub.SomePkgSubClass;
+import com.tngtech.archunit.library.testclasses.some.pkg.sub.SomePkgSubclass;
 
 @SuppressWarnings("WeakerAccess")
 public class FirstAnyPkgClass {
-    SomePkgSubClass illegalTarget;
+    SomePkgSubclass illegalTarget;
     SecondThreeAnyClass legalTarget;
     // The importer will never find the bytecode of FirstAnyPkgClass[].class, thus it will always be a stub in the same package
     FirstAnyPkgClass[] evilArrayToCauseOriginallyUnimportedClass;

File: archunit/src/test/java/com/tngtech/archunit/library/testclasses/some/pkg/SomePkgClass.java
Patch:
@@ -1,9 +1,9 @@
 package com.tngtech.archunit.library.testclasses.some.pkg;
 
-import com.tngtech.archunit.library.testclasses.some.pkg.sub.SomePkgSubClass;
+import com.tngtech.archunit.library.testclasses.some.pkg.sub.SomePkgSubclass;
 
 public class SomePkgClass {
-    SomePkgSubClass legalTarget;
+    SomePkgSubclass legalTarget;
 
     void call() {
         legalTarget.callMe();

File: archunit/src/test/java/com/tngtech/archunit/library/testclasses/some/pkg/sub/SomePkgSubclass.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.tngtech.archunit.library.testclasses.first.any.pkg.FirstAnyPkgClass;
 
-public class SomePkgSubClass {
+public class SomePkgSubclass {
     FirstAnyPkgClass legalTarget;
 
     void call() {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -26,6 +26,8 @@
 public interface ImportContext {
     Optional<JavaClass> createSuperclass(JavaClass owner);
 
+    Optional<JavaType> createGenericSuperclass(JavaClass owner);
+
     Set<JavaClass> createInterfaces(JavaClass owner);
 
     List<JavaTypeVariable<JavaClass>> createTypeParameters(JavaClass owner);

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -428,6 +428,8 @@ interface DeclarationHandler {
 
         void onDeclaredTypeParameters(DomainBuilders.TypeParametersBuilder typeParametersBuilder);
 
+        void onGenericSuperclass(DomainBuilders.JavaParameterizedTypeBuilder<JavaClass> genericSuperclassBuilder);
+
         void onDeclaredField(DomainBuilders.JavaFieldBuilder fieldBuilder);
 
         void onDeclaredConstructor(DomainBuilders.JavaConstructorBuilder constructorBuilder);

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -114,7 +114,7 @@ public void visit(int version, int access, String name, String signature, String
 
         className = descriptor.getFullyQualifiedClassName();
         declarationHandler.onNewClass(className, superclassName, interfaceNames);
-        JavaGenericTypeImporter.parseAsmTypeSignature(signature, declarationHandler);
+        JavaClassSignatureImporter.parseAsmTypeSignature(signature, declarationHandler);
     }
 
     private boolean alreadyImported(JavaClassDescriptor descriptor) {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaTypeVariableTest.java
Patch:
@@ -9,7 +9,7 @@
 
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 import static com.tngtech.archunit.testutil.Assertions.assertThatType;
-import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
+import static com.tngtech.archunit.testutil.Assertions.assertThatTypeErasuresOf;
 
 public class JavaTypeVariableTest {
 
@@ -45,8 +45,8 @@ class ClassWithUnboundTypeParameter<T extends HashMap<Object, Object> & Serializ
 
         JavaTypeVariable<JavaClass> type = new ClassFileImporter().importClass(ClassWithUnboundTypeParameter.class).getTypeParameters().get(0);
 
-        assertThatTypes(type.getBounds()).matchExactly(HashMap.class, Serializable.class);
-        assertThatTypes(type.getUpperBounds()).matchExactly(HashMap.class, Serializable.class);
+        assertThatTypeErasuresOf(type.getBounds()).matchExactly(HashMap.class, Serializable.class);
+        assertThatTypeErasuresOf(type.getUpperBounds()).matchExactly(HashMap.class, Serializable.class);
     }
 
     @Test

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaTypeAssertion.java
Patch:
@@ -89,7 +89,8 @@ public JavaTypeVariableOfClassAssertion hasOnlyTypeParameter(String name) {
     }
 
     private JavaClass actualClass() {
-        return actual instanceof JavaClass ? (JavaClass) actual : actual.toErasure();
+        assertThat(actual).as(describeAssertion(actual.getName())).isInstanceOf(JavaClass.class);
+        return (JavaClass) actual;
     }
 
     private String ensureArrayName(String name) {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileImportRecord.java
Patch:
@@ -41,7 +41,7 @@ class ClassFileImportRecord {
     private static final Logger LOG = LoggerFactory.getLogger(ClassFileImportRecord.class);
 
     private static final TypeParametersBuilder NO_TYPE_PARAMETERS =
-            new TypeParametersBuilder(Collections.<JavaTypeParameterBuilder<JavaClass>>emptySet());
+            new TypeParametersBuilder(Collections.<JavaTypeParameterBuilder<JavaClass>>emptyList());
 
     private final Map<String, JavaClass> classes = new HashMap<>();
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/DomainBuilders.java
Patch:
@@ -16,7 +16,6 @@
 package com.tngtech.archunit.core.importer;
 
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
@@ -541,9 +540,9 @@ public List<JavaType> getUpperBounds(Iterable<? extends JavaTypeVariable<?>> all
     }
 
     static class TypeParametersBuilder {
-        private final Collection<JavaTypeParameterBuilder<JavaClass>> typeParameterBuilders;
+        private final List<JavaTypeParameterBuilder<JavaClass>> typeParameterBuilders;
 
-        TypeParametersBuilder(Collection<JavaTypeParameterBuilder<JavaClass>> typeParameterBuilders) {
+        TypeParametersBuilder(List<JavaTypeParameterBuilder<JavaClass>> typeParameterBuilders) {
             this.typeParameterBuilders = typeParameterBuilders;
         }
 

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/ThirdPartyRulesTest.java
Patch:
@@ -42,10 +42,10 @@ private static ArchCondition<JavaClass> notCreateProblematicClassesOutsideOfWork
                 target(is(constructor())).and(targetOwner(is(assignableTo(ThirdPartyClassWithProblem.class))));
 
         DescribedPredicate<JavaCall<?>> notFromWithinThirdPartyClass =
-                originOwner(is(not(assignableTo(ThirdPartyClassWithProblem.class)))).forSubType();
+                originOwner(is(not(assignableTo(ThirdPartyClassWithProblem.class)))).forSubtype();
 
         DescribedPredicate<JavaCall<?>> notFromWorkaroundFactory =
-                originOwner(is(not(equivalentTo(ThirdPartyClassWorkaroundFactory.class)))).forSubType();
+                originOwner(is(not(equivalentTo(ThirdPartyClassWorkaroundFactory.class)))).forSubtype();
 
         DescribedPredicate<JavaCall<?>> targetIsIllegalConstructorOfThirdPartyClass =
                 constructorCallOfThirdPartyClass.

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/ThirdPartyRulesTest.java
Patch:
@@ -39,10 +39,10 @@ private static ArchCondition<JavaClass> notCreateProblematicClassesOutsideOfWork
                 target(is(constructor())).and(targetOwner(is(assignableTo(ThirdPartyClassWithProblem.class))));
 
         DescribedPredicate<JavaCall<?>> notFromWithinThirdPartyClass =
-                originOwner(is(not(assignableTo(ThirdPartyClassWithProblem.class)))).forSubType();
+                originOwner(is(not(assignableTo(ThirdPartyClassWithProblem.class)))).forSubtype();
 
         DescribedPredicate<JavaCall<?>> notFromWorkaroundFactory =
-                originOwner(is(not(equivalentTo(ThirdPartyClassWorkaroundFactory.class)))).forSubType();
+                originOwner(is(not(equivalentTo(ThirdPartyClassWorkaroundFactory.class)))).forSubtype();
 
         DescribedPredicate<JavaCall<?>> targetIsIllegalConstructorOfThirdPartyClass =
                 constructorCallOfThirdPartyClass.

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/thirdparty/ThirdPartyClassWorkaroundFactory.java
Patch:
@@ -9,8 +9,8 @@ public ThirdPartyClassWithProblem create() {
         return new ThirdPartyClassWithProblem();
     }
 
-    public ThirdPartySubClassWithProblem createSubClass() {
+    public ThirdPartySubclassWithProblem createSubclass() {
         // some workaround here
-        return new ThirdPartySubClassWithProblem();
+        return new ThirdPartySubclassWithProblem();
     }
 }

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/thirdparty/ThirdPartySubclassWithProblem.java
Patch:
@@ -1,4 +1,4 @@
 package com.tngtech.archunit.example.layers.thirdparty;
 
-public class ThirdPartySubClassWithProblem extends ThirdPartyClassWithProblem {
+public class ThirdPartySubclassWithProblem extends ThirdPartyClassWithProblem {
 }

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/ThirdPartyRulesTest.java
Patch:
@@ -43,10 +43,10 @@ private ArchCondition<JavaClass> notCreateProblematicClassesOutsideOfWorkaroundF
                 target(is(constructor())).and(targetOwner(is(assignableTo(ThirdPartyClassWithProblem.class))));
 
         DescribedPredicate<JavaCall<?>> notFromWithinThirdPartyClass =
-                originOwner(is(not(assignableTo(ThirdPartyClassWithProblem.class)))).forSubType();
+                originOwner(is(not(assignableTo(ThirdPartyClassWithProblem.class)))).forSubtype();
 
         DescribedPredicate<JavaCall<?>> notFromWorkaroundFactory =
-                originOwner(is(not(equivalentTo(ThirdPartyClassWorkaroundFactory.class)))).forSubType();
+                originOwner(is(not(equivalentTo(ThirdPartyClassWorkaroundFactory.class)))).forSubtype();
 
         DescribedPredicate<JavaCall<?>> targetIsIllegalConstructorOfThirdPartyClass =
                 constructorCallOfThirdPartyClass.

File: archunit-integration-test/src/test/java/com/tngtech/archunit/ArchUnitArchitectureTest.java
Patch:
@@ -71,7 +71,7 @@ public class ArchUnitArchitectureTest {
     private static DescribedPredicate<JavaCall<?>> typeIsIllegallyResolvedViaReflection() {
         DescribedPredicate<JavaCall<?>> explicitlyAllowedUsage =
                 origin(is(annotatedWith(MayResolveTypesViaReflection.class)))
-                        .or(contextIsAnnotatedWith(MayResolveTypesViaReflection.class)).forSubType();
+                        .or(contextIsAnnotatedWith(MayResolveTypesViaReflection.class)).forSubtype();
 
         return classIsResolvedViaReflection().and(not(explicitlyAllowedUsage));
     }
@@ -100,7 +100,7 @@ private static DescribedPredicate<JavaCall<?>> classIsResolvedViaReflection() {
                 target(HasOwner.Functions.Get.<JavaClass>owner()
                         .is(equivalentTo(Class.class)))
                         .and(target(has(name("forName"))))
-                        .forSubType();
+                        .forSubtype();
         DescribedPredicate<JavaCall<?>> targetIsMarked =
                 annotatedWith(ResolvesTypesViaReflection.class).onResultOf(Get.target());
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/ExamplesIntegrationTest.java
Patch:
@@ -108,7 +108,7 @@
 import com.tngtech.archunit.example.layers.service.impl.WronglyNamedSvc;
 import com.tngtech.archunit.example.layers.thirdparty.ThirdPartyClassWithProblem;
 import com.tngtech.archunit.example.layers.thirdparty.ThirdPartyClassWorkaroundFactory;
-import com.tngtech.archunit.example.layers.thirdparty.ThirdPartySubClassWithProblem;
+import com.tngtech.archunit.example.layers.thirdparty.ThirdPartySubclassWithProblem;
 import com.tngtech.archunit.example.layers.web.AnnotatedController;
 import com.tngtech.archunit.example.layers.web.InheritedControllerImpl;
 import com.tngtech.archunit.example.onionarchitecture.adapter.cli.AdministrationCLI;
@@ -1370,8 +1370,8 @@ Stream<DynamicTest> ThirdPartyRulesTest() {
                 .by(callFromMethod(ClassViolatingThirdPartyRules.class, "illegallyInstantiateThirdPartyClass")
                         .toConstructor(ThirdPartyClassWithProblem.class)
                         .inLine(9))
-                .by(callFromMethod(ClassViolatingThirdPartyRules.class, "illegallyInstantiateThirdPartySubClass")
-                        .toConstructor(ThirdPartySubClassWithProblem.class)
+                .by(callFromMethod(ClassViolatingThirdPartyRules.class, "illegallyInstantiateThirdPartySubclass")
+                        .toConstructor(ThirdPartySubclassWithProblem.class)
                         .inLine(17))
 
                 .toDynamicTests();

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/ExpectedDependency.java
Patch:
@@ -78,9 +78,9 @@ private InheritanceCreator(Class<?> clazz) {
             this.clazz = clazz;
         }
 
-        public ExpectedDependency extending(Class<?> superClass) {
-            return new ExpectedDependency(clazz, superClass,
-                    getDependencyPattern(clazz.getName(), "extends", superClass.getName(), 0));
+        public ExpectedDependency extending(Class<?> superclass) {
+            return new ExpectedDependency(clazz, superclass,
+                    getDependencyPattern(clazz.getName(), "extends", superclass.getName(), 0));
         }
 
         public ExpectedDependency implementing(Class<?> anInterface) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AccessTarget.java
Patch:
@@ -522,7 +522,7 @@ public static DescribedPredicate<AccessTarget> declaredIn(String className) {
         public static DescribedPredicate<AccessTarget> declaredIn(DescribedPredicate<? super JavaClass> predicate) {
             return Get.<JavaClass>owner().is(predicate)
                     .as("declared in %s", predicate.getDescription())
-                    .forSubType();
+                    .forSubtype();
         }
 
         @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -24,7 +24,7 @@
 
 @Internal
 public interface ImportContext {
-    Optional<JavaClass> createSuperClass(JavaClass owner);
+    Optional<JavaClass> createSuperclass(JavaClass owner);
 
     Set<JavaClass> createInterfaces(JavaClass owner);
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassDependencies.java
Patch:
@@ -70,8 +70,8 @@ private Set<Dependency> dependenciesFromAccesses(Set<JavaAccess<?>> accesses) {
 
     private Set<Dependency> inheritanceDependenciesFromSelf() {
         ImmutableSet.Builder<Dependency> result = ImmutableSet.builder();
-        for (JavaClass superType : FluentIterable.from(javaClass.getInterfaces()).append(javaClass.getSuperClass().asSet())) {
-            result.add(Dependency.fromInheritance(javaClass, superType));
+        for (JavaClass supertype : FluentIterable.from(javaClass.getInterfaces()).append(javaClass.getRawSuperclass().asSet())) {
+            result.add(Dependency.fromInheritance(javaClass, supertype));
         }
         return result.build();
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMember.java
Patch:
@@ -215,7 +215,7 @@ public static DescribedPredicate<JavaMember> declaredIn(String className) {
         public static DescribedPredicate<JavaMember> declaredIn(DescribedPredicate<? super JavaClass> predicate) {
             return Get.<JavaClass>owner().is(predicate)
                     .as("declared in %s", predicate.getDescription())
-                    .forSubType();
+                    .forSubtype();
         }
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ReverseDependencies.java
Patch:
@@ -272,7 +272,7 @@ public Set<ACCESS> load(MEMBER member) {
         private Set<JavaClass> getPossibleTargetClassesForAccess(JavaClass owner) {
             return ImmutableSet.<JavaClass>builder()
                     .add(owner)
-                    .addAll(owner.getAllSubClasses())
+                    .addAll(owner.getAllSubclasses())
                     .build();
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasThrowsClause.java
Patch:
@@ -70,7 +70,7 @@ public static DescribedPredicate<HasThrowsClause<?>> throwsClauseContainingType(
 
         @PublicAPI(usage = ACCESS)
         public static DescribedPredicate<HasThrowsClause<?>> throwsClauseContainingType(DescribedPredicate<? super JavaClass> predicate) {
-            DescribedPredicate<ThrowsDeclaration<?>> declarationPredicate = GET_RAW_TYPE.is(predicate).forSubType();
+            DescribedPredicate<ThrowsDeclaration<?>> declarationPredicate = GET_RAW_TYPE.is(predicate).forSubtype();
             return throwsClause(anyElementThat(declarationPredicate)).as("throws clause containing type " + predicate.getDescription());
         }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/AccessRecord.java
Patch:
@@ -356,7 +356,7 @@ public ClassHierarchyPath(JavaClassDescriptor childType, JavaClass parent) {
             }
 
             private Optional<JavaClass> tryFindChildInHierarchy(JavaClassDescriptor childType, JavaClass parent) {
-                for (JavaClass subclass : parent.getAllSubClasses()) {
+                for (JavaClass subclass : parent.getAllSubclasses()) {
                     if (subclass.getName().equals(childType.getFullyQualifiedClassName())) {
                         return Optional.of(subclass);
                     }
@@ -413,12 +413,12 @@ private ClassHierarchyResolutionStrategy(JavaClass child, JavaClass parent) {
 
                 @Override
                 public boolean hasNext() {
-                    return !current.equals(parent) && current.getSuperClass().isPresent();
+                    return !current.equals(parent) && current.getRawSuperclass().isPresent();
                 }
 
                 @Override
                 public JavaClass next() {
-                    current = current.getSuperClass().get();
+                    current = current.getRawSuperclass().get();
                     return current;
                 }
             }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileProcessor.java
Patch:
@@ -77,10 +77,10 @@ public boolean isNew(String className) {
         }
 
         @Override
-        public void onNewClass(String className, Optional<String> superClassName, Set<String> interfaceNames) {
+        public void onNewClass(String className, Optional<String> superclassName, Set<String> interfaceNames) {
             ownerName = className;
-            if (superClassName.isPresent()) {
-                importRecord.setSuperClass(ownerName, superClassName.get());
+            if (superclassName.isPresent()) {
+                importRecord.setSuperclass(ownerName, superclassName.get());
             }
             importRecord.addInterfaces(ownerName, interfaceNames);
         }

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/FieldAccessCondition.java
Patch:
@@ -41,13 +41,13 @@ public void check(JavaFieldAccess item, ConditionEvents events) {
 
     static class FieldGetAccessCondition extends FieldAccessCondition {
         FieldGetAccessCondition(DescribedPredicate<? super JavaFieldAccess> predicate) {
-            super(predicate.<JavaFieldAccess>forSubType().and(accessType(GET)));
+            super(predicate.<JavaFieldAccess>forSubtype().and(accessType(GET)));
         }
     }
 
     static class FieldSetAccessCondition extends FieldAccessCondition {
         FieldSetAccessCondition(DescribedPredicate<? super JavaFieldAccess> predicate) {
-            super(predicate.<JavaFieldAccess>forSubType().and(accessType(SET)));
+            super(predicate.<JavaFieldAccess>forSubtype().and(accessType(SET)));
         }
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenCodeUnitsInternal.java
Patch:
@@ -93,7 +93,7 @@ public CodeUnitsShouldInternal should() {
 
         @Override
         public CodeUnitsShouldInternal should(ArchCondition<? super JavaCodeUnit> condition) {
-            return new CodeUnitsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaCodeUnit>forSubType(), prepareCondition);
+            return new CodeUnitsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaCodeUnit>forSubtype(), prepareCondition);
         }
 
         private static class GivenCodeUnitsFactory implements Factory<JavaCodeUnit, GivenCodeUnitsInternal> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenMembersInternal.java
Patch:
@@ -90,7 +90,7 @@ private GivenMembersInternal(
 
         @Override
         public MembersShouldConjunction<JavaMember> should(ArchCondition<? super JavaMember> condition) {
-            return new MembersShouldInternal(finishedClassesTransformer(), priority, condition.<JavaMember>forSubType(), prepareCondition);
+            return new MembersShouldInternal(finishedClassesTransformer(), priority, condition.<JavaMember>forSubtype(), prepareCondition);
         }
 
         @Override

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractMembersShouldInternal.java
Patch:
@@ -295,7 +295,7 @@ public SELF apply(DescribedPredicate<? super JavaClass> predicate) {
     }
 
     private SELF copyWithNewCondition(ArchCondition<? super MEMBER> newCondition) {
-        return copyWithNewCondition(new ConditionAggregator<>(newCondition.<MEMBER>forSubType()));
+        return copyWithNewCondition(new ConditionAggregator<>(newCondition.<MEMBER>forSubtype()));
     }
 
     abstract SELF copyWithNewCondition(ConditionAggregator<MEMBER> newCondition);

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassInternal.java
Patch:
@@ -43,6 +43,6 @@ public ClassesShould should() {
 
     @Override
     public ClassesShouldConjunction should(ArchCondition<? super JavaClass> condition) {
-        return new ClassesShouldInternal(classesTransformer, priority, condition.<JavaClass>forSubType(), prepareCondition);
+        return new ClassesShouldInternal(classesTransformer, priority, condition.<JavaClass>forSubtype(), prepareCondition);
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassesInternal.java
Patch:
@@ -90,7 +90,7 @@ public GivenClassesConjunction apply(DescribedPredicate<? super JavaClass> input
 
     @Override
     public ClassesShouldConjunction should(ArchCondition<? super JavaClass> condition) {
-        return new ClassesShouldInternal(finishedClassesTransformer(), priority, condition.<JavaClass>forSubType(), prepareCondition);
+        return new ClassesShouldInternal(finishedClassesTransformer(), priority, condition.<JavaClass>forSubtype(), prepareCondition);
     }
 
     private static class GivenClassesFactory implements Factory<JavaClass, GivenClassesInternal> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenConstructorsInternal.java
Patch:
@@ -63,7 +63,7 @@ public ConstructorsShouldInternal should() {
 
     @Override
     public ConstructorsShouldInternal should(ArchCondition<? super JavaConstructor> condition) {
-        return new ConstructorsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaConstructor>forSubType(), prepareCondition);
+        return new ConstructorsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaConstructor>forSubtype(), prepareCondition);
     }
 
     private static class GivenConstructorsFactory implements Factory<JavaConstructor, GivenConstructorsInternal> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenFieldsInternal.java
Patch:
@@ -64,7 +64,7 @@ public FieldsShouldInternal should() {
 
     @Override
     public FieldsShouldInternal should(ArchCondition<? super JavaField> condition) {
-        return new FieldsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaField>forSubType(), prepareCondition);
+        return new FieldsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaField>forSubtype(), prepareCondition);
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenMethodsInternal.java
Patch:
@@ -79,7 +79,7 @@ public MethodsShouldInternal should() {
 
     @Override
     public MethodsShouldInternal should(ArchCondition<? super JavaMethod> condition) {
-        return new MethodsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaMethod>forSubType(), prepareCondition);
+        return new MethodsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaMethod>forSubtype(), prepareCondition);
     }
 
     private static class GivenMethodsFactory implements Factory<JavaMethod, GivenMethodsInternal> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenObjectsInternal.java
Patch:
@@ -49,7 +49,7 @@ private GivenObjectsInternal(
 
     @Override
     public ArchRule should(ArchCondition<? super T> condition) {
-        return new ObjectsShouldInternal<>(finishedClassesTransformer(), priority, condition.<T>forSubType(), prepareCondition);
+        return new ObjectsShouldInternal<>(finishedClassesTransformer(), priority, condition.<T>forSubtype(), prepareCondition);
     }
 
     private static class GivenObjectsFactory<T> implements AbstractGivenObjects.Factory<T, GivenObjectsInternal<T>> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ObjectsShouldInternal.java
Patch:
@@ -152,7 +152,7 @@ static <T> AddMode<T> and(final Function<ArchCondition<T>, ArchCondition<T>> pre
             return new AddMode<T>() {
                 @Override
                 ArchCondition<T> apply(Optional<ArchCondition<T>> first, ArchCondition<? super T> other) {
-                    ArchCondition<T> second = prepareCondition.apply(other.<T>forSubType());
+                    ArchCondition<T> second = prepareCondition.apply(other.<T>forSubtype());
                     return first.isPresent() ? first.get().and(second) : second;
                 }
             };
@@ -162,7 +162,7 @@ static <T> AddMode<T> or(final Function<ArchCondition<T>, ArchCondition<T>> prep
             return new AddMode<T>() {
                 @Override
                 ArchCondition<T> apply(Optional<ArchCondition<T>> first, ArchCondition<? super T> other) {
-                    ArchCondition<T> second = prepareCondition.apply(other.<T>forSubType());
+                    ArchCondition<T> second = prepareCondition.apply(other.<T>forSubtype());
                     return first.isPresent() ? first.get().or(second) : second;
                 }
             };

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/PredicateAggregator.java
Patch:
@@ -58,7 +58,7 @@ static <T> AddMode<T> and() {
             return new AddMode<T>() {
                 @Override
                 DescribedPredicate<T> apply(Optional<DescribedPredicate<T>> first, DescribedPredicate<? super T> other) {
-                    DescribedPredicate<T> second = other.forSubType();
+                    DescribedPredicate<T> second = other.forSubtype();
                     return first.isPresent() ? first.get().and(second) : second;
                 }
             };
@@ -68,7 +68,7 @@ static <T> AddMode<T> or() {
             return new AddMode<T>() {
                 @Override
                 DescribedPredicate<T> apply(Optional<DescribedPredicate<T>> first, DescribedPredicate<? super T> other) {
-                    DescribedPredicate<T> second = other.forSubType();
+                    DescribedPredicate<T> second = other.forSubtype();
                     return first.isPresent() ? first.get().or(second) : second;
                 }
             };

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MembersShould.java
Patch:
@@ -440,7 +440,7 @@ public interface MembersShould<CONJUNCTION extends MembersShouldConjunction<?>>
      * <br><br>
      * E.g.
      * <pre><code>
-     * {@link ArchRuleDefinition#members() members()}.{@link GivenMembers#should() should()}.{@link MembersShould#beDeclaredInClassesThat(DescribedPredicate) beDeclaredInClassesThat(areSubTypeOf(Example.class))}
+     * {@link ArchRuleDefinition#members() members()}.{@link GivenMembers#should() should()}.{@link MembersShould#beDeclaredInClassesThat(DescribedPredicate) beDeclaredInClassesThat(areSubtypeOf(Example.class))}
      * </code></pre>
      * would be violated by <code>someField</code> in
      *

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MembersThat.java
Patch:
@@ -451,7 +451,7 @@ public interface MembersThat<CONJUNCTION extends GivenMembersConjunction<?>> {
      *
      * will be matched by
      * <pre><code>
-     * {@link ArchRuleDefinition#members() members()}.{@link GivenMembers#that() that()}.{@link MembersThat#areDeclaredInClassesThat(DescribedPredicate) areDeclaredInClassesThat(areSubTypeOf(Object.class))}
+     * {@link ArchRuleDefinition#members() members()}.{@link GivenMembers#that() that()}.{@link MembersThat#areDeclaredInClassesThat(DescribedPredicate) areDeclaredInClassesThat(areSubtypeOf(Object.class))}
      * </code></pre>
      *
      * @param predicate A predicate which matches classes where members have to be declared in

File: archunit/src/main/java/com/tngtech/archunit/library/Architectures.java
Patch:
@@ -362,7 +362,7 @@ private LayerDefinition(String name, boolean optional) {
             @PublicAPI(usage = ACCESS)
             public LayeredArchitecture definedBy(DescribedPredicate<? super JavaClass> predicate) {
                 checkNotNull(predicate, "Supplied predicate must not be null");
-                this.containsPredicate = predicate.forSubType();
+                this.containsPredicate = predicate.forSubtype();
                 return LayeredArchitecture.this.addLayerDefinition(this);
             }
 

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/GivenSlicesInternal.java
Patch:
@@ -43,7 +43,7 @@ class GivenSlicesInternal implements GivenSlices, SlicesShould, GivenSlicesConju
 
     @Override
     public ArchRule should(ArchCondition<? super Slice> condition) {
-        return ArchRule.Factory.create(classesTransformer, condition.<Slice>forSubType(), priority);
+        return ArchRule.Factory.create(classesTransformer, condition.<Slice>forSubtype(), priority);
     }
 
     @Override

File: archunit/src/test/java/com/tngtech/archunit/core/domain/DependencyTest.java
Patch:
@@ -132,7 +132,7 @@ public void Dependency_from_origin_and_target() {
         assertThat(dependency.getDescription()).as("description")
                 .contains("Class <" + origin.getName() + "> implements interface <" + target.getName() + ">");
 
-        origin = importClassWithContext(DependencySubInterface.class);
+        origin = importClassWithContext(DependencySubinterface.class);
         dependency = createDependency(origin, target);
         assertThat(dependency.getDescription()).as("description")
                 .contains("Interface <" + origin.getName() + "> extends interface <" + target.getName() + ">");
@@ -353,7 +353,7 @@ public String toString() {
     private static class DependencyClass {
     }
 
-    private interface DependencySubInterface extends DependencyInterface {
+    private interface DependencySubinterface extends DependencyInterface {
     }
 
     private interface DependencyInterface {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/testobjects/InterfaceForA.java
Patch:
@@ -1,4 +1,4 @@
 package com.tngtech.archunit.core.domain.testobjects;
 
-public interface InterfaceForA extends SuperInterface {
+public interface InterfaceForA extends Superinterface {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/testobjects/Superinterface.java
Patch:
@@ -1,4 +1,4 @@
 package com.tngtech.archunit.core.domain.testobjects;
 
-public interface SuperInterface {
+public interface Superinterface {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterAnnotationsTest.java
Patch:
@@ -66,7 +66,7 @@ public void imports_simple_annotation() {
         assertThat(javaClass.getSimpleName()).as("simple name").isEqualTo(AnnotationToImport.class.getSimpleName());
         assertThat(javaClass.getPackageName()).as("package name").isEqualTo(AnnotationToImport.class.getPackage().getName());
         assertThat(javaClass.getModifiers()).as("modifiers").containsOnly(JavaModifier.PUBLIC, JavaModifier.ABSTRACT);
-        assertThat(javaClass.getSuperClass()).as("super class").isAbsent();
+        assertThat(javaClass.getRawSuperclass()).as("super class").isAbsent();
         assertThatTypes(javaClass.getInterfaces()).as("interfaces").matchInAnyOrder(Annotation.class);
         assertThat(javaClass.isInterface()).as("is interface").isTrue();
         assertThat(javaClass.isEnum()).as("is enum").isFalse();

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportTestUtils.java
Patch:
@@ -332,7 +332,7 @@ private JavaClass importNew(Class<?> owner) {
     private static class ImportContextStub implements ImportContext {
 
         @Override
-        public Optional<JavaClass> createSuperClass(JavaClass owner) {
+        public Optional<JavaClass> createSuperclass(JavaClass owner) {
             return Optional.absent();
         }
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/IndependentClasspathRule.java
Patch:
@@ -21,7 +21,7 @@ class IndependentClasspathRule extends ExternalResource {
     private final SystemPropertiesRule systemPropertiesRule = new SystemPropertiesRule();
 
     @Override
-    protected void before() throws Throwable {
+    protected void before() {
         systemPropertiesRule.before();
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/resolvers/SelectedClassResolverFromClasspathTest.java
Patch:
@@ -68,11 +68,11 @@ public boolean matches(URI argument) {
         });
     }
 
-    private ImmutableList<String> packages(String... subPackages) {
+    private ImmutableList<String> packages(String... subpackages) {
         ImmutableList.Builder<String> result = ImmutableList.builder();
-        for (String pkg : subPackages) {
+        for (String pkg : subpackages) {
             result.add(getClass().getPackage().getName() + ".testclasses." + pkg);
         }
         return result.build();
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/callimport/ExternalSubtypeConstructorCall.java
Patch:
@@ -4,7 +4,7 @@
 
 import com.tngtech.archunit.core.importer.testexamples.complexexternal.ChildClass;
 
-public class ExternalSubTypeConstructorCall {
+public class ExternalSubtypeConstructorCall {
     void call() {
         new ChildClass();
     }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/OtherSubclass.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
-public class OtherSubClass extends BaseClass implements ParentInterface {
+public class OtherSubclass extends BaseClass implements ParentInterface {
     private int foo = 5;
 
     void soSthOtherSub() {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/SomeCollection.java
Patch:
@@ -1,4 +1,4 @@
 package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
-public abstract class SomeCollection implements CollectionInterface, OtherInterface, SubInterface {
+public abstract class SomeCollection implements CollectionInterface, OtherInterface, Subinterface {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/SubSubSubSubclass.java
Patch:
@@ -1,4 +1,4 @@
 package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
-public class SubSubSubSubClass extends SubSubSubClass {
+public class SubSubSubSubclass extends SubSubSubclass {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/SubSubSubclass.java
Patch:
@@ -1,4 +1,4 @@
 package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
-public class SubSubSubClass extends SubSubClass {
+public class SubSubSubclass extends SubSubclass {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/SubSubclass.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
-public class SubSubClass extends SubClass implements SubInterface, YetAnotherInterface {
+public class SubSubclass extends Subclass implements Subinterface, YetAnotherInterface {
     private String printMe = "NoOp";
 
     void doSomethingSubSub() {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/Subinterface.java
Patch:
@@ -1,4 +1,4 @@
 package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
-public interface SubInterface extends ParentInterface {
+public interface Subinterface extends ParentInterface {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/hierarchicalfieldaccess/SubclassWithAccessedField.java
Patch:
@@ -1,5 +1,5 @@
 package com.tngtech.archunit.core.importer.testexamples.hierarchicalfieldaccess;
 
-public class SubClassWithAccessedField extends SuperClassWithAccessedField {
+public class SubclassWithAccessedField extends SuperclassWithAccessedField {
     int maskedField;
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/hierarchicalfieldaccess/SuperclassWithAccessedField.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.core.importer.testexamples.hierarchicalfieldaccess;
 
-public class SuperClassWithAccessedField {
+public class SuperclassWithAccessedField {
     String field;
     int maskedField;
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/hierarchicalmethodcall/SubclassWithCalledMethod.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.core.importer.testexamples.hierarchicalmethodcall;
 
-public class SubClassWithCalledMethod extends SuperClassWithCalledMethod {
+public class SubclassWithCalledMethod extends SuperclassWithCalledMethod {
     public static final String maskedMethod = "maskedMethod";
 
     @Override

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/hierarchicalmethodcall/SuperclassWithCalledMethod.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.core.importer.testexamples.hierarchicalmethodcall;
 
-public class SuperClassWithCalledMethod {
+public class SuperclassWithCalledMethod {
     public static final String method = "method";
 
     String method() {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/integration/ClassCDependingOnClassB_SuperclassOfX.java
Patch:
@@ -1,10 +1,10 @@
 package com.tngtech.archunit.core.importer.testexamples.integration;
 
-public class ClassCDependingOnClassB_SuperClassOfX {
+public class ClassCDependingOnClassB_SuperclassOfX {
     private ClassBDependingOnClassA classB;
     private int cState;
 
-    public ClassCDependingOnClassB_SuperClassOfX(int a, int b, int c) {
+    public ClassCDependingOnClassB_SuperclassOfX(int a, int b, int c) {
         this.cState = a + b + c;
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/integration/ClassXDependingOnClassesABCD.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.core.importer.testexamples.integration;
 
-public class ClassXDependingOnClassesABCD extends ClassCDependingOnClassB_SuperClassOfX implements InterfaceOfClassX {
+public class ClassXDependingOnClassesABCD extends ClassCDependingOnClassB_SuperclassOfX implements InterfaceOfClassX {
     private ClassA classA;
     private ClassBDependingOnClassA classB;
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/outsideofclasspath/MiddleClass.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.core.importer.testexamples.outsideofclasspath;
 
-public class MiddleClass extends MissingSuperClass {
+public class MiddleClass extends MissingSuperclass {
     public String someField;
     private MissingDependency missingDependency = new MissingDependency();
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/outsideofclasspath/MissingSuperclass.java
Patch:
@@ -1,9 +1,9 @@
 package com.tngtech.archunit.core.importer.testexamples.outsideofclasspath;
 
-public class MissingSuperClass {
+public class MissingSuperclass {
     public String parentField;
 
-    public MissingSuperClass() {
+    public MissingSuperclass() {
     }
 
     public void overrideMe() {

File: archunit/src/test/java/com/tngtech/archunit/library/testclasses/first/any/pkg/FirstAnyPkgClass.java
Patch:
@@ -1,11 +1,11 @@
 package com.tngtech.archunit.library.testclasses.first.any.pkg;
 
 import com.tngtech.archunit.library.testclasses.second.three.any.SecondThreeAnyClass;
-import com.tngtech.archunit.library.testclasses.some.pkg.sub.SomePkgSubClass;
+import com.tngtech.archunit.library.testclasses.some.pkg.sub.SomePkgSubclass;
 
 @SuppressWarnings("WeakerAccess")
 public class FirstAnyPkgClass {
-    SomePkgSubClass illegalTarget;
+    SomePkgSubclass illegalTarget;
     SecondThreeAnyClass legalTarget;
     // The importer will never find the bytecode of FirstAnyPkgClass[].class, thus it will always be a stub in the same package
     FirstAnyPkgClass[] evilArrayToCauseOriginallyUnimportedClass;

File: archunit/src/test/java/com/tngtech/archunit/library/testclasses/some/pkg/SomePkgClass.java
Patch:
@@ -1,9 +1,9 @@
 package com.tngtech.archunit.library.testclasses.some.pkg;
 
-import com.tngtech.archunit.library.testclasses.some.pkg.sub.SomePkgSubClass;
+import com.tngtech.archunit.library.testclasses.some.pkg.sub.SomePkgSubclass;
 
 public class SomePkgClass {
-    SomePkgSubClass legalTarget;
+    SomePkgSubclass legalTarget;
 
     void call() {
         legalTarget.callMe();

File: archunit/src/test/java/com/tngtech/archunit/library/testclasses/some/pkg/sub/SomePkgSubclass.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.tngtech.archunit.library.testclasses.first.any.pkg.FirstAnyPkgClass;
 
-public class SomePkgSubClass {
+public class SomePkgSubclass {
     FirstAnyPkgClass legalTarget;
 
     void call() {

File: archunit-java-modules-test/src/main/java/module-info.java
Patch:
@@ -0,0 +1,3 @@
+module example_module {
+    exports com.tngtech.archunit.example;
+}
\ No newline at end of file

File: archunit-java-modules-test/src/main/java/module-info.java
Patch:
@@ -0,0 +1,3 @@
+module example_module {
+    exports com.tngtech.archunit.example;
+}
\ No newline at end of file

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -145,8 +145,8 @@ public Set<JavaMember> get() {
                     .build();
         }
     });
-    private JavaClassDependencies javaClassDependencies;
-    private ReverseDependencies reverseDependencies;
+    private JavaClassDependencies javaClassDependencies = new JavaClassDependencies(this);  // just for stubs; will be overwritten for imported classes
+    private ReverseDependencies reverseDependencies = ReverseDependencies.EMPTY;  // just for stubs; will be overwritten for imported classes
 
     JavaClass(JavaClassBuilder builder) {
         source = checkNotNull(builder.getSource());

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -28,7 +28,7 @@ public interface ImportContext {
 
     Set<JavaClass> createInterfaces(JavaClass owner);
 
-    List<JavaTypeVariable> createTypeParameters(JavaClass owner);
+    List<JavaTypeVariable<JavaClass>> createTypeParameters(JavaClass owner);
 
     Set<JavaField> createFields(JavaClass owner);
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -72,7 +72,7 @@ public class JavaClass implements JavaType, HasName.AndFullName, HasAnnotations<
     private final boolean isAnonymousClass;
     private final boolean isMemberClass;
     private final Set<JavaModifier> modifiers;
-    private List<JavaTypeVariable> typeParameters = emptyList();
+    private List<JavaTypeVariable<JavaClass>> typeParameters = emptyList();
     private final Supplier<Class<?>> reflectSupplier;
     private Set<JavaField> fields = emptySet();
     private Set<JavaCodeUnit> codeUnits = emptySet();
@@ -644,7 +644,7 @@ public Optional<JavaAnnotation<JavaClass>> tryGetAnnotationOfType(String typeNam
     }
 
     @PublicAPI(usage = ACCESS)
-    public List<JavaTypeVariable> getTypeParameters() {
+    public List<JavaTypeVariable<JavaClass>> getTypeParameters() {
         return typeParameters;
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaWildcardType.java
Patch:
@@ -46,7 +46,7 @@ public class JavaWildcardType implements JavaType, HasUpperBounds {
     private final List<JavaType> lowerBounds;
     private final JavaClass erasure;
 
-    JavaWildcardType(JavaWildcardTypeBuilder builder) {
+    JavaWildcardType(JavaWildcardTypeBuilder<?> builder) {
         upperBounds = builder.getUpperBounds();
         lowerBounds = builder.getLowerBounds();
         erasure = builder.getUnboundErasureType(upperBounds);

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileImportRecord.java
Patch:
@@ -41,7 +41,7 @@ class ClassFileImportRecord {
     private static final Logger LOG = LoggerFactory.getLogger(ClassFileImportRecord.class);
 
     private static final TypeParametersBuilder NO_TYPE_PARAMETERS =
-            new TypeParametersBuilder(Collections.<JavaTypeParameterBuilder>emptySet());
+            new TypeParametersBuilder(Collections.<JavaTypeParameterBuilder<JavaClass>>emptySet());
 
     private final Map<String, JavaClass> classes = new HashMap<>();
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -237,7 +237,7 @@ public Set<JavaClass> createInterfaces(JavaClass owner) {
     }
 
     @Override
-    public List<JavaTypeVariable> createTypeParameters(JavaClass owner) {
+    public List<JavaTypeVariable<JavaClass>> createTypeParameters(JavaClass owner) {
         TypeParametersBuilder typeParametersBuilder = importRecord.getTypeParameterBuildersFor(owner.getName());
         return typeParametersBuilder.build(owner, classes.byTypeName());
     }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportTestUtils.java
Patch:
@@ -342,7 +342,7 @@ public Set<JavaClass> createInterfaces(JavaClass owner) {
         }
 
         @Override
-        public List<JavaTypeVariable> createTypeParameters(JavaClass owner) {
+        public List<JavaTypeVariable<JavaClass>> createTypeParameters(JavaClass owner) {
             return Collections.emptyList();
         }
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -96,7 +96,7 @@ public static JavaTypeAssertion assertThatType(JavaType javaType) {
         return new JavaTypeAssertion(javaType);
     }
 
-    public static JavaTypeVariableAssertion assertThatTypeVariable(JavaTypeVariable typeVariable) {
+    public static JavaTypeVariableAssertion assertThatTypeVariable(JavaTypeVariable<?> typeVariable) {
         return new JavaTypeVariableAssertion(typeVariable);
     }
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaTypeVariableAssertion.java
Patch:
@@ -23,8 +23,8 @@
 import static com.tngtech.archunit.testutil.assertion.JavaTypeVariableAssertion.ExpectedConcreteWildcardType.wildcardType;
 import static java.util.Collections.emptyList;
 
-public class JavaTypeVariableAssertion extends AbstractObjectAssert<JavaTypeVariableAssertion, JavaTypeVariable> {
-    public JavaTypeVariableAssertion(JavaTypeVariable actual) {
+public class JavaTypeVariableAssertion extends AbstractObjectAssert<JavaTypeVariableAssertion, JavaTypeVariable<?>> {
+    public JavaTypeVariableAssertion(JavaTypeVariable<?> actual) {
         super(actual, JavaTypeVariableAssertion.class);
     }
 
@@ -215,7 +215,7 @@ public ExpectedConcreteTypeVariable withoutUpperBounds() {
         @Override
         public void assertMatchWith(JavaType actual, DescriptionContext context) {
             assertThat(actual).as(context.step("JavaType").toString()).isInstanceOf(JavaTypeVariable.class);
-            JavaTypeVariable actualTypeVariable = (JavaTypeVariable) actual;
+            JavaTypeVariable<?> actualTypeVariable = (JavaTypeVariable<?>) actual;
             assertThat(actualTypeVariable.getName()).as(context.step("type variable name").toString()).isEqualTo(name);
 
             if (upperBounds != null) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -28,7 +28,7 @@ public interface ImportContext {
 
     Set<JavaClass> createInterfaces(JavaClass owner);
 
-    List<JavaTypeVariable> createTypeParameters(JavaClass owner);
+    List<JavaTypeVariable<JavaClass>> createTypeParameters(JavaClass owner);
 
     Set<JavaField> createFields(JavaClass owner);
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -72,7 +72,7 @@ public class JavaClass implements JavaType, HasName.AndFullName, HasAnnotations<
     private final boolean isAnonymousClass;
     private final boolean isMemberClass;
     private final Set<JavaModifier> modifiers;
-    private List<JavaTypeVariable> typeParameters = emptyList();
+    private List<JavaTypeVariable<JavaClass>> typeParameters = emptyList();
     private final Supplier<Class<?>> reflectSupplier;
     private Set<JavaField> fields = emptySet();
     private Set<JavaCodeUnit> codeUnits = emptySet();
@@ -644,7 +644,7 @@ public Optional<JavaAnnotation<JavaClass>> tryGetAnnotationOfType(String typeNam
     }
 
     @PublicAPI(usage = ACCESS)
-    public List<JavaTypeVariable> getTypeParameters() {
+    public List<JavaTypeVariable<JavaClass>> getTypeParameters() {
         return typeParameters;
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaWildcardType.java
Patch:
@@ -46,7 +46,7 @@ public class JavaWildcardType implements JavaType, HasUpperBounds {
     private final List<JavaType> lowerBounds;
     private final JavaClass erasure;
 
-    JavaWildcardType(JavaWildcardTypeBuilder builder) {
+    JavaWildcardType(JavaWildcardTypeBuilder<?> builder) {
         upperBounds = builder.getUpperBounds();
         lowerBounds = builder.getLowerBounds();
         erasure = builder.getUnboundErasureType(upperBounds);

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileImportRecord.java
Patch:
@@ -41,7 +41,7 @@ class ClassFileImportRecord {
     private static final Logger LOG = LoggerFactory.getLogger(ClassFileImportRecord.class);
 
     private static final TypeParametersBuilder NO_TYPE_PARAMETERS =
-            new TypeParametersBuilder(Collections.<JavaTypeParameterBuilder>emptySet());
+            new TypeParametersBuilder(Collections.<JavaTypeParameterBuilder<JavaClass>>emptySet());
 
     private final Map<String, JavaClass> classes = new HashMap<>();
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -237,7 +237,7 @@ public Set<JavaClass> createInterfaces(JavaClass owner) {
     }
 
     @Override
-    public List<JavaTypeVariable> createTypeParameters(JavaClass owner) {
+    public List<JavaTypeVariable<JavaClass>> createTypeParameters(JavaClass owner) {
         TypeParametersBuilder typeParametersBuilder = importRecord.getTypeParameterBuildersFor(owner.getName());
         return typeParametersBuilder.build(owner, classes.byTypeName());
     }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportTestUtils.java
Patch:
@@ -342,7 +342,7 @@ public Set<JavaClass> createInterfaces(JavaClass owner) {
         }
 
         @Override
-        public List<JavaTypeVariable> createTypeParameters(JavaClass owner) {
+        public List<JavaTypeVariable<JavaClass>> createTypeParameters(JavaClass owner) {
             return Collections.emptyList();
         }
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -96,7 +96,7 @@ public static JavaTypeAssertion assertThatType(JavaType javaType) {
         return new JavaTypeAssertion(javaType);
     }
 
-    public static JavaTypeVariableAssertion assertThatTypeVariable(JavaTypeVariable typeVariable) {
+    public static JavaTypeVariableAssertion assertThatTypeVariable(JavaTypeVariable<?> typeVariable) {
         return new JavaTypeVariableAssertion(typeVariable);
     }
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaTypeVariableAssertion.java
Patch:
@@ -23,8 +23,8 @@
 import static com.tngtech.archunit.testutil.assertion.JavaTypeVariableAssertion.ExpectedConcreteWildcardType.wildcardType;
 import static java.util.Collections.emptyList;
 
-public class JavaTypeVariableAssertion extends AbstractObjectAssert<JavaTypeVariableAssertion, JavaTypeVariable> {
-    public JavaTypeVariableAssertion(JavaTypeVariable actual) {
+public class JavaTypeVariableAssertion extends AbstractObjectAssert<JavaTypeVariableAssertion, JavaTypeVariable<?>> {
+    public JavaTypeVariableAssertion(JavaTypeVariable<?> actual) {
         super(actual, JavaTypeVariableAssertion.class);
     }
 
@@ -215,7 +215,7 @@ public ExpectedConcreteTypeVariable withoutUpperBounds() {
         @Override
         public void assertMatchWith(JavaType actual, DescriptionContext context) {
             assertThat(actual).as(context.step("JavaType").toString()).isInstanceOf(JavaTypeVariable.class);
-            JavaTypeVariable actualTypeVariable = (JavaTypeVariable) actual;
+            JavaTypeVariable<?> actualTypeVariable = (JavaTypeVariable<?>) actual;
             assertThat(actualTypeVariable.getName()).as(context.step("type variable name").toString()).isEqualTo(name);
 
             if (upperBounds != null) {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/TestUtils.java
Patch:
@@ -181,7 +181,7 @@ private JavaMethodCall to(MethodCallTarget methodCallTarget) {
             for (MethodCallTarget target : targets) {
                 calls.add(newMethodCall(method, target, lineNumber));
             }
-            when(context.getMethodCallsFor(method)).thenReturn(ImmutableSet.copyOf(calls));
+            when(context.createMethodCallsFor(method)).thenReturn(ImmutableSet.copyOf(calls));
             method.completeFrom(context);
             return getCallToTarget(methodCallTarget);
         }
@@ -206,7 +206,7 @@ private JavaMethodCall getCallToTarget(MethodCallTarget callTarget) {
 
         public void to(JavaField target, AccessType accessType) {
             ImportContext context = mock(ImportContext.class);
-            when(context.getFieldAccessesFor(method))
+            when(context.createFieldAccessesFor(method))
                     .thenReturn(ImmutableSet.of(
                             newFieldAccess(method, target, lineNumber, accessType)
                     ));

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaAnnotationAssertion.java
Patch:
@@ -31,7 +31,7 @@ public JavaAnnotationAssertion(JavaAnnotation<?> actual) {
         super(actual, JavaAnnotationAssertion.class);
     }
 
-    private JavaAnnotationAssertion hasType(Class<? extends Annotation> annotationType) {
+    public JavaAnnotationAssertion hasType(Class<? extends Annotation> annotationType) {
         assertThatType(actual.getRawType())
                 .as("annotation type of " + descriptionText())
                 .matches(annotationType);

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -1295,12 +1295,13 @@ void completeAnnotations(final ImportContext context) {
         }
     }
 
-    void completeFrom(ImportContext context) {
+    JavaClassDependencies completeFrom(ImportContext context) {
         completeComponentType(context);
         for (JavaCodeUnit codeUnit : codeUnits) {
             codeUnit.completeFrom(context);
         }
         javaClassDependencies = new JavaClassDependencies(this);
+        return javaClassDependencies;
     }
 
     private void completeComponentType(ImportContext context) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClasses.java
Patch:
@@ -197,8 +197,8 @@ static JavaClasses of(
         JavaPackage defaultPackage = JavaPackage.from(allClasses);
         for (JavaClass clazz : allClasses) {
             setPackage(clazz, defaultPackage);
-            clazz.completeFrom(importContext);
-            reverseDependenciesCreation.registerDependenciesOf(clazz);
+            JavaClassDependencies classDependencies = clazz.completeFrom(importContext);
+            reverseDependenciesCreation.registerDependenciesOf(clazz, classDependencies);
         }
         reverseDependenciesCreation.finish(allClasses);
         return new JavaClasses(defaultPackage, selectedClasses);

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClasses.java
Patch:
@@ -228,7 +228,7 @@ void completeClass(JavaClass clazz) {
         }
 
         void finish() {
-            AccessContext.TopProcess accessCompletionProcess = new AccessContext.TopProcess(classes);
+            AccessContext.TopProcess accessCompletionProcess = new AccessContext.TopProcess(classes, context);
             for (JavaClass.CompletionProcess process : classCompletionProcesses) {
                 accessCompletionProcess.mergeWith(process.completeCodeUnitsFrom(context));
             }

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/ViolationStoreFactory.java
Patch:
@@ -183,7 +183,7 @@ public List<String> getViolations(ArchRule rule) {
 
         private List<String> readLines(String ruleDetailsFileName) {
             String violationsText = readStoreFile(ruleDetailsFileName);
-            List<String> lines = Splitter.on(UNESCAPED_LINE_BREAK_PATTERN).splitToList(violationsText);
+            List<String> lines = Splitter.on(UNESCAPED_LINE_BREAK_PATTERN).omitEmptyStrings().splitToList(violationsText);
             return unescape(lines);
         }
 

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/ViolationStoreFactory.java
Patch:
@@ -183,7 +183,7 @@ public List<String> getViolations(ArchRule rule) {
 
         private List<String> readLines(String ruleDetailsFileName) {
             String violationsText = readStoreFile(ruleDetailsFileName);
-            List<String> lines = Splitter.on(UNESCAPED_LINE_BREAK_PATTERN).splitToList(violationsText);
+            List<String> lines = Splitter.on(UNESCAPED_LINE_BREAK_PATTERN).omitEmptyStrings().splitToList(violationsText);
             return unescape(lines);
         }
 

File: archunit/src/test/java/com/tngtech/archunit/core/domain/TestUtils.java
Patch:
@@ -140,7 +140,7 @@ public static ConstructorCallTarget targetFrom(JavaConstructor constructor) {
     }
 
     public static Dependency dependencyFrom(JavaAccess<?> access) {
-        return Dependency.tryCreateFromAccess(access).get();
+        return getOnlyElement(Dependency.tryCreateFromAccess(access));
     }
 
     public static class AccessesSimulator {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/TestUtils.java
Patch:
@@ -140,7 +140,7 @@ public static ConstructorCallTarget targetFrom(JavaConstructor constructor) {
     }
 
     public static Dependency dependencyFrom(JavaAccess<?> access) {
-        return Dependency.tryCreateFromAccess(access).get();
+        return getOnlyElement(Dependency.tryCreateFromAccess(access));
     }
 
     public static class AccessesSimulator {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -228,12 +228,12 @@ public boolean isArray() {
     /**
      * This is a convenience method for {@link #tryGetComponentType()} in cases where
      * clients know that this type is certainly an array type and thus the component type present.
-     * @throws IllegalArgumentException if this class is no array
+     * @throws IllegalStateException if this class is no array
      * @return The result of {@link #tryGetComponentType()}
      */
     @PublicAPI(usage = ACCESS)
     public JavaClass getComponentType() {
-        return tryGetComponentType().getOrThrow(new IllegalArgumentException(
+        return tryGetComponentType().getOrThrow(new IllegalStateException(
                 String.format("Type %s is no array", getSimpleName())));
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassTest.java
Patch:
@@ -123,7 +123,7 @@ Object notAnArray() {
             public void call() {
                 nonArrayType.getComponentType();
             }
-        }).isInstanceOf(IllegalArgumentException.class);
+        }).isInstanceOf(IllegalStateException.class);
         assertThat(nonArrayType.getBaseComponentType()).isSameAs(nonArrayType);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -69,4 +69,6 @@ public interface ImportContext {
     Set<InstanceofCheck> getInstanceofChecksOfType(JavaClass javaClass);
 
     JavaClass resolveClass(String fullyQualifiedClassName);
+
+    Optional<JavaClass> getMethodReturnType(String declaringClassName, String methodName);
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/JavaAnnotationTestBuilder.java
Patch:
@@ -1,5 +1,6 @@
 package com.tngtech.archunit.core.importer;
 
+import com.tngtech.archunit.core.domain.ImportContext;
 import com.tngtech.archunit.core.domain.JavaAnnotation;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClassDescriptor;
@@ -19,7 +20,7 @@ public JavaAnnotationTestBuilder addProperty(String key, Object value) {
         return this;
     }
 
-    public JavaAnnotation<?> build(JavaClass owner, ClassesByTypeName byTypeName) {
-        return delegate.build(owner, byTypeName);
+    public JavaAnnotation<?> build(JavaClass owner, ImportContext importContext) {
+        return delegate.build(owner, importContext);
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/simpleimport/AnnotationToImport.java
Patch:
@@ -10,5 +10,5 @@
 
     EnumToImport someEnumMethod() default EnumToImport.SECOND;
 
-    Deprecated someAnnotationMethod() default @Deprecated;
+    AnnotationParameter someAnnotationMethod() default @AnnotationParameter;
 }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -100,6 +100,7 @@ public void visit(int version, int access, String name, String signature, String
         LOG.trace("Found interfaces {} on class '{}'", interfaceNames, name);
         boolean opCodeForInterfaceIsPresent = (access & Opcodes.ACC_INTERFACE) != 0;
         boolean opCodeForEnumIsPresent = (access & Opcodes.ACC_ENUM) != 0;
+        boolean opCodeForAnnotationIsPresent = (access & Opcodes.ACC_ANNOTATION) != 0;
         Optional<String> superClassName = getSuperClassName(superName, opCodeForInterfaceIsPresent);
         LOG.trace("Found superclass {} on class '{}'", superClassName.orNull(), name);
 
@@ -108,6 +109,7 @@ public void visit(int version, int access, String name, String signature, String
                 .withDescriptor(descriptor)
                 .withInterface(opCodeForInterfaceIsPresent)
                 .withEnum(opCodeForEnumIsPresent)
+                .withAnnotation(opCodeForAnnotationIsPresent)
                 .withModifiers(JavaModifier.getModifiersForClass(access));
 
         className = descriptor.getFullyQualifiedClassName();

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -100,6 +100,7 @@ public void visit(int version, int access, String name, String signature, String
         LOG.trace("Found interfaces {} on class '{}'", interfaceNames, name);
         boolean opCodeForInterfaceIsPresent = (access & Opcodes.ACC_INTERFACE) != 0;
         boolean opCodeForEnumIsPresent = (access & Opcodes.ACC_ENUM) != 0;
+        boolean opCodeForAnnotationIsPresent = (access & Opcodes.ACC_ANNOTATION) != 0;
         Optional<String> superClassName = getSuperClassName(superName, opCodeForInterfaceIsPresent);
         LOG.trace("Found superclass {} on class '{}'", superClassName.orNull(), name);
 
@@ -108,6 +109,7 @@ public void visit(int version, int access, String name, String signature, String
                 .withDescriptor(descriptor)
                 .withInterface(opCodeForInterfaceIsPresent)
                 .withEnum(opCodeForEnumIsPresent)
+                .withAnnotation(opCodeForAnnotationIsPresent)
                 .withModifiers(JavaModifier.getModifiersForClass(access));
 
         className = descriptor.getFullyQualifiedClassName();

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -64,5 +64,7 @@ public interface ImportContext {
 
     Set<JavaAnnotation<?>> getAnnotationsWithParameterOfType(JavaClass javaClass);
 
+    Set<InstanceofCheck> getInstanceofChecksOfType(JavaClass javaClass);
+
     JavaClass resolveClass(String fullyQualifiedClassName);
 }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Dependency.java
Patch:
@@ -140,7 +140,8 @@ private static Optional<Dependency> tryCreateDependency(
         String targetDescription = bracketFormat(targetClass.getName());
         String dependencyDescription = originDescription + " " + dependencyType + " " + targetDescription;
         String description = dependencyDescription + " in " + originClass.getSourceCodeLocation();
-        return Optional.of(new Dependency(originClass, targetClass, 0, description));
+        int lineNumber = originClass.getSourceCodeLocation().getLineNumber();
+        return Optional.of(new Dependency(originClass, targetClass, lineNumber, description));
     }
 
     private static String bracketFormat(String name) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AnnotationPropertiesFormatter.java
Patch:
@@ -134,7 +134,7 @@ public String apply(String input) {
 
         /**
          * Configures that the identifier is omitted if the annotation is a
-         * <a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-9.html#jls-9.7.3">single-element annotation</a>
+         * <a href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.7.3">single-element annotation</a>
          * and the identifier of the only element is "value".
          *
          * <ul><li>Example with this configuration: {@code @Copyright("2020 Acme Corporation")}</li>

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AnnotationProxy.java
Patch:
@@ -120,7 +120,7 @@ private JavaClassConversion(ClassLoader classLoader) {
 
         @Override
         public Class<?> convert(JavaClass input, Class<?> returnType) {
-            return JavaType.From.javaClass(input).resolveClass(classLoader);
+            return JavaClassDescriptor.From.javaClass(input).resolveClass(classLoader);
         }
 
         @Override
@@ -150,7 +150,7 @@ public boolean canHandle(Class<?> returnType) {
     private static class JavaEnumConstantConversion implements Conversion<JavaEnumConstant> {
         @Override
         public Enum<?> convert(JavaEnumConstant input, Class<?> returnType) {
-            for (Object constant : JavaType.From.javaClass(input.getDeclaringClass()).resolveClass().getEnumConstants()) {
+            for (Object constant : JavaClassDescriptor.From.javaClass(input.getDeclaringClass()).resolveClass().getEnumConstants()) {
                 Enum<?> anEnum = (Enum<?>) constant;
                 if (anEnum.name().equals(input.name())) {
                     return anEnum;
@@ -196,7 +196,7 @@ public Annotation convert(JavaAnnotation<?> input, Class<?> returnType) {
             // JavaAnnotation.getType() will return the type name of a Class<? extends Annotation>
             @SuppressWarnings("unchecked")
             Class<? extends Annotation> type = (Class<? extends Annotation>)
-                    JavaType.From.javaClass(input.getRawType()).resolveClass(classLoader);
+                    JavaClassDescriptor.From.javaClass(input.getRawType()).resolveClass(classLoader);
             return AnnotationProxy.of(type, input);
         }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.tngtech.archunit.core.domain;
 
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
@@ -27,6 +28,8 @@ public interface ImportContext {
 
     Set<JavaClass> createInterfaces(JavaClass owner);
 
+    List<JavaTypeVariable> createTypeParameters(JavaClass owner);
+
     Set<JavaField> createFields(JavaClass owner);
 
     Set<JavaMethod> createMethods(JavaClass owner);

File: archunit/src/main/java/com/tngtech/archunit/core/domain/SourceCodeLocation.java
Patch:
@@ -40,7 +40,6 @@
  */
 @PublicAPI(usage = ACCESS)
 public final class SourceCodeLocation {
-    private static final String LOCATION_TEMPLATE = "(%s:%d)";
 
     @PublicAPI(usage = ACCESS)
     public static SourceCodeLocation of(JavaClass sourceClass) {
@@ -57,7 +56,7 @@ private static String formatLocation(JavaClass sourceClass, int lineNumber) {
                 ? sourceClass.getSource().get().getFileName()
                 : Optional.<String>absent();
         String sourceFileName = recordedSourceFileName.isPresent() ? recordedSourceFileName.get() : guessSourceFileName(sourceClass);
-        return String.format(LOCATION_TEMPLATE, sourceFileName, lineNumber);
+        return "(" + sourceFileName + ":" + lineNumber + ")";
     }
 
     private static String guessSourceFileName(JavaClass location) {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/AccessTargetTest.java
Patch:
@@ -14,6 +14,7 @@
 import static com.tngtech.archunit.core.domain.TestUtils.simulateCall;
 import static com.tngtech.archunit.core.domain.TestUtils.withinImportedClasses;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
+import static com.tngtech.archunit.testutil.Assertions.assertThatType;
 
 public class AccessTargetTest {
     @Test
@@ -130,7 +131,7 @@ public void no_throws_clause_is_resolved() {
         assertThat(throwsClause).as("throws clause").isEmpty();
         assertThat(throwsClause.getTypes()).isEmpty();
         assertThat(throwsClause.getOwner()).isEqualTo(target);
-        assertThat(throwsClause.getDeclaringClass()).matches(Target.class);
+        assertThatType(throwsClause.getDeclaringClass()).matches(Target.class);
     }
 
     @Test
@@ -197,7 +198,7 @@ private void assertDeclarations(CodeUnitCallTarget target, Class<?>... exception
         ThrowsClause<CodeUnitCallTarget> throwsClause = target.getThrowsClause();
         assertThat(throwsClause.getTypes()).matches(exceptionTypes);
         for (ThrowsDeclaration<CodeUnitCallTarget> throwsDeclaration : throwsClause) {
-            assertThat(throwsDeclaration.getDeclaringClass()).isEqualTo(target.getOwner());
+            assertThatType(throwsDeclaration.getDeclaringClass()).isEqualTo(target.getOwner());
             assertThat(throwsDeclaration.getOwner()).isEqualTo(target.getThrowsClause());
             assertThat(throwsDeclaration.getLocation()).isEqualTo(target);
         }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/AnnotationProxyTest.java
Patch:
@@ -241,7 +241,7 @@ public void wrong_annotation_type_is_rejected() {
     public void array_is_converted_to_the_correct_type() {
         ImportTestUtils.ImportedTestClasses importedClasses = simpleImportedClasses();
         JavaAnnotation<?> annotation = new JavaAnnotationTestBuilder()
-                .withType(JavaType.From.name(TestAnnotation.class.getName()))
+                .withType(JavaClassDescriptor.From.name(TestAnnotation.class.getName()))
                 .addProperty("types", new Object[0])
                 .addProperty("enumConstants", new Object[0])
                 .addProperty("subAnnotations", new Object[0])
@@ -333,9 +333,9 @@ public String toString() {
 
         Class<?> typeWithDefault() default Serializable.class;
 
-        Class[] types();
+        Class<?>[] types();
 
-        Class[] typesWithDefault() default {Serializable.class, String.class};
+        Class<?>[] typesWithDefault() default {Serializable.class, String.class};
 
         TestEnum enumConstant();
 

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassesTest.java
Patch:
@@ -12,7 +12,7 @@
 
 import static com.tngtech.archunit.core.domain.TestUtils.importClassWithContext;
 import static com.tngtech.archunit.core.domain.TestUtils.importClassesWithContext;
-import static com.tngtech.archunit.testutil.Assertions.assertThatClasses;
+import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
 import static java.util.Collections.singletonList;
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -37,7 +37,7 @@ public void restriction_on_classes_should_keep_the_original_package_tree() {
 
         JavaPackage javaPackage = restrictedClasses.getPackage(SomeClass.class.getPackage().getName());
 
-        assertThatClasses(javaPackage.getClasses()).contain(SomeOtherClass.class);
+        assertThatTypes(javaPackage.getClasses()).contain(SomeOtherClass.class);
     }
 
     @Test
@@ -136,4 +136,4 @@ private static class SomeClass {
 
     private static class SomeOtherClass {
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/core/domain/ThrowsClauseTest.java
Patch:
@@ -9,7 +9,7 @@
 
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.equivalentTo;
 import static com.tngtech.archunit.core.domain.TestUtils.importMethod;
-import static com.tngtech.archunit.testutil.Assertions.assertThatClasses;
+import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class ThrowsClauseTest {
@@ -32,7 +32,7 @@ public void size() {
     public void getTypes() {
         JavaMethod method = importMethod(SomeClass.class, "method");
 
-        assertThatClasses(method.getThrowsClause().getTypes()).matchInAnyOrder(IOException.class, SQLDataException.class);
+        assertThatTypes(method.getThrowsClause().getTypes()).matchInAnyOrder(IOException.class, SQLDataException.class);
     }
 
     private void assertAllTrue(Iterable<? extends AbstractBooleanAssert<?>> asserts) {
@@ -59,4 +59,4 @@ private static class SomeClass {
         void method() throws IOException, SQLDataException {
         }
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/core/importer/JavaAnnotationTestBuilder.java
Patch:
@@ -2,14 +2,14 @@
 
 import com.tngtech.archunit.core.domain.JavaAnnotation;
 import com.tngtech.archunit.core.domain.JavaClass;
-import com.tngtech.archunit.core.domain.JavaType;
+import com.tngtech.archunit.core.domain.JavaClassDescriptor;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaAnnotationBuilder;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaAnnotationBuilder.ValueBuilder;
 
 public class JavaAnnotationTestBuilder {
     private final JavaAnnotationBuilder delegate = new JavaAnnotationBuilder();
 
-    public JavaAnnotationTestBuilder withType(JavaType type) {
+    public JavaAnnotationTestBuilder withType(JavaClassDescriptor type) {
         delegate.withType(type);
         return this;
     }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaCodeUnitAssertion.java
Patch:
@@ -6,6 +6,7 @@
 import com.tngtech.archunit.core.domain.JavaCodeUnit;
 
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
+import static com.tngtech.archunit.testutil.Assertions.assertThatType;
 
 public class JavaCodeUnitAssertion<T extends JavaCodeUnit, SELF extends JavaCodeUnitAssertion<T, SELF>>
         extends JavaMemberAssertion<T, SELF> {
@@ -17,12 +18,12 @@ public JavaCodeUnitAssertion(T javaMember, Class<SELF> selfType) {
     public void isEquivalentTo(Method method) {
         super.isEquivalentTo(method);
         assertThat(actual.getRawParameterTypes()).matches(method.getParameterTypes());
-        assertThat(actual.getRawReturnType()).matches(method.getReturnType());
+        assertThatType(actual.getRawReturnType()).matches(method.getReturnType());
     }
 
     public void isEquivalentTo(Constructor<?> constructor) {
         super.isEquivalentTo(constructor);
         assertThat(actual.getRawParameterTypes()).matches(constructor.getParameterTypes());
-        assertThat(actual.getRawReturnType()).matches(void.class);
+        assertThatType(actual.getRawReturnType()).matches(void.class);
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaConstructorAssertion.java
Patch:
@@ -7,6 +7,7 @@
 
 import static com.tngtech.archunit.core.domain.JavaConstructor.CONSTRUCTOR_NAME;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
+import static com.tngtech.archunit.testutil.Assertions.assertThatType;
 import static com.tngtech.archunit.testutil.assertion.JavaMemberAssertion.getExpectedNameOf;
 
 public class JavaConstructorAssertion extends AbstractObjectAssert<JavaConstructorAssertion, JavaConstructor> {
@@ -19,6 +20,6 @@ public void isEquivalentTo(Constructor<?> constructor) {
         assertThat(actual.getName()).isEqualTo(CONSTRUCTOR_NAME);
         assertThat(actual.getFullName()).isEqualTo(getExpectedNameOf(constructor, CONSTRUCTOR_NAME));
         assertThat(actual.getRawParameterTypes()).matches(constructor.getParameterTypes());
-        assertThat(actual.getRawReturnType()).matches(void.class);
+        assertThatType(actual.getRawReturnType()).matches(void.class);
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaFieldAssertion.java
Patch:
@@ -4,7 +4,7 @@
 
 import com.tngtech.archunit.core.domain.JavaField;
 
-import static com.tngtech.archunit.testutil.Assertions.assertThat;
+import static com.tngtech.archunit.testutil.Assertions.assertThatType;
 
 public class JavaFieldAssertion extends JavaMemberAssertion<JavaField, JavaFieldAssertion> {
     public JavaFieldAssertion(JavaField javaField) {
@@ -13,6 +13,6 @@ public JavaFieldAssertion(JavaField javaField) {
 
     public void isEquivalentTo(Field field) {
         super.isEquivalentTo(field);
-        assertThat(actual.getRawType()).matches(field.getType());
+        assertThatType(actual.getRawType()).matches(field.getType());
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassDescriptor.java
Patch:
@@ -134,7 +134,7 @@ private static String createObjectComponentType(String componentTypeName) {
             return "L" + componentTypeName + ";";
         }
 
-        static JavaClassDescriptor javaClass(JavaClass javaClass) {
+        public static JavaClassDescriptor javaClass(JavaClass javaClass) {
             return name(javaClass.getName());
         }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaType.java
Patch:
@@ -30,6 +30,9 @@ public interface JavaType extends HasName {
      *     <li>the class itself, if this type is a {@link JavaClass}</li>
      *     <li>the {@link JavaClass} equivalent to {@link Object}, if this type is an unbound {@link JavaTypeVariable}</li>
      *     <li>the {@link JavaClass} equivalent to the erasure of the left most bound, if this type is a bound {@link JavaTypeVariable}</li>
+     *     <li>if this type is a {@link JavaGenericArrayType}, the erasure will be the {@link JavaClass}
+     *     equivalent to the array type that has the erasure of the generic component type of this type as its component type;
+     *     e.g. take the generic array type {@code T[][]} where {@code T} is unbound, then the erasure will be the array type {@code Object[][]}</li>
      * </ul>
      */
     @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileProcessor.java
Patch:
@@ -17,14 +17,14 @@
 
 import java.io.InputStream;
 import java.net.URI;
-import java.util.List;
 import java.util.Set;
 
 import com.tngtech.archunit.ArchConfiguration;
 import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.domain.JavaFieldAccess.AccessType;
+import com.tngtech.archunit.core.importer.DomainBuilders.TypeParametersBuilder;
 import com.tngtech.archunit.core.importer.JavaClassProcessor.AccessHandler;
 import com.tngtech.archunit.core.importer.JavaClassProcessor.DeclarationHandler;
 import com.tngtech.archunit.core.importer.RawAccessRecord.CodeUnit;
@@ -88,8 +88,8 @@ public void onNewClass(String className, Optional<String> superClassName, Set<St
         }
 
         @Override
-        public void onDeclaredTypeParameters(List<DomainBuilders.JavaTypeVariableBuilder> typeVariableBuilders) {
-            importRecord.addTypeParameters(ownerName, typeVariableBuilders);
+        public void onDeclaredTypeParameters(TypeParametersBuilder typeParametersBuilder) {
+            importRecord.addTypeParameters(ownerName, typeParametersBuilder);
         }
 
         @Override

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -412,7 +412,7 @@ interface DeclarationHandler {
 
         void onNewClass(String className, Optional<String> superClassName, Set<String> interfaceNames);
 
-        void onDeclaredTypeParameters(List<DomainBuilders.JavaTypeVariableBuilder> typeVariableBuilders);
+        void onDeclaredTypeParameters(DomainBuilders.TypeParametersBuilder typeParametersBuilder);
 
         void onDeclaredField(DomainBuilders.JavaFieldBuilder fieldBuilder);
 

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaTypeVariableTest.java
Patch:
@@ -33,6 +33,7 @@ class ClassWithUnboundTypeParameter<T extends HashMap<Object, Object> & Serializ
         JavaTypeVariable type = new ClassFileImporter().importClass(ClassWithUnboundTypeParameter.class).getTypeParameters().get(0);
 
         assertThatTypes(type.getBounds()).matchExactly(HashMap.class, Serializable.class);
+        assertThatTypes(type.getUpperBounds()).matchExactly(HashMap.class, Serializable.class);
     }
 
     @Test

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaTypeVariableTest.java
Patch:
@@ -33,7 +33,6 @@ class ClassWithUnboundTypeParameter<T extends HashMap<Object, Object> & Serializ
         JavaTypeVariable type = new ClassFileImporter().importClass(ClassWithUnboundTypeParameter.class).getTypeParameters().get(0);
 
         assertThatTypes(type.getBounds()).matchExactly(HashMap.class, Serializable.class);
-        assertThatTypes(type.getUpperBounds()).matchExactly(HashMap.class, Serializable.class);
     }
 
     @Test

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.tngtech.archunit.core.domain;
 
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
@@ -27,6 +28,8 @@ public interface ImportContext {
 
     Set<JavaClass> createInterfaces(JavaClass owner);
 
+    List<JavaTypeVariable> createTypeParameters(JavaClass owner);
+
     Set<JavaField> createFields(JavaClass owner);
 
     Set<JavaMethod> createMethods(JavaClass owner);

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -1225,7 +1225,7 @@ public static List<String> namesOf(Class<?>... paramTypes) {
     }
 
     @PublicAPI(usage = ACCESS)
-    public static List<String> namesOf(List<Class<?>> paramTypes) {
+    public static List<String> namesOf(Iterable<Class<?>> paramTypes) {
         ArrayList<String> result = new ArrayList<>();
         for (Class<?> paramType : paramTypes) {
             result.add(paramType.getName());

File: archunit/src/test/java/com/tngtech/archunit/core/domain/AccessTargetTest.java
Patch:
@@ -14,6 +14,7 @@
 import static com.tngtech.archunit.core.domain.TestUtils.simulateCall;
 import static com.tngtech.archunit.core.domain.TestUtils.withinImportedClasses;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
+import static com.tngtech.archunit.testutil.Assertions.assertThatType;
 
 public class AccessTargetTest {
     @Test
@@ -130,7 +131,7 @@ public void no_throws_clause_is_resolved() {
         assertThat(throwsClause).as("throws clause").isEmpty();
         assertThat(throwsClause.getTypes()).isEmpty();
         assertThat(throwsClause.getOwner()).isEqualTo(target);
-        assertThat(throwsClause.getDeclaringClass()).matches(Target.class);
+        assertThatType(throwsClause.getDeclaringClass()).matches(Target.class);
     }
 
     @Test
@@ -197,7 +198,7 @@ private void assertDeclarations(CodeUnitCallTarget target, Class<?>... exception
         ThrowsClause<CodeUnitCallTarget> throwsClause = target.getThrowsClause();
         assertThat(throwsClause.getTypes()).matches(exceptionTypes);
         for (ThrowsDeclaration<CodeUnitCallTarget> throwsDeclaration : throwsClause) {
-            assertThat(throwsDeclaration.getDeclaringClass()).isEqualTo(target.getOwner());
+            assertThatType(throwsDeclaration.getDeclaringClass()).isEqualTo(target.getOwner());
             assertThat(throwsDeclaration.getOwner()).isEqualTo(target.getThrowsClause());
             assertThat(throwsDeclaration.getLocation()).isEqualTo(target);
         }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassesTest.java
Patch:
@@ -12,7 +12,7 @@
 
 import static com.tngtech.archunit.core.domain.TestUtils.importClassWithContext;
 import static com.tngtech.archunit.core.domain.TestUtils.importClassesWithContext;
-import static com.tngtech.archunit.testutil.Assertions.assertThatClasses;
+import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
 import static java.util.Collections.singletonList;
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -37,7 +37,7 @@ public void restriction_on_classes_should_keep_the_original_package_tree() {
 
         JavaPackage javaPackage = restrictedClasses.getPackage(SomeClass.class.getPackage().getName());
 
-        assertThatClasses(javaPackage.getClasses()).contain(SomeOtherClass.class);
+        assertThatTypes(javaPackage.getClasses()).contain(SomeOtherClass.class);
     }
 
     @Test
@@ -136,4 +136,4 @@ private static class SomeClass {
 
     private static class SomeOtherClass {
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/core/domain/ThrowsClauseTest.java
Patch:
@@ -9,7 +9,7 @@
 
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.equivalentTo;
 import static com.tngtech.archunit.core.domain.TestUtils.importMethod;
-import static com.tngtech.archunit.testutil.Assertions.assertThatClasses;
+import static com.tngtech.archunit.testutil.Assertions.assertThatTypes;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class ThrowsClauseTest {
@@ -32,7 +32,7 @@ public void size() {
     public void getTypes() {
         JavaMethod method = importMethod(SomeClass.class, "method");
 
-        assertThatClasses(method.getThrowsClause().getTypes()).matchInAnyOrder(IOException.class, SQLDataException.class);
+        assertThatTypes(method.getThrowsClause().getTypes()).matchInAnyOrder(IOException.class, SQLDataException.class);
     }
 
     private void assertAllTrue(Iterable<? extends AbstractBooleanAssert<?>> asserts) {
@@ -59,4 +59,4 @@ private static class SomeClass {
         void method() throws IOException, SQLDataException {
         }
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaCodeUnitAssertion.java
Patch:
@@ -6,6 +6,7 @@
 import com.tngtech.archunit.core.domain.JavaCodeUnit;
 
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
+import static com.tngtech.archunit.testutil.Assertions.assertThatType;
 
 public class JavaCodeUnitAssertion<T extends JavaCodeUnit, SELF extends JavaCodeUnitAssertion<T, SELF>>
         extends JavaMemberAssertion<T, SELF> {
@@ -17,12 +18,12 @@ public JavaCodeUnitAssertion(T javaMember, Class<SELF> selfType) {
     public void isEquivalentTo(Method method) {
         super.isEquivalentTo(method);
         assertThat(actual.getRawParameterTypes()).matches(method.getParameterTypes());
-        assertThat(actual.getRawReturnType()).matches(method.getReturnType());
+        assertThatType(actual.getRawReturnType()).matches(method.getReturnType());
     }
 
     public void isEquivalentTo(Constructor<?> constructor) {
         super.isEquivalentTo(constructor);
         assertThat(actual.getRawParameterTypes()).matches(constructor.getParameterTypes());
-        assertThat(actual.getRawReturnType()).matches(void.class);
+        assertThatType(actual.getRawReturnType()).matches(void.class);
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaConstructorAssertion.java
Patch:
@@ -7,6 +7,7 @@
 
 import static com.tngtech.archunit.core.domain.JavaConstructor.CONSTRUCTOR_NAME;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
+import static com.tngtech.archunit.testutil.Assertions.assertThatType;
 import static com.tngtech.archunit.testutil.assertion.JavaMemberAssertion.getExpectedNameOf;
 
 public class JavaConstructorAssertion extends AbstractObjectAssert<JavaConstructorAssertion, JavaConstructor> {
@@ -19,6 +20,6 @@ public void isEquivalentTo(Constructor<?> constructor) {
         assertThat(actual.getName()).isEqualTo(CONSTRUCTOR_NAME);
         assertThat(actual.getFullName()).isEqualTo(getExpectedNameOf(constructor, CONSTRUCTOR_NAME));
         assertThat(actual.getRawParameterTypes()).matches(constructor.getParameterTypes());
-        assertThat(actual.getRawReturnType()).matches(void.class);
+        assertThatType(actual.getRawReturnType()).matches(void.class);
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaFieldAssertion.java
Patch:
@@ -4,7 +4,7 @@
 
 import com.tngtech.archunit.core.domain.JavaField;
 
-import static com.tngtech.archunit.testutil.Assertions.assertThat;
+import static com.tngtech.archunit.testutil.Assertions.assertThatType;
 
 public class JavaFieldAssertion extends JavaMemberAssertion<JavaField, JavaFieldAssertion> {
     public JavaFieldAssertion(JavaField javaField) {
@@ -13,6 +13,6 @@ public JavaFieldAssertion(JavaField javaField) {
 
     public void isEquivalentTo(Field field) {
         super.isEquivalentTo(field);
-        assertThat(actual.getRawType()).matches(field.getType());
+        assertThatType(actual.getRawType()).matches(field.getType());
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -61,7 +61,7 @@
 import static java.util.Collections.emptyMap;
 import static java.util.Collections.emptySet;
 
-public class JavaClass implements HasName.AndFullName, HasAnnotations<JavaClass>, HasModifiers, HasSourceCodeLocation {
+public class JavaClass implements JavaType, HasName.AndFullName, HasAnnotations<JavaClass>, HasModifiers, HasSourceCodeLocation {
     private final Optional<Source> source;
     private final SourceCodeLocation sourceCodeLocation;
     private final JavaClassDescriptor descriptor;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AnnotationProxy.java
Patch:
@@ -120,7 +120,7 @@ private JavaClassConversion(ClassLoader classLoader) {
 
         @Override
         public Class<?> convert(JavaClass input, Class<?> returnType) {
-            return JavaType.From.javaClass(input).resolveClass(classLoader);
+            return JavaClassDescriptor.From.javaClass(input).resolveClass(classLoader);
         }
 
         @Override
@@ -150,7 +150,7 @@ public boolean canHandle(Class<?> returnType) {
     private static class JavaEnumConstantConversion implements Conversion<JavaEnumConstant> {
         @Override
         public Enum<?> convert(JavaEnumConstant input, Class<?> returnType) {
-            for (Object constant : JavaType.From.javaClass(input.getDeclaringClass()).resolveClass().getEnumConstants()) {
+            for (Object constant : JavaClassDescriptor.From.javaClass(input.getDeclaringClass()).resolveClass().getEnumConstants()) {
                 Enum<?> anEnum = (Enum<?>) constant;
                 if (anEnum.name().equals(input.name())) {
                     return anEnum;
@@ -196,7 +196,7 @@ public Annotation convert(JavaAnnotation<?> input, Class<?> returnType) {
             // JavaAnnotation.getType() will return the type name of a Class<? extends Annotation>
             @SuppressWarnings("unchecked")
             Class<? extends Annotation> type = (Class<? extends Annotation>)
-                    JavaType.From.javaClass(input.getRawType()).resolveClass(classLoader);
+                    JavaClassDescriptor.From.javaClass(input.getRawType()).resolveClass(classLoader);
             return AnnotationProxy.of(type, input);
         }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -113,7 +113,7 @@ JavaClasses complete() {
 
     private void ensureCallTargetsArePresent() {
         for (RawAccessRecord record : importRecord.getAccessRecords()) {
-            classes.ensurePresent(record.target.owner.getName());
+            classes.ensurePresent(record.target.owner.getFullyQualifiedClassName());
         }
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/domain/AnnotationProxyTest.java
Patch:
@@ -241,7 +241,7 @@ public void wrong_annotation_type_is_rejected() {
     public void array_is_converted_to_the_correct_type() {
         ImportTestUtils.ImportedTestClasses importedClasses = simpleImportedClasses();
         JavaAnnotation<?> annotation = new JavaAnnotationTestBuilder()
-                .withType(JavaType.From.name(TestAnnotation.class.getName()))
+                .withType(JavaClassDescriptor.From.name(TestAnnotation.class.getName()))
                 .addProperty("types", new Object[0])
                 .addProperty("enumConstants", new Object[0])
                 .addProperty("subAnnotations", new Object[0])
@@ -333,9 +333,9 @@ public String toString() {
 
         Class<?> typeWithDefault() default Serializable.class;
 
-        Class[] types();
+        Class<?>[] types();
 
-        Class[] typesWithDefault() default {Serializable.class, String.class};
+        Class<?>[] typesWithDefault() default {Serializable.class, String.class};
 
         TestEnum enumConstant();
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/JavaAnnotationTestBuilder.java
Patch:
@@ -2,14 +2,14 @@
 
 import com.tngtech.archunit.core.domain.JavaAnnotation;
 import com.tngtech.archunit.core.domain.JavaClass;
-import com.tngtech.archunit.core.domain.JavaType;
+import com.tngtech.archunit.core.domain.JavaClassDescriptor;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaAnnotationBuilder;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaAnnotationBuilder.ValueBuilder;
 
 public class JavaAnnotationTestBuilder {
     private final JavaAnnotationBuilder delegate = new JavaAnnotationBuilder();
 
-    public JavaAnnotationTestBuilder withType(JavaType type) {
+    public JavaAnnotationTestBuilder withType(JavaClassDescriptor type) {
         delegate.withType(type);
         return this;
     }

File: archunit/src/main/java/com/tngtech/archunit/lang/FailureMessages.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.tngtech.archunit.lang;
 
-import java.util.Collection;
 import java.util.List;
 
 import com.google.common.base.Predicate;
@@ -31,8 +30,8 @@ public class FailureMessages extends ForwardingList<String> {
     private final List<String> failures;
     private final Optional<String> informationAboutNumberOfViolations;
 
-    FailureMessages(Collection<String> failures, Optional<String> informationAboutNumberOfViolations) {
-        this.failures = ImmutableList.copyOf(failures);
+    FailureMessages(ImmutableList<String> failures, Optional<String> informationAboutNumberOfViolations) {
+        this.failures = failures;
         this.informationAboutNumberOfViolations = informationAboutNumberOfViolations;
     }
 

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceCycleArchCondition.java
Patch:
@@ -218,7 +218,7 @@ private String createDescription(Collection<String> edgeDescriptions) {
         private String createDetails(Map<String, Edge<Slice, Dependency>> descriptionsToEdges) {
             List<String> details = new ArrayList<>();
             for (Map.Entry<String, Edge<Slice, Dependency>> edgeWithDescription : descriptionsToEdges.entrySet()) {
-                details.add(String.format("Dependencies of %s", edgeWithDescription.getKey()));
+                details.add("Dependencies of " + edgeWithDescription.getKey());
                 details.addAll(dependenciesDescription(edgeWithDescription.getValue()));
             }
             return Joiner.on(System.lineSeparator()).join(details);

File: archunit/src/test/java/com/tngtech/archunit/ArchConfigurationTest.java
Patch:
@@ -231,7 +231,7 @@ public void allows_to_override_any_property_via_system_property() {
 
         assertThat(configuration.md5InClassSourcesEnabled()).as("MD5 sum in class sources enabled").isTrue();
         assertThat(configuration.getProperty(customPropertyName)).as("custom property").isEqualTo("changed");
-        assertThat(configuration.getSubProperties(subPropertyKeyOf(customPropertyName))).containsExactly(
+        assertThat(configuration.getSubProperties(subPropertyKeyOf(customPropertyName))).containsOnly(
                 entry(subPropertyNameOf(customPropertyName), "changed"),
                 entry(subPropertyNameOf(otherPropertyName), "other"));
     }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/UrlSourceTest.java
Patch:
@@ -80,6 +80,7 @@ public void ignores_invalid_paths_in_class_path_property() {
         String classPath = createClassPathProperty(valid.toString(),
                 "/invalid/path/because/of/" + CHARACTER_THAT_IS_HOPEFULLY_ILLEGAL_ON_EVERY_PLATFORM + "/");
         System.setProperty(JAVA_CLASS_PATH_PROP, classPath);
+        System.clearProperty(JAVA_BOOT_PATH_PROP);
 
         assertThat(UrlSource.From.classPathSystemProperties()).containsOnly(toUrl(valid));
     }
@@ -142,6 +143,7 @@ public void terminates_recursively_resolving_manifest_classpaths_if_manifests_ha
                 .create(jarTwoPath);
 
         System.setProperty(JAVA_CLASS_PATH_PROP, jarOne.getName());
+        System.clearProperty(JAVA_BOOT_PATH_PROP);
         UrlSource urls = UrlSource.From.classPathSystemProperties();
 
         assertThat(urls).containsOnly(toUrl(Paths.get(jarOne.getName())), toUrl(Paths.get(jarTwo.getName())));

File: archunit/src/test/java/com/tngtech/archunit/testutil/syntax/MethodCallChain.java
Patch:
@@ -18,7 +18,7 @@ class MethodCallChain {
     MethodCallChain(MethodChoiceStrategy methodChoiceStrategy, TypedValue typedValue) {
         this.methodChoiceStrategy = checkNotNull(methodChoiceStrategy);
         currentValue = checkNotNull(typedValue);
-        nextMethodCandidate = methodChoiceStrategy.choose(typedValue.getType());
+        nextMethodCandidate = methodChoiceStrategy.choose(typedValue.getType(), false);
     }
 
     TypedValue getCurrentValue() {
@@ -33,11 +33,11 @@ boolean hasAnotherMethodCandidate() {
         return nextMethodCandidate.isPresent();
     }
 
-    void invokeNextMethodCandidate(Parameters parameters) {
+    void invokeNextMethodCandidate(Parameters parameters, boolean tryToTerminate) {
         PropagatedType nextType = currentValue.resolveType(nextMethodCandidate.get().getGenericReturnType());
         Object nextValue = invoke(nextMethodCandidate.get(), currentValue.getValue(), parameters.getValues());
         currentValue = validate(new TypedValue(nextType, nextValue));
-        nextMethodCandidate = methodChoiceStrategy.choose(currentValue.getType());
+        nextMethodCandidate = methodChoiceStrategy.choose(currentValue.getType(), tryToTerminate);
     }
 
     private TypedValue validate(TypedValue value) {

File: archunit/src/test/java/com/tngtech/archunit/testutil/syntax/MethodCallChainTest.java
Patch:
@@ -115,7 +115,7 @@ private <T> MethodCallChain createCallChainStart(Class<T> startInterface, T star
     }
 
     private void invokeNext(MethodCallChain callChain) {
-        callChain.invokeNextMethodCandidate(new Parameters(Collections.<Parameter>emptyList()));
+        callChain.invokeNextMethodCandidate(new Parameters(Collections.<Parameter>emptyList()), false);
     }
 
     private static class CallChainTestCase<T> {

File: archunit/src/test/java/com/tngtech/archunit/testutil/syntax/MethodCallChain.java
Patch:
@@ -18,7 +18,7 @@ class MethodCallChain {
     MethodCallChain(MethodChoiceStrategy methodChoiceStrategy, TypedValue typedValue) {
         this.methodChoiceStrategy = checkNotNull(methodChoiceStrategy);
         currentValue = checkNotNull(typedValue);
-        nextMethodCandidate = methodChoiceStrategy.choose(typedValue.getType());
+        nextMethodCandidate = methodChoiceStrategy.choose(typedValue.getType(), false);
     }
 
     TypedValue getCurrentValue() {
@@ -33,11 +33,11 @@ boolean hasAnotherMethodCandidate() {
         return nextMethodCandidate.isPresent();
     }
 
-    void invokeNextMethodCandidate(Parameters parameters) {
+    void invokeNextMethodCandidate(Parameters parameters, boolean tryToTerminate) {
         PropagatedType nextType = currentValue.resolveType(nextMethodCandidate.get().getGenericReturnType());
         Object nextValue = invoke(nextMethodCandidate.get(), currentValue.getValue(), parameters.getValues());
         currentValue = validate(new TypedValue(nextType, nextValue));
-        nextMethodCandidate = methodChoiceStrategy.choose(currentValue.getType());
+        nextMethodCandidate = methodChoiceStrategy.choose(currentValue.getType(), tryToTerminate);
     }
 
     private TypedValue validate(TypedValue value) {

File: archunit/src/test/java/com/tngtech/archunit/testutil/syntax/MethodCallChainTest.java
Patch:
@@ -115,7 +115,7 @@ private <T> MethodCallChain createCallChainStart(Class<T> startInterface, T star
     }
 
     private void invokeNext(MethodCallChain callChain) {
-        callChain.invokeNextMethodCandidate(new Parameters(Collections.<Parameter>emptyList()));
+        callChain.invokeNextMethodCandidate(new Parameters(Collections.<Parameter>emptyList()), false);
     }
 
     private static class CallChainTestCase<T> {

File: archunit/src/main/java/com/tngtech/archunit/lang/FailureMessages.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.tngtech.archunit.lang;
 
-import java.util.Collection;
 import java.util.List;
 
 import com.google.common.base.Predicate;
@@ -31,8 +30,8 @@ public class FailureMessages extends ForwardingList<String> {
     private final List<String> failures;
     private final Optional<String> informationAboutNumberOfViolations;
 
-    FailureMessages(Collection<String> failures, Optional<String> informationAboutNumberOfViolations) {
-        this.failures = ImmutableList.copyOf(failures);
+    FailureMessages(ImmutableList<String> failures, Optional<String> informationAboutNumberOfViolations) {
+        this.failures = failures;
         this.informationAboutNumberOfViolations = informationAboutNumberOfViolations;
     }
 

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceCycleArchCondition.java
Patch:
@@ -218,7 +218,7 @@ private String createDescription(Collection<String> edgeDescriptions) {
         private String createDetails(Map<String, Edge<Slice, Dependency>> descriptionsToEdges) {
             List<String> details = new ArrayList<>();
             for (Map.Entry<String, Edge<Slice, Dependency>> edgeWithDescription : descriptionsToEdges.entrySet()) {
-                details.add(String.format("Dependencies of %s", edgeWithDescription.getKey()));
+                details.add("Dependencies of " + edgeWithDescription.getKey());
                 details.addAll(dependenciesDescription(edgeWithDescription.getValue()));
             }
             return Joiner.on(System.lineSeparator()).join(details);

File: archunit/src/test/java/com/tngtech/archunit/ArchConfigurationTest.java
Patch:
@@ -231,7 +231,7 @@ public void allows_to_override_any_property_via_system_property() {
 
         assertThat(configuration.md5InClassSourcesEnabled()).as("MD5 sum in class sources enabled").isTrue();
         assertThat(configuration.getProperty(customPropertyName)).as("custom property").isEqualTo("changed");
-        assertThat(configuration.getSubProperties(subPropertyKeyOf(customPropertyName))).containsExactly(
+        assertThat(configuration.getSubProperties(subPropertyKeyOf(customPropertyName))).containsOnly(
                 entry(subPropertyNameOf(customPropertyName), "changed"),
                 entry(subPropertyNameOf(otherPropertyName), "other"));
     }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/UrlSourceTest.java
Patch:
@@ -80,6 +80,7 @@ public void ignores_invalid_paths_in_class_path_property() {
         String classPath = createClassPathProperty(valid.toString(),
                 "/invalid/path/because/of/" + CHARACTER_THAT_IS_HOPEFULLY_ILLEGAL_ON_EVERY_PLATFORM + "/");
         System.setProperty(JAVA_CLASS_PATH_PROP, classPath);
+        System.clearProperty(JAVA_BOOT_PATH_PROP);
 
         assertThat(UrlSource.From.classPathSystemProperties()).containsOnly(toUrl(valid));
     }
@@ -142,6 +143,7 @@ public void terminates_recursively_resolving_manifest_classpaths_if_manifests_ha
                 .create(jarTwoPath);
 
         System.setProperty(JAVA_CLASS_PATH_PROP, jarOne.getName());
+        System.clearProperty(JAVA_BOOT_PATH_PROP);
         UrlSource urls = UrlSource.From.classPathSystemProperties();
 
         assertThat(urls).containsOnly(toUrl(Paths.get(jarOne.getName())), toUrl(Paths.get(jarTwo.getName())));

File: archunit/src/main/java/com/tngtech/archunit/core/PluginLoader.java
Patch:
@@ -134,7 +134,8 @@ public Creator<T> load(String pluginClassName) {
     @Internal
     public enum JavaVersion {
 
-        JAVA_9(9);
+        JAVA_9(9),
+        JAVA_14(14);
 
         private final int releaseVersion;
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/DomainPlugin.java
Patch:
@@ -19,6 +19,7 @@
 import com.tngtech.archunit.core.InitialConfiguration;
 import com.tngtech.archunit.core.PluginLoader;
 
+import static com.tngtech.archunit.core.PluginLoader.JavaVersion.JAVA_14;
 import static com.tngtech.archunit.core.PluginLoader.JavaVersion.JAVA_9;
 
 interface DomainPlugin {
@@ -29,6 +30,7 @@ class Loader {
         private static final PluginLoader<DomainPlugin> pluginLoader = PluginLoader
                 .forType(DomainPlugin.class)
                 .ifVersionGreaterOrEqualTo(JAVA_9).load("com.tngtech.archunit.core.domain.Java9DomainPlugin")
+                .ifVersionGreaterOrEqualTo(JAVA_14).load("com.tngtech.archunit.core.domain.Java14DomainPlugin")
                 .fallback(new LegacyDomainPlugin());
 
         static DomainPlugin loadForCurrentPlatform() {

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -70,6 +70,7 @@
 import static com.tngtech.archunit.core.domain.TestUtils.resolvedTargetFrom;
 import static com.tngtech.archunit.core.domain.TestUtils.targetFrom;
 import static com.tngtech.archunit.testutil.assertion.JavaAnnotationAssertion.propertiesOf;
+import static com.tngtech.archunit.testutil.assertion.JavaAnnotationAssertion.runtimePropertiesOf;
 import static com.tngtech.archunit.testutil.assertion.JavaPackagesAssertion.sortByName;
 
 public class Assertions extends org.assertj.core.api.Assertions {
@@ -327,7 +328,7 @@ public void matches(Class<?> clazz) {
             assertThat(actual.getModifiers()).as("Modifiers of " + actual)
                     .isEqualTo(JavaModifier.getModifiersForClass(clazz.getModifiers()));
             assertThat(actual.isArray()).as(actual + " is array").isEqualTo(clazz.isArray());
-            assertThat(propertiesOf(actual.getAnnotations())).as("Annotations of " + actual)
+            assertThat(runtimePropertiesOf(actual.getAnnotations())).as("Annotations of " + actual)
                     .isEqualTo(propertiesOf(clazz.getAnnotations()));
 
             if (clazz.isArray()) {

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaMembersAssertion.java
Patch:
@@ -30,6 +30,7 @@
 import static com.tngtech.archunit.core.domain.JavaModifier.VOLATILE;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 import static com.tngtech.archunit.testutil.assertion.JavaAnnotationAssertion.propertiesOf;
+import static com.tngtech.archunit.testutil.assertion.JavaAnnotationAssertion.runtimePropertiesOf;
 import static com.tngtech.archunit.testutil.assertion.JavaMemberAssertion.getExpectedFullNameOf;
 
 public class JavaMembersAssertion extends AbstractObjectAssert<JavaMembersAssertion, List<JavaMember>> {
@@ -89,7 +90,7 @@ private void matchCasted(Set<Member> members) {
     static <T extends Member & AnnotatedElement> void assertEquivalent(JavaMember javaMember, T member) {
         assertThat(javaMember.getOwner().reflect()).isEqualTo(member.getDeclaringClass());
         assertModifiersMatch(javaMember, member);
-        assertThat(propertiesOf(javaMember.getAnnotations()))
+        assertThat(runtimePropertiesOf(javaMember.getAnnotations()))
                 .isEqualTo(propertiesOf(member.getAnnotations()));
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/Location.java
Patch:
@@ -140,9 +140,9 @@ private String encodeIllegalCharacters(String relativeURI) {
     }
 
     void checkScheme(String scheme, NormalizedUri uri) {
-        checkArgument(scheme.equals(uri.getScheme()),
-                "URI %s of %s must have scheme %s, but has %s",
-                uri, getClass().getSimpleName(), scheme, uri.getScheme());
+        String actualScheme = uri.getScheme();
+        checkArgument(scheme.equals(actualScheme),
+                "URI %s of Location must have scheme %s, but has %s", uri, scheme, actualScheme);
     }
 
     /**

File: archunit/src/test/java/com/tngtech/archunit/core/importer/NormalizedResourceNameTest.java
Patch:
@@ -18,6 +18,7 @@ public static Object[][] resource_name_starts_with_cases() {
                 $("com", "com", true),
                 $("com/foo", "com", true),
                 $("/com/", "/com", true),
+                $("\\com\\foo", "/com/foo", true),
                 $("com", "bar", false),
                 $("com", "co", false),
                 $("co/m", "co", true),

File: archunit/src/test/java/com/tngtech/archunit/core/importer/NormalizedResourceNameTest.java
Patch:
@@ -18,6 +18,7 @@ public static Object[][] resource_name_starts_with_cases() {
                 $("com", "com", true),
                 $("com/foo", "com", true),
                 $("/com/", "/com", true),
+                $("\\com\\foo", "/com/foo", true),
                 $("com", "bar", false),
                 $("com", "co", false),
                 $("co/m", "co", true),

File: archunit/src/test/java/com/tngtech/archunit/testutil/ArchConfigurationRule.java
Patch:
@@ -4,7 +4,7 @@
 import org.junit.rules.ExternalResource;
 
 public class ArchConfigurationRule extends ExternalResource {
-    private boolean resolveMissingDependenciesFromClassPath;
+    private boolean resolveMissingDependenciesFromClassPath = ArchConfiguration.get().resolveMissingDependenciesFromClassPath();
 
     public ArchConfigurationRule resolveAdditionalDependenciesFromClassPath(boolean enabled) {
         resolveMissingDependenciesFromClassPath = enabled;

File: archunit/src/test/java/com/tngtech/archunit/testutil/ArchConfigurationRule.java
Patch:
@@ -4,7 +4,7 @@
 import org.junit.rules.ExternalResource;
 
 public class ArchConfigurationRule extends ExternalResource {
-    private boolean resolveMissingDependenciesFromClassPath;
+    private boolean resolveMissingDependenciesFromClassPath = ArchConfiguration.get().resolveMissingDependenciesFromClassPath();
 
     public ArchConfigurationRule resolveAdditionalDependenciesFromClassPath(boolean enabled) {
         resolveMissingDependenciesFromClassPath = enabled;

File: archunit/src/jdk9main/java/com/tngtech/archunit/core/importer/ModuleLocationFactory.java
Patch:
@@ -100,7 +100,7 @@ public boolean isArchive() {
         }
 
         @Override
-        Iterable<NormalizedResourceName> iterateEntries() {
+        Iterable<NormalizedResourceName> iterateEntriesInternal() {
             return doWithModuleReader(moduleReference, moduleReader -> moduleReader.list()
                     .filter(resourceName::isStartOf)
                     .map(NormalizedResourceName::from)

File: archunit/src/jdk9main/java/com/tngtech/archunit/core/importer/ModuleLocationFactory.java
Patch:
@@ -100,7 +100,7 @@ public boolean isArchive() {
         }
 
         @Override
-        Iterable<NormalizedResourceName> iterateEntries() {
+        Iterable<NormalizedResourceName> iterateEntriesInternal() {
             return doWithModuleReader(moduleReference, moduleReader -> moduleReader.list()
                     .filter(resourceName::isStartOf)
                     .map(NormalizedResourceName::from)

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/ClassResolver.java
Patch:
@@ -183,7 +183,7 @@ public Optional<JavaClass> tryResolve(String typeName) {
             }
         }
 
-        private abstract class ClassResolverProvider {
+        private abstract static class ClassResolverProvider {
             private final Function<Exception, ClassResolverConfigurationException> onFailure;
 
             ClassResolverProvider(Function<Exception, ClassResolverConfigurationException> onFailure) {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileImporter.java
Patch:
@@ -248,7 +248,7 @@ public JavaClasses importPackagesOf(Collection<Class<?>> classes) {
      */
     @PublicAPI(usage = ACCESS)
     public JavaClasses importClasspath() {
-        return importClasspath(new ImportOptions().with(ImportOption.Predefined.DO_NOT_INCLUDE_ARCHIVES));
+        return importClasspath(importOptions.with(ImportOption.Predefined.DO_NOT_INCLUDE_ARCHIVES));
     }
 
     /**

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileImporter.java
Patch:
@@ -248,7 +248,7 @@ public JavaClasses importPackagesOf(Collection<Class<?>> classes) {
      */
     @PublicAPI(usage = ACCESS)
     public JavaClasses importClasspath() {
-        return importClasspath(new ImportOptions().with(ImportOption.Predefined.DO_NOT_INCLUDE_ARCHIVES));
+        return importClasspath(importOptions.with(ImportOption.Predefined.DO_NOT_INCLUDE_ARCHIVES));
     }
 
     /**

File: archunit/src/test/java/com/tngtech/archunit/core/domain/packageexamples/annotated/package-info.java
Patch:
@@ -0,0 +1,2 @@
+@PackageLevelAnnotation
+package com.tngtech.archunit.core.domain.packageexamples.annotated;

File: archunit/src/main/java/com/tngtech/archunit/lang/ArchRule.java
Patch:
@@ -87,7 +87,9 @@ public static void assertNoViolation(EvaluationResult result) {
             FailureReport report = result.getFailureReport();
 
             Set<Pattern> patterns = readPatternsFrom(ARCHUNIT_IGNORE_PATTERNS_FILE_NAME);
-            report = report.filter(notMatchedByAny(patterns));
+            if (!patterns.isEmpty()) {
+                report = report.filter(notMatchedByAny(patterns));
+            }
             if (!report.isEmpty()) {
                 throw new AssertionError(report.toString());
             }

File: archunit/src/main/java/com/tngtech/archunit/lang/EvaluationResult.java
Patch:
@@ -59,7 +59,7 @@ public EvaluationResult(HasDescription rule, ConditionEvents events, Priority pr
 
     @PublicAPI(usage = ACCESS)
     public FailureReport getFailureReport() {
-        return new FailureReport(rule, priority, events.getFailureDescriptionLines());
+        return new FailureReport(rule, priority, events.getFailureMessages());
     }
 
     @PublicAPI(usage = ACCESS)

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/testexamples/completedependencygraph/ninenodes/CompleteNineNodesGraphRoot.java
Patch:
@@ -1,7 +1,7 @@
-package com.tngtech.archunit.library.dependencies.testexamples.completedependencygraph;
+package com.tngtech.archunit.library.dependencies.testexamples.completedependencygraph.ninenodes;
 
 /**
  * Marker class to find root package of slices resulting in a complete dependency graph.
  */
-public interface CompleteGraphRoot {
+public interface CompleteNineNodesGraphRoot {
 }

File: archunit/src/test/java/com/tngtech/archunit/testutil/ArchConfigurationRule.java
Patch:
@@ -12,7 +12,7 @@ public ArchConfigurationRule resolveAdditionalDependenciesFromClassPath(boolean
     }
 
     @Override
-    protected void before() throws Throwable {
+    protected void before() {
         ArchConfiguration.get().reset();
         ArchConfiguration.get().setResolveMissingDependenciesFromClassPath(resolveMissingDependenciesFromClassPath);
     }

File: archunit/src/main/java/com/tngtech/archunit/lang/ConfiguredMessageFormat.java
Patch:
@@ -18,6 +18,8 @@
 import com.google.common.base.Joiner;
 import com.tngtech.archunit.base.HasDescription;
 
+import static java.lang.System.lineSeparator;
+
 class ConfiguredMessageFormat {
     private static final ConfiguredMessageFormat instance = new ConfiguredMessageFormat();
 
@@ -26,7 +28,7 @@ static ConfiguredMessageFormat get() {
     }
 
     String formatFailure(HasDescription rule, FailureMessages failureMessages, Priority priority) {
-        String violationTexts = Joiner.on(System.lineSeparator()).join(failureMessages);
+        String violationTexts = Joiner.on(lineSeparator()).join(failureMessages);
         return String.format("Architecture Violation [Priority: %s] - Rule '%s' was violated (%s):%n%s",
                 priority.asString(), rule.getDescription(), failureMessages.getInformationAboutNumberOfViolations(), violationTexts);
     }

File: archunit/src/main/java/com/tngtech/archunit/lang/EvaluationResult.java
Patch:
@@ -59,7 +59,7 @@ public EvaluationResult(HasDescription rule, ConditionEvents events, Priority pr
 
     @PublicAPI(usage = ACCESS)
     public FailureReport getFailureReport() {
-        return new FailureReport(rule, priority, events.getFailureDescriptionLines());
+        return new FailureReport(rule, priority, events.getFailureMessages());
     }
 
     @PublicAPI(usage = ACCESS)

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/testexamples/completedependencygraph/ninenodes/CompleteNineNodesGraphRoot.java
Patch:
@@ -1,7 +1,7 @@
-package com.tngtech.archunit.library.dependencies.testexamples.completedependencygraph;
+package com.tngtech.archunit.library.dependencies.testexamples.completedependencygraph.ninenodes;
 
 /**
  * Marker class to find root package of slices resulting in a complete dependency graph.
  */
-public interface CompleteGraphRoot {
+public interface CompleteNineNodesGraphRoot {
 }

File: archunit/src/test/java/com/tngtech/archunit/testutil/ArchConfigurationRule.java
Patch:
@@ -12,7 +12,7 @@ public ArchConfigurationRule resolveAdditionalDependenciesFromClassPath(boolean
     }
 
     @Override
-    protected void before() throws Throwable {
+    protected void before() {
         ArchConfiguration.get().reset();
         ArchConfiguration.get().setResolveMissingDependenciesFromClassPath(resolveMissingDependenciesFromClassPath);
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaType.java
Patch:
@@ -74,9 +74,6 @@ public JavaType load(String typeName) {
                     //       i.e. [Ljava.lang.Object;
                     return new ArrayType(ensureCorrectArrayTypeName(typeName));
                 }
-                if (typeName.contains("/")) {
-                    return new ObjectType(Type.getType(typeName).getClassName());
-                }
                 return new ObjectType(typeName);
             }
         });

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileProcessor.java
Patch:
@@ -139,7 +139,7 @@ public void setLineNumber(int lineNumber) {
         @Override
         public void handleFieldInstruction(int opcode, String owner, String name, String desc) {
             AccessType accessType = AccessType.forOpCode(opcode);
-            LOG.debug("Found {} access to field {}.{}:{} in line {}", accessType, owner, name, desc, lineNumber);
+            LOG.trace("Found {} access to field {}.{}:{} in line {}", accessType, owner, name, desc, lineNumber);
             TargetInfo target = new RawAccessRecord.FieldTargetInfo(owner, name, desc);
             importRecord.registerFieldAccess(filled(new RawAccessRecord.ForField.Builder(), target)
                     .withAccessType(accessType)
@@ -148,7 +148,7 @@ public void handleFieldInstruction(int opcode, String owner, String name, String
 
         @Override
         public void handleMethodInstruction(String owner, String name, String desc) {
-            LOG.debug("Found call of method {}.{}:{} in line {}", owner, name, desc, lineNumber);
+            LOG.trace("Found call of method {}.{}:{} in line {}", owner, name, desc, lineNumber);
             if (CONSTRUCTOR_NAME.equals(name)) {
                 TargetInfo target = new ConstructorTargetInfo(owner, name, desc);
                 importRecord.registerConstructorCall(filled(new RawAccessRecord.Builder(), target).build());

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileProcessor.java
Patch:
@@ -139,7 +139,7 @@ public void setLineNumber(int lineNumber) {
         @Override
         public void handleFieldInstruction(int opcode, String owner, String name, String desc) {
             AccessType accessType = AccessType.forOpCode(opcode);
-            LOG.debug("Found {} access to field {}.{}:{} in line {}", accessType, owner, name, desc, lineNumber);
+            LOG.trace("Found {} access to field {}.{}:{} in line {}", accessType, owner, name, desc, lineNumber);
             TargetInfo target = new RawAccessRecord.FieldTargetInfo(owner, name, desc);
             importRecord.registerFieldAccess(filled(new RawAccessRecord.ForField.Builder(), target)
                     .withAccessType(accessType)
@@ -148,7 +148,7 @@ public void handleFieldInstruction(int opcode, String owner, String name, String
 
         @Override
         public void handleMethodInstruction(String owner, String name, String desc) {
-            LOG.debug("Found call of method {}.{}:{} in line {}", owner, name, desc, lineNumber);
+            LOG.trace("Found call of method {}.{}:{} in line {}", owner, name, desc, lineNumber);
             if (CONSTRUCTOR_NAME.equals(name)) {
                 TargetInfo target = new ConstructorTargetInfo(owner, name, desc);
                 importRecord.registerConstructorCall(filled(new RawAccessRecord.Builder(), target).build());

File: archunit/src/main/java/com/tngtech/archunit/library/Architectures.java
Patch:
@@ -175,7 +175,7 @@ public String getDescription() {
                 return overriddenDescription.get();
             }
 
-            List<String> lines = newArrayList("Layered architecture consisting of");
+            List<String> lines = newArrayList("Layered architecture consisting of" + (optionalLayers ? " (optional)" : ""));
             for (LayerDefinition definition : layerDefinitions) {
                 lines.add(definition.toString());
             }
@@ -538,7 +538,7 @@ public String getDescription() {
                 return overriddenDescription.get();
             }
 
-            List<String> lines = newArrayList("Onion architecture consisting of");
+            List<String> lines = newArrayList("Onion architecture consisting of" + (optionalLayers ? " (optional)" : ""));
             if (domainModelPackageIdentifiers.length > 0) {
                 lines.add(String.format("domain models ('%s')", Joiner.on("', '").join(domainModelPackageIdentifiers)));
             }

File: archunit/src/test/java/com/tngtech/archunit/library/ArchitecturesTest.java
Patch:
@@ -146,6 +146,7 @@ public void layered_architecture_rejects_empty_layers_by_default() {
     @Test
     public void layered_architecture_allows_empty_layers_if_all_layers_are_optional() {
         LayeredArchitecture architecture = aLayeredArchitectureWithEmptyLayers().withOptionalLayers(true);
+        assertThat(architecture.getDescription()).startsWith("Layered architecture consisting of (optional)");
 
         JavaClasses classes = new ClassFileImporter().importPackages(absolute(""));
 
@@ -357,6 +358,7 @@ public void onion_architecture_rejects_empty_layers_by_default() {
     @Test
     public void onion_architecture_allows_empty_layers_if_all_layers_are_optional() {
         OnionArchitecture architecture = anOnionArchitectureWithEmptyLayers().withOptionalLayers(true);
+        assertThat(architecture.getDescription()).startsWith("Onion architecture consisting of (optional)");
 
         JavaClasses classes = new ClassFileImporter().importPackages(absolute("onionarchitecture"));
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaModifier.java
Patch:
@@ -42,6 +42,8 @@ public enum JavaModifier {
     @PublicAPI(usage = ACCESS)
     TRANSIENT(EnumSet.of(ApplicableType.FIELD), Opcodes.ACC_TRANSIENT),
     @PublicAPI(usage = ACCESS)
+    ENUM(EnumSet.of(ApplicableType.FIELD), Opcodes.ACC_ENUM),
+    @PublicAPI(usage = ACCESS)
     ABSTRACT(EnumSet.of(ApplicableType.CLASS, ApplicableType.METHOD), Opcodes.ACC_ABSTRACT),
     @PublicAPI(usage = ACCESS)
     SYNCHRONIZED(EnumSet.of(ApplicableType.METHOD), Opcodes.ACC_SYNCHRONIZED),

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/ExamplesIntegrationTest.java
Patch:
@@ -797,6 +797,7 @@ Stream<DynamicTest> LayeredArchitectureTest() {
 
                                 .by(annotatedClass(ServiceViolatingLayerRules.class).withAnnotationParameterType(ComplexControllerAnnotation.class))
                                 .by(annotatedClass(ServiceViolatingLayerRules.class).withAnnotationParameterType(SimpleControllerAnnotation.class))
+                                .by(annotatedClass(ServiceViolatingLayerRules.class).withAnnotationParameterType(SomeEnum.class))
                                 .by(method(ComplexServiceAnnotation.class, "controllerAnnotation").withReturnType(ComplexControllerAnnotation.class))
                                 .by(method(ComplexServiceAnnotation.class, "controllerEnum").withReturnType(SomeEnum.class));
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/HandlingAssertion.java
Patch:
@@ -170,7 +170,7 @@ private Set<String> removeExpectedAccesses(Collection<?> violatingObjects, Set<?
                 return emptySet();
             }
         }
-        return singleton("Unexpected access: " + violatingObject);
+        return singleton("Unexpected violation handling: " + violatingObject);
     }
 
     private Set<String> errorMessagesFrom(Set<?> set) {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/TestUtils.java
Patch:
@@ -136,7 +136,7 @@ public static ConstructorCallTarget targetFrom(JavaConstructor constructor) {
     }
 
     public static Dependency dependencyFrom(JavaAccess<?> access) {
-        return Dependency.from(access);
+        return Dependency.tryCreateFromAccess(access).get();
     }
 
     public static class AccessesSimulator {

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/ExamplesIntegrationTest.java
Patch:
@@ -693,6 +693,7 @@ Stream<DynamicTest> LayerDependencyRulesTest() {
                 .by(method(ServiceViolatingLayerRules.class, dependentMethod).withReturnType(SomeGuiController.class))
                 .by(annotatedClass(ServiceViolatingLayerRules.class).withAnnotationParameterType(ComplexControllerAnnotation.class))
                 .by(annotatedClass(ServiceViolatingLayerRules.class).withAnnotationParameterType(SimpleControllerAnnotation.class))
+                .by(annotatedClass(ServiceViolatingLayerRules.class).withAnnotationParameterType(SomeEnum.class))
                 .by(method(ComplexServiceAnnotation.class, "controllerAnnotation").withReturnType(ComplexControllerAnnotation.class))
                 .by(method(ComplexServiceAnnotation.class, "controllerEnum").withReturnType(SomeEnum.class))
 
@@ -744,6 +745,7 @@ Stream<DynamicTest> LayerDependencyRulesTest() {
                 .by(annotatedClass(WronglyNamedSvc.class).annotatedWith(MyService.class))
                 .by(annotatedClass(ServiceViolatingLayerRules.class).withAnnotationParameterType(ComplexControllerAnnotation.class))
                 .by(annotatedClass(ServiceViolatingLayerRules.class).withAnnotationParameterType(SimpleControllerAnnotation.class))
+                .by(annotatedClass(ServiceViolatingLayerRules.class).withAnnotationParameterType(SomeEnum.class))
                 .by(method(ComplexServiceAnnotation.class, "controllerAnnotation").withReturnType(ComplexControllerAnnotation.class))
                 .by(method(ComplexServiceAnnotation.class, "controllerEnum").withReturnType(SomeEnum.class))
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassDependencies.java
Patch:
@@ -246,6 +246,9 @@ private Set<Dependency> annotationParameterDependencies(JavaAnnotation<?> origin
         if (value instanceof JavaClass) {
             JavaClass annotationMember = (JavaClass) value;
             result.add(Dependency.fromAnnotationMember(origin, annotationMember));
+        } else if (value instanceof JavaEnumConstant) {
+            JavaEnumConstant enumConstant = (JavaEnumConstant) value;
+            result.add(Dependency.fromAnnotationMember(origin, enumConstant.getDeclaringClass()));
         } else if (value instanceof JavaAnnotation<?>) {
             JavaAnnotation<?> nestedAnnotation = (JavaAnnotation<?>) value;
             result.add(Dependency.fromAnnotationMember(origin, nestedAnnotation.getRawType()));

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -145,8 +145,7 @@ private void completeMembers() {
 
     private void completeAnnotations() {
         for (JavaClass javaClass : classes.getAll().values()) {
-            // By invoking the .get method of the annotations supplier, annotations are registered into the ImportContext
-            javaClass.getAnnotations();
+            DomainObjectCreationContext.completeAnnotations(javaClass, this);
             for (JavaMember member : javaClass.getFields()) {
                 memberDependenciesByTarget.registerMemberAnnotations(member);
             }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -1039,7 +1039,6 @@ private <T extends HasDescription & HasAnnotations<?>> Set<Dependency> annotatio
         for (JavaAnnotation<?> annotation : annotated.getAnnotations()) {
             result.add(Dependency.fromAnnotation(annotation));
             result.addAll(annotationParametersDependencies(annotation));
-            result.addAll(annotationDependencies(annotation.getRawType()));
         }
         return result.build();
     }
@@ -1067,11 +1066,9 @@ private Set<Dependency> annotationParameterDependencies(JavaAnnotation<?> origin
         if (value instanceof JavaClass) {
             JavaClass annotationMember = (JavaClass) value;
             result.add(Dependency.fromAnnotationMember(origin, annotationMember));
-            result.addAll(annotationDependencies(annotationMember));
         } else if (value instanceof JavaAnnotation<?>) {
             JavaAnnotation<?> nestedAnnotation = (JavaAnnotation<?>) value;
             result.add(Dependency.fromAnnotationMember(origin, nestedAnnotation.getRawType()));
-            result.addAll(annotationDependencies(nestedAnnotation.getRawType()));
             result.addAll(annotationParametersDependencies(nestedAnnotation));
         }
         return result.build();

File: archunit/src/test/java/com/tngtech/archunit/core/domain/testobjects/AhavingMembersOfTypeB.java
Patch:
@@ -1,5 +1,7 @@
 package com.tngtech.archunit.core.domain.testobjects;
 
+@DomainAnnotation
+@SuppressWarnings({"RedundantThrows", "unused"})
 public class AhavingMembersOfTypeB {
     private B b;
 

File: archunit/src/test/java/com/tngtech/archunit/core/domain/testobjects/B.java
Patch:
@@ -1,5 +1,6 @@
 package com.tngtech.archunit.core.domain.testobjects;
 
+@DomainAnnotation
 public class B {
     String field;
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -279,7 +279,7 @@ public void matchInAnyOrder(Class<?>... classes) {
         }
 
         public void matchExactly(Class<?>... classes) {
-            assertThat((Object[]) actual).as("classes").hasSize(classes.length);
+            assertThat(TestUtils.namesOf(actual)).as("classes").containsExactlyElementsOf(namesOf(classes));
             for (int i = 0; i < actual.length; i++) {
                 assertThat(actual[i]).as("Element %d", i).matches(classes[i]);
             }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaAnnotationAssertion.java
Patch:
@@ -20,7 +20,7 @@ public class JavaAnnotationAssertion {
     public static Set<Map<String, Object>> propertiesOf(Set<? extends JavaAnnotation<?>> annotations) {
         List<Annotation> converted = new ArrayList<>();
         for (JavaAnnotation<?> annotation : annotations) {
-            converted.add(annotation.as((Class) annotation.getType().reflect()));
+            converted.add(annotation.as((Class) annotation.getRawType().reflect()));
         }
         return propertiesOf(converted.toArray(new Annotation[0]));
     }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassTest.java
Patch:
@@ -447,7 +447,6 @@ public void direct_dependencies_from_self_by_annotation() {
                         .to(B.class)
                         .inLineNumber(0))
         ;
-        // TODO test meta annotations
         // TODO test that annotation dependencies do not lead to a infinite loop
     }
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/PublicAPIRules.java
Patch:
@@ -306,10 +306,10 @@ public boolean apply(JavaClass input) {
         };
     }
 
-    private static DescribedPredicate<JavaAnnotation> publicApiForInheritance() {
-        return new DescribedPredicate<JavaAnnotation>("@%s(usage = %s)", PublicAPI.class.getSimpleName(), INHERITANCE) {
+    private static DescribedPredicate<JavaAnnotation<?>> publicApiForInheritance() {
+        return new DescribedPredicate<JavaAnnotation<?>>("@%s(usage = %s)", PublicAPI.class.getSimpleName(), INHERITANCE) {
             @Override
-            public boolean apply(JavaAnnotation input) {
+            public boolean apply(JavaAnnotation<?> input) {
                 return input.getRawType().isEquivalentTo(PublicAPI.class) &&
                         input.as(PublicAPI.class).usage() == INHERITANCE;
             }

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/TestAnalysisRequest.java
Patch:
@@ -5,7 +5,7 @@
 @SuppressWarnings("unchecked")
 class TestAnalysisRequest implements ClassAnalysisRequest {
     private String[] packages = new String[0];
-    private Class<?>[] packageRoots = new Class[0];
+    private Class<?>[] packageRoots = new Class<?>[0];
     private Class<? extends LocationProvider>[] locationProviders = new Class[0];
     private Class<? extends ImportOption>[] importOptions = new Class[0];
     private CacheMode cacheMode = CacheMode.FOREVER;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AccessTarget.java
Patch:
@@ -174,7 +174,7 @@ public boolean apply(JavaMember input) {
      */
     @Override
     @PublicAPI(usage = ACCESS)
-    public boolean isAnnotatedWith(final DescribedPredicate<? super JavaAnnotation> predicate) {
+    public boolean isAnnotatedWith(final DescribedPredicate<? super JavaAnnotation<?>> predicate) {
         return anyMember(new Predicate<JavaMember>() {
             @Override
             public boolean apply(JavaMember input) {
@@ -202,7 +202,7 @@ public boolean apply(JavaMember input) {
 
     @Override
     @PublicAPI(usage = ACCESS)
-    public boolean isMetaAnnotatedWith(final DescribedPredicate<? super JavaAnnotation> predicate) {
+    public boolean isMetaAnnotatedWith(final DescribedPredicate<? super JavaAnnotation<?>> predicate) {
         return anyMember(new Predicate<JavaMember>() {
             @Override
             public boolean apply(JavaMember input) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/DomainObjectCreationContext.java
Patch:
@@ -30,6 +30,7 @@
 import com.google.common.collect.SetMultimap;
 import com.tngtech.archunit.Internal;
 import com.tngtech.archunit.base.Function;
+import com.tngtech.archunit.base.HasDescription;
 import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.importer.DomainBuilders;
 import com.tngtech.archunit.core.importer.DomainBuilders.ConstructorCallTargetBuilder;
@@ -78,8 +79,8 @@ public static void completeMembers(JavaClass javaClass, ImportContext importCont
         javaClass.completeMembers(importContext);
     }
 
-    public static JavaAnnotation createJavaAnnotation(JavaAnnotationBuilder builder) {
-        return new JavaAnnotation(builder);
+    public static <T extends HasDescription> JavaAnnotation<T> createJavaAnnotation(T owner, JavaAnnotationBuilder builder) {
+        return new JavaAnnotation<>(owner, builder);
     }
 
     public static JavaClassList createJavaClassList(List<JavaClass> elements) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -35,7 +35,7 @@ public interface ImportContext {
 
     Optional<JavaStaticInitializer> createStaticInitializer(JavaClass owner);
 
-    Map<String, JavaAnnotation> createAnnotations(JavaClass owner);
+    Map<String, JavaAnnotation<JavaClass>> createAnnotations(JavaClass owner);
 
     Optional<JavaClass> createEnclosingClass(JavaClass owner);
 
@@ -57,9 +57,9 @@ public interface ImportContext {
 
     Set<ThrowsDeclaration<JavaConstructor>> getConstructorThrowsDeclarationsOfType(JavaClass javaClass);
 
-    Set<JavaAnnotation> getAnnotationsOfType(JavaClass javaClass);
+    Set<JavaAnnotation<?>> getAnnotationsOfType(JavaClass javaClass);
 
-    Set<JavaAnnotation> getAnnotationsWithParameterOfType(JavaClass javaClass);
+    Set<JavaAnnotation<?>> getAnnotationsWithParameterOfType(JavaClass javaClass);
 
     Set<JavaMember> getMembersAnnotatedWithType(JavaClass javaClass);
 

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasNameTest.java
Patch:
@@ -62,7 +62,7 @@ public void functions() {
         assertThat(GET_FULL_NAME.apply(test)).isEqualTo("full");
     }
 
-    private AbstractBooleanAssert assertNameMatches(String input, String regex) {
+    private AbstractBooleanAssert<?> assertNameMatches(String input, String regex) {
         return assertThat(nameMatching(regex).apply(newHasName(input)))
                 .as(input + " =~ " + regex);
     }
@@ -84,4 +84,4 @@ public String getFullName() {
             }
         };
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/core/importer/JavaAnnotationTestBuilder.java
Patch:
@@ -19,7 +19,7 @@ public JavaAnnotationTestBuilder addProperty(String key, Object value) {
         return this;
     }
 
-    public JavaAnnotation build(JavaClass owner, ClassesByTypeName byTypeName) {
+    public JavaAnnotation<?> build(JavaClass owner, ClassesByTypeName byTypeName) {
         return delegate.build(owner, byTypeName);
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/ClassAccessesFieldConditionTest.java
Patch:
@@ -100,7 +100,7 @@ static class PositiveTestCase extends TestCase<PositiveTestCase> {
     static class NegativeTestCase extends TestCase<NegativeTestCase> {
     }
 
-    abstract static class TestCase<SELF extends TestCase> {
+    abstract static class TestCase<SELF extends TestCase<SELF>> {
         AccessInfo accessInfo;
         ArchCondition<JavaClass> condition;
 
@@ -125,4 +125,4 @@ private SELF self() {
             return (SELF) this;
         }
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/ClassesShouldTest.java
Patch:
@@ -1438,10 +1438,10 @@ static String singleLineFailureReportOf(EvaluationResult result) {
     }
 
     @SuppressWarnings("SameParameterValue")
-    private static DescribedPredicate<JavaAnnotation> annotation(final Class<? extends Annotation> type) {
-        return new DescribedPredicate<JavaAnnotation>("@" + type.getSimpleName()) {
+    private static DescribedPredicate<JavaAnnotation<?>> annotation(final Class<? extends Annotation> type) {
+        return new DescribedPredicate<JavaAnnotation<?>>("@" + type.getSimpleName()) {
             @Override
-            public boolean apply(JavaAnnotation input) {
+            public boolean apply(JavaAnnotation<?> input) {
                 return input.getRawType().getName().equals(type.getName());
             }
         };

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaAnnotationAssertion.java
Patch:
@@ -17,9 +17,9 @@
 
 public class JavaAnnotationAssertion {
     @SuppressWarnings("rawtypes")
-    public static Set<Map<String, Object>> propertiesOf(Set<JavaAnnotation> annotations) {
+    public static Set<Map<String, Object>> propertiesOf(Set<? extends JavaAnnotation<?>> annotations) {
         List<Annotation> converted = new ArrayList<>();
-        for (JavaAnnotation annotation : annotations) {
+        for (JavaAnnotation<?> annotation : annotations) {
             converted.add(annotation.as((Class) annotation.getType().reflect()));
         }
         return propertiesOf(converted.toArray(new Annotation[0]));

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -761,7 +761,7 @@ public Set<ThrowsDeclaration<JavaConstructor>> getConstructorsWithThrowsDeclarat
     }
 
     /**
-     * @return {@link JavaAnnotation} of all imported classes that have the type of this class.
+     * @return All imported {@link JavaAnnotation JavaAnnotations} that have the annotation type of this class.
      */
     @PublicAPI(usage = ACCESS)
     public Set<JavaAnnotation> getAnnotationsWithTypeOfSelf() {

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/LayerDependencyRulesTest.java
Patch:
@@ -57,6 +57,6 @@ public class LayerDependencyRulesTest {
     @ArchTest
     public static final ArchRule services_should_only_depend_on_persistence_or_other_services =
             classes().that().resideInAPackage("..service..")
-                    .should().onlyDependOnClassesThat().resideInAnyPackage("..service..", "..persistence..", "java..");
+                    .should().onlyDependOnClassesThat().resideInAnyPackage("..service..", "..persistence..", "java..", "javax..");
 
 }

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/LayerDependencyRulesTest.java
Patch:
@@ -54,6 +54,6 @@ public class LayerDependencyRulesTest {
     @ArchTest
     static final ArchRule services_should_only_depend_on_persistence_or_other_services =
             classes().that().resideInAPackage("..service..")
-                    .should().onlyDependOnClassesThat().resideInAnyPackage("..service..", "..persistence..", "java..");
+                    .should().onlyDependOnClassesThat().resideInAnyPackage("..service..", "..persistence..", "java..", "javax..");
 
 }

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/LayerDependencyRulesTest.java
Patch:
@@ -63,7 +63,8 @@ public void services_should_only_be_depended_on_by_controllers_or_other_services
     @Test
     public void services_should_only_depend_on_persistence_or_other_services() {
         classes().that().resideInAPackage("..service..")
-                .should().onlyDependOnClassesThat().resideInAnyPackage("..service..", "..persistence..", "java..").check(classes);
+                .should().onlyDependOnClassesThat().resideInAnyPackage("..service..", "..persistence..", "java..", "javax..")
+                .check(classes);
     }
 
 }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -1020,7 +1020,9 @@ private Set<Dependency> constructorParameterDependenciesFromSelf() {
     private Set<Dependency> annotationDependenciesFromSelf() {
         return new ImmutableSet.Builder<Dependency>()
                 .addAll(annotationDependencies(this))
-                .addAll(annotationDependencies(getAllMembers()))
+                .addAll(annotationDependencies(getFields()))
+                .addAll(annotationDependencies(getMethods()))
+                .addAll(annotationDependencies(getConstructors()))
                 .build();
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Dependency.java
Patch:
@@ -94,7 +94,7 @@ static Dependency fromThrowsDeclaration(ThrowsDeclaration<? extends JavaCodeUnit
     }
 
     static Dependency fromAnnotation(HasDescription origin, JavaAnnotation target, JavaClass owner) {
-        return createDependencyFromDescribable(origin, "is annotated with", target.getType(), owner);
+        return createDependencyFromDescribable(origin, "is annotated with", target.getRawType(), owner);
     }
 
     static Dependency fromAnnotationMember(HasDescription origin, JavaClass memberType, JavaClass owner) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -1038,7 +1038,7 @@ private <T extends HasDescription & HasAnnotations> Set<Dependency> annotationDe
         for (JavaAnnotation annotation : annotations) {
             result.add(Dependency.fromAnnotation(annotated, annotation, this));
             result.addAll(annotationParametersDependencies(annotation, annotated));
-            result.addAll(annotationDependencies(annotation.getType()));
+            result.addAll(annotationDependencies(annotation.getRawType()));
         }
         return result.build();
     }
@@ -1069,8 +1069,8 @@ private Set<Dependency> annotationParameterDependencies(HasDescription origin, O
             result.addAll(annotationDependencies(annotationMember));
         } else if (value instanceof JavaAnnotation) {
             JavaAnnotation nestedAnnotation = (JavaAnnotation) value;
-            result.add(Dependency.fromAnnotationMember(origin, nestedAnnotation.getType(), this));
-            result.addAll(annotationDependencies(nestedAnnotation.getType()));
+            result.add(Dependency.fromAnnotationMember(origin, nestedAnnotation.getRawType(), this));
+            result.addAll(annotationDependencies(nestedAnnotation.getRawType()));
             result.addAll(annotationParametersDependencies(nestedAnnotation, origin));
         }
         return result.build();

File: archunit/src/test/java/com/tngtech/archunit/core/domain/DependencyTest.java
Patch:
@@ -71,7 +71,7 @@ public void Dependency_from_annotation_on_class() {
                 .get(ClassWithDependencyOnAnnotation.class);
 
         JavaAnnotation annotation = origin.getAnnotations().iterator().next();
-        Class<?> annotationClass = annotation.getType().reflect();
+        Class<?> annotationClass = annotation.getRawType().reflect();
 
         Dependency dependency = Dependency.fromAnnotation(origin, annotation, origin);
         assertThat(dependency.getOriginClass()).matches(ClassWithDependencyOnAnnotation.class);
@@ -96,7 +96,7 @@ public void Dependency_from_annotation_on_member() {
                 .getField("obj");
 
         JavaAnnotation annotation = origin.getAnnotations().iterator().next();
-        Class<?> annotationClass = annotation.getType().reflect();
+        Class<?> annotationClass = annotation.getRawType().reflect();
 
         Dependency dependency = Dependency.fromAnnotation(origin, annotation, origin.getOwner());
         assertThat(dependency.getOriginClass()).matches(ClassWithAnnotatedField.class);

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Dependency.java
Patch:
@@ -63,7 +63,9 @@ static Dependency from(JavaAccess<?> access) {
     }
 
     static Dependency fromInheritance(JavaClass origin, JavaClass targetSuperType) {
-        String originDescription = origin.getDescription();
+        String originType = origin.isInterface() ? "Interface" : "Class";
+        String originDescription = originType + " " + bracketFormat(origin.getName());
+
         String dependencyType = !origin.isInterface() && targetSuperType.isInterface() ? "implements" : "extends";
 
         String targetType = targetSuperType.isInterface() ? "interface" : "class";

File: archunit/src/test/java/com/tngtech/archunit/core/domain/DependencyTest.java
Patch:
@@ -77,7 +77,7 @@ public void Dependency_from_annotation_on_class() {
         assertThat(dependency.getOriginClass()).matches(ClassWithDependencyOnAnnotation.class);
         assertThat(dependency.getTargetClass()).matches(annotationClass);
         assertThat(dependency.getDescription()).as("description")
-                .contains("Class <" + origin.getName() + "> has annotation <" + annotationClass.getName() + ">");
+                .contains("Class <" + origin.getName() + "> is annotated with <" + annotationClass.getName() + ">");
 
         origin = importClassesWithContext(InterfaceWithDependencyOnAnnotation.class, SomeAnnotation.class)
                 .get(InterfaceWithDependencyOnAnnotation.class);
@@ -86,7 +86,7 @@ public void Dependency_from_annotation_on_class() {
         assertThat(dependency.getOriginClass()).matches(InterfaceWithDependencyOnAnnotation.class);
         assertThat(dependency.getTargetClass()).matches(annotationClass);
         assertThat(dependency.getDescription()).as("description")
-                .contains("Interface <" + origin.getName() + "> has annotation <" + annotationClass.getName() + ">");
+                .contains("Class <" + origin.getName() + "> is annotated with <" + annotationClass.getName() + ">");
     }
 
     @Test
@@ -102,7 +102,7 @@ public void Dependency_from_annotation_on_member() {
         assertThat(dependency.getOriginClass()).matches(ClassWithAnnotatedField.class);
         assertThat(dependency.getTargetClass()).matches(annotationClass);
         assertThat(dependency.getDescription()).as("description")
-                .contains(origin.getDescription() + " has annotation <" + annotationClass.getName() + ">");
+                .contains(origin.getDescription() + " is annotated with <" + annotationClass.getName() + ">");
     }
 
     @Test

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Dependency.java
Patch:
@@ -112,7 +112,7 @@ private static Dependency createDependencyFromDescribable(HasDescription hasDesc
         String originDescription = hasDescription.getDescription();
         String targetDescription = bracketFormat(target.getName());
         String dependencyDescription = originDescription + " " + dependencyType + " " + targetDescription;
-        String description = dependencyDescription + " in " + formatLocation(owner, 0);
+        String description = dependencyDescription + " in " + owner.getSourceCodeLocation();
         return new Dependency(owner, target, 0, description);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -351,7 +351,7 @@ void registerConstructors(Set<JavaConstructor> constructors) {
 
         void registerAnnotations(Collection<JavaAnnotation> annotations) {
             for (JavaAnnotation annotation : annotations) {
-                annotationTypeDependencies.put(annotation.getType(), annotation);
+                annotationTypeDependencies.put(annotation.getRawType(), annotation);
                 registerAnnotationParameters(annotation);
             }
         }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Dependency.java
Patch:
@@ -92,7 +92,7 @@ static Dependency fromThrowsDeclaration(ThrowsDeclaration<? extends JavaCodeUnit
     }
 
     static Dependency fromAnnotation(HasDescription origin, JavaAnnotation target, JavaClass owner) {
-        return createDependencyFromDescribable(origin, "has annotation", target.getType(), owner);
+        return createDependencyFromDescribable(origin, "is annotated with", target.getType(), owner);
     }
 
     static Dependency fromAnnotationMember(HasDescription origin, JavaClass memberType, JavaClass owner) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaAnnotation.java
Patch:
@@ -19,9 +19,7 @@
 import java.util.Map;
 
 import com.tngtech.archunit.PublicAPI;
-import com.tngtech.archunit.base.HasDescription;
 import com.tngtech.archunit.base.Optional;
-import com.tngtech.archunit.core.domain.properties.HasAnnotations;
 import com.tngtech.archunit.core.domain.properties.HasOwner;
 import com.tngtech.archunit.core.domain.properties.HasType;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaAnnotationBuilder;
@@ -139,5 +137,6 @@ public <A extends Annotation> A as(Class<A> annotationType) {
         return AnnotationProxy.of(annotationType, this);
     }
 
-    public interface JavaAnnotatedElement extends HasAnnotations, HasDescription {}
+    // TODO support annotation description
+
 }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -327,6 +327,9 @@ void registerConstructors(Set<JavaConstructor> constructors) {
         }
 
         void registerAnnotations(Collection<JavaAnnotation> annotations) {
+            for (JavaAnnotation annotation : annotations) {
+                annotationTypeDependencies.put(annotation.getType(), annotation);
+            }
         }
 
         Set<JavaField> getFieldsOfType(JavaClass javaClass) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -57,5 +57,7 @@ public interface ImportContext {
 
     Set<ThrowsDeclaration<JavaConstructor>> getConstructorThrowsDeclarationsOfType(JavaClass javaClass);
 
+    Set<JavaAnnotation> getAnnotationsOfType(JavaClass javaClass);
+
     JavaClass resolveClass(String fullyQualifiedClassName);
 }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/TestUtils.java
Patch:
@@ -119,8 +119,8 @@ static ImportedTestClasses simpleImportedClasses() {
         return ImportTestUtils.simpleImportedClasses();
     }
 
-    static JavaAnnotation javaAnnotationFrom(Annotation annotation) {
-        return ImportTestUtils.javaAnnotationFrom(annotation);
+    static JavaAnnotation javaAnnotationFrom(Annotation annotation, Class<?> annotatedClass) {
+        return ImportTestUtils.javaAnnotationFrom(annotation, annotatedClass);
     }
 
     public static FieldAccessTarget targetFrom(JavaField javaField) {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/JavaAnnotationTestBuilder.java
Patch:
@@ -1,6 +1,7 @@
 package com.tngtech.archunit.core.importer;
 
 import com.tngtech.archunit.core.domain.JavaAnnotation;
+import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaType;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaAnnotationBuilder;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaAnnotationBuilder.ValueBuilder;
@@ -18,7 +19,7 @@ public JavaAnnotationTestBuilder addProperty(String key, Object value) {
         return this;
     }
 
-    public JavaAnnotation build(ClassesByTypeName byTypeName) {
-        return delegate.build(byTypeName);
+    public JavaAnnotation build(JavaClass owner, ClassesByTypeName byTypeName) {
+        return delegate.build(owner, byTypeName);
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasParameterTypes.java
Patch:
@@ -92,12 +92,12 @@ public static DescribedPredicate<HasParameterTypes> rawParameterTypes(final List
          */
         @Deprecated
         @PublicAPI(usage = ACCESS)
-        public static DescribedPredicate<HasParameterTypes> parameterTypes(final DescribedPredicate<JavaClassList> predicate) {
+        public static DescribedPredicate<HasParameterTypes> parameterTypes(final DescribedPredicate<? super JavaClassList> predicate) {
             return adjustDeprecatedDescription(new RawParameterTypesPredicate(predicate));
         }
 
         @PublicAPI(usage = ACCESS)
-        public static DescribedPredicate<HasParameterTypes> rawParameterTypes(final DescribedPredicate<List<JavaClass>> predicate) {
+        public static DescribedPredicate<HasParameterTypes> rawParameterTypes(final DescribedPredicate<? super List<JavaClass>> predicate) {
             return new RawParameterTypesPredicate(predicate);
         }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AllDependenciesCondition.java
Patch:
@@ -54,7 +54,7 @@ private AllDependenciesCondition(
     }
 
     @PublicAPI(usage = ACCESS)
-    public AllDependenciesCondition ignoreDependency(DescribedPredicate<Dependency> ignorePredicate) {
+    public AllDependenciesCondition ignoreDependency(DescribedPredicate<? super Dependency> ignorePredicate) {
         return new AllDependenciesCondition(getDescription(),
                 conditionPredicate,
                 javaClassToRelevantDependencies,

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AnyDependencyCondition.java
Patch:
@@ -54,7 +54,7 @@ private AnyDependencyCondition(
     }
 
     @PublicAPI(usage = ACCESS)
-    public AnyDependencyCondition ignoreDependency(DescribedPredicate<Dependency> ignorePredicate) {
+    public AnyDependencyCondition ignoreDependency(DescribedPredicate<? super Dependency> ignorePredicate) {
         return new AnyDependencyCondition(getDescription(),
                 conditionPredicate,
                 javaClassToRelevantDependencies,

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ClassesShouldInternal.java
Patch:
@@ -585,7 +585,7 @@ public ClassesShouldConjunction notBeEnums() {
     }
 
     @Override
-    public ClassesShouldConjunction containNumberOfElements(DescribedPredicate<Integer> predicate) {
+    public ClassesShouldConjunction containNumberOfElements(DescribedPredicate<? super Integer> predicate) {
         return addCondition(ArchConditions.containNumberOfElements(predicate));
     }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/ClassesShould.java
Patch:
@@ -1030,5 +1030,5 @@ public interface ClassesShould {
      * @return A syntax element that can either be used as working rule, or to continue specifying a more complex rule
      */
     @PublicAPI(usage = ACCESS)
-    ClassesShouldConjunction containNumberOfElements(DescribedPredicate<Integer> predicate);
+    ClassesShouldConjunction containNumberOfElements(DescribedPredicate<? super Integer> predicate);
 }

File: archunit/src/main/java/com/tngtech/archunit/library/Architectures.java
Patch:
@@ -315,9 +315,9 @@ private LayerDefinition(String name) {
             }
 
             @PublicAPI(usage = ACCESS)
-            public LayeredArchitecture definedBy(DescribedPredicate<JavaClass> predicate) {
+            public LayeredArchitecture definedBy(DescribedPredicate<? super JavaClass> predicate) {
                 checkNotNull(predicate, "Supplied predicate must not be null");
-                this.containsPredicate = predicate;
+                this.containsPredicate = predicate.forSubType();
                 return LayeredArchitecture.this.addLayerDefinition(this);
             }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasParameterTypes.java
Patch:
@@ -92,12 +92,12 @@ public static DescribedPredicate<HasParameterTypes> rawParameterTypes(final List
          */
         @Deprecated
         @PublicAPI(usage = ACCESS)
-        public static DescribedPredicate<HasParameterTypes> parameterTypes(final DescribedPredicate<JavaClassList> predicate) {
+        public static DescribedPredicate<HasParameterTypes> parameterTypes(final DescribedPredicate<? super JavaClassList> predicate) {
             return adjustDeprecatedDescription(new RawParameterTypesPredicate(predicate));
         }
 
         @PublicAPI(usage = ACCESS)
-        public static DescribedPredicate<HasParameterTypes> rawParameterTypes(final DescribedPredicate<List<JavaClass>> predicate) {
+        public static DescribedPredicate<HasParameterTypes> rawParameterTypes(final DescribedPredicate<? super List<JavaClass>> predicate) {
             return new RawParameterTypesPredicate(predicate);
         }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AllDependenciesCondition.java
Patch:
@@ -54,7 +54,7 @@ private AllDependenciesCondition(
     }
 
     @PublicAPI(usage = ACCESS)
-    public AllDependenciesCondition ignoreDependency(DescribedPredicate<Dependency> ignorePredicate) {
+    public AllDependenciesCondition ignoreDependency(DescribedPredicate<? super Dependency> ignorePredicate) {
         return new AllDependenciesCondition(getDescription(),
                 conditionPredicate,
                 javaClassToRelevantDependencies,

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AnyDependencyCondition.java
Patch:
@@ -54,7 +54,7 @@ private AnyDependencyCondition(
     }
 
     @PublicAPI(usage = ACCESS)
-    public AnyDependencyCondition ignoreDependency(DescribedPredicate<Dependency> ignorePredicate) {
+    public AnyDependencyCondition ignoreDependency(DescribedPredicate<? super Dependency> ignorePredicate) {
         return new AnyDependencyCondition(getDescription(),
                 conditionPredicate,
                 javaClassToRelevantDependencies,

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ClassesShouldInternal.java
Patch:
@@ -585,7 +585,7 @@ public ClassesShouldConjunction notBeEnums() {
     }
 
     @Override
-    public ClassesShouldConjunction containNumberOfElements(DescribedPredicate<Integer> predicate) {
+    public ClassesShouldConjunction containNumberOfElements(DescribedPredicate<? super Integer> predicate) {
         return addCondition(ArchConditions.containNumberOfElements(predicate));
     }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/ClassesShould.java
Patch:
@@ -1030,5 +1030,5 @@ public interface ClassesShould {
      * @return A syntax element that can either be used as working rule, or to continue specifying a more complex rule
      */
     @PublicAPI(usage = ACCESS)
-    ClassesShouldConjunction containNumberOfElements(DescribedPredicate<Integer> predicate);
+    ClassesShouldConjunction containNumberOfElements(DescribedPredicate<? super Integer> predicate);
 }

File: archunit/src/main/java/com/tngtech/archunit/library/Architectures.java
Patch:
@@ -315,9 +315,9 @@ private LayerDefinition(String name) {
             }
 
             @PublicAPI(usage = ACCESS)
-            public LayeredArchitecture definedBy(DescribedPredicate<JavaClass> predicate) {
+            public LayeredArchitecture definedBy(DescribedPredicate<? super JavaClass> predicate) {
                 checkNotNull(predicate, "Supplied predicate must not be null");
-                this.containsPredicate = predicate;
+                this.containsPredicate = predicate.forSubType();
                 return LayeredArchitecture.this.addLayerDefinition(this);
             }
 

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceDependency.java
Patch:
@@ -67,7 +67,7 @@ public Slice getTarget() {
     @Override
     @PublicAPI(usage = ACCESS)
     public String getDescription() {
-        return String.format("%s calls %s:%n%s",
+        return String.format("%s depends on %s:%n%s",
                 origin.getDescription(),
                 target.getDescription(),
                 joinDependencies(relevantDependencies));

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/FreezingArchRule.java
Patch:
@@ -59,7 +59,8 @@
  * </li>
  * <li>
  *   a {@link ViolationLineMatcher} to decide which violations are "known", i.e. have already been present in the previous evaluation.<br>
- *   The default {@link ViolationLineMatcher} compares violations ignoring the line number of their source code location.<br>
+ *   The default {@link ViolationLineMatcher} compares violations ignoring the line number of their source code location
+ *   and auto-generated numbers of anonymous classes or lambda expressions.<br>
  *   A custom implementation can be configured in two ways.
  *   Again either programmatically via {@link #associateViolationLinesVia(ViolationLineMatcher)}, or within
  *   {@value com.tngtech.archunit.ArchConfiguration#ARCHUNIT_PROPERTIES_RESOURCE_NAME}, e.g.

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/FreezingArchRule.java
Patch:
@@ -59,7 +59,8 @@
  * </li>
  * <li>
  *   a {@link ViolationLineMatcher} to decide which violations are "known", i.e. have already been present in the previous evaluation.<br>
- *   The default {@link ViolationLineMatcher} compares violations ignoring the line number of their source code location.<br>
+ *   The default {@link ViolationLineMatcher} compares violations ignoring the line number of their source code location
+ *   and auto-generated numbers of anonymous classes or lambda expressions.<br>
  *   A custom implementation can be configured in two ways.
  *   Again either programmatically via {@link #associateViolationLinesVia(ViolationLineMatcher)}, or within
  *   {@value com.tngtech.archunit.ArchConfiguration#ARCHUNIT_PROPERTIES_RESOURCE_NAME}, e.g.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AccessTarget.java
Patch:
@@ -455,7 +455,7 @@ public Set<JavaConstructor> apply(ConstructorCallTarget input) {
     }
 
     /**
-     * Represents an {@link CodeUnitCallTarget CodeUnitCallTarget} where the target is a method. For further elaboration about the necessity to distinguish
+     * Represents a {@link CodeUnitCallTarget} where the target is a method. For further elaboration about the necessity to distinguish
      * {@link MethodCallTarget MethodCallTarget} from {@link JavaMethod}, refer to the documentation at {@link AccessTarget} and in particular the
      * documentation at {@link #resolve()}.
      */

File: archunit/src/main/java/com/tngtech/archunit/core/importer/Location.java
Patch:
@@ -49,7 +49,7 @@
 
 /**
  * Handles various forms of location from where classes can be imported in a consistent way. Any location
- * will be treated like an {@link URI}, thus there will not be any platform dependent file separator problems.<br><br>
+ * will be treated like a {@link URI}, thus there will not be any platform dependent file separator problems.<br><br>
  * Examples for locations could be
  * <ul>
  *     <li><code>file:///home/someuser/workspace/myproject/target/classes/myproject/Foo.class</code></li>

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AccessTarget.java
Patch:
@@ -455,7 +455,7 @@ public Set<JavaConstructor> apply(ConstructorCallTarget input) {
     }
 
     /**
-     * Represents an {@link CodeUnitCallTarget CodeUnitCallTarget} where the target is a method. For further elaboration about the necessity to distinguish
+     * Represents a {@link CodeUnitCallTarget} where the target is a method. For further elaboration about the necessity to distinguish
      * {@link MethodCallTarget MethodCallTarget} from {@link JavaMethod}, refer to the documentation at {@link AccessTarget} and in particular the
      * documentation at {@link #resolve()}.
      */

File: archunit/src/main/java/com/tngtech/archunit/core/importer/Location.java
Patch:
@@ -49,7 +49,7 @@
 
 /**
  * Handles various forms of location from where classes can be imported in a consistent way. Any location
- * will be treated like an {@link URI}, thus there will not be any platform dependent file separator problems.<br><br>
+ * will be treated like a {@link URI}, thus there will not be any platform dependent file separator problems.<br><br>
  * Examples for locations could be
  * <ul>
  *     <li><code>file:///home/someuser/workspace/myproject/target/classes/myproject/Foo.class</code></li>

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -56,4 +56,6 @@ public interface ImportContext {
     Set<JavaConstructor> getConstructorsWithParameterOfType(JavaClass javaClass);
 
     Set<ThrowsDeclaration<JavaConstructor>> getConstructorThrowsDeclarationsOfType(JavaClass javaClass);
+
+    JavaClass resolveClass(String fullyQualifiedClassName);
 }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassTest.java
Patch:
@@ -118,13 +118,13 @@ class OnlyReferencingMultiDimArray {
                 .get(OnlyReferencingMultiDimArray.class);
 
         JavaClass arrayType = javaClass.getField("field").getRawType();
-        JavaClass twoDim = arrayType.tryGetComponentType().get();
+        JavaClass twoDim = arrayType.getComponentType();
         assertThat(twoDim.getName()).isEqualTo(OnlyReferencingMultiDimArray[][].class.getName());
 
-        JavaClass oneDim = twoDim.tryGetComponentType().get();
+        JavaClass oneDim = twoDim.getComponentType();
         assertThat(oneDim.getName()).isEqualTo(OnlyReferencingMultiDimArray[].class.getName());
 
-        JavaClass original = oneDim.tryGetComponentType().get();
+        JavaClass original = oneDim.getComponentType();
         assertThat(original).isEqualTo(javaClass);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -57,5 +57,5 @@ public interface ImportContext {
 
     Set<ThrowsDeclaration<JavaConstructor>> getConstructorThrowsDeclarationsOfType(JavaClass javaClass);
 
-    Optional<JavaClass> resolveComponentType(JavaType type);
+    JavaClass resolveClass(String fullyQualifiedClassName);
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportTestUtils.java
Patch:
@@ -430,8 +430,8 @@ public Set<ThrowsDeclaration<JavaConstructor>> getConstructorThrowsDeclarationsO
         }
 
         @Override
-        public Optional<JavaClass> resolveComponentType(JavaType type) {
-            return Optional.absent();
+        public JavaClass resolveClass(String fullyQualifiedClassName) {
+            throw new UnsupportedOperationException("Override me where necessary");
         }
     }
-}
\ No newline at end of file
+}

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassTest.java
Patch:
@@ -83,15 +83,15 @@ public void finds_array_type() {
         JavaMethod method = importClassWithContext(IsArrayTestClass.class).getMethod("anArray");
 
         assertThat(method.getRawReturnType().isArray()).isTrue();
-        assertThat(method.getRawReturnType().tryGetComponentType().get().getName()).isEqualTo("java.lang.Object");
+        assertThat(method.getRawReturnType().tryGetComponentType().get()).matches(Object.class);
     }
 
     @Test
     public void finds_non_array_type() {
         JavaMethod method = importClassWithContext(IsArrayTestClass.class).getMethod("notAnArray");
 
         assertThat(method.getRawReturnType().isArray()).isFalse();
-        assertThat(method.getRawReturnType().tryGetComponentType().isPresent()).isFalse();
+        assertThat(method.getRawReturnType().tryGetComponentType()).isAbsent();
     }
 
     @Test
@@ -1152,4 +1152,4 @@ private class NestedNamedInnerClass {
             }
         }
     }
-}
\ No newline at end of file
+}

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -56,4 +56,6 @@ public interface ImportContext {
     Set<JavaConstructor> getConstructorsWithParameterOfType(JavaClass javaClass);
 
     Set<ThrowsDeclaration<JavaConstructor>> getConstructorThrowsDeclarationsOfType(JavaClass javaClass);
+
+    Optional<JavaClass> resolveComponentType(JavaType type);
 }

File: archunit/src/main/java/com/tngtech/archunit/library/Architectures.java
Patch:
@@ -215,7 +215,7 @@ public void check(JavaClass item, ConditionEvents events) {
             @Override
             public void finish(ConditionEvents events) {
                 boolean conditionSatisfied = predicate.apply(allClassNames.size());
-                String message = String.format("Layer '%s' should not be empty", layerDefinition.name);
+                String message = String.format("Layer '%s' is empty", layerDefinition.name);
                 events.add(new SimpleConditionEvent(layerDefinition, conditionSatisfied, message));
             }
         }

File: archunit/src/test/java/com/tngtech/archunit/library/ArchitecturesTest.java
Patch:
@@ -118,8 +118,7 @@ public void layered_architecture_defining_empty_layers_is_rejected() {
         LayeredArchitecture architecture = layeredArchitecture()
                 .layer("Some").definedBy(absolute("should.not.be.found.."))
                 .layer("Other").definedBy(absolute("also.not.found"))
-                .whereLayer("Some").mayNotBeAccessedByAnyLayer()
-                .whereLayer("Other").mayNotBeAccessedByAnyLayer();
+                .layer("Okay").definedBy("..testclasses..");
 
         JavaClasses classes = new ClassFileImporter().importPackages(getClass().getPackage().getName() + ".testclasses");
 
@@ -320,7 +319,7 @@ private static String expectedAccessViolationPattern(Class<?> from, String fromM
     }
 
     private static String expectedEmptyLayer(String layerName) {
-        return String.format("Layer '%s' should not be empty", layerName);
+        return String.format("Layer '%s' is empty", layerName);
     }
 
     private static String fieldTypePattern(Class<?> owner, String fieldName, Class<?> fieldType) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -250,7 +250,7 @@ public <A extends Annotation> A getAnnotationOfType(Class<A> type) {
     @PublicAPI(usage = ACCESS)
     public JavaAnnotation getAnnotationOfType(String typeName) {
         return tryGetAnnotationOfType(typeName).getOrThrow(new IllegalArgumentException(
-                String.format("Type %s is not annotated with @%s", getSimpleName(), Formatters.ensureSimpleName(typeName))));
+                String.format("Type %s is not annotated with @%s", getSimpleName(), typeName)));
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMember.java
Patch:
@@ -85,7 +85,7 @@ public <A extends Annotation> A getAnnotationOfType(Class<A> type) {
     public JavaAnnotation getAnnotationOfType(String typeName) {
         return tryGetAnnotationOfType(typeName).getOrThrow(new IllegalArgumentException(String.format(
                 "Member %s is not annotated with @%s",
-                getFullName(), Formatters.ensureSimpleName(typeName))));
+                getFullName(), typeName)));
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaCodeUnit.java
Patch:
@@ -62,6 +62,9 @@ public abstract class JavaCodeUnit extends JavaMember implements HasParameterTyp
         fullName = formatMethod(getOwner().getName(), getName(), getRawParameterTypes());
     }
 
+    /**
+     * @return The full name of this {@link JavaCodeUnit}, i.e. a string containing {@code ${declaringClass}.${name}(${parameterTypes})}
+     */
     @Override
     @PublicAPI(usage = ACCESS)
     public String getFullName() {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaField.java
Patch:
@@ -42,6 +42,9 @@ public class JavaField extends JavaMember implements HasType {
         fieldSupplier = Suppliers.memoize(new ReflectFieldSupplier());
     }
 
+    /**
+     * @return The full name of this {@link JavaField}, i.e. a string containing {@code ${declaringClass}.${name}}
+     */
     @Override
     @PublicAPI(usage = ACCESS)
     public String getFullName() {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasSourceCodeLocation.java
Patch:
@@ -21,6 +21,9 @@
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
 public interface HasSourceCodeLocation {
+    /**
+     * @return The {@link SourceCodeLocation} of this object, i.e. how to locate the respective object within the set of source files.
+     */
     @PublicAPI(usage = ACCESS)
     SourceCodeLocation getSourceCodeLocation();
 }

File: archunit/src/main/java/com/tngtech/archunit/ArchConfiguration.java
Patch:
@@ -35,13 +35,14 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
+import static com.tngtech.archunit.base.ClassLoaders.getCurrentClassLoader;
 
 /**
  * Allows access to configured properties in {@value ARCHUNIT_PROPERTIES_RESOURCE_NAME}.
  */
 public final class ArchConfiguration {
     @Internal // {@value ...} does not work on non public constants outside of the package
-    public static final String ARCHUNIT_PROPERTIES_RESOURCE_NAME = "/archunit.properties";
+    public static final String ARCHUNIT_PROPERTIES_RESOURCE_NAME = "archunit.properties";
     @Internal // {@value ...} does not work on non public constants outside of the package
     public static final String RESOLVE_MISSING_DEPENDENCIES_FROM_CLASS_PATH = "resolveMissingDependenciesFromClassPath";
     static final String CLASS_RESOLVER = "classResolver";
@@ -84,7 +85,7 @@ private ArchConfiguration(String propertiesResourceName) {
     private void readProperties(String propertiesResourceName) {
         properties.clear();
 
-        URL archUnitPropertiesUrl = getClass().getResource(propertiesResourceName);
+        URL archUnitPropertiesUrl = getCurrentClassLoader(getClass()).getResource(propertiesResourceName);
         if (archUnitPropertiesUrl == null) {
             LOG.debug("No configuration found in classpath at {} => Using default configuration", propertiesResourceName);
             return;

File: archunit/src/main/java/com/tngtech/archunit/lang/ArchRule.java
Patch:
@@ -38,6 +38,7 @@
 
 import static com.google.common.io.Resources.readLines;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
+import static com.tngtech.archunit.base.ClassLoaders.getCurrentClassLoader;
 import static java.nio.charset.StandardCharsets.UTF_8;
 
 /**
@@ -107,7 +108,7 @@ public boolean apply(String message) {
         }
 
         private static Set<Pattern> readPatternsFrom(String fileNameInClassPath) {
-            URL ignorePatternsResource = Assertions.class.getResource('/' + fileNameInClassPath);
+            URL ignorePatternsResource = getCurrentClassLoader(Assertions.class).getResource(fileNameInClassPath);
             if (ignorePatternsResource == null) {
                 return Collections.emptySet();
             }

File: archunit/src/main/java/com/tngtech/archunit/library/Architectures.java
Patch:
@@ -328,19 +328,19 @@ private OnionArchitecture(String[] domainModelPackageIdentifiers,
         }
 
         @PublicAPI(usage = ACCESS)
-        public OnionArchitecture domainModel(String... packageIdentifiers) {
+        public OnionArchitecture domainModels(String... packageIdentifiers) {
             domainModelPackageIdentifiers = packageIdentifiers;
             return this;
         }
 
         @PublicAPI(usage = ACCESS)
-        public OnionArchitecture domainService(String... packageIdentifiers) {
+        public OnionArchitecture domainServices(String... packageIdentifiers) {
             domainServicePackageIdentifiers = packageIdentifiers;
             return this;
         }
 
         @PublicAPI(usage = ACCESS)
-        public OnionArchitecture application(String... packageIdentifiers) {
+        public OnionArchitecture applicationServices(String... packageIdentifiers) {
             applicationPackageIdentifiers = packageIdentifiers;
             return this;
         }

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/ControllerRulesTest.java
Patch:
@@ -4,7 +4,7 @@
 import com.tngtech.archunit.base.PackageMatchers;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaMember;
-import com.tngtech.archunit.example.security.Secured;
+import com.tngtech.archunit.example.layers.security.Secured;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;
@@ -20,7 +20,7 @@
 
 @Category(Example.class)
 @RunWith(ArchUnitRunner.class)
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class ControllerRulesTest {
 
     @ArchTest

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/CyclicDependencyRulesTest.java
Patch:
@@ -2,8 +2,8 @@
 
 import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.core.domain.JavaClass;
-import com.tngtech.archunit.example.cycle.complexcycles.slice1.SliceOneCallingConstructorInSliceTwoAndMethodInSliceThree;
-import com.tngtech.archunit.example.cycle.complexcycles.slice3.ClassCallingConstructorInSliceFive;
+import com.tngtech.archunit.example.cycles.complexcycles.slice1.SliceOneCallingConstructorInSliceTwoAndMethodInSliceThree;
+import com.tngtech.archunit.example.cycles.complexcycles.slice3.ClassCallingConstructorInSliceFive;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;
@@ -18,7 +18,7 @@
 
 @Category(Example.class)
 @RunWith(ArchUnitRunner.class)
-@AnalyzeClasses(packages = "com.tngtech.archunit.example.cycle")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.cycles")
 public class CyclicDependencyRulesTest {
 
     @ArchTest

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/DaoRulesTest.java
Patch:
@@ -18,7 +18,7 @@
 
 @Category(Example.class)
 @RunWith(ArchUnitRunner.class)
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class DaoRulesTest {
     @ArchTest
     public static final ArchRule DAOs_must_reside_in_a_dao_package =

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/FrozenRulesTest.java
Patch:
@@ -28,7 +28,7 @@
  */
 @Category(Example.class)
 @RunWith(ArchUnitRunner.class)
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class FrozenRulesTest {
 
     @ArchTest

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/InterfaceRulesTest.java
Patch:
@@ -5,9 +5,9 @@
 
 import com.tngtech.archunit.core.importer.Location;
 import com.tngtech.archunit.core.importer.Locations;
-import com.tngtech.archunit.example.SomeBusinessInterface;
-import com.tngtech.archunit.example.persistence.first.dao.SomeDao;
-import com.tngtech.archunit.example.service.impl.SomeInterfacePlacedInTheWrongPackage;
+import com.tngtech.archunit.example.layers.SomeBusinessInterface;
+import com.tngtech.archunit.example.layers.persistence.first.dao.SomeDao;
+import com.tngtech.archunit.example.layers.service.impl.SomeInterfacePlacedInTheWrongPackage;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/LayerDependencyRulesTest.java
Patch:
@@ -12,7 +12,7 @@
 
 @Category(Example.class)
 @RunWith(ArchUnitRunner.class)
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class LayerDependencyRulesTest {
 
     // 'access' catches only violations by real accesses, i.e. accessing a field, calling a method; compare 'dependOn' further down

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/MethodsTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.tngtech.archunit.exampletest.junit4;
 
-import com.tngtech.archunit.example.anticorruption.WrappedResult;
-import com.tngtech.archunit.example.security.Secured;
+import com.tngtech.archunit.example.layers.anticorruption.WrappedResult;
+import com.tngtech.archunit.example.layers.security.Secured;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;
@@ -14,7 +14,7 @@
 
 @Category(Example.class)
 @RunWith(ArchUnitRunner.class)
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class MethodsTest {
 
     @ArchTest

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/OnionArchitectureTest.java
Patch:
@@ -11,9 +11,9 @@
 
 @Category(Example.class)
 @RunWith(ArchUnitRunner.class)
-@AnalyzeClasses(packages = "com.tngtech.archunit.onionarchitecture.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.onionarchitecture")
 public class OnionArchitectureTest {
-    private static final String BASE_PACKAGE = "com.tngtech.archunit.onionarchitecture.example";
+    private static final String BASE_PACKAGE = "com.tngtech.archunit.example.onionarchitecture";
 
     @ArchTest
     static final ArchRule onion_architecture_is_respected = onionArchitecture()

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/RestrictNumberOfClassesWithACertainPropertyTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.tngtech.archunit.exampletest.junit4;
 
-import com.tngtech.archunit.example.SomeBusinessInterface;
-import com.tngtech.archunit.example.SomeOtherBusinessInterface;
+import com.tngtech.archunit.example.layers.SomeBusinessInterface;
+import com.tngtech.archunit.example.layers.SomeOtherBusinessInterface;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;
@@ -14,7 +14,7 @@
 
 @Category(Example.class)
 @RunWith(ArchUnitRunner.class)
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class RestrictNumberOfClassesWithACertainPropertyTest {
     @ArchTest
     public static final ArchRule no_new_classes_should_implement_SomeBusinessInterface =

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/RuleLibraryTest.java
Patch:
@@ -9,7 +9,7 @@
 
 @Category(Example.class)
 @RunWith(ArchUnitRunner.class)
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class RuleLibraryTest {
     @ArchTest
     public static final ArchRules LIBRARY = ArchRules.in(RuleSetsTest.class);

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/RuleSetsTest.java
Patch:
@@ -9,11 +9,11 @@
 
 @Category(Example.class)
 @RunWith(ArchUnitRunner.class)
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class RuleSetsTest {
     @ArchTest
     private final ArchRules CODING_RULES = ArchRules.in(CodingRulesTest.class);
 
     @ArchTest
-    private final ArchRules CYCLIC_DEPENDENCY_RULES = ArchRules.in(CyclicDependencyRulesTest.class);
+    private final ArchRules NAMING_CONVENTION_RULES = ArchRules.in(NamingConventionTest.class);
 }

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/SessionBeanRulesTest.java
Patch:
@@ -35,7 +35,7 @@
 
 @Category(Example.class)
 @RunWith(ArchUnitRunner.class)
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class SessionBeanRulesTest {
 
     @ArchTest

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/SlicesIsolationTest.java
Patch:
@@ -2,8 +2,8 @@
 
 import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.core.domain.JavaClass;
-import com.tngtech.archunit.example.controller.one.UseCaseOneTwoController;
-import com.tngtech.archunit.example.controller.two.UseCaseTwoController;
+import com.tngtech.archunit.example.layers.controller.one.UseCaseOneTwoController;
+import com.tngtech.archunit.example.layers.controller.two.UseCaseTwoController;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;
@@ -17,7 +17,7 @@
 
 @Category(Example.class)
 @RunWith(ArchUnitRunner.class)
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class SlicesIsolationTest {
     @ArchTest
     public static final ArchRule controllers_should_only_use_their_own_slice =

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/ThirdPartyRulesTest.java
Patch:
@@ -3,8 +3,8 @@
 import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.core.domain.JavaCall;
 import com.tngtech.archunit.core.domain.JavaClass;
-import com.tngtech.archunit.example.thirdparty.ThirdPartyClassWithProblem;
-import com.tngtech.archunit.example.thirdparty.ThirdPartyClassWorkaroundFactory;
+import com.tngtech.archunit.example.layers.thirdparty.ThirdPartyClassWithProblem;
+import com.tngtech.archunit.example.layers.thirdparty.ThirdPartyClassWorkaroundFactory;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;
@@ -27,7 +27,7 @@
 
 @Category(Example.class)
 @RunWith(ArchUnitRunner.class)
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class ThirdPartyRulesTest {
 
     @ArchTest

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/ControllerRulesTest.java
Patch:
@@ -4,7 +4,7 @@
 import com.tngtech.archunit.base.PackageMatchers;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaMember;
-import com.tngtech.archunit.example.security.Secured;
+import com.tngtech.archunit.example.layers.security.Secured;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
@@ -17,7 +17,7 @@
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
 
 @ArchTag("example")
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class ControllerRulesTest {
 
     @ArchTest

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/CyclicDependencyRulesTest.java
Patch:
@@ -1,8 +1,8 @@
 package com.tngtech.archunit.exampletest.junit5;
 
 import com.tngtech.archunit.core.domain.JavaClass;
-import com.tngtech.archunit.example.cycle.complexcycles.slice1.SliceOneCallingConstructorInSliceTwoAndMethodInSliceThree;
-import com.tngtech.archunit.example.cycle.complexcycles.slice3.ClassCallingConstructorInSliceFive;
+import com.tngtech.archunit.example.cycles.complexcycles.slice1.SliceOneCallingConstructorInSliceTwoAndMethodInSliceThree;
+import com.tngtech.archunit.example.cycles.complexcycles.slice3.ClassCallingConstructorInSliceFive;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
@@ -15,7 +15,7 @@
 import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
 
 @ArchTag("example")
-@AnalyzeClasses(packages = "com.tngtech.archunit.example.cycle")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.cycles")
 public class CyclicDependencyRulesTest {
 
     @ArchTest

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/DaoRulesTest.java
Patch:
@@ -15,7 +15,7 @@
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noMethods;
 
 @ArchTag("example")
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class DaoRulesTest {
     @ArchTest
     static final ArchRule DAOs_must_reside_in_a_dao_package =

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/FrozenRulesTest.java
Patch:
@@ -25,7 +25,7 @@
  * i.e. if you only change the line numbers of frozen violations, the test will still pass.
  */
 @ArchTag("example")
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class FrozenRulesTest {
 
     @ArchTest

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/InterfaceRulesTest.java
Patch:
@@ -5,9 +5,9 @@
 
 import com.tngtech.archunit.core.importer.Location;
 import com.tngtech.archunit.core.importer.Locations;
-import com.tngtech.archunit.example.SomeBusinessInterface;
-import com.tngtech.archunit.example.persistence.first.dao.SomeDao;
-import com.tngtech.archunit.example.service.impl.SomeInterfacePlacedInTheWrongPackage;
+import com.tngtech.archunit.example.layers.SomeBusinessInterface;
+import com.tngtech.archunit.example.layers.persistence.first.dao.SomeDao;
+import com.tngtech.archunit.example.layers.service.impl.SomeInterfacePlacedInTheWrongPackage;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/LayerDependencyRulesTest.java
Patch:
@@ -9,7 +9,7 @@
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
 
 @ArchTag("example")
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class LayerDependencyRulesTest {
 
     // 'access' catches only violations by real accesses, i.e. accessing a field, calling a method; compare 'dependOn' further down

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/MethodsTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.tngtech.archunit.exampletest.junit5;
 
-import com.tngtech.archunit.example.anticorruption.WrappedResult;
-import com.tngtech.archunit.example.security.Secured;
+import com.tngtech.archunit.example.layers.anticorruption.WrappedResult;
+import com.tngtech.archunit.example.layers.security.Secured;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
@@ -11,7 +11,7 @@
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noCodeUnits;
 
 @ArchTag("example")
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class MethodsTest {
 
     @ArchTest

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/OnionArchitectureTest.java
Patch:
@@ -8,9 +8,9 @@
 import static com.tngtech.archunit.library.Architectures.onionArchitecture;
 
 @ArchTag("example")
-@AnalyzeClasses(packages = "com.tngtech.archunit.onionarchitecture.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.onionarchitecture")
 public class OnionArchitectureTest {
-    private static final String BASE_PACKAGE = "com.tngtech.archunit.onionarchitecture.example";
+    private static final String BASE_PACKAGE = "com.tngtech.archunit.example.onionarchitecture";
 
     @ArchTest
     static final ArchRule onion_architecture_is_respected = onionArchitecture()

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/RestrictNumberOfClassesWithACertainPropertyTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.tngtech.archunit.exampletest.junit5;
 
-import com.tngtech.archunit.example.SomeBusinessInterface;
-import com.tngtech.archunit.example.SomeOtherBusinessInterface;
+import com.tngtech.archunit.example.layers.SomeBusinessInterface;
+import com.tngtech.archunit.example.layers.SomeOtherBusinessInterface;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
@@ -11,7 +11,7 @@
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
 
 @ArchTag("example")
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class RestrictNumberOfClassesWithACertainPropertyTest {
 
     @ArchTest

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/RuleLibraryTest.java
Patch:
@@ -6,7 +6,7 @@
 import com.tngtech.archunit.junit.ArchTest;
 
 @ArchTag("example")
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 class RuleLibraryTest {
     @ArchTest
     static final ArchRules LIBRARY = ArchRules.in(RuleSetsTest.class);

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/RuleSetsTest.java
Patch:
@@ -6,11 +6,11 @@
 import com.tngtech.archunit.junit.ArchTest;
 
 @ArchTag("example")
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 class RuleSetsTest {
     @ArchTest
     private final ArchRules CODING_RULES = ArchRules.in(CodingRulesTest.class);
 
     @ArchTest
-    private final ArchRules CYCLIC_DEPENDENCY_RULES = ArchRules.in(CyclicDependencyRulesTest.class);
+    private final ArchRules NAMING_CONVENTION_RULES = ArchRules.in(NamingConventionTest.class);
 }

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/SessionBeanRulesTest.java
Patch:
@@ -32,7 +32,7 @@
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
 
 @ArchTag("example")
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class SessionBeanRulesTest {
 
     @ArchTest

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/SlicesIsolationTest.java
Patch:
@@ -1,8 +1,8 @@
 package com.tngtech.archunit.exampletest.junit5;
 
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.example.controller.one.UseCaseOneTwoController;
-import com.tngtech.archunit.example.controller.two.UseCaseTwoController;
+import com.tngtech.archunit.example.layers.controller.one.UseCaseOneTwoController;
+import com.tngtech.archunit.example.layers.controller.two.UseCaseTwoController;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
@@ -14,7 +14,7 @@
 import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
 
 @ArchTag("example")
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class SlicesIsolationTest {
     @ArchTest
     static final ArchRule controllers_should_only_use_their_own_slice =

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/ThirdPartyRulesTest.java
Patch:
@@ -3,8 +3,8 @@
 import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.core.domain.JavaCall;
 import com.tngtech.archunit.core.domain.JavaClass;
-import com.tngtech.archunit.example.thirdparty.ThirdPartyClassWithProblem;
-import com.tngtech.archunit.example.thirdparty.ThirdPartyClassWorkaroundFactory;
+import com.tngtech.archunit.example.layers.thirdparty.ThirdPartyClassWithProblem;
+import com.tngtech.archunit.example.layers.thirdparty.ThirdPartyClassWorkaroundFactory;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
@@ -24,7 +24,7 @@
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
 
 @ArchTag("example")
-@AnalyzeClasses(packages = "com.tngtech.archunit.example")
+@AnalyzeClasses(packages = "com.tngtech.archunit.example.layers")
 public class ThirdPartyRulesTest {
 
     @ArchTest

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/complexcycles/slice1/ClassBeingCalledInSliceOne.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.cycle.complexcycles.slice1;
+package com.tngtech.archunit.example.cycles.complexcycles.slice1;
 
 public class ClassBeingCalledInSliceOne {
     public void doSomethingInSliceOne() {

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/complexcycles/slice1/ClassOfMinimalCycleCallingSliceTwo.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.cycle.complexcycles.slice1;
+package com.tngtech.archunit.example.cycles.complexcycles.slice1;
 
-import com.tngtech.archunit.example.cycle.complexcycles.slice2.ClassOfMinimalCycleCallingSliceOne;
+import com.tngtech.archunit.example.cycles.complexcycles.slice2.ClassOfMinimalCycleCallingSliceOne;
 
 public class ClassOfMinimalCycleCallingSliceTwo {
     private ClassOfMinimalCycleCallingSliceOne classInSliceTwo;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/complexcycles/slice1/SliceOneCallingConstructorInSliceTwoAndMethodInSliceThree.java
Patch:
@@ -1,7 +1,7 @@
-package com.tngtech.archunit.example.cycle.complexcycles.slice1;
+package com.tngtech.archunit.example.cycles.complexcycles.slice1;
 
-import com.tngtech.archunit.example.cycle.complexcycles.slice2.InstantiatedClassInSliceTwo;
-import com.tngtech.archunit.example.cycle.complexcycles.slice3.ClassCallingConstructorInSliceFive;
+import com.tngtech.archunit.example.cycles.complexcycles.slice2.InstantiatedClassInSliceTwo;
+import com.tngtech.archunit.example.cycles.complexcycles.slice3.ClassCallingConstructorInSliceFive;
 
 public class SliceOneCallingConstructorInSliceTwoAndMethodInSliceThree {
     private ClassCallingConstructorInSliceFive classInSliceThree;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/complexcycles/slice1/UnrelatedEnum.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.cycle.complexcycles.slice1;
+package com.tngtech.archunit.example.cycles.complexcycles.slice1;
 
 // This was just added for the integration tests since it creates some synthetic byte code
 @SuppressWarnings("SwitchStatementWithTooFewBranches")

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/complexcycles/slice2/ClassOfMinimalCycleCallingSliceOne.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.cycle.complexcycles.slice2;
+package com.tngtech.archunit.example.cycles.complexcycles.slice2;
 
-import com.tngtech.archunit.example.cycle.complexcycles.slice1.ClassOfMinimalCycleCallingSliceTwo;
+import com.tngtech.archunit.example.cycles.complexcycles.slice1.ClassOfMinimalCycleCallingSliceTwo;
 
 public class ClassOfMinimalCycleCallingSliceOne {
     private ClassOfMinimalCycleCallingSliceTwo classInSliceOne;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/complexcycles/slice4/ClassWithAccessedFieldCallingMethodInSliceOne.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.cycle.complexcycles.slice4;
+package com.tngtech.archunit.example.cycles.complexcycles.slice4;
 
-import com.tngtech.archunit.example.cycle.complexcycles.slice1.ClassBeingCalledInSliceOne;
+import com.tngtech.archunit.example.cycles.complexcycles.slice1.ClassBeingCalledInSliceOne;
 
 public class ClassWithAccessedFieldCallingMethodInSliceOne {
     private ClassBeingCalledInSliceOne classInSliceOne;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/constructorcycle/slice2/SliceTwoCallingConstructorInSliceOne.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.cycle.constructorcycle.slice2;
+package com.tngtech.archunit.example.cycles.constructorcycle.slice2;
 
-import com.tngtech.archunit.example.cycle.constructorcycle.slice1.SomeClassWithCalledConstructor;
+import com.tngtech.archunit.example.cycles.constructorcycle.slice1.SomeClassWithCalledConstructor;
 
 public class SliceTwoCallingConstructorInSliceOne {
     void callSliceOne() {

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/fieldaccesscycle/slice1/ClassInSliceOneWithAccessedField.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.cycle.fieldaccesscycle.slice1;
+package com.tngtech.archunit.example.cycles.fieldaccesscycle.slice1;
 
 public class ClassInSliceOneWithAccessedField {
     public String accessedField;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/fieldaccesscycle/slice1/SliceOneAccessingFieldInSliceTwo.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.cycle.fieldaccesscycle.slice1;
+package com.tngtech.archunit.example.cycles.fieldaccesscycle.slice1;
 
-import com.tngtech.archunit.example.cycle.fieldaccesscycle.slice2.SliceTwoAccessingFieldInSliceOne;
+import com.tngtech.archunit.example.cycles.fieldaccesscycle.slice2.SliceTwoAccessingFieldInSliceOne;
 
 public class SliceOneAccessingFieldInSliceTwo {
     private SliceTwoAccessingFieldInSliceOne classInSliceTwo;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/fieldaccesscycle/slice2/SliceTwoAccessingFieldInSliceOne.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.cycle.fieldaccesscycle.slice2;
+package com.tngtech.archunit.example.cycles.fieldaccesscycle.slice2;
 
-import com.tngtech.archunit.example.cycle.fieldaccesscycle.slice1.ClassInSliceOneWithAccessedField;
+import com.tngtech.archunit.example.cycles.fieldaccesscycle.slice1.ClassInSliceOneWithAccessedField;
 
 public class SliceTwoAccessingFieldInSliceOne {
     private ClassInSliceOneWithAccessedField classInSliceOne;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/membercycle/slice2/SliceTwoWithMethodParameterTypeInSliceThree.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.cycle.membercycle.slice2;
+package com.tngtech.archunit.example.cycles.membercycle.slice2;
 
-import com.tngtech.archunit.example.cycle.membercycle.slice3.SliceThreeWithMethodReturnTypeInSliceFour;
+import com.tngtech.archunit.example.cycles.membercycle.slice3.SliceThreeWithMethodReturnTypeInSliceFour;
 
 public class SliceTwoWithMethodParameterTypeInSliceThree {
     public void methodWithParameterInSliceThree(SliceThreeWithMethodReturnTypeInSliceFour methodParameter) {

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/membercycle/slice3/SliceThreeWithMethodReturnTypeInSliceFour.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.cycle.membercycle.slice3;
+package com.tngtech.archunit.example.cycles.membercycle.slice3;
 
-import com.tngtech.archunit.example.cycle.membercycle.slice4.SliceFourWithConstructorParameterInSliceOne;
+import com.tngtech.archunit.example.cycles.membercycle.slice4.SliceFourWithConstructorParameterInSliceOne;
 
 public class SliceThreeWithMethodReturnTypeInSliceFour {
     public SliceFourWithConstructorParameterInSliceOne methodWithReturnTypeInSliceFour() {

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/membercycle/slice4/SliceFourWithConstructorParameterInSliceOne.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.cycle.membercycle.slice4;
+package com.tngtech.archunit.example.cycles.membercycle.slice4;
 
-import com.tngtech.archunit.example.cycle.membercycle.slice1.SliceOneWithFieldTypeInSliceTwo;
+import com.tngtech.archunit.example.cycles.membercycle.slice1.SliceOneWithFieldTypeInSliceTwo;
 
 public class SliceFourWithConstructorParameterInSliceOne {
     public SliceFourWithConstructorParameterInSliceOne(SliceOneWithFieldTypeInSliceTwo fieldInSliceTwo) {

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/simplecycle/slice1/SliceOneCallingMethodInSliceTwo.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.cycle.simplecycle.slice1;
+package com.tngtech.archunit.example.cycles.simplecycle.slice1;
 
-import com.tngtech.archunit.example.cycle.simplecycle.slice2.SliceTwoCallingMethodOfSliceThree;
+import com.tngtech.archunit.example.cycles.simplecycle.slice2.SliceTwoCallingMethodOfSliceThree;
 
 public class SliceOneCallingMethodInSliceTwo {
     private SliceTwoCallingMethodOfSliceThree classInSliceTwo;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/simplecycle/slice1/SomeClassBeingCalledInSliceOne.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.cycle.simplecycle.slice1;
+package com.tngtech.archunit.example.cycles.simplecycle.slice1;
 
 public class SomeClassBeingCalledInSliceOne {
     public void doSomethingInSliceOne() {

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/simplecycle/slice2/SliceTwoCallingMethodOfSliceThree.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.cycle.simplecycle.slice2;
+package com.tngtech.archunit.example.cycles.simplecycle.slice2;
 
-import com.tngtech.archunit.example.cycle.simplecycle.slice3.SliceThreeCallingMethodOfSliceOne;
+import com.tngtech.archunit.example.cycles.simplecycle.slice3.SliceThreeCallingMethodOfSliceOne;
 
 public class SliceTwoCallingMethodOfSliceThree {
     private SliceThreeCallingMethodOfSliceOne classInSliceThree;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/simplecycle/slice3/SliceThreeCallingMethodOfSliceOne.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.cycle.simplecycle.slice3;
+package com.tngtech.archunit.example.cycles.simplecycle.slice3;
 
-import com.tngtech.archunit.example.cycle.simplecycle.slice1.SomeClassBeingCalledInSliceOne;
+import com.tngtech.archunit.example.cycles.simplecycle.slice1.SomeClassBeingCalledInSliceOne;
 
 public class SliceThreeCallingMethodOfSliceOne {
     private SomeClassBeingCalledInSliceOne someClassInSliceOne;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/simplescenario/administration/AdministrationService.java
Patch:
@@ -1,9 +1,9 @@
-package com.tngtech.archunit.example.cycle.simplescenario.administration;
+package com.tngtech.archunit.example.cycles.simplescenario.administration;
 
 import java.util.UUID;
 
-import com.tngtech.archunit.example.cycle.simplescenario.report.Report;
-import com.tngtech.archunit.example.cycle.simplescenario.report.ReportService;
+import com.tngtech.archunit.example.cycles.simplescenario.report.Report;
+import com.tngtech.archunit.example.cycles.simplescenario.report.ReportService;
 
 public class AdministrationService {
     private ReportService reportService;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/simplescenario/administration/Invoice.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.cycle.simplescenario.administration;
+package com.tngtech.archunit.example.cycles.simplescenario.administration;
 
 public class Invoice {
     public String getCustomer() {

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/simplescenario/importer/ImportService.java
Patch:
@@ -1,8 +1,8 @@
-package com.tngtech.archunit.example.cycle.simplescenario.importer;
+package com.tngtech.archunit.example.cycles.simplescenario.importer;
 
 import java.util.UUID;
 
-import com.tngtech.archunit.example.cycle.simplescenario.administration.AdministrationService;
+import com.tngtech.archunit.example.cycles.simplescenario.administration.AdministrationService;
 
 public class ImportService {
     private AdministrationService administrationService;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/simplescenario/report/Report.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.cycle.simplescenario.report;
+package com.tngtech.archunit.example.cycles.simplescenario.report;
 
 public class Report {
     public boolean isEmpty() {

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/cycles/simplescenario/report/ReportService.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.cycle.simplescenario.report;
+package com.tngtech.archunit.example.cycles.simplescenario.report;
 
-import com.tngtech.archunit.example.cycle.simplescenario.importer.ImportService;
+import com.tngtech.archunit.example.cycles.simplescenario.importer.ImportService;
 
 public class ReportService {
     private ImportService importService;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/AbstractController.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example;
+package com.tngtech.archunit.example.layers;
 
-import com.tngtech.archunit.example.web.InheritedControllerImpl;
+import com.tngtech.archunit.example.layers.web.InheritedControllerImpl;
 
 /**
  * For demo purpose only, see {@link InheritedControllerImpl}

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/ClassViolatingCodingRules.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example;
+package com.tngtech.archunit.example.layers;
 
 import java.io.FileNotFoundException;
 import java.io.PrintStream;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/ClassViolatingSessionBeanRules.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example;
+package com.tngtech.archunit.example.layers;
 
 import javax.annotation.PostConstruct;
 import javax.ejb.Local;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/EvilCoreAccessor.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example;
+package com.tngtech.archunit.example.layers;
 
-import com.tngtech.archunit.example.core.VeryCentralCore;
+import com.tngtech.archunit.example.layers.core.VeryCentralCore;
 
 @SuppressWarnings("unused")
 public class EvilCoreAccessor {

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/MyController.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example;
+package com.tngtech.archunit.example.layers;
 
 import java.lang.annotation.Retention;
 

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/MyService.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example;
+package com.tngtech.archunit.example.layers;
 
 import java.lang.annotation.Retention;
 

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/OtherClassViolatingSessionBeanRules.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example;
+package com.tngtech.archunit.example.layers;
 
 public class OtherClassViolatingSessionBeanRules {
     public static final String init = "init";

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/SecondBeanImplementingSomeBusinessInterface.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example;
+package com.tngtech.archunit.example.layers;
 
 import javax.ejb.Local;
 import javax.ejb.Stateless;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/SomeCustomException.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example;
+package com.tngtech.archunit.example.layers;
 
 public class SomeCustomException extends RuntimeException {
 }

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/SomeMediator.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example;
+package com.tngtech.archunit.example.layers;
 
-import com.tngtech.archunit.example.service.ServiceViolatingLayerRules;
+import com.tngtech.archunit.example.layers.service.ServiceViolatingLayerRules;
 
 public class SomeMediator {
     public static final String violateLayerRulesIndirectly = "violateLayerRulesIndirectly";

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/SomeOtherBusinessInterface.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example;
+package com.tngtech.archunit.example.layers;
 
 public interface SomeOtherBusinessInterface {
 }

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/anticorruption/WellBehaved.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.anticorruption;
+package com.tngtech.archunit.example.layers.anticorruption;
 
 public interface WellBehaved {
     WrappedResult someMethod();

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/anticorruption/WithIllegalReturnType.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.anticorruption;
+package com.tngtech.archunit.example.layers.anticorruption;
 
-import com.tngtech.archunit.example.anticorruption.internal.InternalType;
+import com.tngtech.archunit.example.layers.anticorruption.internal.InternalType;
 
 /**
  * We want classes in this layer to only return type {@link WrappedResult}, thus this interface here

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/controller/SomeController.java
Patch:
@@ -1,7 +1,7 @@
-package com.tngtech.archunit.example.controller;
+package com.tngtech.archunit.example.layers.controller;
 
-import com.tngtech.archunit.example.service.ServiceViolatingDaoRules;
-import com.tngtech.archunit.example.service.ServiceViolatingLayerRules;
+import com.tngtech.archunit.example.layers.service.ServiceViolatingDaoRules;
+import com.tngtech.archunit.example.layers.service.ServiceViolatingLayerRules;
 
 public class SomeController {
     private ServiceViolatingDaoRules service;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/controller/SomeGuiController.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.controller;
+package com.tngtech.archunit.example.layers.controller;
 
-import com.tngtech.archunit.example.service.ServiceHelper;
+import com.tngtech.archunit.example.layers.service.ServiceHelper;
 
 public class SomeGuiController {
     void callServiceLayer() {

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/controller/one/SomeEnum.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.controller.one;
+package com.tngtech.archunit.example.layers.controller.one;
 
 public enum SomeEnum {
     DISPATCH,

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/controller/one/UseCaseOneThreeController.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.controller.one;
+package com.tngtech.archunit.example.layers.controller.one;
 
-import com.tngtech.archunit.example.controller.three.UseCaseThreeController;
+import com.tngtech.archunit.example.layers.controller.three.UseCaseThreeController;
 
 @SuppressWarnings("unused")
 public class UseCaseOneThreeController {

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/controller/one/UseCaseOneTwoController.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.controller.one;
+package com.tngtech.archunit.example.layers.controller.one;
 
-import com.tngtech.archunit.example.controller.two.UseCaseTwoController;
+import com.tngtech.archunit.example.layers.controller.two.UseCaseTwoController;
 
 public class UseCaseOneTwoController {
     public static final String doSomethingOne = "doSomethingOne";

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/controller/three/UseCaseThreeController.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.controller.three;
+package com.tngtech.archunit.example.layers.controller.three;
 
-import com.tngtech.archunit.example.controller.one.UseCaseOneTwoController;
+import com.tngtech.archunit.example.layers.controller.one.UseCaseOneTwoController;
 
 public class UseCaseThreeController {
     public static final String doSomethingThree = "doSomethingThree";

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/controller/two/UseCaseTwoController.java
Patch:
@@ -1,7 +1,7 @@
-package com.tngtech.archunit.example.controller.two;
+package com.tngtech.archunit.example.layers.controller.two;
 
-import com.tngtech.archunit.example.AbstractController;
-import com.tngtech.archunit.example.controller.one.UseCaseOneTwoController;
+import com.tngtech.archunit.example.layers.AbstractController;
+import com.tngtech.archunit.example.layers.controller.one.UseCaseOneTwoController;
 
 public class UseCaseTwoController extends AbstractController {
     public static final String doSomethingTwo = "doSomethingTwo";

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/core/AnotherGoodCoreSatellite.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.core;
+package com.tngtech.archunit.example.layers.core;
 
 @SuppressWarnings("unused")
 public class AnotherGoodCoreSatellite implements CoreSatellite {

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/core/GoodCoreSatellite.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.core;
+package com.tngtech.archunit.example.layers.core;
 
 @SuppressWarnings("unused")
 public class GoodCoreSatellite implements CoreSatellite {

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/core/HighSecurity.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.core;
+package com.tngtech.archunit.example.layers.core;
 
 import java.lang.annotation.Retention;
 

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/core/VeryCentralCore.java
Patch:
@@ -1,7 +1,7 @@
-package com.tngtech.archunit.example.core;
+package com.tngtech.archunit.example.layers.core;
 
-import com.tngtech.archunit.example.SomeOtherBusinessInterface;
-import com.tngtech.archunit.example.web.AnnotatedController;
+import com.tngtech.archunit.example.layers.SomeOtherBusinessInterface;
+import com.tngtech.archunit.example.layers.web.AnnotatedController;
 
 @HighSecurity
 @SuppressWarnings("unused")

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/persistence/WrongSecurityCheck.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.persistence;
+package com.tngtech.archunit.example.layers.persistence;
 
 import java.io.File;
 import java.io.FileInputStream;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/persistence/first/dao/EntityInWrongPackage.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.persistence.first.dao;
+package com.tngtech.archunit.example.layers.persistence.first.dao;
 
 import javax.persistence.Entity;
 import javax.persistence.Id;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/persistence/first/dao/domain/PersistentObject.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.persistence.first.dao.domain;
+package com.tngtech.archunit.example.layers.persistence.first.dao.domain;
 
 import java.util.Objects;
 

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/persistence/second/dao/domain/OtherPersistentObject.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.persistence.second.dao.domain;
+package com.tngtech.archunit.example.layers.persistence.second.dao.domain;
 
 import java.util.Objects;
 

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/security/AdditionalSecurityChecks.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.security;
+package com.tngtech.archunit.example.layers.security;
 
 import java.security.cert.X509Certificate;
 

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/security/Secured.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.security;
+package com.tngtech.archunit.example.layers.security;
 
 import java.lang.annotation.Retention;
 

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/service/ServiceHelper.java
Patch:
@@ -1,6 +1,6 @@
-package com.tngtech.archunit.example.service;
+package com.tngtech.archunit.example.layers.service;
 
-import com.tngtech.archunit.example.security.Secured;
+import com.tngtech.archunit.example.layers.security.Secured;
 
 /**
  * Well modelled code always has lots of 'helpers' ;-)

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/service/impl/SomeInterfacePlacedInTheWrongPackage.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.service.impl;
+package com.tngtech.archunit.example.layers.service.impl;
 
 public interface SomeInterfacePlacedInTheWrongPackage {
 }

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/thirdparty/ThirdPartyClassWithProblem.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.thirdparty;
+package com.tngtech.archunit.example.layers.thirdparty;
 
 /**
  * This class simulates a problem with a third party class, where we can't influence the original code base.

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/thirdparty/ThirdPartyClassWorkaroundFactory.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.thirdparty;
+package com.tngtech.archunit.example.layers.thirdparty;
 
 /**
  * Assuming creation via this factory would provide some workaround for correct initialization in the given context.

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/layers/thirdparty/ThirdPartySubClassWithProblem.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.example.thirdparty;
+package com.tngtech.archunit.example.layers.thirdparty;
 
 public class ThirdPartySubClassWithProblem extends ThirdPartyClassWithProblem {
 }

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/plantuml/catalog/ProductCatalog.java
Patch:
@@ -1,9 +1,9 @@
-package com.tngtech.archunit.example.shopping.catalog;
+package com.tngtech.archunit.example.plantuml.catalog;
 
 import java.util.Set;
 
-import com.tngtech.archunit.example.shopping.order.Order;
-import com.tngtech.archunit.example.shopping.product.Product;
+import com.tngtech.archunit.example.plantuml.order.Order;
+import com.tngtech.archunit.example.plantuml.product.Product;
 
 public class ProductCatalog {
     private Set<Product> allProducts;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/plantuml/customer/Customer.java
Patch:
@@ -1,7 +1,7 @@
-package com.tngtech.archunit.example.shopping.customer;
+package com.tngtech.archunit.example.plantuml.customer;
 
-import com.tngtech.archunit.example.shopping.address.Address;
-import com.tngtech.archunit.example.shopping.order.Order;
+import com.tngtech.archunit.example.plantuml.address.Address;
+import com.tngtech.archunit.example.plantuml.order.Order;
 
 public class Customer {
     private Address address;

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/plantuml/product/Product.java
Patch:
@@ -1,7 +1,7 @@
-package com.tngtech.archunit.example.shopping.product;
+package com.tngtech.archunit.example.plantuml.product;
 
-import com.tngtech.archunit.example.shopping.customer.Customer;
-import com.tngtech.archunit.example.shopping.order.Order;
+import com.tngtech.archunit.example.plantuml.customer.Customer;
+import com.tngtech.archunit.example.plantuml.order.Order;
 
 public class Product {
     public Customer customer;

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/ControllerRulesTest.java
Patch:
@@ -6,7 +6,7 @@
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.domain.JavaMember;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
-import com.tngtech.archunit.example.security.Secured;
+import com.tngtech.archunit.example.layers.security.Secured;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
@@ -19,7 +19,7 @@
 @Category(Example.class)
 public class ControllerRulesTest {
 
-    private final JavaClasses classes = new ClassFileImporter().importPackages("com.tngtech.archunit.example");
+    private final JavaClasses classes = new ClassFileImporter().importPackages("com.tngtech.archunit.example.layers");
 
     @Test
     public void controllers_should_only_call_secured_methods() {

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/CyclicDependencyRulesTest.java
Patch:
@@ -3,8 +3,8 @@
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
-import com.tngtech.archunit.example.cycle.complexcycles.slice1.SliceOneCallingConstructorInSliceTwoAndMethodInSliceThree;
-import com.tngtech.archunit.example.cycle.complexcycles.slice3.ClassCallingConstructorInSliceFive;
+import com.tngtech.archunit.example.cycles.complexcycles.slice1.SliceOneCallingConstructorInSliceTwoAndMethodInSliceThree;
+import com.tngtech.archunit.example.cycles.complexcycles.slice3.ClassCallingConstructorInSliceFive;
 import com.tngtech.archunit.library.dependencies.SliceAssignment;
 import com.tngtech.archunit.library.dependencies.SliceIdentifier;
 import org.junit.Test;
@@ -17,7 +17,7 @@
 @Category(Example.class)
 public class CyclicDependencyRulesTest {
 
-    private final JavaClasses classes = new ClassFileImporter().importPackages("com.tngtech.archunit.example.cycle");
+    private final JavaClasses classes = new ClassFileImporter().importPackages("com.tngtech.archunit.example.cycles");
 
     @Test
     public void no_cycles_by_method_calls_between_slices() {

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/DaoRulesTest.java
Patch:
@@ -7,9 +7,9 @@
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
-import com.tngtech.archunit.example.persistence.first.InWrongPackageDao;
-import com.tngtech.archunit.example.persistence.second.dao.OtherDao;
-import com.tngtech.archunit.example.service.ServiceViolatingDaoRules;
+import com.tngtech.archunit.example.layers.persistence.first.InWrongPackageDao;
+import com.tngtech.archunit.example.layers.persistence.second.dao.OtherDao;
+import com.tngtech.archunit.example.layers.service.ServiceViolatingDaoRules;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/FrozenRulesTest.java
Patch:
@@ -5,7 +5,7 @@
 import com.tngtech.archunit.ArchConfiguration;
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
-import com.tngtech.archunit.example.ClassViolatingCodingRules;
+import com.tngtech.archunit.example.layers.ClassViolatingCodingRules;
 import com.tngtech.archunit.library.freeze.FreezingArchRule;
 import com.tngtech.archunit.library.freeze.ViolationLineMatcher;
 import com.tngtech.archunit.library.freeze.ViolationStore;

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/InterfaceRulesTest.java
Patch:
@@ -2,9 +2,9 @@
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
-import com.tngtech.archunit.example.SomeBusinessInterface;
-import com.tngtech.archunit.example.persistence.first.dao.SomeDao;
-import com.tngtech.archunit.example.service.impl.SomeInterfacePlacedInTheWrongPackage;
+import com.tngtech.archunit.example.layers.SomeBusinessInterface;
+import com.tngtech.archunit.example.layers.persistence.first.dao.SomeDao;
+import com.tngtech.archunit.example.layers.service.impl.SomeInterfacePlacedInTheWrongPackage;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/LayerDependencyRulesTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
-import com.tngtech.archunit.example.ClassViolatingCodingRules;
+import com.tngtech.archunit.example.layers.ClassViolatingCodingRules;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/MethodsTest.java
Patch:
@@ -2,8 +2,8 @@
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
-import com.tngtech.archunit.example.anticorruption.WrappedResult;
-import com.tngtech.archunit.example.security.Secured;
+import com.tngtech.archunit.example.layers.anticorruption.WrappedResult;
+import com.tngtech.archunit.example.layers.security.Secured;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
@@ -12,7 +12,7 @@
 
 @Category(Example.class)
 public class MethodsTest {
-    private final JavaClasses classes = new ClassFileImporter().importPackages("com.tngtech.archunit.example");
+    private final JavaClasses classes = new ClassFileImporter().importPackages("com.tngtech.archunit.example.layers");
 
     @Test
     public void all_public_methods_in_the_controller_layer_should_return_API_response_wrappers() {

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/OnionArchitectureTest.java
Patch:
@@ -9,7 +9,7 @@
 
 @Category(Example.class)
 public class OnionArchitectureTest {
-    private static final String BASE_PACKAGE = "com.tngtech.archunit.onionarchitecture.example";
+    private static final String BASE_PACKAGE = "com.tngtech.archunit.example.onionarchitecture";
 
     private final JavaClasses classes = new ClassFileImporter().importPackages(BASE_PACKAGE);
 

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/RestrictNumberOfClassesWithACertainPropertyTest.java
Patch:
@@ -2,8 +2,8 @@
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
-import com.tngtech.archunit.example.SomeBusinessInterface;
-import com.tngtech.archunit.example.SomeOtherBusinessInterface;
+import com.tngtech.archunit.example.layers.SomeBusinessInterface;
+import com.tngtech.archunit.example.layers.SomeOtherBusinessInterface;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
@@ -13,7 +13,7 @@
 @Category(Example.class)
 public class RestrictNumberOfClassesWithACertainPropertyTest {
 
-    private final JavaClasses classes = new ClassFileImporter().importPackages("com.tngtech.archunit.example");
+    private final JavaClasses classes = new ClassFileImporter().importPackages("com.tngtech.archunit.example.layers");
 
     @Test
     public void no_new_classes_should_implement_SomeBusinessInterface() {

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/SecurityTest.java
Patch:
@@ -16,18 +16,18 @@ public class SecurityTest {
     @Test
     public void only_security_infrastructure_should_use_java_security() {
         ArchRule rule = classes().that().resideInAPackage("java.security..")
-                .should().onlyBeAccessed().byAnyPackage("..example.security..", "java.security..")
+                .should().onlyBeAccessed().byAnyPackage("..example.layers.security..", "java.security..")
                 .because("we want to have one isolated cross-cutting concern 'security'");
 
-        JavaClasses classes = new ClassFileImporter().importPackages("com.tngtech.archunit.example", "java.security");
+        JavaClasses classes = new ClassFileImporter().importPackages("com.tngtech.archunit.example.layers", "java.security");
 
         rule.check(classes);
     }
 
     @Test
     public void only_security_infrastructure_should_use_java_security_on_whole_classpath() {
         ArchRule rule = classes().that().resideInAPackage("java.security.cert..")
-                .should().onlyBeAccessed().byAnyPackage("..example.security..", "java..", "..sun..", "javax..", "apple.security..");
+                .should().onlyBeAccessed().byAnyPackage("..example.layers.security..", "java..", "..sun..", "javax..", "apple.security..");
 
         JavaClasses classes = new ClassFileImporter().importClasspath(onlyAppAndRuntime());
 

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/SessionBeanRulesTest.java
Patch:
@@ -16,7 +16,7 @@
 import com.tngtech.archunit.core.domain.JavaFieldAccess;
 import com.tngtech.archunit.core.domain.properties.HasOwner;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
-import com.tngtech.archunit.example.ClassViolatingSessionBeanRules;
+import com.tngtech.archunit.example.layers.ClassViolatingSessionBeanRules;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ConditionEvents;
 import com.tngtech.archunit.lang.SimpleConditionEvent;

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/SlicesIsolationTest.java
Patch:
@@ -4,8 +4,8 @@
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
-import com.tngtech.archunit.example.controller.one.UseCaseOneTwoController;
-import com.tngtech.archunit.example.controller.two.UseCaseTwoController;
+import com.tngtech.archunit.example.layers.controller.one.UseCaseOneTwoController;
+import com.tngtech.archunit.example.layers.controller.two.UseCaseTwoController;
 import com.tngtech.archunit.library.dependencies.Slice;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
@@ -16,7 +16,7 @@
 @Category(Example.class)
 public class SlicesIsolationTest {
 
-    private final JavaClasses classes = new ClassFileImporter().importPackages("com.tngtech.archunit.example");
+    private final JavaClasses classes = new ClassFileImporter().importPackages("com.tngtech.archunit.example.layers");
 
     @Test
     public void controllers_should_only_use_their_own_slice() {

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/ThirdPartyRulesTest.java
Patch:
@@ -5,9 +5,9 @@
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
-import com.tngtech.archunit.example.ClassViolatingThirdPartyRules;
-import com.tngtech.archunit.example.thirdparty.ThirdPartyClassWithProblem;
-import com.tngtech.archunit.example.thirdparty.ThirdPartyClassWorkaroundFactory;
+import com.tngtech.archunit.example.layers.ClassViolatingThirdPartyRules;
+import com.tngtech.archunit.example.layers.thirdparty.ThirdPartyClassWithProblem;
+import com.tngtech.archunit.example.layers.thirdparty.ThirdPartyClassWorkaroundFactory;
 import com.tngtech.archunit.lang.ArchCondition;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/ExtensionIntegrationTest.java
Patch:
@@ -6,7 +6,7 @@
 import com.tngtech.archunit.ArchConfiguration;
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
-import com.tngtech.archunit.example.ClassViolatingCodingRules;
+import com.tngtech.archunit.example.layers.ClassViolatingCodingRules;
 import com.tngtech.archunit.exampletest.extension.EvaluatedRuleEvent;
 import com.tngtech.archunit.exampletest.extension.ExampleExtension;
 import com.tngtech.archunit.lang.ArchRule;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -98,7 +98,7 @@ public void visitSource(String source, String debug) {
 
     @Override
     public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
-        LOG.info("Analysing class '{}'", name);
+        LOG.debug("Analyzing class '{}'", name);
         JavaType javaType = JavaTypeImporter.createFromAsmObjectTypeName(name);
         if (alreadyImported(javaType)) {
             return;
@@ -202,7 +202,7 @@ public MethodVisitor visitMethod(int access, String name, String desc, String si
             return super.visitMethod(access, name, desc, signature, exceptions);
         }
 
-        LOG.debug("Analysing method {}.{}:{}", className, name, desc);
+        LOG.debug("Analyzing method {}.{}:{}", className, name, desc);
         accessHandler.setContext(new CodeUnit(name, namesOf(Type.getArgumentTypes(desc)), className));
 
         DomainBuilders.JavaCodeUnitBuilder<?, ?> codeUnitBuilder = addCodeUnitBuilder(name);
@@ -268,7 +268,7 @@ public void visitEnd() {
         }
 
         declarationHandler.onDeclaredAnnotations(annotations);
-        LOG.debug("Done analysing {}", className);
+        LOG.debug("Done analyzing {}", className);
     }
 
     private static List<String> namesOf(Type[] types) {

File: archunit/src/main/java/com/tngtech/archunit/library/freeze/FreezingArchRule.java
Patch:
@@ -27,7 +27,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
-import static com.tngtech.archunit.library.freeze.ViolationStore.Factory.FREEZE_STORE_PROPERTY;
+import static com.tngtech.archunit.library.freeze.ViolationStoreFactory.FREEZE_STORE_PROPERTY;
 
 /**
  * A decorator around an existing {@link ArchRule} that "freezes" the state of all violations on the first call instead of failing the test.
@@ -187,6 +187,6 @@ public String toString() {
      */
     @PublicAPI(usage = ACCESS)
     public static FreezingArchRule freeze(ArchRule rule) {
-        return new FreezingArchRule(rule, ViolationStore.Factory.create(), DefaultViolationLineMatcherFactory.create());
+        return new FreezingArchRule(rule, ViolationStoreFactory.create(), ViolationLineMatcherFactory.create());
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/library/freeze/TextFileBasedViolationStoreTest.java
Patch:
@@ -10,6 +10,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.io.Files;
 import com.tngtech.archunit.lang.ArchRule;
+import com.tngtech.archunit.library.freeze.ViolationStoreFactory.TextFileBasedViolationStore;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -21,15 +22,15 @@
 import static java.util.Arrays.asList;
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class DefaultViolationStoreFactoryTest {
+public class TextFileBasedViolationStoreTest {
 
     @Rule
     public final ExpectedException thrown = ExpectedException.none();
 
     @Rule
     public final TemporaryFolder temporaryFolder = new TemporaryFolder();
 
-    private final ViolationStore store = DefaultViolationStoreFactory.create();
+    private final ViolationStore store = new TextFileBasedViolationStore();
     private File configuredFolder;
 
     @Before

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/SessionBeanRulesTest.java
Patch:
@@ -46,7 +46,7 @@ public class SessionBeanRulesTest {
 
     @ArchTest
     static final ArchRule business_interface_implementations_should_be_unique =
-            classes().that(are(businessInterfaces())).should(haveAnUniqueImplementation());
+            classes().that(are(businessInterfaces())).should(haveAUniqueImplementation());
 
     private static DescribedPredicate<JavaFieldAccess> targetIsStatelessSessionBean() {
         return Get.<JavaFieldAccess, FieldAccessTarget>target()
@@ -88,8 +88,8 @@ private static DescribedPredicate<JavaClass> businessInterfaces() {
         return INTERFACES.and(haveLocalBeanSubclass()).as("business interfaces");
     }
 
-    private static ArchCondition<JavaClass> haveAnUniqueImplementation() {
-        return new ArchCondition<JavaClass>("have an unique implementation") {
+    private static ArchCondition<JavaClass> haveAUniqueImplementation() {
+        return new ArchCondition<JavaClass>("have a unique implementation") {
             @Override
             public void check(JavaClass businessInterface, ConditionEvents events) {
                 events.add(new SimpleConditionEvent(businessInterface,

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/SessionBeanRulesTest.java
Patch:
@@ -43,7 +43,7 @@ public class SessionBeanRulesTest {
 
     @ArchTest
     static final ArchRule business_interface_implementations_should_be_unique =
-            classes().that(are(businessInterfaces())).should(haveAnUniqueImplementation());
+            classes().that(are(businessInterfaces())).should(haveAUniqueImplementation());
 
     private static DescribedPredicate<JavaFieldAccess> targetIsStatelessSessionBean() {
         return Get.<JavaFieldAccess, FieldAccessTarget>target()
@@ -85,8 +85,8 @@ private static DescribedPredicate<JavaClass> businessInterfaces() {
         return INTERFACES.and(haveLocalBeanSubclass()).as("business interfaces");
     }
 
-    private static ArchCondition<JavaClass> haveAnUniqueImplementation() {
-        return new ArchCondition<JavaClass>("have an unique implementation") {
+    private static ArchCondition<JavaClass> haveAUniqueImplementation() {
+        return new ArchCondition<JavaClass>("have a unique implementation") {
             @Override
             public void check(JavaClass businessInterface, ConditionEvents events) {
                 events.add(new SimpleConditionEvent(businessInterface,

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/SessionBeanRulesTest.java
Patch:
@@ -46,7 +46,7 @@ public void stateless_session_beans_should_not_have_state() {
 
     @Test
     public void business_interface_implementations_should_be_unique() {
-        classes().that(are(BUSINESS_INTERFACES)).should(HAVE_AN_UNIQUE_IMPLEMENTATION).check(classes);
+        classes().that(are(BUSINESS_INTERFACES)).should(HAVE_A_UNIQUE_IMPLEMENTATION).check(classes);
     }
 
     private static final DescribedPredicate<JavaFieldAccess> TARGET_IS_STATELESS_SESSION_BEAN =
@@ -85,8 +85,8 @@ private boolean isLocalBeanImplementation(JavaClass bean, JavaClass businessInte
     private static final DescribedPredicate<JavaClass> BUSINESS_INTERFACES =
             INTERFACES.and(HAVE_LOCAL_BEAN_SUBCLASS).as("business interfaces");
 
-    private static final ArchCondition<JavaClass> HAVE_AN_UNIQUE_IMPLEMENTATION =
-            new ArchCondition<JavaClass>("have an unique implementation") {
+    private static final ArchCondition<JavaClass> HAVE_A_UNIQUE_IMPLEMENTATION =
+            new ArchCondition<JavaClass>("have a unique implementation") {
                 @Override
                 public void check(JavaClass businessInterface, ConditionEvents events) {
                     events.add(new SimpleConditionEvent(businessInterface,

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/ExamplesIntegrationTest.java
Patch:
@@ -983,7 +983,7 @@ public String getDescription() {
                         .setting().field(ClassViolatingSessionBeanRules.class, "state")
                         .inLine(13))
 
-                .ofRule("classes that are business interfaces should have an unique implementation")
+                .ofRule("classes that are business interfaces should have a unique implementation")
                 .by(someBusinessInterfaceIsImplementedByTwoBeans)
 
                 .toDynamicTests();

File: archunit/src/main/java/com/tngtech/archunit/lang/extension/ArchUnitExtension.java
Patch:
@@ -41,11 +41,11 @@
 @PublicAPI(usage = INHERITANCE, state = EXPERIMENTAL)
 public interface ArchUnitExtension {
     /**
-     * An unique String, identifying this extension, so ArchUnit can associate configured properties. The
+     * A unique String, identifying this extension, so ArchUnit can associate configured properties. The
      * String must not contain '<b>.</b>' (dot). The return value MUST BE UNIQUE between all configured extensions,
      * or an exception will be thrown, thus it's good practice, to use some company specific namespace.
      *
-     * @return An unique String identifier of this extension
+     * @return A unique String identifier of this extension
      */
     String getUniqueIdentifier();
 

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceIdentifier.java
Patch:
@@ -29,7 +29,7 @@
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
 /**
- * An unique identifier of a {@link Slice}. All {@link JavaClasses} that are assigned to the same
+ * A unique identifier of a {@link Slice}. All {@link JavaClasses} that are assigned to the same
  * {@link SliceIdentifier} are considered to belong to the same {@link Slice}.<br>
  * A {@link SliceIdentifier} consists of textual parts. Two {@link SliceIdentifier} are considered to
  * be equal if and only if their parts are equal. The parts can also be referred to from

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Dependency.java
Patch:
@@ -116,11 +116,13 @@ public JavaClass getTargetClass() {
     }
 
     @Override
+    @PublicAPI(usage = ACCESS)
     public String getDescription() {
         return description;
     }
 
     @Override
+    @PublicAPI(usage = ACCESS)
     public SourceCodeLocation getSourceCodeLocation() {
         return sourceCodeLocation;
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaAnnotation.java
Patch:
@@ -79,11 +79,13 @@ public final class JavaAnnotation implements HasType {
      */
     @Override
     @Deprecated
+    @PublicAPI(usage = ACCESS)
     public JavaClass getType() {
         return getRawType();
     }
 
     @Override
+    @PublicAPI(usage = ACCESS)
     public JavaClass getRawType() {
         return type;
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClassList.java
Patch:
@@ -17,9 +17,9 @@
 
 import java.util.List;
 
-import com.google.common.collect.ForwardingList;
 import com.google.common.collect.ImmutableList;
 import com.tngtech.archunit.PublicAPI;
+import com.tngtech.archunit.base.ForwardingList;
 import com.tngtech.archunit.base.Function;
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ThrowsDeclaration.java
Patch:
@@ -98,6 +98,7 @@ public JavaClass getDeclaringClass() {
      */
     @Override
     @Deprecated
+    @PublicAPI(usage = ACCESS)
     public JavaClass getType() {
         return getRawType();
     }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileSource.java
Patch:
@@ -37,6 +37,7 @@
 import com.google.common.collect.FluentIterable;
 import com.tngtech.archunit.Internal;
 
+@Internal
 interface ClassFileSource extends Iterable<ClassFileLocation> {
     @Internal
     class FromFilePath extends SimpleFileVisitor<Path> implements ClassFileSource {
@@ -60,7 +61,7 @@ public Iterator<ClassFileLocation> iterator() {
         }
 
         @Override
-        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
+        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
             if (shouldBeConsidered(file)) {
                 classFileLocations.add(new InputStreamSupplierClassFileLocation(file.toUri(), newInputStreamSupplierFor(file)));
             }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenFieldsConjunction.java
Patch:
@@ -41,8 +41,10 @@ public interface GivenFieldsConjunction extends GivenMembersConjunction<JavaFiel
     GivenFieldsConjunction or(DescribedPredicate<? super JavaField> predicate);
 
     @Override
+    @PublicAPI(usage = ACCESS)
     FieldsShouldConjunction should(ArchCondition<? super JavaField> condition);
 
     @Override
+    @PublicAPI(usage = ACCESS)
     FieldsShould<?> should();
 }

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Slice.java
Patch:
@@ -21,9 +21,9 @@
 import java.util.Set;
 
 import com.google.common.base.Joiner;
-import com.google.common.collect.ForwardingSet;
 import com.google.common.collect.ImmutableSet;
 import com.tngtech.archunit.PublicAPI;
+import com.tngtech.archunit.base.ForwardingSet;
 import com.tngtech.archunit.base.HasDescription;
 import com.tngtech.archunit.core.domain.Dependency;
 import com.tngtech.archunit.core.domain.JavaClass;
@@ -81,6 +81,7 @@ protected Set<JavaClass> delegate() {
     }
 
     @Override
+    @PublicAPI(usage = ACCESS)
     public String getDescription() {
         return description.format(matchingGroups);
     }
@@ -95,6 +96,7 @@ public String getDescription() {
      * @return Same slice with different description
      */
     @Override
+    @PublicAPI(usage = ACCESS)
     public Slice as(String pattern) {
         return new Slice(sliceAssignment, matchingGroups, new Description(pattern), classes);
     }

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceDependency.java
Patch:
@@ -65,6 +65,7 @@ public Slice getTarget() {
     }
 
     @Override
+    @PublicAPI(usage = ACCESS)
     public String getDescription() {
         return String.format("%s calls %s:%n%s",
                 origin.getDescription(),

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/syntax/GivenNamedSlices.java
Patch:
@@ -29,8 +29,10 @@ public interface GivenNamedSlices extends GivenObjects<Slice>, CanOverrideDescri
     SlicesShould should();
 
     @Override
+    @PublicAPI(usage = ACCESS)
     GivenNamedSlices as(String newDescription);
 
     @Override
+    @PublicAPI(usage = ACCESS)
     GivenSlicesConjunction that(DescribedPredicate<? super Slice> predicate);
 }
\ No newline at end of file

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/syntax/GivenSlices.java
Patch:
@@ -24,5 +24,6 @@ public interface GivenSlices extends GivenNamedSlices {
     GivenNamedSlices namingSlices(String pattern);
 
     @Override
+    @PublicAPI(usage = ACCESS)
     GivenSlices as(String newDescription);
 }
\ No newline at end of file

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/syntax/GivenSlicesConjunction.java
Patch:
@@ -28,9 +28,11 @@ public interface GivenSlicesConjunction extends GivenConjunction<Slice> {
     SlicesShould should();
 
     @Override
+    @PublicAPI(usage = ACCESS)
     GivenSlicesConjunction and(DescribedPredicate<? super Slice> predicate);
 
     @Override
+    @PublicAPI(usage = ACCESS)
     GivenSlicesConjunction or(DescribedPredicate<? super Slice> predicate);
 
     @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -102,7 +102,7 @@ JavaClasses complete() {
         for (RawAccessRecord constructorCallRecord : importRecord.getRawConstructorCallRecords()) {
             tryProcess(constructorCallRecord, AccessRecord.Factory.forConstructorCallRecord(), processedConstructorCallRecords);
         }
-        return createJavaClasses(classes.getDirectlyImported(), this);
+        return createJavaClasses(classes.getDirectlyImported(), classes.getAll(), this);
     }
 
     private void ensureCallTargetsArePresent() {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/FieldsShould.java
Patch:
@@ -55,7 +55,7 @@ public interface FieldsShould<CONJUNCTION extends FieldsShouldConjunction> exten
      *
      * <pre><code>
      * class Example {
-     *     Object someField;
+     *     String someField;
      * }</code></pre>
      *
      * @param type Type fields should not have
@@ -95,7 +95,7 @@ public interface FieldsShould<CONJUNCTION extends FieldsShouldConjunction> exten
      *
      * <pre><code>
      * class Example {
-     *     Object someField;
+     *     String someField;
      * }</code></pre>
      *
      * @param typeName Name of type fields should not have
@@ -135,7 +135,7 @@ public interface FieldsShould<CONJUNCTION extends FieldsShouldConjunction> exten
      *
      * <pre><code>
      * class Example {
-     *     Object someField;
+     *     String someField;
      * }</code></pre>
      *
      * @param predicate A predicate determining which sort of types fields should not have

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasThrowsClause.java
Patch:
@@ -42,7 +42,8 @@ private Predicates() {
         }
 
         @PublicAPI(usage = ACCESS)
-        public static DescribedPredicate<HasThrowsClause<?>> throwsClauseWithTypes(final Class<?>... types) {
+        @SafeVarargs
+        public static DescribedPredicate<HasThrowsClause<?>> throwsClauseWithTypes(final Class<? extends Throwable>... types) {
             return throwsClauseWithTypes(namesOf(types));
         }
 
@@ -58,7 +59,7 @@ public static DescribedPredicate<HasThrowsClause<?>> throwsClauseWithTypes(final
         }
 
         @PublicAPI(usage = ACCESS)
-        public static DescribedPredicate<HasThrowsClause<?>> throwsClauseContainingType(final Class<?> type) {
+        public static DescribedPredicate<HasThrowsClause<?>> throwsClauseContainingType(final Class<? extends Throwable> type) {
             return throwsClauseContainingType(type.getName());
         }
 

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasThrowsClauseTest.java
Patch:
@@ -27,7 +27,7 @@ public void predicate_throwsClauseWithTypes_by_type() {
                 .hasDescription(String.format("throws types [%s, %s]", FirstException.class.getName(), SecondException.class.getName()));
         assertThat(HasThrowsClause.Predicates.throwsClauseWithTypes(FirstException.class)).rejects(hasThrowsClause);
         assertThat(HasThrowsClause.Predicates.throwsClauseWithTypes(SecondException.class)).rejects(hasThrowsClause);
-        assertThat(HasThrowsClause.Predicates.throwsClauseWithTypes(Object.class)).rejects(hasThrowsClause);
+        assertThat(HasThrowsClause.Predicates.throwsClauseWithTypes(RuntimeException.class)).rejects(hasThrowsClause);
     }
 
     @Test

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/ExpectedConstructor.java
Patch:
@@ -22,9 +22,10 @@ private Creator(Class<?> clazz, Class<?>[] params) {
         }
 
         public ExpectedMessage beingAnnotatedWith(Class<? extends Annotation> annotationType) {
-            return new ExpectedMessage(String.format("%s is annotated with @%s",
+            return new ExpectedMessage(String.format("Constructor <%s> is annotated with @%s in (%s.java:0)",
                     formatMethod(clazz.getName(), JavaConstructor.CONSTRUCTOR_NAME, JavaClass.namesOf(params)),
-                    annotationType.getSimpleName()));
+                    annotationType.getSimpleName(),
+                    clazz.getSimpleName()));
         }
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/FieldsThatInternal.java
Patch:
@@ -23,7 +23,7 @@
 import static com.tngtech.archunit.core.domain.properties.HasType.Predicates.rawType;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.have;
 
-public class FieldsThatInternal extends MembersThatInternal<JavaField, GivenFieldsInternal>
+class FieldsThatInternal extends MembersThatInternal<JavaField, GivenFieldsInternal>
         implements FieldsThat<GivenFieldsInternal> {
 
     FieldsThatInternal(GivenFieldsInternal givenFields, PredicateAggregator<JavaField> currentPredicate) {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/MembersDeclaredInClassesThat.java
Patch:
@@ -40,7 +40,7 @@
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.are;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.have;
 
-public class MembersDeclaredInClassesThat<MEMBER extends JavaMember, CONJUNCTION extends GivenMembersConjunction<MEMBER>>
+class MembersDeclaredInClassesThat<MEMBER extends JavaMember, CONJUNCTION extends GivenMembersConjunction<MEMBER>>
         implements ClassesThat<CONJUNCTION> {
     private final Function<DescribedPredicate<? super JavaClass>, CONJUNCTION> predicateAggregator;
 

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/MembersThatInternal.java
Patch:
@@ -36,7 +36,7 @@
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.are;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.have;
 
-public class MembersThatInternal<
+class MembersThatInternal<
         MEMBER extends JavaMember,
         CONJUNCTION extends AbstractGivenMembersInternal<MEMBER, CONJUNCTION>
         >

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenFields.java
Patch:
@@ -23,6 +23,7 @@
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
 public interface GivenFields extends GivenMembers<JavaField> {
+
     @Override
     @PublicAPI(usage = ACCESS)
     FieldsThat<?> that();

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/CodeUnitsThat.java
Patch:
@@ -25,7 +25,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
-public interface CodeUnitsThat<CONJUNCTION> extends MembersThat<CONJUNCTION> {
+public interface CodeUnitsThat<CONJUNCTION extends GivenCodeUnitsConjunction<?>> extends MembersThat<CONJUNCTION> {
 
     /**
      * Matches {@link JavaCodeUnit JavaCodeUnits} that have the specified raw parameter types.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenMembersConjunction.java
Patch:
@@ -43,5 +43,5 @@ public interface GivenMembersConjunction<MEMBER extends JavaMember> extends Give
     MembersShouldConjunction<MEMBER> should(ArchCondition<? super MEMBER> condition);
 
     @PublicAPI(usage = ACCESS)
-    MembersShould<MembersShouldConjunction<MEMBER>> should();
+    MembersShould<? extends MembersShouldConjunction<MEMBER>> should();
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MembersShould.java
Patch:
@@ -27,7 +27,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
-public interface MembersShould<CONJUNCTION> {
+public interface MembersShould<CONJUNCTION extends MembersShouldConjunction<?>> {
 
     /**
      * Asserts that members have a certain name (i.e. field name, method name or {@link JavaConstructor#CONSTRUCTOR_NAME}).

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MembersShouldConjunction.java
Patch:
@@ -27,11 +27,11 @@ public interface MembersShouldConjunction<MEMBER extends JavaMember> extends Arc
     MembersShouldConjunction<MEMBER> andShould(ArchCondition<? super MEMBER> condition);
 
     @PublicAPI(usage = ACCESS)
-    MembersShould<MembersShouldConjunction<MEMBER>> andShould();
+    MembersShould<? extends MembersShouldConjunction<MEMBER>> andShould();
 
     @PublicAPI(usage = ACCESS)
     MembersShouldConjunction<MEMBER> orShould(ArchCondition<? super MEMBER> condition);
 
     @PublicAPI(usage = ACCESS)
-    MembersShould<MembersShouldConjunction<MEMBER>> orShould();
+    MembersShould<? extends MembersShouldConjunction<MEMBER>> orShould();
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MembersThat.java
Patch:
@@ -27,7 +27,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
-public interface MembersThat<CONJUNCTION> {
+public interface MembersThat<CONJUNCTION extends GivenMembersConjunction<?>> {
 
     /**
      * Matches members by their name (i.e. field name, method name or {@link JavaConstructor#CONSTRUCTOR_NAME}).

File: archunit/src/test/java/com/tngtech/archunit/testutil/syntax/MethodCallChainTest.java
Patch:
@@ -115,7 +115,7 @@ private <T> MethodCallChain createCallChainStart(Class<T> startInterface, T star
     }
 
     private void invokeNext(MethodCallChain callChain) {
-        callChain.invokeNextMethodCandidate(new Parameters("FIXME", Collections.<Parameter>emptyList()));
+        callChain.invokeNextMethodCandidate(new Parameters(Collections.<Parameter>emptyList()));
     }
 
     private static class CallChainTestCase<T> {

File: archunit/src/test/java/com/tngtech/archunit/testutil/syntax/Parameter.java
Patch:
@@ -11,11 +11,11 @@ class Parameter {
         this.description = description;
     }
 
-    public Object getValue() {
+    Object getValue() {
         return value;
     }
 
-    public String getDescription() {
+    String getDescription() {
         return description;
     }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/ArchRule.java
Patch:
@@ -33,7 +33,6 @@
 import com.tngtech.archunit.lang.extension.EvaluatedRule;
 import com.tngtech.archunit.lang.syntax.ArchRuleDefinition;
 import com.tngtech.archunit.lang.syntax.elements.ClassesShould;
-import com.tngtech.archunit.lang.syntax.elements.ClassesShouldThat;
 import com.tngtech.archunit.lang.syntax.elements.ClassesThat;
 import com.tngtech.archunit.lang.syntax.elements.GivenClasses;
 
@@ -46,7 +45,7 @@
  * To define a rule, use one of the factory methods within {@link ArchRuleDefinition}, for example
  * <br><br><pre><code>
  * ArchRule rule = {@link ArchRuleDefinition#noClasses()}.{@link GivenClasses#that() that()}.{@link ClassesThat#resideInAPackage(String) resideInAPackage("..svc..")}
- *                     .{@link GivenClasses#should() should()}.{@link ClassesShould#accessClassesThat() accessClassesThat()}.{@link ClassesShouldThat#resideInAPackage(String) resideInAPackage("..ui..")};
+ *                     .{@link GivenClasses#should() should()}.{@link ClassesShould#accessClassesThat() accessClassesThat()}.{@link ClassesThat#resideInAPackage(String) resideInAPackage("..ui..")};
  * rule.check(importedJavaClasses);
  * </code></pre>
  * <br>

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ClassesShouldThatInternal.java
Patch:
@@ -29,7 +29,7 @@
 import com.tngtech.archunit.lang.EvaluationResult;
 import com.tngtech.archunit.lang.syntax.elements.ClassesShould;
 import com.tngtech.archunit.lang.syntax.elements.ClassesShouldConjunction;
-import com.tngtech.archunit.lang.syntax.elements.ClassesShouldThat;
+import com.tngtech.archunit.lang.syntax.elements.ClassesThat;
 
 import static com.tngtech.archunit.base.DescribedPredicate.dont;
 import static com.tngtech.archunit.base.DescribedPredicate.not;
@@ -42,7 +42,7 @@
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.are;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.have;
 
-class ClassesShouldThatInternal implements ClassesShouldThat, ClassesShouldConjunction {
+class ClassesShouldThatInternal implements ClassesThat<ClassesShouldConjunction>, ClassesShouldConjunction {
     private final ClassesShouldInternal classesShould;
     private final PredicateAggregator<JavaClass> predicateAggregator;
     private final Function<DescribedPredicate<JavaClass>, ArchCondition<JavaClass>> createCondition;

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassesThatInternal.java
Patch:
@@ -21,8 +21,8 @@
 import com.tngtech.archunit.core.domain.JavaAnnotation;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaModifier;
+import com.tngtech.archunit.lang.syntax.elements.ClassesThat;
 import com.tngtech.archunit.lang.syntax.elements.GivenClassesConjunction;
-import com.tngtech.archunit.lang.syntax.elements.GivenClassesThat;
 
 import static com.tngtech.archunit.base.DescribedPredicate.dont;
 import static com.tngtech.archunit.base.DescribedPredicate.not;
@@ -36,7 +36,7 @@
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.are;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.have;
 
-class GivenClassesThatInternal implements GivenClassesThat {
+class GivenClassesThatInternal implements ClassesThat<GivenClassesConjunction> {
     private final GivenClassesInternal givenClasses;
     private final PredicateAggregator<JavaClass> currentPredicate;
 

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/OnlyBeAccessedSpecificationInternal.java
Patch:
@@ -21,7 +21,7 @@
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.conditions.ArchConditions;
 import com.tngtech.archunit.lang.syntax.elements.ClassesShouldConjunction;
-import com.tngtech.archunit.lang.syntax.elements.ClassesShouldThat;
+import com.tngtech.archunit.lang.syntax.elements.ClassesThat;
 import com.tngtech.archunit.lang.syntax.elements.OnlyBeAccessedSpecification;
 
 import static com.tngtech.archunit.lang.conditions.ArchConditions.onlyBeAccessedByAnyPackage;
@@ -40,7 +40,7 @@ public ClassesShouldConjunction byAnyPackage(String... packageIdentifiers) {
     }
 
     @Override
-    public ClassesShouldThat byClassesThat() {
+    public ClassesThat<ClassesShouldConjunction> byClassesThat() {
         return new ClassesShouldThatInternal(classesShould, new Function<DescribedPredicate<JavaClass>, ArchCondition<JavaClass>>() {
             @Override
             public ArchCondition<JavaClass> apply(DescribedPredicate<JavaClass> predicate) {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenClasses.java
Patch:
@@ -27,7 +27,7 @@ public interface GivenClasses extends GivenObjects<JavaClass> {
     ClassesShould should();
 
     @PublicAPI(usage = ACCESS)
-    GivenClassesThat that();
+    ClassesThat<GivenClassesConjunction> that();
 
     @Override
     GivenClassesConjunction that(DescribedPredicate<? super JavaClass> predicate);

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenClassesConjunction.java
Patch:
@@ -38,7 +38,7 @@ public interface GivenClassesConjunction extends GivenConjunction<JavaClass> {
      * @see #and(DescribedPredicate)
      */
     @PublicAPI(usage = ACCESS)
-    GivenClassesThat and();
+    ClassesThat<GivenClassesConjunction> and();
 
     @Override
     @PublicAPI(usage = ACCESS)
@@ -48,5 +48,5 @@ public interface GivenClassesConjunction extends GivenConjunction<JavaClass> {
      * @see #or(DescribedPredicate)
      */
     @PublicAPI(usage = ACCESS)
-    GivenClassesThat or();
+    ClassesThat<GivenClassesConjunction> or();
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/OnlyBeAccessedSpecification.java
Patch:
@@ -36,7 +36,7 @@ public interface OnlyBeAccessedSpecification<CONJUNCTION> {
      * @return A syntax element that allows restricting which classes the access should be from
      */
     @PublicAPI(usage = ACCESS)
-    ClassesShouldThat byClassesThat();
+    ClassesThat<ClassesShouldConjunction> byClassesThat();
 
     /**
      * @param predicate Restricts which classes the access should be from

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/ClassesThatTestsExistTest.java
Patch:
@@ -28,7 +28,7 @@ public void for_each_context_all_syntax_elements_are_tested() {
                 Set<Method> testMethods = getMethodsStartingWith(entry.getElement(), testClass);
                 assertThat(testMethods.size())
                         .as("Number of tests in %s to cover %s.%s(..)", testClass.getSimpleName(),
-                                ClassesShouldThat.class.getSimpleName(), entry.getElement())
+                                ClassesThat.class.getSimpleName(), entry.getElement())
                         .isGreaterThanOrEqualTo(entry.getCount());
             }
         }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassInternal.java
Patch:
@@ -42,7 +42,7 @@ public ClassesShould should() {
     }
 
     @Override
-    public ClassesShouldConjunction should(ArchCondition<JavaClass> condition) {
-        return new ClassesShouldInternal(classesTransformer, priority, condition, prepareCondition);
+    public ClassesShouldConjunction should(ArchCondition<? super JavaClass> condition) {
+        return new ClassesShouldInternal(classesTransformer, priority, condition.<JavaClass>forSubType(), prepareCondition);
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenClass.java
Patch:
@@ -26,5 +26,5 @@ public interface GivenClass {
     ClassesShould should();
 
     @PublicAPI(usage = ACCESS)
-    ClassesShouldConjunction should(ArchCondition<JavaClass> condition);
+    ClassesShouldConjunction should(ArchCondition<? super JavaClass> condition);
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/MembersThat.java
Patch:
@@ -39,7 +39,7 @@ public interface MembersThat<CONJUNCTION> {
     CONJUNCTION haveName(String name);
 
     /**
-     * Matches members that don't have a certain name (i.e. field name, method name or {@link JavaConstructor#CONSTRUCTOR_NAME}).
+     * Matches members that do not have a certain name (i.e. field name, method name or {@link JavaConstructor#CONSTRUCTOR_NAME}).
      *
      * @param name The member name
      * @return A syntax conjunction element, which can be completed to form a full rule

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/ClassesShouldTest.java
Patch:
@@ -1387,7 +1387,7 @@ static String singleLineFailureReportOf(EvaluationResult result) {
         return result.getFailureReport().toString().replaceAll("\\r?\\n", FAILURE_REPORT_NEWLINE_MARKER);
     }
 
-    private static DescribedPredicate<JavaAnnotation> annotation(final Class<? extends Annotation> type) {
+    static DescribedPredicate<JavaAnnotation> annotation(final Class<? extends Annotation> type) {
         return new DescribedPredicate<JavaAnnotation>("@" + type.getSimpleName()) {
             @Override
             public boolean apply(JavaAnnotation input) {

File: archunit-integration-test/src/test/java/com/tngtech/archunit/PublicAPIRules.java
Patch:
@@ -249,7 +249,7 @@ private static DescribedPredicate<JavaAnnotation> publicApiForInheritance() {
         return new DescribedPredicate<JavaAnnotation>("@%s(usage = %s)", PublicAPI.class.getSimpleName(), INHERITANCE) {
             @Override
             public boolean apply(JavaAnnotation input) {
-                return input.getType().isEquivalentTo(PublicAPI.class) &&
+                return input.getRawType().isEquivalentTo(PublicAPI.class) &&
                         input.as(PublicAPI.class).usage() == INHERITANCE;
             }
         };

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Dependency.java
Patch:
@@ -76,7 +76,7 @@ static Dependency fromInheritance(JavaClass origin, JavaClass targetSuperType) {
     }
 
     static Dependency fromField(JavaField field) {
-        return createDependencyFromJavaMember(field, "has type", field.getType());
+        return createDependencyFromJavaMember(field, "has type", field.getRawType());
     }
 
     static Dependency fromReturnType(JavaMethod method) {
@@ -88,7 +88,7 @@ static Dependency fromParameter(JavaCodeUnit codeUnit, JavaClass parameter) {
     }
 
     static Dependency fromThrowsDeclaration(ThrowsDeclaration<? extends JavaCodeUnit> declaration) {
-        return createDependencyFromJavaMember(declaration.getLocation(), "throws type", declaration.getType());
+        return createDependencyFromJavaMember(declaration.getLocation(), "throws type", declaration.getRawType());
     }
 
     private static Dependency createDependencyFromJavaMember(JavaMember origin, String dependencyType, JavaClass target) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -58,7 +58,7 @@
 import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Utils.toAnnotationOfType;
 import static com.tngtech.archunit.core.domain.properties.HasName.Functions.GET_NAME;
 import static com.tngtech.archunit.core.domain.properties.HasReturnType.Functions.GET_RAW_RETURN_TYPE;
-import static com.tngtech.archunit.core.domain.properties.HasType.Functions.GET_TYPE;
+import static com.tngtech.archunit.core.domain.properties.HasType.Functions.GET_RAW_TYPE;
 
 public class JavaClass implements HasName, HasAnnotations, HasModifiers {
     private final Optional<Source> source;
@@ -187,7 +187,7 @@ public boolean isMetaAnnotatedWith(Class<? extends Annotation> type) {
     @Override
     public boolean isMetaAnnotatedWith(String typeName) {
         for (JavaAnnotation annotation : annotations.get().values()) {
-            if (annotation.getType().isAnnotatedWith(typeName) || annotation.getType().isMetaAnnotatedWith(typeName)) {
+            if (annotation.getRawType().isAnnotatedWith(typeName) || annotation.getRawType().isMetaAnnotatedWith(typeName)) {
                 return true;
             }
         }
@@ -851,7 +851,7 @@ private Set<Dependency> inheritanceDependenciesFromSelf() {
 
     private Set<Dependency> fieldDependenciesFromSelf() {
         ImmutableSet.Builder<Dependency> result = ImmutableSet.builder();
-        for (JavaField field : nonPrimitive(getFields(), GET_TYPE)) {
+        for (JavaField field : nonPrimitive(getFields(), GET_RAW_TYPE)) {
             result.add(Dependency.fromField(field));
         }
         return result.build();

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMember.java
Patch:
@@ -113,7 +113,7 @@ public boolean isMetaAnnotatedWith(Class<? extends Annotation> type) {
     @Override
     public boolean isMetaAnnotatedWith(String typeName) {
         for (JavaAnnotation annotation : annotations.get().values()) {
-            if (annotation.getType().isAnnotatedWith(typeName) || annotation.getType().isMetaAnnotatedWith(typeName)) {
+            if (annotation.getRawType().isAnnotatedWith(typeName) || annotation.getRawType().isMetaAnnotatedWith(typeName)) {
                 return true;
             }
         }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasThrowsClause.java
Patch:
@@ -31,7 +31,7 @@
 import static com.tngtech.archunit.core.domain.JavaClass.namesOf;
 import static com.tngtech.archunit.core.domain.JavaClassList.GET_NAMES;
 import static com.tngtech.archunit.core.domain.properties.HasName.Predicates.name;
-import static com.tngtech.archunit.core.domain.properties.HasType.Functions.GET_TYPE;
+import static com.tngtech.archunit.core.domain.properties.HasType.Functions.GET_RAW_TYPE;
 
 public interface HasThrowsClause<LOCATION extends HasParameterTypes & HasReturnType & HasName.AndFullName & CanBeAnnotated & HasOwner<JavaClass>> {
     @PublicAPI(usage = ACCESS)
@@ -69,7 +69,7 @@ public static DescribedPredicate<HasThrowsClause<?>> throwsClauseContainingType(
 
         @PublicAPI(usage = ACCESS)
         public static DescribedPredicate<HasThrowsClause<?>> throwsClauseContainingType(DescribedPredicate<? super JavaClass> predicate) {
-            DescribedPredicate<ThrowsDeclaration<?>> declarationPredicate = GET_TYPE.is(predicate).forSubType();
+            DescribedPredicate<ThrowsDeclaration<?>> declarationPredicate = GET_RAW_TYPE.is(predicate).forSubType();
             return throwsClause(anyElementThat(declarationPredicate)).as("throws clause containing type " + predicate.getDescription());
         }
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -285,7 +285,7 @@ private static class MemberDependenciesByTarget {
 
         void registerFields(Set<JavaField> fields) {
             for (JavaField field : fields) {
-                fieldTypeDependencies.put(field.getType(), field);
+                fieldTypeDependencies.put(field.getRawType(), field);
             }
         }
 
@@ -296,7 +296,7 @@ void registerMethods(Set<JavaMethod> methods) {
                 }
                 methodReturnTypeDependencies.put(method.getRawReturnType(), method);
                 for (ThrowsDeclaration<JavaMethod> throwsDeclaration : method.getThrowsClause()) {
-                    methodsThrowsDeclarationDependencies.put(throwsDeclaration.getType(), throwsDeclaration);
+                    methodsThrowsDeclarationDependencies.put(throwsDeclaration.getRawType(), throwsDeclaration);
                 }
             }
         }
@@ -307,7 +307,7 @@ void registerConstructors(Set<JavaConstructor> constructors) {
                     constructorParameterTypeDependencies.put(parameter, constructor);
                 }
                 for (ThrowsDeclaration<JavaConstructor> throwsDeclaration : constructor.getThrowsClause()) {
-                    constructorThrowsDeclarationDependencies.put(throwsDeclaration.getType(), throwsDeclaration);
+                    constructorThrowsDeclarationDependencies.put(throwsDeclaration.getRawType(), throwsDeclaration);
                 }
             }
         }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/DomainBuilders.java
Patch:
@@ -69,7 +69,7 @@ static Map<String, JavaAnnotation> buildAnnotations(Set<JavaAnnotationBuilder> a
         ImmutableMap.Builder<String, JavaAnnotation> result = ImmutableMap.builder();
         for (JavaAnnotationBuilder annotationBuilder : annotations) {
             JavaAnnotation javaAnnotation = annotationBuilder.build(importedClasses);
-            result.put(javaAnnotation.getType().getName(), javaAnnotation);
+            result.put(javaAnnotation.getRawType().getName(), javaAnnotation);
         }
         return result.build();
     }
@@ -314,7 +314,6 @@ JavaClassBuilder withSourceFileName(String sourceFileName) {
             return this;
         }
 
-        @SuppressWarnings("unchecked")
         JavaClassBuilder withType(JavaType javaType) {
             this.javaType = javaType;
             return this;

File: archunit/src/main/java/com/tngtech/archunit/library/GeneralCodingRules.java
Patch:
@@ -35,7 +35,7 @@
 import static com.tngtech.archunit.core.domain.properties.HasName.Predicates.name;
 import static com.tngtech.archunit.core.domain.properties.HasOwner.Predicates.With.owner;
 import static com.tngtech.archunit.core.domain.properties.HasParameterTypes.Predicates.rawParameterTypes;
-import static com.tngtech.archunit.core.domain.properties.HasType.Functions.GET_TYPE;
+import static com.tngtech.archunit.core.domain.properties.HasType.Functions.GET_RAW_TYPE;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.accessField;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.callCodeUnitWhere;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.callMethodWhere;
@@ -122,7 +122,7 @@ private static ArchCondition<JavaClass> throwGenericExceptions() {
     @PublicAPI(usage = ACCESS)
     public static final ArchCondition<JavaClass> USE_JAVA_UTIL_LOGGING =
             setFieldWhere(resideInAPackage("java.util.logging..")
-                    .onResultOf(Get.<JavaFieldAccess, FieldAccessTarget>target().then(GET_TYPE)))
+                    .onResultOf(Get.<JavaFieldAccess, FieldAccessTarget>target().then(GET_RAW_TYPE)))
                     .as("use java.util.logging");
 
     /**

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportTestUtils.java
Patch:
@@ -243,7 +243,7 @@ public static AccessTarget.FieldAccessTarget targetFrom(JavaField field) {
         return new DomainBuilders.FieldAccessTargetBuilder()
                 .withOwner(field.getOwner())
                 .withName(field.getName())
-                .withType(field.getType())
+                .withType(field.getRawType())
                 .withField(Suppliers.ofInstance(Optional.of(field)))
                 .build();
     }
@@ -316,7 +316,7 @@ private static ImmutableMap<String, JavaAnnotation> annotationsFor(Class<?> inpu
                 .uniqueIndex(new Function<JavaAnnotation, String>() {
                     @Override
                     public String apply(JavaAnnotation input) {
-                        return input.getType().getName();
+                        return input.getRawType().getName();
                     }
                 });
     }

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/ClassesShouldTest.java
Patch:
@@ -1391,7 +1391,7 @@ private static DescribedPredicate<JavaAnnotation> annotation(final Class<? exten
         return new DescribedPredicate<JavaAnnotation>("@" + type.getSimpleName()) {
             @Override
             public boolean apply(JavaAnnotation input) {
-                return input.getType().getName().equals(type.getName());
+                return input.getRawType().getName().equals(type.getName());
             }
         };
     }

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -379,7 +379,7 @@ private ThrowsDeclarationAssertion(ThrowsDeclaration<?> throwsDeclaration) {
         }
 
         public void matches(Class<?> clazz) {
-            assertThat(actual.getType()).as("Type of " + actual)
+            assertThat(actual.getRawType()).as("Type of " + actual)
                     .matches(clazz);
         }
     }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaFieldAssertion.java
Patch:
@@ -13,6 +13,7 @@ public JavaFieldAssertion(JavaField javaField) {
 
     public void isEquivalentTo(Field field) {
         super.isEquivalentTo(field);
+        assertThat(actual.getRawType()).matches(field.getType());
         assertThat(actual.getType()).matches(field.getType());
     }
 }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/PublicAPIRules.java
Patch:
@@ -116,7 +116,7 @@ public boolean apply(JavaMember input) {
 
             private boolean equivalentMethod(JavaMethod method, String name, Class<?>... paramTypes) {
                 return method.getName().equals(name) &&
-                        method.getParameters().getNames().equals(JavaClass.namesOf(paramTypes));
+                        method.getRawParameterTypes().getNames().equals(JavaClass.namesOf(paramTypes));
             }
 
             private boolean enumMethod(JavaMethod methodToCheck, String name, Class<?>... paramTypes) {
@@ -216,7 +216,7 @@ private boolean inheritsFromSuperMethod(JavaMember input) {
 
             private boolean isPublicAPISuperMethod(JavaMethod candidate, JavaMethod methodToCheck) {
                 return candidate.getName().equals(methodToCheck.getName()) &&
-                        candidate.getParameters().equals(methodToCheck.getParameters()) &&
+                        candidate.getRawParameterTypes().equals(methodToCheck.getRawParameterTypes()) &&
                         candidate.isAnnotatedWith(PublicAPI.class);
             }
         };

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/ExpectedMember.java
Patch:
@@ -63,7 +63,7 @@ <T extends HasOwner<JavaClass> & HasName> boolean matches(T member) {
 
     private List<String> getParameters(Object member) {
         return member instanceof HasParameterTypes ?
-                ((HasParameterTypes) member).getParameters().getNames() :
+                ((HasParameterTypes) member).getRawParameterTypes().getNames() :
                 emptyList();
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaConstructor.java
Patch:
@@ -89,10 +89,10 @@ private class ReflectConstructorSupplier implements Supplier<Constructor<?>> {
         public Constructor<?> get() {
             Class<?> reflectedOwner = getOwner().reflect();
             try {
-                return reflectedOwner.getDeclaredConstructor(reflect(getParameters()));
+                return reflectedOwner.getDeclaredConstructor(reflect(getRawParameterTypes()));
             } catch (NoSuchMethodException e) {
                 throw new InconsistentClassPathException(
-                        "Can't resolve constructor " + formatMethod(reflectedOwner.getName(), getName(), getParameters()), e);
+                        "Can't resolve constructor " + formatMethod(reflectedOwner.getName(), getName(), getRawParameterTypes()), e);
             }
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMethod.java
Patch:
@@ -95,10 +95,10 @@ private class ReflectMethodSupplier implements Supplier<Method> {
         public Method get() {
             Class<?> reflectedOwner = getOwner().reflect();
             try {
-                return reflectedOwner.getDeclaredMethod(getName(), reflect(getParameters()));
+                return reflectedOwner.getDeclaredMethod(getName(), reflect(getRawParameterTypes()));
             } catch (NoSuchMethodException e) {
                 throw new InconsistentClassPathException(
-                        "Can't resolve method " + formatMethod(reflectedOwner.getName(), getName(), getParameters()), e);
+                        "Can't resolve method " + formatMethod(reflectedOwner.getName(), getName(), getRawParameterTypes()), e);
             }
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -291,7 +291,7 @@ void registerFields(Set<JavaField> fields) {
 
         void registerMethods(Set<JavaMethod> methods) {
             for (JavaMethod method : methods) {
-                for (JavaClass parameter : method.getParameters()) {
+                for (JavaClass parameter : method.getRawParameterTypes()) {
                     methodParameterTypeDependencies.put(parameter, method);
                 }
                 methodReturnTypeDependencies.put(method.getRawReturnType(), method);
@@ -303,7 +303,7 @@ void registerMethods(Set<JavaMethod> methods) {
 
         void registerConstructors(Set<JavaConstructor> constructors) {
             for (JavaConstructor constructor : constructors) {
-                for (JavaClass parameter : constructor.getParameters()) {
+                for (JavaClass parameter : constructor.getRawParameterTypes()) {
                     constructorParameterTypeDependencies.put(parameter, constructor);
                 }
                 for (ThrowsDeclaration<JavaConstructor> throwsDeclaration : constructor.getThrowsClause()) {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/RawAccessRecord.java
Patch:
@@ -100,7 +100,6 @@ public String getName() {
             return name;
         }
 
-        @SuppressWarnings("unchecked")
         public List<String> getParameters() {
             return parameters;
         }
@@ -140,7 +139,7 @@ public String toString() {
 
         public boolean is(JavaCodeUnit method) {
             return getName().equals(method.getName())
-                    && getParameters().equals(method.getParameters().getNames())
+                    && getParameters().equals(method.getRawParameterTypes().getNames())
                     && getDeclaringClassName().equals(method.getOwner().getName());
         }
     }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassTest.java
Patch:
@@ -127,7 +127,7 @@ public void inner_class_has_package_of_declaring_class() {
     @Test
     public void Array_class_has_default_package() {
         JavaClass arrayType = importClassWithContext(Arrays.class)
-                .getMethod("toString", Object[].class).getParameters().get(0);
+                .getMethod("toString", Object[].class).getRawParameterTypes().get(0);
 
         assertThat(arrayType.getPackageName()).isEmpty();
     }
@@ -308,7 +308,7 @@ private Condition<JavaCodeUnit> equivalentCodeUnit(final Class<?> owner, final S
             public boolean matches(JavaCodeUnit value) {
                 return value.getOwner().isEquivalentTo(owner) &&
                         value.getName().equals(methodName) &&
-                        value.getParameters().getNames().equals(ImmutableList.of(paramType.getName()));
+                        value.getRawParameterTypes().getNames().equals(ImmutableList.of(paramType.getName()));
             }
         };
     }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/TestUtils.java
Patch:
@@ -243,7 +243,7 @@ private <T extends JavaCall<?>> T findMethod(Set<T> callsFromSelf,
             for (T call : callsFromSelf) {
                 if (call.getTargetOwner().isEquivalentTo(targetOwner) &&
                         call.getTarget().getName().equals(methodName) &&
-                        call.getTarget().getParameters().getNames().equals(paramNames)) {
+                        call.getTarget().getRawParameterTypes().getNames().equals(paramNames)) {
                     return call;
                 }
             }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportTestUtils.java
Patch:
@@ -233,7 +233,7 @@ private static <E extends Enum<?>> JavaEnumConstant enumConstant(E value) {
     public static AccessTarget.ConstructorCallTarget targetFrom(JavaConstructor target) {
         return new DomainBuilders.ConstructorCallTargetBuilder()
                 .withOwner(target.getOwner())
-                .withParameters(target.getParameters())
+                .withParameters(target.getRawParameterTypes())
                 .withReturnType(target.getRawReturnType())
                 .withConstructor(Suppliers.ofInstance(Optional.of(target)))
                 .build();
@@ -252,7 +252,7 @@ public static MethodCallTarget targetFrom(JavaMethod target, Supplier<Set<JavaMe
         return new DomainBuilders.MethodCallTargetBuilder()
                 .withOwner(target.getOwner())
                 .withName(target.getName())
-                .withParameters(target.getParameters())
+                .withParameters(target.getRawParameterTypes())
                 .withReturnType(target.getRawReturnType())
                 .withMethods(resolveSupplier)
                 .build();

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -217,7 +217,7 @@ public Condition<JavaAccess<?>> toConstructor(final Class<?> targetClass, final
                     @Override
                     public boolean matches(JavaAccess<?> access) {
                         return to(targetClass, CONSTRUCTOR_NAME).matches(access) &&
-                                ((ConstructorCallTarget) access.getTarget()).getParameters().getNames().equals(paramTypeNames);
+                                ((ConstructorCallTarget) access.getTarget()).getRawParameterTypes().getNames().equals(paramTypeNames);
                     }
                 };
             }

File: archunit/src/test/java/com/tngtech/archunit/testutil/Conditions.java
Patch:
@@ -26,7 +26,7 @@ public static Condition<JavaCodeUnit> codeUnitWithSignature(final String name, f
         return new Condition<JavaCodeUnit>() {
             @Override
             public boolean matches(JavaCodeUnit value) {
-                return name.equals(value.getName()) && namesOf(parameters).equals(value.getParameters().getNames());
+                return name.equals(value.getName()) && namesOf(parameters).equals(value.getRawParameterTypes().getNames());
             }
         }.as("matches signature <" + name + ", " + namesOf(parameters) + ">");
     }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaCodeUnitAssertion.java
Patch:
@@ -9,21 +9,23 @@
 
 public class JavaCodeUnitAssertion<T extends JavaCodeUnit, SELF extends JavaCodeUnitAssertion<T, SELF>>
         extends JavaMemberAssertion<T, SELF> {
-    
+
     public JavaCodeUnitAssertion(T javaMember, Class<SELF> selfType) {
         super(javaMember, selfType);
     }
 
     public void isEquivalentTo(Method method) {
         super.isEquivalentTo(method);
         assertThat(actual.getParameters()).matches(method.getParameterTypes());
+        assertThat(actual.getRawParameterTypes()).matches(method.getParameterTypes());
         assertThat(actual.getReturnType()).matches(method.getReturnType());
         assertThat(actual.getRawReturnType()).matches(method.getReturnType());
     }
 
     public void isEquivalentTo(Constructor<?> constructor) {
         super.isEquivalentTo(constructor);
         assertThat(actual.getParameters()).matches(constructor.getParameterTypes());
+        assertThat(actual.getRawParameterTypes()).matches(constructor.getParameterTypes());
         assertThat(actual.getReturnType()).matches(void.class);
         assertThat(actual.getRawReturnType()).matches(void.class);
     }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenCodeUnitsInternal.java
Patch:
@@ -20,7 +20,6 @@
 import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.JavaCodeUnit;
 import com.tngtech.archunit.lang.ArchCondition;
-import com.tngtech.archunit.lang.ArchRule;
 import com.tngtech.archunit.lang.ClassesTransformer;
 import com.tngtech.archunit.lang.Priority;
 import com.tngtech.archunit.lang.syntax.elements.GivenCodeUnits;
@@ -87,8 +86,8 @@ private GivenCodeUnitsInternal(
         }
 
         @Override
-        public ArchRule should(ArchCondition<? super JavaCodeUnit> condition) {
-            return new CodeUnitsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaCodeUnit>forSubType(), prepareCondition);
+        public CodeUnitsShouldInternal<JavaCodeUnit> should(ArchCondition<? super JavaCodeUnit> condition) {
+            return new CodeUnitsShouldInternal<>(finishedClassesTransformer(), priority, condition.<JavaCodeUnit>forSubType(), prepareCondition);
         }
 
         private static class GivenCodeUnitsFactory implements Factory<JavaCodeUnit, GivenCodeUnitsInternal> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenMembersInternal.java
Patch:
@@ -20,7 +20,6 @@
 import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.JavaMember;
 import com.tngtech.archunit.lang.ArchCondition;
-import com.tngtech.archunit.lang.ArchRule;
 import com.tngtech.archunit.lang.ClassesTransformer;
 import com.tngtech.archunit.lang.Priority;
 import com.tngtech.archunit.lang.syntax.elements.GivenMembers;
@@ -57,7 +56,7 @@ public MembersThatInternal<MEMBER, SELF> or() {
     }
 
     @Override
-    public ArchRule should(ArchCondition<? super MEMBER> condition) {
+    public MembersShouldInternal<MEMBER> should(ArchCondition<? super MEMBER> condition) {
         return new MembersShouldInternal<>(finishedClassesTransformer(), priority, condition.<MEMBER>forSubType(), this.prepareCondition);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ConstructorsShouldInternal.java
Patch:
@@ -21,7 +21,7 @@
 import com.tngtech.archunit.lang.ClassesTransformer;
 import com.tngtech.archunit.lang.Priority;
 
-class ConstructorsShouldInternal extends ObjectsShouldInternal<JavaConstructor> {
+class ConstructorsShouldInternal extends CodeUnitsShouldInternal<JavaConstructor> {
 
     ConstructorsShouldInternal(
             ClassesTransformer<? extends JavaConstructor> classesTransformer,

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/FieldsShouldInternal.java
Patch:
@@ -21,7 +21,7 @@
 import com.tngtech.archunit.lang.ClassesTransformer;
 import com.tngtech.archunit.lang.Priority;
 
-class FieldsShouldInternal extends ObjectsShouldInternal<JavaField> {
+class FieldsShouldInternal extends MembersShouldInternal<JavaField> {
 
     FieldsShouldInternal(
             ClassesTransformer<? extends JavaField> classesTransformer,

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenConstructorsInternal.java
Patch:
@@ -20,7 +20,6 @@
 import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.JavaConstructor;
 import com.tngtech.archunit.lang.ArchCondition;
-import com.tngtech.archunit.lang.ArchRule;
 import com.tngtech.archunit.lang.ClassesTransformer;
 import com.tngtech.archunit.lang.Priority;
 import com.tngtech.archunit.lang.syntax.elements.GivenConstructors;
@@ -58,7 +57,7 @@ private GivenConstructorsInternal(
     }
 
     @Override
-    public ArchRule should(ArchCondition<? super JavaConstructor> condition) {
+    public ConstructorsShouldInternal should(ArchCondition<? super JavaConstructor> condition) {
         return new ConstructorsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaConstructor>forSubType(), prepareCondition);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenMethodsInternal.java
Patch:
@@ -20,13 +20,13 @@
 import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.JavaMethod;
 import com.tngtech.archunit.lang.ArchCondition;
-import com.tngtech.archunit.lang.ArchRule;
 import com.tngtech.archunit.lang.ClassesTransformer;
 import com.tngtech.archunit.lang.Priority;
 import com.tngtech.archunit.lang.syntax.elements.GivenMethods;
 import com.tngtech.archunit.lang.syntax.elements.GivenMethodsConjunction;
 
-class GivenMethodsInternal extends AbstractGivenCodeUnitsInternal<JavaMethod, GivenMethodsInternal>
+class GivenMethodsInternal
+        extends AbstractGivenCodeUnitsInternal<JavaMethod, GivenMethodsInternal>
         implements GivenMethods, GivenMethodsConjunction {
 
     GivenMethodsInternal(Priority priority, ClassesTransformer<JavaMethod> classesTransformer) {
@@ -58,7 +58,7 @@ private GivenMethodsInternal(
     }
 
     @Override
-    public ArchRule should(ArchCondition<? super JavaMethod> condition) {
+    public MethodsShouldInternal should(ArchCondition<? super JavaMethod> condition) {
         return new MethodsShouldInternal(finishedClassesTransformer(), priority, condition.<JavaMethod>forSubType(), prepareCondition);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/MethodsShouldInternal.java
Patch:
@@ -21,7 +21,7 @@
 import com.tngtech.archunit.lang.ClassesTransformer;
 import com.tngtech.archunit.lang.Priority;
 
-class MethodsShouldInternal extends ObjectsShouldInternal<JavaMethod> {
+class MethodsShouldInternal extends CodeUnitsShouldInternal<JavaMethod> {
 
     MethodsShouldInternal(
             ClassesTransformer<? extends JavaMethod> classesTransformer,

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/MethodsTest.java
Patch:
@@ -58,9 +58,9 @@ private static ArchCondition<JavaMethod> returnType(final Class<?> type) {
         return new ArchCondition<JavaMethod>("return type " + type.getName()) {
             @Override
             public void check(JavaMethod method, ConditionEvents events) {
-                boolean typeMatches = method.getReturnType().isAssignableTo(type);
+                boolean typeMatches = method.getRawReturnType().isAssignableTo(type);
                 String message = String.format("%s returns %s in %s",
-                        method.getFullName(), method.getReturnType().getName(),
+                        method.getFullName(), method.getRawReturnType().getName(),
                         formatLocation(method.getOwner(), 0));
                 events.add(new SimpleConditionEvent(method, typeMatches, message));
             }

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/MethodsTest.java
Patch:
@@ -55,9 +55,9 @@ private static ArchCondition<JavaMethod> returnType(final Class<?> type) {
         return new ArchCondition<JavaMethod>("return type " + type.getName()) {
             @Override
             public void check(JavaMethod method, ConditionEvents events) {
-                boolean typeMatches = method.getReturnType().isAssignableTo(type);
+                boolean typeMatches = method.getRawReturnType().isAssignableTo(type);
                 String message = String.format("%s returns %s in %s",
-                        method.getFullName(), method.getReturnType().getName(),
+                        method.getFullName(), method.getRawReturnType().getName(),
                         formatLocation(method.getOwner(), 0));
                 events.add(new SimpleConditionEvent(method, typeMatches, message));
             }

File: archunit-example/example-plain/src/test/java/com/tngtech/archunit/exampletest/MethodsTest.java
Patch:
@@ -59,9 +59,9 @@ private static ArchCondition<JavaMethod> returnType(final Class<?> type) {
         return new ArchCondition<JavaMethod>("return type " + type.getName()) {
             @Override
             public void check(JavaMethod method, ConditionEvents events) {
-                boolean typeMatches = method.getReturnType().isAssignableTo(type);
+                boolean typeMatches = method.getRawReturnType().isAssignableTo(type);
                 String message = String.format("%s returns %s in %s",
-                        method.getFullName(), method.getReturnType().getName(),
+                        method.getFullName(), method.getRawReturnType().getName(),
                         formatLocation(method.getOwner(), 0));
                 events.add(new SimpleConditionEvent(method, typeMatches, message));
             }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Dependency.java
Patch:
@@ -80,7 +80,7 @@ static Dependency fromField(JavaField field) {
     }
 
     static Dependency fromReturnType(JavaMethod method) {
-        return createDependencyFromJavaMember(method, "has return type", method.getReturnType());
+        return createDependencyFromJavaMember(method, "has return type", method.getRawReturnType());
     }
 
     static Dependency fromParameter(JavaCodeUnit codeUnit, JavaClass parameter) {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -294,7 +294,7 @@ void registerMethods(Set<JavaMethod> methods) {
                 for (JavaClass parameter : method.getParameters()) {
                     methodParameterTypeDependencies.put(parameter, method);
                 }
-                methodReturnTypeDependencies.put(method.getReturnType(), method);
+                methodReturnTypeDependencies.put(method.getRawReturnType(), method);
                 for (ThrowsDeclaration<JavaMethod> throwsDeclaration : method.getThrowsClause()) {
                     methodsThrowsDeclarationDependencies.put(throwsDeclaration.getType(), throwsDeclaration);
                 }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -654,7 +654,7 @@ private Optional<Class<?>> determineComponentType(ClassesByTypeName importedClas
             }
 
             private Optional<Class<?>> determineComponentTypeFromReturnValue(Optional<JavaMethod> method) {
-                String name = method.get().getReturnType().getName();
+                String name = method.get().getRawReturnType().getName();
                 Optional<Class<?>> result = AnnotationTypeConversion.tryConvert(name);
                 if (result.isPresent()) {
                     return Optional.<Class<?>>of(result.get().getComponentType());

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassTest.java
Patch:
@@ -71,14 +71,14 @@ public class JavaClassTest {
     public void finds_array_type() {
         JavaMethod method = importClassWithContext(IsArrayTestClass.class).getMethod("anArray");
 
-        assertThat(method.getReturnType().isArray()).isTrue();
+        assertThat(method.getRawReturnType().isArray()).isTrue();
     }
 
     @Test
     public void finds_non_array_type() {
         JavaMethod method = importClassWithContext(IsArrayTestClass.class).getMethod("notAnArray");
 
-        assertThat(method.getReturnType().isArray()).isFalse();
+        assertThat(method.getRawReturnType().isArray()).isFalse();
     }
 
     @Test

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportTestUtils.java
Patch:
@@ -121,7 +121,7 @@ private static Set<DomainBuilders.JavaAnnotationBuilder> javaAnnotationBuildersF
         return result.build();
     }
 
-    static JavaClass javaClassFor(Class<?> owner) {
+    private static JavaClass javaClassFor(Class<?> owner) {
         return new DomainBuilders.JavaClassBuilder()
                 .withType(JavaType.From.name(owner.getName()))
                 .withInterface(owner.isInterface())
@@ -234,7 +234,7 @@ public static AccessTarget.ConstructorCallTarget targetFrom(JavaConstructor targ
         return new DomainBuilders.ConstructorCallTargetBuilder()
                 .withOwner(target.getOwner())
                 .withParameters(target.getParameters())
-                .withReturnType(target.getReturnType())
+                .withReturnType(target.getRawReturnType())
                 .withConstructor(Suppliers.ofInstance(Optional.of(target)))
                 .build();
     }
@@ -253,7 +253,7 @@ public static MethodCallTarget targetFrom(JavaMethod target, Supplier<Set<JavaMe
                 .withOwner(target.getOwner())
                 .withName(target.getName())
                 .withParameters(target.getParameters())
-                .withReturnType(target.getReturnType())
+                .withReturnType(target.getRawReturnType())
                 .withMethods(resolveSupplier)
                 .build();
     }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaCodeUnitAssertion.java
Patch:
@@ -9,6 +9,7 @@
 
 public class JavaCodeUnitAssertion<T extends JavaCodeUnit, SELF extends JavaCodeUnitAssertion<T, SELF>>
         extends JavaMemberAssertion<T, SELF> {
+    
     public JavaCodeUnitAssertion(T javaMember, Class<SELF> selfType) {
         super(javaMember, selfType);
     }
@@ -17,11 +18,13 @@ public void isEquivalentTo(Method method) {
         super.isEquivalentTo(method);
         assertThat(actual.getParameters()).matches(method.getParameterTypes());
         assertThat(actual.getReturnType()).matches(method.getReturnType());
+        assertThat(actual.getRawReturnType()).matches(method.getReturnType());
     }
 
     public void isEquivalentTo(Constructor<?> constructor) {
         super.isEquivalentTo(constructor);
         assertThat(actual.getParameters()).matches(constructor.getParameterTypes());
         assertThat(actual.getReturnType()).matches(void.class);
+        assertThat(actual.getRawReturnType()).matches(void.class);
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenFieldsConjunction.java
Patch:
@@ -22,6 +22,7 @@
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
 public interface GivenFieldsConjunction extends GivenMembersConjunction<JavaField> {
+
     @Override
     @PublicAPI(usage = ACCESS)
     FieldsThat<? extends GivenFieldsConjunction> and();

File: archunit/src/main/java/com/tngtech/archunit/library/GeneralCodingRules.java
Patch:
@@ -34,7 +34,7 @@
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.resideInAPackage;
 import static com.tngtech.archunit.core.domain.properties.HasName.Predicates.name;
 import static com.tngtech.archunit.core.domain.properties.HasOwner.Predicates.With.owner;
-import static com.tngtech.archunit.core.domain.properties.HasParameterTypes.Predicates.parameterTypes;
+import static com.tngtech.archunit.core.domain.properties.HasParameterTypes.Predicates.rawParameterTypes;
 import static com.tngtech.archunit.core.domain.properties.HasType.Functions.GET_TYPE;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.accessField;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.callCodeUnitWhere;
@@ -69,7 +69,7 @@ private static ArchCondition<JavaClass> accessStandardStreams() {
         ArchCondition<JavaClass> callOfPrintStackTrace = callMethodWhere(
                 target(name("printStackTrace"))
                         .and(target(owner(assignableTo(Throwable.class))))
-                        .and(target(parameterTypes(new Class[0]))));
+                        .and(target(rawParameterTypes(new Class[0]))));
 
         return accessToSystemOut.or(accessToSystemErr).or(callOfPrintStackTrace).as("access standard streams");
     }

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/GivenMembersTest.java
Patch:
@@ -475,7 +475,7 @@ public void check(JavaMember item, ConditionEvents events) {
         assertThat(result.getFailureReport().getDetails()).containsOnlyElementsOf(expectedMessages);
     }
 
-    private void assertViolation(EvaluationResult result) {
+    static void assertViolation(EvaluationResult result) {
         assertThat(result.hasViolation()).as("result has violation").isTrue();
     }
 
@@ -510,7 +510,7 @@ public void check(JavaMember member, ConditionEvents events) {
         };
     }
 
-    private static String formatMember(JavaMember member) {
+    static String formatMember(JavaMember member) {
         return member.getFullName().replaceAll("^[^(]*\\.", "");
     }
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/syntax/RandomSyntaxTestBase.java
Patch:
@@ -335,7 +335,9 @@ Parameter get(String methodName, TypeToken<?> type) {
                 .add(new SpecificParameterProvider(String[].class) {
                     @Override
                     Parameter get(String methodName, TypeToken<?> type) {
-                        return new Parameter(new String[]{"one", "two"}, "['one', 'two']");
+                        return methodName.toLowerCase().contains("type") ?
+                                new Parameter(new String[]{"first.Type", "second.Type"}, "[first.Type, second.Type]") :
+                                new Parameter(new String[]{"one", "two"}, "['one', 'two']");
                     }
                 })
                 .add(new SpecificParameterProvider(Class.class) {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/FieldsThatInternal.java
Patch:
@@ -23,10 +23,10 @@
 import static com.tngtech.archunit.core.domain.properties.HasType.Predicates.type;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.have;
 
-public class GivenFieldsThatInternal extends GivenMembersThatInternal<JavaField, GivenFieldsInternal>
+public class FieldsThatInternal extends MembersThatInternal<JavaField, GivenFieldsInternal>
         implements FieldsThat<GivenFieldsInternal> {
 
-    GivenFieldsThatInternal(GivenFieldsInternal givenFields, PredicateAggregator<JavaField> currentPredicate) {
+    FieldsThatInternal(GivenFieldsInternal givenFields, PredicateAggregator<JavaField> currentPredicate) {
         super(givenFields, currentPredicate);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/MembersThatInternal.java
Patch:
@@ -36,7 +36,7 @@
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.are;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.have;
 
-public class GivenMembersThatInternal<
+public class MembersThatInternal<
         MEMBER extends JavaMember,
         CONJUNCTION extends AbstractGivenMembersInternal<MEMBER, CONJUNCTION>
         >
@@ -45,7 +45,7 @@ public class GivenMembersThatInternal<
     final CONJUNCTION givenMembers;
     final PredicateAggregator<MEMBER> currentPredicate;
 
-    GivenMembersThatInternal(
+    MembersThatInternal(
             CONJUNCTION givenMembers, PredicateAggregator<MEMBER> currentPredicate) {
         this.givenMembers = givenMembers;
         this.currentPredicate = currentPredicate;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ThrowsDeclaration.java
Patch:
@@ -98,6 +98,7 @@ public JavaClass getDeclaringClass() {
      * <pre><code>void method() throws SomeException {...}</code></pre>
      * the {@link JavaClass} representing <code>SomeException</code> will be returned
      */
+    @Override
     @PublicAPI(usage = ACCESS)
     public JavaClass getType() {
         return type;

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenFields.java
Patch:
@@ -22,6 +22,9 @@
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
 public interface GivenFields extends GivenMembers<JavaField> {
+    @Override
+    @PublicAPI(usage = ACCESS)
+    FieldsThat<? extends GivenFieldsConjunction> that();
 
     @Override
     @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenMembers.java
Patch:
@@ -34,7 +34,7 @@ public interface GivenMembers<MEMBER extends JavaMember> extends GivenObjects<ME
      * @return A syntax element, which can be used to restrict the members under consideration
      */
     @PublicAPI(usage = ACCESS)
-    MembersThat<GivenMembersConjunction<MEMBER>> that();
+    MembersThat<? extends GivenMembersConjunction<MEMBER>> that();
 
     /**
      * Allows to restrict the set of members under consideration. E.g.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenMembersConjunction.java
Patch:
@@ -32,9 +32,9 @@ public interface GivenMembersConjunction<MEMBER extends JavaMember> extends Give
     GivenMembersConjunction<MEMBER> or(DescribedPredicate<? super MEMBER> predicate);
 
     @PublicAPI(usage = ACCESS)
-    MembersThat<GivenMembersConjunction<MEMBER>> and();
+    MembersThat<? extends GivenMembersConjunction<MEMBER>> and();
 
     @PublicAPI(usage = ACCESS)
-    MembersThat<GivenMembersConjunction<MEMBER>> or();
+    MembersThat<? extends GivenMembersConjunction<MEMBER>> or();
 
 }

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/GivenMembersTest.java
Patch:
@@ -497,7 +497,7 @@ public boolean apply(JavaMember member) {
         };
     }
 
-    private static ArchCondition<JavaMember> beAnnotatedWith(final Class<? extends Annotation> annotationType) {
+    static ArchCondition<JavaMember> beAnnotatedWith(final Class<? extends Annotation> annotationType) {
         return new ArchCondition<JavaMember>("be annotated with @%s", annotationType.getSimpleName()) {
             @Override
             public void check(JavaMember member, ConditionEvents events) {
@@ -514,11 +514,11 @@ private static String formatMember(JavaMember member) {
         return member.getFullName().replaceAll("^[^(]*\\.", "");
     }
 
-    private static DescribedRuleStart described(GivenMembersConjunction<?> conjunction) {
+    static DescribedRuleStart described(GivenMembersConjunction<?> conjunction) {
         return new DescribedRuleStart(conjunction);
     }
 
-    private static class DescribedRuleStart {
+    static class DescribedRuleStart {
         private final GivenMembersConjunction<?> conjunction;
 
         DescribedRuleStart(GivenMembersConjunction<?> conjunction) {

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/RandomSlicesSyntaxTest.java
Patch:
@@ -5,6 +5,7 @@
 import java.util.regex.Pattern;
 
 import com.tngtech.archunit.library.dependencies.syntax.GivenSlices;
+import com.tngtech.archunit.testutil.syntax.MethodChoiceStrategy;
 import com.tngtech.archunit.testutil.syntax.RandomSyntaxSeed;
 import com.tngtech.archunit.testutil.syntax.RandomSyntaxTestBase;
 import com.tngtech.java.junit.dataprovider.DataProvider;
@@ -15,6 +16,7 @@ public class RandomSlicesSyntaxTest extends RandomSyntaxTestBase {
     @DataProvider
     public static List<List<?>> random_rules() {
         return RandomSyntaxTestBase.createRandomRules(givenClassesSeed(),
+                MethodChoiceStrategy.chooseAllArchUnitSyntaxMethods().exceptMethodsWithName("ignoreDependency"),
                 new Skip("^naming slices.*"),
                 new ReplaceEverythingSoFar("as '([^']+)'", "$1"));
     }

File: archunit/src/test/java/com/tngtech/archunit/testutil/assertion/JavaMethodAssertion.java
Patch:
@@ -7,7 +7,7 @@
 
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 import static com.tngtech.archunit.testutil.assertion.JavaMembersAssertion.assertEquivalent;
-import static com.tngtech.archunit.testutil.assertion.JavaMembersAssertion.getExpectedNameOf;
+import static com.tngtech.archunit.testutil.assertion.JavaMemberAssertion.getExpectedNameOf;
 
 public class JavaMethodAssertion extends AbstractObjectAssert<JavaMethodAssertion, JavaMethod> {
     public JavaMethodAssertion(JavaMethod javaMethod) {

File: archunit/src/test/java/com/tngtech/archunit/testutil/syntax/RandomSyntaxTestBase.java
Patch:
@@ -325,7 +325,8 @@ Parameter get(String methodName, TypeToken<?> type) {
                         if (methodName.toLowerCase().contains("annotat")) {
                             return new Parameter("AnnotationType", "@AnnotationType");
                         } else if (methodName.toLowerCase().contains("assign")
-                                || methodName.toLowerCase().contains("implement")) {
+                                || methodName.toLowerCase().contains("implement")
+                                || methodName.toLowerCase().contains("declared")) {
                             return new Parameter("some.Type", "some.Type");
                         } else if (methodName.equals("be") || methodName.equals("notBe")) {
                             return new Parameter("some.Type", "some.Type");

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/DependencyCondition.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenCodeUnitsInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/AbstractGivenObjects.java
Patch:
@@ -27,7 +27,7 @@
 abstract class AbstractGivenObjects<T, SELF extends AbstractGivenObjects<T, SELF>>
         implements GivenObjects<T>, GivenConjunction<T> {
 
-    private final Factory<T, SELF> factory;
+    final Factory<T, SELF> factory;
     final Priority priority;
     private final ClassesTransformer<T> classesTransformer;
     final Function<ArchCondition<T>, ArchCondition<T>> prepareCondition;

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/CodeUnitsShouldInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ConstructorsShouldInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/FieldsShouldInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenConstructorsInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenFieldsInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenMethodsInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/MembersShouldInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/MethodsShouldInternal.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/SyntaxPredicates.java
Patch:
@@ -35,7 +35,7 @@
 import static com.tngtech.archunit.lang.conditions.ArchConditions.fullyQualifiedName;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.have;
 
-class ClassesThatPredicates {
+class SyntaxPredicates {
     static DescribedPredicate<HasName> haveNameNotMatching(String regex) {
         return have(not(nameMatching(regex)).as("name not matching '%s'", regex));
     }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/Transformers.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenClasses.java
Patch:
@@ -22,6 +22,7 @@
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
 public interface GivenClasses extends GivenObjects<JavaClass> {
+
     @PublicAPI(usage = ACCESS)
     ClassesShould should();
 

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenCodeUnits.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenCodeUnitsConjunction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenConstructors.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenConstructorsConjunction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenFields.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenFieldsConjunction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenMethods.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenMethodsConjunction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 TNG Technology Consulting GmbH
+ * Copyright 2019 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/persistence/second/dao/jpa/OtherJpa.java
Patch:
@@ -5,6 +5,7 @@
 
 import com.tngtech.archunit.example.persistence.second.dao.OtherDao;
 import com.tngtech.archunit.example.persistence.second.dao.domain.OtherPersistentObject;
+import com.tngtech.archunit.example.security.Secured;
 
 import java.sql.Connection;
 import java.sql.SQLException;
@@ -25,6 +26,7 @@ public void testConnection() throws SQLException {
     }
 
     @Override
+    @Secured
     public EntityManager getEntityManager() {
         return entityManager;
     }

File: archunit-junit/junit4/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsMethodsTest.java
Patch:
@@ -27,8 +27,7 @@
 import static com.tngtech.archunit.junit.ArchUnitRunnerTestUtils.BE_SATISFIED;
 import static com.tngtech.archunit.junit.ArchUnitRunnerTestUtils.getRule;
 import static com.tngtech.archunit.junit.ArchUnitRunnerTestUtils.newRunnerFor;
-import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.all;
-import static com.tngtech.archunit.lang.syntax.ClassesIdentityTransformer.classes;
+import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.never;
@@ -204,6 +203,7 @@ public static void toBeIgnored(JavaClasses classes) {
         }
     }
 
+    @SuppressWarnings("WeakerAccess")
     @AnalyzeClasses(packages = "some.pkg")
     public static class ArchTestWithAbstractBaseClass extends AbstractBaseClass {
     }
@@ -213,7 +213,7 @@ abstract static class AbstractBaseClass {
 
         @ArchTest
         void abstractBaseClassInstanceMethod(JavaClasses classes) {
-            all(classes()).should(BE_SATISFIED).check(classes);
+            classes().should(BE_SATISFIED).check(classes);
         }
     }
 }
\ No newline at end of file

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassesInternal.java
Patch:
@@ -73,8 +73,8 @@ public GivenClassesThat that() {
     }
 
     @Override
-    public ClassesShouldConjunction should(ArchCondition<JavaClass> condition) {
-        return new ClassesShouldInternal(finishedClassesTransformer(), priority, condition, prepareCondition);
+    public ClassesShouldConjunction should(ArchCondition<? super JavaClass> condition) {
+        return new ClassesShouldInternal(finishedClassesTransformer(), priority, condition.<JavaClass>forSubType(), prepareCondition);
     }
 
     private static class GivenClassesFactory implements Factory<JavaClass, GivenClassesInternal> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenObjectsInternal.java
Patch:
@@ -48,8 +48,8 @@ private GivenObjectsInternal(
     }
 
     @Override
-    public ArchRule should(ArchCondition<T> condition) {
-        return new ObjectsShouldInternal<>(finishedClassesTransformer(), priority, condition, prepareCondition);
+    public ArchRule should(ArchCondition<? super T> condition) {
+        return new ObjectsShouldInternal<>(finishedClassesTransformer(), priority, condition.<T>forSubType(), prepareCondition);
     }
 
     private static class GivenObjectsFactory<T> implements AbstractGivenObjects.Factory<T, GivenObjectsInternal<T>> {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenClassesConjunction.java
Patch:
@@ -25,7 +25,7 @@
 public interface GivenClassesConjunction extends GivenConjunction<JavaClass> {
     @Override
     @PublicAPI(usage = ACCESS)
-    ClassesShouldConjunction should(ArchCondition<JavaClass> condition);
+    ClassesShouldConjunction should(ArchCondition<? super JavaClass> condition);
 
     @PublicAPI(usage = ACCESS)
     ClassesShould should();

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenConjunction.java
Patch:
@@ -25,7 +25,7 @@
 
 public interface GivenConjunction<OBJECTS> {
     @PublicAPI(usage = ACCESS)
-    ArchRule should(ArchCondition<OBJECTS> condition);
+    ArchRule should(ArchCondition<? super OBJECTS> condition);
 
     /**
      * Combines the current predicate (e.g. {@link Predicates#simpleName(String) simpleName} == 'SomeClass') with

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenObjects.java
Patch:
@@ -24,7 +24,7 @@
 
 public interface GivenObjects<T> {
     @PublicAPI(usage = ACCESS)
-    ArchRule should(ArchCondition<T> condition);
+    ArchRule should(ArchCondition<? super T> condition);
 
     @PublicAPI(usage = ACCESS)
     GivenConjunction<T> that(DescribedPredicate<? super T> predicate);

File: archunit-example/example-plain/src/main/java/com/tngtech/archunit/example/controller/two/UseCaseTwoController.java
Patch:
@@ -1,8 +1,9 @@
 package com.tngtech.archunit.example.controller.two;
 
+import com.tngtech.archunit.example.AbstractController;
 import com.tngtech.archunit.example.controller.one.UseCaseOneTwoController;
 
-public class UseCaseTwoController {
+public class UseCaseTwoController extends AbstractController {
     public static final String doSomethingTwo = "doSomethingTwo";
 
     public void doSomethingTwo() {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileProcessor.java
Patch:
@@ -26,6 +26,7 @@
 import com.tngtech.archunit.core.importer.JavaClassProcessor.AccessHandler;
 import com.tngtech.archunit.core.importer.JavaClassProcessor.DeclarationHandler;
 import com.tngtech.archunit.core.importer.RawAccessRecord.CodeUnit;
+import com.tngtech.archunit.core.importer.RawAccessRecord.ConstructorTargetInfo;
 import com.tngtech.archunit.core.importer.RawAccessRecord.MethodTargetInfo;
 import com.tngtech.archunit.core.importer.RawAccessRecord.TargetInfo;
 import com.tngtech.archunit.core.importer.resolvers.ClassResolver;
@@ -149,7 +150,7 @@ public void handleFieldInstruction(int opcode, String owner, String name, String
         public void handleMethodInstruction(String owner, String name, String desc) {
             LOG.debug("Found call of method {}.{}:{} in line {}", owner, name, desc, lineNumber);
             if (CONSTRUCTOR_NAME.equals(name)) {
-                TargetInfo target = new RawAccessRecord.ConstructorTargetInfo(owner, name, desc);
+                TargetInfo target = new ConstructorTargetInfo(owner, name, desc);
                 importRecord.registerConstructorCall(filled(new RawAccessRecord.Builder(), target).build());
             } else {
                 TargetInfo target = new MethodTargetInfo(owner, name, desc);

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Slice.java
Patch:
@@ -48,7 +48,7 @@
  */
 public final class Slice extends ForwardingSet<JavaClass> implements HasDescription, CanOverrideDescription<Slice> {
     private final List<String> matchingGroups;
-    private Description description;
+    private final Description description;
     private final Set<JavaClass> classes;
 
     private Slice(List<String> matchingGroups, Set<JavaClass> classes) {

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -48,8 +48,6 @@
 import com.tngtech.archunit.testutil.assertion.JavaFieldsAssertion;
 import com.tngtech.archunit.testutil.assertion.JavaMethodAssertion;
 import com.tngtech.archunit.testutil.assertion.JavaMethodsAssertion;
-import com.tngtech.archunit.testutil.assertion.DependenciesAssertion;
-import com.tngtech.archunit.testutil.assertion.DependencyAssertion;
 import com.tngtech.archunit.testutil.assertion.JavaPackagesAssertion;
 import org.assertj.core.api.AbstractCharSequenceAssert;
 import org.assertj.core.api.AbstractIterableAssert;

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/ShouldOnlyByClassesThatTest.java
Patch:
@@ -1014,5 +1014,4 @@ private interface InterfaceBeingDependedOnByImplementing {
 
     private static class ClassDependingViaImplementing implements InterfaceBeingDependedOnByImplementing {
     }
-}
-
+}
\ No newline at end of file

File: archunit/src/test/java/com/tngtech/archunit/core/domain/TestUtils.java
Patch:
@@ -78,12 +78,12 @@ public static JavaClass importClassWithContext(Class<?> owner) {
     public static JavaClasses importClassesWithContext(Class<?>... classes) {
         JavaClasses importedHierarchy = importHierarchies(classes);
         final List<String> classNames = JavaClass.namesOf(classes);
-        return JavaClasses.of(importedHierarchy.that(new DescribedPredicate<JavaClass>(importedHierarchy.getDescription()) {
+        return importedHierarchy.that(new DescribedPredicate<JavaClass>(importedHierarchy.getDescription()) {
             @Override
             public boolean apply(JavaClass input) {
                 return classNames.contains(input.getName());
             }
-        }));
+        });
     }
 
     public static JavaMethodCallBuilder newMethodCallBuilder(JavaMethod origin, MethodCallTarget target, int lineNumber) {

File: archunit/src/main/java/com/tngtech/archunit/base/DescribedPredicate.java
Patch:
@@ -27,11 +27,9 @@
  * @param <T> The type of objects the predicate applies to
  */
 @PublicAPI(usage = INHERITANCE)
-public abstract class DescribedPredicate<T> {
+public abstract class DescribedPredicate<T> implements Predicate<T> {
     private final String description;
 
-    public abstract boolean apply(T input);
-
     public DescribedPredicate(String description, Object... params) {
         checkArgument(description != null, "Description must be set");
         this.description = String.format(description, params);

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassesTest.java
Patch:
@@ -19,7 +19,7 @@ public class JavaClassesTest {
     private static final ImmutableMap<String, JavaClass> BY_TYPE_NAME = ImmutableMap.of(
             SomeClass.class.getName(), SOME_CLASS,
             SomeOtherClass.class.getName(), SOME_OTHER_CLASS);
-    public static final JavaClasses ALL_CLASSES = new JavaClasses(BY_TYPE_NAME, "classes");
+    public static final JavaClasses ALL_CLASSES = new JavaClasses(JavaPackage.from(BY_TYPE_NAME.values()), BY_TYPE_NAME);
 
     @Rule
     public final ExpectedException thrown = ExpectedException.none();

File: archunit/src/main/java/com/tngtech/archunit/core/domain/ImportContext.java
Patch:
@@ -51,9 +51,9 @@ public interface ImportContext {
 
     Set<JavaMethod> getMethodsWithReturnType(JavaClass javaClass);
 
-    Set<JavaMethod> getMethodsWithThrowsDeclaration(JavaClass javaClass);
+    Set<ThrowsDeclaration<JavaMethod>> getMethodThrowsDeclarationsOfType(JavaClass javaClass);
 
     Set<JavaConstructor> getConstructorsWithParameterOfType(JavaClass javaClass);
 
-    Set<JavaConstructor> getConstructorsWithThrowsDeclaration(JavaClass javaClass);
+    Set<ThrowsDeclaration<JavaConstructor>> getConstructorThrowsDeclarationsOfType(JavaClass javaClass);
 }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaField.java
Patch:
@@ -63,7 +63,7 @@ public Field reflect() {
     }
 
     @Override
-    String getDescription() {
+    public String getDescription() {
         return "Field <" + getFullName() + ">";
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/domain/TestUtils.java
Patch:
@@ -41,9 +41,10 @@ public static JavaClassList javaClassList(Class<?>... types) {
         return new JavaClassList(classes);
     }
 
-    public static ThrowsClause throwsClause(Class<?>... types) {
+    public static ThrowsClause<?> throwsClause(Class<?>... types) {
         List<JavaClass> importedTypes = ImmutableList.copyOf(new ClassFileImporter().importClasses(types));
-        return ThrowsClause.fromThrownTypes(importedTypes);
+        JavaMethod irrelevantOwner = importedTypes.get(0).getMethod("toString");
+        return ThrowsClause.from(irrelevantOwner, importedTypes);
     }
 
     public static JavaMethod importMethod(Class<?> clazz, String methodName, Class<?>... params) {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasThrowsClauseTest.java
Patch:
@@ -43,10 +43,10 @@ public void predicate_on_parameters_by_String() {
     public void predicate_on_parameters_by_Predicate() {
         HasThrowsClause hasThrowsClause = newHasThrowsClause(String.class, Serializable.class);
 
-        assertThat(HasThrowsClause.Predicates.throwsClause(DescribedPredicate.<ThrowsClause>alwaysTrue()).apply(hasThrowsClause)).isTrue();
-        assertThat(HasThrowsClause.Predicates.throwsClause(DescribedPredicate.<ThrowsClause>alwaysFalse()).apply(hasThrowsClause)).isFalse();
+        assertThat(HasThrowsClause.Predicates.throwsClause(DescribedPredicate.<ThrowsClause<?>>alwaysTrue()).apply(hasThrowsClause)).isTrue();
+        assertThat(HasThrowsClause.Predicates.throwsClause(DescribedPredicate.<ThrowsClause<?>>alwaysFalse()).apply(hasThrowsClause)).isFalse();
 
-        assertThat(HasThrowsClause.Predicates.throwsClause(DescribedPredicate.<ThrowsClause>alwaysFalse().as("some text")).getDescription())
+        assertThat(HasThrowsClause.Predicates.throwsClause(DescribedPredicate.<ThrowsClause<?>>alwaysFalse().as("some text")).getDescription())
                 .isEqualTo("throws types some text");
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportTestUtils.java
Patch:
@@ -37,6 +37,7 @@
 import com.tngtech.archunit.core.domain.JavaModifier;
 import com.tngtech.archunit.core.domain.JavaStaticInitializer;
 import com.tngtech.archunit.core.domain.JavaType;
+import com.tngtech.archunit.core.domain.ThrowsDeclaration;
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaMethodCallBuilder;
 import org.objectweb.asm.Type;
 
@@ -414,7 +415,7 @@ public Set<JavaMethod> getMethodsWithReturnType(JavaClass javaClass) {
         }
 
         @Override
-        public Set<JavaMethod> getMethodsWithThrowsDeclaration(JavaClass javaClass) {
+        public Set<ThrowsDeclaration<JavaMethod>> getMethodThrowsDeclarationsOfType(JavaClass javaClass) {
             return Collections.emptySet();
         }
 
@@ -424,7 +425,7 @@ public Set<JavaConstructor> getConstructorsWithParameterOfType(JavaClass javaCla
         }
 
         @Override
-        public Set<JavaConstructor> getConstructorsWithThrowsDeclaration(JavaClass javaClass) {
+        public Set<ThrowsDeclaration<JavaConstructor>> getConstructorThrowsDeclarationsOfType(JavaClass javaClass) {
             return Collections.emptySet();
         }
     }

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -406,16 +406,16 @@ public void matches(Class<?> clazz) {
         }
     }
 
-    public static class ThrowsClauseAssertion
-            extends AbstractListAssert<ThrowsClauseAssertion, List<? extends ThrowsDeclaration>, ThrowsDeclaration, ObjectAssert<ThrowsDeclaration>> {
+    public static class ThrowsClauseAssertion extends
+            AbstractIterableAssert<ThrowsClauseAssertion, ThrowsClause, ThrowsDeclaration, ObjectAssert<ThrowsDeclaration>> {
         private ThrowsClauseAssertion(ThrowsClause throwsClause) {
             super(throwsClause, ThrowsClauseAssertion.class);
         }
 
         public void matches(Class<?>... classes) {
             assertThat(actual).as("ThrowsClause").hasSize(classes.length);
             for (int i = 0; i < actual.size(); i++) {
-                assertThat(actual.get(i)).as("Element %d", i).matches(classes[i]);
+                assertThat(Iterables.get(actual, i)).as("Element %d", i).matches(classes[i]);
             }
         }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -874,7 +874,7 @@ private Set<Dependency> methodParameterDependenciesFromSelf() {
     private Set<Dependency> methodThrowsDeclarationDependenciesFromSelf() {
         ImmutableSet.Builder<Dependency> result = ImmutableSet.builder();
         for (JavaMethod method : getMethods()) {
-            for (ThrowsDeclaration throwsDeclaration : method.getThrowsDeclarations()) {
+            for (ThrowsDeclaration throwsDeclaration : method.getThrowsClause()) {
                 result.add(Dependency.fromThrowsDeclaration(method, throwsDeclaration.getType()));
             }
         }
@@ -894,7 +894,7 @@ private Set<Dependency> constructorParameterDependenciesFromSelf() {
     private Set<Dependency> constructorThrowsDeclarationDependenciesFromSelf() {
         ImmutableSet.Builder<Dependency> result = ImmutableSet.builder();
         for (JavaConstructor constructor : getConstructors()) {
-            for (ThrowsDeclaration throwsDeclaration : constructor.getThrowsDeclarations()) {
+            for (ThrowsDeclaration throwsDeclaration : constructor.getThrowsClause()) {
                 result.add(Dependency.fromThrowsDeclaration(constructor, throwsDeclaration.getType()));
             }
         }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -295,7 +295,7 @@ void registerMethods(Set<JavaMethod> methods) {
                     methodParameterTypeDependencies.put(parameter, method);
                 }
                 methodReturnTypeDependencies.put(method.getReturnType(), method);
-                for (ThrowsDeclaration throwsDeclaration : method.getThrowsDeclarations()) {
+                for (ThrowsDeclaration throwsDeclaration : method.getThrowsClause()) {
                     methodsThrowsDeclarationDependencies.put(throwsDeclaration.getType(), method);
                 }
             }
@@ -306,7 +306,7 @@ void registerConstructors(Set<JavaConstructor> constructors) {
                 for (JavaClass parameter : constructor.getParameters()) {
                     constructorParameterTypeDependencies.put(parameter, constructor);
                 }
-                for (ThrowsDeclaration throwsDeclaration : constructor.getThrowsDeclarations()) {
+                for (ThrowsDeclaration throwsDeclaration : constructor.getThrowsClause()) {
                     constructorThrowsDeclarationDependencies.put(throwsDeclaration.getType(), constructor);
                 }
             }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -213,7 +213,7 @@ public MethodVisitor visitMethod(int access, String name, String desc, String si
                 .withParameters(typesFrom(methodType.getArgumentTypes()))
                 .withReturnType(JavaTypeImporter.importAsmType(methodType.getReturnType()))
                 .withDescriptor(desc)
-                .withThrowsDeclarations(typesFrom(exceptions))
+                .withThrowsClause(typesFrom(exceptions))
                 ;
 
         return new MethodProcessor(className, accessHandler, codeUnitBuilder);

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterTest.java
Patch:
@@ -550,7 +550,7 @@ public void imports_methods_with_correct_return_types() throws Exception {
     public void imports_methods_with_correct_throws_declarations() throws Exception {
         Set<JavaCodeUnit> methods = classesIn("testexamples/methodimport").getCodeUnits();
 
-        assertThat(findAnyByName(methods, "throwExceptions").getThrowsDeclarations())
+        assertThat(findAnyByName(methods, "throwExceptions").getThrowsClause())
                 .as("Throws types of method 'throwsExceptions'").matches(IOException.class, InterruptedException.class);
     }
 
@@ -774,7 +774,7 @@ public void imports_constructor_with_correct_throws_declarations() throws Except
         JavaClass clazz = classesIn("testexamples/constructorimport").get(ClassWithThrowingConstructor.class);
 
         assertThat(clazz.getConstructors()).as("Constructors").hasSize(1);
-        assertThat(clazz.getConstructor().getThrowsDeclarations()).as("Throws types of sole constructor")
+        assertThat(clazz.getConstructor().getThrowsClause()).as("Throws types of sole constructor")
                 .matches(IOException.class, InterruptedException.class);
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ImportTestUtils.java
Patch:
@@ -81,7 +81,7 @@ private static Set<DomainBuilders.BuilderWithBuildParameter<JavaClass, JavaMetho
                     .withDescriptor(Type.getMethodDescriptor(method))
                     .withAnnotations(javaAnnotationBuildersFrom(method.getAnnotations(), importedClasses))
                     .withModifiers(JavaModifier.getModifiersForMethod(method.getModifiers()))
-                    .withThrowsDeclarations(typesFrom(method.getExceptionTypes())));
+                    .withThrowsClause(typesFrom(method.getExceptionTypes())));
         }
         return methodBuilders;
     }
@@ -97,7 +97,7 @@ private static Set<DomainBuilders.BuilderWithBuildParameter<JavaClass, JavaConst
                     .withDescriptor(Type.getConstructorDescriptor(constructor))
                     .withAnnotations(javaAnnotationBuildersFrom(constructor.getAnnotations(), importedClasses))
                     .withModifiers(JavaModifier.getModifiersForMethod(constructor.getModifiers()))
-                    .withThrowsDeclarations(typesFrom(constructor.getExceptionTypes())));
+                    .withThrowsClause(typesFrom(constructor.getExceptionTypes())));
         }
         return constructorBuilders;
     }

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/PlantUmlArchCondition.java
Patch:
@@ -99,13 +99,13 @@ private PlantUmlArchCondition(
     }
 
     @PublicAPI(usage = ACCESS)
-    public PlantUmlArchCondition ignoreDependenciesWithOrigin(DescribedPredicate<JavaClass> ignorePredicate) {
+    public PlantUmlArchCondition ignoreDependenciesWithOrigin(DescribedPredicate<? super JavaClass> ignorePredicate) {
         return ignoreDependencies(GET_ORIGIN_CLASS.is(ignorePredicate)
                 .as("ignoring dependencies with origin " + ignorePredicate.getDescription()));
     }
 
     @PublicAPI(usage = ACCESS)
-    public PlantUmlArchCondition ignoreDependenciesWithTarget(DescribedPredicate<JavaClass> ignorePredicate) {
+    public PlantUmlArchCondition ignoreDependenciesWithTarget(DescribedPredicate<? super JavaClass> ignorePredicate) {
         return ignoreDependencies(GET_TARGET_CLASS.is(ignorePredicate)
                 .as("ignoring dependencies with target " + ignorePredicate.getDescription()));
     }
@@ -123,7 +123,7 @@ public PlantUmlArchCondition ignoreDependencies(final String origin, final Strin
     }
 
     @PublicAPI(usage = ACCESS)
-    public PlantUmlArchCondition ignoreDependencies(DescribedPredicate<Dependency> ignorePredicate) {
+    public PlantUmlArchCondition ignoreDependencies(DescribedPredicate<? super Dependency> ignorePredicate) {
         String description = getDescription() + ", " + ignorePredicate.getDescription();
         return new PlantUmlArchCondition(description,
                 this.ignorePredicate.or(ignorePredicate),

File: archunit/src/main/java/com/tngtech/archunit/ArchConfiguration.java
Patch:
@@ -50,8 +50,8 @@ public final class ArchConfiguration {
     private static final Pattern EXTENSION_PROP___GROUP_ONE_ID_GROUP_TWO_KEY = Pattern.compile("^extension\\.([^.]+)\\.(.+)");
 
     private static final Map<String, String> PROPERTY_DEFAULTS = ImmutableMap.of(
-            RESOLVE_MISSING_DEPENDENCIES_FROM_CLASS_PATH, "" + false,
-            ENABLE_MD5_IN_CLASS_SOURCES, "" + false
+            RESOLVE_MISSING_DEPENDENCIES_FROM_CLASS_PATH, Boolean.TRUE.toString(),
+            ENABLE_MD5_IN_CLASS_SOURCES, Boolean.FALSE.toString()
     );
 
     private static final Supplier<ArchConfiguration> INSTANCE = Suppliers.memoize(new Supplier<ArchConfiguration>() {

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/ExpectedTestFailures.java
Patch:
@@ -305,7 +305,7 @@ private static class ExpectedViolationToAssign {
 
         static ExpectedViolationToAssign byRuleText(String ruleText) {
             return new ExpectedViolationToAssign(
-                    failure -> failure.error.getMessage().contains(ruleText),
+                    failure -> failure.error.getMessage().contains(String.format("Rule '%s'", ruleText)),
                     ExpectedViolation.ofRule(ruleText),
                     HandlingAssertion.ofRule());
         }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/resolvers/SelectedClassResolverFromClasspathTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import static com.tngtech.archunit.core.domain.TestUtils.importClassWithContext;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
-import static org.mockito.Matchers.argThat;
+import static org.mockito.Mockito.argThat;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileProcessor.java
Patch:
@@ -35,12 +35,12 @@
 import org.slf4j.LoggerFactory;
 
 import static com.tngtech.archunit.core.domain.JavaConstructor.CONSTRUCTOR_NAME;
-import static org.objectweb.asm.Opcodes.ASM6;
+import static org.objectweb.asm.Opcodes.ASM7;
 
 class ClassFileProcessor {
     private static final Logger LOG = LoggerFactory.getLogger(ClassFileProcessor.class);
 
-    static final int ASM_API_VERSION = ASM6;
+    static final int ASM_API_VERSION = ASM7;
 
     private final ClassResolver.Factory classResolverFactory = new ClassResolver.Factory();
 

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchTestMethodExecution.java
Patch:
@@ -47,7 +47,7 @@ private void executeTestMethod(JavaClasses classes) {
                 "Methods annotated with @%s must have exactly one parameter of type %s",
                 ArchTest.class.getSimpleName(), JavaClasses.class.getSimpleName());
 
-        invokeMethod(testMethod, classes);
+        invokeMethod(testMethod, testClass, classes);
     }
 
     @Override

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/ArchUnitTestDescriptor.java
Patch:
@@ -188,7 +188,7 @@ public Type getType() {
 
         @Override
         public ArchUnitEngineExecutionContext execute(ArchUnitEngineExecutionContext context, DynamicTestExecutor dynamicTestExecutor) {
-            invokeMethod(method, classes.get());
+            invokeMethod(method, method.getDeclaringClass(), classes.get());
             return context;
         }
     }

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ReflectionUtils.java
Patch:
@@ -110,11 +110,11 @@ static <T> T getValueOrThrowException(Field field, Class<?> fieldOwner, Function
         }
     }
 
-    static <T> T invokeMethod(Method method, Object... args) {
+    static <T> T invokeMethod(Method method, Class<?> methodOwner, Object... args) {
         if (Modifier.isStatic(method.getModifiers())) {
             return invoke(null, method, args);
         } else {
-            return invoke(newInstanceOf(method.getDeclaringClass()), method, args);
+            return invoke(newInstanceOf(methodOwner), method, args);
         }
     }
 

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchRuleDeclaration.java
Patch:
@@ -87,7 +87,7 @@ private static Set<ArchRuleDeclaration<?>> archRuleDeclarationsFrom(Class<?> tes
     }
 
     private static ArchRules getArchRulesIn(Field field) {
-        ArchRules value = getValue(field);
+        ArchRules value = getValue(field, field.getDeclaringClass());
         return checkNotNull(value, "Field %s.%s is not initialized",
                 field.getDeclaringClass().getName(), field.getName());
     }

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchRuleExecution.java
Patch:
@@ -36,7 +36,7 @@ class ArchRuleExecution extends ArchTestExecution {
 
     @Override
     Result evaluateOn(JavaClasses classes) {
-        ArchRule rule = getValue(ruleField);
+        ArchRule rule = getValue(ruleField, testClass);
         try {
             rule.check(classes);
         } catch (Exception | AssertionError e) {

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchTestExecution.java
Patch:
@@ -49,8 +49,8 @@ boolean ignore() {
         return ignore;
     }
 
-    static <T> T getValue(Field field) {
-        return getValueOrThrowException(field, WRAP_CAUSE);
+    static <T> T getValue(Field field, Class<?> fieldOwner) {
+        return getValueOrThrowException(field, fieldOwner, WRAP_CAUSE);
     }
 
     abstract static class Result {

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchUnitRunner.java
Patch:
@@ -126,7 +126,7 @@ private Set<ArchTestExecution> asTestExecutions(ArchRules archRules, boolean for
     }
 
     private ArchRules getArchRules(Field field) {
-        return getValue(field);
+        return getValue(field, field.getDeclaringClass());
     }
 
     private Collection<ArchTestExecution> findArchRuleMethods() {

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/ArchUnitTestDescriptor.java
Patch:
@@ -108,7 +108,7 @@ private static void resolveChildren(
     }
 
     private static <T> T getValue(Field field) {
-        return getValueOrThrowException(field, WRAP_CAUSE);
+        return getValueOrThrowException(field, field.getDeclaringClass(), WRAP_CAUSE);
     }
 
     private static void resolveArchRules(

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ReflectionUtils.java
Patch:
@@ -98,12 +98,12 @@ private static <T> T getValue(Field field, Object owner) {
         }
     }
 
-    static <T> T getValueOrThrowException(Field field, Function<Throwable, ? extends RuntimeException> exceptionConverter) {
+    static <T> T getValueOrThrowException(Field field, Class<?> fieldOwner, Function<Throwable, ? extends RuntimeException> exceptionConverter) {
         try {
             if (Modifier.isStatic(field.getModifiers())) {
                 return getValue(field, null);
             } else {
-                return getValue(field, newInstanceOf(field.getDeclaringClass()));
+                return getValue(field, newInstanceOf(fieldOwner));
             }
         } catch (ReflectionException e) {
             throw exceptionConverter.apply(e.getCause());

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/ArchUnitTestEngine.java
Patch:
@@ -64,7 +64,7 @@
  */
 @Internal
 public final class ArchUnitTestEngine extends HierarchicalTestEngine<ArchUnitEngineExecutionContext> {
-    static final String UNIQUE_ID = "junit-archunit";
+    static final String UNIQUE_ID = "archunit";
 
     private SharedCache cache = new SharedCache(); // NOTE: We want to change this in tests -> no static/final reference
 

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AllAccessesCondition.java
Patch:
@@ -28,7 +28,7 @@ class AllAccessesCondition extends AllAttributesMatchCondition<JavaAccess<?>> {
 
     AllAccessesCondition(String prefix, DescribedPredicate<JavaAccess<?>> predicate,
             Function<JavaClass, ? extends Collection<JavaAccess<?>>> getRelevantAccesses) {
-        super(Joiner.on(" ").join(prefix, predicate.getDescription()), new JavaAccessCondition(predicate));
+        super(Joiner.on(" ").join(prefix, predicate.getDescription()), new JavaAccessCondition<>(predicate));
         this.getRelevantAccesses = getRelevantAccesses;
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Dependency.java
Patch:
@@ -38,6 +38,9 @@
  * <li>a class calls a method of another class</li>
  * <li>a class calls a constructor of another class</li>
  * <li>a class inherits from another class (which is in fact a special case of constructor call)</li>
+ * <li>a class implements an interface</li>
+ * <li>a class has a field with type of another class</li>
+ * <li>a class has a method/constructor with parameter/return type of another class</li>
  * </ul>
  */
 public class Dependency implements HasDescription, Comparable<Dependency> {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasName.java
Patch:
@@ -55,7 +55,6 @@ private static class NameMatchingPredicate extends DescribedPredicate<HasName> {
             NameMatchingPredicate(String regex) {
                 super(String.format("name matching '%s'", regex));
                 this.pattern = Pattern.compile(regex);
-                ;
             }
 
             @Override

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/ClassesThatTestsExistTest.java
Patch:
@@ -18,7 +18,7 @@
  */
 public class ClassesThatTestsExistTest {
     private static final Set<Class<?>> CLASSES_SHOULD_THAT_CONTEXT = ImmutableSet.of(
-            GivenClassesThatTest.class, ShouldAccessClassesThatTest.class, ShouldOnlyBeAccessedByClassesThatTest.class
+            GivenClassesThatTest.class, ShouldClassesThatTest.class, ShouldOnlyByClassesThatTest.class
     );
 
     @Test

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AllDependenciesCondition.java
Patch:
@@ -33,21 +33,21 @@
 @PublicAPI(usage = ACCESS)
 public final class AllDependenciesCondition extends AllAttributesMatchCondition<Dependency> {
     private final DescribedPredicate<? super Dependency> conditionPredicate;
-    private final Function<JavaClass, Collection<Dependency>> javaClassToRelevantDependencies;
+    private final Function<JavaClass, ? extends Collection<Dependency>> javaClassToRelevantDependencies;
     private final DescribedPredicate<Dependency> ignorePredicate;
 
     AllDependenciesCondition(
             String description,
             final DescribedPredicate<? super Dependency> predicate,
-            Function<JavaClass, Collection<Dependency>> javaClassToRelevantDependencies) {
+            Function<JavaClass, ? extends Collection<Dependency>> javaClassToRelevantDependencies) {
 
         this(description, predicate, javaClassToRelevantDependencies, DescribedPredicate.<Dependency>alwaysFalse());
     }
 
     private AllDependenciesCondition(
             String description,
             final DescribedPredicate<? super Dependency> conditionPredicate,
-            Function<JavaClass, Collection<Dependency>> javaClassToRelevantDependencies,
+            Function<JavaClass, ? extends Collection<Dependency>> javaClassToRelevantDependencies,
             DescribedPredicate<Dependency> ignorePredicate) {
 
         super(description, new ArchCondition<Dependency>(conditionPredicate.getDescription()) {

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/ShouldOnlyBeAccessedByClassesThatTest.java
Patch:
@@ -26,7 +26,7 @@
 import static com.tngtech.archunit.core.domain.properties.HasType.Functions.GET_TYPE;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.are;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
-import static com.tngtech.archunit.lang.syntax.elements.ClassesShouldThatEvaluator.filterClassesAppearingInFailureReport;
+import static com.tngtech.archunit.lang.syntax.elements.ClassesShouldEvaluator.filterClassesAppearingInFailureReport;
 import static com.tngtech.archunit.testutil.Assertions.assertThatClasses;
 
 public class ShouldOnlyBeAccessedByClassesThatTest {

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/ExamplesIntegrationTest.java
Patch:
@@ -96,7 +96,6 @@
 import com.tngtech.archunit.example.thirdparty.ThirdPartySubClassWithProblem;
 import com.tngtech.archunit.example.web.AnnotatedController;
 import com.tngtech.archunit.example.web.InheritedControllerImpl;
-import com.tngtech.archunit.exampletest.PlantUmlArchitectureTest;
 import com.tngtech.archunit.exampletest.SecurityTest;
 import com.tngtech.archunit.testutils.CyclicErrorMatcher;
 import com.tngtech.archunit.testutils.ExpectedClass;
@@ -595,7 +594,7 @@ Stream<DynamicTest> NamingConventionTest() {
     Stream<DynamicTest> PlantUmlArchitectureTest() {
         return ExpectedTestFailures
                 .forTests(
-                        PlantUmlArchitectureTest.class,
+                        com.tngtech.archunit.exampletest.PlantUmlArchitectureTest.class,
                         com.tngtech.archunit.exampletest.junit4.PlantUmlArchitectureTest.class,
                         com.tngtech.archunit.exampletest.junit5.PlantUmlArchitectureTest.class)
 

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/RuleSetsTest.java
Patch:
@@ -9,8 +9,8 @@
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
 class RuleSetsTest {
     @ArchTest
-    static final ArchRules CODING_RULES = ArchRules.in(CodingRulesTest.class);
+    private final ArchRules CODING_RULES = ArchRules.in(CodingRulesTest.class);
 
     @ArchTest
-    static final ArchRules CYCLIC_DEPENDENCY_RULES = ArchRules.in(CyclicDependencyRulesTest.class);
+    private final ArchRules CYCLIC_DEPENDENCY_RULES = ArchRules.in(CyclicDependencyRulesTest.class);
 }

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/RuleSetsTest.java
Patch:
@@ -12,8 +12,8 @@
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
 public class RuleSetsTest {
     @ArchTest
-    public static final ArchRules CODING_RULES = ArchRules.in(CodingRulesTest.class);
+    private final ArchRules CODING_RULES = ArchRules.in(CodingRulesTest.class);
 
     @ArchTest
-    public static final ArchRules CYCLIC_DEPENDENCY_RULES = ArchRules.in(CyclicDependencyRulesTest.class);
+    private final ArchRules CYCLIC_DEPENDENCY_RULES = ArchRules.in(CyclicDependencyRulesTest.class);
 }

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchRuleDeclaration.java
Patch:
@@ -26,9 +26,9 @@
 import com.google.common.collect.ImmutableSet;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.tngtech.archunit.junit.ArchTestExecution.getValue;
 import static com.tngtech.archunit.junit.ReflectionUtils.getAllFields;
 import static com.tngtech.archunit.junit.ReflectionUtils.getAllMethods;
-import static com.tngtech.archunit.junit.ReflectionUtils.getValue;
 import static com.tngtech.archunit.junit.ReflectionUtils.withAnnotation;
 
 abstract class ArchRuleDeclaration<T extends AnnotatedElement> {
@@ -87,7 +87,7 @@ private static Set<ArchRuleDeclaration<?>> archRuleDeclarationsFrom(Class<?> tes
     }
 
     private static ArchRules getArchRulesIn(Field field) {
-        ArchRules value = getValue(field, null);
+        ArchRules value = getValue(field);
         return checkNotNull(value, "Field %s.%s is not initialized",
                 field.getDeclaringClass().getName(), field.getName());
     }

File: archunit-junit/junit4/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsRuleSetsTest.java
Patch:
@@ -215,7 +215,7 @@ public static class ArchTestWithRuleLibrary {
         static final String someOtherMethodRuleName = "someOtherMethodRule";
 
         @ArchTest
-        public static final ArchRules rules = ArchRules.in(ArchTestWithRuleSet.class);
+        final ArchRules rules = ArchRules.in(ArchTestWithRuleSet.class);
 
         @ArchTest
         public static void someOtherMethodRule(JavaClasses classes) {
@@ -225,7 +225,7 @@ public static void someOtherMethodRule(JavaClasses classes) {
     @AnalyzeClasses(packages = "some.pkg")
     public static class ArchTestWithRuleSet {
         @ArchTest
-        public static final ArchRules rules = ArchRules.in(Rules.class);
+        final ArchRules rules = ArchRules.in(Rules.class);
     }
 
     @AnalyzeClasses(packages = "some.pkg")

File: archunit/src/main/java/com/tngtech/archunit/core/importer/JavaClassProcessor.java
Patch:
@@ -91,7 +91,7 @@ Optional<JavaClass> createJavaClass() {
 
     @Override
     public void visitSource(String source, String debug) {
-        if (source != null) {
+        if (!importAborted() && source != null) {
             javaClassBuilder.withSourceFileName(source);
         }
     }

File: archunit-junit/junit4/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsMethodsTest.java
Patch:
@@ -26,7 +26,7 @@
 import static com.tngtech.archunit.junit.ArchUnitRunnerTestUtils.getRule;
 import static com.tngtech.archunit.junit.ArchUnitRunnerTestUtils.newRunnerFor;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
@@ -63,7 +63,7 @@ public void setUp() {
     }
 
     @Test
-    public void executes_test_methods_and_supplies_JavaClasses() throws InitializationError {
+    public void executes_test_methods_and_supplies_JavaClasses() {
         runner.runChild(getRule(testSomething, runner), runNotifier);
         verify(runNotifier, never()).fireTestFailure(any(Failure.class));
         verify(runNotifier).fireTestFinished(descriptionCaptor.capture());
@@ -77,7 +77,7 @@ public void fails_methods_with_no_parameters() throws InitializationError {
         runAndAssertWrongParametersForChild(noParams, newRunner(ArchTestWithIllegalTestMethods.class));
     }
 
-    private ArchUnitRunner newRunner(Class<ArchTestWithIllegalTestMethods> testClass) throws InitializationError {
+    private ArchUnitRunner newRunner(Class<ArchTestWithIllegalTestMethods> testClass) {
         return newRunnerFor(testClass, cache);
     }
 

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ClassCacheConcurrencyTest.java
Patch:
@@ -21,7 +21,7 @@
 import org.mockito.junit.MockitoRule;
 
 import static java.util.concurrent.TimeUnit.MINUTES;
-import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.atMost;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/JavaClassDiagramAssociation.java
Patch:
@@ -122,7 +122,7 @@ private AssociatedComponent(PlantUmlComponent component) {
 
         private boolean contains(JavaClass javaClass) {
             for (PackageMatcher packageMatcher : packageMatchers) {
-                if (packageMatcher.matches(javaClass.getPackage())) {
+                if (packageMatcher.matches(javaClass.getPackageName())) {
                     return true;
                 }
             }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/testobjects/AhavingMembersOfTypeB.java
Patch:
@@ -11,6 +11,6 @@ B methodReturningB() {
         return null;
     }
 
-    void methodWithParameterTypeB(String some, SuperA b) {
+    void methodWithParameterTypeB(String some, B b) {
     }
 }

File: archunit-junit/junit4/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsMethodsTest.java
Patch:
@@ -26,7 +26,7 @@
 import static com.tngtech.archunit.junit.ArchUnitRunnerTestUtils.getRule;
 import static com.tngtech.archunit.junit.ArchUnitRunnerTestUtils.newRunnerFor;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
@@ -63,7 +63,7 @@ public void setUp() {
     }
 
     @Test
-    public void executes_test_methods_and_supplies_JavaClasses() throws InitializationError {
+    public void executes_test_methods_and_supplies_JavaClasses() {
         runner.runChild(getRule(testSomething, runner), runNotifier);
         verify(runNotifier, never()).fireTestFailure(any(Failure.class));
         verify(runNotifier).fireTestFinished(descriptionCaptor.capture());
@@ -77,7 +77,7 @@ public void fails_methods_with_no_parameters() throws InitializationError {
         runAndAssertWrongParametersForChild(noParams, newRunner(ArchTestWithIllegalTestMethods.class));
     }
 
-    private ArchUnitRunner newRunner(Class<ArchTestWithIllegalTestMethods> testClass) throws InitializationError {
+    private ArchUnitRunner newRunner(Class<ArchTestWithIllegalTestMethods> testClass) {
         return newRunnerFor(testClass, cache);
     }
 

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ClassCacheConcurrencyTest.java
Patch:
@@ -21,7 +21,7 @@
 import org.mockito.junit.MockitoRule;
 
 import static java.util.concurrent.TimeUnit.MINUTES;
-import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.atMost;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/JavaClassDiagramAssociation.java
Patch:
@@ -122,7 +122,7 @@ private AssociatedComponent(PlantUmlComponent component) {
 
         private boolean contains(JavaClass javaClass) {
             for (PackageMatcher packageMatcher : packageMatchers) {
-                if (packageMatcher.matches(javaClass.getPackage())) {
+                if (packageMatcher.matches(javaClass.getPackageName())) {
                     return true;
                 }
             }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/testobjects/AhavingMembersOfTypeB.java
Patch:
@@ -11,6 +11,6 @@ B methodReturningB() {
         return null;
     }
 
-    void methodWithParameterTypeB(String some, SuperA b) {
+    void methodWithParameterTypeB(String some, B b) {
     }
 }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/ArchUnitArchitectureTest.java
Patch:
@@ -77,7 +77,7 @@ private static DescribedPredicate<JavaClass> belong_to_the_import_context() {
         return new DescribedPredicate<JavaClass>("belong to the import context") {
             @Override
             public boolean apply(JavaClass input) {
-                return input.getPackage().startsWith(ClassFileImporter.class.getPackage().getName())
+                return input.getPackageName().startsWith(ClassFileImporter.class.getPackage().getName())
                         && !input.getName().contains(DomainBuilders.class.getSimpleName());
             }
         };

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchUnitRunner.java
Patch:
@@ -196,7 +196,7 @@ private static class JUnit4ClassAnalysisRequest implements ClassAnalysisRequest
         }
 
         @Override
-        public String[] getPackages() {
+        public String[] getPackageNames() {
             return analyzeClasses.packages();
         }
 

File: archunit-junit/junit4/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerTest.java
Patch:
@@ -63,7 +63,7 @@ public void runner_creates_correct_analysis_request() {
 
         AnalyzeClasses analyzeClasses = MaxAnnotatedTest.class.getAnnotation(AnalyzeClasses.class);
         ClassAnalysisRequest analysisRequest = analysisRequestCaptor.getValue();
-        assertThat(analysisRequest.getPackages()).isEqualTo(analyzeClasses.packages());
+        assertThat(analysisRequest.getPackageNames()).isEqualTo(analyzeClasses.packages());
         assertThat(analysisRequest.getPackageRoots()).isEqualTo(analyzeClasses.packagesOf());
         assertThat(analysisRequest.getLocationProviders()).isEqualTo(analyzeClasses.locations());
         assertThat(analysisRequest.getImportOptions()).isEqualTo(analyzeClasses.importOptions());

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/ArchUnitTestDescriptor.java
Patch:
@@ -289,7 +289,7 @@ private static AnalyzeClasses checkAnnotation(Class<?> testClass) {
         }
 
         @Override
-        public String[] getPackages() {
+        public String[] getPackageNames() {
             return analyzeClasses.packages();
         }
 

File: archunit-junit/junit5/engine/src/test/java/com/tngtech/archunit/junit/ArchUnitTestEngineTest.java
Patch:
@@ -734,7 +734,7 @@ void passes_AnalyzeClasses_to_cache() {
             verify(classCache).getClassesToAnalyzeFor(eq(FullAnalyzeClassesSpec.class), classAnalysisRequestCaptor.capture());
             ClassAnalysisRequest request = classAnalysisRequestCaptor.getValue();
             AnalyzeClasses expected = FullAnalyzeClassesSpec.class.getAnnotation(AnalyzeClasses.class);
-            assertThat(request.getPackages()).isEqualTo(expected.packages());
+            assertThat(request.getPackageNames()).isEqualTo(expected.packages());
             assertThat(request.getPackageRoots()).isEqualTo(expected.packagesOf());
             assertThat(request.getLocationProviders()).isEqualTo(expected.locations());
             assertThat(request.getImportOptions()).isEqualTo(expected.importOptions());
@@ -942,7 +942,7 @@ private void simulateCachedClassesForTest(Class<?> testClass, Class<?> classToRe
     }
 
     private ClassAnalysisRequest classAnalysisRequestOf(Class<?> testClass) {
-        return argThat(r -> Arrays.equals(r.getPackages(), testClass.getAnnotation(AnalyzeClasses.class).packages()));
+        return argThat(r -> Arrays.equals(r.getPackageNames(), testClass.getAnnotation(AnalyzeClasses.class).packages()));
     }
 
     private EngineExecutionTestListener execute(UniqueId uniqueId, Class<?> testClass) {

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ClassAnalysisRequest.java
Patch:
@@ -6,7 +6,7 @@
  * Simple adapter to separate the JUnit version specific @AnalyzeClasses from infrastructure like {@link ClassCache}.
  */
 interface ClassAnalysisRequest {
-    String[] getPackages();
+    String[] getPackageNames();
 
     Class<?>[] getPackageRoots();
 

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ClassCache.java
Patch:
@@ -40,7 +40,7 @@
 
 /**
  * The {@link ClassCache} takes care of caching {@link JavaClasses} between test runs. On the one hand,
- * it caches {@link JavaClasses} between different {@link ArchTest @ArchTest} evaluations,
+ * it caches {@link JavaClasses} between different test runs,
  * on the other hand, it caches {@link JavaClasses} between different test classes,
  * i.e. if two test classes <code>ATest</code> and <code>BTest</code>
  * import the same locations (e.g. packages, URLs, etc.), the imported {@link JavaClasses} from <code>ATest</code> will be
@@ -181,7 +181,7 @@ private Specific(ClassAnalysisRequest classAnalysisRequest, Class<?> testClass)
 
             private Set<Location> getLocationsOfPackages() {
                 Set<String> packages = ImmutableSet.<String>builder()
-                        .add(classAnalysisRequest.getPackages())
+                        .add(classAnalysisRequest.getPackageNames())
                         .addAll(toPackageStrings(classAnalysisRequest.getPackageRoots()))
                         .build();
                 return locationsOf(packages);
@@ -235,7 +235,7 @@ public static RequestedLocations by(ClassAnalysisRequest classAnalysisRequest, C
         }
 
         private static boolean noSpecificLocationRequested(ClassAnalysisRequest classAnalysisRequest) {
-            return classAnalysisRequest.getPackages().length == 0
+            return classAnalysisRequest.getPackageNames().length == 0
                     && classAnalysisRequest.getPackageRoots().length == 0
                     && classAnalysisRequest.getLocationProviders().length == 0;
         }

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ClassCacheTest.java
Patch:
@@ -97,7 +97,7 @@ public void filters_jars_relative_to_class() {
 
         assertThat(classes).isNotEmpty();
         for (JavaClass clazz : classes) {
-            assertThat(clazz.getPackage()).doesNotContain("tngtech");
+            assertThat(clazz.getPackageName()).doesNotContain("tngtech");
         }
     }
 
@@ -142,8 +142,8 @@ public void filters_urls() {
 
         assertThat(classes).isNotEmpty();
         for (JavaClass clazz : classes) {
-            assertThat(clazz.getPackage()).doesNotContain(ClassCache.class.getSimpleName());
-            assertThat(clazz.getPackage()).contains("junit");
+            assertThat(clazz.getPackageName()).doesNotContain("tngtech");
+            assertThat(clazz.getPackageName()).contains("junit");
         }
     }
 

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/TestAnalysisRequest.java
Patch:
@@ -7,11 +7,11 @@ class TestAnalysisRequest implements ClassAnalysisRequest {
     private String[] packages = new String[0];
     private Class<?>[] packageRoots = new Class[0];
     private Class<? extends LocationProvider>[] locationProviders = new Class[0];
-    private Class[] importOptions = new Class[0];
+    private Class<? extends ImportOption>[] importOptions = new Class[0];
     private CacheMode cacheMode = CacheMode.FOREVER;
 
     @Override
-    public String[] getPackages() {
+    public String[] getPackageNames() {
         return packages;
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaType.java
Patch:
@@ -41,7 +41,7 @@ public interface JavaType {
 
     String getSimpleName();
 
-    String getPackage();
+    String getPackageName();
 
     @ResolvesTypesViaReflection
     Class<?> resolveClass();
@@ -148,7 +148,7 @@ public String getSimpleName() {
             }
 
             @Override
-            public String getPackage() {
+            public String getPackageName() {
                 return javaPackage;
             }
 
@@ -227,7 +227,7 @@ private static class PrimitiveType extends AbstractType {
             }
 
             @Override
-            Class<?> classForName(ClassLoader classLoader) throws ClassNotFoundException {
+            Class<?> classForName(ClassLoader classLoader) {
                 return primitiveClassesByName.get(getName());
             }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ArchConditions.java
Patch:
@@ -57,7 +57,7 @@
 import static com.tngtech.archunit.core.domain.Dependency.Predicates.dependencyTarget;
 import static com.tngtech.archunit.core.domain.Formatters.ensureSimpleName;
 import static com.tngtech.archunit.core.domain.Formatters.formatLocation;
-import static com.tngtech.archunit.core.domain.JavaClass.Functions.GET_PACKAGE;
+import static com.tngtech.archunit.core.domain.JavaClass.Functions.GET_PACKAGE_NAME;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.simpleName;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.simpleNameContaining;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.simpleNameEndingWith;
@@ -242,7 +242,7 @@ public static ArchCondition<JavaClass> onlyBeAccessedByAnyPackage(String... pack
     public static ArchCondition<JavaClass> onlyHaveDependentsInAnyPackage(String... packageIdentifiers) {
         String description = String.format("only have dependents in any package ['%s']",
                 Joiner.on("', '").join(packageIdentifiers));
-        return onlyHaveDependentsWhere(dependencyOrigin(GET_PACKAGE.is(PackageMatchers.of(packageIdentifiers))))
+        return onlyHaveDependentsWhere(dependencyOrigin(GET_PACKAGE_NAME.is(PackageMatchers.of(packageIdentifiers))))
                 .as(description);
     }
 
@@ -273,7 +273,7 @@ public Collection<Dependency> apply(JavaClass input) {
     public static AllDependenciesCondition onlyHaveDependenciesInAnyPackage(String... packageIdentifiers) {
         String description = String.format("only have dependencies in any package ['%s']",
                 Joiner.on("', '").join(packageIdentifiers));
-        return onlyHaveDependenciesWhere(dependencyTarget(GET_PACKAGE.is(PackageMatchers.of(packageIdentifiers))))
+        return onlyHaveDependenciesWhere(dependencyTarget(GET_PACKAGE_NAME.is(PackageMatchers.of(packageIdentifiers))))
                 .as(description);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/library/Architectures.java
Patch:
@@ -45,7 +45,6 @@
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 import static com.tngtech.archunit.core.domain.Dependency.Predicates.dependency;
 import static com.tngtech.archunit.core.domain.Dependency.Predicates.dependencyOrigin;
-import static com.tngtech.archunit.core.domain.JavaClass.Functions.GET_PACKAGE;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.equivalentTo;
 import static com.tngtech.archunit.core.domain.properties.HasName.Predicates.name;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.onlyHaveDependentsWhere;
@@ -164,7 +163,7 @@ public EvaluationResult evaluate(JavaClasses classes) {
 
         private DescribedPredicate<Dependency> originPackageMatchesIfDependencyIsRelevant(SortedSet<String> packagesOfAllowedAccessors) {
             DescribedPredicate<Dependency> originPackageMatches =
-                    dependencyOrigin(GET_PACKAGE.is(PackageMatchers.of(toArray(packagesOfAllowedAccessors))));
+                    dependencyOrigin(JavaClass.Functions.GET_PACKAGE_NAME.is(PackageMatchers.of(toArray(packagesOfAllowedAccessors))));
 
             return irrelevantDependenciesPredicate.isPresent() ?
                     originPackageMatches.or(irrelevantDependenciesPredicate.get()) :
@@ -207,7 +206,7 @@ public LayeredArchitecture ignoreDependency(
         }
 
         private String[] toArray(Set<String> strings) {
-            return strings.toArray(new String[strings.size()]);
+            return strings.toArray(new String[0]);
         }
 
         private SortedSet<String> packagesOf(String layerName) {

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Slices.java
Patch:
@@ -267,7 +267,7 @@ public Slices matching(String packageIdentifier) {
             SliceBuilders sliceBuilders = new SliceBuilders();
             PackageMatcher matcher = PackageMatcher.of(packageIdentifier);
             for (JavaClass clazz : classes) {
-                Optional<List<String>> groups = matcher.match(clazz.getPackage()).transform(TO_GROUPS);
+                Optional<List<String>> groups = matcher.match(clazz.getPackageName()).transform(TO_GROUPS);
                 sliceBuilders.add(groups, clazz);
             }
             return new Slices(sliceBuilders.build()).as(slicesMatchingDescription(packageIdentifier));

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaTypeTest.java
Patch:
@@ -92,7 +92,7 @@ public void anonymous_type() {
 
         assertThat(anonymousType.getName()).isEqualTo(getClass().getName() + "$1");
         assertThat(anonymousType.getSimpleName()).isEmpty();
-        assertThat(anonymousType.getPackage()).isEqualTo(getClass().getPackage().getName());
+        assertThat(anonymousType.getPackageName()).isEqualTo(getClass().getPackage().getName());
     }
 
     @Test
@@ -101,7 +101,7 @@ public void special_chars_type() {
 
         assertThat(specialChars.getName()).isEqualTo("s_123_wéirdâ.Weird_αρετη_Type");
         assertThat(specialChars.getSimpleName()).isEqualTo("Weird_αρετη_Type");
-        assertThat(specialChars.getPackage()).isEqualTo("s_123_wéirdâ");
+        assertThat(specialChars.getPackageName()).isEqualTo("s_123_wéirdâ");
     }
 
     @Test
@@ -110,7 +110,7 @@ public void default_package() {
 
         assertThat(specialChars.getName()).isEqualTo("DefaultPackage");
         assertThat(specialChars.getSimpleName()).isEqualTo("DefaultPackage");
-        assertThat(specialChars.getPackage()).isEmpty();
+        assertThat(specialChars.getPackageName()).isEmpty();
     }
 
     @DataProvider

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -281,6 +281,8 @@ public void matches(Class<?> clazz) {
                     .isEqualTo(ensureArrayName(clazz.getSimpleName()));
             assertThat(actual.getPackage()).as("Package of " + actual)
                     .isEqualTo(clazz.getPackage() != null ? clazz.getPackage().getName() : "");
+            assertThat(actual.getPackageName()).as("Package name of " + actual)
+                    .isEqualTo(clazz.getPackage() != null ? clazz.getPackage().getName() : "");
             assertThat(actual.getModifiers()).as("Modifiers of " + actual)
                     .isEqualTo(JavaModifier.getModifiersForClass(clazz.getModifiers()));
             assertThat(propertiesOf(actual.getAnnotations())).as("Annotations of " + actual)
@@ -776,7 +778,7 @@ private JavaTypeAssertion(JavaType actual) {
         public void isEquivalentTo(Class<?> clazz) {
             assertThat(actual.getName()).as("name").isEqualTo(clazz.getName());
             assertThat(actual.getSimpleName()).as("simple name").isEqualTo(clazz.getSimpleName());
-            assertThat(actual.getPackage()).as("package").isEqualTo(clazz.getPackage() != null ? clazz.getPackage().getName() : "");
+            assertThat(actual.getPackageName()).as("package").isEqualTo(clazz.getPackage() != null ? clazz.getPackage().getName() : "");
         }
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/ComponentName.java
Patch:
@@ -24,9 +24,6 @@ class ComponentName {
 
     ComponentName(String value) {
         this.value = checkNotNull(value);
-        if (value.contains("-") || value.contains("_")) {
-            throw new IllegalDiagramException("Component Name '%s' should not contain character(s): '-' or '_'", value);
-        }
     }
 
     String asString() {

File: archunit/src/main/java/com/tngtech/archunit/base/Guava.java
Patch:
@@ -27,7 +27,7 @@
  */
 @Internal
 public final class Guava {
-    private static <T> Predicate<T> toGuava(final DescribedPredicate<T> predicate) {
+    public static <T> Predicate<T> toGuava(final DescribedPredicate<T> predicate) {
         return new Predicate<T>() {
             @Override
             public boolean apply(T input) {

File: archunit/src/main/java/com/tngtech/archunit/base/PackageMatcher.java
Patch:
@@ -88,7 +88,9 @@ private void validateCharacters(String packageIdentifier) {
         for (int i = 0; i < packageIdentifier.length(); i++) {
             char c = packageIdentifier.charAt(i);
             if (!Character.isJavaIdentifierPart(c) && !PACKAGE_CONTROL_SYMBOLS.contains(c)) {
-                throw new IllegalArgumentException("Package Identifier may only consist of valid java identifier parts or the symbols '.)(*'");
+                throw new IllegalArgumentException(
+                        String.format("Package Identifier '%s' may only consist of valid java identifier parts or the symbols '.)(*'",
+                                packageIdentifier));
             }
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/library/plantuml/Stereotype.java
Patch:
@@ -26,7 +26,7 @@ class Stereotype {
         this.value = checkNotNull(value);
     }
 
-    String getValue() {
+    String asString() {
         return value;
     }
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/ExamplesIntegrationTest.java
Patch:
@@ -619,7 +619,7 @@ public String getDescription() {
         };
     }
 
-    // FIXME: This can at the moment not really be covered by JUnit support, but probably should be...
+    // TODO: This can at the moment not really be covered by JUnit support, but probably should be...
     @TestFactory
     Stream<DynamicTest> SecurityTest() {
         ExpectedTestFailures expectedTestFailures = ExpectedTestFailures

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/RestrictNumberOfClassesWithACertainPropertyTest.java
Patch:
@@ -13,9 +13,11 @@
 @ArchTag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
 public class RestrictNumberOfClassesWithACertainPropertyTest {
+
     @ArchTest
     static final ArchRule no_new_classes_should_implement_SomeBusinessInterface =
             classes().that().implement(SomeBusinessInterface.class)
                     .should().containNumberOfElements(lessThanOrEqualTo(1))
                     .because("from now on new classes should implement " + SomeOtherBusinessInterface.class.getName());
+
 }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/ExamplesIntegrationTest.java
Patch:
@@ -536,8 +536,8 @@ Stream<DynamicTest> MethodReturnTypeTest() {
                 .ofRule("methods that reside in a package '..anticorruption..' and are public "
                         + String.format("should return type %s, ", WrappedResult.class.getName())
                         + "because we don't want to couple the client code directly to the return types of the encapsulated module")
-                .by(ExpectedMethod.method(WithIllegalReturnType.class, "directlyReturnInternalType").returningType(InternalType.class))
-                .by(ExpectedMethod.method(WithIllegalReturnType.class, "otherIllegalMethod", String.class).returningType(int.class))
+                .by(ExpectedMethod.of(WithIllegalReturnType.class, "directlyReturnInternalType").returningType(InternalType.class))
+                .by(ExpectedMethod.of(WithIllegalReturnType.class, "otherIllegalMethod", String.class).returningType(int.class))
 
                 .toDynamicTests();
     }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/ExpectedMethod.java
Patch:
@@ -5,7 +5,7 @@
 import static com.tngtech.archunit.core.domain.Formatters.formatMethod;
 
 public class ExpectedMethod {
-    public static ExpectedMethod.Creator method(Class<?> owner, String methodName, Class<?>... params) {
+    public static ExpectedMethod.Creator of(Class<?> owner, String methodName, Class<?>... params) {
         return new ExpectedMethod.Creator(owner, methodName, params);
     }
 

File: archunit-junit/junit5/engine-api/src/main/java/com/tngtech/archunit/junit/FieldSelector.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.Objects;
 
 import com.tngtech.archunit.PublicAPI;
+import com.tngtech.archunit.core.MayResolveTypesViaReflection;
 import org.junit.platform.engine.DiscoverySelector;
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
@@ -72,6 +73,7 @@ public static FieldSelector selectField(String className, String fieldName) {
         return selectField(classForName(className), fieldName);
     }
 
+    @MayResolveTypesViaReflection(reason = "Within the ArchUnitTestEngine we may resolve types via reflection, since they are needed anyway")
     private static Class<?> classForName(String className) {
         try {
             return Class.forName(className);

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/ArchUnitTestEngine.java
Patch:
@@ -25,6 +25,7 @@
 import java.util.stream.StreamSupport;
 
 import com.tngtech.archunit.Internal;
+import com.tngtech.archunit.core.MayResolveTypesViaReflection;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
@@ -167,6 +168,7 @@ private boolean isArchUnitTestCandidate(JavaClass javaClass) {
         return javaClass.getAllMembers().stream().anyMatch(m -> m.isAnnotatedWith(ArchTest.class));
     }
 
+    @MayResolveTypesViaReflection(reason = "Within the ArchUnitTestEngine we may resolve types via reflection, since they are needed anyway")
     private Stream<Class<?>> safelyReflect(JavaClass javaClass) {
         try {
             return Stream.of(javaClass.reflect());

File: archunit-junit/junit5/engine/src/main/java/com/tngtech/archunit/junit/ElementResolver.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 
+import com.tngtech.archunit.core.MayResolveTypesViaReflection;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.UniqueId;
 
@@ -99,6 +100,7 @@ private Deque<UniqueId.Segment> tail(Deque<UniqueId.Segment> segmentsToResolve)
         return result;
     }
 
+    @MayResolveTypesViaReflection(reason = "Within the ArchUnitTestEngine we may resolve types via reflection, since they are needed anyway")
     private Class<?> classOf(UniqueId.Segment segment) {
         try {
             return Class.forName(segment.getValue());

File: archunit-junit/junit5/src/main/java/com/tngtech/archunit/junit/ArchUnitTestDescriptor.java
Patch:
@@ -237,13 +237,13 @@ private static class ArchUnitRulesDescriptor extends AbstractArchUnitTestDescrip
         public void createChildren(ElementResolver resolver) {
             rules.forEachDeclaration(declaration -> declaration.handleWith(new ArchRuleDeclaration.Handler() {
                 @Override
-                public void handleFieldDeclaration(Field field, boolean ignore) {
+                public void handleFieldDeclaration(Field field, boolean unimportantBecauseTheHierarchyAlreadyDoesThis) {
                     resolver.resolve(FIELD_SEGMENT_TYPE, field.getName(), childResolver ->
                             resolveChildren(ArchUnitRulesDescriptor.this, childResolver, rules.getTestClass(), field, classes));
                 }
 
                 @Override
-                public void handleMethodDeclaration(Method method, boolean ignore) {
+                public void handleMethodDeclaration(Method method, boolean unimportantBecauseTheHierarchyAlreadyDoesThis) {
                     resolver.resolve(METHOD_SEGMENT_TYPE, method.getName(), childResolver ->
                             addChild(new ArchUnitMethodDescriptor(getUniqueId(), method, classes)));
                 }

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchUnitRunner.java
Patch:
@@ -120,7 +120,7 @@ private Set<ArchTestExecution> findArchRulesIn(FrameworkField ruleField) {
 
     private Set<ArchTestExecution> asTestExecutions(ArchRules archRules, boolean forceIgnore) {
         ExecutionTransformer executionTransformer = new ExecutionTransformer();
-        for (ArchRuleDeclaration<?> declaration : toDeclarations(archRules, getTestClass().getJavaClass(), forceIgnore)) {
+        for (ArchRuleDeclaration<?> declaration : toDeclarations(archRules, getTestClass().getJavaClass(), ArchTest.class, forceIgnore)) {
             declaration.handleWith(executionTransformer);
         }
         return executionTransformer.getExecutions();

File: archunit-junit/junit5/src/main/java/com/tngtech/archunit/junit/ArchUnitTestDescriptor.java
Patch:
@@ -278,7 +278,7 @@ String getDisplayName() {
         }
 
         void forEachDeclaration(Consumer<ArchRuleDeclaration<?>> doWithDeclaration) {
-            toDeclarations(rules, testClass, false).forEach(doWithDeclaration);
+            toDeclarations(rules, testClass, ArchTest.class, false).forEach(doWithDeclaration);
         }
     }
 

File: archunit-junit/src/api/java/com/tngtech/archunit/junit/ArchIgnore.java
Patch:
@@ -24,7 +24,7 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Marks rules (annotated with @{@link ArchTest} to be ignored by the test support.
+ * Marks rules (annotated with <code>@ArchTest</code>) to be ignored by the test support.
  * I.e. rules marked this way will be skipped during evaluation.
  */
 @Target({TYPE, FIELD, METHOD})

File: archunit-junit/junit5/src/test/java/com/tngtech/archunit/junit/testexamples/RuleThatFails.java
Patch:
@@ -8,8 +8,8 @@
 
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
 
-class RuleThatFails {
-    static ArchRule on(Class<?> input) {
+public class RuleThatFails {
+    public static ArchRule on(Class<?> input) {
         return classes().should(new ArchCondition<JavaClass>("not be " + input.getName()) {
             @Override
             public void check(JavaClass item, ConditionEvents events) {

File: archunit-junit/junit5/src/test/java/com/tngtech/archunit/junit/testexamples/SimpleRuleLibrary.java
Patch:
@@ -3,6 +3,8 @@
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchRules;
 import com.tngtech.archunit.junit.ArchTest;
+import com.tngtech.archunit.junit.testexamples.subone.SimpleRuleField;
+import com.tngtech.archunit.junit.testexamples.subtwo.SimpleRules;
 
 @AnalyzeClasses(packages = "some.dummy.package")
 public class SimpleRuleLibrary {

File: archunit-junit/junit5/src/test/java/com/tngtech/archunit/junit/testexamples/TestClassWithTags.java
Patch:
@@ -5,6 +5,7 @@
 import com.tngtech.archunit.junit.ArchRules;
 import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
+import com.tngtech.archunit.junit.testexamples.subone.SimpleRuleField;
 import com.tngtech.archunit.lang.ArchRule;
 
 @ArchTag("tag-one")

File: archunit-junit/junit5/src/test/java/com/tngtech/archunit/junit/testexamples/subone/SimpleRuleField.java
Patch:
@@ -1,7 +1,9 @@
-package com.tngtech.archunit.junit.testexamples;
+package com.tngtech.archunit.junit.testexamples.subone;
 
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
+import com.tngtech.archunit.junit.testexamples.RuleThatFails;
+import com.tngtech.archunit.junit.testexamples.UnwantedClass;
 import com.tngtech.archunit.lang.ArchRule;
 
 @AnalyzeClasses(packages = "some.dummy.package")

File: archunit-junit/junit5/src/test/java/com/tngtech/archunit/junit/testexamples/subone/SimpleRuleMethod.java
Patch:
@@ -1,8 +1,10 @@
-package com.tngtech.archunit.junit.testexamples;
+package com.tngtech.archunit.junit.testexamples.subone;
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
+import com.tngtech.archunit.junit.testexamples.RuleThatFails;
+import com.tngtech.archunit.junit.testexamples.UnwantedClass;
 
 @AnalyzeClasses(packages = "some.dummy.package")
 public class SimpleRuleMethod {

File: archunit-junit/junit5/src/test/java/com/tngtech/archunit/junit/testexamples/subtwo/SimpleRules.java
Patch:
@@ -1,11 +1,13 @@
-package com.tngtech.archunit.junit.testexamples;
+package com.tngtech.archunit.junit.testexamples.subtwo;
 
 import java.util.Set;
 
 import com.google.common.collect.ImmutableSet;
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
+import com.tngtech.archunit.junit.testexamples.RuleThatFails;
+import com.tngtech.archunit.junit.testexamples.UnwantedClass;
 import com.tngtech.archunit.lang.ArchRule;
 
 @AnalyzeClasses(packages = "some.dummy.package")

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/CodingRulesTest.java
Patch:
@@ -2,17 +2,17 @@
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.AnalyzeClasses;
+import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.lang.ArchRule;
-import org.junit.jupiter.api.Tag;
 
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
 import static com.tngtech.archunit.library.GeneralCodingRules.ACCESS_STANDARD_STREAMS;
 import static com.tngtech.archunit.library.GeneralCodingRules.NO_CLASSES_SHOULD_ACCESS_STANDARD_STREAMS;
 import static com.tngtech.archunit.library.GeneralCodingRules.NO_CLASSES_SHOULD_THROW_GENERIC_EXCEPTIONS;
 import static com.tngtech.archunit.library.GeneralCodingRules.NO_CLASSES_SHOULD_USE_JAVA_UTIL_LOGGING;
 
-@Tag("example")
+@ArchTag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
 public class CodingRulesTest {
 

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/CyclicDependencyRulesTest.java
Patch:
@@ -3,15 +3,15 @@
 import com.tngtech.archunit.example.cycle.complexcycles.slice1.SliceOneCallingConstructorInSliceTwoAndMethodInSliceThree;
 import com.tngtech.archunit.example.cycle.complexcycles.slice3.ClassCallingConstructorInSliceFive;
 import com.tngtech.archunit.junit.AnalyzeClasses;
+import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.lang.ArchRule;
-import org.junit.jupiter.api.Tag;
 
 import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.resideInAPackage;
 import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
 
-@Tag("example")
+@ArchTag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example.cycle")
 public class CyclicDependencyRulesTest {
 

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/DaoRulesTest.java
Patch:
@@ -4,14 +4,14 @@
 import javax.persistence.EntityManager;
 
 import com.tngtech.archunit.junit.AnalyzeClasses;
+import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.lang.ArchRule;
-import org.junit.jupiter.api.Tag;
 
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
 
-@Tag("example")
+@ArchTag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
 public class DaoRulesTest {
     @ArchTest

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/InterfaceRulesTest.java
Patch:
@@ -9,14 +9,14 @@
 import com.tngtech.archunit.example.persistence.first.dao.SomeDao;
 import com.tngtech.archunit.example.service.impl.SomeInterfacePlacedInTheWrongPackage;
 import com.tngtech.archunit.junit.AnalyzeClasses;
+import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.LocationProvider;
 import com.tngtech.archunit.lang.ArchRule;
-import org.junit.jupiter.api.Tag;
 
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
 
-@Tag("example")
+@ArchTag("example")
 @AnalyzeClasses(locations = InterfaceRulesTest.RelevantExampleClasses.class)
 public class InterfaceRulesTest {
 

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/LayerDependencyRulesTest.java
Patch:
@@ -1,14 +1,14 @@
 package com.tngtech.archunit.exampletest.junit5;
 
 import com.tngtech.archunit.junit.AnalyzeClasses;
+import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.lang.ArchRule;
-import org.junit.jupiter.api.Tag;
 
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
 
-@Tag("example")
+@ArchTag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
 public class LayerDependencyRulesTest {
 

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/LayeredArchitectureTest.java
Patch:
@@ -3,13 +3,13 @@
 import com.tngtech.archunit.example.SomeMediator;
 import com.tngtech.archunit.example.service.ServiceViolatingLayerRules;
 import com.tngtech.archunit.junit.AnalyzeClasses;
+import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.lang.ArchRule;
-import org.junit.jupiter.api.Tag;
 
 import static com.tngtech.archunit.library.Architectures.layeredArchitecture;
 
-@Tag("example")
+@ArchTag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
 public class LayeredArchitectureTest {
     @ArchTest

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/MethodReturnTypeTest.java
Patch:
@@ -12,22 +12,22 @@
 import com.tngtech.archunit.core.domain.properties.HasOwner.Functions.Get;
 import com.tngtech.archunit.example.anticorruption.WrappedResult;
 import com.tngtech.archunit.junit.AnalyzeClasses;
+import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.lang.AbstractClassesTransformer;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ArchRule;
 import com.tngtech.archunit.lang.ClassesTransformer;
 import com.tngtech.archunit.lang.ConditionEvents;
 import com.tngtech.archunit.lang.SimpleConditionEvent;
-import org.junit.jupiter.api.Tag;
 
 import static com.tngtech.archunit.core.domain.Formatters.formatLocation;
 import static com.tngtech.archunit.core.domain.JavaClass.Predicates.resideInAPackage;
 import static com.tngtech.archunit.core.domain.JavaModifier.PUBLIC;
 import static com.tngtech.archunit.core.domain.properties.HasModifiers.Predicates.modifier;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.all;
 
-@Tag("example")
+@ArchTag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
 public class MethodReturnTypeTest {
 

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/NamingConventionTest.java
Patch:
@@ -4,13 +4,13 @@
 import com.tngtech.archunit.example.MyController;
 import com.tngtech.archunit.example.MyService;
 import com.tngtech.archunit.junit.AnalyzeClasses;
+import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.lang.ArchRule;
-import org.junit.jupiter.api.Tag;
 
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
 
-@Tag("example")
+@ArchTag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
 public class NamingConventionTest {
 

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/RestrictNumberOfClassesWithACertainPropertyTest.java
Patch:
@@ -3,14 +3,14 @@
 import com.tngtech.archunit.example.SomeBusinessInterface;
 import com.tngtech.archunit.example.SomeOtherBusinessInterface;
 import com.tngtech.archunit.junit.AnalyzeClasses;
+import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.lang.ArchRule;
-import org.junit.jupiter.api.Tag;
 
 import static com.tngtech.archunit.base.DescribedPredicate.lessThanOrEqualTo;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
 
-@Tag("example")
+@ArchTag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
 public class RestrictNumberOfClassesWithACertainPropertyTest {
     @ArchTest

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/RuleLibraryTest.java
Patch:
@@ -2,10 +2,10 @@
 
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchRules;
+import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
-import org.junit.jupiter.api.Tag;
 
-@Tag("example")
+@ArchTag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
 class RuleLibraryTest {
     @ArchTest

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/RuleSetsTest.java
Patch:
@@ -2,10 +2,10 @@
 
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchRules;
+import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
-import org.junit.jupiter.api.Tag;
 
-@Tag("example")
+@ArchTag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
 class RuleSetsTest {
     @ArchTest

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/SessionBeanRulesTest.java
Patch:
@@ -15,12 +15,12 @@
 import com.tngtech.archunit.core.domain.JavaFieldAccess;
 import com.tngtech.archunit.core.domain.properties.HasOwner;
 import com.tngtech.archunit.junit.AnalyzeClasses;
+import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ArchRule;
 import com.tngtech.archunit.lang.ConditionEvents;
 import com.tngtech.archunit.lang.SimpleConditionEvent;
-import org.junit.jupiter.api.Tag;
 
 import static com.tngtech.archunit.base.DescribedPredicate.not;
 import static com.tngtech.archunit.core.domain.JavaAccess.Predicates.originOwnerEqualsTargetOwner;
@@ -31,7 +31,7 @@
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
 
-@Tag("example")
+@ArchTag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
 public class SessionBeanRulesTest {
 

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/SingleClassTest.java
Patch:
@@ -5,15 +5,15 @@
 import com.tngtech.archunit.example.core.HighSecurity;
 import com.tngtech.archunit.example.core.VeryCentralCore;
 import com.tngtech.archunit.junit.AnalyzeClasses;
+import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.lang.ArchRule;
-import org.junit.jupiter.api.Tag;
 
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClass;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.theClass;
 
-@Tag("example")
+@ArchTag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
 public class SingleClassTest {
 

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/SlicesIsolationTest.java
Patch:
@@ -4,16 +4,16 @@
 import com.tngtech.archunit.example.controller.one.UseCaseOneTwoController;
 import com.tngtech.archunit.example.controller.two.UseCaseTwoController;
 import com.tngtech.archunit.junit.AnalyzeClasses;
+import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.lang.ArchRule;
 import com.tngtech.archunit.library.dependencies.Slice;
-import org.junit.jupiter.api.Tag;
 
 import static com.tngtech.archunit.base.DescribedPredicate.alwaysTrue;
 import static com.tngtech.archunit.core.domain.properties.HasName.Predicates.nameMatching;
 import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
 
-@Tag("example")
+@ArchTag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
 public class SlicesIsolationTest {
     @ArchTest

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/ThirdPartyRulesTest.java
Patch:
@@ -6,10 +6,10 @@
 import com.tngtech.archunit.example.thirdparty.ThirdPartyClassWithProblem;
 import com.tngtech.archunit.example.thirdparty.ThirdPartyClassWorkaroundFactory;
 import com.tngtech.archunit.junit.AnalyzeClasses;
+import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ArchRule;
-import org.junit.jupiter.api.Tag;
 
 import static com.tngtech.archunit.base.DescribedPredicate.not;
 import static com.tngtech.archunit.core.domain.AccessTarget.Predicates.constructor;
@@ -23,7 +23,7 @@
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.is;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
 
-@Tag("example")
+@ArchTag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
 public class ThirdPartyRulesTest {
 

File: archunit-junit/junit5/src/main/java/com/tngtech/archunit/junit/ArchUnitTestDescriptor.java
Patch:
@@ -174,7 +174,7 @@ private static class ArchUnitRulesDescriptor extends AbstractArchUnitTestDescrip
                             .append("class", rules.getDefinitionLocation().getName()),
                     rules.getDisplayName(),
                     ClassSource.from(rules.getDefinitionLocation()),
-                    field);
+                    field, rules.getDefinitionLocation());
 
             setParent(parent);
 

File: archunit-junit/junit5/src/test/java/com/tngtech/archunit/junit/testexamples/TestMethodWithTags.java
Patch:
@@ -2,15 +2,15 @@
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.AnalyzeClasses;
+import com.tngtech.archunit.junit.ArchTag;
 import com.tngtech.archunit.junit.ArchTest;
-import org.junit.jupiter.api.Tag;
 
 @AnalyzeClasses
 public class TestMethodWithTags {
     public static final String METHOD_WITH_TAG_NAME = "method_with_tag";
 
-    @Tag("method-tag-one")
-    @Tag("method-tag-two")
+    @ArchTag("method-tag-one")
+    @ArchTag("method-tag-two")
     @ArchTest
     static void method_with_tag(JavaClasses classes) {
     }

File: archunit/src/main/java/com/tngtech/archunit/PublicAPI.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.tngtech.archunit;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.Inherited;
 
 import static com.tngtech.archunit.PublicAPI.State.STABLE;
@@ -32,6 +33,7 @@
  */
 @Internal
 @Inherited
+@Documented
 public @interface PublicAPI {
     /**
      * Marks how this API is supposed to be used.

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/AnalyzeClasses.java
Patch:
@@ -72,7 +72,7 @@
     Class<? extends ImportOption>[] importOptions() default {};
 
     /**
-     * Controls, if the {@link ClassCache} should cache {@link JavaClasses} by location,
+     * Controls, if {@link JavaClasses} should be cached by location,
      * to be reused between several test classes, or just within the same class.
      *
      * @return The {@link CacheMode} to use for this test class.

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchRuleExecution.java
Patch:
@@ -32,7 +32,7 @@ class ArchRuleExecution extends ArchTestExecution {
         super(testClass, ignore);
 
         validateStatic(ruleField);
-        ArchUnitTestInitializationException.check(ArchRule.class.isAssignableFrom(ruleField.getType()),
+        ArchTestInitializationException.check(ArchRule.class.isAssignableFrom(ruleField.getType()),
                 "Rule field %s.%s to check must be of type %s",
                 testClass.getSimpleName(), ruleField.getName(), ArchRule.class.getSimpleName());
 

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchTestExecution.java
Patch:
@@ -34,7 +34,7 @@ abstract class ArchTestExecution {
     }
 
     static <T extends Member> T validateStatic(T member) {
-        ArchUnitTestInitializationException.check(
+        ArchTestInitializationException.check(
                 Modifier.isStatic(member.getModifiers()),
                 "With @%s annotated members must be static", ArchTest.class.getSimpleName());
         return member;

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchTestMethodExecution.java
Patch:
@@ -44,7 +44,7 @@ Result evaluateOn(JavaClasses classes) {
     }
 
     private void executeTestMethod(JavaClasses classes) throws Throwable {
-        ArchUnitTestInitializationException.check(
+        ArchTestInitializationException.check(
                 Arrays.equals(testMethod.getParameterTypes(), new Class<?>[]{JavaClasses.class}),
                 "Methods annotated with @%s must have exactly one parameter of type %s",
                 ArchTest.class.getSimpleName(), JavaClasses.class.getSimpleName());

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchUnitRunner.java
Patch:
@@ -73,7 +73,7 @@ public ArchUnitRunner(Class<?> testClass) throws InitializationError {
 
     private static AnalyzeClasses checkAnnotation(Class<?> testClass) {
         AnalyzeClasses analyzeClasses = testClass.getAnnotation(AnalyzeClasses.class);
-        ArchUnitTestInitializationException.check(analyzeClasses != null,
+        ArchTestInitializationException.check(analyzeClasses != null,
                 "Class %s must be annotated with @%s",
                 testClass.getSimpleName(), AnalyzeClasses.class.getSimpleName());
         return analyzeClasses;

File: archunit-junit/junit4/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerTest.java
Patch:
@@ -85,7 +85,7 @@ public void runner_clears_cache_after_exception_during_test_run() {
 
     @Test
     public void rejects_missing_analyze_annotation() throws InitializationError {
-        thrown.expect(ArchUnitTestInitializationException.class);
+        thrown.expect(ArchTestInitializationException.class);
         thrown.expectMessage(Object.class.getSimpleName());
         thrown.expectMessage("must be annotated");
         thrown.expectMessage(AnalyzeClasses.class.getSimpleName());

File: archunit-junit/junit5/src/api/java/com/tngtech/archunit/junit/AnalyzeClasses.java
Patch:
@@ -76,7 +76,7 @@
     Class<? extends ImportOption>[] importOptions() default {};
 
     /**
-     * Controls, if the {@link ClassCache} should cache {@link JavaClasses} by location,
+     * Controls, if {@link JavaClasses} should be cached by location,
      * to be reused between several test classes, or just within the same class.
      *
      * @return The {@link CacheMode} to use for this test class.

File: archunit-junit/junit5/src/engine-api/java/com/tngtech/archunit/junit/FieldSource.java
Patch:
@@ -32,10 +32,12 @@ private FieldSource(Field field) {
         fieldName = field.getName();
     }
 
+    @PublicAPI(usage = ACCESS)
     public String getClassName() {
         return className;
     }
 
+    @PublicAPI(usage = ACCESS)
     public String getFieldName() {
         return fieldName;
     }

File: archunit-junit/junit5/src/main/java/com/tngtech/archunit/junit/ArchUnitTestDescriptor.java
Patch:
@@ -121,12 +121,12 @@ private static class ArchUnitMethodDescriptor extends AbstractArchUnitTestDescri
         }
 
         private void validate(Method method) {
-            ArchUnitTestInitializationException.check(
+            ArchTestInitializationException.check(
                     isStatic(method.getModifiers()),
                     "@%s Method %s.%s must be static",
                     ArchTest.class.getSimpleName(), method.getDeclaringClass().getSimpleName(), method.getName());
 
-            ArchUnitTestInitializationException.check(
+            ArchTestInitializationException.check(
                     method.getParameterCount() == 1 && method.getParameterTypes()[0].equals(JavaClasses.class),
                     "@%s Method %s.%s must have exactly one parameter of type %s",
                     ArchTest.class.getSimpleName(), method.getDeclaringClass().getSimpleName(), method.getName(), JavaClasses.class.getName());

File: archunit-junit/junit5/src/test/java/com/tngtech/archunit/junit/ArchUnitTestEngineTest.java
Patch:
@@ -368,7 +368,7 @@ void rule_method_that_is_not_static_is_rejected() {
             UniqueId uniqueId = uniqueTestId();
 
             assertThatThrownBy(() -> execute(uniqueId, WrongRuleMethodNotStatic.class))
-                    .isInstanceOf(ArchUnitTestInitializationException.class)
+                    .isInstanceOf(ArchTestInitializationException.class)
                     .hasMessageContaining(ArchTest.class.getSimpleName())
                     .hasMessageContaining(WrongRuleMethodNotStatic.class.getSimpleName())
                     .hasMessageContaining(WrongRuleMethodNotStatic.NOT_STATIC_METHOD_NAME)
@@ -380,7 +380,7 @@ void rule_method_with_wrong_parameters_is_rejected() {
             UniqueId uniqueId = uniqueTestId();
 
             assertThatThrownBy(() -> execute(uniqueId, WrongRuleMethodWrongParameters.class))
-                    .isInstanceOf(ArchUnitTestInitializationException.class)
+                    .isInstanceOf(ArchTestInitializationException.class)
                     .hasMessageContaining(ArchTest.class.getSimpleName())
                     .hasMessageContaining(WrongRuleMethodWrongParameters.class.getSimpleName())
                     .hasMessageContaining(WrongRuleMethodWrongParameters.WRONG_PARAMETERS_METHOD_NAME)

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ArchTestInitializationException.java
Patch:
@@ -3,14 +3,14 @@
 import com.tngtech.archunit.Internal;
 
 @Internal
-public class ArchUnitTestInitializationException extends RuntimeException {
-    private ArchUnitTestInitializationException(String message, Object... args) {
+public class ArchTestInitializationException extends RuntimeException {
+    private ArchTestInitializationException(String message, Object... args) {
         super(String.format(message, args));
     }
 
     public static void check(boolean condition, String message, Object... args) {
         if (!condition) {
-            throw new ArchUnitTestInitializationException(message, args);
+            throw new ArchTestInitializationException(message, args);
         }
     }
 }

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchUnitRunner.java
Patch:
@@ -39,6 +39,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 import static com.tngtech.archunit.junit.ArchRuleDeclaration.elementShouldBeIgnored;
+import static com.tngtech.archunit.junit.ArchRuleDeclaration.toDeclarations;
 import static com.tngtech.archunit.junit.ArchTestExecution.validateStatic;
 import static com.tngtech.archunit.junit.ReflectionUtils.getValue;
 
@@ -119,7 +120,7 @@ private Set<ArchTestExecution> findArchRulesIn(FrameworkField ruleField) {
 
     private Set<ArchTestExecution> asTestExecutions(ArchRules archRules, boolean forceIgnore) {
         ExecutionTransformer executionTransformer = new ExecutionTransformer();
-        for (ArchRuleDeclaration<?> declaration : archRules.asDeclarations(getTestClass().getJavaClass(), forceIgnore)) {
+        for (ArchRuleDeclaration<?> declaration : toDeclarations(archRules, getTestClass().getJavaClass(), forceIgnore)) {
             declaration.handleWith(executionTransformer);
         }
         return executionTransformer.getExecutions();

File: archunit-junit/junit5/src/main/java/com/tngtech/archunit/junit/ArchUnitTestDescriptor.java
Patch:
@@ -33,6 +33,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Suppliers.memoize;
+import static com.tngtech.archunit.junit.ArchRuleDeclaration.toDeclarations;
 import static com.tngtech.archunit.junit.ReflectionUtils.getAllFields;
 import static com.tngtech.archunit.junit.ReflectionUtils.getAllMethods;
 import static com.tngtech.archunit.junit.ReflectionUtils.getValue;
@@ -218,7 +219,7 @@ String getDisplayName() {
         }
 
         void forEachDeclaration(Consumer<ArchRuleDeclaration<?>> doWithDeclaration) {
-            rules.asDeclarations(testClass, false).forEach(doWithDeclaration);
+            toDeclarations(rules, testClass, false).forEach(doWithDeclaration);
         }
     }
 

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchUnitRunner.java
Patch:
@@ -169,17 +169,17 @@ void clear(Class<?> testClass) {
         }
     }
 
-    private class ExecutionTransformer implements ArchRuleDeclaration.Handler {
+    private static class ExecutionTransformer implements ArchRuleDeclaration.Handler {
         private final ImmutableSet.Builder<ArchTestExecution> executions = ImmutableSet.builder();
 
         @Override
         public void handleFieldDeclaration(Field field, boolean ignore) {
-            executions.add(new ArchRuleExecution(getTestClass().getJavaClass(), field, ignore));
+            executions.add(new ArchRuleExecution(field.getDeclaringClass(), field, ignore));
         }
 
         @Override
         public void handleMethodDeclaration(Method method, boolean ignore) {
-            executions.add(new ArchTestMethodExecution(getTestClass().getJavaClass(), method, ignore));
+            executions.add(new ArchTestMethodExecution(method.getDeclaringClass(), method, ignore));
         }
 
         Set<ArchTestExecution> getExecutions() {

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/CodingRulesTest.java
Patch:
@@ -1,7 +1,6 @@
 package com.tngtech.archunit.exampletest.junit4;
 
 import com.tngtech.archunit.core.domain.JavaClasses;
-import com.tngtech.archunit.exampletest.Example;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/CyclicDependencyRulesTest.java
Patch:
@@ -4,7 +4,6 @@
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.example.cycle.complexcycles.slice1.SliceOneCallingConstructorInSliceTwoAndMethodInSliceThree;
 import com.tngtech.archunit.example.cycle.complexcycles.slice3.ClassCallingConstructorInSliceFive;
-import com.tngtech.archunit.exampletest.Example;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/DaoRulesTest.java
Patch:
@@ -3,7 +3,6 @@
 import javax.persistence.Entity;
 import javax.persistence.EntityManager;
 
-import com.tngtech.archunit.exampletest.Example;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/InterfaceRulesTest.java
Patch:
@@ -8,7 +8,6 @@
 import com.tngtech.archunit.example.SomeBusinessInterface;
 import com.tngtech.archunit.example.persistence.first.dao.SomeDao;
 import com.tngtech.archunit.example.service.impl.SomeInterfacePlacedInTheWrongPackage;
-import com.tngtech.archunit.exampletest.Example;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/LayerDependencyRulesTest.java
Patch:
@@ -1,6 +1,5 @@
 package com.tngtech.archunit.exampletest.junit4;
 
-import com.tngtech.archunit.exampletest.Example;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/LayeredArchitectureTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.tngtech.archunit.example.SomeMediator;
 import com.tngtech.archunit.example.service.ServiceViolatingLayerRules;
-import com.tngtech.archunit.exampletest.Example;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/MethodReturnTypeTest.java
Patch:
@@ -11,7 +11,6 @@
 import com.tngtech.archunit.core.domain.properties.HasModifiers;
 import com.tngtech.archunit.core.domain.properties.HasOwner.Functions.Get;
 import com.tngtech.archunit.example.anticorruption.WrappedResult;
-import com.tngtech.archunit.exampletest.Example;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/NamingConventionTest.java
Patch:
@@ -3,7 +3,6 @@
 import com.tngtech.archunit.example.AbstractController;
 import com.tngtech.archunit.example.MyController;
 import com.tngtech.archunit.example.MyService;
-import com.tngtech.archunit.exampletest.Example;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/RestrictNumberOfClassesWithACertainPropertyTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.tngtech.archunit.example.SomeBusinessInterface;
 import com.tngtech.archunit.example.SomeOtherBusinessInterface;
-import com.tngtech.archunit.exampletest.Example;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/RuleLibraryTest.java
Patch:
@@ -1,6 +1,5 @@
 package com.tngtech.archunit.exampletest.junit4;
 
-import com.tngtech.archunit.exampletest.Example;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchRules;
 import com.tngtech.archunit.junit.ArchTest;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/RuleSetsTest.java
Patch:
@@ -1,6 +1,5 @@
 package com.tngtech.archunit.exampletest.junit4;
 
-import com.tngtech.archunit.exampletest.Example;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchRules;
 import com.tngtech.archunit.junit.ArchTest;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/SessionBeanRulesTest.java
Patch:
@@ -14,7 +14,6 @@
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.JavaFieldAccess;
 import com.tngtech.archunit.core.domain.properties.HasOwner;
-import com.tngtech.archunit.exampletest.Example;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/SingleClassTest.java
Patch:
@@ -4,7 +4,6 @@
 import com.tngtech.archunit.example.core.CoreSatellite;
 import com.tngtech.archunit.example.core.HighSecurity;
 import com.tngtech.archunit.example.core.VeryCentralCore;
-import com.tngtech.archunit.exampletest.Example;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/SlicesIsolationTest.java
Patch:
@@ -4,7 +4,6 @@
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.example.controller.one.UseCaseOneTwoController;
 import com.tngtech.archunit.example.controller.two.UseCaseTwoController;
-import com.tngtech.archunit.exampletest.Example;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/ThirdPartyRulesTest.java
Patch:
@@ -5,7 +5,6 @@
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.example.thirdparty.ThirdPartyClassWithProblem;
 import com.tngtech.archunit.example.thirdparty.ThirdPartyClassWorkaroundFactory;
-import com.tngtech.archunit.exampletest.Example;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitRunner;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/CyclicErrorMatcher.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.testutils;
 
 import java.util.ArrayList;
 import java.util.Collection;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/ExpectedClass.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.testutils;
 
 public class ExpectedClass {
     public static Creator javaClass(Class<?> clazz) {

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/ExpectedDependency.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.testutils;
 
 import com.tngtech.archunit.core.domain.Dependency;
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/ExpectedLocation.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.testutils;
 
 public class ExpectedLocation {
     public static Creator javaClass(Class<?> clazz) {

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/ExpectedMember.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.testutils;
 
 import java.util.ArrayList;
 import java.util.EnumSet;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/ExpectedMessage.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.testutils;
 
 import java.util.ArrayList;
 import java.util.List;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/ExpectedMethod.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.testutils;
 
 import com.tngtech.archunit.core.domain.JavaClass;
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/ExpectedNaming.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.testutils;
 
 public class ExpectedNaming {
     public static Creator simpleNameOf(Class<?> clazz) {

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/ExpectedRelation.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.testutils;
 
 import com.tngtech.archunit.core.domain.JavaAccess;
 import com.tngtech.archunit.lang.ConditionEvent;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/HandlingAssertion.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.testutils;
 
 import java.util.Collection;
 import java.util.HashSet;
@@ -14,10 +14,10 @@
 import com.tngtech.archunit.core.domain.JavaConstructorCall;
 import com.tngtech.archunit.core.domain.JavaFieldAccess;
 import com.tngtech.archunit.core.domain.JavaMethodCall;
-import com.tngtech.archunit.junit.ExpectedAccess.ExpectedCall;
-import com.tngtech.archunit.junit.ExpectedAccess.ExpectedFieldAccess;
 import com.tngtech.archunit.lang.EvaluationResult;
 import com.tngtech.archunit.lang.ViolationHandler;
+import com.tngtech.archunit.testutils.ExpectedAccess.ExpectedCall;
+import com.tngtech.archunit.testutils.ExpectedAccess.ExpectedFieldAccess;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Sets.union;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/MessageAssertionChain.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.testutils;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -12,7 +12,7 @@
 import com.tngtech.archunit.Internal;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.tngtech.archunit.junit.MessageAssertionChain.Link.Result.difference;
+import static com.tngtech.archunit.testutils.MessageAssertionChain.Link.Result.difference;
 import static java.lang.System.lineSeparator;
 import static java.util.Collections.singletonList;
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/SliceDependencyErrorMatcher.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.testutils;
 
 import java.util.ArrayList;
 import java.util.HashSet;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/testutils/ViolationComparisonResult.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.junit;
+package com.tngtech.archunit.testutils;
 
 class ViolationComparisonResult {
     private final String message;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/CyclicDependencyRulesTest.java
Patch:
@@ -50,7 +50,9 @@ public class CyclicDependencyRulesTest {
 
     @ArchTest
     public static final ArchRule no_cycles_in_complex_scenario_with_custom_ignore =
-            slices().matching("..(complexcycles).(*)..").namingSlices("$2 of $1").should().beFreeOfCycles()
+            slices().matching("..(complexcycles).(*)..").namingSlices("$2 of $1")
+                    .as("Slices of complex scenario ignoring some violations")
+                    .should().beFreeOfCycles()
                     .ignoreDependency(SliceOneCallingConstructorInSliceTwoAndMethodInSliceThree.class, ClassCallingConstructorInSliceFive.class)
                     .ignoreDependency(resideInAPackage("..slice4.."), DescribedPredicate.<JavaClass>alwaysTrue());
 }

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/RestrictNumberOfClassesWithACertainPropertyTest.java
Patch:
@@ -21,6 +21,5 @@ public class RestrictNumberOfClassesWithACertainPropertyTest {
     public static final ArchRule no_new_classes_should_implement_SomeBusinessInterface =
             classes().that().implement(SomeBusinessInterface.class)
                     .should().containNumberOfElements(lessThanOrEqualTo(1))
-                    .because("from now on new classes should implement "
-                            + SomeOtherBusinessInterface.class.getName());
+                    .because("from now on new classes should implement " + SomeOtherBusinessInterface.class.getName());
 }

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/RuleLibraryTest.java
Patch:
@@ -16,7 +16,7 @@ public class RuleLibraryTest {
     public static final ArchRules LIBRARY = ArchRules.in(RuleSetsTest.class);
 
     @ArchTest
-    public static final ArchRules FURTHER_CODING_RULES = ArchRules.in(CodingRulesMethodsTest.class);
+    public static final ArchRules FURTHER_CODING_RULES = ArchRules.in(CodingRulesTest.class);
 
     @ArchTest
     public static final ArchRules SLICES_ISOLATION_RULES = ArchRules.in(SlicesIsolationTest.class);

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/LayerDependencyRulesTest.java
Patch:
@@ -10,7 +10,7 @@
 
 @Tag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
-class LayerDependencyRulesTest {
+public class LayerDependencyRulesTest {
 
     @ArchTest
     static final ArchRule services_should_not_access_controllers =

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/LayeredArchitectureTest.java
Patch:
@@ -11,7 +11,7 @@
 
 @Tag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
-class LayeredArchitectureTest {
+public class LayeredArchitectureTest {
     @ArchTest
     static final ArchRule layer_dependencies_are_respected = layeredArchitecture()
 

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/NamingConventionTest.java
Patch:
@@ -12,7 +12,7 @@
 
 @Tag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
-class NamingConventionTest {
+public class NamingConventionTest {
 
     @ArchTest
     static ArchRule services_should_be_prefixed =

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/RestrictNumberOfClassesWithACertainPropertyTest.java
Patch:
@@ -17,6 +17,5 @@ public class RestrictNumberOfClassesWithACertainPropertyTest {
     static final ArchRule no_new_classes_should_implement_SomeBusinessInterface =
             classes().that().implement(SomeBusinessInterface.class)
                     .should().containNumberOfElements(lessThanOrEqualTo(1))
-                    .because("from now on new classes should implement "
-                            + SomeOtherBusinessInterface.class.getName());
+                    .because("from now on new classes should implement " + SomeOtherBusinessInterface.class.getName());
 }

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/RuleLibraryTest.java
Patch:
@@ -12,7 +12,7 @@ class RuleLibraryTest {
     static final ArchRules LIBRARY = ArchRules.in(RuleSetsTest.class);
 
     @ArchTest
-    static final ArchRules FURTHER_CODING_RULES = ArchRules.in(CodingRulesMethodsTest.class);
+    static final ArchRules FURTHER_CODING_RULES = ArchRules.in(CodingRulesTest.class);
 
     @ArchTest
     static final ArchRules SLICES_ISOLATION_RULES = ArchRules.in(SlicesIsolationTest.class);

File: archunit-example/example-junit5/src/test/java/com/tngtech/archunit/exampletest/junit5/SlicesIsolationTest.java
Patch:
@@ -15,7 +15,7 @@
 
 @Tag("example")
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
-class SlicesIsolationTest {
+public class SlicesIsolationTest {
     @ArchTest
     static final ArchRule controllers_should_only_use_their_own_slice =
             slices().matching("..controller.(*)..").namingSlices("Controller $1")

File: archunit-integration-test/src/test/java/com/tngtech/archunit/junit/ExpectedMember.java
Patch:
@@ -1,7 +1,6 @@
 package com.tngtech.archunit.junit;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
@@ -17,6 +16,7 @@
 import com.tngtech.archunit.core.domain.properties.HasParameterTypes;
 
 import static com.tngtech.archunit.core.domain.JavaConstructor.CONSTRUCTOR_NAME;
+import static java.util.Collections.emptyList;
 import static java.util.Collections.singleton;
 
 abstract class ExpectedMember {
@@ -64,7 +64,7 @@ <T extends HasOwner<JavaClass> & HasName> boolean matches(T member) {
     private List<String> getParameters(Object member) {
         return member instanceof HasParameterTypes ?
                 ((HasParameterTypes) member).getParameters().getNames() :
-                Collections.<String>emptyList();
+                emptyList();
     }
 
     static class ExpectedOrigin extends ExpectedMember {

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchTestExecution.java
Patch:
@@ -33,10 +33,10 @@ abstract class ArchTestExecution {
         this.ignore = ignore;
     }
 
-    static <T extends Member> T validatePublicStatic(T member) {
+    static <T extends Member> T validateStatic(T member) {
         ArchUnitTestInitializationException.check(
-                Modifier.isPublic(member.getModifiers()) && Modifier.isStatic(member.getModifiers()),
-                "With @%s annotated members must be public and static", ArchTest.class.getSimpleName());
+                Modifier.isStatic(member.getModifiers()),
+                "With @%s annotated members must be static", ArchTest.class.getSimpleName());
         return member;
     }
 

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchTestMethodExecution.java
Patch:
@@ -30,7 +30,7 @@ class ArchTestMethodExecution extends ArchTestExecution {
 
     ArchTestMethodExecution(Class<?> testClass, Method testMethod, boolean ignore) {
         super(testClass, ignore);
-        this.testMethod = validatePublicStatic(testMethod);
+        this.testMethod = validateStatic(testMethod);
     }
 
     @Override

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchUnitRunner.java
Patch:
@@ -39,7 +39,7 @@
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 import static com.tngtech.archunit.junit.ArchRuleDeclaration.elementShouldBeIgnored;
-import static com.tngtech.archunit.junit.ArchTestExecution.validatePublicStatic;
+import static com.tngtech.archunit.junit.ArchTestExecution.validateStatic;
 import static com.tngtech.archunit.junit.ReflectionUtils.getValue;
 
 /**
@@ -126,7 +126,7 @@ private Set<ArchTestExecution> asTestExecutions(ArchRules archRules, boolean for
     }
 
     private ArchRules getArchRules(Field field) {
-        validatePublicStatic(field);
+        validateStatic(field);
         return getValue(field, null);
     }
 

File: archunit-junit/junit5/src/main/java/com/tngtech/archunit/junit/AnalyzeClasses.java
Patch:
@@ -18,6 +18,7 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
+import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
 import com.tngtech.archunit.core.importer.ImportOption;
@@ -26,6 +27,7 @@
 import com.tngtech.archunit.core.importer.ImportOptions;
 import org.junit.platform.commons.annotation.Testable;
 
+import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
@@ -46,6 +48,7 @@
 @Testable
 @Target(TYPE)
 @Retention(RUNTIME)
+@PublicAPI(usage = ACCESS)
 public @interface AnalyzeClasses {
     /**
      * @return Packages to look for within the classpath / modulepath

File: archunit-junit/junit5/src/main/java/com/tngtech/archunit/junit/ArchUnitTestDescriptor.java
Patch:
@@ -39,7 +39,7 @@
 import static com.tngtech.archunit.junit.ReflectionUtils.withAnnotation;
 import static java.lang.reflect.Modifier.isStatic;
 
-public class ArchUnitTestDescriptor extends AbstractArchUnitTestDescriptor {
+class ArchUnitTestDescriptor extends AbstractArchUnitTestDescriptor {
     private final Class<?> testClass;
     private ClassCache classCache;
 

File: archunit-junit/junit5/src/main/java/com/tngtech/archunit/junit/ArchUnitTestEngine.java
Patch:
@@ -26,7 +26,7 @@
 /**
  * A simple test engine to discover and execute ArchUnit tests with JUnit 5. In particular the engine
  * uses a {@link ClassCache} to avoid the costly import process as much as possible.
- * <br/><br/>
+ * <br><br>
  * Mark classes to be executed by the {@link ArchUnitTestEngine} with {@link AnalyzeClasses @AnalyzeClasses} and
  * rule fields or methods with {@link ArchTest @ArchTest}. Example:
  * <pre><code>
@@ -38,7 +38,7 @@
  * </code></pre>
  */
 @Internal
-public class ArchUnitTestEngine extends HierarchicalTestEngine<ArchUnitEngineExecutionContext> {
+public final class ArchUnitTestEngine extends HierarchicalTestEngine<ArchUnitEngineExecutionContext> {
     private SharedCache cache = new SharedCache(); // NOTE: We want to change this in tests -> no static/final reference
 
     @Override

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ClassCache.java
Patch:
@@ -45,7 +45,7 @@
  * i.e. if two test classes <code>ATest</code> and <code>BTest</code>
  * import the same locations (e.g. packages, URLs, etc.), the imported {@link JavaClasses} from <code>ATest</code> will be
  * reused for <code>BTest</code>. This behavior can be controlled by the supplied {@link CacheMode}.
- * <br/><br/>
+ * <br><br>
  * Important information regarding performance: The cache uses soft references, meaning that a small heap
  * may dramatically reduce performance, if multiple test classes are executed.
  * The cache will hold imported classes as long as there is sufficient memory, and reuse them, if the same

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/CodingRulesMethodsTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.exampletest.junit;
+package com.tngtech.archunit.exampletest.junit4;
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.exampletest.Example;
@@ -14,7 +14,7 @@
 @Category(Example.class)
 @RunWith(ArchUnitRunner.class)
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
-public class CodingRulesWithRunnerMethodsTest {
+public class CodingRulesMethodsTest {
     @ArchTest
     public static void no_java_util_logging_as_method(JavaClasses classes) {
         noClasses().should(USE_JAVA_UTIL_LOGGING).check(classes);

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/CodingRulesTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.exampletest.junit;
+package com.tngtech.archunit.exampletest.junit4;
 
 import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.exampletest.Example;
@@ -18,7 +18,7 @@
 @Category(Example.class)
 @RunWith(ArchUnitRunner.class)
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
-public class CodingRulesWithRunnerTest {
+public class CodingRulesTest {
 
     @ArchTest
     public static final ArchRule NO_ACCESS_TO_STANDARD_STREAMS = NO_CLASSES_SHOULD_ACCESS_STANDARD_STREAMS;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/CyclicDependencyRulesTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.exampletest.junit;
+package com.tngtech.archunit.exampletest.junit4;
 
 import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.core.domain.JavaClass;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/DaoRulesTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.exampletest.junit;
+package com.tngtech.archunit.exampletest.junit4;
 
 import javax.persistence.EntityManager;
 
@@ -15,7 +15,7 @@
 @Category(Example.class)
 @RunWith(ArchUnitRunner.class)
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
-public class DaoRulesWithRunnerTest {
+public class DaoRulesTest {
     @ArchTest
     public static final ArchRule only_DAOs_may_use_the_EntityManager =
             noClasses().that().resideOutsideOfPackage("..dao..")

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/LayerDependencyRulesTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.exampletest.junit;
+package com.tngtech.archunit.exampletest.junit4;
 
 import com.tngtech.archunit.exampletest.Example;
 import com.tngtech.archunit.junit.AnalyzeClasses;
@@ -14,7 +14,7 @@
 @Category(Example.class)
 @RunWith(ArchUnitRunner.class)
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
-public class LayerDependencyRulesWithRunnerTest {
+public class LayerDependencyRulesTest {
 
     @ArchTest
     public static final ArchRule services_should_not_access_controllers =

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/LayeredArchitectureTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.exampletest.junit;
+package com.tngtech.archunit.exampletest.junit4;
 
 import com.tngtech.archunit.example.SomeMediator;
 import com.tngtech.archunit.example.service.ServiceViolatingLayerRules;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/MethodReturnTypeTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.exampletest.junit;
+package com.tngtech.archunit.exampletest.junit4;
 
 import java.util.ArrayList;
 import java.util.List;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/NamingConventionTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.exampletest.junit;
+package com.tngtech.archunit.exampletest.junit4;
 
 import com.tngtech.archunit.example.AbstractController;
 import com.tngtech.archunit.example.MyController;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/RestrictNumberOfClassesWithACertainPropertyTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.exampletest.junit;
+package com.tngtech.archunit.exampletest.junit4;
 
 import com.tngtech.archunit.example.SomeBusinessInterface;
 import com.tngtech.archunit.example.SomeOtherBusinessInterface;

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/RuleLibraryTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.exampletest.junit;
+package com.tngtech.archunit.exampletest.junit4;
 
 import com.tngtech.archunit.exampletest.Example;
 import com.tngtech.archunit.junit.AnalyzeClasses;
@@ -16,7 +16,7 @@ public class RuleLibraryTest {
     public static final ArchRules LIBRARY = ArchRules.in(RuleSetsTest.class);
 
     @ArchTest
-    public static final ArchRules FURTHER_CODING_RULES = ArchRules.in(CodingRulesWithRunnerMethodsTest.class);
+    public static final ArchRules FURTHER_CODING_RULES = ArchRules.in(CodingRulesMethodsTest.class);
 
     @ArchTest
     public static final ArchRules SLICES_ISOLATION_RULES = ArchRules.in(SlicesIsolationTest.class);

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/RuleSetsTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.exampletest.junit;
+package com.tngtech.archunit.exampletest.junit4;
 
 import com.tngtech.archunit.exampletest.Example;
 import com.tngtech.archunit.junit.AnalyzeClasses;
@@ -13,7 +13,7 @@
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
 public class RuleSetsTest {
     @ArchTest
-    public static final ArchRules CODING_RULES = ArchRules.in(CodingRulesWithRunnerTest.class);
+    public static final ArchRules CODING_RULES = ArchRules.in(CodingRulesTest.class);
 
     @ArchTest
     public static final ArchRules CYCLIC_DEPENDENCY_RULES = ArchRules.in(CyclicDependencyRulesTest.class);

File: archunit-example/example-junit4/src/test/java/com/tngtech/archunit/exampletest/junit4/SlicesIsolationTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.exampletest.junit;
+package com.tngtech.archunit.exampletest.junit4;
 
 import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.core.domain.JavaClass;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit4/CyclicDependencyRulesIntegrationTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.integration.junit;
+package com.tngtech.archunit.integration.junit4;
 
 import com.tngtech.archunit.example.cycle.complexcycles.slice1.ClassBeingCalledInSliceOne;
 import com.tngtech.archunit.example.cycle.complexcycles.slice1.ClassOfMinimalCycleCallingSliceTwo;
@@ -36,7 +36,7 @@
 import com.tngtech.archunit.example.cycle.simplescenario.importer.ImportService;
 import com.tngtech.archunit.example.cycle.simplescenario.report.Report;
 import com.tngtech.archunit.example.cycle.simplescenario.report.ReportService;
-import com.tngtech.archunit.exampletest.junit.CyclicDependencyRulesTest;
+import com.tngtech.archunit.exampletest.junit4.CyclicDependencyRulesTest;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitIntegrationTestRunner;
@@ -45,7 +45,7 @@
 import com.tngtech.archunit.lang.ArchRule;
 import org.junit.runner.RunWith;
 
-import static com.tngtech.archunit.integration.junit.CyclicErrorMatcher.cycle;
+import static com.tngtech.archunit.integration.junit4.CyclicErrorMatcher.cycle;
 import static com.tngtech.archunit.junit.ExpectedAccess.callFromConstructor;
 import static com.tngtech.archunit.junit.ExpectedAccess.callFromMethod;
 import static com.tngtech.archunit.junit.ExpectedDependency.constructor;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit4/CyclicErrorMatcher.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.integration.junit;
+package com.tngtech.archunit.integration.junit4;
 
 import java.util.ArrayList;
 import java.util.Collection;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit4/ExpectedViolationFrom.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.integration.junit;
+package com.tngtech.archunit.integration.junit4;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit4/ExtensionIntegrationTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.integration.junit;
+package com.tngtech.archunit.integration.junit4;
 
 import java.util.Map;
 import java.util.Objects;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit4/LayeredArchitectureIntegrationTest.java
Patch:
@@ -1,12 +1,12 @@
-package com.tngtech.archunit.integration.junit;
+package com.tngtech.archunit.integration.junit4;
 
 import com.tngtech.archunit.example.SomeMediator;
 import com.tngtech.archunit.example.controller.one.UseCaseOneTwoController;
 import com.tngtech.archunit.example.controller.two.UseCaseTwoController;
 import com.tngtech.archunit.example.persistence.layerviolation.DaoCallingService;
 import com.tngtech.archunit.example.service.ServiceInterface;
 import com.tngtech.archunit.example.service.ServiceViolatingLayerRules;
-import com.tngtech.archunit.exampletest.junit.LayeredArchitectureTest;
+import com.tngtech.archunit.exampletest.junit4.LayeredArchitectureTest;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitIntegrationTestRunner;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit4/MethodReturnTypeIntegrationTest.java
Patch:
@@ -1,9 +1,9 @@
-package com.tngtech.archunit.integration.junit;
+package com.tngtech.archunit.integration.junit4;
 
 import com.tngtech.archunit.example.anticorruption.WithIllegalReturnType;
 import com.tngtech.archunit.example.anticorruption.WrappedResult;
 import com.tngtech.archunit.example.anticorruption.internal.InternalType;
-import com.tngtech.archunit.exampletest.junit.MethodReturnTypeTest;
+import com.tngtech.archunit.exampletest.junit4.MethodReturnTypeTest;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitIntegrationTestRunner;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit4/NamingConventionIntegrationTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.integration.junit;
+package com.tngtech.archunit.integration.junit4;
 
 import com.tngtech.archunit.example.AbstractController;
 import com.tngtech.archunit.example.MyController;
@@ -9,7 +9,7 @@
 import com.tngtech.archunit.example.service.impl.WronglyNamedSvc;
 import com.tngtech.archunit.example.web.AnnotatedController;
 import com.tngtech.archunit.example.web.InheritedControllerImpl;
-import com.tngtech.archunit.exampletest.junit.NamingConventionTest;
+import com.tngtech.archunit.exampletest.junit4.NamingConventionTest;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitIntegrationTestRunner;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit4/RestrictNumberOfClassesWithACertainPropertyIntegrationTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.integration.junit;
+package com.tngtech.archunit.integration.junit4;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -7,7 +7,7 @@
 import com.tngtech.archunit.example.SecondBeanImplementingSomeBusinessInterface;
 import com.tngtech.archunit.example.SomeBusinessInterface;
 import com.tngtech.archunit.example.SomeOtherBusinessInterface;
-import com.tngtech.archunit.exampletest.junit.RestrictNumberOfClassesWithACertainPropertyTest;
+import com.tngtech.archunit.exampletest.junit4.RestrictNumberOfClassesWithACertainPropertyTest;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitIntegrationTestRunner;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit4/SliceDependencyErrorMatcher.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.integration.junit;
+package com.tngtech.archunit.integration.junit4;
 
 import java.util.ArrayList;
 import java.util.HashSet;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit4/SlicesIsolationIntegrationTest.java
Patch:
@@ -1,10 +1,10 @@
-package com.tngtech.archunit.integration.junit;
+package com.tngtech.archunit.integration.junit4;
 
 import com.tngtech.archunit.example.controller.one.UseCaseOneThreeController;
 import com.tngtech.archunit.example.controller.one.UseCaseOneTwoController;
 import com.tngtech.archunit.example.controller.three.UseCaseThreeController;
 import com.tngtech.archunit.example.controller.two.UseCaseTwoController;
-import com.tngtech.archunit.exampletest.junit.SlicesIsolationTest;
+import com.tngtech.archunit.exampletest.junit4.SlicesIsolationTest;
 import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ArchUnitIntegrationTestRunner;
@@ -16,7 +16,7 @@
 import static com.tngtech.archunit.example.controller.one.UseCaseOneTwoController.doSomethingOne;
 import static com.tngtech.archunit.example.controller.three.UseCaseThreeController.doSomethingThree;
 import static com.tngtech.archunit.example.controller.two.UseCaseTwoController.doSomethingTwo;
-import static com.tngtech.archunit.integration.junit.SliceDependencyErrorMatcher.sliceDependency;
+import static com.tngtech.archunit.integration.junit4.SliceDependencyErrorMatcher.sliceDependency;
 import static com.tngtech.archunit.junit.ExpectedAccess.callFromMethod;
 
 @RunWith(ArchUnitIntegrationTestRunner.class)

File: archunit-integration-test/src/test/java/com/tngtech/archunit/junit/ArchUnitIntegrationTestRunner.java
Patch:
@@ -5,7 +5,7 @@
 import java.lang.reflect.Method;
 
 import com.tngtech.archunit.core.domain.JavaClasses;
-import com.tngtech.archunit.integration.junit.ExpectedViolationFrom;
+import com.tngtech.archunit.integration.junit4.ExpectedViolationFrom;
 import com.tngtech.archunit.lang.EvaluationResult;
 import org.junit.runner.Description;
 import org.junit.runner.notification.Failure;

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/CacheMode.java
Patch:
@@ -23,7 +23,7 @@
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
 /**
- * Determines how the JUnit test support caches classes.<br/>
+ * Determines how the JUnit test support caches classes.<br>
  * The test support can cache imported classes according to their location between several runs
  * of different test classes, i.e. if <code>ATest</code> analyses <code>file:///some/path</code> and
  * <code>BTest</code> analyses the same classes, the classes imported for <code>ATest</code>

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ReflectionUtils.java
Patch:
@@ -85,6 +85,7 @@ static <T> T newInstanceOf(Class<T> type) {
     @SuppressWarnings("unchecked") // callers must know, what they do here, we can't make this compile safe anyway
     static <T> T getValue(Field field, Object owner) {
         try {
+            field.setAccessible(true);
             return (T) field.get(owner);
         } catch (IllegalAccessException e) {
             throw new ReflectionException(e);

File: archunit-junit/junit5/src/test/java/com/tngtech/archunit/junit/EngineExecutionTestListener.java
Patch:
@@ -95,7 +95,7 @@ public String toString() {
         }
     }
 
-    private static <T> Collector<T, Collection<T>, T> onlyElement() {
+    static <T> Collector<T, Collection<T>, T> onlyElement() {
         Supplier<Collection<T>> supplier = ArrayList::new;
         BiConsumer<Collection<T>, T> accumulator = Collection::add;
         BinaryOperator<Collection<T>> combiner = (left, right) -> {

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/AnalyzeClasses.java
Patch:
@@ -47,12 +47,12 @@
 @Retention(RUNTIME)
 public @interface AnalyzeClasses {
     /**
-     * @return Packages to look for in all URLs known to the actual {@link java.net.URLClassLoader}
+     * @return Packages to look for within the classpath / modulepath
      */
     String[] packages() default {};
 
     /**
-     * @return Classes that specify packages to look for in all URLs known to the actual {@link java.net.URLClassLoader}
+     * @return Classes that specify packages to look for within the classpath / modulepath
      */
     Class<?>[] packagesOf() default {};
 

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchRuleExecution.java
Patch:
@@ -23,7 +23,6 @@
 import com.tngtech.archunit.lang.ArchRule;
 import org.junit.runner.Description;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.tngtech.archunit.junit.ReflectionUtils.getValue;
 
 class ArchRuleExecution extends ArchTestExecution {
@@ -35,7 +34,7 @@ class ArchRuleExecution extends ArchTestExecution {
         super(testClass, ignore);
 
         validatePublicStatic(ruleField);
-        checkArgument(ArchRule.class.isAssignableFrom(ruleField.getType()),
+        ArchUnitTestInitializationException.check(ArchRule.class.isAssignableFrom(ruleField.getType()),
                 "Rule field %s.%s to check must be of type %s",
                 testClass.getSimpleName(), ruleField.getName(), ArchRule.class.getSimpleName());
 

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchTestExecution.java
Patch:
@@ -24,8 +24,6 @@
 import org.junit.runner.notification.Failure;
 import org.junit.runner.notification.RunNotifier;
 
-import static com.google.common.base.Preconditions.checkArgument;
-
 abstract class ArchTestExecution {
     final Class<?> testClass;
     private final boolean ignore;
@@ -36,7 +34,8 @@ abstract class ArchTestExecution {
     }
 
     static <T extends Member> T validatePublicStatic(T member) {
-        checkArgument(Modifier.isPublic(member.getModifiers()) && Modifier.isStatic(member.getModifiers()),
+        ArchUnitTestInitializationException.check(
+                Modifier.isPublic(member.getModifiers()) && Modifier.isStatic(member.getModifiers()),
                 "With @%s annotated members must be public and static", ArchTest.class.getSimpleName());
         return member;
     }

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchUnitRunner.java
Patch:
@@ -37,7 +37,6 @@
 import org.junit.runners.model.InitializationError;
 import org.junit.runners.model.Statement;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 import static com.tngtech.archunit.junit.ArchRuleDeclaration.elementShouldBeIgnored;
 import static com.tngtech.archunit.junit.ArchTestExecution.validatePublicStatic;
@@ -73,7 +72,7 @@ public ArchUnitRunner(Class<?> testClass) throws InitializationError {
 
     private static AnalyzeClasses checkAnnotation(Class<?> testClass) {
         AnalyzeClasses analyzeClasses = testClass.getAnnotation(AnalyzeClasses.class);
-        checkArgument(analyzeClasses != null,
+        ArchUnitTestInitializationException.check(analyzeClasses != null,
                 "Class %s must be annotated with @%s",
                 testClass.getSimpleName(), AnalyzeClasses.class.getSimpleName());
         return analyzeClasses;

File: archunit-junit/junit4/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerTest.java
Patch:
@@ -85,7 +85,7 @@ public void runner_clears_cache_after_exception_during_test_run() {
 
     @Test
     public void rejects_missing_analyze_annotation() throws InitializationError {
-        thrown.expect(IllegalArgumentException.class);
+        thrown.expect(ArchUnitTestInitializationException.class);
         thrown.expectMessage(Object.class.getSimpleName());
         thrown.expectMessage("must be annotated");
         thrown.expectMessage(AnalyzeClasses.class.getSimpleName());

File: archunit-junit/junit5/src/test/java/com/tngtech/archunit/junit/testexamples/SimpleRuleField.java
Patch:
@@ -1,13 +1,13 @@
 package com.tngtech.archunit.junit.testexamples;
 
+import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.lang.ArchRule;
 
-import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
-
+@AnalyzeClasses(packages = "some.dummy.package")
 public class SimpleRuleField {
     @ArchTest
-    public static final ArchRule simple_rule = classes().should().bePublic();
+    public static final ArchRule simple_rule = RuleThatFails.on(UnwantedClass.CLASS_VIOLATING_RULES);
 
     public static final String SIMPLE_RULE_FIELD_NAME = "simple_rule";
 }

File: archunit-junit/junit5/src/test/java/com/tngtech/archunit/junit/testexamples/SimpleRuleLibrary.java
Patch:
@@ -1,8 +1,10 @@
 package com.tngtech.archunit.junit.testexamples;
 
+import com.tngtech.archunit.junit.AnalyzeClasses;
 import com.tngtech.archunit.junit.ArchRules;
 import com.tngtech.archunit.junit.ArchTest;
 
+@AnalyzeClasses(packages = "some.dummy.package")
 public class SimpleRuleLibrary {
     @ArchTest
     public static final ArchRules rules_one = ArchRules.in(SimpleRules.class);

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ArchRuleDeclaration.java
Patch:
@@ -18,11 +18,11 @@ abstract class ArchRuleDeclaration<T extends AnnotatedElement> {
 
     abstract void handleWith(Handler handler);
 
-    static ArchRuleDeclaration from(Class<?> testClass, Method method, boolean forceIgnore) {
+    static ArchRuleDeclaration<Method> from(Class<?> testClass, Method method, boolean forceIgnore) {
         return new AsMethod(testClass, method, forceIgnore);
     }
 
-    static ArchRuleDeclaration from(Class<?> testClass, Field field, boolean forceIgnore) {
+    static ArchRuleDeclaration<Field> from(Class<?> testClass, Field field, boolean forceIgnore) {
         return new AsField(testClass, field, forceIgnore);
     }
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/junit/ArchUnitIntegrationTestRunner.java
Patch:
@@ -1,7 +1,6 @@
 package com.tngtech.archunit.junit;
 
 import java.lang.annotation.Annotation;
-import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 
@@ -15,7 +14,6 @@
 import org.junit.runners.model.Statement;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static org.mockito.Mockito.mock;
 
 public class ArchUnitIntegrationTestRunner extends ArchUnitRunner {
     public ArchUnitIntegrationTestRunner(Class<?> testClass) throws InitializationError {
@@ -115,7 +113,7 @@ private static class ClassesCaptor extends ArchTestExecution {
         private JavaClasses classes;
 
         ClassesCaptor() {
-            super(Object.class, mock(AnnotatedElement.class), false);
+            super(Object.class, false);
         }
 
         @Override

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/AnalyzeClasses.java
Patch:
@@ -18,6 +18,7 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
+import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.core.importer.ClassFileImporter;
 import com.tngtech.archunit.core.importer.ImportOption;
 import com.tngtech.archunit.core.importer.ImportOption.DontIncludeJars;
@@ -71,7 +72,8 @@
     Class<? extends ImportOption>[] importOptions() default {};
 
     /**
-     * Controls when the {@link ArchUnitRunner} clears the {@link ClassCache}.
+     * Controls, if the {@link ClassCache} should cache {@link JavaClasses} by location,
+     * to be reused between several test classes, or just within the same class.
      *
      * @return The {@link CacheMode} to use for this test class.
      */

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchRuleExecution.java
Patch:
@@ -30,8 +30,8 @@ class ArchRuleExecution extends ArchTestExecution {
     @VisibleForTesting
     final ArchRule rule;
 
-    ArchRuleExecution(Class<?> testClass, Field ruleField, boolean forceIgnore) {
-        super(testClass, ruleField, forceIgnore);
+    ArchRuleExecution(Class<?> testClass, Field ruleField, boolean ignore) {
+        super(testClass, ignore);
 
         validatePublicStatic(ruleField);
         checkArgument(ArchRule.class.isAssignableFrom(ruleField.getType()),

File: archunit-junit/junit4/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsMethodsTest.java
Patch:
@@ -56,9 +56,10 @@ public class ArchUnitRunnerRunsMethodsTest {
     private JavaClasses cachedClasses = importClassesWithContext(ArchUnitRunnerRunsMethodsTest.class);
 
     @Before
+    @SuppressWarnings("unchecked")
     public void setUp() {
         when(cache.get()).thenReturn(classCache);
-        when(classCache.getClassesToAnalyzeFor(any(Class.class))).thenReturn(cachedClasses);
+        when(classCache.getClassesToAnalyzeFor(any(Class.class), any(ClassAnalysisRequest.class))).thenReturn(cachedClasses);
     }
 
     @Test

File: archunit-junit/junit4/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsRuleFieldsTest.java
Patch:
@@ -65,9 +65,10 @@ public class ArchUnitRunnerRunsRuleFieldsTest {
     private JavaClasses cachedClasses = importClassesWithContext(Object.class);
 
     @Before
+    @SuppressWarnings("unchecked")
     public void setUp() {
         when(cache.get()).thenReturn(classCache);
-        when(classCache.getClassesToAnalyzeFor(any(Class.class))).thenReturn(cachedClasses);
+        when(classCache.getClassesToAnalyzeFor(any(Class.class), any(ClassAnalysisRequest.class))).thenReturn(cachedClasses);
     }
 
     @Test

File: archunit-junit/junit4/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsRuleSetsTest.java
Patch:
@@ -72,9 +72,10 @@ public class ArchUnitRunnerRunsRuleSetsTest {
     private JavaClasses cachedClasses = importClassesWithContext(ArchUnitRunnerRunsRuleSetsTest.class);
 
     @Before
+    @SuppressWarnings("unchecked")
     public void setUp() {
         when(cache.get()).thenReturn(classCache);
-        when(classCache.getClassesToAnalyzeFor(any(Class.class))).thenReturn(cachedClasses);
+        when(classCache.getClassesToAnalyzeFor(any(Class.class), any(ClassAnalysisRequest.class))).thenReturn(cachedClasses);
     }
 
     @Test

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ArchTestMethodExecution.java
Patch:
@@ -48,7 +48,7 @@ private void executeTestMethod(JavaClasses classes) throws Throwable {
                     ArchTest.class.getSimpleName(), JavaClasses.class.getSimpleName()));
         }
 
-        new FrameworkMethod(testMethod).invokeExplosively(testClass.newInstance(), classes);
+        new FrameworkMethod(testMethod).invokeExplosively(testClass.getDeclaredConstructor().newInstance(), classes);
     }
 
     @Override

File: archunit-junit/junit4/src/main/java/com/tngtech/archunit/junit/ClassCache.java
Patch:
@@ -140,8 +140,8 @@ private Set<Location> locationsOf(Set<String> packages) {
 
     private static <T> T newInstanceOf(Class<T> type) {
         try {
-            return type.newInstance();
-        } catch (InstantiationException | IllegalAccessException e) {
+            return type.getDeclaredConstructor().newInstance();
+        } catch (Exception e) {
             throw new ReflectionException(e);
         }
     }

File: archunit-junit/junit4/src/test/java/com/tngtech/archunit/junit/ClassCacheTest.java
Patch:
@@ -244,7 +244,7 @@ public static class TestClassWithIllegalLocationProviderWithPrivateConstructor {
     public static class TestFilterForJUnitJars implements ImportOption {
         @Override
         public boolean includes(Location location) {
-            return location.contains("junit") && location.contains(".jar");
+            return location.contains("/org/junit") && location.isJar();
         }
     }
 

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/LocationProvider.java
Patch:
@@ -23,8 +23,8 @@
 import static com.tngtech.archunit.PublicAPI.Usage.INHERITANCE;
 
 /**
- * Allows to provide a custom implementation that supplies {@link Location Locations}
- * to be imported by the {@link ArchUnitRunner}.
+ * Allows to provide a custom implementation, that supplies {@link Location Locations}
+ * to be imported by the JUnit test infrastructure.
  * <p>
  * The implementation must offer a public default (i.e. no arg) constructor.
  * </p>

File: archunit/src/main/java/com/tngtech/archunit/core/domain/DomainObjectCreationContext.java
Patch:
@@ -29,6 +29,7 @@
 import com.google.common.collect.SetMultimap;
 import com.tngtech.archunit.Internal;
 import com.tngtech.archunit.base.Function;
+import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.importer.DomainBuilders;
 import com.tngtech.archunit.core.importer.DomainBuilders.ConstructorCallTargetBuilder;
 import com.tngtech.archunit.core.importer.DomainBuilders.FieldAccessTargetBuilder;
@@ -126,8 +127,8 @@ public static JavaEnumConstant createJavaEnumConstant(JavaEnumConstantBuilder bu
         return new JavaEnumConstant(builder);
     }
 
-    public static Source createSource(URI uri) {
-        return new Source(uri);
+    public static Source createSource(URI uri, Optional<String> sourceFileName) {
+        return new Source(uri, sourceFileName);
     }
 
     static class AccessContext {

File: archunit-example/src/main/java/com/tngtech/archunit/example/cycle/complexcycles/slice1/ClassOfMinimalCycleCallingSliceTwo.java
Patch:
@@ -1,9 +1,9 @@
 package com.tngtech.archunit.example.cycle.complexcycles.slice1;
 
-import com.tngtech.archunit.example.cycle.complexcycles.slice2.ClassOfMinimalCircleCallingSliceOne;
+import com.tngtech.archunit.example.cycle.complexcycles.slice2.ClassOfMinimalCycleCallingSliceOne;
 
-public class ClassOfMinimalCircleCallingSliceTwo {
-    private ClassOfMinimalCircleCallingSliceOne classInSliceTwo;
+public class ClassOfMinimalCycleCallingSliceTwo {
+    private ClassOfMinimalCycleCallingSliceOne classInSliceTwo;
 
     public void callSliceTwo() {
         classInSliceTwo.callSliceOne();

File: archunit-example/src/main/java/com/tngtech/archunit/example/cycle/complexcycles/slice2/ClassOfMinimalCycleCallingSliceOne.java
Patch:
@@ -1,9 +1,9 @@
 package com.tngtech.archunit.example.cycle.complexcycles.slice2;
 
-import com.tngtech.archunit.example.cycle.complexcycles.slice1.ClassOfMinimalCircleCallingSliceTwo;
+import com.tngtech.archunit.example.cycle.complexcycles.slice1.ClassOfMinimalCycleCallingSliceTwo;
 
-public class ClassOfMinimalCircleCallingSliceOne {
-    private ClassOfMinimalCircleCallingSliceTwo classInSliceOne;
+public class ClassOfMinimalCycleCallingSliceOne {
+    private ClassOfMinimalCycleCallingSliceTwo classInSliceOne;
 
     public void callSliceOne() {
         classInSliceOne.callSliceTwo();

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/SecurityIntegrationTest.java
Patch:
@@ -9,7 +9,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 
-import static com.tngtech.archunit.junit.ExpectedAccess.callFrom;
+import static com.tngtech.archunit.junit.ExpectedAccess.callFromMethod;
 
 public class SecurityIntegrationTest extends SecurityTest {
     @Rule
@@ -37,10 +37,10 @@ public void only_security_infrastructure_should_use_java_security_on_whole_class
     private void expectViolationFromWrongSecurityCheck(String ruleText) {
         expectedViolation.ofRule(ruleText)
 
-                .by(callFrom(WrongSecurityCheck.class, "doCustomNonsense")
+                .by(callFromMethod(WrongSecurityCheck.class, "doCustomNonsense")
                         .toMethod(CertificateFactory.class, "getInstance", String.class)
                         .inLine(19))
-                .by(callFrom(WrongSecurityCheck.class, "doCustomNonsense")
+                .by(callFromMethod(WrongSecurityCheck.class, "doCustomNonsense")
                         .toMethod(CertificateFactory.class, "generateCertificate", InputStream.class)
                         .inLine(19));
     }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/SessionBeanRulesIntegrationTest.java
Patch:
@@ -19,7 +19,7 @@
 import static com.google.common.base.Predicates.containsPattern;
 import static com.google.common.collect.Collections2.filter;
 import static com.tngtech.archunit.example.OtherClassViolatingSessionBeanRules.init;
-import static com.tngtech.archunit.junit.ExpectedAccess.accessFrom;
+import static com.tngtech.archunit.junit.ExpectedAccess.callFromMethod;
 
 public class SessionBeanRulesIntegrationTest extends SessionBeanRulesTest {
     @Rule
@@ -29,10 +29,10 @@ public class SessionBeanRulesIntegrationTest extends SessionBeanRulesTest {
     @Override
     public void stateless_session_beans_should_not_have_state() {
         expectedViolation.ofRule("No Stateless Session Bean should have state")
-                .by(accessFrom(ClassViolatingSessionBeanRules.class, "setState", String.class)
+                .by(callFromMethod(ClassViolatingSessionBeanRules.class, "setState", String.class)
                         .setting().field(ClassViolatingSessionBeanRules.class, "state")
                         .inLine(25))
-                .by(accessFrom(OtherClassViolatingSessionBeanRules.class, init)
+                .by(callFromMethod(OtherClassViolatingSessionBeanRules.class, init)
                         .setting().field(ClassViolatingSessionBeanRules.class, "state")
                         .inLine(13));
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/ThirdPartyRulesIntegrationTest.java
Patch:
@@ -8,7 +8,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 
-import static com.tngtech.archunit.junit.ExpectedAccess.callFrom;
+import static com.tngtech.archunit.junit.ExpectedAccess.callFromMethod;
 
 public class ThirdPartyRulesIntegrationTest extends ThirdPartyRulesTest {
     private static final String RULE_TEXT = "classes should " + THIRD_PARTY_CLASS_RULE_TEXT;
@@ -20,10 +20,10 @@ public class ThirdPartyRulesIntegrationTest extends ThirdPartyRulesTest {
     @Override
     public void third_party_class_should_only_be_instantiated_via_workaround() {
         expectedViolation.ofRule(RULE_TEXT)
-                .by(callFrom(ClassViolatingThirdPartyRules.class, "illegallyInstantiateThirdPartyClass")
+                .by(callFromMethod(ClassViolatingThirdPartyRules.class, "illegallyInstantiateThirdPartyClass")
                         .toConstructor(ThirdPartyClassWithProblem.class)
                         .inLine(9))
-                .by(callFrom(ClassViolatingThirdPartyRules.class, "illegallyInstantiateThirdPartySubClass")
+                .by(callFromMethod(ClassViolatingThirdPartyRules.class, "illegallyInstantiateThirdPartySubClass")
                         .toConstructor(ThirdPartySubClassWithProblem.class)
                         .inLine(17));
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/DaoRulesWithRunnerIntegrationTest.java
Patch:
@@ -13,7 +13,7 @@
 import com.tngtech.archunit.lang.ArchRule;
 import org.junit.runner.RunWith;
 
-import static com.tngtech.archunit.junit.ExpectedAccess.accessFrom;
+import static com.tngtech.archunit.junit.ExpectedAccess.callFromMethod;
 
 @RunWith(ArchUnitIntegrationTestRunner.class)
 @AnalyzeClasses(packages = "com.tngtech.archunit.example")
@@ -29,10 +29,10 @@ public class DaoRulesWithRunnerIntegrationTest {
     @CalledByArchUnitIntegrationTestRunner
     private static void expectViolationByIllegalUseOfEntityManager(ExpectsViolations expectsViolations) {
         expectsViolations.ofRule(ONLY_DAOS_MAY_ACCESS_THE_ENTITYMANAGER_RULE_TEXT)
-                .by(accessFrom(ServiceViolatingDaoRules.class, "illegallyUseEntityManager")
+                .by(callFromMethod(ServiceViolatingDaoRules.class, "illegallyUseEntityManager")
                         .toMethod(EntityManager.class, "persist", Object.class)
                         .inLine(26))
-                .by(accessFrom(ServiceViolatingDaoRules.class, "illegallyUseEntityManager")
+                .by(callFromMethod(ServiceViolatingDaoRules.class, "illegallyUseEntityManager")
                         .toMethod(MyEntityManager.class, "persist", Object.class)
                         .inLine(27));
     }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/junit/ExpectsViolations.java
Patch:
@@ -10,7 +10,7 @@ public interface ExpectsViolations {
 
     ExpectsViolations by(ExpectedCall call);
 
-    ExpectsViolations by(ExpectedDependency inheritance);
+    ExpectsViolations by(ExpectedDependency expectedDependency);
 
     ExpectsViolations by(MessageAssertionChain.Link assertion);
 }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/junit/HandlingAssertion.java
Patch:
@@ -50,8 +50,8 @@ public ExpectsViolations by(ExpectedCall call) {
     }
 
     @Override
-    public ExpectsViolations by(ExpectedDependency inheritance) {
-        expectedDependencies.add(inheritance);
+    public ExpectsViolations by(ExpectedDependency dependency) {
+        expectedDependencies.add(dependency);
         return this;
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaConstructorCall.java
Patch:
@@ -24,7 +24,7 @@ public class JavaConstructorCall extends JavaCall<ConstructorCallTarget> {
     }
 
     @Override
-    protected String descriptionTemplate() {
-        return "Method <%s> calls constructor <%s>";
+    protected String descriptionVerb() {
+        return "calls";
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMember.java
Patch:
@@ -163,6 +163,8 @@ public String toString() {
     @PublicAPI(usage = ACCESS)
     public abstract Member reflect();
 
+    abstract String getDescription();
+
     public static final class Predicates {
         private Predicates() {
         }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMethodCall.java
Patch:
@@ -24,7 +24,7 @@ public class JavaMethodCall extends JavaCall<MethodCallTarget> {
     }
 
     @Override
-    protected String descriptionTemplate() {
-        return "Method <%s> calls method <%s>";
+    protected String descriptionVerb() {
+        return "calls";
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaAccessTest.java
Patch:
@@ -82,8 +82,8 @@ private static class TestJavaAccess extends JavaAccess<MethodCallTarget> {
         }
 
         @Override
-        protected String descriptionTemplate() {
-            return "";
+        protected String descriptionVerb() {
+            return "accesses";
         }
 
         public static class Creator {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/testobjects/AAccessingB.java
Patch:
@@ -1,7 +1,7 @@
 package com.tngtech.archunit.core.domain.testobjects;
 
-public class ADependingOnB extends SuperA implements InterfaceForA {
-    public ADependingOnB() {
+public class AAccessingB {
+    public AAccessingB() {
         B b = new B();
         b.field = "new";
         b.call();

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassGraphCreator.java
Patch:
@@ -128,7 +128,7 @@ private void ensureClassesOfHierarchyInContext() {
 
     private void resolveInheritance(String currentTypeName, Function<JavaClass, Set<String>> inheritanceStrategy) {
         for (String parent : inheritanceStrategy.apply(classes.getOrResolve(currentTypeName))) {
-            resolveInheritance(parent, interfaceStrategy);
+            resolveInheritance(parent, inheritanceStrategy);
         }
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/SubSubClass.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
-public class SubSubClass extends SubClass {
+public class SubSubClass extends SubClass implements SubInterface, YetAnotherInterface {
     private String printMe = "NoOp";
 
     void doSomethingSubSub() {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/ClassesShould.java
Patch:
@@ -848,7 +848,7 @@ public interface ClassesShould {
     ClassesShouldConjunction notBe(String className);
 
     /**
-     * Asserts that number of matched elements conforms supplied predicated.
+     * Asserts that the number of classes checked by this rule conforms to the supplied predicate.
      *
      * @return A syntax element that can either be used as working rule, or to continue specifying a more complex rule
      */

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/ClassesShouldTest.java
Patch:
@@ -1152,12 +1152,12 @@ public static Object[][] containNumberOfElements_rules() {
 
     @Test
     @UseDataProvider("containNumberOfElements_rules")
-    public void haveMatchedFound(DescribedPredicate<Integer> predicate) {
+    public void containNumberOfElements(DescribedPredicate<Integer> predicate) {
         EvaluationResult result = classes().should().containNumberOfElements(predicate).evaluate(importClasses(String.class, Integer.class));
 
         assertThat(singleLineFailureReportOf(result))
-                .contains("contain number of elements")
-                .contains("there is/are 2 element(s) in classes [JavaClass{name='java.lang.String'}, JavaClass{name='java.lang.Integer'}]");
+                .contains("contain number of elements " + predicate.getDescription())
+                .contains("there is/are 2 element(s) in classes [java.lang.Integer, java.lang.String]");
     }
 
     @DataProvider

File: archunit-example/src/main/java/com/tngtech/archunit/example/controller/WronglyAnnotated.java
Patch:
@@ -1,7 +1,9 @@
 package com.tngtech.archunit.example.controller;
 
 import com.tngtech.archunit.example.MyController;
+import com.tngtech.archunit.example.core.HighSecurity;
 
+@HighSecurity
 @MyController
 public class WronglyAnnotated {
 }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/junit/ExpectedLocation.java
Patch:
@@ -14,7 +14,7 @@ private Creator(Class<?> clazz) {
 
         public ExpectedMessage notResidingIn(String packageIdentifier) {
             String expectedMessage = String.format(
-                    "Class %s doesn't reside in a package '%s' in (%s.java:0)",
+                    "class %s doesn't reside in a package '%s' in (%s.java:0)",
                     clazz.getName(), packageIdentifier, clazz.getSimpleName());
             return new ExpectedMessage(expectedMessage);
         }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/junit/ExpectedViolation.java
Patch:
@@ -123,7 +123,7 @@ private PackageAssertionCreator(Class<?> clazz) {
         }
 
         public MessageAssertionChain.Link notMatching(String packageIdentifier) {
-            return containsLine("Class %s doesn't reside in a package '%s' in (%s.java:0)",
+            return containsLine("class %s doesn't reside in a package '%s' in (%s.java:0)",
                     clazz.getName(), packageIdentifier, clazz.getSimpleName());
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ClassesShouldInternal.java
Patch:
@@ -59,10 +59,12 @@ private ClassesShouldInternal(ClassesTransformer<JavaClass> classesTransformer,
         super(classesTransformer, priority, conditionAggregator, prepareCondition);
     }
 
+    @Override
     public ClassesShouldConjunction be(final Class<?> clazz) {
         return copyWithNewCondition(conditionAggregator.add(ArchConditions.be(clazz)));
     }
 
+    @Override
     public ClassesShouldConjunction notBe(final Class<?> clazz) {
         return copyWithNewCondition(conditionAggregator.add(ArchConditions.notBe(clazz)));
     }
@@ -72,6 +74,7 @@ public ClassesShouldConjunction be(String className) {
         return copyWithNewCondition(conditionAggregator.add(ArchConditions.be(className)));
     }
 
+    @Override
     public ClassesShouldConjunction notBe(String className) {
         return copyWithNewCondition(conditionAggregator.add(ArchConditions.notBe(className)));
     }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/ClassesShould.java
Patch:
@@ -827,6 +827,7 @@ public interface ClassesShould {
      * @param className the name of the only class that should be matched.
      * @return A syntax element that can either be used as working rule, or to continue specifying a more complex rule
      */
+    @PublicAPI(usage = ACCESS)
     ClassesShouldConjunction be(String className);
 
     /**
@@ -835,5 +836,6 @@ public interface ClassesShould {
      * @param className the name of the class that should not be matched.
      * @return A syntax element that can either be used as working rule, or to continue specifying a more complex rule
      */
+    @PublicAPI(usage = ACCESS)
     ClassesShouldConjunction notBe(String className);
 }

File: archunit/src/test/java/com/tngtech/archunit/testutil/syntax/RandomSyntaxTestBase.java
Patch:
@@ -318,6 +318,8 @@ Parameter get(String methodName, TypeToken<?> type) {
                         } else if (methodName.toLowerCase().contains("assign")
                                 || methodName.toLowerCase().contains("implement")) {
                             return new Parameter("some.Type", "some.Type");
+                        } else if (methodName.equals("be") || methodName.equals("notBe")) {
+                            return new Parameter("some.Type", "some.Type");
                         } else {
                             return new Parameter("string", "'string'");
                         }

File: archunit/src/test/java/com/tngtech/archunit/lang/syntax/elements/testclasses/SomeClass.java
Patch:
@@ -1,4 +1,4 @@
 package com.tngtech.archunit.lang.syntax.elements.testclasses;
 
-public class RightNamedClass {
+public class SomeClass {
 }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/UrlSource.java
Patch:
@@ -87,7 +87,7 @@ private static Optional<URL> parseClassPathEntry(String path) {
         }
 
         private static Optional<URL> newFileUri(String path) {
-            path = path.endsWith("/") || path.endsWith(".class") ? path : path + "/";
+            path = path.endsWith(File.separator) || path.endsWith(".class") ? path : path + File.separator;
             try {
                 return Optional.of(Paths.get(path).toUri().toURL());
             } catch (MalformedURLException e) {

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ArchUnitRunner.java
Patch:
@@ -44,10 +44,10 @@
  * </p>
  * Example:
  * <pre><code>
- * {@literal @}RunWith(ArchUnitRunner.class)
- * {@literal @}AnalyzeClasses(packages = "com.example")
+ *{@literal @}RunWith(ArchUnitRunner.class)
+ *{@literal @}AnalyzeClasses(packages = "com.example")
  * public class SomeArchTest {
- *     {@literal @}ArchTest
+ *    {@literal @}ArchTest
  *     public static final ArchRule some_rule = //...
  * }
  * </code></pre>

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/LocationProvider.java
Patch:
@@ -23,7 +23,7 @@
 import static com.tngtech.archunit.PublicAPI.Usage.INHERITANCE;
 
 /**
- * Allows to provide a custom implementation, that supplies {@link Location Locations}
+ * Allows to provide a custom implementation that supplies {@link Location Locations}
  * to be imported by the {@link ArchUnitRunner}.
  * <p>
  * The implementation must offer a public default (i.e. no arg) constructor.

File: archunit/src/main/java/com/tngtech/archunit/ArchConfiguration.java
Patch:
@@ -41,7 +41,8 @@
 public final class ArchConfiguration {
     @Internal // {@value ...} doesn't work on non public constants outside of the package
     public static final String ARCHUNIT_PROPERTIES_RESOURCE_NAME = "/archunit.properties";
-    static final String RESOLVE_MISSING_DEPENDENCIES_FROM_CLASS_PATH = "resolveMissingDependenciesFromClassPath";
+    @Internal // {@value ...} doesn't work on non public constants outside of the package
+    public static final String RESOLVE_MISSING_DEPENDENCIES_FROM_CLASS_PATH = "resolveMissingDependenciesFromClassPath";
     static final String CLASS_RESOLVER = "classResolver";
     static final String CLASS_RESOLVER_ARGS = "classResolver.args";
     @Internal

File: archunit/src/main/java/com/tngtech/archunit/PublicAPI.java
Patch:
@@ -20,11 +20,11 @@
 import static com.tngtech.archunit.PublicAPI.State.STABLE;
 
 /**
- * Marks classes and members, that are part of ArchUnit's public API. I.e. users of ArchUnit should ONLY use
+ * Marks classes and members that are part of ArchUnit's public API. I.e. users of ArchUnit should ONLY use
  * those classes and members.<br><br>
  * Furthermore the specified {@link #usage()} defines the way, this public API should be used.<br>
- * {@link Usage#ACCESS} defines, that this class or member should only be accessed (e.g. calling a method)
- * by users of ArchUnit. {@link Usage#INHERITANCE} defines, that this class / interface may be extended / implemented
+ * {@link Usage#ACCESS} defines that this class or member should only be accessed (e.g. calling a method)
+ * by users of ArchUnit. {@link Usage#INHERITANCE} defines that this class / interface may be extended / implemented
  * by users of ArchUnit. Note that this naturally includes permission to access any accessible members
  * of this class / interface.<br><br>
  * Any usage of ArchUnit's classes outside of this contract, is not supported and may break with any (even minor)

File: archunit/src/main/java/com/tngtech/archunit/core/PluginLoader.java
Patch:
@@ -76,7 +76,7 @@ public T get() {
             return fallback;
         }
 
-        @SuppressWarnings("unchecked") // We explicitly check, that the loaded class is assignable to T (i.e. pluginType)
+        @SuppressWarnings("unchecked") // We explicitly check that the loaded class is assignable to T (i.e. pluginType)
         @MayResolveTypesViaReflection(reason = "This only resolves ArchUnit's own classes, it's not dependent on any project classpath")
         private T create(String className) {
             try {

File: archunit/src/main/java/com/tngtech/archunit/core/ResolvesTypesViaReflection.java
Patch:
@@ -22,7 +22,7 @@
 import static java.lang.annotation.RetentionPolicy.CLASS;
 
 /**
- * Marks the methods or classes, that resolve types via reflection so we can use it for architecture
+ * Marks the methods or classes that resolve types via reflection so we can use it for architecture
  * assertions.
  */
 @Retention(CLASS)

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ImportOption.java
Patch:
@@ -25,14 +25,14 @@
 
 /**
  * Will be evaluated for every class location, to determine if the class should be imported.<br><br>
- * <b>IMPORTANT</b>: For things like caching to work, it's important, that the behavior of any implementation
+ * <b>IMPORTANT</b>: For things like caching to work, it's important that the behavior of any implementation
  * is constant, i.e. throughout the whole run of a test suite, for any {@link Location} x, the result of
  * <code>importOption.includes(x)</code> must return the same value on consecutive calls for EVERY instance
  * of the custom implementation of {@link ImportOption}.<br>
  * In other words, if you for example create a custom implementation of {@link ImportOption},
  * where you look at some test specific file, if a certain class should be imported, this will
  * cause wrong caching (i.e. the second run will assume, the classes are already cached, because it can't
- * be determined, that the {@link ImportOption} would choose different classes to be selected for this run)
+ * be determined that the {@link ImportOption} would choose different classes to be selected for this run)
  */
 @PublicAPI(usage = INHERITANCE)
 public interface ImportOption {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/ClassResolverFromClasspath.java
Patch:
@@ -27,7 +27,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 
 /**
- * A {@link ClassResolver}, that tries to locate missing dependencies on the classpath.
+ * A {@link ClassResolver} that tries to locate missing dependencies on the classpath.
  * I.e. uses {@link Class#getResource(String)} to find the {@link URI} of the classfile for the missing
  * type, then uses the supplied {@link ClassResolver.ClassUriImporter} to import the type.
  */

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/SelectedClassResolverFromClasspath.java
Patch:
@@ -26,7 +26,7 @@
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
 /**
- * Only resolves classes from classpath, that are beneath the configured {@link #packageRoots}. E.g. useful,
+ * Only resolves classes from classpath that are beneath the configured {@link #packageRoots}. E.g. useful,
  * if one wants to import com.my.app.foo, but resolve all dependencies to com.my.app, but not to java.util..
  * or similar.
  *

File: archunit/src/main/java/com/tngtech/archunit/lang/ConditionEvent.java
Patch:
@@ -65,7 +65,7 @@ public interface ConditionEvent {
     void handleWith(Handler handler);
 
     /**
-     * Handles the data of a {@link ConditionEvent}, that is the corresponding objects and the description
+     * Handles the data of a {@link ConditionEvent} that is the corresponding objects and the description
      * (compare {@link #handleWith(Handler)}).<br>
      * As an example, this could be a single element of type {@link JavaMethodCall} together with a description, like
      * <p>

File: archunit/src/main/java/com/tngtech/archunit/lang/ConditionEvents.java
Patch:
@@ -71,7 +71,7 @@ public void describeFailuresTo(CollectsLines messages) {
      * Passes violations to the supplied {@link ViolationHandler}. The passed violations will automatically
      * be filtered by the reified type of the given {@link ViolationHandler}. That is, if a
      * <code>ViolationHandler&lt;SomeClass&gt;</code> is passed, only violations by objects assignable to
-     * <code>SomeClass</code> will be reported. The term 'reified' means, that the type parameter
+     * <code>SomeClass</code> will be reported. The term 'reified' means that the type parameter
      * was not erased, i.e. ArchUnit can still determine the actual type parameter of the passed violation handler,
      * otherwise the upper bound, in extreme cases {@link Object}, will be used (i.e. all violations will be passed).
      *

File: archunit/src/main/java/com/tngtech/archunit/library/Architectures.java
Patch:
@@ -81,7 +81,7 @@ private Architectures() {
      * {@link LayeredArchitecture LayeredArchitecture} only supports the white list way, because it prevents detours "outside of
      * the architecture", e.g.<br>
      * 'Persistence' --&gt; 'my.application.somehelper' --&gt; 'Business Logic'<br>
-     * The white list way enforces, that every class that wants to interact with classes inside of
+     * The white list way enforces that every class that wants to interact with classes inside of
      * the layered architecture must be part of the layered architecture itself and thus adhere to the same rules.
      *
      * @return An {@link ArchRule} enforcing the specified layered architecture

File: archunit/src/test/java/com/tngtech/archunit/core/domain/SourceTest.java
Patch:
@@ -142,7 +142,7 @@ public void disables_md5_calculation_via_config() throws Exception {
 
         assertThat(Md5sum.of("any".getBytes())).isEqualTo(Md5sum.DISABLED);
 
-        // NOTE: This tests, that URIs are note resolved, which costs performance, if it would be resolved, we would get UNDETERMINED
+        // NOTE: This tests that URIs are note resolved, which costs performance, if it would be resolved, we would get UNDETERMINED
         assertThat(new Source(new URI("bummer")).getMd5sum()).isEqualTo(Md5sum.DISABLED);
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileImporterTest.java
Patch:
@@ -1616,7 +1616,7 @@ public void imports_urls_of_files() {
     @Test
     public void imports_urls_of_jars() throws IOException {
         Set<URL> urls = newHashSet(urlOf(Test.class), urlOf(RunWith.class));
-        assumeTrue("We can't completely ensure, that this will always be taken from a JAR file, though it's very likely",
+        assumeTrue("We can't completely ensure that this will always be taken from a JAR file, though it's very likely",
                 "jar".equals(urls.iterator().next().getProtocol()));
 
         JavaClasses classes = new ClassFileImporter().importUrls(urls)

File: archunit/src/test/java/com/tngtech/archunit/core/importer/LocationsTest.java
Patch:
@@ -63,7 +63,7 @@ public void locations_of_packages_within_JAR_URIs_that_dont_contain_package_fold
 
         for (ClassFileLocation classFileLocation : source) {
             try (InputStream ignored = classFileLocation.openStream()) {
-                // we only care, that we can open the stream
+                // we only care that we can open the stream
             }
         }
 
@@ -113,7 +113,7 @@ private Iterable<URI> urisOf(Collection<Location> locations) {
         return result;
     }
 
-    private URI resolvedUri(Class<?> base, String part) throws Exception {
+    private URI resolvedUri(Class<?> base, String part) {
         String urlAsString = urlOfClass(base).toExternalForm();
         String baseResourcePart = '/' + base.getName().replace('.', '/');
         String resolved = urlAsString.substring(0, urlAsString.lastIndexOf(baseResourcePart)) + part;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/LocationTest.java
Patch:
@@ -106,7 +106,7 @@ public void iterate_entries_of_package_of_jar_url() throws Exception {
     public void iterate_entries_of_non_existing_jar_url() throws Exception {
         File nonExistingJar = new File(createNonExistingFolder(), "not-there.jar");
 
-        Location location = Location.of(URI.create("jar:file:" + nonExistingJar.getAbsolutePath() + "!/"));
+        Location location = Location.of(URI.create("jar:" + nonExistingJar.toURI() + "!/"));
 
         assertThat(location.iterateEntries())
                 .as("entries of JAR")
@@ -129,7 +129,7 @@ public void iterate_entries_of_file_url() throws Exception {
 
     @Test
     public void iterate_entries_of_non_existing_file_url() throws Exception {
-        Location location = Location.of(URI.create("file:" + createNonExistingFolder().getAbsolutePath()));
+        Location location = Location.of(createNonExistingFolder().toURI());
 
         assertThat(location.iterateEntries())
                 .as("entries of DIR")

File: archunit/src/test/java/com/tngtech/archunit/core/importer/LocationTest.java
Patch:
@@ -106,7 +106,7 @@ public void iterate_entries_of_package_of_jar_url() throws Exception {
     public void iterate_entries_of_non_existing_jar_url() throws Exception {
         File nonExistingJar = new File(createNonExistingFolder(), "not-there.jar");
 
-        Location location = Location.of(URI.create("jar:file:" + nonExistingJar.getAbsolutePath() + "!/"));
+        Location location = Location.of(URI.create("jar:" + nonExistingJar.toURI() + "!/"));
 
         assertThat(location.iterateEntries())
                 .as("entries of JAR")
@@ -129,7 +129,7 @@ public void iterate_entries_of_file_url() throws Exception {
 
     @Test
     public void iterate_entries_of_non_existing_file_url() throws Exception {
-        Location location = Location.of(URI.create("file:" + createNonExistingFolder().getAbsolutePath()));
+        Location location = Location.of(createNonExistingFolder().toURI());
 
         assertThat(location.iterateEntries())
                 .as("entries of DIR")

File: archunit/src/main/java/com/tngtech/archunit/core/importer/UrlSource.java
Patch:
@@ -87,7 +87,7 @@ private static Optional<URL> parseClassPathEntry(String path) {
         }
 
         private static Optional<URL> newFileUri(String path) {
-            path = path.endsWith("/") ? path : path + "/";
+            path = path.endsWith("/") || path.endsWith(".class") ? path : path + "/";
             return newUrl("file", path);
         }
 
@@ -101,7 +101,7 @@ private static Optional<URL> newUrl(String protocol, String path) {
             } catch (MalformedURLException e) {
                 LOG.warn("Cannot parse URL from path " + path, e);
                 return Optional.absent();
-            } catch (IllegalArgumentException e){
+            } catch (IllegalArgumentException e) {
                 LOG.warn("Cannot escape fragments from path " + path, e);
                 return Optional.absent();
             }

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/SecurityTest.java
Patch:
@@ -27,7 +27,7 @@ public void only_security_infrastructure_should_use_java_security() {
     @Test
     public void only_security_infrastructure_should_use_java_security_on_whole_classpath() {
         ArchRule rule = classes().that().resideInAPackage("java.security.cert..")
-                .should().onlyBeAccessed().byAnyPackage("..example.security..", "java..", "..sun..", "javax..");
+                .should().onlyBeAccessed().byAnyPackage("..example.security..", "java..", "..sun..", "javax..", "apple.security..");
 
         JavaClasses classes = new ClassFileImporter().importClasspath(onlyAppAndRuntime());
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/SecurityIntegrationTest.java
Patch:
@@ -29,7 +29,7 @@ public void only_security_infrastructure_should_use_java_security() {
     @Override
     public void only_security_infrastructure_should_use_java_security_on_whole_classpath() {
         expectViolationFromWrongSecurityCheck("classes that reside in a package 'java.security.cert..' "
-                + "should only be accessed by any package ['..example.security..', 'java..', '..sun..', 'javax..']");
+                + "should only be accessed by any package ['..example.security..', 'java..', '..sun..', 'javax..', 'apple.security..']");
 
         super.only_security_infrastructure_should_use_java_security_on_whole_classpath();
     }

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/SecurityTest.java
Patch:
@@ -27,7 +27,7 @@ public void only_security_infrastructure_should_use_java_security() {
     @Test
     public void only_security_infrastructure_should_use_java_security_on_whole_classpath() {
         ArchRule rule = classes().that().resideInAPackage("java.security.cert..")
-                .should().onlyBeAccessed().byAnyPackage("..example.security..", "java..", "..sun..", "javax..");
+                .should().onlyBeAccessed().byAnyPackage("..example.security..", "java..", "..sun..", "javax..", "apple.security..");
 
         JavaClasses classes = new ClassFileImporter().importClasspath(onlyAppAndRuntime());
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/SecurityIntegrationTest.java
Patch:
@@ -29,7 +29,7 @@ public void only_security_infrastructure_should_use_java_security() {
     @Override
     public void only_security_infrastructure_should_use_java_security_on_whole_classpath() {
         expectViolationFromWrongSecurityCheck("classes that reside in a package 'java.security.cert..' "
-                + "should only be accessed by any package ['..example.security..', 'java..', '..sun..', 'javax..']");
+                + "should only be accessed by any package ['..example.security..', 'java..', '..sun..', 'javax..', 'apple.security..']");
 
         super.only_security_infrastructure_should_use_java_security_on_whole_classpath();
     }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/junit/ExpectedLocation.java
Patch:
@@ -14,7 +14,8 @@ private Creator(Class<?> clazz) {
 
         public ExpectedMessage notResidingIn(String packageIdentifier) {
             String expectedMessage = String.format(
-                    "Class %s doesn't reside in a package '%s'", clazz.getName(), packageIdentifier);
+                    "Class %s doesn't reside in a package '%s' in (%s.java:0)",
+                    clazz.getName(), packageIdentifier, clazz.getSimpleName());
             return new ExpectedMessage(expectedMessage);
         }
     }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/junit/ExpectedNaming.java
Patch:
@@ -25,7 +25,8 @@ public ExpectedMessage containing(String infix) {
         }
 
         private ExpectedMessage expectedSimpleName(String suffix) {
-            return new ExpectedMessage(String.format("simple name of %s %s", clazz.getName(), suffix));
+            return new ExpectedMessage(String.format("simple name of %s %s in (%s.java:0)",
+                    clazz.getName(), suffix, clazz.getSimpleName()));
         }
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileImporter.java
Patch:
@@ -155,13 +155,13 @@ public JavaClasses importPackagesOf(Collection<Class<?>> classes) {
     }
 
     /**
-     * Imports classes from the whole classpath without JARs.
+     * Imports classes from the whole classpath without archives (JARs or JRTs).
      *
      * @return Imported classes
      */
     @PublicAPI(usage = ACCESS)
     public JavaClasses importClasspath() {
-        return importClasspath(new ImportOptions().with(ImportOption.Predefined.DONT_INCLUDE_JARS));
+        return importClasspath(new ImportOptions().with(ImportOption.Predefined.DONT_INCLUDE_ARCHIVES));
     }
 
     @PublicAPI(usage = ACCESS)

File: archunit/src/main/java/com/tngtech/archunit/core/InitialConfiguration.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 TNG Technology Consulting GmbH
+ * Copyright 2018 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/PluginLoader.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 TNG Technology Consulting GmbH
+ * Copyright 2018 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/domain/DomainPlugin.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 TNG Technology Consulting GmbH
+ * Copyright 2018 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ImportPlugin.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 TNG Technology Consulting GmbH
+ * Copyright 2018 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/LocationResolver.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 TNG Technology Consulting GmbH
+ * Copyright 2018 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/UrlSource.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 TNG Technology Consulting GmbH
+ * Copyright 2018 TNG Technology Consulting GmbH
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: archunit/src/main/java/com/tngtech/archunit/core/importer/resolvers/ClassResolver.java
Patch:
@@ -167,7 +167,7 @@ private ClassResolverProvider tryCreateResolverProviderForDefaultConstructor(fin
             return new ClassResolverProvider(instantiationException(defaultConstructor, args)) {
                 @Override
                 ClassResolver tryGet() throws Exception {
-                    return (ClassResolver) resolverClass.newInstance();
+                    return (ClassResolver) resolverClass.getConstructor().newInstance();
                 }
             };
         }

File: archunit/src/main/java/com/tngtech/archunit/lang/ConditionEvent.java
Patch:
@@ -34,7 +34,7 @@ public interface ConditionEvent {
     /**
      * Adds the 'opposite' of the event. <br>
      * E.g. <i>The event is a violation, if some conditions A and B are both true?</i>
-     * <br> -> <i>The 'inverted' event is a violation if either A or B (or both) are not true</i><br>
+     * <br> {@literal ->} <i>The 'inverted' event is a violation if either A or B (or both) are not true</i><br>
      * In the most simple case, this is just an equivalent event evaluating {@link #isViolation()}
      * inverted.
      *

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenConjunction.java
Patch:
@@ -39,13 +39,13 @@ public interface GivenConjunction<OBJECTS> {
      * all(objects()).that(predicateA).or(predicateB).and(predicateC)...
      * </code></pre>
      * <p>
-     * will filter on predicate (predicateA || predicateB) && predicateC, and
+     * will filter on predicate <code>(predicateA || predicateB) {@literal &&} predicateC</code>, and
      * <br><br>
      * <pre><code>
      * all(objects()).that(predicateA).and(predicateB).or(predicateC)...
      * </code></pre>
      * <p>
-     * will filter on predicate (predicateA && predicateB) || predicateC. If you need more control over the
+     * will filter on predicate <code>(predicateA {@literal &&} predicateB) || predicateC</code>. If you need more control over the
      * precedence, how predicates are joined, you have to join these predicates separately, i.e.
      * <br><br>
      * <pre><code>

File: archunit/src/main/java/com/tngtech/archunit/core/importer/Location.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.tngtech.archunit.core.importer;
 
+import java.io.File;
 import java.io.IOException;
 import java.net.URI;
 import java.net.URISyntaxException;
@@ -161,7 +162,7 @@ private static URI ensureJarProtocol(URI uri) {
     }
 
     private static URI newFileUri(String fileName) {
-        return URI.create(String.format("%s:%s", FILE_SCHEME, fileName));
+        return new File(fileName).toURI();
     }
 
     private static URI newJarUri(URI uri) {

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/InterfaceRulesTest.java
Patch:
@@ -11,7 +11,7 @@
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;
 
 @Category(Example.class)
-public class InterfaceRules {
+public class InterfaceRulesTest {
 
     @Test
     public void interfaces_should_not_have_names_ending_with_the_word_interface() {

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/InterfaceRulesIntegrationTest.java
Patch:
@@ -2,14 +2,14 @@
 
 import com.tngtech.archunit.example.SomeBusinessInterface;
 import com.tngtech.archunit.example.service.impl.SomeInterfacePlacedInTheWrongPackage;
-import com.tngtech.archunit.exampletest.InterfaceRules;
+import com.tngtech.archunit.exampletest.InterfaceRulesTest;
 import com.tngtech.archunit.junit.ExpectedViolation;
 import org.junit.Rule;
 import org.junit.Test;
 
 import static com.tngtech.archunit.junit.ExpectedViolation.clazz;
 
-public class InterfaceRulesIntegrationTest extends InterfaceRules {
+public class InterfaceRulesIntegrationTest extends InterfaceRulesTest {
     @Rule
     public final ExpectedViolation expectedViolation = ExpectedViolation.none();
 

File: archunit-example/src/main/java/com/tngtech/archunit/example/service/ServiceViolatingDaoRules.java
Patch:
@@ -4,10 +4,12 @@
 import javax.persistence.EntityManager;
 import javax.persistence.PersistenceContext;
 
+import com.tngtech.archunit.example.MyService;
 import com.tngtech.archunit.example.persistence.first.dao.SomeDao;
 import com.tngtech.archunit.example.persistence.second.dao.OtherDao;
 import com.tngtech.archunit.example.persistence.second.dao.domain.OtherPersistentObject;
 
+@MyService
 public class ServiceViolatingDaoRules {
     @EJB
     private SomeDao someDao;

File: archunit-example/src/main/java/com/tngtech/archunit/example/service/ServiceViolatingLayerRules.java
Patch:
@@ -1,8 +1,10 @@
 package com.tngtech.archunit.example.service;
 
+import com.tngtech.archunit.example.MyService;
 import com.tngtech.archunit.example.controller.one.UseCaseOneTwoController;
 import com.tngtech.archunit.example.controller.two.UseCaseTwoController;
 
+@MyService
 public class ServiceViolatingLayerRules {
     public static final String illegalAccessToController = "illegalAccessToController";
     public static final String doSomething = "doSomething";

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/CodingRulesIntegrationTest.java
Patch:
@@ -47,7 +47,7 @@ static void expectViolationByWritingToStandardStream(ExpectsViolations expectsVi
                         .inLine(14))
                 .by(accessFrom(ServiceViolatingLayerRules.class, "illegalAccessToController")
                         .accessing().field(System.class, "out")
-                        .inLine(11));
+                        .inLine(13));
     }
 
     @Test

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/LayerDependencyRulesIntegrationTest.java
Patch:
@@ -39,13 +39,13 @@ static void expectViolationByAccessFromServiceToController(ExpectsViolations exp
                 "should access classes that reside in a package '..controller..'")
                 .by(accessFrom(ServiceViolatingLayerRules.class, illegalAccessToController)
                         .getting().field(UseCaseOneTwoController.class, someString)
-                        .inLine(11))
+                        .inLine(13))
                 .by(callFrom(ServiceViolatingLayerRules.class, illegalAccessToController)
                         .toConstructor(UseCaseTwoController.class)
-                        .inLine(12))
+                        .inLine(14))
                 .by(callFrom(ServiceViolatingLayerRules.class, illegalAccessToController)
                         .toMethod(UseCaseTwoController.class, doSomethingTwo)
-                        .inLine(13));
+                        .inLine(15));
     }
 
     @Test

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/DaoRulesWithRunnerIntegrationTest.java
Patch:
@@ -31,9 +31,9 @@ private static void expectViolationByIllegalUseOfEntityManager(ExpectsViolations
         expectsViolations.ofRule(ONLY_DAOS_MAY_ACCESS_THE_ENTITYMANAGER_RULE_TEXT)
                 .by(accessFrom(ServiceViolatingDaoRules.class, "illegallyUseEntityManager")
                         .toMethod(EntityManager.class, "persist", Object.class)
-                        .inLine(24))
+                        .inLine(26))
                 .by(accessFrom(ServiceViolatingDaoRules.class, "illegallyUseEntityManager")
                         .toMethod(MyEntityManager.class, "persist", Object.class)
-                        .inLine(25));
+                        .inLine(27));
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ImportOption.java
Patch:
@@ -69,8 +69,9 @@ public boolean includes(Location location) {
     final class DontIncludeTests implements ImportOption {
         private static final Pattern MAVEN_PATTERN = Pattern.compile(".*/target/test-classes/.*");
         private static final Pattern GRADLE_PATTERN = Pattern.compile(".*/build/classes/([^/]+/)?test/.*");
+        private static final Pattern INTELLIJ_PATTERN = Pattern.compile(".*/out/test/classes/.*");
 
-        private static final Set<Pattern> EXCLUDED_PATTERN = ImmutableSet.of(MAVEN_PATTERN, GRADLE_PATTERN);
+        private static final Set<Pattern> EXCLUDED_PATTERN = ImmutableSet.of(MAVEN_PATTERN, GRADLE_PATTERN, INTELLIJ_PATTERN);
 
         @Override
         public boolean includes(Location location) {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/Location.java
Patch:
@@ -16,7 +16,6 @@
 package com.tngtech.archunit.core.importer;
 
 import java.io.IOException;
-import java.net.JarURLConnection;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
@@ -178,7 +177,8 @@ private static class JarFileLocation extends Location {
         @Override
         ClassFileSource asClassFileSource(ImportOptions importOptions) {
             try {
-                return new ClassFileSource.FromJar((JarURLConnection) uri.toURL().openConnection(), importOptions);
+                String[] parts = uri.toString().split("!/", 2);
+                return new ClassFileSource.FromJar(new URL(parts[0] + "!/"), parts[1], importOptions);
             } catch (IOException e) {
                 throw new LocationException(e);
             }

File: archunit/src/main/java/com/tngtech/archunit/lang/ConditionEvent.java
Patch:
@@ -20,6 +20,7 @@
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.core.domain.JavaMethodCall;
 
+import static com.tngtech.archunit.PublicAPI.State.EXPERIMENTAL;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 import static com.tngtech.archunit.PublicAPI.Usage.INHERITANCE;
 
@@ -60,6 +61,7 @@ public interface ConditionEvent {
      *
      * @param handler The handler to supply the data of this event to.
      */
+    @PublicAPI(usage = INHERITANCE, state = EXPERIMENTAL)
     void handleWith(Handler handler);
 
     /**
@@ -75,7 +77,7 @@ interface Handler {
          * @param correspondingObjects The objects this event describes (e.g. method calls, field accesses, ...)
          * @param message              Describes the event
          */
-        @PublicAPI(usage = ACCESS)
+        @PublicAPI(usage = ACCESS, state = EXPERIMENTAL)
         void handle(Collection<?> correspondingObjects, String message);
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/ConditionEvents.java
Patch:
@@ -24,6 +24,7 @@
 import com.google.common.reflect.TypeToken;
 import com.tngtech.archunit.PublicAPI;
 
+import static com.tngtech.archunit.PublicAPI.State.EXPERIMENTAL;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
 public final class ConditionEvents implements Iterable<ConditionEvent> {
@@ -77,7 +78,7 @@ public void describeFailuresTo(CollectsLines messages) {
      * @param violationHandler The violation handler that is supposed to handle all violations matching the
      *                         respective type parameter
      */
-    @PublicAPI(usage = ACCESS)
+    @PublicAPI(usage = ACCESS, state = EXPERIMENTAL)
     public void handleViolations(ViolationHandler<?> violationHandler) {
         ConditionEvent.Handler eventHandler = convertToEventHandler(violationHandler);
         for (final ConditionEvent event : eventsByViolation.get(Type.VIOLATION)) {

File: archunit/src/main/java/com/tngtech/archunit/lang/EvaluationResult.java
Patch:
@@ -19,6 +19,7 @@
 import com.tngtech.archunit.base.HasDescription;
 import com.tngtech.archunit.core.domain.JavaClasses;
 
+import static com.tngtech.archunit.PublicAPI.State.EXPERIMENTAL;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
 /**
@@ -68,7 +69,7 @@ public void add(EvaluationResult part) {
     /**
      * @see ConditionEvents#handleViolations(ViolationHandler)
      */
-    @PublicAPI(usage = ACCESS)
+    @PublicAPI(usage = ACCESS, state = EXPERIMENTAL)
     public void handleViolations(ViolationHandler<?> violationHandler) {
         events.handleViolations(violationHandler);
     }

File: archunit/src/main/java/com/tngtech/archunit/lang/ViolationHandler.java
Patch:
@@ -19,9 +19,10 @@
 
 import com.tngtech.archunit.PublicAPI;
 
+import static com.tngtech.archunit.PublicAPI.State.EXPERIMENTAL;
 import static com.tngtech.archunit.PublicAPI.Usage.INHERITANCE;
 
-@PublicAPI(usage = INHERITANCE)
+@PublicAPI(usage = INHERITANCE, state = EXPERIMENTAL)
 public interface ViolationHandler<T> {
     void handle(Collection<T> violatingObjects, String message);
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AllDependenciesOnClassCondition.java
Patch:
@@ -25,7 +25,7 @@
 import com.tngtech.archunit.lang.SimpleConditionEvent;
 
 class AllDependenciesOnClassCondition extends AllAttributesMatchCondition<Dependency> {
-    AllDependenciesOnClassCondition(String description, final DescribedPredicate<Dependency> predicate) {
+    AllDependenciesOnClassCondition(String description, final DescribedPredicate<? super Dependency> predicate) {
         super(description, new ArchCondition<Dependency>(predicate.getDescription()) {
             @Override
             public void check(Dependency item, ConditionEvents events) {

File: archunit/src/main/java/com/tngtech/archunit/lang/extension/ArchUnitExtension.java
Patch:
@@ -21,6 +21,7 @@
 import com.tngtech.archunit.ArchConfiguration;
 import com.tngtech.archunit.PublicAPI;
 
+import static com.tngtech.archunit.PublicAPI.State.EXPERIMENTAL;
 import static com.tngtech.archunit.PublicAPI.Usage.INHERITANCE;
 
 /**
@@ -37,7 +38,7 @@
  * Whenever a rule is evaluated, ArchUnit will dispatch the result to all extensions configured this way,
  * before reacting to the result (e.g. by failing the test, if violations exist).
  */
-@PublicAPI(usage = INHERITANCE)
+@PublicAPI(usage = INHERITANCE, state = EXPERIMENTAL)
 public interface ArchUnitExtension {
     /**
      * An unique String, identifying this extension, so ArchUnit can associate configured properties. The

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ArchRuleDefinition.java
Patch:
@@ -31,7 +31,7 @@
 import static com.tngtech.archunit.lang.Priority.MEDIUM;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.never;
 
-public final class ArchRuleDefinition<T> {
+public final class ArchRuleDefinition {
     private ArchRuleDefinition() {
     }
 

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/syntax/SlicesShould.java
Patch:
@@ -16,14 +16,14 @@
 package com.tngtech.archunit.library.dependencies.syntax;
 
 import com.tngtech.archunit.PublicAPI;
-import com.tngtech.archunit.lang.ArchRule;
+import com.tngtech.archunit.library.dependencies.SliceRule;
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 
 public interface SlicesShould {
     @PublicAPI(usage = ACCESS)
-    ArchRule beFreeOfCycles();
+    SliceRule beFreeOfCycles();
 
     @PublicAPI(usage = ACCESS)
-    ArchRule notDependOnEachOther();
+    SliceRule notDependOnEachOther();
 }

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaTypeTest.java
Patch:
@@ -14,7 +14,7 @@
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
-import static com.tngtech.archunit.core.domain.Assertions.assertThat;
+import static com.tngtech.archunit.testutil.Assertions.assertThat;
 
 @RunWith(DataProviderRunner.class)
 public class JavaTypeTest {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/JavaTypeImporterTest.java
Patch:
@@ -4,7 +4,7 @@
 import org.junit.Test;
 import org.objectweb.asm.Type;
 
-import static com.tngtech.archunit.core.domain.Assertions.assertThat;
+import static com.tngtech.archunit.testutil.Assertions.assertThat;
 
 public class JavaTypeImporterTest {
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ImportOption.java
Patch:
@@ -69,8 +69,9 @@ public boolean includes(Location location) {
     final class DontIncludeTests implements ImportOption {
         private static final Pattern MAVEN_PATTERN = Pattern.compile(".*/target/test-classes/.*");
         private static final Pattern GRADLE_PATTERN = Pattern.compile(".*/build/classes/([^/]+/)?test/.*");
+        private static final Pattern INTELLIJ_PATTERN = Pattern.compile(".*/out/test/classes/.*");
 
-        private static final Set<Pattern> EXCLUDED_PATTERN = ImmutableSet.of(MAVEN_PATTERN, GRADLE_PATTERN);
+        private static final Set<Pattern> EXCLUDED_PATTERN = ImmutableSet.of(MAVEN_PATTERN, GRADLE_PATTERN, INTELLIJ_PATTERN);
 
         @Override
         public boolean includes(Location location) {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ArchRuleDefinition.java
Patch:
@@ -31,7 +31,7 @@
 import static com.tngtech.archunit.lang.Priority.MEDIUM;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.never;
 
-public final class ArchRuleDefinition<T> {
+public final class ArchRuleDefinition {
     private ArchRuleDefinition() {
     }
 

File: archunit-example/src/main/java/com/tngtech/archunit/example/service/ServiceViolatingDaoRules.java
Patch:
@@ -4,10 +4,12 @@
 import javax.persistence.EntityManager;
 import javax.persistence.PersistenceContext;
 
+import com.tngtech.archunit.example.MyService;
 import com.tngtech.archunit.example.persistence.first.dao.SomeDao;
 import com.tngtech.archunit.example.persistence.second.dao.OtherDao;
 import com.tngtech.archunit.example.persistence.second.dao.domain.OtherPersistentObject;
 
+@MyService
 public class ServiceViolatingDaoRules {
     @EJB
     private SomeDao someDao;

File: archunit-example/src/main/java/com/tngtech/archunit/example/service/ServiceViolatingLayerRules.java
Patch:
@@ -1,8 +1,10 @@
 package com.tngtech.archunit.example.service;
 
+import com.tngtech.archunit.example.MyService;
 import com.tngtech.archunit.example.controller.one.UseCaseOneTwoController;
 import com.tngtech.archunit.example.controller.two.UseCaseTwoController;
 
+@MyService
 public class ServiceViolatingLayerRules {
     public static final String illegalAccessToController = "illegalAccessToController";
     public static final String doSomething = "doSomething";

File: archunit-example/src/main/java/com/tngtech/archunit/example/service/impl/ServiceImplementation.java
Patch:
@@ -1,6 +1,8 @@
 package com.tngtech.archunit.example.service.impl;
 
+import com.tngtech.archunit.example.MyService;
 import com.tngtech.archunit.example.service.ServiceInterface;
 
+@MyService
 public class ServiceImplementation implements ServiceInterface {
 }

File: archunit-example/src/main/java/com/tngtech/archunit/example/web/InheritedControllerImpl.java
Patch:
@@ -3,6 +3,4 @@
 import com.tngtech.archunit.example.AbstractController;
 
 public class InheritedControllerImpl extends AbstractController {
-
-
 }

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/InterfaceRules.java
Patch:
@@ -14,7 +14,7 @@
 public class InterfaceRules {
 
     @Test
-    public void interfaces_should_not_have_the_word_interface_in_the_name() {
+    public void interfaces_should_not_have_names_ending_with_the_word_interface() {
         JavaClasses classes = new ClassFileImporter().importClasses(
                 SomeBusinessInterface.class,
                 SomeDao.class
@@ -24,7 +24,7 @@ public void interfaces_should_not_have_the_word_interface_in_the_name() {
     }
 
     @Test
-    public void interfaces_should_not_have_the_word_interface_in_the_name_alternative2() {
+    public void interfaces_should_not_have_simple_class_names_ending_with_the_word_interface() {
         JavaClasses classes = new ClassFileImporter().importClasses(
                 SomeBusinessInterface.class,
                 SomeDao.class

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/CodingRulesIntegrationTest.java
Patch:
@@ -47,7 +47,7 @@ static void expectViolationByWritingToStandardStream(ExpectsViolations expectsVi
                         .inLine(14))
                 .by(accessFrom(ServiceViolatingLayerRules.class, "illegalAccessToController")
                         .accessing().field(System.class, "out")
-                        .inLine(11));
+                        .inLine(13));
     }
 
     @Test

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/LayerDependencyRulesIntegrationTest.java
Patch:
@@ -39,13 +39,13 @@ static void expectViolationByAccessFromServiceToController(ExpectsViolations exp
                 "should access classes that reside in a package '..controller..'")
                 .by(accessFrom(ServiceViolatingLayerRules.class, illegalAccessToController)
                         .getting().field(UseCaseOneTwoController.class, someString)
-                        .inLine(11))
+                        .inLine(13))
                 .by(callFrom(ServiceViolatingLayerRules.class, illegalAccessToController)
                         .toConstructor(UseCaseTwoController.class)
-                        .inLine(12))
+                        .inLine(14))
                 .by(callFrom(ServiceViolatingLayerRules.class, illegalAccessToController)
                         .toMethod(UseCaseTwoController.class, doSomethingTwo)
-                        .inLine(13));
+                        .inLine(15));
     }
 
     @Test

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/DaoRulesWithRunnerIntegrationTest.java
Patch:
@@ -31,9 +31,9 @@ private static void expectViolationByIllegalUseOfEntityManager(ExpectsViolations
         expectsViolations.ofRule(ONLY_DAOS_MAY_ACCESS_THE_ENTITYMANAGER_RULE_TEXT)
                 .by(accessFrom(ServiceViolatingDaoRules.class, "illegallyUseEntityManager")
                         .toMethod(EntityManager.class, "persist", Object.class)
-                        .inLine(24))
+                        .inLine(26))
                 .by(accessFrom(ServiceViolatingDaoRules.class, "illegallyUseEntityManager")
                         .toMethod(MyEntityManager.class, "persist", Object.class)
-                        .inLine(25));
+                        .inLine(27));
     }
 }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/LayeredArchitectureIntegrationTest.java
Patch:
@@ -64,17 +64,17 @@ static void expectLayerViolationsWithException(ExpectsViolations expectsViolatio
 
                 .by(callFrom(ServiceViolatingLayerRules.class, "illegalAccessToController")
                         .toConstructor(UseCaseTwoController.class)
-                        .inLine(12)
+                        .inLine(14)
                         .asDependency())
 
                 .by(callFrom(ServiceViolatingLayerRules.class, "illegalAccessToController")
                         .toMethod(UseCaseTwoController.class, "doSomethingTwo")
-                        .inLine(13)
+                        .inLine(15)
                         .asDependency())
 
                 .by(accessFrom(ServiceViolatingLayerRules.class, "illegalAccessToController")
                         .getting().field(UseCaseOneTwoController.class, "someString")
-                        .inLine(11)
+                        .inLine(13)
                         .asDependency());
     }
 }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/junit/ExpectedViolation.java
Patch:
@@ -143,7 +143,7 @@ public MessageAssertionChain.Link havingNameMatching(String regex) {
             return containsLine("class %s matches '%s'", clazz.getName(), regex);
         }
 
-        public MessageAssertionChain.Link havingNameContaining(String infix) {
+        public MessageAssertionChain.Link havingSimpleNameContaining(String infix) {
             return containsLine("simple name of %s contains '%s'", clazz.getName(), infix);
         }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ArchConditions.java
Patch:
@@ -355,8 +355,8 @@ public static ArchCondition<JavaClass> haveSimpleNameContaining(final String inf
             @Override
             public void check(JavaClass item, ConditionEvents events) {
                 boolean satisfied = predicate.apply(item);
-                String dynInfix = satisfied ? "contains" : "doesn't contain";
-                String message = String.format("simple name of %s %s '%s'", item.getName(), dynInfix, infix);
+                String messageInfix = satisfied ? "contains" : "doesn't contain";
+                String message = String.format("simple name of %s %s '%s'", item.getName(), messageInfix, infix);
                 events.add(new SimpleConditionEvent(item, satisfied, message));
             }
         };

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ClassesShouldThatInternal.java
Patch:
@@ -48,13 +48,13 @@ class ClassesShouldThatInternal implements ClassesShouldThat, ClassesShouldConju
     private final FinishedRule finishedRule = new FinishedRule();
 
     ClassesShouldThatInternal(ClassesShouldInternal classesShould,
-                              Function<DescribedPredicate<JavaClass>, ArchCondition<JavaClass>> createCondition) {
+            Function<DescribedPredicate<JavaClass>, ArchCondition<JavaClass>> createCondition) {
         this(classesShould, new PredicateAggregator<JavaClass>(), createCondition);
     }
 
     private ClassesShouldThatInternal(ClassesShouldInternal classesShould,
-                                      PredicateAggregator<JavaClass> predicateAggregator,
-                                      Function<DescribedPredicate<JavaClass>, ArchCondition<JavaClass>> createCondition) {
+            PredicateAggregator<JavaClass> predicateAggregator,
+            Function<DescribedPredicate<JavaClass>, ArchCondition<JavaClass>> createCondition) {
         this.classesShould = classesShould;
         this.predicateAggregator = predicateAggregator;
         this.createCondition = createCondition;

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ClassesThatPredicates.java
Patch:
@@ -48,7 +48,7 @@ static DescribedPredicate<JavaClass> haveSimpleNameNotContaining(String infix) {
         return have(not(simpleNameContaining(infix)).as("simple name not containing '%s'", infix));
     }
 
-    public static DescribedPredicate<JavaClass> haveSimpleNameNotEndingWith(String suffix) {
+    static DescribedPredicate<JavaClass> haveSimpleNameNotEndingWith(String suffix) {
         return have(not(simpleNameEndingWith(suffix)).as("simple name not ending with '%s'", suffix));
     }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AllDependenciesOnClassCondition.java
Patch:
@@ -25,7 +25,7 @@
 import com.tngtech.archunit.lang.SimpleConditionEvent;
 
 class AllDependenciesOnClassCondition extends AllAttributesMatchCondition<Dependency> {
-    AllDependenciesOnClassCondition(String description, final DescribedPredicate<Dependency> predicate) {
+    AllDependenciesOnClassCondition(String description, final DescribedPredicate<? super Dependency> predicate) {
         super(description, new ArchCondition<Dependency>(predicate.getDescription()) {
             @Override
             public void check(Dependency item, ConditionEvents events) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -54,7 +54,7 @@
 import static com.tngtech.archunit.core.domain.properties.CanBeAnnotated.Utils.toAnnotationOfType;
 import static com.tngtech.archunit.core.domain.properties.HasName.Functions.GET_NAME;
 
-public class JavaClass implements HasName, HasAnnotations, HasModifiers {
+public class JavaClass implements HasName.AndSimpleName, HasAnnotations, HasModifiers {
     private final Optional<Source> source;
     private final JavaType javaType;
     private final boolean isInterface;
@@ -106,7 +106,7 @@ public String getName() {
         return javaType.getName();
     }
 
-    @PublicAPI(usage = ACCESS)
+    @Override
     public String getSimpleName() {
         return javaType.getSimpleName();
     }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/junit/ArchUnitIntegrationTestRunner.java
Patch:
@@ -1,6 +1,7 @@
 package com.tngtech.archunit.junit;
 
 import java.lang.annotation.Annotation;
+import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 
@@ -14,6 +15,7 @@
 import org.junit.runners.model.Statement;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static org.mockito.Mockito.mock;
 
 public class ArchUnitIntegrationTestRunner extends ArchUnitRunner {
     public ArchUnitIntegrationTestRunner(Class<?> testClass) throws InitializationError {
@@ -113,7 +115,7 @@ private static class ClassesCaptor extends ArchTestExecution {
         private JavaClasses classes;
 
         ClassesCaptor() {
-            super(Object.class);
+            super(Object.class, mock(AnnotatedElement.class), false);
         }
 
         @Override

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ArchRuleExecution.java
Patch:
@@ -30,8 +30,8 @@ class ArchRuleExecution extends ArchTestExecution {
     @VisibleForTesting
     final ArchRule rule;
 
-    ArchRuleExecution(Class<?> testClass, Field ruleField) {
-        super(testClass);
+    ArchRuleExecution(Class<?> testClass, Field ruleField, boolean forceIgnore) {
+        super(testClass, ruleField, forceIgnore);
 
         validatePublicStatic(ruleField);
         checkArgument(ArchRule.class.isAssignableFrom(ruleField.getType()),

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ArchTestMethodExecution.java
Patch:
@@ -26,8 +26,8 @@
 class ArchTestMethodExecution extends ArchTestExecution {
     private final Method testMethod;
 
-    ArchTestMethodExecution(Class<?> testClass, Method testMethod) {
-        super(testClass);
+    ArchTestMethodExecution(Class<?> testClass, Method testMethod, boolean forceIgnore) {
+        super(testClass, testMethod, forceIgnore);
         this.testMethod = validatePublicStatic(testMethod);
     }
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/CyclicDependencyRulesIntegrationTest.java
Patch:
@@ -44,7 +44,7 @@
 import static com.tngtech.archunit.core.domain.JavaConstructor.CONSTRUCTOR_NAME;
 import static com.tngtech.archunit.integration.junit.CyclicErrorMatcher.cycle;
 import static com.tngtech.archunit.junit.ExpectedAccess.accessFrom;
-import static com.tngtech.archunit.junit.ExpectedInheritance.inheritanceFrom;
+import static com.tngtech.archunit.junit.ExpectedDependency.inheritanceFrom;
 
 @RunWith(ArchUnitIntegrationTestRunner.class)
 @AnalyzeClasses(packages = "com.tngtech.archunit.example.cycle")

File: archunit-integration-test/src/test/java/com/tngtech/archunit/junit/ExpectsViolations.java
Patch:
@@ -10,5 +10,7 @@ public interface ExpectsViolations {
 
     ExpectsViolations by(ExpectedCall call);
 
+    ExpectsViolations by(ExpectedDependency inheritance);
+
     ExpectsViolations by(MessageAssertionChain.Link assertion);
 }

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ArchUnitRunner.java
Patch:
@@ -55,7 +55,7 @@
  */
 @PublicAPI(usage = ACCESS)
 public class ArchUnitRunner extends ParentRunner<ArchTestExecution> {
-    private SharedCache cache = new SharedCache(); // NOTE: We want to change this in tests -> no static reference
+    private SharedCache cache = new SharedCache(); // NOTE: We want to change this in tests -> no static/final reference
 
     @Internal
     public ArchUnitRunner(Class<?> testClass) throws InitializationError {

File: archunit/src/main/java/com/tngtech/archunit/base/DescribedIterable.java
Patch:
@@ -18,7 +18,6 @@
 import java.util.Iterator;
 
 import com.tngtech.archunit.PublicAPI;
-import com.tngtech.archunit.core.domain.properties.HasDescription;
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 import static com.tngtech.archunit.PublicAPI.Usage.INHERITANCE;

File: archunit/src/main/java/com/tngtech/archunit/base/DescribedPredicate.java
Patch:
@@ -29,7 +29,7 @@
  */
 @PublicAPI(usage = INHERITANCE)
 public abstract class DescribedPredicate<T> {
-    private String description;
+    private final String description;
 
     public abstract boolean apply(T input);
 
@@ -97,7 +97,7 @@ public static <T> DescribedPredicate<T> alwaysTrue() {
         return (DescribedPredicate<T>) ALWAYS_TRUE;
     }
 
-    private static DescribedPredicate<Object> ALWAYS_TRUE = new DescribedPredicate<Object>("always true") {
+    private static final DescribedPredicate<Object> ALWAYS_TRUE = new DescribedPredicate<Object>("always true") {
         @Override
         public boolean apply(Object input) {
             return true;

File: archunit/src/main/java/com/tngtech/archunit/base/HasDescription.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.tngtech.archunit.core.domain.properties;
+package com.tngtech.archunit.base;
 
 import com.tngtech.archunit.PublicAPI;
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Dependency.java
Patch:
@@ -24,7 +24,7 @@
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.ChainableFunction;
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.core.domain.properties.HasDescription;
+import com.tngtech.archunit.base.HasDescription;
 import com.tngtech.archunit.core.domain.properties.HasName;
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaAccess.java
Patch:
@@ -21,7 +21,7 @@
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.ChainableFunction;
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.core.domain.properties.HasDescription;
+import com.tngtech.archunit.base.HasDescription;
 import com.tngtech.archunit.core.domain.properties.HasName;
 import com.tngtech.archunit.core.domain.properties.HasOwner;
 import com.tngtech.archunit.core.domain.properties.HasOwner.Functions.Get;

File: archunit/src/main/java/com/tngtech/archunit/core/importer/DomainBuilders.java
Patch:
@@ -336,7 +336,7 @@ public Set<JavaModifier> getModifiers() {
     @Internal
     public static final class JavaAnnotationBuilder {
         private JavaType type;
-        private Map<String, ValueBuilder> values = new HashMap<>();
+        private final Map<String, ValueBuilder> values = new HashMap<>();
         private ClassesByTypeName importedClasses;
 
         JavaAnnotationBuilder() {

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ImportOption.java
Patch:
@@ -51,7 +51,7 @@ public boolean includes(Location location) {
             }
         },
         DONT_INCLUDE_JARS {
-            private DontIncludeJars dontIncludeJars = new DontIncludeJars();
+            private final DontIncludeJars dontIncludeJars = new DontIncludeJars();
 
             @Override
             public boolean includes(Location location) {

File: archunit/src/main/java/com/tngtech/archunit/lang/AbstractClassesTransformer.java
Patch:
@@ -25,7 +25,7 @@
 
 @PublicAPI(usage = INHERITANCE)
 public abstract class AbstractClassesTransformer<T> implements ClassesTransformer<T> {
-    private String description;
+    private final String description;
 
     protected AbstractClassesTransformer(String description) {
         this.description = description;

File: archunit/src/main/java/com/tngtech/archunit/lang/ArchCondition.java
Patch:
@@ -32,7 +32,7 @@
 
 @PublicAPI(usage = INHERITANCE)
 public abstract class ArchCondition<T> {
-    private String description;
+    private final String description;
 
     public ArchCondition(String description) {
         this.description = checkNotNull(description);

File: archunit/src/main/java/com/tngtech/archunit/lang/CanBeEvaluated.java
Patch:
@@ -16,8 +16,8 @@
 package com.tngtech.archunit.lang;
 
 import com.tngtech.archunit.PublicAPI;
+import com.tngtech.archunit.base.HasDescription;
 import com.tngtech.archunit.core.domain.JavaClasses;
-import com.tngtech.archunit.core.domain.properties.HasDescription;
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 

File: archunit/src/main/java/com/tngtech/archunit/lang/ClassesTransformer.java
Patch:
@@ -18,8 +18,8 @@
 import com.tngtech.archunit.PublicAPI;
 import com.tngtech.archunit.base.DescribedIterable;
 import com.tngtech.archunit.base.DescribedPredicate;
+import com.tngtech.archunit.base.HasDescription;
 import com.tngtech.archunit.core.domain.JavaClasses;
-import com.tngtech.archunit.core.domain.properties.HasDescription;
 
 import static com.tngtech.archunit.PublicAPI.Usage.INHERITANCE;
 

File: archunit/src/main/java/com/tngtech/archunit/lang/ConfiguredMessageFormat.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.Collection;
 
 import com.google.common.base.Joiner;
-import com.tngtech.archunit.core.domain.properties.HasDescription;
+import com.tngtech.archunit.base.HasDescription;
 
 class ConfiguredMessageFormat {
     private static final ConfiguredMessageFormat instance = new ConfiguredMessageFormat();

File: archunit/src/main/java/com/tngtech/archunit/lang/EvaluationResult.java
Patch:
@@ -16,8 +16,8 @@
 package com.tngtech.archunit.lang;
 
 import com.tngtech.archunit.PublicAPI;
+import com.tngtech.archunit.base.HasDescription;
 import com.tngtech.archunit.core.domain.JavaClasses;
-import com.tngtech.archunit.core.domain.properties.HasDescription;
 
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
 

File: archunit/src/main/java/com/tngtech/archunit/lang/FailureReport.java
Patch:
@@ -21,7 +21,7 @@
 
 import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
-import com.tngtech.archunit.core.domain.properties.HasDescription;
+import com.tngtech.archunit.base.HasDescription;
 
 public class FailureReport implements CollectsLines {
     private final Set<String> failureMessages = new TreeSet<>();

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ContainAnyCondition.java
Patch:
@@ -49,8 +49,8 @@ public String toString() {
 
     static class AnyConditionEvent implements ConditionEvent {
         private final Collection<?> correspondingObjects;
-        private Collection<ConditionEvent> violating;
-        private Collection<ConditionEvent> allowed;
+        private final Collection<ConditionEvent> violating;
+        private final Collection<ConditionEvent> allowed;
 
         private AnyConditionEvent(Collection<?> correspondingObjects, ConditionEvents events) {
             this(correspondingObjects, events.getAllowed(), events.getViolating());

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ContainsOnlyCondition.java
Patch:
@@ -49,8 +49,8 @@ public String toString() {
 
     static class OnlyConditionEvent implements ConditionEvent {
         private final Collection<?> correspondingObjects;
-        private Collection<ConditionEvent> allowed;
-        private Collection<ConditionEvent> violating;
+        private final Collection<ConditionEvent> allowed;
+        private final Collection<ConditionEvent> violating;
 
         private OnlyConditionEvent(Collection<?> correspondingObjects, ConditionEvents events) {
             this(correspondingObjects, events.getAllowed(), events.getViolating());

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Edge.java
Patch:
@@ -25,14 +25,14 @@
 class Edge<T, ATTACHMENT> {
     private final T from;
     private final T to;
-    private List<ATTACHMENT> attachments = new ArrayList<>();
+    private final List<ATTACHMENT> attachments = new ArrayList<>();
 
     Edge(T from, T to) {
         this.from = from;
         this.to = to;
     }
 
-    public Edge(T from, T to, Collection<ATTACHMENT> attachments) {
+    Edge(T from, T to, Collection<ATTACHMENT> attachments) {
         this(from, to);
         this.attachments.addAll(attachments);
     }
@@ -45,7 +45,7 @@ T getTo() {
         return to;
     }
 
-    public List<ATTACHMENT> getAttachments() {
+    List<ATTACHMENT> getAttachments() {
         return ImmutableList.copyOf(attachments);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Slice.java
Patch:
@@ -24,10 +24,10 @@
 import com.google.common.collect.ForwardingSet;
 import com.google.common.collect.ImmutableSet;
 import com.tngtech.archunit.PublicAPI;
+import com.tngtech.archunit.base.HasDescription;
 import com.tngtech.archunit.core.domain.Dependency;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.core.domain.properties.CanOverrideDescription;
-import com.tngtech.archunit.core.domain.properties.HasDescription;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.tngtech.archunit.PublicAPI.Usage.ACCESS;
@@ -126,7 +126,7 @@ String format(List<String> matchingGroups) {
 
     static class Builder {
         private final List<String> matchingGroups;
-        private Set<JavaClass> classes = new HashSet<>();
+        private final Set<JavaClass> classes = new HashSet<>();
 
         private Builder(List<String> matchingGroups) {
             this.matchingGroups = matchingGroups;

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Slices.java
Patch:
@@ -279,7 +279,7 @@ private static String slicesMatchingDescription(String packageIdentifier) {
     }
 
     private static class SliceBuilders {
-        Map<List<String>, Slice.Builder> sliceBuilders = new HashMap<>();
+        private final Map<List<String>, Slice.Builder> sliceBuilders = new HashMap<>();
 
         void add(Optional<List<String>> matchingGroups, JavaClass clazz) {
             if (matchingGroups.isPresent()) {

File: archunit/src/test/java/com/tngtech/archunit/lang/EvaluationResultTest.java
Patch:
@@ -6,7 +6,7 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.tngtech.archunit.core.domain.properties.HasDescription;
+import com.tngtech.archunit.base.HasDescription;
 import org.junit.Test;
 
 import static com.google.common.collect.Iterables.getOnlyElement;

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/syntax/GivenSlices.java
Patch:
@@ -22,4 +22,7 @@
 public interface GivenSlices extends GivenNamedSlices {
     @PublicAPI(usage = ACCESS)
     GivenNamedSlices namingSlices(String pattern);
+
+    @Override
+    GivenSlices as(String newDescription);
 }
\ No newline at end of file

File: archunit/src/main/java/com/tngtech/archunit/lang/extension/ArchUnitExtensions.java
Patch:
@@ -50,6 +50,9 @@ private void dispatch(EvaluatedRule evaluatedRule, ArchUnitExtension extension)
         Properties extensionProperties = configuration.getExtensionProperties(extension.getUniqueIdentifier());
         if (isEnabled(extensionProperties)) {
             configureAndDispatch(extension, extensionProperties, evaluatedRule);
+        } else if (LOG.isDebugEnabled()) {
+            LOG.debug("Extension '{}' is disabled, skipping... (to enable this extension, configure extension.{}.{}=true)",
+                    extension.getUniqueIdentifier(), extension.getUniqueIdentifier(), ENABLED_PROPERTY);
         }
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Source.java
Patch:
@@ -35,9 +35,9 @@
  * <b>NOTE</b>: Since the generation of md5 sums has a performance impact, it is disabled by default.<br>
  * To enable it, add
  * <br><br><code>
- * {@value com.tngtech.archunit.ArchConfiguration#ENABLE_MD5_IN_CLASS_SOURCES}=true
+ * {@value ArchConfiguration#ENABLE_MD5_IN_CLASS_SOURCES}=true
  * </code><br><br>
- * to your <code>{@value com.tngtech.archunit.ArchConfiguration#ARCHUNIT_PROPERTIES_RESOURCE_NAME}</code>.
+ * to your <code>{@value ArchConfiguration#ARCHUNIT_PROPERTIES_RESOURCE_NAME}</code>.
  * </p>
  */
 public class Source {

File: archunit/src/test/java/com/tngtech/archunit/lang/extension/examples/DummyTestExtension.java
Patch:
@@ -6,7 +6,7 @@
 import com.tngtech.archunit.lang.extension.EvaluatedRule;
 
 public class DummyTestExtension implements ArchUnitExtension {
-    public static final String UNIQUE_IDENTIFIER = DummyTestExtension.class.getName();
+    public static final String UNIQUE_IDENTIFIER = DummyTestExtension.class.getName().replace(".", "_");
 
     @Override
     public String getUniqueIdentifier() {

File: archunit/src/test/java/com/tngtech/archunit/lang/extension/examples/YetAnotherDummyTestExtension.java
Patch:
@@ -8,7 +8,7 @@
 public class YetAnotherDummyTestExtension implements ArchUnitExtension {
     @Override
     public String getUniqueIdentifier() {
-        return getClass().getName();
+        return getClass().getName().replace(".", "_");
     }
 
     @Override

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/SessionBeanRulesTest.java
Patch:
@@ -96,7 +96,7 @@ private boolean isLocalBeanImplementation(JavaClass bean, JavaClass businessInte
             new ArchCondition<JavaClass>("have an unique implementation") {
                 @Override
                 public void check(JavaClass businessInterface, ConditionEvents events) {
-                    events.add(new SimpleConditionEvent<>(businessInterface,
+                    events.add(new SimpleConditionEvent(businessInterface,
                             businessInterface.getAllSubClasses().size() <= 1,
                             describe(businessInterface)));
                 }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/PublicAPIRules.java
Patch:
@@ -152,7 +152,7 @@ private static ArchCondition<JavaMember> notBePublic() {
             @Override
             public void check(JavaMember item, ConditionEvents events) {
                 boolean satisfied = !item.getModifiers().contains(PUBLIC);
-                events.add(new SimpleConditionEvent<>(item, satisfied,
+                events.add(new SimpleConditionEvent(item, satisfied,
                         String.format("member %s.%s is %spublic in %s",
                                 item.getOwner().getName(),
                                 item.getName(),
@@ -267,7 +267,7 @@ private static ArchCondition<? super JavaClass> beInterfaces() {
             @Override
             public void check(JavaClass item, ConditionEvents events) {
                 boolean satisfied = item.isInterface();
-                events.add(new SimpleConditionEvent<>(item, satisfied,
+                events.add(new SimpleConditionEvent(item, satisfied,
                         String.format("class %s is %sinterface", item.getName(), satisfied ? "" : "no ")));
             }
         };
@@ -279,7 +279,7 @@ private static ArchCondition<JavaClass> bePublicAPIForInheritance() {
             public void check(JavaClass item, ConditionEvents events) {
                 boolean satisfied = item.isAnnotatedWith(publicApiForInheritance()) ||
                         markedAsPublicAPIForInheritance().apply(item);
-                events.add(new SimpleConditionEvent<>(item, satisfied,
+                events.add(new SimpleConditionEvent(item, satisfied,
                         String.format("class %s is %smeant for inheritance", item.getName(), satisfied ? "" : "not ")));
             }
         };

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/AnalyzeClasses.java
Patch:
@@ -41,7 +41,7 @@
     /**
      * @return Classes that specify packages to look for in all URLs known to the actual {@link java.net.URLClassLoader}
      */
-    Class[] packagesOf() default {};
+    Class<?>[] packagesOf() default {};
 
     /**
      * Allows to filter the class import. The supplied types will be instantiated and used to create the

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ClassCache.java
Patch:
@@ -59,9 +59,9 @@ private LocationsKey locationsToImport(Class<?> testClass) {
         return new LocationsKey(analyzeClasses.importOptions(), locations);
     }
 
-    private Set<String> toPackageStrings(Class[] classes) {
+    private Set<String> toPackageStrings(Class<?>[] classes) {
         ImmutableSet.Builder<String> result = ImmutableSet.builder();
-        for (Class clazz : classes) {
+        for (Class<?> clazz : classes) {
             result.add(clazz.getPackage().getName());
         }
         return result.build();

File: archunit/src/main/java/com/tngtech/archunit/base/Optional.java
Patch:
@@ -190,7 +190,7 @@ public boolean equals(Object obj) {
             if (obj == null || getClass() != obj.getClass()) {
                 return false;
             }
-            final Present other = (Present) obj;
+            final Present<?> other = (Present<?>) obj;
             return Objects.equals(this.object, other.object);
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AccessTarget.java
Patch:
@@ -193,7 +193,7 @@ public abstract static class CodeUnitCallTarget extends AccessTarget implements
         private final ImmutableList<JavaClass> parameters;
         private final JavaClass returnType;
 
-        CodeUnitCallTarget(CodeUnitCallTargetBuilder builder) {
+        CodeUnitCallTarget(CodeUnitCallTargetBuilder<?> builder) {
             super(builder.getOwner(), builder.getName(), builder.getFullName());
             this.parameters = ImmutableList.copyOf(builder.getParameters());
             this.returnType = builder.getReturnType();

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaClass.java
Patch:
@@ -840,7 +840,7 @@ AccessContext.Part completeCodeUnitsFrom(ImportContext context) {
     }
 
     @ResolvesTypesViaReflection
-    @MayResolveTypesViaReflection(reason = "Just part of a bigger resolution procecss")
+    @MayResolveTypesViaReflection(reason = "Just part of a bigger resolution process")
     private class ReflectClassSupplier implements Supplier<Class<?>> {
         @Override
         public Class<?> get() {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaCodeUnit.java
Patch:
@@ -102,7 +102,7 @@ AccessContext.Part completeFrom(ImportContext context) {
     }
 
     @ResolvesTypesViaReflection
-    @MayResolveTypesViaReflection(reason = "Just part of a bigger resolution procecss")
+    @MayResolveTypesViaReflection(reason = "Just part of a bigger resolution process")
     static Class<?>[] reflect(JavaClassList parameters) {
         List<Class<?>> result = new ArrayList<>();
         for (JavaClass parameter : parameters) {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaConstructor.java
Patch:
@@ -71,7 +71,7 @@ void registerCallsToConstructor(Collection<JavaConstructorCall> calls) {
     }
 
     @ResolvesTypesViaReflection
-    @MayResolveTypesViaReflection(reason = "Just part of a bigger resolution procecss")
+    @MayResolveTypesViaReflection(reason = "Just part of a bigger resolution process")
     private class ReflectConstructorSupplier implements Supplier<Constructor<?>> {
         @Override
         public Constructor<?> get() {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaField.java
Patch:
@@ -67,7 +67,7 @@ void registerAccessesToField(Supplier<Set<JavaFieldAccess>> accesses) {
     }
 
     @ResolvesTypesViaReflection
-    @MayResolveTypesViaReflection(reason = "Just part of a bigger resolution procecss")
+    @MayResolveTypesViaReflection(reason = "Just part of a bigger resolution process")
     private class ReflectFieldSupplier implements Supplier<Field> {
         @Override
         public Field get() {

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMethod.java
Patch:
@@ -77,7 +77,7 @@ void registerCallsToMethod(Supplier<Set<JavaMethodCall>> calls) {
     }
 
     @ResolvesTypesViaReflection
-    @MayResolveTypesViaReflection(reason = "Just part of a bigger resolution procecss")
+    @MayResolveTypesViaReflection(reason = "Just part of a bigger resolution process")
     private class ReflectMethodSupplier implements Supplier<Method> {
         @Override
         public Method get() {

File: archunit/src/main/java/com/tngtech/archunit/lang/ConditionEvent.java
Patch:
@@ -20,12 +20,12 @@
 import static com.tngtech.archunit.PublicAPI.Usage.INHERITANCE;
 
 @PublicAPI(usage = INHERITANCE)
-public interface ConditionEvent<T> {
+public interface ConditionEvent {
     boolean isViolation();
 
     void addInvertedTo(ConditionEvents events);
 
     void describeTo(CollectsLines messages);
 
-    T getCorrespondingObject();
+    Object getCorrespondingObject();
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AccessTargetCondition.java
Patch:
@@ -31,6 +31,6 @@ class AccessTargetCondition extends ArchCondition<JavaAccess<?>> {
 
     @Override
     public void check(JavaAccess<?> item, ConditionEvents events) {
-        events.add(new SimpleConditionEvent<>(item, callIdentifier.apply(item), item.getDescription()));
+        events.add(new SimpleConditionEvent(item, callIdentifier.apply(item), item.getDescription()));
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AllAttributesMatchCondition.java
Patch:
@@ -32,7 +32,7 @@ abstract class AllAttributesMatchCondition<T> extends ArchCondition<JavaClass> {
     }
 
     @Override
-    public final void check(JavaClass item, ConditionEvents events) {
+    public void check(JavaClass item, ConditionEvents events) {
         containOnlyElementsThat(condition).check(relevantAttributes(item), events);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/CodeUnitCallCondition.java
Patch:
@@ -31,6 +31,6 @@ class CodeUnitCallCondition extends ArchCondition<JavaCall<?>> {
 
     @Override
     public void check(JavaCall<?> item, ConditionEvents events) {
-        events.add(new SimpleConditionEvent<>(item, callIdentifier.apply(item), item.getDescription()));
+        events.add(new SimpleConditionEvent(item, callIdentifier.apply(item), item.getDescription()));
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/FieldAccessCondition.java
Patch:
@@ -50,7 +50,7 @@ class FieldAccessCondition extends ArchCondition<JavaFieldAccess> {
     @Override
     public void check(JavaFieldAccess item, ConditionEvents events) {
         String message = item.getDescriptionWithTemplate(descriptionTemplate);
-        events.add(new SimpleConditionEvent<>(item, fieldAccessIdentifier.apply(item), message));
+        events.add(new SimpleConditionEvent(item, fieldAccessIdentifier.apply(item), message));
     }
 
     static class FieldGetAccessCondition extends FieldAccessCondition {

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/JavaAccessCondition.java
Patch:
@@ -32,7 +32,7 @@ class JavaAccessCondition extends ArchCondition<JavaAccess<?>> {
     @Override
     public void check(JavaAccess<?> item, ConditionEvents events) {
         if (!item.getOriginOwner().equals(item.getTargetOwner())) {
-            events.add(new SimpleConditionEvent<>(item, predicate.apply(item), item.getDescription()));
+            events.add(new SimpleConditionEvent(item, predicate.apply(item), item.getDescription()));
         }
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceCycleArchCondition.java
Patch:
@@ -160,7 +160,7 @@ private ConditionEvent newEvent(Cycle<Slice, Dependency> cycle) {
             Map<String, Edge<Slice, Dependency>> descriptionsToEdges = sortEdgesByDescription(cycle);
             String description = createDescription(descriptionsToEdges);
             String details = createDetails(descriptionsToEdges);
-            return new SimpleConditionEvent<>(cycle,
+            return new SimpleConditionEvent(cycle,
                     false,
                     String.format(MESSAGE_TEMPLATE, description, details));
         }

File: archunit/src/test/java/com/tngtech/archunit/lang/ArchConditionTest.java
Patch:
@@ -183,7 +183,7 @@ private ArchCondition<Integer> endsWith(final int number) {
             @Override
             public void check(final Integer item, ConditionEvents events) {
                 boolean matches = item.toString().endsWith(Integer.toString(number));
-                events.add(new SimpleConditionEvent<>(item, matches,
+                events.add(new SimpleConditionEvent(item, matches,
                         item + (matches ? " ends with " : " does not end with ") + number));
             }
         };
@@ -193,7 +193,7 @@ public static ConditionWithInit someCondition(String description) {
         return new ConditionWithInit(description);
     }
 
-    private static class GreaterThanEvent extends SimpleConditionEvent<Integer> {
+    private static class GreaterThanEvent extends SimpleConditionEvent {
         GreaterThanEvent(int item, int number) {
             super(item, item > number,
                     String.format(

File: archunit/src/test/java/com/tngtech/archunit/lang/ArchRuleTest.java
Patch:
@@ -174,7 +174,7 @@ public void check(JavaClass item, ConditionEvents events) {
             new ArchCondition<JavaClass>("always be violated") {
                 @Override
                 public void check(JavaClass item, ConditionEvents events) {
-                    events.add(new SimpleConditionEvent<>(item, false, "I'm violated"));
+                    events.add(new SimpleConditionEvent(item, false, "I'm violated"));
                 }
             };
 }
\ No newline at end of file

File: archunit/src/test/java/com/tngtech/archunit/lang/EvaluationResultTest.java
Patch:
@@ -24,7 +24,7 @@ public void properties_are_passed_to_FailureReport() {
     private ConditionEvents events(String... messages) {
         ConditionEvents result = new ConditionEvents();
         for (String message : messages) {
-            result.add(new SimpleConditionEvent<>(new Object(), false, message));
+            result.add(new SimpleConditionEvent(new Object(), false, message));
         }
         return result;
     }

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/ContainAnyConditionTest.java
Patch:
@@ -18,7 +18,7 @@
 import static java.util.Collections.emptyList;
 
 public class ContainAnyConditionTest {
-    static final List<Object> TWO_NONSERIALIZABLE_OBJECTS = asList(new Object(), new Object());
+    private static final List<Object> TWO_NONSERIALIZABLE_OBJECTS = asList(new Object(), new Object());
 
     @Test
     public void satisfied_works_and_description_contains_mismatches() {

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/ContainsOnlyConditionTest.java
Patch:
@@ -22,7 +22,7 @@ public class ContainsOnlyConditionTest {
         @Override
         public void check(Object item, ConditionEvents events) {
             boolean satisfied = item instanceof Serializable;
-            events.add(new SimpleConditionEvent<>(item, satisfied, isSerializableMessageFor(item.getClass())));
+            events.add(new SimpleConditionEvent(item, satisfied, isSerializableMessageFor(item.getClass())));
         }
     };
 

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/NeverConditionTest.java
Patch:
@@ -19,8 +19,8 @@ public class NeverConditionTest {
     private static final ArchCondition<Object> ONE_VIOLATED_ONE_SATISFIED = new ArchCondition<Object>("irrelevant") {
         @Override
         public void check(Object item, ConditionEvents events) {
-            events.add(new SimpleConditionEvent<>(item, false, ORIGINALLY_MISMATCH));
-            events.add(new SimpleConditionEvent<>(item, true, ORIGINALLY_NO_MISMATCH));
+            events.add(new SimpleConditionEvent(item, false, ORIGINALLY_MISMATCH));
+            events.add(new SimpleConditionEvent(item, true, ORIGINALLY_NO_MISMATCH));
         }
     };
 

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/SimpleEdge.java
Patch:
@@ -9,11 +9,11 @@ class SimpleEdge extends Edge<String, String> {
         super(from, to);
     }
 
-    public static List<Edge<String, String>> singleEdgeList(String from, String to) {
+    static List<Edge<String, String>> singleEdgeList(String from, String to) {
         return Collections.<Edge<String, String>>singletonList(new SimpleEdge(from, to));
     }
 
-    public static Set<Edge<String, String>> singleEdge(String from, String to) {
+    static Set<Edge<String, String>> singleEdge(String from, String to) {
         return Collections.<Edge<String, String>>singleton(new SimpleEdge(from, to));
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ImportOption.java
Patch:
@@ -67,7 +67,7 @@ public boolean includes(Location location) {
      */
     final class DontIncludeTests implements ImportOption {
         private static final String MAVEN_INFIX = "/target/test-classes/";
-        private static final String GRADLE_INFIX = "/build/classes/test/";
+        private static final String GRADLE_INFIX = "/build/classes/java/test/";
 
         private static final Set<String> EXCLUDED_INFIXES = ImmutableSet.of(MAVEN_INFIX, GRADLE_INFIX);
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/DontIncludeTestsTest.java
Patch:
@@ -37,11 +37,11 @@ public void excludes_test_class() {
     @DataProvider
     public static Object[][] folders() {
         return $$(
-                $(new String[]{"build", "classes", "test"}, false),
+                $(new String[]{"build", "classes", "java", "test"}, false),
                 $(new String[]{"target", "classes", "test"}, true),
                 $(new String[]{"target", "test-classes"}, false),
                 $(new String[]{"build", "test-classes"}, true),
-                $(new String[]{"build", "classes", "main"}, true),
+                $(new String[]{"build", "classes", "java", "main"}, true),
                 $(new String[]{"target", "classes"}, true)
         );
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Source.java
Patch:
@@ -35,9 +35,9 @@
  * <b>NOTE</b>: Since the generation of md5 sums has a performance impact, it is disabled by default.<br>
  * To enable it, add
  * <br><br><code>
- * {@value ArchConfiguration#ENABLE_MD5_IN_CLASS_SOURCES}=true
+ * {@value com.tngtech.archunit.ArchConfiguration#ENABLE_MD5_IN_CLASS_SOURCES}=true
  * </code><br><br>
- * to your <code>{@value ArchConfiguration#ARCHUNIT_PROPERTIES_RESOURCE_NAME}</code>.
+ * to your <code>{@value com.tngtech.archunit.ArchConfiguration#ARCHUNIT_PROPERTIES_RESOURCE_NAME}</code>.
  * </p>
  */
 public class Source {

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ClassCache.java
Patch:
@@ -1,5 +1,6 @@
 package com.tngtech.archunit.junit;
 
+import java.util.Collection;
 import java.util.HashSet;
 import java.util.Objects;
 import java.util.Set;
@@ -111,7 +112,7 @@ private synchronized void initialize() {
 
     // Used for testing -> that's also the reason it's declared top level
     static class CacheClassFileImporter {
-        JavaClasses importClasses(ImportOption importOption, Set<Location> locations) {
+        JavaClasses importClasses(ImportOption importOption, Collection<Location> locations) {
             return new ClassFileImporter().withImportOption(importOption).importLocations(locations);
         }
     }

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ClassCacheTest.java
Patch:
@@ -16,7 +16,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anySet;
+import static org.mockito.Matchers.anyCollection;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
@@ -127,7 +127,7 @@ public void distinguishes_import_option_when_caching() {
     }
 
     private void verifyNumberOfImports(int number) {
-        verify(cacheClassFileImporter, times(number)).importClasses(any(ImportOption.class), anySet());
+        verify(cacheClassFileImporter, times(number)).importClasses(any(ImportOption.class), anyCollection());
         verifyNoMoreInteractions(cacheClassFileImporter);
     }
 

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/ClassFileImportHelper.java
Patch:
@@ -4,8 +4,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import com.tngtech.archunit.core.ClassFileImporter;
-import com.tngtech.archunit.core.JavaClasses;
+import com.tngtech.archunit.core.domain.JavaClasses;
+import com.tngtech.archunit.core.importer.ClassFileImporter;
 
 class ClassFileImportHelper {
     private final ClassFileImporter importer = new ClassFileImporter();

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/CodingRulesTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.exampletest;
 
-import com.tngtech.archunit.core.JavaClasses;
+import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.example.ClassViolatingCodingRules;
 import org.junit.Before;
 import org.junit.Ignore;

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/DaoRulesTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import javax.persistence.Entity;
 
-import com.tngtech.archunit.core.JavaClasses;
+import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.example.persistence.first.InWrongPackageDao;
 import com.tngtech.archunit.example.persistence.second.dao.OtherDao;
 import com.tngtech.archunit.example.service.ServiceViolatingDaoRules;

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/LayerDependencyRulesTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.exampletest;
 
-import com.tngtech.archunit.core.JavaClasses;
+import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.example.ClassViolatingCodingRules;
 import org.junit.Before;
 import org.junit.Ignore;

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/junit/CodingRulesWithRunnerMethodsTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.exampletest.junit;
 
-import com.tngtech.archunit.core.JavaClasses;
+import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.AnalyseClasses;
 import com.tngtech.archunit.junit.ArchIgnore;
 import com.tngtech.archunit.junit.ArchTest;

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/junit/CodingRulesWithRunnerTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.exampletest.junit;
 
-import com.tngtech.archunit.core.JavaClasses;
+import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.AnalyseClasses;
 import com.tngtech.archunit.junit.ArchIgnore;
 import com.tngtech.archunit.junit.ArchTest;

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/junit/SlicesIsolationTest.java
Patch:
@@ -7,14 +7,14 @@
 import com.tngtech.archunit.lang.ArchRule;
 import org.junit.runner.RunWith;
 
-import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.allSlices;
+import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
 
 @RunWith(ArchUnitRunner.class)
 @AnalyseClasses(packages = "com.tngtech.archunit.example")
 public class SlicesIsolationTest {
     @ArchIgnore
     @ArchTest
     public static final ArchRule controllers_should_only_use_their_own_slice =
-            allSlices().matching("..controller.(*)..").namingSlices("Controller $1")
+            slices().matching("..controller.(*)..").namingSlices("Controller $1")
                     .as("Controllers").shouldNotDependOnEachOther();
 }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/CodingRulesWithRunnerIntegrationTest.java
Patch:
@@ -3,6 +3,7 @@
 import com.tngtech.archunit.integration.CodingRulesIntegrationTest;
 import com.tngtech.archunit.junit.AnalyseClasses;
 import com.tngtech.archunit.junit.ArchTest;
+import com.tngtech.archunit.junit.ArchUnitIntegrationTestRunner;
 import com.tngtech.archunit.lang.ArchRule;
 import org.junit.runner.RunWith;
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/CodingRulesWithRunnerMethodsIntegrationTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.integration.junit;
 
-import com.tngtech.archunit.core.JavaClasses;
+import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.exampletest.junit.CodingRulesWithRunnerMethodsTest;
 import com.tngtech.archunit.junit.AnalyseClasses;
 import com.tngtech.archunit.junit.ArchTest;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/CyclicDependencyRulesIntegrationTest.java
Patch:
@@ -32,11 +32,12 @@
 import com.tngtech.archunit.exampletest.junit.CyclicDependencyRulesTest;
 import com.tngtech.archunit.junit.AnalyseClasses;
 import com.tngtech.archunit.junit.ArchTest;
+import com.tngtech.archunit.junit.ArchUnitIntegrationTestRunner;
 import com.tngtech.archunit.junit.ExpectedViolation;
 import com.tngtech.archunit.lang.ArchRule;
 import org.junit.runner.RunWith;
 
-import static com.tngtech.archunit.core.JavaConstructor.CONSTRUCTOR_NAME;
+import static com.tngtech.archunit.core.domain.JavaConstructor.CONSTRUCTOR_NAME;
 import static com.tngtech.archunit.integration.junit.CyclicErrorMatcher.cycle;
 import static com.tngtech.archunit.junit.ExpectedViolation.from;
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/DaoRulesWithRunnerIntegrationTest.java
Patch:
@@ -7,6 +7,7 @@
 import com.tngtech.archunit.exampletest.junit.DaoRulesWithRunnerTest;
 import com.tngtech.archunit.junit.AnalyseClasses;
 import com.tngtech.archunit.junit.ArchTest;
+import com.tngtech.archunit.junit.ArchUnitIntegrationTestRunner;
 import com.tngtech.archunit.junit.ExpectedViolation;
 import com.tngtech.archunit.lang.ArchRule;
 import org.junit.runner.RunWith;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/ExpectedViolationFrom.java
Patch:
@@ -11,7 +11,7 @@
  */
 @Retention(RUNTIME)
 @Target(FIELD)
-@interface ExpectedViolationFrom {
+public @interface ExpectedViolationFrom {
     Class<?> location();
 
     String method();

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/LayerDependencyRulesWithRunnerIntegrationTest.java
Patch:
@@ -4,6 +4,7 @@
 import com.tngtech.archunit.integration.LayerDependencyRulesIntegrationTest;
 import com.tngtech.archunit.junit.AnalyseClasses;
 import com.tngtech.archunit.junit.ArchTest;
+import com.tngtech.archunit.junit.ArchUnitIntegrationTestRunner;
 import com.tngtech.archunit.lang.ArchRule;
 import org.junit.runner.RunWith;
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/LayeredArchitectureIntegrationTest.java
Patch:
@@ -8,6 +8,7 @@
 import com.tngtech.archunit.exampletest.junit.LayeredArchitectureTest;
 import com.tngtech.archunit.junit.AnalyseClasses;
 import com.tngtech.archunit.junit.ArchTest;
+import com.tngtech.archunit.junit.ArchUnitIntegrationTestRunner;
 import com.tngtech.archunit.junit.ExpectedViolation;
 import com.tngtech.archunit.lang.ArchRule;
 import org.junit.runner.RunWith;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/SlicesIsolationIntegrationTest.java
Patch:
@@ -5,6 +5,7 @@
 import com.tngtech.archunit.exampletest.junit.SlicesIsolationTest;
 import com.tngtech.archunit.junit.AnalyseClasses;
 import com.tngtech.archunit.junit.ArchTest;
+import com.tngtech.archunit.junit.ArchUnitIntegrationTestRunner;
 import com.tngtech.archunit.junit.ExpectedViolation;
 import com.tngtech.archunit.lang.ArchRule;
 import org.junit.runner.RunWith;

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/AnalyseClasses.java
Patch:
@@ -3,7 +3,7 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import com.tngtech.archunit.core.ImportOption;
+import com.tngtech.archunit.core.importer.ImportOption;
 
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ReflectionUtils.java
Patch:
@@ -66,8 +66,7 @@ void collectFrom(Class<?> type) {
         protected abstract Collection<? extends T> extractFrom(Class<?> type);
     }
 
-    // NOTE: Don't use Guava classes in public API
-    public interface Predicate<T> {
+    interface Predicate<T> {
         boolean apply(T input);
     }
 

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsMethodsTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.junit;
 
-import com.tngtech.archunit.core.JavaClasses;
+import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.ArchUnitRunner.SharedCache;
 import org.junit.Before;
 import org.junit.Rule;
@@ -16,7 +16,7 @@
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
-import static com.tngtech.archunit.core.TestUtils.javaClassesViaReflection;
+import static com.tngtech.archunit.core.domain.TestUtils.javaClassesViaReflection;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsMethodsTest.ArchTestWithIgnoredMethod.toBeIgnored;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsMethodsTest.ArchTestWithIllegalTestMethods.noParams;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsMethodsTest.ArchTestWithIllegalTestMethods.tooManyParams;

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsRuleFieldsTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.junit;
 
-import com.tngtech.archunit.core.JavaClasses;
+import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.junit.ArchUnitRunner.SharedCache;
 import com.tngtech.archunit.lang.ArchRule;
 import org.junit.Before;
@@ -18,7 +18,7 @@
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
-import static com.tngtech.archunit.core.TestUtils.javaClassesViaReflection;
+import static com.tngtech.archunit.core.domain.TestUtils.javaClassesViaReflection;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleFieldsTest.IgnoredArchTest.RULE_ONE_IN_IGNORED_TEST;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleFieldsTest.IgnoredArchTest.RULE_TWO_IN_IGNORED_TEST;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleFieldsTest.SomeArchTest.FAILING_FIELD_NAME;

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerTestUtils.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.junit;
 
-import com.tngtech.archunit.core.JavaClass;
+import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ConditionEvents;
 import com.tngtech.archunit.lang.SimpleConditionEvent;

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ClassCacheConcurrencyTest.java
Patch:
@@ -8,7 +8,7 @@
 import java.util.concurrent.Future;
 
 import com.tngtech.archunit.Slow;
-import com.tngtech.archunit.core.ClassFileImporter;
+import com.tngtech.archunit.core.importer.ClassFileImporter;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;

File: archunit/src/main/java/com/tngtech/archunit/core/MayResolveTypesViaReflection.java
Patch:
@@ -2,6 +2,8 @@
 
 import java.lang.annotation.Retention;
 
+import com.tngtech.archunit.Internal;
+
 import static java.lang.annotation.RetentionPolicy.CLASS;
 
 /**
@@ -11,6 +13,7 @@
  * the predefined conditions and predicates.
  */
 @Retention(CLASS)
+@Internal
 public @interface MayResolveTypesViaReflection {
     String reason();
 }

File: archunit/src/main/java/com/tngtech/archunit/core/ResolvesTypesViaReflection.java
Patch:
@@ -2,12 +2,15 @@
 
 import java.lang.annotation.Retention;
 
+import com.tngtech.archunit.Internal;
+
 import static java.lang.annotation.RetentionPolicy.CLASS;
 
 /**
  * Marks the methods or classes, that resolve types via reflection so we can use it for architecture
  * assertions.
  */
 @Retention(CLASS)
+@Internal
 public @interface ResolvesTypesViaReflection {
 }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/AnnotationProxy.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.core.domain;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
@@ -17,6 +17,7 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.tngtech.archunit.base.Optional;
+import com.tngtech.archunit.core.MayResolveTypesViaReflection;
 
 import static com.google.common.base.Preconditions.checkArgument;
 

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileLocation.java
Patch:
@@ -1,9 +1,9 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.core.importer;
 
 import java.io.InputStream;
 import java.net.URI;
 
-public interface ClassFileLocation {
+interface ClassFileLocation {
     InputStream openStream();
 
     URI getUri();

File: archunit/src/main/java/com/tngtech/archunit/lang/ArchCondition.java
Patch:
@@ -9,9 +9,12 @@
 import com.google.common.base.Joiner;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableList;
+import com.tngtech.archunit.PublicAPI;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.tngtech.archunit.PublicAPI.Usage.INHERITANCE;
 
+@PublicAPI(usage = INHERITANCE)
 public abstract class ArchCondition<T> {
     private String description;
 

File: archunit/src/main/java/com/tngtech/archunit/lang/ConfiguredMessageFormat.java
Patch:
@@ -3,7 +3,7 @@
 import java.util.Collection;
 
 import com.google.common.base.Joiner;
-import com.tngtech.archunit.core.properties.HasDescription;
+import com.tngtech.archunit.core.domain.properties.HasDescription;
 
 class ConfiguredMessageFormat {
     private static final ConfiguredMessageFormat instance = new ConfiguredMessageFormat();

File: archunit/src/main/java/com/tngtech/archunit/lang/FailureReport.java
Patch:
@@ -6,7 +6,7 @@
 
 import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
-import com.tngtech.archunit.core.properties.HasDescription;
+import com.tngtech.archunit.core.domain.properties.HasDescription;
 
 public class FailureReport implements CollectsLines {
     private final Set<String> failureMessages = new TreeSet<>();

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AccessTargetCondition.java
Patch:
@@ -1,7 +1,7 @@
 package com.tngtech.archunit.lang.conditions;
 
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.core.JavaAccess;
+import com.tngtech.archunit.core.domain.JavaAccess;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ConditionEvents;
 import com.tngtech.archunit.lang.SimpleConditionEvent;

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AllAccessesToClassCondition.java
Patch:
@@ -4,8 +4,8 @@
 
 import com.google.common.base.Joiner;
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.core.JavaAccess;
-import com.tngtech.archunit.core.JavaClass;
+import com.tngtech.archunit.core.domain.JavaAccess;
+import com.tngtech.archunit.core.domain.JavaClass;
 
 class AllAccessesToClassCondition extends AllAttributesMatchCondition<JavaAccess<?>> {
     AllAccessesToClassCondition(String prefix, DescribedPredicate<JavaAccess<?>> predicate) {

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AllAttributesMatchCondition.java
Patch:
@@ -2,7 +2,7 @@
 
 import java.util.Collection;
 
-import com.tngtech.archunit.core.JavaClass;
+import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ConditionEvents;
 

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AnyAccessFromClassCondition.java
Patch:
@@ -4,8 +4,8 @@
 
 import com.google.common.base.Joiner;
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.core.JavaAccess;
-import com.tngtech.archunit.core.JavaClass;
+import com.tngtech.archunit.core.domain.JavaAccess;
+import com.tngtech.archunit.core.domain.JavaClass;
 
 class AnyAccessFromClassCondition extends AnyAttributeMatchesCondition<JavaAccess<?>> {
     AnyAccessFromClassCondition(String prefix, DescribedPredicate<? super JavaAccess<?>> predicate) {

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AnyAttributeMatchesCondition.java
Patch:
@@ -2,7 +2,7 @@
 
 import java.util.Collection;
 
-import com.tngtech.archunit.core.JavaClass;
+import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ConditionEvents;
 

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ClassAccessesFieldCondition.java
Patch:
@@ -3,8 +3,8 @@
 import java.util.Collection;
 
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.core.JavaClass;
-import com.tngtech.archunit.core.JavaFieldAccess;
+import com.tngtech.archunit.core.domain.JavaClass;
+import com.tngtech.archunit.core.domain.JavaFieldAccess;
 import com.tngtech.archunit.lang.conditions.FieldAccessCondition.FieldGetAccessCondition;
 import com.tngtech.archunit.lang.conditions.FieldAccessCondition.FieldSetAccessCondition;
 

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ClassCallsCodeUnitCondition.java
Patch:
@@ -3,8 +3,8 @@
 import java.util.Collection;
 
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.core.JavaCall;
-import com.tngtech.archunit.core.JavaClass;
+import com.tngtech.archunit.core.domain.JavaCall;
+import com.tngtech.archunit.core.domain.JavaClass;
 
 class ClassCallsCodeUnitCondition extends AnyAttributeMatchesCondition<JavaCall<?>> {
     ClassCallsCodeUnitCondition(DescribedPredicate<? super JavaCall<?>> predicate) {

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/CodeUnitCallCondition.java
Patch:
@@ -1,7 +1,7 @@
 package com.tngtech.archunit.lang.conditions;
 
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.core.JavaCall;
+import com.tngtech.archunit.core.domain.JavaCall;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ConditionEvents;
 import com.tngtech.archunit.lang.SimpleConditionEvent;

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/JavaAccessCondition.java
Patch:
@@ -1,7 +1,7 @@
 package com.tngtech.archunit.lang.conditions;
 
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.core.JavaAccess;
+import com.tngtech.archunit.core.domain.JavaAccess;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ConditionEvents;
 import com.tngtech.archunit.lang.SimpleConditionEvent;

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/JavaAccessPackagePredicate.java
Patch:
@@ -7,7 +7,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.base.PackageMatcher;
-import com.tngtech.archunit.core.JavaAccess;
+import com.tngtech.archunit.core.domain.JavaAccess;
 
 class JavaAccessPackagePredicate extends DescribedPredicate<JavaAccess<?>> {
     private final Function<JavaAccess<?>, String> getPackage;

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassesInternal.java
Patch:
@@ -3,12 +3,12 @@
 import com.tngtech.archunit.base.Function;
 import com.tngtech.archunit.base.Function.Functions;
 import com.tngtech.archunit.base.Optional;
-import com.tngtech.archunit.core.JavaClass;
+import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.lang.ArchCondition;
-import com.tngtech.archunit.lang.ArchRule;
 import com.tngtech.archunit.lang.ClassesTransformer;
 import com.tngtech.archunit.lang.Priority;
 import com.tngtech.archunit.lang.syntax.elements.ClassesShould;
+import com.tngtech.archunit.lang.syntax.elements.ClassesShouldConjunction;
 import com.tngtech.archunit.lang.syntax.elements.GivenClasses;
 import com.tngtech.archunit.lang.syntax.elements.GivenClassesConjunction;
 import com.tngtech.archunit.lang.syntax.elements.GivenClassesThat;
@@ -48,7 +48,7 @@ public GivenClassesThat that() {
     }
 
     @Override
-    public ArchRule should(ArchCondition<JavaClass> condition) {
+    public ClassesShouldConjunction should(ArchCondition<JavaClass> condition) {
         return new ClassesShouldInternal(finishedClassesTransformer(), priority, condition, prepareCondition);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/ObjectsShouldInternal.java
Patch:
@@ -5,7 +5,7 @@
 import com.tngtech.archunit.base.Function;
 import com.tngtech.archunit.base.Function.Functions;
 import com.tngtech.archunit.base.Optional;
-import com.tngtech.archunit.core.JavaClasses;
+import com.tngtech.archunit.core.domain.JavaClasses;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ArchRule;
 import com.tngtech.archunit.lang.ClassesTransformer;

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/OnlyBeAccessedSpecificationInternal.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.base.Function;
-import com.tngtech.archunit.core.JavaClass;
+import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.conditions.ArchConditions;
 import com.tngtech.archunit.lang.syntax.elements.ClassesShouldConjunction;

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/DependencyRules.java
Patch:
@@ -5,7 +5,7 @@
 import java.util.TreeSet;
 
 import com.google.common.base.Joiner;
-import com.tngtech.archunit.core.Dependency;
+import com.tngtech.archunit.core.domain.Dependency;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ArchRule;
 import com.tngtech.archunit.lang.ConditionEvents;

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/SliceCycleArchCondition.java
Patch:
@@ -19,8 +19,8 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Ordering;
-import com.tngtech.archunit.core.Dependency;
-import com.tngtech.archunit.core.JavaClass;
+import com.tngtech.archunit.core.domain.Dependency;
+import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ConditionEvent;
 import com.tngtech.archunit.lang.ConditionEvents;

File: archunit/src/test/java/com/tngtech/archunit/base/OptionalTest.java
Patch:
@@ -1,7 +1,5 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.base;
 
-import com.tngtech.archunit.base.Function;
-import com.tngtech.archunit.base.Optional;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;

File: archunit/src/test/java/com/tngtech/archunit/core/domain/Assertions.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.core.domain;
 
 import org.assertj.core.api.AbstractObjectAssert;
 

File: archunit/src/test/java/com/tngtech/archunit/core/domain/JavaClassesTest.java
Patch:
@@ -1,15 +1,15 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.core.domain;
 
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.tngtech.archunit.base.DescribedPredicate;
 import org.junit.Test;
 
-import static com.tngtech.archunit.core.TestUtils.javaClassViaReflection;
+import static com.tngtech.archunit.core.domain.TestUtils.javaClassViaReflection;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class JavaClassesTest {
-    public static final JavaClass SOME_CLASS = javaClassViaReflection(SomeClass.class);
+    private static final JavaClass SOME_CLASS = javaClassViaReflection(SomeClass.class);
     private static final JavaClass SOME_OTHER_CLASS = javaClassViaReflection(SomeOtherClass.class);
     private static final ImmutableMap<String, JavaClass> BY_TYPE_NAME = ImmutableMap.of(
             SomeClass.class.getName(), SOME_CLASS,

File: archunit/src/test/java/com/tngtech/archunit/core/domain/SourceTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.core.domain;
 
 import java.io.IOException;
 import java.net.URI;
@@ -13,7 +13,7 @@
 import com.google.common.collect.Lists;
 import com.google.common.io.ByteStreams;
 import com.tngtech.archunit.ArchConfiguration;
-import com.tngtech.archunit.core.Source.Md5sum;
+import com.tngtech.archunit.core.domain.Source.Md5sum;
 import com.tngtech.java.junit.dataprovider.DataProvider;
 import com.tngtech.java.junit.dataprovider.DataProviderRunner;
 import com.tngtech.java.junit.dataprovider.UseDataProvider;
@@ -151,7 +151,7 @@ private static byte[] expectedMd5BytesAt(URL url) throws IOException, NoSuchAlgo
         return MessageDigest.getInstance("MD5").digest(bytes);
     }
 
-    static byte[] bytesAt(URL url) throws IOException {
+    public static byte[] bytesAt(URL url) throws IOException {
         return ByteStreams.toByteArray(url.openStream());
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasModifiersTest.java
Patch:
@@ -1,12 +1,12 @@
-package com.tngtech.archunit.core.properties;
+package com.tngtech.archunit.core.domain.properties;
 
 import java.util.Set;
 
 import com.google.common.collect.ImmutableSet;
-import com.tngtech.archunit.core.JavaModifier;
+import com.tngtech.archunit.core.domain.JavaModifier;
 import org.junit.Test;
 
-import static com.tngtech.archunit.core.properties.HasModifiers.Predicates.modifier;
+import static com.tngtech.archunit.core.domain.properties.HasModifiers.Predicates.modifier;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class HasModifiersTest {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasNameTest.java
Patch:
@@ -1,10 +1,10 @@
-package com.tngtech.archunit.core.properties;
+package com.tngtech.archunit.core.domain.properties;
 
 import org.assertj.core.api.AbstractBooleanAssert;
 import org.junit.Test;
 
-import static com.tngtech.archunit.core.properties.HasName.Predicates.name;
-import static com.tngtech.archunit.core.properties.HasName.Predicates.nameMatching;
+import static com.tngtech.archunit.core.domain.properties.HasName.Predicates.name;
+import static com.tngtech.archunit.core.domain.properties.HasName.Predicates.nameMatching;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 
 public class HasNameTest {

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasOwnerTest.java
Patch:
@@ -1,8 +1,8 @@
-package com.tngtech.archunit.core.properties;
+package com.tngtech.archunit.core.domain.properties;
 
 import com.tngtech.archunit.base.DescribedPredicate;
-import com.tngtech.archunit.core.properties.HasOwner.Functions.Get;
-import com.tngtech.archunit.core.properties.HasOwner.Predicates.With;
+import com.tngtech.archunit.core.domain.properties.HasOwner.Functions.Get;
+import com.tngtech.archunit.core.domain.properties.HasOwner.Predicates.With;
 import org.junit.Test;
 
 import static com.tngtech.archunit.testutil.Assertions.assertThat;

File: archunit/src/test/java/com/tngtech/archunit/core/domain/properties/HasTypeTest.java
Patch:
@@ -1,9 +1,9 @@
-package com.tngtech.archunit.core.properties;
+package com.tngtech.archunit.core.domain.properties;
 
-import com.tngtech.archunit.core.JavaClass;
+import com.tngtech.archunit.core.domain.JavaClass;
 import org.junit.Test;
 
-import static com.tngtech.archunit.core.TestUtils.javaClassViaReflection;
+import static com.tngtech.archunit.core.domain.TestUtils.javaClassViaReflection;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 
 public class HasTypeTest {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileProcessorTest.java
Patch:
@@ -1,7 +1,8 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.core.importer;
 
 import com.tngtech.archunit.base.Optional;
-import com.tngtech.archunit.core.ClassFileProcessor.ClassResolverFromClassPath;
+import com.tngtech.archunit.core.domain.JavaClass;
+import com.tngtech.archunit.core.importer.ClassFileProcessor.ClassResolverFromClassPath;
 import org.junit.Test;
 
 import static com.tngtech.archunit.testutil.Assertions.assertThat;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/ClassFileSourceTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.core.importer;
 
 import java.io.File;
 import java.io.IOException;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/LocationTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.core.importer;
 
 import java.io.IOException;
 import java.io.InputStream;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/LocationsTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.core.importer;
 
 import java.net.URI;
 import java.net.URL;
@@ -9,7 +9,7 @@
 import com.tngtech.java.junit.dataprovider.DataProvider;
 import org.junit.Test;
 
-import static com.tngtech.archunit.core.LocationTest.urlOfClass;
+import static com.tngtech.archunit.core.importer.LocationTest.urlOfClass;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class LocationsTest {
@@ -25,7 +25,7 @@ public void locations_of_URLs() throws Exception {
 
     @Test
     public void locations_of_packages_within_file_URIs() throws Exception {
-        Set<Location> locations = Locations.ofPackage("com.tngtech.archunit.core");
+        Set<Location> locations = Locations.ofPackage("com.tngtech.archunit.core.importer");
 
         assertThat(locations).extracting("uri").containsOnly(
                 uriOfFolderOf(getClass()),

File: archunit/src/test/java/com/tngtech/archunit/core/importer/TestJarFile.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.core.importer;
 
 import java.io.File;
 import java.io.FileOutputStream;
@@ -9,6 +9,8 @@
 import java.util.jar.JarOutputStream;
 import java.util.zip.ZipEntry;
 
+import com.tngtech.archunit.core.domain.TestUtils;
+
 import static com.google.common.io.ByteStreams.toByteArray;
 
 class TestJarFile {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/SomeAnnotation.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples;
+package com.tngtech.archunit.core.importer.testexamples;
 
 public @interface SomeAnnotation {
     String mandatory();

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/SomeClass.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples;
+package com.tngtech.archunit.core.importer.testexamples;
 
 public class SomeClass {
     SomeEnum other;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/SomeEnum.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples;
+package com.tngtech.archunit.core.importer.testexamples;
 
 public enum SomeEnum {
     SOME_VALUE, OTHER_VALUE;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/annotatedclassimport/ClassAnnotationWithArrays.java
Patch:
@@ -1,8 +1,8 @@
-package com.tngtech.archunit.core.testexamples.annotatedclassimport;
+package com.tngtech.archunit.core.importer.testexamples.annotatedclassimport;
 
 import java.lang.annotation.Retention;
 
-import com.tngtech.archunit.core.testexamples.SomeEnum;
+import com.tngtech.archunit.core.importer.testexamples.SomeEnum;
 
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/annotatedclassimport/ClassWithAnnotationWithEmptyArrays.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.annotatedclassimport;
+package com.tngtech.archunit.core.importer.testexamples.annotatedclassimport;
 
 @ClassAnnotationWithArrays(
         primitives = {},

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/annotatedclassimport/ClassWithComplexAnnotations.java
Patch:
@@ -1,9 +1,9 @@
-package com.tngtech.archunit.core.testexamples.annotatedclassimport;
+package com.tngtech.archunit.core.importer.testexamples.annotatedclassimport;
 
 import java.io.Serializable;
 
-import static com.tngtech.archunit.core.testexamples.SomeEnum.OTHER_VALUE;
-import static com.tngtech.archunit.core.testexamples.SomeEnum.SOME_VALUE;
+import static com.tngtech.archunit.core.importer.testexamples.SomeEnum.OTHER_VALUE;
+import static com.tngtech.archunit.core.importer.testexamples.SomeEnum.SOME_VALUE;
 
 @SimpleAnnotation("some")
 @TypeAnnotationWithEnumAndArrayValue(

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/annotatedclassimport/SimpleAnnotation.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.annotatedclassimport;
+package com.tngtech.archunit.core.importer.testexamples.annotatedclassimport;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/annotationfieldimport/FieldAnnotationWithArrays.java
Patch:
@@ -1,9 +1,9 @@
-package com.tngtech.archunit.core.testexamples.annotationfieldimport;
+package com.tngtech.archunit.core.importer.testexamples.annotationfieldimport;
 
 import java.lang.annotation.Retention;
 
-import com.tngtech.archunit.core.testexamples.SomeEnum;
-import com.tngtech.archunit.core.testexamples.annotatedclassimport.SimpleAnnotation;
+import com.tngtech.archunit.core.importer.testexamples.SomeEnum;
+import com.tngtech.archunit.core.importer.testexamples.annotatedclassimport.SimpleAnnotation;
 
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/annotationmethodimport/MethodAnnotationWithArrays.java
Patch:
@@ -1,9 +1,9 @@
-package com.tngtech.archunit.core.testexamples.annotationmethodimport;
+package com.tngtech.archunit.core.importer.testexamples.annotationmethodimport;
 
 import java.lang.annotation.Retention;
 
-import com.tngtech.archunit.core.testexamples.SomeEnum;
-import com.tngtech.archunit.core.testexamples.annotatedclassimport.SimpleAnnotation;
+import com.tngtech.archunit.core.importer.testexamples.SomeEnum;
+import com.tngtech.archunit.core.importer.testexamples.annotatedclassimport.SimpleAnnotation;
 
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/callimport/CallsExternalMethod.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.callimport;
+package com.tngtech.archunit.core.importer.testexamples.callimport;
 
 import java.util.ArrayList;
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/callimport/CallsMethodReturningArray.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.callimport;
+package com.tngtech.archunit.core.importer.testexamples.callimport;
 
 public class CallsMethodReturningArray {
     SomeEnum[] getValues() {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/callimport/CallsOtherConstructor.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.callimport;
+package com.tngtech.archunit.core.importer.testexamples.callimport;
 
 public class CallsOtherConstructor {
     void createOther() {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/callimport/CallsOtherMethod.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.callimport;
+package com.tngtech.archunit.core.importer.testexamples.callimport;
 
 public class CallsOtherMethod {
     CallsOwnMethod other;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/callimport/CallsOwnConstructor.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.callimport;
+package com.tngtech.archunit.core.importer.testexamples.callimport;
 
 public class CallsOwnConstructor {
     public CallsOwnConstructor(String string) {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/callimport/CallsOwnMethod.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.callimport;
+package com.tngtech.archunit.core.importer.testexamples.callimport;
 
 public class CallsOwnMethod {
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/callimport/ExternalInterfaceMethodCall.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.callimport;
+package com.tngtech.archunit.core.importer.testexamples.callimport;
 
 import java.util.SortedMap;
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/callimport/ExternalSubTypeConstructorCall.java
Patch:
@@ -1,8 +1,8 @@
-package com.tngtech.archunit.core.testexamples.callimport;
+package com.tngtech.archunit.core.importer.testexamples.callimport;
 
 import java.util.HashMap;
 
-import com.tngtech.archunit.core.testexamples.complexexternal.ChildClass;
+import com.tngtech.archunit.core.importer.testexamples.complexexternal.ChildClass;
 
 public class ExternalSubTypeConstructorCall {
     void call() {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/BaseClass.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.classhierarchyimport;
+package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
 public class BaseClass implements OtherInterface {
     static {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/CollectionInterface.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.classhierarchyimport;
+package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
 import java.util.Collection;
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/OtherSubClass.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.classhierarchyimport;
+package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
 public class OtherSubClass extends BaseClass implements ParentInterface {
     private int foo = 5;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/SomeCollection.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.classhierarchyimport;
+package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
 public abstract class SomeCollection implements CollectionInterface, OtherInterface, SubInterface {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/SubClass.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.classhierarchyimport;
+package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
 public class SubClass extends BaseClass implements SubInterface {
     static {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/classhierarchyimport/SubSubClass.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.classhierarchyimport;
+package com.tngtech.archunit.core.importer.testexamples.classhierarchyimport;
 
 public class SubSubClass extends SubClass {
     private String printMe = "NoOp";

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/complexexternal/ChildClass.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.complexexternal;
+package com.tngtech.archunit.core.importer.testexamples.complexexternal;
 
 public class ChildClass extends UpperMiddleClass {
     public String someField;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/complexexternal/LowerMiddleClass.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.complexexternal;
+package com.tngtech.archunit.core.importer.testexamples.complexexternal;
 
 public class LowerMiddleClass extends ParentClass {
     public String someField;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/complexexternal/ParentClass.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.complexexternal;
+package com.tngtech.archunit.core.importer.testexamples.complexexternal;
 
 public class ParentClass {
     public String someField;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/complexexternal/UpperMiddleClass.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.complexexternal;
+package com.tngtech.archunit.core.importer.testexamples.complexexternal;
 
 public class UpperMiddleClass extends LowerMiddleClass {
     public String someField;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/complexmethodimport/ClassWithComplexMethod.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.complexmethodimport;
+package com.tngtech.archunit.core.importer.testexamples.complexmethodimport;
 
 import java.io.Serializable;
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/constructorimport/ClassWithComplexConstructor.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.constructorimport;
+package com.tngtech.archunit.core.importer.testexamples.constructorimport;
 
 import java.io.Serializable;
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/constructorimport/ClassWithSimpleConstructors.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.constructorimport;
+package com.tngtech.archunit.core.importer.testexamples.constructorimport;
 
 public class ClassWithSimpleConstructors {
     ClassWithSimpleConstructors() {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/dependents/ClassDependingOnParentThroughChild.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.dependents;
+package com.tngtech.archunit.core.importer.testexamples.dependents;
 
 public class ClassDependingOnParentThroughChild {
     SubClassHoldingDependencies classHoldingDependencies;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/dependents/ClassHoldingDependencies.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.dependents;
+package com.tngtech.archunit.core.importer.testexamples.dependents;
 
 public class ClassHoldingDependencies {
     int someInt;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/dependents/FirstClassWithDependency.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.dependents;
+package com.tngtech.archunit.core.importer.testexamples.dependents;
 
 import java.io.Serializable;
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/dependents/ParentClassHoldingDependencies.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.dependents;
+package com.tngtech.archunit.core.importer.testexamples.dependents;
 
 public class ParentClassHoldingDependencies {
     Object parentField;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/dependents/SecondClassWithDependency.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.dependents;
+package com.tngtech.archunit.core.importer.testexamples.dependents;
 
 public class SecondClassWithDependency {
     void other() {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/dependents/SubClassHoldingDependencies.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.dependents;
+package com.tngtech.archunit.core.importer.testexamples.dependents;
 
 public class SubClassHoldingDependencies extends ParentClassHoldingDependencies {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/diamond/ClassCallingDiamond.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.diamond;
+package com.tngtech.archunit.core.importer.testexamples.diamond;
 
 public class ClassCallingDiamond {
     public static final String callInterface = "callInterface";

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/diamond/ClassImplementingD.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.diamond;
+package com.tngtech.archunit.core.importer.testexamples.diamond;
 
 public class ClassImplementingD implements InterfaceD {
     @Override

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/diamond/InterfaceB.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.diamond;
+package com.tngtech.archunit.core.importer.testexamples.diamond;
 
 public interface InterfaceB extends InterfaceA {
     String implementMe = "implementMe";

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/diamond/InterfaceC.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.diamond;
+package com.tngtech.archunit.core.importer.testexamples.diamond;
 
 public interface InterfaceC extends InterfaceA {
     void implementMe();

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/fieldaccessimport/ForeignFieldAccess.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.fieldaccessimport;
+package com.tngtech.archunit.core.importer.testexamples.fieldaccessimport;
 
 public class ForeignFieldAccess {
     public String getStringFromOther() {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/fieldaccessimport/ForeignFieldAccessFromConstructor.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.fieldaccessimport;
+package com.tngtech.archunit.core.importer.testexamples.fieldaccessimport;
 
 public class ForeignFieldAccessFromConstructor {
     public ForeignFieldAccessFromConstructor() {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/fieldaccessimport/ForeignFieldAccessFromStaticInitializer.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.fieldaccessimport;
+package com.tngtech.archunit.core.importer.testexamples.fieldaccessimport;
 
 public class ForeignFieldAccessFromStaticInitializer {
     static {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/fieldaccessimport/ForeignStaticFieldAccess.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.fieldaccessimport;
+package com.tngtech.archunit.core.importer.testexamples.fieldaccessimport;
 
 public class ForeignStaticFieldAccess {
     public static String getStaticStringFromOther() {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/fieldaccessimport/MultipleFieldAccessInSameMethod.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.fieldaccessimport;
+package com.tngtech.archunit.core.importer.testexamples.fieldaccessimport;
 
 public class MultipleFieldAccessInSameMethod {
     void multipleCalls() {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/fieldaccessimport/OwnFieldAccess.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.fieldaccessimport;
+package com.tngtech.archunit.core.importer.testexamples.fieldaccessimport;
 
 public class OwnFieldAccess {
     public String stringValue;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/fieldaccessimport/OwnStaticFieldAccess.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.fieldaccessimport;
+package com.tngtech.archunit.core.importer.testexamples.fieldaccessimport;
 
 public class OwnStaticFieldAccess {
     static String staticStringValue;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/fieldaccesstointerfaces/ClassAccessingInterfaceFields.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.fieldaccesstointerfaces;
+package com.tngtech.archunit.core.importer.testexamples.fieldaccesstointerfaces;
 
 public class ClassAccessingInterfaceFields {
     private ClassWithInterfacesWithFields classWithInterfacesWithFields;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/fieldaccesstointerfaces/ClassWithInterfacesWithFields.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.fieldaccesstointerfaces;
+package com.tngtech.archunit.core.importer.testexamples.fieldaccesstointerfaces;
 
 public class ClassWithInterfacesWithFields implements InterfaceWithFields, OtherInterfaceWithFields {
 }

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/fieldaccesstointerfaces/InterfaceWithFields.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.fieldaccesstointerfaces;
+package com.tngtech.archunit.core.importer.testexamples.fieldaccesstointerfaces;
 
 // NOTE: The compiler will inline Strings or primitives, thus use field type Object
 public interface InterfaceWithFields extends ParentInterfaceWithFields {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/fieldaccesstointerfaces/OtherInterfaceWithFields.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.fieldaccesstointerfaces;
+package com.tngtech.archunit.core.importer.testexamples.fieldaccesstointerfaces;
 
 public interface OtherInterfaceWithFields {
     Object otherObjectFieldOne = "otherObjectFieldOne";

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/fieldaccesstointerfaces/ParentInterfaceWithFields.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.fieldaccesstointerfaces;
+package com.tngtech.archunit.core.importer.testexamples.fieldaccesstointerfaces;
 
 public interface ParentInterfaceWithFields {
     Object parentObjectFieldOne = "parentObjectFieldOne";

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/fieldimport/ClassWithIntAndObjectFields.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.fieldimport;
+package com.tngtech.archunit.core.importer.testexamples.fieldimport;
 
 import java.io.Serializable;
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/fieldimport/ClassWithStringField.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.fieldimport;
+package com.tngtech.archunit.core.importer.testexamples.fieldimport;
 
 public class ClassWithStringField {
     @Deprecated

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/hierarchicalfieldaccess/AccessToSuperAndSubClassField.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.hierarchicalfieldaccess;
+package com.tngtech.archunit.core.importer.testexamples.hierarchicalfieldaccess;
 
 public class AccessToSuperAndSubClassField {
     String accessSuperClassField() {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/hierarchicalfieldaccess/SubClassWithAccessedField.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.hierarchicalfieldaccess;
+package com.tngtech.archunit.core.importer.testexamples.hierarchicalfieldaccess;
 
 public class SubClassWithAccessedField extends SuperClassWithAccessedField {
     int maskedField;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/hierarchicalfieldaccess/SuperClassWithAccessedField.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.hierarchicalfieldaccess;
+package com.tngtech.archunit.core.importer.testexamples.hierarchicalfieldaccess;
 
 public class SuperClassWithAccessedField {
     String field;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/hierarchicalmethodcall/CallOfSuperAndSubClassMethod.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.hierarchicalmethodcall;
+package com.tngtech.archunit.core.importer.testexamples.hierarchicalmethodcall;
 
 public class CallOfSuperAndSubClassMethod {
     public static final String callSuperClassMethod = "callSuperClassMethod";

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/hierarchicalmethodcall/SubClassWithCalledMethod.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.hierarchicalmethodcall;
+package com.tngtech.archunit.core.importer.testexamples.hierarchicalmethodcall;
 
 public class SubClassWithCalledMethod extends SuperClassWithCalledMethod {
     public static final String maskedMethod = "maskedMethod";

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/hierarchicalmethodcall/SuperClassWithCalledMethod.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.hierarchicalmethodcall;
+package com.tngtech.archunit.core.importer.testexamples.hierarchicalmethodcall;
 
 public class SuperClassWithCalledMethod {
     public static final String method = "method";

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/innerclassimport/CalledClass.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.innerclassimport;
+package com.tngtech.archunit.core.importer.testexamples.innerclassimport;
 
 public class CalledClass {
     private String someString;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/innerclassimport/ClassWithInnerClass.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.innerclassimport;
+package com.tngtech.archunit.core.importer.testexamples.innerclassimport;
 
 public class ClassWithInnerClass {
     void callInsideOfAnonymous() {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/integration/ClassA.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.integration;
+package com.tngtech.archunit.core.importer.testexamples.integration;
 
 public class ClassA {
     private String init;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/integration/ClassBDependingOnClassA.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.integration;
+package com.tngtech.archunit.core.importer.testexamples.integration;
 
 public class ClassBDependingOnClassA {
     private String bState = "initialized";

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/integration/ClassCDependingOnClassB.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.integration;
+package com.tngtech.archunit.core.importer.testexamples.integration;
 
 public class ClassCDependingOnClassB {
     private ClassBDependingOnClassA classB;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/integration/ClassXDependingOnClassesABCD.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.integration;
+package com.tngtech.archunit.core.importer.testexamples.integration;
 
 public class ClassXDependingOnClassesABCD extends ClassCDependingOnClassB {
     private ClassA classA;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/methodimport/ClassWithObjectVoidAndIntIntSerializableMethod.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.methodimport;
+package com.tngtech.archunit.core.importer.testexamples.methodimport;
 
 import java.io.Serializable;
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/methodimport/ClassWithStringStringMethod.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.methodimport;
+package com.tngtech.archunit.core.importer.testexamples.methodimport;
 
 public class ClassWithStringStringMethod {
     String createString(String input) {

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/modifierfieldimport/ClassWithFieldsWithModifiers.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.modifierfieldimport;
+package com.tngtech.archunit.core.importer.testexamples.modifierfieldimport;
 
 public class ClassWithFieldsWithModifiers {
     private Object privateField;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/nestedimport/ClassWithNestedClass.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.nestedimport;
+package com.tngtech.archunit.core.importer.testexamples.nestedimport;
 
 public class ClassWithNestedClass {
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/outsideofclasspath/ChildClass.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.outsideofclasspath;
+package com.tngtech.archunit.core.importer.testexamples.outsideofclasspath;
 
 import java.io.Serializable;
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/outsideofclasspath/ExistingDependency.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.outsideofclasspath;
+package com.tngtech.archunit.core.importer.testexamples.outsideofclasspath;
 
 import java.io.Serializable;
 

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/outsideofclasspath/MiddleClass.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.outsideofclasspath;
+package com.tngtech.archunit.core.importer.testexamples.outsideofclasspath;
 
 public class MiddleClass extends MissingSuperClass {
     public String someField;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/outsideofclasspath/MissingDependency.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.outsideofclasspath;
+package com.tngtech.archunit.core.importer.testexamples.outsideofclasspath;
 
 public class MissingDependency {
     public String someField;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/outsideofclasspath/MissingSuperClass.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.outsideofclasspath;
+package com.tngtech.archunit.core.importer.testexamples.outsideofclasspath;
 
 public class MissingSuperClass {
     public String parentField;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/primitivefieldimport/ClassWithPrimitiveFields.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.primitivefieldimport;
+package com.tngtech.archunit.core.importer.testexamples.primitivefieldimport;
 
 public class ClassWithPrimitiveFields {
     boolean aBoolean;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/specialtargets/ClassCallingSpecialTarget.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.specialtargets;
+package com.tngtech.archunit.core.importer.testexamples.specialtargets;
 
 public class ClassCallingSpecialTarget {
     private SpecialTarget specialTarget;

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/specialtargets/SuperOne.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.specialtargets;
+package com.tngtech.archunit.core.importer.testexamples.specialtargets;
 
 public interface SuperOne {
     void primitiveArgs(byte b, long l);

File: archunit/src/test/java/com/tngtech/archunit/core/importer/testexamples/specialtargets/SuperTwo.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core.testexamples.specialtargets;
+package com.tngtech.archunit.core.importer.testexamples.specialtargets;
 
 public interface SuperTwo {
     void primitiveArgs(byte b, long l);

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/junit/SlicesIsolationTest.java
Patch:
@@ -7,14 +7,14 @@
 import com.tngtech.archunit.lang.ArchRule;
 import org.junit.runner.RunWith;
 
-import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.allSlices;
+import static com.tngtech.archunit.library.dependencies.SlicesRuleDefinition.slices;
 
 @RunWith(ArchUnitRunner.class)
 @AnalyseClasses(packages = "com.tngtech.archunit.example")
 public class SlicesIsolationTest {
     @ArchIgnore
     @ArchTest
     public static final ArchRule controllers_should_only_use_their_own_slice =
-            allSlices().matching("..controller.(*)..").namingSlices("Controller $1")
+            slices().matching("..controller.(*)..").namingSlices("Controller $1")
                     .as("Controllers").shouldNotDependOnEachOther();
 }

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ReflectionUtils.java
Patch:
@@ -66,8 +66,7 @@ void collectFrom(Class<?> type) {
         protected abstract Collection<? extends T> extractFrom(Class<?> type);
     }
 
-    // NOTE: Don't use Guava classes in public API
-    public interface Predicate<T> {
+    interface Predicate<T> {
         boolean apply(T input);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/MayResolveTypesViaReflection.java
Patch:
@@ -2,6 +2,8 @@
 
 import java.lang.annotation.Retention;
 
+import com.tngtech.archunit.Internal;
+
 import static java.lang.annotation.RetentionPolicy.CLASS;
 
 /**
@@ -11,6 +13,7 @@
  * the predefined conditions and predicates.
  */
 @Retention(CLASS)
+@Internal
 public @interface MayResolveTypesViaReflection {
     String reason();
 }

File: archunit/src/main/java/com/tngtech/archunit/core/ResolvesTypesViaReflection.java
Patch:
@@ -2,12 +2,15 @@
 
 import java.lang.annotation.Retention;
 
+import com.tngtech.archunit.Internal;
+
 import static java.lang.annotation.RetentionPolicy.CLASS;
 
 /**
  * Marks the methods or classes, that resolve types via reflection so we can use it for architecture
  * assertions.
  */
 @Retention(CLASS)
+@Internal
 public @interface ResolvesTypesViaReflection {
 }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/Formatters.java
Patch:
@@ -5,8 +5,10 @@
 
 import com.google.common.base.Joiner;
 import com.google.common.primitives.Ints;
+import com.tngtech.archunit.Internal;
 import com.tngtech.archunit.core.domain.properties.HasName;
 
+@Internal
 public class Formatters {
     private Formatters() {
     }

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaConstructorCall.java
Patch:
@@ -4,7 +4,7 @@
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaConstructorCallBuilder;
 
 public class JavaConstructorCall extends JavaCall<ConstructorCallTarget> {
-    public JavaConstructorCall(JavaConstructorCallBuilder builder) {
+    JavaConstructorCall(JavaConstructorCallBuilder builder) {
         super(builder);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaField.java
Patch:
@@ -19,7 +19,7 @@ public class JavaField extends JavaMember implements HasType {
     private final Supplier<Field> fieldSupplier;
     private Supplier<Set<JavaFieldAccess>> accessesToSelf = Suppliers.ofInstance(Collections.<JavaFieldAccess>emptySet());
 
-    public JavaField(DomainBuilders.JavaFieldBuilder builder) {
+    JavaField(DomainBuilders.JavaFieldBuilder builder) {
         super(builder);
         type = builder.getType();
         fieldSupplier = Suppliers.memoize(new ReflectFieldSupplier());

File: archunit/src/main/java/com/tngtech/archunit/core/domain/JavaMethodCall.java
Patch:
@@ -4,7 +4,7 @@
 import com.tngtech.archunit.core.importer.DomainBuilders.JavaMethodCallBuilder;
 
 public class JavaMethodCall extends JavaCall<MethodCallTarget> {
-    public JavaMethodCall(JavaMethodCallBuilder builder) {
+    JavaMethodCall(JavaMethodCallBuilder builder) {
         super(builder);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/domain/properties/HasDescriptor.java
Patch:
@@ -1,5 +1,8 @@
 package com.tngtech.archunit.core.domain.properties;
 
+import com.tngtech.archunit.Internal;
+
+@Internal
 public interface HasDescriptor {
     String getDescriptor();
 }

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassFileLocation.java
Patch:
@@ -3,7 +3,7 @@
 import java.io.InputStream;
 import java.net.URI;
 
-public interface ClassFileLocation {
+interface ClassFileLocation {
     InputStream openStream();
 
     URI getUri();

File: archunit/src/main/java/com/tngtech/archunit/core/importer/ClassesByTypeName.java
Patch:
@@ -2,6 +2,6 @@
 
 import com.tngtech.archunit.core.domain.JavaClass;
 
-public interface ClassesByTypeName {
+interface ClassesByTypeName {
     JavaClass get(String typeName);
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/ArchCondition.java
Patch:
@@ -9,9 +9,12 @@
 import com.google.common.base.Joiner;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableList;
+import com.tngtech.archunit.PublicAPI;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.tngtech.archunit.PublicAPI.Usage.INHERITANCE;
 
+@PublicAPI(usage = INHERITANCE)
 public abstract class ArchCondition<T> {
     private String description;
 

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassesInternal.java
Patch:
@@ -5,10 +5,10 @@
 import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.domain.JavaClass;
 import com.tngtech.archunit.lang.ArchCondition;
-import com.tngtech.archunit.lang.ArchRule;
 import com.tngtech.archunit.lang.ClassesTransformer;
 import com.tngtech.archunit.lang.Priority;
 import com.tngtech.archunit.lang.syntax.elements.ClassesShould;
+import com.tngtech.archunit.lang.syntax.elements.ClassesShouldConjunction;
 import com.tngtech.archunit.lang.syntax.elements.GivenClasses;
 import com.tngtech.archunit.lang.syntax.elements.GivenClassesConjunction;
 import com.tngtech.archunit.lang.syntax.elements.GivenClassesThat;
@@ -48,7 +48,7 @@ public GivenClassesThat that() {
     }
 
     @Override
-    public ArchRule should(ArchCondition<JavaClass> condition) {
+    public ClassesShouldConjunction should(ArchCondition<JavaClass> condition) {
         return new ClassesShouldInternal(finishedClassesTransformer(), priority, condition, prepareCondition);
     }
 

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/SlicesTest.java
Patch:
@@ -13,6 +13,7 @@
 import org.junit.Test;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.tngtech.archunit.core.domain.TestUtils.dependencyFrom;
 import static com.tngtech.archunit.core.domain.TestUtils.javaClassesViaReflection;
 import static com.tngtech.archunit.core.domain.TestUtils.javaMethodViaReflection;
 import static com.tngtech.archunit.core.domain.TestUtils.simulateCall;
@@ -61,8 +62,8 @@ public void slices_of_dependencies() {
         simulateCall().from(methodThatCallsJavaUtil, 5).to(methodThatCallsJavaLang);
         simulateCall().from(methodThatCallsJavaLang, 1).to(methodThatCallsJavaUtil);
 
-        Dependency first = Dependency.from(getOnlyElement(methodThatCallsJavaUtil.getMethodCallsFromSelf()));
-        Dependency second = Dependency.from(getOnlyElement(methodThatCallsJavaLang.getMethodCallsFromSelf()));
+        Dependency first = dependencyFrom(getOnlyElement(methodThatCallsJavaUtil.getMethodCallsFromSelf()));
+        Dependency second = dependencyFrom(getOnlyElement(methodThatCallsJavaLang.getMethodCallsFromSelf()));
 
         Slices slices = Slices.matching("java.(*)..").transform(ImmutableSet.of(first, second));
 

File: archunit/src/main/java/com/tngtech/archunit/core/ClassGraphCreator.java
Patch:
@@ -168,7 +168,7 @@ public Set<JavaConstructor> createConstructors(JavaClass owner) {
 
     @Override
     public Optional<JavaStaticInitializer> createStaticInitializer(JavaClass owner) {
-        Optional<JavaStaticInitializer.Builder> builder = importRecord.getStaticInitializerBuilderFor(owner.getName());
+        Optional<JavaStaticInitializerBuilder> builder = importRecord.getStaticInitializerBuilderFor(owner.getName());
         return builder.isPresent() ?
                 Optional.of(builder.get().build(owner, classes.byTypeName())) :
                 Optional.<JavaStaticInitializer>absent();

File: archunit/src/main/java/com/tngtech/archunit/core/ImportedClasses.java
Patch:
@@ -70,12 +70,12 @@ public JavaClass get(String typeName) {
 
     private static JavaClass simpleClassOf(String typeName) {
         JavaType type = JavaType.From.name(typeName);
-        JavaClass.Builder builder = new JavaClass.Builder().withType(type);
+        JavaClassBuilder builder = new JavaClassBuilder().withType(type);
         addModifiersIfPossible(builder, type);
         return builder.build();
     }
 
-    private static void addModifiersIfPossible(JavaClass.Builder builder, JavaType type) {
+    private static void addModifiersIfPossible(JavaClassBuilder builder, JavaType type) {
         if (type.isPrimitive() || type.isArray()) {
             builder.withModifiers(PRIMITIVE_AND_ARRAY_TYPE_MODIFIERS);
         }

File: archunit/src/main/java/com/tngtech/archunit/core/JavaEnumConstant.java
Patch:
@@ -6,9 +6,9 @@ public class JavaEnumConstant {
     private final JavaClass declaringClass;
     private final String name;
 
-    JavaEnumConstant(JavaClass declaringClass, String name) {
-        this.declaringClass = declaringClass;
-        this.name = name;
+    public JavaEnumConstant(JavaEnumConstantBuilder builder) {
+        this.declaringClass = builder.getDeclaringClass();
+        this.name = builder.getName();
     }
 
     public JavaClass getDeclaringClass() {

File: archunit/src/test/java/com/tngtech/archunit/core/ClassFileProcessorTest.java
Patch:
@@ -2,16 +2,14 @@
 
 import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.ClassFileProcessor.ClassResolverFromClassPath;
-import com.tngtech.archunit.core.JavaClassProcessor.DeclarationHandler;
 import org.junit.Test;
 
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
 
 public class ClassFileProcessorTest {
     @Test
     public void ClassResolverFromClassPath_resolves_robustly() {
-        Optional<JavaClass> resolved = new ClassResolverFromClassPath(mock(DeclarationHandler.class))
+        Optional<JavaClass> resolved = new ClassResolverFromClassPath()
                 .tryResolve("not.There");
 
         assertThat(resolved).isAbsent();

File: archunit/src/main/java/com/tngtech/archunit/core/ClassResolver.java
Patch:
@@ -3,5 +3,5 @@
 import com.tngtech.archunit.base.Optional;
 
 interface ClassResolver {
-    Optional<JavaClass> tryResolve(String typeName, ImportedClasses.ByTypeName importedClasses);
+    Optional<JavaClass> tryResolve(String typeName);
 }

File: archunit/src/test/java/com/tngtech/archunit/core/ClassFileProcessorTest.java
Patch:
@@ -12,7 +12,7 @@ public class ClassFileProcessorTest {
     @Test
     public void ClassResolverFromClassPath_resolves_robustly() {
         Optional<JavaClass> resolved = new ClassResolverFromClassPath(mock(DeclarationHandler.class))
-                .tryResolve("not.There", mock(ImportedClasses.ByTypeName.class));
+                .tryResolve("not.There");
 
         assertThat(resolved).isAbsent();
     }

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/SessionBeanRulesTest.java
Patch:
@@ -84,7 +84,7 @@ public boolean apply(JavaClass input) {
                 //       one type, otherwise this would need to be more sophisticated
                 private boolean isLocalBeanImplementation(JavaClass bean, JavaClass businessInterfaceType) {
                     return bean.isAnnotatedWith(Local.class) &&
-                            bean.getReflectionAnnotation(Local.class).value()[0].getName()
+                            bean.getAnnotationOfType(Local.class).value()[0].getName()
                                     .equals(businessInterfaceType.getName());
                 }
             };

File: archunit/src/main/java/com/tngtech/archunit/core/properties/HasAnnotations.java
Patch:
@@ -9,11 +9,11 @@
 public interface HasAnnotations extends CanBeAnnotated {
     Set<JavaAnnotation> getAnnotations();
 
-    JavaAnnotation getAnnotationOfType(Class<? extends Annotation> type);
+    <A extends Annotation> A getAnnotationOfType(Class<A> type);
 
     JavaAnnotation getAnnotationOfType(String typeName);
 
-    Optional<JavaAnnotation> tryGetAnnotationOfType(Class<? extends Annotation> type);
+    <A extends Annotation> Optional<A> tryGetAnnotationOfType(Class<A> type);
 
     Optional<JavaAnnotation> tryGetAnnotationOfType(String typeName);
 }

File: archunit-example/src/main/java/com/tngtech/archunit/example/ClassViolatingSessionBeanRules.java
Patch:
@@ -10,7 +10,7 @@ public class ClassViolatingSessionBeanRules implements SomeBusinessInterface {
     public static final String CONSTANT = "CONSTANT";
     private final String CONSTANT_FROM_CONSTRUCTOR;
     private String setOnConstruction;
-    private String state;
+    String state;
 
     public ClassViolatingSessionBeanRules() {
         CONSTANT_FROM_CONSTRUCTOR = "CONSTANT_FROM_CONSTRUCTOR";

File: archunit-example/src/main/java/com/tngtech/archunit/example/service/ServiceViolatingDaoRules.java
Patch:
@@ -25,6 +25,6 @@ public void illegallyUseEntityManager() {
         myEntityManager.persist(new OtherPersistentObject(2L)); // Violates rule not to use EntityManager outside of DAOs
     }
 
-    public static abstract class MyEntityManager implements EntityManager {
+    public abstract static class MyEntityManager implements EntityManager {
     }
 }

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/ClassFileImportHelper.java
Patch:
@@ -7,10 +7,10 @@
 import com.tngtech.archunit.core.ClassFileImporter;
 import com.tngtech.archunit.core.JavaClasses;
 
-public class ClassFileImportHelper {
+class ClassFileImportHelper {
     private final ClassFileImporter importer = new ClassFileImporter();
 
-    public JavaClasses importTreesOf(Class<?>... rootClasses) {
+    JavaClasses importTreesOf(Class<?>... rootClasses) {
         try {
             return uncheckedImportTreesOf(rootClasses);
         } catch (Exception e) {

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/junit/RuleSetsTest.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.exampletest;
+package com.tngtech.archunit.exampletest.junit;
 
 import com.tngtech.archunit.junit.AnalyseClasses;
 import com.tngtech.archunit.junit.ArchRules;
@@ -10,8 +10,8 @@
 @AnalyseClasses(packages = "com.tngtech.archunit.example")
 public class RuleSetsTest {
     @ArchTest
-    public static final ArchRules<?> CODING_RULES = ArchRules.in(CodingRulesWithRunnerTest.class);
+    public static final ArchRules CODING_RULES = ArchRules.in(CodingRulesWithRunnerTest.class);
 
     @ArchTest
-    public static final ArchRules<?> CYCLIC_DEPENDENCY_RULES = ArchRules.in(CyclicDependencyRulesWithRunnerTest.class);
+    public static final ArchRules CYCLIC_DEPENDENCY_RULES = ArchRules.in(CyclicDependencyRulesTest.class);
 }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/ArchUnitIntegrationTestRunner.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.integration;
+package com.tngtech.archunit.integration.junit;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/CodingRulesWithRunnerMethodsIntegrationTest.java
Patch:
@@ -1,7 +1,7 @@
-package com.tngtech.archunit.integration;
+package com.tngtech.archunit.integration.junit;
 
 import com.tngtech.archunit.core.JavaClasses;
-import com.tngtech.archunit.exampletest.CodingRulesWithRunnerMethodsTest;
+import com.tngtech.archunit.exampletest.junit.CodingRulesWithRunnerMethodsTest;
 import com.tngtech.archunit.junit.AnalyseClasses;
 import com.tngtech.archunit.junit.ArchTest;
 import com.tngtech.archunit.junit.ExpectedViolation;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/CyclicErrorMatcher.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.integration;
+package com.tngtech.archunit.integration.junit;
 
 import java.util.ArrayList;
 import java.util.Collection;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/ExpectedViolationFrom.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.integration;
+package com.tngtech.archunit.integration.junit;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/SliceDependencyErrorMatcher.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.integration;
+package com.tngtech.archunit.integration.junit;
 
 import java.util.ArrayList;
 import java.util.HashSet;

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ArchTest.java
Patch:
@@ -3,12 +3,14 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
+import com.tngtech.archunit.lang.ArchRule;
+
 import static java.lang.annotation.ElementType.FIELD;
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Marks a field of type {@link com.tngtech.archunit.lang.ArchRule} to be evaluated by the {@link ArchUnitRunner}.
+ * Marks a field of type {@link ArchRule} to be evaluated by the {@link ArchUnitRunner}.
  *
  * @see ArchUnitRunner
  */

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ArchTestExecution.java
Patch:
@@ -41,7 +41,7 @@ public boolean ignore() {
         return testClass.getAnnotation(ArchIgnore.class) != null || getAnnotation(ArchIgnore.class) != null;
     }
 
-    static abstract class Result {
+    abstract static class Result {
         abstract void notify(RunNotifier notifier);
     }
 

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ArchUnitRunner.java
Patch:
@@ -64,10 +64,10 @@ private Set<ArchTestExecution> findArchRulesIn(FrameworkField ruleField) {
         return Collections.<ArchTestExecution>singleton(new ArchRuleExecution(getTestClass().getJavaClass(), ruleField.getField()));
     }
 
-    private ArchRules<?> getArchRules(FrameworkField ruleField) {
+    private ArchRules getArchRules(FrameworkField ruleField) {
         ArchTestExecution.validate(ruleField.getField());
         try {
-            return (ArchRules<?>) ruleField.get(null);
+            return (ArchRules) ruleField.get(null);
         } catch (IllegalAccessException e) {
             throw new RuntimeException(e);
         }

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ClassCache.java
Patch:
@@ -5,7 +5,7 @@
 import java.util.concurrent.ConcurrentHashMap;
 
 import com.google.common.collect.ImmutableSet;
-import com.tngtech.archunit.core.ArchUnitException.ReflectionException;
+import com.tngtech.archunit.base.ArchUnitException.ReflectionException;
 import com.tngtech.archunit.core.ClassFileImporter;
 import com.tngtech.archunit.core.JavaClasses;
 import com.tngtech.archunit.core.Location;

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ReflectionUtils.java
Patch:
@@ -56,7 +56,7 @@ private static <T> List<T> getAll(Class<?> type, Collector<T> collector) {
         return collector.collected;
     }
 
-    private static abstract class Collector<T> {
+    private abstract static class Collector<T> {
         private final List<T> collected = new ArrayList<>();
 
         void collectFrom(Class<?> type) {

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsMethodsTest.java
Patch:
@@ -27,6 +27,7 @@
 import static com.tngtech.archunit.junit.ArchUnitRunnerTestUtils.newRunnerFor;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -63,6 +64,7 @@ public void setUp() {
     @Test
     public void executes_test_methods_and_supplies_JavaClasses() throws InitializationError {
         runner.runChild(getRule(testSomething, runner), runNotifier);
+        verify(runNotifier, never()).fireTestFailure(any(Failure.class));
         verify(runNotifier).fireTestFinished(descriptionCaptor.capture());
         assertThat(descriptionCaptor.getAllValues()).extractingResultOf("getMethodName")
                 .contains(testSomething);

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerTestUtils.java
Patch:
@@ -2,17 +2,17 @@
 
 import com.tngtech.archunit.core.JavaClass;
 import com.tngtech.archunit.lang.ArchCondition;
-import com.tngtech.archunit.lang.ConditionEvent;
 import com.tngtech.archunit.lang.ConditionEvents;
+import com.tngtech.archunit.lang.SimpleConditionEvent;
 import org.junit.runners.model.InitializationError;
 
 import static com.tngtech.archunit.lang.conditions.ArchConditions.never;
 
-public class ArchUnitRunnerTestUtils {
+class ArchUnitRunnerTestUtils {
     static final ArchCondition<JavaClass> BE_SATISFIED = new ArchCondition<JavaClass>("satisfy something") {
         @Override
         public void check(JavaClass item, ConditionEvents events) {
-            events.add(ConditionEvent.satisfied("I'm always satisfied"));
+            events.add(SimpleConditionEvent.satisfied(item, "I'm always satisfied"));
         }
     };
 

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ClassCacheTest.java
Patch:
@@ -98,6 +98,7 @@ public void filters_urls() {
     }
 
     @Test
+    @SuppressWarnings("unchecked")
     public void non_existing_packages_are_ignored() {
         JavaClasses first = cache.getClassesToAnalyseFor(TestClassWithNonExistingPackage.class);
         JavaClasses second = cache.getClassesToAnalyseFor(TestClassWithFilterJustByPackageOfClass.class);

File: archunit/src/main/java/com/tngtech/archunit/base/DescribedIterable.java
Patch:
@@ -1,7 +1,9 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.base;
 
 import java.util.Iterator;
 
+import com.tngtech.archunit.core.properties.HasDescription;
+
 public interface DescribedIterable<T> extends Iterable<T>, HasDescription {
     class From {
         public static <T> DescribedIterable<T> iterable(final Iterable<T> iterable, final String description) {

File: archunit/src/main/java/com/tngtech/archunit/base/Optional.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.base;
 
 import java.util.Objects;
 import java.util.Set;

File: archunit/src/main/java/com/tngtech/archunit/base/Restrictable.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.base;
 
 /**
  * Common Interface for types that allow a restriction by predicates,<br>

File: archunit/src/main/java/com/tngtech/archunit/core/AccessContext.java
Patch:
@@ -9,6 +9,7 @@
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
+import com.tngtech.archunit.base.Function;
 
 class AccessContext {
     final SetMultimap<JavaClass, JavaFieldAccess> fieldAccessesByTarget = HashMultimap.create();
@@ -72,7 +73,7 @@ private Function<JavaClass, Set<JavaFieldAccess>> fieldAccessTargetResolvesTo(fi
                 public Set<JavaFieldAccess> apply(JavaClass input) {
                     Set<JavaFieldAccess> result = new HashSet<>();
                     for (JavaFieldAccess access : fieldAccessesByTarget.get(input)) {
-                        if (access.getTarget().resolve().asSet().contains(field)) {
+                        if (access.getTarget().resolveField().asSet().contains(field)) {
                             result.add(access);
                         }
                     }

File: archunit/src/main/java/com/tngtech/archunit/core/AnnotationProxy.java
Patch:
@@ -16,6 +16,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.tngtech.archunit.base.Optional;
 
 import static com.google.common.base.Preconditions.checkArgument;
 

File: archunit/src/main/java/com/tngtech/archunit/core/ClassFileImportRecord.java
Patch:
@@ -9,6 +9,7 @@
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
+import com.tngtech.archunit.base.Optional;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: archunit/src/main/java/com/tngtech/archunit/core/ClassFileProcessor.java
Patch:
@@ -7,7 +7,8 @@
 import java.util.Set;
 
 import com.tngtech.archunit.ArchConfiguration;
-import com.tngtech.archunit.core.ArchUnitException.LocationException;
+import com.tngtech.archunit.base.ArchUnitException.LocationException;
+import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.JavaClassProcessor.AccessHandler;
 import com.tngtech.archunit.core.JavaClassProcessor.DeclarationHandler;
 import com.tngtech.archunit.core.JavaFieldAccess.AccessType;

File: archunit/src/main/java/com/tngtech/archunit/core/ClassFileSource.java
Patch:
@@ -23,7 +23,7 @@
 import com.google.common.base.Predicate;
 import com.google.common.base.Supplier;
 import com.google.common.collect.FluentIterable;
-import com.tngtech.archunit.core.ArchUnitException.LocationException;
+import com.tngtech.archunit.base.ArchUnitException.LocationException;
 
 import static com.tngtech.archunit.core.Location.newJarUrl;
 

File: archunit/src/main/java/com/tngtech/archunit/core/ClassGraphCreator.java
Patch:
@@ -7,6 +7,8 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.SetMultimap;
+import com.tngtech.archunit.base.Function;
+import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.AccessRecord.FieldAccessRecord;
 import com.tngtech.archunit.core.AccessTarget.ConstructorCallTarget;
 import com.tngtech.archunit.core.AccessTarget.MethodCallTarget;

File: archunit/src/main/java/com/tngtech/archunit/core/ClassResolver.java
Patch:
@@ -1,5 +1,7 @@
 package com.tngtech.archunit.core;
 
+import com.tngtech.archunit.base.Optional;
+
 interface ClassResolver {
     Optional<JavaClass> tryResolve(String typeName, ImportedClasses.ByTypeName importedClasses);
 }

File: archunit/src/main/java/com/tngtech/archunit/core/Dependency.java
Patch:
@@ -5,6 +5,7 @@
 import java.util.Set;
 
 import com.google.common.collect.ComparisonChain;
+import com.tngtech.archunit.core.properties.HasDescription;
 
 /**
  * Represents a dependency of one Java class on another Java class. Such a dependency can occur by either of the

File: archunit/src/main/java/com/tngtech/archunit/core/Guava.java
Patch:
@@ -3,6 +3,8 @@
 import java.util.Map;
 
 import com.google.common.base.Predicate;
+import com.tngtech.archunit.base.DescribedPredicate;
+import com.tngtech.archunit.base.Function;
 
 /**
  * NOTE: We keep Google Guava out of the public API and use the Gradle Shadow plugin to repackage the internally

File: archunit/src/main/java/com/tngtech/archunit/core/ImportContext.java
Patch:
@@ -3,6 +3,7 @@
 import java.util.Map;
 import java.util.Set;
 
+import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.AccessRecord.FieldAccessRecord;
 import com.tngtech.archunit.core.AccessTarget.MethodCallTarget;
 

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClasses.java
Patch:
@@ -8,6 +8,9 @@
 import java.util.Set;
 
 import com.google.common.collect.ImmutableMap;
+import com.tngtech.archunit.base.DescribedIterable;
+import com.tngtech.archunit.base.DescribedPredicate;
+import com.tngtech.archunit.base.Restrictable;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 

File: archunit/src/main/java/com/tngtech/archunit/core/JavaConstructor.java
Patch:
@@ -8,7 +8,7 @@
 import com.google.common.base.Supplier;
 import com.google.common.base.Suppliers;
 import com.google.common.collect.ImmutableSet;
-import com.tngtech.archunit.core.ArchUnitException.InconsistentClassPathException;
+import com.tngtech.archunit.base.ArchUnitException.InconsistentClassPathException;
 
 import static com.tngtech.archunit.core.Formatters.formatMethod;
 

File: archunit/src/main/java/com/tngtech/archunit/core/JavaMethod.java
Patch:
@@ -6,7 +6,8 @@
 
 import com.google.common.base.Supplier;
 import com.google.common.base.Suppliers;
-import com.tngtech.archunit.core.ArchUnitException.InconsistentClassPathException;
+import com.tngtech.archunit.base.ArchUnitException.InconsistentClassPathException;
+import com.tngtech.archunit.base.Optional;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.tngtech.archunit.core.Formatters.formatMethod;

File: archunit/src/main/java/com/tngtech/archunit/core/Location.java
Patch:
@@ -11,8 +11,8 @@
 import java.util.Objects;
 import java.util.jar.JarFile;
 
-import com.tngtech.archunit.core.ArchUnitException.LocationException;
-import com.tngtech.archunit.core.ArchUnitException.UnsupportedUrlProtocolException;
+import com.tngtech.archunit.base.ArchUnitException.LocationException;
+import com.tngtech.archunit.base.ArchUnitException.UnsupportedUrlProtocolException;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;

File: archunit/src/main/java/com/tngtech/archunit/core/Locations.java
Patch:
@@ -10,7 +10,7 @@
 import java.util.Set;
 
 import com.google.common.collect.ImmutableSet;
-import com.tngtech.archunit.core.ArchUnitException.LocationException;
+import com.tngtech.archunit.base.ArchUnitException.LocationException;
 
 public class Locations {
     public static Collection<Location> of(Collection<URL> urls) {

File: archunit/src/main/java/com/tngtech/archunit/core/Source.java
Patch:
@@ -8,6 +8,7 @@
 
 import com.google.common.io.ByteStreams;
 import com.tngtech.archunit.ArchConfiguration;
+import com.tngtech.archunit.base.Optional;
 
 /**
  * Contains information about an imported class, i.e. the URI from where the class was imported and an md5 sum

File: archunit/src/main/java/com/tngtech/archunit/core/properties/HasDescription.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.core.properties;
 
 public interface HasDescription {
     String getDescription();

File: archunit/src/main/java/com/tngtech/archunit/lang/ConditionEvents.java
Patch:
@@ -30,7 +30,7 @@ public boolean isEmpty() {
         return getAllowed().isEmpty() && getViolating().isEmpty();
     }
 
-    public void describeFailuresTo(FailureMessages messages) {
+    public void describeFailuresTo(CollectsLines messages) {
         for (ConditionEvent event : getViolating()) {
             event.describeTo(messages);
         }

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/AccessPackageCondition.java
Patch:
@@ -5,10 +5,11 @@
 
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
+import com.tngtech.archunit.base.PackageMatcher;
 import com.tngtech.archunit.core.JavaAccess;
 import com.tngtech.archunit.lang.ArchCondition;
-import com.tngtech.archunit.lang.ConditionEvent;
 import com.tngtech.archunit.lang.ConditionEvents;
+import com.tngtech.archunit.lang.SimpleConditionEvent;
 
 class AccessPackageCondition extends ArchCondition<JavaAccess<?>> {
     private final List<PackageMatcher> packageMatchers = new ArrayList<>();
@@ -46,7 +47,7 @@ public void check(JavaAccess<?> item, ConditionEvents events) {
         for (PackageMatcher matcher : packageMatchers) {
             matches = matches || matcher.matches(getPackage.apply(item));
         }
-        events.add(new ConditionEvent(matches, item.getDescription()));
+        events.add(new SimpleConditionEvent<>(item, matches, item.getDescription()));
     }
 
     static class Creator {

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ClassAccessesFieldCondition.java
Patch:
@@ -2,7 +2,7 @@
 
 import java.util.Collection;
 
-import com.tngtech.archunit.core.DescribedPredicate;
+import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.core.JavaClass;
 import com.tngtech.archunit.core.JavaFieldAccess;
 import com.tngtech.archunit.lang.conditions.FieldAccessCondition.FieldGetAccessCondition;

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/JavaAccessCondition.java
Patch:
@@ -1,10 +1,10 @@
 package com.tngtech.archunit.lang.conditions;
 
-import com.tngtech.archunit.core.DescribedPredicate;
+import com.tngtech.archunit.base.DescribedPredicate;
 import com.tngtech.archunit.core.JavaAccess;
 import com.tngtech.archunit.lang.ArchCondition;
-import com.tngtech.archunit.lang.ConditionEvent;
 import com.tngtech.archunit.lang.ConditionEvents;
+import com.tngtech.archunit.lang.SimpleConditionEvent;
 
 class JavaAccessCondition extends ArchCondition<JavaAccess<?>> {
     private final DescribedPredicate<JavaAccess<?>> predicate;
@@ -16,6 +16,6 @@ class JavaAccessCondition extends ArchCondition<JavaAccess<?>> {
 
     @Override
     public void check(JavaAccess<?> item, ConditionEvents events) {
-        events.add(new ConditionEvent(predicate.apply(item), item.getDescription()));
+        events.add(new SimpleConditionEvent<>(item, predicate.apply(item), item.getDescription()));
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Slice.java
Patch:
@@ -9,8 +9,8 @@
 import com.google.common.collect.ForwardingSet;
 import com.google.common.collect.ImmutableSet;
 import com.tngtech.archunit.core.Dependency;
-import com.tngtech.archunit.core.HasDescription;
 import com.tngtech.archunit.core.JavaClass;
+import com.tngtech.archunit.core.properties.HasDescription;
 
 import static com.google.common.base.Preconditions.checkArgument;
 

File: archunit/src/test/java/com/tngtech/archunit/core/ClassFileProcessorTest.java
Patch:
@@ -1,5 +1,6 @@
 package com.tngtech.archunit.core;
 
+import com.tngtech.archunit.base.Optional;
 import com.tngtech.archunit.core.ClassFileProcessor.ClassResolverFromClassPath;
 import com.tngtech.archunit.core.JavaClassProcessor.DeclarationHandler;
 import org.junit.Test;

File: archunit/src/test/java/com/tngtech/archunit/core/JavaClassesTest.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.tngtech.archunit.base.DescribedPredicate;
 import org.junit.Test;
 
 import static com.tngtech.archunit.core.TestUtils.javaClassViaReflection;

File: archunit/src/test/java/com/tngtech/archunit/core/OptionalTest.java
Patch:
@@ -1,5 +1,7 @@
 package com.tngtech.archunit.core;
 
+import com.tngtech.archunit.base.Function;
+import com.tngtech.archunit.base.Optional;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;

File: archunit/src/test/java/com/tngtech/archunit/lang/ConditionEventsTest.java
Patch:
@@ -15,8 +15,8 @@ public class ConditionEventsTest {
     @DataProvider
     public static Object[][] eventsWithEmpty() {
         return $$(
-                $(events(ConditionEvent.satisfied("irrelevant")), false),
-                $(events(ConditionEvent.violated("irrelevant")), false),
+                $(events(SimpleConditionEvent.satisfied("irrelevant", "irrelevant")), false),
+                $(events(SimpleConditionEvent.violated("irrelevant", "irrelevant")), false),
                 $(new ConditionEvents(), true));
     }
 

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/ClassAccessesFieldConditionTest.java
Patch:
@@ -100,7 +100,7 @@ static class PositiveTestCase extends TestCase<PositiveTestCase> {
     static class NegativeTestCase extends TestCase<NegativeTestCase> {
     }
 
-    static abstract class TestCase<SELF extends TestCase> {
+    abstract static class TestCase<SELF extends TestCase> {
         AccessInfo accessInfo;
         ArchCondition<JavaClass> condition;
 

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/ContainsOnlyConditionTest.java
Patch:
@@ -6,6 +6,7 @@
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.ConditionEvent;
 import com.tngtech.archunit.lang.ConditionEvents;
+import com.tngtech.archunit.lang.SimpleConditionEvent;
 import org.junit.Test;
 
 import static com.tngtech.archunit.lang.conditions.ArchConditions.containOnlyElementsThat;
@@ -14,14 +15,14 @@
 import static java.util.Collections.emptyList;
 
 public class ContainsOnlyConditionTest {
-    static final List<SerializableObject> TWO_SERIALIZABLE_OBJECTS = asList(new SerializableObject(), new SerializableObject());
+    private static final List<SerializableObject> TWO_SERIALIZABLE_OBJECTS = asList(new SerializableObject(), new SerializableObject());
     static final List<Object> ONE_SERIALIZABLE_AND_ONE_NON_SERIALIZABLE_OBJECT = asList(new SerializableObject(), new Object());
 
     static final ArchCondition<Object> IS_SERIALIZABLE = new ArchCondition<Object>("be serializable") {
         @Override
         public void check(Object item, ConditionEvents events) {
             boolean satisfied = item instanceof Serializable;
-            events.add(new ConditionEvent(satisfied, isSerializableMessageFor(item.getClass())));
+            events.add(new SimpleConditionEvent<>(item, satisfied, isSerializableMessageFor(item.getClass())));
         }
     };
 

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/SlicesTest.java
Patch:
@@ -6,8 +6,8 @@
 import java.util.regex.Pattern;
 
 import com.google.common.collect.ImmutableSet;
+import com.tngtech.archunit.base.DescribedIterable;
 import com.tngtech.archunit.core.Dependency;
-import com.tngtech.archunit.core.DescribedIterable;
 import com.tngtech.archunit.core.JavaClasses;
 import com.tngtech.archunit.core.JavaMethod;
 import org.junit.Test;

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClass.java
Patch:
@@ -481,7 +481,7 @@ void completeClassHierarchyFrom(ImportContext context) {
             @Override
             public Set<JavaField> get() {
                 ImmutableSet.Builder<JavaField> result = ImmutableSet.builder();
-                for (JavaClass javaClass : getClassHierarchy()) {
+                for (JavaClass javaClass : concat(getClassHierarchy(), getAllInterfaces())) {
                     result.addAll(javaClass.getFields());
                 }
                 return result.build();

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/junit/RuleSetsTest.java
Patch:
@@ -10,8 +10,8 @@
 @AnalyseClasses(packages = "com.tngtech.archunit.example")
 public class RuleSetsTest {
     @ArchTest
-    public static final ArchRules<?> CODING_RULES = ArchRules.in(CodingRulesWithRunnerTest.class);
+    public static final ArchRules CODING_RULES = ArchRules.in(CodingRulesWithRunnerTest.class);
 
     @ArchTest
-    public static final ArchRules<?> CYCLIC_DEPENDENCY_RULES = ArchRules.in(CyclicDependencyRulesTest.class);
+    public static final ArchRules CYCLIC_DEPENDENCY_RULES = ArchRules.in(CyclicDependencyRulesTest.class);
 }

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ArchUnitRunner.java
Patch:
@@ -64,10 +64,10 @@ private Set<ArchTestExecution> findArchRulesIn(FrameworkField ruleField) {
         return Collections.<ArchTestExecution>singleton(new ArchRuleExecution(getTestClass().getJavaClass(), ruleField.getField()));
     }
 
-    private ArchRules<?> getArchRules(FrameworkField ruleField) {
+    private ArchRules getArchRules(FrameworkField ruleField) {
         ArchTestExecution.validate(ruleField.getField());
         try {
-            return (ArchRules<?>) ruleField.get(null);
+            return (ArchRules) ruleField.get(null);
         } catch (IllegalAccessException e) {
             throw new RuntimeException(e);
         }

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsRuleSetsTest.java
Patch:
@@ -99,7 +99,7 @@ public static class ArchTestWithRuleLibrary {
         public static final String someOtherMethodRuleName = "someOtherMethodRule";
 
         @ArchTest
-        public static final ArchRules<JavaClass> rules = ArchRules.in(ArchTestWithRuleSet.class);
+        public static final ArchRules rules = ArchRules.in(ArchTestWithRuleSet.class);
 
         @ArchTest
         public static void someOtherMethodRule(JavaClasses classes) {
@@ -109,7 +109,7 @@ public static void someOtherMethodRule(JavaClasses classes) {
     @AnalyseClasses(packages = "some.pkg")
     public static class ArchTestWithRuleSet {
         @ArchTest
-        public static final ArchRules<JavaClass> rules = ArchRules.in(Rules.class);
+        public static final ArchRules rules = ArchRules.in(Rules.class);
     }
 
     public static class Rules {

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenClasses.java
Patch:
@@ -8,5 +8,6 @@ public interface GivenClasses extends GivenObjects<JavaClass> {
 
     GivenClassesThat that();
 
-    GivenConjunction<JavaClass> that(DescribedPredicate<? super JavaClass> predicate);
+    @Override
+    GivenClassesConjunction that(DescribedPredicate<? super JavaClass> predicate);
 }

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClass.java
Patch:
@@ -51,7 +51,7 @@ private JavaClass(Builder builder) {
         source = checkNotNull(builder.source);
         javaType = checkNotNull(builder.javaType);
         isInterface = builder.isInterface;
-        modifiers = builder.modifiers;
+        modifiers = checkNotNull(builder.modifiers);
         reflectSupplier = Suppliers.memoize(new ReflectClassSupplier());
     }
 
@@ -616,7 +616,7 @@ static final class Builder {
         private Optional<Source> source = Optional.absent();
         private JavaType javaType;
         private boolean isInterface;
-        private Set<JavaModifier> modifiers;
+        private Set<JavaModifier> modifiers = new HashSet<>();
 
         Builder withSource(Source source) {
             this.source = Optional.of(source);

File: archunit/src/test/java/com/tngtech/archunit/core/JavaTypeTest.java
Patch:
@@ -33,6 +33,7 @@ public void asm_object_type() {
     public void primitive_types_by_name_and_descriptor(String name, Class<?> expected) {
         JavaType primitiveType = JavaType.From.name(name);
         assertThat(primitiveType.isPrimitive()).isTrue();
+        assertThat(primitiveType.isArray()).isFalse();
         assertThat(primitiveType.tryGetComponentType()).isAbsent();
 
         assertThat(primitiveType).isEquivalentTo(expected);
@@ -43,6 +44,7 @@ public void primitive_types_by_name_and_descriptor(String name, Class<?> expecte
     public void array_types_by_name_and_canonical_name(String name, Class<?> expected) {
         JavaType arrayType = JavaType.From.name(name);
         assertThat(arrayType.isPrimitive()).isFalse();
+        assertThat(arrayType.isArray()).isTrue();
         assertThat(arrayType.tryGetComponentType()).contains(JavaType.From.name(expected.getComponentType().getName()));
 
         assertThat(arrayType).isEquivalentTo(expected);
@@ -52,6 +54,7 @@ public void array_types_by_name_and_canonical_name(String name, Class<?> expecte
     public void object_name() {
         JavaType objectType = JavaType.From.name(Object.class.getName());
         assertThat(objectType.isPrimitive()).isFalse();
+        assertThat(objectType.isArray()).isFalse();
         assertThat(objectType.tryGetComponentType()).isAbsent();
 
         assertThat(objectType).isEquivalentTo(Object.class);

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/DaoRulesTest.java
Patch:
@@ -11,9 +11,10 @@
 import org.junit.Test;
 
 import static com.tngtech.archunit.core.properties.CanBeAnnotated.Predicates.annotatedWith;
-import static com.tngtech.archunit.core.properties.HasName.Predicates.withNameMatching;
+import static com.tngtech.archunit.core.properties.HasName.Predicates.nameMatching;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.resideInAPackage;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.are;
+import static com.tngtech.archunit.lang.conditions.ArchPredicates.have;
 import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.allClasses;
 
 public class DaoRulesTest {
@@ -27,7 +28,7 @@ public void setUp() throws Exception {
     @Ignore
     @Test
     public void DAOs_must_reside_in_a_dao_package() {
-        allClasses().that(withNameMatching(".*Dao")).should(resideInAPackage("..dao.."))
+        allClasses().that(have(nameMatching(".*Dao"))).should(resideInAPackage("..dao.."))
                 .as("DAOs should reside in a package '..dao..'").check(classes);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/JavaAccess.java
Patch:
@@ -112,8 +112,8 @@ private JavaClass getLocationClass() {
     protected abstract String descriptionTemplate();
 
     public static class Predicates {
-        public static DescribedPredicate<JavaAccess<?>> withOrigin(DescribedPredicate<? super JavaCodeUnit> predicate) {
-            return predicate.onResultOf(Functions.Get.origin());
+        public static DescribedPredicate<JavaAccess<?>> origin(DescribedPredicate<? super JavaCodeUnit> predicate) {
+            return predicate.onResultOf(Functions.Get.origin()).as("origin " + predicate.getDescription());
         }
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClass.java
Patch:
@@ -539,8 +539,8 @@ public boolean apply(JavaClass input) {
             }
         };
 
-        public static DescribedPredicate<JavaClass> withType(final Class<?> type) {
-            return equalTo(type.getName()).<JavaClass>onResultOf(GET_NAME).as("with type " + type.getName());
+        public static DescribedPredicate<JavaClass> type(final Class<?> type) {
+            return equalTo(type.getName()).<JavaClass>onResultOf(GET_NAME).as("type " + type.getName());
         }
 
         public static DescribedPredicate<JavaClass> assignableTo(final Class<?> type) {

File: archunit/src/main/java/com/tngtech/archunit/core/RawAccessRecord.java
Patch:
@@ -18,7 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.tngtech.archunit.core.JavaConstructor.CONSTRUCTOR_NAME;
-import static com.tngtech.archunit.core.properties.HasName.Predicates.withNameMatching;
+import static com.tngtech.archunit.core.properties.HasName.Predicates.nameMatching;
 import static java.util.Collections.singleton;
 import static java.util.Collections.singletonList;
 import static java.util.regex.Pattern.quote;
@@ -181,7 +181,7 @@ private static class ClassHierarchyPath {
 
             private ClassHierarchyPath(JavaType childType, JavaClass parent) {
                 Set<JavaClass> classesToSearchForChild = Sets.union(singleton(parent), parent.getAllSubClasses());
-                Optional<JavaClass> child = tryFind(classesToSearchForChild, withNameMatching(quote(childType.getName())));
+                Optional<JavaClass> child = tryFind(classesToSearchForChild, nameMatching(quote(childType.getName())));
                 if (child.isPresent()) {
                     createPath(child.get(), parent);
                 }

File: archunit/src/main/java/com/tngtech/archunit/core/properties/HasModifiers.java
Patch:
@@ -9,8 +9,8 @@ public interface HasModifiers {
     Set<JavaModifier> getModifiers();
 
     class Predicates {
-        public static DescribedPredicate<HasModifiers> withModifier(final JavaModifier modifier) {
-            return new DescribedPredicate<HasModifiers>("with modifier " + modifier) {
+        public static DescribedPredicate<HasModifiers> modifier(final JavaModifier modifier) {
+            return new DescribedPredicate<HasModifiers>("modifier " + modifier) {
                 @Override
                 public boolean apply(HasModifiers input) {
                     return input.getModifiers().contains(modifier);

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ArchConditions.java
Patch:
@@ -18,7 +18,7 @@
 
 import static com.tngtech.archunit.core.JavaClass.Predicates.assignableTo;
 import static com.tngtech.archunit.core.JavaFieldAccess.Predicates.fieldAccessTarget;
-import static com.tngtech.archunit.core.properties.HasName.Predicates.withName;
+import static com.tngtech.archunit.core.properties.HasName.Predicates.name;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.callTarget;
 
 public final class ArchConditions {
@@ -109,8 +109,8 @@ public static <T> ArchCondition<Collection<? extends T>> containOnlyElementsThat
     }
 
     private static DescribedPredicate<JavaFieldAccess> ownerAndNameAre(final Class<?> target, final String fieldName) {
-        return fieldAccessTarget(With.<JavaClass>owner(withName(target.getName())))
-                .and(fieldAccessTarget(withName(fieldName)))
+        return fieldAccessTarget(With.<JavaClass>owner(name(target.getName())))
+                .and(fieldAccessTarget(name(fieldName)))
                 .as(target.getName() + "." + fieldName);
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/ClassFileImporterTest.java
Patch:
@@ -137,7 +137,7 @@
 import static com.google.common.collect.Iterables.getFirst;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Sets.newHashSet;
-import static com.tngtech.archunit.core.JavaClass.Predicates.withType;
+import static com.tngtech.archunit.core.JavaClass.Predicates.type;
 import static com.tngtech.archunit.core.JavaConstructor.CONSTRUCTOR_NAME;
 import static com.tngtech.archunit.core.JavaFieldAccess.AccessType.GET;
 import static com.tngtech.archunit.core.JavaFieldAccess.AccessType.SET;
@@ -1520,7 +1520,7 @@ public void imports_urls_of_jars() throws IOException {
                 "jar".equals(urls.iterator().next().getProtocol()));
 
         JavaClasses classes = new ClassFileImporter().importUrls(urls)
-                .that(DescribedPredicate.not(withType(Annotation.class))); // NOTE @Test and @RunWith implement Annotation.class
+                .that(DescribedPredicate.not(type(Annotation.class))); // NOTE @Test and @RunWith implement Annotation.class
 
         assertThat(classes).as("Number of classes at the given URLs").hasSize(2);
     }

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/ArchConditionsTest.java
Patch:
@@ -22,7 +22,7 @@
 import static com.tngtech.archunit.core.TestUtils.javaMethodViaReflection;
 import static com.tngtech.archunit.core.TestUtils.predicateWithDescription;
 import static com.tngtech.archunit.core.TestUtils.simulateCall;
-import static com.tngtech.archunit.core.properties.HasName.Predicates.withNameMatching;
+import static com.tngtech.archunit.core.properties.HasName.Predicates.nameMatching;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.accessClass;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.accessClassesThatResideIn;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.accessClassesThatResideInAnyPackage;
@@ -68,11 +68,11 @@ public void access_class() {
         JavaClass clazz = javaClassViaReflection(CallingClass.class);
         JavaCall<?> call = simulateCall().from(clazz, "call").to(SomeSuperClass.class, "callMe");
 
-        ConditionEvents events = check(never(accessClass(withNameMatching(".*Some.*"))), clazz);
+        ConditionEvents events = check(never(accessClass(nameMatching(".*Some.*"))), clazz);
 
         assertThat(events).containViolations(call.getDescription());
 
-        events = check(never(accessClass(withNameMatching(".*Wong.*"))), clazz);
+        events = check(never(accessClass(nameMatching(".*Wong.*"))), clazz);
 
         assertThat(events).containNoViolation();
     }

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/FieldAccessConditionTest.java
Patch:
@@ -15,7 +15,7 @@
 import static com.tngtech.archunit.core.JavaFieldAccess.AccessType.GET;
 import static com.tngtech.archunit.core.JavaFieldAccess.AccessType.SET;
 import static com.tngtech.archunit.core.JavaFieldAccess.Predicates.fieldAccessTarget;
-import static com.tngtech.archunit.core.properties.HasName.Predicates.withName;
+import static com.tngtech.archunit.core.properties.HasName.Predicates.name;
 import static com.tngtech.archunit.lang.conditions.testobjects.TestObjects.CALLER_CLASS;
 import static com.tngtech.archunit.lang.conditions.testobjects.TestObjects.TARGET_CLASS;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -82,7 +82,7 @@ public void condition_satisfied_on_access_field() {
     }
 
     private static DescribedPredicate<JavaFieldAccess> nameIs(final String fieldName) {
-        return fieldAccessTarget(withName(fieldName)).as("name is" + fieldName);
+        return fieldAccessTarget(name(fieldName)).as("name is" + fieldName);
     }
 
     private String messageOf(Collection<ConditionEvent> events) {

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/SessionBeanRulesIntegrationTest.java
Patch:
@@ -26,7 +26,7 @@ public class SessionBeanRulesIntegrationTest extends SessionBeanRulesTest {
     @Test
     @Override
     public void stateless_session_beans_should_not_have_state() {
-        expectedViolation.ofRule("Stateless Session Beans should not have state")
+        expectedViolation.ofRule("No Stateless Session Bean should have state")
                 .byAccess(from(ClassViolatingSessionBeanRules.class, "setState", String.class)
                         .setting().field(ClassViolatingSessionBeanRules.class, "state")
                         .inLine(25));
@@ -37,7 +37,7 @@ public void stateless_session_beans_should_not_have_state() {
     @Test
     @Override
     public void business_interface_implementations_should_be_unique() {
-        expectedViolation.ofRule("Business Interfaces should have an unique implementation")
+        expectedViolation.ofRule("classes that are business interfaces should have an unique implementation")
                 .by(SOME_BUSINESS_INTERFACE_IS_IMPLEMENTED_BY_TWO_BEANS);
 
         super.business_interface_implementations_should_be_unique();

File: archunit/src/main/java/com/tngtech/archunit/lang/ConfiguredMessageFormat.java
Patch:
@@ -3,7 +3,6 @@
 import java.util.Collection;
 
 import com.google.common.base.Joiner;
-import com.tngtech.archunit.base.DescribedIterable;
 import com.tngtech.archunit.core.properties.HasDescription;
 
 class ConfiguredMessageFormat {
@@ -20,7 +19,7 @@ String formatFailure(HasDescription rule, Collection<String> failureMessages, Pr
         return priorityPrefix + message;
     }
 
-    <T> String formatRuleText(DescribedIterable<T> itemsUnderTest, ArchCondition<T> condition) {
+    <T> String formatRuleText(HasDescription itemsUnderTest, ArchCondition<T> condition) {
         return String.format("%s should %s", itemsUnderTest.getDescription(), condition.getDescription());
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/GivenClassesInternal.java
Patch:
@@ -10,11 +10,13 @@
 import com.tngtech.archunit.lang.Priority;
 import com.tngtech.archunit.lang.syntax.elements.ClassesShould;
 import com.tngtech.archunit.lang.syntax.elements.GivenClasses;
+import com.tngtech.archunit.lang.syntax.elements.GivenClassesConjunction;
 import com.tngtech.archunit.lang.syntax.elements.GivenClassesThat;
 
 import static java.util.Collections.singletonList;
 
-class GivenClassesInternal extends AbstractGivenObjects<JavaClass, GivenClassesInternal> implements GivenClasses {
+class GivenClassesInternal extends AbstractGivenObjects<JavaClass, GivenClassesInternal>
+        implements GivenClasses, GivenClassesConjunction {
 
     GivenClassesInternal(Priority priority, ClassesTransformer<JavaClass> classesTransformer) {
         this(priority, classesTransformer, Functions.<ArchCondition<JavaClass>>identity());

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/OnlyBeAccessedSpecificationInternal.java
Patch:
@@ -1,19 +1,19 @@
 package com.tngtech.archunit.lang.syntax;
 
-import com.tngtech.archunit.lang.syntax.elements.ClassesShould;
 import com.tngtech.archunit.lang.syntax.elements.OnlyBeAccessedSpecification;
+import com.tngtech.archunit.lang.syntax.elements.ShouldConjunction;
 
 import static com.tngtech.archunit.lang.conditions.ArchConditions.onlyBeAccessedByAnyPackage;
 
-class OnlyBeAccessedSpecificationInternal implements OnlyBeAccessedSpecification {
+class OnlyBeAccessedSpecificationInternal implements OnlyBeAccessedSpecification<ShouldConjunction> {
     private final ClassesShouldInternal classesShould;
 
     OnlyBeAccessedSpecificationInternal(ClassesShouldInternal classesShould) {
         this.classesShould = classesShould;
     }
 
     @Override
-    public ClassesShould byAnyPackage(String... packageIdentifiers) {
+    public ShouldConjunction byAnyPackage(String... packageIdentifiers) {
         return classesShould.copyWithCondition(onlyBeAccessedByAnyPackage(packageIdentifiers));
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/ClassesShouldThat.java
Patch:
@@ -1,4 +1,4 @@
 package com.tngtech.archunit.lang.syntax.elements;
 
-public interface ClassesShouldThat extends ClassesThat<ClassesShouldThat>, ClassesShould {
+public interface ClassesShouldThat extends ClassesThat<ShouldConjunction> {
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenClasses.java
Patch:
@@ -8,5 +8,5 @@ public interface GivenClasses extends GivenObjects<JavaClass> {
 
     GivenClassesThat that();
 
-    GivenClasses that(DescribedPredicate<? super JavaClass> predicate);
+    GivenConjunction<JavaClass> that(DescribedPredicate<? super JavaClass> predicate);
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenClassesThat.java
Patch:
@@ -1,5 +1,4 @@
 package com.tngtech.archunit.lang.syntax.elements;
 
-public interface GivenClassesThat extends ClassesThat<GivenClassesThat> {
-    ClassesShould should();
+public interface GivenClassesThat extends ClassesThat<GivenClassesConjunction> {
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/GivenObjects.java
Patch:
@@ -7,7 +7,5 @@
 public interface GivenObjects<T> {
     ArchRule should(ArchCondition<T> condition);
 
-    GivenObjects<T> as(String description);
-
-    GivenObjects<T> that(DescribedPredicate<? super T> predicate);
+    GivenConjunction<T> that(DescribedPredicate<? super T> predicate);
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/syntax/elements/OnlyBeAccessedSpecification.java
Patch:
@@ -1,5 +1,5 @@
 package com.tngtech.archunit.lang.syntax.elements;
 
-public interface OnlyBeAccessedSpecification {
-    ClassesShould byAnyPackage(String... packageIdentifiers);
+public interface OnlyBeAccessedSpecification<CONJUNCTION extends Conjunction> {
+    CONJUNCTION byAnyPackage(String... packageIdentifiers);
 }

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/junit/RuleSetsTest.java
Patch:
@@ -13,5 +13,5 @@ public class RuleSetsTest {
     public static final ArchRules<?> CODING_RULES = ArchRules.in(CodingRulesWithRunnerTest.class);
 
     @ArchTest
-    public static final ArchRules<?> CYCLIC_DEPENDENCY_RULES = ArchRules.in(CyclicDependencyRulesWithRunnerTest.class);
+    public static final ArchRules<?> CYCLIC_DEPENDENCY_RULES = ArchRules.in(CyclicDependencyRulesTest.class);
 }

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/CyclicErrorMatcher.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.integration;
+package com.tngtech.archunit.integration.junit;
 
 import java.util.ArrayList;
 import java.util.Collection;

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/junit/SlicesIsolationIntegrationTest.java
Patch:
@@ -23,7 +23,7 @@ public class SlicesIsolationIntegrationTest {
             SlicesIsolationTest.controllers_should_only_use_their_own_slice;
 
     static void expectViolationFromDependencies(ExpectedViolation expectViolation) {
-        expectViolation.ofRule("Controllers should only depend on their own slice")
+        expectViolation.ofRule("Controllers should not depend on each other")
                 .by(sliceDependency()
                         .described("Controller one calls Controller two")
                         .byAccess(from(UseCaseOneController.class, doSomethingOne)

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ArchRuleExecution.java
Patch:
@@ -61,7 +61,7 @@ private static ArchRule asArchRule(Object ruleCandidate) {
 
         private static RuleEvaluationException fieldTypeFailure(Field ruleField) {
             String hint = String.format("Only fields of type %s may be annotated with @%s",
-                    ArchRule.class.getName(), ArchTest.class.getName());
+                    ArchRule.class.getSimpleName(), ArchTest.class.getSimpleName());
             String problem = String.format("Cannot evaluate @%s on field %s.%s",
                     ArchTest.class.getSimpleName(), ruleField.getDeclaringClass().getName(), ruleField.getName());
             return new RuleEvaluationException(hint + problem);

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsMethodsTest.java
Patch:
@@ -27,6 +27,7 @@
 import static com.tngtech.archunit.junit.ArchUnitRunnerTestUtils.newRunnerFor;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -63,6 +64,7 @@ public void setUp() {
     @Test
     public void executes_test_methods_and_supplies_JavaClasses() throws InitializationError {
         runner.runChild(getRule(testSomething, runner), runNotifier);
+        verify(runNotifier, never()).fireTestFailure(any(Failure.class));
         verify(runNotifier).fireTestFinished(descriptionCaptor.capture());
         assertThat(descriptionCaptor.getAllValues()).extractingResultOf("getMethodName")
                 .contains(testSomething);

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/FieldAccessCondition.java
Patch:
@@ -12,8 +12,8 @@
 
 import static com.tngtech.archunit.core.JavaFieldAccess.AccessType.GET;
 import static com.tngtech.archunit.core.JavaFieldAccess.AccessType.SET;
+import static com.tngtech.archunit.core.JavaFieldAccess.Predicates.accessType;
 import static com.tngtech.archunit.core.JavaFieldAccess.getDescriptionTemplateFor;
-import static com.tngtech.archunit.lang.conditions.ArchPredicates.accessType;
 import static java.util.Collections.singleton;
 
 class FieldAccessCondition extends ArchCondition<JavaFieldAccess> {

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ExpectedViolation.java
Patch:
@@ -241,7 +241,7 @@ private Member(Class<?> clazz, String memberName, Class<?>[] paramTypes) {
             this.clazz = clazz;
             this.memberName = memberName;
             for (Class<?> paramType : paramTypes) {
-                params.add(String.format("%s.class", paramType.getSimpleName()));
+                params.add(paramType.getName());
             }
         }
 

File: archunit/src/main/java/com/tngtech/archunit/core/AccessTarget.java
Patch:
@@ -11,7 +11,7 @@
 import com.tngtech.archunit.core.properties.CanBeAnnotated;
 import com.tngtech.archunit.core.properties.HasName;
 import com.tngtech.archunit.core.properties.HasOwner;
-import com.tngtech.archunit.core.properties.HasParameters;
+import com.tngtech.archunit.core.properties.HasParameterTypes;
 import com.tngtech.archunit.core.properties.HasReturnType;
 import com.tngtech.archunit.core.properties.HasType;
 
@@ -125,7 +125,7 @@ public Set<JavaField> resolve() {
         }
     }
 
-    public static abstract class CodeUnitCallTarget extends AccessTarget implements HasParameters, HasReturnType {
+    public static abstract class CodeUnitCallTarget extends AccessTarget implements HasParameterTypes, HasReturnType {
         private final ImmutableList<JavaClass> parameters;
         private final JavaClass returnType;
 

File: archunit/src/main/java/com/tngtech/archunit/core/JavaCodeUnit.java
Patch:
@@ -10,7 +10,7 @@
 import com.tngtech.archunit.core.AccessRecord.FieldAccessRecord;
 import com.tngtech.archunit.core.AccessTarget.ConstructorCallTarget;
 import com.tngtech.archunit.core.AccessTarget.MethodCallTarget;
-import com.tngtech.archunit.core.properties.HasParameters;
+import com.tngtech.archunit.core.properties.HasParameterTypes;
 import com.tngtech.archunit.core.properties.HasReturnType;
 
 import static com.tngtech.archunit.core.Formatters.formatMethod;
@@ -25,7 +25,7 @@
  * in particular every place, where Java code with behavior, like calling other methods or accessing fields, can
  * be defined.
  */
-public abstract class JavaCodeUnit extends JavaMember implements HasParameters, HasReturnType {
+public abstract class JavaCodeUnit extends JavaMember implements HasParameterTypes, HasReturnType {
     private final JavaClass returnType;
     private final List<JavaClass> parameters;
     private final String fullName;

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ArchConditions.java
Patch:
@@ -121,7 +121,7 @@ public ArchCondition<JavaClass> inHierarchyOf(Class<?> type) {
             return callMethodWhere(callTarget()
                     .isDeclaredIn(theHierarchyOf(type))
                     .hasName(methodName)
-                    .hasParameters(params));
+                    .hasParameterTypes(params));
         }
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/ClassFileImporterTest.java
Patch:
@@ -1548,7 +1548,7 @@ public void imports_classes_outside_of_the_classpath() throws IOException {
         assertThat(middleClass.isInterface()).as("is interface").isFalse();
         assertThatCall(findAnyByName(middleClass.getMethodCallsFromSelf(), "println"))
                 .isFrom(middleClass.getMethod("overrideMe"))
-                .isTo(targetWithFullName(PrintStream.class.getName() + ".println(String.class)"))
+                .isTo(targetWithFullName(String.format("%s.println(%s)", PrintStream.class.getName(), String.class.getName())))
                 .inLineNumber(12);
         assertThatCall(findAnyByName(middleClass.getMethodCallsFromSelf(), "getSomeString"))
                 .isFrom(middleClass.getMethod("overrideMe"))

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -38,7 +38,7 @@
 import org.assertj.core.api.AbstractIterableAssert;
 import org.assertj.core.api.AbstractListAssert;
 import org.assertj.core.api.AbstractObjectAssert;
-import org.assertj.core.internal.cglib.asm.Type;
+import org.objectweb.asm.Type;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Lists.newArrayList;

File: archunit/src/main/java/com/tngtech/archunit/core/JavaCodeUnit.java
Patch:
@@ -106,6 +106,7 @@ static Class<?>[] reflect(JavaClassList parameters) {
     }
 
     abstract static class Builder<OUTPUT, SELF extends Builder<OUTPUT, SELF>> extends JavaMember.Builder<OUTPUT, SELF> {
+        // FIXME: Use JavaType instead of ASM Type
         private Type returnType;
         private Type[] parameters;
 

File: archunit/src/main/java/com/tngtech/archunit/lang/ConditionEvent.java
Patch:
@@ -26,7 +26,7 @@ public void addInvertedTo(ConditionEvents events) {
         events.add(new ConditionEvent(!conditionSatisfied, message));
     }
 
-    public void describeTo(FailureMessages messages) {
+    public void describeTo(CollectsLines messages) {
         messages.add(message);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/lang/ConditionEvents.java
Patch:
@@ -30,7 +30,7 @@ public boolean isEmpty() {
         return getAllowed().isEmpty() && getViolating().isEmpty();
     }
 
-    public void describeFailuresTo(FailureMessages messages) {
+    public void describeFailuresTo(CollectsLines messages) {
         for (ConditionEvent event : getViolating()) {
             event.describeTo(messages);
         }

File: archunit/src/main/java/com/tngtech/archunit/lang/ConfiguredMessageFormat.java
Patch:
@@ -1,5 +1,7 @@
 package com.tngtech.archunit.lang;
 
+import java.util.Collection;
+
 import com.google.common.base.Joiner;
 import com.tngtech.archunit.base.DescribedIterable;
 import com.tngtech.archunit.core.properties.HasDescription;
@@ -11,7 +13,7 @@ static ConfiguredMessageFormat get() {
         return instance;
     }
 
-    String formatFailure(HasDescription rule, FailureMessages failureMessages, Priority priority) {
+    String formatFailure(HasDescription rule, Collection<String> failureMessages, Priority priority) {
         String violationTexts = Joiner.on(System.lineSeparator()).join(failureMessages);
         String priorityPrefix = String.format("Architecture Violation [Priority: %s] - ", priority.asString());
         String message = String.format("Rule '%s' was violated:%n%s", rule.getDescription(), violationTexts);

File: archunit/src/test/java/com/tngtech/archunit/core/TestUtils.java
Patch:
@@ -175,9 +175,8 @@ public static JavaClasses javaClassesViaReflection(Class<?>... classes) {
         ImportContext context = simulateContextForCompletion(importedClasses);
         for (JavaClass javaClass : result.values()) {
             javaClass.completeClassHierarchyFrom(context);
-            javaClass.completeFrom(context).completeCodeUnitsFrom(context);
         }
-        return new JavaClasses(result);
+        return JavaClasses.of(result, context);
     }
 
     private static ImportContext simulateContextForCompletion(final ImportedTestClasses importedClasses) {

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/DaoRulesTest.java
Patch:
@@ -12,12 +12,12 @@
 import org.junit.Ignore;
 import org.junit.Test;
 
+import static com.tngtech.archunit.core.properties.HasName.Predicates.withNameMatching;
 import static com.tngtech.archunit.lang.ArchRule.all;
 import static com.tngtech.archunit.lang.ArchRule.classes;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.resideInAPackage;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.annotatedWith;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.are;
-import static com.tngtech.archunit.lang.conditions.ArchPredicates.withName;
 
 public class DaoRulesTest {
     private JavaClasses classes;
@@ -30,7 +30,7 @@ public void setUp() throws Exception {
     @Ignore
     @Test
     public void DAOs_must_reside_in_a_dao_package() {
-        all(classes().that(are(withName(".*Dao"))).as("DAOs"))
+        all(classes().that(are(withNameMatching(".*Dao"))).as("DAOs"))
                 .should(resideInAPackage("..dao..")).check(classes);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/AccessTarget.java
Patch:
@@ -11,6 +11,7 @@
 import com.tngtech.archunit.core.properties.HasName;
 import com.tngtech.archunit.core.properties.HasOwner;
 import com.tngtech.archunit.core.properties.HasParameters;
+import com.tngtech.archunit.core.properties.HasReturnType;
 import com.tngtech.archunit.core.properties.HasType;
 
 import static com.tngtech.archunit.core.JavaConstructor.CONSTRUCTOR_NAME;
@@ -123,7 +124,7 @@ public Set<JavaField> resolve() {
         }
     }
 
-    public static abstract class CodeUnitCallTarget extends AccessTarget implements HasParameters {
+    public static abstract class CodeUnitCallTarget extends AccessTarget implements HasParameters, HasReturnType {
         private final ImmutableList<JavaClass> parameters;
         private final JavaClass returnType;
 
@@ -138,6 +139,7 @@ public JavaClassList getParameters() {
             return new JavaClassList(parameters);
         }
 
+        @Override
         public JavaClass getReturnType() {
             return returnType;
         }

File: archunit/src/main/java/com/tngtech/archunit/core/JavaCodeUnit.java
Patch:
@@ -11,6 +11,7 @@
 import com.tngtech.archunit.core.AccessTarget.ConstructorCallTarget;
 import com.tngtech.archunit.core.AccessTarget.MethodCallTarget;
 import com.tngtech.archunit.core.properties.HasParameters;
+import com.tngtech.archunit.core.properties.HasReturnType;
 import org.objectweb.asm.Type;
 
 import static com.tngtech.archunit.core.Formatters.formatMethod;
@@ -25,7 +26,7 @@
  * in particular every place, where Java code with behavior, like calling other methods or accessing fields, can
  * be defined.
  */
-public abstract class JavaCodeUnit extends JavaMember implements HasParameters {
+public abstract class JavaCodeUnit extends JavaMember implements HasParameters, HasReturnType {
     private final JavaClass returnType;
     private final List<JavaClass> parameters;
     private final String fullName;
@@ -51,6 +52,7 @@ public JavaClassList getParameters() {
         return new JavaClassList(parameters);
     }
 
+    @Override
     public JavaClass getReturnType() {
         return returnType;
     }

File: archunit/src/main/java/com/tngtech/archunit/core/RawAccessRecord.java
Patch:
@@ -16,7 +16,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.tngtech.archunit.core.JavaConstructor.CONSTRUCTOR_NAME;
-import static com.tngtech.archunit.lang.conditions.ArchPredicates.withName;
+import static com.tngtech.archunit.core.properties.HasName.Predicates.withNameMatching;
 import static java.util.Collections.singleton;
 import static java.util.Collections.singletonList;
 import static java.util.regex.Pattern.quote;
@@ -179,7 +179,7 @@ private static class ClassHierarchyPath {
 
             private ClassHierarchyPath(JavaType childType, JavaClass parent) {
                 Set<JavaClass> classesToSearchForChild = Sets.union(singleton(parent), parent.getAllSubClasses());
-                Optional<JavaClass> child = tryFind(classesToSearchForChild, withName(quote(childType.getName())));
+                Optional<JavaClass> child = tryFind(classesToSearchForChild, withNameMatching(quote(childType.getName())));
                 if (child.isPresent()) {
                     createPath(child.get(), parent);
                 }

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/CallPredicate.java
Patch:
@@ -19,8 +19,8 @@
 import static com.tngtech.archunit.core.JavaClass.namesOf;
 import static com.tngtech.archunit.core.JavaClass.withType;
 import static com.tngtech.archunit.core.JavaConstructor.CONSTRUCTOR_NAME;
+import static com.tngtech.archunit.core.properties.HasName.Predicates.withNameMatching;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.hasParameterTypes;
-import static com.tngtech.archunit.lang.conditions.ArchPredicates.withName;
 
 public class CallPredicate extends DescribedPredicate<JavaCall<?>> {
     private final CombinedCallPredicate predicate;
@@ -38,7 +38,7 @@ public boolean apply(JavaCall<?> input) {
     }
 
     public CallPredicate hasName(String name) {
-        return new CallPredicate(modification.modify(predicate, withName(name).as("has name '%s'", name)), modification);
+        return new CallPredicate(modification.modify(predicate, withNameMatching(name).as("has name '%s'", name)), modification);
     }
 
     public CallPredicate hasParameters(Class<?>... paramTypes) {
@@ -91,7 +91,7 @@ public <T extends HasOwner<JavaClass> & HasName & HasParameters> CallPredicate i
 
     public <T extends HasOwner<JavaClass> & HasName & HasParameters> CallPredicate matches(Class<?> owner, String methodName, List<String> paramTypeNames) {
         DescribedPredicate<T> isDeclaredIn = declaredInPredicateFor(owner).onResultOf(Get.<JavaClass>owner()).forSubType();
-        DescribedPredicate<T> hasName = withName(methodName).forSubType();
+        DescribedPredicate<T> hasName = withNameMatching(methodName).forSubType();
         DescribedPredicate<T> isPredicate = isDeclaredIn.and(hasName).and(ArchPredicates.hasParameterTypeNames(paramTypeNames))
                 .as(formatMethod(owner.getName(), methodName, paramTypeNames));
 

File: archunit/src/test/java/com/tngtech/archunit/ArchUnitArchitectureTest.java
Patch:
@@ -18,6 +18,7 @@
 
 import static com.tngtech.archunit.core.ClassFileImporter.PredefinedImportOption.DONT_INCLUDE_TESTS;
 import static com.tngtech.archunit.core.DescribedPredicate.not;
+import static com.tngtech.archunit.core.properties.HasName.Predicates.withNameMatching;
 import static com.tngtech.archunit.lang.ArchRule.all;
 import static com.tngtech.archunit.lang.ArchRule.classes;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.accessFieldWhere;
@@ -29,7 +30,6 @@
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.callTarget;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.ownerAndNameAre;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.ownerIs;
-import static com.tngtech.archunit.lang.conditions.ArchPredicates.withName;
 
 public class ArchUnitArchitectureTest {
     private static final ClassFileImporter importer = new ClassFileImporter()
@@ -88,7 +88,7 @@ private DescribedPredicate<JavaCall<?>> classIsResolvedViaReflection() {
     private ArchCondition<JavaClass> illegallyAccessReflectFunction() {
         DescribedPredicate<JavaFieldAccess> targetIsReflectFunction = ownerAndNameAre(JavaClass.class, "REFLECT");
         DescribedPredicate<JavaFieldAccess> notAllowedOrigin =
-                not(accessOrigin(withName(JavaStaticInitializer.STATIC_INITIALIZER_NAME)))
+                not(accessOrigin(withNameMatching(JavaStaticInitializer.STATIC_INITIALIZER_NAME)))
                         .and(not(accessOrigin(annotatedWith(MayResolveTypesViaReflection.class))))
                         .and(not(accessOrigin(ownerIs(annotatedWith(MayResolveTypesViaReflection.class)))));
 

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/ArchConditionsTest.java
Patch:
@@ -21,6 +21,7 @@
 import static com.tngtech.archunit.core.TestUtils.javaMethodViaReflection;
 import static com.tngtech.archunit.core.TestUtils.predicateWithDescription;
 import static com.tngtech.archunit.core.TestUtils.simulateCall;
+import static com.tngtech.archunit.core.properties.HasName.Predicates.withNameMatching;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.accessClass;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.accessClassesThatResideIn;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.accessClassesThatResideInAnyPackage;
@@ -37,7 +38,6 @@
 import static com.tngtech.archunit.lang.conditions.ArchConditions.resideInAPackage;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.setField;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.setFieldWhere;
-import static com.tngtech.archunit.lang.conditions.ArchPredicates.withName;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 
 public class ArchConditionsTest {
@@ -67,11 +67,11 @@ public void access_class() {
         JavaClass clazz = javaClassViaReflection(CallingClass.class);
         JavaCall<?> call = simulateCall().from(clazz, "call").to(SomeSuperClass.class, "callMe");
 
-        ConditionEvents events = check(never(accessClass(withName(".*Some.*"))), clazz);
+        ConditionEvents events = check(never(accessClass(withNameMatching(".*Some.*"))), clazz);
 
         assertThat(events).containViolations(call.getDescription());
 
-        events = check(never(accessClass(withName(".*Wong.*"))), clazz);
+        events = check(never(accessClass(withNameMatching(".*Wong.*"))), clazz);
 
         assertThat(events).containNoViolation();
     }

File: archunit/src/main/java/com/tngtech/archunit/core/AccessTarget.java
Patch:
@@ -11,6 +11,7 @@
 import com.tngtech.archunit.core.properties.HasName;
 import com.tngtech.archunit.core.properties.HasOwner;
 import com.tngtech.archunit.core.properties.HasParameters;
+import com.tngtech.archunit.core.properties.HasType;
 
 import static com.tngtech.archunit.core.JavaConstructor.CONSTRUCTOR_NAME;
 
@@ -89,7 +90,7 @@ public boolean isAnnotatedWith(Class<? extends Annotation> annotation) {
         return false;
     }
 
-    public static class FieldAccessTarget extends AccessTarget {
+    public static class FieldAccessTarget extends AccessTarget implements HasType {
         private final JavaClass type;
         private final Supplier<Optional<JavaField>> field;
 
@@ -99,6 +100,7 @@ public static class FieldAccessTarget extends AccessTarget {
             this.field = Suppliers.memoize(field);
         }
 
+        @Override
         public JavaClass getType() {
             return type;
         }

File: archunit/src/main/java/com/tngtech/archunit/core/JavaField.java
Patch:
@@ -7,11 +7,12 @@
 import com.google.common.base.Supplier;
 import com.google.common.base.Suppliers;
 import com.tngtech.archunit.core.ArchUnitException.InconsistentClassPathException;
+import com.tngtech.archunit.core.properties.HasType;
 import org.objectweb.asm.Type;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-public class JavaField extends JavaMember {
+public class JavaField extends JavaMember implements HasType {
     private final JavaClass type;
     private final Supplier<Field> fieldSupplier;
     private Supplier<Set<JavaFieldAccess>> accessesToSelf = Suppliers.ofInstance(Collections.<JavaFieldAccess>emptySet());
@@ -27,6 +28,7 @@ public String getFullName() {
         return getOwner().getName() + "." + getName();
     }
 
+    @Override
     public JavaClass getType() {
         return type;
     }

File: archunit/src/main/java/com/tngtech/archunit/core/AccessRecord.java
Patch:
@@ -14,6 +14,9 @@
 import com.tngtech.archunit.core.JavaFieldAccess.AccessType;
 import com.tngtech.archunit.core.RawAccessRecord.CodeUnit;
 import com.tngtech.archunit.core.RawAccessRecord.TargetInfo;
+import com.tngtech.archunit.core.properties.HasDescriptor;
+import com.tngtech.archunit.core.properties.HasName;
+import com.tngtech.archunit.core.properties.HasOwner;
 import org.objectweb.asm.Type;
 
 import static com.google.common.collect.Iterables.getOnlyElement;

File: archunit/src/main/java/com/tngtech/archunit/core/Dependency.java
Patch:
@@ -5,6 +5,7 @@
 import java.util.Set;
 
 import com.google.common.collect.ComparisonChain;
+import com.tngtech.archunit.core.properties.HasDescription;
 
 /**
  * Represents a dependency of one Java class on another Java class. Such a dependency can occur by either of the

File: archunit/src/main/java/com/tngtech/archunit/core/DescribedIterable.java
Patch:
@@ -2,6 +2,8 @@
 
 import java.util.Iterator;
 
+import com.tngtech.archunit.core.properties.HasDescription;
+
 public interface DescribedIterable<T> extends Iterable<T>, HasDescription {
     class From {
         public static <T> DescribedIterable<T> iterable(final Iterable<T> iterable, final String description) {

File: archunit/src/main/java/com/tngtech/archunit/core/Formatters.java
Patch:
@@ -5,6 +5,7 @@
 
 import com.google.common.base.Joiner;
 import com.google.common.primitives.Ints;
+import com.tngtech.archunit.core.properties.HasName;
 
 public class Formatters {
     private Formatters() {

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClass.java
Patch:
@@ -13,12 +13,14 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
+import com.tngtech.archunit.core.properties.HasAnnotations;
+import com.tngtech.archunit.core.properties.HasName;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.concat;
 import static com.tngtech.archunit.core.DescribedPredicate.equalTo;
-import static com.tngtech.archunit.core.HasName.Functions.GET_NAME;
 import static com.tngtech.archunit.core.JavaConstructor.CONSTRUCTOR_NAME;
+import static com.tngtech.archunit.core.properties.HasName.Functions.GET_NAME;
 
 public class JavaClass implements HasName, HasAnnotations {
     private final Optional<Source> source;

File: archunit/src/main/java/com/tngtech/archunit/core/JavaCodeUnit.java
Patch:
@@ -10,6 +10,7 @@
 import com.tngtech.archunit.core.AccessRecord.FieldAccessRecord;
 import com.tngtech.archunit.core.AccessTarget.ConstructorCallTarget;
 import com.tngtech.archunit.core.AccessTarget.MethodCallTarget;
+import com.tngtech.archunit.core.properties.HasParameters;
 import org.objectweb.asm.Type;
 
 import static com.tngtech.archunit.core.Formatters.formatMethod;

File: archunit/src/main/java/com/tngtech/archunit/core/RawAccessRecord.java
Patch:
@@ -10,6 +10,9 @@
 
 import com.google.common.collect.Sets;
 import com.tngtech.archunit.core.JavaFieldAccess.AccessType;
+import com.tngtech.archunit.core.properties.HasDescriptor;
+import com.tngtech.archunit.core.properties.HasName;
+import com.tngtech.archunit.core.properties.HasOwner;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.tngtech.archunit.core.JavaConstructor.CONSTRUCTOR_NAME;

File: archunit/src/main/java/com/tngtech/archunit/core/properties/CanBeAnnotated.java
Patch:
@@ -1,8 +1,7 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.core.properties;
 
 import java.lang.annotation.Annotation;
 
 public interface CanBeAnnotated {
-
     boolean isAnnotatedWith(Class<? extends Annotation> annotation);
 }

File: archunit/src/main/java/com/tngtech/archunit/core/properties/HasDescription.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.core.properties;
 
 public interface HasDescription {
     String getDescription();

File: archunit/src/main/java/com/tngtech/archunit/core/properties/HasName.java
Patch:
@@ -1,4 +1,6 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.core.properties;
+
+import com.tngtech.archunit.core.Function;
 
 public interface HasName {
     String getName();

File: archunit/src/main/java/com/tngtech/archunit/core/properties/HasOwner.java
Patch:
@@ -1,4 +1,4 @@
-package com.tngtech.archunit.core;
+package com.tngtech.archunit.core.properties;
 
 public interface HasOwner<T> {
     T getOwner();

File: archunit/src/main/java/com/tngtech/archunit/lang/ClassesTransformer.java
Patch:
@@ -3,8 +3,8 @@
 import com.tngtech.archunit.core.DescribedIterable;
 import com.tngtech.archunit.core.DescribedPredicate;
 import com.tngtech.archunit.core.Guava;
-import com.tngtech.archunit.core.HasDescription;
 import com.tngtech.archunit.core.JavaClasses;
+import com.tngtech.archunit.core.properties.HasDescription;
 
 public abstract class ClassesTransformer<T> implements HasDescription {
     private String description;

File: archunit/src/main/java/com/tngtech/archunit/lang/ConfiguredMessageFormat.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.google.common.base.Joiner;
 import com.tngtech.archunit.core.DescribedIterable;
-import com.tngtech.archunit.core.HasDescription;
+import com.tngtech.archunit.core.properties.HasDescription;
 
 class ConfiguredMessageFormat {
     private static final ConfiguredMessageFormat instance = new ConfiguredMessageFormat();

File: archunit/src/main/java/com/tngtech/archunit/lang/RuleToEvaluate.java
Patch:
@@ -1,6 +1,6 @@
 package com.tngtech.archunit.lang;
 
-import com.tngtech.archunit.core.HasDescription;
+import com.tngtech.archunit.core.properties.HasDescription;
 
 public interface RuleToEvaluate extends HasDescription {
     ConditionEvents evaluate();

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/CallPredicate.java
Patch:
@@ -6,13 +6,13 @@
 import com.google.common.collect.ImmutableList;
 import com.tngtech.archunit.core.AccessTarget.CodeUnitCallTarget;
 import com.tngtech.archunit.core.DescribedPredicate;
-import com.tngtech.archunit.core.HasName;
-import com.tngtech.archunit.core.HasOwner;
-import com.tngtech.archunit.core.HasParameters;
 import com.tngtech.archunit.core.JavaCall;
 import com.tngtech.archunit.core.JavaClass;
 import com.tngtech.archunit.core.JavaCodeUnit;
 import com.tngtech.archunit.core.Optional;
+import com.tngtech.archunit.core.properties.HasName;
+import com.tngtech.archunit.core.properties.HasOwner;
+import com.tngtech.archunit.core.properties.HasParameters;
 
 import static com.tngtech.archunit.core.Formatters.formatMethod;
 import static com.tngtech.archunit.core.JavaClass.namesOf;

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Slice.java
Patch:
@@ -9,8 +9,8 @@
 import com.google.common.collect.ForwardingSet;
 import com.google.common.collect.ImmutableSet;
 import com.tngtech.archunit.core.Dependency;
-import com.tngtech.archunit.core.HasDescription;
 import com.tngtech.archunit.core.JavaClass;
+import com.tngtech.archunit.core.properties.HasDescription;
 
 import static com.google.common.base.Preconditions.checkArgument;
 

File: archunit/src/test/java/com/tngtech/archunit/core/ClassFileImporterTest.java
Patch:
@@ -34,14 +34,16 @@
 import com.tngtech.archunit.core.ClassFileImporter.ImportOption;
 import com.tngtech.archunit.core.JavaFieldAccess.AccessType;
 import com.tngtech.archunit.core.Source.Md5sum;
-import com.tngtech.archunit.core.testexamples.annotatedclassimport.TypeAnnotationWithEnumAndArrayValue;
+import com.tngtech.archunit.core.properties.HasName;
+import com.tngtech.archunit.core.properties.HasOwner;
 import com.tngtech.archunit.core.testexamples.SomeAnnotation;
 import com.tngtech.archunit.core.testexamples.annotatedclassimport.ClassAnnotationWithArrays;
 import com.tngtech.archunit.core.testexamples.annotatedclassimport.ClassWithAnnotationWithEmptyArrays;
 import com.tngtech.archunit.core.testexamples.annotatedclassimport.ClassWithComplexAnnotations;
 import com.tngtech.archunit.core.testexamples.annotatedclassimport.ClassWithOneAnnotation;
 import com.tngtech.archunit.core.testexamples.annotatedclassimport.ClassWithUnimportedAnnotation;
 import com.tngtech.archunit.core.testexamples.annotatedclassimport.SimpleAnnotation;
+import com.tngtech.archunit.core.testexamples.annotatedclassimport.TypeAnnotationWithEnumAndArrayValue;
 import com.tngtech.archunit.core.testexamples.annotationfieldimport.ClassWithAnnotatedFields;
 import com.tngtech.archunit.core.testexamples.annotationfieldimport.ClassWithAnnotatedFields.FieldAnnotationWithEnumClassAndArrayValue;
 import com.tngtech.archunit.core.testexamples.annotationfieldimport.ClassWithAnnotatedFields.FieldAnnotationWithIntValue;

File: archunit/src/test/java/com/tngtech/archunit/lang/ArchRuleTest.java
Patch:
@@ -4,10 +4,10 @@
 
 import com.google.common.collect.ForwardingSet;
 import com.tngtech.archunit.core.DescribedPredicate;
-import com.tngtech.archunit.core.HasDescription;
 import com.tngtech.archunit.core.JavaClass;
 import com.tngtech.archunit.core.JavaClassesTest;
 import com.tngtech.archunit.core.Restrictable;
+import com.tngtech.archunit.core.properties.HasDescription;
 import org.hamcrest.Description;
 import org.hamcrest.Matcher;
 import org.hamcrest.TypeSafeDiagnosingMatcher;

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/ArchPredicatesTest.java
Patch:
@@ -5,9 +5,9 @@
 import java.util.Collections;
 
 import com.tngtech.archunit.core.DescribedPredicate;
-import com.tngtech.archunit.core.HasParameters;
 import com.tngtech.archunit.core.JavaClass;
 import com.tngtech.archunit.core.JavaMethod;
+import com.tngtech.archunit.core.properties.HasParameters;
 import org.junit.Rule;
 import org.junit.Test;
 import org.mockito.Mock;

File: archunit/src/main/java/com/tngtech/archunit/core/AccessRecord.java
Patch:
@@ -87,7 +87,8 @@ public Optional<JavaConstructor> get() {
                     }
                 };
                 JavaClassList paramTypes = getArgumentTypesFrom(record.target.desc, classes);
-                return new ConstructorCallTarget(targetOwner, paramTypes, constructorSupplier);
+                JavaClass returnType = classes.get(void.class.getName());
+                return new ConstructorCallTarget(targetOwner, paramTypes, returnType, constructorSupplier);
             }
 
             public int getLineNumber() {

File: archunit/src/test/java/com/tngtech/archunit/core/TestUtils.java
Patch:
@@ -341,7 +341,7 @@ static ConstructorCallTarget targetFrom(JavaConstructor target) {
         return new ConstructorCallTarget(
                 target.getOwner(),
                 target.getParameters(),
-                Suppliers.ofInstance(Optional.of(target)));
+                target.getReturnType(), Suppliers.ofInstance(Optional.of(target)));
     }
 
     static MethodCallTarget targetFrom(JavaMethod target) {

File: archunit/src/main/java/com/tngtech/archunit/core/JavaType.java
Patch:
@@ -10,6 +10,7 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
 import com.tngtech.archunit.core.ArchUnitException.ReflectionException;
+import com.tngtech.archunit.core.Optional;
 import org.objectweb.asm.Type;
 
 import static com.google.common.base.Preconditions.checkArgument;

File: archunit/src/test/java/com/tngtech/archunit/core/ClassFileImporterTest.java
Patch:
@@ -34,14 +34,14 @@
 import com.tngtech.archunit.core.ClassFileImporter.ImportOption;
 import com.tngtech.archunit.core.JavaFieldAccess.AccessType;
 import com.tngtech.archunit.core.Source.Md5sum;
+import com.tngtech.archunit.core.testexamples.annotatedclassimport.TypeAnnotationWithEnumAndArrayValue;
 import com.tngtech.archunit.core.testexamples.SomeAnnotation;
 import com.tngtech.archunit.core.testexamples.annotatedclassimport.ClassAnnotationWithArrays;
 import com.tngtech.archunit.core.testexamples.annotatedclassimport.ClassWithAnnotationWithEmptyArrays;
 import com.tngtech.archunit.core.testexamples.annotatedclassimport.ClassWithComplexAnnotations;
 import com.tngtech.archunit.core.testexamples.annotatedclassimport.ClassWithOneAnnotation;
 import com.tngtech.archunit.core.testexamples.annotatedclassimport.ClassWithUnimportedAnnotation;
 import com.tngtech.archunit.core.testexamples.annotatedclassimport.SimpleAnnotation;
-import com.tngtech.archunit.core.testexamples.annotatedclassimport.TypeAnnotationWithEnumAndArrayValue;
 import com.tngtech.archunit.core.testexamples.annotationfieldimport.ClassWithAnnotatedFields;
 import com.tngtech.archunit.core.testexamples.annotationfieldimport.ClassWithAnnotatedFields.FieldAnnotationWithEnumClassAndArrayValue;
 import com.tngtech.archunit.core.testexamples.annotationfieldimport.ClassWithAnnotatedFields.FieldAnnotationWithIntValue;

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ClassCacheConcurrencyTest.java
Patch:
@@ -7,6 +7,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 
+import com.tngtech.archunit.Slow;
 import com.tngtech.archunit.core.ClassFileImporter;
 import org.junit.Rule;
 import org.junit.Test;

File: archunit/src/test/java/com/tngtech/archunit/core/TestUtils.java
Patch:
@@ -90,7 +90,7 @@ public static JavaMethod javaMethodViaReflection(JavaClass clazz, Method method)
                 .build(clazz, simpleImportedClasses());
     }
 
-    private static ImportedTestClasses simpleImportedClasses() {
+    static ImportedTestClasses simpleImportedClasses() {
         return new ImportedTestClasses();
     }
 
@@ -438,7 +438,7 @@ private static JavaAnnotation javaAnnotationFrom(Annotation annotation, Imported
     }
 
     private static JavaAnnotation.Builder javaAnnotationBuilderFrom(Annotation annotation, ImportedClasses.ByTypeName importedClasses) {
-        JavaAnnotation.Builder builder = new JavaAnnotation.Builder().withType(Type.getType(annotation.annotationType()));
+        JavaAnnotation.Builder builder = new JavaAnnotation.Builder().withType(JavaType.From.name(annotation.annotationType().getName()));
         for (Map.Entry<String, Object> entry : mapOf(annotation, importedClasses).entrySet()) {
             builder.addProperty(entry.getKey(), JavaAnnotation.ValueBuilder.ofFinished(entry.getValue()));
         }

File: archunit/src/main/java/com/tngtech/archunit/core/JavaConstructor.java
Patch:
@@ -50,7 +50,7 @@ void registerCallsToConstructor(Collection<JavaConstructorCall> calls) {
 
     static final class Builder extends JavaCodeUnit.Builder<JavaConstructor, Builder> {
         @Override
-        JavaConstructor construct(Builder builder) {
+        JavaConstructor construct(Builder builder, ImportedClasses.ByTypeName importedClasses) {
             return new JavaConstructor(builder);
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/JavaField.java
Patch:
@@ -60,7 +60,7 @@ public JavaClass getType() {
         }
 
         @Override
-        JavaField construct(Builder builder) {
+        JavaField construct(Builder builder, ImportedClasses.ByTypeName importedClasses) {
             return new JavaField(builder);
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/core/JavaStaticInitializer.java
Patch:
@@ -36,7 +36,7 @@ public Builder() {
         }
 
         @Override
-        JavaStaticInitializer construct(Builder builder) {
+        JavaStaticInitializer construct(Builder builder, ImportedClasses.ByTypeName importedClasses) {
             return new JavaStaticInitializer(builder);
         }
     }

File: archunit/src/test/java/com/tngtech/archunit/core/LocationTest.java
Patch:
@@ -38,7 +38,7 @@ public void equals_and_hashcode() {
         JarFile jarFile = new TestJarFile().withEntry(fullClassFileName(getClass())).create();
         Location location = Location.of(jarFile);
         Location equal = Location.of(jarFile);
-        Location different = Location.of(new TestJarFile().withEntry(fullClassFileName(Location.class)).create());
+        Location different = Location.of(new TestJarFile().withEntry(fullClassFileName(getClass())).create());
 
         assertThat(location).isEqualTo(location);
         assertThat(location).isEqualTo(equal);

File: archunit/src/main/java/com/tngtech/archunit/core/Source.java
Patch:
@@ -92,7 +92,7 @@ private Md5sum(byte[] input, MessageDigest md5Digest) {
         }
 
         public byte[] asBytes() {
-            return md5Bytes;
+            return Arrays.copyOf(md5Bytes, md5Bytes.length);
         }
 
         @Override

File: archunit/src/main/java/com/tngtech/archunit/core/ArchUnitException.java
Patch:
@@ -15,7 +15,7 @@ public class ArchUnitException extends RuntimeException {
         super(cause);
     }
 
-    public static class LocationException extends ArchUnitException {
+    static class LocationException extends ArchUnitException {
         LocationException(Exception e) {
             super(e);
         }
@@ -27,13 +27,13 @@ public ReflectionException(Throwable cause) {
         }
     }
 
-    public static class UnsupportedUrlProtocolException extends ArchUnitException {
+    static class UnsupportedUrlProtocolException extends ArchUnitException {
         UnsupportedUrlProtocolException(URL url) {
             super("The protocol of the following URL is not (yet) supported: " + url);
         }
     }
 
-    public static class InconsistentClassPathException extends ArchUnitException {
+    static class InconsistentClassPathException extends ArchUnitException {
         InconsistentClassPathException(String message, Throwable cause) {
             super(message, cause);
         }

File: archunit/src/main/java/com/tngtech/archunit/core/Location.java
Patch:
@@ -80,7 +80,7 @@ public static Location of(JarFile jar) {
         return new JarFileLocation(newJarUrl(newURL(String.format("%s:%s", FILE_PROTOCOL, jar.getName()))));
     }
 
-    private static URL newJarUrl(URL url) {
+    static URL newJarUrl(URL url) {
         try {
             return new URL(String.format("%s:%s!/", JAR_PROTOCOL, url.toExternalForm()));
         } catch (MalformedURLException e) {

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/DaoRulesTest.java
Patch:
@@ -10,10 +10,10 @@
 import org.junit.Ignore;
 import org.junit.Test;
 
-import static com.tngtech.archunit.core.DescribedPredicate.are;
 import static com.tngtech.archunit.lang.ArchRule.all;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.resideInAPackage;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.annotatedWith;
+import static com.tngtech.archunit.lang.conditions.ArchPredicates.are;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.named;
 
 public class DaoRulesTest {

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/CodingRulesIntegrationTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.tngtech.archunit.integration;
 
 import com.tngtech.archunit.example.ClassViolatingCodingRules;
+import com.tngtech.archunit.example.SomeCustomException;
 import com.tngtech.archunit.example.service.ServiceViolatingLayerRules;
 import com.tngtech.archunit.exampletest.CodingRulesTest;
 import com.tngtech.archunit.junit.ExpectedViolation;
@@ -38,7 +39,7 @@ static void expectViolationByWritingToStandardStream(ExpectedViolation expectedV
                         .accessing().field(System.class, "err")
                         .inLine(10))
                 .byCall(from(ClassViolatingCodingRules.class, "printToStandardStream")
-                        .toMethod(Throwable.class, "printStackTrace")
+                        .toMethod(SomeCustomException.class, "printStackTrace")
                         .inLine(11))
                 .byAccess(from(ServiceViolatingLayerRules.class, "illegalAccessToController")
                         .accessing().field(System.class, "out")

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ArchRules.java
Patch:
@@ -9,11 +9,11 @@
 import java.util.Set;
 
 import com.google.common.collect.ImmutableSet;
-import com.tngtech.archunit.core.ReflectionUtils.Predicate;
+import com.tngtech.archunit.junit.ReflectionUtils.Predicate;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.tngtech.archunit.core.ReflectionUtils.getAllFields;
-import static com.tngtech.archunit.core.ReflectionUtils.getAllMethods;
+import static com.tngtech.archunit.junit.ReflectionUtils.getAllFields;
+import static com.tngtech.archunit.junit.ReflectionUtils.getAllMethods;
 
 public class ArchRules<T> {
     private final Collection<Field> fields;

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ArchTestMethodExecution.java
Patch:
@@ -20,7 +20,7 @@ public ArchTestMethodExecution(Class<?> testClass, Method testMethod) {
     public Result evaluateOn(JavaClasses classes) {
         try {
             executeTestMethod(classes);
-            return new PositiveResult(describeSelf());
+            return new PositiveResult();
         } catch (Throwable failure) {
             return new NegativeResult(describeSelf(), failure);
         }

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ClassCache.java
Patch:
@@ -5,19 +5,19 @@
 import java.util.concurrent.ConcurrentHashMap;
 
 import com.google.common.collect.ImmutableSet;
+import com.tngtech.archunit.core.ArchUnitException.ReflectionException;
 import com.tngtech.archunit.core.ClassFileImporter;
 import com.tngtech.archunit.core.JavaClasses;
 import com.tngtech.archunit.core.Location;
 import com.tngtech.archunit.core.Locations;
-import com.tngtech.archunit.core.ReflectionException;
 
 class ClassCache {
     private final ConcurrentHashMap<Class<?>, JavaClasses> cachedByTest = new ConcurrentHashMap<>();
     private final ConcurrentHashMap<Set<Location>, LazyJavaClasses> cachedByLocations = new ConcurrentHashMap<>();
 
     private ClassFileImporter classFileImporter = new ClassFileImporter();
 
-    public JavaClasses getClassesToAnalyseFor(Class<?> testClass) {
+    JavaClasses getClassesToAnalyseFor(Class<?> testClass) {
         checkArgument(testClass);
 
         if (cachedByTest.containsKey(testClass)) {

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/RuleEvaluationException.java
Patch:
@@ -1,11 +1,11 @@
 package com.tngtech.archunit.junit;
 
-public class RuleEvaluationException extends RuntimeException {
-    public RuleEvaluationException(String message, Throwable throwable) {
+class RuleEvaluationException extends RuntimeException {
+    RuleEvaluationException(String message, Throwable throwable) {
         super(message, throwable);
     }
 
-    public RuleEvaluationException(String format, Object... args) {
+    RuleEvaluationException(String format, Object... args) {
         super(String.format(format, args));
     }
 }

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsMethodsTest.java
Patch:
@@ -16,7 +16,7 @@
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
-import static com.tngtech.archunit.core.TestUtils.javaClasses;
+import static com.tngtech.archunit.core.TestUtils.javaClassesViaReflection;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsMethodsTest.ArchTestWithIgnoredMethod.toBeIgnored;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsMethodsTest.ArchTestWithIllegalTestMethods.noParams;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsMethodsTest.ArchTestWithIllegalTestMethods.tooManyParams;
@@ -52,7 +52,7 @@ public class ArchUnitRunnerRunsMethodsTest {
     @InjectMocks
     private ArchUnitRunner runner = newRunnerFor(ArchTestWithTestMethod.class);
 
-    private JavaClasses cachedClasses = javaClasses(ArchUnitRunnerRunsMethodsTest.class);
+    private JavaClasses cachedClasses = javaClassesViaReflection(ArchUnitRunnerRunsMethodsTest.class);
 
     @Before
     public void setUp() {

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsRuleFieldsTest.java
Patch:
@@ -19,7 +19,7 @@
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
-import static com.tngtech.archunit.core.TestUtils.javaClasses;
+import static com.tngtech.archunit.core.TestUtils.javaClassesViaReflection;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleFieldsTest.IgnoredArchTest.RULE_ONE_IN_IGNORED_TEST;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleFieldsTest.IgnoredArchTest.RULE_TWO_IN_IGNORED_TEST;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleFieldsTest.SomeArchTest.FAILING_FIELD_NAME;
@@ -61,7 +61,7 @@ public class ArchUnitRunnerRunsRuleFieldsTest {
     @InjectMocks
     private ArchUnitRunner runner = ArchUnitRunnerTestUtils.newRunnerFor(SomeArchTest.class);
 
-    private JavaClasses cachedClasses = javaClasses(ArchUnitRunnerRunsRuleFieldsTest.class);
+    private JavaClasses cachedClasses = javaClassesViaReflection(Object.class);
 
     @Before
     public void setUp() {

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsRuleSetsTest.java
Patch:
@@ -18,7 +18,7 @@
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
-import static com.tngtech.archunit.core.TestUtils.javaClasses;
+import static com.tngtech.archunit.core.TestUtils.javaClassesViaReflection;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleSetsTest.ArchTestWithRuleLibrary.someOtherMethodRuleName;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleSetsTest.Rules.someFieldRuleName;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleSetsTest.Rules.someMethodRuleName;
@@ -52,7 +52,7 @@ public class ArchUnitRunnerRunsRuleSetsTest {
     @InjectMocks
     private ArchUnitRunner runnerForRuleLibrary = newRunnerFor(ArchTestWithRuleLibrary.class);
 
-    private JavaClasses cachedClasses = javaClasses(ArchUnitRunnerRunsRuleSetsTest.class);
+    private JavaClasses cachedClasses = javaClassesViaReflection(ArchUnitRunnerRunsRuleSetsTest.class);
 
     @Before
     public void setUp() {

File: archunit/src/main/java/com/tngtech/archunit/core/ChainableFunction.java
Patch:
@@ -1,7 +1,7 @@
 package com.tngtech.archunit.core;
 
 public abstract class ChainableFunction<F, T> implements Function<F, T> {
-    public <E> Function<E, T> after(final Function<E, F> function) {
+    public <E> Function<E, T> after(final Function<E, ? extends F> function) {
         return new Function<E, T>() {
             @Override
             public T apply(E input) {

File: archunit/src/main/java/com/tngtech/archunit/core/DescribedIterable.java
Patch:
@@ -1,9 +1,7 @@
-package com.tngtech.archunit.lang;
+package com.tngtech.archunit.core;
 
 import java.util.Iterator;
 
-import com.tngtech.archunit.core.HasDescription;
-
 public interface DescribedIterable<T> extends Iterable<T>, HasDescription {
     class From {
         public static <T> DescribedIterable<T> iterable(final Iterable<T> iterable, final String description) {

File: archunit/src/main/java/com/tngtech/archunit/core/HasOwner.java
Patch:
@@ -6,6 +6,6 @@ public interface HasOwner<T> {
     interface IsOwnedByClass extends HasOwner<JavaClass> {
     }
 
-    interface IsOwnedByCodeUnit extends HasOwner<JavaCodeUnit<?, ?>> {
+    interface IsOwnedByCodeUnit extends HasOwner<JavaCodeUnit> {
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/lang/ArchCondition.java
Patch:
@@ -17,7 +17,7 @@ public ArchCondition(String description) {
         this(null, description);
     }
 
-    public ArchCondition(Iterable<T> objectsToTest, String description) {
+    private ArchCondition(Iterable<T> objectsToTest, String description) {
         this.objectsToTest = objectsToTest;
         this.description = checkNotNull(description);
     }

File: archunit/src/main/java/com/tngtech/archunit/lang/ArchRule.java
Patch:
@@ -35,7 +35,7 @@
  * @see OpenArchRule
  */
 public abstract class ArchRule<T> {
-    final String text;
+    private final String text;
     final ArchCondition<T> condition;
 
     ArchRule(String text, ArchCondition<T> condition) {

File: archunit/src/main/java/com/tngtech/archunit/lang/InputTransformer.java
Patch:
@@ -1,5 +1,6 @@
 package com.tngtech.archunit.lang;
 
+import com.tngtech.archunit.core.DescribedIterable;
 import com.tngtech.archunit.core.DescribedPredicate;
 import com.tngtech.archunit.core.Guava;
 import com.tngtech.archunit.core.HasDescription;

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Path.java
Patch:
@@ -13,7 +13,7 @@
 import static com.google.common.collect.Iterables.getLast;
 
 class Path<T, ATTACHMENT> {
-    final List<Edge<T, ATTACHMENT>> edges;
+    private final List<Edge<T, ATTACHMENT>> edges;
 
     Path() {
         this(Collections.<Edge<T, ATTACHMENT>>emptyList());

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Slices.java
Patch:
@@ -8,10 +8,10 @@
 import java.util.Set;
 
 import com.tngtech.archunit.core.Dependency;
+import com.tngtech.archunit.core.DescribedIterable;
 import com.tngtech.archunit.core.JavaClass;
 import com.tngtech.archunit.core.JavaClasses;
 import com.tngtech.archunit.core.Optional;
-import com.tngtech.archunit.lang.DescribedIterable;
 import com.tngtech.archunit.lang.InputTransformer;
 import com.tngtech.archunit.lang.conditions.PackageMatcher;
 

File: archunit/src/test/java/com/tngtech/archunit/core/JavaCallTest.java
Patch:
@@ -2,14 +2,14 @@
 
 import org.junit.Test;
 
-import static com.tngtech.archunit.core.TestUtils.javaMethod;
+import static com.tngtech.archunit.core.TestUtils.javaMethodViaReflection;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class JavaCallTest {
     @Test
     public void get_target() {
-        JavaMethodCall call = TestUtils.simulateCall().from(javaMethod(getClass(), "toString"), 5)
-                .to(javaMethod(getClass(), "hashCode"));
+        JavaMethodCall call = TestUtils.simulateCall().from(javaMethodViaReflection(getClass(), "toString"), 5)
+                .to(javaMethodViaReflection(getClass(), "hashCode"));
 
         assertThat(JavaCall.GET_TARGET.apply(call)).isEqualTo(call.getTarget());
     }

File: archunit/src/test/java/com/tngtech/archunit/core/JavaMemberTest.java
Patch:
@@ -3,15 +3,15 @@
 import org.junit.Test;
 
 import static com.tngtech.archunit.core.JavaMember.modifier;
-import static com.tngtech.archunit.core.TestUtils.javaMethod;
+import static com.tngtech.archunit.core.TestUtils.javaMethodViaReflection;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 
 public class JavaMemberTest {
     @Test
     public void modifier_predicate() {
-        assertThat(modifier(JavaModifier.PRIVATE).apply(javaMethod(SomeClass.class, "isPrivate")))
+        assertThat(modifier(JavaModifier.PRIVATE).apply(javaMethodViaReflection(SomeClass.class, "isPrivate")))
                 .as("Predicate matches").isTrue();
-        assertThat(modifier(JavaModifier.PRIVATE).apply(javaMethod(SomeClass.class, "isNotPrivate")))
+        assertThat(modifier(JavaModifier.PRIVATE).apply(javaMethodViaReflection(SomeClass.class, "isNotPrivate")))
                 .as("Predicate matches").isFalse();
         assertThat(modifier(JavaModifier.PRIVATE).getDescription()).isEqualTo("modifier PRIVATE");
     }

File: archunit/src/test/java/com/tngtech/archunit/core/TestJarFile.java
Patch:
@@ -9,8 +9,6 @@
 import java.util.jar.JarOutputStream;
 import java.util.zip.ZipEntry;
 
-import org.assertj.core.util.Files;
-
 import static com.google.common.io.ByteStreams.toByteArray;
 
 class TestJarFile {
@@ -22,7 +20,7 @@ TestJarFile withEntry(String entry) {
     }
 
     JarFile create() {
-        File folder = Files.newTemporaryFolder();
+        File folder = TestUtils.newTemporaryFolder();
         File file = new File(folder, "test.jar");
 
         try (JarOutputStream jarOut = new JarOutputStream(new FileOutputStream(file))) {

File: archunit/src/test/java/com/tngtech/archunit/core/testexamples/SomeEnum.java
Patch:
@@ -1,7 +1,7 @@
 package com.tngtech.archunit.core.testexamples;
 
 public enum SomeEnum {
-    SOME_VALUE;
+    SOME_VALUE, OTHER_VALUE;
 
     void bar() {
     }

File: archunit/src/test/java/com/tngtech/archunit/core/testexamples/complexexternal/ParentClass.java
Patch:
@@ -2,6 +2,7 @@
 
 public class ParentClass {
     public String someField;
+    public Object someParentField;
 
     public ParentClass() {
     }

File: archunit/src/test/java/com/tngtech/archunit/core/testexamples/dependents/ClassHoldingDependencies.java
Patch:
@@ -1,13 +1,13 @@
 package com.tngtech.archunit.core.testexamples.dependents;
 
-public class ClassWithDependents {
+public class ClassHoldingDependencies {
     int someInt;
     String someString;
 
-    public ClassWithDependents() {
+    public ClassHoldingDependencies() {
     }
 
-    public ClassWithDependents(int someInt) {
+    public ClassHoldingDependencies(int someInt) {
         this();
         this.someInt = someInt;
     }

File: archunit/src/test/java/com/tngtech/archunit/core/testexamples/dependents/FirstClassWithDependency.java
Patch:
@@ -4,7 +4,7 @@
 
 public class FirstClassWithDependency {
     void first() {
-        ClassWithDependents instanceOne = new ClassWithDependents();
+        ClassHoldingDependencies instanceOne = new ClassHoldingDependencies();
         Object someOtherObject = new Object();
         Serializable someSerializable = new Serializable() {
         };
@@ -15,7 +15,7 @@ void first() {
     }
 
     void second() {
-        ClassWithDependents instanceTwo = new ClassWithDependents(1);
+        ClassHoldingDependencies instanceTwo = new ClassHoldingDependencies(1);
         instanceTwo.setSomeString("string");
         instanceTwo.someString = "other";
     }

File: archunit/src/test/java/com/tngtech/archunit/core/testexamples/dependents/SecondClassWithDependency.java
Patch:
@@ -2,7 +2,7 @@
 
 public class SecondClassWithDependency {
     void other() {
-        ClassWithDependents instanceOne = new ClassWithDependents();
+        ClassHoldingDependencies instanceOne = new ClassHoldingDependencies();
         instanceOne.setSomeInt(0);
         instanceOne.someInt = 99;
     }

File: archunit/src/test/java/com/tngtech/archunit/core/testexamples/fieldimport/ClassWithStringField.java
Patch:
@@ -1,5 +1,6 @@
 package com.tngtech.archunit.core.testexamples.fieldimport;
 
 public class ClassWithStringField {
+    @Deprecated
     private String stringField;
 }

File: archunit/src/test/java/com/tngtech/archunit/core/testexamples/simpleimport/ClassToImportTwo.java
Patch:
@@ -1,4 +1,4 @@
 package com.tngtech.archunit.core.testexamples.simpleimport;
 
-public class ClassToImportTwo {
+public final class ClassToImportTwo {
 }

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ArchTestMethodExecution.java
Patch:
@@ -20,7 +20,7 @@ public ArchTestMethodExecution(Class<?> testClass, Method testMethod) {
     public Result evaluateOn(JavaClasses classes) {
         try {
             executeTestMethod(classes);
-            return new PositiveResult(describeSelf());
+            return new PositiveResult();
         } catch (Throwable failure) {
             return new NegativeResult(describeSelf(), failure);
         }

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/RuleEvaluationException.java
Patch:
@@ -1,11 +1,11 @@
 package com.tngtech.archunit.junit;
 
-public class RuleEvaluationException extends RuntimeException {
-    public RuleEvaluationException(String message, Throwable throwable) {
+class RuleEvaluationException extends RuntimeException {
+    RuleEvaluationException(String message, Throwable throwable) {
         super(message, throwable);
     }
 
-    public RuleEvaluationException(String format, Object... args) {
+    RuleEvaluationException(String format, Object... args) {
         super(String.format(format, args));
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/core/ClassFileProcessor.java
Patch:
@@ -122,7 +122,7 @@ public void handleFieldInstruction(int opcode, String owner, String name, String
         }
 
         @Override
-        public void handleMethodInstruction(int opcode, String owner, String name, String desc) {
+        public void handleMethodInstruction(String owner, String name, String desc) {
             LOG.debug("Found call of method {}.{}:{} in line {}", owner, name, desc, lineNumber);
             if (CONSTRUCTOR_NAME.equals(name)) {
                 TargetInfo target = new RawAccessRecord.ConstructorTargetInfo(owner, name, desc);

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClassProcessor.java
Patch:
@@ -234,7 +234,7 @@ public void visitFieldInsn(int opcode, String owner, String name, String desc) {
 
         @Override
         public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {
-            accessHandler.handleMethodInstruction(opcode, owner, name, desc);
+            accessHandler.handleMethodInstruction(owner, name, desc);
         }
 
         @Override
@@ -273,7 +273,7 @@ interface AccessHandler {
 
         void setLineNumber(int lineNumber);
 
-        void handleMethodInstruction(int opcode, String owner, String name, String desc);
+        void handleMethodInstruction(String owner, String name, String desc);
 
         class NoOp implements AccessHandler {
             @Override
@@ -289,7 +289,7 @@ public void setLineNumber(int lineNumber) {
             }
 
             @Override
-            public void handleMethodInstruction(int opcode, String owner, String name, String desc) {
+            public void handleMethodInstruction(String owner, String name, String desc) {
             }
         }
     }

File: archunit/src/main/java/com/tngtech/archunit/lang/ArchCondition.java
Patch:
@@ -17,7 +17,7 @@ public ArchCondition(String description) {
         this(null, description);
     }
 
-    public ArchCondition(Iterable<T> objectsToTest, String description) {
+    private ArchCondition(Iterable<T> objectsToTest, String description) {
         this.objectsToTest = objectsToTest;
         this.description = checkNotNull(description);
     }

File: archunit/src/main/java/com/tngtech/archunit/lang/ArchRule.java
Patch:
@@ -35,7 +35,7 @@
  * @see OpenArchRule
  */
 public abstract class ArchRule<T> {
-    final String text;
+    private final String text;
     final ArchCondition<T> condition;
 
     ArchRule(String text, ArchCondition<T> condition) {

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Path.java
Patch:
@@ -13,7 +13,7 @@
 import static com.google.common.collect.Iterables.getLast;
 
 class Path<T, ATTACHMENT> {
-    final List<Edge<T, ATTACHMENT>> edges;
+    private final List<Edge<T, ATTACHMENT>> edges;
 
     Path() {
         this(Collections.<Edge<T, ATTACHMENT>>emptyList());

File: archunit/src/main/java/com/tngtech/archunit/core/JavaType.java
Patch:
@@ -193,7 +193,7 @@ public String toString() {
         }
 
         private static class ObjectType extends AbstractType {
-            static final String CLASS_NAME_REGEX = "(\\w+\\.)*(\\w|\\$)+";
+            static final String CLASS_NAME_REGEX = "([^.]+\\.)*([^.])+";
 
             ObjectType(String fullName) {
                 super(fullName, ensureSimpleName(fullName), createPackage(fullName));

File: archunit/src/test/java/com/tngtech/archunit/core/ClassFileImporterTest.java
Patch:
@@ -143,8 +143,6 @@ public class ClassFileImporterTest {
     @Rule
     public final OutsideOfClassPathRule outsideOfClassPath = new OutsideOfClassPathRule();
 
-    // FIXME: Write tests for array parameters
-
     @Test
     public void imports_simple_package() throws Exception {
         Set<String> expectedClassNames = Sets.newHashSet(

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ArchRules.java
Patch:
@@ -9,11 +9,11 @@
 import java.util.Set;
 
 import com.google.common.collect.ImmutableSet;
-import com.tngtech.archunit.core.ReflectionUtils.Predicate;
+import com.tngtech.archunit.junit.ReflectionUtils.Predicate;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.tngtech.archunit.core.ReflectionUtils.getAllFields;
-import static com.tngtech.archunit.core.ReflectionUtils.getAllMethods;
+import static com.tngtech.archunit.junit.ReflectionUtils.getAllFields;
+import static com.tngtech.archunit.junit.ReflectionUtils.getAllMethods;
 
 public class ArchRules<T> {
     private final Collection<Field> fields;

File: archunit/src/main/java/com/tngtech/archunit/core/ImportedClasses.java
Patch:
@@ -30,7 +30,7 @@ boolean contain(String name) {
 
     void ensurePresent(String typeName) {
         if (!contain(typeName)) {
-            Optional<JavaClass> resolved = resolver.resolve(typeName, byType());
+            Optional<JavaClass> resolved = resolver.tryResolve(typeName, byType());
             JavaClass newClass = resolved.isPresent() ? resolved.get() : simpleClassOf(typeName);
             additionalClasses.put(typeName, newClass);
         }

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ArchPredicates.java
Patch:
@@ -20,7 +20,7 @@
 import static com.tngtech.archunit.core.DescribedPredicate.equalTo;
 import static com.tngtech.archunit.core.Formatters.formatMethodParameterTypeNames;
 import static com.tngtech.archunit.core.JavaClass.REFLECT;
-import static com.tngtech.archunit.core.ReflectionUtils.namesOf;
+import static com.tngtech.archunit.core.JavaClass.namesOf;
 import static java.util.regex.Pattern.quote;
 
 public class ArchPredicates {

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/CallPredicate.java
Patch:
@@ -16,9 +16,9 @@
 
 import static com.tngtech.archunit.core.Formatters.formatMethod;
 import static com.tngtech.archunit.core.JavaClass.REFLECT;
+import static com.tngtech.archunit.core.JavaClass.namesOf;
 import static com.tngtech.archunit.core.JavaConstructor.CONSTRUCTOR_NAME;
 import static com.tngtech.archunit.core.JavaMember.GET_OWNER;
-import static com.tngtech.archunit.core.ReflectionUtils.namesOf;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.hasParameterTypes;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.named;
 

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/MethodCallConditionTest.java
Patch:
@@ -14,7 +14,7 @@
 import org.junit.experimental.theories.Theory;
 import org.junit.runner.RunWith;
 
-import static com.tngtech.archunit.core.ReflectionUtils.namesOf;
+import static com.tngtech.archunit.core.JavaClass.namesOf;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.callTarget;
 import static com.tngtech.archunit.lang.conditions.testobjects.TestObjects.CALLER_CLASS;
 import static com.tngtech.archunit.lang.conditions.testobjects.TestObjects.TARGET_CLASS;

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -43,6 +43,7 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Lists.newArrayList;
 import static com.tngtech.archunit.core.Formatters.formatMethodParameterTypeNames;
+import static com.tngtech.archunit.core.JavaClass.namesOf;
 import static com.tngtech.archunit.core.JavaConstructor.CONSTRUCTOR_NAME;
 import static com.tngtech.archunit.core.JavaModifier.ABSTRACT;
 import static com.tngtech.archunit.core.JavaModifier.FINAL;
@@ -54,7 +55,6 @@
 import static com.tngtech.archunit.core.JavaModifier.SYNCHRONIZED;
 import static com.tngtech.archunit.core.JavaModifier.TRANSIENT;
 import static com.tngtech.archunit.core.JavaModifier.VOLATILE;
-import static com.tngtech.archunit.core.ReflectionUtils.namesOf;
 import static com.tngtech.archunit.core.TestUtils.classForName;
 import static com.tngtech.archunit.core.TestUtils.invoke;
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/Conditions.java
Patch:
@@ -3,7 +3,7 @@
 import com.tngtech.archunit.core.JavaCodeUnit;
 import org.assertj.core.api.Condition;
 
-import static com.tngtech.archunit.core.ReflectionUtils.namesOf;
+import static com.tngtech.archunit.core.JavaClass.namesOf;
 
 public final class Conditions {
     private Conditions() {}

File: archunit/src/main/java/com/tngtech/archunit/core/ClassFileProcessor.java
Patch:
@@ -20,7 +20,6 @@
 
 import static com.tngtech.archunit.core.JavaConstructor.CONSTRUCTOR_NAME;
 import static com.tngtech.archunit.core.ReflectionUtils.getAllSuperTypes;
-import static com.tngtech.archunit.core.ReflectionUtils.tryGetClassForName;
 import static org.objectweb.asm.Opcodes.ASM5;
 
 class ClassFileProcessor {
@@ -159,7 +158,7 @@ public Optional<JavaClass> resolve(String typeName, ImportedClasses.ByTypeName i
                 return Optional.of(importedClasses.get(typeName));
             }
 
-            Optional<Class<?>> type = tryGetClassForName(typeName);
+            Optional<Class<?>> type = JavaType.From.name(typeName).tryResolveClass();
             if (!type.isPresent()) {
                 return Optional.absent();
             }
@@ -180,7 +179,7 @@ private Optional<JavaClass> tryResolve(Class<?> type) {
 
         @Override
         public Map<String, Optional<JavaClass>> getAllSuperClasses(String className, ImportedClasses.ByTypeName importedClasses) {
-            Optional<Class<?>> type = tryGetClassForName(className);
+            Optional<Class<?>> type = JavaType.From.name(className).tryResolveClass();
             return type.isPresent() ?
                     tryGetAllSuperClasses(type.get(), importedClasses) :
                     Collections.<String, Optional<JavaClass>>emptyMap();

File: archunit/src/main/java/com/tngtech/archunit/core/HasAnnotations.java
Patch:
@@ -3,11 +3,9 @@
 import java.lang.annotation.Annotation;
 import java.util.Set;
 
-public interface HasAnnotations {
+public interface HasAnnotations extends CanBeAnnotated {
     Set<JavaAnnotation> getAnnotations();
 
-    boolean isAnnotatedWith(Class<? extends Annotation> annotation);
-
     JavaAnnotation getAnnotationOfType(Class<? extends Annotation> type);
 
     Optional<JavaAnnotation> tryGetAnnotationOfType(Class<? extends Annotation> type);

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClass.java
Patch:
@@ -14,7 +14,6 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.concat;
 import static com.tngtech.archunit.core.JavaConstructor.CONSTRUCTOR_NAME;
-import static com.tngtech.archunit.core.ReflectionUtils.classForName;
 import static com.tngtech.archunit.core.ReflectionUtils.namesOf;
 
 public class JavaClass implements HasName, HasAnnotations {
@@ -369,7 +368,7 @@ public Set<JavaAccess<?>> getAccessesToSelf() {
      */
     @MayResolveTypesViaReflection(reason = "This is not part of the import and a specific decision to rely on the classpath")
     public Class<?> reflect() {
-        return classForName(getName());
+        return javaType.resolveClass(getClass().getClassLoader());
     }
 
     void completeClassHierarchyFrom(ImportContext context) {

File: archunit/src/test/java/com/tngtech/archunit/core/ClassFileImporterTest.java
Patch:
@@ -1266,7 +1266,7 @@ private URL urlOf(Class<?> clazz) {
     }
 
     private Constructor<?> reflect(ConstructorCallTarget target) {
-        return reflect(target.resolve().get());
+        return reflect(target.tryResolve().get());
     }
 
     private Constructor<?> reflect(JavaConstructor javaConstructor) {

File: archunit/src/test/java/com/tngtech/archunit/core/TestUtils.java
Patch:
@@ -340,7 +340,7 @@ static Class[] asClasses(List<JavaClass> parameters) {
     }
 
     public static Class<?> classForName(String name) {
-        return ReflectionUtils.classForName(name);
+        return JavaType.From.name(name).resolveClass();
     }
 
     private static Set<JavaAnnotation.Builder> javaAnnotationBuildersFrom(Annotation[] reflectionAnnotations) {

File: archunit/src/main/java/com/tngtech/archunit/core/ClassGraphCreator.java
Patch:
@@ -17,7 +17,6 @@
 import static com.tngtech.archunit.core.BuilderWithBuildParameter.BuildFinisher.build;
 import static com.tngtech.archunit.core.ImportedClasses.simpleClassOf;
 import static com.tngtech.archunit.core.JavaAnnotation.buildAnnotations;
-import static com.tngtech.archunit.core.ReflectionUtils.ensureCorrectArrayTypeName;
 
 class ClassGraphCreator implements ImportContext {
     private static final Logger LOG = LoggerFactory.getLogger(ClassGraphCreator.class);
@@ -55,7 +54,7 @@ JavaClasses complete() {
 
     private void ensureCallTargetsArePresent() {
         for (RawAccessRecord record : importRecord.getAccessRecords()) {
-            classes.ensurePresent(ensureCorrectArrayTypeName(record.target.owner.getName()));
+            classes.ensurePresent(record.target.owner.getName());
         }
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/ImportedClasses.java
Patch:
@@ -6,8 +6,6 @@
 
 import com.google.common.collect.ImmutableMap;
 
-import static com.tngtech.archunit.core.ReflectionUtils.ensureCorrectArrayTypeName;
-
 class ImportedClasses {
     private final ImmutableMap<String, JavaClass> directlyImported;
     private final Map<String, JavaClass> additionalClasses = new HashMap<>();
@@ -39,7 +37,7 @@ void ensurePresent(String typeName) {
     }
 
     static JavaClass simpleClassOf(String typeName) {
-        return new JavaClass.Builder().withType(JavaType.From.name(ensureCorrectArrayTypeName(typeName))).build();
+        return new JavaClass.Builder().withType(JavaType.From.name(typeName)).build();
     }
 
     void add(JavaClass clazz) {

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClassProcessor.java
Patch:
@@ -26,7 +26,6 @@
 import static com.tngtech.archunit.core.ClassFileProcessor.ASM_API_VERSION;
 import static com.tngtech.archunit.core.JavaConstructor.CONSTRUCTOR_NAME;
 import static com.tngtech.archunit.core.JavaStaticInitializer.STATIC_INITIALIZER_NAME;
-import static com.tngtech.archunit.core.ReflectionUtils.ensureCorrectArrayTypeName;
 
 class JavaClassProcessor extends ClassVisitor {
     private static final Logger LOG = LoggerFactory.getLogger(JavaClassProcessor.class);
@@ -152,7 +151,7 @@ public void visitEnd() {
     private static List<String> namesOf(Type[] types) {
         ImmutableList.Builder<String> result = ImmutableList.builder();
         for (Type type : types) {
-            result.add(ensureCorrectArrayTypeName(type.getClassName())); // FIXME: Centralise the array handling and write test for array parameter, since all tests up to ClassCacheTest passed with wrong handling
+            result.add(JavaType.From.asmType(type).getName());
         }
         return result.build();
     }

File: archunit/src/test/java/com/tngtech/archunit/core/ClassFileImporterTest.java
Patch:
@@ -142,6 +142,8 @@ public class ClassFileImporterTest {
     @Rule
     public final TemporaryFolder temporaryFolder = new TemporaryFolder();
 
+    // FIXME: Assert type details since we don't use reflection anymore and write tests for array parameters
+
     @Test
     public void imports_simple_classes() throws Exception {
         Set<String> expectedClassNames = Sets.newHashSet(

File: archunit/src/main/java/com/tngtech/archunit/core/ImportedClasses.java
Patch:
@@ -39,7 +39,7 @@ void ensurePresent(String typeName) {
     }
 
     static JavaClass simpleClassOf(String typeName) {
-        return new JavaClass.Builder().withType(JavaType.of(ensureCorrectArrayTypeName(typeName))).build();
+        return new JavaClass.Builder().withType(JavaType.From.name(ensureCorrectArrayTypeName(typeName))).build();
     }
 
     void add(JavaClass clazz) {

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClassProcessor.java
Patch:
@@ -63,7 +63,7 @@ public void visit(int version, int access, String name, String signature, String
                 Optional.<String>absent();
         LOG.debug("Found superclass {} on class '{}'", superClassName, name);
 
-        javaClassBuilder = new JavaClass.Builder().withType(JavaType.fromAsmObjectType(name));
+        javaClassBuilder = new JavaClass.Builder().withType(JavaType.From.fromAsmObjectTypeName(name));
         boolean opCodeForInterfaceIsPresent = (access & Opcodes.ACC_INTERFACE) != 0;
         javaClassBuilder.withInterface(opCodeForInterfaceIsPresent);
         className = createTypeName(name);

File: archunit/src/main/java/com/tngtech/archunit/core/RawAccessRecord.java
Patch:
@@ -120,7 +120,7 @@ static abstract class TargetInfo {
         final String desc;
 
         TargetInfo(String owner, String name, String desc) {
-            this.owner = JavaType.fromAsmObjectType(owner);
+            this.owner = JavaType.From.fromAsmObjectTypeName(owner);
             this.name = name;
             this.desc = desc;
         }

File: archunit/src/test/java/com/tngtech/archunit/core/TestUtils.java
Patch:
@@ -113,7 +113,7 @@ public JavaClass get(String typeName) {
         }
 
         private JavaClass importNew(Class<?> owner) {
-            JavaClass result = new JavaClass.Builder().withType(JavaType.of(owner.getName())).build();
+            JavaClass result = new JavaClass.Builder().withType(JavaType.From.name(owner.getName())).build();
             imported.put(result.getName(), result);
             return result;
         }
@@ -197,7 +197,7 @@ public Optional<JavaClass> answer(InvocationOnMock invocation) throws Throwable
     }
 
     private static JavaClass simulateImport(Class<?> owner, ImportedTestClasses importedClasses) {
-        JavaClass javaClass = new JavaClass.Builder().withType(JavaType.of(owner.getName())).build();
+        JavaClass javaClass = new JavaClass.Builder().withType(JavaType.From.name(owner.getName())).build();
         importedClasses.register(javaClass);
         ImportContext context = simulateImportContext(owner, importedClasses);
         javaClass.completeMembers(context);

File: archunit/src/main/java/com/tngtech/archunit/core/ImportedClasses.java
Patch:
@@ -39,7 +39,7 @@ void ensurePresent(String typeName) {
     }
 
     static JavaClass simpleClassOf(String typeName) {
-        return new JavaClass.Builder().withType(TypeDetails.of(ensureCorrectArrayTypeName(typeName))).build();
+        return new JavaClass.Builder().withType(JavaType.of(ensureCorrectArrayTypeName(typeName))).build();
     }
 
     void add(JavaClass clazz) {

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClassProcessor.java
Patch:
@@ -63,7 +63,7 @@ public void visit(int version, int access, String name, String signature, String
                 Optional.<String>absent();
         LOG.debug("Found superclass {} on class '{}'", superClassName, name);
 
-        javaClassBuilder = new JavaClass.Builder().withType(TypeDetails.fromAsmObjectType(name));
+        javaClassBuilder = new JavaClass.Builder().withType(JavaType.fromAsmObjectType(name));
         boolean opCodeForInterfaceIsPresent = (access & Opcodes.ACC_INTERFACE) != 0;
         javaClassBuilder.withInterface(opCodeForInterfaceIsPresent);
         className = createTypeName(name);

File: archunit/src/main/java/com/tngtech/archunit/core/RawAccessRecord.java
Patch:
@@ -115,12 +115,12 @@ && getParameters().equals(method.getParameters().getNames())
     }
 
     static abstract class TargetInfo {
-        final TypeDetails owner;
+        final JavaType owner;
         final String name;
         final String desc;
 
         TargetInfo(String owner, String name, String desc) {
-            this.owner = TypeDetails.fromAsmObjectType(owner);
+            this.owner = JavaType.fromAsmObjectType(owner);
             this.name = name;
             this.desc = desc;
         }
@@ -174,7 +174,7 @@ public String toString() {
         private static class ClassHierarchyPath {
             private final List<JavaClass> path = new ArrayList<>();
 
-            private ClassHierarchyPath(TypeDetails childType, JavaClass parent) {
+            private ClassHierarchyPath(JavaType childType, JavaClass parent) {
                 Set<JavaClass> classesToSearchForChild = Sets.union(singleton(parent), parent.getAllSubClasses());
                 Optional<JavaClass> child = tryFind(classesToSearchForChild, named(quote(childType.getName())));
                 if (child.isPresent()) {

File: archunit/src/test/java/com/tngtech/archunit/core/TestUtils.java
Patch:
@@ -113,7 +113,7 @@ public JavaClass get(String typeName) {
         }
 
         private JavaClass importNew(Class<?> owner) {
-            JavaClass result = new JavaClass.Builder().withType(TypeDetails.of(owner.getName())).build();
+            JavaClass result = new JavaClass.Builder().withType(JavaType.of(owner.getName())).build();
             imported.put(result.getName(), result);
             return result;
         }
@@ -197,7 +197,7 @@ public Optional<JavaClass> answer(InvocationOnMock invocation) throws Throwable
     }
 
     private static JavaClass simulateImport(Class<?> owner, ImportedTestClasses importedClasses) {
-        JavaClass javaClass = new JavaClass.Builder().withType(TypeDetails.of(owner.getName())).build();
+        JavaClass javaClass = new JavaClass.Builder().withType(JavaType.of(owner.getName())).build();
         importedClasses.register(javaClass);
         ImportContext context = simulateImportContext(owner, importedClasses);
         javaClass.completeMembers(context);

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClassProcessor.java
Patch:
@@ -63,7 +63,7 @@ public void visit(int version, int access, String name, String signature, String
                 Optional.<String>absent();
         LOG.debug("Found superclass {} on class '{}'", superClassName, name);
 
-        javaClassBuilder = new JavaClass.Builder().withType(TypeDetails.of(JavaType.fromClassName(name).getName()));
+        javaClassBuilder = new JavaClass.Builder().withType(TypeDetails.fromAsmObjectType(name));
         boolean opCodeForInterfaceIsPresent = (access & Opcodes.ACC_INTERFACE) != 0;
         javaClassBuilder.withInterface(opCodeForInterfaceIsPresent);
         className = createTypeName(name);

File: archunit/src/main/java/com/tngtech/archunit/core/RawAccessRecord.java
Patch:
@@ -115,12 +115,12 @@ && getParameters().equals(method.getParameters().getNames())
     }
 
     static abstract class TargetInfo {
-        final JavaType owner;
+        final TypeDetails owner;
         final String name;
         final String desc;
 
         TargetInfo(String owner, String name, String desc) {
-            this.owner = JavaType.fromClassName(owner);
+            this.owner = TypeDetails.fromAsmObjectType(owner);
             this.name = name;
             this.desc = desc;
         }
@@ -174,7 +174,7 @@ public String toString() {
         private static class ClassHierarchyPath {
             private final List<JavaClass> path = new ArrayList<>();
 
-            private ClassHierarchyPath(JavaType childType, JavaClass parent) {
+            private ClassHierarchyPath(TypeDetails childType, JavaClass parent) {
                 Set<JavaClass> classesToSearchForChild = Sets.union(singleton(parent), parent.getAllSubClasses());
                 Optional<JavaClass> child = tryFind(classesToSearchForChild, named(quote(childType.getName())));
                 if (child.isPresent()) {

File: archunit/src/main/java/com/tngtech/archunit/core/AnnotationProxy.java
Patch:
@@ -129,14 +129,14 @@ private static class JavaEnumConstantConversion implements Conversion<JavaEnumCo
         @Override
         @MayResolveTypesViaReflection(reason = "We already depend on the classpath, if we proxy an annotation type")
         public Enum<?> convert(JavaEnumConstant input, Class<?> returnType) {
-            for (Object constant : classForName(input.getType().getName()).getEnumConstants()) {
+            for (Object constant : classForName(input.getDeclaringClass().getName()).getEnumConstants()) {
                 Enum<?> anEnum = (Enum<?>) constant;
-                if (anEnum.name().equals(input.getName())) {
+                if (anEnum.name().equals(input.name())) {
                     return anEnum;
                 }
             }
             throw new IllegalStateException(String.format(
-                    "Couldn't find Enum Constant %s.%s", input.getType().getSimpleName(), input.getName()));
+                    "Couldn't find Enum Constant %s.%s", input.getDeclaringClass().getSimpleName(), input.name()));
         }
 
         @Override

File: archunit/src/main/java/com/tngtech/archunit/core/ImportedClasses.java
Patch:
@@ -6,6 +6,8 @@
 
 import com.google.common.collect.ImmutableMap;
 
+import static com.tngtech.archunit.core.ReflectionUtils.ensureCorrectArrayTypeName;
+
 class ImportedClasses {
     private final ImmutableMap<String, JavaClass> directlyImported;
     private final Map<String, JavaClass> additionalClasses = new HashMap<>();
@@ -37,7 +39,7 @@ void ensurePresent(String typeName) {
     }
 
     static JavaClass simpleClassOf(String typeName) {
-        return new JavaClass.Builder().withType(TypeDetails.of(typeName)).build();
+        return new JavaClass.Builder().withType(TypeDetails.of(ensureCorrectArrayTypeName(typeName))).build();
     }
 
     void add(JavaClass clazz) {

File: archunit/src/main/java/com/tngtech/archunit/core/RawAccessRecord.java
Patch:
@@ -120,7 +120,7 @@ static abstract class TargetInfo {
         final String desc;
 
         TargetInfo(String owner, String name, String desc) {
-            this.owner = JavaType.fromDescriptor(owner);
+            this.owner = JavaType.fromClassName(owner);
             this.name = name;
             this.desc = desc;
         }

File: archunit/src/test/java/com/tngtech/archunit/core/TestUtils.java
Patch:
@@ -304,7 +304,7 @@ public static DescribedPredicate<Object> predicateWithDescription(String descrip
     }
 
     public static <E extends Enum<?>> JavaEnumConstant enumConstant(E value) {
-        return new JavaEnumConstant(TypeDetails.of(value.getDeclaringClass().getName()), value.name());
+        return new JavaEnumConstant(simulateImport(value.getDeclaringClass(), simpleImportedClasses()), value.name());
     }
 
     static FieldAccessTarget targetFrom(JavaField field) {

File: archunit/src/test/java/com/tngtech/archunit/core/TestUtils.java
Patch:
@@ -113,7 +113,7 @@ public JavaClass get(String typeName) {
         }
 
         private JavaClass importNew(Class<?> owner) {
-            JavaClass result = new JavaClass.Builder().withType(TypeDetails.of(owner)).build();
+            JavaClass result = new JavaClass.Builder().withType(TypeDetails.of(owner.getName())).build();
             imported.put(result.getName(), result);
             return result;
         }
@@ -197,7 +197,7 @@ public Optional<JavaClass> answer(InvocationOnMock invocation) throws Throwable
     }
 
     private static JavaClass simulateImport(Class<?> owner, ImportedTestClasses importedClasses) {
-        JavaClass javaClass = new JavaClass.Builder().withType(TypeDetails.of(owner)).build();
+        JavaClass javaClass = new JavaClass.Builder().withType(TypeDetails.of(owner.getName())).build();
         importedClasses.register(javaClass);
         ImportContext context = simulateImportContext(owner, importedClasses);
         javaClass.completeMembers(context);
@@ -304,7 +304,7 @@ public static DescribedPredicate<Object> predicateWithDescription(String descrip
     }
 
     public static <E extends Enum<?>> JavaEnumConstant enumConstant(E value) {
-        return new JavaEnumConstant(TypeDetails.of(value.getDeclaringClass()), value.name());
+        return new JavaEnumConstant(TypeDetails.of(value.getDeclaringClass().getName()), value.name());
     }
 
     static FieldAccessTarget targetFrom(JavaField field) {

File: archunit/src/main/java/com/tngtech/archunit/core/ImportContext.java
Patch:
@@ -23,6 +23,8 @@ interface ImportContext {
 
     Map<String, JavaAnnotation> createAnnotations(JavaClass owner);
 
+    Optional<JavaClass> createEnclosingClass(JavaClass owner);
+
     Set<FieldAccessRecord> getFieldAccessRecordsFor(JavaCodeUnit codeUnit);
 
     Set<AccessRecord<MethodCallTarget>> getMethodCallRecordsFor(JavaCodeUnit codeUnit);

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClass.java
Patch:
@@ -409,7 +409,7 @@ void completeMembers(ImportContext context) {
     }
 
     CompletionProcess completeFrom(ImportContext context) {
-        enclosingClass = findClass(typeDetails.getEnclosingClass(), context);
+        enclosingClass = context.createEnclosingClass(this);
         return new CompletionProcess();
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/ImportContext.java
Patch:
@@ -9,6 +9,8 @@
 interface ImportContext {
     JavaClass getJavaClassWithType(String name);
 
+    Optional<JavaClass> createSuperClass(JavaClass owner);
+
     Set<JavaClass> createInterfaces(JavaClass owner);
 
     Set<JavaField> createFields(JavaClass owner);

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClass.java
Patch:
@@ -376,7 +376,7 @@ void completeClassHierarchyFrom(ImportContext context) {
     }
 
     private void completeSuperClassFrom(ImportContext context) {
-        superClass = findClass(typeDetails.getSuperclass(), context);
+        superClass = context.createSuperClass(this);
         if (superClass.isPresent()) {
             superClass.get().subClasses.add(this);
         }

File: archunit/src/main/java/com/tngtech/archunit/core/ImportContext.java
Patch:
@@ -9,6 +9,8 @@
 interface ImportContext {
     JavaClass getJavaClassWithType(String name);
 
+    Set<JavaClass> createInterfaces(JavaClass owner);
+
     Set<JavaField> createFields(JavaClass owner);
 
     Set<JavaMethod> createMethods(JavaClass owner);

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClass.java
Patch:
@@ -383,9 +383,7 @@ private void completeSuperClassFrom(ImportContext context) {
     }
 
     private void completeInterfacesFrom(ImportContext context) {
-        for (String interfaceName : typeDetails.getInterfaces()) {
-            interfaces.add(findClass(interfaceName, context));
-        }
+        interfaces.addAll(context.createInterfaces(this));
         for (JavaClass i : interfaces) {
             i.subClasses.add(this);
         }

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/DaoRulesTest.java
Patch:
@@ -10,10 +10,10 @@
 import org.junit.Ignore;
 import org.junit.Test;
 
-import static com.tngtech.archunit.core.DescribedPredicate.are;
 import static com.tngtech.archunit.lang.ArchRule.all;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.resideInAPackage;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.annotatedWith;
+import static com.tngtech.archunit.lang.conditions.ArchPredicates.are;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.named;
 
 public class DaoRulesTest {

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/SessionBeanRulesTest.java
Patch:
@@ -21,11 +21,11 @@
 import org.junit.Ignore;
 import org.junit.Test;
 
-import static com.tngtech.archunit.core.DescribedPredicate.are;
 import static com.tngtech.archunit.core.JavaClass.INTERFACES;
 import static com.tngtech.archunit.lang.ArchRule.all;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.never;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.setFieldWhere;
+import static com.tngtech.archunit.lang.conditions.ArchPredicates.are;
 
 public class SessionBeanRulesTest {
     private JavaClasses classes;

File: archunit/src/main/java/com/tngtech/archunit/core/AnnotationProxy.java
Patch:
@@ -127,6 +127,7 @@ public boolean canHandle(Object input) {
 
     private static class JavaEnumConstantConversion implements Conversion<JavaEnumConstant> {
         @Override
+        @MayResolveTypesViaReflection(reason = "We already depend on the classpath, if we proxy an annotation type")
         public Enum<?> convert(JavaEnumConstant input, Class<?> returnType) {
             for (Object constant : classForName(input.getType().getName()).getEnumConstants()) {
                 Enum<?> anEnum = (Enum<?>) constant;

File: archunit/src/main/java/com/tngtech/archunit/core/ClassFileProcessor.java
Patch:
@@ -136,6 +136,7 @@ private ClassResolverFromClassPath getClassResolver(MembersRecorder membersRecor
         return new ClassResolverFromClassPath(membersRecorder);
     }
 
+    @MayResolveTypesViaReflection(reason = "This is a dedicated option to resolve further dependencies from the classpath")
     static class ClassResolverFromClassPath implements ClassResolver {
         private final DeclarationHandler declarationHandler;
 

File: archunit/src/main/java/com/tngtech/archunit/core/ReflectionUtils.java
Patch:
@@ -42,6 +42,7 @@ static Class<?> classForName(String name) {
         return classForName(name, ReflectionUtils.class.getClassLoader());
     }
 
+    @MayResolveTypesViaReflection(reason = "This method is one of the known sources for resolving via reflection")
     static Optional<Class<?>> tryGetClassForName(String name) {
         try {
             return Optional.<Class<?>>of(classForName(name));

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsMethodsTest.java
Patch:
@@ -16,7 +16,7 @@
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
-import static com.tngtech.archunit.core.TestUtils.javaClasses;
+import static com.tngtech.archunit.core.TestUtils.javaClassesViaReflection;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsMethodsTest.ArchTestWithIgnoredMethod.toBeIgnored;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsMethodsTest.ArchTestWithIllegalTestMethods.noParams;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsMethodsTest.ArchTestWithIllegalTestMethods.tooManyParams;
@@ -52,7 +52,7 @@ public class ArchUnitRunnerRunsMethodsTest {
     @InjectMocks
     private ArchUnitRunner runner = newRunnerFor(ArchTestWithTestMethod.class);
 
-    private JavaClasses cachedClasses = javaClasses(ArchUnitRunnerRunsMethodsTest.class);
+    private JavaClasses cachedClasses = javaClassesViaReflection(ArchUnitRunnerRunsMethodsTest.class);
 
     @Before
     public void setUp() {

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsRuleFieldsTest.java
Patch:
@@ -19,7 +19,7 @@
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
-import static com.tngtech.archunit.core.TestUtils.javaClasses;
+import static com.tngtech.archunit.core.TestUtils.javaClassesViaReflection;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleFieldsTest.IgnoredArchTest.RULE_ONE_IN_IGNORED_TEST;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleFieldsTest.IgnoredArchTest.RULE_TWO_IN_IGNORED_TEST;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleFieldsTest.SomeArchTest.FAILING_FIELD_NAME;
@@ -61,7 +61,7 @@ public class ArchUnitRunnerRunsRuleFieldsTest {
     @InjectMocks
     private ArchUnitRunner runner = ArchUnitRunnerTestUtils.newRunnerFor(SomeArchTest.class);
 
-    private JavaClasses cachedClasses = javaClasses(ArchUnitRunnerRunsRuleFieldsTest.class);
+    private JavaClasses cachedClasses = javaClassesViaReflection(Object.class);
 
     @Before
     public void setUp() {

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsRuleSetsTest.java
Patch:
@@ -18,7 +18,7 @@
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
-import static com.tngtech.archunit.core.TestUtils.javaClasses;
+import static com.tngtech.archunit.core.TestUtils.javaClassesViaReflection;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleSetsTest.ArchTestWithRuleLibrary.someOtherMethodRuleName;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleSetsTest.Rules.someFieldRuleName;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleSetsTest.Rules.someMethodRuleName;
@@ -52,7 +52,7 @@ public class ArchUnitRunnerRunsRuleSetsTest {
     @InjectMocks
     private ArchUnitRunner runnerForRuleLibrary = newRunnerFor(ArchTestWithRuleLibrary.class);
 
-    private JavaClasses cachedClasses = javaClasses(ArchUnitRunnerRunsRuleSetsTest.class);
+    private JavaClasses cachedClasses = javaClassesViaReflection(ArchUnitRunnerRunsRuleSetsTest.class);
 
     @Before
     public void setUp() {

File: archunit/src/main/java/com/tngtech/archunit/core/ClassResolver.java
Patch:
@@ -1,10 +1,9 @@
 package com.tngtech.archunit.core;
 
 import java.util.Map;
-import java.util.Set;
 
 interface ClassResolver {
-    JavaClass resolve(String typeName);
+    Optional<JavaClass> resolve(String typeName, ImportedClasses.ByTypeName importedClasses);
 
-    Set<JavaClass> getAllSuperClasses(String className, Map<String, JavaClass> importedClasses);
+    Map<String, Optional<JavaClass>> getAllSuperClasses(String className, ImportedClasses.ByTypeName importedClasses);
 }

File: archunit/src/main/java/com/tngtech/archunit/core/HasParameters.java
Patch:
@@ -1,7 +1,5 @@
 package com.tngtech.archunit.core;
 
-import java.util.List;
-
 public interface HasParameters {
-    List<TypeDetails> getParameters();
+    JavaClassList getParameters();
 }

File: archunit/src/main/java/com/tngtech/archunit/core/JavaModifier.java
Patch:
@@ -15,7 +15,9 @@ public enum JavaModifier {
     FINAL(Opcodes.ACC_FINAL),
     VOLATILE(Opcodes.ACC_VOLATILE),
     TRANSIENT(Opcodes.ACC_TRANSIENT),
-    ABSTRACT(Opcodes.ACC_ABSTRACT);
+    ABSTRACT(Opcodes.ACC_ABSTRACT),
+    SYNCHRONIZED(Opcodes.ACC_SYNCHRONIZED),
+    NATIVE(Opcodes.ACC_NATIVE);
 
     private final int asmAccessFlag;
 

File: archunit/src/main/java/com/tngtech/archunit/core/JavaType.java
Patch:
@@ -33,7 +33,7 @@ class JavaType {
 
     private final String typeName;
 
-    JavaType(String typeName) {
+    private JavaType(String typeName) {
         this.typeName = typeName;
     }
 
@@ -48,7 +48,7 @@ static JavaType fromDescriptor(String descriptor) {
         return new JavaType(type.getClassName());
     }
 
-    public Class<?> asClass() {
+    Class<?> asClass() {
         return classForName(typeName);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/TypeDetails.java
Patch:
@@ -9,6 +9,7 @@
 import com.tngtech.archunit.core.ArchUnitException.ReflectionException;
 import org.objectweb.asm.Type;
 
+import static com.tngtech.archunit.core.Formatters.ensureSimpleName;
 import static com.tngtech.archunit.core.ReflectionUtils.classForName;
 
 public class TypeDetails {
@@ -41,7 +42,7 @@ private TypeDetails(Type type) {
 
     private TypeDetails(String fullName) {
         this.name = fullName;
-        this.simpleName = fullName.replaceAll("^.*(\\.|\\$)", "");
+        this.simpleName = ensureSimpleName(fullName);
         this.javaPackage = fullName.replaceAll("(\\.|\\$).*$", "");
         isInterface = false;
     }
@@ -100,7 +101,7 @@ public static List<TypeDetails> allOf(Class<?>... types) {
         return allOf(ImmutableList.copyOf(types));
     }
 
-    public static List<TypeDetails> allOf(Collection<Class<?>> types) {
+    private static List<TypeDetails> allOf(Collection<Class<?>> types) {
         ImmutableList.Builder<TypeDetails> result = ImmutableList.builder();
         for (Class<?> type : types) {
             result.add(TypeDetails.of(type));

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ArchConditions.java
Patch:
@@ -7,7 +7,6 @@
 import com.tngtech.archunit.core.JavaCall;
 import com.tngtech.archunit.core.JavaClass;
 import com.tngtech.archunit.core.JavaFieldAccess;
-import com.tngtech.archunit.core.TypeDetails;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.conditions.ClassAccessesFieldCondition.ClassGetsFieldCondition;
 import com.tngtech.archunit.lang.conditions.ClassAccessesFieldCondition.ClassSetsFieldCondition;
@@ -115,7 +114,7 @@ private MethodCallConditionCreator(String methodName, Class<?>[] params) {
         }
 
         public ArchCondition<JavaClass> in(Class<?> clazz) {
-            return callMethodWhere(callTarget().is(clazz, methodName, TypeDetails.allOf(params)));
+            return callMethodWhere(callTarget().is(clazz, methodName, params));
         }
 
         public ArchCondition<JavaClass> inHierarchyOf(Class<?> type) {

File: archunit/src/test/java/com/tngtech/archunit/core/AnnotationProxyTest.java
Patch:
@@ -17,7 +17,7 @@
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 
-import static com.tngtech.archunit.core.TestUtils.javaAnnotationOf;
+import static com.tngtech.archunit.core.TestUtils.javaAnnotationFrom;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class AnnotationProxyTest {
@@ -223,7 +223,7 @@ public void equals_hashcode_and_toString() {
 
     @Test
     public void wrong_annotation_type_is_rejected() {
-        JavaAnnotation mismatch = javaAnnotationOf(TestAnnotation.class.getAnnotation(Retention.class));
+        JavaAnnotation mismatch = javaAnnotationFrom(TestAnnotation.class.getAnnotation(Retention.class));
 
         thrown.expect(IllegalArgumentException.class);
         thrown.expectMessage(Retention.class.getSimpleName());
@@ -377,7 +377,7 @@ private boolean mismatch(String expectedPart) {
     }
 
     private <A extends Annotation> A getProxyFor(Class<A> annotationType) {
-        JavaAnnotation toProxy = javaAnnotationOf(Irrelevant.class.getAnnotation(annotationType));
+        JavaAnnotation toProxy = javaAnnotationFrom(Irrelevant.class.getAnnotation(annotationType));
         return AnnotationProxy.of(annotationType, toProxy);
     }
 }
\ No newline at end of file

File: archunit/src/test/java/com/tngtech/archunit/core/JavaCallTest.java
Patch:
@@ -2,14 +2,14 @@
 
 import org.junit.Test;
 
-import static com.tngtech.archunit.core.TestUtils.javaMethod;
+import static com.tngtech.archunit.core.TestUtils.javaMethodViaReflection;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class JavaCallTest {
     @Test
     public void get_target() {
-        JavaMethodCall call = TestUtils.simulateCall().from(javaMethod(getClass(), "toString"), 5)
-                .to(javaMethod(getClass(), "hashCode"));
+        JavaMethodCall call = TestUtils.simulateCall().from(javaMethodViaReflection(getClass(), "toString"), 5)
+                .to(javaMethodViaReflection(getClass(), "hashCode"));
 
         assertThat(JavaCall.GET_TARGET.apply(call)).isEqualTo(call.getTarget());
     }

File: archunit/src/test/java/com/tngtech/archunit/core/JavaMemberTest.java
Patch:
@@ -3,15 +3,15 @@
 import org.junit.Test;
 
 import static com.tngtech.archunit.core.JavaMember.modifier;
-import static com.tngtech.archunit.core.TestUtils.javaMethod;
+import static com.tngtech.archunit.core.TestUtils.javaMethodViaReflection;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 
 public class JavaMemberTest {
     @Test
     public void modifier_predicate() {
-        assertThat(modifier(JavaModifier.PRIVATE).apply(javaMethod(SomeClass.class, "isPrivate")))
+        assertThat(modifier(JavaModifier.PRIVATE).apply(javaMethodViaReflection(SomeClass.class, "isPrivate")))
                 .as("Predicate matches").isTrue();
-        assertThat(modifier(JavaModifier.PRIVATE).apply(javaMethod(SomeClass.class, "isNotPrivate")))
+        assertThat(modifier(JavaModifier.PRIVATE).apply(javaMethodViaReflection(SomeClass.class, "isNotPrivate")))
                 .as("Predicate matches").isFalse();
         assertThat(modifier(JavaModifier.PRIVATE).getDescription()).isEqualTo("modifier PRIVATE");
     }

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/CallPredicateTest.java
Patch:
@@ -1,7 +1,6 @@
 package com.tngtech.archunit.lang.conditions;
 
 import com.tngtech.archunit.core.JavaCall;
-import com.tngtech.archunit.core.TypeDetails;
 import org.junit.Test;
 
 import static com.tngtech.archunit.core.TestUtils.simulateCall;
@@ -26,7 +25,7 @@ public void combination_of_restrictions() {
 
     @Test
     public void descriptions() {
-        CallPredicate predicate = target().is(SomeClass.class, "someMethod", TypeDetails.allOf(String.class));
+        CallPredicate predicate = target().is(SomeClass.class, "someMethod", String.class);
         assertThat(predicate.getDescription())
                 .isEqualTo(String.format("target is %s.someMethod(String.class)", SomeClass.class.getName()));
 

File: archunit/src/main/java/com/tngtech/archunit/core/BuilderWithBuildParameter.java
Patch:
@@ -10,7 +10,7 @@ interface BuilderWithBuildParameter<PARAMETER, VALUE> {
     VALUE build(PARAMETER clazz);
 
     class BuildFinisher {
-        public static <PARAMETER, VALUE> Set<VALUE> build(Set<? extends BuilderWithBuildParameter<PARAMETER, ? extends VALUE>> builders, PARAMETER parameter) {
+        static <PARAMETER, VALUE> Set<VALUE> build(Set<? extends BuilderWithBuildParameter<PARAMETER, ? extends VALUE>> builders, PARAMETER parameter) {
             checkNotNull(builders);
             checkNotNull(parameter);
 

File: archunit/src/main/java/com/tngtech/archunit/core/JavaAnnotation.java
Patch:
@@ -63,7 +63,7 @@ public <A extends Annotation> A as(Class<A> annotationType) {
         return AnnotationProxy.of(annotationType, this);
     }
 
-    static ImmutableMap<String, JavaAnnotation> buildAnnotations(Set<Builder> annotations) {
+    static Map<String, JavaAnnotation> buildAnnotations(Set<Builder> annotations) {
         ImmutableMap.Builder<String, JavaAnnotation> result = ImmutableMap.builder();
         for (Builder annotationBuilder : annotations) {
             JavaAnnotation javaAnnotation = annotationBuilder.build();

File: archunit/src/main/java/com/tngtech/archunit/core/AccessContext.java
Patch:
@@ -28,7 +28,7 @@ static class Part extends AccessContext {
         Part() {
         }
 
-        Part(JavaCodeUnit<?, ?> codeUnit) {
+        Part(JavaCodeUnit codeUnit) {
             for (JavaFieldAccess access : codeUnit.getFieldAccesses()) {
                 fieldAccessesByTarget.put(access.getTarget().getOwner(), access);
             }

File: archunit/src/main/java/com/tngtech/archunit/core/HasOwner.java
Patch:
@@ -6,6 +6,6 @@ public interface HasOwner<T> {
     interface IsOwnedByClass extends HasOwner<JavaClass> {
     }
 
-    interface IsOwnedByCodeUnit extends HasOwner<JavaCodeUnit<?, ?>> {
+    interface IsOwnedByCodeUnit extends HasOwner<JavaCodeUnit> {
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/core/ImportContext.java
Patch:
@@ -6,11 +6,11 @@
 import com.tngtech.archunit.core.AccessTarget.MethodCallTarget;
 
 public interface ImportContext {
-    Set<FieldAccessRecord> getFieldAccessRecordsFor(JavaCodeUnit<?, ?> codeUnit);
+    Set<FieldAccessRecord> getFieldAccessRecordsFor(JavaCodeUnit codeUnit);
 
-    Set<AccessRecord<MethodCallTarget>> getMethodCallRecordsFor(JavaCodeUnit<?, ?> codeUnit);
+    Set<AccessRecord<MethodCallTarget>> getMethodCallRecordsFor(JavaCodeUnit codeUnit);
 
-    Set<AccessRecord<AccessTarget.ConstructorCallTarget>> getConstructorCallRecordsFor(JavaCodeUnit<?, ?> codeUnit);
+    Set<AccessRecord<AccessTarget.ConstructorCallTarget>> getConstructorCallRecordsFor(JavaCodeUnit codeUnit);
 
     Optional<JavaClass> tryGetJavaClassWithType(String name);
 }

File: archunit/src/main/java/com/tngtech/archunit/core/JavaConstructor.java
Patch:
@@ -1,13 +1,12 @@
 package com.tngtech.archunit.core;
 
-import java.lang.reflect.Constructor;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Set;
 
 import com.google.common.collect.ImmutableSet;
 
-public class JavaConstructor extends JavaCodeUnit<Constructor<?>, MemberDescription.ForConstructor> {
+public class JavaConstructor extends JavaCodeUnit {
     private Set<JavaConstructorCall> callsToSelf = Collections.emptySet();
 
     public static final String CONSTRUCTOR_NAME = "<init>";

File: archunit/src/main/java/com/tngtech/archunit/core/JavaField.java
Patch:
@@ -1,6 +1,5 @@
 package com.tngtech.archunit.core;
 
-import java.lang.reflect.Field;
 import java.util.Collections;
 import java.util.Set;
 
@@ -9,7 +8,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-public class JavaField extends JavaMember<Field, MemberDescription.ForField> {
+public class JavaField extends JavaMember {
     private final TypeDetails type;
     private Supplier<Set<JavaFieldAccess>> accessesToSelf = Suppliers.ofInstance(Collections.<JavaFieldAccess>emptySet());
 

File: archunit/src/main/java/com/tngtech/archunit/core/JavaMethod.java
Patch:
@@ -1,6 +1,5 @@
 package com.tngtech.archunit.core;
 
-import java.lang.reflect.Method;
 import java.util.Collections;
 import java.util.Set;
 
@@ -9,7 +8,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-public class JavaMethod extends JavaCodeUnit<Method, MemberDescription.ForMethod> {
+public class JavaMethod extends JavaCodeUnit {
     private Supplier<Set<JavaMethodCall>> callsToSelf = Suppliers.ofInstance(Collections.<JavaMethodCall>emptySet());
 
     private JavaMethod(Builder builder) {

File: archunit/src/main/java/com/tngtech/archunit/core/JavaStaticInitializer.java
Patch:
@@ -1,12 +1,11 @@
 package com.tngtech.archunit.core;
 
-import java.lang.reflect.Method;
 import java.util.Collections;
 import java.util.Set;
 
 import static java.util.Collections.emptySet;
 
-public class JavaStaticInitializer extends JavaCodeUnit<Method, MemberDescription.ForMethod> {
+public class JavaStaticInitializer extends JavaCodeUnit {
     public static final String STATIC_INITIALIZER_NAME = "<clinit>";
 
     private JavaStaticInitializer(Builder builder) {

File: archunit/src/main/java/com/tngtech/archunit/core/RawAccessRecord.java
Patch:
@@ -106,7 +106,7 @@ public String toString() {
                     '}';
         }
 
-        public boolean is(JavaCodeUnit<?, ?> method) {
+        public boolean is(JavaCodeUnit method) {
             return getName().equals(method.getName())
                     && getParameters().equals(method.getParameters())
                     && getDeclaringClassName().equals(method.getOwner().getName());

File: archunit/src/test/java/com/tngtech/archunit/core/JavaClassTest.java
Patch:
@@ -37,7 +37,7 @@ public void finds_fields_and_methods() {
         for (JavaField field : javaClass.getFields()) {
             assertThat(field.getOwner()).isSameAs(javaClass);
         }
-        for (JavaCodeUnit<?, ?> method : javaClass.getCodeUnits()) {
+        for (JavaCodeUnit method : javaClass.getCodeUnits()) {
             assertThat(method.getOwner()).isSameAs(javaClass);
         }
     }

File: archunit/src/test/java/com/tngtech/archunit/core/TestUtils.java
Patch:
@@ -90,7 +90,7 @@ public Optional<JavaClass> answer(InvocationOnMock invocation) throws Throwable
         });
         javaClass.completeClassHierarchyFrom(context);
         javaClass.completeFrom(context);
-        for (JavaCodeUnit<?, ?> unit : javaClass.getCodeUnits()) {
+        for (JavaCodeUnit unit : javaClass.getCodeUnits()) {
             unit.completeFrom(context);
         }
         return javaClass;
@@ -251,7 +251,7 @@ public TestAccessRecord(T target) {
             }
 
             @Override
-            public JavaCodeUnit<?, ?> getCaller() {
+            public JavaCodeUnit getCaller() {
                 return method;
             }
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/Conditions.java
Patch:
@@ -22,11 +22,11 @@ public boolean matches(Iterable<? extends T> value) {
         }.as("containing an element that " + condition.description());
     }
 
-    public static Condition<JavaCodeUnit<?, ?>> codeUnitWithSignature(final String name, final Class<?>... parameters) {
+    public static Condition<JavaCodeUnit> codeUnitWithSignature(final String name, final Class<?>... parameters) {
         final List<TypeDetails> paramList = TypeDetails.allOf(parameters);
-        return new Condition<JavaCodeUnit<?, ?>>() {
+        return new Condition<JavaCodeUnit>() {
             @Override
-            public boolean matches(JavaCodeUnit<?, ?> value) {
+            public boolean matches(JavaCodeUnit value) {
                 return name.equals(value.getName()) && paramList.equals(value.getParameters());
             }
         }.as("matches signature <" + name + ", " + paramList + ">");

File: archunit/src/main/java/com/tngtech/archunit/core/JavaCodeUnit.java
Patch:
@@ -28,6 +28,7 @@ public abstract class JavaCodeUnit<M extends Member, T extends MemberDescription
         extends JavaMember<M, T>
         implements HasParameters {
 
+    final T memberDescription;
     private Set<JavaFieldAccess> fieldAccesses;
     private Set<JavaMethodCall> methodCalls;
     private Set<JavaConstructorCall> constructorCalls;
@@ -38,7 +39,8 @@ public abstract class JavaCodeUnit<M extends Member, T extends MemberDescription
     }
 
     JavaCodeUnit(T memberDescription, JavaClass owner) {
-        super(memberDescription, owner);
+        super(owner, memberDescription.getAnnotations(), memberDescription.getName(), memberDescription.getDescriptor(), JavaModifier.getModifiersFor(memberDescription.getModifiers()));
+        this.memberDescription = memberDescription;
         fullName = formatMethod(getOwner().getName(), getName(), getParameters());
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/JavaFieldTest.java
Patch:
@@ -25,9 +25,9 @@ public void incompatible_owner_is_rejected() throws Exception {
 
     @Test
     public void hasType_works() {
-        assertThat(JavaField.hasType(DescribedPredicate.<Class<?>>equalTo(SomeEnum.class))
+        assertThat(JavaField.hasType(DescribedPredicate.equalTo(TypeDetails.of(SomeEnum.class)))
                 .apply(fieldWithType(SomeEnum.class))).as("Predicate matches").isTrue();
-        assertThat(JavaField.hasType(DescribedPredicate.<Class<?>>equalTo(Serializable.class))
+        assertThat(JavaField.hasType(DescribedPredicate.equalTo(TypeDetails.of(Serializable.class)))
                 .apply(fieldWithType(SomeEnum.class))).as("Predicate matches").isFalse();
 
         assertThat(JavaField.hasType(predicateWithDescription("something")).getDescription())
@@ -36,7 +36,7 @@ public void hasType_works() {
 
     private JavaField fieldWithType(Class<?> type) {
         JavaField result = javaField(SomeClass.class, "other");
-        checkState(result.getType() == type, "field doesn't have the type the test expects anymore");
+        checkState(result.getType().equals(TypeDetails.of(type)), "field doesn't have the type the test expects anymore");
         return result;
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -58,7 +58,7 @@ public void isEquivalentTo(Field field) {
             assertThat(javaField.getName()).isEqualTo(field.getName());
             assertThat(javaField.getFullName()).isEqualTo(field.getDeclaringClass().getName() + "." + field.getName());
             assertThat(javaField.getOwner().reflect()).isEqualTo(field.getDeclaringClass());
-            assertThat(javaField.getType()).isEqualTo(field.getType());
+            assertThat(javaField.getType()).isEqualTo(TypeDetails.of(field.getType()));
             assertThat(javaField.getModifiers()).isEqualTo(getModifiersFor(field.getModifiers()));
             assertThat(propertiesOf(javaField.getAnnotations())).isEqualTo(propertiesOf(field.getAnnotations()));
         }

File: archunit/src/main/java/com/tngtech/archunit/core/MemberDescription.java
Patch:
@@ -47,7 +47,7 @@ public int getModifiers() {
 
         @Override
         public Set<JavaAnnotation> getAnnotationsFor(JavaMember<?, ?> owner) {
-            return JavaAnnotation.of(owner, member.getAnnotations());
+            return JavaAnnotation.of(member.getAnnotations());
         }
 
         @Override

File: archunit/src/main/java/com/tngtech/archunit/core/JavaAnnotation.java
Patch:
@@ -16,8 +16,8 @@ private JavaAnnotation(Builder builder) {
         owner = builder.owner;
     }
 
-    public Class<?> getType() {
-        return annotation.annotationType();
+    public TypeDetails getType() {
+        return TypeDetails.of(annotation.annotationType());
     }
 
     @Override
@@ -27,7 +27,7 @@ public Class<?> getType() {
 
     public Object get(String annotationMethodName) {
         try {
-            Object result = getType().getMethod(annotationMethodName).invoke(annotation);
+            Object result = annotation.annotationType().getMethod(annotationMethodName).invoke(annotation);
             if (result instanceof Class) {
                 return TypeDetails.of((Class<?>) result);
             }

File: archunit/src/main/java/com/tngtech/archunit/core/ClassFileImportContext.java
Patch:
@@ -606,7 +606,7 @@ public int getModifiers() {
         }
 
         @Override
-        public Set<JavaAnnotation<?>> getAnnotationsFor(JavaMember<?, ?> owner) {
+        public Set<JavaAnnotation> getAnnotationsFor(JavaMember<?, ?> owner) {
             return emptySet();
         }
 

File: archunit/src/main/java/com/tngtech/archunit/core/JavaStaticInitializer.java
Patch:
@@ -68,7 +68,7 @@ public int getModifiers() {
         }
 
         @Override
-        public Set<JavaAnnotation<?>> getAnnotationsFor(JavaMember<?, ?> owner) {
+        public Set<JavaAnnotation> getAnnotationsFor(JavaMember<?, ?> owner) {
             return emptySet();
         }
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -62,9 +62,9 @@ public void isEquivalentTo(Field field) {
             assertThat(propertiesOf(javaField.getAnnotations())).isEqualTo(propertiesOf(field.getAnnotations()));
         }
 
-        private Set<Map<String, Object>> propertiesOf(Set<JavaAnnotation<?>> annotations) {
+        private Set<Map<String, Object>> propertiesOf(Set<JavaAnnotation> annotations) {
             Set<Map<String, Object>> result = new HashSet<>();
-            for (JavaAnnotation<?> annotation : annotations) {
+            for (JavaAnnotation annotation : annotations) {
                 result.add(annotation.getProperties());
             }
             return result;

File: archunit/src/main/java/com/tngtech/archunit/core/JavaCodeUnit.java
Patch:
@@ -24,7 +24,9 @@
  * @param <T> The type of the description for this member; the description is an abstraction in case there are problems
  *            in determining a fitting {@link Member java.lang.reflect.Member}
  */
-public abstract class JavaCodeUnit<M extends Member, T extends MemberDescription<M>> extends JavaMember<M, T> implements HasParameters {
+public abstract class JavaCodeUnit<M extends Member, T extends MemberDescription<M>>
+        extends JavaMember<M, T>
+        implements HasParameters {
 
     private Set<JavaFieldAccess> fieldAccesses;
     private Set<JavaMethodCall> methodCalls;

File: archunit/src/test/java/com/tngtech/archunit/core/TestJarFile.java
Patch:
@@ -9,8 +9,6 @@
 import java.util.jar.JarOutputStream;
 import java.util.zip.ZipEntry;
 
-import org.assertj.core.util.Files;
-
 import static com.google.common.io.ByteStreams.toByteArray;
 
 class TestJarFile {
@@ -22,7 +20,7 @@ TestJarFile withEntry(String entry) {
     }
 
     JarFile create() {
-        File folder = Files.newTemporaryFolder();
+        File folder = TestUtils.newTemporaryFolder();
         File file = new File(folder, "test.jar");
 
         try (JarOutputStream jarOut = new JarOutputStream(new FileOutputStream(file))) {

File: archunit/src/main/java/com/tngtech/archunit/core/DescribedIterable.java
Patch:
@@ -1,9 +1,7 @@
-package com.tngtech.archunit.lang;
+package com.tngtech.archunit.core;
 
 import java.util.Iterator;
 
-import com.tngtech.archunit.core.HasDescription;
-
 public interface DescribedIterable<T> extends Iterable<T>, HasDescription {
     class From {
         public static <T> DescribedIterable<T> iterable(final Iterable<T> iterable, final String description) {

File: archunit/src/main/java/com/tngtech/archunit/core/Formatters.java
Patch:
@@ -11,13 +11,13 @@ public class Formatters {
     private Formatters() {
     }
 
-    public static String formatMethod(String ownerName, String methodName, List<Class<?>> parameters) {
+    public static String formatMethod(String ownerName, String methodName, List<TypeDetails> parameters) {
         return String.format(FULL_METHOD_NAME_TEMPLATE, ownerName, methodName, formatMethodParameters(parameters));
     }
 
-    public static String formatMethodParameters(List<Class<?>> parameters) {
+    public static String formatMethodParameters(List<TypeDetails> parameters) {
         List<String> formatted = new ArrayList<>();
-        for (Class<?> type : parameters) {
+        for (TypeDetails type : parameters) {
             formatted.add(String.format("%s.class", type.getSimpleName()));
         }
         return Joiner.on(", ").join(formatted);

File: archunit/src/main/java/com/tngtech/archunit/core/ImportWorkaround.java
Patch:
@@ -17,12 +17,12 @@ class ImportWorkaround {
     static Set<JavaClass> getAllSuperClasses(String typeName) {
         ImmutableSet.Builder<JavaClass> result = ImmutableSet.builder();
         for (Class<?> type : getAllSuperTypes(classForName(typeName))) {
-            result.add(new JavaClass.Builder().withType(new TypeDetails(type)).build());
+            result.add(new JavaClass.Builder().withType(TypeDetails.of(type)).build());
         }
         return result.build();
     }
 
     static JavaClass resolveClass(String typeName) {
-        return new JavaClass.Builder().withType(new TypeDetails(classForName(typeName))).build();
+        return new JavaClass.Builder().withType(TypeDetails.of(classForName(typeName))).build();
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClasses.java
Patch:
@@ -7,7 +7,6 @@
 import java.util.Set;
 
 import com.google.common.collect.ImmutableMap;
-import com.tngtech.archunit.lang.DescribedIterable;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 

File: archunit/src/main/java/com/tngtech/archunit/core/JavaCodeUnit.java
Patch:
@@ -45,9 +45,9 @@ public String getFullName() {
         return fullName;
     }
 
-    public abstract List<Class<?>> getParameters();
+    public abstract List<TypeDetails> getParameters();
 
-    public static DescribedPredicate<JavaCodeUnit<?, ?>> hasParameters(final List<Class<?>> paramTypes) {
+    public static DescribedPredicate<JavaCodeUnit<?, ?>> hasParameters(final List<TypeDetails> paramTypes) {
         return new DescribedPredicate<JavaCodeUnit<?, ?>>("has parameters [%s]", formatMethodParameters(paramTypes)) {
             @Override
             public boolean apply(JavaCodeUnit<?, ?> input) {
@@ -56,7 +56,7 @@ public boolean apply(JavaCodeUnit<?, ?> input) {
         };
     }
 
-    public abstract Class<?> getReturnType();
+    public abstract TypeDetails getReturnType();
 
     public Set<JavaFieldAccess> getFieldAccesses() {
         return fieldAccesses;

File: archunit/src/main/java/com/tngtech/archunit/core/JavaConstructor.java
Patch:
@@ -19,13 +19,13 @@ private JavaConstructor(Builder builder) {
     }
 
     @Override
-    public List<Class<?>> getParameters() {
+    public List<TypeDetails> getParameters() {
         return Lists.newArrayList(memberDescription.getParameterTypes());
     }
 
     @Override
-    public Class<?> getReturnType() {
-        return void.class;
+    public TypeDetails getReturnType() {
+        return TypeDetails.of(void.class);
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/lang/InputTransformer.java
Patch:
@@ -1,5 +1,6 @@
 package com.tngtech.archunit.lang;
 
+import com.tngtech.archunit.core.DescribedIterable;
 import com.tngtech.archunit.core.DescribedPredicate;
 import com.tngtech.archunit.core.Guava;
 import com.tngtech.archunit.core.HasDescription;

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ArchConditions.java
Patch:
@@ -7,6 +7,7 @@
 import com.tngtech.archunit.core.JavaCall;
 import com.tngtech.archunit.core.JavaClass;
 import com.tngtech.archunit.core.JavaFieldAccess;
+import com.tngtech.archunit.core.TypeDetails;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.conditions.ClassAccessesFieldCondition.ClassGetsFieldCondition;
 import com.tngtech.archunit.lang.conditions.ClassAccessesFieldCondition.ClassSetsFieldCondition;
@@ -114,7 +115,7 @@ private MethodCallConditionCreator(String methodName, Class<?>[] params) {
         }
 
         public ArchCondition<JavaClass> in(Class<?> clazz) {
-            return callMethodWhere(callTarget().is(clazz, methodName, params));
+            return callMethodWhere(callTarget().is(clazz, methodName, TypeDetails.allOf(params)));
         }
 
         public ArchCondition<JavaClass> inHierarchyOf(Class<?> type) {

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Slices.java
Patch:
@@ -8,10 +8,10 @@
 import java.util.Set;
 
 import com.tngtech.archunit.core.Dependency;
+import com.tngtech.archunit.core.DescribedIterable;
 import com.tngtech.archunit.core.JavaClass;
 import com.tngtech.archunit.core.JavaClasses;
 import com.tngtech.archunit.core.Optional;
-import com.tngtech.archunit.lang.DescribedIterable;
 import com.tngtech.archunit.lang.InputTransformer;
 import com.tngtech.archunit.lang.conditions.PackageMatcher;
 

File: archunit/src/test/java/com/tngtech/archunit/core/JavaClassesTest.java
Patch:
@@ -8,8 +8,8 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class JavaClassesTest {
-    public static final JavaClass SOME_CLASS = new JavaClass.Builder().withType(new TypeDetails(SomeClass.class)).build();
-    public static final JavaClass SOME_OTHER_CLASS = new JavaClass.Builder().withType(new TypeDetails(SomeOtherClass.class)).build();
+    public static final JavaClass SOME_CLASS = new JavaClass.Builder().withType(TypeDetails.of(SomeClass.class)).build();
+    public static final JavaClass SOME_OTHER_CLASS = new JavaClass.Builder().withType(TypeDetails.of(SomeOtherClass.class)).build();
     private static final ImmutableMap<String, JavaClass> BY_RAW_CLASS = ImmutableMap.of(
             SomeClass.class.getName(), SOME_CLASS,
             SomeOtherClass.class.getName(), SOME_OTHER_CLASS);

File: archunit/src/test/java/com/tngtech/archunit/core/JavaCodeUnitTest.java
Patch:
@@ -14,13 +14,13 @@ public void hasParameters() {
         JavaMethod method = javaMethod(SomeClass.class, "withArgs", Object.class, String.class);
 
         DescribedPredicate<JavaCodeUnit<?, ?>> predicate =
-                JavaCodeUnit.hasParameters(Collections.<Class<?>>singletonList(Object.class));
+                JavaCodeUnit.hasParameters(TypeDetails.allOf(Collections.<Class<?>>singletonList(Object.class)));
 
         assertThat(predicate.apply(method)).as("Predicate matches").isFalse();
         assertThat(predicate.getDescription()).isEqualTo("has parameters [Object.class]");
 
         predicate =
-                JavaCodeUnit.hasParameters(Arrays.asList(Object.class, String.class));
+                JavaCodeUnit.hasParameters(TypeDetails.allOf(Arrays.asList(Object.class, String.class)));
 
         assertThat(predicate.apply(method)).as("Predicate matches").isTrue();
         assertThat(predicate.getDescription()).isEqualTo("has parameters [Object.class, String.class]");

File: archunit/src/test/java/com/tngtech/archunit/core/JavaFieldAccessTest.java
Patch:
@@ -10,7 +10,7 @@
 public class JavaFieldAccessTest {
     @Test
     public void equals_should_work() throws Exception {
-        JavaClass clazz = new JavaClass.Builder().withType(new TypeDetails(SomeClass.class)).build();
+        JavaClass clazz = new JavaClass.Builder().withType(TypeDetails.of(SomeClass.class)).build();
         JavaFieldAccess access = new JavaFieldAccess(stringFieldAccessRecordBuilder(clazz)
                 .withCaller(accessFieldMethod(clazz))
                 .build());
@@ -48,7 +48,7 @@ public void equals_should_work() throws Exception {
     @Test
     public void fieldAccess_should_have_same_name_as_target() throws Exception {
 
-        JavaClass clazz = new JavaClass.Builder().withType(new TypeDetails(SomeClass.class)).build();
+        JavaClass clazz = new JavaClass.Builder().withType(TypeDetails.of(SomeClass.class)).build();
 
         JavaFieldAccess access = new JavaFieldAccess(stringFieldAccessRecordBuilder(clazz)
                 .withCaller(accessFieldMethod(clazz))

File: archunit/src/test/java/com/tngtech/archunit/core/TestUtils.java
Patch:
@@ -39,7 +39,7 @@ public static JavaMethod javaMethod(JavaClass clazz, Method method) {
     }
 
     public static JavaClass javaClass(Class<?> owner) {
-        JavaClass javaClass = new JavaClass.Builder().withType(new TypeDetails(owner)).build();
+        JavaClass javaClass = new JavaClass.Builder().withType(TypeDetails.of(owner)).build();
         ClassFileImportContext context = mock(ClassFileImportContext.class);
         when(context.tryGetJavaClassWithType(anyString())).thenAnswer(new Answer<Optional<JavaClass>>() {
             @Override

File: archunit/src/test/java/com/tngtech/archunit/lang/InputTransformerTest.java
Patch:
@@ -3,6 +3,7 @@
 import java.util.HashSet;
 import java.util.Set;
 
+import com.tngtech.archunit.core.DescribedIterable;
 import com.tngtech.archunit.core.DescribedPredicate;
 import com.tngtech.archunit.core.JavaClass;
 import com.tngtech.archunit.core.JavaClasses;

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/CallPredicateTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.tngtech.archunit.lang.conditions;
 
 import com.tngtech.archunit.core.JavaCall;
+import com.tngtech.archunit.core.TypeDetails;
 import org.junit.Test;
 
 import static com.tngtech.archunit.core.TestUtils.simulateCall;
@@ -25,7 +26,7 @@ public void combination_of_restrictions() {
 
     @Test
     public void descriptions() {
-        CallPredicate predicate = target().is(SomeClass.class, "someMethod", String.class);
+        CallPredicate predicate = target().is(SomeClass.class, "someMethod", TypeDetails.allOf(String.class));
         assertThat(predicate.getDescription())
                 .isEqualTo(String.format("target is %s.someMethod(String.class)", SomeClass.class.getName()));
 

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/MethodCallConditionTest.java
Patch:
@@ -3,9 +3,9 @@
 import java.util.Collection;
 import java.util.List;
 
-import com.google.common.collect.Lists;
 import com.tngtech.archunit.core.JavaCall;
 import com.tngtech.archunit.core.JavaClass;
+import com.tngtech.archunit.core.TypeDetails;
 import com.tngtech.archunit.lang.ConditionEvent;
 import com.tngtech.archunit.lang.ConditionEvents;
 import org.assertj.core.api.Condition;
@@ -143,7 +143,7 @@ private JavaCall<?> callToTargetIn(Collection<? extends JavaCall<?>> calls) {
     private static class MethodCallConditionBuilder {
         private Class<?> targetClass;
         private String methodName;
-        private List<Class<?>> paramTypes;
+        private List<TypeDetails> paramTypes;
 
         private MethodCallConditionBuilder(MethodCallToAnalyse callToAnalyse) {
             targetClass = callToAnalyse.call.getTarget().getOwner().reflect();
@@ -162,7 +162,7 @@ public MethodCallConditionBuilder withName(String methodName) {
         }
 
         public MethodCallConditionBuilder withParameters(Class<?> paramTypes) {
-            this.paramTypes = Lists.<Class<?>>newArrayList(paramTypes);
+            this.paramTypes = TypeDetails.allOf(paramTypes);
             return this;
         }
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/Conditions.java
Patch:
@@ -2,8 +2,8 @@
 
 import java.util.List;
 
-import com.google.common.collect.ImmutableList;
 import com.tngtech.archunit.core.JavaCodeUnit;
+import com.tngtech.archunit.core.TypeDetails;
 import org.assertj.core.api.Condition;
 
 public final class Conditions {
@@ -23,7 +23,7 @@ public boolean matches(Iterable<? extends T> value) {
     }
 
     public static Condition<JavaCodeUnit<?, ?>> codeUnitWithSignature(final String name, final Class<?>... parameters) {
-        final List<Class<?>> paramList = ImmutableList.copyOf(parameters);
+        final List<TypeDetails> paramList = TypeDetails.allOf(parameters);
         return new Condition<JavaCodeUnit<?, ?>>() {
             @Override
             public boolean matches(JavaCodeUnit<?, ?> value) {

File: archunit/src/main/java/com/tngtech/archunit/core/JavaModifier.java
Patch:
@@ -23,7 +23,7 @@ public enum JavaModifier {
         this.asmAccessFlag = asmAccessFlag;
     }
 
-    static Set<JavaModifier> getModifiersFor(int asmAccess) {
+    public static Set<JavaModifier> getModifiersFor(int asmAccess) {
         Set<JavaModifier> result = new HashSet<>();
         for (JavaModifier modifier : JavaModifier.values()) {
             if ((modifier.asmAccessFlag & asmAccess) != 0) {

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ArchPredicates.java
Patch:
@@ -120,7 +120,7 @@ public static DescribedPredicate<JavaFieldAccess> targetTypeResidesIn(String pac
         return new DescribedPredicate<JavaFieldAccess>("target type resides in '%s'", packageIdentifier) {
             @Override
             public boolean apply(JavaFieldAccess input) {
-                Class<?> fieldType = input.getTarget().reflect().getType();
+                Class<?> fieldType = input.getTarget().getType();
 
                 return fieldType.getPackage() != null &&
                         packageMatcher.matches(fieldType.getPackage().getName());

File: archunit/src/test/java/com/tngtech/archunit/core/testexamples/fieldimport/ClassWithStringField.java
Patch:
@@ -1,5 +1,6 @@
 package com.tngtech.archunit.core.testexamples.fieldimport;
 
 public class ClassWithStringField {
+    @Deprecated
     private String stringField;
 }

File: archunit/src/main/java/com/tngtech/archunit/core/ClassFileImportContext.java
Patch:
@@ -170,7 +170,7 @@ public JavaField getTarget() {
             }
 
             private JavaField createFieldFor(TargetInfo targetInfo) {
-                JavaClass owner = new JavaClass.Builder().withType(targetInfo.owner.asClass()).build();
+                JavaClass owner = new JavaClass.Builder().withType(new TypeDetails(targetInfo.owner.asClass())).build();
                 return createField(targetInfo, owner);
             }
 
@@ -231,7 +231,7 @@ public JavaConstructor getTarget() {
             }
 
             private JavaConstructor createConstructorFor(TargetInfo targetInfo) {
-                JavaClass owner = new JavaClass.Builder().withType(targetInfo.owner.asClass()).build();
+                JavaClass owner = new JavaClass.Builder().withType(new TypeDetails(targetInfo.owner.asClass())).build();
                 return createConstructor(targetInfo, owner);
             }
 
@@ -284,7 +284,7 @@ public JavaMethod getTarget() {
             }
 
             private JavaMethod createMethodFor(TargetInfo targetInfo) {
-                JavaClass owner = new JavaClass.Builder().withType(targetInfo.owner.asClass()).build();
+                JavaClass owner = new JavaClass.Builder().withType(new TypeDetails(targetInfo.owner.asClass())).build();
                 return createMethod(targetInfo, owner);
             }
 

File: archunit/src/main/java/com/tngtech/archunit/core/ClassFileProcessor.java
Patch:
@@ -119,7 +119,7 @@ void init(String classDescriptor) {
         private void tryInit(String classDescriptor) {
             currentClass = classForDescriptor(classDescriptor);
             codeUnitRecorder = new CodeUnitRecorder(currentClass);
-            currentClassBuilder = new JavaClass.Builder(codeUnitRecorder).withType(currentClass);
+            currentClassBuilder = new JavaClass.Builder(codeUnitRecorder).withType(new TypeDetails(currentClass));
         }
 
         private Class<?> classForDescriptor(String descriptor) {

File: archunit/src/main/java/com/tngtech/archunit/core/ImportWorkaround.java
Patch:
@@ -17,12 +17,12 @@ class ImportWorkaround {
     static Set<JavaClass> getAllSuperClasses(String typeName) {
         ImmutableSet.Builder<JavaClass> result = ImmutableSet.builder();
         for (Class<?> type : getAllSuperTypes(classForName(typeName))) {
-            result.add(new JavaClass.Builder().withType(type).build());
+            result.add(new JavaClass.Builder().withType(new TypeDetails(type)).build());
         }
         return result.build();
     }
 
     static JavaClass resolveClass(String typeName) {
-        return new JavaClass.Builder().withType(classForName(typeName)).build();
+        return new JavaClass.Builder().withType(new TypeDetails(classForName(typeName))).build();
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/core/ClassFileImporterTest.java
Patch:
@@ -1134,7 +1134,7 @@ public void imports_urls_of_files() {
 
         JavaClasses classes = new ClassFileImporter().importUrls(urls);
         FluentIterable<JavaClass> classesFoundAtUrls = FluentIterable.from(classes)
-                .filter(not(equalTo(new JavaClass.Builder().withType(Object.class).build())));
+                .filter(not(equalTo(new JavaClass.Builder().withType(new TypeDetails(Object.class)).build())));
 
         assertThat(classesFoundAtUrls).as("Number of classes at the given URLs").hasSize(2);
     }

File: archunit/src/test/java/com/tngtech/archunit/core/JavaClassesTest.java
Patch:
@@ -8,8 +8,8 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class JavaClassesTest {
-    public static final JavaClass SOME_CLASS = new JavaClass.Builder().withType(SomeClass.class).build();
-    public static final JavaClass SOME_OTHER_CLASS = new JavaClass.Builder().withType(SomeOtherClass.class).build();
+    public static final JavaClass SOME_CLASS = new JavaClass.Builder().withType(new TypeDetails(SomeClass.class)).build();
+    public static final JavaClass SOME_OTHER_CLASS = new JavaClass.Builder().withType(new TypeDetails(SomeOtherClass.class)).build();
     private static final ImmutableMap<String, JavaClass> BY_RAW_CLASS = ImmutableMap.of(
             SomeClass.class.getName(), SOME_CLASS,
             SomeOtherClass.class.getName(), SOME_OTHER_CLASS);

File: archunit/src/test/java/com/tngtech/archunit/core/TestUtils.java
Patch:
@@ -36,7 +36,7 @@ public static JavaMethod javaMethod(JavaClass clazz, Method method) {
     }
 
     public static JavaClass javaClass(Class<?> owner) {
-        JavaClass javaClass = new JavaClass.Builder().withType(owner).build();
+        JavaClass javaClass = new JavaClass.Builder().withType(new TypeDetails(owner)).build();
         ClassFileImportContext context = mock(ClassFileImportContext.class);
         when(context.tryGetJavaClassWithType(anyString())).thenAnswer(new Answer<Optional<JavaClass>>() {
             @Override

File: archunit/src/main/java/com/tngtech/archunit/core/ImportContext.java
Patch:
@@ -9,6 +9,8 @@
 interface ImportContext {
     JavaClass getJavaClassWithType(String name);
 
+    Optional<JavaClass> createSuperClass(JavaClass owner);
+
     Set<JavaClass> createInterfaces(JavaClass owner);
 
     Set<JavaField> createFields(JavaClass owner);

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClass.java
Patch:
@@ -376,7 +376,7 @@ void completeClassHierarchyFrom(ImportContext context) {
     }
 
     private void completeSuperClassFrom(ImportContext context) {
-        superClass = findClass(typeDetails.getSuperclass(), context);
+        superClass = context.createSuperClass(this);
         if (superClass.isPresent()) {
             superClass.get().subClasses.add(this);
         }

File: archunit/src/main/java/com/tngtech/archunit/core/ImportContext.java
Patch:
@@ -9,6 +9,8 @@
 interface ImportContext {
     JavaClass getJavaClassWithType(String name);
 
+    Set<JavaClass> createInterfaces(JavaClass owner);
+
     Set<JavaField> createFields(JavaClass owner);
 
     Set<JavaMethod> createMethods(JavaClass owner);

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClass.java
Patch:
@@ -383,9 +383,7 @@ private void completeSuperClassFrom(ImportContext context) {
     }
 
     private void completeInterfacesFrom(ImportContext context) {
-        for (String interfaceName : typeDetails.getInterfaces()) {
-            interfaces.add(findClass(interfaceName, context));
-        }
+        interfaces.addAll(context.createInterfaces(this));
         for (JavaClass i : interfaces) {
             i.subClasses.add(this);
         }

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/DaoRulesTest.java
Patch:
@@ -10,10 +10,10 @@
 import org.junit.Ignore;
 import org.junit.Test;
 
-import static com.tngtech.archunit.core.DescribedPredicate.are;
 import static com.tngtech.archunit.lang.ArchRule.all;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.resideInAPackage;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.annotatedWith;
+import static com.tngtech.archunit.lang.conditions.ArchPredicates.are;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.named;
 
 public class DaoRulesTest {

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/SessionBeanRulesTest.java
Patch:
@@ -21,11 +21,11 @@
 import org.junit.Ignore;
 import org.junit.Test;
 
-import static com.tngtech.archunit.core.DescribedPredicate.are;
 import static com.tngtech.archunit.core.JavaClass.INTERFACES;
 import static com.tngtech.archunit.lang.ArchRule.all;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.never;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.setFieldWhere;
+import static com.tngtech.archunit.lang.conditions.ArchPredicates.are;
 
 public class SessionBeanRulesTest {
     private JavaClasses classes;

File: archunit/src/main/java/com/tngtech/archunit/core/AnnotationProxy.java
Patch:
@@ -127,6 +127,7 @@ public boolean canHandle(Object input) {
 
     private static class JavaEnumConstantConversion implements Conversion<JavaEnumConstant> {
         @Override
+        @MayResolveTypesViaReflection(reason = "We already depend on the classpath, if we proxy an annotation type")
         public Enum<?> convert(JavaEnumConstant input, Class<?> returnType) {
             for (Object constant : classForName(input.getType().getName()).getEnumConstants()) {
                 Enum<?> anEnum = (Enum<?>) constant;

File: archunit/src/main/java/com/tngtech/archunit/core/ClassFileProcessor.java
Patch:
@@ -136,6 +136,7 @@ private ClassResolverFromClassPath getClassResolver(MembersRecorder membersRecor
         return new ClassResolverFromClassPath(membersRecorder);
     }
 
+    @MayResolveTypesViaReflection(reason = "This is a dedicated option to resolve further dependencies from the classpath")
     static class ClassResolverFromClassPath implements ClassResolver {
         private final DeclarationHandler declarationHandler;
 

File: archunit/src/main/java/com/tngtech/archunit/core/ReflectionUtils.java
Patch:
@@ -42,6 +42,7 @@ static Class<?> classForName(String name) {
         return classForName(name, ReflectionUtils.class.getClassLoader());
     }
 
+    @MayResolveTypesViaReflection(reason = "This method is one of the known sources for resolving via reflection")
     static Optional<Class<?>> tryGetClassForName(String name) {
         try {
             return Optional.<Class<?>>of(classForName(name));

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsMethodsTest.java
Patch:
@@ -16,7 +16,7 @@
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
-import static com.tngtech.archunit.core.TestUtils.javaClasses;
+import static com.tngtech.archunit.core.TestUtils.javaClassesViaReflection;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsMethodsTest.ArchTestWithIgnoredMethod.toBeIgnored;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsMethodsTest.ArchTestWithIllegalTestMethods.noParams;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsMethodsTest.ArchTestWithIllegalTestMethods.tooManyParams;
@@ -52,7 +52,7 @@ public class ArchUnitRunnerRunsMethodsTest {
     @InjectMocks
     private ArchUnitRunner runner = newRunnerFor(ArchTestWithTestMethod.class);
 
-    private JavaClasses cachedClasses = javaClasses(ArchUnitRunnerRunsMethodsTest.class);
+    private JavaClasses cachedClasses = javaClassesViaReflection(ArchUnitRunnerRunsMethodsTest.class);
 
     @Before
     public void setUp() {

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsRuleFieldsTest.java
Patch:
@@ -19,7 +19,7 @@
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
-import static com.tngtech.archunit.core.TestUtils.javaClasses;
+import static com.tngtech.archunit.core.TestUtils.javaClassesViaReflection;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleFieldsTest.IgnoredArchTest.RULE_ONE_IN_IGNORED_TEST;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleFieldsTest.IgnoredArchTest.RULE_TWO_IN_IGNORED_TEST;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleFieldsTest.SomeArchTest.FAILING_FIELD_NAME;
@@ -61,7 +61,7 @@ public class ArchUnitRunnerRunsRuleFieldsTest {
     @InjectMocks
     private ArchUnitRunner runner = ArchUnitRunnerTestUtils.newRunnerFor(SomeArchTest.class);
 
-    private JavaClasses cachedClasses = javaClasses(ArchUnitRunnerRunsRuleFieldsTest.class);
+    private JavaClasses cachedClasses = javaClassesViaReflection(Object.class);
 
     @Before
     public void setUp() {

File: archunit-junit/src/test/java/com/tngtech/archunit/junit/ArchUnitRunnerRunsRuleSetsTest.java
Patch:
@@ -18,7 +18,7 @@
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 
-import static com.tngtech.archunit.core.TestUtils.javaClasses;
+import static com.tngtech.archunit.core.TestUtils.javaClassesViaReflection;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleSetsTest.ArchTestWithRuleLibrary.someOtherMethodRuleName;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleSetsTest.Rules.someFieldRuleName;
 import static com.tngtech.archunit.junit.ArchUnitRunnerRunsRuleSetsTest.Rules.someMethodRuleName;
@@ -52,7 +52,7 @@ public class ArchUnitRunnerRunsRuleSetsTest {
     @InjectMocks
     private ArchUnitRunner runnerForRuleLibrary = newRunnerFor(ArchTestWithRuleLibrary.class);
 
-    private JavaClasses cachedClasses = javaClasses(ArchUnitRunnerRunsRuleSetsTest.class);
+    private JavaClasses cachedClasses = javaClassesViaReflection(ArchUnitRunnerRunsRuleSetsTest.class);
 
     @Before
     public void setUp() {

File: archunit/src/main/java/com/tngtech/archunit/core/ClassResolver.java
Patch:
@@ -1,10 +1,9 @@
 package com.tngtech.archunit.core;
 
 import java.util.Map;
-import java.util.Set;
 
 interface ClassResolver {
-    JavaClass resolve(String typeName);
+    Optional<JavaClass> resolve(String typeName, ImportedClasses.ByTypeName importedClasses);
 
-    Set<JavaClass> getAllSuperClasses(String className, Map<String, JavaClass> importedClasses);
+    Map<String, Optional<JavaClass>> getAllSuperClasses(String className, ImportedClasses.ByTypeName importedClasses);
 }

File: archunit/src/main/java/com/tngtech/archunit/core/HasParameters.java
Patch:
@@ -1,7 +1,5 @@
 package com.tngtech.archunit.core;
 
-import java.util.List;
-
 public interface HasParameters {
-    List<TypeDetails> getParameters();
+    JavaClassList getParameters();
 }

File: archunit/src/main/java/com/tngtech/archunit/core/JavaModifier.java
Patch:
@@ -15,7 +15,9 @@ public enum JavaModifier {
     FINAL(Opcodes.ACC_FINAL),
     VOLATILE(Opcodes.ACC_VOLATILE),
     TRANSIENT(Opcodes.ACC_TRANSIENT),
-    ABSTRACT(Opcodes.ACC_ABSTRACT);
+    ABSTRACT(Opcodes.ACC_ABSTRACT),
+    SYNCHRONIZED(Opcodes.ACC_SYNCHRONIZED),
+    NATIVE(Opcodes.ACC_NATIVE);
 
     private final int asmAccessFlag;
 

File: archunit/src/main/java/com/tngtech/archunit/core/JavaType.java
Patch:
@@ -33,7 +33,7 @@ class JavaType {
 
     private final String typeName;
 
-    JavaType(String typeName) {
+    private JavaType(String typeName) {
         this.typeName = typeName;
     }
 
@@ -48,7 +48,7 @@ static JavaType fromDescriptor(String descriptor) {
         return new JavaType(type.getClassName());
     }
 
-    public Class<?> asClass() {
+    Class<?> asClass() {
         return classForName(typeName);
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/TypeDetails.java
Patch:
@@ -9,6 +9,7 @@
 import com.tngtech.archunit.core.ArchUnitException.ReflectionException;
 import org.objectweb.asm.Type;
 
+import static com.tngtech.archunit.core.Formatters.ensureSimpleName;
 import static com.tngtech.archunit.core.ReflectionUtils.classForName;
 
 public class TypeDetails {
@@ -41,7 +42,7 @@ private TypeDetails(Type type) {
 
     private TypeDetails(String fullName) {
         this.name = fullName;
-        this.simpleName = fullName.replaceAll("^.*(\\.|\\$)", "");
+        this.simpleName = ensureSimpleName(fullName);
         this.javaPackage = fullName.replaceAll("(\\.|\\$).*$", "");
         isInterface = false;
     }
@@ -100,7 +101,7 @@ public static List<TypeDetails> allOf(Class<?>... types) {
         return allOf(ImmutableList.copyOf(types));
     }
 
-    public static List<TypeDetails> allOf(Collection<Class<?>> types) {
+    private static List<TypeDetails> allOf(Collection<Class<?>> types) {
         ImmutableList.Builder<TypeDetails> result = ImmutableList.builder();
         for (Class<?> type : types) {
             result.add(TypeDetails.of(type));

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ArchConditions.java
Patch:
@@ -7,7 +7,6 @@
 import com.tngtech.archunit.core.JavaCall;
 import com.tngtech.archunit.core.JavaClass;
 import com.tngtech.archunit.core.JavaFieldAccess;
-import com.tngtech.archunit.core.TypeDetails;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.conditions.ClassAccessesFieldCondition.ClassGetsFieldCondition;
 import com.tngtech.archunit.lang.conditions.ClassAccessesFieldCondition.ClassSetsFieldCondition;
@@ -115,7 +114,7 @@ private MethodCallConditionCreator(String methodName, Class<?>[] params) {
         }
 
         public ArchCondition<JavaClass> in(Class<?> clazz) {
-            return callMethodWhere(callTarget().is(clazz, methodName, TypeDetails.allOf(params)));
+            return callMethodWhere(callTarget().is(clazz, methodName, params));
         }
 
         public ArchCondition<JavaClass> inHierarchyOf(Class<?> type) {

File: archunit/src/test/java/com/tngtech/archunit/core/AnnotationProxyTest.java
Patch:
@@ -17,7 +17,7 @@
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 
-import static com.tngtech.archunit.core.TestUtils.javaAnnotationOf;
+import static com.tngtech.archunit.core.TestUtils.javaAnnotationFrom;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class AnnotationProxyTest {
@@ -223,7 +223,7 @@ public void equals_hashcode_and_toString() {
 
     @Test
     public void wrong_annotation_type_is_rejected() {
-        JavaAnnotation mismatch = javaAnnotationOf(TestAnnotation.class.getAnnotation(Retention.class));
+        JavaAnnotation mismatch = javaAnnotationFrom(TestAnnotation.class.getAnnotation(Retention.class));
 
         thrown.expect(IllegalArgumentException.class);
         thrown.expectMessage(Retention.class.getSimpleName());
@@ -377,7 +377,7 @@ private boolean mismatch(String expectedPart) {
     }
 
     private <A extends Annotation> A getProxyFor(Class<A> annotationType) {
-        JavaAnnotation toProxy = javaAnnotationOf(Irrelevant.class.getAnnotation(annotationType));
+        JavaAnnotation toProxy = javaAnnotationFrom(Irrelevant.class.getAnnotation(annotationType));
         return AnnotationProxy.of(annotationType, toProxy);
     }
 }
\ No newline at end of file

File: archunit/src/test/java/com/tngtech/archunit/core/JavaCallTest.java
Patch:
@@ -2,14 +2,14 @@
 
 import org.junit.Test;
 
-import static com.tngtech.archunit.core.TestUtils.javaMethod;
+import static com.tngtech.archunit.core.TestUtils.javaMethodViaReflection;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class JavaCallTest {
     @Test
     public void get_target() {
-        JavaMethodCall call = TestUtils.simulateCall().from(javaMethod(getClass(), "toString"), 5)
-                .to(javaMethod(getClass(), "hashCode"));
+        JavaMethodCall call = TestUtils.simulateCall().from(javaMethodViaReflection(getClass(), "toString"), 5)
+                .to(javaMethodViaReflection(getClass(), "hashCode"));
 
         assertThat(JavaCall.GET_TARGET.apply(call)).isEqualTo(call.getTarget());
     }

File: archunit/src/test/java/com/tngtech/archunit/core/JavaMemberTest.java
Patch:
@@ -3,15 +3,15 @@
 import org.junit.Test;
 
 import static com.tngtech.archunit.core.JavaMember.modifier;
-import static com.tngtech.archunit.core.TestUtils.javaMethod;
+import static com.tngtech.archunit.core.TestUtils.javaMethodViaReflection;
 import static com.tngtech.archunit.testutil.Assertions.assertThat;
 
 public class JavaMemberTest {
     @Test
     public void modifier_predicate() {
-        assertThat(modifier(JavaModifier.PRIVATE).apply(javaMethod(SomeClass.class, "isPrivate")))
+        assertThat(modifier(JavaModifier.PRIVATE).apply(javaMethodViaReflection(SomeClass.class, "isPrivate")))
                 .as("Predicate matches").isTrue();
-        assertThat(modifier(JavaModifier.PRIVATE).apply(javaMethod(SomeClass.class, "isNotPrivate")))
+        assertThat(modifier(JavaModifier.PRIVATE).apply(javaMethodViaReflection(SomeClass.class, "isNotPrivate")))
                 .as("Predicate matches").isFalse();
         assertThat(modifier(JavaModifier.PRIVATE).getDescription()).isEqualTo("modifier PRIVATE");
     }

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/CallPredicateTest.java
Patch:
@@ -1,7 +1,6 @@
 package com.tngtech.archunit.lang.conditions;
 
 import com.tngtech.archunit.core.JavaCall;
-import com.tngtech.archunit.core.TypeDetails;
 import org.junit.Test;
 
 import static com.tngtech.archunit.core.TestUtils.simulateCall;
@@ -26,7 +25,7 @@ public void combination_of_restrictions() {
 
     @Test
     public void descriptions() {
-        CallPredicate predicate = target().is(SomeClass.class, "someMethod", TypeDetails.allOf(String.class));
+        CallPredicate predicate = target().is(SomeClass.class, "someMethod", String.class);
         assertThat(predicate.getDescription())
                 .isEqualTo(String.format("target is %s.someMethod(String.class)", SomeClass.class.getName()));
 

File: archunit/src/main/java/com/tngtech/archunit/core/BuilderWithBuildParameter.java
Patch:
@@ -10,7 +10,7 @@ interface BuilderWithBuildParameter<PARAMETER, VALUE> {
     VALUE build(PARAMETER clazz);
 
     class BuildFinisher {
-        public static <PARAMETER, VALUE> Set<VALUE> build(Set<? extends BuilderWithBuildParameter<PARAMETER, ? extends VALUE>> builders, PARAMETER parameter) {
+        static <PARAMETER, VALUE> Set<VALUE> build(Set<? extends BuilderWithBuildParameter<PARAMETER, ? extends VALUE>> builders, PARAMETER parameter) {
             checkNotNull(builders);
             checkNotNull(parameter);
 

File: archunit/src/main/java/com/tngtech/archunit/core/JavaAnnotation.java
Patch:
@@ -63,7 +63,7 @@ public <A extends Annotation> A as(Class<A> annotationType) {
         return AnnotationProxy.of(annotationType, this);
     }
 
-    static ImmutableMap<String, JavaAnnotation> buildAnnotations(Set<Builder> annotations) {
+    static Map<String, JavaAnnotation> buildAnnotations(Set<Builder> annotations) {
         ImmutableMap.Builder<String, JavaAnnotation> result = ImmutableMap.builder();
         for (Builder annotationBuilder : annotations) {
             JavaAnnotation javaAnnotation = annotationBuilder.build();

File: archunit/src/main/java/com/tngtech/archunit/core/AccessContext.java
Patch:
@@ -28,7 +28,7 @@ static class Part extends AccessContext {
         Part() {
         }
 
-        Part(JavaCodeUnit<?, ?> codeUnit) {
+        Part(JavaCodeUnit codeUnit) {
             for (JavaFieldAccess access : codeUnit.getFieldAccesses()) {
                 fieldAccessesByTarget.put(access.getTarget().getOwner(), access);
             }

File: archunit/src/main/java/com/tngtech/archunit/core/HasOwner.java
Patch:
@@ -6,6 +6,6 @@ public interface HasOwner<T> {
     interface IsOwnedByClass extends HasOwner<JavaClass> {
     }
 
-    interface IsOwnedByCodeUnit extends HasOwner<JavaCodeUnit<?, ?>> {
+    interface IsOwnedByCodeUnit extends HasOwner<JavaCodeUnit> {
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/core/ImportContext.java
Patch:
@@ -6,11 +6,11 @@
 import com.tngtech.archunit.core.AccessTarget.MethodCallTarget;
 
 public interface ImportContext {
-    Set<FieldAccessRecord> getFieldAccessRecordsFor(JavaCodeUnit<?, ?> codeUnit);
+    Set<FieldAccessRecord> getFieldAccessRecordsFor(JavaCodeUnit codeUnit);
 
-    Set<AccessRecord<MethodCallTarget>> getMethodCallRecordsFor(JavaCodeUnit<?, ?> codeUnit);
+    Set<AccessRecord<MethodCallTarget>> getMethodCallRecordsFor(JavaCodeUnit codeUnit);
 
-    Set<AccessRecord<AccessTarget.ConstructorCallTarget>> getConstructorCallRecordsFor(JavaCodeUnit<?, ?> codeUnit);
+    Set<AccessRecord<AccessTarget.ConstructorCallTarget>> getConstructorCallRecordsFor(JavaCodeUnit codeUnit);
 
     Optional<JavaClass> tryGetJavaClassWithType(String name);
 }

File: archunit/src/main/java/com/tngtech/archunit/core/JavaConstructor.java
Patch:
@@ -1,13 +1,12 @@
 package com.tngtech.archunit.core;
 
-import java.lang.reflect.Constructor;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Set;
 
 import com.google.common.collect.ImmutableSet;
 
-public class JavaConstructor extends JavaCodeUnit<Constructor<?>, MemberDescription.ForConstructor> {
+public class JavaConstructor extends JavaCodeUnit {
     private Set<JavaConstructorCall> callsToSelf = Collections.emptySet();
 
     public static final String CONSTRUCTOR_NAME = "<init>";

File: archunit/src/main/java/com/tngtech/archunit/core/JavaField.java
Patch:
@@ -1,6 +1,5 @@
 package com.tngtech.archunit.core;
 
-import java.lang.reflect.Field;
 import java.util.Collections;
 import java.util.Set;
 
@@ -9,7 +8,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-public class JavaField extends JavaMember<Field, MemberDescription.ForField> {
+public class JavaField extends JavaMember {
     private final TypeDetails type;
     private Supplier<Set<JavaFieldAccess>> accessesToSelf = Suppliers.ofInstance(Collections.<JavaFieldAccess>emptySet());
 

File: archunit/src/main/java/com/tngtech/archunit/core/JavaMethod.java
Patch:
@@ -1,6 +1,5 @@
 package com.tngtech.archunit.core;
 
-import java.lang.reflect.Method;
 import java.util.Collections;
 import java.util.Set;
 
@@ -9,7 +8,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-public class JavaMethod extends JavaCodeUnit<Method, MemberDescription.ForMethod> {
+public class JavaMethod extends JavaCodeUnit {
     private Supplier<Set<JavaMethodCall>> callsToSelf = Suppliers.ofInstance(Collections.<JavaMethodCall>emptySet());
 
     private JavaMethod(Builder builder) {

File: archunit/src/main/java/com/tngtech/archunit/core/JavaStaticInitializer.java
Patch:
@@ -1,12 +1,11 @@
 package com.tngtech.archunit.core;
 
-import java.lang.reflect.Method;
 import java.util.Collections;
 import java.util.Set;
 
 import static java.util.Collections.emptySet;
 
-public class JavaStaticInitializer extends JavaCodeUnit<Method, MemberDescription.ForMethod> {
+public class JavaStaticInitializer extends JavaCodeUnit {
     public static final String STATIC_INITIALIZER_NAME = "<clinit>";
 
     private JavaStaticInitializer(Builder builder) {

File: archunit/src/main/java/com/tngtech/archunit/core/RawAccessRecord.java
Patch:
@@ -106,7 +106,7 @@ public String toString() {
                     '}';
         }
 
-        public boolean is(JavaCodeUnit<?, ?> method) {
+        public boolean is(JavaCodeUnit method) {
             return getName().equals(method.getName())
                     && getParameters().equals(method.getParameters())
                     && getDeclaringClassName().equals(method.getOwner().getName());

File: archunit/src/test/java/com/tngtech/archunit/core/JavaClassTest.java
Patch:
@@ -37,7 +37,7 @@ public void finds_fields_and_methods() {
         for (JavaField field : javaClass.getFields()) {
             assertThat(field.getOwner()).isSameAs(javaClass);
         }
-        for (JavaCodeUnit<?, ?> method : javaClass.getCodeUnits()) {
+        for (JavaCodeUnit method : javaClass.getCodeUnits()) {
             assertThat(method.getOwner()).isSameAs(javaClass);
         }
     }

File: archunit/src/test/java/com/tngtech/archunit/core/TestUtils.java
Patch:
@@ -90,7 +90,7 @@ public Optional<JavaClass> answer(InvocationOnMock invocation) throws Throwable
         });
         javaClass.completeClassHierarchyFrom(context);
         javaClass.completeFrom(context);
-        for (JavaCodeUnit<?, ?> unit : javaClass.getCodeUnits()) {
+        for (JavaCodeUnit unit : javaClass.getCodeUnits()) {
             unit.completeFrom(context);
         }
         return javaClass;
@@ -251,7 +251,7 @@ public TestAccessRecord(T target) {
             }
 
             @Override
-            public JavaCodeUnit<?, ?> getCaller() {
+            public JavaCodeUnit getCaller() {
                 return method;
             }
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/Conditions.java
Patch:
@@ -22,11 +22,11 @@ public boolean matches(Iterable<? extends T> value) {
         }.as("containing an element that " + condition.description());
     }
 
-    public static Condition<JavaCodeUnit<?, ?>> codeUnitWithSignature(final String name, final Class<?>... parameters) {
+    public static Condition<JavaCodeUnit> codeUnitWithSignature(final String name, final Class<?>... parameters) {
         final List<TypeDetails> paramList = TypeDetails.allOf(parameters);
-        return new Condition<JavaCodeUnit<?, ?>>() {
+        return new Condition<JavaCodeUnit>() {
             @Override
-            public boolean matches(JavaCodeUnit<?, ?> value) {
+            public boolean matches(JavaCodeUnit value) {
                 return name.equals(value.getName()) && paramList.equals(value.getParameters());
             }
         }.as("matches signature <" + name + ", " + paramList + ">");

File: archunit/src/main/java/com/tngtech/archunit/core/JavaCodeUnit.java
Patch:
@@ -28,6 +28,7 @@ public abstract class JavaCodeUnit<M extends Member, T extends MemberDescription
         extends JavaMember<M, T>
         implements HasParameters {
 
+    final T memberDescription;
     private Set<JavaFieldAccess> fieldAccesses;
     private Set<JavaMethodCall> methodCalls;
     private Set<JavaConstructorCall> constructorCalls;
@@ -38,7 +39,8 @@ public abstract class JavaCodeUnit<M extends Member, T extends MemberDescription
     }
 
     JavaCodeUnit(T memberDescription, JavaClass owner) {
-        super(memberDescription, owner);
+        super(owner, memberDescription.getAnnotations(), memberDescription.getName(), memberDescription.getDescriptor(), JavaModifier.getModifiersFor(memberDescription.getModifiers()));
+        this.memberDescription = memberDescription;
         fullName = formatMethod(getOwner().getName(), getName(), getParameters());
     }
 

File: archunit/src/test/java/com/tngtech/archunit/core/JavaFieldTest.java
Patch:
@@ -25,9 +25,9 @@ public void incompatible_owner_is_rejected() throws Exception {
 
     @Test
     public void hasType_works() {
-        assertThat(JavaField.hasType(DescribedPredicate.<Class<?>>equalTo(SomeEnum.class))
+        assertThat(JavaField.hasType(DescribedPredicate.equalTo(TypeDetails.of(SomeEnum.class)))
                 .apply(fieldWithType(SomeEnum.class))).as("Predicate matches").isTrue();
-        assertThat(JavaField.hasType(DescribedPredicate.<Class<?>>equalTo(Serializable.class))
+        assertThat(JavaField.hasType(DescribedPredicate.equalTo(TypeDetails.of(Serializable.class)))
                 .apply(fieldWithType(SomeEnum.class))).as("Predicate matches").isFalse();
 
         assertThat(JavaField.hasType(predicateWithDescription("something")).getDescription())
@@ -36,7 +36,7 @@ public void hasType_works() {
 
     private JavaField fieldWithType(Class<?> type) {
         JavaField result = javaField(SomeClass.class, "other");
-        checkState(result.getType() == type, "field doesn't have the type the test expects anymore");
+        checkState(result.getType().equals(TypeDetails.of(type)), "field doesn't have the type the test expects anymore");
         return result;
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -58,7 +58,7 @@ public void isEquivalentTo(Field field) {
             assertThat(javaField.getName()).isEqualTo(field.getName());
             assertThat(javaField.getFullName()).isEqualTo(field.getDeclaringClass().getName() + "." + field.getName());
             assertThat(javaField.getOwner().reflect()).isEqualTo(field.getDeclaringClass());
-            assertThat(javaField.getType()).isEqualTo(field.getType());
+            assertThat(javaField.getType()).isEqualTo(TypeDetails.of(field.getType()));
             assertThat(javaField.getModifiers()).isEqualTo(getModifiersFor(field.getModifiers()));
             assertThat(propertiesOf(javaField.getAnnotations())).isEqualTo(propertiesOf(field.getAnnotations()));
         }

File: archunit/src/main/java/com/tngtech/archunit/core/MemberDescription.java
Patch:
@@ -47,7 +47,7 @@ public int getModifiers() {
 
         @Override
         public Set<JavaAnnotation> getAnnotationsFor(JavaMember<?, ?> owner) {
-            return JavaAnnotation.of(owner, member.getAnnotations());
+            return JavaAnnotation.of(member.getAnnotations());
         }
 
         @Override

File: archunit/src/main/java/com/tngtech/archunit/core/JavaAnnotation.java
Patch:
@@ -16,8 +16,8 @@ private JavaAnnotation(Builder builder) {
         owner = builder.owner;
     }
 
-    public Class<?> getType() {
-        return annotation.annotationType();
+    public TypeDetails getType() {
+        return TypeDetails.of(annotation.annotationType());
     }
 
     @Override
@@ -27,7 +27,7 @@ public Class<?> getType() {
 
     public Object get(String annotationMethodName) {
         try {
-            Object result = getType().getMethod(annotationMethodName).invoke(annotation);
+            Object result = annotation.annotationType().getMethod(annotationMethodName).invoke(annotation);
             if (result instanceof Class) {
                 return TypeDetails.of((Class<?>) result);
             }

File: archunit/src/main/java/com/tngtech/archunit/core/ClassFileImportContext.java
Patch:
@@ -606,7 +606,7 @@ public int getModifiers() {
         }
 
         @Override
-        public Set<JavaAnnotation<?>> getAnnotationsFor(JavaMember<?, ?> owner) {
+        public Set<JavaAnnotation> getAnnotationsFor(JavaMember<?, ?> owner) {
             return emptySet();
         }
 

File: archunit/src/main/java/com/tngtech/archunit/core/JavaStaticInitializer.java
Patch:
@@ -68,7 +68,7 @@ public int getModifiers() {
         }
 
         @Override
-        public Set<JavaAnnotation<?>> getAnnotationsFor(JavaMember<?, ?> owner) {
+        public Set<JavaAnnotation> getAnnotationsFor(JavaMember<?, ?> owner) {
             return emptySet();
         }
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/Assertions.java
Patch:
@@ -62,9 +62,9 @@ public void isEquivalentTo(Field field) {
             assertThat(propertiesOf(javaField.getAnnotations())).isEqualTo(propertiesOf(field.getAnnotations()));
         }
 
-        private Set<Map<String, Object>> propertiesOf(Set<JavaAnnotation<?>> annotations) {
+        private Set<Map<String, Object>> propertiesOf(Set<JavaAnnotation> annotations) {
             Set<Map<String, Object>> result = new HashSet<>();
-            for (JavaAnnotation<?> annotation : annotations) {
+            for (JavaAnnotation annotation : annotations) {
                 result.add(annotation.getProperties());
             }
             return result;

File: archunit/src/main/java/com/tngtech/archunit/core/JavaCodeUnit.java
Patch:
@@ -24,7 +24,9 @@
  * @param <T> The type of the description for this member; the description is an abstraction in case there are problems
  *            in determining a fitting {@link Member java.lang.reflect.Member}
  */
-public abstract class JavaCodeUnit<M extends Member, T extends MemberDescription<M>> extends JavaMember<M, T> implements HasParameters {
+public abstract class JavaCodeUnit<M extends Member, T extends MemberDescription<M>>
+        extends JavaMember<M, T>
+        implements HasParameters {
 
     private Set<JavaFieldAccess> fieldAccesses;
     private Set<JavaMethodCall> methodCalls;

File: archunit/src/test/java/com/tngtech/archunit/core/TestJarFile.java
Patch:
@@ -9,8 +9,6 @@
 import java.util.jar.JarOutputStream;
 import java.util.zip.ZipEntry;
 
-import org.assertj.core.util.Files;
-
 import static com.google.common.io.ByteStreams.toByteArray;
 
 class TestJarFile {
@@ -22,7 +20,7 @@ TestJarFile withEntry(String entry) {
     }
 
     JarFile create() {
-        File folder = Files.newTemporaryFolder();
+        File folder = TestUtils.newTemporaryFolder();
         File file = new File(folder, "test.jar");
 
         try (JarOutputStream jarOut = new JarOutputStream(new FileOutputStream(file))) {

File: archunit/src/main/java/com/tngtech/archunit/core/DescribedIterable.java
Patch:
@@ -1,9 +1,7 @@
-package com.tngtech.archunit.lang;
+package com.tngtech.archunit.core;
 
 import java.util.Iterator;
 
-import com.tngtech.archunit.core.HasDescription;
-
 public interface DescribedIterable<T> extends Iterable<T>, HasDescription {
     class From {
         public static <T> DescribedIterable<T> iterable(final Iterable<T> iterable, final String description) {

File: archunit/src/main/java/com/tngtech/archunit/core/Formatters.java
Patch:
@@ -11,13 +11,13 @@ public class Formatters {
     private Formatters() {
     }
 
-    public static String formatMethod(String ownerName, String methodName, List<Class<?>> parameters) {
+    public static String formatMethod(String ownerName, String methodName, List<TypeDetails> parameters) {
         return String.format(FULL_METHOD_NAME_TEMPLATE, ownerName, methodName, formatMethodParameters(parameters));
     }
 
-    public static String formatMethodParameters(List<Class<?>> parameters) {
+    public static String formatMethodParameters(List<TypeDetails> parameters) {
         List<String> formatted = new ArrayList<>();
-        for (Class<?> type : parameters) {
+        for (TypeDetails type : parameters) {
             formatted.add(String.format("%s.class", type.getSimpleName()));
         }
         return Joiner.on(", ").join(formatted);

File: archunit/src/main/java/com/tngtech/archunit/core/ImportWorkaround.java
Patch:
@@ -17,12 +17,12 @@ class ImportWorkaround {
     static Set<JavaClass> getAllSuperClasses(String typeName) {
         ImmutableSet.Builder<JavaClass> result = ImmutableSet.builder();
         for (Class<?> type : getAllSuperTypes(classForName(typeName))) {
-            result.add(new JavaClass.Builder().withType(new TypeDetails(type)).build());
+            result.add(new JavaClass.Builder().withType(TypeDetails.of(type)).build());
         }
         return result.build();
     }
 
     static JavaClass resolveClass(String typeName) {
-        return new JavaClass.Builder().withType(new TypeDetails(classForName(typeName))).build();
+        return new JavaClass.Builder().withType(TypeDetails.of(classForName(typeName))).build();
     }
 }

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClasses.java
Patch:
@@ -7,7 +7,6 @@
 import java.util.Set;
 
 import com.google.common.collect.ImmutableMap;
-import com.tngtech.archunit.lang.DescribedIterable;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 

File: archunit/src/main/java/com/tngtech/archunit/core/JavaCodeUnit.java
Patch:
@@ -45,9 +45,9 @@ public String getFullName() {
         return fullName;
     }
 
-    public abstract List<Class<?>> getParameters();
+    public abstract List<TypeDetails> getParameters();
 
-    public static DescribedPredicate<JavaCodeUnit<?, ?>> hasParameters(final List<Class<?>> paramTypes) {
+    public static DescribedPredicate<JavaCodeUnit<?, ?>> hasParameters(final List<TypeDetails> paramTypes) {
         return new DescribedPredicate<JavaCodeUnit<?, ?>>("has parameters [%s]", formatMethodParameters(paramTypes)) {
             @Override
             public boolean apply(JavaCodeUnit<?, ?> input) {
@@ -56,7 +56,7 @@ public boolean apply(JavaCodeUnit<?, ?> input) {
         };
     }
 
-    public abstract Class<?> getReturnType();
+    public abstract TypeDetails getReturnType();
 
     public Set<JavaFieldAccess> getFieldAccesses() {
         return fieldAccesses;

File: archunit/src/main/java/com/tngtech/archunit/core/JavaConstructor.java
Patch:
@@ -19,13 +19,13 @@ private JavaConstructor(Builder builder) {
     }
 
     @Override
-    public List<Class<?>> getParameters() {
+    public List<TypeDetails> getParameters() {
         return Lists.newArrayList(memberDescription.getParameterTypes());
     }
 
     @Override
-    public Class<?> getReturnType() {
-        return void.class;
+    public TypeDetails getReturnType() {
+        return TypeDetails.of(void.class);
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/lang/InputTransformer.java
Patch:
@@ -1,5 +1,6 @@
 package com.tngtech.archunit.lang;
 
+import com.tngtech.archunit.core.DescribedIterable;
 import com.tngtech.archunit.core.DescribedPredicate;
 import com.tngtech.archunit.core.Guava;
 import com.tngtech.archunit.core.HasDescription;

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ArchConditions.java
Patch:
@@ -7,6 +7,7 @@
 import com.tngtech.archunit.core.JavaCall;
 import com.tngtech.archunit.core.JavaClass;
 import com.tngtech.archunit.core.JavaFieldAccess;
+import com.tngtech.archunit.core.TypeDetails;
 import com.tngtech.archunit.lang.ArchCondition;
 import com.tngtech.archunit.lang.conditions.ClassAccessesFieldCondition.ClassGetsFieldCondition;
 import com.tngtech.archunit.lang.conditions.ClassAccessesFieldCondition.ClassSetsFieldCondition;
@@ -114,7 +115,7 @@ private MethodCallConditionCreator(String methodName, Class<?>[] params) {
         }
 
         public ArchCondition<JavaClass> in(Class<?> clazz) {
-            return callMethodWhere(callTarget().is(clazz, methodName, params));
+            return callMethodWhere(callTarget().is(clazz, methodName, TypeDetails.allOf(params)));
         }
 
         public ArchCondition<JavaClass> inHierarchyOf(Class<?> type) {

File: archunit/src/main/java/com/tngtech/archunit/library/dependencies/Slices.java
Patch:
@@ -8,10 +8,10 @@
 import java.util.Set;
 
 import com.tngtech.archunit.core.Dependency;
+import com.tngtech.archunit.core.DescribedIterable;
 import com.tngtech.archunit.core.JavaClass;
 import com.tngtech.archunit.core.JavaClasses;
 import com.tngtech.archunit.core.Optional;
-import com.tngtech.archunit.lang.DescribedIterable;
 import com.tngtech.archunit.lang.InputTransformer;
 import com.tngtech.archunit.lang.conditions.PackageMatcher;
 

File: archunit/src/test/java/com/tngtech/archunit/core/JavaClassesTest.java
Patch:
@@ -8,8 +8,8 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class JavaClassesTest {
-    public static final JavaClass SOME_CLASS = new JavaClass.Builder().withType(new TypeDetails(SomeClass.class)).build();
-    public static final JavaClass SOME_OTHER_CLASS = new JavaClass.Builder().withType(new TypeDetails(SomeOtherClass.class)).build();
+    public static final JavaClass SOME_CLASS = new JavaClass.Builder().withType(TypeDetails.of(SomeClass.class)).build();
+    public static final JavaClass SOME_OTHER_CLASS = new JavaClass.Builder().withType(TypeDetails.of(SomeOtherClass.class)).build();
     private static final ImmutableMap<String, JavaClass> BY_RAW_CLASS = ImmutableMap.of(
             SomeClass.class.getName(), SOME_CLASS,
             SomeOtherClass.class.getName(), SOME_OTHER_CLASS);

File: archunit/src/test/java/com/tngtech/archunit/core/JavaCodeUnitTest.java
Patch:
@@ -14,13 +14,13 @@ public void hasParameters() {
         JavaMethod method = javaMethod(SomeClass.class, "withArgs", Object.class, String.class);
 
         DescribedPredicate<JavaCodeUnit<?, ?>> predicate =
-                JavaCodeUnit.hasParameters(Collections.<Class<?>>singletonList(Object.class));
+                JavaCodeUnit.hasParameters(TypeDetails.allOf(Collections.<Class<?>>singletonList(Object.class)));
 
         assertThat(predicate.apply(method)).as("Predicate matches").isFalse();
         assertThat(predicate.getDescription()).isEqualTo("has parameters [Object.class]");
 
         predicate =
-                JavaCodeUnit.hasParameters(Arrays.asList(Object.class, String.class));
+                JavaCodeUnit.hasParameters(TypeDetails.allOf(Arrays.asList(Object.class, String.class)));
 
         assertThat(predicate.apply(method)).as("Predicate matches").isTrue();
         assertThat(predicate.getDescription()).isEqualTo("has parameters [Object.class, String.class]");

File: archunit/src/test/java/com/tngtech/archunit/core/JavaFieldAccessTest.java
Patch:
@@ -10,7 +10,7 @@
 public class JavaFieldAccessTest {
     @Test
     public void equals_should_work() throws Exception {
-        JavaClass clazz = new JavaClass.Builder().withType(new TypeDetails(SomeClass.class)).build();
+        JavaClass clazz = new JavaClass.Builder().withType(TypeDetails.of(SomeClass.class)).build();
         JavaFieldAccess access = new JavaFieldAccess(stringFieldAccessRecordBuilder(clazz)
                 .withCaller(accessFieldMethod(clazz))
                 .build());
@@ -48,7 +48,7 @@ public void equals_should_work() throws Exception {
     @Test
     public void fieldAccess_should_have_same_name_as_target() throws Exception {
 
-        JavaClass clazz = new JavaClass.Builder().withType(new TypeDetails(SomeClass.class)).build();
+        JavaClass clazz = new JavaClass.Builder().withType(TypeDetails.of(SomeClass.class)).build();
 
         JavaFieldAccess access = new JavaFieldAccess(stringFieldAccessRecordBuilder(clazz)
                 .withCaller(accessFieldMethod(clazz))

File: archunit/src/test/java/com/tngtech/archunit/core/TestUtils.java
Patch:
@@ -39,7 +39,7 @@ public static JavaMethod javaMethod(JavaClass clazz, Method method) {
     }
 
     public static JavaClass javaClass(Class<?> owner) {
-        JavaClass javaClass = new JavaClass.Builder().withType(new TypeDetails(owner)).build();
+        JavaClass javaClass = new JavaClass.Builder().withType(TypeDetails.of(owner)).build();
         ClassFileImportContext context = mock(ClassFileImportContext.class);
         when(context.tryGetJavaClassWithType(anyString())).thenAnswer(new Answer<Optional<JavaClass>>() {
             @Override

File: archunit/src/test/java/com/tngtech/archunit/lang/InputTransformerTest.java
Patch:
@@ -3,6 +3,7 @@
 import java.util.HashSet;
 import java.util.Set;
 
+import com.tngtech.archunit.core.DescribedIterable;
 import com.tngtech.archunit.core.DescribedPredicate;
 import com.tngtech.archunit.core.JavaClass;
 import com.tngtech.archunit.core.JavaClasses;

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/CallPredicateTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.tngtech.archunit.lang.conditions;
 
 import com.tngtech.archunit.core.JavaCall;
+import com.tngtech.archunit.core.TypeDetails;
 import org.junit.Test;
 
 import static com.tngtech.archunit.core.TestUtils.simulateCall;
@@ -25,7 +26,7 @@ public void combination_of_restrictions() {
 
     @Test
     public void descriptions() {
-        CallPredicate predicate = target().is(SomeClass.class, "someMethod", String.class);
+        CallPredicate predicate = target().is(SomeClass.class, "someMethod", TypeDetails.allOf(String.class));
         assertThat(predicate.getDescription())
                 .isEqualTo(String.format("target is %s.someMethod(String.class)", SomeClass.class.getName()));
 

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/MethodCallConditionTest.java
Patch:
@@ -3,9 +3,9 @@
 import java.util.Collection;
 import java.util.List;
 
-import com.google.common.collect.Lists;
 import com.tngtech.archunit.core.JavaCall;
 import com.tngtech.archunit.core.JavaClass;
+import com.tngtech.archunit.core.TypeDetails;
 import com.tngtech.archunit.lang.ConditionEvent;
 import com.tngtech.archunit.lang.ConditionEvents;
 import org.assertj.core.api.Condition;
@@ -143,7 +143,7 @@ private JavaCall<?> callToTargetIn(Collection<? extends JavaCall<?>> calls) {
     private static class MethodCallConditionBuilder {
         private Class<?> targetClass;
         private String methodName;
-        private List<Class<?>> paramTypes;
+        private List<TypeDetails> paramTypes;
 
         private MethodCallConditionBuilder(MethodCallToAnalyse callToAnalyse) {
             targetClass = callToAnalyse.call.getTarget().getOwner().reflect();
@@ -162,7 +162,7 @@ public MethodCallConditionBuilder withName(String methodName) {
         }
 
         public MethodCallConditionBuilder withParameters(Class<?> paramTypes) {
-            this.paramTypes = Lists.<Class<?>>newArrayList(paramTypes);
+            this.paramTypes = TypeDetails.allOf(paramTypes);
             return this;
         }
 

File: archunit/src/test/java/com/tngtech/archunit/testutil/Conditions.java
Patch:
@@ -2,8 +2,8 @@
 
 import java.util.List;
 
-import com.google.common.collect.ImmutableList;
 import com.tngtech.archunit.core.JavaCodeUnit;
+import com.tngtech.archunit.core.TypeDetails;
 import org.assertj.core.api.Condition;
 
 public final class Conditions {
@@ -23,7 +23,7 @@ public boolean matches(Iterable<? extends T> value) {
     }
 
     public static Condition<JavaCodeUnit<?, ?>> codeUnitWithSignature(final String name, final Class<?>... parameters) {
-        final List<Class<?>> paramList = ImmutableList.copyOf(parameters);
+        final List<TypeDetails> paramList = TypeDetails.allOf(parameters);
         return new Condition<JavaCodeUnit<?, ?>>() {
             @Override
             public boolean matches(JavaCodeUnit<?, ?> value) {

File: archunit/src/main/java/com/tngtech/archunit/core/JavaModifier.java
Patch:
@@ -23,7 +23,7 @@ public enum JavaModifier {
         this.asmAccessFlag = asmAccessFlag;
     }
 
-    static Set<JavaModifier> getModifiersFor(int asmAccess) {
+    public static Set<JavaModifier> getModifiersFor(int asmAccess) {
         Set<JavaModifier> result = new HashSet<>();
         for (JavaModifier modifier : JavaModifier.values()) {
             if ((modifier.asmAccessFlag & asmAccess) != 0) {

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ArchPredicates.java
Patch:
@@ -120,7 +120,7 @@ public static DescribedPredicate<JavaFieldAccess> targetTypeResidesIn(String pac
         return new DescribedPredicate<JavaFieldAccess>("target type resides in '%s'", packageIdentifier) {
             @Override
             public boolean apply(JavaFieldAccess input) {
-                Class<?> fieldType = input.getTarget().reflect().getType();
+                Class<?> fieldType = input.getTarget().getType();
 
                 return fieldType.getPackage() != null &&
                         packageMatcher.matches(fieldType.getPackage().getName());

File: archunit/src/test/java/com/tngtech/archunit/core/testexamples/fieldimport/ClassWithStringField.java
Patch:
@@ -1,5 +1,6 @@
 package com.tngtech.archunit.core.testexamples.fieldimport;
 
 public class ClassWithStringField {
+    @Deprecated
     private String stringField;
 }

File: archunit/src/main/java/com/tngtech/archunit/core/ClassFileImportContext.java
Patch:
@@ -170,7 +170,7 @@ public JavaField getTarget() {
             }
 
             private JavaField createFieldFor(TargetInfo targetInfo) {
-                JavaClass owner = new JavaClass.Builder().withType(targetInfo.owner.asClass()).build();
+                JavaClass owner = new JavaClass.Builder().withType(new TypeDetails(targetInfo.owner.asClass())).build();
                 return createField(targetInfo, owner);
             }
 
@@ -231,7 +231,7 @@ public JavaConstructor getTarget() {
             }
 
             private JavaConstructor createConstructorFor(TargetInfo targetInfo) {
-                JavaClass owner = new JavaClass.Builder().withType(targetInfo.owner.asClass()).build();
+                JavaClass owner = new JavaClass.Builder().withType(new TypeDetails(targetInfo.owner.asClass())).build();
                 return createConstructor(targetInfo, owner);
             }
 
@@ -284,7 +284,7 @@ public JavaMethod getTarget() {
             }
 
             private JavaMethod createMethodFor(TargetInfo targetInfo) {
-                JavaClass owner = new JavaClass.Builder().withType(targetInfo.owner.asClass()).build();
+                JavaClass owner = new JavaClass.Builder().withType(new TypeDetails(targetInfo.owner.asClass())).build();
                 return createMethod(targetInfo, owner);
             }
 

File: archunit/src/main/java/com/tngtech/archunit/core/ClassFileProcessor.java
Patch:
@@ -119,7 +119,7 @@ void init(String classDescriptor) {
         private void tryInit(String classDescriptor) {
             currentClass = classForDescriptor(classDescriptor);
             codeUnitRecorder = new CodeUnitRecorder(currentClass);
-            currentClassBuilder = new JavaClass.Builder(codeUnitRecorder).withType(currentClass);
+            currentClassBuilder = new JavaClass.Builder(codeUnitRecorder).withType(new TypeDetails(currentClass));
         }
 
         private Class<?> classForDescriptor(String descriptor) {

File: archunit/src/main/java/com/tngtech/archunit/core/ImportWorkaround.java
Patch:
@@ -17,12 +17,12 @@ class ImportWorkaround {
     static Set<JavaClass> getAllSuperClasses(String typeName) {
         ImmutableSet.Builder<JavaClass> result = ImmutableSet.builder();
         for (Class<?> type : getAllSuperTypes(classForName(typeName))) {
-            result.add(new JavaClass.Builder().withType(type).build());
+            result.add(new JavaClass.Builder().withType(new TypeDetails(type)).build());
         }
         return result.build();
     }
 
     static JavaClass resolveClass(String typeName) {
-        return new JavaClass.Builder().withType(classForName(typeName)).build();
+        return new JavaClass.Builder().withType(new TypeDetails(classForName(typeName))).build();
     }
 }

File: archunit/src/test/java/com/tngtech/archunit/core/ClassFileImporterTest.java
Patch:
@@ -1134,7 +1134,7 @@ public void imports_urls_of_files() {
 
         JavaClasses classes = new ClassFileImporter().importUrls(urls);
         FluentIterable<JavaClass> classesFoundAtUrls = FluentIterable.from(classes)
-                .filter(not(equalTo(new JavaClass.Builder().withType(Object.class).build())));
+                .filter(not(equalTo(new JavaClass.Builder().withType(new TypeDetails(Object.class)).build())));
 
         assertThat(classesFoundAtUrls).as("Number of classes at the given URLs").hasSize(2);
     }

File: archunit/src/test/java/com/tngtech/archunit/core/JavaClassesTest.java
Patch:
@@ -8,8 +8,8 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class JavaClassesTest {
-    public static final JavaClass SOME_CLASS = new JavaClass.Builder().withType(SomeClass.class).build();
-    public static final JavaClass SOME_OTHER_CLASS = new JavaClass.Builder().withType(SomeOtherClass.class).build();
+    public static final JavaClass SOME_CLASS = new JavaClass.Builder().withType(new TypeDetails(SomeClass.class)).build();
+    public static final JavaClass SOME_OTHER_CLASS = new JavaClass.Builder().withType(new TypeDetails(SomeOtherClass.class)).build();
     private static final ImmutableMap<String, JavaClass> BY_RAW_CLASS = ImmutableMap.of(
             SomeClass.class.getName(), SOME_CLASS,
             SomeOtherClass.class.getName(), SOME_OTHER_CLASS);

File: archunit/src/test/java/com/tngtech/archunit/core/TestUtils.java
Patch:
@@ -36,7 +36,7 @@ public static JavaMethod javaMethod(JavaClass clazz, Method method) {
     }
 
     public static JavaClass javaClass(Class<?> owner) {
-        JavaClass javaClass = new JavaClass.Builder().withType(owner).build();
+        JavaClass javaClass = new JavaClass.Builder().withType(new TypeDetails(owner)).build();
         ClassFileImportContext context = mock(ClassFileImportContext.class);
         when(context.tryGetJavaClassWithType(anyString())).thenAnswer(new Answer<Optional<JavaClass>>() {
             @Override

File: archunit-example/src/test/java/com/tngtech/archunit/exampletest/DaoRulesTest.java
Patch:
@@ -18,9 +18,9 @@
 import static com.tngtech.archunit.lang.conditions.ArchConditions.never;
 import static com.tngtech.archunit.lang.conditions.ArchConditions.resideInAPackage;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.annotatedWith;
+import static com.tngtech.archunit.lang.conditions.ArchPredicates.callTarget;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.named;
 import static com.tngtech.archunit.lang.conditions.ArchPredicates.resideIn;
-import static com.tngtech.archunit.lang.conditions.ArchPredicates.targetOwnerIs;
 
 public class DaoRulesTest {
     private JavaClasses classes;
@@ -43,7 +43,7 @@ public void only_DAOs_may_use_the_EntityManager() {
         JavaClasses classesThatAreNoDaos = classes.that(not(resideIn("..dao.."))).as("classes that are no DAOs");
 
         all(classesThatAreNoDaos)
-                .should(never(callMethodWhere(targetOwnerIs(EntityManager.class)))
+                .should(never(callMethodWhere(callTarget().isDeclaredIn(EntityManager.class)))
                         .as("not access the " + EntityManager.class.getSimpleName()));
     }
 

File: archunit/src/main/java/com/tngtech/archunit/core/Formatters.java
Patch:
@@ -15,7 +15,7 @@ public static String formatMethod(String ownerName, String methodName, List<Clas
         return String.format(FULL_METHOD_NAME_TEMPLATE, ownerName, methodName, formatMethodParameters(parameters));
     }
 
-    private static String formatMethodParameters(List<Class<?>> parameters) {
+    public static String formatMethodParameters(List<Class<?>> parameters) {
         List<String> formatted = new ArrayList<>();
         for (Class<?> type : parameters) {
             formatted.add(String.format("%s.class", type.getSimpleName()));

File: archunit/src/main/java/com/tngtech/archunit/core/JavaClasses.java
Patch:
@@ -85,7 +85,7 @@ public CompletionProcess(ClassFileImportContext context) {
         }
 
         void completeClass(JavaClass clazz) {
-            classCompletionProcesses.add(clazz.completeClassHierarchyFrom(context));
+            classCompletionProcesses.add(clazz.completeFrom(context));
         }
 
         public void finish() {

File: archunit/src/main/java/com/tngtech/archunit/lang/ConditionEvent.java
Patch:
@@ -5,6 +5,7 @@
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.transform;
 
 public class ConditionEvent {
@@ -14,6 +15,7 @@ public class ConditionEvent {
     public ConditionEvent(boolean conditionSatisfied, String messageTemplate, Object... args) {
         this.conditionSatisfied = conditionSatisfied;
         this.message = String.format(messageTemplate, args);
+        checkArgument(conditionSatisfied || !message.trim().isEmpty(), "Message may not be empty for violation");
     }
 
     public boolean isViolation() {

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ContainsAnyCondition.java
Patch:
@@ -20,7 +20,9 @@ public void check(Collection<? extends T> collection, ConditionEvents events) {
         for (T element : collection) {
             condition.check(element, subEvents);
         }
-        events.add(new AnyConditionEvent(subEvents));
+        if (!subEvents.isEmpty()) {
+            events.add(new AnyConditionEvent(subEvents));
+        }
     }
 
     @Override

File: archunit/src/main/java/com/tngtech/archunit/lang/conditions/ContainsOnlyCondition.java
Patch:
@@ -20,7 +20,9 @@ public void check(Collection<? extends T> collection, ConditionEvents events) {
         for (T item : collection) {
             condition.check(item, subEvents);
         }
-        events.add(new OnlyConditionEvent(subEvents));
+        if (!subEvents.isEmpty()) {
+            events.add(new OnlyConditionEvent(subEvents));
+        }
     }
 
     @Override

File: archunit/src/test/java/com/tngtech/archunit/core/ClassFileImporterTest.java
Patch:
@@ -455,6 +455,7 @@ public void creates_relations_between_classes_and_interfaces() throws Exception
         JavaClass someCollection = classes.get(SomeCollection.class);
         JavaClass collectionInterface = classes.get(CollectionInterface.class);
         JavaClass collection = classes.get(Collection.class);
+        JavaClass iterable = classes.get(Iterable.class);
 
         assertThat(baseClass.getInterfaces()).containsOnly(otherInterface);
         assertThat(baseClass.getAllInterfaces()).containsOnly(otherInterface, grandParentInterface);
@@ -465,7 +466,8 @@ public void creates_relations_between_classes_and_interfaces() throws Exception
         assertThat(otherSubClass.getAllInterfaces()).containsOnly(parentInterface, grandParentInterface, otherInterface);
         assertThat(someCollection.getInterfaces()).containsOnly(collectionInterface, otherInterface, subInterface);
         assertThat(someCollection.getAllInterfaces()).containsOnly(
-                collectionInterface, otherInterface, subInterface, parentInterface, grandParentInterface, collection);
+                collectionInterface, otherInterface, subInterface, parentInterface, grandParentInterface,
+                collection, iterable);
     }
 
     @Test

File: archunit/src/test/java/com/tngtech/archunit/core/JavaAccessTest.java
Patch:
@@ -41,11 +41,11 @@ protected String descriptionTemplate() {
             return "";
         }
 
-        private static class Creator {
+        public static class Creator {
             private final JavaMethod origin;
             private JavaMethod target;
 
-            public Creator(JavaClass owner, String name) {
+            private Creator(JavaClass owner, String name) {
                 this.origin = javaMethod(owner, name);
             }
 

File: archunit/src/test/java/com/tngtech/archunit/core/JavaClassTest.java
Patch:
@@ -17,7 +17,7 @@
 import static com.tngtech.archunit.core.JavaConstructor.CONSTRUCTOR_NAME;
 import static com.tngtech.archunit.core.JavaStaticInitializer.STATIC_INITIALIZER_NAME;
 import static com.tngtech.archunit.core.TestUtils.javaClass;
-import static com.tngtech.archunit.core.TestUtils.simulateCallFrom;
+import static com.tngtech.archunit.core.TestUtils.simulateCall;
 import static com.tngtech.archunit.testutil.Conditions.codeUnitWithSignature;
 import static com.tngtech.archunit.testutil.Conditions.containing;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -124,8 +124,8 @@ public void Annotations_are_reported() {
     public void allAccesses_contains_accesses_from_superclass() {
         JavaClass javaClass = javaClass(ClassWithTwoFieldsAndTwoMethods.class);
         JavaClass anotherClass = javaClass(Object.class);
-        simulateCallFrom(javaClass.getMethod("stringMethod"), 8).to(anotherClass.getMethod("toString"));
-        simulateCallFrom(javaClass.getSuperClass().get().getMethod("objectMethod"), 8).to(anotherClass.getMethod("toString"));
+        simulateCall().from(javaClass.getMethod("stringMethod"), 8).to(anotherClass.getMethod("toString"));
+        simulateCall().from(javaClass.getSuperClass().get().getMethod("objectMethod"), 8).to(anotherClass.getMethod("toString"));
 
         assertThat(javaClass.getAccessesFromSelf()).extractingResultOf("getOriginOwner").containsOnly(javaClass);
         assertThat(javaClass.getAllAccessesFromSelf()).extractingResultOf("getOriginOwner")

File: archunit/src/test/java/com/tngtech/archunit/core/OptionalTest.java
Patch:
@@ -50,6 +50,8 @@ public void orNull_works() {
     public void or_works() {
         assertThat(Optional.of("test").or("other")).isEqualTo("test");
         assertThat(Optional.absent().or("other")).isEqualTo("other");
+        assertThat(Optional.of("test").or(Optional.of("other"))).isEqualTo(Optional.of("test"));
+        assertThat(Optional.absent().or(Optional.of("other"))).isEqualTo(Optional.of("other"));
     }
 
     @Test

File: archunit/src/test/java/com/tngtech/archunit/lang/conditions/MethodCallConditionTest.java
Patch:
@@ -14,7 +14,7 @@
 import org.junit.experimental.theories.Theory;
 import org.junit.runner.RunWith;
 
-import static com.tngtech.archunit.lang.conditions.ArchPredicates.targetIs;
+import static com.tngtech.archunit.lang.conditions.ArchPredicates.callTarget;
 import static com.tngtech.archunit.lang.conditions.testobjects.TestObjects.CALLER_CLASS;
 import static com.tngtech.archunit.lang.conditions.testobjects.TestObjects.TARGET_CLASS;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -167,7 +167,7 @@ public MethodCallConditionBuilder withParameters(Class<?> paramTypes) {
         }
 
         private MethodCallCondition build() {
-            return new MethodCallCondition(targetIs(targetClass, methodName, paramTypes));
+            return new MethodCallCondition(callTarget().is(targetClass, methodName, paramTypes));
         }
     }
 }
\ No newline at end of file

File: archunit/src/test/java/com/tngtech/archunit/library/dependencies/SlicesTest.java
Patch:
@@ -14,7 +14,7 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.tngtech.archunit.core.TestUtils.javaClasses;
 import static com.tngtech.archunit.core.TestUtils.javaMethod;
-import static com.tngtech.archunit.core.TestUtils.simulateCallFrom;
+import static com.tngtech.archunit.core.TestUtils.simulateCall;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class SlicesTest {
@@ -57,8 +57,8 @@ public void name_parts_are_resolved_correctly() {
     public void slices_of_dependencies() {
         JavaMethod methodThatCallsJavaUtil = javaMethod(Object.class, "toString");
         JavaMethod methodThatCallsJavaLang = javaMethod(Map.class, "put", Object.class, Object.class);
-        simulateCallFrom(methodThatCallsJavaUtil, 5).to(methodThatCallsJavaLang);
-        simulateCallFrom(methodThatCallsJavaLang, 1).to(methodThatCallsJavaUtil);
+        simulateCall().from(methodThatCallsJavaUtil, 5).to(methodThatCallsJavaLang);
+        simulateCall().from(methodThatCallsJavaLang, 1).to(methodThatCallsJavaUtil);
 
         Dependency first = Dependency.from(getOnlyElement(methodThatCallsJavaUtil.getMethodCallsFromSelf()));
         Dependency second = Dependency.from(getOnlyElement(methodThatCallsJavaLang.getMethodCallsFromSelf()));

File: archunit/src/main/java/com/tngtech/archunit/lang/ArchRule.java
Patch:
@@ -80,7 +80,7 @@ public static Creator priority(Priority priority) {
     public static InputTransformer<JavaClass> classes() {
         return new InputTransformer<JavaClass>("classes") {
             @Override
-            public JavaClasses transform(JavaClasses collection) {
+            public Iterable<JavaClass> doTransform(JavaClasses collection) {
                 return collection;
             }
         };

File: archunit/src/main/java/com/tngtech/archunit/lang/OpenArchRule.java
Patch:
@@ -26,7 +26,7 @@ private OpenArchRule(OpenDescribable<T> describable, ArchCondition<T> condition)
     }
 
     public <U extends Iterable<T> & HasDescription> void check(JavaClasses classes) {
-        priority(priority).all(inputTransformer.<U>transform(classes)).should(condition);
+        priority(priority).all(inputTransformer.transform(classes)).should(condition);
     }
 
     public static class OpenDescribable<TYPE> {

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/ArchUnitIntegrationTestRunner.java
Patch:
@@ -28,9 +28,10 @@ protected void runChild(final ArchTestExecution child, final RunNotifier notifie
         try {
             extractExpectedConfiguration(child).configure(expectedViolation);
             expectedViolation.apply(new IntegrationTestStatement(child), description).evaluate();
-            notifier.fireTestFinished(description);
         } catch (Throwable throwable) {
             notifier.fireTestFailure(new Failure(description, throwable));
+        } finally {
+            notifier.fireTestFinished(description);
         }
     }
 

File: archunit-integration-test/src/test/java/com/tngtech/archunit/integration/SessionBeanRulesIntegrationTest.java
Patch:
@@ -51,7 +51,7 @@ public void describeTo(Description description) {
 
         @Override
         protected boolean matchesSafely(String item) {
-            String[] parts = item.replaceAll(".*\n", "").split(" is implemented by ");
+            String[] parts = item.replaceAll(String.format(".*%n"), "").split(" is implemented by ");
             if (parts.length != 2) {
                 return false;
             }

File: archunit/src/test/java/com/tngtech/archunit/core/LocationTest.java
Patch:
@@ -77,7 +77,7 @@ public void JAR_location_as_ClassFileSource() throws IOException {
                 .withEntry(fullClassFileName(getClass()))
                 .withEntry(fullClassFileName(Location.class))
                 .create();
-        ClassFileSource source = Location.of(new URL("file://" + jar.getName())).asClassFileSource();
+        ClassFileSource source = Location.of(new URL("file:///" + jar.getName())).asClassFileSource();
 
         List<List<Byte>> importedFiles = new ArrayList<>();
         for (Supplier<InputStream> stream : source) {

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ArchTestExecution.java
Patch:
@@ -57,7 +57,7 @@ static class PositiveResult extends Result {
 
         @Override
         void notify(RunNotifier notifier) {
-            notifier.fireTestFinished(description);
+            // Do nothing
         }
     }
 

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ArchUnitRunner.java
Patch:
@@ -91,6 +91,7 @@ protected void runChild(ArchTestExecution child, RunNotifier notifier) {
         notifier.fireTestStarted(describeChild(child));
         JavaClasses classes = cache.get().getClassesToAnalyseFor(getTestClass().getJavaClass());
         child.evaluateOn(classes).notify(notifier);
+        notifier.fireTestFinished(describeChild(child));
     }
 
     static class SharedCache {

File: archunit-junit/src/main/java/com/tngtech/archunit/junit/ArchRules.java
Patch:
@@ -14,6 +14,7 @@ public class ArchRules<T> {
     private final Set<Field> fields;
     private final Set<Method> methods;
 
+    @SuppressWarnings("unchecked")
     public ArchRules(Class<?> definitionLocation) {
         fields = getAllFields(definitionLocation, withAnnotation(ArchTest.class));
         methods = getAllMethods(definitionLocation, withAnnotation(ArchTest.class));

