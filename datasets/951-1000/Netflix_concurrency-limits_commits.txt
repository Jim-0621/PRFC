File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/Gradient2Limit.java
Patch:
@@ -268,9 +268,9 @@ public int _update(final long startTime, final long rtt, final int inflight, fin
         final double shortRtt = (double)rtt;
         final double longRtt = this.longRtt.add(rtt).doubleValue();
 
-        shortRttSampleListener.addSample(shortRtt);
-        longRttSampleListener.addSample(longRtt);
-        queueSizeSampleListener.addSample(queueSize);
+        shortRttSampleListener.addDoubleSample(shortRtt);
+        longRttSampleListener.addDoubleSample(longRtt);
+        queueSizeSampleListener.addDoubleSample(queueSize);
 
         // If the long RTT is substantially larger than the short RTT then reduce the long RTT measurement.
         // This can happen when latency returns to normal after a prolonged prior of excessive load.  Reducing the

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/GradientLimit.java
Patch:
@@ -264,10 +264,10 @@ private int nextProbeCountdown() {
     @Override
     public int _update(final long startTime, final long rtt, final int inflight, final boolean didDrop) {
         lastRtt = rtt;
-        minWindowRttSampleListener.addSample(rtt);
+        minWindowRttSampleListener.addLongSample(rtt);
 
         final double queueSize = this.queueSize.apply((int)this.estimatedLimit);
-        queueSizeSampleListener.addSample(queueSize);
+        queueSizeSampleListener.addDoubleSample(queueSize);
 
         // Reset or probe for a new noload RTT and a new estimatedLimit.  It's necessary to cut the limit
         // in half to avoid having the limit drift upwards when the RTT is probed during heavy load.
@@ -283,7 +283,7 @@ public int _update(final long startTime, final long rtt, final int inflight, fin
         }
         
         final long rttNoLoad = rttNoLoadMeasurement.add(rtt).longValue();
-        minRttSampleListener.addSample(rttNoLoad);
+        minRttSampleListener.addLongSample(rttNoLoad);
         
         // Rtt could be higher than rtt_noload because of smoothing rtt noload updates
         // so set to 1.0 to indicate no queuing.  Otherwise calculate the slope and don't

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/VegasLimit.java
Patch:
@@ -218,7 +218,7 @@ protected int _update(long startTime, long rtt, int inflight, boolean didDrop) {
             return (int)estimatedLimit;
         }
         
-        rttSampleListener.addSample(rtt_noload);
+        rttSampleListener.addLongSample(rtt_noload);
 
         return updateEstimatedLimit(rtt, inflight, didDrop);
     }

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/AbstractPartitionedLimiter.java
Patch:
@@ -138,7 +138,7 @@ boolean isLimitExceeded() {
 
         void acquire() {
             int nowBusy = busy.incrementAndGet();
-            inflightDistribution.addSample(nowBusy);
+            inflightDistribution.addLongSample(nowBusy);
         }
 
         /**
@@ -149,7 +149,7 @@ boolean tryAcquire() {
             int current = busy.get();
             while (current < limit) {
                 if (busy.compareAndSet(current, current + 1)) {
-                    inflightDistribution.addSample(current + 1);
+                    inflightDistribution.addLongSample(current + 1);
                     return true;
                 }
                 current = busy.get();

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/SimpleLimiter.java
Patch:
@@ -59,7 +59,7 @@ else if (!semaphore.tryAcquire()) {
         else {
             listener = Optional.of(new Listener(createListener()));
         }
-        inflightDistribution.addSample(getInflight());
+        inflightDistribution.addLongSample(getInflight());
         return listener;
     }
 

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/MetricRegistry.java
Patch:
@@ -59,7 +59,7 @@ default SampleListener distribution(String id, String... tagNameValuePairs) {
      */
     @Deprecated
     default void registerGauge(String id, Supplier<Number> supplier, String... tagNameValuePairs) {
-        throw new UnsupportedOperationException("registerDistribution is deprecated");
+        throw new UnsupportedOperationException("registerGauge is deprecated");
     }
 
     /**

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/MetricRegistry.java
Patch:
@@ -59,7 +59,7 @@ default SampleListener distribution(String id, String... tagNameValuePairs) {
      */
     @Deprecated
     default void registerGauge(String id, Supplier<Number> supplier, String... tagNameValuePairs) {
-        throw new UnsupportedOperationException("registerDistribution is deprecated");
+        throw new UnsupportedOperationException("registerGauge is deprecated");
     }
 
     /**

File: concurrency-limits-grpc/src/main/java/com/netflix/concurrency/limits/grpc/server/ConcurrencyLimitServerInterceptor.java
Patch:
@@ -160,7 +160,6 @@ public void close(Status status, Metadata trailers) {
                                         } finally {
                                             safeComplete(() -> {
                                                 switch (status.getCode()) {
-                                                    case CANCELLED:
                                                     case DEADLINE_EXCEEDED:
                                                         listener.onDropped();
                                                         break;

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/GradientLimit.java
Patch:
@@ -57,12 +57,12 @@ public static class Builder {
          * Minimum threshold for accepting a new rtt sample.  Any RTT lower than this threshold
          * will be discarded.
          *  
-         * @param minRttTreshold
+         * @param minRttThreshold
          * @param units
          * @return Chainable builder
          */
         @Deprecated
-        public Builder minRttThreshold(long minRttTreshold, TimeUnit units) {
+        public Builder minRttThreshold(long minRttThreshold, TimeUnit units) {
             return this;
         }
         

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/VegasLimit.java
Patch:
@@ -63,7 +63,7 @@ private Builder() {
          * The limiter will probe for a new noload RTT every probeMultiplier * current limit
          * iterations.  Default value is 30.  
          * @param probeMultiplier 
-         * @return Chinable builder
+         * @return Chainable builder
          */
         public Builder probeMultiplier(int probeMultiplier) {
             this.probeMultiplier = probeMultiplier;

File: concurrency-limits-grpc/src/main/java/com/netflix/concurrency/limits/grpc/server/ConcurrencyLimitServerInterceptor.java
Patch:
@@ -160,7 +160,6 @@ public void close(Status status, Metadata trailers) {
                                         } finally {
                                             safeComplete(() -> {
                                                 switch (status.getCode()) {
-                                                    case CANCELLED:
                                                     case DEADLINE_EXCEEDED:
                                                         listener.onDropped();
                                                         break;

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/GradientLimit.java
Patch:
@@ -57,12 +57,12 @@ public static class Builder {
          * Minimum threshold for accepting a new rtt sample.  Any RTT lower than this threshold
          * will be discarded.
          *  
-         * @param minRttTreshold
+         * @param minRttThreshold
          * @param units
          * @return Chainable builder
          */
         @Deprecated
-        public Builder minRttThreshold(long minRttTreshold, TimeUnit units) {
+        public Builder minRttThreshold(long minRttThreshold, TimeUnit units) {
             return this;
         }
         

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/VegasLimit.java
Patch:
@@ -63,7 +63,7 @@ private Builder() {
          * The limiter will probe for a new noload RTT every probeMultiplier * current limit
          * iterations.  Default value is 30.  
          * @param probeMultiplier 
-         * @return Chinable builder
+         * @return Chainable builder
          */
         public Builder probeMultiplier(int probeMultiplier) {
             this.probeMultiplier = probeMultiplier;

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/internal/EmptyMetricRegistry.java
Patch:
@@ -25,11 +25,11 @@ public final class EmptyMetricRegistry implements MetricRegistry {
     private EmptyMetricRegistry() {}
     
     @Override
-    public SampleListener registerDistribution(String id, String... tagNameValuePairs) {
+    public SampleListener distribution(String id, String... tagNameValuePairs) {
         return value -> { };
     }
 
     @Override
-    public void registerGauge(String id, Supplier<Number> supplier, String... tagNameValuePairs) {
+    public void gauge(String id, Supplier<Number> supplier, String... tagNameValuePairs) {
     }
 }

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/Gradient2Limit.java
Patch:
@@ -251,9 +251,9 @@ private Gradient2Limit(Builder builder) {
         this.lastRtt = 0;
         this.longRtt = new ExpAvgMeasurement(builder.longWindow, 10);
 
-        this.longRttSampleListener = builder.registry.registerDistribution(MetricIds.MIN_RTT_NAME);
-        this.shortRttSampleListener = builder.registry.registerDistribution(MetricIds.WINDOW_MIN_RTT_NAME);
-        this.queueSizeSampleListener = builder.registry.registerDistribution(MetricIds.WINDOW_QUEUE_SIZE_NAME);
+        this.longRttSampleListener = builder.registry.distribution(MetricIds.MIN_RTT_NAME);
+        this.shortRttSampleListener = builder.registry.distribution(MetricIds.WINDOW_MIN_RTT_NAME);
+        this.queueSizeSampleListener = builder.registry.distribution(MetricIds.WINDOW_QUEUE_SIZE_NAME);
     }
 
     @Override

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/GradientLimit.java
Patch:
@@ -227,9 +227,9 @@ private GradientLimit(Builder builder) {
         this.resetRttCounter = nextProbeCountdown();
         this.rttNoLoadMeasurement = new MinimumMeasurement();
         
-        this.minRttSampleListener = builder.registry.registerDistribution(MetricIds.MIN_RTT_NAME);
-        this.minWindowRttSampleListener = builder.registry.registerDistribution(MetricIds.WINDOW_MIN_RTT_NAME);
-        this.queueSizeSampleListener = builder.registry.registerDistribution(MetricIds.WINDOW_QUEUE_SIZE_NAME);
+        this.minRttSampleListener = builder.registry.distribution(MetricIds.MIN_RTT_NAME);
+        this.minWindowRttSampleListener = builder.registry.distribution(MetricIds.WINDOW_MIN_RTT_NAME);
+        this.queueSizeSampleListener = builder.registry.distribution(MetricIds.WINDOW_QUEUE_SIZE_NAME);
     }
 
     private int nextProbeCountdown() {

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/VegasLimit.java
Patch:
@@ -185,7 +185,7 @@ private VegasLimit(Builder builder) {
 
         resetProbeJitter();
 
-        this.rttSampleListener = builder.registry.registerDistribution(MetricIds.MIN_RTT_NAME);
+        this.rttSampleListener = builder.registry.distribution(MetricIds.MIN_RTT_NAME);
     }
 
     private void resetProbeJitter() {

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/AbstractLimiter.java
Patch:
@@ -60,7 +60,7 @@ protected AbstractLimiter(Builder<?> builder) {
         this.limit = limitAlgorithm.getLimit();
         this.limitAlgorithm.notifyOnChange(this::onNewLimit);
 
-        builder.registry.registerGauge(MetricIds.LIMIT_NAME, this::getLimit);
+        builder.registry.gauge(MetricIds.LIMIT_NAME, this::getLimit);
 
     }
 

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/AbstractPartitionedLimiter.java
Patch:
@@ -160,8 +160,8 @@ public int getInflight() {
         }
 
         void createMetrics(MetricRegistry registry) {
-            this.inflightDistribution = registry.registerDistribution(MetricIds.INFLIGHT_NAME, PARTITION_TAG_NAME, name);
-            registry.registerGauge(MetricIds.PARTITION_LIMIT_NAME, this::getLimit, PARTITION_TAG_NAME, name);
+            this.inflightDistribution = registry.distribution(MetricIds.INFLIGHT_NAME, PARTITION_TAG_NAME, name);
+            registry.gauge(MetricIds.PARTITION_LIMIT_NAME, this::getLimit, PARTITION_TAG_NAME, name);
         }
 
         @Override

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/SimpleLimiter.java
Patch:
@@ -41,7 +41,7 @@ public static Builder newBuilder() {
     public SimpleLimiter(AbstractLimiter.Builder<?> builder) {
         super(builder);
 
-        this.inflightDistribution = builder.registry.registerDistribution(MetricIds.INFLIGHT_NAME);
+        this.inflightDistribution = builder.registry.distribution(MetricIds.INFLIGHT_NAME);
     }
 
     @Override

File: concurrency-limits-spectator/src/test/java/com/netflix/concurrency/limits/spectator/SpectatorMetricRegistryTest.java
Patch:
@@ -12,7 +12,7 @@ public void testGuage() {
         DefaultRegistry registry = new DefaultRegistry();
         SpectatorMetricRegistry metricRegistry = new SpectatorMetricRegistry(registry, registry.createId("foo"));
         
-        metricRegistry.registerGauge("bar", () -> 10);
+        metricRegistry.gauge("bar", () -> 10);
         
         PolledMeter.update(registry);
         
@@ -24,8 +24,8 @@ public void testUnregister() {
         DefaultRegistry registry = new DefaultRegistry();
         SpectatorMetricRegistry metricRegistry = new SpectatorMetricRegistry(registry, registry.createId("foo"));
         
-        metricRegistry.registerGauge("bar", () -> 10);
-        metricRegistry.registerGauge("bar", () -> 20);
+        metricRegistry.gauge("bar", () -> 10);
+        metricRegistry.gauge("bar", () -> 20);
         
         PolledMeter.update(registry);
         

File: concurrency-limits-core/src/test/java/com/netflix/concurrency/limits/limit/window/ImmutableAverageSampleWindowTest.java
Patch:
@@ -25,16 +25,16 @@ public class ImmutableAverageSampleWindowTest {
 
     @Test
     public void calculateAverage() {
-        ImmutableAverageSampleWindow window = new ImmutableAverageSampleWindow();
+        SampleWindow window = new ImmutableAverageSampleWindow();
         window = window.addSample(bigRtt, 1, false);
         window = window.addSample(moderateRtt, 1, false);
         window = window.addSample(lowRtt, 1, false);
         Assert.assertEquals((bigRtt + moderateRtt + lowRtt) / 3, window.getTrackedRttNanos());
     }
 
     @Test
-    public void droppedSampleShouldNotChangeTrackedAverage() {
-        ImmutableAverageSampleWindow window = new ImmutableAverageSampleWindow();
+    public void droppedSampleShouldChangeTrackedAverage() {
+        SampleWindow window = new ImmutableAverageSampleWindow();
         window = window.addSample(bigRtt, 1, false);
         window = window.addSample(moderateRtt, 1, false);
         window = window.addSample(lowRtt, 1, false);

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/window/SampleWindow.java
Patch:
@@ -21,9 +21,7 @@
  * @see com.netflix.concurrency.limits.limit.WindowedLimit
  */
 public interface SampleWindow {
-    SampleWindow addSample(long rtt, int inflight);
-
-    SampleWindow addDroppedSample(int inflight);
+    SampleWindow addSample(long rtt, int inflight, boolean dropped);
 
     long getCandidateRttNanos();
 

File: concurrency-limits-grpc/src/main/java/com/netflix/concurrency/limits/grpc/server/GrpcServerLimiterBuilder.java
Patch:
@@ -15,9 +15,7 @@
  */
 package com.netflix.concurrency.limits.grpc.server;
 
-import com.netflix.concurrency.limits.Limiter;
 import com.netflix.concurrency.limits.limiter.AbstractPartitionedLimiter;
-import com.netflix.concurrency.limits.limiter.SimpleLimiter;
 import io.grpc.Attributes;
 import io.grpc.Metadata;
 

File: concurrency-limits-grpc/src/test/java/com/netflix/concurrency/limits/grpc/server/ConcurrencyLimitServerInterceptorTest.java
Patch:
@@ -105,7 +105,6 @@ public void releaseOnError() {
         }
         // Verify
         Mockito.verify(limiter, Mockito.times(1)).acquire(Mockito.isA(GrpcServerRequestContext.class));
-        Mockito.verify(listener.getResult().get(), Mockito.timeout(1000).times(1)).onIgnore();
     }
 
     @Test

File: concurrency-limits-grpc/src/test/java/com/netflix/concurrency/limits/grpc/server/example/PartitionedExample.java
Patch:
@@ -81,8 +81,8 @@ public static void main(String[] args) throws IOException, ExecutionException, I
                     driver2.getAndResetDropCount(),
 //                    driver3.getAndResetDropCount(),
                     TimeUnit.NANOSECONDS.toMillis(latency.getAndReset()),
-                    limit.getShortRtt(TimeUnit.MILLISECONDS),
-                    limit.getLongRtt(TimeUnit.MILLISECONDS)
+                    limit.getLastRtt(TimeUnit.MILLISECONDS),
+                    limit.getRttNoLoad(TimeUnit.MILLISECONDS)
                     ))  ;
         }, 1, 1, TimeUnit.SECONDS);
 

File: concurrency-limits-servlet/src/main/java/com/netflix/concurrency/limits/servlet/ConcurrencyLimitServletFilter.java
Patch:
@@ -58,6 +58,7 @@ public void doFilter(ServletRequest request, ServletResponse response, FilterCha
                 listener.get().onSuccess();
             } catch (Exception e) {
                 listener.get().onIgnore();
+                throw e;
             }
         } else {
             outputThrottleError((HttpServletResponse)response);

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/window/SampleWindow.java
Patch:
@@ -21,9 +21,7 @@
  * @see com.netflix.concurrency.limits.limit.WindowedLimit
  */
 public interface SampleWindow {
-    SampleWindow addSample(long rtt, int inflight);
-
-    SampleWindow addDroppedSample(int inflight);
+    SampleWindow addSample(long rtt, int inflight, boolean dropped);
 
     long getCandidateRttNanos();
 

File: concurrency-limits-grpc/src/main/java/com/netflix/concurrency/limits/grpc/server/GrpcServerLimiterBuilder.java
Patch:
@@ -15,9 +15,7 @@
  */
 package com.netflix.concurrency.limits.grpc.server;
 
-import com.netflix.concurrency.limits.Limiter;
 import com.netflix.concurrency.limits.limiter.AbstractPartitionedLimiter;
-import com.netflix.concurrency.limits.limiter.SimpleLimiter;
 import io.grpc.Attributes;
 import io.grpc.Metadata;
 

File: concurrency-limits-grpc/src/test/java/com/netflix/concurrency/limits/grpc/server/ConcurrencyLimitServerInterceptorTest.java
Patch:
@@ -105,7 +105,6 @@ public void releaseOnError() {
         }
         // Verify
         Mockito.verify(limiter, Mockito.times(1)).acquire(Mockito.isA(GrpcServerRequestContext.class));
-        Mockito.verify(listener.getResult().get(), Mockito.timeout(1000).times(1)).onIgnore();
     }
 
     @Test

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/window/SampleWindow.java
Patch:
@@ -21,9 +21,7 @@
  * @see com.netflix.concurrency.limits.limit.WindowedLimit
  */
 public interface SampleWindow {
-    SampleWindow addSample(long rtt, int inflight);
-
-    SampleWindow addDroppedSample(int inflight);
+    SampleWindow addSample(long rtt, int inflight, boolean dropped);
 
     long getCandidateRttNanos();
 

File: concurrency-limits-grpc/src/main/java/com/netflix/concurrency/limits/grpc/server/GrpcServerLimiterBuilder.java
Patch:
@@ -15,9 +15,7 @@
  */
 package com.netflix.concurrency.limits.grpc.server;
 
-import com.netflix.concurrency.limits.Limiter;
 import com.netflix.concurrency.limits.limiter.AbstractPartitionedLimiter;
-import com.netflix.concurrency.limits.limiter.SimpleLimiter;
 import io.grpc.Attributes;
 import io.grpc.Metadata;
 

File: concurrency-limits-grpc/src/test/java/com/netflix/concurrency/limits/grpc/server/ConcurrencyLimitServerInterceptorTest.java
Patch:
@@ -105,7 +105,6 @@ public void releaseOnError() {
         }
         // Verify
         Mockito.verify(limiter, Mockito.times(1)).acquire(Mockito.isA(GrpcServerRequestContext.class));
-        Mockito.verify(listener.getResult().get(), Mockito.timeout(1000).times(1)).onIgnore();
     }
 
     @Test

File: concurrency-limits-grpc/src/test/java/com/netflix/concurrency/limits/grpc/server/ConcurrencyLimitServerInterceptorTest.java
Patch:
@@ -72,7 +72,7 @@ public void releaseOnSuccess() {
 
         ClientCalls.blockingUnaryCall(channel, METHOD_DESCRIPTOR, CallOptions.DEFAULT, "foo");
         Mockito.verify(limiter, Mockito.times(1)).acquire(Mockito.isA(GrpcServerRequestContext.class));
-        Mockito.verify(listener.getResult().get(), Mockito.times(1)).onSuccess();
+        Mockito.verify(listener.getResult().get(), Mockito.timeout(1000).times(1)).onSuccess();
     }
 
     @Test
@@ -94,7 +94,7 @@ public void releaseOnError() {
             // Verify
             Assert.assertEquals(Status.Code.INVALID_ARGUMENT, e.getStatus().getCode());
             Mockito.verify(limiter, Mockito.times(1)).acquire(Mockito.isA(GrpcServerRequestContext.class));
-            Mockito.verify(listener.getResult().get(), Mockito.times(1)).onIgnore();
+            Mockito.verify(listener.getResult().get(), Mockito.timeout(1000).times(1)).onIgnore();
         }
     }
 
@@ -116,7 +116,7 @@ public void releaseOnUncaughtException() throws IOException {
         } catch (StatusRuntimeException e) {
             // Verify
             Mockito.verify(limiter, Mockito.times(1)).acquire(Mockito.isA(GrpcServerRequestContext.class));
-            Mockito.verify(listener.getResult().get(), Mockito.times(1)).onIgnore();
+            Mockito.verify(listener.getResult().get(), Mockito.timeout(1000).times(1)).onIgnore();
         }
     }
 }

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/ImmutableSampleWindow.java
Patch:
@@ -55,7 +55,7 @@ public long getCandidateRttNanos() {
         return minRtt;
     }
 
-    public long getAverateRttNanos() {
+    public long getAverageRttNanos() {
         return sampleCount == 0 ? 0 : sum / sampleCount;
     }
     
@@ -75,9 +75,9 @@ public boolean didDrop() {
     public String toString() {
         return "ImmutableSampleWindow ["
                 + "minRtt=" + TimeUnit.NANOSECONDS.toMicros(minRtt) / 1000.0 
-                + ", avgRtt=" + TimeUnit.NANOSECONDS.toMicros(getAverateRttNanos()) / 1000.0
+                + ", avgRtt=" + TimeUnit.NANOSECONDS.toMicros(getAverageRttNanos()) / 1000.0
                 + ", maxInFlight=" + maxInFlight 
                 + ", sampleCount=" + sampleCount 
                 + ", didDrop=" + didDrop + "]";
     }
-}
\ No newline at end of file
+}

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/WindowedLimit.java
Patch:
@@ -55,7 +55,7 @@ public Builder minWindowTime(long minWindowTime, TimeUnit units) {
          * Maximum window duration for sampling a new minRtt
          */
         public Builder maxWindowTime(long maxWindowTime, TimeUnit units) {
-            Preconditions.checkArgument(maxWindowTime >= units.toMillis(100), "minWindowTime must be >= 100 ms");
+            Preconditions.checkArgument(units.toMillis(maxWindowTime) >= 100, "maxWindowTime must be >= 100 ms");
             this.maxWindowTime = units.toNanos(maxWindowTime);
             return this;
         }
@@ -137,7 +137,7 @@ public void onSample(long startTime, long rtt, int inflight, boolean didDrop) {
                         sample.set(new ImmutableSampleWindow());
 
                         nextUpdateTime = endTime + Math.min(Math.max(current.getCandidateRttNanos() * 2, minWindowTime), maxWindowTime);
-                        delegate.onSample(startTime, current.getAverateRttNanos(), current.getMaxInFlight(), current.didDrop());
+                        delegate.onSample(startTime, current.getAverageRttNanos(), current.getMaxInFlight(), current.didDrop());
                     }
                 }
             }

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/ImmutableSampleWindow.java
Patch:
@@ -55,7 +55,7 @@ public long getCandidateRttNanos() {
         return minRtt;
     }
 
-    public long getAverateRttNanos() {
+    public long getAverageRttNanos() {
         return sampleCount == 0 ? 0 : sum / sampleCount;
     }
     
@@ -75,9 +75,9 @@ public boolean didDrop() {
     public String toString() {
         return "ImmutableSampleWindow ["
                 + "minRtt=" + TimeUnit.NANOSECONDS.toMicros(minRtt) / 1000.0 
-                + ", avgRtt=" + TimeUnit.NANOSECONDS.toMicros(getAverateRttNanos()) / 1000.0
+                + ", avgRtt=" + TimeUnit.NANOSECONDS.toMicros(getAverageRttNanos()) / 1000.0
                 + ", maxInFlight=" + maxInFlight 
                 + ", sampleCount=" + sampleCount 
                 + ", didDrop=" + didDrop + "]";
     }
-}
\ No newline at end of file
+}

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/WindowedLimit.java
Patch:
@@ -55,7 +55,7 @@ public Builder minWindowTime(long minWindowTime, TimeUnit units) {
          * Maximum window duration for sampling a new minRtt
          */
         public Builder maxWindowTime(long maxWindowTime, TimeUnit units) {
-            Preconditions.checkArgument(maxWindowTime >= units.toMillis(100), "minWindowTime must be >= 100 ms");
+            Preconditions.checkArgument(units.toMillis(maxWindowTime) >= 100, "maxWindowTime must be >= 100 ms");
             this.maxWindowTime = units.toNanos(maxWindowTime);
             return this;
         }
@@ -137,7 +137,7 @@ public void onSample(long startTime, long rtt, int inflight, boolean didDrop) {
                         sample.set(new ImmutableSampleWindow());
 
                         nextUpdateTime = endTime + Math.min(Math.max(current.getCandidateRttNanos() * 2, minWindowTime), maxWindowTime);
-                        delegate.onSample(startTime, current.getAverateRttNanos(), current.getMaxInFlight(), current.didDrop());
+                        delegate.onSample(startTime, current.getAverageRttNanos(), current.getMaxInFlight(), current.didDrop());
                     }
                 }
             }

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/Gradient2Limit.java
Patch:
@@ -263,7 +263,7 @@ public int _update(final long startTime, final long rtt, final int inflight, fin
 
         // Rtt could be higher than rtt_noload because of smoothing rtt noload updates
         // so set to 1.0 to indicate no queuing.  Otherwise calculate the slope and don't
-        // allow it to be reduced by more than half to avoid aggressive load-sheding due to 
+        // allow it to be reduced by more than half to avoid aggressive load-shedding due to 
         // outliers.
         final double gradient = Math.max(0.5, Math.min(1.0, longRtt / shortRtt));
         double newLimit = estimatedLimit * gradient + queueSize;

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/Gradient2Limit.java
Patch:
@@ -40,7 +40,7 @@
  * The core algorithm re-calculates the limit every sampling window (ex. 1 second) using the formula
  *
  *      // Calculate the gradient limiting to the range [0.5, 1.0] to filter outliers
- *      gradient = min(0.5, max(1.0, currentRtt / longtermRtt));
+ *      gradient = max(0.5, min(1.0, longtermRtt / currentRtt));
  *
  *      // Calculate the new limit by applying the gradient and allowing for some queuing
  *      newLimit = gradient * currentLimit + queueSize;

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/Gradient2Limit.java
Patch:
@@ -230,7 +230,7 @@ private Gradient2Limit(Builder builder) {
         this.minLimit = builder.minLimit;
         this.queueSize = builder.queueSize;
         this.smoothing = builder.smoothing;
-        this.shortRtt = new SingleMeasurement(); // new ExpAvgMeasurement(builder.shortWindow,10);
+        this.shortRtt = new SingleMeasurement();
         this.longRtt = new ExpAvgMeasurement(builder.longWindow, 10);
 
         this.longRttSampleListener = builder.registry.registerDistribution(MetricIds.MIN_RTT_NAME);

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/AbstractPartitionedLimiter.java
Patch:
@@ -269,6 +269,7 @@ private void releasePartition(Partition partition) {
 
     @Override
     protected void onNewLimit(int newLimit) {
+        super.onNewLimit(newLimit);
         partitions.forEach((name, partition) -> partition.updateLimit(newLimit));
     }
 

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/functions/Log10RootFunction.java
Patch:
@@ -43,6 +43,6 @@ public static Function<Integer, Integer> create(int baseline) {
     
     @Override
     public Integer apply(Integer t) {
-        return t < 1000 ? lookup[t] : (int)Math.sqrt(t);
+        return t < 1000 ? lookup[t] : (int)Math.log10(t);
     }
 }

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/functions/Log10RootFunction.java
Patch:
@@ -43,6 +43,6 @@ public static Function<Integer, Integer> create(int baseline) {
     
     @Override
     public Integer apply(Integer t) {
-        return t < 1000 ? lookup[t] : (int)Math.sqrt(t);
+        return t < 1000 ? lookup[t] : (int)Math.log10(t);
     }
 }

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/Gradient2Limit.java
Patch:
@@ -230,7 +230,7 @@ private Gradient2Limit(Builder builder) {
         this.minLimit = builder.minLimit;
         this.queueSize = builder.queueSize;
         this.smoothing = builder.smoothing;
-        this.shortRtt = new SingleMeasurement(); // new ExpAvgMeasurement(builder.shortWindow,10);
+        this.shortRtt = new SingleMeasurement();
         this.longRtt = new ExpAvgMeasurement(builder.longWindow, 10);
 
         this.longRttSampleListener = builder.registry.registerDistribution(MetricIds.MIN_RTT_NAME);

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/AbstractPartitionedLimiter.java
Patch:
@@ -269,6 +269,7 @@ private void releasePartition(Partition partition) {
 
     @Override
     protected void onNewLimit(int newLimit) {
+        super.onNewLimit(newLimit);
         partitions.forEach((name, partition) -> partition.updateLimit(newLimit));
     }
 

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/Gradient2Limit.java
Patch:
@@ -57,9 +57,9 @@
  *
  * 2.  Transition from steady state to load
  *
- * In this state either the RPS to latency has spiked. The gradient is < 1.0 due to a growing request queue that
+ * In this state either the RPS to latency has spiked. The gradient is {@literal <} 1.0 due to a growing request queue that
  * cannot be handled by the system. Excessive requests and rejected due to the low limit. The baseline RTT grows using
- * exponential decay but lags the current measurement, which keeps the gradient < 1.0 and limit low.
+ * exponential decay but lags the current measurement, which keeps the gradient {@literal <} 1.0 and limit low.
  *
  * 3.  Transition from load to steady state
  *

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/Gradient2Limit.java
Patch:
@@ -57,9 +57,9 @@
  *
  * 2.  Transition from steady state to load
  *
- * In this state either the RPS to latency has spiked. The gradient is < 1.0 due to a growing request queue that
+ * In this state either the RPS to latency has spiked. The gradient is {@literal <} 1.0 due to a growing request queue that
  * cannot be handled by the system. Excessive requests and rejected due to the low limit. The baseline RTT grows using
- * exponential decay but lags the current measurement, which keeps the gradient < 1.0 and limit low.
+ * exponential decay but lags the current measurement, which keeps the gradient {@literal <} 1.0 and limit low.
  *
  * 3.  Transition from load to steady state
  *

File: concurrency-limits-core/src/test/java/com/netflix/concurrency/limits/limit/ExpAvgMeasurementTest.java
Patch:
@@ -12,13 +12,13 @@ public class ExpAvgMeasurementTest {
     public void testWarmup() {
         ExpAvgMeasurement avg = new ExpAvgMeasurement(100, 10);
 
-        double expected[] = new double[]{10.0, 10, 10, 10, 10, 10, 10, 10, 10, 10};
+        double expected[] = new double[]{10.0, 10.5, 11, 11.5, 12, 12.5, 13, 13.5, 14, 14.5};
         for (int i = 0; i < 10; i++) {
             double value = avg.add(i + 10).doubleValue();
             Assert.assertEquals(expected[i], avg.get().doubleValue(), 0.01);
         }
 
         avg.add(100);
-        Assert.assertEquals(11.7, avg.get().doubleValue(), 0.1);
+        Assert.assertEquals(16.2, avg.get().doubleValue(), 0.1);
     }
 }

File: concurrency-limits-core/src/test/java/com/netflix/concurrency/limits/limit/ExpAvgMeasurementTest.java
Patch:
@@ -12,13 +12,13 @@ public class ExpAvgMeasurementTest {
     public void testWarmup() {
         ExpAvgMeasurement avg = new ExpAvgMeasurement(100, 10);
 
-        double expected[] = new double[]{10.0, 10, 10, 10, 10, 10, 10, 10, 10, 10};
+        double expected[] = new double[]{10.0, 10.5, 11, 11.5, 12, 12.5, 13, 13.5, 14, 14.5};
         for (int i = 0; i < 10; i++) {
             double value = avg.add(i + 10).doubleValue();
             Assert.assertEquals(expected[i], avg.get().doubleValue(), 0.01);
         }
 
         avg.add(100);
-        Assert.assertEquals(11.7, avg.get().doubleValue(), 0.1);
+        Assert.assertEquals(16.2, avg.get().doubleValue(), 0.1);
     }
 }

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/Gradient2Limit.java
Patch:
@@ -21,6 +21,7 @@
 import com.netflix.concurrency.limits.internal.EmptyMetricRegistry;
 import com.netflix.concurrency.limits.limit.measurement.ExpAvgMeasurement;
 import com.netflix.concurrency.limits.limit.measurement.Measurement;
+import com.netflix.concurrency.limits.limit.measurement.SingleMeasurement;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -205,7 +206,7 @@ private Gradient2Limit(Builder builder) {
         this.minLimit = builder.minLimit;
         this.queueSize = builder.queueSize;
         this.smoothing = builder.smoothing;
-        this.shortRtt = new ExpAvgMeasurement(builder.shortWindow,10);
+        this.shortRtt = new SingleMeasurement(); // new ExpAvgMeasurement(builder.shortWindow,10);
         this.longRtt = new ExpAvgMeasurement(builder.longWindow,10);
         this.maxDriftIntervals = builder.shortWindow * builder.driftMultiplier;
 
@@ -237,6 +238,7 @@ public int _update(final long startTime, final long rtt, final int inflight, fin
             }
         } else {
             intervalsAbove = 0;
+            this.longRtt.update(ignore -> (longRtt + shortRtt) / 2);
         }
 
         shortRttSampleListener.addSample(shortRtt);

File: concurrency-limits-core/src/test/java/com/netflix/concurrency/limits/limit/ExpAvgMeasurementTest.java
Patch:
@@ -12,13 +12,13 @@ public class ExpAvgMeasurementTest {
     public void testWarmup() {
         ExpAvgMeasurement avg = new ExpAvgMeasurement(100, 10);
 
-        double expected[] = new double[]{10.0, 10.5, 11, 11.5, 12, 12.5, 13, 13.5, 14, 14.5};
+        double expected[] = new double[]{10.0, 10, 10, 10, 10, 10, 10, 10, 10, 10};
         for (int i = 0; i < 10; i++) {
             double value = avg.add(i + 10).doubleValue();
             Assert.assertEquals(expected[i], avg.get().doubleValue(), 0.01);
         }
 
         avg.add(100);
-        Assert.assertEquals(16.19, avg.get().doubleValue(), 0.01);
+        Assert.assertEquals(11.7, avg.get().doubleValue(), 0.1);
     }
 }

File: concurrency-limits-core/src/test/java/com/netflix/concurrency/limits/limit/ExpAvgMeasurementTest.java
Patch:
@@ -12,13 +12,13 @@ public class ExpAvgMeasurementTest {
     public void testWarmup() {
         ExpAvgMeasurement avg = new ExpAvgMeasurement(100, 10);
 
-        double expected[] = new double[]{10.0, 10.5, 11, 11.5, 12, 12.5, 13, 13.5, 14, 14.5};
+        double expected[] = new double[]{10.0, 10, 10, 10, 10, 10, 10, 10, 10, 10};
         for (int i = 0; i < 10; i++) {
             double value = avg.add(i + 10).doubleValue();
             Assert.assertEquals(expected[i], avg.get().doubleValue(), 0.01);
         }
 
         avg.add(100);
-        Assert.assertEquals(16.19, avg.get().doubleValue(), 0.01);
+        Assert.assertEquals(11.7, avg.get().doubleValue(), 0.1);
     }
 }

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/Gradient2Limit.java
Patch:
@@ -21,6 +21,7 @@
 import com.netflix.concurrency.limits.internal.EmptyMetricRegistry;
 import com.netflix.concurrency.limits.limit.measurement.ExpAvgMeasurement;
 import com.netflix.concurrency.limits.limit.measurement.Measurement;
+import com.netflix.concurrency.limits.limit.measurement.SingleMeasurement;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -205,7 +206,7 @@ private Gradient2Limit(Builder builder) {
         this.minLimit = builder.minLimit;
         this.queueSize = builder.queueSize;
         this.smoothing = builder.smoothing;
-        this.shortRtt = new ExpAvgMeasurement(builder.shortWindow,10);
+        this.shortRtt = new SingleMeasurement(); // new ExpAvgMeasurement(builder.shortWindow,10);
         this.longRtt = new ExpAvgMeasurement(builder.longWindow,10);
         this.maxDriftIntervals = builder.shortWindow * builder.driftMultiplier;
 
@@ -237,6 +238,7 @@ public int _update(final long startTime, final long rtt, final int inflight, fin
             }
         } else {
             intervalsAbove = 0;
+            this.longRtt.update(ignore -> (longRtt + shortRtt) / 2);
         }
 
         shortRttSampleListener.addSample(shortRtt);

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/AbstractLimiter.java
Patch:
@@ -17,6 +17,7 @@
 
 import com.netflix.concurrency.limits.Limit;
 import com.netflix.concurrency.limits.Limiter;
+import com.netflix.concurrency.limits.MetricIds;
 import com.netflix.concurrency.limits.MetricRegistry;
 import com.netflix.concurrency.limits.internal.EmptyMetricRegistry;
 import com.netflix.concurrency.limits.limit.VegasLimit;
@@ -58,6 +59,8 @@ protected AbstractLimiter(Builder<?> builder) {
         this.limitAlgorithm = builder.limit;
         this.limit = limitAlgorithm.getLimit();
         this.limitAlgorithm.notifyOnChange(this::onNewLimit);
+        
+        builder.registry.registerGauge(MetricIds.LIMIT_GUAGE_NAME, this::getLimit);
     }
 
     protected Listener createListener() {

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/AbstractPartitionedLimiter.java
Patch:
@@ -192,8 +192,6 @@ public AbstractPartitionedLimiter(Builder<?, ContextT> builder) {
 
         this.partitionResolvers = builder.partitionResolvers;
         this.maxDelayedThreads = builder.maxDelayedThreads;
-        
-        builder.registry.registerGauge(MetricIds.LIMIT_GUAGE_NAME, this::getLimit);
 
         onNewLimit(getLimit());
     }

File: concurrency-limits-grpc/src/test/java/com/netflix/concurrency/limits/grpc/server/example/PartitionedExample.java
Patch:
@@ -28,7 +28,7 @@ public static void main(String[] args) throws IOException, ExecutionException, I
                         .partition("1", 1.0)
                         .partition("2", 0.0)
 //                        .partition("3", 0.0)
-                        .partitionRejectDelay("2", 1000, TimeUnit.MILLISECONDS)
+//                        .partitionRejectDelay("2", 1000, TimeUnit.MILLISECONDS)
 //                        .partitionRejectDelay("3", 1000, TimeUnit.MILLISECONDS)
                         .limit(WindowedLimit.newBuilder()
                                 .minWindowTime(1, TimeUnit.SECONDS)

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/GradientLimit.java
Patch:
@@ -46,7 +46,7 @@ public static class Builder {
         private int initialLimit = 50;
         private int minLimit = 1;
         private int maxConcurrency = 1000;
-        
+
         private double smoothing = 0.2;
         private Function<Integer, Integer> queueSize = SquareRootFunction.create(4);
         private MetricRegistry registry = EmptyMetricRegistry.INSTANCE;
@@ -272,9 +272,10 @@ public int _update(final long startTime, final long rtt, final int inflight, fin
         // Don't grow the limit if we are app limited
         } else if (inflight < estimatedLimit / 2) {
             return (int)estimatedLimit;
+        } else {
+            newLimit = estimatedLimit * gradient + queueSize;
         }
 
-        newLimit = estimatedLimit * gradient + queueSize;
         if (newLimit < estimatedLimit) {
             newLimit = Math.max(minLimit, estimatedLimit * (1-smoothing) + smoothing*(newLimit));
         }

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/WindowedLimit.java
Patch:
@@ -30,7 +30,7 @@ public class WindowedLimit implements Limit {
     /**
      * Minimum observed samples to filter out sample windows with not enough significant samples
      */
-    private static final int DEFAULT_WINDOW_SIZE = 100;
+    private static final int DEFAULT_WINDOW_SIZE = 10;
 
     public static Builder newBuilder() {
         return new Builder();

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/WindowedLimit.java
Patch:
@@ -30,7 +30,7 @@ public class WindowedLimit implements Limit {
     /**
      * Minimum observed samples to filter out sample windows with not enough significant samples
      */
-    private static final int DEFAULT_WINDOW_SIZE = 100;
+    private static final int DEFAULT_WINDOW_SIZE = 10;
 
     public static Builder newBuilder() {
         return new Builder();

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/AbstractLimiter.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.function.Supplier;
 
 public abstract class AbstractLimiter<ContextT> implements Limiter<ContextT> {
-    public abstract static class Builder<BuilderT extends Builder<BuilderT, ContextT>, ContextT> {
+    public abstract static class Builder<BuilderT extends Builder<BuilderT>> {
         private Limit limit = VegasLimit.newDefault();
         private Supplier<Long> clock = System::nanoTime;
         protected MetricRegistry registry = EmptyMetricRegistry.INSTANCE;
@@ -53,7 +53,7 @@ public BuilderT metricRegistry(MetricRegistry registry) {
     private final Limit limitAlgorithm;
     private volatile int limit;
 
-    protected AbstractLimiter(Builder<?, ContextT> builder) {
+    protected AbstractLimiter(Builder<?> builder) {
         this.clock = builder.clock;
         this.limitAlgorithm = builder.limit;
         this.limit = limitAlgorithm.getLimit();

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/AbstractPartitionedLimiter.java
Patch:
@@ -31,7 +31,7 @@
 public abstract class AbstractPartitionedLimiter<ContextT> extends AbstractLimiter<ContextT> {
     private static final String PARTITION_TAG_NAME = "partition";
 
-    public abstract static class Builder<BuilderT extends AbstractLimiter.Builder<BuilderT, ContextT>, ContextT> extends AbstractLimiter.Builder<BuilderT, ContextT> {
+    public abstract static class Builder<BuilderT extends AbstractLimiter.Builder<BuilderT>, ContextT> extends AbstractLimiter.Builder<BuilderT> {
         private List<Function<ContextT, String>> partitionResolvers = new ArrayList<>();
         private final Map<String, Partition> partitions = new LinkedHashMap<>();
 

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/AbstractPartitionedLimiter.java
Patch:
@@ -66,6 +66,8 @@ boolean isLimitExceeded() {
 
         void acquire() {
             busy++;
+            inflightDistribution.addSample(busy);
+
         }
 
         void release() {

File: concurrency-limits-core/src/test/java/com/netflix/concurrency/limits/limiter/BlockingLimiterTest.java
Patch:
@@ -44,7 +44,7 @@ public void testMultipleBlockedThreads() {
         SettableLimit limit = SettableLimit.startingAt(1);
         BlockingLimiter<Void> limiter = BlockingLimiter.wrap(DefaultLimiter.newBuilder().limit(limit).build(new SimpleStrategy<>()));
         ExecutorService executorService = Executors.newFixedThreadPool(numThreads);
-        CyclicBarrier barrier = new CyclicBarrier(numThreads);
+        CyclicBarrier barrier = new CyclicBarrier(numThreads + 1);
         try {
             IntStream.range(0, numThreads).forEach(x -> executorService.submit(() -> {
                 await(barrier);

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/LifoBlockingLimiter.java
Patch:
@@ -69,7 +69,7 @@ public Builder<ContextT> backlogTimeoutMillis(long timeout) {
         /**
          * Function to derive the backlog timeout from the request context.  This allows timeouts
          * to be set dynamically based on things like request deadlines. 
-         * @param supplier
+         * @param mapper
          * @param units
          * @return
          */

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/LifoBlockingLimiter.java
Patch:
@@ -69,7 +69,7 @@ public Builder<ContextT> backlogTimeoutMillis(long timeout) {
         /**
          * Function to derive the backlog timeout from the request context.  This allows timeouts
          * to be set dynamically based on things like request deadlines. 
-         * @param supplier
+         * @param mapper
          * @param units
          * @return
          */

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/functions/SquareRootFunction.java
Patch:
@@ -24,7 +24,7 @@ public final class SquareRootFunction implements Function<Integer, Integer> {
      * @return
      */
     public static Function<Integer, Integer> create(int baseline) {
-        return INSTANCE.andThen(t -> t + baseline);
+        return INSTANCE.andThen(t -> Math.max(baseline, t));
     }
     
     @Override

File: concurrency-limits-core/src/test/java/com/netflix/concurrency/limits/limit/functions/SquareRootFunctionTest.java
Patch:
@@ -9,18 +9,18 @@ public class SquareRootFunctionTest {
     @Test
     public void confirm0Index() {
         Function<Integer, Integer> func = SquareRootFunction.create(4);
-        Assert.assertEquals(5, func.apply(0).intValue());
+        Assert.assertEquals(4, func.apply(0).intValue());
     }
     
     @Test
     public void confirmMaxIndex() {
         Function<Integer, Integer> func = SquareRootFunction.create(4);
-        Assert.assertEquals(35, func.apply(999).intValue());
+        Assert.assertEquals(31, func.apply(999).intValue());
     }
     
     @Test
     public void confirmOutofLookupRange() {
         Function<Integer, Integer> func = SquareRootFunction.create(4);
-        Assert.assertEquals(35, func.apply(1005).intValue());
+        Assert.assertEquals(50, func.apply(2500).intValue());
     }
 }

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/DefaultLimiter.java
Patch:
@@ -23,7 +23,7 @@ public final class DefaultLimiter<ContextT> implements Limiter<ContextT> {
     
     private static final long DEFAULT_MIN_WINDOW_TIME = TimeUnit.SECONDS.toNanos(1);
     private static final long DEFAULT_MAX_WINDOW_TIME = TimeUnit.SECONDS.toNanos(1);
-    private static final long DEFAULT_MIN_RTT_THRESHOLD = TimeUnit.MICROSECONDS.toNanos(100);
+    private static final long DEFAULT_MIN_RTT_THRESHOLD = TimeUnit.MICROSECONDS.toNanos(500);
     
     /**
      * Minimum observed samples to filter out sample windows with not enough significant samples
@@ -143,7 +143,7 @@ private DefaultLimiter(Builder builder, Strategy<ContextT> strategy) {
         this.limit = builder.limit;
         this.minWindowTime = builder.minWindowTime;
         this.maxWindowTime = builder.maxWindowTime;
-        this.minRttThreshold = DEFAULT_MIN_RTT_THRESHOLD;
+        this.minRttThreshold = builder.minRttThreshold;
         this.windowSize = builder.windowSize;
         this.strategy = strategy;
         strategy.setLimit(limit.getLimit());

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/DefaultLimiter.java
Patch:
@@ -23,7 +23,7 @@ public final class DefaultLimiter<ContextT> implements Limiter<ContextT> {
     
     private static final long DEFAULT_MIN_WINDOW_TIME = TimeUnit.SECONDS.toNanos(1);
     private static final long DEFAULT_MAX_WINDOW_TIME = TimeUnit.SECONDS.toNanos(1);
-    private static final long DEFAULT_MIN_RTT_THRESHOLD = TimeUnit.MICROSECONDS.toNanos(100);
+    private static final long DEFAULT_MIN_RTT_THRESHOLD = TimeUnit.MICROSECONDS.toNanos(500);
     
     /**
      * Minimum observed samples to filter out sample windows with not enough significant samples
@@ -143,7 +143,7 @@ private DefaultLimiter(Builder builder, Strategy<ContextT> strategy) {
         this.limit = builder.limit;
         this.minWindowTime = builder.minWindowTime;
         this.maxWindowTime = builder.maxWindowTime;
-        this.minRttThreshold = DEFAULT_MIN_RTT_THRESHOLD;
+        this.minRttThreshold = builder.minRttThreshold;
         this.windowSize = builder.windowSize;
         this.strategy = strategy;
         strategy.setLimit(limit.getLimit());

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/GradientLimit.java
Patch:
@@ -97,7 +97,7 @@ public Builder maxConcurrency(int maxConcurrency) {
         /**
          * Maximum allowable concurrency.  Any estimated concurrency will be capped
          * at this value
-         * @param maxConcurrency
+         * @param maxLimit
          * @return Chainable builder
          */
         public Builder maxLimit(int maxLimit) {

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/GradientLimit.java
Patch:
@@ -97,7 +97,7 @@ public Builder maxConcurrency(int maxConcurrency) {
         /**
          * Maximum allowable concurrency.  Any estimated concurrency will be capped
          * at this value
-         * @param maxConcurrency
+         * @param maxLimit
          * @return Chainable builder
          */
         public Builder maxLimit(int maxLimit) {

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/functions/SquareRootFunction.java
Patch:
@@ -24,7 +24,7 @@ public final class SquareRootFunction implements Function<Integer, Integer> {
      * @return
      */
     public static Function<Integer, Integer> create(int baseline) {
-        return INSTANCE.andThen(t -> t + baseline);
+        return INSTANCE.andThen(t -> Math.max(t, baseline));
     }
     
     @Override

File: concurrency-limits-core/src/test/java/com/netflix/concurrency/limits/limit/functions/SquareRootFunctionTest.java
Patch:
@@ -9,18 +9,18 @@ public class SquareRootFunctionTest {
     @Test
     public void confirm0Index() {
         Function<Integer, Integer> func = SquareRootFunction.create(4);
-        Assert.assertEquals(5, func.apply(0).intValue());
+        Assert.assertEquals(4, func.apply(0).intValue());
     }
     
     @Test
     public void confirmMaxIndex() {
         Function<Integer, Integer> func = SquareRootFunction.create(4);
-        Assert.assertEquals(35, func.apply(999).intValue());
+        Assert.assertEquals(31, func.apply(999).intValue());
     }
     
     @Test
     public void confirmOutofLookupRange() {
         Function<Integer, Integer> func = SquareRootFunction.create(4);
-        Assert.assertEquals(35, func.apply(1005).intValue());
+        Assert.assertEquals(33, func.apply(1105).intValue());
     }
 }

File: concurrency-limits-grpc/src/main/java/com/netflix/concurrency/limits/grpc/server/ConcurrencyLimitServerInterceptor.java
Patch:
@@ -73,7 +73,7 @@ public static Builder newBuilder(Limiter<GrpcServerRequestContext> grpcLimiter)
     }
     
     /**
-     * @deprecated Use {@link ConcurrencyLimitServerInterceptor#newBuidler(Limiter)}
+     * @deprecated Use {@link ConcurrencyLimitServerInterceptor#newBuilder(Limiter)}
      * @param grpcLimiter
      */
     @Deprecated

File: concurrency-limits-grpc/src/main/java/com/netflix/concurrency/limits/grpc/server/ConcurrencyLimitServerInterceptor.java
Patch:
@@ -73,7 +73,7 @@ public static Builder newBuilder(Limiter<GrpcServerRequestContext> grpcLimiter)
     }
     
     /**
-     * @deprecated Use {@link ConcurrencyLimitServerInterceptor#newBuidler(Limiter)}
+     * @deprecated Use {@link ConcurrencyLimitServerInterceptor#newBuilder(Limiter)}
      * @param grpcLimiter
      */
     @Deprecated

File: concurrency-limits-grpc/src/main/java/com/netflix/concurrency/limits/grpc/server/ConcurrencyLimitServerInterceptor.java
Patch:
@@ -68,7 +68,7 @@ public ConcurrencyLimitServerInterceptor build() {
         }
     }
     
-    public static Builder newBuidler(Limiter<GrpcServerRequestContext> grpcLimiter) {
+    public static Builder newBuilder(Limiter<GrpcServerRequestContext> grpcLimiter) {
         return new Builder(grpcLimiter);
     }
     

File: concurrency-limits-grpc/src/main/java/com/netflix/concurrency/limits/grpc/server/ConcurrencyLimitServerInterceptor.java
Patch:
@@ -68,7 +68,7 @@ public ConcurrencyLimitServerInterceptor build() {
         }
     }
     
-    public static Builder newBuidler(Limiter<GrpcServerRequestContext> grpcLimiter) {
+    public static Builder newBuilder(Limiter<GrpcServerRequestContext> grpcLimiter) {
         return new Builder(grpcLimiter);
     }
     

File: concurrency-limits-grpc/src/test/java/com/netflix/concurrency/limits/grpc/server/example/Example.java
Patch:
@@ -76,7 +76,7 @@ public void invoke(String req, StreamObserver<String> observer) {
     }
     
     public static void main(String[] args) throws IOException {
-        Limit limit = VegasLimit.newBuilder()
+        Limit limit = GradientLimit.newBuilder()
                 .build();
         
         // Create a server

File: concurrency-limits-grpc/src/test/java/com/netflix/concurrency/limits/grpc/server/example/Example.java
Patch:
@@ -76,7 +76,7 @@ public void invoke(String req, StreamObserver<String> observer) {
     }
     
     public static void main(String[] args) throws IOException {
-        Limit limit = VegasLimit.newBuilder()
+        Limit limit = GradientLimit.newBuilder()
                 .build();
         
         // Create a server

File: concurrency-limits-core/src/test/java/com/netflix/concurrency/limits/limit/functions/SquareRootFunctionTest.java
Patch:
@@ -9,7 +9,7 @@ public class SquareRootFunctionTest {
     @Test
     public void confirm0Index() {
         Function<Integer, Integer> func = SquareRootFunction.create(4);
-        Assert.assertEquals(4, func.apply(0).intValue());
+        Assert.assertEquals(5, func.apply(0).intValue());
     }
     
     @Test

File: concurrency-limits-core/src/test/java/com/netflix/concurrency/limits/limit/AIMDLimitTest.java
Patch:
@@ -4,7 +4,7 @@
 
 import org.junit.Test;
 
-import com.netflix.concurrency.limits.limiter.ImmutableSample;
+import com.netflix.concurrency.limits.limiter.ImmutableSampleWindow;
 
 import junit.framework.Assert;
 
@@ -18,14 +18,14 @@ public void testDefault() {
     @Test
     public void increaseOnSuccess() {
         AIMDLimit limiter = AIMDLimit.newBuilder().initialLimit(10).build();
-        limiter.update(new ImmutableSample().addSample(TimeUnit.MILLISECONDS.toNanos(1), 10));
+        limiter.update(new ImmutableSampleWindow().addSample(TimeUnit.MILLISECONDS.toNanos(1), 10));
         Assert.assertEquals(11, limiter.getLimit());
     }
 
     @Test
     public void decreaseOnDrops() {
         AIMDLimit limiter = AIMDLimit.newBuilder().initialLimit(10).build();
-        limiter.update(new ImmutableSample().addDroppedSample(1));
+        limiter.update(new ImmutableSampleWindow().addDroppedSample(1));
         Assert.assertEquals(9, limiter.getLimit());
     }
 }

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/DefaultLimiter.java
Patch:
@@ -79,7 +79,7 @@ public Builder limit(Limit limit) {
          * Minimum window duration for sampling a new minRtt
          */
         public Builder minWindowTime(long minWindowTime, TimeUnit units) {
-            Preconditions.checkArgument(minWindowTime >= units.toMillis(100), "minWindowTime must be >= 100 ms");
+            Preconditions.checkArgument(units.toMillis(minWindowTime) >= 100, "minWindowTime must be >= 100 ms");
             this.minWindowTime = units.toNanos(minWindowTime);
             return this;
         }
@@ -143,14 +143,13 @@ private DefaultLimiter(Builder builder, Strategy<ContextT> strategy) {
 
     @Override
     public Optional<Listener> acquire(final ContextT context) {
-        final long startTime = nanoClock.get();
-        
         // Did we exceed the limit
         final Token token = strategy.tryAcquire(context);
         if (!token.isAcquired()) {
             return Optional.empty();
         }
         
+        final long startTime = nanoClock.get();
         int currentMaxInFlight = inFlight.incrementAndGet();
 
         return Optional.of(new Listener() {

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/DefaultLimiter.java
Patch:
@@ -83,7 +83,7 @@ public Builder limit(Limit limit) {
         }
         
         public Builder minWindowTime(long minWindowTime, TimeUnit units) {
-            Preconditions.checkArgument(minWindowTime >= units.toMillis(100), "minWindowTime must be >= 100 ms");
+            Preconditions.checkArgument(units.toMillis(minWindowTime) >= 100, "minWindowTime must be >= 100 ms");
             this.minWindowTime = units.toNanos(minWindowTime);
             return this;
         }
@@ -130,14 +130,13 @@ private DefaultLimiter(Builder builder, Strategy<ContextT> strategy) {
 
     @Override
     public Optional<Listener> acquire(final ContextT context) {
-        final long startTime = nanoClock.get();
-        
         // Did we exceed the limit
         final Token token = strategy.tryAcquire(context);
         if (!token.isAcquired()) {
             return Optional.empty();
         }
         
+        final long startTime = nanoClock.get();
         int currentMaxInFlight = inFlight.incrementAndGet();
 
         return Optional.of(new Listener() {

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/DefaultLimiter.java
Patch:
@@ -83,7 +83,7 @@ public Builder limit(Limit limit) {
         }
         
         public Builder minWindowTime(long minWindowTime, TimeUnit units) {
-            Preconditions.checkArgument(minWindowTime >= units.toMillis(100), "minWindowTime must be >= 100 ms");
+            Preconditions.checkArgument(units.toMillis(minWindowTime) >= 100, "minWindowTime must be >= 100 ms");
             this.minWindowTime = units.toNanos(minWindowTime);
             return this;
         }
@@ -130,14 +130,13 @@ private DefaultLimiter(Builder builder, Strategy<ContextT> strategy) {
 
     @Override
     public Optional<Listener> acquire(final ContextT context) {
-        final long startTime = nanoClock.get();
-        
         // Did we exceed the limit
         final Token token = strategy.tryAcquire(context);
         if (!token.isAcquired()) {
             return Optional.empty();
         }
         
+        final long startTime = nanoClock.get();
         int currentMaxInFlight = inFlight.incrementAndGet();
 
         return Optional.of(new Listener() {

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/Limit.java
Patch:
@@ -38,8 +38,7 @@ interface SampleWindow {
     /**
      * Update the concurrency limit using a new rtt sample
      * 
-     * @param rtt Minimum RTT sample for the last window
-     * @param maxInFlight Maximum number of inflight requests observed in the sampling window
+     * @param sample Data from the last sampling window such as RTT
      */
     void update(SampleWindow sample);
 }

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/Limit.java
Patch:
@@ -38,8 +38,7 @@ interface SampleWindow {
     /**
      * Update the concurrency limit using a new rtt sample
      * 
-     * @param rtt Minimum RTT sample for the last window
-     * @param maxInFlight Maximum number of inflight requests observed in the sampling window
+     * @param sample Data from the last sampling window such as RTT
      */
     void update(SampleWindow sample);
 }

File: concurrency-limits-servlet/src/main/java/com/netflix/concurrency/limits/servlet/ServletLimiterBuilder.java
Patch:
@@ -39,7 +39,7 @@ public ServletLimiterBuilder partitionByHeader(String name, Consumer<LookupParti
      */
     public ServletLimiterBuilder partitionByUserPrincipal(Function<Principal, String> principalToGroup, Consumer<LookupPartitionStrategy.Builder<HttpServletRequest>> configurer) {
         return partitionByLookup(
-                request -> Optional.ofNullable(request.getUserPrincipal()).map(principalToGroup) .orElse(null),
+                request -> Optional.ofNullable(request.getUserPrincipal()).map(principalToGroup).orElse(null),
                 configurer);
     }
     
@@ -77,7 +77,7 @@ public ServletLimiterBuilder partitionByParameter(String name, Consumer<LookupPa
      */
     public ServletLimiterBuilder partitionByPathInfo(Function<String, String> pathToGroup, Consumer<LookupPartitionStrategy.Builder<HttpServletRequest>> configurer) {
         return partitionByLookup(
-                request -> Optional.ofNullable(request.getPathInfo()).orElse(null),
+                request -> Optional.ofNullable(request.getPathInfo()).map(pathToGroup).orElse(null),
                 configurer);
     }
     

File: concurrency-limits-core/src/test/java/com/netflix/concurrency/limits/limit/VegasLimitTest.java
Patch:
@@ -38,7 +38,7 @@ public void decreaseLimit() {
         limit.update(TimeUnit.MILLISECONDS.toNanos(10));
         Assert.assertEquals(11, limit.getLimit());
         limit.update(TimeUnit.MILLISECONDS.toNanos(50));
-        Assert.assertEquals(5, limit.getLimit());
+        Assert.assertEquals(10, limit.getLimit());
     }
     
     @Test

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limiter/DefaultLimiter.java
Patch:
@@ -21,7 +21,6 @@ public final class DefaultLimiter<ContextT> implements Limiter<ContextT> {
     private final Supplier<Long> nanoClock = System::nanoTime;
     
     private final static long DEFAULT_MIN_WINDOW_TIME = TimeUnit.MILLISECONDS.toNanos(200);
-    private final static int DEFAULT_WINDOW_SIZE = 100;
     private final static int DEFAULT_WINDOW_SIZE = 10;
     
     /**

File: concurrency-limits-grpc/src/main/java/com/netflix/concurrency/limits/grpc/client/GrpcClientLimiterBuilder.java
Patch:
@@ -3,7 +3,6 @@
 import com.netflix.concurrency.limits.Limiter;
 import com.netflix.concurrency.limits.limiter.AbstractLimiterBuilder;
 import com.netflix.concurrency.limits.limiter.BlockingLimiter;
-import com.netflix.concurrency.limits.limiter.DefaultLimiter;
 import com.netflix.concurrency.limits.strategy.LookupPartitionStrategy;
 
 import io.grpc.CallOptions;
@@ -41,7 +40,7 @@ protected GrpcClientLimiterBuilder self() {
     }
     
     public Limiter<GrpcClientRequestContext> build() {
-        Limiter<GrpcClientRequestContext> limiter = DefaultLimiter.newBuilder().limit(limit).build(getFinalStrategy());
+        Limiter<GrpcClientRequestContext> limiter = buildLimiter();
         if (blockOnLimit) {
             limiter = BlockingLimiter.wrap(limiter);
         }

File: concurrency-limits-grpc/src/main/java/com/netflix/concurrency/limits/grpc/server/GrpcServerLimiterBuilder.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.netflix.concurrency.limits.Limiter;
 import com.netflix.concurrency.limits.limiter.AbstractLimiterBuilder;
-import com.netflix.concurrency.limits.limiter.DefaultLimiter;
 import com.netflix.concurrency.limits.strategy.LookupPartitionStrategy;
 
 import io.grpc.Attributes;
@@ -52,6 +51,6 @@ protected GrpcServerLimiterBuilder self() {
     }
     
     public Limiter<GrpcServerRequestContext> build() {
-        return DefaultLimiter.newBuilder().limit(limit).build(getFinalStrategy());
+        return buildLimiter();
     }
 }

File: concurrency-limits-servlet/src/main/java/com/netflix/concurrency/limits/servlet/ServletLimiterBuilder.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.netflix.concurrency.limits.Limiter;
 import com.netflix.concurrency.limits.limiter.AbstractLimiterBuilder;
-import com.netflix.concurrency.limits.limiter.DefaultLimiter;
 import com.netflix.concurrency.limits.strategy.LookupPartitionStrategy;
 
 import java.security.Principal;
@@ -88,6 +87,6 @@ protected ServletLimiterBuilder self() {
     }
     
     public Limiter<HttpServletRequest> build() {
-        return DefaultLimiter.newBuilder().limit(limit).build(getFinalStrategy());
+        return buildLimiter();
     }
 }

File: concurrency-limits-grpc/src/main/java/com/netflix/concurrency/limits/grpc/client/GrpcClientLimiterBuilder.java
Patch:
@@ -3,7 +3,6 @@
 import com.netflix.concurrency.limits.Limiter;
 import com.netflix.concurrency.limits.limiter.AbstractLimiterBuilder;
 import com.netflix.concurrency.limits.limiter.BlockingLimiter;
-import com.netflix.concurrency.limits.limiter.DefaultLimiter;
 import com.netflix.concurrency.limits.strategy.LookupPartitionStrategy;
 
 import io.grpc.CallOptions;
@@ -41,7 +40,7 @@ protected GrpcClientLimiterBuilder self() {
     }
     
     public Limiter<GrpcClientRequestContext> build() {
-        Limiter<GrpcClientRequestContext> limiter = DefaultLimiter.newBuilder().limit(limit).build(getFinalStrategy());
+        Limiter<GrpcClientRequestContext> limiter = buildLimiter();
         if (blockOnLimit) {
             limiter = BlockingLimiter.wrap(limiter);
         }

File: concurrency-limits-grpc/src/main/java/com/netflix/concurrency/limits/grpc/server/GrpcServerLimiterBuilder.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.netflix.concurrency.limits.Limiter;
 import com.netflix.concurrency.limits.limiter.AbstractLimiterBuilder;
-import com.netflix.concurrency.limits.limiter.DefaultLimiter;
 import com.netflix.concurrency.limits.strategy.LookupPartitionStrategy;
 
 import io.grpc.Attributes;
@@ -52,6 +51,6 @@ protected GrpcServerLimiterBuilder self() {
     }
     
     public Limiter<GrpcServerRequestContext> build() {
-        return DefaultLimiter.newBuilder().limit(limit).build(getFinalStrategy());
+        return buildLimiter();
     }
 }

File: concurrency-limits-servlet/src/main/java/com/netflix/concurrency/limits/servlet/ServletLimiterBuilder.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.netflix.concurrency.limits.Limiter;
 import com.netflix.concurrency.limits.limiter.AbstractLimiterBuilder;
-import com.netflix.concurrency.limits.limiter.DefaultLimiter;
 import com.netflix.concurrency.limits.strategy.LookupPartitionStrategy;
 
 import java.security.Principal;
@@ -88,6 +87,6 @@ protected ServletLimiterBuilder self() {
     }
     
     public Limiter<HttpServletRequest> build() {
-        return DefaultLimiter.newBuilder().limit(limit).build(getFinalStrategy());
+        return buildLimiter();
     }
 }

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/internal/EmptyMetricRegistry.java
Patch:
@@ -15,6 +15,6 @@ public SampleListener registerDistribution(String id, String... tagNameValuePair
     }
 
     @Override
-    public void registerGuage(String id, Supplier<Number> supplier, String... tagNameValuePairs) {
+    public void registerGauge(String id, Supplier<Number> supplier, String... tagNameValuePairs) {
     }
 }

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/VegasLimit.java
Patch:
@@ -74,7 +74,7 @@ public static VegasLimit newDefault() {
      */
     private volatile int estimatedLimit;
     
-    private long rtt_noload;
+    private volatile long rtt_noload;
     
     private boolean didDrop = false;
     

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/strategy/LookupPartitionStrategy.java
Patch:
@@ -72,7 +72,7 @@ private LookupPartitionStrategy(Builder<T> builder) {
         
         this.lookup = builder.lookup;
         
-        builder.registry.registerGuage(MetricIds.LIMIT_GUAGE_NAME, this::getLimit);
+        builder.registry.registerGauge(MetricIds.LIMIT_GUAGE_NAME, this::getLimit);
     }
     
     @Override
@@ -118,7 +118,7 @@ public Partition(String name, double pct) {
         
         public void createMetrics(MetricRegistry registry) {
             this.busyDistribution = registry.registerDistribution(MetricIds.INFLIGHT_GUAGE_NAME, PARTITION_TAG_NAME, name);
-            registry.registerGuage(MetricIds.PARTITION_LIMIT_GUAGE_NAME, this::getLimit, PARTITION_TAG_NAME, name);
+            registry.registerGauge(MetricIds.PARTITION_LIMIT_GUAGE_NAME, this::getLimit, PARTITION_TAG_NAME, name);
         }
         
         public void updateLimit(int totalLimit) {

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/strategy/PredicatePartitionStrategy.java
Patch:
@@ -65,7 +65,7 @@ private PredicatePartitionStrategy(Builder<T> builder) {
         this.partitions = new ArrayList<>(builder.partitions);
         this.partitions.forEach(partition -> partition.createMetrics(builder.registry));
         
-        builder.registry.registerGuage(MetricIds.LIMIT_GUAGE_NAME, this::getLimit);
+        builder.registry.registerGauge(MetricIds.LIMIT_GUAGE_NAME, this::getLimit);
     }
     
     @Override
@@ -116,7 +116,7 @@ public Partition(String name, double pct, Predicate<T> predicate) {
         
         public void createMetrics(MetricRegistry registry) {
             this.inflightDistribution = registry.registerDistribution(MetricIds.INFLIGHT_GUAGE_NAME, PARTITION_TAG_NAME, name);
-            registry.registerGuage(MetricIds.PARTITION_LIMIT_GUAGE_NAME, this::getLimit, PARTITION_TAG_NAME, name);
+            registry.registerGauge(MetricIds.PARTITION_LIMIT_GUAGE_NAME, this::getLimit, PARTITION_TAG_NAME, name);
         }
         
         public void updateLimit(int totalLimit) {

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/strategy/SimpleStrategy.java
Patch:
@@ -25,7 +25,7 @@ public SimpleStrategy() {
     
     public SimpleStrategy(MetricRegistry registry) {
         this.inflightMetric = registry.registerDistribution(MetricIds.INFLIGHT_GUAGE_NAME);
-        registry.registerGuage(MetricIds.LIMIT_GUAGE_NAME, this::getLimit);
+        registry.registerGauge(MetricIds.LIMIT_GUAGE_NAME, this::getLimit);
     }
     
     @Override

File: concurrency-limits-spectator/src/test/java/com/netflix/concurrency/limits/spectator/SpectatorMetricRegistryTest.java
Patch:
@@ -12,7 +12,7 @@ public void testGuage() {
         DefaultRegistry registry = new DefaultRegistry();
         SpectatorMetricRegistry metricRegistry = new SpectatorMetricRegistry(registry, registry.createId("foo"));
         
-        metricRegistry.registerGuage("bar", () -> 10);
+        metricRegistry.registerGauge("bar", () -> 10);
         
         PolledMeter.update(registry);
         

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/internal/EmptyMetricRegistry.java
Patch:
@@ -15,6 +15,6 @@ public SampleListener registerDistribution(String id, String... tagNameValuePair
     }
 
     @Override
-    public void registerGuage(String id, Supplier<Number> supplier, String... tagNameValuePairs) {
+    public void registerGauge(String id, Supplier<Number> supplier, String... tagNameValuePairs) {
     }
 }

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/VegasLimit.java
Patch:
@@ -74,7 +74,7 @@ public static VegasLimit newDefault() {
      */
     private volatile int estimatedLimit;
     
-    private long rtt_noload;
+    private volatile long rtt_noload;
     
     private boolean didDrop = false;
     

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/strategy/LookupPartitionStrategy.java
Patch:
@@ -72,7 +72,7 @@ private LookupPartitionStrategy(Builder<T> builder) {
         
         this.lookup = builder.lookup;
         
-        builder.registry.registerGuage(MetricIds.LIMIT_GUAGE_NAME, this::getLimit);
+        builder.registry.registerGauge(MetricIds.LIMIT_GUAGE_NAME, this::getLimit);
     }
     
     @Override
@@ -118,7 +118,7 @@ public Partition(String name, double pct) {
         
         public void createMetrics(MetricRegistry registry) {
             this.busyDistribution = registry.registerDistribution(MetricIds.INFLIGHT_GUAGE_NAME, PARTITION_TAG_NAME, name);
-            registry.registerGuage(MetricIds.PARTITION_LIMIT_GUAGE_NAME, this::getLimit, PARTITION_TAG_NAME, name);
+            registry.registerGauge(MetricIds.PARTITION_LIMIT_GUAGE_NAME, this::getLimit, PARTITION_TAG_NAME, name);
         }
         
         public void updateLimit(int totalLimit) {

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/strategy/PredicatePartitionStrategy.java
Patch:
@@ -65,7 +65,7 @@ private PredicatePartitionStrategy(Builder<T> builder) {
         this.partitions = new ArrayList<>(builder.partitions);
         this.partitions.forEach(partition -> partition.createMetrics(builder.registry));
         
-        builder.registry.registerGuage(MetricIds.LIMIT_GUAGE_NAME, this::getLimit);
+        builder.registry.registerGauge(MetricIds.LIMIT_GUAGE_NAME, this::getLimit);
     }
     
     @Override
@@ -116,7 +116,7 @@ public Partition(String name, double pct, Predicate<T> predicate) {
         
         public void createMetrics(MetricRegistry registry) {
             this.inflightDistribution = registry.registerDistribution(MetricIds.INFLIGHT_GUAGE_NAME, PARTITION_TAG_NAME, name);
-            registry.registerGuage(MetricIds.PARTITION_LIMIT_GUAGE_NAME, this::getLimit, PARTITION_TAG_NAME, name);
+            registry.registerGauge(MetricIds.PARTITION_LIMIT_GUAGE_NAME, this::getLimit, PARTITION_TAG_NAME, name);
         }
         
         public void updateLimit(int totalLimit) {

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/strategy/SimpleStrategy.java
Patch:
@@ -25,7 +25,7 @@ public SimpleStrategy() {
     
     public SimpleStrategy(MetricRegistry registry) {
         this.inflightMetric = registry.registerDistribution(MetricIds.INFLIGHT_GUAGE_NAME);
-        registry.registerGuage(MetricIds.LIMIT_GUAGE_NAME, this::getLimit);
+        registry.registerGauge(MetricIds.LIMIT_GUAGE_NAME, this::getLimit);
     }
     
     @Override

File: concurrency-limits-spectator/src/test/java/com/netflix/concurrency/limits/spectator/SpectatorMetricRegistryTest.java
Patch:
@@ -12,7 +12,7 @@ public void testGuage() {
         DefaultRegistry registry = new DefaultRegistry();
         SpectatorMetricRegistry metricRegistry = new SpectatorMetricRegistry(registry, registry.createId("foo"));
         
-        metricRegistry.registerGuage("bar", () -> 10);
+        metricRegistry.registerGauge("bar", () -> 10);
         
         PolledMeter.update(registry);
         

File: concurrency-limits-grpc/src/main/java/com/netflix/concurrency/limits/grpc/client/GrpcClientLimiterBuilder.java
Patch:
@@ -55,8 +55,8 @@ public <T> GrpcClientLimiterBuilder blockOnLimit(boolean blockOnLimit) {
     
     /**
      * Guarantee a percentage of the limit to the specific method
-     * @param percent Percent of the limit to guarantee 
-     * @param method The method
+     * @param d Percent of the limit to guarantee 
+     * @param m The method
      * @return Chainable builder
      */
     public <T> GrpcClientLimiterBuilder methodEquals(double d, MethodDescriptor<?, ?> m) {

File: concurrency-limits-grpc/src/main/java/com/netflix/concurrency/limits/grpc/server/GrpcServerLimiter.java
Patch:
@@ -16,8 +16,8 @@ public interface GrpcServerLimiter {
     /**
      * Acquire a limit given a request context.
      * 
-     * @param method
-     * @param callOptions
+     * @param call
+     * @param headers
      * @return Valid Listener if acquired or Optional.empty() if limit reached
      */
     Optional<Limiter.Listener> acquire(ServerCall<?, ?> call, Metadata headers);

File: concurrency-limits-servlet/src/main/java/com/netflix/concurrency/limits/servlet/GroupServletLimiter.java
Patch:
@@ -23,7 +23,7 @@
  * where each group is allocated a certain percentage of the limit.
  * 
  * For example, the following setup guarantees 10% of the limit to batch and 90% to live based on the user
- * principal.  The user principal is mapped here to a group using a simple Map<String, String> which
+ * principal.  The user principal is mapped here to a group using a simple {@literal Map<String, String>} which
  * could have been loaded from a configuration file or database.
  * 
  * {@code

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/VegasLimit.java
Patch:
@@ -6,8 +6,8 @@
 import java.util.concurrent.TimeUnit;
 
 /**
- * Limiter based on TCP Vegas where the limit increases by 1 if the queue_use is small (< alpha)
- * and decreases by 1 if the queue_use is large (> beta).
+ * Limiter based on TCP Vegas where the limit increases by 1 if the queue_use is small ({@literal <} alpha)
+ * and decreases by 1 if the queue_use is large ({@literal >} beta).
  * 
  * Queue size is calculated using the formula, 
  *  queue_use = limit − BWE×RTTnoLoad = limit × (1 − RTTnoLoad/RTTactual)

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/VegasLimit.java
Patch:
@@ -95,7 +95,7 @@ private VegasLimit(Builder builder) {
         this.alpha = builder.alpha;
         this.beta = builder.beta;
         this.backoffRatio = builder.backoffRatio;
-        builder.registry.guage(MIN_RTT_GUAGE_NAME, () -> rtt_noload);
+        builder.registry.registerGuage(MIN_RTT_GUAGE_NAME, () -> rtt_noload);
     }
 
     @Override

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/VegasLimit.java
Patch:
@@ -97,12 +97,12 @@ public synchronized void update(long rtt) {
         if (didDrop) {
             didDrop = false;
         } else {
-            int newLimit = 1;
+            int newLimit = estimatedLimit;
             int queueSize = (int) Math.ceil(estimatedLimit * (1 - (double)rtt_noload / rtt));
             if (queueSize <= alpha) {
-                newLimit = estimatedLimit + 1;
+                newLimit ++;
             } else if (queueSize >= beta) {
-                newLimit = estimatedLimit - 1;
+                newLimit --;
             }
             
             estimatedLimit = Math.max(1, Math.min(maxLimit, newLimit));

File: concurrency-limits-core/src/test/java/com/netflix/concurrency/limits/limit/AIMDLimitTest.java
Patch:
@@ -25,6 +25,6 @@ public void decreaseOnDrops() {
         AIMDLimit limiter = new AIMDLimit(10);
         limiter.drop();
         limiter.update(TimeUnit.MILLISECONDS.toNanos(1));
-        Assert.assertEquals(7, limiter.getLimit());
+        Assert.assertEquals(9, limiter.getLimit());
     }
 }

File: concurrency-limits-core/src/main/java/com/netflix/concurrency/limits/limit/VegasLimit.java
Patch:
@@ -97,12 +97,12 @@ public synchronized void update(long rtt) {
         if (didDrop) {
             didDrop = false;
         } else {
-            int newLimit = 1;
+            int newLimit = estimatedLimit;
             int queueSize = (int) Math.ceil(estimatedLimit * (1 - (double)rtt_noload / rtt));
             if (queueSize <= alpha) {
-                newLimit = estimatedLimit + 1;
+                newLimit ++;
             } else if (queueSize >= beta) {
-                newLimit = estimatedLimit - 1;
+                newLimit --;
             }
             
             estimatedLimit = Math.max(1, Math.min(maxLimit, newLimit));

File: concurrency-limits-core/src/test/java/com/netflix/concurrency/limits/limit/AIMDLimitTest.java
Patch:
@@ -25,6 +25,6 @@ public void decreaseOnDrops() {
         AIMDLimit limiter = new AIMDLimit(10);
         limiter.drop();
         limiter.update(TimeUnit.MILLISECONDS.toNanos(1));
-        Assert.assertEquals(7, limiter.getLimit());
+        Assert.assertEquals(9, limiter.getLimit());
     }
 }

