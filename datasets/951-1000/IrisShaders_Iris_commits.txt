File: common/src/main/java/net/irisshaders/batchedentityrendering/impl/SegmentedBufferBuilder.java
Patch:
@@ -33,7 +33,7 @@ private static boolean shouldSortOnUpload(RenderType type) {
 
 	public VertexConsumer getBuffer(RenderType renderType) {
 		try {
-			ByteBufferBuilderHolder buffer = buffers.computeIfAbsent(renderType, (r) -> new ByteBufferBuilderHolder(new ByteBufferBuilder(512 * 2024)));
+			ByteBufferBuilderHolder buffer = buffers.computeIfAbsent(renderType, (r) -> new ByteBufferBuilderHolder(new ByteBufferBuilder(renderType.bufferSize())));
 
 			buffer.wasUsed();
 			BufferBuilder builder = builders.computeIfAbsent(renderType, (t) -> new BufferBuilder(buffer.getBuffer(), renderType.mode(), renderType.format()));

File: common/src/main/java/net/irisshaders/batchedentityrendering/mixin/CompositeStateAccessor.java
Patch:
@@ -9,4 +9,7 @@
 public interface CompositeStateAccessor {
 	@Accessor("transparencyState")
 	RenderStateShard.TransparencyStateShard getTransparency();
+
+	@Accessor("depthTestState")
+    RenderStateShard.DepthTestStateShard getDepth();
 }

File: common/src/main/java/net/irisshaders/batchedentityrendering/mixin/MixinCompositeRenderType.java
Patch:
@@ -27,8 +27,9 @@ private MixinCompositeRenderType(String name, VertexFormat vertexFormat, VertexF
 	@Inject(method = INIT, at = @At("RETURN"))
 	private void batchedentityrendering$onCompositeInit(String string, VertexFormat vertexFormat, VertexFormat.Mode mode, int i, boolean bl, boolean bl2, CompositeState compositeState, CallbackInfo ci) {
 		RenderStateShard.TransparencyStateShard transparency = ((CompositeStateAccessor) (Object) compositeState).getTransparency();
+		RenderStateShard.DepthTestStateShard depth = ((CompositeStateAccessor) (Object) compositeState).getDepth();
 
-		if ("water_mask".equals(name)) {
+		if ("water_mask".equals(name) || depth == RenderStateShard.NO_DEPTH_TEST) {
 			transparencyType = TransparencyType.WATER_MASK;
 		} else if ("lines".equals(name)) {
 			transparencyType = TransparencyType.LINES;

File: common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderKey.java
Patch:
@@ -21,7 +21,7 @@ public enum ShaderKey {
 	TEXTURED(ProgramId.Textured, AlphaTests.NON_ZERO_ALPHA, DefaultVertexFormat.POSITION_TEX, FogMode.OFF, LightingModel.LIGHTMAP),
 	TEXTURED_COLOR(ProgramId.Textured, AlphaTests.ONE_TENTH_ALPHA, DefaultVertexFormat.POSITION_TEX_COLOR, FogMode.OFF, LightingModel.LIGHTMAP),
 	SPS(ProgramId.SpiderEyes, AlphaTests.OFF, DefaultVertexFormat.POSITION_TEX_COLOR, FogMode.PER_FRAGMENT, LightingModel.FULLBRIGHT),
-	SKY_BASIC(ProgramId.SkyBasic, AlphaTests.OFF, DefaultVertexFormat.POSITION, FogMode.PER_VERTEX, LightingModel.LIGHTMAP),
+	SKY_BASIC(ProgramId.SkyBasic, AlphaTests.OFF, DefaultVertexFormat.POSITION, FogMode.OFF, LightingModel.FULLBRIGHT),
 	SKY_BASIC_COLOR(ProgramId.SkyBasic, AlphaTests.NON_ZERO_ALPHA, DefaultVertexFormat.POSITION_COLOR, FogMode.OFF, LightingModel.LIGHTMAP),
 	SKY_TEXTURED(ProgramId.SkyTextured, AlphaTests.OFF, DefaultVertexFormat.POSITION_TEX, FogMode.OFF, LightingModel.LIGHTMAP),
 	SKY_TEXTURED_COLOR(ProgramId.SkyTextured, AlphaTests.OFF, DefaultVertexFormat.POSITION_TEX_COLOR, FogMode.OFF, LightingModel.LIGHTMAP),

File: common/src/main/java/net/irisshaders/iris/vertices/sodium/terrain/XHFPTerrainVertex.java
Patch:
@@ -1,6 +1,7 @@
 package net.irisshaders.iris.vertices.sodium.terrain;
 
 import net.caffeinemc.mods.sodium.api.util.ColorABGR;
+import net.caffeinemc.mods.sodium.api.util.ColorARGB;
 import net.caffeinemc.mods.sodium.client.render.chunk.vertex.format.ChunkVertexEncoder;
 import net.caffeinemc.mods.sodium.client.render.frapi.helper.ColorHelper;
 import net.irisshaders.iris.shaderpack.materialmap.WorldRenderingSettings;
@@ -150,7 +151,7 @@ public long write(long ptr,
 
 			MemoryUtil.memPutInt(ptr, packPositionHi(x, y, z));
 			MemoryUtil.memPutInt(ptr + 4L, packPositionLo(x, y, z));
-			MemoryUtil.memPutInt(ptr + 8L, WorldRenderingSettings.INSTANCE.shouldUseSeparateAo() ? ColorABGR.withAlpha(vertex.color, vertex.ao) : ColorHelper.multiplyRGB(vertex.color, vertex.ao));
+			MemoryUtil.memPutInt(ptr + 8L, WorldRenderingSettings.INSTANCE.shouldUseSeparateAo() ? ColorABGR.withAlpha(vertex.color, vertex.ao) : ColorARGB.mulRGB(vertex.color, vertex.ao));
 			MemoryUtil.memPutInt(ptr + 12L, packTexture(u, v));
 			MemoryUtil.memPutInt(ptr + 16L, packLightAndData(light, material, section));
 

File: common/src/main/java/net/irisshaders/iris/shadows/ShadowMatrices.java
Patch:
@@ -10,7 +10,7 @@ public class ShadowMatrices {
 
 	public static Matrix4f createOrthoMatrix(float halfPlaneLength, float nearPlane, float farPlane) {
 		//System.out.println("making a matrix with " + nearPlane + " / " + farPlane + " * " + halfPlaneLength);
-		return new Matrix4f().setOrthoSymmetric(halfPlaneLength, halfPlaneLength, nearPlane, farPlane);
+		return new Matrix4f().setOrthoSymmetric(halfPlaneLength * 2, halfPlaneLength * 2, nearPlane, farPlane);
 	}
 
 	public static Matrix4f createPerspectiveMatrix(float fov) {

File: common/src/main/java/net/irisshaders/iris/compat/dh/DHCompatInternal.java
Patch:
@@ -99,9 +99,9 @@ public DHCompatInternal(IrisRenderingPipeline pipeline, boolean dhShadowEnabled)
 	}
 
 	public static int getDhBlockRenderDistance() {
-		if (DhApi.Delayed.configs == null) {
+		if (DhApi.Delayed.configs == null || !dhEnabled) {
 			// Called before DH has finished setup
-			return 0;
+			return Minecraft.getInstance().options.getEffectiveRenderDistance();
 		}
 
 		return DhApi.Delayed.configs.graphics().chunkRenderDistance().getValue() * 16;

File: common/src/main/java/net/irisshaders/iris/shadows/ShadowRenderer.java
Patch:
@@ -41,6 +41,7 @@
 import net.minecraft.client.renderer.culling.Frustum;
 import net.minecraft.client.renderer.entity.EntityRenderDispatcher;
 import net.minecraft.core.BlockPos;
+import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import org.joml.Matrix4f;
@@ -393,7 +394,7 @@ public void renderShadows(LevelRendererAccessor levelRenderer, Camera playerCame
 			// If FOV is not null, the pack wants a perspective based projection matrix. (This is to support legacy packs)
 			shadowProjection = ShadowMatrices.createPerspectiveMatrix(this.fov);
 		} else {
-			shadowProjection = ShadowMatrices.createOrthoMatrix(halfPlaneLength, nearPlane < 0 ? -DHCompat.getRenderDistance() * 16 : nearPlane, farPlane < 0 ? DHCompat.getRenderDistance() * 16 : farPlane);
+			shadowProjection = ShadowMatrices.createOrthoMatrix(halfPlaneLength, Mth.equal(nearPlane, -1.0f) ? -DHCompat.getRenderDistance() * 16 : nearPlane, Mth.equal(farPlane, -1.0f) ? DHCompat.getRenderDistance() * 16 : farPlane);
 		}
 
 		IrisRenderSystem.setShadowProjection(shadowProjection);

File: common/src/main/java/net/irisshaders/iris/pipeline/CompositeRenderer.java
Patch:
@@ -113,7 +113,7 @@ public CompositeRenderer(WorldRenderingPipeline pipeline, CompositePass composit
 			if (source == null || !source.isValid()) {
 				if (computes.length != 0 && computes[i] != null && computes[i].length > 0) {
 					ComputeOnlyPass pass = new ComputeOnlyPass();
-					pass.name = computes[i].length > 0 ? computes[i][0].getName() : "unknown";
+					pass.name = computes[i].length > 0 ? Arrays.stream(computes[i]).filter(Objects::nonNull).findFirst().map(ComputeSource::getName).orElse("unknown") : "unknown";
 					pass.computes = createComputes(computes[i], flipped, flippedAtLeastOnceSnapshot, shadowTargetsSupplier, holder);
 					passes.add(pass);
 				}

File: common/src/main/java/net/irisshaders/iris/gl/texture/InternalTextureFormat.java
Patch:
@@ -83,7 +83,7 @@ public enum InternalTextureFormat {
 	RGB5_A1(GL11C.GL_RGB5_A1, GlVersion.GL_11, PixelFormat.RGBA),
 	RGB565(GL41C.GL_RGB565, GlVersion.GL_41, PixelFormat.RGB),
 	RGB10_A2(GL11C.GL_RGB10_A2, GlVersion.GL_11, PixelFormat.RGBA),
-	RGB10_A2UI(GL33C.GL_RGB10_A2UI, GlVersion.GL_33, PixelFormat.RGBA),
+	RGB10_A2UI(GL33C.GL_RGB10_A2UI, GlVersion.GL_33, PixelFormat.RGBA_INTEGER),
 	R11F_G11F_B10F(GL30C.GL_R11F_G11F_B10F, GlVersion.GL_30, PixelFormat.RGB),
 	RGB9_E5(GL30C.GL_RGB9_E5, GlVersion.GL_30, PixelFormat.RGB);
 

File: common/src/main/java/net/irisshaders/iris/pipeline/FinalPassRenderer.java
Patch:
@@ -7,6 +7,7 @@
 import it.unimi.dsi.fastutil.ints.IntList;
 import it.unimi.dsi.fastutil.objects.Object2ObjectMap;
 import net.irisshaders.iris.features.FeatureFlags;
+import net.irisshaders.iris.gl.GLDebug;
 import net.irisshaders.iris.gl.IrisRenderSystem;
 import net.irisshaders.iris.gl.buffer.ShaderStorageBufferHolder;
 import net.irisshaders.iris.gl.framebuffer.GlFramebuffer;
@@ -218,6 +219,7 @@ public void renderFinalPass() {
 		}
 
 		if (this.finalPass != null) {
+			GLDebug.pushGroup(990, "final");
 			// If there is a final pass, we use the shader-based full screen quad rendering pathway instead
 			// of just copying the color buffer.
 
@@ -251,6 +253,7 @@ public void renderFinalPass() {
 			FullScreenQuadRenderer.INSTANCE.renderQuad();
 
 			FullScreenQuadRenderer.INSTANCE.end();
+			GLDebug.popGroup();
 		} else {
 			// If there are no passes, we somehow need to transfer the content of the Iris color render targets into
 			// the main Minecraft framebuffer.

File: common/src/main/java/net/irisshaders/iris/vertices/sodium/terrain/FormatAnalyzer.java
Patch:
@@ -89,9 +89,6 @@ public static ChunkVertexType createFormat(boolean blockId, boolean normal, bool
 			VERTEX_FORMAT.addElement(IrisChunkMeshAttributes.MID_BLOCK, 14, midBlockOffset);
 		}
 
-		System.out.println("Created a new format with " + offset + " stride: " + Integer.toBinaryString(key));
-
-
 		return classMap.computeIfAbsent(key, k -> new XHFPModelVertexType(VERTEX_FORMAT.build(), blockIdOffset, normalOffset, midUvOffset, midBlockOffset));
 	}
 }

File: common/src/main/java/net/irisshaders/iris/shaderpack/properties/PackShadowDirectives.java
Patch:
@@ -171,7 +171,7 @@ private static void acceptColorMipmapSettings(DirectiveHolder directives, Int2Ob
 		directives.acceptConstBooleanDirective("generateShadowColorMipmap", mipmap -> samplers.forEach((i, sampler) -> sampler.setMipmap(mipmap)));
 
 		// Find any per-sampler overrides for the shadow depth mipmap setting
-		for (int i = 0; i < samplers.size(); i++) {
+		for (int i = 0; i < PackShadowDirectives.MAX_SHADOW_COLOR_BUFFERS_IRIS; i++) {
 			String name = "shadowcolor" + i + "Mipmap";
 			directives.acceptConstBooleanDirective(name, samplers.computeIfAbsent(i, sa -> new SamplingSettings())::setMipmap);
 
@@ -197,7 +197,7 @@ private static void acceptDepthFilteringSettings(DirectiveHolder directives, Imm
 	}
 
 	private static void acceptColorFilteringSettings(DirectiveHolder directives, Int2ObjectMap<SamplingSettings> samplers) {
-		for (int i = 0; i < samplers.size(); i++) {
+		for (int i = 0; i < PackShadowDirectives.MAX_SHADOW_COLOR_BUFFERS_IRIS; i++) {
 			String name = "shadowcolor" + i + "Nearest";
 
 			directives.acceptConstBooleanDirective(name, samplers.computeIfAbsent(i, sa -> new SamplingSettings())::setNearest);

File: common/src/main/java/net/irisshaders/iris/shadows/ShadowCompositeRenderer.java
Patch:
@@ -233,12 +233,15 @@ public void renderAll() {
 		ProgramUniforms.clearActiveUniforms();
 		GlStateManager._glUseProgram(0);
 
+		// TODO IMS: Apparantly we are not supposed to do this for shadowcomp...
+		/*
 		for (int i = 0; i < renderTargets.getRenderTargetCount(); i++) {
 			// Reset mipmapping states at the end of the frame.
 			if (renderTargets.get(i) != null) {
 				resetRenderTarget(renderTargets.get(i));
 			}
 		}
+		 */
 
 		RenderSystem.activeTexture(GL15C.GL_TEXTURE0);
 	}

File: common/src/main/java/net/irisshaders/iris/gl/GlVersion.java
Patch:
@@ -4,5 +4,7 @@ public enum GlVersion {
 	GL_11,
 	GL_12,
 	GL_30,
-	GL_31
+	GL_31,
+	GL_33,
+	GL_41
 }

File: common/src/main/java/net/irisshaders/iris/gl/texture/PixelType.java
Patch:
@@ -29,7 +29,9 @@ public enum PixelType {
 	UNSIGNED_INT_8_8_8_8(4, GL12C.GL_UNSIGNED_INT_8_8_8_8, GlVersion.GL_12),
 	UNSIGNED_INT_8_8_8_8_REV(4, GL12C.GL_UNSIGNED_INT_8_8_8_8_REV, GlVersion.GL_12),
 	UNSIGNED_INT_10_10_10_2(4, GL12C.GL_UNSIGNED_INT_10_10_10_2, GlVersion.GL_12),
-	UNSIGNED_INT_2_10_10_10_REV(4, GL12C.GL_UNSIGNED_INT_2_10_10_10_REV, GlVersion.GL_12);
+	UNSIGNED_INT_2_10_10_10_REV(4, GL12C.GL_UNSIGNED_INT_2_10_10_10_REV, GlVersion.GL_12),
+	UNSIGNED_INT_10F_11F_11F_REV(4, GL30C.GL_UNSIGNED_INT_10F_11F_11F_REV, GlVersion.GL_30),
+	UNSIGNED_INT_5_9_9_9_REV(4, GL30C.GL_UNSIGNED_INT_5_9_9_9_REV, GlVersion.GL_30);
 
 	private final int byteSize;
 	private final int glFormat;

File: common/src/main/java/net/irisshaders/iris/compat/sodium/mixin/MixinSodiumGameOptionPages.java
Patch:
@@ -149,7 +149,7 @@ private static OptionImpl<Options, SupportedGraphicsMode> createLimitedVideoSett
 				new Component[]{Component.translatable("options.graphics.fast"), Component.translatable("options.graphics.fancy")}))
 			.setBinding(
 				(opts, value) -> opts.graphicsMode().set(value.toVanilla()),
-				opts -> SupportedGraphicsMode.fromVanilla(opts.graphicsMode().get()))
+				opts -> SupportedGraphicsMode.fromVanilla(opts.graphicsMode()))
 			.setImpact(OptionImpact.HIGH)
 			.setFlags(OptionFlag.REQUIRES_RENDERER_RELOAD)
 			.build();

File: common/src/main/java/net/irisshaders/iris/mixin/MixinLevelRenderer.java
Patch:
@@ -103,7 +103,7 @@ public class MixinLevelRenderer {
 			this.overrideFrustum = null;
 		}
 
-		Minecraft.getInstance().smartCull = !pipeline.shouldDisableOcclusionCulling();
+		IrisRenderSystem.backupAndDisableCullingState(pipeline.shouldDisableOcclusionCulling());
 
 		if (Iris.shouldActivateWireframe() && this.minecraft.isLocalServer()) {
 			IrisRenderSystem.setPolygonMode(GL43C.GL_LINE);
@@ -141,6 +141,8 @@ private Frustum changeFrustum(Frustum frustum) {
 				Minecraft.getInstance().gui.getChat().addMessage(Component.literal("A new beta is out for Iris " + info.betaTag + ". Please redownload it.").withStyle(ChatFormatting.BOLD, ChatFormatting.RED)));
 		}
 
+		IrisRenderSystem.restoreCullingState();
+
 		if (Iris.shouldActivateWireframe() && this.minecraft.isLocalServer()) {
 			IrisRenderSystem.setPolygonMode(GL43C.GL_FILL);
 		}

File: common/src/main/java/net/irisshaders/iris/compat/dh/DHMixinConfigPlugin.java
Patch:
@@ -16,7 +16,7 @@ public void onLoad(String mixinPackage) {
 
 	@Override
 	public String getRefMapperConfig() {
-		return "";
+		return null;
 	}
 
 	@Override

File: common/src/main/java/net/irisshaders/iris/vertices/BlockSensitiveBufferBuilder.java
Patch:
@@ -4,4 +4,6 @@ public interface BlockSensitiveBufferBuilder {
 	void beginBlock(int block, byte renderType, byte blockEmission, int localPosX, int localPosY, int localPosZ);
 
 	void endBlock();
+
+    void ignoreMidBlock(boolean b);
 }

File: common/src/main/java/net/irisshaders/iris/vertices/sodium/terrain/FormatAnalyzer.java
Patch:
@@ -28,7 +28,7 @@ public static ChunkVertexType createFormat(boolean blockId, boolean normal, bool
 		}
 
 		if (midBlock) {
-			key |= 16;
+			key |= 8;
 		}
 
 		if (classMap.containsKey(key)) {
@@ -89,7 +89,7 @@ public static ChunkVertexType createFormat(boolean blockId, boolean normal, bool
 			VERTEX_FORMAT.addElement(IrisChunkMeshAttributes.MID_BLOCK, 14, midBlockOffset);
 		}
 
-		//System.out.println("Created a new format with " + offset + " stride: " + Integer.toBinaryString(key));
+		System.out.println("Created a new format with " + offset + " stride: " + Integer.toBinaryString(key));
 
 
 		return classMap.computeIfAbsent(key, k -> new XHFPModelVertexType(VERTEX_FORMAT.build(), blockIdOffset, normalOffset, midUvOffset, midBlockOffset));

File: common/src/main/java/net/irisshaders/iris/compat/sodium/mixin/MixinChunkBuildBuffers.java
Patch:
@@ -27,12 +27,12 @@ private void setupContextHolder(ChunkVertexType vertexType, CallbackInfo ci, @Lo
 	}
 
 	@Override
-	public void beginBlock(short block, short renderType, byte blockEmission, int localPosX, int localPosY, int localPosZ) {
+	public void beginBlock(int block, byte renderType, byte blockEmission, int localPosX, int localPosY, int localPosZ) {
 		contextHolder.setBlockData(block, renderType, blockEmission, localPosX, localPosY, localPosZ);
 	}
 
 	@Override
 	public void endBlock() {
-		contextHolder.setBlockData((short) 0, (short) 0, (byte) 0, 0, 0, 0);
+		contextHolder.setBlockData(0, (byte) 0, (byte) 0, 0, 0, 0);
 	}
 }

File: common/src/main/java/net/irisshaders/iris/compat/sodium/mixin/MixinChunkMeshBuildTask.java
Patch:
@@ -22,14 +22,14 @@ public class MixinChunkMeshBuildTask {
 	private void iris$onRenderModel(ChunkBuildContext buildContext, CancellationToken cancellationToken, CallbackInfoReturnable<ChunkBuildOutput> cir, @Local ChunkBuildBuffers buffers, @Local BlockState blockState, @Local(ordinal = 0) BlockPos.MutableBlockPos blockPos) {
 		if (WorldRenderingSettings.INSTANCE.getBlockStateIds() == null) return;
 
-		((BlockSensitiveBufferBuilder) buffers).beginBlock((short) WorldRenderingSettings.INSTANCE.getBlockStateIds().getInt(blockState), (short) 0, (byte) blockState.getLightEmission(), blockPos.getX(), blockPos.getY(), blockPos.getZ());
+		((BlockSensitiveBufferBuilder) buffers).beginBlock(WorldRenderingSettings.INSTANCE.getBlockStateIds().getInt(blockState), (byte) 0, (byte) blockState.getLightEmission(), blockPos.getX(), blockPos.getY(), blockPos.getZ());
 	}
 
 	@Inject(method = "execute(Lnet/caffeinemc/mods/sodium/client/render/chunk/compile/ChunkBuildContext;Lnet/caffeinemc/mods/sodium/client/util/task/CancellationToken;)Lnet/caffeinemc/mods/sodium/client/render/chunk/compile/ChunkBuildOutput;", at = @At(value = "INVOKE", target = "Lnet/caffeinemc/mods/sodium/client/render/chunk/compile/pipeline/FluidRenderer;render(Lnet/caffeinemc/mods/sodium/client/world/LevelSlice;Lnet/minecraft/world/level/block/state/BlockState;Lnet/minecraft/world/level/material/FluidState;Lnet/minecraft/core/BlockPos;Lnet/minecraft/core/BlockPos;Lnet/caffeinemc/mods/sodium/client/render/chunk/translucent_sorting/TranslucentGeometryCollector;Lnet/caffeinemc/mods/sodium/client/render/chunk/compile/ChunkBuildBuffers;)V"))
 	private void iris$onRenderLiquid(ChunkBuildContext buildContext, CancellationToken cancellationToken, CallbackInfoReturnable<ChunkBuildOutput> cir, @Local ChunkBuildBuffers buffers, @Local BlockState blockState, @Local FluidState fluidState, @Local(ordinal = 0) BlockPos.MutableBlockPos blockPos) {
 		if (WorldRenderingSettings.INSTANCE.getBlockStateIds() == null) return;
 
-		((BlockSensitiveBufferBuilder) buffers).beginBlock((short) WorldRenderingSettings.INSTANCE.getBlockStateIds().getInt(fluidState.createLegacyBlock()), (short) 1, (byte) blockState.getLightEmission(), blockPos.getX(), blockPos.getY(), blockPos.getZ());
+		((BlockSensitiveBufferBuilder) buffers).beginBlock(WorldRenderingSettings.INSTANCE.getBlockStateIds().getInt(fluidState.createLegacyBlock()), (byte) 1, (byte) blockState.getLightEmission(), blockPos.getX(), blockPos.getY(), blockPos.getZ());
 	}
 
 	@Inject(method = "execute(Lnet/caffeinemc/mods/sodium/client/render/chunk/compile/ChunkBuildContext;Lnet/caffeinemc/mods/sodium/client/util/task/CancellationToken;)Lnet/caffeinemc/mods/sodium/client/render/chunk/compile/ChunkBuildOutput;", at = @At(value = "INVOKE", target = "Lnet/minecraft/world/level/block/state/BlockState;isSolidRender(Lnet/minecraft/world/level/BlockGetter;Lnet/minecraft/core/BlockPos;)Z"))

File: common/src/main/java/net/irisshaders/iris/pipeline/transform/transformer/CommonTransformer.java
Patch:
@@ -289,6 +289,8 @@ public static void transform(
 		renameFunctionCall(root, "texture3D", "texture");
 		renameFunctionCall(root, "texture2DLod", "textureLod");
 		renameFunctionCall(root, "texture3DLod", "textureLod");
+		renameFunctionCall(root, "texture2DProj", "textureProj");
+		renameFunctionCall(root, "texture3DProj", "textureProj");
 		renameFunctionCall(root, "texture2DGrad", "textureGrad");
 		renameFunctionCall(root, "texture2DGradARB", "textureGrad");
 		renameFunctionCall(root, "texture3DGrad", "textureGrad");

File: common/src/main/java/net/irisshaders/iris/pipeline/transform/transformer/SodiumCoreTransformer.java
Patch:
@@ -31,6 +31,7 @@ public static void transform(
 
 			root.replaceReferenceExpressions(t, "textureMatrix", "mat4(1.0)");
 			SodiumTransformer.replaceMidTexCoord(t, tree, root, 1.0f / 32768.0f);
+			SodiumTransformer.replaceMCEntity(t, tree, root);
 
 			SodiumTransformer.injectVertInit(t, tree, root, parameters);
 		}

File: common/src/main/java/net/irisshaders/iris/vertices/BlockSensitiveBufferBuilder.java
Patch:
@@ -1,7 +1,7 @@
 package net.irisshaders.iris.vertices;
 
 public interface BlockSensitiveBufferBuilder {
-	void beginBlock(short block, short renderType, byte blockEmission, int localPosX, int localPosY, int localPosZ);
+	void beginBlock(int block, byte renderType, byte blockEmission, int localPosX, int localPosY, int localPosZ);
 
 	void endBlock();
 }

File: common/src/main/java/net/irisshaders/iris/vertices/sodium/terrain/IrisChunkMeshAttributes.java
Patch:
@@ -7,6 +7,6 @@ public class IrisChunkMeshAttributes {
 	public static final VertexFormatAttribute MID_TEX_COORD = new VertexFormatAttribute("midTexCoord", GlVertexAttributeFormat.UNSIGNED_SHORT, 2, false, false);
 	public static final VertexFormatAttribute TANGENT = new VertexFormatAttribute("TANGENT", GlVertexAttributeFormat.BYTE, 4, true, false);
 	public static final VertexFormatAttribute NORMAL = new VertexFormatAttribute("NORMAL", GlVertexAttributeFormat.BYTE, 3, true, false);
-	public static final VertexFormatAttribute BLOCK_ID = new VertexFormatAttribute("BLOCK_ID", GlVertexAttributeFormat.SHORT, 2, false, false);
+	public static final VertexFormatAttribute BLOCK_ID = new VertexFormatAttribute("BLOCK_ID", GlVertexAttributeFormat.UNSIGNED_INT, 1, false, true);
 	public static final VertexFormatAttribute MID_BLOCK = new VertexFormatAttribute("MID_BLOCK", GlVertexAttributeFormat.BYTE, 4, false, false);
 }

File: common/src/main/java/net/irisshaders/iris/Iris.java
Patch:
@@ -254,6 +254,7 @@ private static boolean loadExternalShaderpack(String name) {
 		}
 
 		Path shaderPackPath;
+		boolean isZip = false;
 
 		if (!Files.isDirectory(shaderPackRoot) && shaderPackRoot.toString().endsWith(".zip")) {
 			Optional<Path> optionalPath;
@@ -281,6 +282,7 @@ private static boolean loadExternalShaderpack(String name) {
 				logger.error("Could not load the shaderpack \"{}\" because it appears to lack a \"shaders\" directory", name);
 				return false;
 			}
+			isZip = true;
 		} else {
 			if (!Files.exists(shaderPackRoot)) {
 				logger.error("Failed to load the shaderpack \"{}\" because it does not exist!", name);
@@ -309,7 +311,7 @@ private static boolean loadExternalShaderpack(String name) {
 		resetShaderPackOptions = false;
 
 		try {
-			currentPack = new ShaderPack(shaderPackPath, changedConfigs, StandardMacros.createStandardEnvironmentDefines());
+			currentPack = new ShaderPack(shaderPackPath, changedConfigs, StandardMacros.createStandardEnvironmentDefines(), isZip);
 
 			MutableOptionValues changedConfigsValues = currentPack.getShaderPackOptions().getOptionValues().mutableCopy();
 

File: common/src/main/java/net/irisshaders/iris/Iris.java
Patch:
@@ -254,6 +254,7 @@ private static boolean loadExternalShaderpack(String name) {
 		}
 
 		Path shaderPackPath;
+		boolean isZip = false;
 
 		if (!Files.isDirectory(shaderPackRoot) && shaderPackRoot.toString().endsWith(".zip")) {
 			Optional<Path> optionalPath;
@@ -281,6 +282,7 @@ private static boolean loadExternalShaderpack(String name) {
 				logger.error("Could not load the shaderpack \"{}\" because it appears to lack a \"shaders\" directory", name);
 				return false;
 			}
+			isZip = true;
 		} else {
 			if (!Files.exists(shaderPackRoot)) {
 				logger.error("Failed to load the shaderpack \"{}\" because it does not exist!", name);
@@ -309,7 +311,7 @@ private static boolean loadExternalShaderpack(String name) {
 		resetShaderPackOptions = false;
 
 		try {
-			currentPack = new ShaderPack(shaderPackPath, changedConfigs, StandardMacros.createStandardEnvironmentDefines());
+			currentPack = new ShaderPack(shaderPackPath, changedConfigs, StandardMacros.createStandardEnvironmentDefines(), isZip);
 
 			MutableOptionValues changedConfigsValues = currentPack.getShaderPackOptions().getOptionValues().mutableCopy();
 

File: common/src/main/java/net/irisshaders/iris/shaderpack/materialmap/BlockMaterialMapping.java
Patch:
@@ -23,7 +23,7 @@
 public class BlockMaterialMapping {
 	public static Object2IntMap<BlockState> createBlockStateIdMap(Int2ObjectLinkedOpenHashMap<List<BlockEntry>> blockPropertiesMap, Int2ObjectLinkedOpenHashMap<List<TagEntry>> tagPropertiesMap) {
 		Object2IntMap<BlockState> blockStateIds = new Object2IntLinkedOpenHashMap<>();
-
+		blockStateIds.defaultReturnValue(-1);
 		blockPropertiesMap.forEach((intId, entries) -> {
 			for (BlockEntry entry : entries) {
 				addBlockStates(entry, blockStateIds, intId);

File: common/src/main/java/net/irisshaders/iris/pipeline/VanillaRenderingPipeline.java
Patch:
@@ -28,7 +28,7 @@ public VanillaRenderingPipeline() {
 		WorldRenderingSettings.INSTANCE.setAmbientOcclusionLevel(1.0f);
 		WorldRenderingSettings.INSTANCE.setUseExtendedVertexFormat(false);
 		WorldRenderingSettings.INSTANCE.setVoxelizeLightBlocks(false);
-		WorldRenderingSettings.INSTANCE.setBlockTypeIds(null);
+		WorldRenderingSettings.INSTANCE.setBlockTypeIds(Object2ObjectMaps.emptyMap());
 	}
 
 	@Override

File: common/src/main/java/net/irisshaders/iris/shaderpack/materialmap/BlockMaterialMapping.java
Patch:
@@ -3,6 +3,7 @@
 import it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.objects.Object2IntLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2ObjectMaps;
 import it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap;
 import net.irisshaders.iris.Iris;
 import net.minecraft.client.renderer.RenderType;
@@ -97,6 +98,8 @@ private static void addTag(TagEntry tagEntry, Object2IntMap<BlockState> idMap, i
 	}
 
 	public static Map<Block, BlockRenderType> createBlockTypeMap(Map<NamespacedId, BlockRenderType> blockPropertiesMap) {
+		if (blockPropertiesMap.isEmpty()) return Object2ObjectMaps.emptyMap();
+
 		Map<Block, BlockRenderType> blockTypeIds = new Reference2ReferenceOpenHashMap<>();
 
 		blockPropertiesMap.forEach((id, blockType) -> {

File: common/src/main/java/net/irisshaders/iris/shaderpack/materialmap/WorldRenderingSettings.java
Patch:
@@ -59,7 +59,6 @@ public void setBlockStateIds(Object2IntMap<BlockState> blockStateIds) {
 		this.blockStateIds = blockStateIds;
 	}
 
-	@Nullable
 	public Map<Block, BlockRenderType> getBlockTypeIds() {
 		return blockTypeIds;
 	}

File: common/src/main/java/net/irisshaders/iris/vertices/sodium/terrain/XHFPTerrainVertex.java
Patch:
@@ -80,7 +80,7 @@ private static int floorInt(float x) {
 
 	@Override
 	public long write(long ptr,
-					  Material material, Vertex[] vertices, int section) {
+					  int material, Vertex[] vertices, int section) {
 		// Calculate the center point of the texture region which is mapped to the quad
 		float texCentroidU = 0.0f;
 		float texCentroidV = 0.0f;
@@ -127,7 +127,7 @@ public long write(long ptr,
 			MemoryUtil.memPutInt(ptr + 4L, packPositionLo(x, y, z));
 			MemoryUtil.memPutInt(ptr + 8L, WorldRenderingSettings.INSTANCE.shouldUseSeparateAo() ? ColorABGR.withAlpha(vertex.color, vertex.ao) : ColorHelper.multiplyRGB(vertex.color, vertex.ao));
 			MemoryUtil.memPutInt(ptr + 12L, packTexture(u, v));
-			MemoryUtil.memPutInt(ptr + 16L, packLightAndData(light, material.bits(), section));
+			MemoryUtil.memPutInt(ptr + 16L, packLightAndData(light, material, section));
 
 			MemoryUtil.memPutShort(ptr + 32, contextHolder.getBlockId());
 			MemoryUtil.memPutShort(ptr + 34, contextHolder.getRenderType());

File: common/src/main/java/net/irisshaders/iris/api/v0/IrisApi.java
Patch:
@@ -49,7 +49,7 @@ static IrisApi getInstance() {
 	 * <p>Generally, mods won't need to call this function for much.
 	 * Mods should be fine with things being rendered multiple times
 	 * each frame from different camera perspectives. Often, there's
-	 * a better approach to fixing bugs than calling this function.
+	 * a	 better approach to fixing bugs than calling this function.
 	 *
 	 * <p>Pretty much the main legitimate use for this function that
 	 * I've seen is in a mod like Immersive Portals, where it has

File: neoforge/src/main/java/net/irisshaders/iris/mixin/forge/MixinRenderFlame.java
Patch:
@@ -4,7 +4,6 @@
 import net.irisshaders.iris.api.v0.IrisApi;
 import net.irisshaders.iris.pathways.LightningHandler;
 import net.minecraft.client.renderer.RenderType;
-import net.minecraft.client.renderer.texture.TextureAtlas;
 import net.minecraft.resources.ResourceLocation;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Pseudo;

File: neoforge/src/main/java/net/irisshaders/iris/mixin/forge/MixinRenderMekasuit.java
Patch:
@@ -5,14 +5,11 @@
 import net.irisshaders.iris.pathways.LightningHandler;
 import net.irisshaders.iris.vertices.ImmediateState;
 import net.minecraft.client.renderer.RenderType;
-import net.minecraft.resources.ResourceLocation;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Pseudo;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Redirect;
 
-import java.util.function.Function;
-
 @Pseudo
 @Mixin(targets = "mekanism/client/render/armor/MekaSuitArmor", remap = false)
 public class MixinRenderMekasuit {

File: common/src/main/java/net/irisshaders/iris/Iris.java
Patch:
@@ -29,7 +29,7 @@
 import net.irisshaders.iris.shaderpack.option.values.MutableOptionValues;
 import net.irisshaders.iris.shaderpack.option.values.OptionValues;
 import net.irisshaders.iris.shaderpack.programs.ProgramSet;
-import net.irisshaders.iris.pbr.pbr.PBRTextureManager;
+import net.irisshaders.iris.pbr.texture.PBRTextureManager;
 import net.irisshaders.iris.vertices.IrisVertexFormats;
 import net.irisshaders.iris.vertices.sodium.EntityToTerrainVertexSerializer;
 import net.irisshaders.iris.vertices.sodium.GlyphExtVertexSerializer;

File: common/src/main/java/net/irisshaders/iris/mixin/texture/MixinGlStateManager.java
Patch:
@@ -3,7 +3,7 @@
 import com.mojang.blaze3d.platform.GlStateManager;
 import net.irisshaders.iris.pbr.TextureInfoCache;
 import net.irisshaders.iris.pbr.TextureTracker;
-import net.irisshaders.iris.pbr.pbr.PBRTextureManager;
+import net.irisshaders.iris.pbr.texture.PBRTextureManager;
 import org.jetbrains.annotations.Nullable;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Unique;

File: common/src/main/java/net/irisshaders/iris/mixin/texture/MixinTextureManager.java
Patch:
@@ -1,7 +1,7 @@
 package net.irisshaders.iris.mixin.texture;
 
 import net.irisshaders.iris.pbr.format.TextureFormatLoader;
-import net.irisshaders.iris.pbr.pbr.PBRTextureManager;
+import net.irisshaders.iris.pbr.texture.PBRTextureManager;
 import net.minecraft.client.renderer.texture.TextureManager;
 import net.minecraft.server.packs.resources.ResourceManager;
 import org.spongepowered.asm.mixin.Mixin;

File: common/src/main/java/net/irisshaders/iris/mixin/texture/pbr/MixinDirectoryLister.java
Patch:
@@ -1,6 +1,6 @@
 package net.irisshaders.iris.mixin.texture.pbr;
 
-import net.irisshaders.iris.pbr.pbr.PBRType;
+import net.irisshaders.iris.pbr.texture.PBRType;
 import net.minecraft.client.renderer.texture.atlas.SpriteSource;
 import net.minecraft.client.renderer.texture.atlas.sources.DirectoryLister;
 import net.minecraft.resources.ResourceLocation;

File: common/src/main/java/net/irisshaders/iris/mixin/texture/pbr/MixinSpriteContents.java
Patch:
@@ -1,8 +1,8 @@
 package net.irisshaders.iris.mixin.texture.pbr;
 
 import net.caffeinemc.mods.sodium.client.render.texture.SpriteUtil;
-import net.irisshaders.iris.pbr.pbr.PBRSpriteHolder;
-import net.irisshaders.iris.pbr.pbr.SpriteContentsExtension;
+import net.irisshaders.iris.pbr.texture.PBRSpriteHolder;
+import net.irisshaders.iris.pbr.texture.SpriteContentsExtension;
 import net.minecraft.client.renderer.texture.SpriteContents;
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 import org.spongepowered.asm.mixin.Dynamic;

File: common/src/main/java/net/irisshaders/iris/mixin/texture/pbr/MixinTextureAtlas.java
Patch:
@@ -1,7 +1,7 @@
 package net.irisshaders.iris.mixin.texture.pbr;
 
-import net.irisshaders.iris.pbr.pbr.PBRAtlasHolder;
-import net.irisshaders.iris.pbr.pbr.TextureAtlasExtension;
+import net.irisshaders.iris.pbr.texture.PBRAtlasHolder;
+import net.irisshaders.iris.pbr.texture.TextureAtlasExtension;
 import net.minecraft.client.renderer.texture.AbstractTexture;
 import net.minecraft.client.renderer.texture.TextureAtlas;
 import net.minecraft.resources.ResourceLocation;

File: common/src/main/java/net/irisshaders/iris/pbr/format/LabPBRTextureFormat.java
Patch:
@@ -4,7 +4,7 @@
 import net.irisshaders.iris.pbr.mipmap.CustomMipmapGenerator;
 import net.irisshaders.iris.pbr.mipmap.DiscreteBlendFunction;
 import net.irisshaders.iris.pbr.mipmap.LinearBlendFunction;
-import net.irisshaders.iris.pbr.pbr.PBRType;
+import net.irisshaders.iris.pbr.texture.PBRType;
 import org.jetbrains.annotations.Nullable;
 
 import java.util.Objects;

File: common/src/main/java/net/irisshaders/iris/pbr/format/TextureFormat.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.irisshaders.iris.gl.IrisRenderSystem;
 import net.irisshaders.iris.pbr.mipmap.CustomMipmapGenerator;
-import net.irisshaders.iris.pbr.pbr.PBRType;
+import net.irisshaders.iris.pbr.texture.PBRType;
 import net.minecraft.client.renderer.texture.AbstractTexture;
 import org.jetbrains.annotations.Nullable;
 import org.lwjgl.opengl.GL11;

File: common/src/main/java/net/irisshaders/iris/pbr/loader/PBRTextureLoader.java
Patch:
@@ -1,4 +1,4 @@
-package net.irisshaders.iris.pbr.pbr.loader;
+package net.irisshaders.iris.pbr.loader;
 
 import net.minecraft.client.renderer.texture.AbstractTexture;
 import net.minecraft.server.packs.resources.ResourceManager;

File: common/src/main/java/net/irisshaders/iris/pbr/loader/PBRTextureLoaderRegistry.java
Patch:
@@ -1,4 +1,4 @@
-package net.irisshaders.iris.pbr.pbr.loader;
+package net.irisshaders.iris.pbr.loader;
 
 import net.minecraft.client.renderer.texture.AbstractTexture;
 import net.minecraft.client.renderer.texture.SimpleTexture;

File: common/src/main/java/net/irisshaders/iris/pbr/loader/SimplePBRLoader.java
Patch:
@@ -1,7 +1,7 @@
-package net.irisshaders.iris.pbr.pbr.loader;
+package net.irisshaders.iris.pbr.loader;
 
 import net.irisshaders.iris.mixin.texture.SimpleTextureAccessor;
-import net.irisshaders.iris.pbr.pbr.PBRType;
+import net.irisshaders.iris.pbr.texture.PBRType;
 import net.minecraft.client.renderer.texture.AbstractTexture;
 import net.minecraft.client.renderer.texture.SimpleTexture;
 import net.minecraft.resources.ResourceLocation;

File: common/src/main/java/net/irisshaders/iris/pbr/texture/PBRAtlasHolder.java
Patch:
@@ -1,4 +1,4 @@
-package net.irisshaders.iris.pbr.pbr;
+package net.irisshaders.iris.pbr.texture;
 
 import org.jetbrains.annotations.Nullable;
 

File: common/src/main/java/net/irisshaders/iris/pbr/texture/PBRAtlasTexture.java
Patch:
@@ -1,11 +1,11 @@
-package net.irisshaders.iris.pbr.pbr;
+package net.irisshaders.iris.pbr.texture;
 
 import com.mojang.blaze3d.platform.TextureUtil;
 import net.irisshaders.iris.Iris;
 import net.irisshaders.iris.mixin.texture.SpriteContentsAnimatedTextureAccessor;
 import net.irisshaders.iris.mixin.texture.SpriteContentsFrameInfoAccessor;
 import net.irisshaders.iris.mixin.texture.SpriteContentsTickerAccessor;
-import net.irisshaders.iris.pbr.pbr.loader.AtlasPBRLoader.PBRTextureAtlasSprite;
+import net.irisshaders.iris.pbr.loader.AtlasPBRLoader.PBRTextureAtlasSprite;
 import net.irisshaders.iris.pbr.util.TextureManipulationUtil;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;

File: common/src/main/java/net/irisshaders/iris/pbr/texture/PBRDumpable.java
Patch:
@@ -1,4 +1,4 @@
-package net.irisshaders.iris.pbr.pbr;
+package net.irisshaders.iris.pbr.texture;
 
 import net.minecraft.client.renderer.texture.Dumpable;
 import net.minecraft.resources.ResourceLocation;

File: common/src/main/java/net/irisshaders/iris/pbr/texture/PBRSpriteHolder.java
Patch:
@@ -1,4 +1,4 @@
-package net.irisshaders.iris.pbr.pbr;
+package net.irisshaders.iris.pbr.texture;
 
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 import org.jetbrains.annotations.Nullable;

File: common/src/main/java/net/irisshaders/iris/pbr/texture/PBRTextureHolder.java
Patch:
@@ -1,4 +1,4 @@
-package net.irisshaders.iris.pbr.pbr;
+package net.irisshaders.iris.pbr.texture;
 
 import net.minecraft.client.renderer.texture.AbstractTexture;
 import org.jetbrains.annotations.NotNull;

File: common/src/main/java/net/irisshaders/iris/pbr/texture/PBRType.java
Patch:
@@ -1,4 +1,4 @@
-package net.irisshaders.iris.pbr.pbr;
+package net.irisshaders.iris.pbr.texture;
 
 import org.apache.commons.io.FilenameUtils;
 import org.jetbrains.annotations.Nullable;

File: common/src/main/java/net/irisshaders/iris/pbr/texture/SpriteContentsExtension.java
Patch:
@@ -1,4 +1,4 @@
-package net.irisshaders.iris.pbr.pbr;
+package net.irisshaders.iris.pbr.texture;
 
 import org.jetbrains.annotations.Nullable;
 

File: common/src/main/java/net/irisshaders/iris/pbr/texture/TextureAtlasExtension.java
Patch:
@@ -1,4 +1,4 @@
-package net.irisshaders.iris.pbr.pbr;
+package net.irisshaders.iris.pbr.texture;
 
 import org.jetbrains.annotations.Nullable;
 

File: common/src/main/java/net/irisshaders/iris/pipeline/CustomTextureManager.java
Patch:
@@ -13,9 +13,9 @@
 import net.irisshaders.iris.mixin.LightTextureAccessor;
 import net.irisshaders.iris.pbr.format.TextureFormat;
 import net.irisshaders.iris.pbr.format.TextureFormatLoader;
-import net.irisshaders.iris.pbr.pbr.PBRTextureHolder;
-import net.irisshaders.iris.pbr.pbr.PBRTextureManager;
-import net.irisshaders.iris.pbr.pbr.PBRType;
+import net.irisshaders.iris.pbr.texture.PBRTextureHolder;
+import net.irisshaders.iris.pbr.texture.PBRTextureManager;
+import net.irisshaders.iris.pbr.texture.PBRType;
 import net.irisshaders.iris.shaderpack.properties.PackDirectives;
 import net.irisshaders.iris.shaderpack.texture.CustomTextureData;
 import net.irisshaders.iris.shaderpack.texture.TextureStage;

File: common/src/main/java/net/irisshaders/iris/pipeline/IrisRenderingPipeline.java
Patch:
@@ -43,9 +43,9 @@
 import net.irisshaders.iris.pbr.TextureInfoCache;
 import net.irisshaders.iris.pbr.format.TextureFormat;
 import net.irisshaders.iris.pbr.format.TextureFormatLoader;
-import net.irisshaders.iris.pbr.pbr.PBRTextureHolder;
-import net.irisshaders.iris.pbr.pbr.PBRTextureManager;
-import net.irisshaders.iris.pbr.pbr.PBRType;
+import net.irisshaders.iris.pbr.texture.PBRTextureHolder;
+import net.irisshaders.iris.pbr.texture.PBRTextureManager;
+import net.irisshaders.iris.pbr.texture.PBRType;
 import net.irisshaders.iris.pipeline.programs.ExtendedShader;
 import net.irisshaders.iris.pipeline.programs.FallbackShader;
 import net.irisshaders.iris.pipeline.programs.ShaderCreator;

File: common/src/main/java/net/irisshaders/iris/mixin/MixinLevelRenderer_Sky.java
Patch:
@@ -51,11 +51,11 @@ private void preRenderSky(Matrix4f matrix4f, Matrix4f matrix4f2, float f, Camera
 			Entity cameraEntity = camera.getEntity();
 
 			boolean isSubmersed = camera.getFluidInCamera() != FogType.NONE;
-			boolean hasBlindness = cameraEntity instanceof LivingEntity && ((LivingEntity) cameraEntity).hasEffect(MobEffects.BLINDNESS);
+			boolean blockSky = ((LevelRendererAccessor) Minecraft.getInstance().levelRenderer).invokeDoesMobEffectBlockSky(camera);
 			boolean useThickFog = this.minecraft.level.effects().isFoggyAt(Mth.floor(cameraPosition.x()),
 				Mth.floor(cameraPosition.y())) || this.minecraft.gui.getBossOverlay().shouldCreateWorldFog();
 
-			if (isSubmersed || hasBlindness || useThickFog) {
+			if (isSubmersed || blockSky || useThickFog) {
 				ci.cancel();
 			}
 		}

File: common/src/main/java/net/irisshaders/iris/mixin/sky/MixinDimensionSpecialEffects.java
Patch:
@@ -23,9 +23,9 @@
 public class MixinDimensionSpecialEffects {
 	@Inject(method = "getSunriseColor", at = @At("HEAD"), cancellable = true)
 	private void iris$getSunriseColor(float timeOfDay, float partialTicks, CallbackInfoReturnable<float[]> cir) {
-		boolean hasBlindness = ((LevelRendererAccessor) Minecraft.getInstance().levelRenderer).invokeDoesMobEffectBlockSky(Minecraft.getInstance().gameRenderer.getMainCamera());
+		boolean blockSky = ((LevelRendererAccessor) Minecraft.getInstance().levelRenderer).invokeDoesMobEffectBlockSky(Minecraft.getInstance().gameRenderer.getMainCamera());
 
-		if (hasBlindness) {
+		if (blockSky) {
 			cir.setReturnValue(null);
 		}
 

File: common/src/main/java/net/irisshaders/iris/shaderpack/IdMap.java
Patch:
@@ -318,7 +318,7 @@ private static Map<NamespacedId, String> parseDimensionMap(Properties properties
 	}
 
 	private static void warnMissingBackslashInPropertiesFile(String processedSource, String propertiesFileName) {
-		if (propertiesFileName.equals("shader.properties")) {
+		if (propertiesFileName.equals("shaders.properties")) {
 			return;
 		}
 		String[] fileNameSections = propertiesFileName.split("\\.");

File: common/src/main/java/net/irisshaders/iris/compat/dh/mixin/MixinAdvancedShadowCullingFrustum.java
Patch:
@@ -10,7 +10,7 @@
 
 @Mixin(AdvancedShadowCullingFrustum.class)
 public class MixinAdvancedShadowCullingFrustum extends Frustum implements IDhApiShadowCullingFrustum {
-	@Shadow
+	@Shadow(remap = false)
 	protected int isVisible(double minX, double minY, double minZ, double maxX, double maxY, double maxZ) {
 		throw new IllegalStateException();
 	}

File: common/src/main/java/net/irisshaders/iris/compat/dh/mixin/MixinBoxCullingFrustum.java
Patch:
@@ -13,7 +13,7 @@ public class MixinBoxCullingFrustum implements IDhApiShadowCullingFrustum {
 	private int worldMinYDH;
 	private int worldMaxYDH;
 
-	@Shadow
+	@Shadow(remap = false)
 	@Final
 	private BoxCuller boxCuller;
 

File: common/src/main/java/net/irisshaders/iris/compat/sodium/mixin/MixinChunkMeshBufferBuilder.java
Patch:
@@ -10,7 +10,7 @@
 
 @Mixin(ChunkMeshBufferBuilder.class)
 public class MixinChunkMeshBufferBuilder implements VertexEncoderInterface {
-	@Shadow
+	@Shadow(remap = false)
 	@Final
 	private ChunkVertexEncoder encoder;
 

File: common/src/main/java/net/irisshaders/iris/compat/sodium/mixin/entity/MixinCommonVertexAttribute.java
Patch:
@@ -12,7 +12,7 @@
 @Mixin(CommonVertexAttribute.class)
 public class MixinCommonVertexAttribute {
 	@Mutable
-	@Shadow
+	@Shadow(remap = false)
 	@Final
 	public static int COUNT;
 

File: common/src/main/java/net/irisshaders/iris/mixin/GlStateManagerAccessor.java
Patch:
@@ -4,7 +4,7 @@
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
 
-@Mixin(GlStateManager.class)
+@Mixin(value = GlStateManager.class, remap = false)
 public interface GlStateManagerAccessor {
 	@Accessor("BLEND")
 	static GlStateManager.BlendState getBLEND() {

File: common/src/main/java/net/irisshaders/iris/mixin/MixinGameRenderer.java
Patch:
@@ -74,7 +74,7 @@ public class MixinGameRenderer {
 		}
 	}
 
-	@Inject(method = {"getPositionTexColorShader", "getPositionColorTexShader"}, at = @At("HEAD"), cancellable = true)
+	@Inject(method = {"getPositionTexColorShader"}, at = @At("HEAD"), cancellable = true)
 	private static void iris$overridePositionTexColorShader(CallbackInfoReturnable<ShaderInstance> cir) {
 		if (isSky()) {
 			override(ShaderKey.SKY_TEXTURED_COLOR, cir);
@@ -475,7 +475,7 @@ private static void override(ShaderKey key, CallbackInfoReturnable<ShaderInstanc
 		Iris.getPipelineManager().getPipeline().ifPresent(WorldRenderingPipeline::finalizeGameRendering);
 	}
 
-	@Redirect(method = "reloadShaders", at = @At(value = "INVOKE", target = "Lcom/google/common/collect/Lists;newArrayList()Ljava/util/ArrayList;"))
+	@Redirect(method = "reloadShaders", at = @At(value = "INVOKE", target = "Lcom/google/common/collect/Lists;newArrayList()Ljava/util/ArrayList;", remap = false))
 	private ArrayList<Program> iris$reloadGeometryShaders() {
 		ArrayList<Program> programs = Lists.newArrayList();
 		programs.addAll(IrisProgramTypes.GEOMETRY.getPrograms().values());

File: common/src/main/java/net/irisshaders/iris/mixin/MixinModelViewBobbing.java
Patch:
@@ -94,7 +94,7 @@ public abstract class MixinModelViewBobbing {
 
 	@Redirect(method = "renderLevel",
 		at = @At(value = "INVOKE",
-			target = "Lorg/joml/Matrix4f;rotation(Lorg/joml/Quaternionfc;)Lorg/joml/Matrix4f;"))
+			target = "Lorg/joml/Matrix4f;rotation(Lorg/joml/Quaternionfc;)Lorg/joml/Matrix4f;", remap = false))
 	private Matrix4f iris$applyBobbingToModelView(Matrix4f instance, Quaternionfc quat, DeltaTracker deltaTracker) {
 		if (!areShadersOn) {
 			instance.rotation(quat);

File: common/src/main/java/net/irisshaders/iris/mixin/MixinProgramManager.java
Patch:
@@ -10,7 +10,7 @@
 
 @Mixin(ProgramManager.class)
 public class MixinProgramManager {
-	@Inject(method = "releaseProgram", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/systems/RenderSystem;assertOnRenderThread()V"))
+	@Inject(method = "releaseProgram", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/systems/RenderSystem;assertOnRenderThread()V", remap = false))
 	private static void iris$releaseGeometry(Shader shader, CallbackInfo ci) {
 		if (shader instanceof ExtendedShader && ((ExtendedShader) shader).getGeometry() != null) {
 			((ExtendedShader) shader).getGeometry().close();

File: common/src/main/java/net/irisshaders/iris/mixin/integrationtest/MixinRenderTarget_StencilBufferTest.java
Patch:
@@ -34,6 +34,7 @@ public class MixinRenderTarget_StencilBufferTest {
 	@ModifyArgs(method = "createBuffers",
 		at = @At(value = "INVOKE",
 			target = "Lcom/mojang/blaze3d/platform/GlStateManager;_texImage2D(IIIIIIIILjava/nio/IntBuffer;)V",
+			remap = false,
 			ordinal = 0))
 	public void init(Args args) {
 		if (STENCIL) {
@@ -50,7 +51,7 @@ public void init(Args args) {
 	}
 
 	@ModifyArgs(method = "createBuffers",
-		at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/platform/GlStateManager;_glFramebufferTexture2D(IIIII)V"),
+		at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/platform/GlStateManager;_glFramebufferTexture2D(IIIII)V", remap = false),
 		slice = @Slice(from = @At(value = "FIELD", target = "Lcom/mojang/blaze3d/pipeline/RenderTarget;useDepth:Z", ordinal = 1)))
 	public void init2(Args args) {
 		if (STENCIL) {

File: common/src/main/java/net/irisshaders/iris/mixin/texture/MixinAbstractTexture.java
Patch:
@@ -15,7 +15,7 @@ public class MixinAbstractTexture {
 	protected int id;
 
 	// Inject after the newly-generated texture ID has been stored into the id field
-	@Inject(method = "getId()I", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/platform/TextureUtil;generateTextureId()I", shift = Shift.BY, by = 2))
+	@Inject(method = "getId()I", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/platform/TextureUtil;generateTextureId()I", remap = false, shift = Shift.BY, by = 2))
 	private void iris$afterGenerateId(CallbackInfoReturnable<Integer> cir) {
 		TextureTracker.INSTANCE.trackTexture(id, (AbstractTexture) (Object) this);
 	}

File: common/src/main/java/net/irisshaders/iris/mixin/texture/MixinTextureManager.java
Patch:
@@ -15,6 +15,7 @@
 
 @Mixin(TextureManager.class)
 public class MixinTextureManager {
+	@SuppressWarnings("all")
 	@Inject(method = {
 		"method_18167",
 		"lambda$reload$5"

File: common/src/main/java/net/irisshaders/iris/mixin/texture/pbr/MixinSpriteContents.java
Patch:
@@ -5,6 +5,7 @@
 import net.irisshaders.iris.pbr.pbr.SpriteContentsExtension;
 import net.minecraft.client.renderer.texture.SpriteContents;
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
+import org.spongepowered.asm.mixin.Dynamic;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Unique;
 import org.spongepowered.asm.mixin.injection.At;
@@ -23,6 +24,8 @@ public class MixinSpriteContents implements SpriteContentsExtension {
 		}
 	}
 
+	@Dynamic("Added by Sodium")
+	@SuppressWarnings("target")
 	@Inject(method = "sodium$setActive(Z)V", at = @At("TAIL"), remap = false, require = 0)
 	private void iris$onTailMarkActive(CallbackInfo ci) {
 		PBRSpriteHolder pbrHolder = ((SpriteContentsExtension) this).getPBRHolder();

File: fabric/src/main/java/net/irisshaders/iris/mixin/fantastic/MixinParticleEngine.java
Patch:
@@ -68,7 +68,7 @@ public class MixinParticleEngine implements PhasedParticleEngine {
 	@Unique
 	private ParticleRenderingPhase phase = ParticleRenderingPhase.EVERYTHING;
 
-	@Redirect(method = "render", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/systems/RenderSystem;setShader(Ljava/util/function/Supplier;)V"))
+	@Redirect(method = "render", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/systems/RenderSystem;setShader(Ljava/util/function/Supplier;)V", remap = false))
 	private void iris$changeParticleShader(Supplier<ShaderInstance> pSupplier0) {
 		RenderSystem.setShader(phase == ParticleRenderingPhase.TRANSLUCENT ? ShaderAccess::getParticleTranslucentShader : pSupplier0);
 	}

File: common/src/main/java/net/irisshaders/iris/compat/dh/DHCompatInternal.java
Patch:
@@ -289,6 +289,6 @@ public IDhApiGenericObjectShaderProgram getGenericShader() {
 	}
 
 	public boolean avoidRenderingClouds() {
-		return pipeline.getDHCloudSetting() == CloudSetting.OFF || (pipeline.getDHCloudSetting() == CloudSetting.DEFAULT && pipeline.getCloudSetting() == CloudSetting.OFF);
+		return pipeline != null && (pipeline.getDHCloudSetting() == CloudSetting.OFF || (pipeline.getDHCloudSetting() == CloudSetting.DEFAULT && pipeline.getCloudSetting() == CloudSetting.OFF));
 	}
 }

File: neoforge/src/main/java/net/irisshaders/iris/mixin/forge/MixinInstancedIcosphere.java
Patch:
@@ -11,7 +11,7 @@
 @Pseudo
 @Mixin(targets = "tv.soaryn.xycraft.machines.client.render.instanced.InstancedIcosphere")
 public class MixinInstancedIcosphere {
-	@Inject(method = "draw", at = @At("RETURN"))
+	@Inject(method = "draw", at = @At("RETURN"), require = 0)
 	private static void onDraw(CallbackInfo ci, @Local ShaderInstance shader) {
 		shader.clear();
 	}

File: src/main/java/net/irisshaders/iris/shaderpack/loading/ProgramId.java
Patch:
@@ -46,8 +46,8 @@ public enum ProgramId {
 	Water(ProgramGroup.Gbuffers, "water", Terrain),
 	HandWater(ProgramGroup.Gbuffers, "hand_water", Hand),
 	DhTerrain(ProgramGroup.Dh, "terrain"),
-	DhGeneric(ProgramGroup.Dh, "generic", DhTerrain),
 	DhWater(ProgramGroup.Dh, "water", DhTerrain),
+	DhGeneric(ProgramGroup.Dh, "generic", DhTerrain),
 	DhShadow(ProgramGroup.Dh, "shadow"),
 
 	Final(ProgramGroup.Final, ""),

File: src/main/java/net/irisshaders/iris/shaderpack/IdMap.java
Patch:
@@ -315,7 +315,7 @@ private static Map<NamespacedId, String> parseDimensionMap(Properties properties
 	}
 
 	private static void warnMissingBackslashInPropertiesFile(String processedSource, String propertiesFileName) {
-		if (propertiesFileName.equals("shader.properties")) {
+		if (propertiesFileName.equals("shaders.properties")) {
 			return;
 		}
 		String[] fileNameSections = propertiesFileName.split("\\.");

File: common/src/main/java/net/irisshaders/iris/shaderpack/materialmap/BlockMaterialMapping.java
Patch:
@@ -101,7 +101,7 @@ private static void addTag(TagEntry tagEntry, Object2IntMap<BlockState> idMap, i
 	}
 
 	public static Map<Block, BlockRenderType> createBlockTypeMap(Map<NamespacedId, BlockRenderType> blockPropertiesMap) {
-		Map<Block, BlockRenderType> blockTypeIds = new Reference2ReferenceLinkedOpenHashMap<>();
+		Map<Block, BlockRenderType> blockTypeIds = new Reference2ReferenceOpenHashMap<>();
 
 		blockPropertiesMap.forEach((id, blockType) -> {
 			ResourceLocation resourceLocation = ResourceLocation.fromNamespaceAndPath(id.getNamespace(), id.getName());

File: common/src/main/java/net/irisshaders/iris/shaderpack/programs/ProgramSet.java
Patch:
@@ -6,7 +6,6 @@
 import net.irisshaders.iris.shaderpack.ShaderPack;
 import net.irisshaders.iris.shaderpack.include.AbsolutePackPath;
 import net.irisshaders.iris.shaderpack.loading.ProgramArrayId;
-import net.irisshaders.iris.shaderpack.loading.ProgramGroup;
 import net.irisshaders.iris.shaderpack.loading.ProgramId;
 import net.irisshaders.iris.shaderpack.parsing.ComputeDirectiveParser;
 import net.irisshaders.iris.shaderpack.parsing.ConstDirectiveParser;
@@ -22,7 +21,6 @@
 import java.util.List;
 import java.util.Optional;
 import java.util.function.Function;
-import java.util.stream.Collectors;
 
 public class ProgramSet implements ProgramSetInterface {
 	private final PackDirectives packDirectives;
@@ -53,7 +51,7 @@ public ProgramSet(AbsolutePackPath directory, Function<AbsolutePackPath, String>
 		//
 		// - https://github.com/IrisShaders/Iris/issues/483
 		// - https://github.com/IrisShaders/Iris/issues/987
-		boolean readTesselation = pack.hasFeature(FeatureFlags.TESSELATION_SHADERS);
+		boolean readTesselation = pack.hasFeature(FeatureFlags.TESSELLATION_SHADERS);
 
 		this.shadowCompute = readComputeArray(directory, sourceProvider, "shadow", shaderProperties);
 		this.setup = readProgramArray(directory, sourceProvider, "setup", shaderProperties);

File: common/src/main/java/net/irisshaders/iris/pipeline/transform/transformer/SodiumTransformer.java
Patch:
@@ -27,7 +27,8 @@ public static void transform(
 		replaceMidTexCoord(t, tree, root, 1.0f / 32768.0f);
 
 		root.replaceExpressionMatches(t, CommonTransformer.glTextureMatrix0, "mat4(1.0)");
-		root.replaceExpressionMatches(t, CommonTransformer.glTextureMatrix1, "mat4(1.0)");
+		root.replaceExpressionMatches(t, CommonTransformer.glTextureMatrix1, "iris_LightmapTextureMatrix");
+		tree.parseAndInjectNode(t, ASTInjectionPoint.BEFORE_FUNCTIONS, "uniform mat4 iris_LightmapTextureMatrix;");
 		root.rename("gl_ProjectionMatrix", "iris_ProjectionMatrix");
 
 		if (parameters.type.glShaderType == ShaderType.VERTEX) {
@@ -179,7 +180,7 @@ vec2 _decode_light(uvec2 value) {
 			"void _vert_init() {" +
 				"_vert_position = _decode_position(a_PositionHi, a_PositionLo);" +
 				"_vert_tex_diffuse_coord = _decode_texcoord(a_TexCoord);" +
-				"_vert_tex_light_coord = _decode_light(a_LightAndData.xy);" +
+				"_vert_tex_light_coord = vec2(a_LightAndData.xy);" +
 				"_vert_color = " + separateAo + ";" +
 				"_draw_id = a_LightAndData[3]; }",
 

File: common/src/main/java/net/irisshaders/iris/compat/dh/DHCompatInternal.java
Patch:
@@ -129,6 +129,8 @@ public static boolean checkFrame() {
 			guiScale = Minecraft.getInstance().options.guiScale().get();
 		}
 
+		if (DhApi.Delayed.configs == null) return dhEnabled;
+
 		if ((dhEnabled != DhApi.Delayed.configs.graphics().renderingEnabled().getValue() || guiScale != Minecraft.getInstance().options.guiScale().get())
 			&& IrisApi.getInstance().isShaderPackInUse()) {
 			guiScale = Minecraft.getInstance().options.guiScale().get();

File: src/main/java/net/irisshaders/iris/shaderpack/programs/ProgramSet.java
Patch:
@@ -6,7 +6,6 @@
 import net.irisshaders.iris.shaderpack.ShaderPack;
 import net.irisshaders.iris.shaderpack.include.AbsolutePackPath;
 import net.irisshaders.iris.shaderpack.loading.ProgramArrayId;
-import net.irisshaders.iris.shaderpack.loading.ProgramGroup;
 import net.irisshaders.iris.shaderpack.loading.ProgramId;
 import net.irisshaders.iris.shaderpack.parsing.ComputeDirectiveParser;
 import net.irisshaders.iris.shaderpack.parsing.ConstDirectiveParser;
@@ -22,7 +21,6 @@
 import java.util.List;
 import java.util.Optional;
 import java.util.function.Function;
-import java.util.stream.Collectors;
 
 public class ProgramSet implements ProgramSetInterface {
 	private final PackDirectives packDirectives;
@@ -53,7 +51,7 @@ public ProgramSet(AbsolutePackPath directory, Function<AbsolutePackPath, String>
 		//
 		// - https://github.com/IrisShaders/Iris/issues/483
 		// - https://github.com/IrisShaders/Iris/issues/987
-		boolean readTesselation = pack.hasFeature(FeatureFlags.TESSELATION_SHADERS);
+		boolean readTesselation = pack.hasFeature(FeatureFlags.TESSELLATION_SHADERS);
 
 		this.shadowCompute = readComputeArray(directory, sourceProvider, "shadow", shaderProperties);
 		this.setup = readProgramArray(directory, sourceProvider, "setup", shaderProperties);

File: src/main/java/net/irisshaders/iris/mixin/MixinModelViewBobbing.java
Patch:
@@ -117,6 +117,7 @@ public abstract class MixinModelViewBobbing {
 
 		instance.set(stack.last().pose());
 
+		float f = deltaTracker.getGameTimeDeltaPartialTick(false);
 		float h = this.minecraft.options.screenEffectScale().get().floatValue();
 		float i = Mth.lerp(f, this.minecraft.player.oSpinningEffectIntensity, this.minecraft.player.spinningEffectIntensity) * h * h;
 		if (i > 0.0F) {

File: src/main/java/net/irisshaders/iris/shaderpack/IdMap.java
Patch:
@@ -72,9 +72,9 @@ public class IdMap {
 
 		entityIdMap = loadProperties(shaderPath, "entity.properties", shaderPackOptions, environmentDefines)
 			.map(IdMap::parseEntityIdMap).orElse(Object2IntMaps.emptyMap());
+		blockTagMap = new Int2ObjectLinkedOpenHashMap<>();
 
 		loadProperties(shaderPath, "block.properties", shaderPackOptions, environmentDefines).ifPresent(blockProperties -> {
-			blockTagMap = new Int2ObjectLinkedOpenHashMap<>();
 			blockPropertiesMap = parseBlockMap(blockProperties, "block.", "block.properties", blockTagMap);
 			blockRenderTypeMap = parseRenderTypeMap(blockProperties, "layer.", "block.properties");
 		});

File: common/src/main/java/net/irisshaders/iris/mixin/MixinQuickPlayDev.java
Patch:
@@ -1,6 +1,6 @@
 package net.irisshaders.iris.mixin;
 
-import net.fabricmc.loader.api.FabricLoader;
+import net.irisshaders.iris.platform.IrisPlatformHelpers;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.screens.DisconnectedScreen;
 import net.minecraft.client.gui.screens.Screen;
@@ -23,7 +23,7 @@
 public class MixinQuickPlayDev {
 	@Inject(method = "joinSingleplayerWorld", at = @At("HEAD"), cancellable = true)
 	private static void iris$createWorldIfDev(Minecraft minecraft, String string, CallbackInfo ci) {
-		if (FabricLoader.getInstance().isDevelopmentEnvironment()) {
+		if (IrisPlatformHelpers.getInstance().isDevelopmentEnvironment()) {
 			ci.cancel();
 
 			if (!minecraft.getLevelSource().levelExists(string)) {

File: neoforge/src/main/java/net/irisshaders/iris/mixin/forge/MixinRenderMekasuit.java
Patch:
@@ -3,6 +3,7 @@
 import net.irisshaders.iris.Iris;
 import net.irisshaders.iris.api.v0.IrisApi;
 import net.irisshaders.iris.pathways.LightningHandler;
+import net.irisshaders.iris.vertices.ImmediateState;
 import net.minecraft.client.renderer.RenderType;
 import net.minecraft.resources.ResourceLocation;
 import org.spongepowered.asm.mixin.Mixin;
@@ -30,7 +31,7 @@ public class MixinRenderMekasuit {
 		"Lmekanism/client/render/armor/MekaSuitArmor;render(Lnet/minecraft/client/model/HumanoidModel;Lnet/minecraft/client/renderer/MultiBufferSource;Lcom/mojang/blaze3d/vertex/PoseStack;IILmekanism/common/lib/Color;ZLnet/minecraft/world/entity/LivingEntity;Ljava/util/Map;Z)V"
 	}, at = @At(value = "FIELD", target = "Lmekanism/client/render/MekanismRenderType;MEKASUIT:Lnet/minecraft/client/renderer/RenderType;"))
 	private RenderType doNotSwitchShaders() {
-		if (IrisApi.getInstance().isShaderPackInUse()) {
+		if (IrisApi.getInstance().isShaderPackInUse() && ImmediateState.isRenderingLevel) {
 			return LightningHandler.MEKASUIT;
 		} else {
 			return (RenderType) MEKASUIT;

File: src/main/java/net/irisshaders/batchedentityrendering/mixin/MixinSheets.java
Patch:
@@ -22,5 +22,6 @@ private static void setSheet(CallbackInfo ci) {
 		((BlendingStateHolder) ARMOR_TRIMS_SHEET_TYPE).setTransparencyType(TransparencyType.OPAQUE_DECAL);
 		((BlendingStateHolder) RenderType.textBackground()).setTransparencyType(TransparencyType.OPAQUE);
 		((BlendingStateHolder) RenderType.textBackgroundSeeThrough()).setTransparencyType(TransparencyType.OPAQUE);
+		((BlendingStateHolder) RenderType.dragonRaysDepth()).setTransparencyType(TransparencyType.DECAL);
 	}
 }

File: src/main/java/net/irisshaders/iris/mixin/entity_render_context/MixinEntityRenderer.java
Patch:
@@ -23,8 +23,8 @@ public class MixinEntityRenderer<T extends Entity> {
 	@Unique
 	private int lastId = -100;
 
-	@Inject(method = "renderNameTag", at = @At(value = "INVOKE", target = "Lnet/minecraft/world/entity/Entity;getNameTagOffsetY()F"))
-	private void setNameTagId(T entity, Component component, PoseStack poseStack, MultiBufferSource multiBufferSource, int i, CallbackInfo ci) {
+	@Inject(method = "renderNameTag", at = @At(value = "INVOKE", target = "Lnet/minecraft/world/entity/Entity;getViewYRot(F)F"))
+	private void setNameTagId(T entity, Component component, PoseStack poseStack, MultiBufferSource multiBufferSource, int i, float f, CallbackInfo ci) {
 		Object2IntFunction<NamespacedId> entityIds = WorldRenderingSettings.INSTANCE.getEntityIds();
 
 		if (entityIds == null) {
@@ -39,7 +39,7 @@ private void setNameTagId(T entity, Component component, PoseStack poseStack, Mu
 	}
 
 	@Inject(method = "renderNameTag", at = @At("RETURN"))
-	private void resetId(T entity, Component component, PoseStack poseStack, MultiBufferSource multiBufferSource, int i, CallbackInfo ci) {
+	private void resetId(T entity, Component component, PoseStack poseStack, MultiBufferSource multiBufferSource, int i, float f, CallbackInfo ci) {
 		if (lastId != -100) {
 			CapturedRenderingState.INSTANCE.setCurrentEntity(lastId);
 			lastId = -100	;

File: src/sodiumCompatibility/java/net/irisshaders/iris/compat/sodium/mixin/clouds/MixinCloudRenderer.java
Patch:
@@ -67,7 +67,7 @@ private static void writeIrisVertex(long buffer, float x, float y, float z, int
 	@Shadow
 	private CloudStatus cloudRenderMode;
 
-	@Inject(method = "render", at = @At(value = "HEAD"), cancellable = true)
+	@Inject(method = "render", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/renderer/DimensionSpecialEffects;getCloudHeight()F"), cancellable = true)
 	private void buildIrisVertexBuffer(ClientLevel level, LocalPlayer player, PoseStack matrices, Matrix4f projectionMatrix, float ticks, float tickDelta, double cameraX, double cameraY, double cameraZ, CallbackInfo ci) {
 		if (IrisApi.getInstance().isShaderPackInUse()) {
 			ci.cancel();

File: src/main/java/net/irisshaders/iris/mixin/vertices/MixinBufferBuilder.java
Patch:
@@ -162,7 +162,7 @@ private void injectMidBlock(float x, float y, float z, CallbackInfoReturnable<Ve
 		}
 
 
-		vertexPointers[vertexCount] = vertexPointer;
+		vertexPointers[iris$vertexCount] = vertexPointer;
 
 		if (injectNormalAndUV1 && this.elementsToFill != (this.elementsToFill & ~VertexFormatElement.NORMAL.mask())) {
 			this.setNormal(0, 0, 0);

File: src/main/java/net/irisshaders/iris/mixin/MixinQuickPlayDev.java
Patch:
@@ -30,7 +30,7 @@ public class MixinQuickPlayDev {
 				minecraft.createWorldOpenFlows().createFreshLevel(string, new LevelSettings(string, GameType.CREATIVE, false, Difficulty.HARD, true, new GameRules(), WorldDataConfiguration.DEFAULT),
 					WorldOptions.defaultWithRandomSeed(), WorldPresets::createNormalWorldDimensions, Minecraft.getInstance().screen);
 			} else {
-				minecraft.createWorldOpenFlows().checkForBackupAndLoad(string, () -> minecraft.setScreen(new TitleScreen()));
+				minecraft.createWorldOpenFlows().openWorld(string, () -> minecraft.setScreen(new TitleScreen()));
 			}
 		}
 	}

File: common/src/sodiumCompatibility/java/net/irisshaders/iris/compat/sodium/mixin/directional_shading/MixinSmoothLightPipeline.java
Patch:
@@ -12,7 +12,7 @@
 @Mixin(SmoothLightPipeline.class)
 public class MixinSmoothLightPipeline {
 	@Inject(method = "applySidedBrightness", at = @At("HEAD"), cancellable = true)
-	private void iris$disableDirectionalShading(QuadLightData out, Direction face, boolean shade, CallbackInfo ci) {
+	private void iris$disableDirectionalShading(CallbackInfo ci) {
 		if (WorldRenderingSettings.INSTANCE.shouldDisableDirectionalShading()) {
 			ci.cancel();
 		}

File: src/main/java/net/irisshaders/iris/vertices/BufferBuilderPolygonView.java
Patch:
@@ -33,11 +33,11 @@ public float z(int index) {
 
 	@Override
 	public float u(int index) {
-		return MemoryUtil.memGetFloat(writePointers[index] + 12);
+		return MemoryUtil.memGetFloat(writePointers[index] + 16);
 	}
 
 	@Override
 	public float v(int index) {
-		return MemoryUtil.memGetFloat(writePointers[index] + 16);
+		return MemoryUtil.memGetFloat(writePointers[index] + 20);
 	}
 }

File: src/main/java/net/irisshaders/iris/vertices/IrisVertexFormats.java
Patch:
@@ -50,7 +50,6 @@ public class IrisVertexFormats {
 			.add("iris_Entity", ENTITY_ID_ELEMENT)
 			.add("mc_midTexCoord", MID_TEXTURE_ELEMENT)
 			.add("at_tangent", TANGENT_ELEMENT)
-			.padding(1)
 			.build();
 
 		GLYPH = VertexFormat.builder()

File: src/main/java/net/irisshaders/iris/mixin/entity_render_context/MixinBlockEntityRenderDispatcher.java
Patch:
@@ -11,6 +11,7 @@
 import net.irisshaders.iris.layer.OuterWrappedRenderType;
 import net.irisshaders.iris.shaderpack.materialmap.WorldRenderingSettings;
 import net.irisshaders.iris.uniforms.CapturedRenderingState;
+import net.irisshaders.iris.vertices.ImmediateState;
 import net.minecraft.client.gui.screens.Screen;
 import net.minecraft.client.renderer.MultiBufferSource;
 import net.minecraft.client.renderer.RenderType;
@@ -49,7 +50,7 @@ public class MixinBlockEntityRenderDispatcher {
 
 		Object2IntMap<BlockState> blockStateIds = WorldRenderingSettings.INSTANCE.getBlockStateIds();
 
-		if (blockStateIds == null) {
+		if (blockStateIds == null || !ImmediateState.isRenderingLevel) {
 			return bufferSource;
 		}
 

File: src/main/java/net/irisshaders/iris/mixin/entity_render_context/MixinEntityRenderDispatcher.java
Patch:
@@ -10,6 +10,7 @@
 import net.irisshaders.iris.shaderpack.materialmap.NamespacedId;
 import net.irisshaders.iris.shaderpack.materialmap.WorldRenderingSettings;
 import net.irisshaders.iris.uniforms.CapturedRenderingState;
+import net.irisshaders.iris.vertices.ImmediateState;
 import net.minecraft.client.renderer.MultiBufferSource;
 import net.minecraft.client.renderer.entity.EntityRenderDispatcher;
 import net.minecraft.core.registries.BuiltInRegistries;
@@ -35,7 +36,7 @@ public class MixinEntityRenderDispatcher {
 	private MultiBufferSource iris$beginEntityRender(MultiBufferSource bufferSource, Entity entity) {
 		Object2IntFunction<NamespacedId> entityIds = WorldRenderingSettings.INSTANCE.getEntityIds();
 
-		if (entityIds == null) {
+		if (entityIds == null || !ImmediateState.isRenderingLevel) {
 			return bufferSource;
 		}
 

File: src/main/java/net/irisshaders/batchedentityrendering/impl/FullyBufferedMultiBufferSource.java
Patch:
@@ -3,6 +3,7 @@
 import com.mojang.blaze3d.vertex.BufferBuilder;
 import com.mojang.blaze3d.vertex.ByteBufferBuilder;
 import com.mojang.blaze3d.vertex.VertexConsumer;
+import it.unimi.dsi.fastutil.objects.Object2ObjectSortedMaps;
 import net.irisshaders.batchedentityrendering.impl.ordering.GraphTranslucencyRenderOrderManager;
 import net.irisshaders.batchedentityrendering.impl.ordering.RenderOrderManager;
 import net.irisshaders.iris.layer.WrappingMultiBufferSource;
@@ -40,7 +41,7 @@ public class FullyBufferedMultiBufferSource extends MultiBufferSource.BufferSour
 	private List<RenderType> renderOrder = new ArrayList<>();
 
 	public FullyBufferedMultiBufferSource() {
-		super(new ByteBufferBuilder(0), Collections.emptyMap());
+		super(new ByteBufferBuilder(0), Object2ObjectSortedMaps.emptyMap());
 
 		this.renderOrderManager = new GraphTranslucencyRenderOrderManager();
 		this.builders = new SegmentedBufferBuilder[NUM_BUFFERS];
@@ -316,7 +317,7 @@ private static class UnflushableWrapper extends MultiBufferSource.BufferSource i
 		private final FullyBufferedMultiBufferSource wrapped;
 
 		UnflushableWrapper(FullyBufferedMultiBufferSource wrapped) {
-			super(new ByteBufferBuilder(0), Collections.emptyMap());
+			super(new ByteBufferBuilder(0), Object2ObjectSortedMaps.emptyMap());
 
 			this.wrapped = wrapped;
 		}

File: src/main/java/net/irisshaders/batchedentityrendering/impl/OldFullyBufferedMultiBufferSource.java
Patch:
@@ -6,6 +6,7 @@
 import com.mojang.blaze3d.vertex.VertexSorting;
 import it.unimi.dsi.fastutil.objects.Object2IntMap;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Object2ObjectSortedMaps;
 import net.minecraft.client.renderer.MultiBufferSource;
 import net.minecraft.client.renderer.RenderType;
 
@@ -27,7 +28,7 @@ public class OldFullyBufferedMultiBufferSource extends MultiBufferSource.BufferS
 	private boolean flushed;
 
 	public OldFullyBufferedMultiBufferSource() {
-		super(new ByteBufferBuilder(0), Collections.emptyMap());
+		super(new ByteBufferBuilder(0), Object2ObjectSortedMaps.emptyMap());
 
 		this.bufferBuilders = new HashMap<>();
 		this.unused = new Object2IntOpenHashMap<>();

File: src/main/java/net/irisshaders/batchedentityrendering/mixin/BufferSourceAccessor.java
Patch:
@@ -8,9 +8,10 @@
 import org.spongepowered.asm.mixin.gen.Accessor;
 
 import java.util.Map;
+import java.util.SequencedMap;
 
 @Mixin(MultiBufferSource.BufferSource.class)
 public interface BufferSourceAccessor {
 	@Accessor
-	Map<RenderType, ByteBufferBuilder> getFixedBuffers();
+	SequencedMap<RenderType, ByteBufferBuilder> getFixedBuffers();
 }

File: src/main/java/net/irisshaders/batchedentityrendering/mixin/MixinBufferSource.java
Patch:
@@ -10,6 +10,7 @@
 import org.spongepowered.asm.mixin.Shadow;
 
 import java.util.Map;
+import java.util.SequencedMap;
 
 @Mixin(MultiBufferSource.BufferSource.class)
 public class MixinBufferSource implements MemoryTrackingBuffer {
@@ -19,7 +20,7 @@ public class MixinBufferSource implements MemoryTrackingBuffer {
 
 	@Shadow
 	@Final
-	protected Map<RenderType, ByteBufferBuilder> fixedBuffers;
+	protected SequencedMap<RenderType, ByteBufferBuilder> fixedBuffers;
 
 	@Override
 	public long getAllocatedSize() {

File: src/main/java/net/irisshaders/iris/gui/FeatureMissingErrorScreen.java
Patch:
@@ -10,7 +10,7 @@
 
 public class FeatureMissingErrorScreen extends Screen {
 	private final Screen parent;
-	private final FormattedText messageTemp;
+	private final Component messageTemp;
 	private MultiLineLabel message;
 
 	public FeatureMissingErrorScreen(Screen parent, Component title, Component message) {
@@ -22,7 +22,7 @@ public FeatureMissingErrorScreen(Screen parent, Component title, Component messa
 	@Override
 	protected void init() {
 		super.init();
-		this.message = MultiLineLabel.create(this.font, messageTemp, this.width - 50);
+		this.message = MultiLineLabel.create(this.font, this.width - 50, messageTemp);
 		this.addRenderableWidget(Button.builder(CommonComponents.GUI_BACK, arg -> this.minecraft.setScreen(parent)).bounds(this.width / 2 - 100, 140, 200, 20).build());
 	}
 

File: src/sodiumCompatibility/java/net/irisshaders/iris/compat/sodium/impl/vertex_format/terrain_xhfp/XHFPModelVertexType.java
Patch:
@@ -20,7 +20,7 @@ public class XHFPModelVertexType implements ChunkVertexType {
 		.addElement(ChunkMeshAttribute.LIGHT_TEXTURE, 16, GlVertexAttributeFormat.UNSIGNED_SHORT, 2, false, true)
 		.addElement(IrisChunkMeshAttributes.MID_TEX_COORD, 20, GlVertexAttributeFormat.UNSIGNED_SHORT, 2, false, false)
 		.addElement(IrisChunkMeshAttributes.TANGENT, 24, IrisGlVertexAttributeFormat.BYTE, 4, true, false)
-		.addElement(IrisChunkMeshAttributes.NORMAL, 28, IrisGlVertexAttributeFormat.BYTE, 3, true, false)
+		.addElement(IrisChunkMeshAttributes.NORMAL, 28, IrisGlVertexAttributeFormat.BYTE, 4, true, false)
 		.addElement(IrisChunkMeshAttributes.BLOCK_ID, 32, IrisGlVertexAttributeFormat.SHORT, 2, false, false)
 		.addElement(IrisChunkMeshAttributes.MID_BLOCK, 36, IrisGlVertexAttributeFormat.BYTE, 4, false, false)
 		.build();

File: src/main/java/net/irisshaders/batchedentityrendering/impl/SegmentedBufferBuilder.java
Patch:
@@ -14,7 +14,7 @@
 import java.util.List;
 import java.util.Map;
 
-public class SegmentedBufferBuilder implements MultiBufferSource, MemoryTrackingBuffer {
+public class SegmentedBufferBuilder implements MemoryTrackingBuffer {
 	private final Map<RenderType, ByteBufferBuilderHolder> buffers;
 	private final Map<RenderType, BufferBuilder> builders;
 	private final List<BufferSegment> segments;
@@ -30,7 +30,6 @@ private static boolean shouldSortOnUpload(RenderType type) {
 		return ((RenderTypeAccessor) type).shouldSortOnUpload();
 	}
 
-	@Override
 	public VertexConsumer getBuffer(RenderType renderType) {
 		ByteBufferBuilderHolder buffer = buffers.computeIfAbsent(renderType, (r) -> new ByteBufferBuilderHolder(new ByteBufferBuilder(512*2024)));
 
@@ -100,6 +99,6 @@ public void freeAndDeleteBuffer() {
 	}
 
 	public void clearBuffers() {
-		buffers.values().removeIf(ByteBufferBuilderHolder::deleteOrClear);
+		//buffers.values().removeIf(ByteBufferBuilderHolder::deleteOrClear);
 	}
 }

File: src/main/java/net/irisshaders/batchedentityrendering/impl/ordering/RenderOrderManager.java
Patch:
@@ -12,6 +12,8 @@ public interface RenderOrderManager {
 
 	boolean maybeStartGroup();
 
+	boolean isInGroup();
+
 	void endGroup();
 
 	void reset();

File: src/main/java/net/irisshaders/iris/mixin/entity_render_context/MixinEntityRenderDispatcher.java
Patch:
@@ -3,6 +3,8 @@
 import com.mojang.blaze3d.vertex.PoseStack;
 import it.unimi.dsi.fastutil.objects.Object2IntFunction;
 import net.irisshaders.batchedentityrendering.impl.Groupable;
+import net.irisshaders.iris.layer.BlockEntityRenderStateShard;
+import net.irisshaders.iris.layer.BufferSourceWrapper;
 import net.irisshaders.iris.layer.EntityRenderStateShard;
 import net.irisshaders.iris.layer.OuterWrappedRenderType;
 import net.irisshaders.iris.shaderpack.materialmap.NamespacedId;
@@ -53,8 +55,7 @@ public class MixinEntityRenderDispatcher {
 
 		CapturedRenderingState.INSTANCE.setCurrentEntity(intId);
 
-		return type ->
-			bufferSource.getBuffer(OuterWrappedRenderType.wrapExactlyOnce("iris:is_entity", type, EntityRenderStateShard.INSTANCE));
+		return new BufferSourceWrapper(bufferSource, (renderType) -> OuterWrappedRenderType.wrapExactlyOnce("iris:entity", renderType, EntityRenderStateShard.INSTANCE));
 	}
 
 	// Inject before MatrixStack#pop so that our wrapper stack management operations naturally line up

File: src/sodiumCompatibility/java/net/irisshaders/iris/compat/sodium/mixin/copyEntity/ModelPartMixin.java
Patch:
@@ -9,6 +9,7 @@
 import me.jellysquid.mods.sodium.client.render.vertex.VertexConsumerUtils;
 import net.caffeinemc.mods.sodium.api.math.MatrixHelper;
 import net.caffeinemc.mods.sodium.api.util.ColorABGR;
+import net.caffeinemc.mods.sodium.api.util.ColorARGB;
 import net.caffeinemc.mods.sodium.api.vertex.buffer.VertexBufferWriter;
 import net.minecraft.client.model.geom.ModelPart;
 import org.spongepowered.asm.mixin.Final;
@@ -97,7 +98,7 @@ private void onRender(PoseStack matrices, VertexConsumer vertices, int light, in
 
 		ci.cancel();
 
-		EntityRenderer.render(matrices, writer, (ModelPart) (Object) this, light, overlay, color);
+		EntityRenderer.render(matrices, writer, (ModelPart) (Object) this, light, overlay, ColorARGB.toABGR(color));
 	}
 
 	/**

File: common/src/main/java/net/irisshaders/iris/pipeline/transform/transformer/SodiumTransformer.java
Patch:
@@ -131,7 +131,7 @@ public static void injectVertInit(
 		Root root,
 		SodiumParameters parameters) {
 		String separateAo = WorldRenderingSettings.INSTANCE.shouldUseSeparateAo() ? "a_Color" : "vec4(a_Color.rgb * a_Color.a, 1.0)";
-		tree.parseAndInjectNodes(t, ASTInjectionPoint.BEFORE_FUNCTIONS,
+		tree.parseAndInjectNodes(t, ASTInjectionPoint.BEFORE_DECLARATIONS,
 			// translated from sodium's chunk_vertex.glsl
 			"vec3 _vert_position;",
 			"vec2 _vert_tex_diffuse_coord;",

File: src/main/java/net/irisshaders/iris/gl/IrisLimits.java
Patch:
@@ -9,4 +9,5 @@ public class IrisLimits {
 	 * is implemented.
 	 */
 	public static final int MAX_COLOR_BUFFERS = 16;
+	public static final boolean VK_CONFORMANCE = false;
 }

File: src/main/java/net/irisshaders/iris/gl/GLDebug.java
Patch:
@@ -311,11 +311,11 @@ public static void nameObject(int id, int object, String name) {
 	}
 
 	public static void pushGroup(int id, String name) {
-		debugState.pushGroup(id, name);
+		//debugState.pushGroup(id, name);
 	}
 
 	public static void popGroup() {
-		debugState.popGroup();
+		//debugState.popGroup();
 	}
 
 	private interface DebugState {

File: src/main/java/net/irisshaders/iris/gl/shader/StandardMacros.java
Patch:
@@ -49,6 +49,7 @@ public static ImmutableList<StringPair> createStandardEnvironmentDefines() {
 		define(standardDefines, getVendor());
 		define(standardDefines, getRenderer());
 		define(standardDefines, "IS_IRIS");
+		define(standardDefines, "IRIS_TAG_SUPPORT");
 
 
 		if (FabricLoader.getInstance().isModLoaded("distanthorizons") && DHCompat.hasRenderingEnabled()) {

File: src/main/java/net/irisshaders/iris/compat/dh/DHCompat.java
Patch:
@@ -79,7 +79,7 @@ public static void run() {
 				if (e instanceof ExceptionInInitializerError eiie) {
 					throw new RuntimeException("Failure loading DH compat.", eiie.getCause());
 				} else {
-					throw new RuntimeException("DH 2.0 not found, yet Fabric claims it's there. Curious.", e);
+					throw new RuntimeException("DH found, but one or more API methods are missing. Iris requires DH [2.0.4] or DH API version [1.1.0] or newer. Please make sure you are on the latest version of DH and Iris.", e);
 				}
 			} else {
 				Iris.logger.info("DH not found, and classes not found.");

File: src/main/java/net/irisshaders/iris/compat/dh/DHCompat.java
Patch:
@@ -79,7 +79,7 @@ public static void run() {
 				if (e instanceof ExceptionInInitializerError eiie) {
 					throw new RuntimeException("Failure loading DH compat.", eiie.getCause());
 				} else {
-					throw new RuntimeException("DH 2.0 not found, yet Fabric claims it's there. Curious.", e);
+					throw new RuntimeException("DH found, but one or more API methods are missing. Iris requires DH [2.0.4] or DH API version [1.1.0] or newer. Please make sure you are on the latest version of DH and Iris.", e);
 				}
 			} else {
 				Iris.logger.info("DH not found, and classes not found.");

File: src/main/java/net/irisshaders/iris/gui/element/screen/IrisButton.java
Patch:
@@ -28,9 +28,11 @@ protected void renderWidget(GuiGraphics guiGraphics, int pInt1, int pInt2, float
 		RenderSystem.enableDepthTest();
 		GuiUtil.bindIrisWidgetsTexture();
 		GuiUtil.drawButton(guiGraphics, this.getX(), this.getY(), this.getWidth(), this.getHeight(), this.isHoveredOrFocused(), this.active);
-		guiGraphics.setColor(1.0F, 1.0F, 1.0F, 1.0F);
+		guiGraphics.setColor(1.0F, 1.0F, 1.0F, this.alphaSupplier.getAsFloat());
 		int lvInt6 = this.active ? 16777215 : 10526880;
 		this.renderString(guiGraphics, lvMinecraft5.font, lvInt6 | Mth.ceil(this.alphaSupplier.getAsFloat() * 255.0F) << 24);
+		guiGraphics.setColor(1.0F, 1.0F, 1.0F, 1.0F);
+
 	}
 
 	public static IrisButton.Builder iris$builder(Component pComponent0, Button.OnPress pButton$OnPress1, FloatSupplier alpha) {

File: src/main/java/net/irisshaders/iris/shaderpack/IdMap.java
Patch:
@@ -97,7 +97,7 @@ private static Optional<Properties> loadProperties(Path shaderPath, String name,
 		}
 
 		// TODO: This is the worst code I have ever made. Do not do this.
-			String processed = PropertiesPreprocessor.preprocessSource(fileContents, shaderPackOptions, environmentDefines).replaceAll("\\\\\\n\\s*\\n", " ").replaceAll("\\S\s*block.", "\nblock.");
+		String processed = PropertiesPreprocessor.preprocessSource(fileContents, shaderPackOptions, environmentDefines).replaceAll("\\\\\\n\\s*\\n", " ").replaceAll("\\S\s*block\\.", "\nblock.");
 
 		StringReader propertiesReader = new StringReader(processed);
 

File: src/main/java/net/irisshaders/iris/shaderpack/IdMap.java
Patch:
@@ -96,7 +96,8 @@ private static Optional<Properties> loadProperties(Path shaderPath, String name,
 			return Optional.empty();
 		}
 
-		String processed = PropertiesPreprocessor.preprocessSource(fileContents, shaderPackOptions, environmentDefines).replaceAll("(?m)^[ \\t]*\\r?\\n", "");
+		// TODO: This is the worst code I have ever made. Do not do this.
+			String processed = PropertiesPreprocessor.preprocessSource(fileContents, shaderPackOptions, environmentDefines).replaceAll("\\\\\\n\\s*\\n", " ").replaceAll("\\S\s*block.", "\nblock.");
 
 		StringReader propertiesReader = new StringReader(processed);
 

File: src/main/java/net/irisshaders/iris/compat/dh/IrisLodRenderProgram.java
Patch:
@@ -168,9 +168,7 @@ public static IrisLodRenderProgram createProgram(String name, boolean isShadowPa
 	// Noise Uniforms
 
 	public int tryGetUniformLocation2(CharSequence name) {
-		int i = GL32.glGetUniformLocation(this.id, name);
-		if (i == -1) Iris.logger.warn("Couldn't find " + name);
-		return i;
+		return GL32.glGetUniformLocation(this.id, name);
 	}
 
 	public void setUniform(int index, Matrix4f matrix) {

File: src/main/java/net/irisshaders/iris/pipeline/transform/ShaderPrinter.java
Patch:
@@ -122,8 +122,6 @@ public void print() {
 								return !FilenameUtils.getExtension(s.toString()).contains("properties");
 							})) {
 								stream.forEach(path -> {
-									Iris.logger.warn(path.toString());
-
 									try {
 										Files.delete(path);
 									} catch (IOException e) {

File: src/main/java/net/irisshaders/iris/Iris.java
Patch:
@@ -650,9 +650,9 @@ public static String getFormattedVersion() {
 		ChatFormatting color;
 		String version = getVersion();
 
-		if (version.endsWith("-development-environment")) {
+		if (FabricLoader.getInstance().isDevelopmentEnvironment()) {
 			color = ChatFormatting.GOLD;
-			version = version.replace("-development-environment", " (Development Environment)");
+			version = version + " (Development Environment)";
 		} else if (version.endsWith("-dirty") || version.contains("unknown") || version.endsWith("-nogit")) {
 			color = ChatFormatting.RED;
 		} else if (version.contains("+rev.")) {

File: src/main/java/net/irisshaders/iris/gui/screen/ShaderPackScreen.java
Patch:
@@ -1,6 +1,7 @@
 package net.irisshaders.iris.gui.screen;
 
 import com.mojang.blaze3d.platform.InputConstants;
+import net.fabricmc.loader.api.FabricLoader;
 import net.irisshaders.iris.Iris;
 import net.irisshaders.iris.api.v0.IrisApi;
 import net.irisshaders.iris.gui.GuiUtil;
@@ -80,9 +81,8 @@ public ShaderPackScreen(Screen parent) {
 
 		String irisName = Iris.MODNAME + " " + Iris.getVersion();
 
-		if (irisName.contains("-development-environment")) {
+		if (FabricLoader.getInstance().isDevelopmentEnvironment()) {
 			this.developmentComponent = Component.literal("Development Environment").withStyle(ChatFormatting.GOLD);
-			irisName = irisName.replace("-development-environment", "");
 		}
 
 		this.irisTextComponent = Component.literal(irisName).withStyle(ChatFormatting.GRAY);

File: src/main/java/net/irisshaders/iris/compat/dh/DHCompat.java
Patch:
@@ -131,6 +131,7 @@ public static boolean checkFrame() {
 		if (!dhPresent) {
 			return false;
 		}
+		
 		try {
 			return (boolean) checkFrame.invoke();
 		} catch (Throwable e) {
@@ -157,7 +158,7 @@ public void clearPipeline() {
 	}
 
 	public int getDepthTex() {
-		if (compatInternalInstance == null) throw new IllegalStateException("Couldn't find DH depth texture");
+		if (compatInternalInstance == null) return -1;
 
 		try {
 			return (int) getDepthTex.invoke(compatInternalInstance);
@@ -167,7 +168,7 @@ public int getDepthTex() {
 	}
 
 	public int getDepthTexNoTranslucent() {
-		if (compatInternalInstance == null) throw new IllegalStateException("Couldn't find DH depth texture");
+		if (compatInternalInstance == null) return -1;
 
 		try {
 			return (int) getDepthTexNoTranslucent.invoke(compatInternalInstance);

File: src/main/java/net/irisshaders/iris/mixin/MixinRenderSystem.java
Patch:
@@ -20,7 +20,7 @@ public class MixinRenderSystem {
 	@Inject(method = "initRenderer", at = @At("RETURN"), remap = false)
 	private static void iris$onRendererInit(int debugVerbosity, boolean alwaysFalse, CallbackInfo ci) {
 		Iris.duringRenderSystemInit();
-		GLDebug.initRenderer();
+		GLDebug.reloadDebugState();
 		IrisRenderSystem.initRenderer();
 		IrisSamplers.initRenderer();
 		Iris.onRenderSystemInit();

File: src/main/java/net/irisshaders/iris/compat/dh/DHCompat.java
Patch:
@@ -128,6 +128,9 @@ public static int getRenderDistance() {
 	}
 
 	public static boolean checkFrame() {
+		if (!dhPresent) {
+			return false;
+		}
 		try {
 			return (boolean) checkFrame.invoke();
 		} catch (Throwable e) {

File: src/main/java/net/irisshaders/iris/Iris.java
Patch:
@@ -96,7 +96,7 @@ public class Iris {
 	private static boolean fallback;
 
 	static {
-		if (FabricLoader.getInstance().isDevelopmentEnvironment() && System.getProperty("user.name").contains("ims") && Util.getPlatform() == Util.OS.LINUX) {
+		if (!BuildConfig.ACTIVATE_RENDERDOC && FabricLoader.getInstance().isDevelopmentEnvironment() && System.getProperty("user.name").contains("ims") && Util.getPlatform() == Util.OS.LINUX) {
 			Configuration.GLFW_LIBRARY_NAME.set("/usr/lib/libglfw.so");
 		}
 	}

File: src/main/java/net/irisshaders/iris/mixin/MixinLevelRenderer.java
Patch:
@@ -4,6 +4,7 @@
 import com.mojang.blaze3d.vertex.PoseStack;
 import com.mojang.math.Axis;
 import net.irisshaders.iris.Iris;
+import net.irisshaders.iris.compat.dh.DHCompat;
 import net.irisshaders.iris.gl.IrisRenderSystem;
 import net.irisshaders.iris.layer.IsOutlineRenderStateShard;
 import net.irisshaders.iris.layer.OuterWrappedRenderType;
@@ -76,6 +77,8 @@ public class MixinLevelRenderer {
 	private void iris$setupPipeline(PoseStack poseStack, float tickDelta, long startTime, boolean renderBlockOutline,
 									Camera camera, GameRenderer gameRenderer, LightTexture lightTexture,
 									Matrix4f projection, CallbackInfo callback) {
+		DHCompat.checkFrame();
+
 		IrisTimeUniforms.updateTime();
 		CapturedRenderingState.INSTANCE.setGbufferModelView(poseStack.last().pose());
 		CapturedRenderingState.INSTANCE.setGbufferProjection(projection);

File: src/main/java/net/irisshaders/iris/pipeline/IrisRenderingPipeline.java
Patch:
@@ -854,6 +854,7 @@ public void beginLevelRendering() {
 		RenderSystem.activeTexture(GL15C.GL_TEXTURE0);
 		Vector4f emptyClearColor = new Vector4f(1.0F);
 
+
 		for (GlImage image : clearImages) {
 			ARBClearTexture.glClearTexImage(image.getId(), 0, image.getFormat().getGlFormat(), image.getPixelType().getGlFormat(), (int[]) null);
 		}
@@ -914,6 +915,7 @@ public void beginLevelRendering() {
 			main.height, depthBufferFormat, packDirectives);
 
 		if (changed) {
+			dhCompat.onResolutionChanged();
 			beginRenderer.recalculateSizes();
 			prepareRenderer.recalculateSizes();
 			deferredRenderer.recalculateSizes();

File: src/main/java/net/irisshaders/iris/shadows/ShadowRenderingState.java
Patch:
@@ -15,15 +15,15 @@ public static void setBlockEntityRenderFunction(BlockEntityRenderFunction functi
 		ShadowRenderingState.function = function;
 	}
 
-	public static int renderBlockEntities(ShadowRenderer shadowRenderer, MultiBufferSource.BufferSource bufferSource, PoseStack modelView, Camera camera, double cameraX, double cameraY, double cameraZ, float tickDelta, boolean hasEntityFrustum) {
-		return function.renderBlockEntities(shadowRenderer, bufferSource, modelView, camera, cameraX, cameraY, cameraZ, tickDelta, hasEntityFrustum);
+	public static int renderBlockEntities(ShadowRenderer shadowRenderer, MultiBufferSource.BufferSource bufferSource, PoseStack modelView, Camera camera, double cameraX, double cameraY, double cameraZ, float tickDelta, boolean hasEntityFrustum, boolean lightsOnly) {
+		return function.renderBlockEntities(shadowRenderer, bufferSource, modelView, camera, cameraX, cameraY, cameraZ, tickDelta, hasEntityFrustum, lightsOnly);
 	}
 
 	public static int getRenderDistance() {
 		return ShadowRenderer.renderDistance;
 	}
 
 	public interface BlockEntityRenderFunction {
-		int renderBlockEntities(ShadowRenderer shadowRenderer, MultiBufferSource.BufferSource bufferSource, PoseStack modelView, Camera camera, double cameraX, double cameraY, double cameraZ, float tickDelta, boolean hasEntityFrustum);
+		int renderBlockEntities(ShadowRenderer shadowRenderer, MultiBufferSource.BufferSource bufferSource, PoseStack modelView, Camera camera, double cameraX, double cameraY, double cameraZ, float tickDelta, boolean hasEntityFrustum, boolean lightsOnly);
 	}
 }

File: src/main/java/net/irisshaders/batchedentityrendering/mixin/MixinCompositeRenderType.java
Patch:
@@ -11,7 +11,7 @@
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
-@Mixin(targets = "net/minecraft/client/renderer/RenderType$CompositeRenderType")
+@Mixin(RenderType.CompositeRenderType.class)
 public abstract class MixinCompositeRenderType extends RenderType implements BlendingStateHolder {
 	private static final String INIT =
 		"<init>(Ljava/lang/String;Lcom/mojang/blaze3d/vertex/VertexFormat;Lcom/mojang/blaze3d/vertex/VertexFormat$Mode;IZZLnet/minecraft/client/renderer/RenderType$CompositeState;)V";

File: src/main/java/net/irisshaders/iris/mixin/MixinEntityRenderDispatcher.java
Patch:
@@ -70,7 +70,7 @@ private static void renderBlockShadow(PoseStack.Pose pPoseStack$Pose0, VertexCon
 	// https://github.com/tr7zw/FirstPersonModel/blob/172ab05368832df82e34ca9f9b06814672f69f59/FPShared/src/main/java/dev/tr7zw/firstperson/mixins/RenderDispatcherMixin.java#L68
 	// The renderBlockShadow injection will handle this, but it's easier to suppress it before all of the other calculations.
 	@SuppressWarnings("all")
-	@Inject(method = "renderOffsetShadow", at = @At("HEAD"), cancellable = true, require = 0, remap = false)
+	@Inject(method = "renderOffsetShadow", at = @At("HEAD"), cancellable = true, require = 0, remap = false, expect = 0)
 	private static void iris$maybeSuppressEntityShadow(PoseStack poseStack, MultiBufferSource bufferSource,
 													   Entity entity, float opacity, float tickDelta, LevelReader level,
 													   float radius, Vec3 offset, CallbackInfo ci) {

File: src/main/java/net/irisshaders/iris/mixin/statelisteners/BooleanStateAccessor.java
Patch:
@@ -1,9 +1,10 @@
 package net.irisshaders.iris.mixin.statelisteners;
 
+import com.mojang.blaze3d.platform.GlStateManager;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
 
-@Mixin(targets = "com/mojang/blaze3d/platform/GlStateManager$BooleanState")
+@Mixin(GlStateManager.BooleanState.class)
 public interface BooleanStateAccessor {
 	@Accessor("enabled")
 	boolean isEnabled();

File: src/main/java/net/irisshaders/iris/gui/element/ShaderPackSelectionList.java
Patch:
@@ -44,7 +44,7 @@ public class ShaderPackSelectionList extends IrisObjectSelectionList<ShaderPackS
 	private ShaderPackEntry applied = null;
 
 	public ShaderPackSelectionList(ShaderPackScreen screen, Minecraft client, int width, int height, int top, int bottom, int left, int right) {
-		super(client, width, bottom, top, bottom, left, right, 20);
+		super(client, width, bottom, top + 4, bottom, left, right, 20);
 		WatchKey key1;
 		WatchService watcher1;
 
@@ -123,7 +123,7 @@ protected void renderListBackground(GuiGraphics pAbstractSelectionList0) {
 		pAbstractSelectionList0.blit(
 			MENU_LIST_BACKGROUND,
 			this.getX(),
-			this.getY() + 3,
+			this.getY() - 2,
 			(float)this.getRight(),
 			(float)(this.getBottom() + (int)this.getScrollAmount()),
 			this.getWidth(),
@@ -140,7 +140,7 @@ protected void renderListBackground(GuiGraphics pAbstractSelectionList0) {
 	protected void renderListSeparators(GuiGraphics pAbstractSelectionList0) {
 		RenderSystem.enableBlend();
 		RenderSystem.setShaderColor(1.0f, 1.0f, 1.0f, screen.listTransition.getAsFloat());
-		pAbstractSelectionList0.blit(CreateWorldScreen.HEADER_SEPARATOR, this.getX(), this.getY() + 2, 0.0F, 0.0F, this.getWidth(), 2, 32, 2);
+		pAbstractSelectionList0.blit(CreateWorldScreen.HEADER_SEPARATOR, this.getX(), this.getY() - 2, 0.0F, 0.0F, this.getWidth(), 2, 32, 2);
 		pAbstractSelectionList0.blit(CreateWorldScreen.FOOTER_SEPARATOR, this.getX(), this.getBottom(), 0.0F, 0.0F, this.getWidth(), 2, 32, 2);
 		RenderSystem.setShaderColor(1.0f, 1.0f, 1.0f, 1.0f);
 		RenderSystem.disableBlend();

File: src/main/java/net/irisshaders/iris/mixin/devenvironment/MixinMinecraft_NoAuthInDev.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.mojang.authlib.minecraft.UserApiService;
 import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
+import net.fabricmc.loader.api.FabricLoader;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.main.GameConfig;
 import org.slf4j.Logger;
@@ -27,7 +28,5 @@ public class MixinMinecraft_NoAuthInDev {
 
 	@Inject(method = "createUserApiService", at = @At("HEAD"), cancellable = true)
 	private void iris$noSocialInteractionsInDevelopment(YggdrasilAuthenticationService yggdrasilAuthenticationService, GameConfig arg, CallbackInfoReturnable<UserApiService> cir) {
-		LOGGER.info("[Iris] Suppressing Yggdrasil authentication check because this is a development environment");
-		cir.setReturnValue(UserApiService.OFFLINE);
 	}
 }

File: src/main/java/net/irisshaders/iris/mixin/statelisteners/BooleanStateAccessor.java
Patch:
@@ -1,9 +1,10 @@
 package net.irisshaders.iris.mixin.statelisteners;
 
+import com.mojang.blaze3d.platform.GlStateManager;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
 
-@Mixin(targets = "com/mojang/blaze3d/platform/GlStateManager$BooleanState")
+@Mixin(GlStateManager.BooleanState.class)
 public interface BooleanStateAccessor {
 	@Accessor("enabled")
 	boolean isEnabled();

File: src/main/java/net/irisshaders/iris/gl/buffer/ShaderStorageBufferHolder.java
Patch:
@@ -52,7 +52,9 @@ public void hasResizedScreen(int width, int height) {
 			cachedWidth = width;
 			cachedHeight = height;
 			for (ShaderStorageBuffer buffer : buffers) {
-				buffer.resizeIfRelative(width, height);
+				if (buffer != null) {
+					buffer.resizeIfRelative(width, height);
+				}
 			}
 		}
 	}

File: src/main/java/net/irisshaders/iris/gl/buffer/ShaderStorageBuffer.java
Patch:
@@ -12,7 +12,7 @@ public class ShaderStorageBuffer {
 	protected int id;
 
 	public ShaderStorageBuffer(int index, ShaderStorageInfo info) {
-		this.id = GlStateManager._glGenBuffers();
+		this.id = IrisRenderSystem.createBuffers();
 		GLDebug.nameObject(GL43C.GL_BUFFER, id, "SSBO " + index);
 		this.index = index;
 		this.info = info;

File: src/main/java/net/irisshaders/iris/gl/shader/ProgramCreator.java
Patch:
@@ -26,6 +26,8 @@ public static int create(String name, GlShader... shaders) {
 		GlStateManager._glBindAttribLocation(program, 1, "UV0");
 
 		for (GlShader shader : shaders) {
+			GLDebug.nameObject(KHRDebug.GL_SHADER, shader.getHandle(), shader.getName());
+
 			GlStateManager.glAttachShader(program, shader.getHandle());
 		}
 

File: src/sodiumCompatibility/java/net/irisshaders/iris/compat/sodium/mixin/IrisSodiumCompatMixinPlugin.java
Patch:
@@ -24,6 +24,7 @@ public void onLoad(String mixinPackage) {
 			// We can't use Iris' logger here due to classloading issues.
 			System.err.println("[Iris] Invalid/missing version of Sodium detected, disabling compatibility mixins!");
 		}
+
 	}
 
 	@Override

File: src/main/java/net/irisshaders/iris/compat/dh/DHCompatInternal.java
Patch:
@@ -110,7 +110,7 @@ public void createDepthTex(int width, int height) {
 
 		translucentDepthDirty = true;
 
-		depthTexNoTranslucent = new DepthTexture(width, height, DepthBufferFormat.DEPTH32F);
+		depthTexNoTranslucent = new DepthTexture("DH depth tex", width, height, DepthBufferFormat.DEPTH32F);
 	}
 
 	public void renderShadowSolid() {

File: src/main/java/net/irisshaders/iris/gl/buffer/ShaderStorageBuffer.java
Patch:
@@ -1,6 +1,7 @@
 package net.irisshaders.iris.gl.buffer;
 
 import com.mojang.blaze3d.platform.GlStateManager;
+import net.irisshaders.iris.gl.GLDebug;
 import net.irisshaders.iris.gl.IrisRenderSystem;
 import org.lwjgl.opengl.GL43C;
 
@@ -12,6 +13,7 @@ public class ShaderStorageBuffer {
 
 	public ShaderStorageBuffer(int index, ShaderStorageInfo info) {
 		this.id = GlStateManager._glGenBuffers();
+		GLDebug.nameObject(GL43C.GL_BUFFER, id, "SSBO " + index);
 		this.index = index;
 		this.info = info;
 	}

File: src/main/java/net/irisshaders/iris/gl/program/Program.java
Patch:
@@ -29,7 +29,6 @@ public void use() {
 		IrisRenderSystem.memoryBarrier(GL43C.GL_SHADER_IMAGE_ACCESS_BARRIER_BIT | GL43C.GL_TEXTURE_FETCH_BARRIER_BIT | GL43C.GL_SHADER_STORAGE_BARRIER_BIT);
 		ProgramManager.glUseProgram(getGlId());
 
-
 		uniforms.update();
 		samplers.update();
 		images.update();

File: src/main/java/net/irisshaders/iris/shadows/ShadowRenderTargets.java
Patch:
@@ -52,8 +52,8 @@ public ShadowRenderTargets(WorldRenderingPipeline pipeline, int resolution, Pack
 		linearFiltered = new boolean[size];
 		buffersToBeCleared = new IntArrayList();
 
-		this.mainDepth = new DepthTexture(resolution, resolution, DepthBufferFormat.DEPTH);
-		this.noTranslucents = new DepthTexture(resolution, resolution, DepthBufferFormat.DEPTH);
+		this.mainDepth = new DepthTexture("shadowtex0", resolution, resolution, DepthBufferFormat.DEPTH);
+		this.noTranslucents = new DepthTexture("shadowtex1", resolution, resolution, DepthBufferFormat.DEPTH);
 
 		this.ownedFramebuffers = new ArrayList<>();
 		this.resolution = resolution;
@@ -133,6 +133,7 @@ private void create(int index) {
 		PackShadowDirectives.SamplingSettings settings = shadowDirectives.getColorSamplingSettings().computeIfAbsent(index, i -> new PackShadowDirectives.SamplingSettings());
 		targets[index] = RenderTarget.builder().setDimensions(resolution, resolution)
 			.setInternalFormat(settings.getFormat())
+			.setName("shadowcolor" + index)
 			.setPixelFormat(settings.getFormat().getPixelFormat()).build();
 		formats[index] = settings.getFormat();
 		if (settings.getClear()) {

File: src/main/java/net/irisshaders/iris/targets/RenderTargets.java
Patch:
@@ -61,8 +61,8 @@ public RenderTargets(int width, int height, int depthTexture, int depthBufferVer
 
 		this.depthSourceFb = createFramebufferWritingToMain(new int[]{0});
 
-		this.noTranslucents = new DepthTexture(width, height, currentDepthFormat);
-		this.noHand = new DepthTexture(width, height, currentDepthFormat);
+		this.noTranslucents = new DepthTexture("depthtex1", width, height, currentDepthFormat);
+		this.noHand = new DepthTexture("dephtex2", width, height, currentDepthFormat);
 
 		this.noTranslucentsDestFb = createFramebufferWritingToMain(new int[]{0});
 		this.noTranslucentsDestFb.addDepthAttachment(this.noTranslucents.getTextureId());
@@ -123,6 +123,7 @@ private void create(int index) {
 		PackRenderTargetDirectives.RenderTargetSettings settings = targetSettingsMap.get(index);
 		Vector2i dimensions = packDirectives.getTextureScaleOverride(index, cachedWidth, cachedHeight);
 		targets[index] = RenderTarget.builder().setDimensions(dimensions.x, dimensions.y)
+			.setName("colortex" + index)
 			.setInternalFormat(settings.getInternalFormat())
 			.setPixelFormat(settings.getInternalFormat().getPixelFormat()).build();
 	}

File: src/sodiumCompatibility/java/net/irisshaders/iris/compat/sodium/impl/shader_overrides/IrisChunkProgramOverrides.java
Patch:
@@ -10,6 +10,7 @@
 import me.jellysquid.mods.sodium.client.render.chunk.vertex.format.ChunkVertexType;
 import net.irisshaders.iris.Iris;
 import net.irisshaders.iris.compat.sodium.impl.IrisChunkShaderBindingPoints;
+import net.irisshaders.iris.gl.GLDebug;
 import net.irisshaders.iris.gl.blending.AlphaTest;
 import net.irisshaders.iris.gl.blending.AlphaTests;
 import net.irisshaders.iris.gl.blending.BlendModeOverride;
@@ -21,6 +22,7 @@
 import net.minecraft.client.Minecraft;
 import net.minecraft.resources.ResourceLocation;
 import org.jetbrains.annotations.Nullable;
+import org.lwjgl.opengl.GL43C;
 
 import java.util.EnumMap;
 import java.util.List;
@@ -252,7 +254,7 @@ private GlProgram<IrisChunkShaderInterface> createShader(IrisTerrainPass pass, S
 				.link((shader) -> {
 					int handle = ((GlObject) shader).handle();
 					ShaderBindingContextExt contextExt = (ShaderBindingContextExt) shader;
-
+					GLDebug.nameObject(GL43C.GL_PROGRAM, handle, "sodium-terrain-" + pass.toString().toLowerCase(Locale.ROOT));
 					return new IrisChunkShaderInterface(handle, contextExt, pipeline, new ChunkShaderOptions(ChunkFogMode.SMOOTH, pass.toTerrainPass(), vertexType),
 						tessCShader != null || tessEShader != null, pass == IrisTerrainPass.SHADOW || pass == IrisTerrainPass.SHADOW_CUTOUT, blendOverride, bufferOverrides, alpha, pipeline.getCustomUniforms());
 				});

File: src/main/java/net/irisshaders/iris/shadows/ShadowRenderer.java
Patch:
@@ -115,7 +115,7 @@ public ShadowRenderer(ProgramSource shadow, PackDirectives directives,
 		this.shouldRenderEntities = shadowDirectives.shouldRenderEntities();
 		this.shouldRenderPlayer = shadowDirectives.shouldRenderPlayer();
 		this.shouldRenderBlockEntities = shadowDirectives.shouldRenderBlockEntities();
-		this.shouldRenderDH = shadowDirectives.isDhShadowEnabled().orElse(true);
+		this.shouldRenderDH = shadowDirectives.isDhShadowEnabled().orElse(false);
 
 		this.compositeRenderer = compositeRenderer;
 
@@ -339,10 +339,10 @@ private FrustumHolder createShadowFrustum(float renderMultiplier, FrustumHolder
 
 			if (isReversed) {
 				return holder.setInfo(new ReversedAdvancedShadowCullingFrustum(CapturedRenderingState.INSTANCE.getGbufferModelView(),
-					shouldRenderDH ? DHCompat.getProjection() : CapturedRenderingState.INSTANCE.getGbufferProjection(), shadowLightVectorFromOrigin, boxCuller, new BoxCuller(halfPlaneLength * renderMultiplier)), distanceInfo, cullingInfo);
+					(shouldRenderDH && DHCompat.hasRenderingEnabled()) ? DHCompat.getProjection() : CapturedRenderingState.INSTANCE.getGbufferProjection(), shadowLightVectorFromOrigin, boxCuller, new BoxCuller(halfPlaneLength * renderMultiplier)), distanceInfo, cullingInfo);
 			} else {
 				return holder.setInfo(new AdvancedShadowCullingFrustum(CapturedRenderingState.INSTANCE.getGbufferModelView(),
-					shouldRenderDH ? DHCompat.getProjection() : CapturedRenderingState.INSTANCE.getGbufferProjection(), shadowLightVectorFromOrigin, boxCuller), distanceInfo, cullingInfo);
+					(shouldRenderDH  && DHCompat.hasRenderingEnabled()) ? DHCompat.getProjection() : CapturedRenderingState.INSTANCE.getGbufferProjection(), shadowLightVectorFromOrigin, boxCuller), distanceInfo, cullingInfo);
 			}
 		}
 

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/vertex_format/MixinSodiumBufferBuilder.java
Patch:
@@ -128,7 +128,7 @@ public void endBlock() {
 		((BlockSensitiveBufferBuilder) getOriginalBufferBuilder()).endBlock();
 	}
 
-	@Inject(method = "resetAttributeBindings", at = @At("RETURN"))
+	@Inject(method = "resetAttributeBindings", at = @At("RETURN"), remap = false)
 	private void onResetAttributeBindings(CallbackInfo ci) {
 		attributeOffsetTangent = ATTRIBUTE_NOT_PRESENT;
 		attributeOffsetMidTexCoord = ATTRIBUTE_NOT_PRESENT;
@@ -137,7 +137,7 @@ private void onResetAttributeBindings(CallbackInfo ci) {
 		attributeOffsetMidBlock = ATTRIBUTE_NOT_PRESENT;
 	}
 
-	@Inject(method = "updateAttributeBindings", at = @At("RETURN"))
+	@Inject(method = "updateAttributeBindings", at = @At("RETURN"), remap = false)
 	private void onUpdateAttributeBindings(VertexFormatDescription desc, CallbackInfo ci) {
 		if (desc.containsElement(IrisCommonVertexAttributes.TANGENT)) {
 			requiredAttributes |= ATTRIBUTE_TANGENT_BIT;

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -44,7 +44,7 @@
 
 public class Buildscript extends SimpleFabricProject {
 	static final boolean SODIUM = true;
-	static final boolean CUSTOM_SODIUM = true;
+	static final boolean CUSTOM_SODIUM = false;
 	static final String MC_VERSION = "1.20.4";
 	static final String customSodiumName = "sodium-fabric-mc1.20.3-0.5.6git.7a62284.jar";
 
@@ -114,10 +114,10 @@ public void getModDependencies(ModDependencyCollector d) {
 			if (CUSTOM_SODIUM) {
 				d.add(new JavaJarDependency(getProjectDir().resolve("custom_sodium").resolve(customSodiumName).toAbsolutePath(), null, new MavenId("me.jellysquid.mods", "sodium-fabric", customSodiumName.replace("sodium-fabric-", ""))), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 			} else {
-				d.addMaven("https://api.modrinth.com/maven", new MavenId("maven.modrinth", "sodium", "mc1.20.3-0.5.5"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
+				d.addMaven("https://api.modrinth.com/maven", new MavenId("maven.modrinth", "sodium", "mc1.20.4-0.5.8"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 			}
 		} else {
-			d.addMaven("https://api.modrinth.com/maven", new MavenId("maven.modrinth", "sodium", "mc1.20.3-0.5.5"), ModDependencyFlag.COMPILE);
+			d.addMaven("https://api.modrinth.com/maven", new MavenId("maven.modrinth", "sodium", "mc1.20.4-0.5.8"), ModDependencyFlag.COMPILE);
 		}
 	}
 

File: src/main/java/net/coderbot/iris/gui/element/widget/StringElementWidget.java
Patch:
@@ -68,8 +68,8 @@ private void increment(int amount) {
 	@Override
 	protected Component createValueLabel() {
 		return prefix.copy().append(GuiUtil.translateOrDefault(
-				new TextComponent(getValue()),
-				"value." + this.option.getName() + "." + getValue())).append(suffix).withStyle(style -> style.withColor(TextColor.fromRgb(0x6688ff)));
+				new TextComponent(getValue()).append(suffix),
+				"value." + this.option.getName() + "." + getValue())).withStyle(style -> style.withColor(TextColor.fromRgb(0x6688ff)));
 	}
 
 	@Override

File: src/main/java/net/coderbot/iris/uniforms/IrisExclusiveUniforms.java
Patch:
@@ -31,7 +31,7 @@ public static void addIrisExclusiveUniforms(UniformHolder uniforms) {
 		uniforms.uniform1f(UniformUpdateFrequency.PER_FRAME, "thunderStrength", IrisExclusiveUniforms::getThunderStrength);
 		uniforms.uniform1f(UniformUpdateFrequency.PER_TICK, "currentPlayerHealth", IrisExclusiveUniforms::getCurrentHealth);
 		uniforms.uniform1f(UniformUpdateFrequency.PER_TICK, "maxPlayerHealth", IrisExclusiveUniforms::getMaxHealth);
-		uniforms.uniform1f(UniformUpdateFrequency.PER_TICK, "currentPlayerHunger", IrisExclusiveUniforms::getCurrentHunger);	
+		uniforms.uniform1f(UniformUpdateFrequency.PER_TICK, "currentPlayerHunger", IrisExclusiveUniforms::getCurrentHunger);
 		uniforms.uniform1f(UniformUpdateFrequency.PER_TICK, "maxPlayerHunger", () -> 20);
 		uniforms.uniform1f(UniformUpdateFrequency.PER_TICK, "currentPlayerArmor", IrisExclusiveUniforms::getCurrentArmor);
 		uniforms.uniform1f(UniformUpdateFrequency.PER_TICK, "maxPlayerArmor", () -> 50);
@@ -98,7 +98,7 @@ private static float getCurrentArmor() {
 			return -1;
 		}
 
-		return (float) Minecraft.getInstance().player.getArmor() / (float) 50.0);
+		return (float) (Minecraft.getInstance().player.getArmorValue() / 50.0f);
 	}
 
 	private static float getMaxAir() {
@@ -117,7 +117,7 @@ private static float getMaxHealth() {
 		return Minecraft.getInstance().player.getMaxHealth();
 	}
 
-	
+
 
 	private static boolean isFirstPersonCamera() {
 		// If camera type is not explicitly third-person, assume it's first-person.

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -255,7 +255,7 @@ public static void handleKeybinds(Minecraft minecraft) {
 			minecraft.setScreen(new ShaderPackScreen(null));
 		} else if (wireframeKeybind.consumeClick()) {
 			if (irisConfig.areDebugOptionsEnabled() && minecraft.player != null && !Minecraft.getInstance().isLocalServer()) {
-				minecraft.player.displayClientMessage(new TextComponent("No cheating; wireframe only in singleplayer!"), false);
+				minecraft.player.displayClientMessage(Component.literal("No cheating; wireframe only in singleplayer!"), false);
 			}
 		}
 	}

File: src/main/java/net/coderbot/iris/mixin/MixinGlStateManager_DepthColorOverride.java
Patch:
@@ -28,7 +28,7 @@ public class MixinGlStateManager_DepthColorOverride {
 		}
 	}
 
-	@Redirect(method = "_drawElements", at = @At(value = "INVOKE", target = "Lorg/lwjgl/opengl/GL11;glDrawElements(IIIJ)V"))
+	@Redirect(method = "_drawElements", at = @At(value = "INVOKE", target = "Lorg/lwjgl/opengl/GL11;glDrawElements(IIIJ)V"), remap = false)
 	private static void iris$modify(int mode, int count, int type, long indices) {
 		if (mode == GL43C.GL_TRIANGLES && ImmediateState.usingTessellation) {
 			mode = GL43C.GL_PATCHES;
@@ -37,7 +37,7 @@ public class MixinGlStateManager_DepthColorOverride {
 		GL43C.glDrawElements(mode, count, type, indices);
 	}
 
-	@Inject(method = "_glUseProgram", at = @At("TAIL"))
+	@Inject(method = "_glUseProgram", at = @At("TAIL"), remap = false)
 	private static void iris$resetTessellation(int pInt0, CallbackInfo ci) {
 		ImmediateState.usingTessellation = false;
 	}

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/shader_overrides/MixinGlProgram.java
Patch:
@@ -13,7 +13,7 @@
 
 import java.util.function.IntFunction;
 
-@Mixin(GlProgram.class)
+@Mixin(value = GlProgram.class, remap = false)
 public class MixinGlProgram extends GlObject implements ShaderBindingContextExt {
 	public <U extends GlUniform<?>> U bindUniformIfPresent(String name, IntFunction<U> factory) {
 		int index = GlStateManager._glGetUniformLocation(this.handle(), name);

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/CompatibilityTransformer.java
Patch:
@@ -307,7 +307,7 @@ public boolean matchesExtract(ExternalDeclaration tree) {
 		}
 	}
 
-	private static final ShaderType[] pipeline = { ShaderType.VERTEX, ShaderType.GEOMETRY, ShaderType.FRAGMENT };
+	private static final ShaderType[] pipeline = { ShaderType.VERTEX, ShaderType.TESSELATION_CONTROL, ShaderType.TESSELATION_EVAL, ShaderType.GEOMETRY, ShaderType.FRAGMENT };
 	private static final Matcher<ExternalDeclaration> outDeclarationMatcher = new DeclarationMatcher(
 			StorageType.OUT);
 	private static final Matcher<ExternalDeclaration> inDeclarationMatcher = new DeclarationMatcher(

File: src/main/java/net/coderbot/iris/pipeline/newshader/FakeChainedJsonException.java
Patch:
@@ -7,7 +7,7 @@ public class FakeChainedJsonException extends ChainedJsonException {
 	private final ShaderCompileException trueException;
 
 	public FakeChainedJsonException(ShaderCompileException e) {
-		super("");
+		super("", e);
 		this.trueException = e;
 	}
 

File: src/main/java/net/coderbot/iris/mixin/MixinLevelRenderer.java
Patch:
@@ -6,6 +6,7 @@
 import com.mojang.math.Vector3f;
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.fantastic.WrappingMultiBufferSource;
+import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.gl.program.Program;
 import net.coderbot.iris.layer.IsOutlineRenderStateShard;
 import net.coderbot.iris.layer.OuterWrappedRenderType;
@@ -89,7 +90,7 @@ public class MixinLevelRenderer {
 		}
 
 		if (Iris.shouldActivateWireframe() && this.minecraft.isLocalServer()) {
-			GL43C.glPolygonMode(GL43C.GL_FRONT_AND_BACK, GL43C.GL_LINE);
+			IrisRenderSystem.setPolygonMode(GL43C.GL_LINE);
 		}
 	}
 
@@ -116,7 +117,7 @@ public class MixinLevelRenderer {
 		pipeline = null;
 
 		if (Iris.shouldActivateWireframe() && this.minecraft.isLocalServer()) {
-			GL43C.glPolygonMode(GL43C.GL_FRONT_AND_BACK, GL43C.GL_FILL);
+			IrisRenderSystem.setPolygonMode(GL43C.GL_FILL);
 		}
 	}
 

File: src/main/java/net/coderbot/iris/postprocess/FullScreenQuadRenderer.java
Patch:
@@ -7,6 +7,7 @@
 import com.mojang.blaze3d.vertex.VertexBuffer;
 import com.mojang.blaze3d.vertex.VertexFormat;
 import net.coderbot.iris.fantastic.VertexBufferHelper;
+import net.coderbot.iris.gl.IrisRenderSystem;
 import org.lwjgl.opengl.GL11;
 
 import org.lwjgl.opengl.GL20C;
@@ -51,7 +52,9 @@ public void begin() {
 	}
 
 	public void renderQuad() {
+		IrisRenderSystem.overridePolygonMode();
 		quad.drawChunkLayer();
+		IrisRenderSystem.restorePolygonMode();
 	}
 
 	public void end() {

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/AttributeTransformer.java
Patch:
@@ -173,12 +173,12 @@ public static void patchOverlayColor(
 
 			// TODO: this is passthrough behavior
 			tree.parseAndInjectNodes(t, ASTInjectionPoint.BEFORE_DECLARATIONS,
-				"patch out vec4 entityColorTCS[];",
+				"patch out vec4 entityColorTCS;",
 				"in vec4 entityColor[];",
 				"out vec4 iris_vertexColorTCS[];",
 				"in vec4 iris_vertexColor[];");
 			tree.prependMainFunctionBody(t,
-				"entityColorTCS[gl_InvocationID] = entityColor[gl_InvocationID];",
+				"entityColorTCS = entityColor[gl_InvocationID];",
 				"iris_vertexColorTCS[gl_InvocationID] = iris_vertexColor[gl_InvocationID];");
 		} else if (parameters.type.glShaderType == ShaderType.TESSELATION_EVAL) {
 			// replace read references to grab the color from the first vertex.

File: src/main/java/net/coderbot/iris/pipeline/transform/TransformPatcher.java
Patch:
@@ -390,7 +390,7 @@ public static Map<PatchShaderType, String> patchVanilla(
 			ShaderAttributeInputs inputs,
 			Object2ObjectMap<Tri<String, TextureType, TextureStage>, String> textureMap) {
 		return transform(vertex, geometry, tessControl, tessEval, fragment,
-				new VanillaParameters(Patch.VANILLA, textureMap, alpha, isLines, hasChunkOffset, inputs, geometry != null));
+				new VanillaParameters(Patch.VANILLA, textureMap, alpha, isLines, hasChunkOffset, inputs, geometry != null, tessControl != null || tessEval != null));
 	}
 
 	public static Map<PatchShaderType, String> patchSodium(String vertex, String geometry, String tessControl, String tessEval, String fragment,

File: src/main/java/net/coderbot/iris/pipeline/transform/parameter/AttributeParameters.java
Patch:
@@ -15,7 +15,7 @@ public AttributeParameters(Patch patch,
 			Object2ObjectMap<Tri<String, TextureType, TextureStage>, String> textureMap,
 			boolean hasGeometry,
 			InputAvailability inputs) {
-		super(patch, textureMap, hasGeometry);
+		super(patch, textureMap, hasGeometry, false);
 		this.inputs = inputs;
 	}
 

File: src/main/java/net/coderbot/iris/pipeline/transform/parameter/GeometryInfoParameters.java
Patch:
@@ -8,12 +8,14 @@
 
 public abstract class GeometryInfoParameters extends Parameters {
 	public final boolean hasGeometry;
+	public final boolean hasTesselation;
 	// WARNING: adding new fields requires updating hashCode and equals methods!
 
 	public GeometryInfoParameters(Patch patch,
-			Object2ObjectMap<Tri<String, TextureType, TextureStage>, String> textureMap, boolean hasGeometry) {
+			Object2ObjectMap<Tri<String, TextureType, TextureStage>, String> textureMap, boolean hasGeometry, boolean hasTesselation) {
 		super(patch, textureMap);
 		this.hasGeometry = hasGeometry;
+		this.hasTesselation = hasTesselation;
 	}
 
 	@Override

File: src/main/java/net/coderbot/iris/pipeline/transform/parameter/VanillaParameters.java
Patch:
@@ -19,8 +19,8 @@ public VanillaParameters(
 			Patch patch,
 			Object2ObjectMap<Tri<String, TextureType, TextureStage>, String> textureMap,
 			AlphaTest alpha, boolean isLines, boolean hasChunkOffset,
-			ShaderAttributeInputs inputs, boolean hasGeometry) {
-		super(patch, textureMap, hasGeometry);
+			ShaderAttributeInputs inputs, boolean hasGeometry, boolean hasTesselation) {
+		super(patch, textureMap, hasGeometry, hasTesselation);
 		this.alpha = alpha;
 		this.isLines = isLines;
 		this.hasChunkOffset = hasChunkOffset;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/options/IrisSodiumOptions.java
Patch:
@@ -66,7 +66,7 @@ public static OptionImpl<Options, ColorSpace> createColorSpaceButton(MinecraftOp
 
 	static ControlValueFormatter translateVariableOrDisabled(String key, String disabled) {
 		return (v) -> {
-			return v == 0 ? disabled : (Component.translatable(key, v)).getString();
+			return v == 0 ? Component.literal(disabled) : (Component.translatable(key, v));
 		};
 	}
 

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -46,7 +46,7 @@ public class Buildscript extends SimpleFabricProject {
 	static final boolean SODIUM = true;
 	static final boolean CUSTOM_SODIUM = true;
 	static final String MC_VERSION = "1.20.2";
-	static final String customSodiumName = "sodium-fabric-mc1.20.2-0.5.3+git.e228d59.jar";
+	static final String customSodiumName = "sodium-fabric-mc1.20.2-0.5.3+git.43e53c4.jar";
 
 	private static final String[] SOURCE_SETS = new String[] {
 		"main",

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPipeline.java
Patch:
@@ -45,6 +45,7 @@ public interface WorldRenderingPipeline {
 
 	void beginTranslucents();
 	void finalizeLevelRendering();
+	void finalizeGameRendering();
 	void destroy();
 
 	SodiumTerrainPipeline getSodiumTerrainPipeline();

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -101,7 +101,7 @@ public void getModDependencies(ModDependencyCollector d) {
 
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:2.0.0-pre13"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.antlr:antlr4-runtime:4.11.1"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
-		d.addMaven("https://api.modrinth.com/maven", new MavenId("maven.modrinth", "distanthorizons", "2.0.0-a-1.19.2"), ModDependencyFlag.COMPILE);
+		d.addMaven("https://api.modrinth.com/maven", new MavenId("maven.modrinth", "distanthorizons", "2.0.0-a-1.19.4"), ModDependencyFlag.COMPILE);
 
 		if (SODIUM) {
 			d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-api-base", "0.4.17+93d8cb8253"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);

File: src/main/java/net/coderbot/iris/gui/element/ShaderPackOptionList.java
Patch:
@@ -47,7 +47,7 @@ public class ShaderPackOptionList extends IrisContainerObjectSelectionList<Shade
 	private OptionMenuContainer container;
 
 	public ShaderPackOptionList(ShaderPackScreen screen, NavigationController navigation, ShaderPack pack, Minecraft client, int width, int height, int top, int bottom, int left, int right) {
-		super(client, width, height, top, bottom, left, right, 24);
+		super(client, width, bottom, top, bottom, left, right, 24);
 		this.navigation = navigation;
 		this.screen = screen;
 		this.setRenderBackground(false);
@@ -61,7 +61,7 @@ protected void renderDecorations(GuiGraphics pAbstractSelectionList0, int pInt1,
 		int lvInt9 = 32;
 		pAbstractSelectionList0.setColor(0.25F, 0.25F, 0.25F, 1.0F);
 		pAbstractSelectionList0.blit(Screen.BACKGROUND_LOCATION, this.getX(), 0, 0.0F, 0.0F, this.width, this.getY(), 32, 32);
-		pAbstractSelectionList0.blit(Screen.BACKGROUND_LOCATION, this.getX(), this.getBottom(), 0.0F, (float)this.getBottom(), this.width, this.height - this.getBottom(), 32, 32);
+		pAbstractSelectionList0.blit(Screen.BACKGROUND_LOCATION, this.getX(), this.getBottom(), 0.0F, 0.0F, this.width, this.height, 32, 32);
 		pAbstractSelectionList0.setColor(1.0F, 1.0F, 1.0F, 1.0F);
 		int lvInt10 = 4;
 		pAbstractSelectionList0.fillGradient(RenderType.guiOverlay(), this.getX(), this.getY(), this.getRight(), this.getY() + 4, -16777216, 0, 0);

File: src/main/java/net/coderbot/iris/gui/screen/ShaderPackScreen.java
Patch:
@@ -213,12 +213,12 @@ protected void init() {
 		this.removeWidget(this.shaderPackList);
 		this.removeWidget(this.shaderOptionList);
 
-		this.shaderPackList = new ShaderPackSelectionList(this, this.minecraft, this.width, this.height, 32, this.height - 58, 0, this.width);
+		this.shaderPackList = new ShaderPackSelectionList(this, this.minecraft, this.width, this.height, 32, this.height - 58 - 32, 0, this.width);
 
 		if (Iris.getCurrentPack().isPresent() && this.navigation != null) {
 			ShaderPack currentPack = Iris.getCurrentPack().get();
 
-			this.shaderOptionList = new ShaderPackOptionList(this, this.navigation, currentPack, this.minecraft, this.width, this.height, 32, this.height - 58, 0, this.width);
+			this.shaderOptionList = new ShaderPackOptionList(this, this.navigation, currentPack, this.minecraft, this.width, this.height, 32, this.height - 58-32, 0, this.width);
 			this.navigation.setActiveOptionList(this.shaderOptionList);
 
 			this.shaderOptionList.rebuild();

File: src/main/java/net/coderbot/iris/shaderpack/ShaderProperties.java
Patch:
@@ -113,7 +113,7 @@ private ShaderProperties() {
 	// TODO: Is there a better solution than having ShaderPack pass a root path to ShaderProperties to be able to read textures?
 	public ShaderProperties(String contents, ShaderPackOptions shaderPackOptions, Iterable<StringPair> environmentDefines, Iterable<StringPair> replacements) {
 		for (StringPair pair : replacements) {
-			contents = contents.replace(pair.getKey(), pair.getValue());
+			contents = contents.replaceAll("\\b" + pair.getKey() + "\\b", pair.getValue());
 		}
 
 		String preprocessedContents = PropertiesPreprocessor.preprocessSource(contents, shaderPackOptions, environmentDefines);

File: src/main/java/net/coderbot/iris/uniforms/custom/CustomUniforms.java
Patch:
@@ -306,7 +306,7 @@ public void addVariable(String type, String name, String expression, boolean isU
 				ExpressionElement ast = Parser.parse(expression, IrisOptions.options);
 				variables.put(name, new Variable(parsedType, name, ast, isUniform));
 			} catch (Exception e) {
-				Iris.logger.warn("Failed to parse custom variable/uniform", e);
+				Iris.logger.warn("Failed to parse custom variable/uniform " + name + " with expression " + expression, e);
 			}
 		}
 

File: src/main/java/net/coderbot/iris/compat/dh/mixin/MixinDHApplyShader.java
Patch:
@@ -11,7 +11,7 @@
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Redirect;
 
-@Mixin(DhApplyShader.class)
+@Mixin(value = DhApplyShader.class, remap = false)
 public class MixinDHApplyShader {
 	@Redirect(method = "onRender", at = @At(value = "INVOKE", target = "Lcom/seibel/distanthorizons/core/wrapperInterfaces/minecraft/IMinecraftRenderWrapper;getTargetFrameBuffer()I"))
 	private int changeFB(IMinecraftRenderWrapper instance) {

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -37,7 +37,6 @@
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.world.level.dimension.BuiltinDimensionTypes;
 import net.minecraft.world.level.dimension.DimensionType;
-import net.minecraft.network.chat.TranslatableComponent;
 import org.jetbrains.annotations.NotNull;
 import org.lwjgl.glfw.GLFW;
 

File: src/main/java/net/coderbot/iris/shaderpack/IrisDefines.java
Patch:
@@ -3,6 +3,7 @@
 import com.google.common.collect.ImmutableList;
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.gl.shader.StandardMacros;
+import net.coderbot.iris.parsing.BiomeCategories;
 import net.coderbot.iris.uniforms.BiomeParameters;
 import net.minecraft.world.level.biome.Biome;
 
@@ -31,9 +32,9 @@ public static ImmutableList<StringPair> createIrisReplacements() {
 
 		BiomeParameters.getBiomeMap().forEach((biome, id) -> define(s, "BIOME_" + biome.location().getPath().toUpperCase(Locale.ROOT), String.valueOf(id)));
 
-		Biome.BiomeCategory[] categories = Biome.BiomeCategory.values();
+		BiomeCategories[] categories = BiomeCategories.values();
 		for (int i = 0; i < categories.length; i++) {
-            define(s, "CAT_" + categories[i].getName().toUpperCase(Locale.ROOT), String.valueOf(i));
+            define(s, "CAT_" + categories[i].name().toUpperCase(Locale.ROOT), String.valueOf(i));
 		}
 
 		return ImmutableList.copyOf(s);

File: src/main/java/net/coderbot/iris/samplers/IrisImages.java
Patch:
@@ -23,6 +23,8 @@ public static void addRenderTargetImages(ImageHolder images, Supplier<ImmutableS
 
 			if (!images.hasImage(name)) continue;
 
+			renderTargets.createIfUnsure(index);
+
 			// Note: image bindings *are* impacted by buffer flips.
 			IntSupplier textureID = () -> {
 				ImmutableSet<Integer> flippedBuffers = flipped.get();

File: src/main/java/kroppeb/stareval/function/Type.java
Patch:
@@ -178,6 +178,7 @@ public static UniformType convert(Type type) {
 		else if (type == VectorType.VEC3) return UniformType.VEC3;
 		else if (type == VectorType.VEC4) return UniformType.VEC4;
 		else if (type == VectorType.I_VEC2) return UniformType.VEC2I;
+		else if (type == VectorType.I_VEC3) return UniformType.VEC3I;
 		else if (type == MatrixType.MAT4) return UniformType.MAT4;
 		else throw new IllegalArgumentException("Unsupported custom uniform type: " + type);
 	}

File: src/main/java/net/coderbot/batchedentityrendering/mixin/MixinBufferBuilder.java
Patch:
@@ -25,7 +25,8 @@ public int getUsedSize() {
 
 	@Override
 	public void freeAndDeleteBuffer() {
-		MemoryUtil.memFree(buffer);
+		if (buffer == null) return;
+		MemoryUtil.getAllocator(false).free(MemoryUtil.memAddress(buffer));
 		buffer = null;
 	}
 }

File: src/main/java/net/coderbot/iris/gl/program/ProgramUniforms.java
Patch:
@@ -322,7 +322,7 @@ private static UniformType getExpectedType(int type) {
 		} else if (type == GL20C.GL_FLOAT_VEC3) {
 			return UniformType.VEC3;
 		} else if (type == GL20C.GL_INT_VEC3) {
-			return null;
+			return UniformType.VEC3I;
 		} else if (type == GL20C.GL_FLOAT_MAT2) {
 			return null;
 		} else if (type == GL20C.GL_FLOAT_VEC2) {

File: src/main/java/net/coderbot/iris/gl/uniform/UniformHolder.java
Patch:
@@ -5,6 +5,7 @@
 import org.joml.Vector2i;
 import org.joml.Vector3d;
 import org.joml.Vector3f;
+import org.joml.Vector3i;
 import org.joml.Vector4f;
 
 import java.util.function.BooleanSupplier;
@@ -28,6 +29,7 @@ public interface UniformHolder {
 	UniformHolder uniform2i(UniformUpdateFrequency updateFrequency, String name, Supplier<Vector2i> value);
 
 	UniformHolder uniform3f(UniformUpdateFrequency updateFrequency, String name, Supplier<Vector3f> value);
+	UniformHolder uniform3i(UniformUpdateFrequency updateFrequency, String name, Supplier<Vector3i> value);
 
 	UniformHolder uniformTruncated3f(UniformUpdateFrequency updateFrequency, String name, Supplier<Vector4f> value);
 

File: src/main/java/net/coderbot/iris/gl/uniform/UniformType.java
Patch:
@@ -8,6 +8,7 @@ public enum UniformType {
 	VEC2,
 	VEC2I,
 	VEC3,
+	VEC3I,
 	VEC4,
 	VEC4I
 }

File: src/main/java/net/coderbot/iris/mixin/MixinLevelRenderer.java
Patch:
@@ -15,6 +15,7 @@
 import net.coderbot.iris.pipeline.WorldRenderingPipeline;
 import net.coderbot.iris.shadows.frustum.fallback.NonCullingFrustum;
 import net.coderbot.iris.uniforms.CapturedRenderingState;
+import net.coderbot.iris.uniforms.IrisTimeUniforms;
 import net.coderbot.iris.uniforms.SystemTimeUniforms;
 import org.joml.Vector3d;
 import net.fabricmc.api.EnvType;
@@ -81,6 +82,7 @@ public class MixinLevelRenderer {
 				" didn't work. This is a bug! Please report it to the Iris developers.");
 		}
 
+		IrisTimeUniforms.updateTime();
 		CapturedRenderingState.INSTANCE.setGbufferModelView(poseStack.last().pose());
 		CapturedRenderingState.INSTANCE.setGbufferProjection(projection);
 		CapturedRenderingState.INSTANCE.setTickDelta(tickDelta);

File: src/main/java/net/coderbot/iris/pipeline/transform/TransformPatcher.java
Patch:
@@ -226,6 +226,7 @@ public TranslationUnit parseTranslationUnit(Root rootInstance, String input) {
 						default:
 							// handling of Optifine's special core profile mode
 							boolean isLine = (parameters.patch == Patch.VANILLA && ((VanillaParameters) parameters).isLines());
+
 							if (profile == Profile.CORE || version.number >= 150 && profile == null || isLine) {
 								// patch the version number to at least 330
 								if (version.number < 330) {

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -113,6 +113,7 @@ public static void addNonDynamicUniforms(UniformHolder uniforms, IdMap idMap, Pa
 		BiomeParameters.addBiomeUniforms(uniforms);
 		new CelestialUniforms(directives.getSunPathRotation()).addCelestialUniforms(uniforms);
 		IrisExclusiveUniforms.addIrisExclusiveUniforms(uniforms);
+		IrisTimeUniforms.addTimeUniforms(uniforms);
 		MatrixUniforms.addMatrixUniforms(uniforms, directives);
 		IdMapUniforms.addIdMapUniforms(updateNotifier, uniforms, idMap, directives.isOldHandLight());
 		CommonUniforms.generalCommonUniforms(uniforms, updateNotifier, directives);

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -107,7 +107,7 @@ public void getModDependencies(ModDependencyCollector d) {
 			d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-rendering-data-attachment-v1", "0.3.21+12bfe4ea53"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 			d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-block-view-api-v2", "1.0.0+92a0d36777"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 			d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-rendering-fluids-v1", "3.0.13+fbde993d53"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
-			d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-resource-loader-v0", "0.11.12+2148f3b9cb"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
+			d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-resource-loader-v0", "0.11.14+f31bf881a9"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 			d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-block-view-api-v2", "1.0.0+73761d2e99"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 
 			if (CUSTOM_SODIUM) {

File: src/main/java/net/coderbot/iris/mixin/MixinGameRenderer.java
Patch:
@@ -178,7 +178,6 @@ public class MixinGameRenderer {
 
 	@Inject(method = {
 			"getRendertypeEntityCutoutShader",
-			"getRendertypeBreezeWindShader",
 			"getRendertypeEntityCutoutNoCullShader",
 			"getRendertypeEntityCutoutNoCullZOffsetShader",
 			"getRendertypeEntityDecalShader",
@@ -201,6 +200,7 @@ public class MixinGameRenderer {
 		"getRendertypeEntityTranslucentShader",
 		"getRendertypeEntityTranslucentCullShader",
 		"getRendertypeItemEntityTranslucentCullShader",
+		"getRendertypeBreezeWindShader",
 		"getRendertypeEntityNoOutlineShader"
 	}, at = @At("HEAD"), cancellable = true)
 	private static void iris$overrideEntityTranslucentShader(CallbackInfoReturnable<ShaderInstance> cir) {

File: src/main/java/net/coderbot/batchedentityrendering/mixin/MixinBufferBuilder.java
Patch:
@@ -25,6 +25,7 @@ public int getUsedSize() {
 
 	@Override
 	public void freeAndDeleteBuffer() {
+		if (buffer == null) return;
 		MemoryUtil.getAllocator(false).free(MemoryUtil.memAddress(buffer));
 		buffer = null;
 	}

File: src/main/java/net/coderbot/batchedentityrendering/mixin/MixinBufferBuilder.java
Patch:
@@ -25,7 +25,7 @@ public int getUsedSize() {
 
 	@Override
 	public void freeAndDeleteBuffer() {
-		MemoryUtil.memFree(buffer);
+		MemoryUtil.getAllocator(false).free(MemoryUtil.memAddress(buffer));
 		buffer = null;
 	}
 }

File: src/main/java/net/coderbot/iris/uniforms/BiomeParameters.java
Patch:
@@ -10,7 +10,6 @@
 import net.minecraft.client.player.LocalPlayer;
 import net.minecraft.core.Holder;
 import net.minecraft.resources.ResourceKey;
-import net.minecraft.data.BuiltinRegistries;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.tags.BiomeTags;

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -71,7 +71,7 @@ public MappingTree createMappings() {
 
 	@Override
 	public FabricLoader getLoader() {
-		return new FabricLoader(FabricMaven.URL, FabricMaven.loader("0.14.10"));
+		return new FabricLoader(FabricMaven.URL, FabricMaven.loader("0.14.22"));
 	}
 
 	@Override

File: src/main/java/net/coderbot/iris/uniforms/BiomeParameters.java
Patch:
@@ -10,6 +10,7 @@
 import net.minecraft.client.player.LocalPlayer;
 import net.minecraft.core.Holder;
 import net.minecraft.data.BuiltinRegistries;
+import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.tags.BiomeTags;
 import net.minecraft.world.level.biome.Biome;

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -340,7 +340,7 @@ private FrustumHolder createShadowFrustum(float renderMultiplier, FrustumHolder
 
 			if (isReversed) {
 				return holder.setInfo(new ReversedAdvancedShadowCullingFrustum(((Matrix4fAccess) (Object) CapturedRenderingState.INSTANCE.getGbufferModelView()).convertToJOML(),
-					((Matrix4fAccess) (Object) CapturedRenderingState.INSTANCE.getGbufferProjection()).convertToJOML(), shadowLightVectorFromOrigin, boxCuller), distanceInfo, cullingInfo);
+					((Matrix4fAccess) (Object) CapturedRenderingState.INSTANCE.getGbufferProjection()).convertToJOML(), shadowLightVectorFromOrigin, boxCuller, new BoxCuller(halfPlaneLength * renderMultiplier)), distanceInfo, cullingInfo);
 			} else {
 				return holder.setInfo(new AdvancedShadowCullingFrustum(((Matrix4fAccess) (Object) CapturedRenderingState.INSTANCE.getGbufferModelView()).convertToJOML(),
 					((Matrix4fAccess) (Object) CapturedRenderingState.INSTANCE.getGbufferProjection()).convertToJOML(), shadowLightVectorFromOrigin, boxCuller), distanceInfo, cullingInfo);

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/VanillaTransformer.java
Patch:
@@ -18,9 +18,9 @@ public static void transform(
 		// this happens before common to make sure the renaming of attributes is done on
 		// attribute inserted by this
 		if (parameters.inputs.hasOverlay()) {
-			if (!parameters.inputs.isText()) {
-				AttributeTransformer.patchOverlayColor(t, tree, root, parameters);
-			}
+			AttributeTransformer.patchOverlayColor(t, tree, root, parameters);
+			AttributeTransformer.patchEntityId(t, tree, root, parameters);
+		} else if (parameters.inputs.isText()) {
 			AttributeTransformer.patchEntityId(t, tree, root, parameters);
 		}
 

File: src/main/java/net/coderbot/iris/pipeline/newshader/ShaderKey.java
Patch:
@@ -37,8 +37,8 @@ public enum ShaderKey {
 	HAND_CUTOUT            (ProgramId.Hand,        AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	HAND_CUTOUT_BRIGHT     (ProgramId.Hand,        AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.FULLBRIGHT),
 	HAND_CUTOUT_DIFFUSE    (ProgramId.Hand,        AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.DIFFUSE_LM),
-	HAND_TEXT              (ProgramId.Hand,        AlphaTests.NON_ZERO_ALPHA,  IrisVertexFormats.ENTITY                       , FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
-	HAND_TEXT_INTENSITY    (ProgramId.Hand,        AlphaTests.NON_ZERO_ALPHA,  IrisVertexFormats.ENTITY                       , FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
+	HAND_TEXT              (ProgramId.Hand,        AlphaTests.NON_ZERO_ALPHA,  IrisVertexFormats.GLYPH                       , FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
+	HAND_TEXT_INTENSITY    (ProgramId.Hand,        AlphaTests.NON_ZERO_ALPHA,  IrisVertexFormats.GLYPH                       , FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	HAND_TRANSLUCENT       (ProgramId.HandWater,   AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	HAND_WATER_BRIGHT      (ProgramId.HandWater,   AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.FULLBRIGHT),
 	HAND_WATER_DIFFUSE     (ProgramId.HandWater,   AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.DIFFUSE_LM),

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -71,7 +71,7 @@ public MappingTree createMappings() {
 
 	@Override
 	public FabricLoader getLoader() {
-		return new FabricLoader(FabricMaven.URL, FabricMaven.loader("0.14.17"));
+		return new FabricLoader(FabricMaven.URL, FabricMaven.loader("0.14.21"));
 	}
 
 	@Override

File: src/main/java/net/coderbot/iris/pipeline/SodiumTerrainPipeline.java
Patch:
@@ -162,7 +162,7 @@ void main() {
 		    // Transform the vertex position into model-view-projection space
 		    gl_Position = iris_ProjectionMatrix * iris_ModelViewMatrix * vec4(position, 1.0);
 
-		    v_ColorModulator = _vert_color * vec4(_sample_lightmap(_vert_tex_light_coord), 1.0);
+		    v_ColorModulator = vec4((_vert_color.rgb * _vert_color.a), 1) * vec4(_sample_lightmap(_vert_tex_light_coord), 1.0);
 		    v_TexCoord = _vert_tex_diffuse_coord;
 
 		    v_MaterialMipBias = _material_mip_bias(_material_params);

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -46,7 +46,7 @@ public class Buildscript extends SimpleFabricProject {
 	static final boolean SODIUM = true;
 	static final boolean CUSTOM_SODIUM = true;
 	static final String MC_VERSION = "1.20.2-pre2";
-	static final String customSodiumName = "sodium-fabric-mc1.20.2-pre1-0.5.2+git.d9371a4-dirty.jar";
+	static final String customSodiumName = "sodium-fabric-mc1.20.2-pre1-0.5.2+git.a275424.jar";
 
 	private static final String[] SOURCE_SETS = new String[] {
 		"main",

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/clouds/MixinCloudRenderer.java
Patch:
@@ -42,7 +42,7 @@ public abstract class MixinCloudRenderer {
 	protected abstract void rebuildGeometry(BufferBuilder bufferBuilder, int cloudDistance, int centerCellX, int centerCellZ);
 
 	@Shadow
-	private ShaderInstance clouds;
+	private ShaderInstance shader;
 
 	@Shadow
 	protected abstract void applyFogModifiers(ClientLevel world, FogRenderer.FogData fogData, LocalPlayer player, int cloudDistance, float tickDelta);
@@ -198,6 +198,6 @@ private ShaderInstance getClouds() {
 			return ((CoreWorldRenderingPipeline) pipeline).getShaderMap().getShader(ShaderKey.CLOUDS_SODIUM);
 		}
 
-		return clouds;
+		return shader;
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/LevelRendererAccessor.java
Patch:
@@ -1,7 +1,6 @@
 package net.coderbot.iris.mixin;
 
 import com.mojang.blaze3d.vertex.PoseStack;
-import it.unimi.dsi.fastutil.objects.ObjectList;
 import net.minecraft.client.Camera;
 import net.minecraft.client.multiplayer.ClientLevel;
 import net.minecraft.client.renderer.LevelRenderer;
@@ -21,8 +20,8 @@ public interface LevelRendererAccessor {
 	@Accessor("entityRenderDispatcher")
 	EntityRenderDispatcher getEntityRenderDispatcher();
 
-	@Invoker("renderChunkLayer")
-	void invokeRenderChunkLayer(RenderType terrainLayer, PoseStack modelView, double cameraX, double cameraY, double cameraZ, Matrix4f projectionMatrix);
+	@Invoker("renderSectionLayer")
+	void invokeRenderSectionLayer(RenderType terrainLayer, PoseStack modelView, double cameraX, double cameraY, double cameraZ, Matrix4f projectionMatrix);
 
 	@Invoker("setupRender")
 	void invokeSetupRender(Camera camera, Frustum frustum, boolean hasForcedFrustum, boolean spectator);

File: src/main/java/net/coderbot/iris/mixin/MixinLevelRenderer.java
Patch:
@@ -198,12 +198,12 @@ public class MixinLevelRenderer {
 	}
 
 
-	@Inject(method = "renderChunkLayer", at = @At("HEAD"))
+	@Inject(method = "renderSectionLayer", at = @At("HEAD"))
 	private void iris$beginTerrainLayer(RenderType renderType, PoseStack poseStack, double d, double e, double f, Matrix4f projectionMatrix, CallbackInfo ci) {
 		pipeline.setPhase(WorldRenderingPhase.fromTerrainRenderType(renderType));
 	}
 
-	@Inject(method = "renderChunkLayer", at = @At("RETURN"))
+	@Inject(method = "renderSectionLayer", at = @At("RETURN"))
 	private void iris$endTerrainLayer(RenderType renderType, PoseStack poseStack, double d, double e, double f, Matrix4f projectionMatrix, CallbackInfo ci) {
 		pipeline.setPhase(WorldRenderingPhase.NONE);
 	}

File: src/main/java/net/coderbot/iris/mixin/MixinMinecraft_PipelineManagement.java
Patch:
@@ -18,7 +18,7 @@ public class MixinMinecraft_PipelineManagement {
 	/**
 	 * Should run before the Minecraft.level field is updated after disconnecting from a server or leaving a singleplayer world
 	 */
-	@Inject(method = "clearLevel(Lnet/minecraft/client/gui/screens/Screen;)V", at = @At("HEAD"))
+	@Inject(method = "clearClientLevel", at = @At("HEAD"))
 	public void iris$trackLastDimensionOnLeave(Screen arg, CallbackInfo ci) {
 		Iris.lastDimension = Iris.getCurrentDimension();
 	}

File: src/main/java/net/coderbot/iris/mixin/entity_render_context/MixinCapeLayer.java
Patch:
@@ -7,6 +7,7 @@
 import net.minecraft.client.player.AbstractClientPlayer;
 import net.minecraft.client.renderer.MultiBufferSource;
 import net.minecraft.client.renderer.entity.layers.CapeLayer;
+import net.minecraft.client.resources.PlayerSkin;
 import net.minecraft.core.Registry;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.world.item.ItemStack;
@@ -22,7 +23,7 @@ public class MixinCapeLayer {
     private static final NamespacedId CAPE_LOCATION = new NamespacedId("minecraft", "player_cape");
 
     @Inject(method = "render(Lcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/client/renderer/MultiBufferSource;ILnet/minecraft/client/player/AbstractClientPlayer;FFFFFF)V", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/vertex/PoseStack;pushPose()V"), locals = LocalCapture.CAPTURE_FAILHARD)
-    private void changeId(PoseStack pCapeLayer0, MultiBufferSource pMultiBufferSource1, int pInt2, AbstractClientPlayer pAbstractClientPlayer3, float pFloat4, float pFloat5, float pFloat6, float pFloat7, float pFloat8, float pFloat9, CallbackInfo ci, ItemStack lvItemStack11) {
+    private void changeId(PoseStack pCapeLayer0, MultiBufferSource pMultiBufferSource1, int pInt2, AbstractClientPlayer pAbstractClientPlayer3, float pFloat4, float pFloat5, float pFloat6, float pFloat7, float pFloat8, float pFloat9, CallbackInfo ci, PlayerSkin lvPlayerSkin11, ItemStack lvItemStack12) {
         if (BlockRenderingSettings.INSTANCE.getItemIds() == null) return;
 
         CapturedRenderingState.INSTANCE.setCurrentRenderedItem(BlockRenderingSettings.INSTANCE.getItemIds().applyAsInt(CAPE_LOCATION));

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -1051,6 +1051,8 @@ public OptionalInt getForcedShadowRenderDistanceChunksForDisplay() {
 
 	@Override
 	public void beginHand() {
+		centerDepthSampler.sampleCenterDepth();
+
 		// We need to copy the current depth texture so that depthtex2 can contain the depth values for
 		// all non-translucent content excluding the hand, as required.
 		renderTargets.copyPreHandDepth();
@@ -1088,7 +1090,6 @@ public void beginTranslucents() {
 	@Override
 	public void finalizeLevelRendering() {
 		isRenderingWorld = false;
-		centerDepthSampler.sampleCenterDepth();
 		compositeRenderer.renderAll();
 		finalPassRenderer.renderFinalPass();
 		colorSpaceConverter.process(Minecraft.getInstance().getMainRenderTarget().getColorTextureId());

File: src/main/java/net/coderbot/iris/pipeline/SodiumTerrainPipeline.java
Patch:
@@ -124,7 +124,7 @@ public SodiumTerrainPipeline(WorldRenderingPipeline parent, ProgramSet programSe
 
 	private static final Supplier<Optional<AlphaTest>> terrainCutoutDefault = () -> Optional.of(AlphaTests.ONE_TENTH_ALPHA);
 	private static final Supplier<Optional<AlphaTest>> translucentDefault = () -> Optional.of(AlphaTest.ALWAYS);
-	private static final Supplier<Optional<AlphaTest>> shadowDefault = () -> Optional.of(AlphaTests.NON_ZERO_ALPHA);
+	private static final Supplier<Optional<AlphaTest>> shadowDefault = () -> Optional.of(AlphaTests.ONE_TENTH_ALPHA);
 
 	public void patchShaders(ChunkVertexType vertexType) {
 		ShaderAttributeInputs inputs = new ShaderAttributeInputs(true, true, false, true, true);

File: src/main/java/net/coderbot/iris/mixin/entity_render_context/MixinItemRenderer.java
Patch:
@@ -14,6 +14,7 @@
 import net.minecraft.world.item.ArmorItem;
 import net.minecraft.world.item.BlockItem;
 import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.SolidBucketItem;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Unique;
 import org.spongepowered.asm.mixin.injection.At;
@@ -30,7 +31,7 @@ public abstract class MixinItemRenderer {
 	private void changeId(ItemStack pItemRenderer0, ItemTransforms.TransformType pItemTransforms$TransformType1, boolean pBoolean2, PoseStack pPoseStack3, MultiBufferSource pMultiBufferSource4, int pInt5, int pInt6, BakedModel pBakedModel7, CallbackInfo ci) {
 		if (BlockRenderingSettings.INSTANCE.getItemIds() == null) return;
 
-		if (pItemRenderer0.getItem() instanceof BlockItem blockItem) {
+		if (pItemRenderer0.getItem() instanceof BlockItem blockItem && !(pItemRenderer0.getItem() instanceof SolidBucketItem)) {
 			if (BlockRenderingSettings.INSTANCE.getBlockStateIds() == null) return;
 
 			previousBeValue = CapturedRenderingState.INSTANCE.getCurrentRenderedBlockEntity();

File: src/main/java/net/coderbot/iris/pipeline/SodiumTerrainPipeline.java
Patch:
@@ -124,7 +124,7 @@ public SodiumTerrainPipeline(WorldRenderingPipeline parent, ProgramSet programSe
 
 	private static final Supplier<Optional<AlphaTest>> terrainCutoutDefault = () -> Optional.of(AlphaTests.ONE_TENTH_ALPHA);
 	private static final Supplier<Optional<AlphaTest>> translucentDefault = () -> Optional.of(AlphaTest.ALWAYS);
-	private static final Supplier<Optional<AlphaTest>> shadowDefault = () -> Optional.of(AlphaTests.NON_ZERO_ALPHA);
+	private static final Supplier<Optional<AlphaTest>> shadowDefault = () -> Optional.of(AlphaTests.ONE_TENTH_ALPHA);
 
 	public void patchShaders(ChunkVertexType vertexType) {
 		ShaderAttributeInputs inputs = new ShaderAttributeInputs(true, true, false, true, true);

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/shadow_map/MixinDefaultChunkRenderer.java
Patch:
@@ -9,7 +9,7 @@
 
 @Mixin(DefaultChunkRenderer.class)
 public class MixinDefaultChunkRenderer {
-    @Redirect(method = "render", at = @At(value = "FIELD", target = "Lme/jellysquid/mods/sodium/client/gui/SodiumGameOptions$PerformanceSettings;useBlockFaceCulling:Z"))
+    @Redirect(method = "render", at = @At(value = "FIELD", target = "Lme/jellysquid/mods/sodium/client/gui/SodiumGameOptions$PerformanceSettings;useBlockFaceCulling:Z"), remap = false)
     private boolean iris$disableBlockFaceCullingInShadowPass(SodiumGameOptions.PerformanceSettings instance) {
         if (ShadowRenderingState.areShadowsCurrentlyBeingRendered()) return false;
         return instance.useBlockFaceCulling;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/shadow_map/MixinRenderSectionManager.java
Patch:
@@ -38,14 +38,14 @@ private void cancelIfShadow(Camera camera, Viewport viewport, int frame, boolean
             "getRenderLists",
             "getVisibleChunkCount",
             "renderLayer"
-    }, at = @At(value = "FIELD", target = "Lme/jellysquid/mods/sodium/client/render/chunk/RenderSectionManager;renderLists:Lme/jellysquid/mods/sodium/client/render/chunk/lists/SortedRenderLists;"))
+    }, at = @At(value = "FIELD", target = "Lme/jellysquid/mods/sodium/client/render/chunk/RenderSectionManager;renderLists:Lme/jellysquid/mods/sodium/client/render/chunk/lists/SortedRenderLists;"), remap = false)
     private SortedRenderLists useShadowRenderList2(RenderSectionManager instance) {
         return ShadowRenderingState.areShadowsCurrentlyBeingRendered() ? shadowRenderLists : renderLists;
     }
 
     @Redirect(method = {
             "resetRenderLists"
-    }, at = @At(value = "FIELD", target = "Lme/jellysquid/mods/sodium/client/render/chunk/RenderSectionManager;renderLists:Lme/jellysquid/mods/sodium/client/render/chunk/lists/SortedRenderLists;"))
+    }, at = @At(value = "FIELD", target = "Lme/jellysquid/mods/sodium/client/render/chunk/RenderSectionManager;renderLists:Lme/jellysquid/mods/sodium/client/render/chunk/lists/SortedRenderLists;"), remap = false)
     private void useShadowRenderList3(RenderSectionManager instance, SortedRenderLists value) {
         if (ShadowRenderingState.areShadowsCurrentlyBeingRendered()) shadowRenderLists = value;
          else renderLists = value;

File: src/main/java/net/coderbot/iris/shadows/frustum/advanced/ReversedAdvancedShadowCullingFrustum.java
Patch:
@@ -2,9 +2,9 @@
 
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.shadows.frustum.BoxCuller;
-import net.coderbot.iris.vendored.joml.Matrix4f;
-import net.coderbot.iris.vendored.joml.Vector3f;
 import net.minecraft.world.phys.AABB;
+import org.joml.Matrix4f;
+import org.joml.Vector3f;
 
 public class ReversedAdvancedShadowCullingFrustum extends AdvancedShadowCullingFrustum {
 	public ReversedAdvancedShadowCullingFrustum(Matrix4f playerView, Matrix4f playerProjection, Vector3f shadowLightVectorFromOrigin, BoxCuller boxCuller) {

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/SodiumTransformer.java
Patch:
@@ -68,7 +68,9 @@ public static void transform(
 		if (parameters.inputs.hasColor()) {
 			// TODO: Handle the fragment shader here
 			root.replaceReferenceExpressions(t, "gl_Color", "vec4(_vert_color, " + (BlockRenderingSettings.INSTANCE.shouldUseSeparateAo() ? "iris_midBlock.w" : "1.0") + ")");
-			addIfNotExists(root, t, tree, "iris_midBlock", Type.F32VEC4, StorageQualifier.StorageType.IN);
+			if (parameters.type.glShaderType == ShaderType.VERTEX) {
+				addIfNotExists(root, t, tree, "iris_midBlock", Type.F32VEC4, StorageQualifier.StorageType.IN);
+			}
 
 		} else {
 			root.replaceReferenceExpressions(t, "gl_Color", "vec4(1.0)");

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/shadow_map/MixinRenderSectionManager.java
Patch:
@@ -36,6 +36,7 @@ private void cancelIfShadow(Camera camera, Viewport viewport, int frame, boolean
 
     @Redirect(method = {
             "getRenderLists",
+            "getVisibleChunkCount",
             "renderLayer"
     }, at = @At(value = "FIELD", target = "Lme/jellysquid/mods/sodium/client/render/chunk/RenderSectionManager;renderLists:Lme/jellysquid/mods/sodium/client/render/chunk/lists/SortedRenderLists;"))
     private SortedRenderLists useShadowRenderList2(RenderSectionManager instance) {

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/shadow_map/frustum/MixinBoxCullingFrustum.java
Patch:
@@ -30,6 +30,6 @@ public class MixinBoxCullingFrustum implements Frustum, ViewportProvider {
 
 	@Override
 	public boolean testAab(float minX, float minY, float minZ, float maxX, float maxY, float maxZ) {
-		return !boxCuller.isCulled(minX, minY, minZ, maxX, maxY, maxZ);
+		return !boxCuller.isCulledSodium(minX, minY, minZ, maxX, maxY, maxZ);
 	}
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/shadow_map/frustum/MixinNonCullingFrustum.java
Patch:
@@ -4,16 +4,16 @@
 import me.jellysquid.mods.sodium.client.render.viewport.ViewportProvider;
 import me.jellysquid.mods.sodium.client.render.viewport.frustum.Frustum;
 import net.coderbot.iris.shadows.frustum.fallback.NonCullingFrustum;
+import net.minecraft.client.Minecraft;
 import org.joml.Vector3d;
 import org.spongepowered.asm.mixin.Mixin;
 
 @Mixin(NonCullingFrustum.class)
 public class MixinNonCullingFrustum implements Frustum, ViewportProvider {
-	private static Vector3d EMPTY = new Vector3d();
-
+	private Vector3d pos = new Vector3d();
 	@Override
 	public Viewport sodium$createViewport() {
-		return new Viewport(this, EMPTY);
+		return new Viewport(this, pos.set(Minecraft.getInstance().gameRenderer.getMainCamera().getPosition().x, Minecraft.getInstance().gameRenderer.getMainCamera().getPosition().y, Minecraft.getInstance().gameRenderer.getMainCamera().getPosition().z));
 	}
 
 	@Override

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/SodiumCoreTransformer.java
Patch:
@@ -22,7 +22,7 @@ public static void transform(
 
 		if (parameters.type == PatchShaderType.VERTEX) {
 			// _draw_translation replaced with Chunks[_draw_id].offset.xyz
-			root.replaceReferenceExpressions(t, "vaPosition", "Chunks[_draw_id].offset.xyz + _vert_position");
+			root.replaceReferenceExpressions(t, "vaPosition", "_vert_position + u_RegionOffset + _get_draw_translation(_draw_id)");
 			root.replaceReferenceExpressions(t, "vaColor", "_vert_color");
 			root.rename("vaNormal", "iris_Normal");
 			root.replaceReferenceExpressions(t, "vaUV0", "_vert_tex_diffuse_coord");

File: src/main/java/net/coderbot/iris/shaderpack/ShaderPack.java
Patch:
@@ -127,6 +127,7 @@ public ShaderPack(Path root, Map<String, String> changedConfigs, Iterable<String
 			if (Files.exists(root.resolve("world0"))) {
 				dimensionIdCreator.add("world0");
 				dimensionMap.putIfAbsent(DimensionId.OVERWORLD, "world0");
+				dimensionMap.putIfAbsent(new NamespacedId("*", "*"), "world0");
 			}
 			if (Files.exists(root.resolve("world-1"))) {
 				dimensionIdCreator.add("world-1");

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -157,7 +157,7 @@ public static void generalCommonUniforms(UniformHolder uniforms, FrameUpdateNoti
 	}
 
 	private static boolean isOnGround() {
-		return client.player != null && client.player.isOnGround();
+		return client.player != null && client.player.onGround();
 	}
 
 	private static boolean isHurt() {

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/vertex_format/MixinVertexSerializerCache.java
Patch:
@@ -8,6 +8,7 @@
 import net.caffeinemc.mods.sodium.api.vertex.format.VertexFormatRegistry;
 import net.caffeinemc.mods.sodium.api.vertex.serializer.VertexSerializer;
 import net.coderbot.iris.compat.sodium.impl.vertex_format.EntityToTerrainVertexSerializer;
+import net.coderbot.iris.compat.sodium.impl.vertex_format.GlyphToTerrainVertexSerializer;
 import net.coderbot.iris.compat.sodium.impl.vertex_format.IrisEntityToTerrainVertexSerializer;
 import net.coderbot.iris.compat.sodium.impl.vertex_format.ModelToEntityVertexSerializer;
 import net.coderbot.iris.vertices.IrisVertexFormats;
@@ -38,5 +39,6 @@ private void putSerializerIris(CallbackInfo ci) {
 		cache.put(createKey(VertexFormatRegistry.instance().get(DefaultVertexFormat.NEW_ENTITY), VertexFormatRegistry.instance().get(IrisVertexFormats.ENTITY)), new ModelToEntityVertexSerializer());
 		cache.put(createKey(VertexFormatRegistry.instance().get(IrisVertexFormats.ENTITY), VertexFormatRegistry.instance().get(IrisVertexFormats.TERRAIN)), new IrisEntityToTerrainVertexSerializer());
 		cache.put(createKey(VertexFormatRegistry.instance().get(DefaultVertexFormat.NEW_ENTITY), VertexFormatRegistry.instance().get(IrisVertexFormats.TERRAIN)), new EntityToTerrainVertexSerializer());
+		cache.put(createKey(VertexFormatRegistry.instance().get(DefaultVertexFormat.POSITION_COLOR_TEX_LIGHTMAP), VertexFormatRegistry.instance().get(IrisVertexFormats.ENTITY)), new GlyphToTerrainVertexSerializer());
 	}
 }

File: src/main/java/net/coderbot/iris/compat/sodium/SodiumVersionCheck.java
Patch:
@@ -13,8 +13,8 @@ public class SodiumVersionCheck {
 	// of pain. So don't forget!
 	private static final ImmutableList<AllowedSodiumVersion> ALLOWED_SODIUM_VERSIONS = ImmutableList.of(
 			// Dev version
-		AllowedSodiumVersion.exact("0.4.10+build.27",
-					"https://modrinth.com/mod/sodium/version/mc1.20-0.4.10")
+		AllowedSodiumVersion.exact("0.5.0-rc1",
+					"https://modrinth.com/mod/sodium/version/mc1.20.1-0.5.0")
 	);
 
 	public static String getDownloadLink() {
@@ -29,6 +29,6 @@ public static boolean isAllowedVersion(String sodiumVersion) {
 			}
 		}
 
-		return true;
+		return false;
 	}
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/shadow_map/frustum/MixinBoxCullingFrustum.java
Patch:
@@ -26,6 +26,6 @@ public class MixinBoxCullingFrustum implements IrisFrustum, ViewportProvider {
 
 	@Override
 	public boolean apply(double minX, double minY, double minZ, double maxX, double maxY, double maxZ) {
-		return boxCuller.isCulled(minX, minY, minZ, maxX, maxY, maxZ);
+		return !boxCuller.isCulled(minX, minY, minZ, maxX, maxY, maxZ);
 	}
 }

File: src/main/java/net/coderbot/iris/gl/state/StateUpdateNotifiers.java
Patch:
@@ -1,5 +1,7 @@
 package net.coderbot.iris.gl.state;
 
+import java.util.function.IntSupplier;
+
 /**
  * Holds some standard update notifiers for various elements of GL state. Currently, this class has a few listeners for
  * fog-related values.
@@ -12,4 +14,5 @@ public class StateUpdateNotifiers {
 	public static ValueUpdateNotifier normalTextureChangeNotifier;
 	public static ValueUpdateNotifier specularTextureChangeNotifier;
 	public static ValueUpdateNotifier phaseChangeNotifier;
+	public static ValueUpdateNotifier fallbackEntityNotifier;
 }

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -63,6 +63,9 @@ public static void addDynamicUniforms(DynamicUniformHolder uniforms, FogMode fog
 		FogUniforms.addFogUniforms(uniforms, fogMode);
 		IrisInternalUniforms.addFogUniforms(uniforms, fogMode);
 
+		// This is a fallback for when entityId via attributes cannot be used. (lightning)
+		uniforms.uniform1i("entityId", CapturedRenderingState.INSTANCE::getCurrentRenderedEntity, StateUpdateNotifiers.fallbackEntityNotifier);
+
 		// TODO: OptiFine doesn't think that atlasSize is a "dynamic" uniform,
 		//       but we do. How will custom uniforms depending on atlasSize work?
 		//
@@ -141,7 +144,6 @@ public static void generalCommonUniforms(UniformHolder uniforms, FrameUpdateNoti
 			// just a dummy value for shaders where entityColor isn't supplied through a vertex attribute (and thus is
 			// not available) - suppresses warnings. See AttributeShaderTransformer for the actual entityColor code.
 			.uniform4f(ONCE, "entityColor", () -> new Vector4f(0, 0, 0, 0))
-			.uniform1i(ONCE, "entityId", () -> -1)
 			.uniform1i(ONCE, "blockEntityId", () -> -1)
 			.uniform1i(ONCE, "currentRenderedItemId", () -> -1)
 			.uniform1f(ONCE, "pi", () -> Math.PI)

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/CompositeCoreTransformer.java
Patch:
@@ -12,6 +12,8 @@ public static void transform(
 			TranslationUnit tree,
 			Root root,
 			Parameters parameters) {
+		CompositeDepthTransformer.transform(t, tree, root);
+
 		if (parameters.type == PatchShaderType.VERTEX) {
 			root.rename("vaPosition", "Position");
 			root.rename("vaUV0", "UV0");

File: src/main/java/net/coderbot/iris/pipeline/transform/TransformPatcher.java
Patch:
@@ -292,7 +292,7 @@ private static Map<PatchShaderType, String> transformInternal(
 			Parameters parameters) {
 		try {
 			return transformer.transform(inputs, parameters);
-		} catch (TransformationException | ParsingException | ParseCancellationException e) {
+		} catch (TransformationException | ParsingException | IllegalStateException | IllegalArgumentException e) {
 			// print the offending programs and rethrow to stop the loading process
 			ShaderPrinter.printProgram("errored_program").addSources(inputs).print();
 			throw e;

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -622,6 +622,7 @@ private int renderPlayerEntity(LevelRendererAccessor levelRenderer, EntityRender
 		int shadowEntities = 0;
 
 		if (!dispatcher.shouldRender(player, frustum, cameraX, cameraY, cameraZ) || player.isSpectator()) {
+			levelRenderer.getLevel().getProfiler().pop();
 			return 0;
 		}
 

File: src/main/java/net/coderbot/batchedentityrendering/mixin/MixinLevelRenderer.java
Patch:
@@ -77,6 +77,7 @@ public class MixinLevelRenderer {
 			Minecraft.getInstance().getProfiler().popPush("entity_draws_opaque");
 			if (renderBuffers.bufferSource() instanceof FullyBufferedMultiBufferSource source) {
 				source.endBatchWithType(TransparencyType.OPAQUE);
+				source.endBatchWithType(TransparencyType.OPAQUE_DECAL);
 			} else {
 				this.renderBuffers.bufferSource().endBatch();
 			}

File: src/main/java/net/coderbot/batchedentityrendering/mixin/MixinSheets.java
Patch:
@@ -19,7 +19,7 @@ public class MixinSheets {
 
 	@Inject(method = "<clinit>", at = @At("TAIL"))
 	private static void setSheet(CallbackInfo ci) {
-		((BlendingStateHolder) ARMOR_TRIMS_SHEET_TYPE).setTransparencyType(TransparencyType.GENERAL_TRANSPARENT);
+		((BlendingStateHolder) ARMOR_TRIMS_SHEET_TYPE).setTransparencyType(TransparencyType.OPAQUE_DECAL);
 		((BlendingStateHolder) RenderType.textBackground()).setTransparencyType(TransparencyType.OPAQUE);
 		((BlendingStateHolder) RenderType.textBackgroundSeeThrough()).setTransparencyType(TransparencyType.OPAQUE);
 	}

File: src/main/java/net/coderbot/iris/colorspace/ColorSpaceFragmentConverter.java
Patch:
@@ -12,8 +12,8 @@
 import net.coderbot.iris.postprocess.FullScreenQuadRenderer;
 import net.coderbot.iris.shaderpack.StringPair;
 import net.coderbot.iris.shaderpack.preprocessor.JcppProcessor;
-import net.coderbot.iris.vendored.joml.Matrix4f;
 import org.apache.commons.io.IOUtils;
+import org.joml.Matrix4f;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL30C;
 import org.lwjgl.opengl.GL43C;
@@ -70,7 +70,7 @@ public void rebuildProgram(int width, int height, ColorSpace colorSpace) {
 
 		ProgramBuilder builder = ProgramBuilder.begin("colorSpaceFragment", vertexSource, null, source, ImmutableSet.of());
 
-		builder.uniformJomlMatrix(UniformUpdateFrequency.ONCE, "projection", () -> new Matrix4f(2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, -1, -1, 0, 1));
+		builder.uniformMatrix(UniformUpdateFrequency.ONCE, "projection", () -> new Matrix4f(2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, -1, -1, 0, 1));
 		builder.addDynamicSampler(() -> target, "readImage");
 
 		swapTexture = GlStateManager._genTexture();

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/options/IrisSodiumOptions.java
Patch:
@@ -43,10 +43,10 @@ public static OptionImpl<Options, Integer> createMaxShadowDistanceSlider(Minecra
 
 	public static OptionImpl<Options, ColorSpace> createColorSpaceButton(MinecraftOptionsStorage vanillaOpts) {
 		OptionImpl<Options, ColorSpace> colorSpace = OptionImpl.createBuilder(ColorSpace.class, vanillaOpts)
-			.setName(new TranslatableComponent("options.iris.colorSpace"))
-			.setTooltip(new TranslatableComponent("options.iris.colorSpace.sodium_tooltip"))
+			.setName(Component.translatable("options.iris.colorSpace"))
+			.setTooltip(Component.translatable("options.iris.colorSpace.sodium_tooltip"))
 			.setControl(option -> new CyclingControl<>(option, ColorSpace.class,
-				new Component[] { new TextComponent("SRGB"), new TextComponent("DCI_P3"), new TextComponent("Display P3"), new TextComponent("REC2020"), new TextComponent("Adobe RGB") }))
+				new Component[] { Component.literal("SRGB"), Component.literal("DCI_P3"), Component.literal("Display P3"), Component.literal("REC2020"), Component.literal("Adobe RGB") }))
 			.setBinding((options, value) -> {
 					IrisVideoSettings.colorSpace = value;
 					try {

File: src/main/java/net/coderbot/iris/mixin/MixinDebugScreenOverlay.java
Patch:
@@ -1,6 +1,7 @@
 package net.coderbot.iris.mixin;
 
 import net.coderbot.iris.Iris;
+import net.coderbot.iris.gui.option.IrisVideoSettings;
 import net.minecraft.ChatFormatting;
 import net.minecraft.client.gui.components.DebugScreenOverlay;
 import org.spongepowered.asm.mixin.Mixin;
@@ -50,6 +51,7 @@ public abstract class MixinDebugScreenOverlay {
 			Iris.getCurrentPack().ifPresent(pack -> {
 				messages.add("[" + Iris.MODNAME + "] " + pack.getProfileInfo());
 			});
+			messages.add("[" + Iris.MODNAME + "] Color space: " + IrisVideoSettings.colorSpace.name());
 		} else {
 			messages.add("[" + Iris.MODNAME + "] Shaders are disabled");
 		}

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -52,6 +52,7 @@ public static ExtendedShader create(WorldRenderingPipeline pipeline, String name
 		BlendModeOverride blendModeOverride = source.getDirectives().getBlendModeOverride().orElse(programId.getBlendModeOverride());
 
 		Map<PatchShaderType, String> transformed = TransformPatcher.patchVanilla(
+			name,
 			source.getVertexSource().orElseThrow(RuntimeException::new),
 			source.getGeometrySource().orElse(null),
 			source.getFragmentSource().orElseThrow(RuntimeException::new),

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -527,7 +527,7 @@ private ComputeProgram[] createShadowComputes(ComputeSource[] compute, ProgramSe
 				ProgramBuilder builder;
 
 				try {
-					String transformed = TransformPatcher.patchCompute(source.getSource().orElse(null), TextureStage.GBUFFERS_AND_SHADOW, customTextureMap);
+					String transformed = TransformPatcher.patchCompute(source.getName(), source.getSource().orElse(null), TextureStage.GBUFFERS_AND_SHADOW, customTextureMap);
 
 					ShaderPrinter.printProgram(source.getName()).addSource(PatchShaderType.COMPUTE, transformed).print();
 
@@ -591,7 +591,7 @@ private ComputeProgram[] createSetupComputes(ComputeSource[] compute, ProgramSet
 				ProgramBuilder builder;
 
 				try {
-					String transformed = TransformPatcher.patchCompute(source.getSource().orElse(null), stage, customTextureMap);
+					String transformed = TransformPatcher.patchCompute(source.getName(), source.getSource().orElse(null), stage, customTextureMap);
 
 					ShaderPrinter.printProgram(source.getName()).addSource(PatchShaderType.COMPUTE, transformed).print();
 

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderer.java
Patch:
@@ -337,6 +337,7 @@ private Program createProgram(ProgramSource source, ImmutableSet<Integer> flippe
 														   Supplier<ShadowRenderTargets> shadowTargetsSupplier) {
 		// TODO: Properly handle empty shaders
 		Map<PatchShaderType, String> transformed = TransformPatcher.patchComposite(
+			source.getName(),
 			source.getVertexSource().orElseThrow(NullPointerException::new),
 			source.getGeometrySource().orElse(null),
 			source.getFragmentSource().orElseThrow(NullPointerException::new), textureStage, pipeline.getTextureMap());
@@ -404,7 +405,7 @@ private ComputeProgram[] createComputes(ComputeSource[] compute, ImmutableSet<In
 				ProgramBuilder builder;
 
 				try {
-					String transformed =  TransformPatcher.patchCompute(source.getSource().orElse(null), textureStage, pipeline.getTextureMap());
+					String transformed =  TransformPatcher.patchCompute(source.getName(), source.getSource().orElse(null), textureStage, pipeline.getTextureMap());
 
 					ShaderPrinter.printProgram(source.getName()).addSource(PatchShaderType.COMPUTE, transformed).print();
 

File: src/main/java/net/coderbot/iris/postprocess/FinalPassRenderer.java
Patch:
@@ -337,6 +337,7 @@ private Program createProgram(ProgramSource source, ImmutableSet<Integer> flippe
 								  Supplier<ShadowRenderTargets> shadowTargetsSupplier) {
 		// TODO: Properly handle empty shaders
 		Map<PatchShaderType, String> transformed = TransformPatcher.patchComposite(
+			source.getName(),
 			source.getVertexSource().orElseThrow(NullPointerException::new),
 			source.getGeometrySource().orElse(null),
 			source.getFragmentSource().orElseThrow(NullPointerException::new), TextureStage.COMPOSITE_AND_FINAL, pipeline.getTextureMap());
@@ -403,7 +404,7 @@ private ComputeProgram[] createComputes(ComputeSource[] compute, ImmutableSet<In
 				ProgramBuilder builder;
 
 				try {
-					String transformed =  TransformPatcher.patchCompute(source.getSource().orElse(null), TextureStage.COMPOSITE_AND_FINAL, pipeline.getTextureMap());
+					String transformed =  TransformPatcher.patchCompute(source.getName(), source.getSource().orElse(null), TextureStage.COMPOSITE_AND_FINAL, pipeline.getTextureMap());
 
 					ShaderPrinter.printProgram(source.getName()).addSource(PatchShaderType.COMPUTE, transformed).print();
 

File: src/main/java/net/coderbot/iris/shadows/ShadowCompositeRenderer.java
Patch:
@@ -277,6 +277,7 @@ private Program createProgram(ProgramSource source, ImmutableSet<Integer> flippe
 														   ShadowRenderTargets targets) {
 		// TODO: Properly handle empty shaders
 		Map<PatchShaderType, String> transformed = TransformPatcher.patchComposite(
+			source.getName(),
 			source.getVertexSource().orElseThrow(NullPointerException::new),
 			source.getGeometrySource().orElse(null),
 			source.getFragmentSource().orElseThrow(NullPointerException::new), TextureStage.SHADOWCOMP, pipeline.getTextureMap());
@@ -326,7 +327,7 @@ private ComputeProgram[] createComputes(ComputeSource[] sources, ImmutableSet<In
 				ProgramBuilder builder;
 
 				try {
-					String transformed = TransformPatcher.patchCompute(source.getSource().orElse(null), TextureStage.SHADOWCOMP, pipeline.getTextureMap());
+					String transformed = TransformPatcher.patchCompute(source.getName(), source.getSource().orElse(null), TextureStage.SHADOWCOMP, pipeline.getTextureMap());
 
 					ShaderPrinter.printProgram(source.getName()).addSource(PatchShaderType.COMPUTE, transformed).print();
 

File: src/main/java/net/coderbot/iris/mixin/MixinGameRenderer_NightVisionCompat.java
Patch:
@@ -18,7 +18,7 @@ public class MixinGameRenderer_NightVisionCompat {
 	// It's optional because of Night Vision Flash Be Gone overwriting this method, but having this injection
 	// succeed avoids a lot of spurious (but silently caught) NullPointerExceptions.
 	@Inject(method = "getNightVisionScale", at = @At(value = "INVOKE",
-			target = "Lnet/minecraft/world/effect/MobEffectInstance;getDuration()I"), cancellable = true,
+			target = "Lnet/minecraft/world/effect/MobEffectInstance;endsWithin(I)Z"), cancellable = true,
 			require = 0)
 	private static void iris$safecheckNightvisionStrength(LivingEntity livingEntity, float partialTicks,
 														  CallbackInfoReturnable<Float> cir){

File: src/main/java/net/coderbot/iris/mixin/MixinWindow.java
Patch:
@@ -11,12 +11,13 @@
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
-@Mixin(Window.class)
+@Mixin(value = Window.class, priority = 1010)
 public class MixinWindow {
-	@Inject(method = "<init>", at = @At(value = "INVOKE", target = "Lorg/lwjgl/glfw/GLFW;glfwDefaultWindowHints()V", shift = At.Shift.AFTER))
+	@Inject(method = "<init>", at = @At(value = "INVOKE", target = "Lorg/lwjgl/glfw/GLFW;glfwCreateWindow(IILjava/lang/CharSequence;JJ)J"))
 	private void iris$enableDebugContext(WindowEventHandler arg, ScreenManager arg2, DisplayData arg3, String string, String string2, CallbackInfo ci) {
 		if (Iris.getIrisConfig().areDebugOptionsEnabled()) {
 			GLFW.glfwWindowHint(GLFW.GLFW_OPENGL_DEBUG_CONTEXT, GLFW.GLFW_TRUE);
+			GLFW.glfwWindowHint(GLFW.GLFW_CONTEXT_NO_ERROR, GLFW.GLFW_FALSE);
 			Iris.logger.info("OpenGL debug context activated.");
 		}
 	}

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -122,8 +122,8 @@ public static FallbackShader createFallback(String name, GlFramebuffer writingTo
 												GlFramebuffer writingToAfterTranslucent, AlphaTest alpha,
 												VertexFormat vertexFormat, BlendModeOverride blendModeOverride,
 												NewWorldRenderingPipeline parent, FogMode fogMode, boolean entityLighting,
-												boolean isGlint, boolean intensityTex, boolean isFullbright) throws IOException {
-		ShaderAttributeInputs inputs = new ShaderAttributeInputs(vertexFormat, isFullbright, false, isGlint);
+												boolean isGlint, boolean isText, boolean intensityTex, boolean isFullbright) throws IOException {
+		ShaderAttributeInputs inputs = new ShaderAttributeInputs(vertexFormat, isFullbright, false, isGlint, isText);
 
 		// TODO: Is this check sound in newer versions?
 		boolean isLeash = vertexFormat == DefaultVertexFormat.POSITION_COLOR_LIGHTMAP;

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/VanillaTransformer.java
Patch:
@@ -17,7 +17,9 @@ public static void transform(
 		// this happens before common to make sure the renaming of attributes is done on
 		// attribute inserted by this
 		if (parameters.inputs.hasOverlay()) {
-			AttributeTransformer.patchOverlayColor(t, tree, root, parameters);
+			if (!parameters.inputs.isText()) {
+				AttributeTransformer.patchOverlayColor(t, tree, root, parameters);
+			}
 			AttributeTransformer.patchEntityId(t, tree, root, parameters);
 		}
 

File: src/main/java/net/coderbot/iris/shaderpack/PackShadowDirectives.java
Patch:
@@ -395,7 +395,7 @@ public boolean getMipmap() {
 		}
 
 		public boolean getNearest() {
-			return this.nearest;
+			return this.nearest || this.format.getPixelFormat().isInteger();
 		}
 
 		public boolean getClear() {

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -116,8 +116,8 @@ public static FallbackShader createFallback(String name, GlFramebuffer writingTo
 												GlFramebuffer writingToAfterTranslucent, AlphaTest alpha,
 												VertexFormat vertexFormat, BlendModeOverride blendModeOverride,
 												NewWorldRenderingPipeline parent, FogMode fogMode, boolean entityLighting,
-												boolean intensityTex, boolean isFullbright) throws IOException {
-		ShaderAttributeInputs inputs = new ShaderAttributeInputs(vertexFormat, isFullbright, false);
+												boolean isGlint, boolean isText, boolean intensityTex, boolean isFullbright) throws IOException {
+		ShaderAttributeInputs inputs = new ShaderAttributeInputs(vertexFormat, isFullbright, false, isGlint, isText);
 
 		// TODO: Is this check sound in newer versions?
 		boolean isLeash = vertexFormat == DefaultVertexFormat.POSITION_COLOR_LIGHTMAP;

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/VanillaTransformer.java
Patch:
@@ -17,7 +17,9 @@ public static void transform(
 		// this happens before common to make sure the renaming of attributes is done on
 		// attribute inserted by this
 		if (parameters.inputs.hasOverlay()) {
-			AttributeTransformer.patchOverlayColor(t, tree, root, parameters);
+			if (!parameters.inputs.isText()) {
+				AttributeTransformer.patchOverlayColor(t, tree, root, parameters);
+			}
 			AttributeTransformer.patchEntityId(t, tree, root, parameters);
 		}
 

File: src/main/java/net/coderbot/iris/shaderpack/PackShadowDirectives.java
Patch:
@@ -395,7 +395,7 @@ public boolean getMipmap() {
 		}
 
 		public boolean getNearest() {
-			return this.nearest;
+			return this.nearest || this.format.getPixelFormat().isInteger();
 		}
 
 		public boolean getClear() {

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -91,7 +91,7 @@ public void getModDependencies(ModDependencyCollector d) {
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.anarres:jcpp:1.4.14"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.20+aeb40ebe90"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
-		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:2.0.0-pre12"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
+		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:2.0.0-pre13"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.antlr:antlr4-runtime:4.11.1"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
 		if (SODIUM) {

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -440,7 +440,7 @@ private static void setShadersDisabled() {
 		logger.info("Shaders are disabled");
 	}
 
-	private static void setDebug(boolean enable) {
+	public static void setDebug(boolean enable) {
 		int success;
 		if (enable) {
 			success = GLDebug.setupDebugMessageCallback();

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -286,7 +286,7 @@ public DeferredWorldRenderingPipeline(ProgramSet programs) {
 			return shadowRenderTargets;
 		};
 
-		PatchedShaderPrinter.resetPrintState();
+		ShaderPrinter.resetPrintState();
 
 		this.prepareRenderer = new CompositeRenderer(this, programs.getPackDirectives(), programs.getPrepare(), programs.getPrepareCompute(), renderTargets,
 				customTextureManager.getNoiseTexture(), updateNotifier, centerDepthSampler, flipper, shadowTargetsSupplier,
@@ -683,7 +683,7 @@ private Pass createPass(ProgramSource source, InputAvailability availability, bo
 		String geometry = transformed.get(PatchShaderType.GEOMETRY);
 		String fragment = transformed.get(PatchShaderType.FRAGMENT);
 
-		PatchedShaderPrinter.debugPatchedShaders(source.getName(), vertex, geometry, fragment);
+		ShaderPrinter.printProgram(source.getName()).addSources(transformed).print();
 
 		ProgramBuilder builder = ProgramBuilder.begin(source.getName(), vertex, geometry, fragment,
 			IrisSamplers.WORLD_RESERVED_TEXTURE_UNITS);

File: src/main/java/net/coderbot/iris/pipeline/transform/parameter/SodiumParameters.java
Patch:
@@ -6,7 +6,6 @@
 import net.coderbot.iris.helpers.Tri;
 import net.coderbot.iris.pipeline.newshader.ShaderAttributeInputs;
 import net.coderbot.iris.pipeline.transform.Patch;
-import net.coderbot.iris.pipeline.transform.PatchShaderType;
 import net.coderbot.iris.shaderpack.texture.TextureStage;
 
 public class SodiumParameters extends Parameters {

File: src/main/java/net/coderbot/iris/pipeline/transform/parameter/VanillaParameters.java
Patch:
@@ -6,7 +6,6 @@
 import net.coderbot.iris.helpers.Tri;
 import net.coderbot.iris.pipeline.newshader.ShaderAttributeInputs;
 import net.coderbot.iris.pipeline.transform.Patch;
-import net.coderbot.iris.shaderpack.loading.ProgramId;
 import net.coderbot.iris.shaderpack.texture.TextureStage;
 
 public class VanillaParameters extends GeometryInfoParameters {
@@ -49,7 +48,7 @@ public int hashCode() {
 		result = prime * result + ((alpha == null) ? 0 : alpha.hashCode());
 		result = prime * result + ((inputs == null) ? 0 : inputs.hashCode());
 		result = prime * result + (hasChunkOffset ? 1231 : 1237);
-		result = prime * result + (isLines ? 1931 : 1937);
+		result = prime * result + (isLines ? 1231 : 1237);
 		return result;
 	}
 

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/AttributeTransformer.java
Patch:
@@ -10,6 +10,7 @@
 import io.github.douira.glsl_transformer.ast.query.match.AutoHintedMatcher;
 import io.github.douira.glsl_transformer.ast.transform.ASTInjectionPoint;
 import io.github.douira.glsl_transformer.ast.transform.ASTParser;
+import io.github.douira.glsl_transformer.ast.transform.TransformationException;
 import io.github.douira.glsl_transformer.parser.ParseShape;
 import net.coderbot.iris.gl.shader.ShaderType;
 import net.coderbot.iris.pipeline.transform.PatchShaderType;
@@ -29,7 +30,7 @@ public static void transform(
 			AttributeParameters parameters) {
 		if (tree.getVersionStatement().getNormalizedProfile().isCore()) {
 			if (parameters.type == PatchShaderType.VERTEX) {
-				throw new IllegalStateException("Vertex shaders must be in the compatibility profile to run properly!");
+				throw new TransformationException("Vertex shaders must be in the compatibility profile to run properly!");
 			}
 			return;
 		}

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/SodiumTransformer.java
Patch:
@@ -4,6 +4,7 @@
 import io.github.douira.glsl_transformer.ast.node.TranslationUnit;
 import io.github.douira.glsl_transformer.ast.node.declaration.TypeAndInitDeclaration;
 import io.github.douira.glsl_transformer.ast.node.external_declaration.DeclarationExternalDeclaration;
+import io.github.douira.glsl_transformer.ast.node.type.qualifier.StorageQualifier;
 import io.github.douira.glsl_transformer.ast.node.type.specifier.BuiltinNumericTypeSpecifier;
 import io.github.douira.glsl_transformer.ast.query.Root;
 import io.github.douira.glsl_transformer.ast.transform.ASTInjectionPoint;

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/CompatibilityTransformer.java
Patch:
@@ -269,7 +269,7 @@ public static void transformEach(ASTParser t, TranslationUnit tree, Root root, P
 					"Moved unsized array specifier (of the form []) from the type to each of the the declaration member(s) "
 							+ structMember.getDeclarators().stream().map(StructDeclarator::getName).map(Identifier::getName)
 									.collect(Collectors.joining(", "))
-							+ ".");
+							+ ". See debugging.md for more information.");
 		}
 	}
 

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -287,7 +287,7 @@ public DeferredWorldRenderingPipeline(ProgramSet programs) {
 			return shadowRenderTargets;
 		};
 
-		PatchedShaderPrinter.resetPrintState();
+		ShaderPrinter.resetPrintState();
 
 		this.prepareRenderer = new CompositeRenderer(this, programs.getPackDirectives(), programs.getPrepare(), programs.getPrepareCompute(), renderTargets,
 				customTextureManager.getNoiseTexture(), updateNotifier, centerDepthSampler, flipper, shadowTargetsSupplier,
@@ -684,7 +684,7 @@ private Pass createPass(ProgramSource source, InputAvailability availability, bo
 		String geometry = transformed.get(PatchShaderType.GEOMETRY);
 		String fragment = transformed.get(PatchShaderType.FRAGMENT);
 
-		PatchedShaderPrinter.debugPatchedShaders(source.getName(), vertex, geometry, fragment);
+		ShaderPrinter.printProgram(source.getName()).addSources(transformed).print();
 
 		ProgramBuilder builder = ProgramBuilder.begin(source.getName(), vertex, geometry, fragment,
 			IrisSamplers.WORLD_RESERVED_TEXTURE_UNITS);

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/AttributeTransformer.java
Patch:
@@ -10,6 +10,7 @@
 import io.github.douira.glsl_transformer.ast.query.match.AutoHintedMatcher;
 import io.github.douira.glsl_transformer.ast.transform.ASTInjectionPoint;
 import io.github.douira.glsl_transformer.ast.transform.ASTParser;
+import io.github.douira.glsl_transformer.ast.transform.TransformationException;
 import io.github.douira.glsl_transformer.parser.ParseShape;
 import net.coderbot.iris.gl.shader.ShaderType;
 import net.coderbot.iris.pipeline.transform.PatchShaderType;
@@ -29,7 +30,7 @@ public static void transform(
 			AttributeParameters parameters) {
 		if (tree.getVersionStatement().getNormalizedProfile().isCore()) {
 			if (parameters.type == PatchShaderType.VERTEX) {
-				throw new IllegalStateException("Vertex shaders must be in the compatibility profile to run properly!");
+				throw new TransformationException("Vertex shaders must be in the compatibility profile to run properly!");
 			}
 			return;
 		}

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/shader_overrides/MixinShaderChunkRenderer.java
Patch:
@@ -69,7 +69,7 @@ public class MixinShaderChunkRenderer implements ShaderChunkRendererExt {
 
 			transformations.injectLine(Transformations.InjectionPoint.BEFORE_CODE, "mat4 iris_LightmapTextureMatrix = mat4(vec4(0.00390625, 0.0, 0.0, 0.0), vec4(0.0, 0.00390625, 0.0, 0.0), vec4(0.0, 0.0, 0.00390625, 0.0), vec4(0.03125, 0.03125, 0.03125, 1.0));");
 
-			Iris.logger.warn(transformations.toString());
+			// Iris.logger.warn(transformations.toString());
 			return new GlShader(type, name, transformations.toString());
 		} else {
 			return ShaderLoader.loadShader(type, name, constants);

File: src/main/java/net/coderbot/iris/pipeline/transform/TransformPatcher.java
Patch:
@@ -6,6 +6,7 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import net.coderbot.iris.Iris;
 import org.antlr.v4.runtime.Token;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -302,7 +303,7 @@ private static Map<PatchShaderType, String> transform(String vertex, String geom
 
 		// if there is no cache result, transform the shaders
 		if (result == null) {
-			transformer.setPrintType(PatchedShaderPrinter.prettyPrintShaders ? PrintType.INDENTED : PrintType.SIMPLE);
+			transformer.setPrintType(Iris.getIrisConfig().areDebugOptionsEnabled() ? PrintType.INDENTED : PrintType.SIMPLE);
 			EnumMap<PatchShaderType, String> inputs = new EnumMap<>(PatchShaderType.class);
 			inputs.put(PatchShaderType.VERTEX, vertex);
 			inputs.put(PatchShaderType.GEOMETRY, geometry);
@@ -334,7 +335,7 @@ private static Map<PatchShaderType, String> transformCompute(String compute, Par
 
 		// if there is no cache result, transform the shaders
 		if (result == null) {
-			transformer.setPrintType(PatchedShaderPrinter.prettyPrintShaders ? PrintType.INDENTED : PrintType.SIMPLE);
+			transformer.setPrintType(Iris.getIrisConfig().areDebugOptionsEnabled() ? PrintType.INDENTED : PrintType.SIMPLE);
 			EnumMap<PatchShaderType, String> inputs = new EnumMap<>(PatchShaderType.class);
 			inputs.put(PatchShaderType.COMPUTE, compute);
 

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -91,7 +91,7 @@ public void getModDependencies(ModDependencyCollector d) {
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.anarres:jcpp:1.4.14"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.12+54e5b2ec60"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
-		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:2.0.0-pre12"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
+		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:2.0.0-pre13"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.antlr:antlr4-runtime:4.11.1"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
 		if (SODIUM) {

File: src/main/java/net/coderbot/iris/pipeline/transform/parameter/SodiumParameters.java
Patch:
@@ -6,7 +6,6 @@
 import net.coderbot.iris.helpers.Tri;
 import net.coderbot.iris.pipeline.newshader.ShaderAttributeInputs;
 import net.coderbot.iris.pipeline.transform.Patch;
-import net.coderbot.iris.pipeline.transform.PatchShaderType;
 import net.coderbot.iris.shaderpack.texture.TextureStage;
 
 public class SodiumParameters extends Parameters {

File: src/main/java/net/coderbot/iris/pipeline/transform/parameter/VanillaParameters.java
Patch:
@@ -6,7 +6,6 @@
 import net.coderbot.iris.helpers.Tri;
 import net.coderbot.iris.pipeline.newshader.ShaderAttributeInputs;
 import net.coderbot.iris.pipeline.transform.Patch;
-import net.coderbot.iris.shaderpack.loading.ProgramId;
 import net.coderbot.iris.shaderpack.texture.TextureStage;
 
 public class VanillaParameters extends GeometryInfoParameters {
@@ -49,7 +48,7 @@ public int hashCode() {
 		result = prime * result + ((alpha == null) ? 0 : alpha.hashCode());
 		result = prime * result + ((inputs == null) ? 0 : inputs.hashCode());
 		result = prime * result + (hasChunkOffset ? 1231 : 1237);
-		result = prime * result + (isLines ? 1931 : 1937);
+		result = prime * result + (isLines ? 1231 : 1237);
 		return result;
 	}
 

File: src/main/java/net/coderbot/iris/gl/shader/GlShader.java
Patch:
@@ -43,7 +43,7 @@ private static int createShader(ShaderType type, String name, String src) {
 		int result = GlStateManager.glGetShaderi(handle, GL20C.GL_COMPILE_STATUS);
 
 		if (result != GL20C.GL_TRUE) {
-			throw new RuntimeException("Shader compilation failed, see log for details");
+			throw new RuntimeException("Shader compilation failed for " + name + ", see log for details");
 		}
 
 		return handle;

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -524,7 +524,7 @@ private ComputeProgram[] createShadowComputes(ComputeSource[] compute, ProgramSe
 					builder = ProgramBuilder.beginCompute(source.getName(), TransformPatcher.patchCompute(source.getSource().orElse(null), TextureStage.GBUFFERS_AND_SHADOW, customTextureMap), IrisSamplers.WORLD_RESERVED_TEXTURE_UNITS);
 				} catch (RuntimeException e) {
 					// TODO: Better error handling
-					throw new RuntimeException("Shader compilation failed!", e);
+					throw new RuntimeException("Shader compilation failed for compute " + source.getName() + "!", e);
 				}
 
 				CommonUniforms.addDynamicUniforms(builder, FogMode.OFF);
@@ -582,7 +582,7 @@ private ComputeProgram[] createSetupComputes(ComputeSource[] compute, ProgramSet
 					builder = ProgramBuilder.beginCompute(source.getName(), TransformPatcher.patchCompute(source.getSource().orElse(null), stage, customTextureMap), IrisSamplers.COMPOSITE_RESERVED_TEXTURE_UNITS);
 				} catch (RuntimeException e) {
 					// TODO: Better error handling
-					throw new RuntimeException("Shader compilation failed!", e);
+					throw new RuntimeException("Shader compilation failed for setup compute " + source.getName() + "!", e);
 				}
 
 				CommonUniforms.addDynamicUniforms(builder, FogMode.OFF);

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderer.java
Patch:
@@ -352,7 +352,7 @@ private Program createProgram(ProgramSource source, ImmutableSet<Integer> flippe
 					IrisSamplers.COMPOSITE_RESERVED_TEXTURE_UNITS);
 		} catch (RuntimeException e) {
 			// TODO: Better error handling
-			throw new RuntimeException("Shader compilation failed!", e);
+			throw new RuntimeException("Shader compilation failed for " + source.getName() + "!", e);
 		}
 
 
@@ -403,7 +403,7 @@ private ComputeProgram[] createComputes(ComputeSource[] compute, ImmutableSet<In
 					builder = ProgramBuilder.beginCompute(source.getName(), TransformPatcher.patchCompute(source.getSource().orElse(null), textureStage, pipeline.getTextureMap()), IrisSamplers.COMPOSITE_RESERVED_TEXTURE_UNITS);
 				} catch (RuntimeException e) {
 					// TODO: Better error handling
-					throw new RuntimeException("Shader compilation failed!", e);
+					throw new RuntimeException("Shader compilation failed for compute " + source.getName() + "!", e);
 				}
 
 				ProgramSamplers.CustomTextureSamplerInterceptor customTextureSamplerInterceptor = ProgramSamplers.customTextureSamplerInterceptor(builder, customTextureIds, flippedAtLeastOnceSnapshot);

File: src/main/java/net/coderbot/iris/postprocess/FinalPassRenderer.java
Patch:
@@ -352,7 +352,7 @@ private Program createProgram(ProgramSource source, ImmutableSet<Integer> flippe
 					IrisSamplers.COMPOSITE_RESERVED_TEXTURE_UNITS);
 		} catch (RuntimeException e) {
 			// TODO: Better error handling
-			throw new RuntimeException("Shader compilation failed!", e);
+			throw new RuntimeException("Shader compilation failed for final!", e);
 		}
 
 		CommonUniforms.addDynamicUniforms(builder, FogMode.OFF);
@@ -401,7 +401,7 @@ private ComputeProgram[] createComputes(ComputeSource[] compute, ImmutableSet<In
 					builder = ProgramBuilder.beginCompute(source.getName(), TransformPatcher.patchCompute(source.getSource().orElse(null), TextureStage.COMPOSITE_AND_FINAL, pipeline.getTextureMap()), IrisSamplers.COMPOSITE_RESERVED_TEXTURE_UNITS);
 				} catch (RuntimeException e) {
 					// TODO: Better error handling
-					throw new RuntimeException("Shader compilation failed!", e);
+					throw new RuntimeException("Shader compilation failed for final compute " + source.getName() + "!", e);
 				}
 
 				ProgramSamplers.CustomTextureSamplerInterceptor customTextureSamplerInterceptor = ProgramSamplers.customTextureSamplerInterceptor(builder, customTextureIds, flippedAtLeastOnceSnapshot);

File: src/main/java/net/coderbot/iris/shadows/ShadowCompositeRenderer.java
Patch:
@@ -287,7 +287,7 @@ private Program createProgram(ProgramSource source, ImmutableSet<Integer> flippe
 				IrisSamplers.COMPOSITE_RESERVED_TEXTURE_UNITS);
 		} catch (RuntimeException e) {
 			// TODO: Better error handling
-			throw new RuntimeException("Shader compilation failed!", e);
+			throw new RuntimeException("Shader compilation failed for shadow composite " + source.getName() + "!", e);
 		}
 
 		ProgramSamplers.CustomTextureSamplerInterceptor customTextureSamplerInterceptor = ProgramSamplers.customTextureSamplerInterceptor(builder, customTextureIds, flippedAtLeastOnceSnapshot);
@@ -324,7 +324,7 @@ private ComputeProgram[] createComputes(ComputeSource[] sources, ImmutableSet<In
 						IrisSamplers.COMPOSITE_RESERVED_TEXTURE_UNITS);
 				} catch (RuntimeException e) {
 					// TODO: Better error handling
-					throw new RuntimeException("Shader compilation failed!", e);
+					throw new RuntimeException("Shader compilation failed for shadowcomp compute " + source.getName() + "!", e);
 				}
 
 				ProgramSamplers.CustomTextureSamplerInterceptor customTextureSamplerInterceptor = ProgramSamplers.customTextureSamplerInterceptor(builder, customTextureIds, flippedAtLeastOnceSnapshot);

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -404,7 +404,7 @@ public DeferredWorldRenderingPipeline(ProgramSet programs) {
 				Program shadowProgram = table.match(RenderCondition.SHADOW, new InputAvailability(true, true, true)).getProgram();
 
 				this.shadowCompositeRenderer = new ShadowCompositeRenderer(this, programs.getPackDirectives(), programs.getShadowComposite(), programs.getShadowCompCompute(), this.shadowRenderTargets, customTextureManager.getNoiseTexture(), updateNotifier,
-					customTextureManager.getCustomTextureIdMap(TextureStage.SHADOWCOMP), programs.getPackDirectives().getExplicitFlips("shadowcomp_pre"), customTextureManager.getIrisCustomTextures(), customUniforms);
+					customTextureManager.getCustomTextureIdMap(TextureStage.SHADOWCOMP), null, programs.getPackDirectives().getExplicitFlips("shadowcomp_pre"), customTextureManager.getIrisCustomTextures(), customUniforms);
 				this.shadowRenderer = new ShadowRenderer(programs.getShadow().orElse(null),
 					programs.getPackDirectives(), shadowRenderTargets, shadowCompositeRenderer, customUniforms, false);
 			} else {

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -459,7 +459,7 @@ public NewWorldRenderingPipeline(ProgramSet programSet) throws IOException {
 			this.shadowClearPasses = ClearPassCreator.createShadowClearPasses(shadowRenderTargets, false, shadowDirectives);
 			this.shadowClearPassesFull = ClearPassCreator.createShadowClearPasses(shadowRenderTargets, true, shadowDirectives);
 			this.shadowCompositeRenderer = new ShadowCompositeRenderer(this, programSet.getPackDirectives(), programSet.getShadowComposite(), programSet.getShadowCompCompute(), this.shadowRenderTargets, customTextureManager.getNoiseTexture(), updateNotifier,
-				customTextureManager.getCustomTextureIdMap(TextureStage.SHADOWCOMP), programSet.getPackDirectives().getExplicitFlips("shadowcomp_pre"), customTextureManager.getIrisCustomTextures(), customUniforms);
+				customTextureManager.getCustomTextureIdMap(TextureStage.SHADOWCOMP), customImages, programSet.getPackDirectives().getExplicitFlips("shadowcomp_pre"), customTextureManager.getIrisCustomTextures(), customUniforms);
 
 			if (programSet.getPackDirectives().getShadowDirectives().isShadowEnabled().orElse(true)) {
 				this.shadowRenderer = new ShadowRenderer(programSet.getShadow().orElse(null),

File: src/main/java/net/coderbot/iris/gl/image/GlImage.java
Patch:
@@ -43,8 +43,9 @@ public GlImage(String name, String samplerName, TextureType target, PixelFormat
 	}
 
 	protected void setup(int texture, int width, int height, int depth) {
-		IrisRenderSystem.texParameteri(texture, target.getGlType(), GL11C.GL_TEXTURE_MIN_FILTER, GL11C.GL_LINEAR);
-		IrisRenderSystem.texParameteri(texture, target.getGlType(), GL11C.GL_TEXTURE_MAG_FILTER, GL11C.GL_LINEAR);
+		boolean isInteger = internalTextureFormat.getPixelFormat().isInteger();
+		IrisRenderSystem.texParameteri(texture, target.getGlType(), GL11C.GL_TEXTURE_MIN_FILTER, isInteger ? GL11C.GL_NEAREST : GL11C.GL_LINEAR);
+		IrisRenderSystem.texParameteri(texture, target.getGlType(), GL11C.GL_TEXTURE_MAG_FILTER, isInteger ? GL11C.GL_NEAREST : GL11C.GL_LINEAR);
 		IrisRenderSystem.texParameteri(texture, target.getGlType(), GL11C.GL_TEXTURE_WRAP_S, GL13C.GL_CLAMP_TO_EDGE);
 
 		if (height > 0) {

File: src/main/java/net/coderbot/iris/mixin/vertices/MixinBufferBuilder.java
Patch:
@@ -138,7 +138,7 @@ public abstract class MixinBufferBuilder extends DefaultedVertexConsumer impleme
 
 	@Override
 	public @NotNull VertexConsumer uv2(int pBufferVertexConsumer0, int pInt1) {
-		if (injectNormalAndUV1) {
+		if (injectNormalAndUV1 && currentElement == DefaultVertexFormat.ELEMENT_UV1) {
 			this.putShort(0, (short) 0);
 			this.putShort(2, (short) 10);
 			this.nextElement();

File: src/main/java/net/coderbot/iris/mixin/vertices/MixinBufferBuilder.java
Patch:
@@ -162,6 +162,7 @@ public abstract class MixinBufferBuilder extends DefaultedVertexConsumer impleme
 	@Inject(method = "discard()V", at = @At("HEAD"))
 	private void iris$onDiscard(CallbackInfo ci) {
 		extending = false;
+		injectNormalAndUV1 = false;
 		vertexCount = 0;
 	}
 

File: src/main/java/net/coderbot/iris/pipeline/newshader/ShaderKey.java
Patch:
@@ -71,8 +71,8 @@ public enum ShaderKey {
 	SHADOW_LEASH           (ProgramId.Shadow,      AlphaTests.OFF,             DefaultVertexFormat.POSITION_COLOR_LIGHTMAP,     FogMode.OFF,          LightingModel.LIGHTMAP  ),
 	SHADOW_LIGHTNING       (ProgramId.Shadow,      AlphaTests.OFF,             DefaultVertexFormat.POSITION_COLOR,     			FogMode.OFF,          LightingModel.FULLBRIGHT),
 	SHADOW_PARTICLES       (ProgramId.Shadow,      AlphaTests.ONE_TENTH_ALPHA, DefaultVertexFormat.PARTICLE,	     			FogMode.OFF,          LightingModel.LIGHTMAP  ),
-	SHADOW_TEXT           (ProgramId.Shadow,       AlphaTests.NON_ZERO_ALPHA,  IrisVertexFormats.TERRAIN                       , FogMode.OFF,          LightingModel.LIGHTMAP  ),
-	SHADOW_TEXT_INTENSITY (ProgramId.Shadow,       AlphaTests.NON_ZERO_ALPHA,  IrisVertexFormats.TERRAIN                       , FogMode.OFF,          LightingModel.LIGHTMAP  );
+	SHADOW_TEXT           (ProgramId.Shadow,       AlphaTests.NON_ZERO_ALPHA,  IrisVertexFormats.ENTITY                       , FogMode.OFF,          LightingModel.LIGHTMAP  ),
+	SHADOW_TEXT_INTENSITY (ProgramId.Shadow,       AlphaTests.NON_ZERO_ALPHA,  IrisVertexFormats.ENTITY                       , FogMode.OFF,          LightingModel.LIGHTMAP  );
 
 	private final ProgramId program;
 	private final AlphaTest alphaTest;

File: src/main/java/net/coderbot/iris/gl/image/ImageBinding.java
Patch:
@@ -19,6 +19,7 @@ public ImageBinding(int imageUnit, int internalFormat, IntSupplier textureID) {
 	public void update() {
 		// We can assume that image bindings are supported here as either the EXT extension or 4.2 core, as otherwise ImageLimits
 		// would report that zero image units are supported.
-		IrisRenderSystem.bindImageTexture(imageUnit, textureID.getAsInt(), 0, false, 0, GL42C.GL_READ_WRITE, internalFormat);
+        // RRe36: I'm not sure if its perfectly fine to always have it be layered, but according to Balint its *probably* fine. Still might need to verify that though.
+		IrisRenderSystem.bindImageTexture(imageUnit, textureID.getAsInt(), 0, true, 0, GL42C.GL_READ_WRITE, internalFormat);
 	}
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/terrain_xhfp/XHFPTerrainVertex.java
Patch:
@@ -78,7 +78,7 @@ public long write(long ptr,
 
 		MemoryUtil.memPutShort(ptr + 36, contextHolder.blockId);
 		MemoryUtil.memPutShort(ptr + 38, contextHolder.renderType);
-		MemoryUtil.memPutInt(ptr + 40, ExtendedDataHelper.computeMidBlock(vertex.x, vertex.y, vertex.z, contextHolder.localPosX, contextHolder.localPosY, contextHolder.localPosZ));
+		MemoryUtil.memPutInt(ptr + 40, contextHolder.ignoreMidBlock ? 0 : ExtendedDataHelper.computeMidBlock(vertex.x, vertex.y, vertex.z, contextHolder.localPosX, contextHolder.localPosY, contextHolder.localPosZ));
 
 		if (vertexCount == 4) {
 			vertexCount = 0;

File: src/main/java/net/coderbot/iris/mixin/entity_render_context/MixinBlockEntityRenderDispatcher.java
Patch:
@@ -66,6 +66,6 @@ public class MixinBlockEntityRenderDispatcher {
 	@Inject(method = "render", at = @At(value = "INVOKE", target = RUN_REPORTED, shift = At.Shift.AFTER))
 	private void iris$afterRender(BlockEntity blockEntity, float tickDelta, PoseStack matrix,
 								  MultiBufferSource bufferSource, CallbackInfo ci) {
-		CapturedRenderingState.INSTANCE.setCurrentBlockEntity(-1);
+		CapturedRenderingState.INSTANCE.setCurrentBlockEntity(0);
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/entity_render_context/MixinEntityRenderDispatcher.java
Patch:
@@ -67,6 +67,6 @@ public class MixinEntityRenderDispatcher {
 	private void iris$endEntityRender(Entity entity, double x, double y, double z, float yaw, float tickDelta,
 									  PoseStack poseStack, MultiBufferSource bufferSource, int light,
 									  CallbackInfo ci) {
-		CapturedRenderingState.INSTANCE.setCurrentEntity(-1);
+		CapturedRenderingState.INSTANCE.setCurrentEntity(0);
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/vertices/MixinVertexFormatElement.java
Patch:
@@ -13,7 +13,7 @@
 public class MixinVertexFormatElement {
 	@Inject(method = "supportsUsage", at = @At("HEAD"), cancellable = true)
 	private void iris$fixGenericAttributes(int index, VertexFormatElement.Usage type, CallbackInfoReturnable<Boolean> cir) {
-		if (type == VertexFormatElement.Usage.GENERIC) {
+		if (type == VertexFormatElement.Usage.GENERIC || type == VertexFormatElement.Usage.PADDING) {
 			cir.setReturnValue(true);
 		}
 	}

File: src/main/java/net/coderbot/iris/pipeline/newshader/ShaderKey.java
Patch:
@@ -41,7 +41,7 @@ public enum ShaderKey {
 	HAND_WATER_BRIGHT      (ProgramId.HandWater,   AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.FULLBRIGHT),
 	HAND_WATER_DIFFUSE     (ProgramId.HandWater,   AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.DIFFUSE_LM),
 	LIGHTNING              (ProgramId.Entities,    AlphaTests.OFF,             DefaultVertexFormat.POSITION_COLOR,              FogMode.PER_VERTEX,   LightingModel.FULLBRIGHT),
-	LEASH                  (ProgramId.Line,        AlphaTests.OFF,             DefaultVertexFormat.POSITION_COLOR_LIGHTMAP,     FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
+	LEASH                  (ProgramId.Basic,       AlphaTests.OFF,             DefaultVertexFormat.POSITION_COLOR_LIGHTMAP,     FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	PARTICLES              (ProgramId.Particles,   AlphaTests.ONE_TENTH_ALPHA, DefaultVertexFormat.PARTICLE,                    FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	PARTICLES_TRANS        (ProgramId.ParticlesTrans,AlphaTests.ONE_TENTH_ALPHA,DefaultVertexFormat.PARTICLE,                   FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	WEATHER                (ProgramId.Weather,     AlphaTests.ONE_TENTH_ALPHA, DefaultVertexFormat.PARTICLE,                    FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -27,6 +27,7 @@
 import net.coderbot.iris.gl.program.ProgramImages;
 import net.coderbot.iris.gl.program.ProgramSamplers;
 import net.coderbot.iris.gl.sampler.SamplerHolder;
+import net.coderbot.iris.gl.sampler.SamplerLimits;
 import net.coderbot.iris.gl.texture.DepthBufferFormat;
 import net.coderbot.iris.gl.texture.TextureType;
 import net.coderbot.iris.helpers.Tri;
@@ -275,7 +276,7 @@ public NewWorldRenderingPipeline(ProgramSet programSet) throws IOException {
 				throw new IllegalStateException("Shader storage buffers/immutable buffer storage is not supported on this graphics card, however the shaderpack requested them? This shouldn't be possible.");
 			}
 		} else {
-			for (int i = 0; i < 16; i++) {
+			for (int i = 0; i < SamplerLimits.get().getMaxShaderStorageUnits(); i++) {
 				IrisRenderSystem.bindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, i, 0);
 			}
 		}

File: src/main/java/net/coderbot/iris/gl/IrisRenderSystem.java
Patch:
@@ -239,15 +239,15 @@ public static int getTexParameteri(int texture, int target, int pname) {
 
 	public static void bindImageTexture(int unit, int texture, int level, boolean layered, int layer, int access, int format) {
 		RenderSystem.assertOnRenderThreadOrInit();
-		if (GL.getCapabilities().OpenGL42) {
+		if (GL.getCapabilities().OpenGL42 || GL.getCapabilities().GL_ARB_shader_image_load_store) {
 			GL42C.glBindImageTexture(unit, texture, level, layered, layer, access, format);
 		} else {
 			EXTShaderImageLoadStore.glBindImageTextureEXT(unit, texture, level, layered, layer, access, format);
 		}
 	}
 
 	public static int getMaxImageUnits() {
-		if (GL.getCapabilities().OpenGL42) {
+		if (GL.getCapabilities().OpenGL42 || GL.getCapabilities().GL_ARB_shader_image_load_store) {
 			return GlStateManager._getInteger(GL42C.GL_MAX_IMAGE_UNITS);
 		} else if (GL.getCapabilities().GL_EXT_shader_image_load_store) {
 			return GlStateManager._getInteger(EXTShaderImageLoadStore.GL_MAX_IMAGE_UNITS_EXT);

File: src/main/java/net/coderbot/iris/gl/IrisRenderSystem.java
Patch:
@@ -261,7 +261,7 @@ public static boolean supportsSSBO() {
 	}
 
 	public static boolean supportsImageLoadStore() {
-		return GL.getCapabilities().OpenGL42 || ((GL.getCapabilities().GL_ARB_shader_image_load_store || GL.getCapabilities().GL_EXT_shader_image_load_store) && GL.getCapabilities().GL_ARB_buffer_storage);
+		return GL.getCapabilities().glBindImageTexture != 0L || GL.getCapabilities().OpenGL42 || ((GL.getCapabilities().GL_ARB_shader_image_load_store || GL.getCapabilities().GL_EXT_shader_image_load_store) && GL.getCapabilities().GL_ARB_buffer_storage);
 	}
 
 	public static void genBuffers(int[] buffers) {

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -725,6 +725,7 @@ public void addGbufferOrShadowSamplers(SamplerHolder samplers, ImageHolder image
 		IrisSamplers.addRenderTargetSamplers(samplerHolder, flipped, renderTargets, false);
 		IrisSamplers.addCustomTextures(samplerHolder, customTextureManager.getIrisCustomTextures());
 		IrisImages.addRenderTargetImages(images, flipped, renderTargets);
+		IrisImages.addCustomImages(images, customImages);
 
 		if (!shouldBindPBR) {
 			shouldBindPBR = IrisSamplers.hasPBRSamplers(samplerHolder);

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -733,6 +733,7 @@ public void addGbufferOrShadowSamplers(SamplerHolder samplers, ImageHolder image
 		IrisSamplers.addLevelSamplers(samplers, this, whitePixel, availability);
 		IrisSamplers.addWorldDepthSamplers(samplerHolder, this.renderTargets);
 		IrisSamplers.addNoiseSampler(samplerHolder, this.customTextureManager.getNoiseTexture());
+		IrisSamplers.addCustomImages(samplerHolder, customImages);
 
 		if (isShadowPass || IrisSamplers.hasShadowSamplers(samplerHolder)) {
 			if (!isShadowPass) {

File: src/main/java/net/coderbot/iris/pipeline/newshader/ShaderKey.java
Patch:
@@ -53,7 +53,7 @@ public enum ShaderKey {
 	BLOCK_ENTITY           (ProgramId.Block,       AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	BLOCK_ENTITY_BRIGHT    (ProgramId.Block,       AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.FULLBRIGHT),
 	BLOCK_ENTITY_DIFFUSE   (ProgramId.Block,       AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.DIFFUSE_LM),
-	BE_TRANSLUCENT         (ProgramId.BlockTrans,  AlphaTests.OFF,             IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.DIFFUSE_LM),
+	BE_TRANSLUCENT         (ProgramId.BlockTrans,  AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.DIFFUSE_LM),
 	BEACON                 (ProgramId.BeaconBeam,  AlphaTests.OFF,             DefaultVertexFormat.BLOCK,                       FogMode.PER_FRAGMENT, LightingModel.FULLBRIGHT),
 	GLINT                  (ProgramId.ArmorGlint,  AlphaTests.NON_ZERO_ALPHA,  DefaultVertexFormat.POSITION_TEX,                FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	LINES                  (ProgramId.Line,        AlphaTests.OFF,             DefaultVertexFormat.POSITION_COLOR_NORMAL,       FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/VanillaTransformer.java
Patch:
@@ -18,10 +18,9 @@ public static void transform(
 		// attribute inserted by this
 		if (parameters.inputs.hasOverlay()) {
 			AttributeTransformer.patchOverlayColor(t, tree, root, parameters);
+			AttributeTransformer.patchEntityId(t, tree, root, parameters);
 		}
 
-		AttributeTransformer.patchEntityId(t, tree, root, parameters);
-
 		CommonTransformer.transform(t, tree, root, parameters, false);
 
 		if (parameters.type.glShaderType == ShaderType.VERTEX) {

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/AttributeTransformer.java
Patch:
@@ -233,7 +233,7 @@ public static void patchEntityId(
 					"flat out ivec2 iris_entityInfoGS;",
 					"flat in ivec2 iris_entityInfo[];");
 			tree.prependMainFunctionBody(t,
-					"iris_EntityGS = iris_Entity[0];");
+					"iris_entityInfoGS = iris_entityInfo[0];");
 		} else if (parameters.type.glShaderType == ShaderType.FRAGMENT) {
 			tree.parseAndInjectNodes(t, ASTInjectionPoint.BEFORE_DECLARATIONS,
 					"flat in ivec2 iris_entityInfo;");

File: src/main/java/net/coderbot/iris/mixin/MixinModelViewBobbing.java
Patch:
@@ -66,6 +66,8 @@ public class MixinModelViewBobbing {
 			at = @At(value = "INVOKE",
 					target = "Lnet/minecraft/client/renderer/GameRenderer;resetProjectionMatrix(Lorg/joml/Matrix4f;)V"))
 	private void iris$applyBobbingToModelView(float tickDelta, long limitTime, PoseStack matrix, CallbackInfo ci) {
+		if (!areShadersOn) return;
+
 		matrix.last().pose().mul(bobbingEffectsModel);
 
 		bobbingEffectsModel = null;

File: src/main/java/net/coderbot/iris/shaderpack/ProgramSet.java
Patch:
@@ -175,7 +175,7 @@ private static <T> Optional<T> first(Optional<T>... candidates) {
 	private ProgramSource[] readProgramArray(AbsolutePackPath directory,
 											 Function<AbsolutePackPath, String> sourceProvider, String name,
 											 ShaderProperties shaderProperties) {
-		ProgramSource[] programs = new ProgramSource[99];
+		ProgramSource[] programs = new ProgramSource[100];
 
 		for (int i = 0; i < programs.length; i++) {
 			String suffix = i == 0 ? "" : Integer.toString(i);
@@ -188,7 +188,7 @@ private ProgramSource[] readProgramArray(AbsolutePackPath directory,
 
 	private ComputeSource[] readProgramArray(AbsolutePackPath directory,
 											 Function<AbsolutePackPath, String> sourceProvider, String name) {
-		ComputeSource[] programs = new ComputeSource[99];
+		ComputeSource[] programs = new ComputeSource[100];
 
 		for (int i = 0; i < programs.length; i++) {
 			String suffix = i == 0 ? "" : Integer.toString(i);

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -221,8 +221,6 @@ public NewWorldRenderingPipeline(ProgramSet programSet) throws IOException {
 			}
 		});
 
-		this.shadowComputes = createShadowComputes(programSet.getShadowCompute(), programSet);
-
 		this.renderTargets = new RenderTargets(main.width, main.height, depthTextureId, ((Blaze3dRenderTargetExt) main).iris$getDepthBufferVersion(), depthBufferFormat, programSet.getPackDirectives().getRenderTargetDirectives().getRenderTargetSettings(), programSet.getPackDirectives());
 		this.sunPathRotation = programSet.getPackDirectives().getSunPathRotation();
 
@@ -282,6 +280,8 @@ public NewWorldRenderingPipeline(ProgramSet programSet) throws IOException {
 			}
 		}
 
+		this.shadowComputes = createShadowComputes(programSet.getShadowCompute(), programSet);
+
 		this.beginRenderer = new CompositeRenderer(this, programSet.getPackDirectives(), programSet.getBegin(), programSet.getBeginCompute(), renderTargets,
 			customTextureManager.getNoiseTexture(), updateNotifier, centerDepthSampler, flipper, shadowTargetsSupplier, TextureStage.BEGIN,
 			customTextureManager.getCustomTextureIdMap().getOrDefault(TextureStage.BEGIN, Object2ObjectMaps.emptyMap()), customTextureManager.getIrisCustomTextures(), customImages,

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/CommonTransformer.java
Patch:
@@ -123,6 +123,7 @@ public static void transform(
 		if (parameters.type.glShaderType == ShaderType.VERTEX) {
 			tree.parseAndInjectNode(t, ASTInjectionPoint.BEFORE_DECLARATIONS,
 					"out float iris_FogFragCoord;");
+			tree.prependMainFunctionBody(t, "iris_FogFragCoord = 0.0f;");
 		} else if (parameters.type.glShaderType == ShaderType.FRAGMENT) {
 			tree.parseAndInjectNode(t, ASTInjectionPoint.BEFORE_DECLARATIONS,
 					"in float iris_FogFragCoord;");

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/SodiumTransformer.java
Patch:
@@ -124,6 +124,7 @@ public static void injectVertInit(
 				"in vec4 a_PosId;",
 				"in vec4 a_Color;",
 				"in vec2 a_TexCoord;",
+				"in ivec2 a_LightCoord;",
 				"void _vert_init() {" +
 						"_vert_position = (a_PosId.xyz * " + parameters.positionScale + " + "
 						+ parameters.positionOffset + ");" +

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/vertex_format/MixinGlAbstractTesselation.java
Patch:
@@ -9,7 +9,7 @@
 
 @Mixin(GlAbstractTessellation.class)
 public class MixinGlAbstractTesselation {
-	@Redirect(method = "bindAttributes", at = @At(value = "INVOKE", target = "Lorg/lwjgl/opengl/GL20C;glVertexAttribPointer(IIIZIJ)V"))
+	@Redirect(method = "bindAttributes", at = @At(value = "INVOKE", target = "Lorg/lwjgl/opengl/GL20C;glVertexAttribPointer(IIIZIJ)V"), remap = false)
 	private void redirect(int index, int size, int type, boolean normalized, int stride, long pointer) {
 		if (type == GL30C.GL_UNSIGNED_SHORT && size == 2 && !normalized && pointer == 16) {
 			GL30C.glVertexAttribIPointer(index, size, type, stride, pointer);

File: src/main/java/net/coderbot/iris/texture/pbr/loader/SimplePBRLoader.java
Patch:
@@ -1,6 +1,5 @@
 package net.coderbot.iris.texture.pbr.loader;
 
-import net.coderbot.iris.Iris;
 import net.coderbot.iris.mixin.texture.SimpleTextureAccessor;
 import net.coderbot.iris.texture.pbr.PBRType;
 import net.minecraft.client.renderer.texture.AbstractTexture;
@@ -29,7 +28,7 @@ public void load(SimpleTexture texture, ResourceManager resourceManager, PBRText
 
 	@Nullable
 	protected AbstractTexture createPBRTexture(ResourceLocation imageLocation, ResourceManager resourceManager, PBRType pbrType) {
-		ResourceLocation pbrImageLocation = pbrType.appendToFileLocation(imageLocation, false);
+		ResourceLocation pbrImageLocation = imageLocation.withPath(pbrType::appendSuffix);
 
 		SimpleTexture pbrTexture = new SimpleTexture(pbrImageLocation);
 		try {

File: src/main/java/net/coderbot/iris/texture/pbr/PBRType.java
Patch:
@@ -1,5 +1,6 @@
 package net.coderbot.iris.texture.pbr;
 
+import net.coderbot.iris.Iris;
 import net.minecraft.resources.ResourceLocation;
 import org.apache.commons.io.FilenameUtils;
 import org.jetbrains.annotations.Nullable;
@@ -35,6 +36,8 @@ public ResourceLocation appendToFileLocation(ResourceLocation location, boolean
 		} else {
 			newPath = path + suffix;
 		}
+		// Temporary fix for CIT Resewn. CIT Resewn has atlases that are not in the textures/ folder, so a custom check must be used here to avoid that assumption.
+		if (newPath.startsWith("optifine/cit")) return new ResourceLocation(location.getNamespace(), newPath + ".png");
 		return new ResourceLocation(location.getNamespace(), isAtlas ? "textures/" + newPath + ".png" : newPath);
 	}
 

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/CompatibilityTransformer.java
Patch:
@@ -308,7 +308,7 @@ private static Statement getInitializer(Root root, String name, Type type) {
 				new Identifier(name),
 				type.isScalar()
 						? LiteralExpression.getDefaultValue(type)
-						: Root.indexNodes(root, () -> new FunctionCallExpression(
+						: root.indexNodes(() -> new FunctionCallExpression(
 								new Identifier(type.getMostCompactName()),
 								Stream.of(LiteralExpression.getDefaultValue(type)))));
 	}

File: src/main/java/net/coderbot/iris/pipeline/newshader/ShaderKey.java
Patch:
@@ -45,7 +45,7 @@ public enum ShaderKey {
 	HAND_WATER_DIFFUSE     (ProgramId.HandWater,   AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.DIFFUSE_LM),
 	LIGHTNING              (ProgramId.Entities,    AlphaTests.OFF,             DefaultVertexFormat.POSITION_COLOR,              FogMode.PER_VERTEX,   LightingModel.FULLBRIGHT),
 	LEASH                  (ProgramId.Basic,       AlphaTests.OFF,             DefaultVertexFormat.POSITION_COLOR_LIGHTMAP,     FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
-	TEXT_BG                (ProgramId.Basic,       AlphaTests.OFF,             DefaultVertexFormat.POSITION_COLOR_LIGHTMAP,     FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
+	TEXT_BG                (ProgramId.EntitiesTrans,AlphaTests.ONE_TENTH_ALPHA,DefaultVertexFormat.POSITION_COLOR_LIGHTMAP,     FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	PARTICLES              (ProgramId.TexturedLit, AlphaTests.ONE_TENTH_ALPHA, DefaultVertexFormat.PARTICLE,                    FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	WEATHER                (ProgramId.Weather,     AlphaTests.ONE_TENTH_ALPHA, DefaultVertexFormat.PARTICLE,                    FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	CRUMBLING              (ProgramId.DamagedBlock,AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.TERRAIN,                       FogMode.OFF,          LightingModel.LIGHTMAP  ),

File: src/main/java/net/coderbot/iris/mixin/texture/SpriteContentsFrameInfoAccessor.java
Patch:
@@ -1,10 +1,11 @@
 package net.coderbot.iris.mixin.texture;
 
+import net.minecraft.client.renderer.texture.SpriteContents;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
 
-@Mixin(targets = "net/minecraft/client/renderer/texture/SpriteContents$FrameInfo")
-public interface FrameInfoAccessor {
+@Mixin(SpriteContents.FrameInfo.class)
+public interface SpriteContentsFrameInfoAccessor {
 	@Accessor("index")
 	int getIndex();
 

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/pbr_animation/MixinSpriteContents.java
Patch:
@@ -6,13 +6,12 @@
 import net.minecraft.client.renderer.texture.SpriteContents;
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 import org.spongepowered.asm.mixin.Mixin;
-import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
 @Mixin(SpriteContents.class)
-public abstract class MixinTextureAtlasSprite {
+public abstract class MixinSpriteContents {
 	@Inject(method = "setActive(Z)V", at = @At("TAIL"), remap = false)
 	private void iris$onTailMarkActive(CallbackInfo ci) {
 		PBRSpriteHolder pbrHolder = ((SpriteContentsExtension) this).getPBRHolder();

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -793,6 +793,8 @@ public void beginLevelRendering() {
 			horizonRenderer.renderHorizon(CapturedRenderingState.INSTANCE.getGbufferModelView(), CapturedRenderingState.INSTANCE.getGbufferProjection(), GameRenderer.getPositionShader());
 
 			RenderSystem.depthMask(true);
+
+			RenderSystem.setShaderColor(1.0f, 1.0f, 1.0f, 1.0f);
 		}
 	}
 

File: src/main/java/net/coderbot/iris/shaderpack/discovery/ShaderpackDirectoryManager.java
Patch:
@@ -8,6 +8,7 @@
 import java.nio.file.Path;
 import java.util.Collection;
 import java.util.Comparator;
+import java.util.List;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
@@ -55,7 +56,7 @@ public void copyPackIntoDirectory(String name, Path source) throws IOException {
 		}
 	}
 
-	public Collection<String> enumerate() throws IOException {
+	public List<String> enumerate() throws IOException {
 		// Make sure the list is sorted since not all OSes sort the list of files in the directory.
 		// Case-insensitive sorting is the most intuitive for the user, but we then sort naturally
 		// afterwards so that we don't alternate cases weirdly in the sorted list.

File: src/main/java/net/coderbot/iris/gbuffer_overrides/matching/InputAvailability.java
Patch:
@@ -53,9 +53,9 @@ public String toString() {
 	public int hashCode() {
 		final int prime = 31;
 		int result = 1;
+		result = prime * result + (texture ? 1231 : 1237);
 		result = prime * result + (lightmap ? 1231 : 1237);
 		result = prime * result + (overlay ? 1231 : 1237);
-		result = prime * result + (texture ? 1231 : 1237);
 		return result;
 	}
 
@@ -68,12 +68,12 @@ public boolean equals(Object obj) {
 		if (getClass() != obj.getClass())
 			return false;
 		InputAvailability other = (InputAvailability) obj;
+		if (texture != other.texture)
+			return false;
 		if (lightmap != other.lightmap)
 			return false;
 		if (overlay != other.overlay)
 			return false;
-		if (texture != other.texture)
-			return false;
 		return true;
 	}
 }

File: src/main/java/net/coderbot/iris/gl/texture/PixelType.java
Patch:
@@ -24,7 +24,7 @@ public enum PixelType {
 	UNSIGNED_SHORT_4_4_4_4_REV(GL12C.GL_UNSIGNED_SHORT_4_4_4_4_REV, GlVersion.GL_12),
 	UNSIGNED_SHORT_5_5_5_1(GL12C.GL_UNSIGNED_SHORT_5_5_5_1, GlVersion.GL_12),
 	UNSIGNED_SHORT_1_5_5_5_REV(GL12C.GL_UNSIGNED_SHORT_1_5_5_5_REV, GlVersion.GL_12),
-	UNSIGNED_INT(GL11C.GL_UNSIGNED_BYTE, GlVersion.GL_11),
+	UNSIGNED_INT(GL11C.GL_UNSIGNED_INT, GlVersion.GL_11),
 	UNSIGNED_INT_8_8_8_8(GL12C.GL_UNSIGNED_INT_8_8_8_8, GlVersion.GL_12),
 	UNSIGNED_INT_8_8_8_8_REV(GL12C.GL_UNSIGNED_INT_8_8_8_8_REV, GlVersion.GL_12),
 	UNSIGNED_INT_10_10_10_2(GL12C.GL_UNSIGNED_INT_10_10_10_2, GlVersion.GL_12),

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderer.java
Patch:
@@ -276,7 +276,6 @@ public void renderAll() {
 			renderPass.framebuffer.bind();
 			renderPass.program.use();
 			if (renderPass.blendModeOverride != null) {
-				System.out.println("BLENDING ");
 				renderPass.blendModeOverride.apply();
 			}
 

File: src/main/java/net/coderbot/iris/shaderpack/parsing/ParsedString.java
Patch:
@@ -146,7 +146,7 @@ public String takeNumber() {
 		if (!(text.length() <= position)) {
 			char next = text.charAt(position);
 
-			if (!Character.isWhitespace(next)) {
+			if (!Character.isWhitespace(next) && next != ';') {
 				return null;
 			}
 		}

File: src/main/java/net/coderbot/iris/uniforms/IrisExclusiveUniforms.java
Patch:
@@ -115,7 +115,7 @@ public static class WorldInfoUniforms {
 		public static void addWorldInfoUniforms(UniformHolder uniforms) {
 			ClientLevel level = Minecraft.getInstance().level;
 			// TODO: Use level.dimensionType() coordinates for 1.18!
-			uniforms.uniform1i(UniformUpdateFrequency.PER_FRAME, "bedrockLevel", () -> 0);
+			uniforms.uniform1i(UniformUpdateFrequency.PER_FRAME, "bedrockLevel", () -> level.dimensionType().minY());
 			uniforms.uniform1i(UniformUpdateFrequency.PER_FRAME, "heightLimit", () -> {
 				if (level != null) {
 					return level.getMaxBuildHeight();

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -80,7 +80,6 @@
 import net.minecraft.client.renderer.DimensionSpecialEffects;
 import net.minecraft.client.renderer.GameRenderer;
 import net.minecraft.client.renderer.texture.AbstractTexture;
-import net.minecraft.network.chat.TranslatableComponent;
 import org.jetbrains.annotations.Nullable;
 import org.lwjgl.opengl.GL;
 import org.lwjgl.opengl.GL11C;
@@ -1223,7 +1222,6 @@ public void beginLevelRendering() {
 		if (showSSBOError) {
 			showSSBOError = false;
 			if (Minecraft.getInstance().player != null) {
-				Minecraft.getInstance().player.displayClientMessage(new TranslatableComponent("iris.shaders.ssbofailure"), false);
 			}
 		}
 

File: src/main/java/net/coderbot/iris/shaderpack/ShaderPack.java
Patch:
@@ -28,6 +28,7 @@
 import net.irisshaders.iris.api.v0.IrisApi;
 import net.minecraft.client.Minecraft;
 import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
 import org.apache.commons.lang3.SystemUtils;
 import org.jetbrains.annotations.Nullable;
 
@@ -152,12 +153,12 @@ public ShaderPack(Path root, Map<String, String> changedConfigs, Iterable<String
 
 		if (!invalidFeatureFlags.isEmpty()) {
 			if (Minecraft.getInstance().screen instanceof ShaderPackScreen) {
-				Component component = Component.translatable("iris.unsupported.pack.description", FeatureFlags.getInvalidStatus(invalidFlagList), invalidFeatureFlags.stream()
+				MutableComponent component = Component.translatable("iris.unsupported.pack.description", FeatureFlags.getInvalidStatus(invalidFlagList), invalidFeatureFlags.stream()
 					.collect(Collectors.joining(", ", ": ", ".")));
 				if (SystemUtils.IS_OS_MAC) {
 					component = component.append(Component.translatable("iris.unsupported.pack.macos"));
 				}
-				Minecraft.getInstance().setScreen(new FeatureMissingErrorScreen(Minecraft.getInstance().screen, new TranslatableComponent("iris.unsupported.pack"), component));
+				Minecraft.getInstance().setScreen(new FeatureMissingErrorScreen(Minecraft.getInstance().screen, Component.translatable("iris.unsupported.pack"), component));
 			}
 			IrisApi.getInstance().getConfig().setShadersEnabledAndApply(false);
 		}

File: src/main/java/net/coderbot/iris/gbuffer_overrides/matching/InputAvailability.java
Patch:
@@ -53,9 +53,9 @@ public String toString() {
 	public int hashCode() {
 		final int prime = 31;
 		int result = 1;
+		result = prime * result + (texture ? 1231 : 1237);
 		result = prime * result + (lightmap ? 1231 : 1237);
 		result = prime * result + (overlay ? 1231 : 1237);
-		result = prime * result + (texture ? 1231 : 1237);
 		return result;
 	}
 
@@ -68,12 +68,12 @@ public boolean equals(Object obj) {
 		if (getClass() != obj.getClass())
 			return false;
 		InputAvailability other = (InputAvailability) obj;
+		if (texture != other.texture)
+			return false;
 		if (lightmap != other.lightmap)
 			return false;
 		if (overlay != other.overlay)
 			return false;
-		if (texture != other.texture)
-			return false;
 		return true;
 	}
 }

File: src/main/java/net/coderbot/iris/gbuffer_overrides/matching/InputAvailability.java
Patch:
@@ -53,9 +53,9 @@ public String toString() {
 	public int hashCode() {
 		final int prime = 31;
 		int result = 1;
+		result = prime * result + (texture ? 1231 : 1237);
 		result = prime * result + (lightmap ? 1231 : 1237);
 		result = prime * result + (overlay ? 1231 : 1237);
-		result = prime * result + (texture ? 1231 : 1237);
 		return result;
 	}
 
@@ -68,12 +68,12 @@ public boolean equals(Object obj) {
 		if (getClass() != obj.getClass())
 			return false;
 		InputAvailability other = (InputAvailability) obj;
+		if (texture != other.texture)
+			return false;
 		if (lightmap != other.lightmap)
 			return false;
 		if (overlay != other.overlay)
 			return false;
-		if (texture != other.texture)
-			return false;
 		return true;
 	}
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/clouds/MixinCloudRenderer.java
Patch:
@@ -173,7 +173,7 @@ private int allocateNewSize(int size) {
 		return IrisApi.getInstance().isShaderPackInUse() ? 480 : size;
 	}
 
-	@Inject(method = "writeVertex", at = @At("HEAD"), cancellable = true)
+	@Inject(method = "writeVertex", at = @At("HEAD"), cancellable = true, remap = false)
 	private static void writeIrisVertex(long buffer, float x, float y, float z, int color, CallbackInfoReturnable<Long> cir) {
 		if (IrisApi.getInstance().isShaderPackInUse()) {
 			CloudVertex.write(buffer, x, y, z, color);

File: src/main/java/net/coderbot/iris/pipeline/newshader/ExtendedShader.java
Patch:
@@ -132,11 +132,11 @@ public void clear() {
 
 	Matrix4f tempMatrix4f = new Matrix4f();
 	Matrix3f tempMatrix3f = new Matrix3f();
-	private static final com.mojang.math.Matrix4f identity;
+	private static final Matrix4f identity;
 
 	static {
-		identity = new com.mojang.math.Matrix4f();
-		identity.setIdentity();
+		identity = new Matrix4f();
+		identity.identity();
 	}
 
 	float[] tempFloats = new float[16];

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -43,7 +43,7 @@ public class Buildscript extends SimpleFabricProject {
 	static final boolean SODIUM = true;
 	static final boolean CUSTOM_SODIUM = true;
 	static final String MC_VERSION = "1.19.3";
-	static final String customSodiumName = "sodium-fabric-mc1.19.3-0.4.9+rev.c1146dc.jar";
+	static final String customSodiumName = "sodium-fabric-mc1.19.3-0.4.9+rev.9b7fe2c.jar";
 
 	private static final String[] SOURCE_SETS = new String[] {
 		"main",

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/separate_ao/MixinFluidRenderer.java
Patch:
@@ -29,7 +29,7 @@ public class MixinFluidRenderer {
         this.useSeparateAo = BlockRenderingSettings.INSTANCE.shouldUseSeparateAo();
     }
 
-    @Redirect(method = "calculateQuadColors", remap = false,
+    @Redirect(method = "updateQuad", remap = false,
             at = @At(value = "INVOKE", target = "me/jellysquid/mods/sodium/client/util/color/ColorABGR.mul (IF)I", remap = false))
     private int iris$applySeparateAo(int color, float ao) {
         if (useSeparateAo) {

File: src/main/java/net/coderbot/iris/uniforms/IrisExclusiveUniforms.java
Patch:
@@ -107,7 +107,8 @@ private static boolean isSpectator() {
 
 	private static Vector3d getEyePosition() {
 		Objects.requireNonNull(Minecraft.getInstance().getCameraEntity());
-		return new Vector3d(Minecraft.getInstance().getCameraEntity().getX(), Minecraft.getInstance().getCameraEntity().getEyeY(), Minecraft.getInstance().getCameraEntity().getZ());
+		Vec3 pos = Minecraft.getInstance().getCameraEntity().getEyePosition(CapturedRenderingState.INSTANCE.getTickDelta());
+		return new Vector3d(pos.x, pos.y, pos.z);
 	}
 
 	public static class WorldInfoUniforms {

File: src/main/java/net/coderbot/iris/shaderpack/PackShadowDirectives.java
Patch:
@@ -295,14 +295,14 @@ private static void acceptColorFilteringSettings(DirectiveHolder directives, Int
 	}
 
 	private void acceptBufferDirectives(DirectiveHolder directives, Int2ObjectMap<SamplingSettings> settings) {
-		for (int i = 0; i < settings.size(); i++) {
+		for (int i = 0; i < PackShadowDirectives.MAX_SHADOW_COLOR_BUFFERS_IRIS; i++) {
 			String bufferName = "shadowcolor" + i;
 			int finalI = i;
 			directives.acceptConstStringDirective(bufferName + "Format", format -> {
 				Optional<InternalTextureFormat> internalFormat = InternalTextureFormat.fromString(format);
 
 				if (internalFormat.isPresent()) {
-					settings.get(finalI).setFormat(internalFormat.get());
+					settings.computeIfAbsent(finalI, sa -> new SamplingSettings()).setFormat(internalFormat.get());
 				} else {
 					Iris.logger.warn("Unrecognized internal texture format " + format + " specified for " + bufferName + "Format, ignoring.");
 				}

File: src/main/java/net/coderbot/iris/features/FeatureFlags.java
Patch:
@@ -5,6 +5,7 @@
 import org.apache.commons.lang3.text.WordUtils;
 
 import java.util.List;
+import java.util.Locale;
 import java.util.function.BooleanSupplier;
 
 public enum FeatureFlags {
@@ -56,15 +57,15 @@ public boolean isUsable() {
 
 	public static boolean isInvalid(String name) {
 		try {
-			return !FeatureFlags.valueOf(name).isUsable();
+			return !FeatureFlags.valueOf(name.toUpperCase(Locale.US)).isUsable();
 		} catch (IllegalArgumentException e) {
 			return true;
 		}
 	}
 
 	public static FeatureFlags getValue(String value) {
 		try {
-			return FeatureFlags.valueOf(value);
+			return FeatureFlags.valueOf(value.toUpperCase(Locale.US));
 		} catch (IllegalArgumentException e) {
 			return FeatureFlags.UNKNOWN;
 		}

File: src/main/java/net/coderbot/iris/gl/buffer/ShaderStorageBuffer.java
Patch:
@@ -26,7 +26,8 @@ public final long getSize() {
 	@Override
 	protected void destroyInternal() {
 		IrisRenderSystem.bindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, index, 0);
-		GlStateManager._glDeleteBuffers(getGlId());
+		// DO NOT use the GlStateManager version here! On Linux, it will attempt to clear the data using BufferData and cause GL errors.
+		IrisRenderSystem.deleteBuffers(getGlId());
 	}
 
 	public void bind() {

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -88,7 +88,7 @@ public static ExtendedShader create(WorldRenderingPipeline pipeline, String name
 
 		String shaderJsonString = shaderJson.toString();
 
-		PatchedShaderPrinter.debugPatchedShaders(source.getName(), vertex, geometry, fragment, shaderJsonString);
+		PatchedShaderPrinter.debugPatchedShaders(name, vertex, geometry, fragment, shaderJsonString);
 
 		ResourceProvider shaderResourceFactory = new IrisProgramResourceFactory(shaderJsonString, vertex, geometry, fragment);
 

File: src/main/java/net/coderbot/iris/features/FeatureFlags.java
Patch:
@@ -9,9 +9,12 @@
 
 public enum FeatureFlags {
 	SEPARATE_HARDWARE_SAMPLERS(() -> true, () -> true),
+	HIGHER_SHADOWCOLOR(() -> true, () -> true),
+	CUSTOM_IMAGES(() -> true, IrisRenderSystem::supportsImageLoadStore),
 	PER_BUFFER_BLENDING(() -> true, IrisRenderSystem::supportsBufferBlending),
 	COMPUTE_SHADERS(() -> true, IrisRenderSystem::supportsCompute),
 	ENTITY_TRANSLUCENT(() -> true, () -> true),
+	SSBO(() -> true, IrisRenderSystem::supportsSSBO),
 	UNKNOWN(() -> false, () -> false);
 
 	private final BooleanSupplier irisRequirement;

File: src/main/java/net/coderbot/iris/gl/shader/StandardMacros.java
Patch:
@@ -46,6 +46,7 @@ public static Iterable<StringPair> createStandardEnvironmentDefines() {
 		define(standardDefines, getOsString());
 		define(standardDefines, getVendor());
 		define(standardDefines, getRenderer());
+		define(standardDefines, "IS_IRIS");
 
 		for (String glExtension : getGlExtensions()) {
 			define(standardDefines, glExtension);

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -267,12 +267,12 @@ public NewWorldRenderingPipeline(ProgramSet programSet) throws IOException {
 			} else {
 				Iris.logger.fatal("Shader storage buffers/immutable buffer storage is not supported on this graphics card, however the shaderpack requested them? Let's hope it's not a problem.");
 				for (int i = 0; i < 16; i++) {
-					IrisRenderSystem.bindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, i, i);
+					IrisRenderSystem.bindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, i, 0);
 				}
 			}
 		} else {
 			for (int i = 0; i < 16; i++) {
-				IrisRenderSystem.bindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, i, i);
+				IrisRenderSystem.bindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, i, 0);
 			}
 		}
 

File: src/main/java/net/coderbot/iris/samplers/IrisSamplers.java
Patch:
@@ -196,7 +196,7 @@ public static void addCustomTextures(SamplerHolder samplers, Object2ObjectMap<St
 	public static void addCustomImages(SamplerHolder images, Set<GlImage> customImages) {
 		customImages.forEach(image -> {
 			if (image.getSamplerName() != null) {
-				images.addDynamicSampler(image::getId, image.getSamplerName());
+				images.addDynamicSampler(image.getTarget(), image::getId, image.getSamplerName());
 			}
 		});
 	}

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -256,7 +256,7 @@ public NewWorldRenderingPipeline(ProgramSet programSet) throws IOException {
 
 		this.beginRenderer = new CompositeRenderer(this, programSet.getPackDirectives(), programSet.getBegin(), programSet.getBeginCompute(), renderTargets,
 			customTextureManager.getNoiseTexture(), updateNotifier, centerDepthSampler, flipper, shadowTargetsSupplier, TextureStage.BEGIN,
-			customTextureManager.getCustomTextureIdMap().getOrDefault(TextureStage.BEGIN, Object2ObjectMaps.emptyMap()), customTextureManager.getIrisCustomTextures(),
+			customTextureManager.getCustomTextureIdMap().getOrDefault(TextureStage.BEGIN, Object2ObjectMaps.emptyMap()), customTextureManager.getIrisCustomTextures(), customImages,
 			programSet.getPackDirectives().getExplicitFlips("begin_pre"), customUniforms);
 
 		flippedBeforeShadow = flipper.snapshot();
@@ -568,6 +568,7 @@ private ComputeProgram[] createSetupComputes(ComputeSource[] compute, ProgramSet
 				IrisSamplers.addCustomTextures(builder, customTextureManager.getIrisCustomTextures());
 				IrisSamplers.addCompositeSamplers(builder, renderTargets);
 				IrisImages.addRenderTargetImages(builder, flipped, renderTargets);
+				IrisImages.addCustomImages(builder, customImages);
 
 				IrisSamplers.addNoiseSampler(customTextureSamplerInterceptor, customTextureManager.getNoiseTexture());
 

File: src/main/java/net/coderbot/iris/shaderpack/ShaderProperties.java
Patch:
@@ -203,7 +203,7 @@ public ShaderProperties(String contents, ShaderPackOptions shaderPackOptions, It
 			});
 
 			handlePassDirective("alphaTest.", key, value, pass -> {
-				if ("off".equals(value)) {
+				if ("off".equals(value) || "false".equals(value)) {
 					alphaTestOverrides.put(pass, AlphaTest.ALWAYS);
 					return;
 				}

File: src/main/java/net/coderbot/iris/compat/sodium/SodiumVersionCheck.java
Patch:
@@ -24,7 +24,7 @@ public static String getDownloadLink() {
 
 	public static boolean isAllowedVersion(String sodiumVersion) {
 		for (AllowedSodiumVersion allowed : ALLOWED_SODIUM_VERSIONS) {
-			if (allowed.matches(sodiumVersion) || FabricLoader.getInstance().isDevelopmentEnvironment()) {
+			if (allowed.matches(sodiumVersion)) {
 				return true;
 			}
 		}

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/IrisSodiumCompatMixinPlugin.java
Patch:
@@ -22,7 +22,7 @@ public void onLoad(String mixinPackage) {
 		validSodiumVersion = FabricLoader.getInstance().getModContainer("sodium").map(sodium -> {
 			String version = sodium.getMetadata().getVersion().getFriendlyString();
 
-			return SodiumVersionCheck.isAllowedVersion(version);
+			return FabricLoader.getInstance().isDevelopmentEnvironment() || SodiumVersionCheck.isAllowedVersion(version);
 		}).orElse(false);
 
 		if (!validSodiumVersion) {

File: src/main/java/net/coderbot/iris/compat/sodium/SodiumVersionCheck.java
Patch:
@@ -24,7 +24,7 @@ public static String getDownloadLink() {
 
 	public static boolean isAllowedVersion(String sodiumVersion) {
 		for (AllowedSodiumVersion allowed : ALLOWED_SODIUM_VERSIONS) {
-			if (allowed.matches(sodiumVersion)) {
+			if (allowed.matches(sodiumVersion) || FabricLoader.getInstance().isDevelopmentEnvironment()) {
 				return true;
 			}
 		}

File: src/main/java/net/coderbot/iris/pipeline/newshader/ShaderKey.java
Patch:
@@ -20,6 +20,7 @@ public enum ShaderKey {
 	SKY_TEXTURED           (ProgramId.SkyTextured, AlphaTests.OFF,             DefaultVertexFormat.POSITION_TEX,                FogMode.OFF,          LightingModel.LIGHTMAP  ),
 	SKY_TEXTURED_COLOR     (ProgramId.SkyTextured, AlphaTests.OFF,             DefaultVertexFormat.POSITION_TEX_COLOR,          FogMode.OFF,          LightingModel.LIGHTMAP  ),
 	CLOUDS                 (ProgramId.Clouds,      AlphaTests.ONE_TENTH_ALPHA, DefaultVertexFormat.POSITION_TEX_COLOR_NORMAL,   FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
+	CLOUDS_SODIUM          (ProgramId.Clouds,      AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.CLOUDS,					    FogMode.PER_FRAGMENT, LightingModel.LIGHTMAP  ),
 	TERRAIN_SOLID          (ProgramId.Terrain,     AlphaTests.OFF,             IrisVertexFormats.TERRAIN,                       FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	TERRAIN_CUTOUT         (ProgramId.Terrain,     AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.TERRAIN,                       FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	TERRAIN_CUTOUT_MIPPED  (ProgramId.Terrain,     AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.TERRAIN,                       FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/CommonTransformer.java
Patch:
@@ -23,7 +23,6 @@
 import io.github.douira.glsl_transformer.ast.node.type.specifier.BuiltinFixedTypeSpecifier.BuiltinType.TypeKind;
 import io.github.douira.glsl_transformer.ast.node.type.specifier.TypeSpecifier;
 import io.github.douira.glsl_transformer.ast.query.Root;
-import io.github.douira.glsl_transformer.ast.query.index.PrefixIdentifierIndex;
 import io.github.douira.glsl_transformer.ast.query.match.AutoHintedMatcher;
 import io.github.douira.glsl_transformer.ast.query.match.Matcher;
 import io.github.douira.glsl_transformer.ast.transform.ASTInjectionPoint;
@@ -331,7 +330,7 @@ public static void replaceGlMultiTexCoordBounded(
 			int minimum,
 			int maximum) {
 		root.replaceReferenceExpressions(t,
-				((PrefixIdentifierIndex<?, ?>) root.identifierIndex).prefixQueryFlat("gl_MultiTexCoord")
+				root.getPrefixIdentifierIndex().prefixQueryFlat("gl_MultiTexCoord")
 						.filter(id -> {
 							int index = Integer.parseInt(id.getName().substring("gl_MultiTexCoord".length()));
 							return index >= minimum && index <= maximum;

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/CompatibilityTransformer.java
Patch:
@@ -366,7 +366,7 @@ public static void transformGrouped(
 			Root prevRoot = prevTree.getRoot();
 
 			// test if the prefix tag is used for some reason
-			if (((PrefixIdentifierIndex<?, ?>) prevRoot.identifierIndex).prefixQueryFlat(tagPrefix).findAny().isPresent()) {
+			if (prevRoot.getPrefixIdentifierIndex().prefixQueryFlat(tagPrefix).findAny().isPresent()) {
 				LOGGER.warn("The prefix tag " + tagPrefix + " is used in the shader, bailing compatibility transformation.");
 				return;
 			}

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/TextureTransformer.java
Patch:
@@ -20,7 +20,6 @@ public static void transform(
 			Root root,
 			TextureStage stage, Object2ObjectMap<Tri<String, TextureType, TextureStage>, String> textureMap) {
 		textureMap.forEach((stringTextureTypeTextureStageTri, s) -> {
-			Iris.logger.warn("A " + stringTextureTypeTextureStageTri.toString() + " " + s);
 			if (stringTextureTypeTextureStageTri.getThird() == stage) {
 				String name = stringTextureTypeTextureStageTri.getFirst();
 

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -61,7 +61,7 @@ private CommonUniforms() {
 	public static void addDynamicUniforms(DynamicUniformHolder uniforms, FogMode fogMode) {
 		ExternallyManagedUniforms.addExternallyManagedUniforms117(uniforms);
 		FogUniforms.addFogUniforms(uniforms, fogMode);
-		IrisInternalUniforms.addFogUniforms(uniforms);
+		IrisInternalUniforms.addFogUniforms(uniforms, fogMode);
 
 		// TODO: OptiFine doesn't think that atlasSize is a "dynamic" uniform,
 		//       but we do. How will custom uniforms depending on atlasSize work?

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/CompatibilityTransformer.java
Patch:
@@ -106,11 +106,11 @@ public static void transformEach(ASTParser t, TranslationUnit tree, Root root, P
 				unusedFunctions.add(definition);
 				if (PatchedShaderPrinter.prettyPrintShaders) {
 					LOGGER.warn("Removing unused function " + functionName);
-				} else if (unusedFunctions.size() == 1) {
+				}/* else if (unusedFunctions.size() == 1) {
 					LOGGER.warn(
 							"Removing unused function " + functionName
 									+ " and omitting further such messages outside of debug mode. See debugging.md for more information.");
-				}
+				}*/
 				continue;
 			}
 

File: src/main/java/net/coderbot/iris/pipeline/transform/transformer/TextureTransformer.java
Patch:
@@ -20,7 +20,6 @@ public static void transform(
 			Root root,
 			TextureStage stage, Object2ObjectMap<Tri<String, TextureType, TextureStage>, String> textureMap) {
 		textureMap.forEach((stringTextureTypeTextureStageTri, s) -> {
-			Iris.logger.warn("A " + stringTextureTypeTextureStageTri.toString() + " " + s);
 			if (stringTextureTypeTextureStageTri.getThird() == stage) {
 				String name = stringTextureTypeTextureStageTri.getFirst();
 

File: src/main/java/net/coderbot/iris/shaderpack/preprocessor/PropertiesPreprocessor.java
Patch:
@@ -112,7 +112,7 @@ private static String process(Preprocessor preprocessor, String source) {
 
 		source = builder.toString();
 
-		return listener.collectLines() + source.replace("IRIS_PASSTHROUGHBACKSLASH", "\\");
+		return (listener.collectLines() + source).replace("IRIS_PASSTHROUGHBACKSLASH", "\\");
 	}
 
 	private static List<String> getBooleanValues(ShaderPackOptions shaderPackOptions) {

File: src/main/java/net/coderbot/iris/uniforms/custom/CustomUniforms.java
Patch:
@@ -306,7 +306,7 @@ public void addVariable(String type, String name, String expression, boolean isU
 				ExpressionElement ast = Parser.parse(expression, IrisOptions.options);
 				variables.put(name, new Variable(parsedType, name, ast, isUniform));
 			} catch (Exception e) {
-				Iris.logger.warn("Failed to parse custom variable/uniform");
+				Iris.logger.warn("Failed to parse custom variable/uniform", e);
 			}
 		}
 

File: src/main/java/net/coderbot/iris/mixin/texture/MixinSpriteLoader.java
Patch:
@@ -14,7 +14,7 @@ public class MixinSpriteLoader {
 	@Inject(method = "loadSprite", at = @At(value = "HEAD"), cancellable = true)
 	private static void editMap(ResourceLocation location, Resource arg2, CallbackInfoReturnable<SpriteContents> ci) {
 		// TODO: sga_x is the enchanting table particles, we REALLY need a better way to do this.
-		if (!(arg2.source().packId().equals("vanilla") && arg2.source().isBuiltin()) && !location.getPath().startsWith("sga") && (location.getPath().endsWith("_n") || location.getPath().endsWith("_s") || location.getPath().endsWith("_n.png") || location.getPath().endsWith("_s.png"))) {
+		if (!(arg2.sourcePackId().equals("vanilla") && arg2.isBuiltin()) && !location.getPath().startsWith("sga") && (location.getPath().endsWith("_n") || location.getPath().endsWith("_s") || location.getPath().endsWith("_n.png") || location.getPath().endsWith("_s.png"))) {
 			ci.setReturnValue(null);
 		}
 	}

File: src/main/java/net/coderbot/iris/shaderpack/ShaderProperties.java
Patch:
@@ -302,6 +302,8 @@ public ShaderProperties(String contents, ShaderPackOptions shaderPackOptions, It
 
 			handleTwoArgDirective("texture.", key, value, (stageName, samplerName) -> {
 				String[] parts = value.split(" ");
+				// TODO: Is there a better way to achieve this?
+				samplerName = samplerName.split("\\.")[0];
 
 				Optional<TextureStage> optionalTextureStage = TextureStage.parse(stageName);
 

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -119,7 +119,6 @@ public static void generalCommonUniforms(UniformHolder uniforms, FrameUpdateNoti
 
 		uniforms
 			.uniform1b(PER_FRAME, "hideGUI", () -> client.options.hideGui)
-			.uniform1f(PER_FRAME, "eyeAltitude", () -> Objects.requireNonNull(client.getCameraEntity()).getEyeY())
 			.uniform1i(PER_FRAME, "isEyeInWater", CommonUniforms::isEyeInWater)
 			.uniform1f(PER_FRAME, "blindness", CommonUniforms::getBlindness)
 			.uniform1f(PER_FRAME, "nightVision", CommonUniforms::getNightVision)

File: src/main/java/net/coderbot/iris/uniforms/FogUniforms.java
Patch:
@@ -25,7 +25,7 @@ public static void addFogUniforms(DynamicUniformHolder uniforms, FogMode fogMode
 			uniforms.uniform1i("fogMode", () -> {
 				float fogDensity = CapturedRenderingState.INSTANCE.getFogDensity();
 
-				if (fogDensity < 0.0F) {
+				if (fogDensity > 0.0F) {
 					return GL11.GL_LINEAR;
 				} else {
 					return GL11.GL_EXP2;

File: src/main/java/net/coderbot/iris/gl/IrisRenderSystem.java
Patch:
@@ -375,6 +375,9 @@ public void copyTexSubImage2D(int destTexture, int target, int i, int i1, int i2
 		@Override
 		public void bindTextureToUnit(int unit, int texture) {
 			ARBDirectStateAccess.glBindTextureUnit(unit, texture);
+
+			// Manually fix GLStateManager bindings...
+			GlStateManagerAccessor.getTEXTURES()[unit].binding = texture;
 		}
 
 		@Override

File: src/main/java/net/coderbot/iris/mixin/entity_render_context/MixinBlockEntityRenderDispatcher.java
Patch:
@@ -53,6 +53,6 @@ public class MixinBlockEntityRenderDispatcher {
 		RenderStateShard stateShard = BlockEntityRenderStateShard.forId(intId);
 
 		return type ->
-			bufferSource.getBuffer(new OuterWrappedRenderType("iris:is_block_entity", type, stateShard));
+			bufferSource.getBuffer(OuterWrappedRenderType.wrapExactlyOnce("iris:is_block_entity", type, stateShard));
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/entity_render_context/MixinEntityRenderDispatcher.java
Patch:
@@ -38,6 +38,6 @@ public class MixinEntityRenderDispatcher {
 		RenderStateShard phase = EntityRenderStateShard.forId(intId);
 
 		return type ->
-				bufferSource.getBuffer(new OuterWrappedRenderType("iris:is_entity", type, phase));
+				bufferSource.getBuffer(OuterWrappedRenderType.wrapExactlyOnce("iris:is_entity", type, phase));
 	}
 }

File: src/main/java/net/coderbot/iris/pipeline/newshader/ShaderKey.java
Patch:
@@ -45,7 +45,7 @@ public enum ShaderKey {
 	LEASH                  (ProgramId.Basic,       AlphaTests.OFF,             DefaultVertexFormat.POSITION_COLOR_LIGHTMAP,     FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	PARTICLES              (ProgramId.TexturedLit, AlphaTests.ONE_TENTH_ALPHA, DefaultVertexFormat.PARTICLE,                    FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	WEATHER                (ProgramId.Weather,     AlphaTests.ONE_TENTH_ALPHA, DefaultVertexFormat.PARTICLE,                    FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
-	CRUMBLING              (ProgramId.DamagedBlock,AlphaTests.ONE_TENTH_ALPHA, DefaultVertexFormat.BLOCK,                       FogMode.OFF,          LightingModel.LIGHTMAP  ),
+	CRUMBLING              (ProgramId.DamagedBlock,AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.TERRAIN,                       FogMode.OFF,          LightingModel.LIGHTMAP  ),
 	TEXT                   (ProgramId.Entities,    AlphaTests.NON_ZERO_ALPHA,  DefaultVertexFormat.POSITION_COLOR_TEX_LIGHTMAP, FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	TEXT_INTENSITY         (ProgramId.Entities,    AlphaTests.NON_ZERO_ALPHA,  DefaultVertexFormat.POSITION_COLOR_TEX_LIGHTMAP, FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	TEXT_BE                (ProgramId.Block,       AlphaTests.NON_ZERO_ALPHA,  DefaultVertexFormat.POSITION_COLOR_TEX_LIGHTMAP, FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),

File: src/main/java/net/coderbot/iris/gl/texture/GlTexture.java
Patch:
@@ -25,7 +25,6 @@ public GlTexture(TextureType target, int sizeX, int sizeY, int sizeZ, int intern
 		ByteBuffer buffer = MemoryUtil.memAlloc(pixels.length);
 		buffer.put(pixels);
 		buffer.flip();
-		Iris.logger.warn(" This is " + this.getGlId() + sizeX + sizeY + sizeZ + internalFormat + format + pixelType + buffer);
 		target.apply(this.getGlId(), sizeX, sizeY, sizeZ, internalFormat, format, pixelType, buffer);
 		MemoryUtil.memFree(buffer);
 

File: src/main/java/net/coderbot/iris/shadows/ShadowCompositeRenderer.java
Patch:
@@ -286,6 +286,7 @@ private Program createProgram(ProgramSource source, ImmutableSet<Integer> flippe
 		this.customUniforms.assignTo(builder);
 
 		IrisSamplers.addNoiseSampler(customTextureSamplerInterceptor, noiseTexture);
+		IrisSamplers.addCustomTextures(customTextureSamplerInterceptor, irisCustomTextures);
 
 		IrisSamplers.addShadowSamplers(customTextureSamplerInterceptor, targets, flipped);
 		IrisImages.addShadowColorImages(builder, targets, flipped);
@@ -320,6 +321,7 @@ private ComputeProgram[] createComputes(ComputeSource[] sources, ImmutableSet<In
 				CommonUniforms.addDynamicUniforms(builder, FogMode.OFF);
 				this.customUniforms.assignTo(builder);
 				IrisSamplers.addNoiseSampler(customTextureSamplerInterceptor, noiseTexture);
+				IrisSamplers.addCustomTextures(customTextureSamplerInterceptor, irisCustomTextures);
 
 				IrisSamplers.addShadowSamplers(customTextureSamplerInterceptor, targets, flipped);
 				IrisImages.addShadowColorImages(builder, targets, flipped);

File: src/main/java/net/coderbot/iris/pipeline/transform/TextureTransformer.java
Patch:
@@ -13,6 +13,7 @@
 import io.github.douira.glsl_transformer.ast.query.match.Matcher;
 import io.github.douira.glsl_transformer.ast.transform.ASTParser;
 import it.unimi.dsi.fastutil.objects.Object2ObjectMap;
+import net.coderbot.iris.Iris;
 import net.coderbot.iris.gl.texture.TextureType;
 import net.coderbot.iris.helpers.Tri;
 import net.coderbot.iris.shaderpack.texture.TextureStage;
@@ -43,6 +44,7 @@ public static void transform(
 		Root root,
 		TextureStage stage, Object2ObjectMap<Tri<String, TextureType, TextureStage>, String> textureMap) {
 		textureMap.forEach((stringTextureTypeTextureStageTri, s) -> {
+			Iris.logger.warn("A " + stringTextureTypeTextureStageTri.toString() + " " + s);
 			if (stringTextureTypeTextureStageTri.getThird() == stage) {
 				RenameTargetResult targetResult = getTextureRenameTargets(stringTextureTypeTextureStageTri.getFirst(), root);
 				if (targetResult != null && targetResult.extractedType.type == convertType(stringTextureTypeTextureStageTri.getSecond())) {

File: src/main/java/net/coderbot/iris/uniforms/BiomeParameters.java
Patch:
@@ -68,6 +68,8 @@ private static BiomeCategories getBiomeCategory(Holder<Biome> holder) {
 		if (holder.is(BiomeTags.WITHOUT_WANDERING_TRADER_SPAWNS)) {
 			// Literally only the void has this...
 			return BiomeCategories.NONE;
+		} else if (holder.is(BiomeTags.HAS_VILLAGE_SNOWY)) {
+			return BiomeCategories.ICY;
 		} else if (holder.is(BiomeTags.IS_HILL)) {
 			return BiomeCategories.EXTREME_HILLS;
 		} else if (holder.is(BiomeTags.IS_TAIGA)) {
@@ -96,8 +98,6 @@ private static BiomeCategories getBiomeCategory(Holder<Biome> holder) {
 			return BiomeCategories.UNDERGROUND;
 		} else if (holder.is(BiomeTags.WITHOUT_ZOMBIE_SIEGES)) {
 			return BiomeCategories.MUSHROOM;
-		} else if (holder.is(BiomeTags.HAS_VILLAGE_SNOWY)) {
-			return BiomeCategories.ICY;
 		} else if (holder.is(BiomeTags.IS_MOUNTAIN)) {
 			return BiomeCategories.MOUNTAIN;
 		} else {

File: src/main/java/net/coderbot/iris/pipeline/transform/TextureTransformer.java
Patch:
@@ -13,6 +13,7 @@
 import io.github.douira.glsl_transformer.ast.query.match.Matcher;
 import io.github.douira.glsl_transformer.ast.transform.ASTParser;
 import it.unimi.dsi.fastutil.objects.Object2ObjectMap;
+import net.coderbot.iris.Iris;
 import net.coderbot.iris.gl.texture.TextureType;
 import net.coderbot.iris.helpers.Tri;
 import net.coderbot.iris.shaderpack.texture.TextureStage;
@@ -35,6 +36,7 @@ public static void transform(
 			Root root,
 			TextureStage stage, Object2ObjectMap<Tri<String, TextureType, TextureStage>, String> textureMap) {
 		textureMap.forEach((stringTextureTypeTextureStageTri, s) -> {
+			Iris.logger.warn("A " + stringTextureTypeTextureStageTri.toString() + " " + s);
 			if (stringTextureTypeTextureStageTri.getThird() == stage) {
 				String name = stringTextureTypeTextureStageTri.getFirst();
 

File: src/main/java/net/coderbot/iris/gl/IrisRenderSystem.java
Patch:
@@ -479,8 +479,10 @@ public void copyTexSubImage2D(int destTexture, int target, int i, int i1, int i2
 
 		@Override
 		public void bindTextureToUnit(int target, int unit, int texture) {
+			int activeTexture = GlStateManager._getActiveTexture();
 			GlStateManager._activeTexture(GL30C.GL_TEXTURE0 + unit);
 			GL11C.glBindTexture(target, texture);
+			GlStateManager._activeTexture(activeTexture);
 		}
 
 		@Override

File: src/main/java/net/coderbot/iris/gl/program/ProgramSamplers.java
Patch:
@@ -195,7 +195,7 @@ private boolean addDynamicSampler(TextureType type, IntSupplier sampler, boolean
 					throw new IllegalStateException("No more available texture units while activating sampler " + name);
 				}
 
-				System.out.println("Binding dynamic sampler " + name + " with type " + type.name() + " to texture unit " + nextUnit);
+				//System.out.println("Binding dynamic sampler " + name + " with type " + type.name() + " to texture unit " + nextUnit);
 
 				// Set up this sampler uniform to use this particular texture unit.
 				calls.add(new GlUniform1iCall(location, nextUnit));

File: src/main/java/net/coderbot/iris/uniforms/ExternallyManagedUniforms.java
Patch:
@@ -32,6 +32,8 @@ public static void addExternallyManagedUniforms117(UniformHolder uniformHolder)
 		addFloat(uniformHolder, "iris_FogEnd");
 		addVec4(uniformHolder, "iris_FogColor");
 		addMat4(uniformHolder, "iris_ProjectionMatrix");
+		addMat4(uniformHolder, "iris_ModelViewMatrix");
+		addMat4(uniformHolder, "iris_NormalMatrix");
 		addFloat(uniformHolder, "iris_TextureScale");
 		addFloat(uniformHolder, "iris_ModelScale");
 		addFloat(uniformHolder, "iris_ModelOffset");

File: src/main/java/net/coderbot/iris/uniforms/custom/CustomUniforms.java
Patch:
@@ -57,7 +57,7 @@ private CustomUniforms(CustomUniformFixedInputUniformsHolder inputHolder, Map<St
 				if (variable.uniform) {
 					this.uniforms.add(cachedUniform);
 				}
-				Iris.logger.info("Was able to resolve uniform " + variable.name + " = " + variable.expression);
+				//Iris.logger.info("Was able to resolve uniform " + variable.name + " = " + variable.expression);
 			} catch (Exception e) {
 				Iris.logger
 						.warn("Failed to resolve uniform " + variable.name + ", reason: " + e

File: src/main/java/net/coderbot/iris/gl/framebuffer/GlFramebuffer.java
Patch:
@@ -97,11 +97,11 @@ protected void destroyInternal() {
 		GlStateManager._glDeleteFramebuffers(getGlId());
 	}
 
-	public boolean isComplete() {
+	public int getStatus() {
 		bind();
 		int status = GlStateManager.glCheckFramebufferStatus(GL30C.GL_FRAMEBUFFER);
 
-		return status == GL30C.GL_FRAMEBUFFER_COMPLETE;
+		return status;
 	}
 
 	public int getId() {

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -77,8 +77,6 @@ public static ExtendedShader create(WorldRenderingPipeline pipeline, String name
 			"        { \"name\": \"iris_ModelViewMatInverse\", \"type\": \"matrix4x4\", \"count\": 16, \"values\": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ] },\n" +
 			"        { \"name\": \"iris_ProjMat\", \"type\": \"matrix4x4\", \"count\": 16, \"values\": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ] },\n" +
 			"        { \"name\": \"iris_ProjMatInverse\", \"type\": \"matrix4x4\", \"count\": 16, \"values\": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ] },\n" +
-			"        { \"name\": \"iris_LineWidth\", \"type\": \"float\", \"count\": 1, \"values\": [ 1.0 ] },\n" +
-			"        { \"name\": \"iris_ScreenSize\", \"type\": \"float\",     \"count\": 2,  \"values\": [ 1.0, 1.0 ] },\n" +
 			"        { \"name\": \"iris_NormalMat\", \"type\": \"matrix3x3\", \"count\": 9, \"values\": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 ] },\n" +
 			"        { \"name\": \"iris_ChunkOffset\", \"type\": \"float\", \"count\": 3, \"values\": [ 0.0, 0.0, 0.0 ] },\n" +
 			"        { \"name\": \"iris_ColorModulator\", \"type\": \"float\", \"count\": 4, \"values\": [ 1.0, 1.0, 1.0, 1.0 ] },\n" +
@@ -108,6 +106,7 @@ public static ExtendedShader create(WorldRenderingPipeline pipeline, String name
 			//SamplerUniforms.addWorldSamplerUniforms(uniforms);
 			//SamplerUniforms.addDepthSamplerUniforms(uniforms);
 			BuiltinReplacementUniforms.addBuiltinReplacementUniforms(uniforms);
+			VanillaUniforms.addVanillaUniforms(uniforms);
 		}, (samplerHolder, imageHolder) -> {
 			parent.addGbufferOrShadowSamplers(samplerHolder, imageHolder, flipped, isShadowPass, inputs.toAvailability());
 		}, isIntensity, parent, inputs, overrides, customUniforms);

File: src/main/java/net/coderbot/iris/uniforms/IrisInternalUniforms.java
Patch:
@@ -32,5 +32,8 @@ public static void addFogUniforms(DynamicUniformHolder uniforms) {
 		}, notifier -> {});
 
 		uniforms.uniform1f("iris_currentAlphaTest", CapturedRenderingState.INSTANCE::getCurrentAlphaTest, notifier -> {});
+
+		// Optifine compatibility
+		uniforms.uniform1f("alphaTestRef", CapturedRenderingState.INSTANCE::getCurrentAlphaTest, notifier -> {});
 	}
 }

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -77,6 +77,8 @@ public static ExtendedShader create(WorldRenderingPipeline pipeline, String name
 			"        { \"name\": \"iris_ModelViewMatInverse\", \"type\": \"matrix4x4\", \"count\": 16, \"values\": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ] },\n" +
 			"        { \"name\": \"iris_ProjMat\", \"type\": \"matrix4x4\", \"count\": 16, \"values\": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ] },\n" +
 			"        { \"name\": \"iris_ProjMatInverse\", \"type\": \"matrix4x4\", \"count\": 16, \"values\": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ] },\n" +
+			"        { \"name\": \"iris_LineWidth\", \"type\": \"float\", \"count\": 1, \"values\": [ 1.0 ] },\n" +
+			"        { \"name\": \"iris_ScreenSize\", \"type\": \"float\",     \"count\": 2,  \"values\": [ 1.0, 1.0 ] },\n" +
 			"        { \"name\": \"iris_NormalMat\", \"type\": \"matrix3x3\", \"count\": 9, \"values\": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 ] },\n" +
 			"        { \"name\": \"iris_ChunkOffset\", \"type\": \"float\", \"count\": 3, \"values\": [ 0.0, 0.0, 0.0 ] },\n" +
 			"        { \"name\": \"iris_ColorModulator\", \"type\": \"float\", \"count\": 4, \"values\": [ 1.0, 1.0, 1.0, 1.0 ] },\n" +

File: src/main/java/net/coderbot/iris/shaderpack/loading/ProgramId.java
Patch:
@@ -32,7 +32,7 @@ public enum ProgramId {
 	Item(ProgramGroup.Gbuffers, "item", TexturedLit),
 
 	Entities(ProgramGroup.Gbuffers, "entities", TexturedLit),
-	EntitiesTrans(ProgramGroup.Gbuffers, "entities_trans", Entities),
+	EntitiesTrans(ProgramGroup.Gbuffers, "entities_translucent", Entities),
 	EntitiesGlowing(ProgramGroup.Gbuffers, "entities_glowing", Entities),
 	ArmorGlint(ProgramGroup.Gbuffers, "armor_glint", Textured),
 	SpiderEyes(ProgramGroup.Gbuffers, "spidereyes", Textured,

File: src/main/java/net/coderbot/iris/gl/program/ProgramBuilder.java
Patch:
@@ -7,6 +7,7 @@
 import net.coderbot.iris.gl.sampler.SamplerHolder;
 import net.coderbot.iris.gl.shader.GlShader;
 import net.coderbot.iris.gl.shader.ProgramCreator;
+import net.coderbot.iris.gl.shader.ShaderCompileException;
 import net.coderbot.iris.gl.shader.ShaderType;
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
 import net.coderbot.iris.gl.state.ValueUpdateNotifier;
@@ -95,6 +96,8 @@ public ComputeProgram buildCompute() {
 	private static GlShader buildShader(ShaderType shaderType, String name, @Nullable String source) {
 		try {
 			return new GlShader(shaderType, name, source);
+		} catch (ShaderCompileException e) {
+			throw e;
 		} catch (RuntimeException e) {
 			throw new RuntimeException("Failed to compile " + shaderType + " shader for program " + name, e);
 		}

File: src/main/java/net/coderbot/iris/gl/shader/GlShader.java
Patch:
@@ -43,7 +43,7 @@ private static int createShader(ShaderType type, String name, String src) {
 		int result = GlStateManager.glGetShaderi(handle, GL20C.GL_COMPILE_STATUS);
 
 		if (result != GL20C.GL_TRUE) {
-			throw new RuntimeException("Shader compilation failed, see log for details");
+			throw new ShaderCompileException(name, log);
 		}
 
 		return handle;

File: src/main/java/net/coderbot/iris/gl/shader/ProgramCreator.java
Patch:
@@ -49,7 +49,7 @@ public static int create(String name, GlShader... shaders) {
 		int result = GlStateManager.glGetProgrami(program, GL20C.GL_LINK_STATUS);
 
 		if (result != GL20C.GL_TRUE) {
-			throw new RuntimeException("Shader program linking failed, see log for details");
+			throw new ShaderCompileException(name, log);
 		}
 
 		return program;

File: src/main/java/net/coderbot/iris/mixin/MixinTitleScreen.java
Patch:
@@ -3,6 +3,7 @@
 import com.google.common.collect.ImmutableList;
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.compat.sodium.SodiumVersionCheck;
+import net.coderbot.iris.gui.debug.DebugLoadFailedGridScreen;
 import net.fabricmc.loader.api.FabricLoader;
 import net.minecraft.ChatFormatting;
 import net.minecraft.Util;

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -28,6 +28,7 @@
 import net.coderbot.iris.gl.program.ProgramBuilder;
 import net.coderbot.iris.gl.program.ProgramImages;
 import net.coderbot.iris.gl.program.ProgramSamplers;
+import net.coderbot.iris.gl.shader.ShaderCompileException;
 import net.coderbot.iris.pipeline.newshader.FogMode;
 import net.coderbot.iris.pipeline.transform.PatchShaderType;
 import net.coderbot.iris.gl.texture.DepthBufferFormat;
@@ -978,6 +979,8 @@ private ComputeProgram[] createShadowComputes(ComputeSource[] compute, ProgramSe
 
 				try {
 					builder = ProgramBuilder.beginCompute(source.getName(), source.getSource().orElse(null), IrisSamplers.WORLD_RESERVED_TEXTURE_UNITS);
+				} catch (ShaderCompileException e) {
+					throw e;
 				} catch (RuntimeException e) {
 					// TODO: Better error handling
 					throw new RuntimeException("Shader compilation failed!", e);

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -10,7 +10,6 @@
 import net.coderbot.iris.gl.shader.ShaderCompileException;
 import net.coderbot.iris.gl.shader.StandardMacros;
 import net.coderbot.iris.gui.debug.DebugLoadFailedGridScreen;
-import net.coderbot.iris.gui.debug.LoadFailedGridScreen;
 import net.coderbot.iris.gui.screen.ShaderPackScreen;
 import net.coderbot.iris.pipeline.FixedFunctionWorldRenderingPipeline;
 import net.coderbot.iris.pipeline.PipelineManager;

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -42,7 +42,7 @@
 public class Buildscript extends SimpleFabricProject {
 	static final boolean SODIUM = true;
 	static final boolean CUSTOM_SODIUM = true;
-	static final String MC_VERSION = "22w46a";
+	static final String MC_VERSION = "1.19.3-pre1";
 	static final String customSodiumName = "sodium-22w46a.jar";
 
 	private static final String[] SOURCE_SETS = new String[] {

File: src/main/java/net/coderbot/iris/compat/sodium/SodiumVersionCheck.java
Patch:
@@ -13,7 +13,7 @@ public class SodiumVersionCheck {
 	// of pain. So don't forget!
 	private static final ImmutableList<AllowedSodiumVersion> ALLOWED_SODIUM_VERSIONS = ImmutableList.of(
 			// Dev version
-			AllowedSodiumVersion.exact("0.4.4+rev.2673009-dirty",
+			AllowedSodiumVersion.exact("0.4.4+rev.2673009",
 					"https://modrinth.com/mod/sodium/version/mc1.19.2-0.4.4")
 	);
 

File: src/main/java/net/coderbot/iris/gl/program/ProgramUniforms.java
Patch:
@@ -346,7 +346,7 @@ private static UniformType getExpectedType(int type) {
 		} else if (type == GL20C.GL_INT_VEC4) {
 			return UniformType.VEC4I;
 		} else if (type == GL20C.GL_FLOAT_MAT3) {
-			return null;
+			return UniformType.MAT3;
 		} else if (type == GL20C.GL_FLOAT_VEC3) {
 			return UniformType.VEC3;
 		} else if (type == GL20C.GL_INT_VEC3) {

File: src/main/java/net/coderbot/iris/gl/uniform/UniformType.java
Patch:
@@ -3,6 +3,7 @@
 public enum UniformType {
 	INT,
 	FLOAT,
+	MAT3,
 	MAT4,
 	VEC2,
 	VEC2I,

File: src/main/java/net/coderbot/iris/mixin/gui/MixinVideoSettingsScreen.java
Patch:
@@ -28,9 +28,10 @@ protected MixinVideoSettingsScreen(Component title) {
 			index = 0
 	)
 	private OptionInstance<?>[] iris$addShaderPackScreenButton(OptionInstance<?>[] $$0) {
-		OptionInstance[] options = new OptionInstance[$$0.length + 1];
+		OptionInstance<?>[] options = new OptionInstance[$$0.length + 2];
 		System.arraycopy($$0, 0, options, 0, $$0.length);
-		options[options.length - 1] = new OptionInstance<>("options.iris.shaderPackSelection", OptionInstance.cachedConstantTooltip(Component.empty()), (arg, object) -> Component.empty(), OptionInstance.BOOLEAN_VALUES, true, (parent) -> minecraft.setScreen(new ShaderPackScreen(this)));
+		options[options.length - 2] = new OptionInstance<>("options.iris.shaderPackSelection", OptionInstance.cachedConstantTooltip(Component.empty()), (arg, object) -> Component.empty(), OptionInstance.BOOLEAN_VALUES, true, (parent) -> minecraft.setScreen(new ShaderPackScreen(this)));
+		options[options.length - 1] = IrisVideoSettings.RENDER_DISTANCE;
 		return options;
 	}
 }

File: src/main/java/net/coderbot/iris/uniforms/ExternallyManagedUniforms.java
Patch:
@@ -44,6 +44,7 @@ public static void addExternallyManagedUniforms117(UniformHolder uniformHolder)
 		uniformHolder.externallyManagedUniform("iris_ProjMat", UniformType.MAT4);
 		uniformHolder.externallyManagedUniform("iris_ChunkOffset", UniformType.VEC3);
 		uniformHolder.externallyManagedUniform("iris_ColorModulator", UniformType.VEC4);
+		uniformHolder.externallyManagedUniform("iris_NormalMat", UniformType.MAT3);
 		uniformHolder.externallyManagedUniform("iris_FogStart", UniformType.FLOAT);
 		uniformHolder.externallyManagedUniform("iris_FogEnd", UniformType.FLOAT);
 		uniformHolder.externallyManagedUniform("iris_FogDensity", UniformType.FLOAT);

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/terrain_xhfp/XHFPModelVertexType.java
Patch:
@@ -75,7 +75,7 @@ public float getPositionOffset() {
 	}
 
 	static short encodeBlockTexture(float value) {
-		return (short) (value * TEXTURE_MAX_VALUE);
+		return (short) (Math.min(0.99999997F, value) * TEXTURE_MAX_VALUE);
 	}
 
 	static float decodeBlockTexture(short raw) {

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -311,13 +311,13 @@ public DeferredWorldRenderingPipeline(ProgramSet programs) {
 				ProgramSource source = resolver.resolveNullable(p.getFirst());
 
 				if (condition == RenderCondition.SHADOW) {
-					if (shadowRenderTargets == null || shadowDirectives.isShadowEnabled() == OptionalBoolean.FALSE) {
+					if (!shadowDirectives.isShadowEnabled().orElse(shadowRenderTargets != null)) {
 						// shadow is not used
 						return null;
 					} else if (source == null) {
 						// still need the custom framebuffer, viewport, and blend mode behavior
 						GlFramebuffer shadowFb =
-							shadowRenderTargets.createShadowFramebuffer(shadowRenderTargets.snapshot(), new int[] {0});
+							shadowTargetsSupplier.get().createShadowFramebuffer(shadowRenderTargets.snapshot(), new int[] {0});
 						return new Pass(null, shadowFb, shadowFb, null,
 							BlendModeOverride.OFF, Collections.emptyList(), true);
 					}
@@ -673,7 +673,7 @@ private Pass createPassInner(ProgramBuilder builder, IdMap map, ProgramDirective
 		if (shadow) {
 			// Always add both draw buffers on the shadow pass.
 			framebufferBeforeTranslucents =
-				Objects.requireNonNull(shadowRenderTargets).createShadowFramebuffer(shadowRenderTargets.snapshot(), new int[] { 0, 1 });
+				shadowTargetsSupplier.get().createShadowFramebuffer(shadowRenderTargets.snapshot(), new int[] { 0, 1 });
 			framebufferAfterTranslucents = framebufferBeforeTranslucents;
 		} else {
 			framebufferBeforeTranslucents =

File: src/main/java/net/coderbot/iris/gl/program/ProgramUniforms.java
Patch:
@@ -346,7 +346,7 @@ private static UniformType getExpectedType(int type) {
 		} else if (type == GL20C.GL_INT_VEC4) {
 			return UniformType.VEC4I;
 		} else if (type == GL20C.GL_FLOAT_MAT3) {
-			return null;
+			return UniformType.MAT3;
 		} else if (type == GL20C.GL_FLOAT_VEC3) {
 			return UniformType.VEC3;
 		} else if (type == GL20C.GL_INT_VEC3) {

File: src/main/java/net/coderbot/iris/gl/uniform/UniformType.java
Patch:
@@ -3,6 +3,7 @@
 public enum UniformType {
 	INT,
 	FLOAT,
+	MAT3,
 	MAT4,
 	VEC2,
 	VEC2I,

File: src/main/java/net/coderbot/iris/uniforms/ExternallyManagedUniforms.java
Patch:
@@ -44,6 +44,7 @@ public static void addExternallyManagedUniforms117(UniformHolder uniformHolder)
 		uniformHolder.externallyManagedUniform("iris_ProjMat", UniformType.MAT4);
 		uniformHolder.externallyManagedUniform("iris_ChunkOffset", UniformType.VEC3);
 		uniformHolder.externallyManagedUniform("iris_ColorModulator", UniformType.VEC4);
+		uniformHolder.externallyManagedUniform("iris_NormalMat", UniformType.MAT3);
 		uniformHolder.externallyManagedUniform("iris_FogStart", UniformType.FLOAT);
 		uniformHolder.externallyManagedUniform("iris_FogEnd", UniformType.FLOAT);
 		uniformHolder.externallyManagedUniform("iris_FogDensity", UniformType.FLOAT);

File: src/main/java/net/coderbot/iris/mixin/MixinSystemReport.java
Patch:
@@ -33,7 +33,7 @@ private void fillSystemDetails(CallbackInfo ci) {
             return sb.toString();
         });
 
-		getSystemDetails().setDetail("NEC status", () -> {
+		this.setDetail("NEC status", () -> {
 			if (Iris.hasNotEnoughCrashes()) {
 				return "Has NEC: INVALID";
 			} else {

File: src/main/java/net/coderbot/iris/mixin/MixinTitleScreen.java
Patch:
@@ -46,7 +46,7 @@ protected MixinTitleScreen(Component arg) {
 			reason = "iris.sodium.failure.reason.notFound";
 		} else if (Iris.isSodiumInvalid()) {
 			reason = "iris.sodium.failure.reason.incompatible";
-		} else if (true) {
+		} else if (Iris.hasNotEnoughCrashes()) {
 			Minecraft.getInstance().setScreen(new ConfirmScreen(
 				bool -> {
 					if (bool) {

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/terrain_xhfp/XHFPModelVertexType.java
Patch:
@@ -75,7 +75,7 @@ public float getPositionOffset() {
 	}
 
 	static short encodeBlockTexture(float value) {
-		return (short) (value * TEXTURE_MAX_VALUE);
+		return (short) (Math.min(0.99999997F, value) * TEXTURE_MAX_VALUE);
 	}
 
 	static float decodeBlockTexture(short raw) {

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -205,7 +205,7 @@ public NewWorldRenderingPipeline(ProgramSet programSet) throws IOException {
 
 		BufferFlipper flipper = new BufferFlipper();
 
-		this.centerDepthSampler = new CenterDepthSampler(renderTargets, programSet.getPackDirectives().getCenterDepthHalfLife());
+		this.centerDepthSampler = new CenterDepthSampler(() -> renderTargets.getDepthTexture(), programSet.getPackDirectives().getCenterDepthHalfLife());
 
 		this.shadowMapResolution = programSet.getPackDirectives().getShadowDirectives().getResolution();
 

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -42,8 +42,8 @@
 public class Buildscript extends SimpleFabricProject {
 	static final boolean SODIUM = true;
 	static final boolean CUSTOM_SODIUM = true;
-	static final String MC_VERSION = "22w44a";
-	static final String customSodiumName = "sodium-22w44a.jar";
+	static final String MC_VERSION = "22w45a";
+	static final String customSodiumName = "sodium-22w45a.jar";
 
 	private static final String[] SOURCE_SETS = new String[] {
 		"main",
@@ -97,7 +97,7 @@ public void getModDependencies(ModDependencyCollector d) {
 		if (SODIUM) {
 			d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-api-base", "0.4.13+93d8cb822d"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 			d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-rendering-data-attachment-v1", "0.3.16+aeb40ebe2d"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
-			d.add(new JavaJarDependency(getProjectDir().resolve("custom_sodium").resolve("frf.jar").toAbsolutePath(), null, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-rendering-fluids-v1", "3.0.10+11ba9c3b9a")), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
+			d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-rendering-fluids-v1", "3.0.11+f75bcd189a"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 			d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-resource-loader-v0", "0.8.0+75e982112d"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 
 			if (CUSTOM_SODIUM) {

File: src/main/java/net/coderbot/iris/mixin/entity_render_context/MixinEntityRenderDispatcher.java
Patch:
@@ -11,6 +11,7 @@
 import net.minecraft.client.renderer.RenderStateShard;
 import net.minecraft.client.renderer.entity.EntityRenderDispatcher;
 import net.minecraft.core.Registry;
+import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.world.entity.Entity;
 import org.spongepowered.asm.mixin.Mixin;
@@ -38,7 +39,7 @@ public class MixinEntityRenderDispatcher {
 			return;
 		}
 
-		ResourceLocation entityId = Registry.ENTITY_TYPE.getKey(entity.getType());
+		ResourceLocation entityId = BuiltInRegistries.ENTITY_TYPE.getKey(entity.getType());
 
 		Object2IntFunction<NamespacedId> entityIds = BlockRenderingSettings.INSTANCE.getEntityIds();
 

File: src/main/java/net/coderbot/iris/UpdateChecker.java
Patch:
@@ -164,7 +164,7 @@ public Optional<String> getUpdateLink() {
 		}
 	}
 
-	class UpdateInfo {
+	static class UpdateInfo {
 		public String semanticVersion;
 		public Map<String, String> updateInfo;
 		public String modHost;

File: src/main/java/net/coderbot/iris/features/FeatureFlags.java
Patch:
@@ -4,11 +4,8 @@
 import net.minecraft.client.resources.language.I18n;
 import org.apache.commons.lang3.text.WordUtils;
 
-import java.util.Arrays;
 import java.util.List;
 import java.util.function.BooleanSupplier;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
 
 public enum FeatureFlags {
 	SEPARATE_HARDWARE_SAMPLERS(() -> true, () -> true),

File: src/main/java/net/coderbot/iris/mixin/shadows/MixinLevelRenderer.java
Patch:
@@ -15,10 +15,10 @@ public class MixinLevelRenderer implements CullingDataCache {
 	@Shadow
 	@Final
 	@Mutable
-	private ObjectList renderChunks;
+	private ObjectList<LevelRenderer.RenderChunkInfo> renderChunks;
 
 	@Unique
-	private ObjectList savedRenderChunks = new ObjectArrayList(69696);
+	private ObjectList<LevelRenderer.RenderChunkInfo> savedRenderChunks = new ObjectArrayList<>(69696);
 
 	@Shadow
 	private boolean needsUpdate;
@@ -68,7 +68,7 @@ public void restoreState() {
 
 	@Unique
 	private void swap() {
-		ObjectList tmpList = renderChunks;
+		ObjectList<LevelRenderer.RenderChunkInfo> tmpList = renderChunks;
 		renderChunks = savedRenderChunks;
 		savedRenderChunks = tmpList;
 

File: src/main/java/net/coderbot/iris/mixin/sky/MixinOptions_CloudsOverride.java
Patch:
@@ -19,7 +19,7 @@
 @Mixin(value = Options.class, priority = 1010)
 public class MixinOptions_CloudsOverride {
 	@Shadow
-	private int renderDistance;
+	public int renderDistance;
 
 	@Inject(method = "getCloudsType", at = @At("HEAD"), cancellable = true)
 	private void iris$overrideCloudsType(CallbackInfoReturnable<CloudStatus> cir) {

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderer.java
Patch:
@@ -172,7 +172,7 @@ public void recalculateSizes() {
 		}
 	}
 
-	private class Pass {
+	private static class Pass {
 		int[] drawBuffers;
 		int viewWidth;
 		int viewHeight;

File: src/main/java/net/coderbot/iris/pipeline/transform/CommonTransformer.java
Patch:
@@ -40,7 +40,7 @@ public class CommonTransformer {
 	public static final AutoHintedMatcher<Expression> glTextureMatrix1 = new AutoHintedMatcher<>(
 			"gl_TextureMatrix[1]", Matcher.expressionPattern);
 	public static final AutoHintedMatcher<ExternalDeclaration> sampler = new AutoHintedMatcher<>(
-			"uniform Type name;", Matcher.externalDeclarationPattern, "__") {
+			"uniform Type name;", Matcher.externalDeclarationPattern) {
 		{
 			markClassedPredicateWildcard("type",
 					pattern.getRoot().identifierIndex.getOne("Type").getAncestor(TypeSpecifier.class),

File: src/main/java/net/coderbot/iris/rendertarget/RenderTarget.java
Patch:
@@ -42,8 +42,8 @@ public RenderTarget(Builder builder) {
 		this.altTexture = textures[1];
 
 		boolean isPixelFormatInteger = builder.internalFormat.getPixelFormat().isInteger();
-		setupTexture(mainTexture, builder.width, builder.height, isPixelFormatInteger);
-		setupTexture(altTexture, builder.width, builder.height, isPixelFormatInteger);
+		setupTexture(mainTexture, builder.width, builder.height, !isPixelFormatInteger);
+		setupTexture(altTexture, builder.width, builder.height, !isPixelFormatInteger);
 
 		// Clean up after ourselves
 		// This is strictly defensive to ensure that other buggy code doesn't tamper with our textures

File: src/main/java/net/coderbot/iris/postprocess/FinalPassRenderer.java
Patch:
@@ -393,5 +393,7 @@ public void destroy() {
 		if (finalPass != null) {
 			finalPass.destroy();
 		}
+		baseline.destroy();
+		colorHolder.destroy();
 	}
 }

File: src/main/java/net/coderbot/iris/shadows/ShadowRenderTargets.java
Patch:
@@ -94,6 +94,7 @@ public void destroy() {
 			target.destroy();
 		}
 
+		mainDepth.destroy();
 		noTranslucents.destroy();
 	}
 

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/vertex_format/MixinModelVertexUtil.java
Patch:
@@ -51,7 +51,7 @@
  */
 @Mixin(ModelVertexUtil.class)
 public class MixinModelVertexUtil {
-	@ModifyVariable(method = "denormalizeVertexTextureFloatAsShort", at = @At("HEAD"))
+	@ModifyVariable(method = "denormalizeVertexTextureFloatAsShort", at = @At("HEAD"), remap = false)
 	private static float iris$clampUV(float uv) {
 		return Math.min(0.99999997F, uv);
 	}

File: src/main/java/net/coderbot/iris/uniforms/IrisExclusiveUniforms.java
Patch:
@@ -138,7 +138,7 @@ public static void addWorldInfoUniforms(UniformHolder uniforms) {
 			});
 			uniforms.uniform1f(UniformUpdateFrequency.PER_FRAME, "ambientLight", () -> {
 				if (level != null) {
-					return ((DimensionTypeAccessor) level.dimensionType()).getAmbientLight();
+					return ((DimensionTypeAccessor) (Object) level.dimensionType()).getAmbientLight();
 				} else {
 					return 0f;
 				}

File: src/main/java/net/coderbot/iris/compat/sodium/SodiumVersionCheck.java
Patch:
@@ -11,7 +11,7 @@ public class SodiumVersionCheck {
 	// If you forget to edit the download links you'll cause the support team a bunch
 	// of pain. So don't forget!
 	private static final ImmutableList<AllowedSodiumVersion> ALLOWED_SODIUM_VERSIONS = ImmutableList.of(
-			// Dev version
+			// Release version
 			AllowedSodiumVersion.exact("0.4.4+build.18",
 					"https://modrinth.com/mod/sodium/version/mc1.19.2-0.4.4")
 	);

File: src/main/java/net/coderbot/iris/mixin/MixinUniform.java
Patch:
@@ -2,8 +2,6 @@
 
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.shaders.Uniform;
-import com.mojang.math.Matrix4f;
-import com.mojang.math.Vector3f;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;

File: src/main/java/net/coderbot/iris/uniforms/IrisExclusiveUniforms.java
Patch:
@@ -138,7 +138,7 @@ public static void addWorldInfoUniforms(UniformHolder uniforms) {
 			});
 			uniforms.uniform1f(UniformUpdateFrequency.PER_FRAME, "ambientLight", () -> {
 				if (level != null) {
-					return ((DimensionTypeAccessor) level.dimensionType()).getAmbientLight();
+					return level.dimensionType().ambientLight();
 				} else {
 					return 0f;
 				}

File: src/main/java/net/coderbot/iris/texture/pbr/loader/AtlasPBRLoader.java
Patch:
@@ -151,6 +151,7 @@ protected TextureAtlasSprite createPBRSprite(TextureAtlasSprite sprite, Resource
 					} else {
 						scaledImage = ImageManipulationUtil.scaleBilinear(nativeImage, targetImageWidth, targetImageHeight);
 					}
+					nativeImage.close();
 					nativeImage = scaledImage;
 
 					frameWidth = targetFrameWidth;

File: src/main/java/net/coderbot/iris/compat/sodium/SodiumVersionCheck.java
Patch:
@@ -13,7 +13,7 @@ public class SodiumVersionCheck {
 	// of pain. So don't forget!
 	private static final ImmutableList<AllowedSodiumVersion> ALLOWED_SODIUM_VERSIONS = ImmutableList.of(
 			// Dev version
-			AllowedSodiumVersion.exact("0.4.4+rev.f01f931-dirty",
+			AllowedSodiumVersion.exact("0.4.4+rev.89c2cc7-dirty",
 					"https://modrinth.com/mod/sodium/version/mc1.19.2-0.4.4")
 	);
 

File: src/main/java/net/coderbot/iris/texture/pbr/PBRType.java
Patch:
@@ -26,7 +26,7 @@ public int getDefaultValue() {
 		return defaultValue;
 	}
 
-	public ResourceLocation appendToFileLocation(ResourceLocation location) {
+	public ResourceLocation appendToFileLocation(ResourceLocation location, boolean isAtlas) {
 		String path = location.getPath();
 		String newPath;
 		int extensionIndex = FilenameUtils.indexOfExtension(path);
@@ -35,7 +35,7 @@ public ResourceLocation appendToFileLocation(ResourceLocation location) {
 		} else {
 			newPath = path + suffix;
 		}
-		return new ResourceLocation(location.getNamespace(), "textures/" + newPath + ".png");
+		return new ResourceLocation(location.getNamespace(), isAtlas ? "textures/" + newPath + ".png" : newPath);
 	}
 
 	/**

File: src/main/java/net/coderbot/iris/texture/pbr/loader/AtlasPBRLoader.java
Patch:
@@ -122,7 +122,7 @@ protected static int fetchAtlasMipLevel(TextureAtlas atlas) {
 	@Nullable
 	protected TextureAtlasSprite createPBRSprite(TextureAtlasSprite sprite, ResourceManager resourceManager, TextureAtlas atlas, int atlasWidth, int atlasHeight, int mipLevel, PBRType pbrType) {
 		ResourceLocation spriteName = sprite.contents().name();
-		ResourceLocation pbrImageLocation = pbrType.appendToFileLocation(spriteName);
+		ResourceLocation pbrImageLocation = pbrType.appendToFileLocation(spriteName, true);
 
 		TextureAtlasSprite pbrSprite = null;
 		Optional<Resource> resource = resourceManager.getResource(pbrImageLocation);

File: src/main/java/net/coderbot/iris/texture/pbr/loader/SimplePBRLoader.java
Patch:
@@ -1,5 +1,6 @@
 package net.coderbot.iris.texture.pbr.loader;
 
+import net.coderbot.iris.Iris;
 import net.coderbot.iris.mixin.texture.SimpleTextureAccessor;
 import net.coderbot.iris.texture.pbr.PBRType;
 import net.minecraft.client.renderer.texture.AbstractTexture;
@@ -28,7 +29,7 @@ public void load(SimpleTexture texture, ResourceManager resourceManager, PBRText
 
 	@Nullable
 	protected AbstractTexture createPBRTexture(ResourceLocation imageLocation, ResourceManager resourceManager, PBRType pbrType) {
-		ResourceLocation pbrImageLocation = pbrType.appendToFileLocation(imageLocation);
+		ResourceLocation pbrImageLocation = pbrType.appendToFileLocation(imageLocation, false);
 
 		SimpleTexture pbrTexture = new SimpleTexture(pbrImageLocation);
 		try {

File: src/main/java/net/coderbot/iris/texture/mipmap/CustomMipmapGenerator.java
Patch:
@@ -10,6 +10,6 @@ public interface CustomMipmapGenerator {
 
 	public interface Provider {
 		@Nullable
-		CustomMipmapGenerator getMipmapGenerator(SpriteContents info);
+		CustomMipmapGenerator getMipmapGenerator();
 	}
 }

File: src/main/java/net/coderbot/iris/texture/pbr/PBRAtlasTexture.java
Patch:
@@ -112,7 +112,7 @@ protected void uploadSprite(TextureAtlasSprite sprite) {
 		}
 
 		Iris.logger.warn("Sprite " + sprite.contents().name().toString() + " with xy " + sprite.getX() + " " + sprite.getY() + " with widthheight" + sprite.contents().width() + " " + sprite.contents().height());
-		sprite.uploadFirstFrame();
+ 		sprite.uploadFirstFrame();
 	}
 
 	public int getFrameFromSprite(TextureAtlasSprite sprite) {

File: src/main/java/net/coderbot/iris/texture/pbr/PBRSpriteHolder.java
Patch:
@@ -28,6 +28,7 @@ public void setSpecularSprite(TextureAtlasSprite sprite) {
 	public void close() {
 		if (normalSprite != null) {
 			normalSprite.contents().close();
+
 		}
 		if (specularSprite != null) {
 			specularSprite.contents().close();

File: src/main/java/net/coderbot/iris/pipeline/newshader/RedirectingUniform.java
Patch:
@@ -15,8 +15,7 @@ public RedirectingUniform(String string, int i, int j, ExtendedShader arg, Consu
 		this.setup = setup;
 	}
 
-	@Override
-	public void set(Matrix4f arg) {
+	public void accept(Matrix4f arg) {
 		setup.accept(arg);
 	}
 }

File: src/main/java/net/coderbot/batchedentityrendering/mixin/MixinRenderBuffers.java
Patch:
@@ -53,6 +53,9 @@ public class MixinRenderBuffers implements RenderBuffersExt, MemoryTrackingRende
 
 	@Inject(method = "bufferSource", at = @At("HEAD"), cancellable = true)
 	private void batchedentityrendering$replaceBufferSource(CallbackInfoReturnable<MultiBufferSource.BufferSource> cir) {
+		if (begins == 0) {
+			return;
+		}
 
 		cir.setReturnValue(buffered);
 	}

File: src/main/java/net/coderbot/iris/gl/shader/StandardMacros.java
Patch:
@@ -80,7 +80,7 @@ public static Iterable<StringPair> createStandardEnvironmentDefines() {
 	 * @see <a href="https://github.com/sp614x/optifine/blob/9c6a5b5326558ccc57c6490b66b3be3b2dc8cbef/OptiFineDoc/doc/shaders.txt#L696-L699">Optifine Doc</a>
 	 */
 	public static String getMcVersion() {
-		String version = SharedConstants.getCurrentVersion().getReleaseTarget();
+		String version = "1.19.3"; // TODO FIX 120
 			// release target so snapshots are set to the higher version
 			//
 			// For example if we were running iris on 21w07a, getReleaseTarget() would return 1.17

File: src/main/java/net/coderbot/iris/mixin/bettermipmaps/MixinTextureAtlasSprite.java
Patch:
@@ -35,8 +35,8 @@ public class MixinTextureAtlasSprite {
 	// support Forge, since this works well on Fabric too, it's fine to ensure that the diff between Fabric and Forge
 	// can remain minimal. Being less dependent on specific details of Fabric is good, since it means we can be more
 	// cross-platform.
-	@ModifyArg(method = "<init>", at = @At(value = "HEAD"))
-	private static NativeImage iris$beforeGenerateMipLevels(SpriteContents value, ResourceLocation resourceLocation, FrameSize frameSize, NativeImage nativeImage) {
+	//@ModifyVariable(method = "<init>", at = @At(value = "FIELD", target = "Lnet/minecraft/client/renderer/texture/SpriteContents;byMipLevel:[Lcom/mojang/blaze3d/platform/NativeImage;"), ordinal = 3)
+	private NativeImage iris$beforeGenerateMipLevels(SpriteContents value, ResourceLocation resourceLocation, FrameSize frameSize, NativeImage nativeImage) {
 		// We're injecting after the "info" field has been set, so this is safe even though we're in a constructor.
 		if (resourceLocation.getPath().contains("leaves")) {
 			// Don't ruin the textures of leaves on fast graphics, since they're supposed to have black pixels

File: src/main/java/net/coderbot/iris/mixin/texture/MixinTextureManager.java
Patch:
@@ -9,12 +9,13 @@
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
+import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 
 @Mixin(TextureManager.class)
 public class MixinTextureManager {
-	@Inject(method = "lambda$reload$4(Lnet/minecraft/server/packs/resources/ResourceManager;Ljava/util/concurrent/Executor;Ljava/lang/Void;)V", at = @At("TAIL"))
-	private void iris$onTailReloadLambda(ResourceManager resourceManager, Executor applyExecutor, Void void1, CallbackInfo ci) {
+	@Inject(method = "lambda$reload$5", at = @At("TAIL"))
+	private void iris$onTailReloadLambda(ResourceManager resourceManager, Executor executor, CompletableFuture completableFuture, Void void_, CallbackInfo ci) {
 		TextureFormatLoader.reload(resourceManager);
 		PBRTextureManager.INSTANCE.clear();
 	}

File: src/main/java/net/coderbot/iris/mixin/texture/TextureAtlasAccessor.java
Patch:
@@ -14,6 +14,6 @@ public interface TextureAtlasAccessor {
 	@Accessor("texturesByName")
 	Map<ResourceLocation, TextureAtlasSprite> getTexturesByName();
 
-	@Invoker("getResourceLocation")
-	ResourceLocation callGetResourceLocation(ResourceLocation location);
+	//@Invoker("getResourceLocation")
+	//ResourceLocation callGetResourceLocation(ResourceLocation location);
 }

File: src/main/java/net/coderbot/iris/mixin/texture/TextureAtlasSpriteAccessor.java
Patch:
@@ -9,9 +9,6 @@
 
 @Mixin(TextureAtlasSprite.class)
 public interface TextureAtlasSpriteAccessor {
-	@Accessor("mainImage")
-	NativeImage[] getMainImage();
-
 	@Accessor("x")
 	int getX();
 

File: src/main/java/net/coderbot/iris/pipeline/SodiumTerrainPipeline.java
Patch:
@@ -368,6 +368,6 @@ public static String parseSodiumImport(String shader) {
 		String path = matcher.group("path");
 
 		ResourceLocation identifier = new ResourceLocation(namespace, path);
-		return ShaderLoader.getShaderSource(identifier);
+		return "";
 	}
 }

File: src/main/java/net/coderbot/iris/texture/pbr/PBRAtlasTexture.java
Patch:
@@ -114,7 +114,7 @@ protected void uploadSprite(TextureAtlasSprite sprite) {
 		if (ticker instanceof AnimatedTextureAccessor) {
 			AnimatedTextureAccessor accessor = (AnimatedTextureAccessor) ticker;
 
-			accessor.invokeUploadFrame(((FrameInfoAccessor) accessor.getFrames().get(accessor.getFrame())).getIndex(), sprite.getX(), sprite.getY());
+			// TODO FIX accessor.invokeUploadFrame(((FrameInfoAccessor) accessor.getFrames().get(sprite.contents().createTicker().frame)).getIndex(), sprite.getX(), sprite.getY());
 			return;
 		}
 

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -6,7 +6,6 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
-import java.util.function.Consumer;
 
 import io.github.coolcrabs.brachyura.compiler.java.JavaCompilation;
 import io.github.coolcrabs.brachyura.compiler.java.JavaCompilationResult;
@@ -27,7 +26,6 @@
 import io.github.coolcrabs.brachyura.processing.ProcessingSink;
 import io.github.coolcrabs.brachyura.processing.ProcessorChain;
 import io.github.coolcrabs.brachyura.processing.sources.ProcessingSponge;
-import io.github.coolcrabs.brachyura.project.Task;
 import io.github.coolcrabs.brachyura.project.java.BuildModule;
 import io.github.coolcrabs.brachyura.util.JvmUtil;
 import io.github.coolcrabs.brachyura.util.Lazy;
@@ -93,7 +91,7 @@ public void getModDependencies(ModDependencyCollector d) {
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.anarres:jcpp:1.4.14"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.20+aeb40ebe90"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
-		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:1.0.0"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
+		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:1.0.1"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.antlr:antlr4-runtime:4.10.1"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
 		if (SODIUM) {

File: src/main/java/net/coderbot/iris/gl/uniform/UniformHolder.java
Patch:
@@ -36,6 +36,7 @@ public interface UniformHolder {
 	UniformHolder uniform3d(UniformUpdateFrequency updateFrequency, String name, Supplier<Vector3d> value);
 
 	UniformHolder uniform4f(UniformUpdateFrequency updateFrequency, String name, Supplier<Vector4f> value);
+	UniformHolder uniform4fArray(UniformUpdateFrequency updateFrequency, String name, Supplier<float[]> value);
 
 	UniformHolder uniformMatrix(UniformUpdateFrequency updateFrequency, String name, Supplier<Matrix4f> value);
 

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -6,7 +6,6 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
-import java.util.function.Consumer;
 
 import io.github.coolcrabs.brachyura.compiler.java.JavaCompilation;
 import io.github.coolcrabs.brachyura.compiler.java.JavaCompilationResult;
@@ -27,7 +26,6 @@
 import io.github.coolcrabs.brachyura.processing.ProcessingSink;
 import io.github.coolcrabs.brachyura.processing.ProcessorChain;
 import io.github.coolcrabs.brachyura.processing.sources.ProcessingSponge;
-import io.github.coolcrabs.brachyura.project.Task;
 import io.github.coolcrabs.brachyura.project.java.BuildModule;
 import io.github.coolcrabs.brachyura.util.JvmUtil;
 import io.github.coolcrabs.brachyura.util.Lazy;
@@ -93,7 +91,7 @@ public void getModDependencies(ModDependencyCollector d) {
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.anarres:jcpp:1.4.14"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.12+54e5b2ec60"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
-		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:1.0.0"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
+		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:1.0.1"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.antlr:antlr4-runtime:4.10.1"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
 		if (SODIUM) {

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -89,7 +89,7 @@ public void getModDependencies(ModDependencyCollector d) {
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.slf4j:slf4j-api:1.7.12"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.5+3cc0f0907d"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
-		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:1.0.0"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
+		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:1.0.1"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.antlr:antlr4-runtime:4.10.1"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
 		if (SODIUM) {

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -651,9 +651,6 @@ public void beginLevelRendering() {
 		// Make sure we're using texture unit 0 for this.
 		RenderSystem.activeTexture(GL15C.GL_TEXTURE0);
 
-		// Update custom uniforms
-		this.customUniforms.update();
-
 		if (shadowRenderTargets != null) {
 			// Clear depth first, regardless of any color clearing.
 			shadowRenderTargets.getDepthSourceFb().bind();
@@ -683,6 +680,9 @@ public void beginLevelRendering() {
 		// NB: execute this before resizing / clearing so that the center depth sample is retrieved properly.
 		updateNotifier.onNewFrame();
 
+		// Update custom uniforms
+		this.customUniforms.update();
+
 		RenderTarget main = Minecraft.getInstance().getMainRenderTarget();
 
 		int depthTextureId = main.getDepthTextureId();

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -135,7 +135,7 @@ public static void generalCommonUniforms(UniformHolder uniforms, FrameUpdateNoti
 			.uniform1f(PER_FRAME, "screenBrightness", () -> client.options.gamma)
 			// just a dummy value for shaders where entityColor isn't supplied through a vertex attribute (and thus is
 			// not available) - suppresses warnings. See AttributeShaderTransformer for the actual entityColor code.
-			.uniform4f(ONCE, "entityColor", Vector4f::new)
+			.uniform4f(ONCE, "entityColor", () -> new Vector4f(0, 0, 0, 0))
 			.uniform1f(ONCE, "pi", () -> Math.PI)
 			.uniform1f(PER_TICK, "playerMood", CommonUniforms::getPlayerMood)
 			.uniform2i(PER_FRAME, "eyeBrightness", CommonUniforms::getEyeBrightness)

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -306,7 +306,7 @@ public DeferredWorldRenderingPipeline(ProgramSet programs) {
 			this.shadowClearPassesFull = ClearPassCreator.createShadowClearPasses(shadowRenderTargets, true, shadowDirectives);
 
 			this.shadowRenderer = new ShadowRenderer(programs.getShadow().orElse(null),
-				programs.getPackDirectives(), shadowRenderTargets);
+				programs.getPackDirectives(), shadowRenderTargets, customUniforms);
 		} else {
 			this.shadowClearPasses = ImmutableList.of();
 			this.shadowClearPassesFull = ImmutableList.of();

File: src/main/java/net/coderbot/iris/pipeline/transform/SodiumTerrainTransformer.java
Patch:
@@ -25,7 +25,9 @@ public static void transform(
 			Root root,
 			Parameters parameters) {
 		switch (parameters.type) {
+			// For Sodium patching, treat fragment and geometry the same
 			case FRAGMENT:
+			case GEOMETRY:
 				transformFragment(t, tree, root, parameters);
 				break;
 			case VERTEX:

File: src/main/java/net/coderbot/iris/pipeline/transform/SodiumTransformer.java
Patch:
@@ -72,7 +72,7 @@ public static void transform(
 				tree.parseAndInjectNodes(t, ASTInjectionPoint.BEFORE_FUNCTIONS,
 						"vec4 ftransform() { return gl_ModelViewProjectionMatrix * gl_Vertex; }");
 			}
-			tree.parseAndInjectNodes(t, ASTInjectionPoint.BEFORE_FUNCTIONS,
+			tree.parseAndInjectNodes(t, ASTInjectionPoint.BEFORE_DECLARATIONS,
 					// translated from sodium's chunk_vertex.glsl
 					"vec3 _vert_position;",
 					"vec2 _vert_tex_diffuse_coord;",

File: src/main/java/net/coderbot/iris/gl/uniform/DynamicUniformHolder.java
Patch:
@@ -1,5 +1,6 @@
 package net.coderbot.iris.gl.uniform;
 
+import com.mojang.math.Matrix4f;
 import net.coderbot.iris.gl.state.ValueUpdateNotifier;
 import net.coderbot.iris.vendored.joml.Vector2i;
 import net.coderbot.iris.vendored.joml.Vector3f;
@@ -19,4 +20,6 @@ public interface DynamicUniformHolder extends UniformHolder {
 	DynamicUniformHolder uniform3f(String name, Supplier<Vector3f> value, ValueUpdateNotifier notifier);
 	DynamicUniformHolder uniform4f(String name, Supplier<Vector4f> value, ValueUpdateNotifier notifier);
 	DynamicUniformHolder uniform4i(String name, Supplier<Vector4i> value, ValueUpdateNotifier notifier);
+	DynamicUniformHolder uniformMatrix(String name, Supplier<Matrix4f> value, ValueUpdateNotifier notifier);
+
 }

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -70,13 +70,12 @@ public static ExtendedShader create(String name, ProgramSource source, GlFramebu
 
 		ResourceProvider shaderResourceFactory = new IrisProgramResourceFactory(shaderJsonString, vertex, geometry, fragment);
 
-		return new ExtendedShader(shaderResourceFactory, name, vertexFormat, writingToBeforeTranslucent, writingToAfterTranslucent, baseline, blendModeOverride, alpha, (uniforms, chunkOffset, listener) -> {
+		return new ExtendedShader(shaderResourceFactory, name, vertexFormat, writingToBeforeTranslucent, writingToAfterTranslucent, baseline, blendModeOverride, alpha, uniforms -> {
 			CommonUniforms.addCommonUniforms(uniforms, source.getParent().getPack().getIdMap(), source.getParent().getPackDirectives(), updateNotifier, fogMode);
 			//SamplerUniforms.addWorldSamplerUniforms(uniforms);
 			//SamplerUniforms.addDepthSamplerUniforms(uniforms);
 			BuiltinReplacementUniforms.addBuiltinReplacementUniforms(uniforms);
 			VanillaUniforms.addVanillaUniforms(uniforms);
-			uniforms.uniform3f("iris_ChunkOffset", chunkOffset, listener);
 		}, (samplerHolder, imageHolder) -> {
 			parent.addGbufferOrShadowSamplers(samplerHolder, imageHolder, flipped, isShadowPass, inputs.toAvailability());
 		}, isIntensity, parent, inputs, source.getDirectives().getBufferBlendOverrides());

File: src/main/java/net/coderbot/iris/uniforms/VanillaUniforms.java
Patch:
@@ -11,8 +11,6 @@
 
 public class VanillaUniforms {
 	public static void addVanillaUniforms(DynamicUniformHolder uniforms) {
-		uniforms.uniformMatrix(UniformUpdateFrequency.PER_FRAME, "iris_ProjMat", RenderSystem::getProjectionMatrix);
-		uniforms.uniformMatrix(UniformUpdateFrequency.PER_FRAME, "iris_ModelViewMat", RenderSystem::getModelViewMatrix);
 		uniforms.uniformMatrix(UniformUpdateFrequency.PER_FRAME, "iris_TextureMat", RenderSystem::getTextureMatrix);
 		uniforms.uniform4fArray(UniformUpdateFrequency.PER_FRAME, "iris_ColorModulator", RenderSystem::getShaderColor);
 		Vector2f cachedScreenSize = new Vector2f();

File: src/main/java/net/coderbot/iris/layer/GbufferPrograms.java
Patch:
@@ -5,7 +5,6 @@
 import net.coderbot.iris.gl.state.StateUpdateNotifiers;
 import net.coderbot.iris.pipeline.WorldRenderingPhase;
 import net.coderbot.iris.pipeline.WorldRenderingPipeline;
-import org.lwjgl.opengl.GL43C;
 
 public class GbufferPrograms {
 	private static boolean entities;
@@ -38,15 +37,13 @@ public static void endEntities() {
 	public static void beginOutline() {
 		checkReentrancy();
 		setPhase(WorldRenderingPhase.OUTLINE);
-		GL43C.glPushDebugGroup(GL43C.GL_DEBUG_SOURCE_APPLICATION, 1, "LINES");
 		outline = true;
 	}
 
 	public static void endOutline() {
 		if (!outline) {
 			throw new IllegalStateException("GbufferPrograms in weird state, tried to call endOutline when outline = false");
 		}
-		GL43C.glPopDebugGroup();
 
 		setPhase(WorldRenderingPhase.NONE);
 		outline = false;

File: src/main/java/net/coderbot/iris/gl/uniform/DynamicUniformHolder.java
Patch:
@@ -2,6 +2,7 @@
 
 import net.coderbot.iris.gl.state.ValueUpdateNotifier;
 import net.coderbot.iris.vendored.joml.Vector2i;
+import net.coderbot.iris.vendored.joml.Vector3f;
 import net.coderbot.iris.vendored.joml.Vector4f;
 import net.coderbot.iris.vendored.joml.Vector4i;
 
@@ -15,6 +16,7 @@ public interface DynamicUniformHolder extends UniformHolder {
 	DynamicUniformHolder uniform1f(String name, DoubleSupplier value, ValueUpdateNotifier notifier);
 	DynamicUniformHolder uniform1i(String name, IntSupplier value, ValueUpdateNotifier notifier);
 	DynamicUniformHolder uniform2i(String name, Supplier<Vector2i> value, ValueUpdateNotifier notifier);
+	DynamicUniformHolder uniform3f(String name, Supplier<Vector3f> value, ValueUpdateNotifier notifier);
 	DynamicUniformHolder uniform4f(String name, Supplier<Vector4f> value, ValueUpdateNotifier notifier);
 	DynamicUniformHolder uniform4i(String name, Supplier<Vector4i> value, ValueUpdateNotifier notifier);
 }

File: src/main/java/net/coderbot/iris/layer/GbufferPrograms.java
Patch:
@@ -5,6 +5,7 @@
 import net.coderbot.iris.gl.state.StateUpdateNotifiers;
 import net.coderbot.iris.pipeline.WorldRenderingPhase;
 import net.coderbot.iris.pipeline.WorldRenderingPipeline;
+import org.lwjgl.opengl.GL43C;
 
 public class GbufferPrograms {
 	private static boolean entities;
@@ -37,13 +38,15 @@ public static void endEntities() {
 	public static void beginOutline() {
 		checkReentrancy();
 		setPhase(WorldRenderingPhase.OUTLINE);
+		GL43C.glPushDebugGroup(GL43C.GL_DEBUG_SOURCE_APPLICATION, 1, "LINES");
 		outline = true;
 	}
 
 	public static void endOutline() {
 		if (!outline) {
 			throw new IllegalStateException("GbufferPrograms in weird state, tried to call endOutline when outline = false");
 		}
+		GL43C.glPopDebugGroup();
 
 		setPhase(WorldRenderingPhase.NONE);
 		outline = false;

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -70,12 +70,13 @@ public static ExtendedShader create(String name, ProgramSource source, GlFramebu
 
 		ResourceProvider shaderResourceFactory = new IrisProgramResourceFactory(shaderJsonString, vertex, geometry, fragment);
 
-		return new ExtendedShader(shaderResourceFactory, name, vertexFormat, writingToBeforeTranslucent, writingToAfterTranslucent, baseline, blendModeOverride, alpha, uniforms -> {
+		return new ExtendedShader(shaderResourceFactory, name, vertexFormat, writingToBeforeTranslucent, writingToAfterTranslucent, baseline, blendModeOverride, alpha, (uniforms, chunkOffset, listener) -> {
 			CommonUniforms.addCommonUniforms(uniforms, source.getParent().getPack().getIdMap(), source.getParent().getPackDirectives(), updateNotifier, fogMode);
 			//SamplerUniforms.addWorldSamplerUniforms(uniforms);
 			//SamplerUniforms.addDepthSamplerUniforms(uniforms);
 			BuiltinReplacementUniforms.addBuiltinReplacementUniforms(uniforms);
 			VanillaUniforms.addVanillaUniforms(uniforms);
+			uniforms.uniform3f("iris_ChunkOffset", chunkOffset, listener);
 		}, (samplerHolder, imageHolder) -> {
 			parent.addGbufferOrShadowSamplers(samplerHolder, imageHolder, flipped, isShadowPass, inputs.toAvailability());
 		}, isIntensity, parent, inputs, source.getDirectives().getBufferBlendOverrides());

File: src/main/java/net/coderbot/iris/pipeline/newshader/ShaderKey.java
Patch:
@@ -16,7 +16,7 @@ public enum ShaderKey {
 	TEXTURED               (ProgramId.Textured,    AlphaTests.NON_ZERO_ALPHA,  DefaultVertexFormat.POSITION_TEX,                FogMode.OFF,          LightingModel.LIGHTMAP  ),
 	TEXTURED_COLOR         (ProgramId.Textured,    AlphaTests.ONE_TENTH_ALPHA, DefaultVertexFormat.POSITION_TEX_COLOR,          FogMode.OFF,          LightingModel.LIGHTMAP  ),
 	SKY_BASIC              (ProgramId.SkyBasic,    AlphaTests.OFF,             DefaultVertexFormat.POSITION,                    FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
-	SKY_BASIC_COLOR        (ProgramId.SkyBasic,    AlphaTests.ONE_TENTH_ALPHA, DefaultVertexFormat.POSITION_COLOR,              FogMode.OFF,          LightingModel.LIGHTMAP  ),
+	SKY_BASIC_COLOR        (ProgramId.SkyBasic,    AlphaTests.NON_ZERO_ALPHA,  DefaultVertexFormat.POSITION_COLOR,              FogMode.OFF,          LightingModel.LIGHTMAP  ),
 	SKY_TEXTURED           (ProgramId.SkyTextured, AlphaTests.OFF,             DefaultVertexFormat.POSITION_TEX,                FogMode.OFF,          LightingModel.LIGHTMAP  ),
 	SKY_TEXTURED_COLOR     (ProgramId.SkyTextured, AlphaTests.OFF,             DefaultVertexFormat.POSITION_TEX_COLOR,          FogMode.OFF,          LightingModel.LIGHTMAP  ),
 	CLOUDS                 (ProgramId.Clouds,      AlphaTests.ONE_TENTH_ALPHA, DefaultVertexFormat.POSITION_TEX_COLOR_NORMAL,   FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),

File: src/main/java/net/coderbot/iris/pipeline/newshader/ShaderKey.java
Patch:
@@ -31,7 +31,7 @@ public enum ShaderKey {
 	ENTITIES_SOLID_BRIGHT  (ProgramId.Entities,    AlphaTests.OFF,             IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.FULLBRIGHT),
 	ENTITIES_CUTOUT        (ProgramId.Entities,    AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	ENTITIES_CUTOUT_DIFFUSE(ProgramId.Entities,    AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.DIFFUSE_LM),
-	ENTITIES_TRANSLUCENT   (ProgramId.EntitiesTrans,AlphaTests.ONE_TENTH_ALPHA,IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
+	ENTITIES_TRANSLUCENT   (ProgramId.EntitiesTrans,AlphaTests.ONE_TENTH_ALPHA,IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.DIFFUSE_LM),
 	ENTITIES_EYES          (ProgramId.SpiderEyes,  AlphaTests.NON_ZERO_ALPHA,  IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.FULLBRIGHT),
 	HAND_CUTOUT            (ProgramId.Hand,        AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	HAND_CUTOUT_BRIGHT     (ProgramId.Hand,        AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.FULLBRIGHT),

File: src/main/java/net/coderbot/iris/shaderpack/ShaderPack.java
Patch:
@@ -26,8 +26,7 @@
 import net.coderbot.iris.shaderpack.texture.TextureStage;
 import net.irisshaders.iris.api.v0.IrisApi;
 import net.minecraft.client.Minecraft;
-import net.minecraft.network.chat.TextComponent;
-import net.minecraft.network.chat.TranslatableComponent;
+import net.minecraft.network.chat.Component;
 import org.jetbrains.annotations.Nullable;
 
 import java.io.BufferedReader;
@@ -127,7 +126,7 @@ public ShaderPack(Path root, Map<String, String> changedConfigs, Iterable<String
 
 		if (!invalidFeatureFlags.isEmpty()) {
 			if (Minecraft.getInstance().screen instanceof ShaderPackScreen) {
-				Minecraft.getInstance().setScreen(new FeatureMissingErrorScreen(Minecraft.getInstance().screen, new TranslatableComponent("iris.unsupported.pack"), new TranslatableComponent("iris.unsupported.pack.description", FeatureFlags.getInvalidStatus(invalidFlagList), invalidFeatureFlags.stream()
+				Minecraft.getInstance().setScreen(new FeatureMissingErrorScreen(Minecraft.getInstance().screen, Component.translatable("iris.unsupported.pack"), Component.translatable("iris.unsupported.pack.description", FeatureFlags.getInvalidStatus(invalidFlagList), invalidFeatureFlags.stream()
 					.collect(Collectors.joining(", ", ": ", ".")))));
 			}
 			IrisApi.getInstance().getConfig().setShadersEnabledAndApply(false);

File: src/main/java/net/coderbot/iris/gui/FeatureMissingErrorScreen.java
Patch:
@@ -24,7 +24,7 @@ public FeatureMissingErrorScreen(Screen parent, Component title, Component messa
 	protected void init() {
 		super.init();
 		this.message = MultiLineLabel.create(this.font, messageTemp, this.width - 50);
-		this.addButton(new Button(this.width / 2 - 100, 140, 200, 20, CommonComponents.GUI_BACK, arg -> this.minecraft.setScreen(parent)));
+		this.addRenderableWidget(new Button(this.width / 2 - 100, 140, 200, 20, CommonComponents.GUI_BACK, arg -> this.minecraft.setScreen(parent)));
 	}
 
 	@Override

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -94,7 +94,7 @@ public void getModDependencies(ModDependencyCollector d) {
 		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.12+54e5b2ec60"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:1.0.0-pre21.2"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
-		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.antlr:antlr4-runtime:4.10.1"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
+    	jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.antlr:antlr4-runtime:4.10.1"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
 		if (SODIUM) {
 			d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-api-base", "0.4.3+d7c144a8d2"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);

File: src/main/java/net/coderbot/iris/gbuffer_overrides/matching/RenderCondition.java
Patch:
@@ -10,6 +10,7 @@ public enum RenderCondition {
 	BLOCK_ENTITIES,
 	BEACON_BEAM,
 	ENTITIES,
+	ENTITIES_TRANSLUCENT,
 	GLINT,
 	ENTITY_EYES,
 	HAND_OPAQUE,

File: src/main/java/net/coderbot/iris/gl/uniform/UniformHolder.java
Patch:
@@ -29,6 +29,8 @@ public interface UniformHolder {
 
 	UniformHolder uniform3f(UniformUpdateFrequency updateFrequency, String name, Supplier<Vector3f> value);
 
+	UniformHolder uniformVanilla3f(UniformUpdateFrequency updateFrequency, String name, Supplier<com.mojang.math.Vector3f> value);
+
 	UniformHolder uniformTruncated3f(UniformUpdateFrequency updateFrequency, String name, Supplier<Vector4f> value);
 
 	UniformHolder uniform3d(UniformUpdateFrequency updateFrequency, String name, Supplier<Vector3d> value);

File: src/main/java/net/coderbot/iris/gui/GuiUtil.java
Patch:
@@ -24,7 +24,7 @@
  * some code that will be changed.
  */
 public final class GuiUtil {
-	private static final ResourceLocation IRIS_WIDGETS_TEX = new ResourceLocation("iris", "textures/gui/widgets.png");
+	public static final ResourceLocation IRIS_WIDGETS_TEX = new ResourceLocation("iris", "textures/gui/widgets.png");
 	private static final Component ELLIPSIS = new TextComponent("...");
 
 	private GuiUtil() {}

File: src/main/java/net/coderbot/iris/pipeline/transform/CompatibilityTransformer.java
Patch:
@@ -294,12 +294,12 @@ public static void transformGrouped(
 		 * find attributes that are declared as "in" in geometry or fragment but not
 		 * declared as "out" in the previous stage. The missing "out" declarations for
 		 * these attributes are added and initialized.
-		 * 
+		 *
 		 * It doesn't bother with array specifiers because they are only legal in
 		 * geometry shaders, but then also only as an in declaration. The out
 		 * declaration in the vertex shader is still just a single value. Missing out
 		 * declarations in the geometry shader are also just normal.
-		 * 
+		 *
 		 * TODO:
 		 * - fix issues where Iris' own declarations are detected and patched like
 		 * iris_FogFragCoord if there are geometry shaders present

File: src/main/java/net/coderbot/iris/postprocess/FinalPassRenderer.java
Patch:
@@ -119,7 +119,7 @@ public FinalPassRenderer(ProgramSet pack, RenderTargets renderTargets, IntSuppli
 			swap.target = target;
 			swap.width = target1.getWidth();
 			swap.height = target1.getHeight();
-			swap.from = renderTargets.createFramebufferWritingToAlt(new int[] {target});
+			swap.from = renderTargets.createColorFramebuffer(ImmutableSet.of(), new int[] {target});
 			// NB: This is handled in RenderTargets now.
 			//swap.from.readBuffer(target);
 			swap.targetTexture = renderTargets.get(target).getMainTexture();

File: src/main/java/net/coderbot/iris/rendertarget/RenderTargets.java
Patch:
@@ -121,7 +121,7 @@ public DepthTexture getDepthTextureNoHand() {
 		return noHand;
 	}
 
-	public boolean resizeIfNeeded(int newDepthBufferVersion, int newDepthTextureId, int newWidth, int newHeight, DepthBufferFormat newDepthFormat) {
+	public boolean resizeIfNeeded(int newDepthBufferVersion, int newDepthTextureId, int newWidth, int newHeight, DepthBufferFormat newDepthFormat, PackDirectives packDirectives) {
 		boolean recreateDepth = false;
 		if (cachedDepthBufferVersion != newDepthBufferVersion) {
 			recreateDepth = true;
@@ -169,8 +169,8 @@ public boolean resizeIfNeeded(int newDepthBufferVersion, int newDepthTextureId,
 			cachedWidth = newWidth;
 			cachedHeight = newHeight;
 
-			for (RenderTarget target : targets) {
-				target.resize(newWidth, newHeight);
+			for (int i = 0; i < targets.length; i++) {
+				targets[i].resize(packDirectives.getTextureScaleOverride(i, newWidth, newHeight));
 			}
 
 			fullClearRequired = true;

File: src/main/java/net/coderbot/iris/shaderpack/loading/ProgramId.java
Patch:
@@ -28,6 +28,7 @@ public enum ProgramId {
 	Item(ProgramGroup.Gbuffers, "item", TexturedLit),
 
 	Entities(ProgramGroup.Gbuffers, "entities", TexturedLit),
+	EntitiesTrans(ProgramGroup.Gbuffers, "entities_trans", Entities),
 	EntitiesGlowing(ProgramGroup.Gbuffers, "entities_glowing", Entities),
 	ArmorGlint(ProgramGroup.Gbuffers, "armor_glint", Textured),
 	SpiderEyes(ProgramGroup.Gbuffers, "spidereyes", Textured),

File: src/main/java/net/coderbot/iris/uniforms/IrisExclusiveUniforms.java
Patch:
@@ -11,6 +11,7 @@
 import net.minecraft.world.level.GameType;
 import net.minecraft.world.phys.Vec3;
 
+import java.util.Objects;
 import java.util.stream.StreamSupport;
 
 public class IrisExclusiveUniforms {
@@ -101,6 +102,7 @@ private static boolean isSpectator() {
 	}
 
 	private static Vector3d getEyePosition() {
-		return new Vector3d(Minecraft.getInstance().player.getX(), Minecraft.getInstance().player.getEyeY(), Minecraft.getInstance().player.getZ());
+		Objects.requireNonNull(Minecraft.getInstance().getCameraEntity());
+		return new Vector3d(Minecraft.getInstance().getCameraEntity().getX(), Minecraft.getInstance().getCameraEntity().getEyeY(), Minecraft.getInstance().getCameraEntity().getZ());
 	}
 }

File: src/main/java/net/coderbot/iris/rendertarget/RenderTargets.java
Patch:
@@ -110,7 +110,7 @@ public DepthTexture getDepthTextureNoHand() {
 		return noHand;
 	}
 
-	public boolean resizeIfNeeded(int newDepthBufferVersion, int newDepthTextureId, int newWidth, int newHeight, DepthBufferFormat newDepthFormat) {
+	public boolean resizeIfNeeded(int newDepthBufferVersion, int newDepthTextureId, int newWidth, int newHeight, DepthBufferFormat newDepthFormat, PackDirectives packDirectives) {
 		boolean recreateDepth = false;
 		if (cachedDepthBufferVersion != newDepthBufferVersion) {
 			recreateDepth = true;
@@ -158,8 +158,8 @@ public boolean resizeIfNeeded(int newDepthBufferVersion, int newDepthTextureId,
 			cachedWidth = newWidth;
 			cachedHeight = newHeight;
 
-			for (RenderTarget target : targets) {
-				target.resize(newWidth, newHeight);
+			for (int i = 0; i < targets.length; i++) {
+				targets[i].resize(packDirectives.getTextureScaleOverride(i, newWidth, newHeight));
 			}
 
 			fullClearRequired = true;

File: src/main/java/net/coderbot/iris/pipeline/transform/CompatibilityTransformer.java
Patch:
@@ -235,8 +235,6 @@ public boolean matchesExtract(ExternalDeclaration tree) {
 	private static final String tagPrefix = "iris_template_";
 	private static final Template<ExternalDeclaration> declarationTemplate = Template
 			.withExternalDeclaration("out __type __name;");
-	private static final Template<ExternalDeclaration> fixedDeclarationTemplate = Template
-			.withExternalDeclaration("out __type __name;");
 	private static final Template<Statement> initTemplate = Template.withStatement("__decl = __value;");
 	private static final Template<ExternalDeclaration> variableTemplate = Template
 			.withExternalDeclaration("__type __internalDecl;");
@@ -479,7 +477,7 @@ public static void transformGrouped(
 							if (outMembers.size() > 1) {
 								outMember.detach();
 								outTypeSpecifier = outTypeSpecifier.cloneInto(prevRoot);
-								DeclarationExternalDeclaration singleOutDeclaration = (DeclarationExternalDeclaration) fixedDeclarationTemplate
+								DeclarationExternalDeclaration singleOutDeclaration = (DeclarationExternalDeclaration) declarationTemplate
 										.getInstanceFor(prevRoot,
 												makeQualifierOut(outDeclaration.getType().getTypeQualifier().cloneInto(prevRoot)),
 												outTypeSpecifier,

File: src/main/java/net/coderbot/iris/gl/uniform/UniformHolder.java
Patch:
@@ -29,6 +29,8 @@ public interface UniformHolder {
 
 	UniformHolder uniform3f(UniformUpdateFrequency updateFrequency, String name, Supplier<Vector3f> value);
 
+	UniformHolder uniformVanilla3f(UniformUpdateFrequency updateFrequency, String name, Supplier<com.mojang.math.Vector3f> value);
+
 	UniformHolder uniformTruncated3f(UniformUpdateFrequency updateFrequency, String name, Supplier<Vector4f> value);
 
 	UniformHolder uniform3d(UniformUpdateFrequency updateFrequency, String name, Supplier<Vector3d> value);

File: src/main/java/net/coderbot/iris/mixin/MixinItem.java
Patch:
@@ -1,11 +1,9 @@
 package net.coderbot.iris.mixin;
 
-import net.irisshaders.iris.api.v0.item.IrisItemColorProvider;
 import net.irisshaders.iris.api.v0.item.IrisItemLightProvider;
 import net.minecraft.world.item.Item;
 import org.spongepowered.asm.mixin.Mixin;
 
 @Mixin(Item.class)
-public class MixinItem implements IrisItemLightProvider, IrisItemColorProvider
-{
+public class MixinItem implements IrisItemLightProvider {
 }

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -93,7 +93,7 @@ public void getModDependencies(ModDependencyCollector d) {
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.anarres:jcpp:1.4.14"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.12+54e5b2ec60"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
-		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:1.0.0-pre20"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
+		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:1.0.0-pre21.2"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.antlr:antlr4-runtime:4.10.1"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
 		if (SODIUM) {

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -93,7 +93,7 @@ public void getModDependencies(ModDependencyCollector d) {
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.anarres:jcpp:1.4.14"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.20+aeb40ebe90"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
-		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:1.0.0-pre20"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
+		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:1.0.0-pre21.2"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.antlr:antlr4-runtime:4.10.1"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
 		if (SODIUM) {

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -89,7 +89,7 @@ public void getModDependencies(ModDependencyCollector d) {
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.slf4j:slf4j-api:1.7.12"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.5+3cc0f0907d"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
-		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:1.0.0-pre20"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
+		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:1.0.0-pre21.2"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
     jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.antlr:antlr4-runtime:4.10.1"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
 		if (SODIUM) {

File: src/main/java/net/coderbot/iris/postprocess/FinalPassRenderer.java
Patch:
@@ -117,7 +117,7 @@ public FinalPassRenderer(ProgramSet pack, RenderTargets renderTargets, IntSuppli
 			swap.target = target;
 			swap.width = target1.getWidth();
 			swap.height = target1.getHeight();
-			swap.from = renderTargets.createFramebufferWritingToAlt(new int[] {target});
+			swap.from = renderTargets.createColorFramebuffer(ImmutableSet.of(), new int[] {target});
 			// NB: This is handled in RenderTargets now.
 			//swap.from.readBuffer(target);
 			swap.targetTexture = renderTargets.get(target).getMainTexture();

File: src/main/java/net/coderbot/iris/pipeline/ClearPassCreator.java
Patch:
@@ -53,7 +53,7 @@ public static ImmutableList<ClearPass> createClearPasses(RenderTargets renderTar
 
 		List<ClearPass> clearPasses = new ArrayList<>();
 
-		clearByColor.forEach((vector2i, vector4fIntListMap) -> {
+		clearByColor.forEach((passSize, vector4fIntListMap) -> {
 			vector4fIntListMap.forEach((clearColor, buffers) -> {
 				int startIndex = 0;
 
@@ -69,10 +69,10 @@ public static ImmutableList<ClearPass> createClearPasses(RenderTargets renderTar
 					}
 
 					// No need to clear the depth buffer, since we're using Minecraft's depth buffer.
-					clearPasses.add(new ClearPass(clearColor, renderTargets::getCurrentWidth, renderTargets::getCurrentHeight,
+					clearPasses.add(new ClearPass(clearColor, passSize::x, passSize::y,
 						renderTargets.createFramebufferWritingToAlt(clearBuffers), GL21C.GL_COLOR_BUFFER_BIT));
 
-					clearPasses.add(new ClearPass(clearColor, renderTargets::getCurrentWidth, renderTargets::getCurrentHeight,
+					clearPasses.add(new ClearPass(clearColor, passSize::x, passSize::y,
 						renderTargets.createFramebufferWritingToMain(clearBuffers), GL21C.GL_COLOR_BUFFER_BIT));
 				}
 			});

File: src/main/java/net/coderbot/iris/pipeline/HorizonRenderer.java
Patch:
@@ -47,7 +47,7 @@ public class HorizonRenderer {
 	private int currentRenderDistance;
 
 	public HorizonRenderer() {
-		currentRenderDistance = Minecraft.getInstance().options.renderDistance;
+		currentRenderDistance = Minecraft.getInstance().options.getEffectiveRenderDistance();
 
 		rebuildBuffer();
 	}
@@ -165,8 +165,8 @@ private void buildHorizon(int radius, VertexConsumer consumer) {
 	}
 
 	public void renderHorizon(Matrix4f modelView, Matrix4f projection, ShaderInstance shader) {
-		if (currentRenderDistance != Minecraft.getInstance().options.renderDistance) {
-			currentRenderDistance = Minecraft.getInstance().options.renderDistance;
+		if (currentRenderDistance != Minecraft.getInstance().options.getEffectiveRenderDistance()) {
+			currentRenderDistance = Minecraft.getInstance().options.getEffectiveRenderDistance();
 			rebuildBuffer();
 		}
 

File: src/main/java/net/coderbot/iris/pipeline/HorizonRenderer.java
Patch:
@@ -170,8 +170,9 @@ public void renderHorizon(Matrix4f modelView, Matrix4f projection, ShaderInstanc
 			rebuildBuffer();
 		}
 
+		buffer.bind();
 		buffer.drawWithShader(modelView, projection, shader);
-
+		VertexBuffer.unbind();
 	}
 
 	public void destroy() {

File: src/main/java/net/coderbot/iris/mixin/GameRendererAccessor.java
Patch:
@@ -20,4 +20,7 @@ public interface GameRendererAccessor {
 
 	@Invoker
 	void invokeBobHurt(PoseStack poseStack, float tickDelta);
+
+	@Invoker
+	double invokeGetFov(Camera camera, float tickDelta, boolean bobView);
 }

File: src/main/java/net/coderbot/iris/mixin/MixinRenderSystem.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.Iris;
+import net.coderbot.iris.gl.GLDebug;
 import net.coderbot.iris.gl.IrisRenderSystem;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
@@ -12,6 +13,7 @@
 public class MixinRenderSystem {
 	@Inject(method = "initRenderer", at = @At("RETURN"))
 	private static void iris$onRendererInit(int debugVerbosity, boolean alwaysFalse, CallbackInfo ci) {
+		GLDebug.initRenderer();
 		IrisRenderSystem.initRenderer();
 		Iris.onRenderSystemInit();
 	}

File: src/main/java/net/coderbot/iris/gl/IrisRenderSystem.java
Patch:
@@ -328,15 +328,14 @@ public void copyTexSubImage2D(int destTexture, int target, int i, int i1, int i2
 			ARBDirectStateAccess.glCopyTextureSubImage2D(destTexture, i, i1, i2, i3, i4, width, height);
 		}
 
-		// TODO: Find out why this causes blurry textures
-		/*@Override
+		@Override
 		public void bindTextureToUnit(int unit, int texture) {
 			if (texture == 0) {
 				super.bindTextureToUnit(unit, texture);
 			} else {
 				ARBDirectStateAccess.glBindTextureUnit(unit, texture);
 			}
-		}*/
+		}
 
 		@Override
 		public int bufferStorage(int target, float[] data, int usage) {

File: src/main/java/net/coderbot/iris/gl/IrisRenderSystem.java
Patch:
@@ -328,14 +328,15 @@ public void copyTexSubImage2D(int destTexture, int target, int i, int i1, int i2
 			ARBDirectStateAccess.glCopyTextureSubImage2D(destTexture, i, i1, i2, i3, i4, width, height);
 		}
 
-		@Override
+		// TODO: Find out why this causes blurry textures
+		/*@Override
 		public void bindTextureToUnit(int unit, int texture) {
 			if (texture == 0) {
 				super.bindTextureToUnit(unit, texture);
 			} else {
 				ARBDirectStateAccess.glBindTextureUnit(unit, texture);
 			}
-		}
+		}*/
 
 		@Override
 		public int bufferStorage(int target, float[] data, int usage) {

File: src/main/java/net/coderbot/iris/mixin/MixinOptions_Entrypoint.java
Patch:
@@ -13,7 +13,7 @@
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
-@Mixin(value = Options.class)
+@Mixin(value = Options.class, priority = 990)
 public class MixinOptions_Entrypoint {
 	@Unique
 	private static boolean iris$initialized;

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -91,7 +91,7 @@ protected FabricModule createModule() {
     @Override
     public void getModDependencies(ModDependencyCollector d) {
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.anarres:jcpp:1.4.14"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
-		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.12+54e5b2ec60"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
+		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.20+aeb40ebe90"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
 		if (SODIUM) {
 			d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-api-base", "0.4.3+d7c144a8d2"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);

File: src/main/java/net/coderbot/iris/shaderpack/preprocessor/JcppProcessor.java
Patch:
@@ -28,6 +28,9 @@ public static String glslPreprocessSource(String source, Iterable<StringPair> en
 		source = source.replace("#version", GlslCollectingListener.VERSION_MARKER);
 		source = source.replace("#extension", GlslCollectingListener.EXTENSION_MARKER);
 
+		// Remove null characters. Some packs, such as Chocapic High Performance, have random null characters that trip up JCPP.
+		source = source.replace("\u0000", "");
+
 		GlslCollectingListener listener = new GlslCollectingListener();
 
 		@SuppressWarnings("resource")

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -115,7 +115,7 @@ public static void addNonDynamicUniforms(UniformHolder uniforms, IdMap idMap, Pa
 		new CelestialUniforms(directives.getSunPathRotation()).addCelestialUniforms(uniforms);
 		IrisExclusiveUniforms.addIrisExclusiveUniforms(uniforms);
 		MatrixUniforms.addMatrixUniforms(uniforms, directives);
-		IdMapUniforms.addIdMapUniforms(updateNotifier, uniforms, idMap);
+		IdMapUniforms.addIdMapUniforms(updateNotifier, uniforms, idMap, directives.isOldHandLight());
 		CommonUniforms.generalCommonUniforms(uniforms, updateNotifier, directives);
 	}
 

File: src/main/java/kroppeb/stareval/function/B2BFunction.java
Patch:
@@ -20,7 +20,7 @@ default Type getReturnType() {
 	}
 
 	@Override
-	default Type[] getParameterTypes() {
-		return new Type[]{Type.Boolean};
+	default Parameter[] getParameters() {
+		return new Parameter[]{Type.BooleanParameter};
 	}
 }

File: src/main/java/kroppeb/stareval/function/BB2BFunction.java
Patch:
@@ -23,7 +23,7 @@ default Type getReturnType() {
 	}
 
 	@Override
-	default Type[] getParameterTypes() {
-		return new Type[]{Type.Boolean, Type.Boolean};
+	default Parameter[] getParameters() {
+		return new Parameter[]{Type.BooleanParameter, Type.BooleanParameter};
 	}
 }

File: src/main/java/kroppeb/stareval/function/F2FFunction.java
Patch:
@@ -18,7 +18,7 @@ default Type getReturnType() {
 	}
 
 	@Override
-	default Type[] getParameterTypes() {
-		return new Type[]{Type.Float};
+	default Parameter[] getParameters() {
+		return new Parameter[]{Type.FloatParameter};
 	}
 }

File: src/main/java/kroppeb/stareval/function/F2IFunction.java
Patch:
@@ -18,7 +18,7 @@ default Type getReturnType() {
 	}
 
 	@Override
-	default Type[] getParameterTypes() {
-		return new Type[]{Type.Float};
+	default Parameter[] getParameters() {
+		return new Parameter[]{Type.FloatParameter};
 	}
 }

File: src/main/java/kroppeb/stareval/function/FF2BFunction.java
Patch:
@@ -23,7 +23,7 @@ default Type getReturnType() {
 	}
 
 	@Override
-	default Type[] getParameterTypes() {
-		return new Type[]{Type.Float, Type.Float};
+	default Parameter[] getParameters() {
+		return new Parameter[]{Type.FloatParameter, Type.FloatParameter};
 	}
 }

File: src/main/java/kroppeb/stareval/function/FF2FFunction.java
Patch:
@@ -23,7 +23,7 @@ default Type getReturnType() {
 	}
 
 	@Override
-	default Type[] getParameterTypes() {
-		return new Type[]{Type.Float, Type.Float};
+	default Parameter[] getParameters() {
+		return new Parameter[]{Type.FloatParameter, Type.FloatParameter};
 	}
 }

File: src/main/java/kroppeb/stareval/function/FFF2BFunction.java
Patch:
@@ -26,7 +26,7 @@ default Type getReturnType() {
 	}
 
 	@Override
-	default Type[] getParameterTypes() {
-		return new Type[]{Type.Float, Type.Float, Type.Float};
+	default Parameter[] getParameters() {
+		return new Parameter[]{Type.FloatParameter, Type.FloatParameter, Type.FloatParameter};
 	}
 }

File: src/main/java/kroppeb/stareval/function/FFF2FFunction.java
Patch:
@@ -26,7 +26,7 @@ default Type getReturnType() {
 	}
 
 	@Override
-	default Type[] getParameterTypes() {
-		return new Type[]{Type.Float, Type.Float, Type.Float};
+	default Parameter[] getParameters() {
+		return new Parameter[]{Type.FloatParameter, Type.FloatParameter, Type.FloatParameter};
 	}
 }

File: src/main/java/kroppeb/stareval/function/I2FFunction.java
Patch:
@@ -18,7 +18,7 @@ default Type getReturnType() {
 	}
 
 	@Override
-	default Type[] getParameterTypes() {
-		return new Type[]{Type.Int};
+	default Parameter[] getParameters() {
+		return new Parameter[]{Type.IntParameter};
 	}
 }

File: src/main/java/kroppeb/stareval/function/I2IFunction.java
Patch:
@@ -18,7 +18,7 @@ default Type getReturnType() {
 	}
 
 	@Override
-	default Type[] getParameterTypes() {
-		return new Type[]{Type.Int};
+	default Parameter[] getParameters() {
+		return new Parameter[]{Type.IntParameter};
 	}
 }

File: src/main/java/kroppeb/stareval/function/II2BFunction.java
Patch:
@@ -23,7 +23,7 @@ default Type getReturnType() {
 	}
 
 	@Override
-	default Type[] getParameterTypes() {
-		return new Type[]{Type.Int, Type.Int};
+	default Parameter[] getParameters() {
+		return new Parameter[]{Type.IntParameter, Type.IntParameter};
 	}
 }

File: src/main/java/kroppeb/stareval/function/II2IFunction.java
Patch:
@@ -23,7 +23,7 @@ default Type getReturnType() {
 	}
 
 	@Override
-	default Type[] getParameterTypes() {
-		return new Type[]{Type.Int, Type.Int};
+	default Parameter[] getParameters() {
+		return new Parameter[]{Type.IntParameter, Type.IntParameter};
 	}
 }

File: src/main/java/kroppeb/stareval/function/III2BFunction.java
Patch:
@@ -26,7 +26,7 @@ default Type getReturnType() {
 	}
 
 	@Override
-	default Type[] getParameterTypes() {
-		return new Type[]{Type.Int, Type.Int, Type.Int};
+	default Parameter[] getParameters() {
+		return new Parameter[]{Type.IntParameter, Type.IntParameter, Type.IntParameter};
 	}
 }

File: src/main/java/kroppeb/stareval/function/III2IFunction.java
Patch:
@@ -26,7 +26,7 @@ default Type getReturnType() {
 	}
 
 	@Override
-	default Type[] getParameterTypes() {
-		return new Type[]{Type.Int, Type.Int, Type.Int};
+	default Parameter[] getParameters() {
+		return new Parameter[]{Type.IntParameter, Type.IntParameter, Type.IntParameter};
 	}
 }

File: src/main/java/kroppeb/stareval/function/V2FFunction.java
Patch:
@@ -17,7 +17,7 @@ default Type getReturnType() {
 	}
 
 	@Override
-	default Type[] getParameterTypes() {
-		return new Type[]{};
+	default Parameter[] getParameters() {
+		return new Parameter[]{};
 	}
 }

File: src/main/java/kroppeb/stareval/function/V2IFunction.java
Patch:
@@ -17,7 +17,7 @@ default Type getReturnType() {
 	}
 
 	@Override
-	default Type[] getParameterTypes() {
-		return new Type[]{};
+	default Parameter[] getParameters() {
+		return new Parameter[]{};
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/texture/MixinResourceLocation.java
Patch:
@@ -11,8 +11,8 @@
 public class MixinResourceLocation {
 	@Inject(method = "isValidPath", at = @At("HEAD"), cancellable = true)
 	private static void iris$allowInvalidPaths(String path, CallbackInfoReturnable<Boolean> cir) {
-		if (path.equals("DUMMY")) {
-			// This is here to solve a weird case in DFU that expects minecraft:DUMMY to be invalid.
+		if (path.equals("DUMMY") || path.equals("\u0001")) {
+			// This is here to solve a weird case in DFU that expects minecraft:DUMMY to be invalid, or cases where people pass an "empty" string that is actually \u0001.
 			cir.setReturnValue(false);
 			return;
 		}

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -89,6 +89,8 @@ public void getModDependencies(ModDependencyCollector d) {
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.slf4j:slf4j-api:1.7.12"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
 		if (SODIUM) {
+			d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-resource-loader-v0", "0.4.8+3cc0f0907d"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
+
 			if (CUSTOM_SODIUM) {
 				d.add(new JavaJarDependency(getProjectDir().resolve("custom_sodium").resolve(customSodiumName).toAbsolutePath(), null, new MavenId("me.jellysquid.mods", "sodium-fabric", customSodiumName.replace("sodium-fabric-", ""))), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 			} else {

File: src/main/java/net/coderbot/iris/mixin/MixinClientLanguage.java
Patch:
@@ -46,7 +46,7 @@ public class MixinClientLanguage {
 	@Final
 	private Map<String, String> storage;
 
-	@Inject(method = "loadFrom", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/resources/language/ClientLanguage;appendFrom(Ljava/util/List;Ljava/util/Map;)V"), locals = LocalCapture.CAPTURE_FAILHARD)
+	@Inject(method = "loadFrom", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/resources/language/ClientLanguage;appendFrom(Ljava/lang/String;Ljava/util/List;Ljava/util/Map;)V"), locals = LocalCapture.CAPTURE_FAILHARD)
 	private static void injectFrom(ResourceManager arg, List<LanguageInfo> list, CallbackInfoReturnable<ClientLanguage> cir, Map<String, String> map, boolean bl, Iterator<LanguageInfo> infoIterator, LanguageInfo info, String json) {
 		if (Iris.class.getResource("/assets/iris/" + json) != null) {
 			Language.loadFromJson(Iris.class.getResourceAsStream("/assets/iris/" + json), map::put);

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/terrain_xhfp/XHFPModelVertexType.java
Patch:
@@ -24,7 +24,7 @@ public class XHFPModelVertexType implements ChunkVertexType {
 			.addElement(IrisChunkMeshAttributes.MID_TEX_COORD, 20, GlVertexAttributeFormat.FLOAT, 2, false, false)
 			.addElement(IrisChunkMeshAttributes.TANGENT, 28, IrisGlVertexAttributeFormat.BYTE, 4, true, false)
 			.addElement(IrisChunkMeshAttributes.NORMAL, 32, IrisGlVertexAttributeFormat.BYTE, 3, true, false)
-			.addElement(IrisChunkMeshAttributes.BLOCK_ID, 36, GlVertexAttributeFormat.UNSIGNED_SHORT, 2, false, false)
+			.addElement(IrisChunkMeshAttributes.BLOCK_ID, 36, IrisGlVertexAttributeFormat.SHORT, 2, false, false)
 			.addElement(IrisChunkMeshAttributes.MID_BLOCK, 40, IrisGlVertexAttributeFormat.BYTE, 3, false, false)
 			.build();
 

File: src/main/java/net/coderbot/iris/pipeline/transform/CommonTransformer.java
Patch:
@@ -86,7 +86,7 @@ public boolean matches(ExternalDeclaration tree) {
 	};
 
 	private static final Template<Statement> alphaTestStatement = Template
-			.withStatement("if output.a < iris_currentAlphaTest discard;");
+			.withStatement("if (output.a < iris_currentAlphaTest) discard;");
 	private static final Template<ExternalDeclaration> fragDataDeclaration = Template
 			.withExternalDeclaration("layout (location = index) out vec4 name;");
 	{

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -99,7 +99,7 @@ public void getModDependencies(ModDependencyCollector d) {
 		d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-rendering-data-attachment-v1", "0.1.6+cf39a74318"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 		d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-rendering-fluids-v1", "0.2.1+cf39a74318"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 
-		jij(d.addMaven(Maven.MAVEN_LOCAL, new MavenId("io.github.douira:glsl-transformer:1.0.0-pre18.1"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
+		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("io.github.douira:glsl-transformer:1.0.0-pre18.1"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.antlr:antlr4-runtime:4.10.1"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
 		if (SODIUM) {

File: src/main/java/net/coderbot/iris/pipeline/transform/TransformPatcher.java
Patch:
@@ -45,7 +45,7 @@ public class TransformPatcher {
 	static Logger LOGGER = LogManager.getLogger(TransformPatcher.class);
 	private static EnumASTTransformer<Parameters, PatchShaderType> transformer;
 	private static final boolean useCache = true;
-	private static final Map<CacheKey, Map<PatchShaderType, String>> cache = useCache ? new LRUCache<>(400) : null;
+	private static final Map<CacheKey, Map<PatchShaderType, String>> cache =  new LRUCache<>(400);
 
 	private static class CacheKey {
 		final Parameters parameters;

File: src/main/java/net/coderbot/iris/pipeline/transform/TransformPatcher.java
Patch:
@@ -47,7 +47,7 @@ public class TransformPatcher {
 	static Logger LOGGER = LogManager.getLogger(TransformPatcher.class);
 	private static EnumASTTransformer<Parameters, PatchShaderType> transformer;
 	private static final boolean useCache = true;
-	private static final Map<CacheKey, Map<PatchShaderType, String>> cache = useCache ? new LRUCache<>(400) : null;
+	private static final Map<CacheKey, Map<PatchShaderType, String>> cache =  new LRUCache<>(400);
 
 	private static class CacheKey {
 		final Parameters parameters;

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -194,7 +194,7 @@ public NewWorldRenderingPipeline(ProgramSet programSet) throws IOException {
 
 		BufferFlipper flipper = new BufferFlipper();
 
-		this.centerDepthSampler = new CenterDepthSampler(programSet.getPackDirectives().getCenterDepthHalfLife());
+		this.centerDepthSampler = new CenterDepthSampler(renderTargets, programSet.getPackDirectives().getCenterDepthHalfLife());
 
 		this.shadowMapResolution = programSet.getPackDirectives().getShadowDirectives().getResolution();
 

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -193,7 +193,7 @@ public DeferredWorldRenderingPipeline(ProgramSet programs) {
 
 		BufferFlipper flipper = new BufferFlipper();
 
-		this.centerDepthSampler = new CenterDepthSampler(programs.getPackDirectives().getCenterDepthHalfLife());
+		this.centerDepthSampler = new CenterDepthSampler(renderTargets, programs.getPackDirectives().getCenterDepthHalfLife());
 
 		this.shadowMapResolution = programs.getPackDirectives().getShadowDirectives().getResolution();
 

File: src/main/java/net/coderbot/iris/postprocess/CenterDepthSampler.java
Patch:
@@ -11,6 +11,7 @@
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
 import net.coderbot.iris.gl.texture.PixelType;
 import net.coderbot.iris.gl.uniform.UniformUpdateFrequency;
+import net.coderbot.iris.rendertarget.RenderTargets;
 import net.coderbot.iris.uniforms.SystemTimeUniforms;
 import net.minecraft.client.Minecraft;
 import org.apache.commons.io.IOUtils;
@@ -30,7 +31,7 @@ public class CenterDepthSampler {
 	private final int texture;
 	private final int altTexture;
 
-	public CenterDepthSampler(float halfLife) {
+	public CenterDepthSampler(RenderTargets targets, float halfLife) {
 		this.texture = GlStateManager._genTexture();
 		this.altTexture = GlStateManager._genTexture();
 		this.framebuffer = new GlFramebuffer();
@@ -55,7 +56,7 @@ public CenterDepthSampler(float halfLife) {
 			throw new RuntimeException(e);
 		}
 
-		builder.addDynamicSampler(Minecraft.getInstance().getMainRenderTarget()::getDepthTextureId, "depth");
+		builder.addDynamicSampler(targets::getDepthTexture, "depth");
 		builder.addDynamicSampler(() -> altTexture, "altDepth");
 		builder.uniform1f(UniformUpdateFrequency.PER_FRAME, "lastFrameTime", SystemTimeUniforms.TIMER::getLastFrameTime);
 		builder.uniform1f(UniformUpdateFrequency.ONCE, "decay", () -> (1.0f / ((halfLife * 0.1) / LN2)));

File: src/main/java/net/coderbot/iris/pipeline/transform/CompatibilityTransformer.java
Patch:
@@ -155,7 +155,7 @@ public static void transformEach(ASTParser t, TranslationUnit tree, Root root, P
 		}
 	};
 
-	private static final String tagPrefix = "iris__";
+	private static final String tagPrefix = "iris_template_";
 	private static final String typeTag = tagPrefix + "1";
 	private static final String nameTag = tagPrefix + "2";
 	private static final String nameTag2 = tagPrefix + "3";

File: src/main/java/net/coderbot/iris/pipeline/transform/CompatibilityTransformer.java
Patch:
@@ -154,7 +154,7 @@ public static void transformGrouped(
 		 * - improved geometry shader support? They use funky declarations
 		 */
 		ShaderType prevType = null;
-		for (int i = 10; i < pipeline.length; i++) {
+		for (int i = 0; i < pipeline.length; i++) {
 			ShaderType type = pipeline[i];
 			PatchShaderType[] patchTypes = PatchShaderType.fromGlShaderType(type);
 

File: src/main/java/net/coderbot/iris/pipeline/transform/TransformPatcher.java
Patch:
@@ -46,7 +46,7 @@
 public class TransformPatcher {
 	static Logger LOGGER = LogManager.getLogger(TransformPatcher.class);
 	private static EnumASTTransformer<Parameters, PatchShaderType> transformer;
-	private static final boolean useCache = false;
+	private static final boolean useCache = true;
 	private static final Map<CacheKey, Map<PatchShaderType, String>> cache = useCache ? new LRUCache<>(400) : null;
 
 	private static class CacheKey {

File: src/main/java/net/coderbot/iris/pipeline/transform/TransformPatcher.java
Patch:
@@ -183,7 +183,7 @@ private static String transform(String source, Parameters parameters) {
 		transformer.getLexer().version = version;
 
 		String result = transformer.transform(
-				PatchedShaderPrinter.prettyPrintShaders ? PrintType.INDENTED : PrintType.COMPACT,
+				PatchedShaderPrinter.prettyPrintShaders ? PrintType.INDENTED : PrintType.SIMPLE,
 				source, parameters);
 
 		if (useCache) {

File: src/main/java/net/coderbot/batchedentityrendering/impl/MemoryTrackingBuffer.java
Patch:
@@ -3,4 +3,5 @@
 public interface MemoryTrackingBuffer {
 	int getAllocatedSize();
 	int getUsedSize();
+	void freeAndDeleteBuffer();
 }

File: src/main/java/net/coderbot/batchedentityrendering/impl/MemoryTrackingRenderBuffers.java
Patch:
@@ -4,4 +4,5 @@ public interface MemoryTrackingRenderBuffers {
     int getEntityBufferAllocatedSize();
     int getMiscBufferAllocatedSize();
     int getMaxBegins();
+	void freeAndDeleteBuffers();
 }

File: src/main/java/net/coderbot/iris/postprocess/FullScreenQuadRenderer.java
Patch:
@@ -62,8 +62,6 @@ public void end() {
 		// https://github.com/IrisShaders/Iris/issues/1214
 
 		RenderSystem.enableDepthTest();
-		VertexBuffer.unbind();
-		VertexBuffer.unbindVertexArray();
 		((VertexBufferHelper) quad).restoreBinding();
 	}
 }

File: src/main/java/net/coderbot/iris/uniforms/ExternallyManagedUniforms.java
Patch:
@@ -12,6 +12,9 @@ public static void addExternallyManagedUniforms(UniformHolder uniformHolder) {
 		addMat4(uniformHolder, "iris_ModelViewMatrix");
 		addMat4(uniformHolder, "u_ModelViewProjectionMatrix");
 		addMat4(uniformHolder, "iris_NormalMatrix");
+		// Exclusive to pre-1.19
+		addFloat(uniformHolder, "darknessFactor");
+		addFloat(uniformHolder, "darknessLightFactor");
 	}
 
 	public static void addExternallyManagedUniforms116(UniformHolder uniformHolder) {

File: src/main/java/net/coderbot/iris/rendertarget/RenderTargets.java
Patch:
@@ -110,7 +110,7 @@ public DepthTexture getDepthTextureNoHand() {
 		return noHand;
 	}
 
-	public void resizeIfNeeded(int newDepthBufferVersion, int newDepthTextureId, int newWidth, int newHeight, DepthBufferFormat newDepthFormat) {
+	public boolean resizeIfNeeded(int newDepthBufferVersion, int newDepthTextureId, int newWidth, int newHeight, DepthBufferFormat newDepthFormat) {
 		boolean recreateDepth = false;
 		if (cachedDepthBufferVersion != newDepthBufferVersion) {
 			recreateDepth = true;
@@ -164,6 +164,8 @@ public void resizeIfNeeded(int newDepthBufferVersion, int newDepthTextureId, int
 
 			fullClearRequired = true;
 		}
+
+		return sizeChanged;
 	}
 
 	public void copyPreTranslucentDepth() {

File: src/main/java/net/coderbot/iris/pipeline/transform/CompositeDepthTransformer.java
Patch:
@@ -9,7 +9,7 @@
 import io.github.douira.glsl_transformer.ast.transform.ASTInjectionPoint;
 import io.github.douira.glsl_transformer.ast.transform.ASTTransformer;
 
-public class CompositeDepthTransformer {
+class CompositeDepthTransformer {
 	private static final AutoHintedMatcher<ExternalDeclaration> uniformFloatCenterDepthSmooth = new AutoHintedMatcher<>(
 			"uniform float centerDepthSmooth;", Matcher.externalDeclarationPattern);
 

File: src/main/java/net/coderbot/iris/pipeline/transform/CommonTransformer.java
Patch:
@@ -108,7 +108,7 @@ public static void transform(
 		// passes. A shader that relies on this behavior is SEUS v11 - it reads
 		// gl_Fog.color and breaks if it is not properly defined.
 		root.rename("gl_Fog", "iris_Fog");
-		tree.parseAndInjectNodes(t, ASTInjectionPoint.BEFORE_FUNCTIONS,
+		tree.parseAndInjectNodes(t, ASTInjectionPoint.BEFORE_DECLARATIONS,
 				"uniform float iris_FogDensity;",
 				"uniform float iris_FogStart;",
 				"uniform float iris_FogEnd;",

File: src/main/java/net/coderbot/iris/pipeline/transform/AttributeParameters.java
Patch:
@@ -15,7 +15,6 @@ public AttributeParameters(Patch patch, ShaderType type, boolean hasGeometry, In
 	public int hashCode() {
 		final int prime = 31;
 		int result = super.hashCode();
-		result = prime * result + (hasGeometry ? 1231 : 1237);
 		result = prime * result + ((inputs == null) ? 0 : inputs.hashCode());
 		return result;
 	}
@@ -29,8 +28,6 @@ public boolean equals(Object obj) {
 		if (getClass() != obj.getClass())
 			return false;
 		AttributeParameters other = (AttributeParameters) obj;
-		if (hasGeometry != other.hasGeometry)
-			return false;
 		if (inputs == null) {
 			if (other.inputs != null)
 				return false;

File: src/main/java/net/coderbot/iris/pipeline/transform/TransformPatcher.java
Patch:
@@ -73,7 +73,7 @@ public boolean equals(Object obj) {
 			if (parameters == null) {
 				if (other.parameters != null)
 					return false;
-			} else if (!Objects.equals(parameters, other.parameters))
+			} else if (!parameters.equals(other.parameters))
 				return false;
 			return true;
 		}

File: src/main/java/net/coderbot/iris/pipeline/transform/TransformPatcher.java
Patch:
@@ -74,7 +74,7 @@ public boolean equals(Object obj) {
 			if (parameters == null) {
 				if (other.parameters != null)
 					return false;
-			} else if (!Objects.equals(parameters, other.parameters))
+			} else if (!parameters.equals(other.parameters))
 				return false;
 			return true;
 		}

File: src/main/java/net/coderbot/iris/pipeline/transform/TransformPatcher.java
Patch:
@@ -122,7 +122,7 @@ public boolean isTokenAllowed(Token token) {
 				}
 			});
 		});
-		transformer.getInternalParser().setParseTokenFilter(parseTokenFilter);
+		transformer.setParseTokenFilter(parseTokenFilter);
 	}
 
 	private static String inspectPatch(

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -258,12 +258,11 @@ public int getAsInt() {
 
 			ItemStack stack = client.player.getItemInHand(hand);
 
-			if (stack == ItemStack.EMPTY || stack == null || !(stack.getItem() instanceof IrisItemLightProvider)) {
+			if (stack == ItemStack.EMPTY || stack == null) {
 				return 0;
 			}
 
-			IrisItemLightProvider item = (IrisItemLightProvider)stack.getItem();
-			return item.getLightEmission(client.player, stack);
+			return ((IrisItemLightProvider)stack.getItem()).getLightEmission(client.player, stack);
 		}
 	}
 

File: src/main/java/net/coderbot/iris/gui/element/ShaderPackOptionList.java
Patch:
@@ -238,7 +238,7 @@ private boolean importSettingsButtonClicked(IrisElementRow.IconButtonElement but
 			// https://github.com/IrisShaders/Iris/issues/1258
 			if (Minecraft.getInstance().getWindow().isFullscreen()) {
 				this.screen.displayNotification(
-					new TranslatableComponent("options.iris.mustDisableFullscreen")
+					Component.translatable("options.iris.mustDisableFullscreen")
 						.withStyle(ChatFormatting.RED).withStyle(ChatFormatting.BOLD));
 				return false;
 			}
@@ -276,7 +276,7 @@ private boolean exportSettingsButtonClicked(IrisElementRow.IconButtonElement but
 			// https://github.com/IrisShaders/Iris/issues/1258
 			if (Minecraft.getInstance().getWindow().isFullscreen()) {
 				this.screen.displayNotification(
-					new TranslatableComponent("options.iris.mustDisableFullscreen")
+					Component.translatable("options.iris.mustDisableFullscreen")
 						.withStyle(ChatFormatting.RED).withStyle(ChatFormatting.BOLD));
 				return false;
 			}

File: src/main/java/net/coderbot/iris/pipeline/patcher/TransformPatcherOld.java
Patch:
@@ -231,7 +231,7 @@ protected void run(TranslationUnitContext ctx) {
 				String profile = Optional.ofNullable(versionStatement.profile)
 						.map(terminal -> terminal.getText())
 						.orElse("");
-				int version = Integer.parseInt(versionStatement.NR_INTCONSTANT().getText());
+				int version = Integer.parseInt(versionStatement.version.getText());
 
 				if (profile.equals("core")) {
 					throw new IllegalStateException(

File: src/main/java/net/coderbot/iris/shaderpack/option/values/OptionValues.java
Patch:
@@ -13,8 +13,8 @@ public interface OptionValues {
 	default boolean getBooleanValueOrDefault(String name) {
 		return getBooleanValue(name).orElseGet(() -> {
 			if (!getOptionSet().getBooleanOptions().containsKey(name)) {
-				Iris.logger.warn("Tried to get boolean value for unknown option: " + name + ", defaulting to false!");
-				return false;
+				Iris.logger.warn("Tried to get boolean value for unknown option: " + name + ", defaulting to true!");
+				return true;
 			}
 			return getOptionSet().getBooleanOptions().get(name).getOption().getDefaultValue();
 		});

File: src/main/java/net/coderbot/iris/pipeline/transform/CompositeTransformer.java
Patch:
@@ -12,7 +12,7 @@
 import net.coderbot.iris.gl.shader.ShaderType;
 
 public class CompositeTransformer {
-	private static final AutoHintedMatcher<Expression> glTextureMatrix0To8 = new AutoHintedMatcher<Expression>(
+	private static final AutoHintedMatcher<Expression> glTextureMatrix0To7 = new AutoHintedMatcher<Expression>(
 			"gl_TextureMatrix[index]", Matcher.expressionPattern) {
 		{
 			markClassedPredicateWildcard("index",
@@ -43,7 +43,7 @@ public static void transform(
 		// transformations.replaceExact("gl_TextureMatrix[" + i + "]", "mat4(1.0)");
 		// transformations.replaceExact("gl_TextureMatrix [" + i + "]", "mat4(1.0)");
 		// }
-		root.replaceExpressionMatches(t, glTextureMatrix0To8, "mat4(1.0)");
+		root.replaceExpressionMatches(t, glTextureMatrix0To7, "mat4(1.0)");
 
 		// TODO: Other fog things
 

File: src/main/java/net/coderbot/iris/pipeline/transform/CompositeTransformer.java
Patch:
@@ -12,7 +12,7 @@
 import net.coderbot.iris.gl.shader.ShaderType;
 
 public class CompositeTransformer {
-	private static final AutoHintedMatcher<Expression> glTextureMatrix1To8 = new AutoHintedMatcher<Expression>(
+	private static final AutoHintedMatcher<Expression> glTextureMatrix0To8 = new AutoHintedMatcher<Expression>(
 			"gl_TextureMatrix[index]", Matcher.expressionPattern) {
 		{
 			markClassedPredicateWildcard("index",
@@ -43,7 +43,7 @@ public static void transform(
 		// transformations.replaceExact("gl_TextureMatrix[" + i + "]", "mat4(1.0)");
 		// transformations.replaceExact("gl_TextureMatrix [" + i + "]", "mat4(1.0)");
 		// }
-		root.replaceExpressionMatches(t, glTextureMatrix1To8, "mat4(1.0)");
+		root.replaceExpressionMatches(t, glTextureMatrix0To8, "mat4(1.0)");
 
 		// TODO: Other fog things
 

File: src/main/java/net/coderbot/iris/pipeline/transform/VanillaTransformer.java
Patch:
@@ -14,12 +14,12 @@ public static void transform(
 			TranslationUnit tree,
 			Root root,
 			VanillaParameters parameters) {
-		// this happens first to make sure the renaming of attributes is done on
+		// this happens before common to make sure the renaming of attributes is done on
 		// attribute inserted by this
 		if (parameters.inputs.hasOverlay()) {
 			AttributeTransformer.patchOverlayColor(t, tree, root, parameters);
 		}
-
+		// this happens before common for patching gl_FragData
 		if (parameters.type == ShaderType.FRAGMENT) {
 			AlphaTestTransformer.transform(t, tree, root, parameters, parameters.alpha);
 		}

File: src/main/java/net/coderbot/iris/pipeline/transform/AlphaTestTransformer.java
Patch:
@@ -31,7 +31,7 @@ public static void transform(
 			// " irisMain();\n" +
 			// alpha.toExpression(" ") +
 			// "}");
-			tree.parseAndInjectNode(t, ASTInjectionPoint.END, "void irisMain() {" +
+			tree.parseAndInjectNode(t, ASTInjectionPoint.END, "void main() {" +
 					" irisMain();" + alpha.toExpression(" ") + "}");
 		}
 	}

File: src/main/java/net/coderbot/iris/pipeline/transform/VanillaTransformer.java
Patch:
@@ -172,6 +172,8 @@ public static void transform(
 
 				// Create our own main function to wrap the existing main function, so that we
 				// can do our line shenanigans.
+				// TRANSFORM: this is fine since the AttributeTransformer has a different name
+				// in the vertex shader
 				// transformations.replaceExact("main", "irisMain");
 				root.rename("main", "irisMain");
 

File: src/main/java/net/coderbot/iris/pipeline/patcher/TransformPatcherOld.java
Patch:
@@ -1,4 +1,4 @@
-package net.coderbot.iris.pipeline.transform;
+package net.coderbot.iris.pipeline.patcher;
 
 import java.util.ArrayList;
 import java.util.Collection;
@@ -51,7 +51,6 @@
 import net.coderbot.iris.gl.blending.AlphaTest;
 import net.coderbot.iris.gl.shader.ShaderType;
 import net.coderbot.iris.pipeline.newshader.ShaderAttributeInputs;
-import net.coderbot.iris.pipeline.patcher.AttributeShaderTransformer;
 
 /**
  * The transform patcher (triforce 2) uses glsl-transformer to do shader

File: src/main/java/net/coderbot/iris/pipeline/transform/SodiumTerrainTransformer.java
Patch:
@@ -10,7 +10,6 @@
 import io.github.douira.glsl_transformer.ast.node.expression.binary.MultiplicationExpression;
 import io.github.douira.glsl_transformer.ast.node.expression.unary.MemberAccessExpression;
 import io.github.douira.glsl_transformer.ast.query.Root;
-import io.github.douira.glsl_transformer.ast.query.match.AutoHintedMatcher;
 import io.github.douira.glsl_transformer.ast.query.match.Matcher;
 import io.github.douira.glsl_transformer.ast.transform.ASTInjectionPoint;
 import io.github.douira.glsl_transformer.ast.transform.ASTTransformer;
@@ -102,8 +101,7 @@ public static void replaceLightmapForSodium(
 		replaceSExpressions.clear();
 		replaceWrapExpressions.clear();
 
-		root.replaceExpressionMatches(t, "gl_TextureMatrix",
-				CommonTransformer.glTextureMatrix1, "iris_LightmapTextureMatrix");
+		root.replaceExpressionMatches(t, CommonTransformer.glTextureMatrix1, "iris_LightmapTextureMatrix");
 		root.replaceReferenceExpressions(t, "gl_MultiTexCoord1", "vec4("
 				+ lightmapCoordsExpression + " * 255.0, 0.0, 1.0)");
 		root.replaceReferenceExpressions(t, "gl_MultiTexCoord2", "vec4("

File: src/main/java/net/coderbot/iris/pipeline/transform/SodiumTransformer.java
Patch:
@@ -17,8 +17,7 @@ public static void transform(
 		AlphaTestTransformer.transform(t, tree, root, parameters, parameters.alpha);
 
 		// transformations.replaceExact("gl_TextureMatrix[0]", "mat4(1.0)");
-		root.replaceExpressionMatches(t, "gl_TextureMatrix",
-				CommonTransformer.glTextureMatrix1, "mat4(1.0)");
+		root.replaceExpressionMatches(t, CommonTransformer.glTextureMatrix0, "mat4(1.0)");
 
 		// transformations.define("gl_ProjectionMatrix", "iris_ProjectionMatrix");
 		root.rename("gl_ProjectionMatrix", "iris_ProjectionMatrix");

File: src/main/java/net/coderbot/iris/pipeline/newshader/ShaderKey.java
Patch:
@@ -24,6 +24,7 @@ public enum ShaderKey {
 	TERRAIN_CUTOUT         (ProgramId.Terrain,     AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.TERRAIN,                       FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	TERRAIN_CUTOUT_MIPPED  (ProgramId.Terrain,     AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.TERRAIN,                       FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	TERRAIN_TRANSLUCENT    (ProgramId.Water,       AlphaTests.OFF,             IrisVertexFormats.TERRAIN,                       FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
+	MOVING_BLOCK	       (ProgramId.Block,       AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.TERRAIN,                       FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	ENTITIES_ALPHA         (ProgramId.Entities,    AlphaTests.VERTEX_ALPHA,    IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	ENTITIES_SOLID         (ProgramId.Entities,    AlphaTests.OFF,             IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.LIGHTMAP  ),
 	ENTITIES_SOLID_DIFFUSE (ProgramId.Entities,    AlphaTests.OFF,             IrisVertexFormats.ENTITY,                        FogMode.PER_VERTEX,   LightingModel.DIFFUSE_LM),

File: src/main/java/net/coderbot/iris/pipeline/transform/AttributeTransformer.java
Patch:
@@ -8,11 +8,11 @@
 import io.github.douira.glsl_transformer.ast.node.basic.ASTNode;
 import io.github.douira.glsl_transformer.ast.node.external_declaration.DeclarationExternalDeclaration;
 import io.github.douira.glsl_transformer.ast.node.external_declaration.ExternalDeclaration;
+import io.github.douira.glsl_transformer.ast.query.Matcher;
 import io.github.douira.glsl_transformer.ast.query.Root;
 import io.github.douira.glsl_transformer.ast.transform.ASTBuilder;
 import io.github.douira.glsl_transformer.ast.transform.ASTInjectionPoint;
 import io.github.douira.glsl_transformer.ast.transform.ASTTransformer;
-import io.github.douira.glsl_transformer.ast.transform.Matcher;
 import net.coderbot.iris.gl.shader.ShaderType;
 
 /**

File: src/main/java/net/coderbot/iris/pipeline/transform/CompositeDepthTransformer.java
Patch:
@@ -4,11 +4,11 @@
 import io.github.douira.glsl_transformer.ast.node.TranslationUnit;
 import io.github.douira.glsl_transformer.ast.node.external_declaration.DeclarationExternalDeclaration;
 import io.github.douira.glsl_transformer.ast.node.external_declaration.ExternalDeclaration;
+import io.github.douira.glsl_transformer.ast.query.Matcher;
 import io.github.douira.glsl_transformer.ast.query.Root;
 import io.github.douira.glsl_transformer.ast.transform.ASTBuilder;
 import io.github.douira.glsl_transformer.ast.transform.ASTInjectionPoint;
 import io.github.douira.glsl_transformer.ast.transform.ASTTransformer;
-import io.github.douira.glsl_transformer.ast.transform.Matcher;
 
 class CompositeDepthTransformer {
 	private static final Matcher<ExternalDeclaration> uniformFloatCenterDepthSmooth = new Matcher<>(

File: src/main/java/net/coderbot/iris/pipeline/transform/SodiumTerrainTransformer.java
Patch:
@@ -11,11 +11,11 @@
 import io.github.douira.glsl_transformer.ast.node.expression.binary.DivisionExpression;
 import io.github.douira.glsl_transformer.ast.node.expression.binary.MultiplicationExpression;
 import io.github.douira.glsl_transformer.ast.node.expression.unary.MemberAccessExpression;
+import io.github.douira.glsl_transformer.ast.query.Matcher;
 import io.github.douira.glsl_transformer.ast.query.Root;
 import io.github.douira.glsl_transformer.ast.transform.ASTBuilder;
 import io.github.douira.glsl_transformer.ast.transform.ASTInjectionPoint;
 import io.github.douira.glsl_transformer.ast.transform.ASTTransformer;
-import io.github.douira.glsl_transformer.ast.transform.Matcher;
 
 /**
  * Does the sodium terrain transformations using glsl-transformer AST.

File: src/main/java/net/coderbot/iris/shaderpack/ShaderProperties.java
Patch:
@@ -64,7 +64,7 @@ public class ShaderProperties {
 	private OptionalBoolean prepareBeforeShadow = OptionalBoolean.DEFAULT;
 	private List<String> sliderOptions = new ArrayList<>();
 	private final Map<String, List<String>> profiles = new LinkedHashMap<>();
-	private List<String> mainScreenOptions = new ArrayList<>();
+	private List<String> mainScreenOptions = null;
 	private final Map<String, List<String>> subScreenOptions = new HashMap<>();
 	private Integer mainScreenColumnCount = null;
 	private final Map<String, Integer> subScreenColumnCount = new HashMap<>();
@@ -516,8 +516,8 @@ public Map<String, List<String>> getProfiles() {
 		return profiles;
 	}
 
-	public List<String> getMainScreenOptions() {
-		return mainScreenOptions;
+	public Optional<List<String>> getMainScreenOptions() {
+		return Optional.ofNullable(mainScreenOptions);
 	}
 
 	public Map<String, List<String>> getSubScreenOptions() {

File: src/main/java/net/coderbot/iris/gui/screen/ShaderPackScreen.java
Patch:
@@ -180,7 +180,7 @@ protected void init() {
 		this.children.remove(this.shaderPackList);
 		this.children.remove(this.shaderOptionList);
 
-		this.shaderPackList = new ShaderPackSelectionList(this.minecraft, this.width, this.height, 32, this.height - 58, 0, this.width);
+		this.shaderPackList = new ShaderPackSelectionList(this, this.minecraft, this.width, this.height, 32, this.height - 58, 0, this.width);
 
 		if (Iris.getCurrentPack().isPresent() && this.navigation != null) {
 			ShaderPack currentPack = Iris.getCurrentPack().get();
@@ -263,7 +263,7 @@ public void refreshScreenSwitchButton() {
 							new TranslatableComponent("options.iris.shaderPackList")
 							: new TranslatableComponent("options.iris.shaderPackSettings")
 			);
-			this.screenSwitchButton.active = optionMenuOpen || Iris.getCurrentPack().isPresent();
+			this.screenSwitchButton.active = optionMenuOpen || shaderPackList.getTopButtonRow().shadersEnabled;
 		}
 	}
 

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -106,7 +106,7 @@ public void getModDependencies(ModDependencyCollector d) {
 				d.addMaven("https://api.modrinth.com/maven", new MavenId("maven.modrinth", "sodium", "mc1.17.1-0.3.4"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 			}
 		} else {
-			d.addMaven("https://api.modrinth.com/maven", new MavenId("maven.modrinth", "sodium", "mc1.17.1-0.3.4"), ModDependencyFlag.COMPILE, null);
+			d.addMaven("https://api.modrinth.com/maven", new MavenId("maven.modrinth", "sodium", "mc1.17.1-0.3.4"), ModDependencyFlag.COMPILE);
 		}
 
 		d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.joml:joml:1.10.2"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);

File: src/main/java/net/coderbot/iris/mixin/sky/MixinLevelRenderer_SunMoonToggle.java
Patch:
@@ -32,9 +32,8 @@ public class MixinLevelRenderer_SunMoonToggle {
 	private void iris$emptyBuilder() {
 		BufferBuilder builder = Tesselator.getInstance().getBuilder();
 
-		builder.discard();
+		builder.end().release();
 		builder.begin(VertexFormat.Mode.QUADS, DefaultVertexFormat.POSITION);
-		builder.end();
 	}
 
 	@Inject(method = "renderSky",

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -77,7 +77,9 @@ public static ExtendedShader create(String name, ProgramSource source, GlFramebu
 				"        { \"name\": \"shadow\" },\n" +
 				"        { \"name\": \"watershadow\" },\n" +
 				"        { \"name\": \"shadowtex0\" },\n" +
+				"        { \"name\": \"shadowtex0HW\" },\n" +
 				"        { \"name\": \"shadowtex1\" },\n" +
+				"        { \"name\": \"shadowtex1HW\" },\n" +
 				"        { \"name\": \"depthtex0\" },\n" +
 				"        { \"name\": \"depthtex1\" },\n" +
 				"        { \"name\": \"noisetex\" },\n");

File: src/main/java/net/coderbot/iris/gl/shader/ProgramCreator.java
Patch:
@@ -19,6 +19,7 @@ public static int create(String name, GlShader... shaders) {
 		GlStateManager._glBindAttribLocation(program, 11, "mc_Entity");
 		GlStateManager._glBindAttribLocation(program, 12, "mc_midTexCoord");
 		GlStateManager._glBindAttribLocation(program, 13, "at_tangent");
+		GlStateManager._glBindAttribLocation(program, 14, "at_midBlock");
 
 		// TODO: more hardcoding for 1.17
 		GlStateManager._glBindAttribLocation(program, 0, "Position");

File: src/main/java/net/coderbot/iris/mixin/vertices/block_rendering/MixinChunkRebuildTask.java
Patch:
@@ -5,6 +5,7 @@
 import it.unimi.dsi.fastutil.objects.Object2IntMap;
 import net.coderbot.iris.block_rendering.BlockRenderingSettings;
 import net.coderbot.iris.vertices.BlockSensitiveBufferBuilder;
+import net.coderbot.iris.vertices.ExtendedDataHelper;
 import net.minecraft.client.renderer.ChunkBufferBuilderPack;
 import net.minecraft.client.renderer.RenderType;
 import net.minecraft.client.renderer.block.BlockRenderDispatcher;
@@ -62,7 +63,7 @@ private short resolveBlockId(BlockState state) {
 			lastBufferBuilder = ((BlockSensitiveBufferBuilder) bufferBuilder2);
 			// All fluids have a ShadersMod render type of 1, to match behavior of Minecraft 1.7 and earlier.
 			// TODO: We're using createLegacyBlock? That seems like something that Mojang wants to deprecate.
-			lastBufferBuilder.beginBlock(resolveBlockId(fluidState.createLegacyBlock()), (short) 1);
+			lastBufferBuilder.beginBlock(resolveBlockId(fluidState.createLegacyBlock()), ExtendedDataHelper.FLUID_RENDER_TYPE, pos.getX() & 0xF, pos.getY() & 0xF, pos.getZ() & 0xF);
 		}
 	}
 
@@ -79,7 +80,7 @@ private short resolveBlockId(BlockState state) {
 		if (bufferBuilder2 instanceof BlockSensitiveBufferBuilder) {
 			lastBufferBuilder = ((BlockSensitiveBufferBuilder) bufferBuilder2);
 			// TODO: Resolve render types for normal blocks?
-			lastBufferBuilder.beginBlock(resolveBlockId(blockState), (short) -1);
+			lastBufferBuilder.beginBlock(resolveBlockId(blockState), ExtendedDataHelper.BLOCK_RENDER_TYPE, pos.getX() & 0xF, pos.getY() & 0xF, pos.getZ() & 0xF);
 		}
 	}
 

File: src/main/java/net/coderbot/iris/vertices/BlockSensitiveBufferBuilder.java
Patch:
@@ -1,6 +1,7 @@
 package net.coderbot.iris.vertices;
 
 public interface BlockSensitiveBufferBuilder {
-	void beginBlock(short block, short renderType);
+	void beginBlock(short block, short renderType, int localPosX, int localPosY, int localPosZ);
+
 	void endBlock();
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/IrisChunkShaderBindingPoints.java
Patch:
@@ -10,4 +10,5 @@ public class IrisChunkShaderBindingPoints {
     public static final int MID_TEX_COORD = 6;
     public static final int TANGENT = 7;
     public static final int NORMAL = 8;
+    public static final int MID_BLOCK = 9;
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/shader_overrides/IrisChunkProgramOverrides.java
Patch:
@@ -156,6 +156,7 @@ private GlProgram<IrisChunkShaderInterface> createShader(IrisTerrainPass pass, S
                     .bindAttribute("mc_midTexCoord", IrisChunkShaderBindingPoints.MID_TEX_COORD)
                     .bindAttribute("at_tangent", IrisChunkShaderBindingPoints.TANGENT)
                     .bindAttribute("a_Normal", IrisChunkShaderBindingPoints.NORMAL)
+					.bindAttribute("at_midBlock", IrisChunkShaderBindingPoints.MID_BLOCK)
 					.link((shader) -> {
 						// TODO: Better way for this? It's a bit too much casting for me.
 						int handle = ((GlObject) shader).handle();

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/IrisChunkMeshAttributes.java
Patch:
@@ -10,4 +10,5 @@ public class IrisChunkMeshAttributes {
 	public static ChunkMeshAttribute TANGENT;
 	public static ChunkMeshAttribute MID_TEX_COORD;
 	public static ChunkMeshAttribute BLOCK_ID;
+	public static ChunkMeshAttribute MID_BLOCK;
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/terrain_xhfp/XHFPModelVertexType.java
Patch:
@@ -15,8 +15,7 @@
  * Like HFPModelVertexType, but extended to support Iris. The extensions aren't particularly efficient right now.
  */
 public class XHFPModelVertexType implements ChunkVertexType {
-	public static final int STRIDE = 40;
-
+	public static final int STRIDE = 44;
 	public static final GlVertexFormat<ChunkMeshAttribute> VERTEX_FORMAT = GlVertexFormat.builder(ChunkMeshAttribute.class, STRIDE)
 			.addElement(ChunkMeshAttribute.POSITION_ID, 0, GlVertexAttributeFormat.UNSIGNED_SHORT, 4, false)
 			.addElement(ChunkMeshAttribute.COLOR, 8, GlVertexAttributeFormat.UNSIGNED_BYTE, 4, true)
@@ -26,6 +25,7 @@ public class XHFPModelVertexType implements ChunkVertexType {
 			.addElement(IrisChunkMeshAttributes.TANGENT, 28, IrisGlVertexAttributeFormat.BYTE, 4, true)
 			.addElement(IrisChunkMeshAttributes.NORMAL, 32, IrisGlVertexAttributeFormat.BYTE, 3, true)
 			.addElement(IrisChunkMeshAttributes.BLOCK_ID, 36, GlVertexAttributeFormat.UNSIGNED_SHORT, 2, false)
+			.addElement(IrisChunkMeshAttributes.MID_BLOCK, 40, IrisGlVertexAttributeFormat.BYTE, 3, false)
 			.build();
 
 	private static final int POSITION_MAX_VALUE = 65536;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/vertex_format/MixinGlVertexFormatBuilder.java
Patch:
@@ -24,7 +24,8 @@ public class MixinGlVertexFormatBuilder {
 
 		if (value == null) {
 			if (key == IrisChunkMeshAttributes.NORMAL || key == IrisChunkMeshAttributes.TANGENT
-					|| key == IrisChunkMeshAttributes.MID_TEX_COORD || key == IrisChunkMeshAttributes.BLOCK_ID) {
+					|| key == IrisChunkMeshAttributes.MID_TEX_COORD || key == IrisChunkMeshAttributes.BLOCK_ID
+					|| key == IrisChunkMeshAttributes.MID_BLOCK) {
 				// Missing these attributes is acceptable and will be handled properly.
 				return EMPTY;
 			}

File: src/main/java/net/coderbot/iris/mixin/sky/MixinOptions_CloudsOverride.java
Patch:
@@ -21,7 +21,7 @@ public class MixinOptions_CloudsOverride {
 	@Shadow
 	private int renderDistance;
 
-	@Inject(method = "getCloudsType", at = @At("HEAD"))
+	@Inject(method = "getCloudsType", at = @At("HEAD"), cancellable = true)
 	private void iris$overrideCloudsType(CallbackInfoReturnable<CloudStatus> cir) {
 		// Vanilla does not render clouds on low render distances, we have to mirror that check
 		// when injecting at the head.
@@ -35,8 +35,10 @@ public class MixinOptions_CloudsOverride {
 			switch (setting) {
 				case OFF:
 					cir.setReturnValue(CloudStatus.OFF);
+					return;
 				case FAST:
 					cir.setReturnValue(CloudStatus.FAST);
+					return;
 				case FANCY:
 					cir.setReturnValue(CloudStatus.FANCY);
 			}

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPipeline.java
Patch:
@@ -42,6 +42,8 @@ public interface WorldRenderingPipeline {
 	CloudSetting getCloudSetting();
 	boolean shouldRenderUnderwaterOverlay();
 	boolean shouldRenderVignette();
+	boolean shouldRenderSun();
+	boolean shouldRenderMoon();
 	boolean shouldWriteRainAndSnowToDepthBuffer();
 	boolean shouldRenderParticlesBeforeDeferred();
 

File: src/main/java/net/coderbot/iris/pipeline/FixedFunctionWorldRenderingPipeline.java
Patch:
@@ -6,6 +6,7 @@
 import net.coderbot.iris.gbuffer_overrides.matching.SpecialCondition;
 import net.coderbot.iris.gbuffer_overrides.state.RenderTargetStateListener;
 import net.coderbot.iris.mixin.LevelRendererAccessor;
+import net.coderbot.iris.shaderpack.CloudSetting;
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.minecraft.client.Camera;
 import net.minecraft.client.Minecraft;
@@ -132,9 +133,8 @@ public boolean shouldDisableDirectionalShading() {
 	}
 
 	@Override
-	public boolean shouldRenderClouds() {
-		// Keep clouds enabled
-		return true;
+	public CloudSetting getCloudSetting() {
+		return CloudSetting.DEFAULT;
 	}
 
 	@Override

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPipeline.java
Patch:
@@ -4,6 +4,7 @@
 import net.coderbot.iris.gbuffer_overrides.matching.SpecialCondition;
 import net.coderbot.iris.gbuffer_overrides.state.RenderTargetStateListener;
 import net.coderbot.iris.mixin.LevelRendererAccessor;
+import net.coderbot.iris.shaderpack.CloudSetting;
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.minecraft.client.Camera;
 
@@ -38,7 +39,7 @@ public interface WorldRenderingPipeline {
 
 	boolean shouldDisableVanillaEntityShadows();
 	boolean shouldDisableDirectionalShading();
-	boolean shouldRenderClouds();
+	CloudSetting getCloudSetting();
 	boolean shouldRenderUnderwaterOverlay();
 	boolean shouldRenderVignette();
 	boolean shouldWriteRainAndSnowToDepthBuffer();

File: src/main/java/net/coderbot/iris/gl/buffer/ShaderStorageBufferHolder.java
Patch:
@@ -17,8 +17,8 @@ public ShaderStorageBufferHolder(Int2IntArrayMap overrides) {
 		overrides.forEach((index, size) -> {
 			int buffer = GlStateManager._glGenBuffers();
 			GlStateManager._glBindBuffer(GL43C.GL_SHADER_STORAGE_BUFFER, buffer);
-			IrisRenderSystem.bufferData(GL43C.GL_SHADER_STORAGE_BUFFER, size, GL43C.GL_DYNAMIC_DRAW);
-			IrisRenderSystem.clearBufferData(GL43C.GL_SHADER_STORAGE_BUFFER, GL43C.GL_R8, GL43C.GL_RED, GL43C.GL_BYTE, new int[] {0});
+			IrisRenderSystem.bufferStorage(GL43C.GL_SHADER_STORAGE_BUFFER, size, 0);
+			IrisRenderSystem.clearBufferSubData(GL43C.GL_SHADER_STORAGE_BUFFER, GL43C.GL_R8, 0, size, GL43C.GL_RED, GL43C.GL_BYTE, new int[] {0});
 			IrisRenderSystem.bindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, index, buffer);
 			buffers[index] = new ShaderStorageBuffer(buffer, index, size);
 		});

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -32,7 +32,7 @@ public class NewShaderTests {
 	public static ExtendedShader create(String name, ProgramSource source, GlFramebuffer writingToBeforeTranslucent,
 										GlFramebuffer writingToAfterTranslucent, GlFramebuffer baseline, AlphaTest fallbackAlpha,
 										VertexFormat vertexFormat, FrameUpdateNotifier updateNotifier,
-										NewWorldRenderingPipeline parent, FogMode fogMode, boolean isSwizzle,
+										NewWorldRenderingPipeline parent, FogMode fogMode, boolean isIntensity,
 										boolean isFullbright) throws IOException {
 		AlphaTest alpha = source.getDirectives().getAlphaTestOverride().orElse(fallbackAlpha);
 		BlendModeOverride blendModeOverride = source.getDirectives().getBlendModeOverride();
@@ -134,7 +134,7 @@ public static ExtendedShader create(String name, ProgramSource source, GlFramebu
 			//SamplerUniforms.addWorldSamplerUniforms(uniforms);
 			//SamplerUniforms.addDepthSamplerUniforms(uniforms);
 			BuiltinReplacementUniforms.addBuiltinReplacementUniforms(uniforms);
-		}, isSwizzle, isFullbright, parent, inputs);
+		}, isIntensity, parent, inputs);
 	}
 
 	public static FallbackShader createFallback(String name, GlFramebuffer writingToBeforeTranslucent,

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -380,17 +380,17 @@ private ShaderInstance createShader(String name, Optional<ProgramSource> source,
 		}
 
 		return createShader(name, source.get(), key.getAlphaTest(), key.getVertexFormat(), key.getFogMode(),
-				key.isSwizzle(), key.shouldIgnoreLightmap());
+				key.isIntensity(), key.shouldIgnoreLightmap());
 	}
 
 	private ShaderInstance createShader(String name, ProgramSource source, AlphaTest fallbackAlpha,
 										VertexFormat vertexFormat, FogMode fogMode,
-										boolean isSwizzle, boolean isFullbright) throws IOException {
+										boolean isIntensity, boolean isFullbright) throws IOException {
 		GlFramebuffer beforeTranslucent = renderTargets.createGbufferFramebuffer(flippedAfterPrepare, source.getDirectives().getDrawBuffers());
 		GlFramebuffer afterTranslucent = renderTargets.createGbufferFramebuffer(flippedAfterTranslucent, source.getDirectives().getDrawBuffers());
 
 		ExtendedShader extendedShader = NewShaderTests.create(name, source, beforeTranslucent, afterTranslucent,
-				baseline, fallbackAlpha, vertexFormat, updateNotifier, this, fogMode, isSwizzle, isFullbright);
+				baseline, fallbackAlpha, vertexFormat, updateNotifier, this, fogMode, isIntensity, isFullbright);
 
 		loadedShaders.add(extendedShader);
 

File: src/main/java/net/coderbot/iris/mixin/MixinClientLanguage.java
Patch:
@@ -24,8 +24,10 @@
  *
  * <p>We "sideload" the language entries with an override system to avoid having to reload the
  * resource manager on shader pack changes, since reloading the resource manager is very slow.</p>
+ *
+ * Uses a lower priority to inject before Incubus-Core to prevent translations from breaking
  */
-@Mixin(ClientLanguage.class)
+@Mixin(value = ClientLanguage.class, priority = 990)
 public class MixinClientLanguage {
 	private static final String LOAD = "Lnet/minecraft/client/resources/language/ClientLanguage;loadFrom(Lnet/minecraft/server/packs/resources/ResourceManager;Ljava/util/List;)Lnet/minecraft/client/resources/language/ClientLanguage;";
 

File: src/main/java/net/coderbot/iris/gl/shader/ProgramCreator.java
Patch:
@@ -19,6 +19,7 @@ public static int create(String name, GlShader... shaders) {
 		IrisRenderSystem.bindAttributeLocation(program, 11, "mc_Entity");
 		IrisRenderSystem.bindAttributeLocation(program, 12, "mc_midTexCoord");
 		IrisRenderSystem.bindAttributeLocation(program, 13, "at_tangent");
+		IrisRenderSystem.bindAttributeLocation(program, 14, "at_midBlock");
 
 		for (GlShader shader : shaders) {
 			GlStateManager.glAttachShader(program, shader.getHandle());

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -611,6 +611,7 @@ private Pass createPassInner(ProgramBuilder builder, IdMap map, ProgramDirective
 		builder.bindAttributeLocation(11, "mc_Entity");
 		builder.bindAttributeLocation(12, "mc_midTexCoord");
 		builder.bindAttributeLocation(13, "at_tangent");
+		builder.bindAttributeLocation(14, "at_midBlock");
 
 		AlphaTestOverride alphaTestOverride = programDirectives.getAlphaTestOverride().orElse(null);
 

File: src/main/java/net/coderbot/iris/vertices/BlockSensitiveBufferBuilder.java
Patch:
@@ -1,6 +1,7 @@
 package net.coderbot.iris.vertices;
 
 public interface BlockSensitiveBufferBuilder {
-	void beginBlock(short block, short renderType);
+	void beginBlock(short block, short renderType, int localPosX, int localPosY, int localPosZ);
+
 	void endBlock();
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/IrisChunkMeshAttributes.java
Patch:
@@ -10,4 +10,5 @@ public class IrisChunkMeshAttributes {
 	public static ChunkMeshAttribute TANGENT;
 	public static ChunkMeshAttribute MID_TEX_COORD;
 	public static ChunkMeshAttribute BLOCK_ID;
+	public static ChunkMeshAttribute MID_BLOCK;
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/terrain_xhfp/XHFPModelVertexType.java
Patch:
@@ -15,7 +15,7 @@
  * Like HFPModelVertexType, but extended to support Iris. The extensions aren't particularly efficient right now.
  */
 public class XHFPModelVertexType implements ChunkVertexType {
-	public static final int STRIDE = 40;
+	public static final int STRIDE = 44;
 	public static final GlVertexFormat<ChunkMeshAttribute> VERTEX_FORMAT = GlVertexFormat.builder(ChunkMeshAttribute.class, STRIDE)
 			.addElement(ChunkMeshAttribute.POSITION, 0, GlVertexAttributeFormat.UNSIGNED_SHORT, 3, false)
 			.addElement(ChunkMeshAttribute.COLOR, 8, GlVertexAttributeFormat.UNSIGNED_BYTE, 4, true)
@@ -25,6 +25,7 @@ public class XHFPModelVertexType implements ChunkVertexType {
 			.addElement(IrisChunkMeshAttributes.TANGENT, 28, IrisGlVertexAttributeFormat.BYTE, 4, true)
 			.addElement(IrisChunkMeshAttributes.NORMAL, 32, IrisGlVertexAttributeFormat.BYTE, 3, true)
 			.addElement(IrisChunkMeshAttributes.BLOCK_ID, 36, GlVertexAttributeFormat.UNSIGNED_SHORT, 2, false)
+			.addElement(IrisChunkMeshAttributes.MID_BLOCK, 40, IrisGlVertexAttributeFormat.BYTE, 3, false)
 			.build();
 
 	public static final float MODEL_SCALE = (32.0f / 65536.0f);

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/vertex_format/MixinGlVertexFormatBuilder.java
Patch:
@@ -24,7 +24,8 @@ public class MixinGlVertexFormatBuilder {
 
 		if (value == null) {
 			if (key == IrisChunkMeshAttributes.NORMAL || key == IrisChunkMeshAttributes.TANGENT
-					|| key == IrisChunkMeshAttributes.MID_TEX_COORD || key == IrisChunkMeshAttributes.BLOCK_ID) {
+					|| key == IrisChunkMeshAttributes.MID_TEX_COORD || key == IrisChunkMeshAttributes.BLOCK_ID
+					|| key == IrisChunkMeshAttributes.MID_BLOCK) {
 				// Missing these attributes is acceptable and will be handled properly.
 				return EMPTY;
 			}

File: src/main/java/net/coderbot/iris/pipeline/patcher/AttributeShaderTransformer.java
Patch:
@@ -2,7 +2,8 @@
 
 import net.coderbot.iris.gbuffer_overrides.matching.InputAvailability;
 import net.coderbot.iris.gl.shader.ShaderType;
-import net.coderbot.iris.shaderpack.transform.*;
+import net.coderbot.iris.shaderpack.transform.StringTransformations;
+import net.coderbot.iris.shaderpack.transform.Transformations;
 
 public class AttributeShaderTransformer {
 	public static String patch(String source, ShaderType type, boolean hasGeometry, InputAvailability inputs) {

File: src/main/java/net/coderbot/iris/pipeline/TransformPatcher.java
Patch:
@@ -194,7 +194,7 @@ public boolean isActive() {
 		// #region patchSodiumTerrain
 		// see SodiumTerrainPipeline for the original patcher
 		LifecycleUser<Parameters> wrapFTransform = new WrapIdentifier<Parameters>()
-				.wrapTarget("fTransform")
+				.wrapTarget("ftransform")
 				.detectionResult("iris_ftransform")
 				.injectionLocation(InjectionPoint.BEFORE_FUNCTIONS)
 				.injectionExternalDeclaration("vec4 iris_ftransform() { return gl_ModelViewProjectionMatrix * gl_Vertex; }");

File: src/main/java/net/coderbot/iris/gl/blending/AlphaTest.java
Patch:
@@ -14,10 +14,10 @@ public AlphaTest(AlphaTestFunction function, float reference) {
 	}
 
 	public String toExpression(String indentation) {
-		return toExpression("gl_FragData[0].a", indentation);
+		return toExpression("gl_FragData[0].a", "iris_currentAlphaTest", indentation);
 	}
 
-	public String toExpression(String alphaAccessor, String indentation) {
+	public String toExpression(String alphaAccessor, String alphaThreshold, String indentation) {
 		String expr = function.getExpression();
 
 		if (function == AlphaTestFunction.ALWAYS) {
@@ -30,7 +30,7 @@ public String toExpression(String alphaAccessor, String indentation) {
 			return "discard;\n";
 		}
 
-		return indentation + "if (!(" + alphaAccessor + " " + expr + " iris_currentAlphaTest)) {\n" +
+		return indentation + "if (!(" + alphaAccessor + " " + expr + " " + alphaThreshold + ")) {\n" +
 				indentation + "    discard;\n" +
 				indentation + "}\n";
 	}

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -180,6 +180,7 @@ public static FallbackShader createFallback(String name, GlFramebuffer writingTo
 				"        { \"name\": \"FogEnd\", \"type\": \"float\", \"count\": 1, \"values\": [ 1.0 ] },\n" +
 				"        { \"name\": \"FogDensity\", \"type\": \"float\", \"count\": 1, \"values\": [ 1.0 ] },\n" +
 				"        { \"name\": \"FogIsExp2\", \"type\": \"int\", \"count\": 1, \"values\": [ 0 ] },\n" +
+				"        { \"name\": \"AlphaTestValue\", \"type\": \"float\", \"count\": 1, \"values\": [ 0.0 ] },\n" +
 				"        { \"name\": \"LineWidth\", \"type\": \"float\", \"count\": 1, \"values\": [ 1.0 ] },\n" +
 				"        { \"name\": \"ScreenSize\", \"type\": \"float\", \"count\": 2, \"values\": [ 1.0, 1.0 ] },\n" +
 				"        { \"name\": \"FogColor\", \"type\": \"float\", \"count\": 4, \"values\": [ 0.0, 0.0, 0.0, 0.0 ] }\n" +
@@ -197,7 +198,7 @@ public static FallbackShader createFallback(String name, GlFramebuffer writingTo
 		}
 
 		return new FallbackShader(shaderResourceFactory, name, vertexFormat, writingToBeforeTranslucent,
-				writingToAfterTranslucent, blendModeOverride, parent);
+				writingToAfterTranslucent, blendModeOverride, alpha.getReference(), parent);
 	}
 
 	private static class IrisProgramResourceFactory implements ResourceProvider {

File: src/main/java/net/coderbot/iris/pipeline/newshader/fallback/ShaderSynthesizer.java
Patch:
@@ -156,7 +156,7 @@ public static String fsh(ShaderAttributeInputs inputs, FogMode fogMode, AlphaTes
 		shader.append("#version 150 core\n");
 
 		shader.append("out vec4 fragColor;\n");
-		shader.append("uniform float iris_currentAlphaTest;\n");
+		shader.append("uniform float AlphaTestValue;\n");
 		shader.append("in vec4 iris_vertexColor;\n");
 
 		if (inputs.hasTex()) {
@@ -232,7 +232,7 @@ public static String fsh(ShaderAttributeInputs inputs, FogMode fogMode, AlphaTes
 		// void main
 		shader.append("void main() {\n");
 		shader.append(main);
-		shader.append(alphaTest.toExpression("fragColor.a", "    "));
+		shader.append(alphaTest.toExpression("fragColor.a", "AlphaTestValue", "    "));
 		shader.append("}\n");
 
 		return shader.toString();

File: src/main/java/net/coderbot/iris/compat/sodium/SodiumVersionCheck.java
Patch:
@@ -12,7 +12,7 @@ public class SodiumVersionCheck {
 	// of pain. So don't forget!
 	private static final ImmutableList<AllowedSodiumVersion> ALLOWED_SODIUM_VERSIONS = ImmutableList.of(
 			// Dev version
-			AllowedSodiumVersion.exact("0.4.1+rev.f4237a3",
+			AllowedSodiumVersion.exact("0.4.1+rev.9d14ef6",
 					"https://modrinth.com/mod/sodium/version/mc1.19-0.4.1"),
 
 			// For use by ReplayMod

File: src/main/java/net/coderbot/iris/gl/IrisRenderSystem.java
Patch:
@@ -44,7 +44,7 @@ public static void texImage2D(int target, int level, int internalformat, int wid
 	}
 
 	public static void copyTexImage2D(int target, int level, int internalFormat, int x, int y, int width, int height, int border) {
-		RenderSystem.assertThread(RenderSystem::isOnRenderThreadOrInit);
+		RenderSystem.assertOnRenderThreadOrInit();
 		GL32C.glCopyTexImage2D(target, level, internalFormat, x, y, width, height, border);
 	}
 

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -165,7 +165,7 @@ static float getDarknessFactor() {
 			MobEffectInstance darkness = ((LivingEntity) cameraEntity).getEffect(MobEffects.DARKNESS);
 
 			if (darkness != null && darkness.getFactorData().isPresent()) {
-				return darkness.getFactorData().get().getFactor(CapturedRenderingState.INSTANCE.getTickDelta());
+				return darkness.getFactorData().get().getFactor((LivingEntity) cameraEntity, CapturedRenderingState.INSTANCE.getTickDelta());
 			}
 		}
 

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -94,7 +94,6 @@ public void getModDependencies(ModDependencyCollector d) {
 		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-resource-loader-v0", "0.4.10+f09604ce18"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.6+2a2bb57318"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-api-base", "0.4.0+cf39a74318"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
-		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-command-api-v1", "1.1.4+cf39a74318"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 
 		d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-rendering-data-attachment-v1", "0.1.6+cf39a74318"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 		d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-rendering-fluids-v1", "0.2.1+cf39a74318"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);

File: src/main/java/net/coderbot/iris/gui/screen/ShaderPackScreen.java
Patch:
@@ -467,8 +467,8 @@ public void applyChanges() {
 		String previousPackName = Iris.getIrisConfig().getShaderPackName().orElse(null);
 		boolean previousShadersEnabled = Iris.getIrisConfig().areShadersEnabled();
 
-		// Only reload if the pack would be different from before, or shaders were toggled, or options were changed.
-		if (!name.equals(previousPackName) || enabled != previousShadersEnabled || !Iris.getShaderPackOptionQueue().isEmpty()) {
+		// Only reload if the pack would be different from before, or shaders were toggled, or options were changed, or if we're about to reset options.
+		if (!name.equals(previousPackName) || enabled != previousShadersEnabled || !Iris.getShaderPackOptionQueue().isEmpty() || Iris.shouldResetShaderPackOptionsOnNextReload()) {
 			Iris.getIrisConfig().setShaderPackName(name);
 			IrisApi.getInstance().getConfig().setShadersEnabledAndApply(enabled);
 		}

File: src/main/java/net/coderbot/iris/pipeline/FixedFunctionWorldRenderingPipeline.java
Patch:
@@ -19,6 +19,7 @@ public FixedFunctionWorldRenderingPipeline() {
 		BlockRenderingSettings.INSTANCE.setUseSeparateAo(false);
 		BlockRenderingSettings.INSTANCE.setAmbientOcclusionLevel(1.0f);
 		BlockRenderingSettings.INSTANCE.setUseExtendedVertexFormat(false);
+		BlockRenderingSettings.INSTANCE.setBlockTypeIds(null);
 	}
 
 	@Override

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/block_id/ChunkBuildBuffersExt.java
Patch:
@@ -3,6 +3,6 @@
 import net.minecraft.world.level.block.state.BlockState;
 
 public interface ChunkBuildBuffersExt {
-    void iris$setMaterialId(BlockState state, short renderType);
-    void iris$resetMaterialId();
+	void iris$setMaterialId(BlockState state, short renderType);
+	void iris$resetMaterialId();
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/options/OptionImplExtended.java
Patch:
@@ -3,5 +3,5 @@
 import java.util.function.BooleanSupplier;
 
 public interface OptionImplExtended {
-    void iris$dynamicallyEnable(BooleanSupplier enabled);
+	void iris$dynamicallyEnable(BooleanSupplier enabled);
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/shader_overrides/IrisShaderTypes.java
Patch:
@@ -6,5 +6,5 @@
  * Initialized by {@link net.coderbot.iris.compat.sodium.mixin.shader_overrides.MixinShaderType}
  */
 public class IrisShaderTypes {
-    public static ShaderType GEOMETRY;
+	public static ShaderType GEOMETRY;
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/IrisModelVertexFormats.java
Patch:
@@ -3,5 +3,5 @@
 import net.coderbot.iris.compat.sodium.impl.vertex_format.terrain_xhfp.XHFPModelVertexType;
 
 public class IrisModelVertexFormats {
-    public static final XHFPModelVertexType MODEL_VERTEX_XHFP = new XHFPModelVertexType();
+	public static final XHFPModelVertexType MODEL_VERTEX_XHFP = new XHFPModelVertexType();
 }

File: src/main/java/net/coderbot/iris/gl/IrisRenderSystem.java
Patch:
@@ -50,8 +50,8 @@ public static void uniformMatrix4fv(int location, boolean transpose, FloatBuffer
 	}
 
 	public static void copyTexImage2D(int target, int level, int internalFormat, int x, int y, int width, int height, int border) {
-		RenderSystem.assertThread(RenderSystem::isOnRenderThreadOrInit);
-		GL30C.glCopyTexImage2D(target, level, internalFormat, x, y, width, height, border);
+		RenderSystem.assertOnRenderThreadOrInit();
+		GL32C.glCopyTexImage2D(target, level, internalFormat, x, y, width, height, border);
 	}
 
 	public static void uniform1f(int location, float v0) {

File: src/main/java/net/coderbot/iris/rendertarget/RenderTargets.java
Patch:
@@ -69,6 +69,9 @@ public RenderTargets(int width, int height, int depthTexture, int depthBufferVer
 
 		this.noHandDestFb = createFramebufferWritingToMain(new int[] {0});
 		this.noHandDestFb.addDepthAttachment(this.noHand.getTextureId());
+
+		this.translucentDepthDirty = true;
+		this.handDepthDirty = true;
 	}
 
 	public void destroy() {

File: src/main/java/net/coderbot/iris/rendertarget/RenderTargets.java
Patch:
@@ -111,6 +111,7 @@ public void resizeIfNeeded(int newDepthBufferVersion, int newDepthTextureId, int
 		boolean depthFormatChanged = newDepthFormat != currentDepthFormat;
 
 		if (depthFormatChanged) {
+			currentDepthFormat = newDepthFormat;
 			// Might need a new copy strategy
 			copyStrategy = DepthCopyStrategy.fastest(currentDepthFormat.isCombinedStencil());
 		}

File: src/main/java/net/coderbot/iris/gui/screen/ShaderPackScreen.java
Patch:
@@ -465,8 +465,8 @@ public void applyChanges() {
 		String previousPackName = Iris.getIrisConfig().getShaderPackName().orElse(null);
 		boolean previousShadersEnabled = Iris.getIrisConfig().areShadersEnabled();
 
-		// Only reload if the pack would be different from before, or shaders were toggled, or options were changed.
-		if (!name.equals(previousPackName) || enabled != previousShadersEnabled || !Iris.getShaderPackOptionQueue().isEmpty()) {
+		// Only reload if the pack would be different from before, or shaders were toggled, or options were changed, or if we're about to reset options.
+		if (!name.equals(previousPackName) || enabled != previousShadersEnabled || !Iris.getShaderPackOptionQueue().isEmpty() || Iris.shouldResetShaderPackOptionsOnNextReload()) {
 			Iris.getIrisConfig().setShaderPackName(name);
 			IrisApi.getInstance().getConfig().setShadersEnabledAndApply(enabled);
 		}

File: src/main/java/net/coderbot/iris/uniforms/IrisExclusiveUniforms.java
Patch:
@@ -19,9 +19,9 @@ private static float getThunderStrength() {
 	private static int getPerspective() {
 		// If camera type is not explicitly third-person, assume it's first-person.
 		switch (Minecraft.getInstance().options.getCameraType()) {
-			case FIRST_PERSON: return 0;
-			case THIRD_PERSON_BACK: return 0;
-			case THIRD_PERSON_FRONT: return 0;
+			case THIRD_PERSON_BACK:
+			case THIRD_PERSON_FRONT:
+				return 1;
 			default: return 0;
 		}
 	}

File: src/main/java/net/coderbot/iris/gl/state/StateUpdateNotifiers.java
Patch:
@@ -13,6 +13,6 @@ public class StateUpdateNotifiers {
 	public static ValueUpdateNotifier fogEndNotifier;
 	public static ValueUpdateNotifier fogDensityNotifier;
 	public static ValueUpdateNotifier blendFuncNotifier;
-	public static ValueUpdateNotifier atlasTextureNotifier;
+	public static ValueUpdateNotifier bindTextureNotifier;
 	public static ValueUpdateNotifier phaseChangeNotifier;
 }

File: src/main/java/net/coderbot/iris/mixin/MixinMinecraft_Keybinds.java
Patch:
@@ -2,9 +2,7 @@
 
 import net.coderbot.iris.Iris;
 import net.minecraft.client.Minecraft;
-import net.minecraft.client.multiplayer.ClientLevel;
 import net.minecraft.util.profiling.ProfilerFiller;
-import org.jetbrains.annotations.Nullable;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.injection.At;
@@ -19,7 +17,7 @@
  * alone shaves over 60kB off the released JAR size.</p>
  */
 @Mixin(Minecraft.class)
-public class MixinMinecraft {
+public class MixinMinecraft_Keybinds {
 	@Shadow
 	private ProfilerFiller profiler;
 

File: src/main/java/net/coderbot/iris/mixin/MixinWindow.java
Patch:
@@ -15,9 +15,9 @@
 public class MixinWindow {
 	@Inject(method = "<init>", at = @At(value = "INVOKE", target = "Lorg/lwjgl/glfw/GLFW;glfwDefaultWindowHints()V", shift = At.Shift.AFTER))
 	private void iris$enableDebugContext(WindowEventHandler arg, ScreenManager arg2, DisplayData arg3, String string, String string2, CallbackInfo ci) {
-		if (Iris.getIrisConfig().isDebugEnabled()) {
+		if (Iris.getIrisConfig().areDebugOptionsEnabled()) {
 			GLFW.glfwWindowHint(GLFW.GLFW_OPENGL_DEBUG_CONTEXT, GLFW.GLFW_TRUE);
-			Iris.logger.warn("OpenGL debug context activated.");
+			Iris.logger.info("OpenGL debug context activated.");
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/rendertype/MixinRenderType_FixEyesTranslucency.java
Patch:
@@ -8,7 +8,7 @@
 import org.spongepowered.asm.mixin.injection.Redirect;
 
 @Mixin(RenderType.class)
-public class MixinFixEyesTranslucency {
+public class MixinRenderType_FixEyesTranslucency {
 	// Minecraft interprets an alpha value of zero as a signal to disable the alpha test.
 	// However, we actually want to reject all nonzero alpha values.
 	//

File: src/main/java/net/coderbot/iris/mixin/vertices/MixinVertexBuffer.java
Patch:
@@ -3,8 +3,8 @@
 import com.mojang.blaze3d.vertex.DefaultVertexFormat;
 import com.mojang.blaze3d.vertex.VertexBuffer;
 import com.mojang.blaze3d.vertex.VertexFormat;
+import net.coderbot.iris.block_rendering.BlockRenderingSettings;
 import net.coderbot.iris.vertices.IrisVertexFormats;
-import net.irisshaders.iris.api.v0.IrisApi;
 import org.spongepowered.asm.mixin.Final;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Mutable;
@@ -22,14 +22,14 @@ public class MixinVertexBuffer {
 
 	@Inject(method = "<init>", at = @At("RETURN"))
 	private void iris$onInit(VertexFormat format, CallbackInfo ci) {
-		if (IrisApi.getInstance().isShaderPackInUse()) {
+		if (BlockRenderingSettings.INSTANCE.shouldUseExtendedVertexFormat()) {
 			// We have to fix the vertex format here, or else the vertex count will be calculated wrongly and too many
 			// vertices will be drawn.
 			//
 			// Needless to say, that is not good if you don't like access violation crashes!
 			if (format == DefaultVertexFormat.BLOCK) {
 				this.format = IrisVertexFormats.TERRAIN;
-			} else if (format == DefaultVertexFormat.NEW_ENTITY) {
+			} else if (format == DefaultVertexFormat.NEW_ENTITY || format == DefaultVertexFormat.POSITION_COLOR_TEX_LIGHTMAP) {
 				this.format = IrisVertexFormats.ENTITY;
 			}
 		}

File: src/main/java/net/coderbot/iris/pipeline/ClearPass.java
Patch:
@@ -13,10 +13,10 @@ public class ClearPass {
 	private final GlFramebuffer framebuffer;
 	private final int clearFlags;
 
-	public ClearPass(Vector4f color, GlFramebuffer framebuffer, boolean clearDepth) {
+	public ClearPass(Vector4f color, GlFramebuffer framebuffer) {
 		this.color = color;
 		this.framebuffer = framebuffer;
-		this.clearFlags = GL21C.GL_COLOR_BUFFER_BIT | (clearDepth ? GL21C.GL_DEPTH_BUFFER_BIT : 0);
+		this.clearFlags = GL21C.GL_COLOR_BUFFER_BIT;
 	}
 
 	public void execute(Vector4f defaultClearColor) {

File: src/main/java/net/coderbot/iris/pipeline/ClearPassCreator.java
Patch:
@@ -61,12 +61,12 @@ public static ImmutableList<ClearPass> createClearPasses(RenderTargets renderTar
 					startIndex++;
 				}
 
-				// only clear depth if this is the first clear pass
+				// No need to clear the depth buffer, since we're using Minecraft's depth buffer.
 				clearPasses.add(new ClearPass(clearColor,
-						renderTargets.createFramebufferWritingToAlt(clearBuffers), clearPasses.isEmpty()));
+						renderTargets.createFramebufferWritingToAlt(clearBuffers)));
 
 				clearPasses.add(new ClearPass(clearColor,
-						renderTargets.createFramebufferWritingToMain(clearBuffers), false));
+						renderTargets.createFramebufferWritingToMain(clearBuffers)));
 			}
 		});
 

File: src/main/java/net/coderbot/iris/shaderpack/LegacyIdMap.java
Patch:
@@ -72,6 +72,8 @@ public static void addLegacyValues(Int2ObjectMap<List<BlockEntry>> blockIdMap) {
 
 		// Lily pad
 		add(blockIdMap, 111, block("lily_pad"));
+
+		// TODO: 76 -> redstone_torch (on)
 	}
 
 	private static BlockEntry block(String name) {

File: src/main/java/net/coderbot/iris/shadows/ShadowRenderTargets.java
Patch:
@@ -3,6 +3,7 @@
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.gl.framebuffer.GlFramebuffer;
+import net.coderbot.iris.gl.texture.DepthBufferFormat;
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
 import net.coderbot.iris.gl.texture.PixelFormat;
 import net.coderbot.iris.gl.texture.PixelType;
@@ -40,8 +41,8 @@ public ShadowRenderTargets(int resolution, InternalTextureFormat[] formats) {
 		targets = new int[formats.length];
 		GlStateManager._genTextures(targets);
 
-		depthTexture = new DepthTexture(resolution, resolution);
-		noTranslucents = new DepthTexture(resolution, resolution);
+		depthTexture = new DepthTexture(resolution, resolution, DepthBufferFormat.DEPTH);
+		noTranslucents = new DepthTexture(resolution, resolution, DepthBufferFormat.DEPTH);
 
 		this.framebuffer = new GlFramebuffer();
 

File: src/main/java/net/coderbot/iris/uniforms/CapturedRenderingState.java
Patch:
@@ -8,6 +8,8 @@
 public class CapturedRenderingState {
 	public static final CapturedRenderingState INSTANCE = new CapturedRenderingState();
 
+	private static final Vector3d ZERO_VECTOR_3d = new Vector3d();
+
 	private Matrix4f gbufferModelView;
 	private Matrix4f gbufferProjection;
 	private Vector3d fogColor;
@@ -39,7 +41,7 @@ public void setGbufferProjection(Matrix4f gbufferProjection) {
 
 	public Vector3d getFogColor() {
 		if (Minecraft.getInstance().level == null || fogColor == null) {
-			return new Vector3d();
+			return ZERO_VECTOR_3d;
 		}
 
 		return fogColor;

File: src/main/java/net/coderbot/iris/uniforms/FogUniforms.java
Patch:
@@ -3,8 +3,8 @@
 import com.mojang.blaze3d.platform.GlStateManager;
 import net.coderbot.iris.gl.state.StateUpdateNotifiers;
 import net.coderbot.iris.gl.uniform.DynamicUniformHolder;
+import net.coderbot.iris.mixin.GlStateManagerAccessor;
 import net.coderbot.iris.mixin.statelisteners.BooleanStateAccessor;
-import net.coderbot.iris.mixin.statelisteners.GlStateManagerAccessor;
 
 public class FogUniforms {
 	private FogUniforms() {

File: src/main/java/net/coderbot/iris/uniforms/WorldTimeUniforms.java
Patch:
@@ -25,7 +25,7 @@ public static void addWorldTimeUniforms(UniformHolder uniforms) {
 			.uniform1i(PER_TICK, "moonPhase", () -> getWorld().getMoonPhase());
 	}
 
-	private static int getWorldDayTime() {
+	static int getWorldDayTime() {
 		long timeOfDay = getWorld().getDayTime();
 
 		long dayTime = ((DimensionTypeAccessor) getWorld().dimensionType()).getFixedTime()

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/block_id/ChunkBuildBuffersExt.java
Patch:
@@ -3,6 +3,6 @@
 import net.minecraft.world.level.block.state.BlockState;
 
 public interface ChunkBuildBuffersExt {
-    void iris$setMaterialId(BlockState state, short renderType);
-    void iris$resetMaterialId();
+	void iris$setMaterialId(BlockState state, short renderType);
+	void iris$resetMaterialId();
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/block_id/MaterialIdAwareVertexWriter.java
Patch:
@@ -3,5 +3,5 @@
 import net.coderbot.iris.block_rendering.MaterialIdHolder;
 
 public interface MaterialIdAwareVertexWriter {
-    void iris$setIdHolder(MaterialIdHolder holder);
+	void iris$setIdHolder(MaterialIdHolder holder);
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/options/OptionImplExtended.java
Patch:
@@ -3,5 +3,5 @@
 import java.util.function.BooleanSupplier;
 
 public interface OptionImplExtended {
-    void iris$dynamicallyEnable(BooleanSupplier enabled);
+	void iris$dynamicallyEnable(BooleanSupplier enabled);
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/shader_overrides/ChunkRenderBackendExt.java
Patch:
@@ -4,5 +4,5 @@
 import me.jellysquid.mods.sodium.client.render.chunk.passes.BlockRenderPass;
 
 public interface ChunkRenderBackendExt {
-    void iris$begin(PoseStack poseStack, BlockRenderPass pass);
+	void iris$begin(PoseStack poseStack, BlockRenderPass pass);
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/shader_overrides/IrisShaderTypes.java
Patch:
@@ -6,5 +6,5 @@
  * Initialized by {@link net.coderbot.iris.compat.sodium.mixin.shader_overrides.MixinShaderType}
  */
 public class IrisShaderTypes {
-    public static ShaderType GEOMETRY;
+	public static ShaderType GEOMETRY;
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/shadow_map/SwappableChunkRenderManager.java
Patch:
@@ -1,5 +1,5 @@
 package net.coderbot.iris.compat.sodium.impl.shadow_map;
 
 public interface SwappableChunkRenderManager {
-    void iris$swapVisibilityState();
+	void iris$swapVisibilityState();
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/IrisGlVertexAttributeFormat.java
Patch:
@@ -5,6 +5,6 @@
 import org.lwjgl.opengl.GL20C;
 
 public class IrisGlVertexAttributeFormat {
-    public static final GlVertexAttributeFormat BYTE =
-            GlVertexAttributeFormatAccessor.createGlVertexAttributeFormat(GL20C.GL_BYTE, 1);
+	public static final GlVertexAttributeFormat BYTE =
+			GlVertexAttributeFormatAccessor.createGlVertexAttributeFormat(GL20C.GL_BYTE, 1);
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/IrisModelVertexFormats.java
Patch:
@@ -3,5 +3,5 @@
 import net.coderbot.iris.compat.sodium.impl.vertex_format.terrain_xhfp.XHFPModelVertexType;
 
 public class IrisModelVertexFormats {
-    public static final XHFPModelVertexType MODEL_VERTEX_XHFP = new XHFPModelVertexType();
+	public static final XHFPModelVertexType MODEL_VERTEX_XHFP = new XHFPModelVertexType();
 }

File: src/test/java/net/coderbot/iris/test/shaderpack/IdMapTest.java
Patch:
@@ -18,7 +18,7 @@
 public class IdMapTest {
 	private static final Map<NamespacedId, BlockRenderType> EXPECTED_LAYERS;
 	private static final Int2ObjectMap<List<BlockEntry>> EXPECTED_BLOCKS;
-	
+
 	static {
 		EXPECTED_LAYERS = new HashMap<>();
 
@@ -41,14 +41,14 @@ public class IdMapTest {
 				new BlockEntry(new NamespacedId("minecraft", "blue_stained_glass"), new HashMap<>()),
 				new BlockEntry(new NamespacedId("minecraft", "white_stained_glass"), new HashMap<>())));
 	}
-	
+
 	@Test
 	void testLoadIdMaps() {
 		ShaderPack shaderPack;
 
 		// ensure that we can actually load the shader pack
 		try {
-			shaderPack = new ShaderPack(IrisTests.getTestShaderPackPath("id_maps"));
+			shaderPack = new ShaderPack(IrisTests.getTestShaderPackPath("id_maps"), IrisTests.TEST_ENVIRONMENT_DEFINES);
 		} catch (Exception e) {
 			Assertions.fail("Couldn't load test shader pack id_maps", e);
 			return;

File: src/test/java/net/coderbot/iris/test/shaderpack/LanguageMapTest.java
Patch:
@@ -15,7 +15,7 @@ void testLoadLanguages() {
 
 		// ensure that we can actually load the shader pack
 		try {
-			shaderPack = new ShaderPack(IrisTests.getTestShaderPackPath("language_maps"));
+			shaderPack = new ShaderPack(IrisTests.getTestShaderPackPath("language_maps"), IrisTests.TEST_ENVIRONMENT_DEFINES);
 		} catch (Exception e) {
 			Assertions.fail("Couldn't load test shader pack language_maps", e);
 			return;

File: src/test/java/net/coderbot/iris/test/shaderpack/OptionApplyTest.java
Patch:
@@ -16,14 +16,13 @@
 import java.util.Map;
 
 public class OptionApplyTest {
-	//@Test
-	// TODO: Re-enable this once we can load shader packs in tests without referencing OpenGL / LWJGL / Minecraft.
+	@Test
 	void testOptions() {
 		ShaderPack shaderPack;
 
 		// ensure that we can actually load the shader pack
 		try {
-			shaderPack = new ShaderPack(IrisTests.getTestShaderPackPath("options"));
+			shaderPack = new ShaderPack(IrisTests.getTestShaderPackPath("options"), IrisTests.TEST_ENVIRONMENT_DEFINES);
 		} catch (Exception e) {
 			Assertions.fail("Couldn't load test shader pack options", e);
 			return;

File: src/main/java/net/coderbot/iris/pipeline/FixedFunctionWorldRenderingPipeline.java
Patch:
@@ -19,6 +19,7 @@ public FixedFunctionWorldRenderingPipeline() {
 		BlockRenderingSettings.INSTANCE.setUseSeparateAo(false);
 		BlockRenderingSettings.INSTANCE.setAmbientOcclusionLevel(1.0f);
 		BlockRenderingSettings.INSTANCE.setUseExtendedVertexFormat(false);
+		BlockRenderingSettings.INSTANCE.setBlockTypeIds(null);
 	}
 
 	@Override

File: src/main/java/net/coderbot/iris/gl/IrisRenderSystem.java
Patch:
@@ -51,7 +51,7 @@ public static void uniformMatrix4fv(int location, boolean transpose, FloatBuffer
 
 	public static void copyTexImage2D(int target, int level, int internalFormat, int x, int y, int width, int height, int border) {
 		RenderSystem.assertThread(RenderSystem::isOnRenderThreadOrInit);
-		GL32C.glCopyTexImage2D(target, level, internalFormat, x, y, width, height, border);
+		GL30C.glCopyTexImage2D(target, level, internalFormat, x, y, width, height, border);
 	}
 
 	public static void uniform1f(int location, float v0) {

File: src/main/java/net/coderbot/iris/pipeline/TransformPatcher.java
Patch:
@@ -16,7 +16,7 @@
 import io.github.douira.glsl_transformer.core.target.*;
 import io.github.douira.glsl_transformer.print.filter.*;
 import io.github.douira.glsl_transformer.transform.*;
-import io.github.douira.glsl_transformer.transform.TransformationPhase.InjectionPoint;
+import io.github.douira.glsl_transformer.transform.InjectionPoint;
 import io.github.douira.glsl_transformer.tree.*;
 import net.coderbot.iris.gl.blending.AlphaTest;
 import net.coderbot.iris.gl.shader.ShaderType;

File: src/main/java/net/coderbot/iris/pipeline/TransformPatcher.java
Patch:
@@ -410,6 +410,9 @@ public boolean isActive() {
 					}
 				});
 
+				chainConcurrentDependent(
+						RunPhase.withInjectExternalDeclarations(InjectionPoint.BEFORE_FUNCTIONS, "attribute vec2 a_LightCoord;"));
+
 				chainConcurrentDependent(new SearchTerminals<Parameters>()
 						.addTarget(new ParsedReplaceTargetImpl<>("gl_MultiTexCoord1",
 								texCoordFallbackReplacement, GLSLParser::expression))

File: src/main/java/net/coderbot/iris/gl/blending/AlphaTest.java
Patch:
@@ -14,10 +14,10 @@ public AlphaTest(AlphaTestFunction function, float reference) {
 	}
 
 	public String toExpression(String indentation) {
-		return toExpression("gl_FragData[0].a", indentation);
+		return toExpression("gl_FragData[0].a", "iris_currentAlphaTest", indentation);
 	}
 
-	public String toExpression(String alphaAccessor, String indentation) {
+	public String toExpression(String alphaAccessor, String alphaThreshold, String indentation) {
 		String expr = function.getExpression();
 
 		if (function == AlphaTestFunction.ALWAYS) {
@@ -30,7 +30,7 @@ public String toExpression(String alphaAccessor, String indentation) {
 			return "discard;\n";
 		}
 
-		return indentation + "if (!(" + alphaAccessor + " " + expr + " iris_currentAlphaTest)) {\n" +
+		return indentation + "if (!(" + alphaAccessor + " " + expr + " " + alphaThreshold + ")) {\n" +
 				indentation + "    discard;\n" +
 				indentation + "}\n";
 	}

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -180,6 +180,7 @@ public static FallbackShader createFallback(String name, GlFramebuffer writingTo
 				"        { \"name\": \"FogEnd\", \"type\": \"float\", \"count\": 1, \"values\": [ 1.0 ] },\n" +
 				"        { \"name\": \"FogDensity\", \"type\": \"float\", \"count\": 1, \"values\": [ 1.0 ] },\n" +
 				"        { \"name\": \"FogIsExp2\", \"type\": \"int\", \"count\": 1, \"values\": [ 0 ] },\n" +
+				"        { \"name\": \"AlphaTestValue\", \"type\": \"float\", \"count\": 1, \"values\": [ 0.0 ] },\n" +
 				"        { \"name\": \"LineWidth\", \"type\": \"float\", \"count\": 1, \"values\": [ 1.0 ] },\n" +
 				"        { \"name\": \"ScreenSize\", \"type\": \"float\", \"count\": 2, \"values\": [ 1.0, 1.0 ] },\n" +
 				"        { \"name\": \"FogColor\", \"type\": \"float\", \"count\": 4, \"values\": [ 0.0, 0.0, 0.0, 0.0 ] }\n" +
@@ -197,7 +198,7 @@ public static FallbackShader createFallback(String name, GlFramebuffer writingTo
 		}
 
 		return new FallbackShader(shaderResourceFactory, name, vertexFormat, writingToBeforeTranslucent,
-				writingToAfterTranslucent, blendModeOverride, parent);
+				writingToAfterTranslucent, blendModeOverride, alpha.getReference(), parent);
 	}
 
 	private static class IrisProgramResourceFactory implements ResourceProvider {

File: src/main/java/net/coderbot/iris/pipeline/newshader/fallback/ShaderSynthesizer.java
Patch:
@@ -156,7 +156,7 @@ public static String fsh(ShaderAttributeInputs inputs, FogMode fogMode, AlphaTes
 		shader.append("#version 150 core\n");
 
 		shader.append("out vec4 fragColor;\n");
-		shader.append("uniform float iris_currentAlphaTest;\n");
+		shader.append("uniform float AlphaTestValue;\n");
 		shader.append("in vec4 iris_vertexColor;\n");
 
 		if (inputs.hasTex()) {
@@ -232,7 +232,7 @@ public static String fsh(ShaderAttributeInputs inputs, FogMode fogMode, AlphaTes
 		// void main
 		shader.append("void main() {\n");
 		shader.append(main);
-		shader.append(alphaTest.toExpression("fragColor.a", "    "));
+		shader.append(alphaTest.toExpression("fragColor.a", "AlphaTestValue", "    "));
 		shader.append("}\n");
 
 		return shader.toString();

File: src/main/java/net/coderbot/iris/mixin/MixinWindow.java
Patch:
@@ -15,7 +15,7 @@
 public class MixinWindow {
 	@Inject(method = "<init>", at = @At(value = "INVOKE", target = "Lorg/lwjgl/glfw/GLFW;glfwDefaultWindowHints()V", shift = At.Shift.AFTER))
 	private void iris$enableDebugContext(WindowEventHandler arg, ScreenManager arg2, DisplayData arg3, String string, String string2, CallbackInfo ci) {
-		if (Iris.getIrisConfig().isDebugEnabled()) {
+		if (Iris.getIrisConfig().areDebugOptionsEnabled()) {
 			GLFW.glfwWindowHint(GLFW.GLFW_OPENGL_DEBUG_CONTEXT, GLFW.GLFW_TRUE);
 			Iris.logger.info("OpenGL debug context activated.");
 		}

File: src/main/java/net/coderbot/iris/mixin/rendertype/MixinRenderType_FixEyesTranslucency.java
Patch:
@@ -8,7 +8,7 @@
 import org.spongepowered.asm.mixin.injection.Redirect;
 
 @Mixin(RenderType.class)
-public class MixinFixEyesTranslucency {
+public class MixinRenderType_FixEyesTranslucency {
 	// Minecraft interprets an alpha value of zero as a signal to disable the alpha test.
 	// However, we actually want to reject all nonzero alpha values.
 	//

File: src/main/java/net/coderbot/iris/mixin/texture/MixinAbstractTexture.java
Patch:
@@ -14,8 +14,9 @@ public class MixinAbstractTexture {
 	@Shadow
 	protected int id;
 
+	// Inject after the newly-generated texture ID has been stored into the id field
 	@Inject(method = "getId()I", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/platform/TextureUtil;generateTextureId()I", shift = Shift.BY, by = 2))
-	private void iris$onGenerateId(CallbackInfoReturnable<Integer> cir) {
+	private void iris$afterGenerateId(CallbackInfoReturnable<Integer> cir) {
 		TextureTracker.INSTANCE.trackTexture(id, (AbstractTexture) (Object) this);
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/vertices/MixinVertexBuffer.java
Patch:
@@ -3,8 +3,8 @@
 import com.mojang.blaze3d.vertex.DefaultVertexFormat;
 import com.mojang.blaze3d.vertex.VertexBuffer;
 import com.mojang.blaze3d.vertex.VertexFormat;
+import net.coderbot.iris.block_rendering.BlockRenderingSettings;
 import net.coderbot.iris.vertices.IrisVertexFormats;
-import net.irisshaders.iris.api.v0.IrisApi;
 import org.spongepowered.asm.mixin.Final;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Mutable;
@@ -22,14 +22,14 @@ public class MixinVertexBuffer {
 
 	@Inject(method = "<init>", at = @At("RETURN"))
 	private void iris$onInit(VertexFormat format, CallbackInfo ci) {
-		if (IrisApi.getInstance().isShaderPackInUse()) {
+		if (BlockRenderingSettings.INSTANCE.shouldUseExtendedVertexFormat()) {
 			// We have to fix the vertex format here, or else the vertex count will be calculated wrongly and too many
 			// vertices will be drawn.
 			//
 			// Needless to say, that is not good if you don't like access violation crashes!
 			if (format == DefaultVertexFormat.BLOCK) {
 				this.format = IrisVertexFormats.TERRAIN;
-			} else if (format == DefaultVertexFormat.NEW_ENTITY) {
+			} else if (format == DefaultVertexFormat.NEW_ENTITY || format == DefaultVertexFormat.POSITION_COLOR_TEX_LIGHTMAP) {
 				this.format = IrisVertexFormats.ENTITY;
 			}
 		}

File: src/main/java/net/coderbot/iris/shadows/ShadowRenderTargets.java
Patch:
@@ -3,10 +3,10 @@
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.gl.framebuffer.GlFramebuffer;
+import net.coderbot.iris.gl.texture.DepthBufferFormat;
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
 import net.coderbot.iris.gl.texture.PixelFormat;
 import net.coderbot.iris.gl.texture.PixelType;
-import net.coderbot.iris.gl.texture.DepthBufferFormat;
 import net.coderbot.iris.rendertarget.DepthTexture;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL13C;

File: src/main/java/net/coderbot/iris/uniforms/HardcodedCustomUniforms.java
Patch:
@@ -35,7 +35,7 @@ public static void addHardcodedCustomUniforms(UniformHolder holder, FrameUpdateN
 		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "isDry", new SmoothedFloat(20, 10, () -> getRawPrecipitation() == 0 ? 1 : 0, updateNotifier));
 		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "isRainy", new SmoothedFloat(20, 10, () -> getRawPrecipitation() == 1 ? 1 : 0, updateNotifier));
 		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "isSnowy", new SmoothedFloat(20, 10, () -> getRawPrecipitation() == 2 ? 1 : 0, updateNotifier));
-		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "isEyeInCave", CommonUniforms.isEyeInWater() == 0 ? eyeInCave : () -> 0);
+		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "isEyeInCave", () -> CommonUniforms.isEyeInWater() == 0 ? eyeInCave.getAsFloat() : 0);
 		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "velocity", () -> getVelocity(tracker));
 		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "starter", getStarter(tracker, updateNotifier));
 		// The following uniforms are Project Reimagined specific.

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/shader_overrides/MixinChunkRenderShaderBackend.java
Patch:
@@ -71,6 +71,7 @@ private void begin(PoseStack poseStack) {
 
         this.override = irisChunkProgramOverrides.getProgramOverride(device, pass);
 
+		Iris.getPipelineManager().getPipeline().ifPresent(WorldRenderingPipeline::beginSodiumTerrainRendering);
         begin(poseStack);
     }
 
@@ -90,6 +91,7 @@ private void begin(PoseStack poseStack) {
     @Inject(method = "end", at = @At("RETURN"))
     private void iris$onEnd(PoseStack poseStack, CallbackInfo ci) {
         ProgramUniforms.clearActiveUniforms();
+		Iris.getPipelineManager().getPipeline().ifPresent(WorldRenderingPipeline::endSodiumTerrainRendering);
     }
 
     @Inject(method = "delete", at = @At("HEAD"), remap = false)

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/vertex_format/MixinChunkOneshotGraphicsState.java
Patch:
@@ -5,7 +5,7 @@
 import me.jellysquid.mods.sodium.client.gl.buffer.VertexData;
 import me.jellysquid.mods.sodium.client.render.chunk.backends.oneshot.ChunkOneshotGraphicsState;
 import me.jellysquid.mods.sodium.client.render.chunk.format.ChunkMeshAttribute;
-import net.coderbot.iris.Iris;
+import net.coderbot.iris.block_rendering.BlockRenderingSettings;
 import net.coderbot.iris.compat.sodium.impl.IrisChunkShaderBindingPoints;
 import net.coderbot.iris.compat.sodium.impl.vertex_format.IrisChunkMeshAttributes;
 import org.apache.commons.lang3.ArrayUtils;
@@ -43,8 +43,7 @@ public abstract class MixinChunkOneshotGraphicsState {
                     remap = false,
                     ordinal = 0))
     private GlVertexAttributeBinding[] iris$addAdditionalBindings(GlVertexAttributeBinding[] base) {
-
-        return Iris.isPackActive() ? ArrayUtils.addAll(base,
+        return BlockRenderingSettings.INSTANCE.shouldUseExtendedVertexFormat() ? ArrayUtils.addAll(base,
                 new GlVertexAttributeBinding(IrisChunkShaderBindingPoints.BLOCK_ID,
                         vertexFormat.getAttribute(IrisChunkMeshAttributes.BLOCK_ID)),
                 new GlVertexAttributeBinding(IrisChunkShaderBindingPoints.MID_TEX_COORD,

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/vertex_format/MixinMultidrawChunkRenderBackend.java
Patch:
@@ -5,7 +5,7 @@
 import me.jellysquid.mods.sodium.client.render.chunk.backends.multidraw.MultidrawChunkRenderBackend;
 import me.jellysquid.mods.sodium.client.render.chunk.backends.multidraw.MultidrawGraphicsState;
 import me.jellysquid.mods.sodium.client.render.chunk.shader.ChunkRenderShaderBackend;
-import net.coderbot.iris.Iris;
+import net.coderbot.iris.block_rendering.BlockRenderingSettings;
 import net.coderbot.iris.compat.sodium.impl.IrisChunkShaderBindingPoints;
 import net.coderbot.iris.compat.sodium.impl.vertex_format.IrisChunkMeshAttributes;
 import org.apache.commons.lang3.ArrayUtils;
@@ -30,7 +30,7 @@ public MixinMultidrawChunkRenderBackend(ChunkVertexType vertexType) {
                     remap = false,
                     ordinal = 0))
     private GlVertexAttributeBinding[] iris$addAdditionalBindings(GlVertexAttributeBinding[] base) {
-        return Iris.isPackActive() ? ArrayUtils.addAll(base,
+        return BlockRenderingSettings.INSTANCE.shouldUseExtendedVertexFormat() ? ArrayUtils.addAll(base,
                 new GlVertexAttributeBinding(IrisChunkShaderBindingPoints.BLOCK_ID,
                         vertexFormat.getAttribute(IrisChunkMeshAttributes.BLOCK_ID)),
                 new GlVertexAttributeBinding(IrisChunkShaderBindingPoints.MID_TEX_COORD,

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/vertex_format/MixinSodiumWorldRenderer.java
Patch:
@@ -2,7 +2,7 @@
 
 import me.jellysquid.mods.sodium.client.model.vertex.type.ChunkVertexType;
 import me.jellysquid.mods.sodium.client.render.SodiumWorldRenderer;
-import net.coderbot.iris.Iris;
+import net.coderbot.iris.block_rendering.BlockRenderingSettings;
 import net.coderbot.iris.compat.sodium.impl.vertex_format.IrisModelVertexFormats;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
@@ -21,6 +21,7 @@ public class MixinSodiumWorldRenderer {
                                 "Lme/jellysquid/mods/sodium/client/model/vertex/type/ChunkVertexType;" +
                             ")Lme/jellysquid/mods/sodium/client/render/chunk/ChunkRenderBackend;"))
     private ChunkVertexType iris$overrideVertexType(ChunkVertexType vertexType) {
-        return Iris.isPackActive() ? IrisModelVertexFormats.MODEL_VERTEX_XHFP : vertexType;
+        return BlockRenderingSettings.INSTANCE.shouldUseExtendedVertexFormat()
+			? IrisModelVertexFormats.MODEL_VERTEX_XHFP : vertexType;
     }
 }

File: src/main/java/net/coderbot/iris/postprocess/FinalPassRenderer.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.mojang.blaze3d.pipeline.MainTarget;
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
 import it.unimi.dsi.fastutil.ints.IntList;

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -938,7 +938,7 @@ public void beginLevelRendering() {
 		// A lot of dimension mods touch sky rendering, FabricSkyboxes injects at HEAD and cancels, etc.
 		DimensionSpecialEffects.SkyType skyType = Minecraft.getInstance().level.effects().skyType();
 
-		if (skyType != DimensionSpecialEffects.SkyType.NONE) {
+		if (skyType == DimensionSpecialEffects.SkyType.NORMAL) {
 			RenderSystem.disableTexture();
 			RenderSystem.depthMask(false);
 

File: src/main/java/net/coderbot/iris/pipeline/TransformPatcher.java
Patch:
@@ -14,7 +14,7 @@
 import io.github.douira.glsl_transformer.core.target.*;
 import io.github.douira.glsl_transformer.print.filter.*;
 import io.github.douira.glsl_transformer.transform.*;
-import io.github.douira.glsl_transformer.tree.*;
+import io.github.douira.glsl_transformer.tree.ExtendedContext;
 import io.github.douira.glsl_transformer.util.CompatUtil;
 import net.coderbot.iris.IrisLogging;
 import net.coderbot.iris.gl.shader.ShaderType;
@@ -218,6 +218,7 @@ protected ActivatableLifecycleUser<Parameters> getInjector() {
 			}
 		}
 				.wrapTarget("gl_Vertex")
+				.parsedReplacement("vec4((a_Pos * u_ModelScale) + d_ModelOffset.xyz, 1.0)")
 				.injectionLocation(InjectionPoint.BEFORE_DECLARATIONS);
 
 		LifecycleUser<Parameters> wrapMultiTexCoord = new WrapIdentifier<Parameters>() {
@@ -238,6 +239,7 @@ protected ActivatableLifecycleUser<Parameters> getInjector() {
 			}
 		}
 				.wrapTarget("gl_MultiTexCoord0")
+				.parsedReplacement("vec4(a_TexCoord * u_TextureScale, 0.0, 1.0)")
 				.injectionLocation(InjectionPoint.BEFORE_DECLARATIONS);
 
 		LifecycleUser<Parameters> wrapColor = new WrapIdentifier<Parameters>()

File: src/main/java/net/coderbot/iris/mixin/vertices/MixinBufferBuilder.java
Patch:
@@ -72,7 +72,7 @@ public abstract class MixinBufferBuilder implements BufferVertexConsumer, BlockS
 	private @Nullable VertexFormatElement currentElement;
 
 	@Shadow
-	public abstract void begin(int drawMode, VertexFormat vertexFormat);
+	public abstract void begin(VertexFormat.Mode drawMode, VertexFormat vertexFormat);
 
 	@Shadow
 	public abstract void putShort(int i, short s);
@@ -81,7 +81,7 @@ public abstract class MixinBufferBuilder implements BufferVertexConsumer, BlockS
 	private boolean iris$shouldNotExtend = false;
 
 	@Override
-	public void iris$beginWithoutExtending(int drawMode, VertexFormat vertexFormat) {
+	public void iris$beginWithoutExtending(VertexFormat.Mode drawMode, VertexFormat vertexFormat) {
 		iris$shouldNotExtend = true;
 		begin(drawMode, vertexFormat);
 		iris$shouldNotExtend = false;

File: src/main/java/net/coderbot/iris/mixin/vertices/immediate/MixinBufferSource.java
Patch:
@@ -20,8 +20,8 @@
 public class MixinBufferSource {
 	@Redirect(method = "getBuffer(Lnet/minecraft/client/renderer/RenderType;)Lcom/mojang/blaze3d/vertex/VertexConsumer;",
 		at = @At(value = "INVOKE",
-			target = "com/mojang/blaze3d/vertex/BufferBuilder.begin (ILcom/mojang/blaze3d/vertex/VertexFormat;)V"))
-	private void iris$redirectBegin(BufferBuilder bufferBuilder, int drawMode, VertexFormat vertexFormat) {
+			target = "com/mojang/blaze3d/vertex/BufferBuilder.begin (Lcom/mojang/blaze3d/vertex/VertexFormat$Mode;Lcom/mojang/blaze3d/vertex/VertexFormat;)V"))
+	private void iris$redirectBegin(BufferBuilder bufferBuilder, VertexFormat.Mode drawMode, VertexFormat vertexFormat) {
 		if (iris$notRenderingLevel()) {
 			((ExtendingBufferBuilder) bufferBuilder).iris$beginWithoutExtending(drawMode, vertexFormat);
 		} else {

File: src/main/java/net/coderbot/iris/vertices/ExtendingBufferBuilder.java
Patch:
@@ -3,5 +3,5 @@
 import com.mojang.blaze3d.vertex.VertexFormat;
 
 public interface ExtendingBufferBuilder {
-	void iris$beginWithoutExtending(int drawMode, VertexFormat vertexFormat);
+	void iris$beginWithoutExtending(VertexFormat.Mode drawMode, VertexFormat vertexFormat);
 }

File: src/main/java/net/coderbot/iris/uniforms/HardcodedCustomUniforms.java
Patch:
@@ -35,7 +35,7 @@ public static void addHardcodedCustomUniforms(UniformHolder holder, FrameUpdateN
 		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "isDry", new SmoothedFloat(20, 10, () -> getRawPrecipitation() == 0 ? 1 : 0, updateNotifier));
 		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "isRainy", new SmoothedFloat(20, 10, () -> getRawPrecipitation() == 1 ? 1 : 0, updateNotifier));
 		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "isSnowy", new SmoothedFloat(20, 10, () -> getRawPrecipitation() == 2 ? 1 : 0, updateNotifier));
-		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "isEyeInCave", CommonUniforms.isEyeInWater() == 0 ? eyeInCave : () -> 0);
+		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "isEyeInCave", () -> CommonUniforms.isEyeInWater() == 0 ? eyeInCave.getAsFloat() : 0);
 		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "velocity", () -> getVelocity(tracker));
 		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "starter", getStarter(tracker, updateNotifier));
 		// The following uniforms are Project Reimagined specific.

File: src/main/java/net/coderbot/iris/mixin/vertices/MixinVertexBuffer.java
Patch:
@@ -29,7 +29,7 @@ public class MixinVertexBuffer {
 			// Needless to say, that is not good if you don't like access violation crashes!
 			if (format == DefaultVertexFormat.BLOCK) {
 				this.format = IrisVertexFormats.TERRAIN;
-			} else if (format == DefaultVertexFormat.NEW_ENTITY) {
+			} else if (format == DefaultVertexFormat.NEW_ENTITY || format == DefaultVertexFormat.POSITION_COLOR_TEX_LIGHTMAP) {
 				this.format = IrisVertexFormats.ENTITY;
 			}
 		}

File: src/main/java/net/coderbot/iris/mixin/vertices/MixinVertexFormat.java
Patch:
@@ -22,7 +22,7 @@ public class MixinVertexFormat {
 				IrisVertexFormats.TERRAIN.setupBufferState(pointer);
 
 				ci.cancel();
-			} else if ((Object) this == DefaultVertexFormat.NEW_ENTITY) {
+			} else if ((Object) this == DefaultVertexFormat.NEW_ENTITY || (Object) this == DefaultVertexFormat.POSITION_COLOR_TEX_LIGHTMAP) {
 				IrisVertexFormats.ENTITY.setupBufferState(pointer);
 
 				ci.cancel();
@@ -37,7 +37,7 @@ public class MixinVertexFormat {
 				IrisVertexFormats.TERRAIN.clearBufferState();
 
 				ci.cancel();
-			} else if ((Object) this == DefaultVertexFormat.NEW_ENTITY) {
+			} else if ((Object) this == DefaultVertexFormat.NEW_ENTITY || (Object) this == DefaultVertexFormat.POSITION_COLOR_TEX_LIGHTMAP) {
 				IrisVertexFormats.ENTITY.clearBufferState();
 
 				ci.cancel();

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/vertex_format/entity/MixinBufferBuilder_ExtendedVertexFormatCompat.java
Patch:
@@ -22,7 +22,7 @@ public class MixinBufferBuilder_ExtendedVertexFormatCompat {
 	private VertexFormat format;
 
 	@ModifyVariable(method = "createSink(Lme/jellysquid/mods/sodium/client/model/vertex/type/VertexType;)Lme/jellysquid/mods/sodium/client/model/vertex/VertexSink;",
-		at = @At("HEAD"))
+		at = @At("HEAD"), remap = false)
 	private VertexType<?> iris$createSink(VertexType<?> type) {
 		if (type instanceof QuadVertexType && format == IrisVertexFormats.ENTITY) {
 			return ExtendedQuadVertexType.INSTANCE;

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -127,7 +127,8 @@ public Path[] getResourceDirs() {
 		String build_id = System.getenv("GITHUB_RUN_NUMBER");
 
 		if (build_id != null) {
-			return baseVersion + "build." + build_id;
+			// We don't want any suffix if we're doing a Github Release.
+			return baseVersion;
 		}
 
 		String commitHash = "";

File: src/main/java/net/coderbot/iris/UpdateInfo.java
Patch:
@@ -4,7 +4,7 @@
 import java.util.Map;
 
 public class UpdateInfo {
-	public int simpleVersion;
+	public String semanticVersion;
 	public Map<String, String> updateInfo;
 	public String modHost;
 	public String modDownload;

File: src/main/java/net/coderbot/iris/mixin/MixinWindow.java
Patch:
@@ -15,7 +15,7 @@
 public class MixinWindow {
 	@Inject(method = "<init>", at = @At(value = "INVOKE", target = "Lorg/lwjgl/glfw/GLFW;glfwDefaultWindowHints()V", shift = At.Shift.AFTER))
 	private void iris$enableDebugContext(WindowEventHandler arg, ScreenManager arg2, DisplayData arg3, String string, String string2, CallbackInfo ci) {
-		if (Iris.getIrisConfig().isDebugEnabled()) {
+		if (Iris.getIrisConfig().areDebugOptionsEnabled()) {
 			GLFW.glfwWindowHint(GLFW.GLFW_OPENGL_DEBUG_CONTEXT, GLFW.GLFW_TRUE);
 			Iris.logger.info("OpenGL debug context activated.");
 		}

File: src/main/java/net/coderbot/iris/uniforms/IrisInternalUniforms.java
Patch:
@@ -31,6 +31,6 @@ public static void addFogUniforms(DynamicUniformHolder uniforms) {
 			return Math.max(0.0F, CapturedRenderingState.INSTANCE.getFogDensity());
 		}, notifier -> {});
 
-		uniforms.uniform1f("iris_currentAlphaTest", CapturedRenderingState.INSTANCE::getCurrentAlphaTest, CapturedRenderingState.INSTANCE.getAlphaTestNotifier());
+		uniforms.uniform1f("iris_currentAlphaTest", CapturedRenderingState.INSTANCE::getCurrentAlphaTest, notifier -> {});
 	}
 }

File: src/main/java/net/coderbot/iris/pipeline/newshader/ExtendedShader.java
Patch:
@@ -137,8 +137,7 @@ public void setSampler(String name, Object sampler) {
 			super.setSampler("tex", sampler);
 		} else if (name.equals("Sampler1")) {
 			name = "iris_overlay";
-		} else if (name.equals("Sampler2") && !isFullbright) {
-			// TODO: Should we be providing the lightmap texture even if it's fullbright? Doing this before broke beacon beams on many packs.
+		} else if (name.equals("Sampler2")) {
 			name = "lightmap";
 		} else if (name.startsWith("Sampler")) {
 			// We only care about the texture, lightmap, and overlay for now from vanilla.

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -330,6 +330,7 @@ public NewWorldRenderingPipeline(ProgramSet programSet) throws IOException {
 		BlockRenderingSettings.INSTANCE.setAmbientOcclusionLevel(programSet.getPackDirectives().getAmbientOcclusionLevel());
 		BlockRenderingSettings.INSTANCE.setDisableDirectionalShading(shouldDisableDirectionalShading());
 		BlockRenderingSettings.INSTANCE.setUseSeparateAo(programSet.getPackDirectives().shouldUseSeparateAo());
+		BlockRenderingSettings.INSTANCE.setUseExtendedVertexFormat(true);
 
 		this.clearPassesFull = ClearPassCreator.createClearPasses(renderTargets, true,
 				programSet.getPackDirectives().getRenderTargetDirectives());

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -56,7 +56,7 @@ public class Buildscript extends SimpleFabricProject {
 
 	@Override
 	public VersionMeta createMcVersion() {
-		return Minecraft.getVersion("22w17a");
+		return Minecraft.getVersion("22w19a");
 	}
 
 	@Override
@@ -66,7 +66,7 @@ public MappingTree createMappings() {
 
 	@Override
 	public FabricLoader getLoader() {
-		return new FabricLoader(FabricMaven.URL, FabricMaven.loader("0.13.3"));
+		return new FabricLoader(FabricMaven.URL, FabricMaven.loader("0.14.5"));
 	}
 
 	@Override
@@ -87,7 +87,7 @@ protected FabricModule createModule() {
     @Override
     public void getModDependencies(ModDependencyCollector d) {
 		jij(d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.anarres:jcpp:1.4.14"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
-		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-resource-loader-v0", "0.4.23+717abbc4ed"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
+		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-resource-loader-v0", "0.4.25+ec94c6f6bf"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.11+54e5b2ecd2"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-command-api-v1", "1.1.11+a67d2aa5ed"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));
 		jij(d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-api-base", "0.4.3+d7c144a8d2"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME));

File: src/main/java/net/coderbot/batchedentityrendering/impl/SegmentedBufferBuilder.java
Patch:
@@ -59,7 +59,7 @@ public List<BufferSegment> getSegments() {
             return Collections.emptyList();
         }
 
-        if (isTranslucent(currentType)) {
+        if (shouldSortOnUpload(currentType)) {
             buffer.setQuadSortOrigin(0, 0, 0);
         }
 

File: src/main/java/net/coderbot/iris/uniforms/IrisExclusiveUniforms.java
Patch:
@@ -13,6 +13,6 @@ public static void addIrisExclusiveUniforms(UniformHolder uniforms) {
 
 
 	private static float getThunderStrength() {
-		return Minecraft.getInstance().level.getThunderLevel(CapturedRenderingState.INSTANCE.getTickDelta()
+		return Minecraft.getInstance().level.getThunderLevel(CapturedRenderingState.INSTANCE.getTickDelta());
 	}
 }

File: src/main/java/net/coderbot/iris/gl/IrisRenderSystem.java
Patch:
@@ -19,12 +19,12 @@ public class IrisRenderSystem {
 	private static Matrix4f backupProjection;
 
 	public static void getIntegerv(int pname, int[] params) {
-		RenderSystem.assertThread(RenderSystem::isOnRenderThreadOrInit);
+		RenderSystem.assertOnRenderThreadOrInit();
 		GL32C.glGetIntegerv(pname, params);
 	}
 
 	public static void getFloatv(int pname, float[] params) {
-		RenderSystem.assertThread(RenderSystem::isOnRenderThreadOrInit);
+		RenderSystem.assertOnRenderThreadOrInit();
 		GL32C.glGetFloatv(pname, params);
 	}
 
@@ -124,7 +124,7 @@ public static void detachShader(int program, int shader) {
 	}
 
 	public static int getTexParameteri(int target, int pname) {
-		RenderSystem.assertThread(RenderSystem::isOnRenderThreadOrInit);
+		RenderSystem.assertOnRenderThreadOrInit();
 		return GL32C.glGetTexParameteri(target, pname);
 	}
 

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -134,7 +134,7 @@ public static ExtendedShader create(String name, ProgramSource source, GlFramebu
 			//SamplerUniforms.addWorldSamplerUniforms(uniforms);
 			//SamplerUniforms.addDepthSamplerUniforms(uniforms);
 			BuiltinReplacementUniforms.addBuiltinReplacementUniforms(uniforms);
-		}, isFullbright, parent);
+		}, isFullbright, parent, inputs);
 	}
 
 	public static FallbackShader createFallback(String name, GlFramebuffer writingToBeforeTranslucent,

File: src/main/java/net/coderbot/iris/texture/TextureInfoCache.java
Patch:
@@ -1,8 +1,10 @@
 package net.coderbot.iris.texture;
 
 import com.mojang.blaze3d.platform.GlStateManager;
+import com.mojang.blaze3d.systems.RenderSystem;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import net.coderbot.iris.mixin.GlStateManagerAccessor;
 import org.jetbrains.annotations.Nullable;
 import org.lwjgl.opengl.GL20C;
 
@@ -28,7 +30,7 @@ public TextureInfo getInfo(int id) {
 	public void onTexImage2D(int target, int level, int internalformat, int width, int height, int border,
 							 int format, int type, @Nullable IntBuffer pixels) {
 		if (level == 0) {
-			int id = GlStateManager.getActiveTextureName();
+			int id = RenderSystem.getTextureId(GlStateManagerAccessor.getActiveTexture());
 			TextureInfo info = getInfo(id);
 			info.internalFormat = internalformat;
 			info.width = width;

File: src/main/java/net/coderbot/iris/mixin/GlStateManagerAccessor.java
Patch:
@@ -6,9 +6,6 @@
 
 @Mixin(GlStateManager.class)
 public interface GlStateManagerAccessor {
-	@Accessor("activeTexture")
-	static int getActiveTexture() { throw new UnsupportedOperationException("not accessed"); }
-
 	@Accessor("BLEND")
 	static GlStateManager.BlendState getBLEND() {
 		throw new UnsupportedOperationException("Not accessed");

File: src/main/java/net/coderbot/iris/gl/state/StateUpdateNotifiers.java
Patch:
@@ -10,6 +10,6 @@ public class StateUpdateNotifiers {
 	public static ValueUpdateNotifier fogStartNotifier;
 	public static ValueUpdateNotifier fogEndNotifier;
 	public static ValueUpdateNotifier blendFuncNotifier;
-	public static ValueUpdateNotifier atlasTextureNotifier;
+	public static ValueUpdateNotifier bindTextureNotifier;
 	public static ValueUpdateNotifier phaseChangeNotifier;
 }

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPipeline.java
Patch:
@@ -18,7 +18,7 @@ public interface WorldRenderingPipeline {
 
 	void setPhase(WorldRenderingPhase phase);
 
-    void beginShadowRender();
+	void beginShadowRender();
 	void endShadowRender();
 
 	void beginHand();

File: src/main/java/net/coderbot/iris/uniforms/CapturedRenderingState.java
Patch:
@@ -8,6 +8,8 @@
 public class CapturedRenderingState {
 	public static final CapturedRenderingState INSTANCE = new CapturedRenderingState();
 
+	private static final Vector3d ZERO_VECTOR_3d = new Vector3d();
+
 	private Matrix4f gbufferModelView;
 	private Matrix4f gbufferProjection;
 	private Vector3d fogColor;
@@ -40,7 +42,7 @@ public void setGbufferProjection(Matrix4f gbufferProjection) {
 
 	public Vector3d getFogColor() {
 		if (Minecraft.getInstance().level == null || fogColor == null) {
-			return new Vector3d();
+			return ZERO_VECTOR_3d;
 		}
 
 		return fogColor;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/terrain_xhfp/XHFPModelVertexType.java
Patch:
@@ -15,7 +15,7 @@
  * Like HFPModelVertexType, but extended to support Iris. The extensions aren't particularly efficient right now.
  */
 public class XHFPModelVertexType implements ChunkVertexType {
-	static final int STRIDE = 36;
+	public static final int STRIDE = 36;
 
 	public static final GlVertexFormat<ChunkMeshAttribute> VERTEX_FORMAT = GlVertexFormat.builder(ChunkMeshAttribute.class, STRIDE)
 			.addElement(ChunkMeshAttribute.POSITION_ID, 0, GlVertexAttributeFormat.UNSIGNED_SHORT, 4, false)

File: src/main/java/net/coderbot/iris/shaderpack/ShaderProperties.java
Patch:
@@ -79,8 +79,8 @@ private ShaderProperties() {
 	}
 
 	// TODO: Is there a better solution than having ShaderPack pass a root path to ShaderProperties to be able to read textures?
-	public ShaderProperties(String contents, ShaderPackOptions shaderPackOptions) {
-		String preprocessedContents = PropertiesPreprocessor.preprocessSource(contents, shaderPackOptions);
+	public ShaderProperties(String contents, ShaderPackOptions shaderPackOptions, Iterable<StringPair> environmentDefines) {
+		String preprocessedContents = PropertiesPreprocessor.preprocessSource(contents, shaderPackOptions, environmentDefines);
 
 		Properties preprocessed = new OrderBackedProperties();
 		Properties original = new OrderBackedProperties();

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -7,6 +7,7 @@
 import net.coderbot.iris.compat.sodium.SodiumVersionCheck;
 import net.coderbot.iris.config.IrisConfig;
 import net.coderbot.iris.gl.GLDebug;
+import net.coderbot.iris.gl.shader.StandardMacros;
 import net.coderbot.iris.gui.screen.ShaderPackScreen;
 import net.coderbot.iris.pipeline.DeferredWorldRenderingPipeline;
 import net.coderbot.iris.pipeline.FixedFunctionWorldRenderingPipeline;
@@ -340,7 +341,7 @@ private static boolean loadExternalShaderpack(String name) {
 		resetShaderPackOptions = false;
 
 		try {
-			currentPack = new ShaderPack(shaderPackPath, changedConfigs);
+			currentPack = new ShaderPack(shaderPackPath, changedConfigs, StandardMacros.createStandardEnvironmentDefines());
 
 			MutableOptionValues changedConfigsValues = currentPack.getShaderPackOptions().getOptionValues().mutableCopy();
 
@@ -663,7 +664,7 @@ public static String getFormattedVersion() {
 	public static boolean isSodiumInvalid() {
 		return sodiumInvalid;
   }
-  
+
 	public static boolean isSodiumInstalled() {
 		return sodiumInstalled;
 	}

File: src/test/java/net/coderbot/iris/test/shaderpack/IdMapTest.java
Patch:
@@ -18,7 +18,7 @@
 public class IdMapTest {
 	private static final Map<NamespacedId, BlockRenderType> EXPECTED_LAYERS;
 	private static final Int2ObjectMap<List<BlockEntry>> EXPECTED_BLOCKS;
-	
+
 	static {
 		EXPECTED_LAYERS = new HashMap<>();
 
@@ -41,14 +41,14 @@ public class IdMapTest {
 				new BlockEntry(new NamespacedId("minecraft", "blue_stained_glass"), new HashMap<>()),
 				new BlockEntry(new NamespacedId("minecraft", "white_stained_glass"), new HashMap<>())));
 	}
-	
+
 	@Test
 	void testLoadIdMaps() {
 		ShaderPack shaderPack;
 
 		// ensure that we can actually load the shader pack
 		try {
-			shaderPack = new ShaderPack(IrisTests.getTestShaderPackPath("id_maps"));
+			shaderPack = new ShaderPack(IrisTests.getTestShaderPackPath("id_maps"), IrisTests.TEST_ENVIRONMENT_DEFINES);
 		} catch (Exception e) {
 			Assertions.fail("Couldn't load test shader pack id_maps", e);
 			return;

File: src/test/java/net/coderbot/iris/test/shaderpack/LanguageMapTest.java
Patch:
@@ -15,7 +15,7 @@ void testLoadLanguages() {
 
 		// ensure that we can actually load the shader pack
 		try {
-			shaderPack = new ShaderPack(IrisTests.getTestShaderPackPath("language_maps"));
+			shaderPack = new ShaderPack(IrisTests.getTestShaderPackPath("language_maps"), IrisTests.TEST_ENVIRONMENT_DEFINES);
 		} catch (Exception e) {
 			Assertions.fail("Couldn't load test shader pack language_maps", e);
 			return;

File: src/test/java/net/coderbot/iris/test/shaderpack/OptionApplyTest.java
Patch:
@@ -16,14 +16,13 @@
 import java.util.Map;
 
 public class OptionApplyTest {
-	//@Test
-	// TODO: Re-enable this once we can load shader packs in tests without referencing OpenGL / LWJGL / Minecraft.
+	@Test
 	void testOptions() {
 		ShaderPack shaderPack;
 
 		// ensure that we can actually load the shader pack
 		try {
-			shaderPack = new ShaderPack(IrisTests.getTestShaderPackPath("options"));
+			shaderPack = new ShaderPack(IrisTests.getTestShaderPackPath("options"), IrisTests.TEST_ENVIRONMENT_DEFINES);
 		} catch (Exception e) {
 			Assertions.fail("Couldn't load test shader pack options", e);
 			return;

File: src/main/java/net/coderbot/iris/mixin/MixinWindow.java
Patch:
@@ -17,7 +17,7 @@ public class MixinWindow {
 	private void iris$enableDebugContext(WindowEventHandler arg, ScreenManager arg2, DisplayData arg3, String string, String string2, CallbackInfo ci) {
 		if (Iris.getIrisConfig().isDebugEnabled()) {
 			GLFW.glfwWindowHint(GLFW.GLFW_OPENGL_DEBUG_CONTEXT, GLFW.GLFW_TRUE);
-			Iris.logger.warn("OpenGL debug context activated.");
+			Iris.logger.info("OpenGL debug context activated.");
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -223,7 +223,7 @@ public DeferredWorldRenderingPipeline(ProgramSet programs) {
 
 		BufferFlipper flipper = new BufferFlipper();
 
-		this.centerDepthSampler = new CenterDepthSampler(renderTargets);
+		this.centerDepthSampler = new CenterDepthSampler(programs.getPackDirectives().getCenterDepthHalfLife());
 
 		Supplier<ShadowMapRenderer> shadowMapRendererSupplier = () -> {
 			createShadowMapRenderer.run();

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -704,6 +704,7 @@ public void destroy() {
 		compositeRenderer.destroy();
 		deferredRenderer.destroy();
 		finalPassRenderer.destroy();
+		centerDepthSampler.destroy();
 
 		// Make sure that any custom framebuffers are not bound before destroying render targets
 		GlStateManager._glBindFramebuffer(GL30C.GL_READ_FRAMEBUFFER, 0);

File: src/main/java/net/coderbot/iris/mixin/MixinGlStateManager_AtlasTracking.java
Patch:
@@ -27,7 +27,7 @@ public class MixinGlStateManager_AtlasTracking {
 
 	@Inject(method = "_bindTexture(I)V", at = @At("HEAD"))
 	private static void iris$onBindTexture(int id, CallbackInfo ci) {
-		if (activeTexture == 0 && atlasTextureListener != null) {
+		if (activeTexture == 0 && atlasTextureListener != null && !TextureAtlasTracker.IS_FETCHING_SIZE) {
 			atlasTextureListener.run();
 		}
 	}

File: src/main/java/net/coderbot/iris/mixin/MixinRenderTarget.java
Patch:
@@ -27,7 +27,7 @@ public class MixinRenderTarget implements Blaze3dRenderTargetExt {
 		iris$colorDirty = true;
 	}
 
-	@Inject(method = "createBuffers()V", at = @At(value = "INVOKE", target = "com/mojang/blaze3d/platform/GlStateManager._bindTexture (I)V"))
+	@Inject(method = "createBuffers(IIZ)V", at = @At(value = "INVOKE", target = "com/mojang/blaze3d/platform/GlStateManager._bindTexture (I)V"))
 	private void iris$onCreateDepthBuffer(int width, int height, boolean checkError, CallbackInfo ci) {
 		DepthBufferTracker.INSTANCE.trackDepthBuffer(this.depthBufferId);
 	}

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -320,8 +320,8 @@ private void copyPreTranslucentDepth() {
 
 		// note: destFb is null since we never end up getting a strategy that requires the target framebuffer
 		// this is a bit of an assumption but it works for now
-		DepthCopyStrategy.fastest(false).copy(getRenderTargets().getFramebuffer(), getDepthTextureId(), null,
-			getDepthTextureNoTranslucentsId(), resolution, resolution);
+		DepthCopyStrategy.fastest(false).copy(targets.getFramebuffer(), targets.getDepthTexture().getTextureId(), null,
+			targets.getDepthTextureNoTranslucents().getTextureId(), resolution, resolution);
 	}
 
 	private void renderEntities(LevelRendererAccessor levelRenderer, Frustum frustum, MultiBufferSource.BufferSource bufferSource, PoseStack modelView, double cameraX, double cameraY, double cameraZ, float tickDelta) {

File: src/main/java/net/coderbot/iris/pipeline/ClearPass.java
Patch:
@@ -13,10 +13,10 @@ public class ClearPass {
 	private final GlFramebuffer framebuffer;
 	private final int clearFlags;
 
-	public ClearPass(Vector4f color, GlFramebuffer framebuffer, boolean clearDepth) {
+	public ClearPass(Vector4f color, GlFramebuffer framebuffer) {
 		this.color = color;
 		this.framebuffer = framebuffer;
-		this.clearFlags = GL21C.GL_COLOR_BUFFER_BIT | (clearDepth ? GL21C.GL_DEPTH_BUFFER_BIT : 0);
+		this.clearFlags = GL21C.GL_COLOR_BUFFER_BIT;
 	}
 
 	public void execute(Vector4f defaultClearColor) {

File: src/main/java/net/coderbot/iris/pipeline/ClearPassCreator.java
Patch:
@@ -61,12 +61,12 @@ public static ImmutableList<ClearPass> createClearPasses(RenderTargets renderTar
 					startIndex++;
 				}
 
-				// only clear depth if this is the first clear pass
+				// No need to clear the depth buffer, since we're using Minecraft's depth buffer.
 				clearPasses.add(new ClearPass(clearColor,
-						renderTargets.createFramebufferWritingToAlt(clearBuffers), clearPasses.isEmpty()));
+						renderTargets.createFramebufferWritingToAlt(clearBuffers)));
 
 				clearPasses.add(new ClearPass(clearColor,
-						renderTargets.createFramebufferWritingToMain(clearBuffers), false));
+						renderTargets.createFramebufferWritingToMain(clearBuffers)));
 			}
 		});
 

File: src/main/java/net/coderbot/iris/shadows/ShadowRenderTargets.java
Patch:
@@ -6,6 +6,7 @@
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
 import net.coderbot.iris.gl.texture.PixelFormat;
 import net.coderbot.iris.gl.texture.PixelType;
+import net.coderbot.iris.gl.texture.DepthBufferFormat;
 import net.coderbot.iris.rendertarget.DepthTexture;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL13C;
@@ -40,8 +41,8 @@ public ShadowRenderTargets(int resolution, InternalTextureFormat[] formats) {
 		targets = new int[formats.length];
 		GlStateManager._genTextures(targets);
 
-		depthTexture = new DepthTexture(resolution, resolution);
-		noTranslucents = new DepthTexture(resolution, resolution);
+		depthTexture = new DepthTexture(resolution, resolution, DepthBufferFormat.DEPTH);
+		noTranslucents = new DepthTexture(resolution, resolution, DepthBufferFormat.DEPTH);
 
 		this.framebuffer = new GlFramebuffer();
 

File: src/main/java/net/coderbot/iris/mixin/MixinMinecraft.java
Patch:
@@ -2,9 +2,7 @@
 
 import net.coderbot.iris.Iris;
 import net.minecraft.client.Minecraft;
-import net.minecraft.client.multiplayer.ClientLevel;
 import net.minecraft.util.profiling.ProfilerFiller;
-import org.jetbrains.annotations.Nullable;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.injection.At;

File: src/main/java/net/coderbot/iris/mixin/texture/TextureAtlasSpriteAccessor.java
Patch:
@@ -28,10 +28,10 @@ public interface TextureAtlasSpriteAccessor {
 	void setFrame(int frame);
 
 	@Accessor("subFrame")
-    int getSubFrame();
+	int getSubFrame();
 
 	@Accessor("subFrame")
-    void setSubFrame(int subFrame);
+	void setSubFrame(int subFrame);
 
 	@Invoker("upload")
 	void callUpload(int frameIndex);

File: src/main/java/net/coderbot/iris/rendertarget/RenderTargets.java
Patch:
@@ -3,12 +3,10 @@
 import com.google.common.collect.ImmutableSet;
 import net.coderbot.iris.gl.framebuffer.GlFramebuffer;
 import net.coderbot.iris.shaderpack.PackRenderTargetDirectives;
-import net.minecraft.client.Minecraft;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
-import java.util.function.IntSupplier;
 
 public class RenderTargets {
 	private final RenderTarget[] targets;

File: src/main/java/net/coderbot/iris/texture/util/ImageManipulationUtil.java
Patch:
@@ -64,7 +64,7 @@ public static NativeImage scaleBilinear(NativeImage image, int newWidth, int new
 					int colorTR = image.getPixelRGBA(x1, y0);
 					int colorBL = image.getPixelRGBA(x0, y1);
 					int colorBR = image.getPixelRGBA(x1, y1);
-	
+
 					finalColor = blendColor(colorTL, colorTR, colorBL, colorBR, weightTL, weightTR, weightBL, weightBR);
 				} else if (x0valid & x1valid) {
 					float leftWeight = (x1 + 0.5f) - unscaledX;

File: src/main/java/net/coderbot/iris/texture/util/TextureManipulationUtil.java
Patch:
@@ -6,7 +6,7 @@
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL30;
 
-public class TextureColorUtil {
+public class TextureManipulationUtil {
 	private static int colorFillFBO = -1;
 
 	public static void fillWithColor(int textureId, int maxLevel, int rgba) {

File: src/main/java/net/coderbot/iris/mixin/MixinGameRenderer.java
Patch:
@@ -396,6 +396,7 @@ private static boolean isSky() {
 
 		if (pipeline != null) {
 			switch (pipeline.getPhase()) {
+				case CUSTOM_SKY:
 				case SKY:
 				case SUNSET:
 				case SUN:

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -901,7 +901,7 @@ public void beginLevelRendering() {
 		// A lot of dimension mods touch sky rendering, FabricSkyboxes injects at HEAD and cancels, etc.
 		DimensionSpecialEffects.SkyType skyType = Minecraft.getInstance().level.effects().skyType();
 
-		if (skyType != DimensionSpecialEffects.SkyType.NORMAL) {
+		if (skyType != DimensionSpecialEffects.SkyType.NONE) {
 			RenderSystem.disableTexture();
 			RenderSystem.depthMask(false);
 			pushProgram(GbufferProgram.SKY_BASIC);

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPhase.java
Patch:
@@ -4,7 +4,7 @@ public enum WorldRenderingPhase {
 	NONE,
 	SKY,
 	SUNSET,
-	CUSTOM_SKY, // Unused, just here to match OptiFine ordinals
+	CUSTOM_SKY,
 	SUN,
 	MOON,
 	STARS,

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -509,7 +509,7 @@ public void beginLevelRendering() {
 		// A lot of dimension mods touch sky rendering, FabricSkyboxes injects at HEAD and cancels, etc.
 		DimensionSpecialEffects.SkyType skyType = Minecraft.getInstance().level.effects().skyType();
 
-		if (skyType != DimensionSpecialEffects.SkyType.NORMAL) {
+		if (skyType != DimensionSpecialEffects.SkyType.NONE) {
 			RenderSystem.disableTexture();
 			RenderSystem.depthMask(false);
 

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -99,6 +99,7 @@ public class DeferredWorldRenderingPipeline implements WorldRenderingPipeline, R
 	private final CustomTextureManager customTextureManager;
 	private final AbstractTexture whitePixel;
 	private final FrameUpdateNotifier updateNotifier;
+	private final CenterDepthSampler centerDepthSampler;
 
 	private final ImmutableSet<Integer> flippedBeforeShadow;
 	private final ImmutableSet<Integer> flippedAfterPrepare;
@@ -174,7 +175,7 @@ public DeferredWorldRenderingPipeline(ProgramSet programs) {
 
 		BufferFlipper flipper = new BufferFlipper();
 
-		CenterDepthSampler centerDepthSampler = new CenterDepthSampler(renderTargets);
+		this.centerDepthSampler = new CenterDepthSampler(renderTargets);
 
 		this.shadowMapResolution = programs.getPackDirectives().getShadowDirectives().getResolution();
 

File: src/main/java/net/coderbot/batchedentityrendering/impl/RenderTypeUtil.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.mojang.blaze3d.vertex.VertexFormat;
 import net.minecraft.client.renderer.RenderType;
-import org.lwjgl.opengl.GL11C;
 
 public class RenderTypeUtil {
     public static boolean isTriangleStripDrawMode(RenderType renderType) {

File: src/main/java/net/coderbot/iris/fantastic/IrisParticleRenderTypes.java
Patch:
@@ -10,7 +10,7 @@
 import net.minecraft.client.renderer.texture.TextureManager;
 
 public class IrisParticleRenderTypes {
-	public static final ParticleRenderType OPAQUE_TERRAIN_SHEET = new ParticleRenderType() {
+	public static final ParticleRenderType OPAQUE_TERRAIN = new ParticleRenderType() {
 		public void begin(BufferBuilder bufferBuilder, TextureManager textureManager) {
 			// Cutout is handled by the particle shader for us.
 			RenderSystem.disableBlend();

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -204,7 +204,7 @@ public DeferredWorldRenderingPipeline(ProgramSet programs) {
 			shadowMapRenderer = new ShadowRenderer(this, programs.getShadow().orElse(null),
 					programs.getPackDirectives(), () -> flippedBeforeShadow, renderTargets,
 					customTextureManager.getNormals(), customTextureManager.getSpecular(), customTextureManager.getNoiseTexture(),
-					programs, customTextureManager.getCustomTextureIdMap().getOrDefault(TextureStage.GBUFFERS_AND_SHADOW, Object2ObjectMaps.emptyMap()));
+					customTextureManager.getCustomTextureIdMap().getOrDefault(TextureStage.GBUFFERS_AND_SHADOW, Object2ObjectMaps.emptyMap()));
 			createShadowMapRenderer = () -> {};
 		};
 

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/shader_overrides/IrisChunkProgramOverrides.java
Patch:
@@ -151,7 +151,6 @@ private GlProgram<IrisChunkShaderInterface> createShader(IrisTerrainPass pass, S
                     .bindAttribute("mc_midTexCoord", IrisChunkShaderBindingPoints.MID_TEX_COORD)
                     .bindAttribute("at_tangent", IrisChunkShaderBindingPoints.TANGENT)
                     .bindAttribute("a_Normal", IrisChunkShaderBindingPoints.NORMAL)
-					.bindFragmentData("iris_FragData", ChunkShaderBindingPoints.FRAG_COLOR)
 					.link((shader) -> {
 						// TODO: Better way for this? It's a bit too much casting for me.
 						int handle = ((GlObject) shader).handle();

File: src/main/java/net/coderbot/iris/pipeline/AttributeShaderTransformer.java
Patch:
@@ -3,7 +3,7 @@
 import net.coderbot.iris.gl.shader.ShaderType;
 import net.coderbot.iris.shaderpack.transform.*;
 
-public class AttributeShaderTransformer extends Patcher {
+public class AttributeShaderTransformer {
 	public String patchAttributesInternal(String source, ShaderType type, boolean hasGeometry) {
 		if (source.contains("iris_")) {
 			throw new IllegalStateException("Shader is attempting to exploit internal Iris code!");

File: src/main/java/net/coderbot/iris/pipeline/Patcher.java
Patch:
@@ -9,7 +9,6 @@
 
 public abstract class Patcher {
 	public static Patcher INSTANCE = new TransformPatcher();
-	// static Patcher INSTANCE = new AttributeShaderTransformer();
 
 	static Logger LOGGER = LogManager.getLogger(Patcher.class);
 

File: src/main/java/net/coderbot/iris/pipeline/TransformPatcher.java
Patch:
@@ -226,7 +226,7 @@ protected boolean isActive() {
 						"mat3(u_NormalMatrix)",
 						InjectionPoint.BEFORE_DECLARATIONS,
 						"uniform mat4 u_NormalMatrix;");
-		Transformation<Parameters> replaceTextureMatrix = new Transformation<>() {
+		Transformation<Parameters> replaceTextureMatrix = new Transformation<Parameters>() {
 			{
 				addEndDependent(new WalkPhase<Parameters>() {
 					ParseTreePattern textureMatrixPattern;

File: src/main/java/net/coderbot/iris/mixin/gui/MixinVideoSettingsScreen.java
Patch:
@@ -30,7 +30,7 @@ protected MixinVideoSettingsScreen(Component title) {
 	private OptionInstance<?>[] iris$addShaderPackScreenButton(OptionInstance<?>[] $$0) {
 		OptionInstance[] options = new OptionInstance[$$0.length + 1];
 		System.arraycopy($$0, 0, options, 0, $$0.length);
-		options[options.length - 1] = new OptionInstance<>("options.iris.shaderPackSelection", OptionInstance.cachedConstantTooltip(Component.empty()), null, OptionInstance.BOOLEAN_VALUES, true, (parent) -> minecraft.setScreen(new ShaderPackScreen(this)));
+		options[options.length - 1] = new OptionInstance<>("options.iris.shaderPackSelection", OptionInstance.cachedConstantTooltip(Component.empty()), (arg, object) -> Component.empty(), OptionInstance.BOOLEAN_VALUES, true, (parent) -> minecraft.setScreen(new ShaderPackScreen(this)));
 		return options;
 	}
 }

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -184,6 +184,7 @@ public DeferredWorldRenderingPipeline(ProgramSet programs) {
 
 		BlockRenderingSettings.INSTANCE.setBlockStateIds(
 				BlockMaterialMapping.createBlockStateIdMap(programs.getPack().getIdMap().getBlockProperties()));
+		BlockRenderingSettings.INSTANCE.setBlockTypeIds(BlockMaterialMapping.createBlockTypeMap(programs.getPack().getIdMap().getBlockRenderTypeMap()));
 
 		BlockRenderingSettings.INSTANCE.setEntityIds(programs.getPack().getIdMap().getEntityIdMap());
 		BlockRenderingSettings.INSTANCE.setAmbientOcclusionLevel(programs.getPackDirectives().getAmbientOcclusionLevel());

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -184,6 +184,7 @@ public DeferredWorldRenderingPipeline(ProgramSet programs) {
 
 		BlockRenderingSettings.INSTANCE.setBlockStateIds(
 				BlockMaterialMapping.createBlockStateIdMap(programs.getPack().getIdMap().getBlockProperties()));
+		BlockRenderingSettings.INSTANCE.setBlockTypeIds(BlockMaterialMapping.createBlockTypeMap(programs.getPack().getIdMap().getBlockRenderTypeMap()));
 
 		BlockRenderingSettings.INSTANCE.setEntityIds(programs.getPack().getIdMap().getEntityIdMap());
 		BlockRenderingSettings.INSTANCE.setAmbientOcclusionLevel(programs.getPackDirectives().getAmbientOcclusionLevel());

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -471,7 +471,7 @@ public void beginLevelRendering() {
 		updateNotifier.onNewFrame();
 
 		RenderTarget main = Minecraft.getInstance().getMainRenderTarget();
-		renderTargets.resizeIfNeeded(((Blaze3dRenderTargetExt) main).iris$isDepthBufferDirty(), main.width, main.height);
+		renderTargets.resizeIfNeeded(((Blaze3dRenderTargetExt) main).iris$isDepthBufferDirty(), main.getDepthTextureId(), main.width, main.height);
 		((Blaze3dRenderTargetExt) main).iris$clearDepthBufferDirtyFlag();
 
 		final ImmutableList<ClearPass> passes;

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -754,7 +754,7 @@ private void prepareRenderTargets() {
 		RenderTarget main = Minecraft.getInstance().getMainRenderTarget();
 		Blaze3dRenderTargetExt mainExt = (Blaze3dRenderTargetExt) main;
 
-		renderTargets.resizeIfNeeded(mainExt.iris$isDepthBufferDirty(), main.width, main.height);
+		renderTargets.resizeIfNeeded(mainExt.iris$isDepthBufferDirty(), main.getDepthTextureId(), main.width, main.height);
 
 		mainExt.iris$clearDepthBufferDirtyFlag();
 

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -451,7 +451,7 @@ private void restoreGlState(Minecraft client) {
 		IrisRenderSystem.restoreProjectionMatrix();
 
 		// Restore the old viewport
-		RenderSystem.viewport(0, 0, client.getWindow().getWidth(), client.getWindow().getHeight());
+		RenderSystem.viewport(0, 0, client.getMainRenderTarget().width, client.getMainRenderTarget().height);
 	}
 
 	private void copyPreTranslucentDepth() {

File: src/main/java/net/coderbot/iris/samplers/IrisSamplers.java
Patch:
@@ -122,13 +122,13 @@ public static void addLevelSamplers(SamplerHolder samplers, AbstractTexture norm
 	}
 
 	public static void addWorldDepthSamplers(SamplerHolder samplers, RenderTargets renderTargets) {
-		samplers.addDynamicSampler(renderTargets.getDepthTexture(), "depthtex0");
+		samplers.addDynamicSampler(renderTargets::getDepthTexture, "depthtex0");
 		// TODO: Should depthtex2 be made available to gbuffer / shadow programs?
 		samplers.addDynamicSampler(renderTargets.getDepthTextureNoTranslucents()::getTextureId, "depthtex1");
 	}
 
 	public static void addCompositeSamplers(SamplerHolder samplers, RenderTargets renderTargets) {
-		samplers.addDynamicSampler(renderTargets.getDepthTexture(),
+		samplers.addDynamicSampler(renderTargets::getDepthTexture,
 				"gdepthtex", "depthtex0");
 		samplers.addDynamicSampler(renderTargets.getDepthTextureNoTranslucents()::getTextureId,
 				"depthtex1");

File: src/main/java/net/coderbot/iris/texture/pbr/loader/PBRTextureLoader.java
Patch:
@@ -2,13 +2,14 @@
 
 import net.minecraft.client.renderer.texture.AbstractTexture;
 import net.minecraft.server.packs.resources.ResourceManager;
+import org.jetbrains.annotations.Nullable;
 
 public interface PBRTextureLoader<T extends AbstractTexture> {
 	void load(T texture, ResourceManager resourceManager, PBRTextureConsumer pbrTextureConsumer);
 
 	interface PBRTextureConsumer {
-		void acceptNormalTexture(AbstractTexture texture);
+		void acceptNormalTexture(@Nullable AbstractTexture texture);
 
-		void acceptSpecularTexture(AbstractTexture texture);
+		void acceptSpecularTexture(@Nullable AbstractTexture texture);
 	}
 }

File: src/main/java/net/coderbot/iris/texture/util/ImageManipulationUtil.java
Patch:
@@ -41,10 +41,10 @@ public static NativeImage scaleBilinear(NativeImage image, int newWidth, int new
 				if (y0 < 0) {
 					y0valid = false;
 				}
-				if (x1 > image.getWidth()) {
+				if (x1 >= image.getWidth()) {
 					x1valid = false;
 				}
-				if (y1 > image.getHeight()) {
+				if (y1 >= image.getHeight()) {
 					y1valid = false;
 				}
 

File: src/main/java/net/coderbot/iris/texture/util/TextureColorUtil.java
Patch:
@@ -1,6 +1,7 @@
 package net.coderbot.iris.texture.util;
 
 import com.mojang.blaze3d.platform.GlStateManager;
+import net.coderbot.iris.gl.IrisRenderSystem;
 import net.minecraft.client.Minecraft;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL30;
@@ -15,10 +16,10 @@ public static void fillWithColor(int textureId, int maxLevel, int rgba) {
 
 		int previousFramebufferId = GlStateManager._getInteger(GL30.GL_FRAMEBUFFER_BINDING);
 		float[] previousClearColor = new float[4];
-		GL11.glGetFloatv(GL11.GL_COLOR_CLEAR_VALUE, previousClearColor);
+		IrisRenderSystem.getFloatv(GL11.GL_COLOR_CLEAR_VALUE, previousClearColor);
 		int previousTextureId = GlStateManager._getInteger(GL11.GL_TEXTURE_BINDING_2D);
 		int[] previousViewport = new int[4];
-		GL11.glGetIntegerv(GL11.GL_VIEWPORT, previousViewport);
+		IrisRenderSystem.getIntegerv(GL11.GL_VIEWPORT, previousViewport);
 
 		GlStateManager._glBindFramebuffer(GL30.GL_FRAMEBUFFER, colorFillFBO);
 		GlStateManager._clearColor(

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -394,7 +394,7 @@ private ShaderInstance createShadowShader(String name, Optional<ProgramSource> s
 	}
 
 	private ShaderInstance createFallbackShadowShader(String name, ShaderKey key) throws IOException {
-		GlFramebuffer framebuffer = ((ShadowRenderer) this.shadowMapRenderer).getFramebuffer();
+		GlFramebuffer framebuffer = this.shadowMapRenderer.getRenderTargets().getFramebuffer();
 
 		FallbackShader shader = NewShaderTests.createFallback(name, framebuffer, framebuffer,
 				key.getAlphaTest(), key.getVertexFormat(), BlendModeOverride.OFF, this, key.getFogMode(),
@@ -407,7 +407,7 @@ private ShaderInstance createFallbackShadowShader(String name, ShaderKey key) th
 
 	private ShaderInstance createShadowShader(String name, ProgramSource source, AlphaTest fallbackAlpha,
 											  VertexFormat vertexFormat, boolean isBeacon, boolean isFullbright) throws IOException {
-		GlFramebuffer framebuffer = ((ShadowRenderer) this.shadowMapRenderer).getFramebuffer();
+		GlFramebuffer framebuffer = this.shadowMapRenderer.getRenderTargets().getFramebuffer();
 
 		ExtendedShader extendedShader = NewShaderTests.create(name, source, framebuffer, framebuffer, baseline,
 				fallbackAlpha, vertexFormat, updateNotifier, this, FogMode.ENABLED, isBeacon, isFullbright);

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -572,7 +572,7 @@ private static void destroyEverything() {
 		}
 	}
 
-	public static DimensionId lastDimension = DimensionId.OVERWORLD;
+	public static DimensionId lastDimension = null;
 
 	public static DimensionId getCurrentDimension() {
 		ClientLevel level = Minecraft.getInstance().level;

File: src/main/java/net/coderbot/iris/mixin/MixinGameRenderer.java
Patch:
@@ -360,7 +360,9 @@ public class MixinGameRenderer {
 			"getRendertypeTextSeeThroughShader"
 	}, at = @At("HEAD"), cancellable = true)
 	private static void iris$overrideTextShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (isRenderingWorld() && !ShadowRenderer.ACTIVE) {
+		if (ShadowRenderer.ACTIVE) {
+			override(ShaderKey.SHADOW_TEXT, cir);
+		} else if (isRenderingWorld()) {
 			override(ShaderKey.TEXT, cir);
 		}
 	}

File: src/main/java/net/coderbot/iris/pipeline/newshader/ShaderKey.java
Patch:
@@ -58,7 +58,8 @@ public enum ShaderKey {
 	SHADOW_TERRAIN_CUTOUT  (ProgramId.Shadow,      AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.TERRAIN,                       FogMode.OFF    ),
 	SHADOW_ENTITIES_CUTOUT (ProgramId.Shadow,      AlphaTests.ONE_TENTH_ALPHA, IrisVertexFormats.ENTITY,                        FogMode.OFF    ),
 	SHADOW_BEACON_BEAM     (ProgramId.Shadow,      AlphaTests.OFF,             DefaultVertexFormat.BLOCK,                       FogMode.OFF    ),
-	SHADOW_LINES           (ProgramId.Shadow,      AlphaTests.OFF,             DefaultVertexFormat.POSITION_COLOR_NORMAL,       FogMode.OFF    );
+	SHADOW_LINES           (ProgramId.Shadow,      AlphaTests.OFF,             DefaultVertexFormat.POSITION_COLOR_NORMAL,       FogMode.OFF    ),
+	SHADOW_TEXT           (ProgramId.Shadow,       AlphaTests.NON_ZERO_ALPHA,  DefaultVertexFormat.POSITION_COLOR_TEX_LIGHTMAP, FogMode.OFF    );
 
 	private final ProgramId program;
 	private final AlphaTest alphaTest;

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -565,6 +565,8 @@ public void beginTranslucents() {
 		IrisRenderSystem.copyTexImage2D(GL20C.GL_TEXTURE_2D, 0, GL20C.GL_DEPTH_COMPONENT, 0, 0, renderTargets.getCurrentWidth(), renderTargets.getCurrentHeight(), 0);
 		GlStateManager._bindTexture(0);
 
+		centerDepthSampler.updateSample();
+
 		deferredRenderer.renderAll();
 
 		RenderSystem.enableBlend();

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -170,7 +170,7 @@ public NewWorldRenderingPipeline(ProgramSet programSet) throws IOException {
 
 		BufferFlipper flipper = new BufferFlipper();
 
-		this.centerDepthSampler = new CenterDepthSampler(renderTargets, updateNotifier);
+		this.centerDepthSampler = new CenterDepthSampler(renderTargets);
 
 		Supplier<ShadowMapRenderer> shadowMapRendererSupplier = () -> {
 			createShadowMapRenderer.run();

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -209,7 +209,7 @@ public DeferredWorldRenderingPipeline(ProgramSet programs) {
 
 		BufferFlipper flipper = new BufferFlipper();
 
-		this.centerDepthSampler = new CenterDepthSampler(renderTargets, updateNotifier);
+		this.centerDepthSampler = new CenterDepthSampler(renderTargets);
 
 		Supplier<ShadowMapRenderer> shadowMapRendererSupplier = () -> {
 			createShadowMapRenderer.run();
@@ -799,6 +799,8 @@ public void beginTranslucents() {
 		IrisRenderSystem.copyTexImage2D(GL20C.GL_TEXTURE_2D, 0, GL20C.GL_DEPTH_COMPONENT, 0, 0, renderTargets.getCurrentWidth(), renderTargets.getCurrentHeight(), 0);
 		GlStateManager._bindTexture(0);
 
+		centerDepthSampler.updateSample();
+
 		deferredRenderer.renderAll();
 		Program.unbind();
 

File: src/main/java/net/coderbot/iris/mixin/texture/AnimationMetadataSectionAccessor.java
Patch:
@@ -2,19 +2,22 @@
 
 import net.minecraft.client.resources.metadata.animation.AnimationMetadataSection;
 import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Mutable;
 import org.spongepowered.asm.mixin.gen.Accessor;
 
 @Mixin(AnimationMetadataSection.class)
 public interface AnimationMetadataSectionAccessor {
 	@Accessor("frameWidth")
 	int getFrameWidth();
 
+	@Mutable
 	@Accessor("frameWidth")
 	void setFrameWidth(int frameWidth);
 
 	@Accessor("frameHeight")
 	int getFrameHeight();
 
+	@Mutable
 	@Accessor("frameHeight")
 	void setFrameHeight(int frameHeight);
 }

File: src/main/java/net/coderbot/iris/mixin/texture/MixinAbstractTexture.java
Patch:
@@ -15,7 +15,7 @@ public class MixinAbstractTexture {
 	protected int id;
 
 	@Inject(method = "getId()I", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/platform/TextureUtil;generateTextureId()I", shift = Shift.BY, by = 2))
-	private void onGenerateId(CallbackInfoReturnable<Integer> cir) {
+	private void iris$onGenerateId(CallbackInfoReturnable<Integer> cir) {
 		TextureTracker.INSTANCE.trackTexture(id, (AbstractTexture) (Object) this);
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/texture/MixinTextureAtlas.java
Patch:
@@ -53,7 +53,7 @@ public void setMipLevel(int mipLevel) {
 	}
 
 	@Inject(method = "load(Lnet/minecraft/server/packs/resources/ResourceManager;)V", at = @At("TAIL"))
-	private void onTailLoad(ResourceManager resourceManager, CallbackInfo ci) {
+	private void iris$onTailLoad(ResourceManager resourceManager, CallbackInfo ci) {
 		AtlasInfoGatherer.resetInfo((TextureAtlas) (Object) this);
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/texture/MixinTextureManager.java
Patch:
@@ -14,13 +14,13 @@
 @Mixin(TextureManager.class)
 public class MixinTextureManager {
 	@Inject(method = "lambda$reload$4(Lnet/minecraft/server/packs/resources/ResourceManager;Ljava/util/concurrent/Executor;Ljava/lang/Void;)V", at = @At("TAIL"))
-	private void onTailReloadLambda(ResourceManager resourceManager, Executor applyExecutor, Void void1, CallbackInfo ci) {
+	private void iris$onTailReloadLambda(ResourceManager resourceManager, Executor applyExecutor, Void void1, CallbackInfo ci) {
 		TextureFormatLoader.reload(resourceManager);
 		PBRTextureManager.INSTANCE.clear();
 	}
 
 	@Inject(method = "close()V", at = @At("TAIL"), remap = false)
-	private void onTailClose(CallbackInfo ci) {
+	private void iris$onTailClose(CallbackInfo ci) {
 		PBRTextureManager.INSTANCE.close();
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/texture/pbr/MixinTextureAtlas.java
Patch:
@@ -16,7 +16,7 @@ public abstract class MixinTextureAtlas extends AbstractTexture implements Textu
 	private PBRAtlasHolder pbrHolder;
 
 	@Inject(method = "cycleAnimationFrames()V", at = @At("TAIL"))
-	private void onTailCycleAnimationFrames(CallbackInfo ci) {
+	private void iris$onTailCycleAnimationFrames(CallbackInfo ci) {
 		if (pbrHolder != null) {
 			pbrHolder.cycleAnimationFrames();
 		}

File: src/main/java/net/coderbot/iris/mixin/texture/pbr/MixinTextureAtlasSprite.java
Patch:
@@ -15,7 +15,7 @@ public class MixinTextureAtlasSprite implements TextureAtlasSpriteExtension {
 	private PBRSpriteHolder pbrHolder;
 
 	@Inject(method = "close()V", at = @At("TAIL"), remap = false)
-	private void onTailClose(CallbackInfo ci) {
+	private void iris$onTailClose(CallbackInfo ci) {
 		if (pbrHolder != null) {
 			pbrHolder.close();
 		}

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -209,7 +209,7 @@ public DeferredWorldRenderingPipeline(ProgramSet programs) {
 
 		BufferFlipper flipper = new BufferFlipper();
 
-		this.centerDepthSampler = new CenterDepthSampler(renderTargets, updateNotifier);
+		this.centerDepthSampler = new CenterDepthSampler(renderTargets);
 
 		Supplier<ShadowMapRenderer> shadowMapRendererSupplier = () -> {
 			createShadowMapRenderer.run();
@@ -799,6 +799,8 @@ public void beginTranslucents() {
 		IrisRenderSystem.copyTexImage2D(GL20C.GL_TEXTURE_2D, 0, GL20C.GL_DEPTH_COMPONENT, 0, 0, renderTargets.getCurrentWidth(), renderTargets.getCurrentHeight(), 0);
 		GlStateManager._bindTexture(0);
 
+		centerDepthSampler.updateSample();
+
 		deferredRenderer.renderAll();
 		Program.unbind();
 

File: src/main/java/net/coderbot/iris/texture/format/LabPBRTextureFormat.java
Patch:
@@ -58,6 +58,6 @@ public boolean equals(Object obj) {
 		if (getClass() != obj.getClass())
 			return false;
 		LabPBRTextureFormat other = (LabPBRTextureFormat) obj;
-		return name == other.name && Objects.equals(version, other.version);
+		return Objects.equals(name, other.name) && Objects.equals(version, other.version);
 	}
 }

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -6,6 +6,7 @@
 import net.coderbot.iris.compat.sodium.SodiumVersionCheck;
 import net.coderbot.iris.config.IrisConfig;
 import net.coderbot.iris.gl.GLDebug;
+import net.coderbot.iris.gl.shader.StandardMacros;
 import net.coderbot.iris.gui.screen.ShaderPackScreen;
 import net.coderbot.iris.pipeline.DeferredWorldRenderingPipeline;
 import net.coderbot.iris.pipeline.FixedFunctionWorldRenderingPipeline;
@@ -342,7 +343,7 @@ private static boolean loadExternalShaderpack(String name) {
 		resetShaderPackOptions = false;
 
 		try {
-			currentPack = new ShaderPack(shaderPackPath, changedConfigs);
+			currentPack = new ShaderPack(shaderPackPath, changedConfigs, StandardMacros.createDefines());
 
 			MutableOptionValues changedConfigsValues = currentPack.getShaderPackOptions().getOptionValues().mutableCopy();
 

File: src/main/java/net/coderbot/iris/pipeline/Patcher.java
Patch:
@@ -17,7 +17,7 @@ public static Patcher getInstance() {
 
   public String patchVanilla(
       String source, ShaderType type, AlphaTest alpha,
-      boolean hasChunkOffset, ShaderAttributeInputs inputs);
+      boolean hasChunkOffset, ShaderAttributeInputs inputs, boolean hasGeometry);
 
   public String patchSodium(String source, ShaderType type, AlphaTest alpha,
       ShaderAttributeInputs inputs, float positionScale, float positionOffset, float textureScale);

File: src/main/java/net/coderbot/iris/mixin/MixinOptions_Entrypoint.java
Patch:
@@ -8,7 +8,8 @@
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
-@Mixin(Options.class)
+// Uses priority of 999 to inject before Fabric key binding API.
+@Mixin(value = Options.class, priority = 999)
 public class MixinOptions_Entrypoint {
 	@Unique
 	private static boolean iris$initialized;

File: src/main/java/net/coderbot/iris/mixin/bettermipmaps/MixinTextureAtlasSprite.java
Patch:
@@ -35,8 +35,8 @@ public class MixinTextureAtlasSprite {
 	// support Forge, since this works well on Fabric too, it's fine to ensure that the diff between Fabric and Forge
 	// can remain minimal. Being less dependent on specific details of Fabric is good, since it means we can be more
 	// cross-platform.
-	@ModifyVariable(method = "<init>", at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/client/renderer/texture/MipmapGenerator;generateMipLevels(Lcom/mojang/blaze3d/platform/NativeImage;I)[Lcom/mojang/blaze3d/platform/NativeImage;"))
+	@ModifyVariable(method = "<init>", at = @At(value = "FIELD",
+		target = "Lnet/minecraft/client/renderer/texture/TextureAtlasSprite;metadata:Lnet/minecraft/client/resources/metadata/animation/AnimationMetadataSection;"), argsOnly = true)
 	private NativeImage iris$beforeGenerateMipLevels(NativeImage nativeImage) {
 		// We're injecting after the "info" field has been set, so this is safe even though we're in a constructor.
 		ResourceLocation name = Objects.requireNonNull(info).name();

File: src/main/java/net/coderbot/iris/mixin/texture/MixinTextureManager.java
Patch:
@@ -1,5 +1,6 @@
-package net.coderbot.iris.mixin.texture.pbr;
+package net.coderbot.iris.mixin.texture;
 
+import net.coderbot.iris.texture.format.TextureFormatLoader;
 import net.coderbot.iris.texture.pbr.PBRTextureManager;
 import net.minecraft.client.renderer.texture.TextureManager;
 import net.minecraft.server.packs.resources.ResourceManager;
@@ -14,6 +15,7 @@
 public class MixinTextureManager {
 	@Inject(method = "lambda$reload$4(Lnet/minecraft/server/packs/resources/ResourceManager;Ljava/util/concurrent/Executor;Ljava/lang/Void;)V", at = @At("TAIL"))
 	private void onTailReloadLambda(ResourceManager resourceManager, Executor applyExecutor, Void void1, CallbackInfo ci) {
+		TextureFormatLoader.reload(resourceManager);
 		PBRTextureManager.INSTANCE.clear();
 	}
 

File: src/main/java/net/coderbot/iris/texture/format/TextureFormatLoader.java
Patch:
@@ -20,7 +20,6 @@ public static TextureFormat getFormat() {
 		return format;
 	}
 
-	// TODO: call this from somewhere
 	public static void reload(ResourceManager resourceManager) {
 		TextureFormat newFormat = loadFormat(resourceManager);
 		boolean didFormatChange = !Objects.equals(format, newFormat);

File: src/main/java/net/coderbot/iris/texture/mipmap/CustomMipmapGenerator.java
Patch:
@@ -1,13 +1,14 @@
 package net.coderbot.iris.texture.mipmap;
 
 import com.mojang.blaze3d.platform.NativeImage;
+import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 import org.jetbrains.annotations.Nullable;
 
 public interface CustomMipmapGenerator {
 	NativeImage[] generateMipLevels(NativeImage image, int mipLevel);
 
 	public interface Provider {
 		@Nullable
-		CustomMipmapGenerator getMipmapGenerator();
+		CustomMipmapGenerator getMipmapGenerator(TextureAtlasSprite.Info info, int atlasWidth, int atlasHeight);
 	}
 }

File: src/main/java/net/coderbot/batchedentityrendering/mixin/MixinRenderBuffers.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.batchedentityrendering.mixin;
 
 import net.coderbot.batchedentityrendering.impl.DrawCallTrackingRenderBuffers;
-import net.coderbot.batchedentityrendering.impl.RenderBuffersExt;
 import net.coderbot.batchedentityrendering.impl.FullyBufferedMultiBufferSource;
 import net.coderbot.batchedentityrendering.impl.MemoryTrackingBuffer;
 import net.coderbot.batchedentityrendering.impl.MemoryTrackingRenderBuffers;
+import net.coderbot.batchedentityrendering.impl.RenderBuffersExt;
 import net.minecraft.client.renderer.MultiBufferSource;
 import net.minecraft.client.renderer.OutlineBufferSource;
 import net.minecraft.client.renderer.RenderBuffers;

File: src/main/java/net/coderbot/iris/IrisLogging.java
Patch:
@@ -7,7 +7,7 @@
 public class IrisLogging {
 	public static boolean ENABLE_SPAM = false; // FabricLoader.getInstance().isDevelopmentEnvironment();
 
-	private Logger logger;
+	private final Logger logger;
 
 	public IrisLogging(String loggerName) {
 		this.logger = LoggerFactory.getLogger(loggerName);

File: src/main/java/net/coderbot/iris/config/IrisConfig.java
Patch:
@@ -1,14 +1,14 @@
 package net.coderbot.iris.config;
 
+import net.coderbot.iris.Iris;
+import net.coderbot.iris.gui.option.IrisVideoSettings;
+
 import java.io.IOException;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.Optional;
 import java.util.Properties;
 
-import net.coderbot.iris.Iris;
-import net.coderbot.iris.gui.option.IrisVideoSettings;
-
 /**
  * A class dedicated to storing the config values of shaderpacks. Right now it only stores the path to the current shaderpack
  */

File: src/main/java/net/coderbot/iris/gl/blending/AlphaTestFunction.java
Patch:
@@ -1,9 +1,9 @@
 package net.coderbot.iris.gl.blending;
 
-import java.util.Optional;
-
 import org.lwjgl.opengl.GL11;
 
+import java.util.Optional;
+
 public enum AlphaTestFunction {
 	NEVER(GL11.GL_NEVER, null),
 	LESS(GL11.GL_LESS, "<"),

File: src/main/java/net/coderbot/iris/gl/blending/BlendModeFunction.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.iris.gl.blending;
 
-import java.util.Optional;
-
 import net.coderbot.iris.Iris;
 import org.lwjgl.opengl.GL11;
 
+import java.util.Optional;
+
 public enum BlendModeFunction {
 	ZERO(GL11.GL_ZERO),
 	ONE(GL11.GL_ONE),

File: src/main/java/net/coderbot/iris/gl/image/ImageBinding.java
Patch:
@@ -1,7 +1,6 @@
 package net.coderbot.iris.gl.image;
 
 import net.coderbot.iris.gl.IrisRenderSystem;
-import org.lwjgl.opengl.GL;
 import org.lwjgl.opengl.GL42C;
 
 import java.util.function.IntSupplier;

File: src/main/java/net/coderbot/iris/gl/program/ProgramBuilder.java
Patch:
@@ -12,10 +12,8 @@
 import net.coderbot.iris.gl.shader.StandardMacros;
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
 import net.coderbot.iris.pipeline.HandRenderer;
-
 import org.jetbrains.annotations.Nullable;
 import org.lwjgl.opengl.GL20C;
-import org.lwjgl.opengl.GL21C;
 
 import java.util.function.IntSupplier;
 

File: src/main/java/net/coderbot/iris/gl/shader/ShaderWorkarounds.java
Patch:
@@ -14,13 +14,13 @@
 
 package net.coderbot.iris.gl.shader;
 
-import java.nio.ByteBuffer;
-
 import org.lwjgl.PointerBuffer;
 import org.lwjgl.opengl.GL20C;
 import org.lwjgl.system.MemoryStack;
 import org.lwjgl.system.MemoryUtil;
 
+import java.nio.ByteBuffer;
+
 /**
  * Contains a workaround for a crash in nglShaderSource on some AMD drivers. Copied from the following Canvas commit:
  * https://github.com/grondag/canvas/commit/820bf754092ccaf8d0c169620c2ff575722d7d96

File: src/main/java/net/coderbot/iris/gl/texture/InternalTextureFormat.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.gl.texture;
 
-import java.util.Optional;
-
 import net.coderbot.iris.gl.GlVersion;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL30C;
 import org.lwjgl.opengl.GL31C;
 
+import java.util.Optional;
+
 public enum InternalTextureFormat {
 	// Default
 	// TODO: This technically shouldn't be exposed to shaders since it's not in the specification, it's the default anyways

File: src/main/java/net/coderbot/iris/gl/texture/PixelFormat.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.gl.texture;
 
-import java.util.Optional;
-
 import net.coderbot.iris.gl.GlVersion;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL12C;
 import org.lwjgl.opengl.GL30C;
 
+import java.util.Optional;
+
 public enum PixelFormat {
 	RED(GL11C.GL_RED, GlVersion.GL_11),
 	RG(GL30C.GL_RG, GlVersion.GL_30),

File: src/main/java/net/coderbot/iris/gl/texture/PixelType.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.gl.texture;
 
-import java.util.Optional;
-
 import net.coderbot.iris.gl.GlVersion;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL12C;
 import org.lwjgl.opengl.GL30C;
 
+import java.util.Optional;
+
 public enum PixelType {
 	BYTE(GL11C.GL_BYTE, GlVersion.GL_11),
 	SHORT(GL11C.GL_SHORT, GlVersion.GL_11),

File: src/main/java/net/coderbot/iris/gl/uniform/JomlMatrixUniform.java
Patch:
@@ -8,7 +8,7 @@
 import java.util.function.Supplier;
 
 public class JomlMatrixUniform extends Uniform {
-	private FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
+	private final FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
 	private Matrix4f cachedValue;
 	private final Supplier<Matrix4f> value;
 

File: src/main/java/net/coderbot/iris/gl/uniform/MatrixFromFloatArrayUniform.java
Patch:
@@ -8,7 +8,7 @@
 import java.util.function.Supplier;
 
 public class MatrixFromFloatArrayUniform extends Uniform {
-	private FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
+	private final FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
 	private float[] cachedValue;
 	private final Supplier<float[]> value;
 

File: src/main/java/net/coderbot/iris/gl/uniform/MatrixUniform.java
Patch:
@@ -8,7 +8,7 @@
 import java.util.function.Supplier;
 
 public class MatrixUniform extends Uniform {
-	private FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
+	private final FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
 	private Matrix4f cachedValue;
 	private final Supplier<Matrix4f> value;
 

File: src/main/java/net/coderbot/iris/gl/uniform/Vector2Uniform.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.iris.gl.uniform;
 
-import java.util.function.Supplier;
-
 import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector2f;
 
+import java.util.function.Supplier;
+
 public class Vector2Uniform extends Uniform {
 	private Vector2f cachedValue;
 	private final Supplier<Vector2f> value;

File: src/main/java/net/coderbot/iris/gl/uniform/Vector3Uniform.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.gl.uniform;
 
-import java.util.function.Supplier;
-
 import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector3d;
 import net.coderbot.iris.vendored.joml.Vector3f;
 import net.coderbot.iris.vendored.joml.Vector4f;
 
+import java.util.function.Supplier;
+
 public class Vector3Uniform extends Uniform {
 	private final Vector3f cachedValue;
 	private final Supplier<Vector3f> value;

File: src/main/java/net/coderbot/iris/gl/uniform/Vector4IntegerJomlUniform.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector4i;
-import org.lwjgl.opengl.GL20;
 
 import java.util.function.Supplier;
 

File: src/main/java/net/coderbot/iris/gl/uniform/Vector4Uniform.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.iris.gl.uniform;
 
-import java.util.function.Supplier;
-
 import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector4f;
 
+import java.util.function.Supplier;
+
 public class Vector4Uniform extends Uniform {
 	private final Vector4f cachedValue;
 	private final Supplier<Vector4f> value;

File: src/main/java/net/coderbot/iris/gui/element/widget/BooleanElementWidget.java
Patch:
@@ -5,7 +5,6 @@
 import net.coderbot.iris.gui.GuiUtil;
 import net.coderbot.iris.gui.NavigationController;
 import net.coderbot.iris.gui.screen.ShaderPackScreen;
-import net.coderbot.iris.shaderpack.OptionalBoolean;
 import net.coderbot.iris.shaderpack.option.BooleanOption;
 import net.coderbot.iris.shaderpack.option.menu.OptionMenuBooleanOptionElement;
 import net.minecraft.ChatFormatting;

File: src/main/java/net/coderbot/iris/gui/element/widget/OptionMenuConstructor.java
Patch:
@@ -3,8 +3,8 @@
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.gui.GuiUtil;
 import net.coderbot.iris.gui.NavigationController;
-import net.coderbot.iris.gui.element.screen.ElementWidgetScreenData;
 import net.coderbot.iris.gui.element.ShaderPackOptionList;
+import net.coderbot.iris.gui.element.screen.ElementWidgetScreenData;
 import net.coderbot.iris.gui.screen.ShaderPackScreen;
 import net.coderbot.iris.shaderpack.option.menu.OptionMenuBooleanOptionElement;
 import net.coderbot.iris.shaderpack.option.menu.OptionMenuContainer;

File: src/main/java/net/coderbot/iris/gui/element/widget/StringElementWidget.java
Patch:
@@ -12,7 +12,6 @@
 
 
 import java.util.List;
-import java.util.Optional;
 
 public class StringElementWidget extends BaseOptionElementWidget<OptionMenuStringOptionElement> {
 	protected final StringOption option;

File: src/main/java/net/coderbot/iris/layer/IrisRenderTypeWrapper.java
Patch:
@@ -1,13 +1,13 @@
 package net.coderbot.iris.layer;
 
-import java.util.Objects;
-import java.util.Optional;
-
 import net.coderbot.batchedentityrendering.impl.WrappableRenderType;
 import net.coderbot.iris.mixin.rendertype.RenderTypeAccessor;
 import net.minecraft.client.renderer.RenderType;
 import org.jetbrains.annotations.Nullable;
 
+import java.util.Objects;
+import java.util.Optional;
+
 public class IrisRenderTypeWrapper extends RenderType implements WrappableRenderType {
 	private final UseProgramRenderStateShard useProgram;
 	private final RenderType wrapped;

File: src/main/java/net/coderbot/iris/layer/UseProgramRenderStateShard.java
Patch:
@@ -1,8 +1,9 @@
 package net.coderbot.iris.layer;
 
-import java.util.Objects;
 import net.minecraft.client.renderer.RenderStateShard;
 
+import java.util.Objects;
+
 public class UseProgramRenderStateShard extends RenderStateShard {
 	private final GbufferProgram program;
 

File: src/main/java/net/coderbot/iris/mixin/DimensionTypeAccessor.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.iris.mixin;
 
+import net.minecraft.world.level.dimension.DimensionType;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
 
 import java.util.OptionalLong;
-import net.minecraft.world.level.dimension.DimensionType;
 
 @Mixin(DimensionType.class)
 public interface DimensionTypeAccessor {

File: src/main/java/net/coderbot/iris/mixin/GameRendererAccessor.java
Patch:
@@ -1,14 +1,12 @@
 package net.coderbot.iris.mixin;
 
 import com.mojang.blaze3d.vertex.PoseStack;
-
 import net.minecraft.client.Camera;
+import net.minecraft.client.renderer.GameRenderer;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
 import org.spongepowered.asm.mixin.gen.Invoker;
 
-import net.minecraft.client.renderer.GameRenderer;
-
 @Mixin(GameRenderer.class)
 public interface GameRendererAccessor {
 	@Accessor

File: src/main/java/net/coderbot/iris/mixin/MixinGlStateManager_AlphaTestOverride.java
Patch:
@@ -1,7 +1,6 @@
 package net.coderbot.iris.mixin;
 
 import com.mojang.blaze3d.platform.GlStateManager;
-
 import net.coderbot.iris.gl.blending.AlphaTestStorage;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;

File: src/main/java/net/coderbot/iris/mixin/MixinMaxFpsCrashFix.java
Patch:
@@ -6,8 +6,6 @@
 import org.spongepowered.asm.mixin.injection.Redirect;
 import org.spongepowered.asm.mixin.injection.Slice;
 
-import net.minecraft.client.Options;
-
 /**
  * A workaround for when OptiFine has set the maxFps to zero in options.txt
  * 

File: src/main/java/net/coderbot/iris/mixin/MixinSystemReport.java
Patch:
@@ -6,7 +6,6 @@
 import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
-
 import net.coderbot.iris.Iris;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;

File: src/main/java/net/coderbot/iris/mixin/rendertype/RenderTypeAccessor.java
Patch:
@@ -1,8 +1,8 @@
 package net.coderbot.iris.mixin.rendertype;
 
+import net.minecraft.client.renderer.RenderType;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
-import net.minecraft.client.renderer.RenderType;
 
 @Mixin(RenderType.class)
 public interface RenderTypeAccessor {

File: src/main/java/net/coderbot/iris/mixin/shadows/MixinPreventRebuildNearInShadowPass.java
Patch:
@@ -7,7 +7,6 @@
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.LevelRenderer;
 import net.minecraft.client.renderer.culling.Frustum;
-import net.minecraft.world.level.block.entity.BlockEntity;
 import org.spongepowered.asm.mixin.Final;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Shadow;

File: src/main/java/net/coderbot/iris/mixin/statelisteners/MixinGlStateManager.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.mojang.blaze3d.platform.GlStateManager;
 import net.coderbot.iris.gl.state.StateUpdateNotifiers;
-import net.coderbot.iris.gl.uniform.ValueUpdateNotifier;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -45,7 +45,6 @@
 import net.coderbot.iris.vendored.joml.Vector4f;
 import net.minecraft.client.Camera;
 import net.minecraft.client.Minecraft;
-import net.minecraft.resources.ResourceLocation;
 import org.jetbrains.annotations.Nullable;
 import org.lwjgl.opengl.GL15C;
 import org.lwjgl.opengl.GL20C;

File: src/main/java/net/coderbot/iris/pipeline/FixedFunctionWorldRenderingPipeline.java
Patch:
@@ -7,6 +7,7 @@
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.minecraft.client.Camera;
 import net.minecraft.client.Minecraft;
+
 import java.util.List;
 import java.util.OptionalInt;
 

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPhase.java
Patch:
@@ -24,5 +24,5 @@ public enum WorldRenderingPhase {
 	CLOUDS,
 	RAIN_SNOW,
 	WORLD_BORDER,
-	HAND_TRANSLUCENT;
+	HAND_TRANSLUCENT
 }

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPipeline.java
Patch:
@@ -4,6 +4,7 @@
 import net.coderbot.iris.mixin.LevelRendererAccessor;
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.minecraft.client.Camera;
+
 import java.util.List;
 import java.util.OptionalInt;
 

File: src/main/java/net/coderbot/iris/rendertarget/DepthTexture.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.rendertarget;
 
-import java.nio.ByteBuffer;
-
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.gl.GlResource;

File: src/main/java/net/coderbot/iris/rendertarget/NativeImageBackedCustomTexture.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.rendertarget;
 
-import com.mojang.blaze3d.platform.GlStateManager;
+import com.mojang.blaze3d.platform.NativeImage;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.shaderpack.texture.CustomTextureData;
 import net.minecraft.client.renderer.texture.DynamicTexture;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL13C;
-import com.mojang.blaze3d.platform.NativeImage;
+
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.Objects;

File: src/main/java/net/coderbot/iris/rendertarget/NativeImageBackedNoiseTexture.java
Patch:
@@ -1,9 +1,10 @@
 package net.coderbot.iris.rendertarget;
 
 import com.mojang.blaze3d.platform.NativeImage;
+import net.minecraft.client.renderer.texture.DynamicTexture;
+
 import java.util.Objects;
 import java.util.Random;
-import net.minecraft.client.renderer.texture.DynamicTexture;
 
 public class NativeImageBackedNoiseTexture extends DynamicTexture {
 	public NativeImageBackedNoiseTexture(int size) {

File: src/main/java/net/coderbot/iris/rendertarget/NoiseTexture.java
Patch:
@@ -1,8 +1,5 @@
 package net.coderbot.iris.rendertarget;
 
-import java.nio.ByteBuffer;
-import java.util.Random;
-
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.gl.GlResource;
@@ -12,6 +9,9 @@
 import org.lwjgl.opengl.GL13C;
 import org.lwjgl.opengl.GL20C;
 
+import java.nio.ByteBuffer;
+import java.util.Random;
+
 /**
  * An extremely simple noise texture. Each color channel contains a uniform random value from 0 to 255. Essentially just
  * dumps an array of random bytes into a texture and calls it a day, literally could not be any simpler than that.

File: src/main/java/net/coderbot/iris/rendertarget/RenderTarget.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.rendertarget;
 
-import java.nio.IntBuffer;
-
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
@@ -10,6 +8,8 @@
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL13C;
 
+import java.nio.IntBuffer;
+
 public class RenderTarget {
 	private final InternalTextureFormat internalFormat;
 	private final PixelFormat format;

File: src/main/java/net/coderbot/iris/rendertarget/SingleColorTexture.java
Patch:
@@ -10,7 +10,6 @@
 import org.lwjgl.opengl.GL13C;
 
 import java.nio.ByteBuffer;
-import java.nio.IntBuffer;
 
 public class SingleColorTexture extends GlResource {
 	public SingleColorTexture(int red, int green, int blue, int alpha) {

File: src/main/java/net/coderbot/iris/samplers/IrisSamplers.java
Patch:
@@ -9,6 +9,7 @@
 import net.coderbot.iris.shadows.ShadowMapRenderer;
 import net.coderbot.iris.texunits.TextureUnit;
 import net.minecraft.client.renderer.texture.AbstractTexture;
+
 import java.util.function.IntSupplier;
 import java.util.function.Supplier;
 

File: src/main/java/net/coderbot/iris/shaderpack/ShaderPack.java
Patch:
@@ -26,7 +26,6 @@
 import net.coderbot.iris.shaderpack.texture.TextureStage;
 import net.coderbot.iris.shaderpack.transform.line.LineTransform;
 import net.coderbot.iris.shaderpack.transform.line.VersionDirectiveNormalizer;
-import org.apache.logging.log4j.Level;
 import org.jetbrains.annotations.Nullable;
 
 import java.io.BufferedReader;

File: src/main/java/net/coderbot/iris/shaderpack/loading/SourceSet.java
Patch:
@@ -1,8 +1,5 @@
 package net.coderbot.iris.shaderpack.loading;
 
-import net.coderbot.iris.shaderpack.ProgramSource;
-
-import java.util.EnumMap;
 import java.util.function.Function;
 
 // TODO: Actually implement this class.

File: src/main/java/net/coderbot/iris/shaderpack/option/OptionSet.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.iris.shaderpack.option;
 
-import net.coderbot.iris.Iris;
 import com.google.common.collect.ImmutableMap;
+import net.coderbot.iris.Iris;
 
 import java.util.HashMap;
 import java.util.Map;

File: src/main/java/net/coderbot/iris/shaderpack/option/menu/OptionMenuElementScreen.java
Patch:
@@ -1,7 +1,6 @@
 package net.coderbot.iris.shaderpack.option.menu;
 
 import net.coderbot.iris.Iris;
-
 import net.coderbot.iris.shaderpack.ShaderProperties;
 import net.coderbot.iris.shaderpack.option.ShaderPackOptions;
 

File: src/main/java/net/coderbot/iris/shaderpack/preprocessor/PropertiesPreprocessor.java
Patch:
@@ -9,13 +9,12 @@
 import org.anarres.cpp.StringLexerSource;
 import org.anarres.cpp.Token;
 
-import java.nio.file.Path;
-import java.util.Arrays;
-import java.util.stream.Collectors;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.stream.Collectors;
 
 public class PropertiesPreprocessor {
 	// Derived from ShaderProcessor.glslPreprocessSource, which is derived from GlShader from Canvas, licenced under LGPL

File: src/main/java/net/coderbot/iris/shaderpack/transform/BuiltinUniformReplacementTransformer.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.iris.shaderpack.transform;
 
 public class BuiltinUniformReplacementTransformer {
-	private String normalizedLightmapCoords;
+	private final String normalizedLightmapCoords;
 
 	private static final String NORMALIZED_PLACEHOLDER = "iris_NormalizedLightmapCoords";
 

File: src/main/java/net/coderbot/iris/shadow/ShadowMatrices.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.mojang.math.Matrix4f;
 import com.mojang.math.Vector3f;
+
 import java.nio.FloatBuffer;
 
 public class ShadowMatrices {

File: src/main/java/net/coderbot/iris/shadows/EmptyShadowMapRenderer.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
+import net.coderbot.iris.Iris;
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
 import net.coderbot.iris.mixin.LevelRendererAccessor;
 import net.minecraft.client.Camera;
@@ -54,7 +55,7 @@ public void renderShadows(LevelRendererAccessor levelRenderer, Camera playerCame
 
 	@Override
 	public void addDebugText(List<String> messages) {
-		messages.add("[Iris] Shadow Maps: not used by shader pack");
+		messages.add("[" + Iris.MODNAME + "] Shadow Maps: not used by shader pack");
 	}
 
 	public int getDepthTextureId() {

File: src/main/java/net/coderbot/iris/uniforms/CameraUniforms.java
Patch:
@@ -1,13 +1,13 @@
 package net.coderbot.iris.uniforms;
 
-import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.ONCE;
-import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.PER_FRAME;
-
 import net.coderbot.iris.JomlConversions;
 import net.coderbot.iris.gl.uniform.UniformHolder;
 import net.coderbot.iris.vendored.joml.Vector3d;
 import net.minecraft.client.Minecraft;
 
+import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.ONCE;
+import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.PER_FRAME;
+
 /**
  * @see <a href="https://github.com/IrisShaders/ShaderDoc/blob/master/uniforms.md#camera">Uniforms: Camera</a>
  */

File: src/main/java/net/coderbot/iris/uniforms/CapturedRenderingState.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.mojang.math.Matrix4f;
 import net.coderbot.iris.gl.uniform.ValueUpdateNotifier;
-
 import net.coderbot.iris.vendored.joml.Vector3d;
 import net.minecraft.client.Minecraft;
 

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -1,8 +1,5 @@
 package net.coderbot.iris.uniforms;
 
-import java.util.Objects;
-import java.util.function.IntSupplier;
-
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.JomlConversions;
@@ -38,6 +35,9 @@
 import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
 
+import java.util.Objects;
+import java.util.function.IntSupplier;
+
 import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.ONCE;
 import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.PER_FRAME;
 import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.PER_TICK;

File: src/main/java/net/coderbot/iris/uniforms/HardcodedCustomUniforms.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.uniforms;
 
-import net.coderbot.iris.Iris;
-import net.coderbot.iris.gl.uniform.FloatSupplier;
 import net.coderbot.iris.gl.uniform.UniformHolder;
 import net.coderbot.iris.gl.uniform.UniformUpdateFrequency;
 import net.coderbot.iris.mixin.DimensionTypeAccessor;

File: src/main/java/net/coderbot/iris/uniforms/IdMapUniforms.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.uniforms;
 
-import java.util.function.IntSupplier;
-
 import it.unimi.dsi.fastutil.objects.Object2IntFunction;
 import net.coderbot.iris.gl.uniform.DynamicUniformHolder;
 import net.coderbot.iris.gl.uniform.UniformUpdateFrequency;
@@ -13,6 +11,8 @@
 import net.minecraft.world.InteractionHand;
 import net.minecraft.world.item.ItemStack;
 
+import java.util.function.IntSupplier;
+
 public final class IdMapUniforms {
 
 	private IdMapUniforms() {

File: src/main/java/net/coderbot/iris/uniforms/transforms/SmoothedVec2f.java
Patch:
@@ -3,6 +3,7 @@
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.coderbot.iris.vendored.joml.Vector2f;
 import net.coderbot.iris.vendored.joml.Vector2i;
+
 import java.util.function.Supplier;
 
 public class SmoothedVec2f implements Supplier<Vector2f> {

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/shader_overrides/IrisChunkProgramOverrides.java
Patch:
@@ -6,12 +6,12 @@
 import me.jellysquid.mods.sodium.client.render.chunk.passes.BlockRenderPass;
 import me.jellysquid.mods.sodium.client.render.chunk.shader.ChunkShaderBindingPoints;
 import net.coderbot.iris.Iris;
+import net.coderbot.iris.compat.sodium.impl.IrisChunkShaderBindingPoints;
 import net.coderbot.iris.gl.blending.BlendModeOverride;
 import net.coderbot.iris.gl.framebuffer.GlFramebuffer;
 import net.coderbot.iris.pipeline.SodiumTerrainPipeline;
 import net.coderbot.iris.pipeline.WorldRenderingPipeline;
 import net.coderbot.iris.shadows.ShadowRenderingState;
-import net.coderbot.iris.compat.sodium.impl.IrisChunkShaderBindingPoints;
 import net.minecraft.client.Minecraft;
 import net.minecraft.resources.ResourceLocation;
 import org.jetbrains.annotations.Nullable;
@@ -186,7 +186,7 @@ private void createShaders(ChunkVertexType vertexType) {
         if (pipeline != null) {
 			pipeline.patchShaders(vertexType);
             for (IrisTerrainPass pass : IrisTerrainPass.values()) {
-				if (pass == IrisTerrainPass.SHADOW && !pipeline.hasShadowPass()) {
+				if (pass.isShadow() && !pipeline.hasShadowPass()) {
 					this.programs.put(pass, null);
 					continue;
 				}

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/entity_xhfp/QuadViewEntity.java
Patch:
@@ -1,7 +1,6 @@
 package net.coderbot.iris.compat.sodium.impl.vertex_format.entity_xhfp;
 
 import net.coderbot.iris.compat.sodium.impl.vertex_format.QuadView;
-import net.coderbot.iris.vertices.NormalHelper;
 import org.lwjgl.system.MemoryUtil;
 
 import java.nio.ByteBuffer;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/terrain_xhfp/XHFPModelVertexBufferWriterNio.java
Patch:
@@ -4,7 +4,6 @@
 import me.jellysquid.mods.sodium.client.model.vertex.buffer.VertexBufferWriterNio;
 import me.jellysquid.mods.sodium.client.render.chunk.format.ModelVertexSink;
 import me.jellysquid.mods.sodium.client.util.Norm3b;
-
 import net.coderbot.iris.compat.sodium.impl.block_id.MaterialIdAwareVertexWriter;
 import net.coderbot.iris.block_rendering.MaterialIdHolder;
 import net.coderbot.iris.compat.sodium.impl.vertex_format.IrisModelVertexFormats;
@@ -26,7 +25,7 @@ public XHFPModelVertexBufferWriterNio(VertexBufferView backingBuffer) {
 	float uSum;
 	float vSum;
 
-	private QuadViewTerrain.QuadViewTerrainNio currentQuad = new QuadViewTerrain.QuadViewTerrainNio();
+	private final QuadViewTerrain.QuadViewTerrainNio currentQuad = new QuadViewTerrain.QuadViewTerrainNio();
 	private final Vector3f normal = new Vector3f();
 
 	@Override

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/block_id/MixinChunkBuildBuffers.java
Patch:
@@ -7,9 +7,9 @@
 import me.jellysquid.mods.sodium.client.render.chunk.compile.ChunkBuildBuffers;
 import me.jellysquid.mods.sodium.client.render.chunk.passes.BlockRenderPassManager;
 import net.coderbot.iris.block_rendering.BlockRenderingSettings;
+import net.coderbot.iris.block_rendering.MaterialIdHolder;
 import net.coderbot.iris.compat.sodium.impl.block_id.ChunkBuildBuffersExt;
 import net.coderbot.iris.compat.sodium.impl.block_id.MaterialIdAwareVertexWriter;
-import net.coderbot.iris.block_rendering.MaterialIdHolder;
 import net.minecraft.world.level.block.state.BlockState;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Unique;

File: src/main/java/net/coderbot/iris/gl/program/ProgramBuilder.java
Patch:
@@ -29,6 +29,8 @@ public class ProgramBuilder extends ProgramUniforms.Builder implements SamplerHo
 		.define(StandardMacros.getVendor())
 		.define("MC_RENDER_QUALITY", "1.0")
 		.define("MC_SHADOW_QUALITY", "1.0")
+		.define("MC_NORMAL_MAP")
+		.define("MC_SPECULAR_MAP")
 		.define("MC_HAND_DEPTH", Float.toString(HandRenderer.DEPTH))
 		.defineAll(StandardMacros.getIrisDefines())
 		.defineAll(StandardMacros.getGlExtensions())

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -31,6 +31,7 @@
 import net.coderbot.iris.postprocess.CenterDepthSampler;
 import net.coderbot.iris.postprocess.CompositeRenderer;
 import net.coderbot.iris.postprocess.FinalPassRenderer;
+import net.coderbot.iris.rendertarget.Blaze3dRenderTargetExt;
 import net.coderbot.iris.rendertarget.RenderTargets;
 import net.coderbot.iris.samplers.IrisImages;
 import net.coderbot.iris.samplers.IrisSamplers;
@@ -470,7 +471,8 @@ public void beginLevelRendering() {
 		updateNotifier.onNewFrame();
 
 		RenderTarget main = Minecraft.getInstance().getMainRenderTarget();
-		renderTargets.resizeIfNeeded(main.width, main.height);
+		renderTargets.resizeIfNeeded(((Blaze3dRenderTargetExt) main).iris$isDepthBufferDirty(), main.width, main.height);
+		((Blaze3dRenderTargetExt) main).iris$clearDepthBufferDirtyFlag();
 
 		final ImmutableList<ClearPass> passes;
 

File: src/main/java/net/coderbot/iris/samplers/IrisSamplers.java
Patch:
@@ -122,13 +122,13 @@ public static void addLevelSamplers(SamplerHolder samplers, AbstractTexture norm
 	}
 
 	public static void addWorldDepthSamplers(SamplerHolder samplers, RenderTargets renderTargets) {
-		samplers.addDynamicSampler(renderTargets.getDepthTexture()::getTextureId, "depthtex0");
+		samplers.addDynamicSampler(renderTargets.getDepthTexture(), "depthtex0");
 		// TODO: Should depthtex2 be made available to gbuffer / shadow programs?
 		samplers.addDynamicSampler(renderTargets.getDepthTextureNoTranslucents()::getTextureId, "depthtex1");
 	}
 
 	public static void addCompositeSamplers(SamplerHolder samplers, RenderTargets renderTargets) {
-		samplers.addDynamicSampler(renderTargets.getDepthTexture()::getTextureId,
+		samplers.addDynamicSampler(renderTargets.getDepthTexture(),
 				"gdepthtex", "depthtex0");
 		samplers.addDynamicSampler(renderTargets.getDepthTextureNoTranslucents()::getTextureId,
 				"depthtex1");

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -40,7 +40,7 @@ public MappingTree createMappings() {
 
     @Override
     public FabricLoader getLoader() {
-        return new FabricLoader(FabricMaven.URL, FabricMaven.loader("0.12.5"));
+        return new FabricLoader(FabricMaven.URL, FabricMaven.loader("0.13.3"));
     }
 
     @Override
@@ -65,6 +65,8 @@ public void getModDependencies(ModDependencyCollector d) {
         d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.slf4j:slf4j-api:1.7.12"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
         d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-resource-loader-v0", "0.4.8+3cc0f0907d"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
         d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.5+3cc0f0907d"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
+        d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-api-base", "0.4.0+3cc0f0907d"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
+        d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-command-api-v1", "1.1.3+3cc0f0907d"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
 
 		if (SODIUM) {
 			if (CUSTOM_SODIUM) {

File: src/main/java/net/coderbot/batchedentityrendering/mixin/MixinRenderBuffers.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.batchedentityrendering.mixin;
 
 import net.coderbot.batchedentityrendering.impl.DrawCallTrackingRenderBuffers;
-import net.coderbot.batchedentityrendering.impl.RenderBuffersExt;
 import net.coderbot.batchedentityrendering.impl.FullyBufferedMultiBufferSource;
 import net.coderbot.batchedentityrendering.impl.MemoryTrackingBuffer;
 import net.coderbot.batchedentityrendering.impl.MemoryTrackingRenderBuffers;
+import net.coderbot.batchedentityrendering.impl.RenderBuffersExt;
 import net.minecraft.client.renderer.MultiBufferSource;
 import net.minecraft.client.renderer.OutlineBufferSource;
 import net.minecraft.client.renderer.RenderBuffers;

File: src/main/java/net/coderbot/iris/IrisLogging.java
Patch:
@@ -6,7 +6,7 @@
 public class IrisLogging {
 	public static boolean ENABLE_SPAM = false; // FabricLoader.getInstance().isDevelopmentEnvironment();
 
-	private Logger logger;
+	private final Logger logger;
 
 	public IrisLogging(String loggerName) {
 		this.logger = LogManager.getLogger(loggerName);
@@ -41,11 +41,11 @@ public void warn(Object... o) {
 	}
 
 	public void info(String info) {
-		this.logger.warn(info);
+		this.logger.info(info);
 	}
 
 	public void info(String info, Object... o) {
-		this.logger.warn(info, o);
+		this.logger.info(info, o);
 	}
 
 	public void debug(String debug) {

File: src/main/java/net/coderbot/iris/gl/IrisRenderSystem.java
Patch:
@@ -7,7 +7,6 @@
 import org.lwjgl.opengl.GL;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL20;
-import org.lwjgl.opengl.GL21;
 import org.lwjgl.opengl.GL30C;
 import org.lwjgl.opengl.GL42C;
 

File: src/main/java/net/coderbot/iris/gl/blending/AlphaTestFunction.java
Patch:
@@ -1,9 +1,9 @@
 package net.coderbot.iris.gl.blending;
 
-import java.util.Optional;
-
 import org.lwjgl.opengl.GL11;
 
+import java.util.Optional;
+
 public enum AlphaTestFunction {
 	NEVER(GL11.GL_NEVER),
 	LESS(GL11.GL_LESS),

File: src/main/java/net/coderbot/iris/gl/blending/BlendModeFunction.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.iris.gl.blending;
 
-import java.util.Optional;
-
 import net.coderbot.iris.Iris;
 import org.lwjgl.opengl.GL11;
 
+import java.util.Optional;
+
 public enum BlendModeFunction {
 	ZERO(GL11.GL_ZERO),
 	ONE(GL11.GL_ONE),

File: src/main/java/net/coderbot/iris/gl/image/ImageBinding.java
Patch:
@@ -1,7 +1,6 @@
 package net.coderbot.iris.gl.image;
 
 import net.coderbot.iris.gl.IrisRenderSystem;
-import org.lwjgl.opengl.GL;
 import org.lwjgl.opengl.GL42C;
 
 import java.util.function.IntSupplier;

File: src/main/java/net/coderbot/iris/gl/program/ProgramBuilder.java
Patch:
@@ -12,10 +12,8 @@
 import net.coderbot.iris.gl.shader.StandardMacros;
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
 import net.coderbot.iris.pipeline.HandRenderer;
-
 import org.jetbrains.annotations.Nullable;
 import org.lwjgl.opengl.GL20C;
-import org.lwjgl.opengl.GL21C;
 
 import java.util.function.IntSupplier;
 

File: src/main/java/net/coderbot/iris/gl/program/ProgramImages.java
Patch:
@@ -7,7 +7,6 @@
 import net.coderbot.iris.gl.image.ImageHolder;
 import net.coderbot.iris.gl.image.ImageLimits;
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
-import org.lwjgl.opengl.GL20C;
 
 import java.util.ArrayList;
 import java.util.List;

File: src/main/java/net/coderbot/iris/gl/shader/ShaderWorkarounds.java
Patch:
@@ -14,13 +14,13 @@
 
 package net.coderbot.iris.gl.shader;
 
-import java.nio.ByteBuffer;
-
 import org.lwjgl.PointerBuffer;
 import org.lwjgl.opengl.GL20C;
 import org.lwjgl.system.MemoryStack;
 import org.lwjgl.system.MemoryUtil;
 
+import java.nio.ByteBuffer;
+
 /**
  * Contains a workaround for a crash in nglShaderSource on some AMD drivers. Copied from the following Canvas commit:
  * https://github.com/grondag/canvas/commit/820bf754092ccaf8d0c169620c2ff575722d7d96

File: src/main/java/net/coderbot/iris/gl/state/StateUpdateNotifiers.java
Patch:
@@ -9,6 +9,8 @@
 public class StateUpdateNotifiers {
 	public static ValueUpdateNotifier fogToggleNotifier;
 	public static ValueUpdateNotifier fogModeNotifier;
+	public static ValueUpdateNotifier fogStartNotifier;
+	public static ValueUpdateNotifier fogEndNotifier;
 	public static ValueUpdateNotifier fogDensityNotifier;
 	public static ValueUpdateNotifier blendFuncNotifier;
 	public static ValueUpdateNotifier bindTextureNotifier;

File: src/main/java/net/coderbot/iris/gl/texture/InternalTextureFormat.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.gl.texture;
 
-import java.util.Optional;
-
 import net.coderbot.iris.gl.GlVersion;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL30C;
 import org.lwjgl.opengl.GL31C;
 
+import java.util.Optional;
+
 public enum InternalTextureFormat {
 	// Default
 	// TODO: This technically shouldn't be exposed to shaders since it's not in the specification, it's the default anyways

File: src/main/java/net/coderbot/iris/gl/texture/PixelFormat.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.gl.texture;
 
-import java.util.Optional;
-
 import net.coderbot.iris.gl.GlVersion;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL12C;
 import org.lwjgl.opengl.GL30C;
 
+import java.util.Optional;
+
 public enum PixelFormat {
 	RED(GL11C.GL_RED, GlVersion.GL_11),
 	RG(GL30C.GL_RG, GlVersion.GL_30),

File: src/main/java/net/coderbot/iris/gl/texture/PixelType.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.gl.texture;
 
-import java.util.Optional;
-
 import net.coderbot.iris.gl.GlVersion;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL12C;
 import org.lwjgl.opengl.GL30C;
 
+import java.util.Optional;
+
 public enum PixelType {
 	BYTE(GL11C.GL_BYTE, GlVersion.GL_11),
 	SHORT(GL11C.GL_SHORT, GlVersion.GL_11),

File: src/main/java/net/coderbot/iris/gl/uniform/IntUniform.java
Patch:
@@ -1,9 +1,9 @@
 package net.coderbot.iris.gl.uniform;
 
-import java.util.function.IntSupplier;
-
 import net.coderbot.iris.gl.IrisRenderSystem;
 
+import java.util.function.IntSupplier;
+
 public class IntUniform extends Uniform {
 	private int cachedValue;
 	private final IntSupplier value;

File: src/main/java/net/coderbot/iris/gl/uniform/JomlMatrixUniform.java
Patch:
@@ -8,7 +8,7 @@
 import java.util.function.Supplier;
 
 public class JomlMatrixUniform extends Uniform {
-	private FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
+	private final FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
 	private Matrix4f cachedValue;
 	private final Supplier<Matrix4f> value;
 

File: src/main/java/net/coderbot/iris/gl/uniform/MatrixFromFloatArrayUniform.java
Patch:
@@ -8,7 +8,7 @@
 import java.util.function.Supplier;
 
 public class MatrixFromFloatArrayUniform extends Uniform {
-	private FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
+	private final FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
 	private float[] cachedValue;
 	private final Supplier<float[]> value;
 

File: src/main/java/net/coderbot/iris/gl/uniform/Vector2IntegerJomlUniform.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector2i;
-import org.lwjgl.opengl.GL20;
 
 import java.util.function.Supplier;
 

File: src/main/java/net/coderbot/iris/gl/uniform/Vector2Uniform.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.iris.gl.uniform;
 
-import java.util.function.Supplier;
-
 import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector2f;
 
+import java.util.function.Supplier;
+
 public class Vector2Uniform extends Uniform {
 	private Vector2f cachedValue;
 	private final Supplier<Vector2f> value;

File: src/main/java/net/coderbot/iris/gl/uniform/Vector3Uniform.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.gl.uniform;
 
-import java.util.function.Supplier;
-
 import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector3d;
 import net.coderbot.iris.vendored.joml.Vector3f;
 import net.coderbot.iris.vendored.joml.Vector4f;
 
+import java.util.function.Supplier;
+
 public class Vector3Uniform extends Uniform {
 	private final Vector3f cachedValue;
 	private final Supplier<Vector3f> value;

File: src/main/java/net/coderbot/iris/gl/uniform/Vector4IntegerJomlUniform.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector4i;
-import org.lwjgl.opengl.GL20;
 
 import java.util.function.Supplier;
 

File: src/main/java/net/coderbot/iris/gl/uniform/Vector4Uniform.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.iris.gl.uniform;
 
-import java.util.function.Supplier;
-
 import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector4f;
 
+import java.util.function.Supplier;
+
 public class Vector4Uniform extends Uniform {
 	private final Vector4f cachedValue;
 	private final Supplier<Vector4f> value;

File: src/main/java/net/coderbot/iris/gui/element/widget/BooleanElementWidget.java
Patch:
@@ -5,7 +5,6 @@
 import net.coderbot.iris.gui.GuiUtil;
 import net.coderbot.iris.gui.NavigationController;
 import net.coderbot.iris.gui.screen.ShaderPackScreen;
-import net.coderbot.iris.shaderpack.OptionalBoolean;
 import net.coderbot.iris.shaderpack.option.BooleanOption;
 import net.coderbot.iris.shaderpack.option.menu.OptionMenuBooleanOptionElement;
 import net.minecraft.ChatFormatting;

File: src/main/java/net/coderbot/iris/gui/element/widget/OptionMenuConstructor.java
Patch:
@@ -3,8 +3,8 @@
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.gui.GuiUtil;
 import net.coderbot.iris.gui.NavigationController;
-import net.coderbot.iris.gui.element.screen.ElementWidgetScreenData;
 import net.coderbot.iris.gui.element.ShaderPackOptionList;
+import net.coderbot.iris.gui.element.screen.ElementWidgetScreenData;
 import net.coderbot.iris.gui.screen.ShaderPackScreen;
 import net.coderbot.iris.shaderpack.option.menu.OptionMenuBooleanOptionElement;
 import net.coderbot.iris.shaderpack.option.menu.OptionMenuContainer;

File: src/main/java/net/coderbot/iris/gui/element/widget/StringElementWidget.java
Patch:
@@ -12,7 +12,6 @@
 import net.minecraft.network.chat.TextComponent;
 
 import java.util.List;
-import java.util.Optional;
 
 public class StringElementWidget extends BaseOptionElementWidget<OptionMenuStringOptionElement> {
 	protected final StringOption option;

File: src/main/java/net/coderbot/iris/layer/IrisRenderTypeWrapper.java
Patch:
@@ -1,13 +1,13 @@
 package net.coderbot.iris.layer;
 
-import java.util.Objects;
-import java.util.Optional;
-
 import net.coderbot.batchedentityrendering.impl.WrappableRenderType;
 import net.coderbot.iris.mixin.rendertype.RenderTypeAccessor;
 import net.minecraft.client.renderer.RenderType;
 import org.jetbrains.annotations.Nullable;
 
+import java.util.Objects;
+import java.util.Optional;
+
 public class IrisRenderTypeWrapper extends RenderType implements WrappableRenderType {
 	private final UseProgramRenderStateShard useProgram;
 	private final RenderType wrapped;

File: src/main/java/net/coderbot/iris/layer/UseProgramRenderStateShard.java
Patch:
@@ -1,8 +1,9 @@
 package net.coderbot.iris.layer;
 
-import java.util.Objects;
 import net.minecraft.client.renderer.RenderStateShard;
 
+import java.util.Objects;
+
 public class UseProgramRenderStateShard extends RenderStateShard {
 	private final GbufferProgram program;
 

File: src/main/java/net/coderbot/iris/mixin/DimensionTypeAccessor.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.iris.mixin;
 
+import net.minecraft.world.level.dimension.DimensionType;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
 
 import java.util.OptionalLong;
-import net.minecraft.world.level.dimension.DimensionType;
 
 @Mixin(DimensionType.class)
 public interface DimensionTypeAccessor {

File: src/main/java/net/coderbot/iris/mixin/GameRendererAccessor.java
Patch:
@@ -1,14 +1,12 @@
 package net.coderbot.iris.mixin;
 
 import com.mojang.blaze3d.vertex.PoseStack;
-
 import net.minecraft.client.Camera;
+import net.minecraft.client.renderer.GameRenderer;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
 import org.spongepowered.asm.mixin.gen.Invoker;
 
-import net.minecraft.client.renderer.GameRenderer;
-
 @Mixin(GameRenderer.class)
 public interface GameRendererAccessor {
 	@Accessor

File: src/main/java/net/coderbot/iris/mixin/MixinBufferSource_WrapperChecking.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.mixin;
 
-import java.util.Set;
-
 import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.layer.InnerWrappedRenderType;
@@ -15,6 +13,8 @@
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
+import java.util.Set;
+
 @Mixin(MultiBufferSource.BufferSource.class)
 public class MixinBufferSource_WrapperChecking {
 	@Unique

File: src/main/java/net/coderbot/iris/mixin/MixinGlStateManager_AlphaTestOverride.java
Patch:
@@ -1,7 +1,6 @@
 package net.coderbot.iris.mixin;
 
 import com.mojang.blaze3d.platform.GlStateManager;
-
 import net.coderbot.iris.gl.blending.AlphaTestStorage;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;

File: src/main/java/net/coderbot/iris/mixin/MixinMaxFpsCrashFix.java
Patch:
@@ -1,12 +1,11 @@
 package net.coderbot.iris.mixin;
 
+import net.minecraft.client.Options;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Redirect;
 import org.spongepowered.asm.mixin.injection.Slice;
 
-import net.minecraft.client.Options;
-
 /**
  * A workaround for when OptiFine has set the maxFps to zero in options.txt
  * 

File: src/main/java/net/coderbot/iris/mixin/gui/MixinVideoSettingsScreen.java
Patch:
@@ -5,7 +5,6 @@
 import net.minecraft.client.Option;
 import net.minecraft.client.gui.screens.Screen;
 import net.minecraft.client.gui.screens.VideoSettingsScreen;
-
 import net.minecraft.network.chat.Component;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;

File: src/main/java/net/coderbot/iris/mixin/rendertype/MixinFixEyesTranslucency.java
Patch:
@@ -1,11 +1,11 @@
 package net.coderbot.iris.mixin.rendertype;
 
+import net.minecraft.client.renderer.RenderStateShard;
+import net.minecraft.client.renderer.RenderType;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Unique;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Redirect;
-import net.minecraft.client.renderer.RenderStateShard;
-import net.minecraft.client.renderer.RenderType;
 
 @Mixin(RenderType.class)
 public class MixinFixEyesTranslucency {

File: src/main/java/net/coderbot/iris/mixin/rendertype/MixinRenderType.java
Patch:
@@ -4,8 +4,6 @@
 import net.coderbot.iris.layer.GbufferProgram;
 import net.coderbot.iris.layer.IrisRenderTypeWrapper;
 import net.coderbot.iris.layer.UseProgramRenderStateShard;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.client.renderer.RenderStateShard;
 import net.minecraft.client.renderer.RenderType;
 import net.minecraft.resources.ResourceLocation;

File: src/main/java/net/coderbot/iris/mixin/rendertype/RenderStateShardAccessor.java
Patch:
@@ -1,8 +1,8 @@
 package net.coderbot.iris.mixin.rendertype;
 
+import net.minecraft.client.renderer.RenderStateShard;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
-import net.minecraft.client.renderer.RenderStateShard;
 
 @Mixin(RenderStateShard.class)
 public interface RenderStateShardAccessor {

File: src/main/java/net/coderbot/iris/mixin/rendertype/RenderTypeAccessor.java
Patch:
@@ -1,8 +1,8 @@
 package net.coderbot.iris.mixin.rendertype;
 
+import net.minecraft.client.renderer.RenderType;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
-import net.minecraft.client.renderer.RenderType;
 
 @Mixin(RenderType.class)
 public interface RenderTypeAccessor {

File: src/main/java/net/coderbot/iris/mixin/shadows/MixinPreventRebuildNearInShadowPass.java
Patch:
@@ -6,7 +6,6 @@
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.LevelRenderer;
 import net.minecraft.client.renderer.culling.Frustum;
-import net.minecraft.world.level.block.entity.BlockEntity;
 import org.spongepowered.asm.mixin.Final;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Shadow;

File: src/main/java/net/coderbot/iris/mixin/texunits/MixinLightTexture.java
Patch:
@@ -1,11 +1,11 @@
 package net.coderbot.iris.mixin.texunits;
 
 import net.coderbot.iris.texunits.TextureUnit;
+import net.minecraft.client.renderer.LightTexture;
 import org.lwjgl.opengl.GL15;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.Constant;
 import org.spongepowered.asm.mixin.injection.ModifyConstant;
-import net.minecraft.client.renderer.LightTexture;
 
 /**
  * Modifies {@link LightTexture} to use a configurable texture unit, instead of being hardcoded to texture

File: src/main/java/net/coderbot/iris/mixin/texunits/MixinOverlayTexture.java
Patch:
@@ -1,11 +1,11 @@
 package net.coderbot.iris.mixin.texunits;
 
 import net.coderbot.iris.texunits.TextureUnit;
+import net.minecraft.client.renderer.texture.OverlayTexture;
 import org.lwjgl.opengl.GL15;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.Constant;
 import org.spongepowered.asm.mixin.injection.ModifyConstant;
-import net.minecraft.client.renderer.texture.OverlayTexture;
 
 @Mixin(OverlayTexture.class)
 public class MixinOverlayTexture {

File: src/main/java/net/coderbot/iris/pipeline/FixedFunctionWorldRenderingPipeline.java
Patch:
@@ -1,8 +1,5 @@
 package net.coderbot.iris.pipeline;
 
-import java.util.List;
-import java.util.OptionalInt;
-
 import com.mojang.blaze3d.platform.GlStateManager;
 
 import net.coderbot.iris.block_rendering.BlockRenderingSettings;
@@ -12,6 +9,9 @@
 import net.minecraft.client.Camera;
 import net.minecraft.client.Minecraft;
 
+import java.util.List;
+import java.util.OptionalInt;
+
 public class FixedFunctionWorldRenderingPipeline implements WorldRenderingPipeline {
 	public FixedFunctionWorldRenderingPipeline() {
 		BlockRenderingSettings.INSTANCE.setDisableDirectionalShading(shouldDisableDirectionalShading());

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPhase.java
Patch:
@@ -24,5 +24,5 @@ public enum WorldRenderingPhase {
 	CLOUDS,
 	RAIN_SNOW,
 	WORLD_BORDER,
-	HAND_TRANSLUCENT;
+	HAND_TRANSLUCENT
 }

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPipeline.java
Patch:
@@ -1,13 +1,13 @@
 package net.coderbot.iris.pipeline;
 
-import java.util.List;
-import java.util.OptionalInt;
-
 import net.coderbot.iris.layer.GbufferProgram;
 import net.coderbot.iris.mixin.LevelRendererAccessor;
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.minecraft.client.Camera;
 
+import java.util.List;
+import java.util.OptionalInt;
+
 public interface WorldRenderingPipeline {
 	void beginLevelRendering();
 	void renderShadows(LevelRendererAccessor levelRenderer, Camera camera);

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderer.java
Patch:
@@ -25,7 +25,6 @@
 import net.coderbot.iris.uniforms.CommonUniforms;
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.minecraft.client.Minecraft;
-import net.minecraft.client.renderer.texture.AbstractTexture;
 import org.lwjgl.opengl.GL15C;
 import org.lwjgl.opengl.GL20C;
 import org.lwjgl.opengl.GL30C;

File: src/main/java/net/coderbot/iris/postprocess/FinalPassRenderer.java
Patch:
@@ -26,7 +26,6 @@
 import net.coderbot.iris.uniforms.CommonUniforms;
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.minecraft.client.Minecraft;
-import net.minecraft.client.renderer.texture.AbstractTexture;
 import org.jetbrains.annotations.Nullable;
 import org.lwjgl.opengl.GL15C;
 import org.lwjgl.opengl.GL20C;

File: src/main/java/net/coderbot/iris/rendertarget/DepthTexture.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.rendertarget;
 
-import java.nio.ByteBuffer;
-
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.gl.GlResource;

File: src/main/java/net/coderbot/iris/rendertarget/NativeImageBackedCustomTexture.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.rendertarget;
 
-import com.mojang.blaze3d.platform.GlStateManager;
+import com.mojang.blaze3d.platform.NativeImage;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.shaderpack.texture.CustomTextureData;
 import net.minecraft.client.renderer.texture.DynamicTexture;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL13C;
-import com.mojang.blaze3d.platform.NativeImage;
+
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.Objects;

File: src/main/java/net/coderbot/iris/rendertarget/NativeImageBackedNoiseTexture.java
Patch:
@@ -1,9 +1,10 @@
 package net.coderbot.iris.rendertarget;
 
 import com.mojang.blaze3d.platform.NativeImage;
+import net.minecraft.client.renderer.texture.DynamicTexture;
+
 import java.util.Objects;
 import java.util.Random;
-import net.minecraft.client.renderer.texture.DynamicTexture;
 
 public class NativeImageBackedNoiseTexture extends DynamicTexture {
 	public NativeImageBackedNoiseTexture(int size) {

File: src/main/java/net/coderbot/iris/rendertarget/NoiseTexture.java
Patch:
@@ -1,8 +1,5 @@
 package net.coderbot.iris.rendertarget;
 
-import java.nio.ByteBuffer;
-import java.util.Random;
-
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.gl.GlResource;
@@ -12,6 +9,9 @@
 import org.lwjgl.opengl.GL13C;
 import org.lwjgl.opengl.GL20C;
 
+import java.nio.ByteBuffer;
+import java.util.Random;
+
 /**
  * An extremely simple noise texture. Each color channel contains a uniform random value from 0 to 255. Essentially just
  * dumps an array of random bytes into a texture and calls it a day, literally could not be any simpler than that.

File: src/main/java/net/coderbot/iris/rendertarget/RenderTarget.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.rendertarget;
 
-import java.nio.IntBuffer;
-
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
@@ -10,6 +8,8 @@
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL13C;
 
+import java.nio.IntBuffer;
+
 public class RenderTarget {
 	private final InternalTextureFormat internalFormat;
 	private final PixelFormat format;

File: src/main/java/net/coderbot/iris/rendertarget/SingleColorTexture.java
Patch:
@@ -10,7 +10,6 @@
 import org.lwjgl.opengl.GL13C;
 
 import java.nio.ByteBuffer;
-import java.nio.IntBuffer;
 
 public class SingleColorTexture extends GlResource {
 	public SingleColorTexture(int red, int green, int blue, int alpha) {

File: src/main/java/net/coderbot/iris/samplers/IrisSamplers.java
Patch:
@@ -8,6 +8,7 @@
 import net.coderbot.iris.shaderpack.PackRenderTargetDirectives;
 import net.coderbot.iris.shadows.ShadowMapRenderer;
 import net.coderbot.iris.texunits.TextureUnit;
+
 import java.util.function.IntSupplier;
 import java.util.function.Supplier;
 

File: src/main/java/net/coderbot/iris/shaderpack/loading/SourceSet.java
Patch:
@@ -1,8 +1,5 @@
 package net.coderbot.iris.shaderpack.loading;
 
-import net.coderbot.iris.shaderpack.ProgramSource;
-
-import java.util.EnumMap;
 import java.util.function.Function;
 
 // TODO: Actually implement this class.

File: src/main/java/net/coderbot/iris/shaderpack/option/OptionSet.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.iris.shaderpack.option;
 
-import net.coderbot.iris.Iris;
 import com.google.common.collect.ImmutableMap;
+import net.coderbot.iris.Iris;
 
 import java.util.HashMap;
 import java.util.Map;

File: src/main/java/net/coderbot/iris/shaderpack/option/ShaderPackOptions.java
Patch:
@@ -25,7 +25,7 @@ public ShaderPackOptions(IncludeGraph graph, Map<String, String> changedConfigs)
 		Map<AbsolutePackPath, OptionAnnotatedSource> allAnnotations = new HashMap<>();
 		OptionSet.Builder setBuilder = OptionSet.builder();
 
-		graph.computeWeaklyConnectedSubgraphs().forEach(subgraph -> {
+		graph.computeWeaklyConnectedComponents().forEach(subgraph -> {
 			ImmutableMap.Builder<AbsolutePackPath, OptionAnnotatedSource> annotationBuilder = ImmutableMap.builder();
 			Set<String> referencedBooleanDefines = new HashSet<>();
 

File: src/main/java/net/coderbot/iris/shaderpack/option/menu/OptionMenuElementScreen.java
Patch:
@@ -1,7 +1,6 @@
 package net.coderbot.iris.shaderpack.option.menu;
 
 import net.coderbot.iris.Iris;
-
 import net.coderbot.iris.shaderpack.ShaderProperties;
 import net.coderbot.iris.shaderpack.option.ShaderPackOptions;
 

File: src/main/java/net/coderbot/iris/shaderpack/preprocessor/PropertiesPreprocessor.java
Patch:
@@ -9,13 +9,12 @@
 import org.anarres.cpp.StringLexerSource;
 import org.anarres.cpp.Token;
 
-import java.nio.file.Path;
-import java.util.Arrays;
-import java.util.stream.Collectors;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.stream.Collectors;
 
 public class PropertiesPreprocessor {
 	// Derived from ShaderProcessor.glslPreprocessSource, which is derived from GlShader from Canvas, licenced under LGPL

File: src/main/java/net/coderbot/iris/shaderpack/transform/BuiltinUniformReplacementTransformer.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.iris.shaderpack.transform;
 
 public class BuiltinUniformReplacementTransformer {
-	private String normalizedLightmapCoords;
+	private final String normalizedLightmapCoords;
 
 	private static final String NORMALIZED_PLACEHOLDER = "iris_NormalizedLightmapCoords";
 

File: src/main/java/net/coderbot/iris/shadow/ShadowMatrices.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.mojang.math.Matrix4f;
 import com.mojang.math.Vector3f;
+
 import java.nio.FloatBuffer;
 
 public class ShadowMatrices {

File: src/main/java/net/coderbot/iris/shadows/EmptyShadowMapRenderer.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
+import net.coderbot.iris.Iris;
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
 import net.coderbot.iris.mixin.LevelRendererAccessor;
 import net.minecraft.client.Camera;
@@ -54,7 +55,7 @@ public void renderShadows(LevelRendererAccessor levelRenderer, Camera playerCame
 
 	@Override
 	public void addDebugText(List<String> messages) {
-		messages.add("[Iris] Shadow Maps: not used by shader pack");
+		messages.add("[" + Iris.MODNAME + "] Shadow Maps: not used by shader pack");
 	}
 
 	public int getDepthTextureId() {

File: src/main/java/net/coderbot/iris/uniforms/CameraUniforms.java
Patch:
@@ -1,13 +1,13 @@
 package net.coderbot.iris.uniforms;
 
-import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.ONCE;
-import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.PER_FRAME;
-
 import net.coderbot.iris.JomlConversions;
 import net.coderbot.iris.gl.uniform.UniformHolder;
 import net.coderbot.iris.vendored.joml.Vector3d;
 import net.minecraft.client.Minecraft;
 
+import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.ONCE;
+import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.PER_FRAME;
+
 /**
  * @see <a href="https://github.com/IrisShaders/ShaderDoc/blob/master/uniforms.md#camera">Uniforms: Camera</a>
  */

File: src/main/java/net/coderbot/iris/uniforms/CapturedRenderingState.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.mojang.math.Matrix4f;
 import net.coderbot.iris.gl.uniform.ValueUpdateNotifier;
-
 import net.coderbot.iris.vendored.joml.Vector3d;
 import net.minecraft.client.Minecraft;
 

File: src/main/java/net/coderbot/iris/uniforms/HardcodedCustomUniforms.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.uniforms;
 
-import net.coderbot.iris.Iris;
-import net.coderbot.iris.gl.uniform.FloatSupplier;
 import net.coderbot.iris.gl.uniform.UniformHolder;
 import net.coderbot.iris.gl.uniform.UniformUpdateFrequency;
 import net.coderbot.iris.mixin.DimensionTypeAccessor;

File: src/main/java/net/coderbot/iris/uniforms/IdMapUniforms.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.uniforms;
 
-import java.util.function.IntSupplier;
-
 import it.unimi.dsi.fastutil.objects.Object2IntFunction;
 import net.coderbot.iris.gl.uniform.DynamicUniformHolder;
 import net.coderbot.iris.gl.uniform.UniformUpdateFrequency;
@@ -13,6 +11,8 @@
 import net.minecraft.world.InteractionHand;
 import net.minecraft.world.item.ItemStack;
 
+import java.util.function.IntSupplier;
+
 public final class IdMapUniforms {
 
 	private IdMapUniforms() {

File: src/main/java/net/coderbot/iris/uniforms/transforms/SmoothedVec2f.java
Patch:
@@ -3,6 +3,7 @@
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.coderbot.iris.vendored.joml.Vector2f;
 import net.coderbot.iris.vendored.joml.Vector2i;
+
 import java.util.function.Supplier;
 
 public class SmoothedVec2f implements Supplier<Vector2f> {

File: src/main/java/net/coderbot/iris/vertices/IrisVertexFormats.java
Patch:
@@ -14,9 +14,9 @@ public class IrisVertexFormats {
 	public static final VertexFormat ENTITY;
 
 	static {
-		ENTITY_ELEMENT = new VertexFormatElement(11, VertexFormatElement.Type.FLOAT, VertexFormatElement.Usage.GENERIC, 4);
+		ENTITY_ELEMENT = new VertexFormatElement(11, VertexFormatElement.Type.SHORT, VertexFormatElement.Usage.GENERIC, 2);
 		MID_TEXTURE_ELEMENT = new VertexFormatElement(12, VertexFormatElement.Type.FLOAT, VertexFormatElement.Usage.GENERIC, 2);
-		TANGENT_ELEMENT = new VertexFormatElement(13, VertexFormatElement.Type.FLOAT, VertexFormatElement.Usage.GENERIC, 4);
+		TANGENT_ELEMENT = new VertexFormatElement(13, VertexFormatElement.Type.BYTE, VertexFormatElement.Usage.GENERIC, 4);
 
 		ImmutableList.Builder<VertexFormatElement> terrainElements = ImmutableList.builder();
 		ImmutableList.Builder<VertexFormatElement> entityElements = ImmutableList.builder();

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/IrisModelVertexFormats.java
Patch:
@@ -1,6 +1,6 @@
 package net.coderbot.iris.compat.sodium.impl.vertex_format;
 
-import net.coderbot.iris.compat.sodium.impl.vertex_format.xhfp.XHFPModelVertexType;
+import net.coderbot.iris.compat.sodium.impl.vertex_format.terrain_xhfp.XHFPModelVertexType;
 
 public class IrisModelVertexFormats {
     public static final XHFPModelVertexType MODEL_VERTEX_XHFP = new XHFPModelVertexType();

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/NormalHelper.java
Patch:
@@ -1,4 +1,4 @@
-package net.coderbot.iris.compat.sodium.impl.vertex_format.xhfp;
+package net.coderbot.iris.compat.sodium.impl.vertex_format;
 
 /*
  * Copyright (c) 2016, 2017, 2018, 2019 FabricMC

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/terrain_xhfp/XHFPModelVertexType.java
Patch:
@@ -1,4 +1,4 @@
-package net.coderbot.iris.compat.sodium.impl.vertex_format.xhfp;
+package net.coderbot.iris.compat.sodium.impl.vertex_format.terrain_xhfp;
 
 import com.mojang.blaze3d.vertex.VertexConsumer;
 import me.jellysquid.mods.sodium.client.gl.attribute.GlVertexAttributeFormat;
@@ -36,7 +36,7 @@ public ModelVertexSink createFallbackWriter(VertexConsumer consumer) {
 
     @Override
     public ModelVertexSink createBufferWriter(VertexBufferView buffer, boolean direct) {
-        return new XHFPModelVertexBufferWriterNio(buffer);
+        return direct ? new XHFPModelVertexBufferWriterUnsafe(buffer) : new XHFPModelVertexBufferWriterNio(buffer);
     }
 
     @Override

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/block_id/MixinChunkBuildBuffers.java
Patch:
@@ -7,9 +7,9 @@
 import me.jellysquid.mods.sodium.client.render.chunk.compile.ChunkBuildBuffers;
 import me.jellysquid.mods.sodium.client.render.chunk.passes.BlockRenderPassManager;
 import net.coderbot.iris.block_rendering.BlockRenderingSettings;
+import net.coderbot.iris.block_rendering.MaterialIdHolder;
 import net.coderbot.iris.compat.sodium.impl.block_id.ChunkBuildBuffersExt;
 import net.coderbot.iris.compat.sodium.impl.block_id.MaterialIdAwareVertexWriter;
-import net.coderbot.iris.block_rendering.MaterialIdHolder;
 import net.minecraft.world.level.block.state.BlockState;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Unique;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/shader_overrides/MixinChunkRenderShaderBackend.java
Patch:
@@ -7,10 +7,10 @@
 import me.jellysquid.mods.sodium.client.render.chunk.passes.BlockRenderPass;
 import me.jellysquid.mods.sodium.client.render.chunk.shader.ChunkProgram;
 import me.jellysquid.mods.sodium.client.render.chunk.shader.ChunkRenderShaderBackend;
-import net.coderbot.iris.gl.program.ProgramUniforms;
-import net.coderbot.iris.shadows.ShadowRenderingState;
 import net.coderbot.iris.compat.sodium.impl.shader_overrides.ChunkRenderBackendExt;
 import net.coderbot.iris.compat.sodium.impl.shader_overrides.IrisChunkProgramOverrides;
+import net.coderbot.iris.gl.program.ProgramUniforms;
+import net.coderbot.iris.shadows.ShadowRenderingState;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.Unique;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/shadow_map/MixinChunkRenderManager.java
Patch:
@@ -11,8 +11,8 @@
 import me.jellysquid.mods.sodium.client.render.chunk.lists.ChunkRenderList;
 import me.jellysquid.mods.sodium.client.render.chunk.passes.BlockRenderPass;
 import me.jellysquid.mods.sodium.client.render.chunk.passes.BlockRenderPassManager;
-import net.coderbot.iris.shadows.ShadowRenderingState;
 import net.coderbot.iris.compat.sodium.impl.shadow_map.SwappableChunkRenderManager;
+import net.coderbot.iris.shadows.ShadowRenderingState;
 import net.minecraft.client.multiplayer.ClientLevel;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import org.spongepowered.asm.mixin.Final;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/vertex_format/MixinChunkOneshotGraphicsState.java
Patch:
@@ -5,12 +5,9 @@
 import me.jellysquid.mods.sodium.client.gl.buffer.VertexData;
 import me.jellysquid.mods.sodium.client.render.chunk.backends.oneshot.ChunkOneshotGraphicsState;
 import me.jellysquid.mods.sodium.client.render.chunk.format.ChunkMeshAttribute;
-import me.jellysquid.mods.sodium.client.render.chunk.format.DefaultModelVertexFormats;
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.compat.sodium.impl.IrisChunkShaderBindingPoints;
 import net.coderbot.iris.compat.sodium.impl.vertex_format.IrisChunkMeshAttributes;
-import net.coderbot.iris.compat.sodium.impl.vertex_format.IrisModelVertexFormats;
-import net.coderbot.iris.pipeline.DeferredWorldRenderingPipeline;
 import org.apache.commons.lang3.ArrayUtils;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Unique;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/vertex_format/MixinMultidrawChunkRenderBackend.java
Patch:
@@ -8,7 +8,6 @@
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.compat.sodium.impl.IrisChunkShaderBindingPoints;
 import net.coderbot.iris.compat.sodium.impl.vertex_format.IrisChunkMeshAttributes;
-import net.coderbot.iris.pipeline.DeferredWorldRenderingPipeline;
 import org.apache.commons.lang3.ArrayUtils;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/vertex_format/MixinSodiumWorldRenderer.java
Patch:
@@ -2,10 +2,8 @@
 
 import me.jellysquid.mods.sodium.client.model.vertex.type.ChunkVertexType;
 import me.jellysquid.mods.sodium.client.render.SodiumWorldRenderer;
-import me.jellysquid.mods.sodium.client.render.chunk.format.DefaultModelVertexFormats;
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.compat.sodium.impl.vertex_format.IrisModelVertexFormats;
-import net.coderbot.iris.pipeline.DeferredWorldRenderingPipeline;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.ModifyArg;

File: src/main/java/net/coderbot/iris/compat/indigo/mixin/MixinAbstractQuadRenderer.java
Patch:
@@ -12,7 +12,7 @@
 @Mixin(targets = "net/fabricmc/fabric/impl/client/indigo/renderer/render/AbstractQuadRenderer", remap = false)
 @Pseudo
 public class MixinAbstractQuadRenderer {
-	@Redirect(method = {"tesselateSmooth", "tesselateSmoothEmissive"},
+	@Redirect(method = {"tessellateSmooth", "tessellateSmoothEmissive"},
 	          at = @At(value = "INVOKE",
 	                   target = "Lnet/fabricmc/fabric/impl/client/indigo/renderer/helper/ColorHelper;multiplyRGB(IF)I"))
 	private int iris$separateAoColorMultiply(int color, float ao) {

File: src/main/java/net/coderbot/iris/mixin/MixinLevelRenderer.java
Patch:
@@ -79,6 +79,8 @@ public class MixinLevelRenderer {
 		Program.unbind();
 	}
 
+	// Setup shadow terrain & render shadows before the main terrain setup. We need to do things in this order to
+	// avoid breaking other mods such as Light Overlay: https://github.com/IrisShaders/Iris/issues/1356
 	@Inject(method = "renderLevel", at = @At(value = "INVOKE", target = "net/minecraft/client/renderer/LevelRenderer.setupRender (Lnet/minecraft/client/Camera;Lnet/minecraft/client/renderer/culling/Frustum;ZIZ)V"))
 	private void iris$renderTerrainShadows(PoseStack poseStack, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightTexture lightTexture, Matrix4f projection, CallbackInfo callback) {
 		pipeline.renderShadows((LevelRendererAccessor) this, camera);

File: src/main/java/net/coderbot/iris/mixin/MixinLevelRenderer.java
Patch:
@@ -85,7 +85,7 @@ public class MixinLevelRenderer {
 		Program.unbind();
 	}
 
-	@Inject(method = "renderLevel", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/renderer/LevelRenderer;compileChunksUntil(J)V", shift = At.Shift.AFTER))
+	@Inject(method = "renderLevel", at = @At(value = "INVOKE", target = "net/minecraft/client/renderer/LevelRenderer.setupRender (Lnet/minecraft/client/Camera;Lnet/minecraft/client/renderer/culling/Frustum;ZIZ)V"))
 	private void iris$renderTerrainShadows(PoseStack poseStack, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightTexture lightTexture, Matrix4f projection, CallbackInfo callback) {
 		pipeline.renderShadows((LevelRendererAccessor) this, camera);
 	}

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/shader_overrides/IrisChunkProgramOverrides.java
Patch:
@@ -186,7 +186,7 @@ private void createShaders(ChunkVertexType vertexType) {
         if (pipeline != null) {
 			pipeline.patchShaders(vertexType);
             for (IrisTerrainPass pass : IrisTerrainPass.values()) {
-				if (pass == IrisTerrainPass.SHADOW && !pipeline.hasShadowPass()) {
+				if (pass.isShadow() && !pipeline.hasShadowPass()) {
 					this.programs.put(pass, null);
 					continue;
 				}

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -40,7 +40,7 @@ public MappingTree createMappings() {
 
     @Override
     public FabricLoader getLoader() {
-        return new FabricLoader(FabricMaven.URL, FabricMaven.loader("0.13.2"));
+        return new FabricLoader(FabricMaven.URL, FabricMaven.loader("0.13.3"));
     }
 
 	@Override

File: src/main/java/net/coderbot/batchedentityrendering/mixin/MixinRenderBuffers.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.batchedentityrendering.mixin;
 
 import net.coderbot.batchedentityrendering.impl.DrawCallTrackingRenderBuffers;
-import net.coderbot.batchedentityrendering.impl.RenderBuffersExt;
 import net.coderbot.batchedentityrendering.impl.FullyBufferedMultiBufferSource;
 import net.coderbot.batchedentityrendering.impl.MemoryTrackingBuffer;
 import net.coderbot.batchedentityrendering.impl.MemoryTrackingRenderBuffers;
+import net.coderbot.batchedentityrendering.impl.RenderBuffersExt;
 import net.minecraft.client.renderer.MultiBufferSource;
 import net.minecraft.client.renderer.OutlineBufferSource;
 import net.minecraft.client.renderer.RenderBuffers;

File: src/main/java/net/coderbot/iris/IrisLogging.java
Patch:
@@ -6,7 +6,7 @@
 public class IrisLogging {
 	public static boolean ENABLE_SPAM = false; // FabricLoader.getInstance().isDevelopmentEnvironment();
 
-	private Logger logger;
+	private final Logger logger;
 
 	public IrisLogging(String loggerName) {
 		this.logger = LogManager.getLogger(loggerName);

File: src/main/java/net/coderbot/iris/config/IrisConfig.java
Patch:
@@ -1,14 +1,14 @@
 package net.coderbot.iris.config;
 
+import net.coderbot.iris.Iris;
+import net.coderbot.iris.gui.option.IrisVideoSettings;
+
 import java.io.IOException;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.Optional;
 import java.util.Properties;
 
-import net.coderbot.iris.Iris;
-import net.coderbot.iris.gui.option.IrisVideoSettings;
-
 /**
  * A class dedicated to storing the config values of shaderpacks. Right now it only stores the path to the current shaderpack
  */

File: src/main/java/net/coderbot/iris/gl/blending/AlphaTestFunction.java
Patch:
@@ -1,9 +1,9 @@
 package net.coderbot.iris.gl.blending;
 
-import java.util.Optional;
-
 import org.lwjgl.opengl.GL11;
 
+import java.util.Optional;
+
 public enum AlphaTestFunction {
 	NEVER(GL11.GL_NEVER, null),
 	LESS(GL11.GL_LESS, "<"),

File: src/main/java/net/coderbot/iris/gl/blending/BlendModeFunction.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.iris.gl.blending;
 
-import java.util.Optional;
-
 import net.coderbot.iris.Iris;
 import org.lwjgl.opengl.GL11;
 
+import java.util.Optional;
+
 public enum BlendModeFunction {
 	ZERO(GL11.GL_ZERO),
 	ONE(GL11.GL_ONE),

File: src/main/java/net/coderbot/iris/gl/image/ImageBinding.java
Patch:
@@ -1,7 +1,6 @@
 package net.coderbot.iris.gl.image;
 
 import net.coderbot.iris.gl.IrisRenderSystem;
-import org.lwjgl.opengl.GL;
 import org.lwjgl.opengl.GL42C;
 
 import java.util.function.IntSupplier;

File: src/main/java/net/coderbot/iris/gl/program/ProgramBuilder.java
Patch:
@@ -12,10 +12,8 @@
 import net.coderbot.iris.gl.shader.StandardMacros;
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
 import net.coderbot.iris.pipeline.HandRenderer;
-
 import org.jetbrains.annotations.Nullable;
 import org.lwjgl.opengl.GL20C;
-import org.lwjgl.opengl.GL21C;
 
 import java.util.function.IntSupplier;
 

File: src/main/java/net/coderbot/iris/gl/shader/ShaderWorkarounds.java
Patch:
@@ -14,13 +14,13 @@
 
 package net.coderbot.iris.gl.shader;
 
-import java.nio.ByteBuffer;
-
 import org.lwjgl.PointerBuffer;
 import org.lwjgl.opengl.GL20C;
 import org.lwjgl.system.MemoryStack;
 import org.lwjgl.system.MemoryUtil;
 
+import java.nio.ByteBuffer;
+
 /**
  * Contains a workaround for a crash in nglShaderSource on some AMD drivers. Copied from the following Canvas commit:
  * https://github.com/grondag/canvas/commit/820bf754092ccaf8d0c169620c2ff575722d7d96

File: src/main/java/net/coderbot/iris/gl/texture/InternalTextureFormat.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.gl.texture;
 
-import java.util.Optional;
-
 import net.coderbot.iris.gl.GlVersion;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL30C;
 import org.lwjgl.opengl.GL31C;
 
+import java.util.Optional;
+
 public enum InternalTextureFormat {
 	// Default
 	// TODO: This technically shouldn't be exposed to shaders since it's not in the specification, it's the default anyways

File: src/main/java/net/coderbot/iris/gl/texture/PixelFormat.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.gl.texture;
 
-import java.util.Optional;
-
 import net.coderbot.iris.gl.GlVersion;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL12C;
 import org.lwjgl.opengl.GL30C;
 
+import java.util.Optional;
+
 public enum PixelFormat {
 	RED(GL11C.GL_RED, GlVersion.GL_11),
 	RG(GL30C.GL_RG, GlVersion.GL_30),

File: src/main/java/net/coderbot/iris/gl/texture/PixelType.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.gl.texture;
 
-import java.util.Optional;
-
 import net.coderbot.iris.gl.GlVersion;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL12C;
 import org.lwjgl.opengl.GL30C;
 
+import java.util.Optional;
+
 public enum PixelType {
 	BYTE(GL11C.GL_BYTE, GlVersion.GL_11),
 	SHORT(GL11C.GL_SHORT, GlVersion.GL_11),

File: src/main/java/net/coderbot/iris/gl/uniform/JomlMatrixUniform.java
Patch:
@@ -8,7 +8,7 @@
 import java.util.function.Supplier;
 
 public class JomlMatrixUniform extends Uniform {
-	private FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
+	private final FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
 	private Matrix4f cachedValue;
 	private final Supplier<Matrix4f> value;
 

File: src/main/java/net/coderbot/iris/gl/uniform/MatrixFromFloatArrayUniform.java
Patch:
@@ -8,7 +8,7 @@
 import java.util.function.Supplier;
 
 public class MatrixFromFloatArrayUniform extends Uniform {
-	private FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
+	private final FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
 	private float[] cachedValue;
 	private final Supplier<float[]> value;
 

File: src/main/java/net/coderbot/iris/gl/uniform/MatrixUniform.java
Patch:
@@ -8,7 +8,7 @@
 import java.util.function.Supplier;
 
 public class MatrixUniform extends Uniform {
-	private FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
+	private final FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
 	private Matrix4f cachedValue;
 	private final Supplier<Matrix4f> value;
 

File: src/main/java/net/coderbot/iris/gl/uniform/Vector2Uniform.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.iris.gl.uniform;
 
-import java.util.function.Supplier;
-
 import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector2f;
 
+import java.util.function.Supplier;
+
 public class Vector2Uniform extends Uniform {
 	private Vector2f cachedValue;
 	private final Supplier<Vector2f> value;

File: src/main/java/net/coderbot/iris/gl/uniform/Vector3Uniform.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.gl.uniform;
 
-import java.util.function.Supplier;
-
 import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector3d;
 import net.coderbot.iris.vendored.joml.Vector3f;
 import net.coderbot.iris.vendored.joml.Vector4f;
 
+import java.util.function.Supplier;
+
 public class Vector3Uniform extends Uniform {
 	private final Vector3f cachedValue;
 	private final Supplier<Vector3f> value;

File: src/main/java/net/coderbot/iris/gl/uniform/Vector4IntegerJomlUniform.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector4i;
-import org.lwjgl.opengl.GL20;
 
 import java.util.function.Supplier;
 

File: src/main/java/net/coderbot/iris/gl/uniform/Vector4Uniform.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.iris.gl.uniform;
 
-import java.util.function.Supplier;
-
 import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector4f;
 
+import java.util.function.Supplier;
+
 public class Vector4Uniform extends Uniform {
 	private final Vector4f cachedValue;
 	private final Supplier<Vector4f> value;

File: src/main/java/net/coderbot/iris/gui/element/widget/BooleanElementWidget.java
Patch:
@@ -5,7 +5,6 @@
 import net.coderbot.iris.gui.GuiUtil;
 import net.coderbot.iris.gui.NavigationController;
 import net.coderbot.iris.gui.screen.ShaderPackScreen;
-import net.coderbot.iris.shaderpack.OptionalBoolean;
 import net.coderbot.iris.shaderpack.option.BooleanOption;
 import net.coderbot.iris.shaderpack.option.menu.OptionMenuBooleanOptionElement;
 import net.minecraft.ChatFormatting;

File: src/main/java/net/coderbot/iris/gui/element/widget/OptionMenuConstructor.java
Patch:
@@ -3,8 +3,8 @@
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.gui.GuiUtil;
 import net.coderbot.iris.gui.NavigationController;
-import net.coderbot.iris.gui.element.screen.ElementWidgetScreenData;
 import net.coderbot.iris.gui.element.ShaderPackOptionList;
+import net.coderbot.iris.gui.element.screen.ElementWidgetScreenData;
 import net.coderbot.iris.gui.screen.ShaderPackScreen;
 import net.coderbot.iris.shaderpack.option.menu.OptionMenuBooleanOptionElement;
 import net.coderbot.iris.shaderpack.option.menu.OptionMenuContainer;

File: src/main/java/net/coderbot/iris/gui/element/widget/StringElementWidget.java
Patch:
@@ -12,7 +12,6 @@
 import net.minecraft.network.chat.TextComponent;
 
 import java.util.List;
-import java.util.Optional;
 
 public class StringElementWidget extends BaseOptionElementWidget<OptionMenuStringOptionElement> {
 	protected final StringOption option;

File: src/main/java/net/coderbot/iris/layer/IrisRenderTypeWrapper.java
Patch:
@@ -1,13 +1,13 @@
 package net.coderbot.iris.layer;
 
-import java.util.Objects;
-import java.util.Optional;
-
 import net.coderbot.batchedentityrendering.impl.WrappableRenderType;
 import net.coderbot.iris.mixin.rendertype.RenderTypeAccessor;
 import net.minecraft.client.renderer.RenderType;
 import org.jetbrains.annotations.Nullable;
 
+import java.util.Objects;
+import java.util.Optional;
+
 public class IrisRenderTypeWrapper extends RenderType implements WrappableRenderType {
 	private final UseProgramRenderStateShard useProgram;
 	private final RenderType wrapped;

File: src/main/java/net/coderbot/iris/layer/UseProgramRenderStateShard.java
Patch:
@@ -1,8 +1,9 @@
 package net.coderbot.iris.layer;
 
-import java.util.Objects;
 import net.minecraft.client.renderer.RenderStateShard;
 
+import java.util.Objects;
+
 public class UseProgramRenderStateShard extends RenderStateShard {
 	private final GbufferProgram program;
 

File: src/main/java/net/coderbot/iris/mixin/DimensionTypeAccessor.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.iris.mixin;
 
+import net.minecraft.world.level.dimension.DimensionType;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
 
 import java.util.OptionalLong;
-import net.minecraft.world.level.dimension.DimensionType;
 
 @Mixin(DimensionType.class)
 public interface DimensionTypeAccessor {

File: src/main/java/net/coderbot/iris/mixin/GameRendererAccessor.java
Patch:
@@ -1,14 +1,12 @@
 package net.coderbot.iris.mixin;
 
 import com.mojang.blaze3d.vertex.PoseStack;
-
 import net.minecraft.client.Camera;
+import net.minecraft.client.renderer.GameRenderer;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
 import org.spongepowered.asm.mixin.gen.Invoker;
 
-import net.minecraft.client.renderer.GameRenderer;
-
 @Mixin(GameRenderer.class)
 public interface GameRendererAccessor {
 	@Accessor

File: src/main/java/net/coderbot/iris/mixin/MixinGlStateManager_AlphaTestOverride.java
Patch:
@@ -1,7 +1,6 @@
 package net.coderbot.iris.mixin;
 
 import com.mojang.blaze3d.platform.GlStateManager;
-
 import net.coderbot.iris.gl.blending.AlphaTestStorage;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;

File: src/main/java/net/coderbot/iris/mixin/MixinMaxFpsCrashFix.java
Patch:
@@ -1,12 +1,11 @@
 package net.coderbot.iris.mixin;
 
+import net.minecraft.client.Options;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Redirect;
 import org.spongepowered.asm.mixin.injection.Slice;
 
-import net.minecraft.client.Options;
-
 /**
  * A workaround for when OptiFine has set the maxFps to zero in options.txt
  * 

File: src/main/java/net/coderbot/iris/mixin/MixinSystemReport.java
Patch:
@@ -6,7 +6,6 @@
 import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
-
 import net.coderbot.iris.Iris;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;

File: src/main/java/net/coderbot/iris/mixin/rendertype/RenderTypeAccessor.java
Patch:
@@ -1,8 +1,8 @@
 package net.coderbot.iris.mixin.rendertype;
 
+import net.minecraft.client.renderer.RenderType;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
-import net.minecraft.client.renderer.RenderType;
 
 @Mixin(RenderType.class)
 public interface RenderTypeAccessor {

File: src/main/java/net/coderbot/iris/mixin/shadows/MixinPreventRebuildNearInShadowPass.java
Patch:
@@ -7,7 +7,6 @@
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.LevelRenderer;
 import net.minecraft.client.renderer.culling.Frustum;
-import net.minecraft.world.level.block.entity.BlockEntity;
 import org.spongepowered.asm.mixin.Final;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Shadow;

File: src/main/java/net/coderbot/iris/mixin/statelisteners/MixinGlStateManager.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.mojang.blaze3d.platform.GlStateManager;
 import net.coderbot.iris.gl.state.StateUpdateNotifiers;
-import net.coderbot.iris.gl.uniform.ValueUpdateNotifier;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -45,7 +45,6 @@
 import net.coderbot.iris.vendored.joml.Vector4f;
 import net.minecraft.client.Camera;
 import net.minecraft.client.Minecraft;
-import net.minecraft.resources.ResourceLocation;
 import org.jetbrains.annotations.Nullable;
 import org.lwjgl.opengl.GL15C;
 import org.lwjgl.opengl.GL20C;

File: src/main/java/net/coderbot/iris/pipeline/FixedFunctionWorldRenderingPipeline.java
Patch:
@@ -7,6 +7,7 @@
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.minecraft.client.Camera;
 import net.minecraft.client.Minecraft;
+
 import java.util.List;
 import java.util.OptionalInt;
 

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPhase.java
Patch:
@@ -24,5 +24,5 @@ public enum WorldRenderingPhase {
 	CLOUDS,
 	RAIN_SNOW,
 	WORLD_BORDER,
-	HAND_TRANSLUCENT;
+	HAND_TRANSLUCENT
 }

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPipeline.java
Patch:
@@ -4,6 +4,7 @@
 import net.coderbot.iris.mixin.LevelRendererAccessor;
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.minecraft.client.Camera;
+
 import java.util.List;
 import java.util.OptionalInt;
 

File: src/main/java/net/coderbot/iris/rendertarget/DepthTexture.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.rendertarget;
 
-import java.nio.ByteBuffer;
-
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.gl.GlResource;

File: src/main/java/net/coderbot/iris/rendertarget/NativeImageBackedCustomTexture.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.rendertarget;
 
-import com.mojang.blaze3d.platform.GlStateManager;
+import com.mojang.blaze3d.platform.NativeImage;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.shaderpack.texture.CustomTextureData;
 import net.minecraft.client.renderer.texture.DynamicTexture;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL13C;
-import com.mojang.blaze3d.platform.NativeImage;
+
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.Objects;

File: src/main/java/net/coderbot/iris/rendertarget/NativeImageBackedNoiseTexture.java
Patch:
@@ -1,9 +1,10 @@
 package net.coderbot.iris.rendertarget;
 
 import com.mojang.blaze3d.platform.NativeImage;
+import net.minecraft.client.renderer.texture.DynamicTexture;
+
 import java.util.Objects;
 import java.util.Random;
-import net.minecraft.client.renderer.texture.DynamicTexture;
 
 public class NativeImageBackedNoiseTexture extends DynamicTexture {
 	public NativeImageBackedNoiseTexture(int size) {

File: src/main/java/net/coderbot/iris/rendertarget/NoiseTexture.java
Patch:
@@ -1,8 +1,5 @@
 package net.coderbot.iris.rendertarget;
 
-import java.nio.ByteBuffer;
-import java.util.Random;
-
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.gl.GlResource;
@@ -12,6 +9,9 @@
 import org.lwjgl.opengl.GL13C;
 import org.lwjgl.opengl.GL20C;
 
+import java.nio.ByteBuffer;
+import java.util.Random;
+
 /**
  * An extremely simple noise texture. Each color channel contains a uniform random value from 0 to 255. Essentially just
  * dumps an array of random bytes into a texture and calls it a day, literally could not be any simpler than that.

File: src/main/java/net/coderbot/iris/rendertarget/RenderTarget.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.rendertarget;
 
-import java.nio.IntBuffer;
-
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
@@ -10,6 +8,8 @@
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL13C;
 
+import java.nio.IntBuffer;
+
 public class RenderTarget {
 	private final InternalTextureFormat internalFormat;
 	private final PixelFormat format;

File: src/main/java/net/coderbot/iris/rendertarget/SingleColorTexture.java
Patch:
@@ -10,7 +10,6 @@
 import org.lwjgl.opengl.GL13C;
 
 import java.nio.ByteBuffer;
-import java.nio.IntBuffer;
 
 public class SingleColorTexture extends GlResource {
 	public SingleColorTexture(int red, int green, int blue, int alpha) {

File: src/main/java/net/coderbot/iris/samplers/IrisSamplers.java
Patch:
@@ -9,6 +9,7 @@
 import net.coderbot.iris.shadows.ShadowMapRenderer;
 import net.coderbot.iris.texunits.TextureUnit;
 import net.minecraft.client.renderer.texture.AbstractTexture;
+
 import java.util.function.IntSupplier;
 import java.util.function.Supplier;
 

File: src/main/java/net/coderbot/iris/shaderpack/ShaderPack.java
Patch:
@@ -26,7 +26,6 @@
 import net.coderbot.iris.shaderpack.texture.TextureStage;
 import net.coderbot.iris.shaderpack.transform.line.LineTransform;
 import net.coderbot.iris.shaderpack.transform.line.VersionDirectiveNormalizer;
-import org.apache.logging.log4j.Level;
 import org.jetbrains.annotations.Nullable;
 
 import java.io.BufferedReader;

File: src/main/java/net/coderbot/iris/shaderpack/loading/SourceSet.java
Patch:
@@ -1,8 +1,5 @@
 package net.coderbot.iris.shaderpack.loading;
 
-import net.coderbot.iris.shaderpack.ProgramSource;
-
-import java.util.EnumMap;
 import java.util.function.Function;
 
 // TODO: Actually implement this class.

File: src/main/java/net/coderbot/iris/shaderpack/option/OptionSet.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.iris.shaderpack.option;
 
-import net.coderbot.iris.Iris;
 import com.google.common.collect.ImmutableMap;
+import net.coderbot.iris.Iris;
 
 import java.util.HashMap;
 import java.util.Map;

File: src/main/java/net/coderbot/iris/shaderpack/option/menu/OptionMenuElementScreen.java
Patch:
@@ -1,7 +1,6 @@
 package net.coderbot.iris.shaderpack.option.menu;
 
 import net.coderbot.iris.Iris;
-
 import net.coderbot.iris.shaderpack.ShaderProperties;
 import net.coderbot.iris.shaderpack.option.ShaderPackOptions;
 

File: src/main/java/net/coderbot/iris/shaderpack/preprocessor/PropertiesPreprocessor.java
Patch:
@@ -9,13 +9,12 @@
 import org.anarres.cpp.StringLexerSource;
 import org.anarres.cpp.Token;
 
-import java.nio.file.Path;
-import java.util.Arrays;
-import java.util.stream.Collectors;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.stream.Collectors;
 
 public class PropertiesPreprocessor {
 	// Derived from ShaderProcessor.glslPreprocessSource, which is derived from GlShader from Canvas, licenced under LGPL

File: src/main/java/net/coderbot/iris/shaderpack/transform/BuiltinUniformReplacementTransformer.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.iris.shaderpack.transform;
 
 public class BuiltinUniformReplacementTransformer {
-	private String normalizedLightmapCoords;
+	private final String normalizedLightmapCoords;
 
 	private static final String NORMALIZED_PLACEHOLDER = "iris_NormalizedLightmapCoords";
 

File: src/main/java/net/coderbot/iris/shadow/ShadowMatrices.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.mojang.math.Matrix4f;
 import com.mojang.math.Vector3f;
+
 import java.nio.FloatBuffer;
 
 public class ShadowMatrices {

File: src/main/java/net/coderbot/iris/shadows/EmptyShadowMapRenderer.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
+import net.coderbot.iris.Iris;
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
 import net.coderbot.iris.mixin.LevelRendererAccessor;
 import net.minecraft.client.Camera;
@@ -54,7 +55,7 @@ public void renderShadows(LevelRendererAccessor levelRenderer, Camera playerCame
 
 	@Override
 	public void addDebugText(List<String> messages) {
-		messages.add("[Iris] Shadow Maps: not used by shader pack");
+		messages.add("[" + Iris.MODNAME + "] Shadow Maps: not used by shader pack");
 	}
 
 	public int getDepthTextureId() {

File: src/main/java/net/coderbot/iris/uniforms/CameraUniforms.java
Patch:
@@ -1,13 +1,13 @@
 package net.coderbot.iris.uniforms;
 
-import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.ONCE;
-import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.PER_FRAME;
-
 import net.coderbot.iris.JomlConversions;
 import net.coderbot.iris.gl.uniform.UniformHolder;
 import net.coderbot.iris.vendored.joml.Vector3d;
 import net.minecraft.client.Minecraft;
 
+import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.ONCE;
+import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.PER_FRAME;
+
 /**
  * @see <a href="https://github.com/IrisShaders/ShaderDoc/blob/master/uniforms.md#camera">Uniforms: Camera</a>
  */

File: src/main/java/net/coderbot/iris/uniforms/CapturedRenderingState.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.mojang.math.Matrix4f;
 import net.coderbot.iris.gl.uniform.ValueUpdateNotifier;
-
 import net.coderbot.iris.vendored.joml.Vector3d;
 import net.minecraft.client.Minecraft;
 

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -1,8 +1,5 @@
 package net.coderbot.iris.uniforms;
 
-import java.util.Objects;
-import java.util.function.IntSupplier;
-
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.JomlConversions;
@@ -38,6 +35,9 @@
 import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
 
+import java.util.Objects;
+import java.util.function.IntSupplier;
+
 import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.ONCE;
 import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.PER_FRAME;
 import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.PER_TICK;

File: src/main/java/net/coderbot/iris/uniforms/HardcodedCustomUniforms.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.uniforms;
 
-import net.coderbot.iris.Iris;
-import net.coderbot.iris.gl.uniform.FloatSupplier;
 import net.coderbot.iris.gl.uniform.UniformHolder;
 import net.coderbot.iris.gl.uniform.UniformUpdateFrequency;
 import net.coderbot.iris.mixin.DimensionTypeAccessor;

File: src/main/java/net/coderbot/iris/uniforms/IdMapUniforms.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.uniforms;
 
-import java.util.function.IntSupplier;
-
 import it.unimi.dsi.fastutil.objects.Object2IntFunction;
 import net.coderbot.iris.gl.uniform.DynamicUniformHolder;
 import net.coderbot.iris.gl.uniform.UniformUpdateFrequency;
@@ -13,6 +11,8 @@
 import net.minecraft.world.InteractionHand;
 import net.minecraft.world.item.ItemStack;
 
+import java.util.function.IntSupplier;
+
 public final class IdMapUniforms {
 
 	private IdMapUniforms() {

File: src/main/java/net/coderbot/iris/uniforms/transforms/SmoothedVec2f.java
Patch:
@@ -3,6 +3,7 @@
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.coderbot.iris.vendored.joml.Vector2f;
 import net.coderbot.iris.vendored.joml.Vector2i;
+
 import java.util.function.Supplier;
 
 public class SmoothedVec2f implements Supplier<Vector2f> {

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/shader_overrides/IrisChunkProgramOverrides.java
Patch:
@@ -6,12 +6,12 @@
 import me.jellysquid.mods.sodium.client.render.chunk.passes.BlockRenderPass;
 import me.jellysquid.mods.sodium.client.render.chunk.shader.ChunkShaderBindingPoints;
 import net.coderbot.iris.Iris;
+import net.coderbot.iris.compat.sodium.impl.IrisChunkShaderBindingPoints;
 import net.coderbot.iris.gl.blending.BlendModeOverride;
 import net.coderbot.iris.gl.framebuffer.GlFramebuffer;
 import net.coderbot.iris.pipeline.SodiumTerrainPipeline;
 import net.coderbot.iris.pipeline.WorldRenderingPipeline;
 import net.coderbot.iris.shadows.ShadowRenderingState;
-import net.coderbot.iris.compat.sodium.impl.IrisChunkShaderBindingPoints;
 import net.minecraft.client.Minecraft;
 import net.minecraft.resources.ResourceLocation;
 import org.jetbrains.annotations.Nullable;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/entity_xhfp/QuadViewEntity.java
Patch:
@@ -1,7 +1,6 @@
 package net.coderbot.iris.compat.sodium.impl.vertex_format.entity_xhfp;
 
 import net.coderbot.iris.compat.sodium.impl.vertex_format.QuadView;
-import net.coderbot.iris.vertices.NormalHelper;
 import org.lwjgl.system.MemoryUtil;
 
 import java.nio.ByteBuffer;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/terrain_xhfp/XHFPModelVertexBufferWriterNio.java
Patch:
@@ -4,7 +4,6 @@
 import me.jellysquid.mods.sodium.client.model.vertex.buffer.VertexBufferWriterNio;
 import me.jellysquid.mods.sodium.client.render.chunk.format.ModelVertexSink;
 import me.jellysquid.mods.sodium.client.util.Norm3b;
-
 import net.coderbot.iris.compat.sodium.impl.block_id.MaterialIdAwareVertexWriter;
 import net.coderbot.iris.block_rendering.MaterialIdHolder;
 import net.coderbot.iris.compat.sodium.impl.vertex_format.IrisModelVertexFormats;
@@ -26,7 +25,7 @@ public XHFPModelVertexBufferWriterNio(VertexBufferView backingBuffer) {
 	float uSum;
 	float vSum;
 
-	private QuadViewTerrain.QuadViewTerrainNio currentQuad = new QuadViewTerrain.QuadViewTerrainNio();
+	private final QuadViewTerrain.QuadViewTerrainNio currentQuad = new QuadViewTerrain.QuadViewTerrainNio();
 	private final Vector3f normal = new Vector3f();
 
 	@Override

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/block_id/MixinChunkBuildBuffers.java
Patch:
@@ -7,9 +7,9 @@
 import me.jellysquid.mods.sodium.client.render.chunk.compile.ChunkBuildBuffers;
 import me.jellysquid.mods.sodium.client.render.chunk.passes.BlockRenderPassManager;
 import net.coderbot.iris.block_rendering.BlockRenderingSettings;
+import net.coderbot.iris.block_rendering.MaterialIdHolder;
 import net.coderbot.iris.compat.sodium.impl.block_id.ChunkBuildBuffersExt;
 import net.coderbot.iris.compat.sodium.impl.block_id.MaterialIdAwareVertexWriter;
-import net.coderbot.iris.block_rendering.MaterialIdHolder;
 import net.minecraft.world.level.block.state.BlockState;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Unique;

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPhase.java
Patch:
@@ -26,7 +26,7 @@ public enum WorldRenderingPhase {
 	CLOUDS,
 	RAIN_SNOW,
 	WORLD_BORDER,
-	HAND_TRANSLUCENT
+	HAND_TRANSLUCENT;
 
 	public static WorldRenderingPhase fromTerrainRenderType(RenderType renderType) {
 		if (renderType == RenderType.solid()) {

File: src/main/java/net/coderbot/batchedentityrendering/mixin/MixinRenderBuffers.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.batchedentityrendering.mixin;
 
 import net.coderbot.batchedentityrendering.impl.DrawCallTrackingRenderBuffers;
-import net.coderbot.batchedentityrendering.impl.RenderBuffersExt;
 import net.coderbot.batchedentityrendering.impl.FullyBufferedMultiBufferSource;
 import net.coderbot.batchedentityrendering.impl.MemoryTrackingBuffer;
 import net.coderbot.batchedentityrendering.impl.MemoryTrackingRenderBuffers;
+import net.coderbot.batchedentityrendering.impl.RenderBuffersExt;
 import net.minecraft.client.renderer.MultiBufferSource;
 import net.minecraft.client.renderer.OutlineBufferSource;
 import net.minecraft.client.renderer.RenderBuffers;

File: src/main/java/net/coderbot/iris/IrisLogging.java
Patch:
@@ -6,7 +6,7 @@
 public class IrisLogging {
 	public static boolean ENABLE_SPAM = false; // FabricLoader.getInstance().isDevelopmentEnvironment();
 
-	private Logger logger;
+	private final Logger logger;
 
 	public IrisLogging(String loggerName) {
 		this.logger = LogManager.getLogger(loggerName);

File: src/main/java/net/coderbot/iris/config/IrisConfig.java
Patch:
@@ -1,14 +1,14 @@
 package net.coderbot.iris.config;
 
+import net.coderbot.iris.Iris;
+import net.coderbot.iris.gui.option.IrisVideoSettings;
+
 import java.io.IOException;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.Optional;
 import java.util.Properties;
 
-import net.coderbot.iris.Iris;
-import net.coderbot.iris.gui.option.IrisVideoSettings;
-
 /**
  * A class dedicated to storing the config values of shaderpacks. Right now it only stores the path to the current shaderpack
  */

File: src/main/java/net/coderbot/iris/gl/IrisRenderSystem.java
Patch:
@@ -7,7 +7,6 @@
 import org.lwjgl.opengl.GL;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL20;
-import org.lwjgl.opengl.GL21;
 import org.lwjgl.opengl.GL30C;
 import org.lwjgl.opengl.GL42C;
 

File: src/main/java/net/coderbot/iris/gl/blending/AlphaTestFunction.java
Patch:
@@ -1,9 +1,9 @@
 package net.coderbot.iris.gl.blending;
 
-import java.util.Optional;
-
 import org.lwjgl.opengl.GL11;
 
+import java.util.Optional;
+
 public enum AlphaTestFunction {
 	NEVER(GL11.GL_NEVER),
 	LESS(GL11.GL_LESS),

File: src/main/java/net/coderbot/iris/gl/blending/BlendModeFunction.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.iris.gl.blending;
 
-import java.util.Optional;
-
 import net.coderbot.iris.Iris;
 import org.lwjgl.opengl.GL11;
 
+import java.util.Optional;
+
 public enum BlendModeFunction {
 	ZERO(GL11.GL_ZERO),
 	ONE(GL11.GL_ONE),

File: src/main/java/net/coderbot/iris/gl/image/ImageBinding.java
Patch:
@@ -1,7 +1,6 @@
 package net.coderbot.iris.gl.image;
 
 import net.coderbot.iris.gl.IrisRenderSystem;
-import org.lwjgl.opengl.GL;
 import org.lwjgl.opengl.GL42C;
 
 import java.util.function.IntSupplier;

File: src/main/java/net/coderbot/iris/gl/program/ProgramBuilder.java
Patch:
@@ -12,10 +12,8 @@
 import net.coderbot.iris.gl.shader.StandardMacros;
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
 import net.coderbot.iris.pipeline.HandRenderer;
-
 import org.jetbrains.annotations.Nullable;
 import org.lwjgl.opengl.GL20C;
-import org.lwjgl.opengl.GL21C;
 
 import java.util.function.IntSupplier;
 

File: src/main/java/net/coderbot/iris/gl/program/ProgramImages.java
Patch:
@@ -7,7 +7,6 @@
 import net.coderbot.iris.gl.image.ImageHolder;
 import net.coderbot.iris.gl.image.ImageLimits;
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
-import org.lwjgl.opengl.GL20C;
 
 import java.util.ArrayList;
 import java.util.List;

File: src/main/java/net/coderbot/iris/gl/shader/ShaderWorkarounds.java
Patch:
@@ -14,13 +14,13 @@
 
 package net.coderbot.iris.gl.shader;
 
-import java.nio.ByteBuffer;
-
 import org.lwjgl.PointerBuffer;
 import org.lwjgl.opengl.GL20C;
 import org.lwjgl.system.MemoryStack;
 import org.lwjgl.system.MemoryUtil;
 
+import java.nio.ByteBuffer;
+
 /**
  * Contains a workaround for a crash in nglShaderSource on some AMD drivers. Copied from the following Canvas commit:
  * https://github.com/grondag/canvas/commit/820bf754092ccaf8d0c169620c2ff575722d7d96

File: src/main/java/net/coderbot/iris/gl/texture/InternalTextureFormat.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.gl.texture;
 
-import java.util.Optional;
-
 import net.coderbot.iris.gl.GlVersion;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL30C;
 import org.lwjgl.opengl.GL31C;
 
+import java.util.Optional;
+
 public enum InternalTextureFormat {
 	// Default
 	// TODO: This technically shouldn't be exposed to shaders since it's not in the specification, it's the default anyways

File: src/main/java/net/coderbot/iris/gl/texture/PixelFormat.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.gl.texture;
 
-import java.util.Optional;
-
 import net.coderbot.iris.gl.GlVersion;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL12C;
 import org.lwjgl.opengl.GL30C;
 
+import java.util.Optional;
+
 public enum PixelFormat {
 	RED(GL11C.GL_RED, GlVersion.GL_11),
 	RG(GL30C.GL_RG, GlVersion.GL_30),

File: src/main/java/net/coderbot/iris/gl/texture/PixelType.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.gl.texture;
 
-import java.util.Optional;
-
 import net.coderbot.iris.gl.GlVersion;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL12C;
 import org.lwjgl.opengl.GL30C;
 
+import java.util.Optional;
+
 public enum PixelType {
 	BYTE(GL11C.GL_BYTE, GlVersion.GL_11),
 	SHORT(GL11C.GL_SHORT, GlVersion.GL_11),

File: src/main/java/net/coderbot/iris/gl/uniform/IntUniform.java
Patch:
@@ -1,9 +1,9 @@
 package net.coderbot.iris.gl.uniform;
 
-import java.util.function.IntSupplier;
-
 import net.coderbot.iris.gl.IrisRenderSystem;
 
+import java.util.function.IntSupplier;
+
 public class IntUniform extends Uniform {
 	private int cachedValue;
 	private final IntSupplier value;

File: src/main/java/net/coderbot/iris/gl/uniform/JomlMatrixUniform.java
Patch:
@@ -8,7 +8,7 @@
 import java.util.function.Supplier;
 
 public class JomlMatrixUniform extends Uniform {
-	private FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
+	private final FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
 	private Matrix4f cachedValue;
 	private final Supplier<Matrix4f> value;
 

File: src/main/java/net/coderbot/iris/gl/uniform/MatrixFromFloatArrayUniform.java
Patch:
@@ -8,7 +8,7 @@
 import java.util.function.Supplier;
 
 public class MatrixFromFloatArrayUniform extends Uniform {
-	private FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
+	private final FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
 	private float[] cachedValue;
 	private final Supplier<float[]> value;
 

File: src/main/java/net/coderbot/iris/gl/uniform/Vector2IntegerJomlUniform.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector2i;
-import org.lwjgl.opengl.GL20;
 
 import java.util.function.Supplier;
 

File: src/main/java/net/coderbot/iris/gl/uniform/Vector2Uniform.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.iris.gl.uniform;
 
-import java.util.function.Supplier;
-
 import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector2f;
 
+import java.util.function.Supplier;
+
 public class Vector2Uniform extends Uniform {
 	private Vector2f cachedValue;
 	private final Supplier<Vector2f> value;

File: src/main/java/net/coderbot/iris/gl/uniform/Vector3Uniform.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.gl.uniform;
 
-import java.util.function.Supplier;
-
 import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector3d;
 import net.coderbot.iris.vendored.joml.Vector3f;
 import net.coderbot.iris.vendored.joml.Vector4f;
 
+import java.util.function.Supplier;
+
 public class Vector3Uniform extends Uniform {
 	private final Vector3f cachedValue;
 	private final Supplier<Vector3f> value;

File: src/main/java/net/coderbot/iris/gl/uniform/Vector4IntegerJomlUniform.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector4i;
-import org.lwjgl.opengl.GL20;
 
 import java.util.function.Supplier;
 

File: src/main/java/net/coderbot/iris/gl/uniform/Vector4Uniform.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.iris.gl.uniform;
 
-import java.util.function.Supplier;
-
 import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector4f;
 
+import java.util.function.Supplier;
+
 public class Vector4Uniform extends Uniform {
 	private final Vector4f cachedValue;
 	private final Supplier<Vector4f> value;

File: src/main/java/net/coderbot/iris/gui/element/widget/BooleanElementWidget.java
Patch:
@@ -5,7 +5,6 @@
 import net.coderbot.iris.gui.GuiUtil;
 import net.coderbot.iris.gui.NavigationController;
 import net.coderbot.iris.gui.screen.ShaderPackScreen;
-import net.coderbot.iris.shaderpack.OptionalBoolean;
 import net.coderbot.iris.shaderpack.option.BooleanOption;
 import net.coderbot.iris.shaderpack.option.menu.OptionMenuBooleanOptionElement;
 import net.minecraft.ChatFormatting;

File: src/main/java/net/coderbot/iris/gui/element/widget/OptionMenuConstructor.java
Patch:
@@ -3,8 +3,8 @@
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.gui.GuiUtil;
 import net.coderbot.iris.gui.NavigationController;
-import net.coderbot.iris.gui.element.screen.ElementWidgetScreenData;
 import net.coderbot.iris.gui.element.ShaderPackOptionList;
+import net.coderbot.iris.gui.element.screen.ElementWidgetScreenData;
 import net.coderbot.iris.gui.screen.ShaderPackScreen;
 import net.coderbot.iris.shaderpack.option.menu.OptionMenuBooleanOptionElement;
 import net.coderbot.iris.shaderpack.option.menu.OptionMenuContainer;

File: src/main/java/net/coderbot/iris/gui/element/widget/StringElementWidget.java
Patch:
@@ -12,7 +12,6 @@
 import net.minecraft.network.chat.TextComponent;
 
 import java.util.List;
-import java.util.Optional;
 
 public class StringElementWidget extends BaseOptionElementWidget<OptionMenuStringOptionElement> {
 	protected final StringOption option;

File: src/main/java/net/coderbot/iris/mixin/DimensionTypeAccessor.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.iris.mixin;
 
+import net.minecraft.world.level.dimension.DimensionType;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
 
 import java.util.OptionalLong;
-import net.minecraft.world.level.dimension.DimensionType;
 
 @Mixin(DimensionType.class)
 public interface DimensionTypeAccessor {

File: src/main/java/net/coderbot/iris/mixin/GameRendererAccessor.java
Patch:
@@ -1,14 +1,12 @@
 package net.coderbot.iris.mixin;
 
 import com.mojang.blaze3d.vertex.PoseStack;
-
 import net.minecraft.client.Camera;
+import net.minecraft.client.renderer.GameRenderer;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
 import org.spongepowered.asm.mixin.gen.Invoker;
 
-import net.minecraft.client.renderer.GameRenderer;
-
 @Mixin(GameRenderer.class)
 public interface GameRendererAccessor {
 	@Accessor

File: src/main/java/net/coderbot/iris/mixin/MixinGlStateManager_AlphaTestOverride.java
Patch:
@@ -1,7 +1,6 @@
 package net.coderbot.iris.mixin;
 
 import com.mojang.blaze3d.platform.GlStateManager;
-
 import net.coderbot.iris.gl.blending.AlphaTestStorage;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;

File: src/main/java/net/coderbot/iris/mixin/MixinMaxFpsCrashFix.java
Patch:
@@ -1,12 +1,11 @@
 package net.coderbot.iris.mixin;
 
+import net.minecraft.client.Options;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Redirect;
 import org.spongepowered.asm.mixin.injection.Slice;
 
-import net.minecraft.client.Options;
-
 /**
  * A workaround for when OptiFine has set the maxFps to zero in options.txt
  * 

File: src/main/java/net/coderbot/iris/mixin/gui/MixinVideoSettingsScreen.java
Patch:
@@ -5,7 +5,6 @@
 import net.minecraft.client.Option;
 import net.minecraft.client.gui.screens.Screen;
 import net.minecraft.client.gui.screens.VideoSettingsScreen;
-
 import net.minecraft.network.chat.Component;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;

File: src/main/java/net/coderbot/iris/mixin/rendertype/MixinRenderType_FixEyesTranslucency.java
Patch:
@@ -1,11 +1,11 @@
 package net.coderbot.iris.mixin.rendertype;
 
+import net.minecraft.client.renderer.RenderStateShard;
+import net.minecraft.client.renderer.RenderType;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Unique;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Redirect;
-import net.minecraft.client.renderer.RenderStateShard;
-import net.minecraft.client.renderer.RenderType;
 
 @Mixin(RenderType.class)
 public class MixinRenderType_FixEyesTranslucency {

File: src/main/java/net/coderbot/iris/mixin/rendertype/RenderStateShardAccessor.java
Patch:
@@ -1,8 +1,8 @@
 package net.coderbot.iris.mixin.rendertype;
 
+import net.minecraft.client.renderer.RenderStateShard;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
-import net.minecraft.client.renderer.RenderStateShard;
 
 @Mixin(RenderStateShard.class)
 public interface RenderStateShardAccessor {

File: src/main/java/net/coderbot/iris/mixin/rendertype/RenderTypeAccessor.java
Patch:
@@ -1,8 +1,8 @@
 package net.coderbot.iris.mixin.rendertype;
 
+import net.minecraft.client.renderer.RenderType;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
-import net.minecraft.client.renderer.RenderType;
 
 @Mixin(RenderType.class)
 public interface RenderTypeAccessor {

File: src/main/java/net/coderbot/iris/mixin/shadows/MixinPreventRebuildNearInShadowPass.java
Patch:
@@ -6,7 +6,6 @@
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.LevelRenderer;
 import net.minecraft.client.renderer.culling.Frustum;
-import net.minecraft.world.level.block.entity.BlockEntity;
 import org.spongepowered.asm.mixin.Final;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Shadow;

File: src/main/java/net/coderbot/iris/mixin/statelisteners/MixinGlStateManager.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.mojang.blaze3d.platform.GlStateManager;
 import net.coderbot.iris.gl.state.StateUpdateNotifiers;
-import net.coderbot.iris.gl.uniform.ValueUpdateNotifier;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;

File: src/main/java/net/coderbot/iris/pipeline/FixedFunctionWorldRenderingPipeline.java
Patch:
@@ -8,6 +8,7 @@
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.minecraft.client.Camera;
 import net.minecraft.client.Minecraft;
+
 import java.util.List;
 import java.util.OptionalInt;
 

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPhase.java
Patch:
@@ -26,7 +26,7 @@ public enum WorldRenderingPhase {
 	CLOUDS,
 	RAIN_SNOW,
 	WORLD_BORDER,
-	HAND_TRANSLUCENT;
+	HAND_TRANSLUCENT
 
 	public static WorldRenderingPhase fromTerrainRenderType(RenderType renderType) {
 		if (renderType == RenderType.solid()) {

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPipeline.java
Patch:
@@ -5,6 +5,7 @@
 import net.coderbot.iris.mixin.LevelRendererAccessor;
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.minecraft.client.Camera;
+
 import java.util.List;
 import java.util.OptionalInt;
 

File: src/main/java/net/coderbot/iris/rendertarget/DepthTexture.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.rendertarget;
 
-import java.nio.ByteBuffer;
-
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.gl.GlResource;

File: src/main/java/net/coderbot/iris/rendertarget/NativeImageBackedCustomTexture.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.rendertarget;
 
-import com.mojang.blaze3d.platform.GlStateManager;
+import com.mojang.blaze3d.platform.NativeImage;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.shaderpack.texture.CustomTextureData;
 import net.minecraft.client.renderer.texture.DynamicTexture;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL13C;
-import com.mojang.blaze3d.platform.NativeImage;
+
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.Objects;

File: src/main/java/net/coderbot/iris/rendertarget/NativeImageBackedNoiseTexture.java
Patch:
@@ -1,9 +1,10 @@
 package net.coderbot.iris.rendertarget;
 
 import com.mojang.blaze3d.platform.NativeImage;
+import net.minecraft.client.renderer.texture.DynamicTexture;
+
 import java.util.Objects;
 import java.util.Random;
-import net.minecraft.client.renderer.texture.DynamicTexture;
 
 public class NativeImageBackedNoiseTexture extends DynamicTexture {
 	public NativeImageBackedNoiseTexture(int size) {

File: src/main/java/net/coderbot/iris/rendertarget/NoiseTexture.java
Patch:
@@ -1,8 +1,5 @@
 package net.coderbot.iris.rendertarget;
 
-import java.nio.ByteBuffer;
-import java.util.Random;
-
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.gl.GlResource;
@@ -12,6 +9,9 @@
 import org.lwjgl.opengl.GL13C;
 import org.lwjgl.opengl.GL20C;
 
+import java.nio.ByteBuffer;
+import java.util.Random;
+
 /**
  * An extremely simple noise texture. Each color channel contains a uniform random value from 0 to 255. Essentially just
  * dumps an array of random bytes into a texture and calls it a day, literally could not be any simpler than that.

File: src/main/java/net/coderbot/iris/rendertarget/RenderTarget.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.rendertarget;
 
-import java.nio.IntBuffer;
-
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
@@ -10,6 +8,8 @@
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL13C;
 
+import java.nio.IntBuffer;
+
 public class RenderTarget {
 	private final InternalTextureFormat internalFormat;
 	private final PixelFormat format;

File: src/main/java/net/coderbot/iris/rendertarget/SingleColorTexture.java
Patch:
@@ -10,7 +10,6 @@
 import org.lwjgl.opengl.GL13C;
 
 import java.nio.ByteBuffer;
-import java.nio.IntBuffer;
 
 public class SingleColorTexture extends GlResource {
 	public SingleColorTexture(int red, int green, int blue, int alpha) {

File: src/main/java/net/coderbot/iris/samplers/IrisSamplers.java
Patch:
@@ -9,6 +9,7 @@
 import net.coderbot.iris.shaderpack.PackRenderTargetDirectives;
 import net.coderbot.iris.shadows.ShadowRenderTargets;
 import net.minecraft.client.renderer.texture.AbstractTexture;
+
 import java.util.function.IntSupplier;
 import java.util.function.Supplier;
 

File: src/main/java/net/coderbot/iris/shaderpack/ShaderPack.java
Patch:
@@ -26,7 +26,6 @@
 import net.coderbot.iris.shaderpack.texture.TextureStage;
 import net.coderbot.iris.shaderpack.transform.line.LineTransform;
 import net.coderbot.iris.shaderpack.transform.line.VersionDirectiveNormalizer;
-import org.apache.logging.log4j.Level;
 import org.jetbrains.annotations.Nullable;
 
 import java.io.BufferedReader;

File: src/main/java/net/coderbot/iris/shaderpack/loading/SourceSet.java
Patch:
@@ -1,8 +1,5 @@
 package net.coderbot.iris.shaderpack.loading;
 
-import net.coderbot.iris.shaderpack.ProgramSource;
-
-import java.util.EnumMap;
 import java.util.function.Function;
 
 // TODO: Actually implement this class.

File: src/main/java/net/coderbot/iris/shaderpack/option/OptionSet.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.iris.shaderpack.option;
 
-import net.coderbot.iris.Iris;
 import com.google.common.collect.ImmutableMap;
+import net.coderbot.iris.Iris;
 
 import java.util.HashMap;
 import java.util.Map;

File: src/main/java/net/coderbot/iris/shaderpack/option/menu/OptionMenuElementScreen.java
Patch:
@@ -1,7 +1,6 @@
 package net.coderbot.iris.shaderpack.option.menu;
 
 import net.coderbot.iris.Iris;
-
 import net.coderbot.iris.shaderpack.ShaderProperties;
 import net.coderbot.iris.shaderpack.option.ShaderPackOptions;
 

File: src/main/java/net/coderbot/iris/shaderpack/preprocessor/PropertiesPreprocessor.java
Patch:
@@ -9,13 +9,12 @@
 import org.anarres.cpp.StringLexerSource;
 import org.anarres.cpp.Token;
 
-import java.nio.file.Path;
-import java.util.Arrays;
-import java.util.stream.Collectors;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.stream.Collectors;
 
 public class PropertiesPreprocessor {
 	// Derived from ShaderProcessor.glslPreprocessSource, which is derived from GlShader from Canvas, licenced under LGPL

File: src/main/java/net/coderbot/iris/shaderpack/transform/BuiltinUniformReplacementTransformer.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.iris.shaderpack.transform;
 
 public class BuiltinUniformReplacementTransformer {
-	private String normalizedLightmapCoords;
+	private final String normalizedLightmapCoords;
 
 	private static final String NORMALIZED_PLACEHOLDER = "iris_NormalizedLightmapCoords";
 

File: src/main/java/net/coderbot/iris/shadow/ShadowMatrices.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.mojang.math.Matrix4f;
 import com.mojang.math.Vector3f;
+
 import java.nio.FloatBuffer;
 
 public class ShadowMatrices {

File: src/main/java/net/coderbot/iris/uniforms/CameraUniforms.java
Patch:
@@ -1,13 +1,13 @@
 package net.coderbot.iris.uniforms;
 
-import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.ONCE;
-import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.PER_FRAME;
-
 import net.coderbot.iris.JomlConversions;
 import net.coderbot.iris.gl.uniform.UniformHolder;
 import net.coderbot.iris.vendored.joml.Vector3d;
 import net.minecraft.client.Minecraft;
 
+import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.ONCE;
+import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.PER_FRAME;
+
 /**
  * @see <a href="https://github.com/IrisShaders/ShaderDoc/blob/master/uniforms.md#camera">Uniforms: Camera</a>
  */

File: src/main/java/net/coderbot/iris/uniforms/CapturedRenderingState.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.mojang.math.Matrix4f;
 import net.coderbot.iris.gl.uniform.ValueUpdateNotifier;
-
 import net.coderbot.iris.vendored.joml.Vector3d;
 import net.minecraft.client.Minecraft;
 

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -1,8 +1,5 @@
 package net.coderbot.iris.uniforms;
 
-import java.util.Objects;
-import java.util.function.IntSupplier;
-
 import com.mojang.blaze3d.platform.GlStateManager;
 import net.coderbot.iris.JomlConversions;
 import net.coderbot.iris.gl.state.StateUpdateNotifiers;
@@ -38,6 +35,9 @@
 import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
 
+import java.util.Objects;
+import java.util.function.IntSupplier;
+
 import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.ONCE;
 import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.PER_FRAME;
 import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.PER_TICK;

File: src/main/java/net/coderbot/iris/uniforms/HardcodedCustomUniforms.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.uniforms;
 
-import net.coderbot.iris.Iris;
-import net.coderbot.iris.gl.uniform.FloatSupplier;
 import net.coderbot.iris.gl.uniform.UniformHolder;
 import net.coderbot.iris.gl.uniform.UniformUpdateFrequency;
 import net.coderbot.iris.mixin.DimensionTypeAccessor;

File: src/main/java/net/coderbot/iris/uniforms/IdMapUniforms.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.uniforms;
 
-import java.util.function.IntSupplier;
-
 import it.unimi.dsi.fastutil.objects.Object2IntFunction;
 import net.coderbot.iris.gl.uniform.DynamicUniformHolder;
 import net.coderbot.iris.gl.uniform.UniformUpdateFrequency;
@@ -13,6 +11,8 @@
 import net.minecraft.world.InteractionHand;
 import net.minecraft.world.item.ItemStack;
 
+import java.util.function.IntSupplier;
+
 public final class IdMapUniforms {
 
 	private IdMapUniforms() {

File: src/main/java/net/coderbot/iris/uniforms/transforms/SmoothedVec2f.java
Patch:
@@ -3,6 +3,7 @@
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.coderbot.iris.vendored.joml.Vector2f;
 import net.coderbot.iris.vendored.joml.Vector2i;
+
 import java.util.function.Supplier;
 
 public class SmoothedVec2f implements Supplier<Vector2f> {

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/shader_overrides/IrisChunkProgramOverrides.java
Patch:
@@ -9,13 +9,13 @@
 import me.jellysquid.mods.sodium.client.render.chunk.shader.ChunkProgram;
 import me.jellysquid.mods.sodium.client.render.chunk.shader.ChunkShaderBindingPoints;
 import net.coderbot.iris.Iris;
+import net.coderbot.iris.compat.sodium.impl.IrisChunkShaderBindingPoints;
 import net.coderbot.iris.gl.program.ProgramImages;
 import net.coderbot.iris.gl.program.ProgramSamplers;
 import net.coderbot.iris.gl.program.ProgramUniforms;
 import net.coderbot.iris.pipeline.SodiumTerrainPipeline;
 import net.coderbot.iris.pipeline.WorldRenderingPipeline;
 import net.coderbot.iris.shadows.ShadowRenderingState;
-import net.coderbot.iris.compat.sodium.impl.IrisChunkShaderBindingPoints;
 import net.minecraft.resources.ResourceLocation;
 import org.jetbrains.annotations.Nullable;
 

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/entity_xhfp/QuadViewEntity.java
Patch:
@@ -1,7 +1,6 @@
 package net.coderbot.iris.compat.sodium.impl.vertex_format.entity_xhfp;
 
 import net.coderbot.iris.compat.sodium.impl.vertex_format.QuadView;
-import net.coderbot.iris.vertices.NormalHelper;
 import org.lwjgl.system.MemoryUtil;
 
 import java.nio.ByteBuffer;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/block_id/MixinChunkBuildBuffers.java
Patch:
@@ -7,9 +7,9 @@
 import me.jellysquid.mods.sodium.client.render.chunk.compile.ChunkBuildBuffers;
 import me.jellysquid.mods.sodium.client.render.chunk.passes.BlockRenderPassManager;
 import net.coderbot.iris.block_rendering.BlockRenderingSettings;
+import net.coderbot.iris.block_rendering.MaterialIdHolder;
 import net.coderbot.iris.compat.sodium.impl.block_id.ChunkBuildBuffersExt;
 import net.coderbot.iris.compat.sodium.impl.block_id.MaterialIdAwareVertexWriter;
-import net.coderbot.iris.block_rendering.MaterialIdHolder;
 import net.minecraft.world.level.block.state.BlockState;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Unique;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/shadow_map/MixinChunkRenderManager.java
Patch:
@@ -11,8 +11,8 @@
 import me.jellysquid.mods.sodium.client.render.chunk.lists.ChunkRenderList;
 import me.jellysquid.mods.sodium.client.render.chunk.passes.BlockRenderPass;
 import me.jellysquid.mods.sodium.client.render.chunk.passes.BlockRenderPassManager;
-import net.coderbot.iris.shadows.ShadowRenderingState;
 import net.coderbot.iris.compat.sodium.impl.shadow_map.SwappableChunkRenderManager;
+import net.coderbot.iris.shadows.ShadowRenderingState;
 import net.minecraft.client.multiplayer.ClientLevel;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import org.spongepowered.asm.mixin.Final;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/shadow_map/MixinSodiumWorldRenderer.java
Patch:
@@ -3,9 +3,9 @@
 import com.mojang.blaze3d.vertex.PoseStack;
 import me.jellysquid.mods.sodium.client.render.SodiumWorldRenderer;
 import me.jellysquid.mods.sodium.client.render.chunk.ChunkRenderManager;
+import net.coderbot.iris.compat.sodium.impl.shadow_map.SwappableChunkRenderManager;
 import net.coderbot.iris.pipeline.ShadowRenderer;
 import net.coderbot.iris.shadows.ShadowRenderingState;
-import net.coderbot.iris.compat.sodium.impl.shadow_map.SwappableChunkRenderManager;
 import net.minecraft.client.Camera;
 import net.minecraft.client.renderer.RenderType;
 import net.minecraft.client.renderer.culling.Frustum;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/vertex_format/MixinChunkOneshotGraphicsState.java
Patch:
@@ -5,7 +5,6 @@
 import me.jellysquid.mods.sodium.client.gl.buffer.VertexData;
 import me.jellysquid.mods.sodium.client.render.chunk.backends.oneshot.ChunkOneshotGraphicsState;
 import me.jellysquid.mods.sodium.client.render.chunk.format.ChunkMeshAttribute;
-import me.jellysquid.mods.sodium.client.render.chunk.format.DefaultModelVertexFormats;
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.compat.sodium.impl.IrisChunkShaderBindingPoints;
 import net.coderbot.iris.compat.sodium.impl.vertex_format.IrisChunkMeshAttributes;

File: src/main/java/net/coderbot/iris/mixin/bettermipmaps/MixinTextureAtlasSprite.java
Patch:
@@ -33,8 +33,8 @@ public class MixinTextureAtlasSprite {
 	// can remain minimal. Being less dependent on specific details of Fabric is good, since it means we can be more
 	// cross-platform.
 	@ModifyVariable(method = "<init>", at = @At(value = "INVOKE",
-		target = "Lnet/minecraft/client/renderer/texture/MipmapGenerator;generateMipLevels(Lcom/mojang/blaze3d/platform/NativeImage;I)[Lcom/mojang/blaze3d/platform/NativeImage;"))
-	private NativeImage iris$beforeGenerateMipLevels(NativeImage nativeImage, TextureAtlas arg, 1111TextureAtlasSprite.Info info) {
+		target = "Lnet/minecraft/client/renderer/texture/MipmapGenerator;generateMipLevels(Lcom/mojang/blaze3d/platform/NativeImage;I)[Lcom/mojang/blaze3d/platform/NativeImage;"), argsOnly = true)
+	private NativeImage iris$beforeGenerateMipLevels(NativeImage nativeImage, TextureAtlas arg, TextureAtlasSprite.Info info) {
 		// We're injecting after the "info" field has been set, so this is safe even though we're in a constructor.
 		ResourceLocation name = Objects.requireNonNull(info).name();
 

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -65,6 +65,8 @@ public void getModDependencies(ModDependencyCollector d) {
         d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.slf4j:slf4j-api:1.7.12"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
         d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-resource-loader-v0", "0.4.8+3cc0f0907d"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
         d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.5+3cc0f0907d"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
+        d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-api-base", "0.4.0+3cc0f0907d"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
+        d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-command-api-v1", "1.1.3+3cc0f0907d"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
 
 		if (SODIUM) {
 			if (CUSTOM_SODIUM) {

File: src/main/java/net/coderbot/iris/IrisLogging.java
Patch:
@@ -41,11 +41,11 @@ public void warn(Object... o) {
 	}
 
 	public void info(String info) {
-		this.logger.warn(info);
+		this.logger.info(info);
 	}
 
 	public void info(String info, Object... o) {
-		this.logger.warn(info, o);
+		this.logger.info(info, o);
 	}
 
 	public void debug(String debug) {

File: src/main/java/net/coderbot/iris/gl/state/StateUpdateNotifiers.java
Patch:
@@ -9,6 +9,8 @@
 public class StateUpdateNotifiers {
 	public static ValueUpdateNotifier fogToggleNotifier;
 	public static ValueUpdateNotifier fogModeNotifier;
+	public static ValueUpdateNotifier fogStartNotifier;
+	public static ValueUpdateNotifier fogEndNotifier;
 	public static ValueUpdateNotifier fogDensityNotifier;
 	public static ValueUpdateNotifier blendFuncNotifier;
 	public static ValueUpdateNotifier atlasTextureNotifier;

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -260,4 +260,7 @@ public int getAsInt() {
 		}
 	}
 
+	static {
+		GbufferPrograms.init();
+	}
 }

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -260,4 +260,7 @@ public int getAsInt() {
 		}
 	}
 
+	static {
+		GbufferPrograms.init();
+	}
 }

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -41,7 +41,6 @@
 import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.ONCE;
 import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.PER_FRAME;
 import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.PER_TICK;
-import static net.coderbot.iris.gl.uniform.UniformUpdateFrequency.ONCE;
 
 public final class CommonUniforms {
 	private static final Minecraft client = Minecraft.getInstance();
@@ -263,4 +262,7 @@ public int getAsInt() {
 		}
 	}
 
+	static {
+		GbufferPrograms.init();
+	}
 }

File: src/main/java/net/coderbot/iris/mixin/MixinGameRenderer.java
Patch:
@@ -296,7 +296,7 @@ public class MixinGameRenderer {
 	private static void iris$overrideBeaconBeamShader(CallbackInfoReturnable<ShaderInstance> cir) {
 		if (ShadowRenderer.ACTIVE) {
 			override(ShaderKey.SHADOW_BEACON_BEAM, cir);
-		} else {
+		} else if (isRenderingWorld()) {
 			override(ShaderKey.BEACON, cir);
 		}
 	}

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -67,7 +67,7 @@ public Consumer<AccessWidenerVisitor> getAw() {
 	@Override
 	public void getModDependencies(ModDependencyCollector d) {
 		d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.anarres:jcpp:1.4.14"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
-		//d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-resource-loader-v0", "0.4.16+55dca1a4d2"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
+		d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-resource-loader-v0", "0.4.22+a67d2aa562"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
 		d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.11+54e5b2ecd2"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
 
 		d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-api-base", "0.4.3+d7c144a8d2"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);

File: src/main/java/net/coderbot/iris/compat/sodium/SodiumVersionCheck.java
Patch:
@@ -12,7 +12,7 @@ public class SodiumVersionCheck {
 	// of pain. So don't forget!
 	private static final ImmutableList<AllowedSodiumVersion> ALLOWED_SODIUM_VERSIONS = ImmutableList.of(
 			// Release version
-			AllowedSodiumVersion.exact("0.4.1+rev.96cae5a",
+			AllowedSodiumVersion.exact("0.4.1+rev.7ca3e90-dirty",
 					"https://modrinth.com/mod/sodium/version/mc1.18.2-0.4.1"),
 
 			// For use by ReplayMod

File: src/main/java/net/coderbot/iris/pipeline/newshader/TriforcePatcher.java
Patch:
@@ -107,15 +107,16 @@ public static void patchCommon(StringTransformations transformations, ShaderType
 		//System.out.println(transformations.toString());
 	}
 
-	public static String patchVanilla(String source, ShaderType type, AlphaTest alpha, boolean hasChunkOffset, ShaderAttributeInputs inputs) {
+	public static String patchVanilla(String source, ShaderType type, AlphaTest alpha, boolean hasChunkOffset, ShaderAttributeInputs inputs, boolean hasGeometry) {
 		StringTransformations transformations = new StringTransformations(source);
 
 		patchCommon(transformations, type);
 
 		if (inputs.hasOverlay()) {
 			// TODO: Change this once we implement 1.17 geometry shader support!
-			AttributeShaderTransformer.patch(transformations, type, false);
+			AttributeShaderTransformer.patch(transformations, type, hasGeometry);
 		}
+
 		addAlphaTest(transformations, type, alpha);
 
 		transformations.define("gl_ProjectionMatrix", "iris_ProjMat");

File: src/main/java/net/coderbot/iris/gl/GLDebug.java
Patch:
@@ -107,6 +107,7 @@ public static int setupDebugMessageCallback(PrintStream stream) {
 			if (caps.OpenGL30 && (GL43C.glGetInteger(33310) & 2) == 0) {
 				Iris.logger.warn("[GL] Warning: A non-debug context may not produce any debug output.");
 				GL43C.glEnable(37600);
+				return 2;
 			}
 			return 1;
 		} else if (caps.GL_ARB_debug_output) {
@@ -148,7 +149,6 @@ public static int disableDebugMessages() {
 		} else if (caps.GL_KHR_debug) {
 			KHRDebug.glDebugMessageCallback(null, 0L);
 			if (caps.OpenGL30 && (GL43C.glGetInteger(33310) & 2) == 0) {
-				Iris.logger.warn("[GL] Warning: A non-debug context may not produce any debug output.");
 				GL43C.glDisable(37600);
 			}
 			return 1;

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -390,7 +390,7 @@ private static void setDebug(boolean enable) {
 		if (Minecraft.getInstance().player != null) {
 			Minecraft.getInstance().player.displayClientMessage(new TranslatableComponent(success != 0 ? (enable ? "iris.shaders.debug.enabled" : "iris.shaders.debug.disabled") : "iris.shaders.debug.failure"), false);
 			if (success == 2) {
-				Minecraft.getInstance().player.displayClientMessage(new TranslatableComponent("iris.shaders.debug.issue"), false);
+				Minecraft.getInstance().player.displayClientMessage(new TranslatableComponent("iris.shaders.debug.restart"), false);
 			}
 		}
 

File: src/main/java/net/coderbot/iris/gl/GLDebug.java
Patch:
@@ -23,7 +23,7 @@
 public final class GLDebug {
 	/**
 	 * Sets up debug callbacks
-	 * @return 0 for failure, 1 for success, 2 for "possible issue".
+	 * @return 0 for failure, 1 for success, 2 for restart required.
 	 */
 	public static int setupDebugMessageCallback() {
 		return setupDebugMessageCallback(APIUtil.DEBUG_STREAM);

File: src/main/java/net/coderbot/iris/mixin/sky/MixinClientLevelData_DisableVoidPlane.java
Patch:
@@ -19,7 +19,7 @@
  */
 @Mixin(ClientLevel.ClientLevelData.class)
 public class MixinClientLevelData_DisableVoidPlane {
-	@Inject(method = "getHorizonHeight()D", at = @At("HEAD"), cancellable = true)
+	@Inject(method = "getHorizonHeight", at = @At("HEAD"), cancellable = true)
 	private void iris$getHorizonHeight(CallbackInfoReturnable<Double> cir) {
 		FogType fogType = Minecraft.getInstance().gameRenderer.getMainCamera().getFluidInCamera();
 

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -65,6 +65,8 @@ public void getModDependencies(ModDependencyCollector d) {
         d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.slf4j:slf4j-api:1.7.12"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
         d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-resource-loader-v0", "0.4.8+3cc0f0907d"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
         d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.5+3cc0f0907d"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
+        d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-api-base", "0.4.0+3cc0f0907d"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
+        d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-command-api-v1", "1.1.3+3cc0f0907d"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
 
 		if (SODIUM) {
 			if (CUSTOM_SODIUM) {

File: src/main/java/net/coderbot/iris/IrisLogging.java
Patch:
@@ -41,11 +41,11 @@ public void warn(Object... o) {
 	}
 
 	public void info(String info) {
-		this.logger.warn(info);
+		this.logger.info(info);
 	}
 
 	public void info(String info, Object... o) {
-		this.logger.warn(info, o);
+		this.logger.info(info, o);
 	}
 
 	public void debug(String debug) {

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPipeline.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.coderbot.iris.gbuffer_overrides.matching.InputAvailability;
 import net.coderbot.iris.gbuffer_overrides.state.RenderTargetStateListener;
-import net.coderbot.iris.layer.GbufferProgram;
 import net.coderbot.iris.mixin.LevelRendererAccessor;
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.minecraft.client.Camera;
@@ -26,8 +25,6 @@ public interface WorldRenderingPipeline {
 	void beginHand();
 
 	void beginTranslucents();
-	void pushProgram(GbufferProgram program);
-	void popProgram(GbufferProgram program);
 	void finalizeLevelRendering();
 	void destroy();
 

File: src/main/java/net/coderbot/iris/mixin/vertices/MixinBufferBuilder.java
Patch:
@@ -126,7 +126,7 @@ public abstract class MixinBufferBuilder implements BufferVertexConsumer, BlockS
 		vertexCount = 0;
 
 		// TODO: Keep this in sync with the extensions
-		int extendedDataLength = (2 * 2) + (1 * 4) + (1 * 4);
+		int extendedDataLength = (2 * 2) + (2 * 4) + (1 * 4);
 
 		int stride = this.format.getVertexSize();
 

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -342,7 +342,8 @@ public DeferredWorldRenderingPipeline(ProgramSet programs) {
 		this.phase = WorldRenderingPhase.NONE;
 
 		this.sodiumTerrainPipeline = new SodiumTerrainPipeline(this, programs, createTerrainSamplers,
-				createShadowTerrainSamplers, createTerrainImages, createShadowTerrainImages);
+			shadowMapRenderer instanceof EmptyShadowMapRenderer || shadowMapRenderer == null ? null : createShadowTerrainSamplers,
+			createTerrainImages, createShadowTerrainImages);
 	}
 
 	private void checkWorld() {

File: src/main/java/net/coderbot/iris/shaderpack/option/ShaderPackOptions.java
Patch:
@@ -25,7 +25,7 @@ public ShaderPackOptions(IncludeGraph graph, Map<String, String> changedConfigs)
 		Map<AbsolutePackPath, OptionAnnotatedSource> allAnnotations = new HashMap<>();
 		OptionSet.Builder setBuilder = OptionSet.builder();
 
-		graph.computeWeaklyConnectedSubgraphs().forEach(subgraph -> {
+		graph.computeWeaklyConnectedComponents().forEach(subgraph -> {
 			ImmutableMap.Builder<AbsolutePackPath, OptionAnnotatedSource> annotationBuilder = ImmutableMap.builder();
 			Set<String> referencedBooleanDefines = new HashSet<>();
 

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -59,7 +59,7 @@ public static void addCommonUniforms(DynamicUniformHolder uniforms, IdMap idMap,
 		IdMapUniforms.addIdMapUniforms(uniforms, idMap);
 		IrisExclusiveUniforms.addIrisExclusiveUniforms(uniforms);
 		MatrixUniforms.addMatrixUniforms(uniforms, directives);
-		HardcodedCustomUniforms.addHardcodedCustomUniforms(directives, uniforms, updateNotifier);
+		HardcodedCustomUniforms.addHardcodedCustomUniforms(uniforms, updateNotifier);
 		FogUniforms.addFogUniforms(uniforms);
 
 		// TODO: OptiFine doesn't think that atlasSize is a "dynamic" uniform,

File: src/main/java/net/coderbot/iris/uniforms/HardcodedCustomUniforms.java
Patch:
@@ -50,7 +50,7 @@ public static void addHardcodedCustomUniforms(PackDirectives directives, Uniform
 		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "night", HardcodedCustomUniforms::getNight);
 		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "dawnDusk", HardcodedCustomUniforms::getDawnDusk);
 		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "shdFade", HardcodedCustomUniforms::getShdFade);
-		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "isPrecipitationRain", new SmoothedFloat(20, 10, () -> (getRawPrecipitation() == 1 && tracker.getCurrentCameraPosition().y < 96.0f) ? 1 : 0, updateNotifier));
+		holder.uniform1f(UniformUpdateFrequency.PER_FRAME, "isPrecipitationRain", new SmoothedFloat(6, 6, () -> (getRawPrecipitation() == 1 && tracker.getCurrentCameraPosition().y < 96.0f) ? 1 : 0, updateNotifier));
 	}
 
 	private static float getEyeInCave() {

File: src/main/java/net/coderbot/iris/uniforms/HardcodedCustomUniforms.java
Patch:
@@ -149,11 +149,11 @@ private static float getAdjTime() {
 	}
 
 	private static float getDay() {
-		return (float) Math.clamp(5.5 - getAdjTime(), 0.0, 1.0);
+		return (float) Math.clamp(0.0, 1.0, 5.5 - getAdjTime());
 	}
 
 	private static float getNight() {
-		return (float) Math.clamp(getAdjTime() - 6.0, 0.0, 1.0);
+		return (float) Math.clamp( 0.0, 1.0, getAdjTime() - 6.0);
 	}
 
 	private static float getDawnDusk() {
@@ -168,6 +168,6 @@ private static Vector3f getNLightPos(PackDirectives directives) {
 	}
 
 	private static float getShdFade() {
-		return (float) Math.clamp(1.0 - (Math.abs(Math.abs(CelestialUniforms.getSunAngle() - 0.5) - 0.25) - 0.225) * 40.0, 0.0, 1.0);
+		return (float) Math.clamp(0.0, 1.0, 1.0 - (Math.abs(Math.abs(CelestialUniforms.getSunAngle() - 0.5) - 0.25) - 0.225) * 40.0);
 	}
 }

File: src/main/java/net/coderbot/iris/pipeline/newshader/TriforcePatcher.java
Patch:
@@ -457,7 +457,7 @@ private static void fixVersion(Transformations transformations) {
 				throw new IllegalStateException("Expected \"compatibility\" after the GLSL version: #version " + actualVersion);
 			}
 		} else {
-			actualVersion = "150 core";
+			actualVersion = "330 core";
 		}
 
 		beforeVersion = beforeVersion.trim();

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/shader_overrides/IrisChunkProgramOverrides.java
Patch:
@@ -149,7 +149,6 @@ private GlProgram<IrisChunkShaderInterface> createShader(IrisTerrainPass pass, S
                     .bindAttribute("mc_midTexCoord", IrisChunkShaderBindingPoints.MID_TEX_COORD)
                     .bindAttribute("at_tangent", IrisChunkShaderBindingPoints.TANGENT)
                     .bindAttribute("a_Normal", IrisChunkShaderBindingPoints.NORMAL)
-					.bindFragmentData("iris_FragData", ChunkShaderBindingPoints.FRAG_COLOR)
 					.link((shader) -> {
 						// TODO: Better way for this? It's a bit too much casting for me.
 						int handle = ((GlObject) shader).handle();

File: buildscript/src/main/java/MultiSrcDirFabricProject.java
Patch:
@@ -53,6 +53,9 @@ public JavaJarDependency build() {
 			for (Path p : paths("java", false)) {
 				compilation.addSourceDir(p);
 			}
+			for (Path p : paths("java", true, true)) {
+				headerSourceSets.add(p);
+			}
 			ProcessingSponge compilationOutput = new ProcessingSponge();
 			JavaCompilationResult compileResult = compilation.compile();
 

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -106,14 +106,14 @@ public Path[] paths(String subdir, boolean onlyHeaders) {
             Collections.addAll(
                 r,
                 getProjectDir().resolve("src").resolve("main").resolve(subdir),
-                getProjectDir().resolve("src").resolve("vendored").resolve(subdir)
-            );
+                getProjectDir().resolve("src").resolve("vendored").resolve(subdir));
             if (SODIUM) {
                 r.add(getProjectDir().resolve("src").resolve("sodiumCompatibility").resolve(subdir));
             } else {
                 r.add(getProjectDir().resolve("src").resolve("noSodiumStub").resolve(subdir));
             }
-        } else if (headers) {
+        }
+        if (headers) {
             r.add(getProjectDir().resolve("src").resolve("headers").resolve(subdir));
         }
         r.removeIf(p -> !Files.exists(p));

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -113,8 +113,9 @@ public Path[] paths(String subdir, boolean onlyHeaders) {
             } else {
                 r.add(getProjectDir().resolve("src").resolve("noSodiumStub").resolve(subdir));
             }
+        } else if (headers) {
+            r.add(getProjectDir().resolve("src").resolve("headers").resolve(subdir));
         }
-        r.add(getProjectDir().resolve("src").resolve("headers").resolve(subdir));
         r.removeIf(p -> !Files.exists(p));
         return r.toArray(new Path[0]);
     }

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -38,12 +38,12 @@ public static ExtendedShader create(String name, ProgramSource source, GlFramebu
 		BlendModeOverride blendModeOverride = source.getDirectives().getBlendModeOverride();
 
 		ShaderAttributeInputs inputs = new ShaderAttributeInputs(vertexFormat, isFullbright);
-		String vertex = TriforcePatcher.patchVanilla(source.getVertexSource().orElseThrow(RuntimeException::new), ShaderType.VERTEX, alpha, true, inputs);
+		String vertex = Patcher.getInstance().patchVanilla(source.getVertexSource().orElseThrow(RuntimeException::new), ShaderType.VERTEX, alpha, true, inputs);
 		String geometry = null;
 		if (source.getGeometrySource().isPresent()) {
-			geometry = TriforcePatcher.patchVanilla(source.getGeometrySource().get(), ShaderType.GEOMETRY, alpha, true, inputs);
+			geometry = Patcher.getInstance().patchVanilla(source.getGeometrySource().get(), ShaderType.GEOMETRY, alpha, true, inputs);
 		}
-		String fragment = TriforcePatcher.patchVanilla(source.getFragmentSource().orElseThrow(RuntimeException::new), ShaderType.FRAGMENT, alpha, true, inputs);
+		String fragment = Patcher.getInstance().patchVanilla(source.getFragmentSource().orElseThrow(RuntimeException::new), ShaderType.FRAGMENT, alpha, true, inputs);
 
 		StringBuilder shaderJson = new StringBuilder("{\n" +
 				"    \"blend\": {\n" +

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderer.java
Patch:
@@ -23,9 +23,9 @@
 import net.coderbot.iris.gl.sampler.SamplerLimits;
 import net.coderbot.iris.gl.shader.ShaderType;
 import net.coderbot.iris.gl.uniform.UniformUpdateFrequency;
-import net.coderbot.iris.pipeline.newshader.TriforcePatcher;
 import net.coderbot.iris.rendertarget.RenderTargets;
 import net.coderbot.iris.pipeline.newshader.FogMode;
+import net.coderbot.iris.pipeline.newshader.Patcher;
 import net.coderbot.iris.samplers.IrisImages;
 import net.coderbot.iris.samplers.IrisSamplers;
 import net.coderbot.iris.shaderpack.PackDirectives;
@@ -216,14 +216,14 @@ private static void setupMipmapping(net.coderbot.iris.rendertarget.RenderTarget
 	// TODO: Don't just copy this from DeferredWorldRenderingPipeline
 	private Program createProgram(ProgramSource source, ImmutableSet<Integer> flipped, ImmutableSet<Integer> flippedAtLeastOnceSnapshot,
 														   Supplier<ShadowMapRenderer> shadowMapRendererSupplier) {
-		String vertex = TriforcePatcher.patchComposite(source.getVertexSource().orElseThrow(RuntimeException::new), ShaderType.VERTEX);
+		String vertex = Patcher.getInstance().patchComposite(source.getVertexSource().orElseThrow(RuntimeException::new), ShaderType.VERTEX);
 
 		String geometry = null;
 		if (source.getGeometrySource().isPresent()) {
 			geometry = TriforcePatcher.patchComposite(source.getGeometrySource().orElseThrow(RuntimeException::new), ShaderType.GEOMETRY);
 		}
 
-		String fragment = TriforcePatcher.patchComposite(source.getFragmentSource().orElseThrow(RuntimeException::new), ShaderType.FRAGMENT);
+		String fragment = Patcher.getInstance().patchComposite(source.getFragmentSource().orElseThrow(RuntimeException::new), ShaderType.FRAGMENT);
 
 		ProgramBuilder builder;
 

File: src/main/java/net/coderbot/iris/postprocess/FinalPassRenderer.java
Patch:
@@ -16,7 +16,7 @@
 import net.coderbot.iris.gl.sampler.SamplerLimits;
 import net.coderbot.iris.gl.uniform.UniformUpdateFrequency;
 import net.coderbot.iris.pipeline.newshader.FogMode;
-import net.coderbot.iris.pipeline.newshader.TriforcePatcher;
+import net.coderbot.iris.pipeline.newshader.Patcher;
 import net.coderbot.iris.rendertarget.FramebufferBlitter;
 import net.coderbot.iris.rendertarget.RenderTarget;
 import net.coderbot.iris.rendertarget.RenderTargets;
@@ -249,14 +249,14 @@ private static void resetRenderTarget(RenderTarget target) {
 	// TODO: Don't just copy this from DeferredWorldRenderingPipeline
 	private Program createProgram(ProgramSource source, ImmutableSet<Integer> flipped, ImmutableSet<Integer> flippedAtLeastOnceSnapshot,
 								  Supplier<ShadowMapRenderer> shadowMapRendererSupplier) {
-		String vertex = TriforcePatcher.patchComposite(source.getVertexSource().orElseThrow(RuntimeException::new), ShaderType.VERTEX);
+		String vertex = Patcher.getInstance().patchComposite(source.getVertexSource().orElseThrow(RuntimeException::new), ShaderType.VERTEX);
 
 		String geometry = null;
 		if (source.getGeometrySource().isPresent()) {
 			geometry = TriforcePatcher.patchComposite(source.getGeometrySource().orElseThrow(RuntimeException::new), ShaderType.GEOMETRY);
 		}
 
-		String fragment = TriforcePatcher.patchComposite(source.getFragmentSource().orElseThrow(RuntimeException::new), ShaderType.FRAGMENT);
+		String fragment = Patcher.getInstance().patchComposite(source.getFragmentSource().orElseThrow(RuntimeException::new), ShaderType.FRAGMENT);
 
 		Objects.requireNonNull(flipped);
 

File: src/main/java/net/coderbot/iris/vertices/IrisVertexFormats.java
Patch:
@@ -16,7 +16,7 @@ public class IrisVertexFormats {
 	static {
 		ENTITY_ELEMENT = new VertexFormatElement(11, VertexFormatElement.Type.SHORT, VertexFormatElement.Usage.GENERIC, 2);
 		MID_TEXTURE_ELEMENT = new VertexFormatElement(12, VertexFormatElement.Type.FLOAT, VertexFormatElement.Usage.GENERIC, 2);
-		TANGENT_ELEMENT = new VertexFormatElement(13, VertexFormatElement.Type.INT, VertexFormatElement.Usage.GENERIC, 1);
+		TANGENT_ELEMENT = new VertexFormatElement(13, VertexFormatElement.Type.BYTE, VertexFormatElement.Usage.GENERIC, 4);
 
 		ImmutableList.Builder<VertexFormatElement> terrainElements = ImmutableList.builder();
 		ImmutableList.Builder<VertexFormatElement> entityElements = ImmutableList.builder();

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/terrain_xhfp/QuadViewTerrain.java
Patch:
@@ -35,7 +35,6 @@ private static float normalizeVertexTextureShortAsFloat(short value) {
 		return (value & 0xFFFF) * (1.0f / 32768.0f);
 	}
 
-	// TODO: Verify that this works with the new changes to the CVF
 	private static float normalizeVertexPositionShortAsFloat(short value) {
 		return (value & 0xFFFF) * (1.0f / 65535.0f);
 	}

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/vertex_format/entity/MixinQuadVertexType.java
Patch:
@@ -20,7 +20,7 @@ public class MixinQuadVertexType {
 	 * @author IMS
 	 * @reason Redirects don't work here
 	 */
-	@Overwrite
+	@Overwrite(remap = false)
 	public QuadVertexSink createBufferWriter(VertexBufferView buffer, boolean direct) {
 		if (IrisApi.getInstance().isShaderPackInUse()) {
 			return direct ? new EntityVertexBufferWriterUnsafe(buffer) : new EntityVertexBufferWriterNio(buffer);

File: src/main/java/net/coderbot/iris/IrisLogging.java
Patch:
@@ -41,11 +41,11 @@ public void warn(Object... o) {
 	}
 
 	public void info(String info) {
-		this.logger.warn(info);
+		this.logger.info(info);
 	}
 
 	public void info(String info, Object... o) {
-		this.logger.warn(info, o);
+		this.logger.info(info, o);
 	}
 
 	public void debug(String debug) {

File: src/main/java/net/coderbot/batchedentityrendering/mixin/RenderTypeAccessor.java
Patch:
@@ -1,12 +1,9 @@
 package net.coderbot.batchedentityrendering.mixin;
 
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.client.renderer.RenderType;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
 
-@Environment(EnvType.CLIENT)
 @Mixin(RenderType.class)
 public interface RenderTypeAccessor {
 	@Accessor("sortOnUpload")

File: src/main/java/net/coderbot/iris/gl/shader/ProgramCreator.java
Patch:
@@ -16,9 +16,9 @@ public static int create(String name, GlShader... shaders) {
 
 		// TODO: This is *really* hardcoded, we need to refactor this to support external calls
 		// to glBindAttribLocation
-		IrisRenderSystem.bindAttributeLocation(program, 10, "mc_Entity");
-		IrisRenderSystem.bindAttributeLocation(program, 11, "mc_midTexCoord");
-		IrisRenderSystem.bindAttributeLocation(program, 12, "at_tangent");
+		IrisRenderSystem.bindAttributeLocation(program, 11, "mc_Entity");
+		IrisRenderSystem.bindAttributeLocation(program, 12, "mc_midTexCoord");
+		IrisRenderSystem.bindAttributeLocation(program, 13, "at_tangent");
 
 		for (GlShader shader : shaders) {
 			GlStateManager.glAttachShader(program, shader.getHandle());

File: src/main/java/net/coderbot/iris/gl/state/StateUpdateNotifiers.java
Patch:
@@ -10,5 +10,7 @@ public class StateUpdateNotifiers {
 	public static ValueUpdateNotifier fogToggleNotifier;
 	public static ValueUpdateNotifier fogModeNotifier;
 	public static ValueUpdateNotifier fogDensityNotifier;
+	public static ValueUpdateNotifier blendFuncNotifier;
 	public static ValueUpdateNotifier atlasTextureNotifier;
+	public static ValueUpdateNotifier phaseChangeNotifier;
 }

File: src/main/java/net/coderbot/iris/gl/uniform/DynamicUniformHolder.java
Patch:
@@ -2,6 +2,7 @@
 
 import net.coderbot.iris.vendored.joml.Vector2i;
 import net.coderbot.iris.vendored.joml.Vector4f;
+import net.coderbot.iris.vendored.joml.Vector4i;
 
 import java.util.function.DoubleSupplier;
 import java.util.function.IntSupplier;
@@ -14,4 +15,5 @@ public interface DynamicUniformHolder extends UniformHolder {
 	DynamicUniformHolder uniform1i(String name, IntSupplier value, ValueUpdateNotifier notifier);
 	DynamicUniformHolder uniform2i(String name, Supplier<Vector2i> value, ValueUpdateNotifier notifier);
 	DynamicUniformHolder uniform4f(String name, Supplier<Vector4f> value, ValueUpdateNotifier notifier);
+	DynamicUniformHolder uniform4i(String name, Supplier<Vector4i> value, ValueUpdateNotifier notifier);
 }

File: src/main/java/net/coderbot/iris/gl/uniform/UniformType.java
Patch:
@@ -7,5 +7,6 @@ public enum UniformType {
 	VEC2,
 	VEC2I,
 	VEC3,
-	VEC4
+	VEC4,
+	VEC4I
 }

File: src/main/java/net/coderbot/iris/gui/option/IrisVideoSettings.java
Patch:
@@ -28,7 +28,6 @@ public static boolean isShadowDistanceSliderEnabled() {
 				.orElse(true);
 	}
 
-	// TODO: Add a Sodium video settings button too.
 	public static final ProgressOption RENDER_DISTANCE = new ShadowDistanceOption("options.iris.shadowDistance", 0.0D, 32.0D, 1.0F, (gameOptions) -> {
 		return (double) getOverriddenShadowDistance(shadowDistance);
 	}, (gameOptions, viewDistance) -> {

File: src/main/java/net/coderbot/iris/mixin/MixinBlockStateBehavior.java
Patch:
@@ -1,8 +1,6 @@
 package net.coderbot.iris.mixin;
 
 import net.coderbot.iris.block_rendering.BlockRenderingSettings;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.core.BlockPos;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.block.Block;
@@ -24,7 +22,6 @@ public abstract class MixinBlockStateBehavior {
 	 * @author IMS
 	 * @reason ambientOcclusionLevel support
 	 */
-	@Environment(EnvType.CLIENT)
 	@Deprecated
 	@Overwrite
 	public float getShadeBrightness(BlockGetter blockGetter, BlockPos blockPos) {

File: src/main/java/net/coderbot/iris/mixin/MixinEntityRenderDispatcher.java
Patch:
@@ -7,14 +7,11 @@
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.client.renderer.MultiBufferSource;
 import net.minecraft.client.renderer.entity.EntityRenderDispatcher;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.LevelReader;
 
-@Environment(EnvType.CLIENT)
 @Mixin(EntityRenderDispatcher.class)
 public class MixinEntityRenderDispatcher {
 	private static final String RENDER_SHADOW =

File: src/main/java/net/coderbot/iris/mixin/MixinParticleEngine.java
Patch:
@@ -4,6 +4,7 @@
 
 import net.coderbot.iris.layer.GbufferProgram;
 import net.coderbot.iris.layer.GbufferPrograms;
+import net.coderbot.iris.pipeline.WorldRenderingPhase;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
@@ -12,14 +13,11 @@
 import net.minecraft.client.particle.ParticleEngine;
 import net.minecraft.client.renderer.LightTexture;
 import net.minecraft.client.renderer.MultiBufferSource;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 
 /**
  * Ensures that all particles are rendered with the textured_lit shader program.
  */
 @Mixin(ParticleEngine.class)
-@Environment(EnvType.CLIENT)
 public class MixinParticleEngine {
 	private static final String RENDER =
 			"Lnet/minecraft/client/particle/ParticleEngine;render(Lcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/client/renderer/MultiBufferSource$BufferSource;Lnet/minecraft/client/renderer/LightTexture;Lnet/minecraft/client/Camera;F)V";
@@ -28,13 +26,15 @@ public class MixinParticleEngine {
 	private void iris$beginDrawingParticles(PoseStack poseStack, MultiBufferSource.BufferSource bufferSource,
 											 LightTexture lightTexture, Camera camera, float f,
 											 CallbackInfo ci) {
+		GbufferPrograms.setPhase(WorldRenderingPhase.PARTICLES);
 		GbufferPrograms.push(GbufferProgram.TEXTURED_LIT);
 	}
 
 	@Inject(method = RENDER, at = @At("RETURN"))
 	private void iris$finishDrawingParticles(PoseStack poseStack, MultiBufferSource.BufferSource bufferSource,
 										LightTexture lightTexture, Camera camera, float f,
 										CallbackInfo ci) {
+		GbufferPrograms.setPhase(WorldRenderingPhase.NONE);
 		GbufferPrograms.pop(GbufferProgram.TEXTURED_LIT);
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/MixinTitleScreen.java
Patch:
@@ -1,11 +1,11 @@
 package net.coderbot.iris.mixin;
 
 import net.coderbot.iris.Iris;
+import net.coderbot.iris.compat.sodium.SodiumVersionCheck;
 import net.fabricmc.loader.api.FabricLoader;
 import net.minecraft.ChatFormatting;
 import net.minecraft.Util;
 import net.minecraft.client.Minecraft;
-import net.minecraft.client.gui.screens.AlertScreen;
 import net.minecraft.client.gui.screens.ConfirmScreen;
 import net.minecraft.client.gui.screens.TitleScreen;
 import net.minecraft.network.chat.TranslatableComponent;
@@ -35,7 +35,7 @@ public class MixinTitleScreen {
 				(boolean accepted) -> {
 					if (accepted) {
 						try {
-							Util.getPlatform().openUri(new URI(Iris.SODIUM_DOWNLOAD_LINK));
+							Util.getPlatform().openUri(new URI(SodiumVersionCheck.getDownloadLink()));
 						} catch (URISyntaxException e) {
 							throw new IllegalStateException(e);
 						}

File: src/main/java/net/coderbot/iris/mixin/MixinTweakFarPlane.java
Patch:
@@ -2,8 +2,6 @@
 
 import com.mojang.blaze3d.vertex.PoseStack;
 import net.coderbot.iris.Iris;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.client.renderer.GameRenderer;
 import org.lwjgl.opengl.GL;
 import org.spongepowered.asm.mixin.Mixin;
@@ -34,7 +32,6 @@
  *
  * Fun.
  */
-@Environment(EnvType.CLIENT)
 @Mixin(GameRenderer.class)
 public class MixinTweakFarPlane {
 	@Shadow

File: src/main/java/net/coderbot/iris/mixin/fabulous/MixinDisableFabulousGraphics.java
Patch:
@@ -6,14 +6,11 @@
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.client.GraphicsStatus;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.Options;
 import net.minecraft.client.renderer.LevelRenderer;
 
-@Environment(EnvType.CLIENT)
 @Mixin(LevelRenderer.class)
 public class MixinDisableFabulousGraphics {
 	@Inject(method = "onResourceManagerReload", at = @At("HEAD"))

File: src/main/java/net/coderbot/iris/mixin/normals/MixinFixEntityVertexNormals.java
Patch:
@@ -8,8 +8,6 @@
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.Slice;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.client.Camera;
 import net.minecraft.client.renderer.GameRenderer;
 import net.minecraft.client.renderer.LevelRenderer;
@@ -33,7 +31,6 @@
  * This mixin has been disabled for now, since the behavior without it matches OptiFine's current behavior on 1.16.3. It
  * has been preserved for now in case it ends up being necessary again at some point in the future.
  */
-@Environment(EnvType.CLIENT)
 @Mixin(LevelRenderer.class)
 public class MixinFixEntityVertexNormals {
 	private static final String RENDER_LEVEL = "Lnet/minecraft/client/renderer/LevelRenderer;renderLevel(Lcom/mojang/blaze3d/vertex/PoseStack;FJZLnet/minecraft/client/Camera;Lnet/minecraft/client/renderer/GameRenderer;Lnet/minecraft/client/renderer/LightTexture;Lcom/mojang/math/Matrix4f;)V";

File: src/main/java/net/coderbot/iris/mixin/rendertype/MixinFixEyesTranslucency.java
Patch:
@@ -4,12 +4,9 @@
 import org.spongepowered.asm.mixin.Unique;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Redirect;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.client.renderer.RenderStateShard;
 import net.minecraft.client.renderer.RenderType;
 
-@Environment(EnvType.CLIENT)
 @Mixin(RenderType.class)
 public class MixinFixEyesTranslucency {
 	// Minecraft interprets an alpha value of zero as a signal to disable the alpha test.

File: src/main/java/net/coderbot/iris/mixin/rendertype/RenderStateShardAccessor.java
Patch:
@@ -2,11 +2,8 @@
 
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.client.renderer.RenderStateShard;
 
-@Environment(EnvType.CLIENT)
 @Mixin(RenderStateShard.class)
 public interface RenderStateShardAccessor {
 	@Accessor("name")

File: src/main/java/net/coderbot/iris/mixin/rendertype/RenderTypeAccessor.java
Patch:
@@ -2,11 +2,8 @@
 
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.client.renderer.RenderType;
 
-@Environment(EnvType.CLIENT)
 @Mixin(RenderType.class)
 public interface RenderTypeAccessor {
 	@Accessor("sortOnUpload")

File: src/main/java/net/coderbot/iris/mixin/texunits/MixinBufferVertexConsumer.java
Patch:
@@ -2,14 +2,11 @@
 
 import com.mojang.blaze3d.vertex.BufferVertexConsumer;
 import net.coderbot.iris.texunits.TextureUnit;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.Constant;
 import org.spongepowered.asm.mixin.injection.ModifyConstant;
 
 @Mixin(BufferVertexConsumer.class)
-@Environment(EnvType.CLIENT)
 public interface MixinBufferVertexConsumer {
 	@ModifyConstant(method = "overlayCoords", constant = @Constant(intValue = 1), require = 1)
 	default int iris$fixOverlayIndex(int index) {

File: src/main/java/net/coderbot/iris/mixin/texunits/MixinDefaultVertexFormat.java
Patch:
@@ -7,11 +7,8 @@
 import org.spongepowered.asm.mixin.injection.Constant;
 import org.spongepowered.asm.mixin.injection.ModifyConstant;
 import org.spongepowered.asm.mixin.injection.Slice;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 
 @Mixin(DefaultVertexFormat.class)
-@Environment(EnvType.CLIENT)
 public class MixinDefaultVertexFormat {
 	@ModifyConstant(method = "<clinit>", constant = @Constant(intValue = 1), require = 1, slice = @Slice(
 		from = @At(value = "FIELD", target = "Lcom/mojang/blaze3d/vertex/DefaultVertexFormat;ELEMENT_UV0:Lcom/mojang/blaze3d/vertex/VertexFormatElement;"),

File: src/main/java/net/coderbot/iris/mixin/texunits/MixinLightTexture.java
Patch:
@@ -5,16 +5,13 @@
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.Constant;
 import org.spongepowered.asm.mixin.injection.ModifyConstant;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.client.renderer.LightTexture;
 
 /**
  * Modifies {@link LightTexture} to use a configurable texture unit, instead of being hardcoded to texture
  * unit #2.
  */
 @Mixin(LightTexture.class)
-@Environment(EnvType.CLIENT)
 public class MixinLightTexture {
 	@ModifyConstant(method = "turnOffLightLayer", constant = @Constant(intValue = GL15.GL_TEXTURE2), require = 1)
 	private int iris$fixLightmapTextureUnit$disable(int texUnit) {

File: src/main/java/net/coderbot/iris/mixin/texunits/MixinOverlayTexture.java
Patch:
@@ -5,12 +5,9 @@
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.Constant;
 import org.spongepowered.asm.mixin.injection.ModifyConstant;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.client.renderer.texture.OverlayTexture;
 
 @Mixin(OverlayTexture.class)
-@Environment(EnvType.CLIENT)
 public class MixinOverlayTexture {
 	@ModifyConstant(method = "<init>()V", constant = @Constant(intValue = GL15.GL_TEXTURE1), require = 1)
 	private int iris$fixOverlayTextureUnit(int texUnit) {

File: src/main/java/net/coderbot/iris/postprocess/CenterDepthSampler.java
Patch:
@@ -18,7 +18,7 @@ public CenterDepthSampler(RenderTargets renderTargets, FrameUpdateNotifier updat
 		// NB: This will always be one frame behind compared to the current frame.
 		// That's probably for the best, since it can help avoid some pipeline stalls.
 		// We're still going to get stalls, though.
-		centerDepthSmooth = new SmoothedFloat(1.0f, this::sampleCenterDepth, updateNotifier);
+		centerDepthSmooth = new SmoothedFloat(1.0f, 1.0f, this::sampleCenterDepth, updateNotifier);
 
 		// Prior to OpenGL 4.1, all framebuffers must have at least 1 color target.
 		depthBufferHolder = renderTargets.createFramebufferWritingToMain(new int[] {0});

File: src/main/java/net/coderbot/iris/postprocess/FinalPassRenderer.java
Patch:
@@ -198,7 +198,7 @@ public void renderFinalPass() {
 
 		for (int i = 0; i < SamplerLimits.get().getMaxTextureUnits(); i++) {
 			// Unbind all textures that we may have used.
-			// NB: This is necessary for shader pack reloading to work propely
+			// NB: This is necessary for shader pack reloading to work properly
 			RenderSystem.activeTexture(GL15C.GL_TEXTURE0 + i);
 			RenderSystem.bindTexture(0);
 		}

File: src/main/java/net/coderbot/iris/samplers/IrisSamplers.java
Patch:
@@ -115,6 +115,7 @@ public static boolean addShadowSamplers(SamplerHolder samplers, ShadowMapRendere
 	public static void addLevelSamplers(SamplerHolder samplers, AbstractTexture normals, AbstractTexture specular) {
 		samplers.addExternalSampler(TextureUnit.TERRAIN.getSamplerId(), "tex", "texture", "gtexture");
 		samplers.addExternalSampler(TextureUnit.LIGHTMAP.getSamplerId(), "lightmap");
+		samplers.addExternalSampler(TextureUnit.OVERLAY.getSamplerId(), "iris_overlay");
 		samplers.addDynamicSampler(normals::getId, "normals");
 		samplers.addDynamicSampler(specular::getId, "specular");
 	}

File: src/main/java/net/coderbot/iris/shaderpack/transform/Transformations.java
Patch:
@@ -4,6 +4,7 @@ public interface Transformations {
 	boolean contains(String content);
 	void injectLine(InjectionPoint at, String line);
 	void replaceExact(String from, String to);
+	void replaceRegex(String regex, String to);
 	String getPrefix();
 	void setPrefix(String prefix);
 	void define(String key, String value);

File: src/main/java/net/coderbot/iris/shadows/ShadowRenderingState.java
Patch:
@@ -9,6 +9,6 @@ public static boolean areShadowsCurrentlyBeingRendered() {
 	}
 
 	public static Matrix4f getShadowOrthoMatrix() {
-		return ShadowRenderer.ACTIVE ? ShadowRenderer.ORTHO.copy() : null;
+		return ShadowRenderer.ACTIVE ? ShadowRenderer.PROJECTION.copy() : null;
 	}
 }

File: src/main/java/net/coderbot/iris/uniforms/CameraUniforms.java
Patch:
@@ -36,7 +36,7 @@ public static Vector3d getUnshiftedCameraPosition() {
 		return JomlConversions.fromVec3(client.gameRenderer.getMainCamera().getPosition());
 	}
 
-	private static class CameraPositionTracker {
+	static class CameraPositionTracker {
 		/**
 		 * Value range of cameraPosition. We want this to be small enough that precision is maintained when we convert
 		 * from a double to a float, but big enough that shifts happen infrequently, since each shift corresponds with
@@ -49,7 +49,7 @@ private static class CameraPositionTracker {
 		private Vector3d currentCameraPosition = new Vector3d();
 		private final Vector3d shift = new Vector3d();
 
-		private CameraPositionTracker(FrameUpdateNotifier notifier) {
+		CameraPositionTracker(FrameUpdateNotifier notifier) {
 			notifier.addListener(this::update);
 		}
 

File: src/main/java/net/coderbot/iris/uniforms/builtin/BuiltinReplacementUniforms.java
Patch:
@@ -4,10 +4,7 @@
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.gl.uniform.UniformHolder;
 import net.coderbot.iris.gl.uniform.UniformUpdateFrequency;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 
-@Environment(EnvType.CLIENT)
 public class BuiltinReplacementUniforms {
 	private static final Matrix4f lightmapTextureMatrix;
 

File: src/main/java/net/coderbot/iris/uniforms/transforms/SmoothedVec2f.java
Patch:
@@ -9,9 +9,9 @@ public class SmoothedVec2f implements Supplier<Vector2f> {
 	private final SmoothedFloat x;
 	private final SmoothedFloat y;
 
-	public SmoothedVec2f(float halfLife, Supplier<Vector2i> unsmoothed, FrameUpdateNotifier updateNotifier) {
-		x = new SmoothedFloat(halfLife, () -> unsmoothed.get().x, updateNotifier);
-		y = new SmoothedFloat(halfLife, () -> unsmoothed.get().y, updateNotifier);
+	public SmoothedVec2f(float halfLifeUp, float halfLifeDown, Supplier<Vector2i> unsmoothed, FrameUpdateNotifier updateNotifier) {
+		x = new SmoothedFloat(halfLifeUp, halfLifeDown, () -> unsmoothed.get().x, updateNotifier);
+		y = new SmoothedFloat(halfLifeUp, halfLifeDown, () -> unsmoothed.get().y, updateNotifier);
 	}
 
 	@Override

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/xhfp/QuadView.java
Patch:
@@ -5,7 +5,7 @@
 public class QuadView {
 	ByteBuffer buffer;
 	int writeOffset;
-	private static final int STRIDE = 48;
+	private static final int STRIDE = 36;
 
 	float x(int index) {
 		return normalizeVertexPositionShortAsFloat(buffer.getShort(writeOffset - STRIDE * (3 - index)));

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -118,7 +118,7 @@ public static void onRenderSystemInit() {
 		}
 
 		if (irisConfig.isDebugEnabled()) {
-			logger.warn("Debug features enabled, GLSL logging will be more verbose!");
+			logger.info("Debug features enabled, OpenGL error logging will be more verbose!");
 			GLDebug.setupDebugMessageCallback();
 		}
 

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/IrisModelVertexFormats.java
Patch:
@@ -3,7 +3,7 @@
 import me.jellysquid.mods.sodium.client.model.vertex.type.VanillaVertexType;
 import net.coderbot.iris.compat.sodium.impl.vertex_format.entity_xhfp.EntityVertexSink;
 import net.coderbot.iris.compat.sodium.impl.vertex_format.entity_xhfp.EntityVertexType;
-import net.coderbot.iris.compat.sodium.impl.vertex_format.xhfp.XHFPModelVertexType;
+import net.coderbot.iris.compat.sodium.impl.vertex_format.terrain_xhfp.XHFPModelVertexType;
 
 public class IrisModelVertexFormats {
     public static final XHFPModelVertexType MODEL_VERTEX_XHFP = new XHFPModelVertexType();

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/entity_xhfp/EntityVertexType.java
Patch:
@@ -7,6 +7,7 @@
 import me.jellysquid.mods.sodium.client.model.vertex.type.BlittableVertexType;
 import me.jellysquid.mods.sodium.client.model.vertex.type.VanillaVertexType;
 import net.coderbot.iris.compat.sodium.impl.vertex_format.entity_xhfp.writer.EntityVertexBufferWriterNio;
+import net.coderbot.iris.compat.sodium.impl.vertex_format.entity_xhfp.writer.EntityVertexBufferWriterUnsafe;
 import net.coderbot.iris.compat.sodium.impl.vertex_format.entity_xhfp.writer.EntityVertexWriterFallback;
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 
@@ -18,7 +19,7 @@ public EntityVertexSink createFallbackWriter(VertexConsumer consumer) {
 
     @Override
     public EntityVertexSink createBufferWriter(VertexBufferView buffer, boolean direct) {
-        return new EntityVertexBufferWriterNio(buffer);
+        return direct ? new EntityVertexBufferWriterUnsafe(buffer) : new EntityVertexBufferWriterNio(buffer);
     }
 
     @Override

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/terrain_xhfp/XHFPModelVertexBufferWriterNio.java
Patch:
@@ -1,4 +1,4 @@
-package net.coderbot.iris.compat.sodium.impl.vertex_format.xhfp;
+package net.coderbot.iris.compat.sodium.impl.vertex_format.terrain_xhfp;
 
 import me.jellysquid.mods.sodium.client.model.vertex.buffer.VertexBufferView;
 import me.jellysquid.mods.sodium.client.model.vertex.buffer.VertexBufferWriterNio;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/terrain_xhfp/XHFPModelVertexType.java
Patch:
@@ -1,4 +1,4 @@
-package net.coderbot.iris.compat.sodium.impl.vertex_format.xhfp;
+package net.coderbot.iris.compat.sodium.impl.vertex_format.terrain_xhfp;
 
 import com.mojang.blaze3d.vertex.VertexConsumer;
 import me.jellysquid.mods.sodium.client.gl.attribute.GlVertexAttributeFormat;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/vertex_format/entity/MixinModelPart.java
Patch:
@@ -77,7 +77,9 @@ private void compile(PoseStack.Pose pose, VertexConsumer vertexConsumer, int lig
                     drain.writeQuad(x2, y2, z2, color, vertex.u, vertex.v, light, overlay, norm);
                 }
 
-				((EntityVertexSink) drain).endQuad(quad.vertices.length, normX, normY, normZ);
+				if (drain instanceof EntityVertexSink) {
+					((EntityVertexSink) drain).endQuad(quad.vertices.length, normX, normY, normZ);
+				}
 			}
         }
 

File: src/main/java/net/coderbot/iris/uniforms/HardcodedCustomUniforms.java
Patch:
@@ -43,10 +43,9 @@ public static void addHardcodedCustomUniforms(UniformHolder holder, FrameUpdateN
 
 	private static float getEyeInCave() {
 		if (client.getCameraEntity().getEyeY() < 5.0) {
-			System.out.println(getEyeSkyBrightness() / 240F);
-			return getEyeSkyBrightness() / 240F;
+			return 1.0f - getEyeSkyBrightness() / 240F;
 		}
-		return 0.0F;
+		return 0.0f;
 	}
 
 	private static float getEyeSkyBrightness() {

File: src/main/java/net/coderbot/iris/mixin/rendertype/MixinRenderType_FixEyesTranslucency.java
Patch:
@@ -8,7 +8,7 @@
 import net.minecraft.client.renderer.RenderType;
 
 @Mixin(RenderType.class)
-public class MixinFixEyesTranslucency {
+public class MixinRenderType_FixEyesTranslucency {
 	// Minecraft interprets an alpha value of zero as a signal to disable the alpha test.
 	// However, we actually want to reject all nonzero alpha values.
 	//

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPipeline.java
Patch:
@@ -1,6 +1,7 @@
 package net.coderbot.iris.pipeline;
 
 import net.coderbot.iris.gbuffer_overrides.matching.InputAvailability;
+import net.coderbot.iris.gbuffer_overrides.state.RenderTargetStateListener;
 import net.coderbot.iris.layer.GbufferProgram;
 import net.coderbot.iris.mixin.LevelRendererAccessor;
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
@@ -18,6 +19,7 @@ public interface WorldRenderingPipeline {
 
 	void setPhase(WorldRenderingPhase phase);
 	void setInputs(InputAvailability availability);
+	RenderTargetStateListener getRenderTargetStateListener();
 
     void beginShadowRender();
 	void endShadowRender();

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPipeline.java
Patch:
@@ -1,5 +1,6 @@
 package net.coderbot.iris.pipeline;
 
+import net.coderbot.iris.gbuffer_overrides.matching.InputAvailability;
 import net.coderbot.iris.layer.GbufferProgram;
 import net.coderbot.iris.mixin.LevelRendererAccessor;
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
@@ -16,6 +17,7 @@ public interface WorldRenderingPipeline {
 	WorldRenderingPhase getPhase();
 
 	void setPhase(WorldRenderingPhase phase);
+	void setInputs(InputAvailability availability);
 
     void beginShadowRender();
 	void endShadowRender();

File: src/main/java/net/coderbot/iris/texunits/TextureUnit.java
Patch:
@@ -4,8 +4,8 @@
 
 public enum TextureUnit {
 	TERRAIN(0),
-	LIGHTMAP(1),
-	OVERLAY(2);
+	LIGHTMAP(2),
+	OVERLAY(1);
 
 	private final int samplerId;
 	private final int unitId;

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -130,7 +130,7 @@ public static ExtendedShader create(String name, ProgramSource source, GlFramebu
 			//SamplerUniforms.addWorldSamplerUniforms(uniforms);
 			//SamplerUniforms.addDepthSamplerUniforms(uniforms);
 			BuiltinReplacementUniforms.addBuiltinReplacementUniforms(uniforms);
-		}, parent);
+		}, isFullbright, parent);
 	}
 
 	public static FallbackShader createFallback(String name, GlFramebuffer writingToBeforeTranslucent,

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -111,7 +111,7 @@ public String getVersion() {
 			e.printStackTrace();
 		}
 
-		String baseVersion = super.getVersion().replace("-development-environment", "");
+		String baseVersion = super.getVersion().replace("development-environment", "");
 
 		return baseVersion + commitHash + (isDirty ? "-dirty" : "");
 	}

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -30,7 +30,7 @@ public class Buildscript extends MultiSrcDirFabricProject {
   
 	@Override
 	public VersionMeta createMcVersion() {
-		return Minecraft.getVersion("22w06a");
+		return Minecraft.getVersion("1.18.2-pre3");
 	}
   
 	@Override

File: src/main/java/net/coderbot/iris/mixin/MixinShaderInstance.java
Patch:
@@ -9,7 +9,6 @@
 import net.coderbot.iris.pipeline.newshader.fallback.FallbackShader;
 import net.minecraft.client.renderer.ShaderInstance;
 import net.minecraft.server.packs.resources.ResourceProvider;
-import org.apache.logging.log4j.Logger;
 import org.lwjgl.opengl.ARBTextureSwizzle;
 import org.lwjgl.opengl.GL20C;
 import org.lwjgl.opengl.GL30C;

File: src/main/java/net/coderbot/iris/mixin/MixinProgramType.java
Patch:
@@ -12,7 +12,7 @@
 @Mixin(Program.Type.class)
 public class MixinProgramType {
 	@SuppressWarnings("target")
-    @Shadow(remap = false)
+    @Shadow
     @Final
     @Mutable
     private static Program.Type[] $VALUES;

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/pbr_animation/MixinTextureAtlasSprite.java
Patch:
@@ -12,7 +12,7 @@
 
 @Mixin(TextureAtlasSprite.class)
 public class MixinTextureAtlasSprite {
-	@Inject(method = "markActive()V", at = @At("TAIL"))
+	@Inject(method = "markActive()V", at = @At("TAIL"), remap = false)
 	private void onTailMarkActive(CallbackInfo ci) {
 		TextureAtlasSpriteExtension extension = (TextureAtlasSpriteExtension) this;
 		if (extension.hasPBRSpriteHolder()) {

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -715,7 +715,6 @@ public void renderShadows(LevelRendererAccessor levelRenderer, Camera playerCame
 	@Override
 	public void addDebugText(List<String> messages) {
 		messages.add("[Iris] Shadow Maps: " + debugStringOverall);
-		messages.add("[Iris] Shadow Distance: " + terrainFrustumHolder.getDistanceInfo());
 		messages.add("[Iris] Shadow Distance Terrain: " + terrainFrustumHolder.getDistanceInfo() + " Entity: " + entityFrustumHolder.getDistanceInfo());
 		messages.add("[Iris] Shadow Culling Terrain: " + terrainFrustumHolder.getCullingInfo() + " Entity: " + entityFrustumHolder.getCullingInfo());
 		messages.add("[Iris] Shadow Terrain: " + debugStringTerrain

File: src/main/java/net/coderbot/iris/mixin/MixinLightTexture.java
Patch:
@@ -18,7 +18,7 @@ public class MixinLightTexture {
 	@Final
 	private Minecraft minecraft;
 
-	@Inject(method = "updateLightTexture", at = @At("HEAD"))
+	@Inject(method = "updateLightTexture", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/multiplayer/ClientLevel;getSkyDarken(F)F"))
 	private void resetDarknessValue(float $$0, CallbackInfo ci) {
 		CapturedRenderingState.INSTANCE.setDarknessLightFactor(0.0F);
 	}

File: src/main/java/net/coderbot/iris/texture/util/ImageScalingUtil.java
Patch:
@@ -103,8 +103,7 @@ private static int blendColor(int c0, int c1, int c2, int c3, float w0, float w1
 	}
 
 	private static int blendChannel(int v0, int v1, int v2, int v3, float w0, float w1, float w2, float w3) {
-//		return Math.round(v0 * w0 + v1 * w1 + v2 * w2 + v3 * w3);
-		return Math.round((float) Math.sqrt(v0*v0 * w0 + v1*v1 * w1 + v2*v2 * w2 + v3*v3 * w3));
+		return Math.round(v0 * w0 + v1 * w1 + v2 * w2 + v3 * w3);
 	}
 
 	private static int blendColor(int c0, int c1, float w0, float w1) {

File: src/main/java/net/coderbot/iris/texture/pbr/PBRAtlasTexture.java
Patch:
@@ -11,7 +11,7 @@
 
 import net.coderbot.iris.mixin.texture.pbr.TextureAtlasPreparationsAccessor;
 import net.coderbot.iris.texture.util.TextureColorUtil;
-import net.coderbot.iris.texture.util.TextureSaveUtil;
+import net.coderbot.iris.texture.util.TextureSavingUtil;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
@@ -83,7 +83,7 @@ public void reload(TextureAtlas.Preparations preparations) {
 		}
 
 		if (Boolean.parseBoolean(System.getProperty("iris.pbr.debug"))) {
-			TextureSaveUtil.saveTextures("atlas", id.getPath().replaceAll("/", "_"), glId, preparationsAccessor.getMipLevel(), preparationsAccessor.getWidth(), preparationsAccessor.getHeight());
+			TextureSavingUtil.saveTextures("atlas", id.getPath().replaceAll("/", "_"), glId, maxLevel, preparationsAccessor.getWidth(), preparationsAccessor.getHeight());
 		}
 	}
 

File: src/main/java/net/coderbot/iris/texture/util/TextureSavingUtil.java
Patch:
@@ -10,12 +10,12 @@
 import net.minecraft.Util;
 import net.minecraft.client.Minecraft;
 
-public class TextureSaveUtil {
+public class TextureSavingUtil {
 	public static void saveTextures(String directory, String filename, int textureId, int maxLevel, int width, int height) {
 		String extension = FilenameUtils.getExtension(filename);
 		String baseName = filename.substring(0, filename.length() - extension.length() - 1);
 		for (int level = 0; level <= maxLevel; ++level) {
-			saveTexture(directory, baseName + "_" + level + "." + extension, textureId, level, width, height);
+			saveTexture(directory, baseName + "_" + level + "." + extension, textureId, level, width >> level, height >> level);
 		}
 	}
 

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -60,16 +60,16 @@ public Consumer<AccessWidenerVisitor> getAw() {
     @Override
     public void getModDependencies(ModDependencyCollector d) {
         d.addMaven(Maven.MAVEN_CENTRAL, new MavenId("org.anarres:jcpp:1.4.14"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
-        d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-resource-loader-v0", "0.4.11+3ac43d9565"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
-        d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.8+c8aba2f365"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
+        d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-resource-loader-v0", "0.4.13+d7c144a83a"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
+        d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-key-binding-api-v1", "1.0.9+d7c144a83a"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME, ModDependencyFlag.JIJ);
 
 		if (SODIUM) {
 			d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-api-base", "0.4.1+b4f4f6cd65"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 			d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-rendering-data-attachment-v1", "0.3.4+7242e9d765"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 			d.addMaven(FabricMaven.URL, new MavenId(FabricMaven.GROUP_ID + ".fabric-api", "fabric-rendering-fluids-v1", "0.1.18+3ac43d9565"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 
 			if (CUSTOM_SODIUM) {
-				d.add(new JavaJarDependency(getProjectDir().resolve("custom_sodium").resolve(customSodiumName), null, new MavenId("me.jellysquid.mods", "sodium-fabric", "mc1.18.1-0.4.0-alpha6")), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
+				d.add(new JavaJarDependency(getProjectDir().resolve("custom_sodium").resolve(customSodiumName).toAbsolutePath(), null, new MavenId("me.jellysquid.mods", "sodium-fabric", customSodiumName.replace("sodium-fabric-", ""))), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 			} else {
 				d.addMaven("https://api.modrinth.com/maven", new MavenId("maven.modrinth", "sodium", "mc1.18.1-0.4.0-alpha6"), ModDependencyFlag.COMPILE, ModDependencyFlag.RUNTIME);
 			}

File: src/main/java/net/coderbot/iris/compat/sodium/SodiumVersionCheck.java
Patch:
@@ -11,8 +11,8 @@ public class SodiumVersionCheck {
 	// If you forget to edit the download links you'll cause the support team a bunch
 	// of pain. So don't forget!
 	private static final ImmutableList<AllowedSodiumVersion> ALLOWED_SODIUM_VERSIONS = ImmutableList.of(
-			// Official 0.3.4
-			AllowedSodiumVersion.exact("0.4.0-alpha6+build.69",
+			// Development build for 22w03a
+			AllowedSodiumVersion.exact("0.4.0-alpha6+build.3",
 					"https://www.curseforge.com/minecraft/mc-mods/sodium/files/3605309"),
 
 			// For use by ReplayMod

File: buildscript/src/main/java/Buildscript.java
Patch:
@@ -102,7 +102,7 @@ public String getVersion() {
 			e.printStackTrace();
 		}
 
-		String baseVersion = super.getVersion().replace("-development_environment", "");
+		String baseVersion = super.getVersion().replace("-development-environment", "");
 
 		return baseVersion + "-" + commitHash + (isDirty ? "-dirty" : "");
 	}

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -561,9 +561,9 @@ public static String getFormattedVersion() {
 		ChatFormatting color;
 		String version = getVersion();
 
-		if (version.endsWith("-development_environment")) {
+		if (version.endsWith("-development-environment")) {
 			color = ChatFormatting.GOLD;
-			version = version.replace("-development_environment", " (Development Environment)");
+			version = version.replace("-development-environment", " (Development Environment)");
 		} else if (version.endsWith("-dirty") || version.contains("unknown")) {
 			color = ChatFormatting.RED;
 		} else if (version.contains("+rev.")) {

File: buildscript/src/main/java/MultiSrcDirFabricProject.java
Patch:
@@ -110,7 +110,8 @@ public IdeProject getIdeProject() {
 			.javaVersion(getJavaVersion())
 			.dependencies(ideDependencies)
 			.sourcePaths(sourcePaths)
-			.resourcePaths(getResourcesDir())
+			// TODO: Audit runRunConfig behavior in BaseJavaProject - mixed references to IdeProject and RunConfig
+			.resourcePaths(paths("resources", false, true))
 			.runConfigs(
 				new IdeProject.RunConfig.RunConfigBuilder()
 					.name("Minecraft Client")

File: src/main/java/net/coderbot/batchedentityrendering/mixin/RenderTypeAccessor.java
Patch:
@@ -1,12 +1,9 @@
 package net.coderbot.batchedentityrendering.mixin;
 
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.client.renderer.RenderType;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
 
-@Environment(EnvType.CLIENT)
 @Mixin(RenderType.class)
 public interface RenderTypeAccessor {
 	@Accessor("sortOnUpload")

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -45,12 +45,9 @@
 import org.jetbrains.annotations.NotNull;
 import org.lwjgl.glfw.GLFW;
 import net.fabricmc.api.ClientModInitializer;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;
 import net.fabricmc.loader.api.FabricLoader;
 
-@Environment(EnvType.CLIENT)
 public class Iris implements ClientModInitializer {
 	public static final String MODID = "iris";
 	public static final Logger logger = LogManager.getLogger(MODID);

File: src/main/java/net/coderbot/iris/layer/GbufferProgram.java
Patch:
@@ -14,10 +14,13 @@ public enum GbufferProgram {
 	BLOCK_ENTITIES,
 	BEACON_BEAM,
 	ENTITIES,
+	ENTITY_NO_OVERLAY,
 	ENTITIES_GLOWING,
 	ARMOR_GLINT,
 	EYES,
+	EYES_NO_OVERLAY,
 	HAND,
+	HAND_NO_OVERLAY,
 	HAND_TRANSLUCENT,
 	LINES,
 	WEATHER

File: src/main/java/net/coderbot/iris/mixin/MixinBlockStateBehavior.java
Patch:
@@ -1,8 +1,6 @@
 package net.coderbot.iris.mixin;
 
 import net.coderbot.iris.block_rendering.BlockRenderingSettings;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.core.BlockPos;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.block.Block;
@@ -24,7 +22,6 @@ public abstract class MixinBlockStateBehavior {
 	 * @author IMS
 	 * @reason ambientOcclusionLevel support
 	 */
-	@Environment(EnvType.CLIENT)
 	@Deprecated
 	@Overwrite
 	public float getShadeBrightness(BlockGetter blockGetter, BlockPos blockPos) {

File: src/main/java/net/coderbot/iris/mixin/MixinEntityRenderDispatcher.java
Patch:
@@ -7,14 +7,11 @@
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.client.renderer.MultiBufferSource;
 import net.minecraft.client.renderer.entity.EntityRenderDispatcher;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.LevelReader;
 
-@Environment(EnvType.CLIENT)
 @Mixin(EntityRenderDispatcher.class)
 public class MixinEntityRenderDispatcher {
 	private static final String RENDER_SHADOW =

File: src/main/java/net/coderbot/iris/mixin/MixinGameRenderer.java
Patch:
@@ -21,8 +21,6 @@
 import org.spongepowered.asm.mixin.injection.Redirect;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.player.LocalPlayer;
 import net.minecraft.client.renderer.GameRenderer;
@@ -36,7 +34,6 @@
 import java.util.function.Function;
 
 @Mixin(GameRenderer.class)
-@Environment(EnvType.CLIENT)
 public class MixinGameRenderer {
 	@Shadow
 	private boolean renderHand;

File: src/main/java/net/coderbot/iris/mixin/MixinLevelRenderer.java
Patch:
@@ -37,7 +37,6 @@
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
 @Mixin(LevelRenderer.class)
-@Environment(EnvType.CLIENT)
 public class MixinLevelRenderer {
 	private static final String RENDER = "Lnet/minecraft/client/renderer/LevelRenderer;renderLevel(Lcom/mojang/blaze3d/vertex/PoseStack;FJZLnet/minecraft/client/Camera;Lnet/minecraft/client/renderer/GameRenderer;Lnet/minecraft/client/renderer/LightTexture;Lcom/mojang/math/Matrix4f;)V";
 	private static final String CLEAR = "Lcom/mojang/blaze3d/systems/RenderSystem;clear(IZ)V";

File: src/main/java/net/coderbot/iris/mixin/MixinParticleEngine.java
Patch:
@@ -13,14 +13,11 @@
 import net.minecraft.client.particle.ParticleEngine;
 import net.minecraft.client.renderer.LightTexture;
 import net.minecraft.client.renderer.MultiBufferSource;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 
 /**
  * Ensures that all particles are rendered with the textured_lit shader program.
  */
 @Mixin(ParticleEngine.class)
-@Environment(EnvType.CLIENT)
 public class MixinParticleEngine {
 	private static final String RENDER =
 			"Lnet/minecraft/client/particle/ParticleEngine;render(Lcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/client/renderer/MultiBufferSource$BufferSource;Lnet/minecraft/client/renderer/LightTexture;Lnet/minecraft/client/Camera;F)V";

File: src/main/java/net/coderbot/iris/mixin/MixinTweakFarPlane.java
Patch:
@@ -2,8 +2,6 @@
 
 import com.mojang.blaze3d.vertex.PoseStack;
 import net.coderbot.iris.Iris;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.client.renderer.GameRenderer;
 import org.lwjgl.opengl.GL;
 import org.spongepowered.asm.mixin.Mixin;
@@ -33,7 +31,6 @@
  *
  * Fun.
  */
-@Environment(EnvType.CLIENT)
 @Mixin(GameRenderer.class)
 public class MixinTweakFarPlane {
 	@Shadow

File: src/main/java/net/coderbot/iris/mixin/fabulous/MixinDisableFabulousGraphics.java
Patch:
@@ -6,14 +6,11 @@
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.client.GraphicsStatus;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.Options;
 import net.minecraft.client.renderer.LevelRenderer;
 
-@Environment(EnvType.CLIENT)
 @Mixin(LevelRenderer.class)
 public class MixinDisableFabulousGraphics {
 	@Inject(method = "onResourceManagerReload", at = @At("HEAD"))

File: src/main/java/net/coderbot/iris/mixin/rendertype/MixinFixEyesTranslucency.java
Patch:
@@ -1,11 +1,8 @@
 package net.coderbot.iris.mixin.rendertype;
 
 import org.spongepowered.asm.mixin.Mixin;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.client.renderer.RenderType;
 
-@Environment(EnvType.CLIENT)
 @Mixin(RenderType.class)
 public class MixinFixEyesTranslucency {
 	// Minecraft interprets an alpha value of zero as a signal to disable the alpha test.

File: src/main/java/net/coderbot/iris/mixin/rendertype/RenderTypeAccessor.java
Patch:
@@ -2,11 +2,8 @@
 
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 import net.minecraft.client.renderer.RenderType;
 
-@Environment(EnvType.CLIENT)
 @Mixin(RenderType.class)
 public interface RenderTypeAccessor {
 	@Accessor("sortOnUpload")

File: src/main/java/net/coderbot/iris/samplers/IrisSamplers.java
Patch:
@@ -115,6 +115,7 @@ public static boolean addShadowSamplers(SamplerHolder samplers, ShadowMapRendere
 	public static void addLevelSamplers(SamplerHolder samplers, AbstractTexture normals, AbstractTexture specular) {
 		samplers.addExternalSampler(TextureUnit.TERRAIN.getSamplerId(), "tex", "texture", "gtexture");
 		samplers.addExternalSampler(TextureUnit.LIGHTMAP.getSamplerId(), "lightmap");
+		samplers.addExternalSampler(TextureUnit.OVERLAY.getSamplerId(), "iris_overlay");
 		samplers.addDynamicSampler(normals::getId, "normals");
 		samplers.addDynamicSampler(specular::getId, "specular");
 	}

File: src/main/java/net/coderbot/iris/shaderpack/transform/Transformations.java
Patch:
@@ -4,6 +4,7 @@ public interface Transformations {
 	boolean contains(String content);
 	void injectLine(InjectionPoint at, String line);
 	void replaceExact(String from, String to);
+	void replaceRegex(String regex, String to);
 	String getPrefix();
 	void setPrefix(String prefix);
 	void define(String key, String value);

File: src/main/java/net/coderbot/iris/uniforms/builtin/BuiltinReplacementUniforms.java
Patch:
@@ -4,10 +4,7 @@
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.gl.uniform.UniformHolder;
 import net.coderbot.iris.gl.uniform.UniformUpdateFrequency;
-import net.fabricmc.api.EnvType;
-import net.fabricmc.api.Environment;
 
-@Environment(EnvType.CLIENT)
 public class BuiltinReplacementUniforms {
 	private static final Matrix4f lightmapTextureMatrix;
 

File: src/main/java/net/coderbot/iris/layer/GbufferProgram.java
Patch:
@@ -14,10 +14,13 @@ public enum GbufferProgram {
 	BLOCK_ENTITIES,
 	BEACON_BEAM,
 	ENTITIES,
+	ENTITY_NO_OVERLAY,
 	ENTITIES_GLOWING,
 	ARMOR_GLINT,
 	EYES,
+	EYES_NO_OVERLAY,
 	HAND,
+	HAND_NO_OVERLAY,
 	HAND_TRANSLUCENT,
 	LINES,
 	WEATHER

File: src/main/java/net/coderbot/iris/samplers/IrisSamplers.java
Patch:
@@ -115,6 +115,7 @@ public static boolean addShadowSamplers(SamplerHolder samplers, ShadowMapRendere
 	public static void addLevelSamplers(SamplerHolder samplers, AbstractTexture normals, AbstractTexture specular) {
 		samplers.addExternalSampler(TextureUnit.TERRAIN.getSamplerId(), "tex", "texture", "gtexture");
 		samplers.addExternalSampler(TextureUnit.LIGHTMAP.getSamplerId(), "lightmap");
+		samplers.addExternalSampler(TextureUnit.OVERLAY.getSamplerId(), "iris_overlay");
 		samplers.addDynamicSampler(normals::getId, "normals");
 		samplers.addDynamicSampler(specular::getId, "specular");
 	}

File: src/main/java/net/coderbot/iris/shaderpack/transform/Transformations.java
Patch:
@@ -4,6 +4,7 @@ public interface Transformations {
 	boolean contains(String content);
 	void injectLine(InjectionPoint at, String line);
 	void replaceExact(String from, String to);
+	void replaceRegex(String regex, String to);
 	String getPrefix();
 	void setPrefix(String prefix);
 	void define(String key, String value);

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/xhfp/XHFPModelVertexBufferWriterNio.java
Patch:
@@ -95,11 +95,11 @@ private void writeQuadInternal(float posX, float posY, float posZ, int color,
 		buffer.putInt(i + 16, XHFPModelVertexType.encodeLightMapTexCoord(light));
 
 		// NB: We don't set midTexCoord, normal, and tangent here, they will be filled in later.
-		// block ID
+		// block ID: We only set the first 2 values, any legacy shaders using z or w will get filled in based on the GLSL spec
+		// https://www.khronos.org/opengl/wiki/Vertex_Specification#Vertex_format
+		// TODO: can we pack this into one short?
 		buffer.putShort(i + 32, materialId);
 		buffer.putShort(i + 34, renderType);
-		buffer.putShort(i + 36, (short) 0);
-		buffer.putShort(i + 38, (short) 0);
 
 		if (vertexCount == 4) {
 			// TODO: Consider applying similar vertex coordinate transformations as the normal HFP texture coordinates

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/vertex_format/xhfp/XHFPModelVertexType.java
Patch:
@@ -25,7 +25,7 @@ public class XHFPModelVertexType implements ChunkVertexType {
 			.addElement(IrisChunkMeshAttributes.MID_TEX_COORD, 20, GlVertexAttributeFormat.UNSIGNED_SHORT, 2, true)
 			.addElement(IrisChunkMeshAttributes.TANGENT, 24, IrisGlVertexAttributeFormat.BYTE, 4, true)
 			.addElement(IrisChunkMeshAttributes.NORMAL, 28, IrisGlVertexAttributeFormat.BYTE, 3, true)
-			.addElement(IrisChunkMeshAttributes.BLOCK_ID, 32, IrisGlVertexAttributeFormat.SHORT, 4, false)
+			.addElement(IrisChunkMeshAttributes.BLOCK_ID, 32, GlVertexAttributeFormat.UNSIGNED_SHORT, 2, false)
 			.build();
 
 	private static final int POSITION_MAX_VALUE = 65536;

File: src/main/java/net/coderbot/iris/compat/sodium/SodiumVersionCheck.java
Patch:
@@ -12,7 +12,7 @@ public class SodiumVersionCheck {
 	// of pain. So don't forget!
 	private static final ImmutableList<AllowedSodiumVersion> ALLOWED_SODIUM_VERSIONS = ImmutableList.of(
 			// Official 0.3.4
-			AllowedSodiumVersion.exact("0.4.0-alpha6+rev.b8f94f8",
+			AllowedSodiumVersion.exact("0.4.0-alpha6+build.69",
 					"https://www.curseforge.com/minecraft/mc-mods/sodium/files/3605309"),
 
 			// For use by ReplayMod

File: src/main/java/net/coderbot/iris/pipeline/FixedFunctionWorldRenderingPipeline.java
Patch:
@@ -53,7 +53,7 @@ public void setPhase(WorldRenderingPhase phase) {
 	}
 
 	@Override
-	public void setBoundTexture(AbstractTexture texture) {
+	public void setBoundTexture(AbstractTexture texture, int id) {
 
 	}
 

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPipeline.java
Patch:
@@ -18,7 +18,7 @@ public interface WorldRenderingPipeline {
 	WorldRenderingPhase getPhase();
 
 	void setPhase(WorldRenderingPhase phase);
-	void setBoundTexture(AbstractTexture texture);
+	void setBoundTexture(AbstractTexture texture, int id);
 
 	void beginShadowRender();
 	void endShadowRender();

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -184,7 +184,7 @@ public DeferredWorldRenderingPipeline(ProgramSet programs) {
 		ImmutableSet<Integer> flippedBeforeShadow = ImmutableSet.of();
 
 		createShadowMapRenderer = () -> {
-			shadowMapRenderer = new ShadowRenderer((CoreWorldRenderingPipeline) this, programs.getShadow().orElse(null),
+			shadowMapRenderer = new ShadowRenderer((CoreWorldRenderingPipeline) this, programs,
 					programs.getPackDirectives(), renderTargets);
 			createShadowMapRenderer = () -> {};
 		};

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -161,7 +161,7 @@ public NewWorldRenderingPipeline(ProgramSet programSet) throws IOException {
 		ImmutableSet<Integer> flippedBeforeShadow = ImmutableSet.of();
 
 		createShadowMapRenderer = () -> {
-			shadowMapRenderer = new ShadowRenderer(this, programSet.getShadow().orElse(null),
+			shadowMapRenderer = new ShadowRenderer(this, programSet,
 					programSet.getPackDirectives(), renderTargets);
 			createShadowMapRenderer = () -> {
 			};

File: src/main/java/net/coderbot/iris/gui/element/widget/BooleanElementWidget.java
Patch:
@@ -83,7 +83,7 @@ public boolean applyPreviousValue() {
 
 	@Override
 	public boolean applyOriginalValue() {
-		this.value = this.appliedValue;
+		this.value = this.option.getDefaultValue();
 		this.queue();
 
 		return true;

File: src/main/java/net/coderbot/iris/gui/element/widget/BooleanElementWidget.java
Patch:
@@ -83,7 +83,7 @@ public boolean applyPreviousValue() {
 
 	@Override
 	public boolean applyOriginalValue() {
-		this.value = this.appliedValue;
+		this.value = this.option.getDefaultValue();
 		this.queue();
 
 		return true;

File: src/main/java/net/coderbot/iris/gui/element/widget/SliderElementWidget.java
Patch:
@@ -29,10 +29,10 @@ public void render(PoseStack poseStack, int x, int y, int width, int height, int
 			this.renderSlider(poseStack, x, y, width, height, mouseX, mouseY, tickDelta);
 		}
 
-		if (!this.screen.isDisplayingComment()) {
-			renderTooltip(poseStack, this.unmodifiedLabel, mouseX, mouseY, hovered);
-		} else if (Screen.hasShiftDown()) {
+		if (Screen.hasShiftDown()) {
 			renderTooltip(poseStack, SET_TO_DEFAULT, mouseX, mouseY, hovered);
+		} else if (!this.screen.isDisplayingComment()) {
+			renderTooltip(poseStack, this.unmodifiedLabel, mouseX, mouseY, hovered);
 		}
 
 		if (this.mouseDown) {

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -7,8 +7,7 @@
 import net.coderbot.iris.JomlConversions;
 import net.coderbot.iris.gl.state.StateUpdateNotifiers;
 import net.coderbot.iris.gl.uniform.DynamicUniformHolder;
-import net.coderbot.iris.gl.uniform.UniformHolder;=======
-import net.coderbot.iris.layer.EntityColorRenderStateShard;
+import net.coderbot.iris.gl.uniform.UniformHolder;
 import net.coderbot.iris.layer.GbufferPrograms;
 import net.coderbot.iris.mixin.statelisteners.BooleanStateAccessor;
 import net.coderbot.iris.mixin.statelisteners.GlStateManagerAccessor;

File: src/main/java/net/coderbot/iris/rendertarget/NativeImageBackedSingleColorTexture.java
Patch:
@@ -10,7 +10,7 @@ public NativeImageBackedSingleColorTexture(int red, int green, int blue, int alp
 	}
 
 	public NativeImageBackedSingleColorTexture(int rgba) {
-		this(rgba & 0xFF, rgba >> 8 & 0xFF, rgba >> 16 & 0xFF, rgba >> 24 & 0xFF);
+		this(rgba >> 24 & 0xFF, rgba >> 16 & 0xFF, rgba >> 8 & 0xFF, rgba & 0xFF);
 	}
 
 	private static NativeImage create(int color) {

File: src/main/java/net/coderbot/iris/mixin/pbr/TextureAtlasMixin.java
Patch:
@@ -40,7 +40,7 @@ public abstract class TextureAtlasMixin extends AbstractTexture implements Textu
 	@Unique
 	private PBRAtlasHolder pbrHolder;
 
-	@Inject(method = "prepareToStitch(Lnet/minecraft/server/packs/resources/ResourceManager;Ljava/util/stream/Stream;Lnet/minecraft/util/profiling/ProfilerFiller;I)Lnet/minecraft/client/renderer/texture/TextureAtlas$Preparations;", at = @At(value = "INVOKE_STRING", target = "popPush(Ljava/lang/String;)V", args = "ldc=loading"))
+	@Inject(method = "prepareToStitch(Lnet/minecraft/server/packs/resources/ResourceManager;Ljava/util/stream/Stream;Lnet/minecraft/util/profiling/ProfilerFiller;I)Lnet/minecraft/client/renderer/texture/TextureAtlas$Preparations;", at = @At(value = "INVOKE_STRING", target = "Lnet/minecraft/util/profiling/ProfilerFiller;popPush(Ljava/lang/String;)V", args = "ldc=loading"))
 	private void beforeLoadingSprites(ResourceManager resourceManager, Stream<ResourceLocation> spriteIds, ProfilerFiller profiler, int mipLevel, CallbackInfoReturnable<TextureAtlas.Preparations> cir) {
 		if (pbrHolder != null) {
 			pbrHolder.clear();

File: src/main/java/net/coderbot/iris/texture/atlas/TextureAtlasExtension.java
Patch:
@@ -2,8 +2,6 @@
 
 import org.jetbrains.annotations.Nullable;
 
-import net.coderbot.iris.texture.atlas.PBRAtlasHolder;
-
 public interface TextureAtlasExtension {
 	boolean hasPBRSpriteHolder();
 

File: src/main/java/net/coderbot/iris/texture/atlas/TextureAtlasSpriteExtension.java
Patch:
@@ -2,8 +2,6 @@
 
 import org.jetbrains.annotations.Nullable;
 
-import net.coderbot.iris.texture.atlas.PBRSpriteHolder;
-
 public interface TextureAtlasSpriteExtension {
 	boolean hasPBRSpriteHolder();
 

File: src/main/java/net/coderbot/iris/pipeline/CustomTextureManager.java
Patch:
@@ -123,11 +123,11 @@ public IntSupplier getNoiseTexture() {
 	}
 
 	public AbstractTexture getNormals() {
-		return holder != null ? holder.getOrCreateNormalAtlas() : normals;
+		return holder != null && holder.hasNormalAtlas() ? holder.getOrCreateNormalAtlas() : normals;
 	}
 
 	public AbstractTexture getSpecular() {
-		return holder != null ? holder.getOrCreateSpecularAtlas() : specular;
+		return holder != null && holder.hasSpecularAtlas() ? holder.getOrCreateSpecularAtlas() : specular;
 	}
 
 	public void destroy() {

File: src/main/java/net/coderbot/iris/texture/atlas/PBRAtlasTexture.java
Patch:
@@ -73,7 +73,7 @@ public void reload(TextureAtlas.Preparations preparations) {
 		}
 
 		if (Boolean.parseBoolean(System.getProperty("iris.pbr.debug"))) {
-			TextureSaveUtil.saveTextures("atlas", id.getPath().replaceAll("/", "_"), getId(), preparationsAccessor.getMipLevel(), preparationsAccessor.getWidth(), preparationsAccessor.getHeight());
+			TextureSaveUtil.saveTextures("atlas", id.getPath().replaceAll("/", "_"), glId, preparationsAccessor.getMipLevel(), preparationsAccessor.getWidth(), preparationsAccessor.getHeight());
 		}
 	}
 

File: src/main/java/net/coderbot/iris/pipeline/CustomTextureManager.java
Patch:
@@ -127,7 +127,7 @@ public AbstractTexture getNormals() {
 	}
 
 	public AbstractTexture getSpecular() {
-		return specular != null ? holder.getOrCreateSpecularAtlas() : specular;
+		return holder != null ? holder.getOrCreateSpecularAtlas() : specular;
 	}
 
 	public void destroy() {

File: src/main/java/net/coderbot/iris/mixin/MixinLevelRenderer.java
Patch:
@@ -195,26 +195,26 @@ public class MixinLevelRenderer {
 
 	@Inject(method = RENDER_LAYER, at = @At("HEAD"))
 	private void iris$beginTerrainLayer(RenderType renderType, PoseStack poseStack, double cameraX, double cameraY, double cameraZ, CallbackInfo callback) {
-		pipeline.setPhase(GbufferPrograms.refinePhase(renderType));
 		if (renderType == RenderType.solid() || renderType == RenderType.cutout() || renderType == RenderType.cutoutMipped()) {
 			pipeline.pushProgram(GbufferProgram.TERRAIN);
 		} else if (renderType == RenderType.translucent() || renderType == RenderType.tripwire()) {
 			pipeline.pushProgram(GbufferProgram.TRANSLUCENT_TERRAIN);
 		} else {
 			throw new IllegalStateException("[Iris] Unexpected terrain layer: " + renderType);
 		}
+		pipeline.setPhase(GbufferPrograms.refinePhase(renderType));
 	}
 
 	@Inject(method = RENDER_LAYER, at = @At("RETURN"))
 	private void iris$endTerrainLayer(RenderType renderType, PoseStack poseStack, double cameraX, double cameraY, double cameraZ, CallbackInfo callback) {
+		pipeline.setPhase(WorldRenderingPhase.NONE);
 		if (renderType == RenderType.solid() || renderType == RenderType.cutout() || renderType == RenderType.cutoutMipped()) {
 			pipeline.popProgram(GbufferProgram.TERRAIN);
 		} else if (renderType == RenderType.translucent() || renderType == RenderType.tripwire()) {
 			pipeline.popProgram(GbufferProgram.TRANSLUCENT_TERRAIN);
 		} else {
 			throw new IllegalStateException("[Iris] Unexpected terrain layer: " + renderType);
 		}
-		pipeline.setPhase(WorldRenderingPhase.NONE);
 	}
 
 	@Inject(method = "renderLevel", at = @At(value = "INVOKE", target = RENDER_WEATHER))

File: src/main/java/net/coderbot/iris/gui/element/ShaderPackSelectionList.java
Patch:
@@ -254,7 +254,7 @@ public TopButtonRowEntry(ShaderPackSelectionList list, boolean shadersEnabled) {
 
 		@Override
 		public void render(PoseStack poseStack, int index, int y, int x, int entryWidth, int entryHeight, int mouseX, int mouseY, boolean hovered, float tickDelta) {
-			this.buttons.setWidth(this.enableDisableButton, (entryWidth - 3) - REFRESH_BUTTON_WIDTH);
+			this.buttons.setWidth(this.enableDisableButton, (entryWidth - 1) - REFRESH_BUTTON_WIDTH);
 			this.enableDisableButton.centerX = x + (int)(entryWidth * 0.5);
 
 			this.buttons.render(poseStack, x - 2, y - 3, 18, mouseX, mouseY, tickDelta, hovered);

File: src/main/java/net/coderbot/iris/gui/element/widget/SliderElementWidget.java
Patch:
@@ -103,7 +103,7 @@ public boolean mouseClicked(double mx, double my, int button) {
 
 			return true;
 		}
-		return super.mouseClicked(mx, my, button);
+		return false;
 	}
 
 	@Override

File: src/main/java/net/coderbot/iris/shaderpack/ShaderPack.java
Patch:
@@ -130,9 +130,8 @@ public ShaderPack(Path root, Map<String, String> changedConfigs) throws IOExcept
 				profileName = internalProfileName;
 			}
 
-			int numOptionsChanged = this.profile.current.map(value -> getShaderPackOptions().getOptionValues().getOptionsChanged() - value.optionValues.size()).orElseGet(() -> getShaderPackOptions().getOptionValues().getOptionsChanged());
-
-			this.profileInfo = "Profile: " + profileName + " (" + numOptionsChanged + " options changed by user)";
+			// TODO: show the options changed in relation to the current profile, and not just total.
+			this.profileInfo = "Profile: " + profileName + " (" + getShaderPackOptions().getOptionValues().getOptionsChanged() + " options changed by user)";
 		}
 
 		Iris.logger.info(this.profileInfo);

File: src/main/java/net/coderbot/iris/shaderpack/option/Profile.java
Patch:
@@ -28,14 +28,14 @@ public boolean matches(OptionSet options, OptionValues values) {
 			String value = entry.getValue();
 
 			if (options.getBooleanOptions().containsKey(option)) {
-				boolean currentValue = values.getBooleanValue(option).orElse(options.getBooleanOptions().get(option).getOption().getDefaultValue());
+				boolean currentValue = values.getBooleanValueOrDefault(option);
 
 				if (!Boolean.toString(currentValue).equals(value)) {
 					return false;
 				}
 			}
 			if (options.getStringOptions().containsKey(option)) {
-				String currentValue = values.getStringValue(option).orElse(options.getStringOptions().get(option).getOption().getDefaultValue());
+				String currentValue = values.getStringValueOrDefault(option);
 
 				if (!value.equals(currentValue)) {
 					return false;

File: src/main/java/net/coderbot/iris/shaderpack/preprocessor/PropertiesPreprocessor.java
Patch:
@@ -100,7 +100,7 @@ private static List<String> getBooleanValues(ShaderPackOptions shaderPackOptions
 		List<String> booleanValues = new ArrayList<>();
 
 		shaderPackOptions.getOptionSet().getBooleanOptions().forEach((string, value) -> {
-			boolean trueValue = shaderPackOptions.getOptionValues().getBooleanValue(string).orElse(value.getOption().getDefaultValue());
+			boolean trueValue = shaderPackOptions.getOptionValues().getBooleanValueOrDefault(string);
 
 			if (trueValue) {
 				booleanValues.add(string);
@@ -113,7 +113,8 @@ private static List<String> getBooleanValues(ShaderPackOptions shaderPackOptions
 	private static Map<String, String> getStringValues(ShaderPackOptions shaderPackOptions) {
 		Map<String, String> stringValues = new HashMap<>();
 
-		shaderPackOptions.getOptionSet().getStringOptions().forEach((optionName, value) -> stringValues.put(optionName, shaderPackOptions.getOptionValues().getStringValue(optionName).orElse(value.getOption().getDefaultValue())));
+		shaderPackOptions.getOptionSet().getStringOptions().forEach(
+				(optionName, value) -> stringValues.put(optionName, shaderPackOptions.getOptionValues().getStringValueOrDefault(optionName)));
 
 		return stringValues;
 	}

File: src/main/java/net/coderbot/iris/shaderpack/option/values/MutableOptionValues.java
Patch:
@@ -61,7 +61,9 @@ public void addAll(Map<String, String> values) {
 			boolean actualValue = booleanValue.orElse(option.getOption().getDefaultValue());
 
 			if (actualValue == option.getOption().getDefaultValue()) {
+				// Just set it to default by removing it from the map
 				booleanValues.remove(name);
+				return;
 			}
 
 			booleanValues.put(name, actualValue);
@@ -81,6 +83,7 @@ public void addAll(Map<String, String> values) {
 
 			if (value.equals(option.getOption().getDefaultValue())) {
 				stringValues.remove(name);
+				return;
 			}
 
 			stringValues.put(name, value);

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -581,7 +581,8 @@ public void finalizeLevelRendering() {
 
 	@Override
 	public boolean shouldDisableVanillaEntityShadows() {
-		return true;
+		// OptiFine seems to disable vanilla shadows when the shaderpack uses shadow mapping?
+		return shadowMapRenderer instanceof ShadowRenderer;
 	}
 
 	@Override

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/IrisSodiumCompatMixinPlugin.java
Patch:
@@ -20,10 +20,10 @@ public void onLoad(String mixinPackage) {
 			return SodiumVersionCheck.isAllowedVersion(version);
 		}).orElse(false);
 
-		//if (!validSodiumVersion) {
+		if (!validSodiumVersion) {
 			// We can't use Iris' logger here due to classloading issues.
 			System.err.println("[Iris] Invalid/missing version of Sodium detected, disabling compatibility mixins!");
-		//}
+		}
 	}
 
 	@Override

File: src/main/java/net/coderbot/iris/mixin/fantastic/MixinLevelRenderer.java
Patch:
@@ -60,9 +60,9 @@ public class MixinLevelRenderer {
 	}
 
 	@Redirect(method = "renderLevel", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/particle/ParticleEngine;render(Lcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/client/renderer/MultiBufferSource$BufferSource;Lnet/minecraft/client/renderer/LightTexture;Lnet/minecraft/client/Camera;F)V"))
-	private void iris$renderBeforeDeferred(ParticleEngine instance, PoseStack poseStack, MultiBufferSource.BufferSource bufferSource, LightTexture lightTexture, Camera camera, float f) {
+	private void iris$renderTranslucentAfterDeferred(ParticleEngine instance, PoseStack poseStack, MultiBufferSource.BufferSource bufferSource, LightTexture lightTexture, Camera camera, float f) {
 		// We don't want to render translucent particles again if we already rendered them earlier!
-		if (Iris.getPipelineManager().getPipeline().map(WorldRenderingPipeline::shouldRenderParticlesBeforeDeferred).orElse(false)) {
+		if (!Iris.getPipelineManager().getPipeline().map(WorldRenderingPipeline::shouldRenderParticlesBeforeDeferred).orElse(false)) {
 			instance.render(poseStack, bufferSource, lightTexture, camera, f);
 		}
 	}

File: src/main/java/net/coderbot/iris/gl/IrisRenderSystem.java
Patch:
@@ -59,7 +59,7 @@ public static void uniform4f(int location, float v0, float v1, float v2, float v
 	}
 
 	public static void uniform4i(int location, int v0, int v1, int v2, int v3) {
-		RenderSystem.assertThread(RenderSystem::isOnRenderThreadOrInit);
+		RenderSystem.assertOnRenderThreadOrInit();
 		GL32C.glUniform4i(location, v0, v1, v2, v3);
 	}
 

File: src/main/java/net/coderbot/iris/gui/screen/ShaderPackScreen.java
Patch:
@@ -334,8 +334,10 @@ public void applyChanges() {
 
 		Iris.getIrisConfig().setShaderPackName(name);
 
-		boolean enabled = this.shaderPackList.getEnableShadersButton().enabled;
+		boolean enabled = this.shaderPackList.getTopButtonRow().shadersEnabled;
 		IrisApi.getInstance().getConfig().setShadersEnabledAndApply(enabled);
+
+		refreshForChangedPack();
 	}
 
 	private void discardChanges() {

File: src/main/java/net/coderbot/iris/gl/blending/BlendModeStorage.java
Patch:
@@ -58,5 +58,4 @@ public static void restoreBlend() {
 		GlStateManager._blendFuncSeparate(originalBlend.getSrcRgb(), originalBlend.getDstRgb(),
 				originalBlend.getSrcAlpha(), originalBlend.getDstAlpha());
 	}
-
 }

File: src/main/java/net/coderbot/iris/mixin/MixinGlStateManager_BlendOverride.java
Patch:
@@ -9,7 +9,6 @@
 
 @Mixin(GlStateManager.class)
 public class MixinGlStateManager_BlendOverride {
-
 	@Inject(method = "_disableBlend", at = @At("HEAD"), cancellable = true)
 	private static void iris$blendDisableLock(CallbackInfo ci) {
 		if (BlendModeStorage.isBlendLocked()) {
@@ -32,8 +31,6 @@ public class MixinGlStateManager_BlendOverride {
 			BlendModeStorage.deferBlendFunc(srcFactor, dstFactor, srcFactor, dstFactor);
 			ci.cancel();
 		}
-
-
 	}
 
 	@Inject(method = "_blendFuncSeparate", at = @At("HEAD"), cancellable = true)

File: src/main/java/net/coderbot/iris/gl/blending/BlendModeStorage.java
Patch:
@@ -1,7 +1,6 @@
 package net.coderbot.iris.gl.blending;
 
 import com.mojang.blaze3d.platform.GlStateManager;
-import net.coderbot.iris.gl.state.StateUpdateNotifiers;
 import net.coderbot.iris.mixin.GlStateManagerAccessor;
 import net.coderbot.iris.mixin.statelisteners.BooleanStateAccessor;
 

File: src/main/java/net/coderbot/iris/mixin/MixinGlStateManager_BlendOverride.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.mojang.blaze3d.platform.GlStateManager;
 import net.coderbot.iris.gl.blending.BlendModeStorage;
-import net.coderbot.iris.gl.state.StateUpdateNotifiers;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;

File: src/main/java/net/coderbot/iris/compat/sodium/SodiumVersionCheck.java
Patch:
@@ -5,10 +5,10 @@
 public class SodiumVersionCheck {
 	// The allowed versions of Sodium for use with Iris
 	private static final ImmutableList<AllowedSodiumVersion> ALLOWED_SODIUM_VERSIONS = ImmutableList.of(
-			// Official 0.2.0
+			// Official 0.3.3
 			AllowedSodiumVersion.exact("0.3.3+build.8"),
 
-			// ReplayMod's existing compatible forked 0.2.0 version
+			// ReplayMod's existing compatible forked 0.3.3 version
 			AllowedSodiumVersion.prefix("0.3.3+rev.14a0485"),
 
 			// For future use by ReplayMod

File: src/main/java/net/coderbot/iris/compat/sodium/SodiumVersionCheck.java
Patch:
@@ -6,7 +6,7 @@ public class SodiumVersionCheck {
 	// The allowed versions of Sodium for use with Iris
 	private static final ImmutableList<AllowedSodiumVersion> ALLOWED_SODIUM_VERSIONS = ImmutableList.of(
 			// Official 0.2.0
-			AllowedSodiumVersion.exact("0.4.0-alpha5"),
+			AllowedSodiumVersion.exact("0.4.0-alpha5+build.9"),
 
 			// ReplayMod's existing compatible forked 0.2.0 version
 			AllowedSodiumVersion.prefix("0.4.0-alpha5+rev.76d0e6e"),

File: src/main/java/net/coderbot/iris/gui/element/ShaderPackOptionList.java
Patch:
@@ -39,7 +39,7 @@ public ShaderPackOptionList(ShaderPackScreen screen, NavigationController naviga
 	}
 
 	public void applyShaderPack(ShaderPack pack) {
-		this.container = pack.getShaderPackOptions().getMenuContainer();
+		this.container = pack.getMenuContainer();
 	}
 
 	public void rebuild() {

File: src/main/java/net/coderbot/iris/shaderpack/option/menu/OptionMenuElement.java
Patch:
@@ -19,8 +19,10 @@ public static OptionMenuElement create(String elementString, OptionMenuContainer
 			return EMPTY;
 		}
 		// Profile element
+		// NB: We don't want to add a profile element if there aren't profiles, even if it's requested. TODO: add this to diagnostics? (lp)
 		if (ELEMENT_PROFILE.equals(elementString)) {
-			return new OptionMenuProfileElement(container.getProfiles(), shaderPackOptions.getOptionSet(), shaderPackOptions.getOptionValues());
+			// null indicates that the element should be forgotten (not treated as empty)
+			return container.getProfiles().size() > 0 ? new OptionMenuProfileElement(container.getProfiles(), shaderPackOptions.getOptionSet(), shaderPackOptions.getOptionValues()) : null;
 		}
 		// Link to sub screen element
 		if (elementString.startsWith("[") && elementString.endsWith("]")) {

File: src/main/java/net/coderbot/iris/shaderpack/option/values/OptionValues.java
Patch:
@@ -7,6 +7,7 @@
 public interface OptionValues {
 	OptionalBoolean getBooleanValue(String name);
 	Optional<String> getStringValue(String name);
+	int getOptionsChanged();
 
 	MutableOptionValues mutableCopy();
 	ImmutableOptionValues toImmutable();

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -718,7 +718,7 @@ private void prepareRenderTargets() {
 	public void beginHand() {
 		// We need to copy the current depth texture so that depthtex2 can contain the depth values for
 		// all non-translucent content without the hand, as required.
-		baseline.bindAsReadBuffer();
+		baseline.bind();
 		GlStateManager._bindTexture(renderTargets.getDepthTextureNoHand().getTextureId());
 		IrisRenderSystem.copyTexImage2D(GL20C.GL_TEXTURE_2D, 0, GL20C.GL_DEPTH_COMPONENT, 0, 0, renderTargets.getCurrentWidth(), renderTargets.getCurrentHeight(), 0);
 		GlStateManager._bindTexture(0);
@@ -730,7 +730,7 @@ public void beginTranslucents() {
 
 		// We need to copy the current depth texture so that depthtex1 can contain the depth values for
 		// all non-translucent content, as required.
-		baseline.bindAsReadBuffer();
+		baseline.bind();
 		GlStateManager._bindTexture(renderTargets.getDepthTextureNoTranslucents().getTextureId());
 		IrisRenderSystem.copyTexImage2D(GL20C.GL_TEXTURE_2D, 0, GL20C.GL_DEPTH_COMPONENT, 0, 0, renderTargets.getCurrentWidth(), renderTargets.getCurrentHeight(), 0);
 		GlStateManager._bindTexture(0);

File: src/main/java/net/coderbot/iris/shaderpack/ShaderPack.java
Patch:
@@ -96,7 +96,7 @@ public ShaderPack(Path root, Map<String, String> changedConfigs) throws IOExcept
 				.map(source -> new ShaderProperties(source, shaderPackOptions))
 				.orElseGet(ShaderProperties::empty);
 
-		ProfileSet profiles = ProfileSet.fromTree(shaderProperties.getProfiles());
+		ProfileSet profiles = ProfileSet.fromTree(shaderProperties.getProfiles(), this.shaderPackOptions.getOptionSet());
 		/*
 		profiles.scan(optionSet, optionValues).current.ifPresent(profile -> profile.disabledPrograms.forEach(program -> {
 			// TODO: disable programs

File: src/main/java/net/coderbot/iris/shaderpack/option/ShaderPackOptions.java
Patch:
@@ -48,7 +48,7 @@ public ShaderPackOptions(ShaderProperties shaderProperties, IncludeGraph graph,
 		this.optionSet = setBuilder.build();
 		this.optionValues = new MutableOptionValues(optionSet, changedConfigs);
 
-		ProfileSet profiles = ProfileSet.fromTree(shaderProperties.getProfiles());
+		ProfileSet profiles = ProfileSet.fromTree(shaderProperties.getProfiles(), this.getOptionSet());
 		/*
 		profiles.scan(optionSet, optionValues).current.ifPresent(profile -> profile.disabledPrograms.forEach(program -> {
 			// TODO: disable programs

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -414,7 +414,7 @@ public static Map<String, String> getShaderPackOptionQueue() {
 	}
 
 	public static void queueShaderPackOptionsFromProfile(Profile profile) {
-		profile.optionValues.forEach(getShaderPackOptionQueue()::put);
+		getShaderPackOptionQueue().putAll(profile.optionValues);
 	}
 
 	public static void clearShaderPackOptionQueue() {

File: src/main/java/net/coderbot/iris/gui/element/widget/StringElementWidget.java
Patch:
@@ -38,10 +38,10 @@ public void init(ShaderPackScreen screen, NavigationController navigation) {
 		List<String> values = this.option.getAllowedValues();
 
 		this.appliedValue = appliedValue.orElse(this.option.getDefaultValue()); // The value currently in use by the shader
-		String actualSetValue = pendingValue.orElse(this.appliedValue); // The unapplied value that has been queued (if that is the case)
+		String actualPendingValue = pendingValue.orElse(this.appliedValue); // The unapplied value that has been queued (if that is the case)
 
 		this.valueCount = values.size();
-		this.valueIndex = values.indexOf(actualSetValue);
+		this.valueIndex = values.indexOf(actualPendingValue);
 	}
 
 	@Override

File: src/main/java/net/coderbot/iris/shaderpack/option/Profile.java
Patch:
@@ -61,7 +61,7 @@ public boolean matches(OptionSet options, OptionValues values) {
 			String value = entry.getValue();
 
 			if (options.getBooleanOptions().containsKey(option)) {
-				boolean currentValue = options.getBooleanOptions().get(option).getOption().getDefaultValue() != values.isBooleanFlipped(option);
+				boolean currentValue = values.getBooleanValue(option).orElse(options.getBooleanOptions().get(option).getOption().getDefaultValue());
 
 				if (!Boolean.toString(currentValue).equals(value)) {
 					return false;

File: src/main/java/kroppeb/stareval/element/PriorityOperatorElement.java
Patch:
@@ -3,5 +3,5 @@
 public interface PriorityOperatorElement extends Element {
 	int getPriority();
 
-	Expression resolveWith(Expression right);
+	ExpressionElement resolveWith(ExpressionElement right);
 }

File: src/main/java/kroppeb/stareval/element/tree/partial/UnfinishedArgsExpression.java
Patch:
@@ -1,12 +1,12 @@
 package kroppeb.stareval.element.tree.partial;
 
-import kroppeb.stareval.element.Expression;
+import kroppeb.stareval.element.ExpressionElement;
 
 import java.util.ArrayList;
 import java.util.List;
 
 public class UnfinishedArgsExpression extends PartialExpression {
-	public final List<Expression> tokens = new ArrayList<>();
+	public final List<ExpressionElement> tokens = new ArrayList<>();
 
 	@Override
 	public String toString() {

File: src/main/java/kroppeb/stareval/parser/Tokenizer.java
Patch:
@@ -1,19 +1,19 @@
 package kroppeb.stareval.parser;
 
+import kroppeb.stareval.element.ExpressionElement;
 import kroppeb.stareval.exception.ParseException;
 import kroppeb.stareval.exception.UnexpectedCharacterException;
 import kroppeb.stareval.exception.UnexpectedEndingException;
-import kroppeb.stareval.element.Expression;
 
 class Tokenizer {
 	private Tokenizer() {
 	}
 
-	static Expression parse(String input, ParserOptions options) throws ParseException {
+	static ExpressionElement parse(String input, ParserOptions options) throws ParseException {
 		return parseInternal(new StringReader(input), options);
 	}
 
-	static Expression parseInternal(StringReader input, ParserOptions options) throws ParseException {
+	static ExpressionElement parseInternal(StringReader input, ParserOptions options) throws ParseException {
 		// parser stack
 		final Parser stack = new Parser();
 		ParserOptions.TokenRules tokenRules = options.getTokenRules();

File: src/main/java/net/coderbot/iris/gl/sampler/SamplerLimits.java
Patch:
@@ -1,13 +1,14 @@
 package net.coderbot.iris.gl.sampler;
 
+import com.mojang.blaze3d.platform.GlStateManager;
 import org.lwjgl.opengl.GL20C;
 
 public class SamplerLimits {
 	private final int maxTextureUnits;
 	private static SamplerLimits instance;
 
 	private SamplerLimits() {
-		this.maxTextureUnits = GL20C.glGetInteger(GL20C.GL_MAX_TEXTURE_IMAGE_UNITS);
+		this.maxTextureUnits = GlStateManager._getInteger(GL20C.GL_MAX_TEXTURE_IMAGE_UNITS);
 	}
 
 	public int getMaxTextureUnits() {

File: src/main/java/net/coderbot/iris/gl/uniform/FloatUniform.java
Patch:
@@ -1,6 +1,6 @@
 package net.coderbot.iris.gl.uniform;
 
-import org.lwjgl.opengl.GL21;
+import net.coderbot.iris.gl.IrisRenderSystem;
 
 public class FloatUniform extends Uniform {
 	private float cachedValue;
@@ -31,7 +31,7 @@ private void updateValue() {
 
 		if (cachedValue != newValue) {
 			cachedValue = newValue;
-			GL21.glUniform1f(location, newValue);
+			IrisRenderSystem.uniform1f(location, newValue);
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/gl/uniform/IntUniform.java
Patch:
@@ -2,7 +2,7 @@
 
 import java.util.function.IntSupplier;
 
-import org.lwjgl.opengl.GL21;
+import net.coderbot.iris.gl.IrisRenderSystem;
 
 public class IntUniform extends Uniform {
 	private int cachedValue;
@@ -33,7 +33,7 @@ private void updateValue() {
 
 		if (cachedValue != newValue) {
 			cachedValue = newValue;
-			GL21.glUniform1i(location, newValue);
+			IrisRenderSystem.uniform1i(location, newValue);
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/gl/uniform/JomlMatrixUniform.java
Patch:
@@ -1,8 +1,8 @@
 package net.coderbot.iris.gl.uniform;
 
+import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Matrix4f;
 import org.lwjgl.BufferUtils;
-import org.lwjgl.opengl.GL21;
 
 import java.nio.FloatBuffer;
 import java.util.function.Supplier;
@@ -29,7 +29,7 @@ public void update() {
 			cachedValue.get(buffer);
 			buffer.rewind();
 
-			GL21.glUniformMatrix4fv(location, false, buffer);
+			IrisRenderSystem.uniformMatrix4fv(location, false, buffer);
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/gl/uniform/MatrixFromFloatArrayUniform.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.iris.gl.uniform;
 
+import net.coderbot.iris.gl.IrisRenderSystem;
 import org.lwjgl.BufferUtils;
-import org.lwjgl.opengl.GL21;
 
 import java.nio.FloatBuffer;
 import java.util.Arrays;
@@ -29,7 +29,7 @@ public void update() {
 			buffer.put(cachedValue);
 			buffer.rewind();
 
-			GL21.glUniformMatrix4fv(location, false, buffer);
+			IrisRenderSystem.uniformMatrix4fv(location, false, buffer);
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/gl/uniform/MatrixUniform.java
Patch:
@@ -4,8 +4,8 @@
 import java.nio.FloatBuffer;
 import java.util.function.Supplier;
 
+import net.coderbot.iris.gl.IrisRenderSystem;
 import org.lwjgl.BufferUtils;
-import org.lwjgl.opengl.GL21;
 
 public class MatrixUniform extends Uniform {
 	private FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
@@ -29,7 +29,7 @@ public void update() {
 			cachedValue.store(buffer);
 			buffer.rewind();
 
-			GL21.glUniformMatrix4fv(location, false, buffer);
+			IrisRenderSystem.uniformMatrix4fv(location, false, buffer);
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/gl/uniform/Vector2IntegerJomlUniform.java
Patch:
@@ -1,5 +1,6 @@
 package net.coderbot.iris.gl.uniform;
 
+import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector2i;
 import org.lwjgl.opengl.GL20;
 
@@ -34,7 +35,7 @@ private void updateValue() {
 
 		if (cachedValue == null || !newValue.equals(cachedValue)) {
 			cachedValue = newValue;
-			GL20.glUniform2i(this.location, newValue.x, newValue.y);
+			IrisRenderSystem.uniform2i(this.location, newValue.x, newValue.y);
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/gl/uniform/Vector2Uniform.java
Patch:
@@ -2,8 +2,8 @@
 
 import java.util.function.Supplier;
 
+import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector2f;
-import org.lwjgl.opengl.GL20;
 
 public class Vector2Uniform extends Uniform {
 	private Vector2f cachedValue;
@@ -23,7 +23,7 @@ public void update() {
 
 		if (cachedValue == null || !newValue.equals(cachedValue)) {
 			cachedValue = newValue;
-			GL20.glUniform2f(this.location, newValue.x, newValue.y);
+			IrisRenderSystem.uniform2f(this.location, newValue.x, newValue.y);
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/gl/uniform/Vector3Uniform.java
Patch:
@@ -2,10 +2,10 @@
 
 import java.util.function.Supplier;
 
+import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector3d;
 import net.coderbot.iris.vendored.joml.Vector3f;
 import net.coderbot.iris.vendored.joml.Vector4f;
-import org.lwjgl.opengl.GL21;
 
 public class Vector3Uniform extends Uniform {
 	private final Vector3f cachedValue;
@@ -48,7 +48,7 @@ public void update() {
 
 		if (!newValue.equals(cachedValue)) {
 			cachedValue.set(newValue.x(), newValue.y(), newValue.z());
-			GL21.glUniform3f(location, cachedValue.x(), cachedValue.y(), cachedValue.z());
+			IrisRenderSystem.uniform3f(location, cachedValue.x(), cachedValue.y(), cachedValue.z());
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/gl/uniform/Vector4Uniform.java
Patch:
@@ -2,8 +2,8 @@
 
 import java.util.function.Supplier;
 
+import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector4f;
-import org.lwjgl.opengl.GL21;
 
 public class Vector4Uniform extends Uniform {
 	private final Vector4f cachedValue;
@@ -34,7 +34,7 @@ private void updateValue() {
 
 		if (!newValue.equals(cachedValue)) {
 			cachedValue.set(newValue.x(), newValue.y(), newValue.z(), newValue.w());
-			GL21.glUniform4f(location, cachedValue.x(), cachedValue.y(), cachedValue.z(), cachedValue.w());
+			IrisRenderSystem.uniform4f(location, cachedValue.x(), cachedValue.y(), cachedValue.z(), cachedValue.w());
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/MixinGameRenderer.java
Patch:
@@ -46,4 +46,5 @@ private void disableVanillaHandRendering(ItemInHandRenderer itemInHandRenderer,
 
 		itemInHandRenderer.renderHandsWithItems(tickDelta, poseStack, bufferSource, localPlayer, light);
 	}
+
 }

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPipeline.java
Patch:
@@ -31,6 +31,7 @@ public interface WorldRenderingPipeline {
 	boolean shouldRenderClouds();
 	boolean shouldRenderUnderwaterOverlay();
 	boolean shouldRenderVignette();
+	boolean shouldWriteRainAndSnowToDepthBuffer();
 
 	float getSunPathRotation();
 }

File: src/main/java/net/coderbot/iris/postprocess/CenterDepthSampler.java
Patch:
@@ -1,5 +1,6 @@
 package net.coderbot.iris.postprocess;
 
+import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.gl.framebuffer.GlFramebuffer;
 import net.coderbot.iris.rendertarget.RenderTargets;
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
@@ -38,7 +39,7 @@ private float sampleCenterDepth() {
 		float[] depthValue = new float[1];
 		// Read a single pixel from the depth buffer
 		// TODO: glReadPixels forces a full pipeline stall / flush, and probably isn't too great for performance
-		GL11C.glReadPixels(
+		IrisRenderSystem.readPixels(
 			renderTargets.getCurrentWidth() / 2, renderTargets.getCurrentHeight() / 2, 1, 1,
 			GL11C.GL_DEPTH_COMPONENT, GL11C.GL_FLOAT, depthValue
 		);

File: src/main/java/net/coderbot/iris/rendertarget/FramebufferBlitter.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.mojang.blaze3d.pipeline.RenderTarget;
 import com.mojang.blaze3d.platform.GlStateManager;
+import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.gl.framebuffer.GlFramebuffer;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL30C;
@@ -14,8 +15,7 @@ public static void copyFramebufferContent(GlFramebuffer from, RenderTarget to) {
 		int width = to.width;
 		int height = to.height;
 
-		// TODO: Support OpenGL 2.1?
-		GL30C.glBlitFramebuffer(0, 0, width, height, 0, 0, width, height,
+		GlStateManager._glBlitFrameBuffer(0, 0, width, height, 0, 0, width, height,
 			GL11C.GL_COLOR_BUFFER_BIT | GL11C.GL_DEPTH_BUFFER_BIT, GL11C.GL_NEAREST);
 	}
 
@@ -27,7 +27,7 @@ public static void copyDepthBufferContent(GlFramebuffer from, RenderTarget to) {
 		int height = to.height;
 
 		// TODO: Support OpenGL 2.1?
-		GL30C.glBlitFramebuffer(0, 0, width, height, 0, 0, width, height,
+		IrisRenderSystem.blitFramebuffer(0, 0, width, height, 0, 0, width, height,
 				GL11C.GL_DEPTH_BUFFER_BIT, GL11C.GL_NEAREST);
 	}
 }

File: src/main/java/net/coderbot/iris/rendertarget/RenderTargets.java
Patch:
@@ -29,7 +29,9 @@ public RenderTargets(int width, int height, Map<Integer, PackRenderTargetDirecti
 
 		renderTargets.forEach((index, settings) -> {
 			// TODO: Handle mipmapping?
-			targets[index] = net.coderbot.iris.rendertarget.RenderTarget.builder().setDimensions(width, height).setInternalFormat(settings.getRequestedFormat()).build();
+			targets[index] = net.coderbot.iris.rendertarget.RenderTarget.builder().setDimensions(width, height)
+					.setInternalFormat(settings.getInternalFormat())
+					.setPixelFormat(settings.getInternalFormat().getPixelFormat()).build();
 		});
 
 		this.depthTexture = new DepthTexture(width, height);

File: src/main/java/net/coderbot/iris/samplers/IrisSamplers.java
Patch:
@@ -75,8 +75,10 @@ public static void addNoiseSampler(SamplerHolder samplers, IntSupplier sampler)
 
 	public static boolean hasShadowSamplers(SamplerHolder samplers) {
 		// TODO: Keep this up to date with the actual definitions.
+		// TODO: Don't query image presence using the sampler interface even though the current underlying implementation
+		//       is the same.
 		ImmutableList<String> shadowSamplers = ImmutableList.of("shadowtex0", "shadowtex1", "shadow", "watershadow",
-				"shadowcolor", "shadowcolor0", "shadowcolor1");
+				"shadowcolor", "shadowcolor0", "shadowcolor1", "shadowcolorimg0", "shadowcolorimg1");
 
 		for (String samplerName : shadowSamplers) {
 			if (samplers.hasSampler(samplerName)) {

File: src/main/java/net/coderbot/iris/shaderpack/PackRenderTargetDirectives.java
Patch:
@@ -137,7 +137,7 @@ public RenderTargetSettings() {
 			this.clearColor = null;
 		}
 
-		public InternalTextureFormat getRequestedFormat() {
+		public InternalTextureFormat getInternalFormat() {
 			return requestedFormat;
 		}
 

File: src/main/java/net/coderbot/iris/shaderpack/ShaderProperties.java
Patch:
@@ -120,7 +120,7 @@ public ShaderProperties(Properties properties) {
 
 			handlePassDirective("alphaTest.", key, value, pass -> {
 				if ("off".equals(value)) {
-					alphaTestOverrides.put(pass, new AlphaTestOverride.Off());
+					alphaTestOverrides.put(pass, AlphaTestOverride.OFF);
 					return;
 				}
 
@@ -149,7 +149,7 @@ public ShaderProperties(Properties properties) {
 					return;
 				}
 
-				alphaTestOverrides.put(pass, new AlphaTestOverride(function.get(), reference));
+				alphaTestOverrides.put(pass, new AlphaTestOverride(new AlphaTest(function.get(), reference)));
 			});
 
 			handlePassDirective("blend.", key, value, pass -> {

File: src/main/java/net/coderbot/iris/shaderpack/option/values/OptionValues.java
Patch:
@@ -1,9 +1,11 @@
 package net.coderbot.iris.shaderpack.option.values;
 
+import net.coderbot.iris.shaderpack.OptionalBoolean;
+
 import java.util.Optional;
 
 public interface OptionValues {
-	boolean isBooleanFlipped(String name);
+	OptionalBoolean getBooleanValue(String name);
 	Optional<String> getStringValue(String name);
 
 	MutableOptionValues mutableCopy();

File: src/main/java/net/coderbot/iris/shadows/ShadowMapRenderer.java
Patch:
@@ -13,5 +13,6 @@ public interface ShadowMapRenderer {
 	// TODO: Support more shadow color textures as well as support there being no shadow color textures.
 	int getColorTexture0Id();
 	int getColorTexture1Id();
+	ShadowRenderTargets getRenderTargets();
 	void destroy();
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/shader_overrides/MixinShaderType.java
Patch:
@@ -11,8 +11,7 @@
 
 @Mixin(ShaderType.class)
 public class MixinShaderType {
-	// Ignore any warnings about not finding the target for this field.
-	// It's a synthetic field, so Mixin doesn't see it.
+	@SuppressWarnings("target")
     @Shadow(remap = false)
     @Final
     @Mutable

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/vertex_format/MixinChunkMeshAttribute.java
Patch:
@@ -16,8 +16,7 @@
  */
 @Mixin(ChunkMeshAttribute.class)
 public class MixinChunkMeshAttribute {
-	// Ignore any warnings about not finding the target for this field.
-	// It's a synthetic field, so Mixin doesn't see it.
+	@SuppressWarnings("target")
     @Shadow(remap = false)
     @Final
     @Mutable

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -414,7 +414,7 @@ public static Map<String, String> getShaderPackOptionQueue() {
 	}
 
 	public static void queueShaderPackOptionsFromProfile(Profile profile) {
-		profile.optionValues.forEach(getShaderPackOptionQueue()::put);
+		getShaderPackOptionQueue().putAll(profile.optionValues);
 	}
 
 	public static void clearShaderPackOptionQueue() {

File: src/main/java/kroppeb/stareval/element/PriorityOperatorElement.java
Patch:
@@ -3,5 +3,5 @@
 public interface PriorityOperatorElement extends Element {
 	int getPriority();
 
-	Expression resolveWith(Expression right);
+	ExpressionElement resolveWith(ExpressionElement right);
 }

File: src/main/java/kroppeb/stareval/element/tree/partial/UnfinishedArgsExpression.java
Patch:
@@ -1,12 +1,12 @@
 package kroppeb.stareval.element.tree.partial;
 
-import kroppeb.stareval.element.Expression;
+import kroppeb.stareval.element.ExpressionElement;
 
 import java.util.ArrayList;
 import java.util.List;
 
 public class UnfinishedArgsExpression extends PartialExpression {
-	public final List<Expression> tokens = new ArrayList<>();
+	public final List<ExpressionElement> tokens = new ArrayList<>();
 
 	@Override
 	public String toString() {

File: src/main/java/kroppeb/stareval/parser/Tokenizer.java
Patch:
@@ -1,19 +1,19 @@
 package kroppeb.stareval.parser;
 
+import kroppeb.stareval.element.ExpressionElement;
 import kroppeb.stareval.exception.ParseException;
 import kroppeb.stareval.exception.UnexpectedCharacterException;
 import kroppeb.stareval.exception.UnexpectedEndingException;
-import kroppeb.stareval.element.Expression;
 
 class Tokenizer {
 	private Tokenizer() {
 	}
 
-	static Expression parse(String input, ParserOptions options) throws ParseException {
+	static ExpressionElement parse(String input, ParserOptions options) throws ParseException {
 		return parseInternal(new StringReader(input), options);
 	}
 
-	static Expression parseInternal(StringReader input, ParserOptions options) throws ParseException {
+	static ExpressionElement parseInternal(StringReader input, ParserOptions options) throws ParseException {
 		// parser stack
 		final Parser stack = new Parser();
 		ParserOptions.TokenRules tokenRules = options.getTokenRules();

File: src/main/java/net/coderbot/iris/gl/sampler/SamplerLimits.java
Patch:
@@ -1,13 +1,14 @@
 package net.coderbot.iris.gl.sampler;
 
+import com.mojang.blaze3d.platform.GlStateManager;
 import org.lwjgl.opengl.GL20C;
 
 public class SamplerLimits {
 	private final int maxTextureUnits;
 	private static SamplerLimits instance;
 
 	private SamplerLimits() {
-		this.maxTextureUnits = GL20C.glGetInteger(GL20C.GL_MAX_TEXTURE_IMAGE_UNITS);
+		this.maxTextureUnits = GlStateManager._getInteger(GL20C.GL_MAX_TEXTURE_IMAGE_UNITS);
 	}
 
 	public int getMaxTextureUnits() {

File: src/main/java/net/coderbot/iris/gl/uniform/FloatUniform.java
Patch:
@@ -1,6 +1,6 @@
 package net.coderbot.iris.gl.uniform;
 
-import org.lwjgl.opengl.GL21;
+import net.coderbot.iris.gl.IrisRenderSystem;
 
 public class FloatUniform extends Uniform {
 	private float cachedValue;
@@ -31,7 +31,7 @@ private void updateValue() {
 
 		if (cachedValue != newValue) {
 			cachedValue = newValue;
-			GL21.glUniform1f(location, newValue);
+			IrisRenderSystem.uniform1f(location, newValue);
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/gl/uniform/IntUniform.java
Patch:
@@ -2,7 +2,7 @@
 
 import java.util.function.IntSupplier;
 
-import org.lwjgl.opengl.GL21;
+import net.coderbot.iris.gl.IrisRenderSystem;
 
 public class IntUniform extends Uniform {
 	private int cachedValue;
@@ -33,7 +33,7 @@ private void updateValue() {
 
 		if (cachedValue != newValue) {
 			cachedValue = newValue;
-			GL21.glUniform1i(location, newValue);
+			IrisRenderSystem.uniform1i(location, newValue);
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/gl/uniform/JomlMatrixUniform.java
Patch:
@@ -1,8 +1,8 @@
 package net.coderbot.iris.gl.uniform;
 
+import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Matrix4f;
 import org.lwjgl.BufferUtils;
-import org.lwjgl.opengl.GL21;
 
 import java.nio.FloatBuffer;
 import java.util.function.Supplier;
@@ -29,7 +29,7 @@ public void update() {
 			cachedValue.get(buffer);
 			buffer.rewind();
 
-			GL21.glUniformMatrix4fv(location, false, buffer);
+			IrisRenderSystem.uniformMatrix4fv(location, false, buffer);
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/gl/uniform/MatrixFromFloatArrayUniform.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.iris.gl.uniform;
 
+import net.coderbot.iris.gl.IrisRenderSystem;
 import org.lwjgl.BufferUtils;
-import org.lwjgl.opengl.GL21;
 
 import java.nio.FloatBuffer;
 import java.util.Arrays;
@@ -29,7 +29,7 @@ public void update() {
 			buffer.put(cachedValue);
 			buffer.rewind();
 
-			GL21.glUniformMatrix4fv(location, false, buffer);
+			IrisRenderSystem.uniformMatrix4fv(location, false, buffer);
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/gl/uniform/MatrixUniform.java
Patch:
@@ -4,8 +4,8 @@
 import java.nio.FloatBuffer;
 import java.util.function.Supplier;
 
+import net.coderbot.iris.gl.IrisRenderSystem;
 import org.lwjgl.BufferUtils;
-import org.lwjgl.opengl.GL21;
 
 public class MatrixUniform extends Uniform {
 	private FloatBuffer buffer = BufferUtils.createFloatBuffer(16);
@@ -29,7 +29,7 @@ public void update() {
 			cachedValue.store(buffer);
 			buffer.rewind();
 
-			GL21.glUniformMatrix4fv(location, false, buffer);
+			IrisRenderSystem.uniformMatrix4fv(location, false, buffer);
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/gl/uniform/Vector2IntegerJomlUniform.java
Patch:
@@ -1,5 +1,6 @@
 package net.coderbot.iris.gl.uniform;
 
+import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector2i;
 import org.lwjgl.opengl.GL20;
 
@@ -34,7 +35,7 @@ private void updateValue() {
 
 		if (cachedValue == null || !newValue.equals(cachedValue)) {
 			cachedValue = newValue;
-			GL20.glUniform2i(this.location, newValue.x, newValue.y);
+			IrisRenderSystem.uniform2i(this.location, newValue.x, newValue.y);
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/gl/uniform/Vector2Uniform.java
Patch:
@@ -2,8 +2,8 @@
 
 import java.util.function.Supplier;
 
+import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector2f;
-import org.lwjgl.opengl.GL20;
 
 public class Vector2Uniform extends Uniform {
 	private Vector2f cachedValue;
@@ -23,7 +23,7 @@ public void update() {
 
 		if (cachedValue == null || !newValue.equals(cachedValue)) {
 			cachedValue = newValue;
-			GL20.glUniform2f(this.location, newValue.x, newValue.y);
+			IrisRenderSystem.uniform2f(this.location, newValue.x, newValue.y);
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/gl/uniform/Vector3Uniform.java
Patch:
@@ -2,10 +2,10 @@
 
 import java.util.function.Supplier;
 
+import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector3d;
 import net.coderbot.iris.vendored.joml.Vector3f;
 import net.coderbot.iris.vendored.joml.Vector4f;
-import org.lwjgl.opengl.GL21;
 
 public class Vector3Uniform extends Uniform {
 	private final Vector3f cachedValue;
@@ -48,7 +48,7 @@ public void update() {
 
 		if (!newValue.equals(cachedValue)) {
 			cachedValue.set(newValue.x(), newValue.y(), newValue.z());
-			GL21.glUniform3f(location, cachedValue.x(), cachedValue.y(), cachedValue.z());
+			IrisRenderSystem.uniform3f(location, cachedValue.x(), cachedValue.y(), cachedValue.z());
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/gl/uniform/Vector4Uniform.java
Patch:
@@ -2,8 +2,8 @@
 
 import java.util.function.Supplier;
 
+import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.vendored.joml.Vector4f;
-import org.lwjgl.opengl.GL21;
 
 public class Vector4Uniform extends Uniform {
 	private final Vector4f cachedValue;
@@ -34,7 +34,7 @@ private void updateValue() {
 
 		if (!newValue.equals(cachedValue)) {
 			cachedValue.set(newValue.x(), newValue.y(), newValue.z(), newValue.w());
-			GL21.glUniform4f(location, cachedValue.x(), cachedValue.y(), cachedValue.z(), cachedValue.w());
+			IrisRenderSystem.uniform4f(location, cachedValue.x(), cachedValue.y(), cachedValue.z(), cachedValue.w());
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/gui/element/widget/StringElementWidget.java
Patch:
@@ -38,10 +38,10 @@ public void init(ShaderPackScreen screen, NavigationController navigation) {
 		List<String> values = this.option.getAllowedValues();
 
 		this.appliedValue = appliedValue.orElse(this.option.getDefaultValue()); // The value currently in use by the shader
-		String actualSetValue = pendingValue.orElse(this.appliedValue); // The unapplied value that has been queued (if that is the case)
+		String actualPendingValue = pendingValue.orElse(this.appliedValue); // The unapplied value that has been queued (if that is the case)
 
 		this.valueCount = values.size();
-		this.valueIndex = values.indexOf(actualSetValue);
+		this.valueIndex = values.indexOf(actualPendingValue);
 	}
 
 	@Override

File: src/main/java/net/coderbot/iris/mixin/MixinGameRenderer.java
Patch:
@@ -46,4 +46,5 @@ private void disableVanillaHandRendering(ItemInHandRenderer itemInHandRenderer,
 
 		itemInHandRenderer.renderHandsWithItems(tickDelta, poseStack, bufferSource, localPlayer, light);
 	}
+
 }

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPipeline.java
Patch:
@@ -31,6 +31,7 @@ public interface WorldRenderingPipeline {
 	boolean shouldRenderClouds();
 	boolean shouldRenderUnderwaterOverlay();
 	boolean shouldRenderVignette();
+	boolean shouldWriteRainAndSnowToDepthBuffer();
 
 	float getSunPathRotation();
 }

File: src/main/java/net/coderbot/iris/postprocess/CenterDepthSampler.java
Patch:
@@ -1,5 +1,6 @@
 package net.coderbot.iris.postprocess;
 
+import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.gl.framebuffer.GlFramebuffer;
 import net.coderbot.iris.rendertarget.RenderTargets;
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
@@ -38,7 +39,7 @@ private float sampleCenterDepth() {
 		float[] depthValue = new float[1];
 		// Read a single pixel from the depth buffer
 		// TODO: glReadPixels forces a full pipeline stall / flush, and probably isn't too great for performance
-		GL11C.glReadPixels(
+		IrisRenderSystem.readPixels(
 			renderTargets.getCurrentWidth() / 2, renderTargets.getCurrentHeight() / 2, 1, 1,
 			GL11C.GL_DEPTH_COMPONENT, GL11C.GL_FLOAT, depthValue
 		);

File: src/main/java/net/coderbot/iris/rendertarget/FramebufferBlitter.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.mojang.blaze3d.pipeline.RenderTarget;
 import com.mojang.blaze3d.platform.GlStateManager;
+import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.gl.framebuffer.GlFramebuffer;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL30C;
@@ -14,8 +15,7 @@ public static void copyFramebufferContent(GlFramebuffer from, RenderTarget to) {
 		int width = to.width;
 		int height = to.height;
 
-		// TODO: Support OpenGL 2.1?
-		GL30C.glBlitFramebuffer(0, 0, width, height, 0, 0, width, height,
+		GlStateManager._glBlitFrameBuffer(0, 0, width, height, 0, 0, width, height,
 			GL11C.GL_COLOR_BUFFER_BIT | GL11C.GL_DEPTH_BUFFER_BIT, GL11C.GL_NEAREST);
 	}
 
@@ -27,7 +27,7 @@ public static void copyDepthBufferContent(GlFramebuffer from, RenderTarget to) {
 		int height = to.height;
 
 		// TODO: Support OpenGL 2.1?
-		GL30C.glBlitFramebuffer(0, 0, width, height, 0, 0, width, height,
+		IrisRenderSystem.blitFramebuffer(0, 0, width, height, 0, 0, width, height,
 				GL11C.GL_DEPTH_BUFFER_BIT, GL11C.GL_NEAREST);
 	}
 }

File: src/main/java/net/coderbot/iris/rendertarget/RenderTargets.java
Patch:
@@ -29,7 +29,9 @@ public RenderTargets(int width, int height, Map<Integer, PackRenderTargetDirecti
 
 		renderTargets.forEach((index, settings) -> {
 			// TODO: Handle mipmapping?
-			targets[index] = net.coderbot.iris.rendertarget.RenderTarget.builder().setDimensions(width, height).setInternalFormat(settings.getRequestedFormat()).build();
+			targets[index] = net.coderbot.iris.rendertarget.RenderTarget.builder().setDimensions(width, height)
+					.setInternalFormat(settings.getInternalFormat())
+					.setPixelFormat(settings.getInternalFormat().getPixelFormat()).build();
 		});
 
 		this.depthTexture = new DepthTexture(width, height);

File: src/main/java/net/coderbot/iris/samplers/IrisSamplers.java
Patch:
@@ -75,8 +75,10 @@ public static void addNoiseSampler(SamplerHolder samplers, IntSupplier sampler)
 
 	public static boolean hasShadowSamplers(SamplerHolder samplers) {
 		// TODO: Keep this up to date with the actual definitions.
+		// TODO: Don't query image presence using the sampler interface even though the current underlying implementation
+		//       is the same.
 		ImmutableList<String> shadowSamplers = ImmutableList.of("shadowtex0", "shadowtex1", "shadow", "watershadow",
-				"shadowcolor", "shadowcolor0", "shadowcolor1");
+				"shadowcolor", "shadowcolor0", "shadowcolor1", "shadowcolorimg0", "shadowcolorimg1");
 
 		for (String samplerName : shadowSamplers) {
 			if (samplers.hasSampler(samplerName)) {

File: src/main/java/net/coderbot/iris/shaderpack/PackRenderTargetDirectives.java
Patch:
@@ -137,7 +137,7 @@ public RenderTargetSettings() {
 			this.clearColor = null;
 		}
 
-		public InternalTextureFormat getRequestedFormat() {
+		public InternalTextureFormat getInternalFormat() {
 			return requestedFormat;
 		}
 

File: src/main/java/net/coderbot/iris/shaderpack/option/Profile.java
Patch:
@@ -61,7 +61,7 @@ public boolean matches(OptionSet options, OptionValues values) {
 			String value = entry.getValue();
 
 			if (options.getBooleanOptions().containsKey(option)) {
-				boolean currentValue = options.getBooleanOptions().get(option).getOption().getDefaultValue() != values.isBooleanFlipped(option);
+				boolean currentValue = values.getBooleanValue(option).orElse(options.getBooleanOptions().get(option).getOption().getDefaultValue());
 
 				if (!Boolean.toString(currentValue).equals(value)) {
 					return false;

File: src/main/java/net/coderbot/iris/shaderpack/option/values/OptionValues.java
Patch:
@@ -1,9 +1,11 @@
 package net.coderbot.iris.shaderpack.option.values;
 
+import net.coderbot.iris.shaderpack.OptionalBoolean;
+
 import java.util.Optional;
 
 public interface OptionValues {
-	boolean isBooleanFlipped(String name);
+	OptionalBoolean getBooleanValue(String name);
 	Optional<String> getStringValue(String name);
 
 	MutableOptionValues mutableCopy();

File: src/main/java/net/coderbot/iris/shadows/ShadowMapRenderer.java
Patch:
@@ -13,5 +13,6 @@ public interface ShadowMapRenderer {
 	// TODO: Support more shadow color textures as well as support there being no shadow color textures.
 	int getColorTexture0Id();
 	int getColorTexture1Id();
+	ShadowRenderTargets getRenderTargets();
 	void destroy();
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/shader_overrides/MixinShaderType.java
Patch:
@@ -11,8 +11,7 @@
 
 @Mixin(ShaderType.class)
 public class MixinShaderType {
-	// Ignore any warnings about not finding the target for this field.
-	// It's a synthetic field, so Mixin doesn't see it.
+	@SuppressWarnings("target")
     @Shadow(remap = false)
     @Final
     @Mutable

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/vertex_format/MixinChunkMeshAttribute.java
Patch:
@@ -16,8 +16,7 @@
  */
 @Mixin(ChunkMeshAttribute.class)
 public class MixinChunkMeshAttribute {
-	// Ignore any warnings about not finding the target for this field.
-	// It's a synthetic field, so Mixin doesn't see it.
+	@SuppressWarnings("target")
     @Shadow(remap = false)
     @Final
     @Mutable

File: src/main/java/net/coderbot/iris/gl/program/ProgramUniforms.java
Patch:
@@ -160,7 +160,8 @@ public OptionalInt location(String name, UniformType type) {
 				return OptionalInt.empty();
 			}
 
-			if (!locations.containsKey(id) && !uniformNames.containsKey(name)) {
+			// TODO: Temporary hack until custom uniforms are merged.
+			if ((!locations.containsKey(id) && !uniformNames.containsKey(name)) || name.equals("framemod8")) {
 				locations.put(id, name);
 				uniformNames.put(name, type);
 			} else {

File: src/main/java/net/coderbot/iris/parsing/IrisFunctions.java
Patch:
@@ -46,8 +46,8 @@
  * #   in(x, val1, val2, ...)                         Check if a value equals one of several values
  */
 public class IrisFunctions {
-	final static FunctionResolver.Builder builder = new FunctionResolver.Builder();
-	final public static FunctionResolver functions;
+	static final FunctionResolver.Builder builder = new FunctionResolver.Builder();
+	public static final FunctionResolver functions;
 	
 	static {
 		{

File: src/main/java/net/coderbot/iris/parsing/IrisOptions.java
Patch:
@@ -16,8 +16,8 @@ public class IrisOptions {
 	static final BinaryOp MoreThan = new BinaryOp("moreThan", 2);
 	static final BinaryOp LessThanOrEquals = new BinaryOp("lessThanOrEquals", 2);
 	static final BinaryOp MoreThanOrEquals = new BinaryOp("moreThanOrEquals", 2);
-	static final BinaryOp And = new BinaryOp("or", 3);
-	static final BinaryOp Or = new BinaryOp("and", 3);
+	static final BinaryOp And = new BinaryOp("and", 3);
+	static final BinaryOp Or = new BinaryOp("or", 3);
 	
 	static final UnaryOp Not = new UnaryOp("not");
 	static final UnaryOp Negate = new UnaryOp("negate");

File: src/main/java/net/coderbot/iris/uniforms/custom/CustomUniforms.java
Patch:
@@ -133,7 +133,7 @@ private CustomUniforms(CustomUniformFixedInputUniformsHolder inputHolder, Map<St
 			while (!free.isEmpty()) {
 				CachedUniform pop = free.remove(free.size() - 1);
 				if (!brokenUniforms.contains(pop)) {
-					// only add those that are broken
+					// only add those that aren't broken
 					ordered.add(pop);
 				} else {
 					// mark all those that rely on use as broken too

File: src/main/java/net/coderbot/iris/pipeline/newshader/ShaderAttributeInputs.java
Patch:
@@ -11,7 +11,7 @@ public class ShaderAttributeInputs {
 	private boolean normal;
 	private boolean newLines;
 
-	public ShaderAttributeInputs(VertexFormat format, boolean isBeacon) {
+	public ShaderAttributeInputs(VertexFormat format, boolean isFullbright) {
 		if (format == DefaultVertexFormat.POSITION_COLOR_NORMAL) {
 			newLines = true;
 		}
@@ -29,7 +29,7 @@ public ShaderAttributeInputs(VertexFormat format, boolean isBeacon) {
 				overlay = true;
 			}
 
-			if ("UV2".equals(name) && !isBeacon) {
+			if ("UV2".equals(name) && !isFullbright) {
 				light = true;
 			}
 

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -130,8 +130,8 @@ public static FallbackShader createFallback(String name, GlFramebuffer writingTo
 										boolean intensityTex, boolean isBeacon) throws IOException {
 		ShaderAttributeInputs inputs = new ShaderAttributeInputs(vertexFormat, isBeacon);
 
-		String vertex = ShaderSynthesizer.vsh(true, inputs, fogMode, entityLighting);
-		String fragment = ShaderSynthesizer.fsh(inputs, fogMode, alpha, intensityTex);
+		String vertex = ShaderSynthesizer.vsh(true, inputs, fogMode, entityLighting, isBeacon);
+		String fragment = ShaderSynthesizer.fsh(inputs, fogMode, alpha, intensityTex, isBeacon);
 
 		String shaderJsonString = "{\n" +
 				"    \"blend\": {\n" +

File: src/main/java/net/coderbot/iris/pipeline/newshader/ShaderAttributeInputs.java
Patch:
@@ -11,7 +11,7 @@ public class ShaderAttributeInputs {
 	private boolean normal;
 	private boolean newLines;
 
-	public ShaderAttributeInputs(VertexFormat format) {
+	public ShaderAttributeInputs(VertexFormat format, boolean isBeacon) {
 		if (format == DefaultVertexFormat.POSITION_COLOR_NORMAL) {
 			newLines = true;
 		}
@@ -29,7 +29,7 @@ public ShaderAttributeInputs(VertexFormat format) {
 				overlay = true;
 			}
 
-			if ("UV2".equals(name)) {
+			if ("UV2".equals(name) && !isBeacon) {
 				light = true;
 			}
 

File: src/main/java/net/coderbot/iris/mixin/MixinShaderInstance.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.iris.mixin;
 
-import com.mojang.blaze3d.shaders.Uniform;
 import net.coderbot.iris.pipeline.newshader.ExtendedShader;
+import net.coderbot.iris.pipeline.newshader.fallback.FallbackShader;
 import net.minecraft.client.renderer.ShaderInstance;
 import org.apache.logging.log4j.Logger;
 import org.lwjgl.opengl.ARBTextureSwizzle;
@@ -68,7 +68,7 @@ public class MixinShaderInstance {
 	@Redirect(method = "updateLocations",
 			at = @At(value = "INVOKE", target = "Lorg/apache/logging/log4j/Logger;warn(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V", remap = false))
 	private void iris$redirectLogSpam(Logger logger, String message, Object arg1, Object arg2) {
-		if (((Object) this) instanceof ExtendedShader) {
+		if (((Object) this) instanceof ExtendedShader || ((Object) this) instanceof FallbackShader) {
 			return;
 		}
 

File: src/main/java/net/coderbot/iris/gui/element/widget/AbstractElementWidget.java
Patch:
@@ -11,6 +11,8 @@ public void render(PoseStack poseStack, int x, int y, int width, int height, int
 	public AbstractElementWidget() {
 	}
 
+	protected void onRefresh() {}
+
 	public abstract void render(PoseStack poseStack, int x, int y, int width, int height, int mouseX, int mouseY, float tickDelta, boolean hovered);
 
 	public boolean mouseClicked(double mx, double my, int button) {

File: src/main/java/net/coderbot/iris/gui/screen/ShaderPackScreen.java
Patch:
@@ -326,7 +326,7 @@ public void applyChanges() {
 		// If the pack is being changed, clear pending options from the previous pack to
 		// avoid possible undefined behavior from applying one pack's options to another pack
 		if (!name.equals(Iris.getCurrentPackName())) {
-			Iris.clearPendingShaderPackOptions();
+			Iris.clearShaderPackOptionQueue();
 		}
 
 		Iris.getIrisConfig().setShaderPackName(name);
@@ -350,7 +350,7 @@ public void applyChanges() {
 	}
 
 	private void discardChanges() {
-		Iris.clearPendingShaderPackOptions();
+		Iris.clearShaderPackOptionQueue();
 	}
 
 	private void openShaderPackFolder() {

File: src/main/java/net/coderbot/iris/shaderpack/option/Profile.java
Patch:
@@ -63,8 +63,7 @@ public boolean matches(OptionSet options, OptionValues values) {
 			if (options.getBooleanOptions().containsKey(option)) {
 				boolean currentValue = options.getBooleanOptions().get(option).getOption().getDefaultValue() != values.isBooleanFlipped(option);
 
-				if (("true".equals(value) && !currentValue) ||
-						("false".equals(value) && currentValue)) {
+				if (!Boolean.toString(currentValue).equals(value)) {
 					return false;
 				}
 			}

File: src/main/java/net/coderbot/iris/shaderpack/option/menu/OptionMenuElement.java
Patch:
@@ -20,7 +20,7 @@ public static OptionMenuElement create(String elementString, OptionMenuContainer
 		}
 		// Profile element
 		if (ELEMENT_PROFILE.equals(elementString)) {
-			return new OptionMenuProfileElement(container.getCurrentProfile(), container.getProfiles());
+			return new OptionMenuProfileElement(container.getProfiles(), shaderPackOptions.getOptionSet(), shaderPackOptions.getOptionValues());
 		}
 		// Link to sub screen element
 		if (elementString.startsWith("[") && elementString.endsWith("]")) {

File: src/main/java/net/coderbot/iris/gl/state/StateUpdateNotifiers.java
Patch:
@@ -7,8 +7,5 @@
  * fog-related values.
  */
 public class StateUpdateNotifiers {
-	public static ValueUpdateNotifier fogToggleNotifier;
-	public static ValueUpdateNotifier fogModeNotifier;
-	public static ValueUpdateNotifier fogDensityNotifier;
 	public static ValueUpdateNotifier atlasTextureNotifier;
 }

File: src/main/java/net/coderbot/iris/pipeline/newshader/FogMode.java
Patch:
@@ -2,5 +2,5 @@
 
 public enum FogMode {
 	OFF,
-	LINEAR
+	ENABLED
 }

File: src/main/java/net/coderbot/iris/pipeline/newshader/TriforceCompositePatcher.java
Patch:
@@ -28,7 +28,6 @@ public static String patch(String source, ShaderType type) {
 		}
 
 		// TODO: Other fog things
-		// TODO: fogDensity isn't actually implemented!
 
 		// This must be defined and valid in all shader passes, including composite passes.
 		//

File: src/main/java/net/coderbot/iris/pipeline/newshader/TriforcePatcher.java
Patch:
@@ -46,7 +46,6 @@ public static String patch(String source, ShaderType type, AlphaTest alpha, bool
 		transformations.injectLine(Transformations.InjectionPoint.BEFORE_CODE, "uniform mat4 iris_TextureMat;");
 
 		// TODO: Other fog things
-		// TODO: fogDensity isn't actually implemented!
 		transformations.injectLine(Transformations.InjectionPoint.BEFORE_CODE, "uniform float iris_FogDensity;\n" +
 				"uniform float iris_FogStart;\n" +
 				"uniform float iris_FogEnd;\n" +

File: src/main/java/net/coderbot/iris/pipeline/newshader/TriforceSodiumPatcher.java
Patch:
@@ -49,7 +49,6 @@ public static String patch(String source, ShaderType type, AlphaTest alpha, Shad
 		transformations.replaceExact("gl_TextureMatrix[0]", "mat4(1.0)");
 
 		// TODO: Other fog things
-		// TODO: fogDensity isn't actually implemented!
 		transformations.injectLine(Transformations.InjectionPoint.BEFORE_CODE, "uniform float iris_FogDensity;\n" +
 				"uniform float u_FogStart;\n" +
 				"uniform float u_FogEnd;\n" +

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderer.java
Patch:
@@ -237,7 +237,6 @@ private Program createProgram(ProgramSource source, ImmutableSet<Integer> flippe
 
 		ProgramSamplers.CustomTextureSamplerInterceptor customTextureSamplerInterceptor = ProgramSamplers.customTextureSamplerInterceptor(builder, customTextureIds, flippedAtLeastOnceSnapshot);
 
-		IrisInternalUniforms.addFogUniforms(builder);
 		CommonUniforms.addCommonUniforms(builder, source.getParent().getPack().getIdMap(), source.getParent().getPackDirectives(), updateNotifier, FogMode.OFF);
 		IrisSamplers.addRenderTargetSamplers(customTextureSamplerInterceptor, () -> flipped, renderTargets, true);
 		IrisImages.addRenderTargetImages(builder, () -> flipped, renderTargets);

File: src/main/java/net/coderbot/iris/postprocess/FinalPassRenderer.java
Patch:
@@ -272,7 +272,6 @@ private Program createProgram(ProgramSource source, ImmutableSet<Integer> flippe
 
 		ProgramSamplers.CustomTextureSamplerInterceptor customTextureSamplerInterceptor = ProgramSamplers.customTextureSamplerInterceptor(builder, customTextureIds, flippedAtLeastOnceSnapshot);
 
-		IrisInternalUniforms.addFogUniforms(builder);
 		CommonUniforms.addCommonUniforms(builder, source.getParent().getPack().getIdMap(), source.getParent().getPackDirectives(), updateNotifier, FogMode.OFF);
 		IrisSamplers.addRenderTargetSamplers(customTextureSamplerInterceptor, () -> flipped, renderTargets, true);
 		IrisImages.addRenderTargetImages(builder, () -> flipped, renderTargets);

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -58,6 +58,7 @@ public static void addCommonUniforms(DynamicUniformHolder uniforms, IdMap idMap,
 		MatrixUniforms.addMatrixUniforms(uniforms, directives);
 		HardcodedCustomUniforms.addHardcodedCustomUniforms(uniforms, updateNotifier);
 		FogUniforms.addFogUniforms(uniforms, fogMode);
+		IrisInternalUniforms.addFogUniforms(uniforms);
 
 		uniforms.uniform4f("entityColor", () -> {
 			if (EntityColorRenderStateShard.currentHurt) {

File: src/main/java/net/coderbot/iris/mixin/MixinShaderInstance.java
Patch:
@@ -78,9 +78,9 @@ public class MixinShaderInstance {
 	}
 
 	@Redirect(method = "<init>", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/shaders/Uniform;glBindAttribLocation(IILjava/lang/CharSequence;)V"))
-	public void redirectBindAttributeLocation(int i, int j, CharSequence charSequence) {
+	public void iris$redirectBindAttributeLocation(int i, int j, CharSequence charSequence) {
 		if (((Object) this) instanceof ExtendedShader && Arrays.asList("Position", "Color", "Normal", "UV0", "UV1", "UV2").contains(charSequence)) {
-			Uniform.glBindAttribLocation(i, j, "va" + charSequence);
+			Uniform.glBindAttribLocation(i, j, "iris_" + charSequence);
 		} else {
 			Uniform.glBindAttribLocation(i, j, charSequence);
 		}

File: src/main/java/net/coderbot/iris/gl/IrisRenderSystem.java
Patch:
@@ -147,7 +147,7 @@ public static int getMaxImageUnits() {
 		if (GL.getCapabilities().OpenGL42) {
 			return GlStateManager._getInteger(GL42C.GL_MAX_IMAGE_UNITS);
 		} else if (GL.getCapabilities().GL_EXT_shader_image_load_store) {
-			return EXTShaderImageLoadStore.GL_MAX_IMAGE_UNITS_EXT;
+			return GlStateManager._getInteger(EXTShaderImageLoadStore.GL_MAX_IMAGE_UNITS_EXT);
 		} else {
 			return 0;
 		}

File: src/main/java/net/coderbot/iris/gl/image/ImageLimits.java
Patch:
@@ -1,5 +1,6 @@
 package net.coderbot.iris.gl.image;
 
+import com.mojang.blaze3d.platform.GlStateManager;
 import org.lwjgl.opengl.EXTShaderImageLoadStore;
 import org.lwjgl.opengl.GL;
 import org.lwjgl.opengl.GL42C;
@@ -10,7 +11,7 @@ public class ImageLimits {
 
 	private ImageLimits() {
 		if (GL.getCapabilities().OpenGL42) {
-			this.maxImageUnits = GL42C.glGetInteger(GL42C.GL_MAX_IMAGE_UNITS);
+			this.maxImageUnits = GlStateManager._getInteger(GL42C.GL_MAX_IMAGE_UNITS);
 		} else if (GL.getCapabilities().GL_EXT_shader_image_load_store) {
 			this.maxImageUnits = EXTShaderImageLoadStore.GL_MAX_IMAGE_UNITS_EXT;
 		} else {

File: src/main/java/net/coderbot/iris/gl/shader/ProgramCreator.java
Patch:
@@ -28,7 +28,7 @@ public static int create(String name, GlShader... shaders) {
 
         //Always detach shaders according to https://www.khronos.org/opengl/wiki/Shader_Compilation#Cleanup
         for (GlShader shader : shaders) {
-            GL20C.glDetachShader(program, shader.getHandle());
+            IrisRenderSystem.detachShader(program, shader.getHandle());
         }
 
 		String log = IrisRenderSystem.getProgramInfoLog(program);

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -706,7 +706,7 @@ public void beginHand() {
 		// all non-translucent content without the hand, as required.
 		baseline.bindAsReadBuffer();
 		GlStateManager._bindTexture(renderTargets.getDepthTextureNoHand().getTextureId());
-		GL20C.glCopyTexImage2D(GL20C.GL_TEXTURE_2D, 0, GL20C.GL_DEPTH_COMPONENT, 0, 0, renderTargets.getCurrentWidth(), renderTargets.getCurrentHeight(), 0);
+		IrisRenderSystem.copyTexImage2D(GL20C.GL_TEXTURE_2D, 0, GL20C.GL_DEPTH_COMPONENT, 0, 0, renderTargets.getCurrentWidth(), renderTargets.getCurrentHeight(), 0);
 		GlStateManager._bindTexture(0);
 	}
 

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -414,7 +414,7 @@ private void setupGlState(float[] orthoMatrix) {
 		// Set up our orthographic projection matrix and load it into the legacy matrix stack
 		RenderSystem.matrixMode(GL11.GL_PROJECTION);
 		RenderSystem.pushMatrix();
-		GL11.glLoadMatrixf(orthoMatrix);
+		IrisRenderSystem.loadMatrixf(orthoMatrix);
 		RenderSystem.matrixMode(GL11.GL_MODELVIEW);
 
 		// Disable backface culling
@@ -447,7 +447,7 @@ private void copyPreTranslucentDepth() {
 		// This is needed for the shadowtex0 / shadowtex1 split.
 		RenderSystem.activeTexture(GL20C.GL_TEXTURE0);
 		RenderSystem.bindTexture(targets.getDepthTextureNoTranslucents().getTextureId());
-		GL20C.glCopyTexImage2D(GL20C.GL_TEXTURE_2D, 0, GL20C.GL_DEPTH_COMPONENT, 0, 0, resolution, resolution, 0);
+		IrisRenderSystem.copyTexImage2D(GL20C.GL_TEXTURE_2D, 0, GL20C.GL_DEPTH_COMPONENT, 0, 0, resolution, resolution, 0);
 		RenderSystem.bindTexture(0);
 	}
 

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/shader_overrides/IrisChunkProgram.java
Patch:
@@ -5,12 +5,12 @@
 import me.jellysquid.mods.sodium.client.gl.device.RenderDevice;
 import me.jellysquid.mods.sodium.client.render.chunk.shader.ChunkProgram;
 import me.jellysquid.mods.sodium.client.render.chunk.shader.ChunkShaderFogComponent;
+import net.coderbot.iris.gl.IrisRenderSystem;
 import net.coderbot.iris.gl.program.ProgramImages;
 import net.coderbot.iris.gl.program.ProgramSamplers;
 import net.coderbot.iris.gl.program.ProgramUniforms;
 import net.minecraft.resources.ResourceLocation;
 import org.jetbrains.annotations.Nullable;
-import org.lwjgl.opengl.GL20C;
 import org.lwjgl.system.MemoryStack;
 
 import java.nio.FloatBuffer;
@@ -92,7 +92,7 @@ private void uniformMatrix(int location, Matrix4f matrix) {
 
             matrix.store(buffer);
 
-            GL20C.glUniformMatrix4fv(location, false, buffer);
+            IrisRenderSystem.uniformMatrix4fv(location, false, buffer);
         }
     }
 }

File: src/main/java/net/coderbot/iris/HorizonRenderer.java
Patch:
@@ -134,7 +134,7 @@ private void buildHorizon(VertexConsumer consumer) {
 	}
 
 	private int getRenderDistanceInBlocks() {
-		return Minecraft.getInstance().options.renderDistance * 16;
+		return Minecraft.getInstance().options.getEffectiveRenderDistance() * 16;
 	}
 
 	public void close() {

File: src/main/java/net/coderbot/iris/mixin/MixinLevelRenderer.java
Patch:
@@ -74,10 +74,10 @@ public class MixinLevelRenderer {
 		SystemTimeUniforms.COUNTER.beginFrame();
 		SystemTimeUniforms.TIMER.beginFrame(startTime);
 
-		if(previousViewDistance != minecraft.options.renderDistance) {
+		if(previousViewDistance != minecraft.options.getEffectiveRenderDistance()) {
 			horizonRenderer.close();
 			horizonRenderer = new HorizonRenderer();
-			previousViewDistance = minecraft.options.renderDistance;
+			previousViewDistance = minecraft.options.getEffectiveRenderDistance();
 		}
 
 		pipeline = Iris.getPipelineManager().preparePipeline(Iris.getCurrentDimension());

File: src/main/java/net/coderbot/iris/uniforms/CameraUniforms.java
Patch:
@@ -29,7 +29,7 @@ public static void addCameraUniforms(UniformHolder uniforms, FrameUpdateNotifier
 
 	private static int getRenderDistanceInBlocks() {
 		// TODO: Should we ask the game renderer for this?
-		return client.options.renderDistance * 16;
+		return client.options.getEffectiveRenderDistance() * 16;
 	}
 
 	public static Vector3d getUnshiftedCameraPosition() {

File: src/main/java/net/coderbot/iris/mixin/MixinItemInHandRenderer.java
Patch:
@@ -17,7 +17,7 @@
 @Mixin(ItemInHandRenderer.class)
 public class MixinItemInHandRenderer {
 	@Inject(method = "renderArmWithItem", at = @At("HEAD"), cancellable = true)
-	private void skipTranslucentHands(AbstractClientPlayer abstractClientPlayer, float f, float g, InteractionHand interactionHand, float h, ItemStack itemStack, float i, PoseStack poseStack, MultiBufferSource multiBufferSource, int j, CallbackInfo ci) {
+	private void iris$skipTranslucentHands(AbstractClientPlayer abstractClientPlayer, float f, float g, InteractionHand interactionHand, float h, ItemStack itemStack, float i, PoseStack poseStack, MultiBufferSource multiBufferSource, int j, CallbackInfo ci) {
 		if (!(Iris.getPipelineManager().getPipelineNullable() instanceof FixedFunctionWorldRenderingPipeline)) {
 			if (HandRenderer.INSTANCE.isRenderingSolid() && HandRenderer.INSTANCE.isHandTranslucent(interactionHand)) {
 				ci.cancel();

File: src/main/java/net/coderbot/iris/pipeline/HandRenderer.java
Patch:
@@ -39,7 +39,7 @@ private void setupGlState(GameRenderer gameRenderer, Camera camera, PoseStack po
 
 		((GameRendererAccessor) gameRenderer).invokeBobHurt(poseStack, tickDelta);
 
-		if(Minecraft.getInstance().options.bobView) {
+		if (Minecraft.getInstance().options.bobView) {
 			((GameRendererAccessor) gameRenderer).invokeBobView(poseStack, tickDelta);
 		}
 	}
@@ -69,7 +69,7 @@ public boolean isAnyHandTranslucent() {
 	}
 
 	public void renderSolid(PoseStack poseStack, float tickDelta, Camera camera, GameRenderer gameRenderer, WorldRenderingPipeline pipeline) {
-		if(!canRender(camera, gameRenderer) || pipeline instanceof FixedFunctionWorldRenderingPipeline) {
+		if (!canRender(camera, gameRenderer) || pipeline instanceof FixedFunctionWorldRenderingPipeline) {
 			return;
 		}
 
@@ -99,7 +99,7 @@ public void renderSolid(PoseStack poseStack, float tickDelta, Camera camera, Gam
 	}
 
 	public void renderTranslucent(PoseStack poseStack, float tickDelta, Camera camera, GameRenderer gameRenderer, WorldRenderingPipeline pipeline) {
-		if(!canRender(camera, gameRenderer) || !isAnyHandTranslucent() || pipeline instanceof FixedFunctionWorldRenderingPipeline) {
+		if (!canRender(camera, gameRenderer) || !isAnyHandTranslucent() || pipeline instanceof FixedFunctionWorldRenderingPipeline) {
 			return;
 		}
 

File: src/main/java/net/coderbot/iris/shaderpack/ShaderPack.java
Patch:
@@ -7,6 +7,7 @@
 import it.unimi.dsi.fastutil.objects.Object2ObjectMap;
 import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
 import net.coderbot.iris.Iris;
+import net.coderbot.iris.shaderpack.preprocessor.PropertiesPreprocessor;
 import net.coderbot.iris.shaderpack.texture.CustomTextureData;
 import net.coderbot.iris.shaderpack.texture.TextureFilteringData;
 import net.coderbot.iris.shaderpack.texture.TextureStage;

File: src/main/java/net/coderbot/iris/shaderpack/preprocessor/PropertiesPreprocessor.java
Patch:
@@ -1,8 +1,7 @@
-package net.coderbot.iris.shaderpack;
+package net.coderbot.iris.shaderpack.preprocessor;
 
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.gl.shader.StandardMacros;
-import net.coderbot.iris.shaderpack.preprocessor.PropertiesCommentListener;
 import org.anarres.cpp.Feature;
 import org.anarres.cpp.Preprocessor;
 import org.anarres.cpp.StringLexerSource;

File: src/main/java/net/coderbot/iris/shaderpack/preprocessor/PropertiesPreprocessor.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.gl.shader.StandardMacros;
-import org.anarres.cpp.DefaultPreprocessorListener;
+import net.coderbot.iris.shaderpack.preprocessor.PropertiesCommentListener;
 import org.anarres.cpp.Feature;
 import org.anarres.cpp.Preprocessor;
 import org.anarres.cpp.StringLexerSource;
@@ -21,7 +21,7 @@ public static String process(Path rootPath, Path shaderPath, String source) {
 	public static String preprocessSource(String source) {
 		@SuppressWarnings("resource")
 		final Preprocessor pp = new Preprocessor();
-		pp.setListener(new DefaultPreprocessorListener());
+		pp.setListener(new PropertiesCommentListener());
 		pp.addInput(new StringLexerSource(source, true));
 		pp.addFeature(Feature.KEEPCOMMENTS);
 

File: src/main/java/net/coderbot/iris/mixin/MixinScreenEffectRenderer.java
Patch:
@@ -23,5 +23,5 @@ public abstract class MixinScreenEffectRenderer {
 		if (pipeline != null && !pipeline.shouldRenderUnderwaterOverlay()) {
 			ci.cancel();
 		}
-    }
+	}
 }

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -83,7 +83,9 @@ public void onInitializeClient() {
 		physicsModInstalled = FabricLoader.getInstance().isModLoaded("physicsmod");
 
 		try {
-			Files.createDirectories(getShaderpacksDirectory());
+			if (!Files.exists(getShaderpacksDirectory())) {
+				Files.createDirectories(getShaderpacksDirectory());
+			}
 		} catch (IOException e) {
 			logger.warn("Failed to create the shaderpacks directory!");
 			logger.catching(Level.WARN, e);

File: src/main/java/net/coderbot/iris/layer/GbufferPrograms.java
Patch:
@@ -70,7 +70,7 @@ public static void endBlockEntities() {
 	public static void push(GbufferProgram program) {
 		program = refine(program);
 
-		WorldRenderingPipeline pipeline = Iris.getPipelineManager().getPipeline();
+		WorldRenderingPipeline pipeline = Iris.getPipelineManager().getPipelineNullable();
 
 		if (pipeline != null) {
 			pipeline.pushProgram(program);
@@ -80,7 +80,7 @@ public static void push(GbufferProgram program) {
 	public static void pop(GbufferProgram program) {
 		program = refine(program);
 
-		WorldRenderingPipeline pipeline = Iris.getPipelineManager().getPipeline();
+		WorldRenderingPipeline pipeline = Iris.getPipelineManager().getPipelineNullable();
 
 		if (pipeline != null) {
 			pipeline.popProgram(program);

File: src/main/java/net/coderbot/iris/mixin/MixinDebugScreenOverlay.java
Patch:
@@ -67,7 +67,7 @@ private void appendShadowDebugText(CallbackInfoReturnable<List<String>> cir) {
 			messages.add(2, ChatFormatting.YELLOW + "[Iris] Install Sodium if you want to run benchmarks or get higher FPS!");
 		}
 
-		Iris.getPipelineManager().getPipeline().addDebugText(messages);
+		Iris.getPipelineManager().getPipeline().ifPresent(pipeline -> pipeline.addDebugText(messages));
 	}
 
 	// stackoverflow.com/a/3758880

File: src/main/java/net/coderbot/iris/mixin/MixinGameRenderer.java
Patch:
@@ -40,7 +40,7 @@ public class MixinGameRenderer {
 
 	@Redirect(method = "renderItemInHand", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/renderer/ItemInHandRenderer;renderHandsWithItems(FLcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/client/renderer/MultiBufferSource$BufferSource;Lnet/minecraft/client/player/LocalPlayer;I)V"))
 	private void disableVanillaHandRendering(ItemInHandRenderer itemInHandRenderer, float tickDelta, PoseStack poseStack, BufferSource bufferSource, LocalPlayer localPlayer, int light) {
-		if (!(Iris.getPipelineManager().getPipeline() instanceof FixedFunctionWorldRenderingPipeline)) {
+		if (!(Iris.getPipelineManager().getPipelineNullable() instanceof FixedFunctionWorldRenderingPipeline)) {
 			return;
 		}
 

File: src/main/java/net/coderbot/iris/mixin/MixinItemInHandRenderer.java
Patch:
@@ -18,7 +18,7 @@
 public class MixinItemInHandRenderer {
 	@Inject(method = "renderArmWithItem", at = @At("HEAD"), cancellable = true)
 	private void skipTranslucentHands(AbstractClientPlayer abstractClientPlayer, float f, float g, InteractionHand interactionHand, float h, ItemStack itemStack, float i, PoseStack poseStack, MultiBufferSource multiBufferSource, int j, CallbackInfo ci) {
-		if (!(Iris.getPipelineManager().getPipeline() instanceof FixedFunctionWorldRenderingPipeline)) {
+		if (!(Iris.getPipelineManager().getPipelineNullable() instanceof FixedFunctionWorldRenderingPipeline)) {
 			if (HandRenderer.INSTANCE.isRenderingSolid() && HandRenderer.INSTANCE.isHandTranslucent(interactionHand)) {
 				ci.cancel();
 			} else if (!HandRenderer.INSTANCE.isRenderingSolid() && !HandRenderer.INSTANCE.isHandTranslucent(interactionHand)) {

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -277,7 +277,7 @@ public DeferredWorldRenderingPipeline(ProgramSet programs) {
 			this.shadowMapRenderer = new EmptyShadowMapRenderer(programs.getPackDirectives().getShadowDirectives().getResolution());
 		}
 
-		this.sodiumTerrainPipeline = new SodiumTerrainPipeline(programs, createTerrainSamplers, createShadowTerrainSamplers);
+		this.sodiumTerrainPipeline = new SodiumTerrainPipeline(this, programs, createTerrainSamplers, createShadowTerrainSamplers);
 	}
 
 	private void checkWorld() {

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/impl/shader_overrides/IrisChunkProgramOverrides.java
Patch:
@@ -159,7 +159,7 @@ private ChunkProgram createShader(RenderDevice device, IrisTerrainPass pass, Sod
     }
 
     public void createShaders(RenderDevice device) {
-        WorldRenderingPipeline worldRenderingPipeline = Iris.getPipelineManager().getPipeline();
+        WorldRenderingPipeline worldRenderingPipeline = Iris.getPipelineManager().getPipelineNullable();
         SodiumTerrainPipeline sodiumTerrainPipeline = null;
 
         if (worldRenderingPipeline != null) {

File: src/main/java/net/coderbot/iris/mixin/MixinBufferSource_WrapperChecking.java
Patch:
@@ -14,15 +14,15 @@
 import org.spongepowered.asm.mixin.Unique;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
-import org.spongepowered.asm.mixin.injection.ModifyArg;
+import org.spongepowered.asm.mixin.injection.ModifyVariable;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
 @Mixin(MultiBufferSource.BufferSource.class)
 public class MixinBufferSource_WrapperChecking {
 	@Unique
 	private final Set<String> unwrapped = new ObjectOpenHashSet<>();
 
-	@ModifyArg(method = "getBuffer", at = @At("HEAD"))
+	@ModifyVariable(method = "getBuffer", at = @At("HEAD"))
 	private RenderType unwrapBufferIfNeeded(RenderType renderType) {
 		// Ensure that entity color wrapped render layers do not take effect when entity batching is inoperable.
 		if (renderType instanceof InnerWrappedRenderType) {

File: src/main/java/net/coderbot/iris/shaderpack/ProgramDirectives.java
Patch:
@@ -108,6 +108,7 @@ public Optional<AlphaTestOverride> getAlphaTestOverride() {
 		return Optional.ofNullable(alphaTestOverride);
 	}
 
+	@Nullable
 	public BlendModeOverride getBlendModeOverride() {
 		return blendModeOverride;
 	}

File: src/main/java/net/coderbot/iris/postprocess/FinalPassRenderer.java
Patch:
@@ -77,7 +77,7 @@ public FinalPassRenderer(ProgramSet pack, RenderTargets renderTargets, IntSuppli
 
 		IntList buffersToBeCleared = pack.getPackDirectives().getRenderTargetDirectives().getBuffersToBeCleared();
 
-		this.baseline = renderTargets.createFramebufferWritingToMain(new int[] {0});
+		this.baseline = renderTargets.createGbufferFramebuffer(flippedBuffers, new int[] {0});
 
 		// TODO: We don't actually fully swap the content, we merely copy it from alt to main
 		// This works for the most part, but it's not perfect. A better approach would be creating secondary

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/options/MixinSodiumGameOptions.java
Patch:
@@ -18,7 +18,9 @@ public class MixinSodiumGameOptions {
     @Inject(method = "writeChanges()V", at = @At("RETURN"), remap = false)
     public void iris$writeIrisConfig(CallbackInfo ci) {
         try {
-            Iris.getIrisConfig().save();
+        	if (Iris.getIrisConfig() != null) {
+				Iris.getIrisConfig().save();
+			}
         } catch (IOException e) {
             e.printStackTrace();
         }

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -547,6 +547,9 @@ public void use() {
 
 			if (blendModeOverride != null) {
 				blendModeOverride.apply();
+			} else {
+				// Previous program on the stack might have applied an override
+				BlendModeOverride.restore();
 			}
 		}
 

File: src/main/java/net/coderbot/batchedentityrendering/mixin/MixinLevelRenderer_EntityListSorting.java
Patch:
@@ -39,7 +39,7 @@ public class MixinLevelRenderer_EntityListSorting {
 
 	@ModifyVariable(method = "renderLevel", at = @At(value = "INVOKE_ASSIGN", target = "Ljava/lang/Iterable;iterator()Ljava/util/Iterator;"),
 			slice = @Slice(from = @At(value = "INVOKE", target = "Lnet/minecraft/client/renderer/RenderBuffers;bufferSource()Lnet/minecraft/client/renderer/MultiBufferSource$BufferSource;"),
-					to = @At(value = "FIELD", target = "net/minecraft/client/renderer/entity/EntityRenderDispatcher.shouldRender (Lnet/minecraft/world/entity/Entity;Lnet/minecraft/client/renderer/culling/Frustum;DDD)Z")), allow = 1)
+					to = @At(value = "INVOKE", target = "Lnet/minecraft/client/renderer/entity/EntityRenderDispatcher;shouldRender(Lnet/minecraft/world/entity/Entity;Lnet/minecraft/client/renderer/culling/Frustum;DDD)Z")), allow = 1)
     private Iterator<Entity> batchedentityrendering$sortEntityList(Iterator<Entity> iterator) {
         // Sort the entity list first in order to allow vanilla's entity batching code to work better.
         this.level.getProfiler().push("sortEntityList");

File: src/main/java/net/coderbot/iris/shaderpack/ShaderPack.java
Patch:
@@ -144,7 +144,7 @@ private static ProgramSet loadOverrides(boolean has, AbsolutePackPath path, Func
 
 	// TODO: Copy-paste from IdMap, find a way to deduplicate this
 	private static Optional<Properties> loadProperties(Path shaderPath, String name) {
-		Properties properties = new Properties();
+		Properties properties = new OrderBackedProperties();
 
 		try {
 			// NB: shaders.properties is specified to be encoded with ISO-8859-1 by OptiFine,

File: src/main/java/net/coderbot/iris/mixin/MixinGlStateManager_BlendOverride.java
Patch:
@@ -10,21 +10,21 @@
 @Mixin(GlStateManager.class)
 public class MixinGlStateManager_BlendOverride {
 	@Inject(method = {"_disableBlend", "_enableBlend"}, at = @At("HEAD"), cancellable = true)
-	private static void blendToggleLock(CallbackInfo ci) {
+	private static void iris$blendToggleLock(CallbackInfo ci) {
 		if(BlendModeStorage.isBlendLocked()) {
 			ci.cancel();
 		}
 	}
 
 	@Inject(method = "_blendFunc", at = @At("HEAD"), cancellable = true)
-	private static void blendFuncLock(int i, int j, CallbackInfo ci) {
+	private static void iris$blendFuncLock(int i, int j, CallbackInfo ci) {
 		if(BlendModeStorage.isBlendLocked()) {
 			ci.cancel();
 		}
 	}
 
 	@Inject(method = "_blendFuncSeparate", at = @At("HEAD"), cancellable = true)
-	private static void blendFuncSeparateLock(int i, int j, int k, int l, CallbackInfo ci) {
+	private static void iris$blendFuncSeparateLock(int i, int j, int k, int l, CallbackInfo ci) {
 		if(BlendModeStorage.isBlendLocked()) {
 			ci.cancel();
 		}

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -246,7 +246,7 @@ private static boolean loadExternalShaderpack(String name) {
 
 		Map<String, String> changedConfigs = loadConfigProperties(shaderPackConfigTxt)
 				.map(properties -> (Map<String, String>) (Map) properties)
-				.orElse(Collections.emptyMap());
+				.orElse(new HashMap<>());
 
 		changedConfigs.putAll(pendingShaderPackOptions);
 		clearPendingShaderPackOptions();

File: src/main/java/net/coderbot/iris/gui/element/widget/BooleanElementWidget.java
Patch:
@@ -25,6 +25,8 @@ public BooleanElementWidget(BooleanOption option, boolean value) {
 
 	@Override
 	public void render(PoseStack poseStack, int x, int y, int width, int height, int mouseX, int mouseY, float tickDelta, boolean hovered) {
+		this.updateRenderParams(width, VALUE_SECTION_WIDTH);
+
 		this.renderOptionWithValue(poseStack, x, y, width, height, hovered);
 		this.renderTooltipIfTrimmed(poseStack, mouseX, mouseY, hovered);
 	}

File: src/main/java/net/coderbot/iris/gui/element/widget/SliderElementWidget.java
Patch:
@@ -40,6 +40,8 @@ public SliderElementWidget(StringOption option, String value) {
 
 	@Override
 	public void render(PoseStack poseStack, int x, int y, int width, int height, int mouseX, int mouseY, float tickDelta, boolean hovered) {
+		this.updateRenderParams(width, VALUE_SECTION_WIDTH + 15);
+
 		if (!hovered) {
 			this.renderOptionWithValue(poseStack, x, y, width, height, false, (float)valueIndex / (valueCount - 1), PREVIEW_SLIDER_WIDTH);
 		} else {

File: src/main/java/net/coderbot/iris/gui/element/widget/StringElementWidget.java
Patch:
@@ -33,6 +33,8 @@ public StringElementWidget(StringOption option, String value) {
 
 	@Override
 	public void render(PoseStack poseStack, int x, int y, int width, int height, int mouseX, int mouseY, float tickDelta, boolean hovered) {
+		this.updateRenderParams(width, VALUE_SECTION_WIDTH);
+
 		this.renderOptionWithValue(poseStack, x, y, width, height, hovered);
 		this.renderTooltipIfTrimmed(poseStack, mouseX, mouseY, hovered);
 	}

File: src/main/java/net/coderbot/iris/gui/element/widget/StringElementWidget.java
Patch:
@@ -45,6 +45,9 @@ private void increment(int amount) {
 		if (this.valueIndex >= this.valueCount) {
 			this.valueIndex = 0;
 		}
+		if (this.valueIndex < 0) {
+			this.valueIndex = this.valueCount - 1;
+		}
 	}
 
 	@Override

File: src/main/java/net/coderbot/iris/shaderpack/option/menu/OptionMenuScreen.java
Patch:
@@ -32,7 +32,7 @@ public OptionMenuScreen(Component heading, OptionMenuContainer container, Shader
 			} catch (IllegalArgumentException error) {
 				Iris.logger.error(error);
 
-				this.elements.add(OptionMenuElement.ERROR);
+				this.elements.add(OptionMenuElement.EMPTY);
 			}
 		}
 	}

File: src/main/java/net/coderbot/iris/mixin/MixinGameRenderer.java
Patch:
@@ -4,6 +4,7 @@
 
 import net.coderbot.iris.Iris;
 
+import net.coderbot.iris.pipeline.FixedFunctionWorldRenderingPipeline;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.injection.At;
@@ -35,6 +36,6 @@ public class MixinGameRenderer {
 
 	@Redirect(method = "renderLevel", at = @At(value = "FIELD", target = "Lnet/minecraft/client/renderer/GameRenderer;renderHand:Z"))
 	private boolean disableVanillaHandRendering(GameRenderer gameRenderer) {
-		return !Iris.getCurrentPack().isPresent() && renderHand;
+		return Iris.getPipelineManager().getPipeline() instanceof FixedFunctionWorldRenderingPipeline && renderHand;
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/MixinItemInHandRenderer.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.mojang.blaze3d.vertex.PoseStack;
 import net.coderbot.iris.Iris;
+import net.coderbot.iris.pipeline.FixedFunctionWorldRenderingPipeline;
 import net.coderbot.iris.pipeline.HandRenderer;
 import net.minecraft.client.player.AbstractClientPlayer;
 import net.minecraft.client.renderer.ItemInHandRenderer;
@@ -17,7 +18,7 @@
 public class MixinItemInHandRenderer {
 	@Inject(method = "renderArmWithItem", at = @At("HEAD"), cancellable = true)
 	private void skipTranslucentHands(AbstractClientPlayer abstractClientPlayer, float f, float g, InteractionHand interactionHand, float h, ItemStack itemStack, float i, PoseStack poseStack, MultiBufferSource multiBufferSource, int j, CallbackInfo ci) {
-		if (Iris.getCurrentPack().isPresent()) {
+		if (!(Iris.getPipelineManager().getPipeline() instanceof FixedFunctionWorldRenderingPipeline)) {
 			if (HandRenderer.INSTANCE.isRenderingSolid() && HandRenderer.INSTANCE.isHandTranslucent(interactionHand)) {
 				ci.cancel();
 			} else if (!HandRenderer.INSTANCE.isRenderingSolid() && !HandRenderer.INSTANCE.isHandTranslucent(interactionHand)) {

File: src/main/java/net/coderbot/iris/pipeline/SodiumTerrainPipeline.java
Patch:
@@ -63,8 +63,6 @@ public SodiumTerrainPipeline(ProgramSet programSet, IntFunction<ProgramSamplers>
 		translucentSource.ifPresent(sources -> translucentFramebuffer = targets.createGbufferFramebuffer(flippedAfterTranslucent,
 				sources.getDirectives().getDrawBuffers()));
 
-
-
 		this.createTerrainSamplers = createTerrainSamplers;
 		this.createShadowSamplers = createShadowSamplers;
 	}

File: src/main/java/net/coderbot/iris/pipeline/newshader/TriforceSodiumPatcher.java
Patch:
@@ -154,6 +154,9 @@ public static String patch(String source, ShaderType type, AlphaTest alpha, Shad
 
 			transformations.injectLine(Transformations.InjectionPoint.BEFORE_CODE, "vec4 getVertexPosition() { return vec4(_draw_translation + _vert_position, 1.0); }");
 			transformations.injectLine(Transformations.InjectionPoint.BEFORE_CODE, "vec4 ftransform() { return gl_ModelViewProjectionMatrix * gl_Vertex; }");
+		} else {
+			transformations.injectLine(Transformations.InjectionPoint.BEFORE_CODE, "uniform mat4 u_ModelViewMatrix;");
+			transformations.injectLine(Transformations.InjectionPoint.BEFORE_CODE, "uniform mat4 u_ProjectionMatrix;");
 		}
 
 		if (type == ShaderType.VERTEX) {

File: src/main/java/net/coderbot/iris/gl/program/ProgramBuilder.java
Patch:
@@ -20,8 +20,6 @@ public class ProgramBuilder extends ProgramUniforms.Builder implements SamplerHo
 	public static final ShaderConstants MACRO_CONSTANTS = ShaderConstants.builder()
 		.define(StandardMacros.getOsString())
 		.define("MC_VERSION", StandardMacros.getMcVersion())
-		.define("MC_RENDER_QUALITY", "1.0")
-		.define("MC_SHADOW_QUALITY", "1.0")
 		.define("MC_GL_VERSION", StandardMacros.getGlVersion(GL20C.GL_VERSION))
 		.define("MC_GLSL_VERSION", StandardMacros.getGlVersion(GL20C.GL_SHADING_LANGUAGE_VERSION))
 		.define(StandardMacros.getRenderer())

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/options/MixinSodiumGameOptionPages.java
Patch:
@@ -28,7 +28,7 @@ public class MixinSodiumGameOptionPages {
     @Redirect(method = "general", remap = false,
             slice = @Slice(
                     from = @At(value = "CONSTANT", args = "stringValue=options.renderDistance"),
-                    to = @At(value = "CONSTANT", args = "stringValue=options.gamma")
+                    to = @At(value = "CONSTANT", args = "stringValue=options.simulationDistance")
             ),
             at = @At(value = "INVOKE", remap = false,
                     target = "me/jellysquid/mods/sodium/client/gui/options/OptionGroup$Builder.add (" +

File: src/main/java/net/coderbot/iris/gui/screen/ShaderPackScreen.java
Patch:
@@ -47,15 +47,15 @@ public void render(PoseStack poseStack, int mouseX, int mouseY, float delta) {
 
 		this.shaderPackList.render(poseStack, mouseX, mouseY, delta);
 
+		super.render(poseStack, mouseX, mouseY, delta);
+
 		drawCenteredString(poseStack, this.font, this.title, (int)(this.width * 0.5), 8, 0xFFFFFF);
 
 		if (addedPackDialog != null && addedPackDialogTimer > 0) {
 			drawCenteredString(poseStack, this.font, addedPackDialog, (int)(this.width * 0.5), 21, 0xFFFFFF);
 		} else {
 			drawCenteredString(poseStack, this.font, SELECT_TITLE, (int)(this.width * 0.5), 21, 0xFFFFFF);
 		}
-
-		super.render(poseStack, mouseX, mouseY, delta);
 	}
 
 	@Override

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/shader_overrides/MixinBlockRenderPass.java
Patch:
@@ -19,7 +19,7 @@ public class MixinBlockRenderPass {
 
     @Inject(method = "<init>", at = @At("RETURN"))
 	public void changeAlphaCutoff(String layer, int ordinal, RenderType renderType, boolean translucent, float alphaCutoff, CallbackInfo ci) {
-		if (alphaCutoff == 0.5F) {
+		if (renderType == RenderType.cutoutMipped()) {
 			this.alphaCutoff = 0.1F;
 		}
 	}

File: src/main/java/net/coderbot/iris/mixin/MixinDebugScreenOverlay.java
Patch:
@@ -63,7 +63,8 @@ private void appendShadowDebugText(CallbackInfoReturnable<List<String>> cir) {
 		List<String> messages = cir.getReturnValue();
 
 		if (!Iris.isSodiumInstalled() && Iris.getCurrentPack().isPresent()) {
-			messages.add(1, ChatFormatting.YELLOW + "[Iris] You are running an experimental version of Iris without Sodium; expect poor performance.");
+			messages.add(1, ChatFormatting.YELLOW + "[Iris] Sodium isn't installed; you will have poor performance.");
+			messages.add(2, ChatFormatting.YELLOW + "[Iris] Install Sodium if you want to run benchmarks or get higher FPS!");
 		}
 
 		Iris.getPipelineManager().getPipeline().addDebugText(messages);

File: src/main/java/net/coderbot/iris/mixin/MixinLevelRenderer.java
Patch:
@@ -59,7 +59,7 @@ public class MixinLevelRenderer {
 	// At this point we've ensured that Minecraft's main framebuffer is cleared.
 	// This is important or else very odd issues will happen with shaders that have a final pass that doesn't write to
 	// all pixels.
-	@Inject(method = "renderLevel", at = @At(value = "INVOKE", target = CLEAR, shift = At.Shift.AFTER))
+	@Inject(method = "renderLevel", at = @At(value = "INVOKE", target = CLEAR, shift = At.Shift.AFTER, remap = false))
 	private void iris$beginLevelRender(PoseStack poseStack, float tickDelta, long startTime, boolean renderBlockOutline,
 	                                   Camera camera, GameRenderer gameRenderer, LightTexture lightTexture,
 									   Matrix4f projection, CallbackInfo callback) {

File: src/main/java/net/coderbot/iris/mixin/gui/MixinGui.java
Patch:
@@ -43,7 +43,8 @@ public class MixinGui {
 		Font font = Minecraft.getInstance().font;
 
 		List<String> warningLines = new ArrayList<>();
-		warningLines.add(ChatFormatting.YELLOW + "[Iris] You are running an experimental version of Iris without Sodium; expect poor performance.");
+		warningLines.add("[Iris] Sodium isn't installed; you will have poor performance.");
+		warningLines.add("[Iris] Install Sodium if you want to run benchmarks or get higher FPS!");
 
 		for (int i = 0; i < warningLines.size(); ++i) {
 			String string = warningLines.get(i);

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -35,7 +35,8 @@ public class Iris implements ClientModInitializer {
 	public static final String MODID = "iris";
 	public static final Logger logger = LogManager.getLogger(MODID);
 	// The recommended version of Sodium for use with Iris
-	private static final String SODIUM_VERSION = "0.2.0+build.4";
+	private static final String SODIUM_VERSION = "0.2.0";
+	public static final String SODIUM_DOWNLOAD_LINK = "https://www.curseforge.com/minecraft/mc-mods/sodium/files/3488820";
 
 	private static Path shaderpacksDirectory;
 

File: src/main/java/net/coderbot/iris/mixin/MixinLevelRenderer.java
Patch:
@@ -59,7 +59,7 @@ public class MixinLevelRenderer {
 	// At this point we've ensured that Minecraft's main framebuffer is cleared.
 	// This is important or else very odd issues will happen with shaders that have a final pass that doesn't write to
 	// all pixels.
-	@Inject(method = "renderLevel", at = @At(value = "INVOKE", target = CLEAR, shift = At.Shift.AFTER))
+	@Inject(method = "renderLevel", at = @At(value = "INVOKE", target = CLEAR, shift = At.Shift.AFTER, remap = false))
 	private void iris$beginLevelRender(PoseStack poseStack, float tickDelta, long startTime, boolean renderBlockOutline,
 	                                   Camera camera, GameRenderer gameRenderer, LightTexture lightTexture,
 									   Matrix4f projection, CallbackInfo callback) {

File: src/main/java/net/coderbot/iris/mixin/MixinGameRenderer.java
Patch:
@@ -32,6 +32,6 @@ public class MixinGameRenderer {
 
 	@Redirect(method = "renderLevel", at = @At(value = "FIELD", target = "Lnet/minecraft/client/renderer/GameRenderer;renderHand:Z"))
 	private boolean disableVanillaHandRendering(GameRenderer gameRenderer) {
-		return Iris.getPipelineManager().getPipeline() instanceof FixedFunctionWorldRenderingPipeline;
+		return !Iris.getCurrentPack().isPresent();
 	}
 }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/block_id/MixinChunkRenderRebuildTask.java
Patch:
@@ -49,9 +49,9 @@ public class MixinChunkRenderRebuildTask {
     }
 
     @Inject(method = "performBuild",
-            at = @At(value = "INVOKE", target = "net/minecraft/world/level/block/Block.isEntityBlock()Z"))
+            at = @At(value = "INVOKE", target = "net/minecraft/world/level/block/state/BlockState.hasBlockEntity ()Z"))
     private void iris$resetId(ChunkRenderCacheLocal cache, ChunkBuildBuffers buffers,
-                              CancellationSource cancellationSource, CallbackInfoReturnable<ChunkBuildResult<?>> cir) {
+                              CancellationSource cancellationSource, CallbackInfoReturnable<ChunkBuildResult> cir) {
         if (buffers instanceof ChunkBuildBuffersExt) {
             ((ChunkBuildBuffersExt) buffers).iris$resetMaterialId();
         }

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/options/MixinRenderSectionManager.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.iris.compat.sodium.mixin.options;
 
 import me.jellysquid.mods.sodium.client.gui.SodiumGameOptions;
-import me.jellysquid.mods.sodium.client.render.chunk.ChunkRenderManager;
+import me.jellysquid.mods.sodium.client.render.chunk.RenderSectionManager;
 import net.coderbot.iris.Iris;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
@@ -10,8 +10,8 @@
 /**
  * Disables fog occlusion when a shader pack is enabled, since shaders are not guaranteed to actually implement fog.
  */
-@Mixin(ChunkRenderManager.class)
-public class MixinChunkRenderManager {
+@Mixin(RenderSectionManager.class)
+public class MixinRenderSectionManager {
     @Redirect(method = "setup", remap = false,
             at = @At(value = "FIELD",
                     target = "me/jellysquid/mods/sodium/client/gui/SodiumGameOptions$AdvancedSettings.useFogOcclusion : Z",

File: src/sodiumCompatibility/java/net/coderbot/iris/compat/sodium/mixin/options/MixinSodiumOptionsGUI.java
Patch:
@@ -36,7 +36,7 @@ protected MixinSodiumOptionsGUI(Component title) {
 
     @Inject(method = "<init>", at = @At("RETURN"))
     private void iris$onInit(Screen prevScreen, CallbackInfo ci) {
-        String shaderPacksTranslated = new TranslatableComponent("options.iris.shaderPackSelection").getString();
+        TranslatableComponent shaderPacksTranslated = new TranslatableComponent("options.iris.shaderPackSelection");
         shaderPacks = new OptionPage(shaderPacksTranslated, ImmutableList.of());
         pages.add(shaderPacks);
     }

File: src/main/java/net/coderbot/iris/layer/GbufferProgram.java
Patch:
@@ -14,7 +14,6 @@ public enum GbufferProgram {
 	BLOCK_ENTITIES,
 	BEACON_BEAM,
 	ENTITIES,
-	ENTITIES_TRANSLUCENT,
 	ENTITIES_GLOWING,
 	ARMOR_GLINT,
 	EYES,

File: src/main/java/net/coderbot/iris/layer/GbufferPrograms.java
Patch:
@@ -12,9 +12,9 @@ public class GbufferPrograms {
 	 * Uses additional information to choose a more specific (and appropriate) GbufferProgram.
 	 */
 	private static GbufferProgram refine(GbufferProgram program) {
-		if (program == GbufferProgram.ENTITIES || program == GbufferProgram.ENTITIES_TRANSLUCENT || program == GbufferProgram.TERRAIN || program == GbufferProgram.TRANSLUCENT_TERRAIN) {
+		if (program == GbufferProgram.ENTITIES || program == GbufferProgram.TERRAIN || program == GbufferProgram.TRANSLUCENT_TERRAIN) {
 			if (HandRenderer.INSTANCE.isActive()) {
-				return program == GbufferProgram.ENTITIES_TRANSLUCENT ? GbufferProgram.HAND_TRANSLUCENT : GbufferProgram.HAND;
+				return HandRenderer.INSTANCE.isRenderingSolid() ? GbufferProgram.HAND : GbufferProgram.HAND_TRANSLUCENT;
 			} else if (entities) {
 				return GbufferProgram.ENTITIES;
 			} else if (blockEntities) {

File: src/main/java/net/coderbot/iris/mixin/MixinItemInHandRenderer.java
Patch:
@@ -18,6 +18,8 @@ public class MixinItemInHandRenderer {
 	private void skipTranslucentHands(AbstractClientPlayer abstractClientPlayer, float f, float g, InteractionHand interactionHand, float h, ItemStack itemStack, float i, PoseStack poseStack, MultiBufferSource multiBufferSource, int j, CallbackInfo ci) {
 		if (HandRenderer.INSTANCE.isRenderingSolid() && HandRenderer.INSTANCE.isHandTranslucent(interactionHand)) {
 			ci.cancel();
+		} else if (!HandRenderer.INSTANCE.isRenderingSolid() && !HandRenderer.INSTANCE.isHandTranslucent(interactionHand)) {
+			ci.cancel();
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -370,8 +370,6 @@ private Pass getPass(GbufferProgram program) {
 				return beaconBeam;
 			case ENTITIES:
 				return entities;
-			case ENTITIES_TRANSLUCENT:
-				return entities;
 			case BLOCK_ENTITIES:
 				return blockEntities;
 			case ENTITIES_GLOWING:

File: src/main/java/net/coderbot/iris/layer/GbufferPrograms.java
Patch:
@@ -11,7 +11,7 @@ public class GbufferPrograms {
 	/**
 	 * Uses additional information to choose a more specific (and appropriate) GbufferProgram.
 	 */
-	private static GbufferProgram refine(GbufferProgram program) {
+	public static GbufferProgram refine(GbufferProgram program) {
 		if (program == GbufferProgram.ENTITIES || program == GbufferProgram.TERRAIN || program == GbufferProgram.TRANSLUCENT_TERRAIN) {
 			if (HandRenderer.isActive()) {
 				return GbufferProgram.HAND;

File: src/main/java/net/coderbot/iris/mixin/GameRendererAccessor.java
Patch:
@@ -18,4 +18,7 @@ public interface GameRendererAccessor {
 
 	@Invoker
 	void invokeBobView(PoseStack poseStack, float tickDelta);
+
+	@Invoker
+	void invokeBobHurt(PoseStack poseStack, float tickDelta);
 }

File: src/main/java/net/coderbot/iris/mixin/MixinItemInHandRenderer.java
Patch:
@@ -16,7 +16,7 @@
 public class MixinItemInHandRenderer {
 	@Inject(method = "renderArmWithItem", at = @At("HEAD"), cancellable = true)
 	private void skipTranslucentHands(AbstractClientPlayer abstractClientPlayer, float f, float g, InteractionHand interactionHand, float h, ItemStack itemStack, float i, PoseStack poseStack, MultiBufferSource multiBufferSource, int j, CallbackInfo ci) {
-		if (HandRenderer.renderingSolid && HandRenderer.INSTANCE.isHandTranslucent(interactionHand)) {
+		if (HandRenderer.isRenderingSolid() && HandRenderer.INSTANCE.isHandTranslucent(interactionHand)) {
 			ci.cancel();
 		}
 	}

File: src/main/java/net/coderbot/iris/mixin/MixinLevelRenderer.java
Patch:
@@ -83,7 +83,7 @@ public class MixinLevelRenderer {
 	// render their waypoint beams.
 	@Inject(method = RENDER_LEVEL, at = @At(value = "RETURN", shift = At.Shift.BEFORE))
 	private void iris$endLevelRender(PoseStack poseStack, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightTexture lightTexture, Matrix4f projection, CallbackInfo callback) {
-		HandRenderer.INSTANCE.renderTranslucent(renderBuffers, poseStack, tickDelta, camera, gameRenderer, pipeline);
+		HandRenderer.INSTANCE.renderTranslucent(poseStack, tickDelta, camera, gameRenderer, pipeline);
 		Minecraft.getInstance().getProfiler().popPush("iris_final");
 		pipeline.finalizeLevelRendering();
 		pipeline = null;
@@ -219,7 +219,7 @@ public class MixinLevelRenderer {
 										LightTexture lightTexture, Matrix4f projection,
 										CallbackInfo ci) {
 		pipeline.beginHand();
-		HandRenderer.INSTANCE.renderSolid(renderBuffers, poseStack, tickDelta, camera, gameRenderer, pipeline);
+		HandRenderer.INSTANCE.renderSolid(poseStack, tickDelta, camera, gameRenderer, pipeline);
 		Minecraft.getInstance().getProfiler().popPush("iris_pre_translucent");
 		pipeline.beginTranslucents();
 	}

File: src/main/java/net/coderbot/iris/shaderpack/ShaderProperties.java
Patch:
@@ -163,9 +163,6 @@ public ShaderProperties(Properties properties) {
 			});
 
 			handleTwoArgDirective("texture.", key, value, (stageName, samplerName) -> {
-				// TODO: Remove
-				System.out.println("Processing custom texture property: " + "Stage: " + stageName + " Sampler: " + samplerName + " Path: " + value);
-
 				String[] parts = value.split(" ");
 
 				// TODO: Support raw textures

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -246,7 +246,8 @@ public DeferredWorldRenderingPipeline(ProgramSet programs) {
 				programs.getPackDirectives().getExplicitFlips("composite_pre"));
 		this.finalPassRenderer = new FinalPassRenderer(programs, renderTargets, noise, updateNotifier, flipper.snapshot(),
 				centerDepthSampler, shadowMapRendererSupplier,
-				customTextureIdMap.getOrDefault(TextureStage.COMPOSITE_AND_FINAL, new Object2ObjectOpenHashMap<>()));
+				customTextureIdMap.getOrDefault(TextureStage.COMPOSITE_AND_FINAL, new Object2ObjectOpenHashMap<>()),
+				this.compositeRenderer.getFlippedAtLeastOnceFinal());
 
 		Supplier<ImmutableSet<Integer>> flipped =
 				() -> isBeforeTranslucent ? flippedBeforeTranslucent : flippedAfterTranslucent;

File: src/main/java/net/coderbot/iris/mixin/MixinShaderInstance.java
Patch:
@@ -15,6 +15,8 @@
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 import org.spongepowered.asm.mixin.injection.callback.LocalCapture;
 
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Objects;
 
 @Mixin(ShaderInstance.class)
@@ -98,7 +100,7 @@ public class MixinShaderInstance {
 
 	@Redirect(method = "<init>", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/shaders/Uniform;glBindAttribLocation(IILjava/lang/CharSequence;)V"))
 	public void redirectBindAttributeLocation(int i, int j, CharSequence charSequence) {
-		if (((Object) this) instanceof ExtendedShader) {
+		if (((Object) this) instanceof ExtendedShader && Arrays.asList("Position", "Color", "Normal", "UV0", "UV1", "UV2").contains(charSequence)) {
 			Uniform.glBindAttribLocation(i, j, "va" + charSequence);
 		} else {
 			Uniform.glBindAttribLocation(i, j, charSequence);

File: src/main/java/net/coderbot/iris/mixin/entity_render_context/MixinEntityRenderDispatcher.java
Patch:
@@ -5,7 +5,6 @@
 import net.coderbot.iris.fantastic.WrappingMultiBufferSource;
 import net.coderbot.iris.layer.EntityRenderStateShard;
 import net.coderbot.iris.layer.OuterWrappedRenderType;
-import net.coderbot.iris.pipeline.HandRenderer;
 import net.coderbot.iris.shaderpack.IdMap;
 import net.minecraft.client.renderer.MultiBufferSource;
 import net.minecraft.client.renderer.RenderStateShard;
@@ -34,7 +33,7 @@ public class MixinEntityRenderDispatcher {
 	private void iris$beginEntityRender(Entity entity, double x, double y, double z, float yaw, float tickDelta,
 										PoseStack poseStack, MultiBufferSource bufferSource, int light,
 										CallbackInfo ci) {
-		if (!(bufferSource instanceof WrappingMultiBufferSource) || HandRenderer.isActive()) {
+		if (!(bufferSource instanceof WrappingMultiBufferSource)) {
 			return;
 		}
 
@@ -59,7 +58,7 @@ public class MixinEntityRenderDispatcher {
 	private void iris$endEntityRender(Entity entity, double x, double y, double z, float yaw, float tickDelta,
 									  PoseStack poseStack, MultiBufferSource bufferSource, int light,
 									  CallbackInfo ci) {
-		if (!(bufferSource instanceof WrappingMultiBufferSource) || HandRenderer.isActive()) {
+		if (!(bufferSource instanceof WrappingMultiBufferSource)) {
 			return;
 		}
 

File: src/main/java/net/coderbot/iris/mixin/entity_render_context/MixinEntityRenderDispatcher.java
Patch:
@@ -5,6 +5,7 @@
 import net.coderbot.iris.fantastic.WrappingMultiBufferSource;
 import net.coderbot.iris.layer.EntityRenderStateShard;
 import net.coderbot.iris.layer.OuterWrappedRenderType;
+import net.coderbot.iris.pipeline.HandRenderer;
 import net.coderbot.iris.shaderpack.IdMap;
 import net.minecraft.client.renderer.MultiBufferSource;
 import net.minecraft.client.renderer.RenderStateShard;
@@ -33,7 +34,7 @@ public class MixinEntityRenderDispatcher {
 	private void iris$beginEntityRender(Entity entity, double x, double y, double z, float yaw, float tickDelta,
 										PoseStack poseStack, MultiBufferSource bufferSource, int light,
 										CallbackInfo ci) {
-		if (!(bufferSource instanceof WrappingMultiBufferSource)) {
+		if (!(bufferSource instanceof WrappingMultiBufferSource) || HandRenderer.isActive()) {
 			return;
 		}
 
@@ -58,7 +59,7 @@ public class MixinEntityRenderDispatcher {
 	private void iris$endEntityRender(Entity entity, double x, double y, double z, float yaw, float tickDelta,
 									  PoseStack poseStack, MultiBufferSource bufferSource, int light,
 									  CallbackInfo ci) {
-		if (!(bufferSource instanceof WrappingMultiBufferSource)) {
+		if (!(bufferSource instanceof WrappingMultiBufferSource) || HandRenderer.isActive()) {
 			return;
 		}
 

File: src/main/java/net/coderbot/iris/mixin/rendertype/MixinRenderType.java
Patch:
@@ -152,7 +152,7 @@ private static RenderType wrap(RenderType wrapped, GbufferProgram program) {
 	private static void iris$wrapEntityRenderTypes(ResourceLocation texture, CallbackInfoReturnable<RenderType> cir) {
 		RenderType base = cir.getReturnValue();
 
-		if(HandRenderer.isActive()) {
+		if (HandRenderer.isActive()) {
 			cir.setReturnValue(wrap(base, GbufferProgram.HAND));
 		} else {
 			cir.setReturnValue(wrap(base, GbufferProgram.ENTITIES));

File: src/main/java/net/coderbot/iris/gl/IrisRenderSystem.java
Patch:
@@ -10,7 +10,7 @@
 import java.nio.IntBuffer;
 
 /**
- * This class is responsible for abstracting calls to OpenGL and asserting that calls are run on the render thread,
+ * This class is responsible for abstracting calls to OpenGL and asserting that calls are run on the render thread.
  */
 public class IrisRenderSystem {
 	public static void generateMipmaps(int mipmapTarget) {

File: src/main/java/kroppeb/stareval/resolver/ExpressionResolver.java
Patch:
@@ -253,7 +253,7 @@ public Expression partialEval(FunctionContext context, FunctionReturn functionRe
 				return new CallExpression(f, new Expression[]{castable});
 			}
 		}
-		this.log("[DEBUG] failed to resolved %s to type %s, even using implicit casts");
+		this.log("[DEBUG] failed to resolved %s to type %s, even using implicit casts", expression, targetType);
 		return null;
 	}
 

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -601,9 +601,6 @@ public void renderShadows(LevelRendererAccessor levelRenderer, Camera playerCame
 		RenderSystem.popMatrix();
 		RenderSystem.matrixMode(GL11.GL_MODELVIEW);
 
-		// program is the identifier for shadow :shrug:
-		this.customUniforms.push(shadowProgram);
-
 		pipeline.endShadowRender();
 		// Note: This unbinds the shadow framebuffer
 		pipeline.popProgram(GbufferProgram.NONE);
@@ -637,6 +634,9 @@ public void addDebugText(List<String> messages) {
 	private void setupShadowProgram() {
 		if (shadowProgram != null) {
 			shadowProgram.use();
+
+			// program is the identifier for shadow :shrug:
+			this.customUniforms.push(shadowProgram);
 			setupAttributes(shadowProgram);
 		} else {
 			ProgramManager.glUseProgram(0);

File: src/main/java/net/coderbot/iris/uniforms/BiomeParameters.java
Patch:
@@ -18,7 +18,7 @@
 public class BiomeParameters {
 	private static final Minecraft client = Minecraft.getInstance();
 	
-	public static void biomeParameters(UniformHolder uniforms) {
+	public static void addBiomeUniforms(UniformHolder uniforms) {
 		
 		uniforms
 				.uniform1i(PER_TICK, "biome", playerI(player ->

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -82,11 +82,12 @@ public static void addCommonUniforms(DynamicUniformHolder uniforms, IdMap idMap,
 		CommonUniforms.addDynamicUniforms(uniforms);
 	}
 
-	private static void addNonDynamicUniforms(UniformHolder uniforms, IdMap idMap, PackDirectives directives, FrameUpdateNotifier updateNotifier) {
+	public static void addNonDynamicUniforms(UniformHolder uniforms, IdMap idMap, PackDirectives directives, FrameUpdateNotifier updateNotifier) {
 		CameraUniforms.addCameraUniforms(uniforms, updateNotifier);
 		ViewportUniforms.addViewportUniforms(uniforms);
 		WorldTimeUniforms.addWorldTimeUniforms(uniforms);
 		SystemTimeUniforms.addSystemTimeUniforms(uniforms);
+		BiomeParameters.addBiomeUniforms(uniforms);
 		new CelestialUniforms(directives.getSunPathRotation()).addCelestialUniforms(uniforms);
 		IrisExclusiveUniforms.addIrisExclusiveUniforms(uniforms);
 		MatrixUniforms.addMatrixUniforms(uniforms, directives);

File: src/main/java/net/coderbot/iris/gui/element/ShaderPackSelectionList.java
Patch:
@@ -52,7 +52,7 @@ public void refresh() {
 		try {
 			this.addEntry(enableShadersButton);
 
-			Path path = Iris.SHADERPACKS_DIRECTORY;
+			Path path = Iris.getShaderpacksDirectory();
 			int index = 0;
 
 			for (String pack : BUILTIN_PACKS) {

File: src/main/java/net/coderbot/iris/gui/screen/ShaderPackScreen.java
Patch:
@@ -179,7 +179,7 @@ public void onFilesDrop(List<Path> paths) {
 	}
 
 	private static void copyShaderPack(Path pack, String name) throws IOException {
-		Path target = Iris.SHADERPACKS_DIRECTORY.resolve(name);
+		Path target = Iris.getShaderpacksDirectory().resolve(name);
 
 		// Copy the pack file into the shaderpacks folder.
 		Files.copy(pack, target);
@@ -254,6 +254,6 @@ private void applyChanges() {
 	}
 
 	private void openShaderPackFolder() {
-		Util.getPlatform().openFile(Iris.SHADERPACKS_DIRECTORY.toFile());
+		Util.getPlatform().openFile(Iris.getShaderpacksDirectory().toFile());
 	}
 }

File: src/main/java/net/coderbot/iris/layer/GbufferProgram.java
Patch:
@@ -2,7 +2,6 @@
 
 public enum GbufferProgram {
 	NONE,
-	CLEAR,
 	BASIC,
 	TEXTURED,
 	TEXTURED_LIT,

File: src/main/java/net/coderbot/iris/mixin/MixinClientLanguage.java
Patch:
@@ -6,6 +6,7 @@
 import java.util.Map;
 
 import net.coderbot.iris.Iris;
+import net.coderbot.iris.shaderpack.LanguageMap;
 import net.coderbot.iris.shaderpack.ShaderPack;
 import net.minecraft.client.resources.language.ClientLanguage;
 import net.minecraft.client.resources.language.LanguageInfo;
@@ -71,15 +72,15 @@ public class MixinClientLanguage {
 		//
 		// So we also check if the user is loading a special language, and if the shaderpack has support for that
 		// language. If they do, we load that, but if they do not, we load "en_us" instead.
-		Map<String, Map<String, String>> languageMap = pack.getLangMap();
+		LanguageMap languageMap = pack.getLanguageMap();
 
 		if (storage.containsKey(key)) {
 			// TODO: Should we allow shader packs to override existing MC translations?
 			return null;
 		}
 
 		for (String code : languageCodes) {
-			Map<String, String> translations = languageMap.get(code);
+			Map<String, String> translations = languageMap.getTranslations(code);
 
 			if (translations != null) {
 				String translation = translations.get(key);

File: src/main/java/net/coderbot/iris/postprocess/FinalPassRenderer.java
Patch:
@@ -90,7 +90,8 @@ public FinalPassRenderer(ProgramSet pack, RenderTargets renderTargets, AbstractT
 
 			SwapPass swap = new SwapPass();
 			swap.from = renderTargets.createFramebufferWritingToAlt(new int[] {target});
-			swap.from.readBuffer(target);
+			// NB: This is handled in RenderTargets now.
+			//swap.from.readBuffer(target);
 			swap.targetTexture = renderTargets.get(target).getMainTexture();
 
 			swapPasses.add(swap);
@@ -161,7 +162,7 @@ public void renderFinalPass() {
 
 		RenderSystem.activeTexture(GL15C.GL_TEXTURE0);
 
-		for (int i = 0; i < RenderTargets.MAX_RENDER_TARGETS; i++) {
+		for (int i = 0; i < renderTargets.getRenderTargetCount(); i++) {
 			// Reset mipmapping states at the end of the frame.
 			resetRenderTarget(renderTargets.get(i));
 		}

File: src/main/java/net/coderbot/iris/samplers/IrisSamplers.java
Patch:
@@ -36,7 +36,7 @@ public static void addRenderTargetSamplers(SamplerHolder samplers, Supplier<Immu
 		// Iris could lift this restriction, though I'm not sure if it could cause issues.
 		int startIndex = isFullscreenPass ? 0 : 4;
 
-		for (int i = startIndex; i < RenderTargets.MAX_RENDER_TARGETS; i++) {
+		for (int i = startIndex; i < renderTargets.getRenderTargetCount(); i++) {
 			final int index = i;
 
 			IntSupplier sampler = () -> {

File: src/main/java/net/coderbot/iris/shaderpack/IdMap.java
Patch:
@@ -30,6 +30,8 @@
 /**
  * A utility class for parsing entries in item.properties, block.properties, and entities.properties files in shaderpacks
  */
+// TODO: Don't reference vanilla Minecraft classes, so that the shaderpack loader can be properly isolated from
+//       Minecraft.
 public class IdMap {
 	/**
 	 * Maps a given item ID to an integer ID

File: src/main/java/net/coderbot/iris/shaderpack/LegacyIdMap.java
Patch:
@@ -5,6 +5,8 @@
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
 
+// TODO: Don't reference vanilla Minecraft classes, so that the shaderpack loader can be properly isolated from
+//       Minecraft.
 public class LegacyIdMap {
 
 	public static void addLegacyValues(Object2IntMap<BlockState> blockIdMap) {

File: src/main/java/net/coderbot/iris/shaderpack/PackDirectives.java
Patch:
@@ -110,9 +110,9 @@ public ImmutableMap<Integer, Boolean> getExplicitFlips(String pass) {
 		}
 
 		explicitFlipsStr.forEach((buffer, shouldFlip) -> {
-			Integer index = PackRenderTargetDirectives.LEGACY_RENDER_TARGET_MAP.get(buffer);
+			int index = PackRenderTargetDirectives.LEGACY_RENDER_TARGETS.indexOf(buffer);
 
-			if (index == null && buffer.startsWith("colortex")) {
+			if (index == -1 && buffer.startsWith("colortex")) {
 				String id = buffer.substring("colortex".length());
 
 				try {
@@ -122,7 +122,7 @@ public ImmutableMap<Integer, Boolean> getExplicitFlips(String pass) {
 				}
 			}
 
-			if (index != null) {
+			if (index != -1) {
 				explicitFlips.put(index, shouldFlip);
 			} else {
 				Iris.logger.warn("Unknown buffer with ID " + buffer + " specified in flip directive for pass "

File: src/main/java/net/coderbot/iris/shaderpack/ProgramSet.java
Patch:
@@ -49,7 +49,6 @@ public class ProgramSet {
 	private final ShaderPack pack;
 
 	public ProgramSet(Path root, Path inclusionRoot, ShaderProperties shaderProperties, ShaderPack pack) throws IOException {
-		// TODO: Support additional render targets beyond 8
 		this.packDirectives = new PackDirectives(PackRenderTargetDirectives.BASELINE_SUPPORTED_RENDER_TARGETS, shaderProperties);
 		this.pack = pack;
 
@@ -105,7 +104,6 @@ private ProgramSet(ProgramSet base, ProgramSet overrides) {
 			throw new IllegalStateException();
 		}
 
-		// TODO: Support additional render targets beyond 8
 		this.packDirectives = new PackDirectives(PackRenderTargetDirectives.BASELINE_SUPPORTED_RENDER_TARGETS, base.getPackDirectives());
 
 		this.shadow = merge(base.shadow, overrides.shadow);

File: src/main/java/net/coderbot/iris/mixin/MixinLevelRenderer.java
Patch:
@@ -102,6 +102,8 @@ public class MixinLevelRenderer {
 	@Inject(method = "renderLevel", at = @At(value = "INVOKE", target = RENDER_SKY))
 	private void iris$beginSky(PoseStack poseStack, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightTexture lightTexture, Matrix4f projection, CallbackInfo callback) {
 		pipeline.setPhase(WorldRenderingPhase.SKY);
+		// TODO: Move the injection instead
+		RenderSystem.setShader(GameRenderer::getPositionShader);
 
 	}
 

File: src/main/java/net/coderbot/iris/layer/GbufferProgram.java
Patch:
@@ -2,7 +2,6 @@
 
 public enum GbufferProgram {
 	NONE,
-	CLEAR,
 	BASIC,
 	TEXTURED,
 	TEXTURED_LIT,

File: src/main/java/net/coderbot/iris/shaderpack/PackRenderTargetDirectives.java
Patch:
@@ -118,7 +118,7 @@ public static final class RenderTargetSettings {
 		public RenderTargetSettings() {
 			this.requestedFormat = InternalTextureFormat.RGBA;
 			this.clear = true;
-			this.clearColor = new Vector4f(0.0f, 0.0f, 0.0f, 0.0f);
+			this.clearColor = null;
 		}
 
 		public InternalTextureFormat getRequestedFormat() {
@@ -129,8 +129,8 @@ public boolean shouldClear() {
 			return clear;
 		}
 
-		public Vector4f getClearColor() {
-			return clearColor;
+		public Optional<Vector4f> getClearColor() {
+			return Optional.ofNullable(clearColor);
 		}
 
 		@Override

File: src/main/java/net/coderbot/iris/pipeline/newshader/CoreWorldRenderingPipeline.java
Patch:
@@ -31,6 +31,7 @@ public interface CoreWorldRenderingPipeline extends WorldRenderingPipeline {
 	ShaderInstance getWeather();
 	ShaderInstance getCrumbling();
 	ShaderInstance getText();
+	ShaderInstance getTextIntensity();
 	ShaderInstance getBlock();
 	ShaderInstance getBeacon();
 	ShaderInstance getShadowTerrainCutout();

File: src/main/java/net/coderbot/iris/mixin/MixinGameRenderer.java
Patch:
@@ -4,6 +4,7 @@
 import com.mojang.blaze3d.platform.GlUtil;
 import com.mojang.math.Matrix4f;
 import net.coderbot.iris.Iris;
+import net.coderbot.iris.pipeline.HandRendering;
 import net.coderbot.iris.uniforms.CapturedRenderingState;
 import net.coderbot.iris.uniforms.SystemTimeUniforms;
 import org.lwjgl.opengl.GL20;
@@ -34,6 +35,8 @@ public class MixinGameRenderer {
 	// https://github.com/jellysquid3/sodium-fabric/blob/1df506fd39dac56bb410725c245e6e51208ec732/src/main/java/me/jellysquid/mods/sodium/client/render/chunk/shader/ChunkProgram.java#L56
 	@Inject(method = "resetProjectionMatrix", at = @At("HEAD"))
 	private void iris$captureProjectionMatrix(Matrix4f projectionMatrix, CallbackInfo callback) {
+		if(HandRendering.INSTANCE.isRendering()) return;
+
 		CapturedRenderingState.INSTANCE.setGbufferProjection(projectionMatrix);
 	}
 

File: src/main/java/net/coderbot/iris/pipeline/HandRendering.java
Patch:
@@ -28,7 +28,7 @@ public class HandRendering {
 	private boolean canRender;
 
 	public void prepareForRendering(RenderBuffers renderBuffers, PoseStack poseStack, float tickDelta, Camera camera, GameRenderer gameRenderer) {
-		this.canRender = !(camera.isDetached() || !(camera.getEntity() instanceof Player) || minecraft.options.hideGui || (camera.getEntity() instanceof LivingEntity && ((LivingEntity)camera.getEntity()).isSleeping()) || minecraft.gameMode.getPlayerMode() == GameType.SPECTATOR);
+		this.canRender = !(camera.isDetached() || !(camera.getEntity() instanceof Player) || ((GameRendererAccessor)gameRenderer).getPanoramicMode() | minecraft.options.hideGui || (camera.getEntity() instanceof LivingEntity && ((LivingEntity)camera.getEntity()).isSleeping()) || minecraft.gameMode.getPlayerMode() == GameType.SPECTATOR);
 
 		this.gameRenderer = gameRenderer;
 		this.renderBuffers = renderBuffers;

File: src/main/java/net/coderbot/iris/mixin/MixinLevelRenderer.java
Patch:
@@ -223,7 +223,7 @@ public class MixinLevelRenderer {
 		pipeline.beginTranslucents();
 	}
 
-	@Inject(method = "renderLevel", at = @At(value = "CONSTANT", args = "stringValue=translucent"))
+	@Inject(method = "renderLevel", at = @At(value = "RETURN", by = -3, shift = At.Shift.BY))
 	private void iris$renderHands(CallbackInfo ci) {
 		Minecraft.getInstance().getProfiler().popPush("iris_hand");
 		HandRendering.render();

File: src/main/java/net/coderbot/iris/gl/state/StateUpdateNotifiers.java
Patch:
@@ -10,4 +10,5 @@ public class StateUpdateNotifiers {
 	public static ValueUpdateNotifier fogToggleNotifier;
 	public static ValueUpdateNotifier fogModeNotifier;
 	public static ValueUpdateNotifier fogDensityNotifier;
+	public static ValueUpdateNotifier atlasTextureNotifier;
 }

File: src/main/java/net/coderbot/iris/gl/uniform/DynamicUniformHolder.java
Patch:
@@ -1,6 +1,8 @@
 package net.coderbot.iris.gl.uniform;
 
 import com.mojang.math.Vector4f;
+import net.coderbot.iris.vendored.joml.Vector2i;
+
 import java.util.function.DoubleSupplier;
 import java.util.function.IntSupplier;
 import java.util.function.Supplier;
@@ -10,5 +12,6 @@ public interface DynamicUniformHolder extends UniformHolder {
 	DynamicUniformHolder uniform1f(String name, IntSupplier value, ValueUpdateNotifier notifier);
 	DynamicUniformHolder uniform1f(String name, DoubleSupplier value, ValueUpdateNotifier notifier);
 	DynamicUniformHolder uniform1i(String name, IntSupplier value, ValueUpdateNotifier notifier);
+	DynamicUniformHolder uniform2i(String name, Supplier<Vector2i> value, ValueUpdateNotifier notifier);
 	DynamicUniformHolder uniform4f(String name, Supplier<Vector4f> value, ValueUpdateNotifier notifier);
 }

File: src/main/java/net/coderbot/iris/texunits/TextureAtlasInterface.java
Patch:
@@ -3,5 +3,6 @@
 import net.minecraft.world.phys.Vec2;
 
 public interface TextureAtlasInterface {
+	void setAtlasSize(int sizeX, int sizeY);
 	Vec2 getAtlasSize();
 }

File: src/main/java/net/coderbot/iris/HorizonRenderer.java
Patch:
@@ -104,8 +104,8 @@ private void buildRegularOctagonalPrism(VertexConsumer consumer, double radius)
 	}
 
 	private void buildBottomPlane(VertexConsumer consumer, int radius) {
-		for(int x = -radius; x <= radius; x += 64) {
-			for(int z = -radius; z <= radius; z += 64) {
+		for (int x = -radius; x <= radius; x += 64) {
+			for (int z = -radius; z <= radius; z += 64) {
 				consumer.vertex(x + 64, BOTTOM, z);
 				consumer.endVertex();
 				consumer.vertex(x, BOTTOM, z);

File: src/main/java/net/coderbot/iris/config/IrisConfig.java
Patch:
@@ -26,7 +26,7 @@ public class IrisConfig {
 	 */
 	private boolean enableShaders;
 
-	private Path propertiesPath;
+	private final Path propertiesPath;
 
 	public IrisConfig(Path propertiesPath) {
 		shaderPackName = null;

File: src/main/java/net/coderbot/iris/mixin/MixinLivingEntityRenderer.java
Patch:
@@ -28,7 +28,7 @@ public abstract class MixinLivingEntityRenderer {
 		}
 
 		boolean hurt;
-		if(Iris.isPhysicsModInstalled()) {
+		if (Iris.isPhysicsModInstalled()) {
 			hurt = entity.hurtTime > 0 && !entity.isDeadOrDying();
 		} else {
 			hurt = entity.hurtTime > 0 || entity.deathTime > 0;

File: src/main/java/net/coderbot/iris/mixin/MixinTitleScreen.java
Patch:
@@ -15,7 +15,7 @@
 public class MixinTitleScreen {
 	@Inject(method = "init", at = @At("RETURN"))
 	public void iris$showSodiumIncompatScreen(CallbackInfo ci) {
-		if(Iris.isSodiumInvalid()) {
+		if (Iris.isSodiumInvalid()) {
 			Minecraft.getInstance().setScreen(new AlertScreen(() -> {
 				Minecraft.getInstance().stop();
 			}, new TranslatableComponent("iris.sodium.failure.title").withStyle(ChatFormatting.RED), new TranslatableComponent("iris.sodium.failure.reason"), new TranslatableComponent("menu.quit")));

File: src/main/java/net/coderbot/iris/mixin/gui/MixinGui.java
Patch:
@@ -45,7 +45,7 @@ public class MixinGui {
 		warningLines.add("[Iris] Sodium isn't installed; you will have poor performance.");
 		warningLines.add("[Iris] Install the compatible Sodium fork if you want to run benchmarks or get higher FPS!");
 
-		for(int i = 0; i < warningLines.size(); ++i) {
+		for (int i = 0; i < warningLines.size(); ++i) {
 			String string = warningLines.get(i);
 
 			final int lineHeight = 9;

File: src/main/java/net/coderbot/iris/mixin/math/MixinMatrix4f.java
Patch:
@@ -29,7 +29,7 @@ public class MixinMatrix4f implements Matrix4fAccess {
 
 	@Override
 	public void copyFromArray(float[] m) {
-		if(m.length != 16) return;
+		if (m.length != 16) return;
 		this.m00 = m[0];
 		this.m10 = m[1];
 		this.m20 = m[2];

File: src/main/java/net/coderbot/iris/samplers/IrisSamplers.java
Patch:
@@ -77,7 +77,7 @@ public static boolean hasShadowSamplers(SamplerHolder samplers) {
 				"shadowcolor", "shadowcolor0", "shadowcolor1");
 
 		for (String samplerName : shadowSamplers) {
-			if(samplers.hasSampler(samplerName)) {
+			if (samplers.hasSampler(samplerName)) {
 				return true;
 			}
 		}

File: src/main/java/net/coderbot/iris/shadows/frustum/advanced/AdvancedShadowCullingFrustum.java
Patch:
@@ -295,7 +295,7 @@ private boolean isVisible(double minX, double minY, double minZ, double maxX, do
 	}
 
 	private boolean isAnyCornerVisible(float x1, float y1, float z1, float x2, float y2, float z2) {
-		for(int i = 0; i < planeCount; ++i) {
+		for (int i = 0; i < planeCount; ++i) {
 			Vector4f plane = this.planes[i];
 
 			// dot(plane, point) > 0.0F implies inside

File: src/main/java/net/coderbot/iris/uniforms/SamplerUniforms.java
Patch:
@@ -69,7 +69,7 @@ public static boolean hasShadowSamplers(LocationalUniformHolder uniformHolder) {
 				"shadowcolor", "shadowcolor0", "shadowcolor1");
 
 		for (String samplerName : shadowSamplers) {
-			if(uniformHolder.location(samplerName, UniformType.INT).isPresent()) {
+			if (uniformHolder.location(samplerName, UniformType.INT).isPresent()) {
 				return true;
 			}
 		}

File: src/main/java/net/coderbot/batchedentityrendering/mixin/MixinCompositeRenderType.java
Patch:
@@ -14,7 +14,7 @@
 @Mixin(targets = "net/minecraft/client/renderer/RenderType$CompositeRenderType")
 public abstract class MixinCompositeRenderType extends RenderType implements BlendingStateHolder {
 	private static final String INIT =
-			"<init>(Ljava/lang/String;Lcom/mojang/blaze3d/vertex/VertexFormat;IIZZLnet/minecraft/client/renderer/RenderType$CompositeState;)V";
+			"<init>(Ljava/lang/String;Lcom/mojang/blaze3d/vertex/VertexFormat;Lcom/mojang/blaze3d/vertex/VertexFormat$Mode;IZZLnet/minecraft/client/renderer/RenderType$CompositeState;)V";
 
 	@Unique
 	private TransparencyType transparencyType;

File: src/main/java/net/coderbot/iris/config/IrisConfig.java
Patch:
@@ -8,7 +8,6 @@
 
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.gui.option.IrisVideoSettings;
-import net.fabricmc.loader.api.FabricLoader;
 
 /**
  * A class dedicated to storing the config values of shaderpacks. Right now it only stores the path to the current shaderpack
@@ -29,10 +28,10 @@ public class IrisConfig {
 
 	private Path propertiesPath;
 
-	public IrisConfig() {
+	public IrisConfig(Path propertiesPath) {
 		shaderPackName = null;
 		enableShaders = true;
-		propertiesPath = FabricLoader.getInstance().getConfigDir().resolve("iris.properties");
+		this.propertiesPath = propertiesPath;
 	}
 
 	/**

File: src/main/java/net/coderbot/iris/mixin/MixinDebugScreenOverlay.java
Patch:
@@ -1,8 +1,6 @@
 package net.coderbot.iris.mixin;
 
 import net.coderbot.iris.Iris;
-import net.coderbot.iris.pipeline.ShadowRenderer;
-import net.fabricmc.loader.api.FabricLoader;
 import net.minecraft.ChatFormatting;
 import net.minecraft.client.gui.components.DebugScreenOverlay;
 import org.spongepowered.asm.mixin.Mixin;

File: src/main/java/net/coderbot/iris/mixin/MixinGlStateManager_AmdCrashFix.java
Patch:
@@ -14,7 +14,9 @@
 @Mixin(GlStateManager.class)
 public class MixinGlStateManager_AmdCrashFix {
 	@Redirect(method = "glShaderSource(ILjava/lang/CharSequence;)V",
-			at = @At(value = "INVOKE", target = "org/lwjgl/opengl/GL20.glShaderSource (ILjava/lang/CharSequence;)V"))
+			at = @At(value = "INVOKE",
+					target = "org/lwjgl/opengl/GL20.glShaderSource (ILjava/lang/CharSequence;)V",
+					remap = false))
 	private static void iris$safeShaderSource(int glId, CharSequence source) {
 		ShaderWorkarounds.safeShaderSource(glId, source);
 	}

File: src/main/java/net/coderbot/iris/mixin/gui/MixinGui.java
Patch:
@@ -2,7 +2,6 @@
 
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.gui.screen.HudHideable;
-import net.fabricmc.loader.api.FabricLoader;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.Font;
 import net.minecraft.client.gui.Gui;

File: src/main/java/net/coderbot/iris/shaderpack/ConstDirectiveParser.java
Patch:
@@ -3,7 +3,6 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Optional;
-import java.util.regex.Pattern;
 
 public class ConstDirectiveParser {
 	public static List<ConstDirective> findDirectives(String source) {

File: src/main/java/net/coderbot/iris/shaderpack/DispatchingDirectiveHolder.java
Patch:
@@ -5,7 +5,6 @@
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.IrisLogging;
 import net.coderbot.iris.vendored.joml.Vector4f;
-import net.fabricmc.loader.api.FabricLoader;
 
 import java.util.HashMap;
 import java.util.Map;

File: src/main/java/net/coderbot/iris/fantastic/IrisParticleRenderTypes.java
Patch:
@@ -18,8 +18,8 @@ public void begin(BufferBuilder bufferBuilder, TextureManager textureManager) {
 			bufferBuilder.begin(7, DefaultVertexFormat.PARTICLE);
 		}
 
-		public void end(Tesselator tessellator) {
-			tessellator.end();
+		public void end(Tesselator tesselator) {
+			tesselator.end();
 		}
 
 		public String toString() {

File: src/main/java/net/coderbot/iris/shaderpack/ConstDirectiveParser.java
Patch:
@@ -3,11 +3,10 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Optional;
-import java.util.regex.Pattern;
 
 public class ConstDirectiveParser {
 	public static List<ConstDirective> findDirectives(String source) {
-		List<ConstDirective> directives = new ArrayList();
+		List<ConstDirective> directives = new ArrayList<>();
 
 		// Match any valid newline sequence
 		// https://stackoverflow.com/a/31060125

File: src/main/java/net/coderbot/batchedentityrendering/mixin/MixinCompositeRenderType.java
Patch:
@@ -14,7 +14,7 @@
 @Mixin(targets = "net/minecraft/client/renderer/RenderType$CompositeRenderType")
 public abstract class MixinCompositeRenderType extends RenderType implements BlendingStateHolder {
 	private static final String INIT =
-			"init>(Ljava/lang/String;Lcom/mojang/blaze3d/vertex/VertexFormat;IIZZLnet/minecraft/client/renderer/RenderType$CompositeState;)V";
+			"<init>(Ljava/lang/String;Lcom/mojang/blaze3d/vertex/VertexFormat;IIZZLnet/minecraft/client/renderer/RenderType$CompositeState;)V";
 
 	@Unique
 	private TransparencyType transparencyType;

File: src/main/java/net/coderbot/iris/mixin/normals/MixinFixEntityVertexNormals.java
Patch:
@@ -62,12 +62,12 @@ public class MixinFixEntityVertexNormals {
 		// we're only interested in it because we want to restore the matrix state before rendering the last
 		// immediate buffers
 		@Slice(id = "after_translucent_rendering", from = @At(value = "FIELD:FIRST",
-			target = "Lnet/minecraft/client/render/WorldRenderer;transparencyShader:Lnet/minecraft/client/gl/ShaderEffect;")),
+			target = "net/minecraft/client/renderer/LevelRenderer.transparencyChain : Lnet/minecraft/client/renderer/PostChain;")),
 		// The opposite of the previous slice, everything up until the translucency rendering.
 		@Slice(id = "before_translucent_rendering",
 			from = @At(value = "INVOKE_STRING", target = PROFILER_SWAP, args = "ldc=entities"),
 			to = @At(value = "FIELD:FIRST", target =
-				"Lnet/minecraft/client/render/WorldRenderer;transparencyShader:Lnet/minecraft/client/gl/ShaderEffect;")
+				"net/minecraft/client/renderer/LevelRenderer.transparencyChain : Lnet/minecraft/client/renderer/PostChain;")
 		)
 	})
 	private void iris$setupGlMatrix(PoseStack poseStack, float tickDelta, long limitTime,

File: src/main/java/net/coderbot/batchedentityrendering/mixin/MixinCompositeRenderType.java
Patch:
@@ -14,7 +14,7 @@
 @Mixin(targets = "net/minecraft/client/renderer/RenderType$CompositeRenderType")
 public abstract class MixinCompositeRenderType extends RenderType implements BlendingStateHolder {
 	private static final String INIT =
-			"init>(Ljava/lang/String;Lcom/mojang/blaze3d/vertex/VertexFormat;IIZZLnet/minecraft/client/renderer/RenderType$CompositeState;)V";
+			"<init>(Ljava/lang/String;Lcom/mojang/blaze3d/vertex/VertexFormat;IIZZLnet/minecraft/client/renderer/RenderType$CompositeState;)V";
 
 	@Unique
 	private TransparencyType transparencyType;

File: src/main/java/net/coderbot/iris/mixin/MixinGlStateManager_AmdCrashFix.java
Patch:
@@ -14,7 +14,9 @@
 @Mixin(GlStateManager.class)
 public class MixinGlStateManager_AmdCrashFix {
 	@Redirect(method = "glShaderSource(ILjava/lang/CharSequence;)V",
-			at = @At(value = "INVOKE", target = "org/lwjgl/opengl/GL20.glShaderSource (ILjava/lang/CharSequence;)V"))
+			at = @At(value = "INVOKE",
+					target = "org/lwjgl/opengl/GL20.glShaderSource (ILjava/lang/CharSequence;)V",
+					remap = false))
 	private static void iris$safeShaderSource(int glId, CharSequence source) {
 		ShaderWorkarounds.safeShaderSource(glId, source);
 	}

File: src/main/java/net/coderbot/iris/mixin/MixinLevelRenderer.java
Patch:
@@ -123,8 +123,8 @@ public class MixinLevelRenderer {
 		RenderSystem.depthMask(true);
 	}
 
-	@Inject(method = "renderSky", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/multiplayer/ClientLevel;getSunAngle(F)F"),
-			slice = @Slice(from = @At(value = "FIELD", target = "Lnet/minecraft/world/phys/Vec3;y:D")))
+	@Inject(method = "renderSky", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/multiplayer/ClientLevel;getTimeOfDay(F)F"),
+			slice = @Slice(from = @At(value = "FIELD", target = "com/mojang/math/Vector3f.YP : Lcom/mojang/math/Vector3f;")))
 	private void iris$renderSky$tiltSun(PoseStack poseStack, float tickDelta, CallbackInfo callback) {
 		poseStack.mulPose(Vector3f.ZP.rotationDegrees(pipeline.getSunPathRotation()));
 	}

File: src/main/java/net/coderbot/iris/gl/shader/ShaderWorkarounds.java
Patch:
@@ -25,7 +25,7 @@
  * Contains a workaround for a crash in nglShaderSource on some AMD drivers. Copied from the following Canvas commit:
  * https://github.com/grondag/canvas/commit/820bf754092ccaf8d0c169620c2ff575722d7d96
  */
-class ShaderWorkarounds {
+public class ShaderWorkarounds {
 	/**
 	 * Identical in function to {@link GL20C#glShaderSource(int, CharSequence)} but
 	 * passes a null pointer for string length to force the driver to rely on the null
@@ -35,7 +35,7 @@ class ShaderWorkarounds {
 	 *
 	 * <p>Hat tip to fewizz for the find and the fix.
 	 */
-	static void safeShaderSource(int glId, CharSequence source) {
+	public static void safeShaderSource(int glId, CharSequence source) {
 		final MemoryStack stack = MemoryStack.stackGet();
 		final int stackPointer = stack.getPointer();
 

File: src/main/java/net/coderbot/iris/layer/InnerWrappedRenderType.java
Patch:
@@ -1,5 +1,6 @@
 package net.coderbot.iris.layer;
 
+import net.coderbot.batchedentityrendering.impl.WrappableRenderType;
 import net.coderbot.iris.mixin.rendertype.RenderTypeAccessor;
 import net.minecraft.client.renderer.RenderStateShard;
 import net.minecraft.client.renderer.RenderType;

File: src/main/java/net/coderbot/iris/layer/IrisRenderTypeWrapper.java
Patch:
@@ -3,6 +3,7 @@
 import java.util.Objects;
 import java.util.Optional;
 
+import net.coderbot.batchedentityrendering.impl.WrappableRenderType;
 import net.coderbot.iris.mixin.rendertype.RenderTypeAccessor;
 import net.minecraft.client.renderer.RenderType;
 import org.jetbrains.annotations.Nullable;

File: src/main/java/net/coderbot/iris/layer/OuterWrappedRenderType.java
Patch:
@@ -1,5 +1,6 @@
 package net.coderbot.iris.layer;
 
+import net.coderbot.batchedentityrendering.impl.WrappableRenderType;
 import net.coderbot.iris.mixin.rendertype.RenderTypeAccessor;
 import net.minecraft.client.renderer.RenderStateShard;
 import net.minecraft.client.renderer.RenderType;

File: src/main/java/net/coderbot/iris/mixin/fantastic/MixinFireworkSparkParticle.java
Patch:
@@ -6,7 +6,7 @@
 import net.minecraft.client.particle.SpriteSet;
 import org.spongepowered.asm.mixin.Mixin;
 
-@Mixin(targets = "net.minecraft.client.particle.FireworksSparkParticle$Explosion")
+@Mixin(targets = "net.minecraft.client.particle.FireworkParticles$SparkParticle")
 public class MixinFireworkSparkParticle extends SimpleAnimatedParticle {
 	private MixinFireworkSparkParticle(ClientLevel level, double x, double y, double z, SpriteSet spriteProvider, float upwardsAcceleration) {
 		super(level, x, y, z, spriteProvider, upwardsAcceleration);

File: src/main/java/net/coderbot/iris/uniforms/FogUniforms.java
Patch:
@@ -3,7 +3,7 @@
 import com.mojang.blaze3d.platform.GlStateManager;
 import net.coderbot.iris.gl.state.StateUpdateNotifiers;
 import net.coderbot.iris.gl.uniform.DynamicUniformHolder;
-import net.coderbot.iris.mixin.statelisteners.CapabilityTrackerAccessor;
+import net.coderbot.iris.mixin.statelisteners.BooleanStateAccessor;
 import net.coderbot.iris.mixin.statelisteners.GlStateManagerAccessor;
 
 public class FogUniforms {
@@ -15,7 +15,7 @@ public static void addFogUniforms(DynamicUniformHolder uniforms) {
 		uniforms.uniform1i("fogMode", () -> {
 			GlStateManager.FogState fog = GlStateManagerAccessor.getFOG();
 
-			if (!((CapabilityTrackerAccessor) fog.enable).getState()) {
+			if (!((BooleanStateAccessor) fog.enable).isEnabled()) {
 				return 0;
 			}
 
@@ -28,7 +28,7 @@ public static void addFogUniforms(DynamicUniformHolder uniforms) {
 		uniforms.uniform1f("fogDensity", () -> {
 			GlStateManager.FogState fog = GlStateManagerAccessor.getFOG();
 
-			if (!((CapabilityTrackerAccessor) fog.enable).getState()) {
+			if (!((BooleanStateAccessor) fog.enable).isEnabled()) {
 				return 0.0f;
 			}
 

File: src/main/java/net/coderbot/iris/mixin/DimensionTypeAccessor.java
Patch:
@@ -8,8 +8,6 @@
 
 @Mixin(DimensionType.class)
 public interface DimensionTypeAccessor {
-
 	@Accessor
 	OptionalLong getFixedTime();
-
 }

File: src/main/java/net/coderbot/iris/mixin/shadows/MixinPreventRebuildNearInShadowPass.java
Patch:
@@ -15,7 +15,7 @@
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
 /**
- * Prevent nearby chunks from being rebuilt on the main thread in the shadow pass. Aside from causing  FPS to tank,
+ * Prevent nearby chunks from being rebuilt on the main thread in the shadow pass. Aside from causing FPS to tank,
  * this also causes weird chunk corruption! It's critical to make sure that it's disabled as a result.
  *
  * This patch is not relevant with Sodium installed since Sodium has a completely different build path for terrain

File: src/main/java/net/coderbot/iris/mixin/fantastic/MixinParticleEngine.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.iris.mixin.fantastic;
 
 import com.google.common.collect.ImmutableList;
-import net.coderbot.iris.fantastic.IrisParticleTextureSheets;
+import net.coderbot.iris.fantastic.IrisParticleRenderTypes;
 import net.coderbot.iris.fantastic.ParticleRenderingPhase;
 import net.coderbot.iris.fantastic.PhasedParticleEngine;
 import net.minecraft.client.particle.ParticleEngine;
@@ -54,7 +54,7 @@ public class MixinParticleEngine implements PhasedParticleEngine {
 
 	static {
 		OPAQUE_PARTICLE_TEXTURE_SHEETS = ImmutableList.of(
-				IrisParticleTextureSheets.OPAQUE_TERRAIN_SHEET,
+				IrisParticleRenderTypes.OPAQUE_TERRAIN_SHEET,
 				ParticleRenderType.PARTICLE_SHEET_OPAQUE,
 				ParticleRenderType.PARTICLE_SHEET_LIT,
 				ParticleRenderType.CUSTOM,

File: src/main/java/net/coderbot/iris/mixin/fantastic/MixinStationaryItemParticle.java
Patch:
@@ -1,6 +1,6 @@
 package net.coderbot.iris.mixin.fantastic;
 
-import net.coderbot.iris.fantastic.IrisParticleTextureSheets;
+import net.coderbot.iris.fantastic.IrisParticleRenderTypes;
 import net.minecraft.client.multiplayer.ClientLevel;
 import net.minecraft.client.particle.ParticleRenderType;
 import net.minecraft.client.particle.StationaryItemParticle;
@@ -36,7 +36,7 @@ public class MixinStationaryItemParticle {
 	@Inject(method = "getRenderType", at = @At("HEAD"), cancellable = true)
 	private void iris$overrideParticleSheet(CallbackInfoReturnable<ParticleRenderType> cir) {
 		if (isOpaque) {
-			cir.setReturnValue(IrisParticleTextureSheets.OPAQUE_TERRAIN_SHEET);
+			cir.setReturnValue(IrisParticleRenderTypes.OPAQUE_TERRAIN_SHEET);
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/fantastic/MixinTerrainParticle.java
Patch:
@@ -1,6 +1,6 @@
 package net.coderbot.iris.mixin.fantastic;
 
-import net.coderbot.iris.fantastic.IrisParticleTextureSheets;
+import net.coderbot.iris.fantastic.IrisParticleRenderTypes;
 import net.minecraft.client.multiplayer.ClientLevel;
 import net.minecraft.client.particle.ParticleRenderType;
 import net.minecraft.client.particle.TerrainParticle;
@@ -32,7 +32,7 @@ public class MixinTerrainParticle {
 	@Inject(method = "getRenderType", at = @At("HEAD"), cancellable = true)
 	private void iris$overrideParticleSheet(CallbackInfoReturnable<ParticleRenderType> cir) {
 		if (isOpaque) {
-			cir.setReturnValue(IrisParticleTextureSheets.OPAQUE_TERRAIN_SHEET);
+			cir.setReturnValue(IrisParticleRenderTypes.OPAQUE_TERRAIN_SHEET);
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/gl/shader/StandardMacros.java
Patch:
@@ -26,9 +26,9 @@ public class StandardMacros {
 	 */
 	public static String getMcVersion() {
 		String version = SharedConstants.getCurrentVersion().getReleaseTarget();
-			// release target so snapshots are set to the higher version
-			//
-			// For example if we were running iris on 21w07a, getReleaseTarget() would return 1.17
+		// release target so snapshots are set to the higher version
+		//
+		// For example if we were running iris on 21w07a, getReleaseTarget() would return 1.17
 
 		if (version == null) {
 			throw new IllegalStateException("Could not get the current minecraft version!");

File: src/main/java/net/coderbot/iris/mixin/shadows/MixinPreventRebuildNearInShadowPass.java
Patch:
@@ -42,11 +42,12 @@ public abstract class MixinPreventRebuildNearInShadowPass {
 				}
 			}
 			MinecraftClient.getInstance().getProfiler().pop();
+			this.method_38551(frustum);
 			ci.cancel();
 		}
 	}
 
-	@Redirect(method = "setupTerrain", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/render/WorldRenderer;method_38551(Lnet/minecraft/client/render/Frustum;)V"))
+	//@Redirect(method = "setupTerrain", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/render/WorldRenderer;method_38551(Lnet/minecraft/client/render/Frustum;)V"))
 	private void dontupdatefrustum(WorldRenderer worldRenderer, Frustum frustum) {
 		if (!ShadowRenderer.ACTIVE) {
 			this.method_38551(frustum);

File: src/main/java/net/coderbot/iris/mixin/MixinLivingEntityRenderer.java
Patch:
@@ -19,7 +19,7 @@ public abstract class MixinLivingEntityRenderer {
 	abstract float getWhiteOverlayProgress(LivingEntity entity, float tickDelta);
 
 	@ModifyVariable(method = "render", at = @At("HEAD"))
-	private MultiBufferSource iris$wrapProvider(MultiBufferSource bufferSource, LivingEntity entity, float yaw,
+	private MultiBufferSource iris$wrapBufferSource(MultiBufferSource bufferSource, LivingEntity entity, float yaw,
 												float tickDelta, PoseStack pose, MultiBufferSource bufferSourceArg,
 												int light) {
 		if (!(bufferSource instanceof Groupable)) {

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -114,7 +114,7 @@ static float getBlindness() {
 			MobEffectInstance blindness = ((LivingEntity) cameraEntity).getEffect(MobEffects.BLINDNESS);
 
 			if (blindness != null) {
-				// Guessing that this is what OF uses, based on how vanilla calculates the fog value in BackgroundRenderer
+				// Guessing that this is what OF uses, based on how vanilla calculates the fog value in FogRenderer
 				// TODO: Add this to ShaderDoc
 				return Math.min(1.0F, blindness.getDuration() / 20.0F);
 			}
@@ -168,7 +168,7 @@ private static float getNightVision() {
 		// Conduit power gives the player a sort-of night vision effect when underwater.
 		// This lets existing shaderpacks be compatible with conduit power automatically.
 		//
-		// Yes, this should be the player entity, to match LightmapTextureManager.
+		// Yes, this should be the player entity, to match LightTexture.
 		if (client.player != null && client.player.hasEffect(MobEffects.CONDUIT_POWER)) {
 			float underwaterVisibility = client.player.getWaterVision();
 

File: src/main/java/net/coderbot/iris/uniforms/builtin/BuiltinReplacementUniforms.java
Patch:
@@ -12,7 +12,7 @@ public class BuiltinReplacementUniforms {
 	private static final Matrix4f lightmapTextureMatrix;
 
 	static {
-		// This mimics the transformations done in LightmapTextureManager to the GL_TEXTURE matrix.
+		// This mimics the transformations done in LightTexture to the GL_TEXTURE matrix.
 		lightmapTextureMatrix = new Matrix4f();
 		lightmapTextureMatrix.setIdentity();
 		lightmapTextureMatrix.multiply(0.00390625f);

File: src/main/java/net/coderbot/iris/mixin/MixinLivingEntityRenderer.java
Patch:
@@ -16,7 +16,7 @@
 @Mixin(LivingEntityRenderer.class)
 public abstract class MixinLivingEntityRenderer {
 	@Shadow
-	abstract float getAttackAnim(LivingEntity entity, float tickDelta);
+	abstract float getWhiteOverlayProgress(LivingEntity entity, float tickDelta);
 
 	@ModifyVariable(method = "render", at = @At("HEAD"))
 	private MultiBufferSource iris$wrapProvider(MultiBufferSource bufferSource, LivingEntity entity, float yaw,
@@ -33,7 +33,7 @@ public abstract class MixinLivingEntityRenderer {
 		} else {
 			hurt = entity.hurtTime > 0 || entity.deathTime > 0;
 		}
-		float whiteFlash = getAttackAnim(entity, tickDelta);
+		float whiteFlash = getWhiteOverlayProgress(entity, tickDelta);
 
 		if (hurt || whiteFlash > 0.0) {
 			EntityColorRenderStateShard phase = new EntityColorRenderStateShard(hurt, whiteFlash);

File: src/headers/java/com/terraformersmc/modmenu/api/ConfigScreenFactory.java
Patch:
@@ -24,7 +24,7 @@
 
 package com.terraformersmc.modmenu.api;
 
-import net.minecraft.client.gui.screen.Screen;
+import net.minecraft.client.gui.screens.Screen;
 
 @FunctionalInterface
 @SuppressWarnings("deprecation")

File: src/headers/java/io/github/prospector/modmenu/api/ConfigScreenFactory.java
Patch:
@@ -24,7 +24,8 @@
 
 package io.github.prospector.modmenu.api;
 
-import net.minecraft.client.gui.screen.Screen;
+
+import net.minecraft.client.gui.screens.Screen;
 
 /**
  * Deprecated interface, switch to {@link com.terraformersmc.modmenu.api.ModMenuApi} and {@link com.terraformersmc.modmenu.api.ConfigScreenFactory} instead

File: src/main/java/net/coderbot/batchedentityrendering/impl/BatchingDebugMessageHelper.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.batchedentityrendering.impl;
 
 public class BatchingDebugMessageHelper {
-	public static String getDebugMessage(DrawCallTrackingBufferBuilderStorage drawTracker) {
+	public static String getDebugMessage(DrawCallTrackingRenderBuffers drawTracker) {
 		int drawCalls = drawTracker.getDrawCalls();
 		int renderTypes = drawTracker.getRenderTypes();
 

File: src/main/java/net/coderbot/batchedentityrendering/impl/BufferBuilderExt.java
Patch:
@@ -1,11 +1,11 @@
 package net.coderbot.batchedentityrendering.impl;
 
-import net.minecraft.client.render.BufferBuilder;
+import com.mojang.blaze3d.vertex.BufferBuilder;
 
 import java.nio.ByteBuffer;
 
 public interface BufferBuilderExt {
-    void setupBufferSlice(ByteBuffer buffer, BufferBuilder.DrawArrayParameters parameters);
+    void setupBufferSlice(ByteBuffer buffer, BufferBuilder.DrawState drawState);
     void teardownBufferSlice();
     void splitStrip();
 }

File: src/main/java/net/coderbot/batchedentityrendering/impl/DrawCallTrackingRenderBuffers.java
Patch:
@@ -1,6 +1,6 @@
 package net.coderbot.batchedentityrendering.impl;
 
-public interface DrawCallTrackingBufferBuilderStorage {
+public interface DrawCallTrackingRenderBuffers {
 	int getDrawCalls();
 	int getRenderTypes();
 	void resetDrawCounts();

File: src/main/java/net/coderbot/batchedentityrendering/impl/FlushableMultiBufferSource.java
Patch:
@@ -1,6 +1,6 @@
 package net.coderbot.batchedentityrendering.impl;
 
-public interface FlushableVertexConsumerProvider {
+public interface FlushableMultiBufferSource {
 	void flushNonTranslucentContent();
 	void flushTranslucentContent();
 }

File: src/main/java/net/coderbot/batchedentityrendering/impl/MemoryTrackingRenderBuffers.java
Patch:
@@ -1,6 +1,6 @@
 package net.coderbot.batchedentityrendering.impl;
 
-public interface MemoryTrackingBufferBuilderStorage {
+public interface MemoryTrackingRenderBuffers {
     int getEntityBufferAllocatedSize();
     int getMiscBufferAllocatedSize();
     int getMaxBegins();

File: src/main/java/net/coderbot/batchedentityrendering/impl/ordering/RenderOrderManager.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.batchedentityrendering.impl.ordering;
 
-import net.minecraft.client.render.RenderLayer;
+import net.minecraft.client.renderer.RenderType;
 
 public interface RenderOrderManager {
-    void begin(RenderLayer layer);
+    void begin(RenderType type);
     void startGroup();
     boolean maybeStartGroup();
     void endGroup();
     void reset();
-    Iterable<RenderLayer> getRenderOrder();
+    Iterable<RenderType> getRenderOrder();
 }

File: src/main/java/net/coderbot/batchedentityrendering/mixin/MixinBufferBuilder.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.batchedentityrendering.mixin;
 
+import com.mojang.blaze3d.vertex.BufferBuilder;
 import net.coderbot.batchedentityrendering.impl.MemoryTrackingBuffer;
-import net.minecraft.client.render.BufferBuilder;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Shadow;
 

File: src/main/java/net/coderbot/iris/fantastic/PhasedParticleEngine.java
Patch:
@@ -1,5 +1,5 @@
 package net.coderbot.iris.fantastic;
 
-public interface PhasedParticleManager {
+public interface PhasedParticleEngine {
 	void setParticleRenderingPhase(ParticleRenderingPhase phase);
 }

File: src/main/java/net/coderbot/iris/gl/program/ProgramUniforms.java
Patch:
@@ -12,11 +12,10 @@
 import net.coderbot.iris.gl.uniform.UniformUpdateFrequency;
 import net.coderbot.iris.gl.uniform.ValueUpdateNotifier;
 import net.coderbot.iris.uniforms.SystemTimeUniforms;
+import net.minecraft.client.Minecraft;
 import org.lwjgl.BufferUtils;
 import org.lwjgl.opengl.GL20C;
 
-import net.minecraft.client.MinecraftClient;
-
 public class ProgramUniforms {
 	private static ProgramUniforms active;
 	private final ImmutableList<Uniform> perTick;
@@ -44,7 +43,7 @@ private void updateStage(ImmutableList<Uniform> uniforms) {
 	}
 
 	private static long getCurrentTick() {
-		return Objects.requireNonNull(MinecraftClient.getInstance().world).getTime();
+		return Objects.requireNonNull(Minecraft.getInstance().level).getGameTime();
 	}
 
 	public void update() {

File: src/main/java/net/coderbot/iris/gl/shader/StandardMacros.java
Patch:
@@ -11,7 +11,7 @@
 import org.lwjgl.opengl.*;
 
 import net.minecraft.SharedConstants;
-import net.minecraft.util.Util;
+import net.minecraft.Util;
 
 public class StandardMacros {
 
@@ -25,7 +25,7 @@ public class StandardMacros {
 	 * @see <a href="https://github.com/sp614x/optifine/blob/9c6a5b5326558ccc57c6490b66b3be3b2dc8cbef/OptiFineDoc/doc/shaders.txt#L696-L699">Optifine Doc</a>
 	 */
 	public static String getMcVersion() {
-		String version = SharedConstants.getGameVersion().getReleaseTarget();
+		String version = SharedConstants.getCurrentVersion().getReleaseTarget();
 			// release target so snapshots are set to the higher version
 			//
 			// For example if we were running iris on 21w07a, getReleaseTarget() would return 1.17
@@ -67,7 +67,7 @@ public static String getMcVersion() {
 	 * @see <a href="https://github.com/sp614x/optifine/blob/9c6a5b5326558ccc57c6490b66b3be3b2dc8cbef/OptiFineDoc/doc/shaders.txt#L709-L714">Optifine Doc</a>
 	 */
 	public static String getOsString() {
-		switch (Util.getOperatingSystem()) {
+		switch (Util.getPlatform()) {
 			case OSX:
 				return "MC_OS_MAC";
 			case LINUX:

File: src/main/java/net/coderbot/iris/gl/uniform/Vector4Uniform.java
Patch:
@@ -1,5 +1,6 @@
 package net.coderbot.iris.gl.uniform;
 
+import com.mojang.math.Vector4f;
 import java.util.function.Supplier;
 import net.minecraft.util.math.Vector4f;
 import org.lwjgl.opengl.GL21;
@@ -32,8 +33,8 @@ private void updateValue() {
 		Vector4f newValue = value.get();
 
 		if (!newValue.equals(cachedValue)) {
-			cachedValue.set(newValue.getX(), newValue.getY(), newValue.getZ(), newValue.getW());
-			GL21.glUniform4f(location, cachedValue.getX(), cachedValue.getY(), cachedValue.getZ(), cachedValue.getW());
+			cachedValue.set(newValue.x(), newValue.y(), newValue.z(), newValue.w());
+			GL21.glUniform4f(location, cachedValue.x(), cachedValue.y(), cachedValue.z(), cachedValue.w());
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/DimensionTypeAccessor.java
Patch:
@@ -1,10 +1,10 @@
 package net.coderbot.iris.mixin;
 
-import net.minecraft.world.dimension.DimensionType;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;
 
 import java.util.OptionalLong;
+import net.minecraft.world.level.dimension.DimensionType;
 
 @Mixin(DimensionType.class)
 public interface DimensionTypeAccessor {

File: src/main/java/net/coderbot/iris/mixin/texunits/MixinOverlayTexture.java
Patch:
@@ -5,11 +5,9 @@
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.Constant;
 import org.spongepowered.asm.mixin.injection.ModifyConstant;
-
-import net.minecraft.client.render.OverlayTexture;
-
 import net.fabricmc.api.EnvType;
 import net.fabricmc.api.Environment;
+import net.minecraft.client.renderer.texture.OverlayTexture;
 
 @Mixin(OverlayTexture.class)
 @Environment(EnvType.CLIENT)

File: src/main/java/net/coderbot/iris/pipeline/SodiumTerrainPipeline.java
Patch:
@@ -207,7 +207,7 @@ public ProgramUniforms initUniforms(int programId) {
 
 		CommonUniforms.addCommonUniforms(uniforms, programSet.getPack().getIdMap(), programSet.getPackDirectives(), updateNotifier, FogMode.LINEAR);
 		SamplerUniforms.addCommonSamplerUniforms(uniforms);
-		SamplerUniforms.addWorldSamplerUniforms(uniforms);
+		SamplerUniforms.addLevelSamplerUniforms(uniforms);
 		SamplerUniforms.addDepthSamplerUniforms(uniforms);
 		BuiltinReplacementUniforms.addBuiltinReplacementUniforms(uniforms);
 

File: src/main/java/net/coderbot/iris/shadows/EmptyShadowMapRenderer.java
Patch:
@@ -2,8 +2,8 @@
 
 import com.mojang.blaze3d.platform.GlStateManager;
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
-import net.coderbot.iris.mixin.WorldRendererAccessor;
-import net.minecraft.client.render.Camera;
+import net.coderbot.iris.mixin.LevelRendererAccessor;
+import net.minecraft.client.Camera;
 import org.lwjgl.opengl.GL20C;
 import org.lwjgl.opengl.GL30C;
 
@@ -46,7 +46,7 @@ public EmptyShadowMapRenderer(int size) {
 	}
 
 	@Override
-	public void renderShadows(WorldRendererAccessor worldRenderer, Camera playerCamera) {
+	public void renderShadows(LevelRendererAccessor levelRenderer, Camera playerCamera) {
 		// No-op
 	}
 

File: src/main/java/net/coderbot/iris/shadows/ShadowMapRenderer.java
Patch:
@@ -1,12 +1,12 @@
 package net.coderbot.iris.shadows;
 
-import net.coderbot.iris.mixin.WorldRendererAccessor;
-import net.minecraft.client.render.Camera;
+import net.coderbot.iris.mixin.LevelRendererAccessor;
+import net.minecraft.client.Camera;
 
 import java.util.List;
 
 public interface ShadowMapRenderer {
-	void renderShadows(WorldRendererAccessor worldRenderer, Camera playerCamera);
+	void renderShadows(LevelRendererAccessor levelRenderer, Camera playerCamera);
 	void addDebugText(List<String> messages);
 	int getDepthTextureId();
 	int getDepthTextureNoTranslucentsId();

File: src/main/java/net/coderbot/iris/shadows/ShadowRenderingState.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.iris.shadows;
 
+import com.mojang.math.Matrix4f;
 import net.coderbot.iris.pipeline.ShadowRenderer;
-import net.minecraft.util.math.Matrix4f;
 
 public class ShadowRenderingState {
 	public static boolean areShadowsCurrentlyBeingRendered() {

File: src/main/java/net/coderbot/iris/uniforms/SamplerUniforms.java
Patch:
@@ -77,7 +77,7 @@ public static boolean hasShadowSamplers(LocationalUniformHolder uniformHolder) {
 		return false;
 	}
 
-	public static void addWorldSamplerUniforms(UniformHolder uniforms) {
+	public static void addLevelSamplerUniforms(UniformHolder uniforms) {
 		uniforms
 			.uniform1i(ONCE, "tex", TextureUnit.TERRAIN::getSamplerId)
 			.uniform1i(ONCE, "texture", TextureUnit.TERRAIN::getSamplerId)

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -113,7 +113,8 @@ public ShadowRenderer(WorldRenderingPipeline pipeline, ProgramSource shadow, Pac
 
 		if (shadowDirectives.getFov() != null) {
 			// TODO: Support FOV in the shadow map for legacy shaders
-			Iris.logger.warn("The shaderpack specifies a shadow FOV of " + shadowDirectives.getFov() + ", but Iris does not currently support perspective projections in the shadow pass.");
+			Iris.logger.warn("The shaderpack specifies a shadow FOV of " + shadowDirectives.getFov()
+					+ ", but Iris does not currently support perspective projections in the shadow pass.");
 		}
 
 		// TODO: Support more than two shadowcolor render targets

File: src/main/java/net/coderbot/iris/mixin/MixinBufferSource_WrapperChecking.java
Patch:
@@ -16,7 +16,7 @@
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
 @Mixin(MultiBufferSource.BufferSource.class)
-public class MixinMultiBufferSourceChild {
+public class MixinBufferSource_WrapperChecking {
 	@Unique
 	private final Set<String> unwrapped = new ObjectOpenHashSet<>();
 

File: src/main/java/net/coderbot/iris/layer/IrisRenderTypeWrapper.java
Patch:
@@ -8,10 +8,10 @@
 import org.jetbrains.annotations.Nullable;
 
 public class IrisRenderTypeWrapper extends RenderType implements WrappableRenderType {
-	private final UseProgramRenderState useProgram;
+	private final UseProgramRenderStateShard useProgram;
 	private final RenderType wrapped;
 
-	public IrisRenderTypeWrapper(String name, RenderType wrapped, UseProgramRenderState useProgram) {
+	public IrisRenderTypeWrapper(String name, RenderType wrapped, UseProgramRenderStateShard useProgram) {
 		super(name, wrapped.format(), wrapped.mode(), wrapped.bufferSize(),
 			wrapped.affectsCrumbling(), isTranslucent(wrapped), wrapped::setupRenderState, wrapped::clearRenderState);
 

File: src/main/java/net/coderbot/iris/layer/OuterWrappedRenderType.java
Patch:
@@ -76,7 +76,7 @@ public String toString() {
 		return "iris_wrapped:" + this.wrapped.toString();
 	}
 
-	private static boolean isTranslucent(RenderType layer) {
-		return ((RenderTypeAccessor) layer).isTranslucent();
+	private static boolean isTranslucent(RenderType type) {
+		return ((RenderTypeAccessor) type).isTranslucent();
 	}
 }

File: src/main/java/net/coderbot/iris/layer/UseProgramRenderStateShard.java
Patch:
@@ -3,10 +3,10 @@
 import java.util.Objects;
 import net.minecraft.client.renderer.RenderStateShard;
 
-public class UseProgramRenderState extends RenderStateShard {
+public class UseProgramRenderStateShard extends RenderStateShard {
 	private GbufferProgram program;
 
-	public UseProgramRenderState(GbufferProgram program) {
+	public UseProgramRenderStateShard(GbufferProgram program) {
 		super("iris:use_program", () -> GbufferPrograms.push(program), () -> GbufferPrograms.pop(program));
 
 		this.program = program;
@@ -22,7 +22,7 @@ public boolean equals(Object object) {
 			return false;
 		}
 
-		UseProgramRenderState other = (UseProgramRenderState) object;
+		UseProgramRenderStateShard other = (UseProgramRenderStateShard) object;
 
 		return Objects.equals(this.program, other.program);
 	}

File: src/main/java/net/coderbot/iris/mixin/MixinBlockStateBehavior.java
Patch:
@@ -13,7 +13,7 @@
 import org.spongepowered.asm.mixin.Shadow;
 
 @Mixin(BlockBehaviour.BlockStateBase.class)
-public abstract class MixinAbstractBlockState {
+public abstract class MixinBlockStateBehavior {
 	@Shadow
 	public abstract Block getBlock();
 

File: src/main/java/net/coderbot/iris/mixin/MixinLivingEntityRenderer.java
Patch:
@@ -4,7 +4,7 @@
 import net.coderbot.batchedentityrendering.impl.Groupable;
 import net.coderbot.iris.Iris;
 import net.coderbot.iris.layer.EntityColorRenderStateShard;
-import net.coderbot.iris.layer.EntityColorVertexConsumerProvider;
+import net.coderbot.iris.layer.EntityColorMultiBufferSource;
 import net.minecraft.client.renderer.MultiBufferSource;
 import net.minecraft.client.renderer.entity.LivingEntityRenderer;
 import net.minecraft.world.entity.LivingEntity;
@@ -35,7 +35,7 @@ public abstract class MixinLivingEntityRenderer {
 
 		if (hurt || whiteFlash > 0.0) {
 			EntityColorRenderStateShard phase = new EntityColorRenderStateShard(hurt, whiteFlash);
-			return new EntityColorVertexConsumerProvider(provider, phase);
+			return new EntityColorMultiBufferSource(provider, phase);
 		} else {
 			return provider;
 		}

File: src/main/java/net/coderbot/iris/mixin/MixinMultiBufferSourceChild.java
Patch:
@@ -19,7 +19,7 @@
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
 @Mixin(MultiBufferSource.BufferSource.class)
-public class MixinImmediateVertexConsumerProvider {
+public class MixinMultiBufferSourceChild {
 	@Unique
 	private final Set<String> unwrapped = new ObjectOpenHashSet<>();
 

File: src/main/java/net/coderbot/iris/mixin/MixinMultiBufferSource_WrapperManager.java
Patch:
@@ -147,11 +147,11 @@ private void ensureWrapped(RenderType base) {
 
 	@Unique
 	private RenderType iris$wrapWithIsEntity(RenderType base) {
-		return new OuterWrappedRenderType("iris:is_entity", base, IsEntityRenderState.INSTANCE);
+		return new OuterWrappedRenderType("iris:is_entity", base, IsEntityRenderStateShard.INSTANCE);
 	}
 
 	@Unique
 	private RenderType iris$wrapWithIsBlockEntity(RenderType base) {
-		return new OuterWrappedRenderType("iris:is_block_entity", base, IsBlockEntityRenderState.INSTANCE);
+		return new OuterWrappedRenderType("iris:is_block_entity", base, IsBlockEntityRenderStateShard.INSTANCE);
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/MixinTntMinecartEntityRenderer.java
Patch:
@@ -3,7 +3,7 @@
 import com.mojang.blaze3d.vertex.PoseStack;
 import net.coderbot.batchedentityrendering.impl.Groupable;
 import net.coderbot.iris.layer.EntityColorRenderStateShard;
-import net.coderbot.iris.layer.EntityColorVertexConsumerProvider;
+import net.coderbot.iris.layer.EntityColorMultiBufferSource;
 import net.minecraft.client.renderer.MultiBufferSource;
 import net.minecraft.client.renderer.entity.TntMinecartRenderer;
 import net.minecraft.world.level.block.state.BlockState;
@@ -22,7 +22,7 @@ public abstract class MixinTntMinecartEntityRenderer {
 
 		if (drawFlash) {
 			EntityColorRenderStateShard phase = new EntityColorRenderStateShard(false, 1.0F);
-			return new EntityColorVertexConsumerProvider(provider, phase);
+			return new EntityColorMultiBufferSource(provider, phase);
 		} else {
 			return provider;
 		}

File: src/main/java/net/coderbot/iris/mixin/rendertype/MixinRenderType.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.coderbot.iris.layer.GbufferProgram;
 import net.coderbot.iris.layer.IrisRenderTypeWrapper;
-import net.coderbot.iris.layer.UseProgramRenderState;
+import net.coderbot.iris.layer.UseProgramRenderStateShard;
 import org.spongepowered.asm.mixin.Final;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Mutable;
@@ -115,7 +115,7 @@ public static RenderType lines() {
 	}
 
 	private static RenderType wrap(String name, RenderType wrapped, GbufferProgram program) {
-		return new IrisRenderTypeWrapper(name, wrapped, new UseProgramRenderState(program));
+		return new IrisRenderTypeWrapper(name, wrapped, new UseProgramRenderStateShard(program));
 	}
 
 	private static RenderType wrapGlint(String glintType, RenderType wrapped) {

File: src/main/java/net/coderbot/iris/shadows/frustum/CullEverythingFrustum.java
Patch:
@@ -20,6 +20,7 @@ public boolean canDetermineInvisible(double minX, double minY, double minZ, doub
 		return false;
 	}
 
+	@Override
 	public boolean isVisible(AABB box) {
 		return false;
 	}

File: src/main/java/net/coderbot/iris/shadows/frustum/ShadowFrustum.java
Patch:
@@ -29,6 +29,7 @@ public boolean preAabbTest(float minX, float minY, float minZ, float maxX, float
 		return true;
 	}
 
+	@Override
 	public boolean isVisible(AABB box) {
 		if (boxCuller.isCulled(box)) {
 			return false;

File: src/main/java/net/coderbot/iris/shadows/frustum/advanced/AdvancedShadowCullingFrustum.java
Patch:
@@ -259,6 +259,7 @@ public void prepare(double cameraX, double cameraY, double cameraZ) {
 		this.z = cameraZ;
 	}
 
+	@Override
 	public boolean isVisible(AABB box) {
 		if (boxCuller != null && boxCuller.isCulled(box)) {
 			return false;

File: src/main/java/net/coderbot/iris/shadows/frustum/fallback/BoxCullingFrustum.java
Patch:
@@ -14,7 +14,8 @@ public BoxCullingFrustum(BoxCuller boxCuller) {
 		this.boxCuller = boxCuller;
 	}
 
-	public void setPosition(double cameraX, double cameraY, double cameraZ) {
+	@Override
+	public void prepare(double cameraX, double cameraY, double cameraZ) {
 		boxCuller.setPosition(cameraX, cameraY, cameraZ);
 	}
 
@@ -32,6 +33,7 @@ public boolean canDetermineInvisible(double minX, double minY, double minZ, doub
 		return false;
 	}
 
+	@Override
 	public boolean isVisible(AABB box) {
 		return !boxCuller.isCulled(box);
 	}

File: src/main/java/net/coderbot/iris/shadows/frustum/fallback/NonCullingFrustum.java
Patch:
@@ -22,6 +22,7 @@ public boolean canDetermineInvisible(double minX, double minY, double minZ, doub
 		return false;
 	}
 
+	@Override
 	public boolean isVisible(AABB box) {
 		return true;
 	}

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -132,6 +132,8 @@ public ShadowRenderer(WorldRenderingPipeline pipeline, ProgramSource shadow, Pac
 
 		if (shadow != null) {
 			this.packHasVoxelization = shadow.getGeometrySource().isPresent();
+		} else {
+			this.packHasVoxelization = false;
 		}
 
 		ProgramSource[] composite = programSet.getComposite();

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -193,7 +193,8 @@ public NewWorldRenderingPipeline(ProgramSet programSet) throws IOException {
 
 		createShadowMapRenderer = () -> {
 			shadowMapRenderer = new ShadowRenderer(this, programSet.getShadow().orElse(null),
-					programSet.getPackDirectives(), () -> flippedBeforeTerrain, renderTargets, normals, specular, noise);
+					programSet.getPackDirectives(), () -> flippedBeforeTerrain, renderTargets, normals, specular, noise,
+					programSet);
 			createShadowMapRenderer = () -> {};
 		};
 

File: src/main/java/net/coderbot/iris/shadows/frustum/fallback/BoxCullingFrustum.java
Patch:
@@ -20,7 +20,7 @@ public void setPosition(double cameraX, double cameraY, double cameraZ) {
 
 	// for Sodium
 	// TODO: Better way to do this... Maybe we shouldn't be using a frustum for the box culling in the first place!
-	public boolean preAabbTest(float minX, float minY, float minZ, float maxX, float maxY, float maxZ) {
+	public boolean fastAabbTest(float minX, float minY, float minZ, float maxX, float maxY, float maxZ) {
 		return !boxCuller.isCulled(minX, minY, minZ, maxX, maxY, maxZ);
 	}
 

File: src/main/java/net/coderbot/iris/layer/InnerWrappedRenderLayer.java
Patch:
@@ -1,5 +1,6 @@
 package net.coderbot.iris.layer;
 
+import net.coderbot.batchedentityrendering.impl.WrappableRenderLayer;
 import net.coderbot.iris.mixin.renderlayer.RenderLayerAccessor;
 import net.minecraft.client.render.RenderLayer;
 import net.minecraft.client.render.RenderPhase;

File: src/main/java/net/coderbot/iris/layer/IrisRenderLayerWrapper.java
Patch:
@@ -3,6 +3,7 @@
 import java.util.Objects;
 import java.util.Optional;
 
+import net.coderbot.batchedentityrendering.impl.WrappableRenderLayer;
 import net.coderbot.iris.mixin.renderlayer.RenderLayerAccessor;
 import org.jetbrains.annotations.Nullable;
 

File: src/main/java/net/coderbot/iris/layer/OuterWrappedRenderLayer.java
Patch:
@@ -1,5 +1,6 @@
 package net.coderbot.iris.layer;
 
+import net.coderbot.batchedentityrendering.impl.WrappableRenderLayer;
 import net.coderbot.iris.mixin.renderlayer.RenderLayerAccessor;
 import net.minecraft.client.render.RenderLayer;
 import net.minecraft.client.render.RenderPhase;

File: src/main/java/net/coderbot/iris/mixin/vertices/MixinBufferBuilder.java
Patch:
@@ -239,7 +239,7 @@ private void computeTangents() {
 		float pbitangenty = -(tangentx * normal.z - tangentz * normal.x);
 		float pbitangentz =   tangentx * normal.x - tangenty * normal.y;
 
-		float dot = bitangentx * pbitangentx + bitangenty + pbitangenty + bitangentz * pbitangentz;
+		float dot = (bitangentx * pbitangentx) + (bitangenty * pbitangenty) + (bitangentz * pbitangentz);
 		float tangentW;
 
 		if (dot < 0) {

File: src/main/java/net/coderbot/iris/pipeline/newshader/CoreWorldRenderingPipeline.java
Patch:
@@ -35,6 +35,7 @@ public interface CoreWorldRenderingPipeline extends WorldRenderingPipeline {
 	Shader getBeacon();
 	Shader getShadowTerrainCutout();
 	Shader getShadowEntitiesCutout();
+	Shader getShadowBeaconBeam();
 	Shader getTranslucent();
 	Shader getGlint();
 	Shader getLines();

File: src/main/java/net/coderbot/iris/pipeline/SodiumTerrainPipeline.java
Patch:
@@ -4,6 +4,7 @@
 import java.util.function.IntFunction;
 
 import net.coderbot.iris.Iris;
+import net.coderbot.iris.IrisLogging;
 import net.coderbot.iris.gl.program.ProgramBuilder;
 import net.coderbot.iris.gl.program.ProgramSamplers;
 import net.coderbot.iris.gl.program.ProgramUniforms;
@@ -129,7 +130,7 @@ private static String transformVertexShader(String base) {
 
 		new BuiltinUniformReplacementTransformer("a_LightCoord").apply(transformations);
 
-		if (FabricLoader.getInstance().isDevelopmentEnvironment()) {
+		if (IrisLogging.ENABLE_SPAM) {
 			System.out.println("Final patched vertex source:");
 			System.out.println(transformations);
 		}
@@ -157,7 +158,7 @@ private static String transformFragmentShader(String base) {
 		ProgramBuilder.MACRO_CONSTANTS.getDefineStrings().forEach(defineString ->
 				transformations.injectLine(Transformations.InjectionPoint.DEFINES, defineString + "\n"));
 
-		if (FabricLoader.getInstance().isDevelopmentEnvironment()) {
+		if (IrisLogging.ENABLE_SPAM) {
 			System.out.println("Final patched fragment source:");
 			System.out.println(transformations);
 		}

File: src/main/java/net/coderbot/batchedentityrendering/impl/BatchingDebugMessageHelper.java
Patch:
@@ -10,7 +10,7 @@ public static String getDebugMessage(DrawCallTrackingBufferBuilderStorage drawTr
 			float effectiveness = effectivenessTimes10 / 10.0F;
 
 			return drawCalls + " draw calls / " + renderTypes + " render types = "
-					+ effectiveness + "% batching effectiveness)";
+					+ effectiveness + "% effective";
 		} else {
 			return "(no draw calls)";
 		}

File: src/main/java/net/coderbot/iris/shadows/ShadowMapRenderer.java
Patch:
@@ -3,8 +3,11 @@
 import net.coderbot.iris.mixin.WorldRendererAccessor;
 import net.minecraft.client.render.Camera;
 
+import java.util.List;
+
 public interface ShadowMapRenderer {
 	void renderShadows(WorldRendererAccessor worldRenderer, Camera playerCamera);
+	void addDebugText(List<String> messages);
 	int getDepthTextureId();
 	int getDepthTextureNoTranslucentsId();
 	// TODO: Support more shadow color textures as well as support there being no shadow color textures.

File: src/main/java/net/coderbot/batchedentityrendering/mixin/MixinMultiPhaseRenderLayer.java
Patch:
@@ -19,7 +19,7 @@ private MixinMultiPhaseRenderLayer(String name, VertexFormat vertexFormat, int d
 		super(name, vertexFormat, drawMode, expectedBufferSize, hasCrumbling, translucent, startAction, endAction);
 	}
 
-	@Inject(method = "<init>", at = @At("RETURN"))
+	@Inject(method = "<init>(Ljava/lang/String;Lnet/minecraft/client/render/VertexFormat;IIZZLnet/minecraft/client/render/RenderLayer$MultiPhaseParameters;)V", at = @At("RETURN"))
 	private void batchedentityrendering$onMultiPhaseInit(String name, VertexFormat vertexFormat, int drawMode, int expectedBufferSize,
 									   boolean hasCrumbling, boolean translucent, MultiPhaseParameters phases,
 									   CallbackInfo ci) {

File: src/main/java/net/coderbot/iris/mixin/entity_render_context/MixinBlockEntityRenderDispatcher.java
Patch:
@@ -25,7 +25,8 @@ public class MixinBlockEntityRenderDispatcher {
 	private static final String RENDER =
 			"render(Lnet/minecraft/block/entity/BlockEntity;FLnet/minecraft/client/util/math/MatrixStack;Lnet/minecraft/client/render/VertexConsumerProvider;)V";
 
-	private static final String RUN_REPORTED = "runReported(Lnet/minecraft/block/entity/BlockEntity;Ljava/lang/Runnable;)V";
+	private static final String RUN_REPORTED =
+			"net/minecraft/client/render/block/entity/BlockEntityRenderDispatcher.runReported(Lnet/minecraft/block/entity/BlockEntity;Ljava/lang/Runnable;)V";
 
 	// I inject here in the method so that:
 	//

File: src/main/java/net/coderbot/iris/shadows/frustum/fallback/NonCullingFrustum.java
Patch:
@@ -1,4 +1,4 @@
-package net.coderbot.iris.shadows.frustum;
+package net.coderbot.iris.shadows.frustum.fallback;
 
 import net.minecraft.client.render.Frustum;
 import net.minecraft.util.math.Box;

File: src/main/java/net/coderbot/iris/block_rendering/BlockRenderingSettings.java
Patch:
@@ -1,6 +1,7 @@
 package net.coderbot.iris.block_rendering;
 
 import net.coderbot.iris.shaderpack.IdMap;
+import org.jetbrains.annotations.Nullable;
 
 public class BlockRenderingSettings {
 	public static final BlockRenderingSettings INSTANCE = new BlockRenderingSettings();
@@ -27,6 +28,7 @@ public void clearReloadRequired() {
 		reloadRequired = false;
 	}
 
+	@Nullable
 	public IdMap getIdMap() {
 		return idMap;
 	}

File: src/main/java/net/coderbot/iris/layer/EntityRenderPhase.java
Patch:
@@ -9,10 +9,10 @@ public final class EntityRenderPhase extends RenderPhase {
 	public EntityRenderPhase(int entityId) {
 		super("iris:is_entity", () -> {
 			CapturedRenderingState.INSTANCE.setCurrentEntity(entityId);
-			GbufferPrograms.push(GbufferProgram.ENTITIES);
+			GbufferPrograms.beginEntities();
 		}, () -> {
 			CapturedRenderingState.INSTANCE.setCurrentEntity(-1);
-			GbufferPrograms.pop(GbufferProgram.ENTITIES);
+			GbufferPrograms.endEntities();
 		});
 
 		this.entityId = entityId;

File: src/main/java/net/coderbot/batchedentityrendering/impl/FullyBufferedVertexConsumerProvider.java
Patch:
@@ -56,7 +56,9 @@ public FullyBufferedVertexConsumerProvider() {
 		this.unflushableWrapper = new UnflushableWrapper(this);
 
 		// TODO: Eh
-		instance = this;
+		if (instance == null) {
+			instance = this;
+		}
 	}
 
 	@Override

File: src/main/java/net/coderbot/iris/block_rendering/BlockRenderingSettings.java
Patch:
@@ -14,6 +14,7 @@ public class BlockRenderingSettings {
 	public BlockRenderingSettings() {
 		reloadRequired = false;
 		idMap = null;
+		ambientOcclusionLevel = 1.0F;
 		disableDirectionalShading = false;
 		useSeparateAo = false;
 	}

File: src/main/java/net/coderbot/iris/mixin/bettermipmaps/MixinSprite.java
Patch:
@@ -86,7 +86,7 @@ private void fillInTransparentPixelColors(SpriteAtlasTexture spriteAtlasTexture,
 					continue;
 				}
 
-				// Replace the color values of this pixel with the average coolors.
+				// Replace the color values of this pixel with the average colors.
 				image.setPixelColor(x, y, resultColor);
 			}
 		}

File: src/main/java/net/coderbot/iris/compat/physicsmod/PhysicsModHooks.java
Patch:
@@ -10,12 +10,12 @@ public static void redirectEndDrawing(RenderType type) {
 	}
 
 	public static void redirectStartDrawing(RenderType type) {
-		if (type == getTargetRenderLayer()) {
+		if (type == getTargetRenderType()) {
 			GbufferPrograms.pop(GbufferProgram.TEXTURED_LIT);
 		}
 	}
 
-	public static RenderType getTargetRenderLayer() {
+	public static RenderType getTargetRenderType() {
 		return RenderType.cutout();
 	}
 }

File: src/main/java/net/coderbot/iris/fantastic/ExtendedBufferStorage.java
Patch:
@@ -1,6 +1,6 @@
 package net.coderbot.iris.fantastic;
 
 public interface ExtendedBufferStorage {
-	void beginWorldRendering();
-	void endWorldRendering();
+	void beginLevelRendering();
+	void endLevelRendering();
 }

File: src/main/java/net/coderbot/iris/layer/WrappableRenderType.java
Patch:
@@ -4,7 +4,7 @@
 
 public interface WrappableRenderType {
 	/**
-	 * Returns the underlying wrapped RenderLayer. Might return itself if this RenderLayer doesn't wrap anything.
+	 * Returns the underlying wrapped RenderType. Might return itself if this RenderType doesn't wrap anything.
 	 */
 	RenderType unwrap();
 }

File: src/main/java/net/coderbot/iris/mixin/bettermipmaps/MixinMipmapGenerator.java
Patch:
@@ -23,7 +23,7 @@
  * </li>
  */
 @Mixin(MipmapGenerator.class)
-public class MixinMipmapHelper {
+public class MixinMipmapGenerator {
 	// Generate some color tables for gamma correction.
 	private static final float[] SRGB_TO_LINEAR = new float[256];
 

File: src/main/java/net/coderbot/iris/mixin/fantastic/MixinRenderBuffers.java
Patch:
@@ -42,12 +42,12 @@ public class MixinRenderBuffers implements ExtendedBufferStorage {
 	private int begins = 0;
 
 	@Override
-	public void beginWorldRendering() {
+	public void beginLevelRendering() {
 		begins += 1;
 	}
 
 	@Override
-	public void endWorldRendering() {
+	public void endLevelRendering() {
 		begins -= 1;
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/fabulous/MixinOption.java
Patch:
@@ -12,7 +12,7 @@
 @Environment(EnvType.CLIENT)
 @Mixin(Option.class)
 public class MixinOption {
-	@Redirect(method = "lambda$static$65", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/platform/GlStateManager;supportsFramebufferBlit()Z"))
+	@Redirect(method = {"lambda$static$65", "method_18554"}, at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/platform/GlStateManager;supportsFramebufferBlit()Z", remap = true), remap = false)
 	private static boolean iris$onAttemptedToSelectFabulousGraphics() {
 		// Returning false here will cause Minecraft to cycle between Fancy and Fast, disabling Fabulous graphics
 		if(!Iris.getIrisConfig().areShadersEnabled()) {

File: src/headers/java/com/terraformersmc/modmenu/api/ConfigScreenFactory.java
Patch:
@@ -24,7 +24,7 @@
 
 package com.terraformersmc.modmenu.api;
 
-import net.minecraft.client.gui.screen.Screen;
+import net.minecraft.client.gui.screens.Screen;
 
 @FunctionalInterface
 @SuppressWarnings("deprecation")

File: src/headers/java/io/github/prospector/modmenu/api/ConfigScreenFactory.java
Patch:
@@ -24,7 +24,8 @@
 
 package io.github.prospector.modmenu.api;
 
-import net.minecraft.client.gui.screen.Screen;
+
+import net.minecraft.client.gui.screens.Screen;
 
 /**
  * Deprecated interface, switch to {@link com.terraformersmc.modmenu.api.ModMenuApi} and {@link com.terraformersmc.modmenu.api.ConfigScreenFactory} instead

File: src/main/java/net/coderbot/iris/mixin/MixinLivingEntityRenderer.java
Patch:
@@ -21,7 +21,7 @@ public abstract class MixinLivingEntityRenderer {
 	private MultiBufferSource iris$wrapProvider(MultiBufferSource provider, LivingEntity entity, float yaw, float tickDelta, PoseStack matrices, MultiBufferSource vertexConsumers, int light) {
 		boolean hurt;
 		if(Iris.isPhysicsModInstalled()) {
-			hurt = entity.hurtTime > 0 && !entity.isDead();
+			hurt = entity.hurtTime > 0 && !entity.isDeadOrDying();
 		} else {
 			hurt = entity.hurtTime > 0 || entity.deathTime > 0;
 		}

File: src/main/java/net/coderbot/iris/mixin/fabulous/MixinOption.java
Patch:
@@ -12,7 +12,7 @@
 @Environment(EnvType.CLIENT)
 @Mixin(Option.class)
 public class MixinOption {
-	//@Redirect(method = "method_18554", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/platform/GlStateManager;supportsFramebufferBlit()Z"))
+	@Redirect(method = "lambda$static$65", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/platform/GlStateManager;supportsFramebufferBlit()Z"))
 	private static boolean iris$onAttemptedToSelectFabulousGraphics() {
 		// Returning false here will cause Minecraft to cycle between Fancy and Fast, disabling Fabulous graphics
 		if(!Iris.getIrisConfig().areShadersEnabled()) {

File: src/main/java/net/coderbot/iris/mixin/MixinDebugScreenOverlay.java
Patch:
@@ -55,7 +55,7 @@ private void appendShaderPackText(CallbackInfoReturnable<List<String>> cir) {
 
 		messages.add(3, "Direct Buffers: +" + humanReadableByteCountBin(directPool.getMemoryUsed()));
 
-		if (!FabricLoader.getInstance().isModLoaded("sodium")) {
+		if (!Iris.isSodiumInstalled()) {
 			messages.add(3, "Native Memory: +" + humanReadableByteCountBin(getNativeMemoryUsage()));
 		}
 	}
@@ -64,7 +64,7 @@ private void appendShaderPackText(CallbackInfoReturnable<List<String>> cir) {
 	private void appendShadowDebugText(CallbackInfoReturnable<List<String>> cir) {
 		List<String> messages = cir.getReturnValue();
 
-		if (!FabricLoader.getInstance().isModLoaded("sodium") && Iris.getCurrentPack().isPresent()) {
+		if (!Iris.isSodiumInstalled() && Iris.getCurrentPack().isPresent()) {
 			messages.add(1, ChatFormatting.YELLOW + "[Iris] Sodium isn't installed; you will have poor performance.");
 			messages.add(2, ChatFormatting.YELLOW + "[Iris] Install the compatible Sodium fork if you want to run benchmarks or get higher FPS!");
 		}

File: src/main/java/net/coderbot/iris/mixin/gui/MixinGui.java
Patch:
@@ -34,7 +34,7 @@ public class MixinGui {
 	// TODO: Move this to a more appropriate mixin
 	@Inject(method = "render", at = @At("RETURN"))
 	public void iris$displayBigSodiumWarning(PoseStack matrices, float tickDelta, CallbackInfo ci) {
-		if (FabricLoader.getInstance().isModLoaded("sodium")
+		if (Iris.isSodiumInstalled()
 				|| Minecraft.getInstance().options.renderDebug
 				|| !Iris.getCurrentPack().isPresent()) {
 			return;

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -245,9 +245,9 @@ private static boolean loadExternalShaderpack(String name) {
 
 		try {
 			currentPack = new ShaderPack(shaderPackPath);
-		} catch (IOException e) {
+		} catch (Exception e) {
 			logger.error("Failed to load the shaderpack \"{}\"!", name);
-			logger.error(e);
+			logger.catching(e);
 
 			return false;
 		}

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -207,7 +207,7 @@ private static boolean loadExternalShaderpack(String name) {
 
 			try {
 				optionalPath = loadExternalZipShaderpack(shaderPackRoot);
-			} catch (FileSystemNotFoundException e) {
+			} catch (FileSystemNotFoundException | NoSuchFileException e) {
 				logger.error("Failed to load the shaderpack \"{}\" because it does not exist in your shaderpacks folder!", name);
 
 				return false;

File: src/main/java/net/coderbot/iris/config/IrisConfig.java
Patch:
@@ -103,6 +103,7 @@ public void load() throws IOException {
 		}
 
 		Properties properties = new Properties();
+		// NB: This uses ISO-8859-1 with unicode escapes as the encoding
 		properties.load(Files.newInputStream(propertiesPath));
 		shaderPackName = properties.getProperty("shaderPack");
 		enableShaders = !"false".equals(properties.getProperty("enableShaders"));
@@ -123,6 +124,7 @@ public void save() throws IOException {
 		Properties properties = new Properties();
 		properties.setProperty("shaderPack", getShaderPackName().orElse(""));
 		properties.setProperty("enableShaders", enableShaders ? "true" : "false");
+		// NB: This uses ISO-8859-1 with unicode escapes as the encoding
 		properties.store(Files.newOutputStream(propertiesPath), COMMENT);
 	}
 }

File: src/main/java/net/coderbot/iris/gl/program/ProgramBuilder.java
Patch:
@@ -27,8 +27,6 @@ public class ProgramBuilder extends ProgramUniforms.Builder implements SamplerHo
 		.defineAll(StandardMacros.getGlExtensions())
 		.build();
 
-
-
 	private final int program;
 	private ProgramSamplers.Builder samplers;
 
@@ -62,7 +60,7 @@ public static ProgramBuilder begin(String name, @Nullable String vertexSource, @
 		fragment = buildShader(ShaderType.FRAGMENT, name + ".fsh", fragmentSource);
 
 		int programId;
-		
+
 		if (geometry != null) {
 			programId = ProgramCreator.create(name, vertex, geometry, fragment);
 		} else {

File: src/main/java/net/coderbot/iris/mixin/MixinGameRenderer.java
Patch:
@@ -21,8 +21,6 @@
 @Mixin(GameRenderer.class)
 @Environment(EnvType.CLIENT)
 public class MixinGameRenderer {
-	// TODO: This probably won't be compatible with mods that directly mess with the GL projection matrix.
-	// https://github.com/jellysquid3/sodium-fabric/blob/1df506fd39dac56bb410725c245e6e51208ec732/src/main/java/me/jellysquid/mods/sodium/client/render/chunk/shader/ChunkProgram.java#L56
 	@Inject(method = "<init>", at = @At("TAIL"))
 	private void iris$logSystem(Minecraft client, ResourceManager resourceManager, RenderBuffers bufferBuilderStorage, CallbackInfo ci) {
 		Iris.logger.info("Hardware information:");
@@ -31,6 +29,8 @@ public class MixinGameRenderer {
 		Iris.logger.info("OS: " + System.getProperty("os.name"));
 	}
 
+	// TODO: This probably won't be compatible with mods that directly mess with the GL projection matrix.
+	// https://github.com/jellysquid3/sodium-fabric/blob/1df506fd39dac56bb410725c245e6e51208ec732/src/main/java/me/jellysquid/mods/sodium/client/render/chunk/shader/ChunkProgram.java#L56
 	@Inject(method = "resetProjectionMatrix", at = @At("HEAD"))
 	private void iris$captureProjectionMatrix(Matrix4f projectionMatrix, CallbackInfo callback) {
 		CapturedRenderingState.INSTANCE.setGbufferProjection(projectionMatrix);

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderer.java
Patch:
@@ -200,6 +200,8 @@ private Program createProgram(ProgramSource source, ImmutableSet<Integer> flippe
 			IrisSamplers.addShadowSamplers(builder, shadowMapRendererSupplier.get());
 		}
 
+		// TODO: Don't duplicate this with FinalPassRenderer
+		// TODO: Parse the value of const float centerDepthSmoothHalflife from the shaderpack's fragment shader configuration
 		builder.uniform1f(UniformUpdateFrequency.PER_FRAME, "centerDepthSmooth", this.centerDepthSampler::getCenterDepthSmoothSample);
 
 		return builder.build();

File: src/main/java/net/coderbot/iris/postprocess/FinalPassRenderer.java
Patch:
@@ -238,6 +238,8 @@ private Program createProgram(ProgramSource source, ImmutableSet<Integer> flippe
 			IrisSamplers.addShadowSamplers(builder, shadowMapRendererSupplier.get());
 		}
 
+		// TODO: Don't duplicate this with CompositeRenderer
+		// TODO: Parse the value of const float centerDepthSmoothHalflife from the shaderpack's fragment shader configuration
 		builder.uniform1f(UniformUpdateFrequency.PER_FRAME, "centerDepthSmooth", this.centerDepthSampler::getCenterDepthSmoothSample);
 
 		return builder.build();

File: src/main/java/net/coderbot/iris/shaderpack/IdMap.java
Patch:
@@ -44,7 +44,7 @@ public class IdMap {
 	private final Object2IntMap<ResourceLocation> entityIdMap;
 
 	/**
-	 * A map that contains the identifier of an item to the integer value parsed in block.properties
+	 * Maps block states to block ids defined in block.properties
 	 */
 	private Object2IntMap<BlockState> blockPropertiesMap;
 
@@ -93,6 +93,8 @@ private static Optional<Properties> loadProperties(Path shaderPath, String name)
 		StringReader propertiesReader = new StringReader(processed);
 		Properties properties = new Properties();
 		try {
+			// NB: ID maps are specified to be encoded with ISO-8859-1 by OptiFine,
+			//     so we don't need to do the UTF-8 workaround here.
 			properties.load(propertiesReader);
 		} catch (IOException e) {
 			Iris.logger.error("Error loading " + name + " at " + shaderPath);

File: src/main/java/net/coderbot/iris/uniforms/CameraUniforms.java
Patch:
@@ -10,7 +10,7 @@
 import net.minecraft.world.phys.Vec3;
 
 /**
- * @see <a href="https://github.com/IrisShaders/ShaderDoc/blob/master/uniforms.md#celestial-bodies">Uniforms: Camera</a>
+ * @see <a href="https://github.com/IrisShaders/ShaderDoc/blob/master/uniforms.md#camera">Uniforms: Camera</a>
  */
 public class CameraUniforms {
 	private static final Minecraft client = Minecraft.getInstance();

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -84,16 +84,18 @@ public static void generalCommonUniforms(UniformHolder uniforms, FrameUpdateNoti
 			.uniform1f(PER_FRAME, "screenBrightness", () -> client.options.gamma)
 			.uniform1f(PER_TICK, "playerMood", CommonUniforms::getPlayerMood)
 			.uniform2i(PER_FRAME, "eyeBrightness", CommonUniforms::getEyeBrightness)
+			// TODO: Parse the value of const float eyeBrightnessHalflife from the shaderpack's fragment shader configuration
 			.uniform2i(PER_FRAME, "eyeBrightnessSmooth", new SmoothedVec2f(10.0f, CommonUniforms::getEyeBrightness, updateNotifier))
 			.uniform1f(PER_TICK, "rainStrength", CommonUniforms::getRainStrength)
+			// TODO: Parse the value of const float wetnessHalfLife and const float drynessHalfLife from the shaderpack's fragment shader configuration
 			.uniform1f(PER_TICK, "wetness", new SmoothedFloat(600f, CommonUniforms::getRainStrength, updateNotifier))
 			.uniform3d(PER_FRAME, "skyColor", CommonUniforms::getSkyColor)
 			.uniform3d(PER_FRAME, "fogColor", CapturedRenderingState.INSTANCE::getFogColor)
 			.uniform2i(ONCE, "atlasSize", CommonUniforms::getAtlasSize);
 	}
 
 	private static Vec2 getAtlasSize() {
-		//TODO: is the block atlas used for this uniform all the time???
+		// TODO: is the block atlas used for this uniform all the time???
 		return ((TextureAtlasInterface) Minecraft.getInstance().getModelManager().getAtlas(TextureAtlas.LOCATION_BLOCKS)).getAtlasSize();
 	}
 

File: src/main/java/net/coderbot/iris/gl/program/ProgramBuilder.java
Patch:
@@ -27,8 +27,6 @@ public class ProgramBuilder extends ProgramUniforms.Builder implements SamplerHo
 		.defineAll(StandardMacros.getGlExtensions())
 		.build();
 
-
-
 	private final int program;
 	private ProgramSamplers.Builder samplers;
 
@@ -62,7 +60,7 @@ public static ProgramBuilder begin(String name, @Nullable String vertexSource, @
 		fragment = buildShader(ShaderType.FRAGMENT, name + ".fsh", fragmentSource);
 
 		int programId;
-		
+
 		if (geometry != null) {
 			programId = ProgramCreator.create(name, vertex, geometry, fragment);
 		} else {

File: src/main/java/net/coderbot/iris/shaderpack/ShaderPack.java
Patch:
@@ -121,10 +121,10 @@ private Map<String, Map<String, String>> parseLangEntries(Path root) throws IOEx
 		if (!Files.exists(langFolderPath)) {
 			return allLanguagesMap;
 		}
-		//We are using a max depth of one to ensure we only get the surface level *files* without going deeper
+		// We are using a max depth of one to ensure we only get the surface level *files* without going deeper
 		// we also want to avoid any directories while filtering
-		//Basically, we want the immediate files nested in the path for the langFolder
-		//There is also Files.list which can be used for similar behavior
+		// Basically, we want the immediate files nested in the path for the langFolder
+		// There is also Files.list which can be used for similar behavior
 		Files.walk(langFolderPath, 1).filter(path -> !Files.isDirectory(path)).forEach(path -> {
 
 			Map<String, String> currentLanguageMap = new HashMap<>();

File: src/main/java/net/coderbot/iris/mixin/fabulous/MixinOption.java
Patch:
@@ -17,7 +17,7 @@ public class MixinOption {
 	@Redirect(method = "method_18554", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/platform/GlStateManager;supportsGl30()Z"))
 	private static boolean iris$onAttemptedToSelectFabulousGraphics() {
 		// Returning false here will cause Minecraft to cycle between Fancy and Fast, disabling Fabulous graphics
-		if(!Iris.getIrisConfig().areShadersEnabled()) {
+		if (!Iris.getIrisConfig().areShadersEnabled()) {
 			return GlStateManager.supportsGl30();
 		}
 		return false;

File: src/main/java/net/coderbot/iris/mixin/MixinGameRenderer.java
Patch:
@@ -23,8 +23,6 @@
 @Mixin(GameRenderer.class)
 @Environment(EnvType.CLIENT)
 public class MixinGameRenderer {
-	// TODO: This probably won't be compatible with mods that directly mess with the GL projection matrix.
-	// https://github.com/jellysquid3/sodium-fabric/blob/1df506fd39dac56bb410725c245e6e51208ec732/src/main/java/me/jellysquid/mods/sodium/client/render/chunk/shader/ChunkProgram.java#L56
 	@Inject(method = "<init>", at = @At("TAIL"))
 	private void iris$logSystem(MinecraftClient client, ResourceManager resourceManager, BufferBuilderStorage bufferBuilderStorage, CallbackInfo ci) {
 		Iris.logger.info("Hardware information:");
@@ -33,6 +31,8 @@ public class MixinGameRenderer {
 		Iris.logger.info("OS: " + System.getProperty("os.name"));
 	}
 
+	// TODO: This probably won't be compatible with mods that directly mess with the GL projection matrix.
+	// https://github.com/jellysquid3/sodium-fabric/blob/1df506fd39dac56bb410725c245e6e51208ec732/src/main/java/me/jellysquid/mods/sodium/client/render/chunk/shader/ChunkProgram.java#L56
 	@Inject(method = "loadProjectionMatrix(Lnet/minecraft/util/math/Matrix4f;)V", at = @At("HEAD"))
 	private void iris$captureProjectionMatrix(Matrix4f projectionMatrix, CallbackInfo callback) {
 		CapturedRenderingState.INSTANCE.setGbufferProjection(projectionMatrix);

File: src/main/java/net/coderbot/iris/texunits/TextureUnit.java
Patch:
@@ -5,8 +5,7 @@
 public enum TextureUnit {
 	TERRAIN(0),
 	LIGHTMAP(1),
-	// TODO: Relocate this to a different texture unit, this is used by depthtex0...
-	OVERLAY(6);
+	OVERLAY(2);
 
 	private final int samplerId;
 	private final int unitId;

File: src/main/java/net/coderbot/iris/shaderpack/ShaderProperties.java
Patch:
@@ -110,7 +110,7 @@ public ShaderProperties(Properties properties) {
 
 			handlePassDirective("alphaTest.", key, value, pass -> {
 				if ("off".equals(value)) {
-					alphaTestOverrides.put(pass, new AlphaTest.Off());
+					alphaTestOverrides.put(pass, AlphaTest.ALWAYS);
 					return;
 				}
 

File: src/main/java/net/coderbot/iris/mixin/MixinGlUniform.java
Patch:
@@ -34,7 +34,7 @@ public final void set(float x, float y) {
 	@Unique
 	private boolean isScreenSize;
 
-	@Inject(method = "<init>()V", at = @At("RETURN"))
+	@Inject(method = "<init>(Ljava/lang/String;IILnet/minecraft/client/gl/GlShader;)V", at = @At("RETURN"))
 	private void iris$onInit(String name, int dataType, int count, GlShader program, CallbackInfo ci) {
 		isScreenSize = "ScreenSize".equals(name) || "iris_ScreenSize".equals(name);
 	}

File: src/main/java/net/coderbot/iris/pipeline/newshader/TriforcePatcher.java
Patch:
@@ -88,14 +88,14 @@ public static String patch(String source, ShaderType type, AlphaTest alpha, bool
 				transformations.define("gl_MultiTexCoord0", "vec4(UV0, 0.0, 1.0)");
 				transformations.injectLine(Transformations.InjectionPoint.BEFORE_CODE, "in vec2 UV0;");
 			} else {
-				transformations.define("gl_MultiTexCoord0", "vec4(0.0, 0.0, 0.0, 1.0)");
+				transformations.define("gl_MultiTexCoord0", "vec4(0.5, 0.5, 0.0, 1.0)");
 			}
 
 			if (inputs.hasLight()) {
 				transformations.define("gl_MultiTexCoord1", "vec4(UV2, 0.0, 1.0)");
 				transformations.injectLine(Transformations.InjectionPoint.BEFORE_CODE, "in ivec2 UV2;");
 			} else {
-				transformations.define("gl_MultiTexCoord1", "vec4(0.0, 0.0, 0.0, 1.0)");
+				transformations.define("gl_MultiTexCoord1", "vec4(240.0, 240.0, 0.0, 1.0)");
 			}
 
 			// gl_MultiTexCoord0 and gl_MultiTexCoord1 are the only valid inputs, other texture coordinates are not valid inputs.

File: src/main/java/net/coderbot/iris/pipeline/newshader/CoreWorldRenderingPipeline.java
Patch:
@@ -28,6 +28,8 @@ public interface CoreWorldRenderingPipeline extends WorldRenderingPipeline {
 	Shader getShadowEntitiesCutout();
 	Shader getTranslucent();
 	Shader getGlint();
+	Shader getLines();
+	Shader getShadowLines();
 	WorldRenderingPhase getPhase();
 	FrameUpdateNotifier getUpdateNotifier();
 	void destroy();

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -92,6 +92,8 @@ public static ExtendedShader create(String name, ProgramSource source, GlFramebu
 				"        { \"name\": \"iris_ColorModulator\", \"type\": \"float\", \"count\": 4, \"values\": [ 1.0, 1.0, 1.0, 1.0 ] },\n" +
 				"        { \"name\": \"iris_FogStart\", \"type\": \"float\", \"count\": 1, \"values\": [ 0.0 ] },\n" +
 				"        { \"name\": \"iris_FogEnd\", \"type\": \"float\", \"count\": 1, \"values\": [ 1.0 ] },\n" +
+				"        { \"name\": \"iris_LineWidth\", \"type\": \"float\", \"count\": 1, \"values\": [ 1.0 ] },\n" +
+				"        { \"name\": \"iris_ScreenSize\", \"type\": \"float\", \"count\": 2, \"values\": [ 1.0, 1.0 ] },\n" +
 				"        { \"name\": \"iris_FogColor\", \"type\": \"float\", \"count\": 4, \"values\": [ 0.0, 0.0, 0.0, 0.0 ] }\n" +
 				"    ]\n" +
 				"}";

File: src/main/java/net/coderbot/iris/compat/physicsmod/PhysicsModHooks.java
Patch:
@@ -5,12 +5,12 @@
 import net.minecraft.client.renderer.RenderType;
 
 public class PhysicsModHooks {
-	public static void redirectEndDrawing(RenderType layer) {
+	public static void redirectEndDrawing(RenderType type) {
 		GbufferPrograms.push(GbufferProgram.TEXTURED_LIT);
 	}
 
-	public static void redirectStartDrawing(RenderType layer) {
-		if (layer == getTargetRenderLayer()) {
+	public static void redirectStartDrawing(RenderType type) {
+		if (type == getTargetRenderLayer()) {
 			GbufferPrograms.pop(GbufferProgram.TEXTURED_LIT);
 		}
 	}

File: src/main/java/net/coderbot/iris/layer/InnerWrappedRenderType.java
Patch:
@@ -76,7 +76,7 @@ public String toString() {
 		return "iris_wrapped:" + this.wrapped.toString();
 	}
 
-	private static boolean isTranslucent(RenderType layer) {
-		return ((RenderTypeAccessor) layer).isTranslucent();
+	private static boolean isTranslucent(RenderType type) {
+		return ((RenderTypeAccessor) type).isTranslucent();
 	}
 }

File: src/main/java/net/coderbot/iris/layer/IrisRenderTypeWrapper.java
Patch:
@@ -75,7 +75,7 @@ public String toString() {
 		return "iris:" + this.wrapped.toString();
 	}
 
-	private static boolean isTranslucent(RenderType layer) {
-		return ((RenderTypeAccessor) layer).isTranslucent();
+	private static boolean isTranslucent(RenderType type) {
+		return ((RenderTypeAccessor) type).isTranslucent();
 	}
 }

File: src/main/java/net/coderbot/iris/layer/OuterWrappedRenderType.java
Patch:
@@ -76,7 +76,7 @@ public String toString() {
 		return "iris_wrapped:" + this.wrapped.toString();
 	}
 
-	private static boolean isTranslucent(RenderType layer) {
-		return ((RenderTypeAccessor) layer).isTranslucent();
+	private static boolean isTranslucent(RenderType type) {
+		return ((RenderTypeAccessor) type).isTranslucent();
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/MixinTntMinecartRenderer.java
Patch:
@@ -16,7 +16,7 @@ public abstract class MixinTntMinecartRenderer {
 	private static MultiBufferSource iris$wrapProvider(MultiBufferSource provider, BlockState blockState, PoseStack matrices, MultiBufferSource vertexConsumers, int light, boolean drawFlash) {
 		if (drawFlash) {
 			EntityColorRenderState phase = new EntityColorRenderState(false, 1.0F);
-			return layer -> provider.getBuffer(new InnerWrappedRenderType("iris_entity_color", layer, phase));
+			return type -> provider.getBuffer(new InnerWrappedRenderType("iris_entity_color", type, phase));
 		} else {
 			return provider;
 		}

File: src/main/java/net/coderbot/iris/mixin/fantastic/MixinRenderBuffers.java
Patch:
@@ -21,8 +21,8 @@ public class MixinRenderBuffers implements ExtendedBufferStorage {
 	private SortedMap<RenderType, BufferBuilder> fixedBuffers;
 
 	@Unique
-	private static void iris$assignBufferBuilder(SortedMap<RenderType, BufferBuilder> builderStorage, RenderType layer) {
-		builderStorage.put(layer, new BufferBuilder(layer.bufferSize()));
+	private static void iris$assignBufferBuilder(SortedMap<RenderType, BufferBuilder> builderStorage, RenderType type) {
+		builderStorage.put(type, new BufferBuilder(type.bufferSize()));
 	}
 
 	@Inject(method = "<init>()V", at = @At("RETURN"))

File: src/main/java/net/coderbot/iris/mixin/shadows/MixinBeaconRenderer.java
Patch:
@@ -14,7 +14,7 @@
 public class MixinBeaconRenderer {
 	@Inject(method = "renderBeaconBeam(Lcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/client/renderer/MultiBufferSource;Lnet/minecraft/resources/ResourceLocation;FFJII[FFF)V",
 	        at = @At("HEAD"), cancellable = true)
-	private static void iris$noLightBeamInShadowPass(PoseStack matrixStack, MultiBufferSource vertexConsumerProvider,
+	private static void iris$noLightBeamInShadowPass(PoseStack poseStack, MultiBufferSource vertexConsumerProvider,
 													 ResourceLocation identifier, float f, float g, long l, int i, int j,
 													 float[] fs, float h, float k, CallbackInfo ci) {
 		if (ShadowRenderingState.areShadowsCurrentlyBeingRendered()) {

File: src/main/java/net/coderbot/iris/mixin/vertices/block_rendering/MixinChunkRebuildTask.java
Patch:
@@ -55,7 +55,7 @@ private short resolveBlockId(BlockState state) {
 	}
 
 	@Inject(method = "compile", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/renderer/block/BlockRenderDispatcher;renderLiquid(Lnet/minecraft/core/BlockPos;Lnet/minecraft/world/level/BlockAndTintGetter;Lcom/mojang/blaze3d/vertex/VertexConsumer;Lnet/minecraft/world/level/material/FluidState;)Z"), locals = LocalCapture.CAPTURE_FAILHARD)
-	private void iris$onRenderFluid(float cameraX, float cameraY, float cameraZ, ChunkRenderDispatcher.CompiledChunk data, ChunkBufferBuilderPack buffers, CallbackInfoReturnable<Set> cir, int i, BlockPos blockPos, BlockPos blockPos2, VisGraph chunkOcclusionDataBuilder, Set set, RenderChunkRegion chunkRendererRegion, PoseStack matrixStack, Random random, BlockRenderDispatcher blockRenderManager, Iterator var15, BlockPos blockPos3, BlockState blockState, FluidState fluidState, RenderType renderLayer, BufferBuilder bufferBuilder) {
+	private void iris$onRenderFluid(float cameraX, float cameraY, float cameraZ, ChunkRenderDispatcher.CompiledChunk data, ChunkBufferBuilderPack buffers, CallbackInfoReturnable<Set> cir, int i, BlockPos blockPos, BlockPos blockPos2, VisGraph chunkOcclusionDataBuilder, Set set, RenderChunkRegion chunkRendererRegion, PoseStack poseStack, Random random, BlockRenderDispatcher blockRenderManager, Iterator var15, BlockPos blockPos3, BlockState blockState, FluidState fluidState, RenderType renderType, BufferBuilder bufferBuilder) {
 		if (bufferBuilder instanceof BlockSensitiveBufferBuilder) {
 			lastBufferBuilder = ((BlockSensitiveBufferBuilder) bufferBuilder);
 			// All fluids have a ShadersMod render type of 1, to match behavior of Minecraft 1.7 and earlier.
@@ -72,7 +72,7 @@ private short resolveBlockId(BlockState state) {
 	}
 
 	@Inject(method = "compile", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/renderer/block/BlockRenderDispatcher;renderBatched(Lnet/minecraft/world/level/block/state/BlockState;Lnet/minecraft/core/BlockPos;Lnet/minecraft/world/level/BlockAndTintGetter;Lcom/mojang/blaze3d/vertex/PoseStack;Lcom/mojang/blaze3d/vertex/VertexConsumer;ZLjava/util/Random;)Z"), locals = LocalCapture.CAPTURE_FAILHARD)
-	private void iris$onRenderBlock(float cameraX, float cameraY, float cameraZ, ChunkRenderDispatcher.CompiledChunk data, ChunkBufferBuilderPack buffers, CallbackInfoReturnable<Set> cir, int i, BlockPos blockPos, BlockPos blockPos2, VisGraph chunkOcclusionDataBuilder, Set set, RenderChunkRegion chunkRendererRegion, PoseStack matrixStack, Random random, BlockRenderDispatcher blockRenderManager, Iterator var15, BlockPos blockPos3, BlockState blockState, RenderType renderLayer2, BufferBuilder bufferBuilder) {
+	private void iris$onRenderBlock(float cameraX, float cameraY, float cameraZ, ChunkRenderDispatcher.CompiledChunk data, ChunkBufferBuilderPack buffers, CallbackInfoReturnable<Set> cir, int i, BlockPos blockPos, BlockPos blockPos2, VisGraph chunkOcclusionDataBuilder, Set set, RenderChunkRegion chunkRendererRegion, PoseStack poseStack, Random random, BlockRenderDispatcher blockRenderManager, Iterator var15, BlockPos blockPos3, BlockState blockState, RenderType renderType2, BufferBuilder bufferBuilder) {
 		if (bufferBuilder instanceof BlockSensitiveBufferBuilder) {
 			lastBufferBuilder = ((BlockSensitiveBufferBuilder) bufferBuilder);
 			// TODO: Resolve render types for normal blocks?

File: src/main/java/net/coderbot/iris/fantastic/FantasticVertexConsumerProvider.java
Patch:
@@ -1,6 +1,6 @@
 package net.coderbot.iris.fantastic;
 
-import net.coderbot.iris.layer.IrisRenderLayerWrapper;
+import net.coderbot.iris.layer.IrisRenderTypeWrapper;
 import net.minecraft.client.renderer.MultiBufferSource;
 import net.minecraft.client.renderer.RenderType;
 import com.mojang.blaze3d.vertex.BufferBuilder;
@@ -24,8 +24,8 @@ private boolean isTransparent(RenderType layer) {
 			return true;
 		}
 
-		if (layer instanceof IrisRenderLayerWrapper) {
-			IrisRenderLayerWrapper wrapped = (IrisRenderLayerWrapper) layer;
+		if (layer instanceof IrisRenderTypeWrapper) {
+			IrisRenderTypeWrapper wrapped = (IrisRenderTypeWrapper) layer;
 			layer = wrapped.unwrap();
 		}
 

File: src/main/java/net/coderbot/iris/layer/IsBlockEntityRenderState.java
Patch:
@@ -2,10 +2,10 @@
 
 import net.minecraft.client.renderer.RenderStateShard;
 
-public class IsBlockEntityRenderPhase extends RenderStateShard {
-	public static final IsBlockEntityRenderPhase INSTANCE = new IsBlockEntityRenderPhase();
+public class IsBlockEntityRenderState extends RenderStateShard {
+	public static final IsBlockEntityRenderState INSTANCE = new IsBlockEntityRenderState();
 
-	private IsBlockEntityRenderPhase() {
+	private IsBlockEntityRenderState() {
 		super("iris:is_block_entity", GbufferPrograms::beginBlockEntities, GbufferPrograms::endBlockEntities);
 	}
 }

File: src/main/java/net/coderbot/iris/layer/IsEntityRenderState.java
Patch:
@@ -2,10 +2,10 @@
 
 import net.minecraft.client.renderer.RenderStateShard;
 
-public class IsEntityRenderPhase extends RenderStateShard {
-	public static final IsEntityRenderPhase INSTANCE = new IsEntityRenderPhase();
+public class IsEntityRenderState extends RenderStateShard {
+	public static final IsEntityRenderState INSTANCE = new IsEntityRenderState();
 
-	private IsEntityRenderPhase() {
+	private IsEntityRenderState() {
 		super("iris:is_entity", GbufferPrograms::beginEntities, GbufferPrograms::endEntities);
 	}
 }

File: src/main/java/net/coderbot/iris/layer/UseProgramRenderState.java
Patch:
@@ -3,10 +3,10 @@
 import java.util.Objects;
 import net.minecraft.client.renderer.RenderStateShard;
 
-public class UseProgramRenderPhase extends RenderStateShard {
+public class UseProgramRenderState extends RenderStateShard {
 	private GbufferProgram program;
 
-	public UseProgramRenderPhase(GbufferProgram program) {
+	public UseProgramRenderState(GbufferProgram program) {
 		super("iris:use_program", () -> GbufferPrograms.push(program), () -> GbufferPrograms.pop(program));
 
 		this.program = program;
@@ -22,7 +22,7 @@ public boolean equals(Object object) {
 			return false;
 		}
 
-		UseProgramRenderPhase other = (UseProgramRenderPhase) object;
+		UseProgramRenderState other = (UseProgramRenderState) object;
 
 		return Objects.equals(this.program, other.program);
 	}

File: src/main/java/net/coderbot/iris/layer/WrappableRenderType.java
Patch:
@@ -2,7 +2,7 @@
 
 import net.minecraft.client.renderer.RenderType;
 
-public interface WrappableRenderLayer {
+public interface WrappableRenderType {
 	/**
 	 * Returns the underlying wrapped RenderLayer. Might return itself if this RenderLayer doesn't wrap anything.
 	 */

File: src/main/java/net/coderbot/iris/mixin/MixinEntityRenderDispatcher.java
Patch:
@@ -21,7 +21,7 @@ public class MixinEntityRenderDispatcher {
 
 	@Inject(method = RENDER_SHADOW, at = @At("HEAD"), cancellable = true)
 	private static void iris$maybeSuppressEntityShadow(PoseStack matrices, MultiBufferSource vertexConsumers,
-													   Entity entity, float opacity, float tickDelta, LevelReader world,
+													   Entity entity, float opacity, float tickDelta, LevelReader level,
 													   float radius, CallbackInfo ci) {
 		if (Iris.getPipelineManager().getPipeline().shouldDisableVanillaEntityShadows()) {
 			ci.cancel();

File: src/main/java/net/coderbot/iris/mixin/MixinFogRenderer.java
Patch:
@@ -14,7 +14,7 @@
 public class MixinFogRenderer {
 	@Shadow private static float fogRed, fogGreen, fogBlue;
 	@Inject(method = "setupColor", at = @At("TAIL"))
-	private static void render(Camera camera, float tickDelta, ClientLevel world, int i, float f, CallbackInfo ci) {
+	private static void render(Camera camera, float tickDelta, ClientLevel level, int i, float f, CallbackInfo ci) {
 		CapturedRenderingState.INSTANCE.setFogColor(fogRed, fogGreen, fogBlue);
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/fantastic/MixinBarrierParticle.java
Patch:
@@ -21,13 +21,13 @@ public class MixinBarrierParticle {
 	private boolean isOpaque;
 
 	@Inject(method = "<init>", at = @At("RETURN"))
-	private void iris$resolveTranslucency(ClientLevel world, double x, double y, double z, ItemLike itemConvertible, CallbackInfo ci) {
+	private void iris$resolveTranslucency(ClientLevel level, double x, double y, double z, ItemLike itemConvertible, CallbackInfo ci) {
 		if (itemConvertible instanceof BlockItem) {
 			BlockItem blockItem = (BlockItem) itemConvertible;
 
-			RenderType layer = ItemBlockRenderTypes.getChunkRenderType(blockItem.getBlock().defaultBlockState());
+			RenderType type = ItemBlockRenderTypes.getChunkRenderType(blockItem.getBlock().defaultBlockState());
 
-			if (layer == RenderType.solid() || layer == RenderType.cutout() || layer == RenderType.cutoutMipped()) {
+			if (type == RenderType.solid() || type == RenderType.cutout() || type == RenderType.cutoutMipped()) {
 				isOpaque = true;
 			}
 		}

File: src/main/java/net/coderbot/iris/mixin/fantastic/MixinFireworkSparkParticle.java
Patch:
@@ -8,8 +8,8 @@
 
 @Mixin(targets = "net.minecraft.client.particle.FireworksSparkParticle$Explosion")
 public class MixinFireworkSparkParticle extends SimpleAnimatedParticle {
-	private MixinFireworkSparkParticle(ClientLevel world, double x, double y, double z, SpriteSet spriteProvider, float upwardsAcceleration) {
-		super(world, x, y, z, spriteProvider, upwardsAcceleration);
+	private MixinFireworkSparkParticle(ClientLevel level, double x, double y, double z, SpriteSet spriteProvider, float upwardsAcceleration) {
+		super(level, x, y, z, spriteProvider, upwardsAcceleration);
 	}
 
 	@Override

File: src/main/java/net/coderbot/iris/mixin/fantastic/MixinTerrainParticle.java
Patch:
@@ -20,10 +20,10 @@ public class MixinTerrainParticle {
 	private boolean isOpaque;
 
 	@Inject(method = "<init>", at = @At("RETURN"))
-	private void iris$resolveTranslucency(ClientLevel world, double x, double y, double z, double velocityX, double velocityY, double velocityZ, BlockState blockState, CallbackInfo callback) {
-		RenderType layer = ItemBlockRenderTypes.getChunkRenderType(blockState);
+	private void iris$resolveTranslucency(ClientLevel level, double x, double y, double z, double velocityX, double velocityY, double velocityZ, BlockState blockState, CallbackInfo callback) {
+		RenderType type = ItemBlockRenderTypes.getChunkRenderType(blockState);
 
-		if (layer == RenderType.solid() || layer == RenderType.cutout() || layer == RenderType.cutoutMipped()) {
+		if (type == RenderType.solid() || type == RenderType.cutout() || type == RenderType.cutoutMipped()) {
 			isOpaque = true;
 		}
 	}

File: src/main/java/net/coderbot/iris/mixin/rendertype/MixinFixEyesTranslucency.java
Patch:
@@ -1,4 +1,4 @@
-package net.coderbot.iris.mixin.renderlayer;
+package net.coderbot.iris.mixin.rendertype;
 
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Unique;

File: src/main/java/net/coderbot/iris/mixin/rendertype/RenderStateShardAccessor.java
Patch:
@@ -1,4 +1,4 @@
-package net.coderbot.iris.mixin.renderlayer;
+package net.coderbot.iris.mixin.rendertype;
 
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;

File: src/main/java/net/coderbot/iris/mixin/rendertype/RenderTypeAccessor.java
Patch:
@@ -1,4 +1,4 @@
-package net.coderbot.iris.mixin.renderlayer;
+package net.coderbot.iris.mixin.rendertype;
 
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.gen.Accessor;

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -681,8 +681,8 @@ public static GbufferProgram getProgramForSheet(ParticleRenderType sheet) {
 	}
 
 	@Override
-	public void renderShadows(LevelRendererAccessor worldRenderer, Camera playerCamera) {
-		this.shadowMapRenderer.renderShadows(worldRenderer, playerCamera);
+	public void renderShadows(LevelRendererAccessor levelRenderer, Camera playerCamera) {
+		this.shadowMapRenderer.renderShadows(levelRenderer, playerCamera);
 	}
 
 	@Override

File: src/main/java/net/coderbot/iris/pipeline/FixedFunctionWorldRenderingPipeline.java
Patch:
@@ -22,7 +22,7 @@ public void beginWorldRendering() {
 	}
 
 	@Override
-	public void renderShadows(LevelRendererAccessor worldRenderer, Camera camera) {
+	public void renderShadows(LevelRendererAccessor levelRenderer, Camera camera) {
 		// stub: nothing to do here
 	}
 

File: src/main/java/net/coderbot/iris/pipeline/WorldRenderingPipeline.java
Patch:
@@ -7,7 +7,7 @@
 
 public interface WorldRenderingPipeline {
 	void beginWorldRendering();
-	void renderShadows(LevelRendererAccessor worldRenderer, Camera camera);
+	void renderShadows(LevelRendererAccessor levelRenderer, Camera camera);
 	void addDebugText(List<String> messages);
 	void beginShadowRender();
 	void endShadowRender();

File: src/main/java/net/coderbot/iris/shadows/EmptyShadowMapRenderer.java
Patch:
@@ -44,7 +44,7 @@ public EmptyShadowMapRenderer(int size) {
 	}
 
 	@Override
-	public void renderShadows(LevelRendererAccessor worldRenderer, Camera playerCamera) {
+	public void renderShadows(LevelRendererAccessor levelRenderer, Camera playerCamera) {
 		// No-op
 	}
 

File: src/main/java/net/coderbot/iris/shadows/ShadowMapRenderer.java
Patch:
@@ -4,7 +4,7 @@
 import net.minecraft.client.Camera;
 
 public interface ShadowMapRenderer {
-	void renderShadows(LevelRendererAccessor worldRenderer, Camera playerCamera);
+	void renderShadows(LevelRendererAccessor levelRenderer, Camera playerCamera);
 	int getDepthTextureId();
 	int getDepthTextureNoTranslucentsId();
 	// TODO: Support more shadow color textures as well as support there being no shadow color textures.

File: src/main/java/net/coderbot/iris/uniforms/IdMapUniforms.java
Patch:
@@ -76,9 +76,9 @@ private static int getBlockEntityId(Map<BlockState, Integer> blockIdMap) {
 			return -1;
 		}
 
-		ClientLevel world = Objects.requireNonNull(Minecraft.getInstance().level);
+		ClientLevel level = Objects.requireNonNull(Minecraft.getInstance().level);
 
-		BlockState blockAt = world.getBlockState(entity.getBlockPos());
+		BlockState blockAt = level.getBlockState(entity.getBlockPos());
 
 		if (!entity.getType().isValid(blockAt.getBlock())) {
 			// Somehow the block here isn't compatible with the block entity at this location.

File: src/main/java/net/coderbot/iris/texunits/TextureUnit.java
Patch:
@@ -5,8 +5,7 @@
 public enum TextureUnit {
 	TERRAIN(0),
 	LIGHTMAP(1),
-	// TODO: Relocate this to a different texture unit, this is used by depthtex0...
-	OVERLAY(6);
+	OVERLAY(2);
 
 	private final int samplerId;
 	private final int unitId;

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -40,7 +40,7 @@ public class Iris implements ClientModInitializer {
 	public static final String MODID = "iris";
 	public static final Logger logger = LogManager.getLogger(MODID);
 	// The recommended version of Sodium for use with Iris
-	private static final String SODIUM_VERSION = "0.3.0-IRIS2";
+	private static final String SODIUM_VERSION = "0.3.0+IRIS2";
 
 	public static final Path SHADERPACKS_DIRECTORY = FabricLoader.getInstance().getGameDir().resolve("shaderpacks");
 
@@ -66,7 +66,7 @@ public void onInitializeClient() {
 				// A lot of people are reporting visual bugs with Iris + Sodium. This makes it so that if we don't have
 				// the right fork of Sodium, it will just crash.
 				if (!versionString.startsWith(SODIUM_VERSION)) {
-					throw new IllegalStateException("You do not have a compatible version of Sodium installed! You have " + versionString + " but" + SODIUM_VERSION + "is expected");
+					throw new IllegalStateException("You do not have a compatible version of Sodium installed! You have " + versionString + " but " + SODIUM_VERSION + " is expected");
 				}
 			}
 		);

File: src/main/java/net/coderbot/iris/mixin/MixinTweakFarPlane.java
Patch:
@@ -55,7 +55,7 @@ public class MixinTweakFarPlane {
 		// Use a minimum distance for the far plane
 		// The real far plane will be 4 times this, so this will result in a far plane of 173 meters.
 		//
-		// Math.max returns the maximum of thw two values, so whenever tweakedViewDistance falls below 43.25F, this code
+		// Math.max returns the maximum of the two values, so whenever tweakedViewDistance falls below 43.25F, this code
 		// forces it to take on a value of 43.25F.
 		tweakedViewDistance = Math.max(43.25F, tweakedViewDistance);
 

File: src/main/java/net/coderbot/iris/compat/indigo/mixin/MixinAbstractQuadRenderer.java
Patch:
@@ -9,7 +9,7 @@
 /**
  * Small tweak to Indigo to make it obey our separateAo setting.
  */
-@Mixin(targets = "net/fabricmc/fabric/impl/client/indigo/renderer/render/AbstractQuadRenderer")
+@Mixin(targets = "net/fabricmc/fabric/impl/client/indigo/renderer/render/AbstractQuadRenderer", remap = false)
 @Pseudo
 public class MixinAbstractQuadRenderer {
 	@Redirect(method = {"tesselateSmooth", "tesselateSmoothEmissive"},

File: src/main/java/net/coderbot/iris/compat/indium/mixin/MixinAbstractQuadRenderer.java
Patch:
@@ -9,7 +9,7 @@
 /**
  * Small tweak to Indium to make it obey our separateAo setting.
  */
-@Mixin(targets = "link/infra/indium/renderer/render/AbstractQuadRenderer")
+@Mixin(targets = "link/infra/indium/renderer/render/AbstractQuadRenderer", remap = false)
 @Pseudo
 public class MixinAbstractQuadRenderer {
 	@Redirect(method = {"tesselateSmooth", "tesselateSmoothEmissive"},

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -307,7 +307,7 @@ public void renderShadows(WorldRendererAccessor worldRenderer, Camera playerCame
 
 		// TODO: Support shadow clear color directives & disable buffer clearing
 		// Ensure that the color and depth values are cleared appropriately
-		RenderSystem.clearColor(0.0f, 0.0f, 0.0f, 0.0f);
+		RenderSystem.clearColor(1.0f, 1.0f, 1.0f, 1.0f);
 		RenderSystem.clearDepth(1.0f);
 		RenderSystem.clear(GL11C.GL_DEPTH_BUFFER_BIT | GL11C.GL_COLOR_BUFFER_BIT, false);
 

File: src/main/java/net/coderbot/iris/mixin/MixinWorldRenderer.java
Patch:
@@ -54,8 +54,9 @@ public class MixinWorldRenderer {
 		pipeline.beginWorldRendering();
 	}
 
-	// Inject a bit early so that we can end our rendering in time.
-	@Inject(method = RENDER, at = @At(value = "INVOKE", target = "Lnet/minecraft/client/render/BackgroundRenderer;method_23792()V"))
+	// Inject a bit early so that we can end our rendering before mods like VoxelMap (which inject at RETURN)
+	// render their waypoint beams.
+	@Inject(method = RENDER, at = @At(value = "RETURN", shift = At.Shift.BEFORE))
 	private void iris$endWorldRender(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager, Matrix4f matrix4f, CallbackInfo callback) {
 		MinecraftClient.getInstance().getProfiler().swap("iris_final");
 		pipeline.finalizeWorldRendering();

File: src/main/java/net/coderbot/iris/compat/indigo/mixin/MixinAbstractQuadRenderer.java
Patch:
@@ -2,13 +2,15 @@
 
 import net.coderbot.iris.block_rendering.BlockRenderingSettings;
 import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Pseudo;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Redirect;
 
 /**
  * Small tweak to Indigo to make it obey our separateAo setting.
  */
 @Mixin(targets = "net/fabricmc/fabric/impl/client/indigo/renderer/render/AbstractQuadRenderer")
+@Pseudo
 public class MixinAbstractQuadRenderer {
 	@Redirect(method = {"tesselateSmooth", "tesselateSmoothEmissive"},
 	          at = @At(value = "INVOKE",

File: src/main/java/net/coderbot/iris/compat/indium/mixin/MixinAbstractQuadRenderer.java
Patch:
@@ -2,13 +2,15 @@
 
 import net.coderbot.iris.block_rendering.BlockRenderingSettings;
 import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Pseudo;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Redirect;
 
 /**
  * Small tweak to Indium to make it obey our separateAo setting.
  */
 @Mixin(targets = "link/infra/indium/renderer/render/AbstractQuadRenderer")
+@Pseudo
 public class MixinAbstractQuadRenderer {
 	@Redirect(method = {"tesselateSmooth", "tesselateSmoothEmissive"},
 			at = @At(value = "INVOKE",

File: src/main/java/net/coderbot/iris/fantastic/BlendingStateHolder.java
Patch:
@@ -1,5 +1,5 @@
 package net.coderbot.iris.fantastic;
 
 public interface BlendingStateHolder {
-	boolean hasBlend();
+	TransparencyType getTransparencyType();
 }

File: src/main/java/net/coderbot/iris/fantastic/FantasticVertexConsumerProvider.java
Patch:
@@ -31,7 +31,7 @@ private boolean isTransparent(RenderLayer layer) {
 		}
 
 		if (layer instanceof BlendingStateHolder) {
-			return ((BlendingStateHolder) layer).hasBlend();
+			return ((BlendingStateHolder) layer).getTransparencyType() != TransparencyType.OPAQUE;
 		}
 
 		return true;

File: src/main/java/net/coderbot/iris/layer/IrisRenderLayerWrapper.java
Patch:
@@ -8,7 +8,7 @@
 
 import net.minecraft.client.render.RenderLayer;
 
-public class IrisRenderLayerWrapper extends RenderLayer {
+public class IrisRenderLayerWrapper extends RenderLayer implements WrappableRenderLayer {
 	private final UseProgramRenderPhase useProgram;
 	private final RenderLayer wrapped;
 
@@ -34,6 +34,7 @@ public void endDrawing() {
 		super.endDrawing();
 	}
 
+	@Override
 	public RenderLayer unwrap() {
 		return this.wrapped;
 	}

File: src/main/java/net/coderbot/iris/mixin/fantastic/MixinBufferBuilderStorage.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.iris.mixin.fantastic;
 
 import net.coderbot.iris.fantastic.ExtendedBufferStorage;
-import net.coderbot.iris.fantastic.FantasticVertexConsumerProvider;
+import net.coderbot.iris.fantastic.FullyBufferedVertexConsumerProvider;
 import net.minecraft.client.render.BufferBuilderStorage;
 import net.minecraft.client.render.OutlineVertexConsumerProvider;
 import net.minecraft.client.render.VertexConsumerProvider;
@@ -14,7 +14,7 @@
 @Mixin(BufferBuilderStorage.class)
 public class MixinBufferBuilderStorage implements ExtendedBufferStorage {
 	@Unique
-	private final VertexConsumerProvider.Immediate buffered = new FantasticVertexConsumerProvider();
+	private final VertexConsumerProvider.Immediate buffered = new FullyBufferedVertexConsumerProvider();
 
 	@Unique
 	private int begins = 0;

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -311,7 +311,7 @@ public void renderShadows(WorldRendererAccessor worldRenderer, Camera playerCame
 
 		// TODO: Support shadow clear color directives & disable buffer clearing
 		// Ensure that the color and depth values are cleared appropriately
-		RenderSystem.clearColor(0.0f, 0.0f, 0.0f, 0.0f);
+		RenderSystem.clearColor(1.0f, 1.0f, 1.0f, 1.0f);
 		RenderSystem.clearDepth(1.0f);
 		RenderSystem.clear(GL11C.GL_DEPTH_BUFFER_BIT | GL11C.GL_COLOR_BUFFER_BIT, false);
 

File: src/main/java/net/coderbot/iris/mixin/MixinWorldRenderer.java
Patch:
@@ -77,8 +77,9 @@ public class MixinWorldRenderer {
 		pipeline.beginWorldRendering();
 	}
 
-	// Inject a bit early so that we can end our rendering in time.
-	@Inject(method = RENDER, at = @At(value = "INVOKE", target = "Lnet/minecraft/client/render/BackgroundRenderer;method_23792()V"))
+	// Inject a bit early so that we can end our rendering before mods like VoxelMap (which inject at RETURN)
+	// render their waypoint beams.
+	@Inject(method = RENDER, at = @At(value = "RETURN", shift = At.Shift.BEFORE))
 	private void iris$endWorldRender(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager, Matrix4f matrix4f, CallbackInfo callback) {
 		MinecraftClient.getInstance().getProfiler().swap("iris_final");
 		pipeline.finalizeWorldRendering();

File: src/main/java/net/coderbot/iris/mixin/MixinLivingEntityRenderer.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.iris.mixin;
 
 import net.coderbot.iris.layer.EntityColorRenderPhase;
-import net.coderbot.iris.layer.EntityColorWrappedRenderLayer;
+import net.coderbot.iris.layer.InnerWrappedRenderLayer;
 import net.minecraft.client.render.VertexConsumerProvider;
 import net.minecraft.client.render.entity.LivingEntityRenderer;
 import net.minecraft.client.util.math.MatrixStack;
@@ -26,7 +26,7 @@ public abstract class MixinLivingEntityRenderer {
 			// This rounding kinda changes how creeper flashes work but it isn't particularly noticeable.
 			// It avoids a big waste of memory with the current buffered entity rendering code creepers are exploding.
 			EntityColorRenderPhase phase = new EntityColorRenderPhase(hurt, Math.round(whiteFlash));
-			return layer -> provider.getBuffer(new EntityColorWrappedRenderLayer("iris_entity_color", layer, phase));
+			return layer -> provider.getBuffer(new InnerWrappedRenderLayer("iris_entity_color", layer, phase));
 		} else {
 			return provider;
 		}

File: src/main/java/net/coderbot/iris/pipeline/newshader/TriforceSodiumPatcher.java
Patch:
@@ -137,7 +137,7 @@ public static String patch(String source, ShaderType type, AlphaTest alpha, Shad
 
 			transformations.injectLine(Transformations.InjectionPoint.BEFORE_CODE,
 					"struct DrawParameters {\n" +
-					"    vec3 Offset;\n" +
+					"    vec4 Offset;\n" +
 					"};\n" +
 					"layout(std140) uniform ubo_DrawParameters {\n" +
 					"    DrawParameters Chunks[256];\n" +
@@ -147,7 +147,7 @@ public static String patch(String source, ShaderType type, AlphaTest alpha, Shad
 					"uniform float u_ModelOffset;\n" +
 					"uniform vec3 u_CameraTranslation;");
 
-			transformations.injectLine(Transformations.InjectionPoint.BEFORE_CODE, "vec3 getVertexPosition() { vec3 vertexPosition = a_Pos.xyz * u_ModelScale + u_ModelOffset; vec3 chunkOffset = Chunks[int(a_Pos.w)].Offset; return chunkOffset + vertexPosition + u_CameraTranslation; }");
+			transformations.injectLine(Transformations.InjectionPoint.BEFORE_CODE, "vec3 getVertexPosition() { vec3 vertexPosition = a_Pos.xyz * u_ModelScale + u_ModelOffset; vec3 chunkOffset = Chunks[int(a_Pos.w)].Offset.xyz; return chunkOffset + vertexPosition + u_CameraTranslation; }");
 			transformations.injectLine(Transformations.InjectionPoint.BEFORE_CODE, "vec4 ftransform() { return gl_ModelViewProjectionMatrix * gl_Vertex; }");
 		}
 

File: src/main/java/net/coderbot/iris/pipeline/newshader/CoreWorldRenderingPipeline.java
Patch:
@@ -23,6 +23,7 @@ public interface CoreWorldRenderingPipeline extends WorldRenderingPipeline {
 	Shader getCrumbling();
 	Shader getText();
 	Shader getBlock();
+	Shader getBeacon();
 	Shader getShadowTerrainCutout();
 	Shader getShadowEntitiesCutout();
 	Shader getTranslucent();

File: src/main/java/net/coderbot/iris/compat/indigo/mixin/MixinAbstractQuadRenderer.java
Patch:
@@ -2,13 +2,15 @@
 
 import net.coderbot.iris.block_rendering.BlockRenderingSettings;
 import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Pseudo;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Redirect;
 
 /**
  * Small tweak to Indigo to make it obey our separateAo setting.
  */
 @Mixin(targets = "net/fabricmc/fabric/impl/client/indigo/renderer/render/AbstractQuadRenderer")
+@Pseudo
 public class MixinAbstractQuadRenderer {
 	@Redirect(method = {"tesselateSmooth", "tesselateSmoothEmissive"},
 	          at = @At(value = "INVOKE",

File: src/main/java/net/coderbot/iris/compat/indium/mixin/MixinAbstractQuadRenderer.java
Patch:
@@ -2,13 +2,15 @@
 
 import net.coderbot.iris.block_rendering.BlockRenderingSettings;
 import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Pseudo;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Redirect;
 
 /**
  * Small tweak to Indium to make it obey our separateAo setting.
  */
 @Mixin(targets = "link/infra/indium/renderer/render/AbstractQuadRenderer")
+@Pseudo
 public class MixinAbstractQuadRenderer {
 	@Redirect(method = {"tesselateSmooth", "tesselateSmoothEmissive"},
 			at = @At(value = "INVOKE",

File: src/main/java/net/coderbot/iris/fantastic/BlendingStateHolder.java
Patch:
@@ -1,5 +1,5 @@
 package net.coderbot.iris.fantastic;
 
 public interface BlendingStateHolder {
-	boolean hasBlend();
+	TransparencyType getTransparencyType();
 }

File: src/main/java/net/coderbot/iris/fantastic/FantasticVertexConsumerProvider.java
Patch:
@@ -31,7 +31,7 @@ private boolean isTransparent(RenderLayer layer) {
 		}
 
 		if (layer instanceof BlendingStateHolder) {
-			return ((BlendingStateHolder) layer).hasBlend();
+			return ((BlendingStateHolder) layer).getTransparencyType() != TransparencyType.OPAQUE;
 		}
 
 		return true;

File: src/main/java/net/coderbot/iris/layer/EntityColorWrappedRenderLayer.java
Patch:
@@ -7,7 +7,7 @@
 import java.util.Objects;
 import java.util.Optional;
 
-public class EntityColorWrappedRenderLayer extends RenderLayer {
+public class EntityColorWrappedRenderLayer extends RenderLayer implements WrappableRenderLayer {
 	private final EntityColorRenderPhase entityColor;
 	private final RenderLayer wrapped;
 
@@ -33,6 +33,7 @@ public void endDrawing() {
 		super.endDrawing();
 	}
 
+	@Override
 	public RenderLayer unwrap() {
 		return this.wrapped;
 	}

File: src/main/java/net/coderbot/iris/layer/IrisRenderLayerWrapper.java
Patch:
@@ -8,7 +8,7 @@
 
 import net.minecraft.client.render.RenderLayer;
 
-public class IrisRenderLayerWrapper extends RenderLayer {
+public class IrisRenderLayerWrapper extends RenderLayer implements WrappableRenderLayer {
 	private final UseProgramRenderPhase useProgram;
 	private final RenderLayer wrapped;
 
@@ -34,6 +34,7 @@ public void endDrawing() {
 		super.endDrawing();
 	}
 
+	@Override
 	public RenderLayer unwrap() {
 		return this.wrapped;
 	}

File: src/main/java/net/coderbot/iris/mixin/fantastic/MixinBufferBuilderStorage.java
Patch:
@@ -1,7 +1,7 @@
 package net.coderbot.iris.mixin.fantastic;
 
 import net.coderbot.iris.fantastic.ExtendedBufferStorage;
-import net.coderbot.iris.fantastic.FantasticVertexConsumerProvider;
+import net.coderbot.iris.fantastic.FullyBufferedVertexConsumerProvider;
 import net.minecraft.client.render.BufferBuilderStorage;
 import net.minecraft.client.render.OutlineVertexConsumerProvider;
 import net.minecraft.client.render.VertexConsumerProvider;
@@ -14,7 +14,7 @@
 @Mixin(BufferBuilderStorage.class)
 public class MixinBufferBuilderStorage implements ExtendedBufferStorage {
 	@Unique
-	private final VertexConsumerProvider.Immediate buffered = new FantasticVertexConsumerProvider();
+	private final VertexConsumerProvider.Immediate buffered = new FullyBufferedVertexConsumerProvider();
 
 	@Unique
 	private int begins = 0;

File: src/main/java/net/coderbot/iris/mixin/MixinTweakFarPlane.java
Patch:
@@ -43,7 +43,7 @@ public class MixinTweakFarPlane {
 	private float iris$tweakViewDistanceToMatchOptiFine(GameRenderer renderer) {
 		if (!Iris.getCurrentPack().isPresent()) {
 			// Don't mess with the far plane if no shaderpack is loaded
-			return this.viewDistance;
+			return this.viewDistance * 4.0F;
 		}
 
 		float tweakedViewDistance = this.viewDistance;

File: src/main/java/net/coderbot/iris/mixin/MixinShader.java
Patch:
@@ -8,7 +8,7 @@
 
 @Mixin(Shader.class)
 public class MixinShader {
-	@Redirect(method = {"upload()V", "loadReferences()V"}, at = @At(value = "INVOKE", target = "Lnet/minecraft/client/gl/GlUniform;getUniformLocation(ILjava/lang/CharSequence;)I"))
+	@Redirect(method = {"bind()V", "loadReferences()V"}, at = @At(value = "INVOKE", target = "Lnet/minecraft/client/gl/GlUniform;getUniformLocation(ILjava/lang/CharSequence;)I"))
 	private int iris$redirectGetUniformLocation(int programId, CharSequence name) {
 		int location = GlUniform.getUniformLocation(programId, name);
 

File: src/main/java/net/coderbot/iris/pipeline/newshader/CoreWorldRenderingPipeline.java
Patch:
@@ -9,6 +9,7 @@ public interface CoreWorldRenderingPipeline extends WorldRenderingPipeline {
 	Shader getSkyBasicColor();
 	Shader getSkyTextured();
 	Shader getSkyTexturedColor();
+	Shader getClouds();
 	Shader getTerrain();
 	Shader getTerrainCutout();
 	Shader getTerrainCutoutMipped();

File: src/main/java/net/coderbot/iris/samplers/IrisSamplers.java
Patch:
@@ -100,7 +100,7 @@ public static boolean addShadowSamplers(SamplerHolder samplers, ShadowMapRendere
 					"shadowtex1", "shadow");
 		} else {
 			usesShadows = samplers.addDynamicSampler(shadowMapRenderer::getDepthTextureId, "shadowtex0", "shadow");
-			usesShadows |= samplers.addDynamicSampler(shadowMapRenderer::getDepthTextureId, "shadowtex1");
+			usesShadows |= samplers.addDynamicSampler(shadowMapRenderer::getDepthTextureNoTranslucentsId, "shadowtex1");
 		}
 
 		samplers.addDynamicSampler(shadowMapRenderer::getColorTexture0Id, "shadowcolor", "shadowcolor0");

File: src/main/java/net/coderbot/iris/samplers/IrisSamplers.java
Patch:
@@ -100,7 +100,7 @@ public static boolean addShadowSamplers(SamplerHolder samplers, ShadowMapRendere
 					"shadowtex1", "shadow");
 		} else {
 			usesShadows = samplers.addDynamicSampler(shadowMapRenderer::getDepthTextureId, "shadowtex0", "shadow");
-			usesShadows |= samplers.addDynamicSampler(shadowMapRenderer::getDepthTextureId, "shadowtex1");
+			usesShadows |= samplers.addDynamicSampler(shadowMapRenderer::getDepthTextureNoTranslucentsId, "shadowtex1");
 		}
 
 		samplers.addDynamicSampler(shadowMapRenderer::getColorTexture0Id, "shadowcolor", "shadowcolor0");

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -430,6 +430,9 @@ public void beginWorldRendering() {
 		// Make sure we're using texture unit 0 for this.
 		RenderSystem.activeTexture(GL15C.GL_TEXTURE0);
 
+		// NB: execute this before resizing / clearing so that the center depth sample is retrieved properly.
+		updateNotifier.onNewFrame();
+
 		Framebuffer main = MinecraftClient.getInstance().getFramebuffer();
 		renderTargets.resizeIfNeeded(main.textureWidth, main.textureHeight);
 
@@ -450,8 +453,6 @@ public void beginWorldRendering() {
 		main.beginWrite(true);
 
 		isBeforeTranslucent = true;
-
-		updateNotifier.onNewFrame();
 	}
 
 	@Override

File: src/main/java/net/coderbot/iris/mixin/MixinGlStateManager.java
Patch:
@@ -11,6 +11,8 @@
 public class MixinGlStateManager {
 	@ModifyConstant(method = "<clinit>", constant = @Constant(intValue = 12), require = 1)
 	private static int iris$increaseMaximumAllowedTextureUnits(int existingValue) {
-		return SamplerLimits.get().getMaxTextureUnits();
+		// should be enough, I hope...
+		// We can't query OpenGL for this since RenderSystem is initialized too early.
+		return 128;
 	}
 }

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -9,6 +9,7 @@
 import net.coderbot.iris.gl.program.Program;
 import net.coderbot.iris.gl.program.ProgramBuilder;
 import net.coderbot.iris.gl.texture.InternalTextureFormat;
+import net.coderbot.iris.gl.framebuffer.GlFramebuffer;
 import net.coderbot.iris.layer.GbufferProgram;
 import net.coderbot.iris.mixin.WorldRendererAccessor;
 import net.coderbot.iris.mixin.shadows.ChunkInfoAccessor;

File: src/main/java/net/coderbot/iris/pipeline/SodiumTerrainPipeline.java
Patch:
@@ -15,6 +15,7 @@
 import net.coderbot.iris.shaderpack.transform.Transformations;
 import net.coderbot.iris.uniforms.CommonUniforms;
 import net.coderbot.iris.uniforms.SamplerUniforms;
+import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.coderbot.iris.uniforms.builtin.BuiltinReplacementUniforms;
 import net.fabricmc.loader.api.FabricLoader;
 

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -410,7 +410,7 @@ private Pass createPass(ProgramSource source) {
 
 		try {
 			builder = ProgramBuilder.begin(source.getName(), source.getVertexSource().orElse(null), source.getGeometrySource().orElse(null),
-				source.getFragmentSource().orElse(null), IrisSamplers.RESERVED_TEXTURE_UNITS);
+				source.getFragmentSource().orElse(null), IrisSamplers.WORLD_RESERVED_TEXTURE_UNITS);
 		} catch (RuntimeException e) {
 			// TODO: Better error handling
 			throw new RuntimeException("Shader compilation failed!", e);
@@ -421,9 +421,9 @@ private Pass createPass(ProgramSource source) {
 		Supplier<ImmutableSet<Integer>> flipped =
 				() -> isBeforeTranslucent ? flippedBeforeTranslucent : flippedAfterTranslucent;
 
+		IrisSamplers.addRenderTargetSamplers(builder, flipped, renderTargets, false);
 		IrisSamplers.addWorldSamplers(builder, renderTargets, normals, specular);
 		IrisSamplers.addNoiseSampler(builder, noise);
-		IrisSamplers.addRenderTargetSamplers(builder, flipped, renderTargets, false);
 
 		if (IrisSamplers.hasShadowSamplers(builder)) {
 			createShadowMapRenderer.run();

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -158,7 +158,7 @@ private Pair<Program, ProgramDirectives> createProgram(ProgramSource source, Pac
 
 		try {
 			builder = ProgramBuilder.begin(source.getName(), source.getVertexSource().orElse(null), source.getGeometrySource().orElse(null),
-					source.getFragmentSource().orElse(null), IrisSamplers.RESERVED_TEXTURE_UNITS);
+					source.getFragmentSource().orElse(null), IrisSamplers.WORLD_RESERVED_TEXTURE_UNITS);
 		} catch (RuntimeException e) {
 			// TODO: Better error handling
 			throw new RuntimeException("Shader compilation failed!", e);

File: src/main/java/net/coderbot/iris/postprocess/FinalPassRenderer.java
Patch:
@@ -264,7 +264,7 @@ private Pair<Program, ProgramDirectives> createProgram(ProgramSource source) {
 
 		try {
 			builder = ProgramBuilder.begin(source.getName(), source.getVertexSource().orElse(null), source.getGeometrySource().orElse(null),
-				source.getFragmentSource().orElse(null), IrisSamplers.RESERVED_TEXTURE_UNITS);
+				source.getFragmentSource().orElse(null), IrisSamplers.COMPOSITE_RESERVED_TEXTURE_UNITS);
 		} catch (RuntimeException e) {
 			// TODO: Better error handling
 			throw new RuntimeException("Shader compilation failed!", e);

File: src/main/java/net/coderbot/iris/uniforms/HardcodedCustomUniforms.java
Patch:
@@ -32,7 +32,7 @@ private static int getWorldDayTime() {
 	}
 
 	private static float getTimeBrightness() {
-		return (float) Math.max(Math.sin(getTimeAngle() * Math.PI * (-2.0)),0.0);
+		return (float) Math.max(Math.sin(getTimeAngle() * Math.PI * 2.0),0.0);
 	}
 
 	private static float getMoonBrightness() {

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -14,6 +14,7 @@
 import net.coderbot.iris.mixin.WorldRendererAccessor;
 import net.coderbot.iris.rendertarget.DepthTexture;
 import net.coderbot.iris.rendertarget.RenderTargets;
+import net.coderbot.iris.samplers.IrisSamplers;
 import net.coderbot.iris.shaderpack.PackDirectives;
 import net.coderbot.iris.shaderpack.PackShadowDirectives;
 import net.coderbot.iris.shaderpack.ProgramDirectives;
@@ -157,13 +158,14 @@ private Pair<Program, ProgramDirectives> createProgram(ProgramSource source, Pac
 
 		try {
 			builder = ProgramBuilder.begin(source.getName(), source.getVertexSource().orElse(null), source.getGeometrySource().orElse(null),
-					source.getFragmentSource().orElse(null));
+					source.getFragmentSource().orElse(null), IrisSamplers.RESERVED_TEXTURE_UNITS);
 		} catch (RuntimeException e) {
 			// TODO: Better error handling
 			throw new RuntimeException("Shader compilation failed!", e);
 		}
 
 		CommonUniforms.addCommonUniforms(builder, source.getParent().getPack().getIdMap(), directives, ((DeferredWorldRenderingPipeline) pipeline).getUpdateNotifier());
+		SamplerUniforms.addCommonSamplerUniforms(builder);
 		SamplerUniforms.addWorldSamplerUniforms(builder);
 
 		return new Pair<>(builder.build(), source.getDirectives());

File: src/main/java/net/coderbot/iris/pipeline/SodiumTerrainPipeline.java
Patch:
@@ -181,6 +181,7 @@ public ProgramUniforms initUniforms(int programId) {
 
 		WorldRenderingPipeline pipeline = Iris.getPipelineManager().getPipeline();
 		CommonUniforms.addCommonUniforms(uniforms, programSet.getPack().getIdMap(), programSet.getPackDirectives(), ((DeferredWorldRenderingPipeline) pipeline).getUpdateNotifier());
+		SamplerUniforms.addCommonSamplerUniforms(uniforms);
 		SamplerUniforms.addWorldSamplerUniforms(uniforms);
 		SamplerUniforms.addDepthSamplerUniforms(uniforms);
 		BuiltinReplacementUniforms.addBuiltinReplacementUniforms(uniforms);

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderer.java
Patch:
@@ -14,6 +14,7 @@
 import net.coderbot.iris.gl.program.ProgramBuilder;
 import net.coderbot.iris.gl.uniform.UniformUpdateFrequency;
 import net.coderbot.iris.rendertarget.*;
+import net.coderbot.iris.samplers.IrisSamplers;
 import net.coderbot.iris.shaderpack.PackDirectives;
 import net.coderbot.iris.shaderpack.PackRenderTargetDirectives;
 import net.coderbot.iris.shaderpack.ProgramDirectives;
@@ -248,7 +249,7 @@ private Pair<Program, ProgramDirectives> createProgram(ProgramSource source) {
 
 		try {
 			builder = ProgramBuilder.begin(source.getName(), source.getVertexSource().orElse(null), source.getGeometrySource().orElse(null),
-				source.getFragmentSource().orElse(null));
+				source.getFragmentSource().orElse(null), IrisSamplers.RESERVED_TEXTURE_UNITS);
 		} catch (RuntimeException e) {
 			// TODO: Better error handling
 			throw new RuntimeException("Shader compilation failed!", e);
@@ -259,6 +260,7 @@ private Pair<Program, ProgramDirectives> createProgram(ProgramSource source) {
 		}
 
 		CommonUniforms.addCommonUniforms(builder, source.getParent().getPack().getIdMap(), source.getParent().getPackDirectives(), updateNotifier);
+		SamplerUniforms.addCommonSamplerUniforms(builder);
 		SamplerUniforms.addCompositeSamplerUniforms(builder);
 		SamplerUniforms.addDepthSamplerUniforms(builder);
 

File: src/main/java/net/coderbot/iris/postprocess/FinalPassRenderer.java
Patch:
@@ -12,6 +12,7 @@
 import net.coderbot.iris.rendertarget.FramebufferBlitter;
 import net.coderbot.iris.rendertarget.RenderTarget;
 import net.coderbot.iris.rendertarget.RenderTargets;
+import net.coderbot.iris.samplers.IrisSamplers;
 import net.coderbot.iris.shaderpack.PackRenderTargetDirectives;
 import net.coderbot.iris.shaderpack.ProgramDirectives;
 import net.coderbot.iris.shaderpack.ProgramSet;
@@ -273,7 +274,7 @@ private Pair<Program, ProgramDirectives> createProgram(ProgramSource source) {
 
 		try {
 			builder = ProgramBuilder.begin(source.getName(), source.getVertexSource().orElse(null), source.getGeometrySource().orElse(null),
-				source.getFragmentSource().orElse(null));
+				source.getFragmentSource().orElse(null), IrisSamplers.RESERVED_TEXTURE_UNITS);
 		} catch (RuntimeException e) {
 			// TODO: Better error handling
 			throw new RuntimeException("Shader compilation failed!", e);
@@ -284,6 +285,7 @@ private Pair<Program, ProgramDirectives> createProgram(ProgramSource source) {
 		}
 
 		CommonUniforms.addCommonUniforms(builder, source.getParent().getPack().getIdMap(), source.getParent().getPackDirectives(), updateNotifier);
+		SamplerUniforms.addCommonSamplerUniforms(builder);
 		SamplerUniforms.addCompositeSamplerUniforms(builder);
 		SamplerUniforms.addDepthSamplerUniforms(builder);
 

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -46,7 +46,6 @@ public static void addCommonUniforms(LocationalUniformHolder uniforms, IdMap idM
 		new CelestialUniforms(directives.getSunPathRotation()).addCelestialUniforms(uniforms);
 		IdMapUniforms.addIdMapUniforms(uniforms, idMap);
 		MatrixUniforms.addMatrixUniforms(uniforms, directives);
-		SamplerUniforms.addCommonSamplerUniforms(uniforms);
 		HardcodedCustomUniforms.addHardcodedCustomUniforms(uniforms, updateNotifier);
 
 		CommonUniforms.generalCommonUniforms(uniforms, updateNotifier);

File: src/main/java/net/coderbot/iris/shaderpack/transform/BuiltinUniformReplacementTransformer.java
Patch:
@@ -83,7 +83,7 @@ private void applyFallbackCases(Transformations transformations) {
 		// If there are references to the fallback lightmap texture matrix, then make it available to the shader program.
 		if (transformations.contains("iris_LightmapTextureMatrix")) {
 			transformations.injectLine(
-				Transformations.InjectionPoint.AFTER_VERSION,
+				Transformations.InjectionPoint.BEFORE_CODE,
 				"uniform mat4 iris_LightmapTextureMatrix;"
 			);
 		}

File: src/main/java/net/coderbot/iris/pipeline/newshader/CoreWorldRenderingPipeline.java
Patch:
@@ -8,6 +8,7 @@ public interface CoreWorldRenderingPipeline extends WorldRenderingPipeline {
 	Shader getSkyBasic();
 	Shader getSkyBasicColor();
 	Shader getSkyTextured();
+	Shader getSkyTexturedColor();
 	Shader getTerrain();
 	Shader getTerrainCutout();
 	Shader getTerrainCutoutMipped();
@@ -20,6 +21,7 @@ public interface CoreWorldRenderingPipeline extends WorldRenderingPipeline {
 	Shader getWeather();
 	Shader getCrumbling();
 	Shader getText();
+	Shader getBlock();
 	Shader getShadowTerrainCutout();
 	Shader getShadowEntitiesCutout();
 	Shader getTranslucent();

File: src/main/java/net/coderbot/iris/pipeline/newshader/WorldRenderingPhase.java
Patch:
@@ -4,6 +4,7 @@ public enum WorldRenderingPhase {
 	SKY,
 	TERRAIN,
 	ENTITIES,
+	BLOCK_ENTITIES,
 	TRANSLUCENT_TERRAIN,
 	TRANSLUCENT_ENTITIES,
 	CLOUDS,

File: src/main/java/net/coderbot/iris/rendertarget/RenderTarget.java
Patch:
@@ -48,7 +48,7 @@ private void setupCurrentlyBoundTexture(int width, int height) {
 		GL11C.glTexParameteri(GL11C.GL_TEXTURE_2D, GL11C.GL_TEXTURE_MIN_FILTER, GL11C.GL_LINEAR);
 		GL11C.glTexParameteri(GL11C.GL_TEXTURE_2D, GL11C.GL_TEXTURE_MAG_FILTER, GL11C.GL_LINEAR);
 		GL11C.glTexParameteri(GL11C.GL_TEXTURE_2D, GL11C.GL_TEXTURE_WRAP_S, GL13C.GL_CLAMP_TO_EDGE);
-		GL11C.glTexParameteri(GL11C.GL_TEXTURE_2D, GL11C.GL_TEXTURE_WRAP_T, GL13C.GL_CLAMP_TO_EDGE );
+		GL11C.glTexParameteri(GL11C.GL_TEXTURE_2D, GL11C.GL_TEXTURE_WRAP_T, GL13C.GL_CLAMP_TO_EDGE);
 
 		resizeCurrentlyBoundTexture(width, height);
 	}

File: src/main/java/net/coderbot/iris/pipeline/newshader/CoreWorldRenderingPipeline.java
Patch:
@@ -8,6 +8,7 @@ public interface CoreWorldRenderingPipeline extends WorldRenderingPipeline {
 	Shader getSkyBasic();
 	Shader getSkyBasicColor();
 	Shader getSkyTextured();
+	Shader getSkyTexturedColor();
 	Shader getTerrain();
 	Shader getTerrainCutout();
 	Shader getTerrainCutoutMipped();
@@ -20,6 +21,7 @@ public interface CoreWorldRenderingPipeline extends WorldRenderingPipeline {
 	Shader getWeather();
 	Shader getCrumbling();
 	Shader getText();
+	Shader getBlock();
 	Shader getShadowTerrainCutout();
 	Shader getShadowEntitiesCutout();
 	Shader getTranslucent();

File: src/main/java/net/coderbot/iris/pipeline/newshader/WorldRenderingPhase.java
Patch:
@@ -4,6 +4,7 @@ public enum WorldRenderingPhase {
 	SKY,
 	TERRAIN,
 	ENTITIES,
+	BLOCK_ENTITIES,
 	TRANSLUCENT_TERRAIN,
 	TRANSLUCENT_ENTITIES,
 	CLOUDS,

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -205,7 +205,7 @@ public NewWorldRenderingPipeline(ProgramSet programSet) throws IOException {
 			this.leash = createShader("gbuffers_leash", basicSource, AlphaTest.ALWAYS, VertexFormats.POSITION_COLOR_LIGHT, true);
 			this.particles = createShader("gbuffers_particles", particleSource, terrainCutoutAlpha, VertexFormats.POSITION_TEXTURE_COLOR_LIGHT, true);
 			this.weather = createShader("gbuffers_weather", weatherSource, terrainCutoutAlpha, VertexFormats.POSITION_TEXTURE_COLOR_LIGHT, true);
-			this.crumbling = createShader("gbuffers_damagedblock", damagedBlockSource, nonZeroAlpha, VertexFormats.POSITION_COLOR_TEXTURE_LIGHT_NORMAL, true);
+			this.crumbling = createShader("gbuffers_damagedblock", damagedBlockSource, terrainCutoutAlpha, VertexFormats.POSITION_COLOR_TEXTURE_LIGHT_NORMAL, true);
 			this.text = createShader("gbuffers_entities_text", entitiesSource, nonZeroAlpha, VertexFormats.POSITION_COLOR_TEXTURE_LIGHT, true);
 
 			// TODO: Shadow programs should have access to different samplers.

File: src/main/java/net/coderbot/iris/shaderpack/ShaderPack.java
Patch:
@@ -4,6 +4,7 @@
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Properties;
@@ -126,7 +127,7 @@ private Map<String, Map<String, String>> parseLangEntries(Path root) throws IOEx
 			//some shaderpacks use optifines file name coding which is different than minecraft's.
 			//An example of this is using "en_US.lang" compared to "en_us.json"
 			//also note that optifine uses a property scheme for loading language entries to keep parity with other optifine features
-			String currentFileName = path.getFileName().toString().toLowerCase();
+			String currentFileName = path.getFileName().toString().toLowerCase(Locale.ROOT);
 			String currentLangCode = currentFileName.substring(0, currentFileName.lastIndexOf("."));
 			Properties properties = new Properties();
 

File: src/main/java/net/coderbot/iris/mixin/MixinWorldRenderer.java
Patch:
@@ -116,7 +116,7 @@ public class MixinWorldRenderer {
 	}*/
 
 	@Inject(method = RENDER_SKY,
-		at = @At(value = "INVOKE", target = "com/mojang/blaze3d/systems/RenderSystem.getShader()Lnet/minecraft/client/render/Shader;", shift = At.Shift.AFTER, remap = false),
+		at = @At(value = "INVOKE", target = "net/minecraft/client/gl/VertexBuffer.setShader (Lnet/minecraft/util/math/Matrix4f;Lnet/minecraft/util/math/Matrix4f;Lnet/minecraft/client/render/Shader;)V", shift = At.Shift.AFTER),
 		slice = @Slice(to = @At(value = "INVOKE", target = "Lnet/minecraft/client/render/SkyProperties;getFogColorOverride(FF)[F")))
 	private void iris$renderSky$drawHorizon(MatrixStack matrices, Matrix4f projectionMatrix, float f, Runnable runnable, CallbackInfo callback) {
 		new HorizonRenderer().renderHorizon(matrices.peek().getModel().copy(), projectionMatrix.copy(), GameRenderer.getPositionShader());

File: src/main/java/net/coderbot/iris/mixin/MixinWorldRenderer.java
Patch:
@@ -116,7 +116,7 @@ public class MixinWorldRenderer {
 	}*/
 
 	@Inject(method = RENDER_SKY,
-		at = @At(value = "INVOKE", target = "com/mojang/blaze3d/systems/RenderSystem.getShader()Lnet/minecraft/client/render/Shader;", shift = At.Shift.AFTER),
+		at = @At(value = "INVOKE", target = "com/mojang/blaze3d/systems/RenderSystem.getShader()Lnet/minecraft/client/render/Shader;", shift = At.Shift.AFTER, remap = false),
 		slice = @Slice(to = @At(value = "INVOKE", target = "Lnet/minecraft/client/render/SkyProperties;getFogColorOverride(FF)[F")))
 	private void iris$renderSky$drawHorizon(MatrixStack matrices, Matrix4f projectionMatrix, float f, Runnable runnable, CallbackInfo callback) {
 		new HorizonRenderer().renderHorizon(matrices.peek().getModel().copy(), projectionMatrix.copy(), GameRenderer.getPositionShader());

File: src/main/java/net/coderbot/iris/mixin/fantastic/MixinMultiPhaseRenderLayer.java
Patch:
@@ -21,7 +21,7 @@ private MixinMultiPhaseRenderLayer(String name, VertexFormat vertexFormat, Verte
 		super(name, vertexFormat, drawMode, expectedBufferSize, hasCrumbling, translucent, startAction, endAction);
 	}
 
-	@Inject(method = "<init>", at = @At("RETURN"))
+	@Inject(method = "<init>(Ljava/lang/String;Lnet/minecraft/client/render/VertexFormat;Lnet/minecraft/client/render/VertexFormat$DrawMode;IZZLnet/minecraft/client/render/RenderLayer$MultiPhaseParameters;)V", at = @At("RETURN"))
 	private void iris$onMultiPhaseInit(String name, VertexFormat vertexFormat, VertexFormat.DrawMode drawMode,
 									   int expectedBufferSize, boolean hasCrumbling, boolean translucent,
 									   RenderLayer.MultiPhaseParameters phases, CallbackInfo ci) {

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -231,7 +231,7 @@ private Shader createShader(String name, ProgramSource source, AlphaTest fallbac
 		GlFramebuffer beforeTranslucent = renderTargets.createGbufferFramebuffer(flippedBeforeTranslucent, source.getDirectives().getDrawBuffers());
 		GlFramebuffer afterTranslucent = renderTargets.createGbufferFramebuffer(flippedAfterTranslucent, source.getDirectives().getDrawBuffers());
 
-		ExtendedShader extendedShader = NewShaderTests.create(name, source, beforeTranslucent, afterTranslucent, baseline, fallbackAlpha, vertexFormat, hasColorAttrib, updateNotifier, this);
+		ExtendedShader extendedShader = NewShaderTests.create(name, source, beforeTranslucent, afterTranslucent, baseline, fallbackAlpha, vertexFormat, updateNotifier, this);
 
 		loadedShaders.add(extendedShader);
 
@@ -289,7 +289,7 @@ private Shader createShadowShader(String name, Optional<ProgramSource> source, A
 	private Shader createShadowShader(String name, ProgramSource source, AlphaTest fallbackAlpha, VertexFormat vertexFormat, boolean hasColorAttrib) throws IOException {
 		GlFramebuffer framebuffer = this.shadowMapRenderer.getFramebuffer();
 
-		ExtendedShader extendedShader = NewShaderTests.create(name, source, framebuffer, framebuffer, baseline, fallbackAlpha, vertexFormat, hasColorAttrib, updateNotifier, this);
+		ExtendedShader extendedShader = NewShaderTests.create(name, source, framebuffer, framebuffer, baseline, fallbackAlpha, vertexFormat, updateNotifier, this);
 
 		loadedShaders.add(extendedShader);
 

File: src/main/java/net/coderbot/iris/shaderpack/ProgramSet.java
Patch:
@@ -106,7 +106,7 @@ private ProgramSet(ProgramSet base, ProgramSet overrides) {
 		}
 
 		// TODO: Support additional render targets beyond 8
-		this.packDirectives = new PackDirectives(PackRenderTargetDirectives.BASELINE_SUPPORTED_RENDER_TARGETS, getPackDirectives());
+		this.packDirectives = new PackDirectives(PackRenderTargetDirectives.BASELINE_SUPPORTED_RENDER_TARGETS, base.getPackDirectives());
 
 		this.shadow = merge(base.shadow, overrides.shadow);
 

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -47,7 +47,7 @@ public static void addCommonUniforms(LocationalUniformHolder uniforms, IdMap idM
 		IdMapUniforms.addIdMapUniforms(uniforms, idMap);
 		MatrixUniforms.addMatrixUniforms(uniforms, directives);
 		SamplerUniforms.addCommonSamplerUniforms(uniforms);
-		HardcodedCustomUniforms.addHardcodedCustomUniforms(uniforms);
+		HardcodedCustomUniforms.addHardcodedCustomUniforms(uniforms, updateNotifier);
 
 		CommonUniforms.generalCommonUniforms(uniforms, updateNotifier);
 	}
@@ -79,7 +79,7 @@ private static Vec3d getSkyColor() {
 		return client.world.method_23777(client.cameraEntity.getBlockPos(), CapturedRenderingState.INSTANCE.getTickDelta());
 	}
 
-	private static float getBlindness() {
+	static float getBlindness() {
 		Entity cameraEntity = client.getCameraEntity();
 
 		if (cameraEntity instanceof LivingEntity) {
@@ -103,7 +103,7 @@ private static float getPlayerMood() {
 		return ((ClientPlayerEntity)client.cameraEntity).getMoodPercentage();
 	}
 
-	private static float getRainStrength() {
+	static float getRainStrength() {
 		if (client.world == null) {
 			return 0f;
 		}

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -163,7 +163,7 @@ private Pair<Program, ProgramDirectives> createProgram(ProgramSource source, Pac
 			throw new RuntimeException("Shader compilation failed!", e);
 		}
 
-		CommonUniforms.addCommonUniforms(builder, source.getParent().getPack().getIdMap(), directives, FrameUpdateNotifier.INSTANCE);
+		CommonUniforms.addCommonUniforms(builder, source.getParent().getPack().getIdMap(), directives, ((DeferredWorldRenderingPipeline) pipeline).getUpdateNotifier());
 		SamplerUniforms.addWorldSamplerUniforms(builder);
 
 		return new Pair<>(builder.build(), source.getDirectives());

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -477,9 +477,9 @@ public void destroy() {
 		compositeRenderer.destroy();
 
 		// Make sure that any custom framebuffers are not bound before destroying render targets
-		GlStateManager.bindFramebuffer(GL30C.GL_READ_FRAMEBUFFER, 0);
-		GlStateManager.bindFramebuffer(GL30C.GL_DRAW_FRAMEBUFFER, 0);
-		GlStateManager.bindFramebuffer(GL30C.GL_FRAMEBUFFER, 0);
+		GlStateManager._glBindFramebuffer(GL30C.GL_READ_FRAMEBUFFER, 0);
+		GlStateManager._glBindFramebuffer(GL30C.GL_DRAW_FRAMEBUFFER, 0);
+		GlStateManager._glBindFramebuffer(GL30C.GL_FRAMEBUFFER, 0);
 
 		MinecraftClient.getInstance().getFramebuffer().beginWrite(false);
 

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderer.java
Patch:
@@ -246,6 +246,8 @@ public void renderAll(ShadowMapRenderer shadowMapRenderer) {
 				RenderSystem.activeTexture(GL15C.GL_TEXTURE0);
 				RenderSystem.bindTexture(swapPass.targetTexture);
 				GL20C.glCopyTexSubImage2D(GL20C.GL_TEXTURE_2D, 0, 0, 0, 0, 0, baseWidth, baseHeight);
+				RenderSystem.bindTexture(0);
+				GlStateManager._glBindFramebuffer(GL30C.GL_READ_FRAMEBUFFER, 0);
 			}
 		}
 

File: src/main/java/net/coderbot/iris/shaderpack/ShaderProperties.java
Patch:
@@ -260,7 +260,7 @@ public OptionalBoolean getFrustumCulling() {
 		return frustumCulling;
 	}
 
-	public Object2ObjectMap<String, AlphaTestOverride> getAlphaTestOverrides() {
+	public Object2ObjectMap<String, AlphaTest> getAlphaTestOverrides() {
 		return alphaTestOverrides;
 	}
 

File: src/main/java/net/coderbot/iris/mixin/MixinWorldRenderer.java
Patch:
@@ -50,7 +50,7 @@ public class MixinWorldRenderer {
 	private void iris$beginWorldRender(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager, Matrix4f matrix4f, CallbackInfo callback) {
 		CapturedRenderingState.INSTANCE.setGbufferModelView(matrices.peek().getModel());
 		CapturedRenderingState.INSTANCE.setTickDelta(tickDelta);
-		pipeline = Iris.getPipelineManager().preparePipeline(Iris.getCurrentDimension());
+		pipeline = Iris.getPipelineManager().preparePipeline(Iris.getCurrentDimension(), true);
 		if (pipeline instanceof DeferredWorldRenderingPipeline) {
 			((DeferredWorldRenderingPipeline) pipeline).getUpdateNotifier().onNewFrame();
 		}

File: src/main/java/net/coderbot/iris/pipeline/SodiumTerrainPipeline.java
Patch:
@@ -133,7 +133,7 @@ private static String transformFragmentShader(String base) {
 	}
 
 	public static Optional<SodiumTerrainPipeline> create() {
-		Iris.getPipelineManager().preparePipeline(Iris.getCurrentDimension());
+		Iris.getPipelineManager().preparePipeline(Iris.getCurrentDimension(), false);
 
 		return Iris.getCurrentPack().map(
 			pack -> new SodiumTerrainPipeline(Objects.requireNonNull(pack.getProgramSet(Iris.getCurrentDimension())))

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -351,7 +351,7 @@ public void renderShadows(WorldRendererAccessor worldRenderer, Camera playerCame
 
 		// TODO: I'm sure that this can be improved / optimized.
 		for (Entity entity : getWorld().getEntities()) {
-			if (!dispatcher.shouldRender(entity, entityShadowFrustum, cameraX, cameraY, cameraZ)) {
+			if (!dispatcher.shouldRender(entity, entityShadowFrustum, cameraX, cameraY, cameraZ) || entity.isSpectator()) {
 				continue;
 			}
 

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -162,7 +162,7 @@ private Pair<Program, ProgramDirectives> createProgram(ProgramSource source, Pac
 			throw new RuntimeException("Shader compilation failed!", e);
 		}
 
-		CommonUniforms.addCommonUniforms(builder, source.getParent().getPack().getIdMap(), directives, FrameUpdateNotifier.INSTANCE);
+		CommonUniforms.addCommonUniforms(builder, source.getParent().getPack().getIdMap(), directives, ((DeferredWorldRenderingPipeline) pipeline).getUpdateNotifier());
 		SamplerUniforms.addWorldSamplerUniforms(builder);
 
 		return new Pair<>(builder.build(), source.getDirectives());

File: src/main/java/net/coderbot/iris/gl/program/ProgramBuilder.java
Patch:
@@ -13,7 +13,7 @@
 public class ProgramBuilder extends ProgramUniforms.Builder {
 	private static final ShaderConstants EMPTY_CONSTANTS = ShaderConstants.builder().build();
 
-	private static final ShaderConstants MACRO_CONSTANTS = ShaderConstants.builder()
+	public static final ShaderConstants MACRO_CONSTANTS = ShaderConstants.builder()
 		.define(StandardMacros.getOsString())
 		.define("MC_VERSION", StandardMacros.getMcVersion())
 		.define("MC_GL_VERSION", StandardMacros.getGlVersion(GL20C.GL_VERSION))

File: src/main/java/net/coderbot/iris/fantastic/FlushableVertexConsumerProvider.java
Patch:
@@ -2,4 +2,5 @@
 
 public interface FlushableVertexConsumerProvider {
 	void flushNonTranslucentContent();
+	void flushTranslucentContent();
 }

File: src/main/java/net/coderbot/iris/mixin/MixinWorldRenderer.java
Patch:
@@ -198,6 +198,8 @@ public class MixinWorldRenderer {
 										CallbackInfo ci, Profiler profiler, Vec3d vec3d, double d, double e, double f,
 										Matrix4f matrix4f2, boolean bl, Frustum frustum2, boolean bl3,
 										VertexConsumerProvider.Immediate immediate) {
+		profiler.swap("iris_opaque_entity_draws");
+
 		if (immediate instanceof FlushableVertexConsumerProvider) {
 			((FlushableVertexConsumerProvider) immediate).flushNonTranslucentContent();
 		}

File: src/main/java/net/coderbot/iris/mixin/MixinWorldRenderer.java
Patch:
@@ -77,6 +77,7 @@ public class MixinWorldRenderer {
 			// Prevent nearby chunks from being rebuilt on the main thread in the shadow pass. Aside from causing
 			// FPS to tank, this also causes weird chunk corruption! It's critical to make sure that it's disabled as a
 			// result.
+			MinecraftClient.getInstance().getProfiler().pop();
 			callback.cancel();
 		}
 	}

File: src/main/java/net/coderbot/iris/shadows/ShadowRenderTargets.java
Patch:
@@ -81,10 +81,10 @@ public int getColorTextureId(int index) {
 	}
 
 	public void destroy() {
+		framebuffer.destroy();
+
 		GL20C.glDeleteTextures(targets);
 		depthTexture.destroy();
 		noTranslucents.destroy();
-
-		framebuffer.destroy();
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/MixinWorldRenderer.java
Patch:
@@ -8,6 +8,7 @@
 import net.coderbot.iris.pipeline.WorldRenderingPipeline;
 import net.coderbot.iris.uniforms.CapturedRenderingState;
 import net.coderbot.iris.uniforms.FrameUpdateNotifier;
+import net.minecraft.client.MinecraftClient;
 import net.minecraft.client.options.GameOptions;
 import net.minecraft.client.render.*;
 import net.minecraft.client.util.math.Vector3f;
@@ -58,6 +59,7 @@ public class MixinWorldRenderer {
 	// Inject a bit early so that we can end our rendering in time.
 	@Inject(method = RENDER, at = @At(value = "INVOKE", target = "Lnet/minecraft/client/render/BackgroundRenderer;method_23792()V"))
 	private void iris$endWorldRender(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager, Matrix4f matrix4f, CallbackInfo callback) {
+		MinecraftClient.getInstance().getProfiler().swap("iris_final");
 		pipeline.finalizeWorldRendering();
 		pipeline = null;
 	}
@@ -193,6 +195,7 @@ public class MixinWorldRenderer {
 			((FlushableVertexConsumerProvider) immediate).flushNonTranslucentContent();
 		}
 
+		profiler.swap("iris_pre_translucent");
 		pipeline.beginTranslucents();
 	}
 }

File: src/main/java/kroppeb/stareval/token/ArgsToken.java
Patch:
@@ -19,6 +19,7 @@ public ExpressionToken simplify() {
 		if (this.tokens.size() != 1) {
 			throw new RuntimeException("Brackets that aren't a call, but have 0 or more than 2 items");
 		}
+
 		return this.tokens.get(0).simplify();
 	}
 }

File: src/main/java/kroppeb/stareval/token/CallToken.java
Patch:
@@ -21,6 +21,7 @@ public ExpressionToken simplify() {
 		for (int i = 0; i < this.args.size(); i++) {
 			this.args.set(i, this.args.get(i).simplify());
 		}
+
 		return this;
 	}
 }

File: src/test/java/kroppeb/stareval/parser/ParserTest.java
Patch:
@@ -14,12 +14,12 @@ class ParserTest {
 	void checkIfValidExpressionsParse(String input) throws Exception {
 		parser.parse(input);
 	}
-	
+
 	@ParameterizedTest
 	@CsvFileSource(resources = "/fullyEquivalent.csv", delimiter = ';')
 	void checkOrderOfOperationsParse(String input1, String input2) throws Exception {
 		ExpressionToken exp1 = parser.parse(input1);
 		ExpressionToken exp2 = parser.parse(input2);
-		assertEquals(exp1.simplify() .toString(), exp2.simplify().toString());
+		assertEquals(exp1.simplify().toString(), exp2.simplify().toString());
 	}
 }

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -346,7 +346,7 @@ private static WorldRenderingPipeline createPipeline(DimensionId dimensionId) {
 
 		try {
 			return new NewWorldRenderingPipeline(programs);
-		} catch (Exception e) {
+		} catch (Throwable e) {
 			Iris.logger.error("Couldn't load NewWorldRenderingPipeline, falling back to vanilla shaders.", e);
 			return new FixedFunctionWorldRenderingPipeline();
 		}

File: src/main/java/net/coderbot/iris/gui/GuiUtil.java
Patch:
@@ -31,7 +31,7 @@ private static MinecraftClient client() {
 	 * used for succeeding draw calls.
 	 */
 	public static void bindIrisWidgetsTexture() {
-		client().getTextureManager().bindTexture(IRIS_WIDGETS_TEX);
+		RenderSystem.setShaderTexture(0, IRIS_WIDGETS_TEX);
 	}
 
 	/**
@@ -56,10 +56,10 @@ public static void drawButton(MatrixStack matrices, int x, int y, int width, int
 		int vOffset = disabled ? 46 : hovered ? 86 : 66;
 
 		// Sets RenderSystem to use solid white as the tint color for blend mode, and enables blend mode
-		RenderSystem.blendColor(1.0f, 1.0f, 1.0f, 1.0f);
 		RenderSystem.enableBlend();
 
 		// Sets RenderSystem to be able to use textures when drawing
+		// This doesn't do anything on 1.17
 		RenderSystem.enableTexture();
 
 		// Top left section

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewWorldRenderingPipeline.java
Patch:
@@ -75,7 +75,7 @@ public NewWorldRenderingPipeline(ProgramSet programSet) throws IOException {
 
 		Files.createDirectories(debugOutDir);
 
-		this.renderTargets = new RenderTargets(MinecraftClient.getInstance().getFramebuffer(), programSet.getPackDirectives());
+		this.renderTargets = new RenderTargets(MinecraftClient.getInstance().getFramebuffer(), programSet.getPackDirectives().getRenderTargetDirectives());
 		this.waterId = programSet.getPack().getIdMap().getBlockProperties().getOrDefault(new Identifier("minecraft", "water"), -1);
 		this.sunPathRotation = programSet.getPackDirectives().getSunPathRotation();
 
@@ -104,7 +104,7 @@ public NewWorldRenderingPipeline(ProgramSet programSet) throws IOException {
 			this.terrainTranslucent = this.terrainSolid;
 		}
 
-		int[] buffersToBeCleared = programSet.getPackDirectives().getBuffersToBeCleared().toIntArray();
+		int[] buffersToBeCleared = programSet.getPackDirectives().getRenderTargetDirectives().getBuffersToBeCleared().toIntArray();
 
 		this.clearAltBuffers = renderTargets.createFramebufferWritingToAlt(buffersToBeCleared);
 		this.clearMainBuffers = renderTargets.createFramebufferWritingToMain(buffersToBeCleared);

File: src/main/java/net/coderbot/iris/pipeline/newshader/ExtendedShader.java
Patch:
@@ -2,6 +2,7 @@
 
 import net.coderbot.iris.gl.framebuffer.GlFramebuffer;
 import net.coderbot.iris.gl.program.ProgramUniforms;
+import net.coderbot.iris.gl.uniform.LocationalUniformHolder;
 import net.coderbot.iris.gl.uniform.UniformHolder;
 import net.minecraft.client.render.Shader;
 import net.minecraft.client.render.VertexFormat;
@@ -15,7 +16,7 @@ public class ExtendedShader extends Shader {
 	GlFramebuffer writingTo;
 	GlFramebuffer baseline;
 
-	public ExtendedShader(ResourceFactory resourceFactory, String string, VertexFormat vertexFormat, GlFramebuffer writingTo, GlFramebuffer baseline, Consumer<UniformHolder> uniformCreator) throws IOException {
+	public ExtendedShader(ResourceFactory resourceFactory, String string, VertexFormat vertexFormat, GlFramebuffer writingTo, GlFramebuffer baseline, Consumer<LocationalUniformHolder> uniformCreator) throws IOException {
 		super(resourceFactory, string, vertexFormat);
 
 		int programId = this.getProgramRef();

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderer.java
Patch:
@@ -157,7 +157,6 @@ public void renderAll() {
 		centerDepthSampler.endWorldRendering();
 
 		RenderSystem.disableBlend();
-		RenderSystem.disableAlphaTest();
 
 		final Framebuffer main = MinecraftClient.getInstance().getFramebuffer();
 		final int baseWidth = main.textureWidth;

File: src/main/java/net/coderbot/iris/shaderpack/ProgramDirectives.java
Patch:
@@ -2,14 +2,14 @@
 
 import java.util.Optional;
 
-import net.coderbot.iris.gl.blending.AlphaTestOverride;
+import net.coderbot.iris.gl.blending.AlphaTest;
 import org.jetbrains.annotations.Nullable;
 
 public class ProgramDirectives {
 	private int[] drawBuffers;
 	private float viewportScale;
 	@Nullable
-	private AlphaTestOverride alphaTestOverride;
+	private AlphaTest alphaTestOverride;
 	private boolean disableBlend;
 
 	ProgramDirectives(ProgramSource source, ShaderProperties properties) {
@@ -53,7 +53,7 @@ public float getViewportScale() {
 		return viewportScale;
 	}
 
-	public Optional<AlphaTestOverride> getAlphaTestOverride() {
+	public Optional<AlphaTest> getAlphaTestOverride() {
 		return Optional.ofNullable(alphaTestOverride);
 	}
 

File: src/main/java/net/coderbot/iris/gl/uniform/LocationalUniformHolder.java
Patch:
@@ -61,8 +61,7 @@ default LocationalUniformHolder uniform2f(UniformUpdateFrequency updateFrequency
 
 	@Override
 	default LocationalUniformHolder uniform2i(UniformUpdateFrequency updateFrequency, String name, Supplier<Vec2f> value) {
-		// TODO: Use VEC2I
-		location(name, UniformType.VEC2).ifPresent(id -> addUniform(updateFrequency, new Vector2IntegerUniform(id, value)));
+		location(name, UniformType.VEC2I).ifPresent(id -> addUniform(updateFrequency, new Vector2IntegerUniform(id, value)));
 
 		return this;
 	}

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderer.java
Patch:
@@ -87,8 +87,7 @@ public CompositeRenderer(ProgramSet pack, RenderTargets renderTargets, EmptyShad
 			pass.generateMipmap = new boolean[RenderTargets.MAX_RENDER_TARGETS];
 
 			for (int i = 0; i < pass.generateMipmap.length; i++) {
-				// TODO: This should be per-pass, currently buffer mipmap directives are handled globally...
-				pass.generateMipmap[i] = renderTargetSettings.get(i).shouldGenerateMipmap();
+				pass.generateMipmap[i] = directives.getMipmappedBuffers().contains(i);
 			}
 
 			if (programEntry == programs.get(programs.size() - 1)) {

File: src/main/java/net/coderbot/iris/shaderpack/ProgramSource.java
Patch:
@@ -16,7 +16,7 @@ public ProgramSource(String name, String vertexSource, String geometrySource, St
 		this.geometrySource = geometrySource;
 		this.fragmentSource = fragmentSource;
 		this.parent = parent;
-		this.directives = new ProgramDirectives(this, properties);
+		this.directives = new ProgramDirectives(this, properties, PackRenderTargetDirectives.BASELINE_SUPPORTED_RENDER_TARGETS);
 	}
 
 	public String getName() {

File: src/main/java/net/coderbot/iris/gl/uniform/LocationalUniformHolder.java
Patch:
@@ -54,15 +54,14 @@ default LocationalUniformHolder uniform1b(UniformUpdateFrequency updateFrequency
 
 	@Override
 	default LocationalUniformHolder uniform2f(UniformUpdateFrequency updateFrequency, String name, Supplier<Vec2f> value) {
-		location(name, UniformType.VEC2).ifPresent(id -> addUniform(updateFrequency, new Vector2Uniform(id, value, true)));
+		location(name, UniformType.VEC2).ifPresent(id -> addUniform(updateFrequency, new Vector2Uniform(id, value)));
 
 		return this;
 	}
 
 	@Override
 	default LocationalUniformHolder uniform2i(UniformUpdateFrequency updateFrequency, String name, Supplier<Vec2f> value) {
-		// TODO: Use VEC2I
-		location(name, UniformType.VEC2).ifPresent(id -> addUniform(updateFrequency, new Vector2Uniform(id, value, false)));
+		location(name, UniformType.VEC2I).ifPresent(id -> addUniform(updateFrequency, new Vector2IntegerUniform(id, value)));
 
 		return this;
 	}

File: src/main/java/net/coderbot/iris/uniforms/SamplerUniforms.java
Patch:
@@ -2,6 +2,7 @@
 
 import net.coderbot.iris.gl.uniform.LocationalUniformHolder;
 import net.coderbot.iris.gl.uniform.UniformHolder;
+import net.coderbot.iris.gl.uniform.UniformType;
 import net.coderbot.iris.gl.uniform.UniformUpdateFrequency;
 import net.coderbot.iris.texunits.TextureUnit;
 
@@ -46,7 +47,7 @@ public static void addCommonSamplerUniforms(LocationalUniformHolder uniforms) {
 
 		// Note: This will make it so that "watershadow" is printed twice to the log, oh well
 		// Check if the "watershadow" uniform is active. If so, the "shadow" texture will have a separate texture unit
-		boolean waterShadowEnabled = uniforms.location("watershadow").isPresent();
+		boolean waterShadowEnabled = uniforms.location("watershadow", UniformType.INT).isPresent();
 
 		addSampler(uniforms, waterShadowEnabled ? SHADOW_TEX_1 : SHADOW_TEX_0, "shadow");
 

File: src/main/java/net/coderbot/iris/uniforms/SamplerUniforms.java
Patch:
@@ -2,6 +2,7 @@
 
 import net.coderbot.iris.gl.uniform.LocationalUniformHolder;
 import net.coderbot.iris.gl.uniform.UniformHolder;
+import net.coderbot.iris.gl.uniform.UniformType;
 import net.coderbot.iris.gl.uniform.UniformUpdateFrequency;
 import net.coderbot.iris.texunits.TextureUnit;
 
@@ -49,7 +50,7 @@ public static void addCommonSamplerUniforms(LocationalUniformHolder uniforms) {
 
 		// Note: This will make it so that "watershadow" is printed twice to the log, oh well
 		// Check if the "watershadow" uniform is active. If so, the "shadow" texture will have a separate texture unit
-		boolean waterShadowEnabled = uniforms.location("watershadow").isPresent();
+		boolean waterShadowEnabled = uniforms.location("watershadow", UniformType.INT).isPresent();
 
 		addSampler(uniforms, waterShadowEnabled ? SHADOW_TEX_1 : SHADOW_TEX_0, "shadow");
 

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -149,7 +149,7 @@ private Pair<Program, ProgramDirectives> createProgram(ProgramSource source, Pac
 			throw new RuntimeException("Shader compilation failed!", e);
 		}
 
-		CommonUniforms.addCommonUniforms(builder, source.getParent().getPack().getIdMap(), directives);
+		CommonUniforms.addCommonUniforms(builder, source.getParent().getPack().getIdMap(), directives, FrameUpdateNotifier.INSTANCE);
 		SamplerUniforms.addWorldSamplerUniforms(builder);
 
 		return new Pair<>(builder.build(), source.getDirectives());

File: src/main/java/net/coderbot/iris/mixin/MixinWorldRenderer.java
Patch:
@@ -7,6 +7,7 @@
 import net.coderbot.iris.layer.GbufferPrograms;
 import net.coderbot.iris.pipeline.WorldRenderingPipeline;
 import net.coderbot.iris.uniforms.CapturedRenderingState;
+import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.minecraft.client.options.GameOptions;
 import net.minecraft.client.render.*;
 import net.minecraft.client.util.math.Vector3f;
@@ -49,6 +50,7 @@ public class MixinWorldRenderer {
 		CapturedRenderingState.INSTANCE.setGbufferModelView(matrices.peek().getModel());
 		CapturedRenderingState.INSTANCE.setTickDelta(tickDelta);
 		pipeline = Iris.getPipelineManager().preparePipeline(Iris.getCurrentDimension());
+		FrameUpdateNotifier.INSTANCE.onNewFrame();
 		
 		pipeline.beginWorldRendering();
 	}

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -21,6 +21,7 @@
 import net.coderbot.iris.shaderpack.ProgramSource;
 import net.coderbot.iris.shadows.EmptyShadowMapRenderer;
 import net.coderbot.iris.uniforms.CommonUniforms;
+import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.coderbot.iris.uniforms.SamplerUniforms;
 import net.minecraft.client.texture.AbstractTexture;
 import org.jetbrains.annotations.Nullable;
@@ -350,7 +351,7 @@ private Pass createPass(ProgramSource source) {
 			throw new RuntimeException("Shader compilation failed!", e);
 		}
 
-		CommonUniforms.addCommonUniforms(builder, source.getParent().getPack().getIdMap(), source.getParent().getPackDirectives());
+		CommonUniforms.addCommonUniforms(builder, source.getParent().getPack().getIdMap(), source.getParent().getPackDirectives(), FrameUpdateNotifier.INSTANCE);
 		SamplerUniforms.addWorldSamplerUniforms(builder);
 		SamplerUniforms.addDepthSamplerUniforms(builder);
 		GlFramebuffer framebuffer = renderTargets.createFramebufferWritingToMain(source.getDirectives().getDrawBuffers());

File: src/main/java/net/coderbot/iris/pipeline/SodiumTerrainPipeline.java
Patch:
@@ -11,6 +11,7 @@
 import net.coderbot.iris.shaderpack.transform.StringTransformations;
 import net.coderbot.iris.shaderpack.transform.Transformations;
 import net.coderbot.iris.uniforms.CommonUniforms;
+import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.coderbot.iris.uniforms.SamplerUniforms;
 import net.coderbot.iris.uniforms.builtin.BuiltinReplacementUniforms;
 
@@ -122,7 +123,7 @@ public Optional<String> getTranslucentFragmentShaderSource() {
 	public ProgramUniforms initUniforms(int programId) {
 		ProgramUniforms.Builder uniforms = ProgramUniforms.builder("<sodium shaders>", programId);
 
-		CommonUniforms.addCommonUniforms(uniforms, programSet.getPack().getIdMap(), programSet.getPackDirectives());
+		CommonUniforms.addCommonUniforms(uniforms, programSet.getPack().getIdMap(), programSet.getPackDirectives(), FrameUpdateNotifier.INSTANCE);
 		SamplerUniforms.addWorldSamplerUniforms(uniforms);
 		SamplerUniforms.addDepthSamplerUniforms(uniforms);
 		BuiltinReplacementUniforms.addBuiltinReplacementUniforms(uniforms);

File: src/main/java/net/coderbot/iris/postprocess/CenterDepthSampler.java
Patch:
@@ -2,6 +2,7 @@
 
 import net.coderbot.iris.gl.framebuffer.GlFramebuffer;
 import net.coderbot.iris.rendertarget.RenderTargets;
+import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.coderbot.iris.uniforms.transforms.SmoothedFloat;
 import org.lwjgl.opengl.GL11C;
 
@@ -13,8 +14,8 @@ public class CenterDepthSampler {
 	private boolean hasFirstSample;
 	private boolean everRetrieved;
 
-	public CenterDepthSampler(RenderTargets renderTargets) {
-		centerDepthSmooth = new SmoothedFloat(1.0f, this::sampleCenterDepth);
+	public CenterDepthSampler(RenderTargets renderTargets, FrameUpdateNotifier updateNotifier) {
+		centerDepthSmooth = new SmoothedFloat(1.0f, this::sampleCenterDepth, updateNotifier);
 
 		// Prior to OpenGL 4.1, all framebuffers must have at least 1 color target.
 		depthBufferHolder = renderTargets.createFramebufferWritingToMain(new int[] {0});

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderer.java
Patch:
@@ -21,6 +21,7 @@
 import net.coderbot.iris.shaderpack.ProgramSource;
 import net.coderbot.iris.shadows.EmptyShadowMapRenderer;
 import net.coderbot.iris.uniforms.CommonUniforms;
+import net.coderbot.iris.uniforms.FrameUpdateNotifier;
 import net.coderbot.iris.uniforms.SamplerUniforms;
 import net.minecraft.client.texture.AbstractTexture;
 import org.lwjgl.opengl.GL15C;
@@ -43,7 +44,7 @@ public class CompositeRenderer {
 	final CenterDepthSampler centerDepthSampler;
 
 	public CompositeRenderer(ProgramSet pack, RenderTargets renderTargets, EmptyShadowMapRenderer shadowMapRenderer, AbstractTexture noiseTexture) {
-		centerDepthSampler = new CenterDepthSampler(renderTargets);
+		centerDepthSampler = new CenterDepthSampler(renderTargets, FrameUpdateNotifier.INSTANCE);
 
 		final PackRenderTargetDirectives renderTargetDirectives = pack.getPackDirectives().getRenderTargetDirectives();
 		final Map<Integer, PackRenderTargetDirectives.RenderTargetSettings> renderTargetSettings =
@@ -303,7 +304,7 @@ private Pair<Program, ProgramDirectives> createProgram(ProgramSource source) {
 			throw new RuntimeException("Shader compilation failed!", e);
 		}
 
-		CommonUniforms.addCommonUniforms(builder, source.getParent().getPack().getIdMap(), source.getParent().getPackDirectives());
+		CommonUniforms.addCommonUniforms(builder, source.getParent().getPack().getIdMap(), source.getParent().getPackDirectives(), FrameUpdateNotifier.INSTANCE);
 		SamplerUniforms.addCompositeSamplerUniforms(builder);
 		SamplerUniforms.addDepthSamplerUniforms(builder);
 

File: src/main/java/net/coderbot/iris/vertices/BlockSensitiveBufferBuilder.java
Patch:
@@ -1,6 +1,6 @@
 package net.coderbot.iris.vertices;
 
 public interface BlockSensitiveBufferBuilder {
-	void beginBlock(short block);
+	void beginBlock(short block, short renderType);
 	void endBlock();
 }

File: src/main/java/net/coderbot/iris/mixin/MixinDebugHud.java
Patch:
@@ -25,6 +25,7 @@ private void appendShadowDebugText(CallbackInfoReturnable<List<String>> cir) {
 		List<String> messages = cir.getReturnValue();
 
 		messages.add("");
+		messages.add("[Iris] Shadows: " + ShadowRenderer.OVERALL_DEBUG_STRING);
 		messages.add("[Iris] Shadow Terrain: " + ShadowRenderer.SHADOW_DEBUG_STRING);
 		messages.add("[Iris] Shadow Entities: " + ShadowRenderer.getEntitiesDebugString());
 	}

File: src/main/java/net/coderbot/iris/shaderpack/PackRenderTargetDirectives.java
Patch:
@@ -107,6 +107,7 @@ private void acceptBufferDirectives(DirectiveHolder directives, RenderTargetSett
 				shouldClear -> settings.clear = shouldClear);
 
 		// TODO: Only for composite, deferred, and final
+		// TODO: what happens if clear = false but clearColor is specified?
 		directives.acceptConstVec4Directive(bufferName + "ClearColor",
 				clearColor -> settings.clearColor = clearColor);
 

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -14,7 +14,6 @@
 import net.coderbot.iris.shaderpack.ProgramDirectives;
 import net.coderbot.iris.shaderpack.ProgramSource;
 import net.coderbot.iris.shadow.ShadowMatrices;
-import net.coderbot.iris.shadows.frustum.CullEverythingFrustum;
 import net.coderbot.iris.shadows.CullingDataCache;
 import net.coderbot.iris.shadows.Matrix4fAccess;
 import net.coderbot.iris.uniforms.*;
@@ -114,7 +113,7 @@ private Pair<Program, ProgramDirectives> createProgram(ProgramSource source, Pac
 		return new Pair<>(builder.build(), source.getDirectives());
 	}
 
-	public static MatrixStack creatShadowModelView(float sunPathRotation) {
+	public static MatrixStack createShadowModelView(float sunPathRotation) {
 		// Determine the camera position
 		Vec3d cameraPos = CameraUniforms.getCameraPosition();
 
@@ -144,7 +143,7 @@ public void renderShadows(WorldRendererAccessor worldRenderer, Camera playerCame
 		ACTIVE = true;
 
 		// Create our camera
-		MatrixStack modelView = creatShadowModelView(this.sunPathRotation);
+		MatrixStack modelView = createShadowModelView(this.sunPathRotation);
 		MODELVIEW = modelView.peek().getModel().copy();
 		float[] orthoMatrix = ShadowMatrices.createOrthoMatrix(HALF_PLANE_LENGTH);
 

File: src/main/java/net/coderbot/iris/uniforms/MatrixUniforms.java
Patch:
@@ -21,7 +21,7 @@ public static void addMatrixUniforms(UniformHolder uniforms, PackDirectives dire
 		// TODO: In some cases, gbufferProjectionInverse takes on a value much different than OptiFine...
 		// We need to audit Mojang's linear algebra.
 		addMatrix(uniforms, "Projection", CapturedRenderingState.INSTANCE::getGbufferProjection);
-		addShadowMatrix(uniforms, "ModelView", () -> ShadowRenderer.creatShadowModelView(directives.getSunPathRotation()).peek().getModel().copy());
+		addShadowMatrix(uniforms, "ModelView", () -> ShadowRenderer.createShadowModelView(directives.getSunPathRotation()).peek().getModel().copy());
 		addShadowArrayMatrix(uniforms, "Projection", MatrixUniforms::getShadowProjection);
 	}
 

File: src/main/java/net/coderbot/iris/config/IrisConfig.java
Patch:
@@ -80,7 +80,7 @@ public void setShaderPackName(String name) {
 			save();
 		} catch (IOException e) {
 			Iris.logger.error("Error saving configuration file, unable to set shader pack name");
-			e.printStackTrace();
+			Iris.logger.catching(e);
 		}
 	}
 

File: src/main/java/net/coderbot/iris/gui/element/ShaderPackListWidget.java
Patch:
@@ -60,7 +60,8 @@ public void refresh() {
 
 			this.addEntry(new LabelEntry(PACK_LIST_LABEL));
 		} catch (Throwable e) {
-			e.printStackTrace();
+			Iris.logger.error("Error reading files while constructing selection UI");
+			Iris.logger.catching(e);
 		}
 	}
 

File: src/main/java/net/coderbot/iris/gui/screen/ShaderPackScreen.java
Patch:
@@ -92,7 +92,7 @@ public void filesDragged(List<Path> paths) {
 			try {
 				Files.copy(pack, Iris.SHADERPACKS_DIRECTORY.resolve(fileName));
 			} catch (IOException e) {
-				e.printStackTrace();
+				Iris.logger.warn("Error copying dragged shader pack", e);
 				this.addedPackDialog = new TranslatableText(
 						"options.iris.shaderPackSelection.copyError",
 						fileName
@@ -142,7 +142,7 @@ private void applyChanges() {
 			Iris.reload();
 		} catch (IOException e) {
 			Iris.logger.error("Error reloading shader pack while applying changes!");
-			e.printStackTrace();
+			Iris.logger.catching(e);
 		}
 	}
 }

File: src/main/java/net/coderbot/iris/mixin/MixinInGameHud.java
Patch:
@@ -19,7 +19,7 @@ public class MixinInGameHud {
 	@Inject(method = "render", at = @At("HEAD"), cancellable = true)
 	public void iris$handleHudHidingScreens(MatrixStack matrices, float tickDelta, CallbackInfo ci) {
 		Screen screen = this.client.currentScreen;
-		if(screen instanceof HudHideable) {
+		if (screen instanceof HudHideable) {
 			ci.cancel();
 		}
 	}

File: src/main/java/net/coderbot/iris/gui/element/ShaderPackListWidget.java
Patch:
@@ -40,7 +40,7 @@ protected int getRowTop(int index) {
 	public void refresh() {
 		this.clearEntries();
 		try {
-			Path path = Iris.shaderpacksDirectory;
+			Path path = Iris.SHADERPACKS_DIRECTORY;
 			int index = -1;
 
 			for (String pack : BUILTIN_PACKS) {

File: src/main/java/net/coderbot/iris/mixin/MixinInGameHud.java
Patch:
@@ -17,7 +17,7 @@ public class MixinInGameHud {
 	@Shadow @Final private MinecraftClient client;
 
 	@Inject(method = "render", at = @At("HEAD"), cancellable = true)
-	public void handleTransparentScreens(MatrixStack matrices, float tickDelta, CallbackInfo ci) {
+	public void iris$handleHudHidingScreens(MatrixStack matrices, float tickDelta, CallbackInfo ci) {
 		Screen screen = this.client.currentScreen;
 		if(screen instanceof HudHideable) {
 			ci.cancel();

File: src/main/java/net/coderbot/iris/gui/element/ShaderPackListWidget.java
Patch:
@@ -57,8 +57,7 @@ public void refresh() {
 					try {
 						FileSystem zipSystem = FileSystems.newFileSystem(p, Iris.class.getClassLoader());
 						return Files.exists(zipSystem.getPath("shaders"));
-					}
-					catch (IOException ignored) {
+					} catch (IOException ignored) {
 					}
 				}
 				return false;

File: src/main/java/net/coderbot/iris/rendertarget/NativeImageBackedNoiseTexture.java
Patch:
@@ -26,6 +26,7 @@ private static NativeImage create(int size) {
 		return image;
 	}
 
+	@Override
 	public void upload() {
 		NativeImage image = Objects.requireNonNull(getImage());
 

File: src/main/java/net/coderbot/iris/parsing/IrisFunctions.java
Patch:
@@ -170,7 +170,7 @@ public class IrisFunctions {
 				
 				IrisFunctions.<F2FFunction>add("sin", (a) -> (float) Math.sin(a));
 				IrisFunctions.<F2FFunction>add("cos", (a) -> (float) Math.cos(a));
-				IrisFunctions.<F2FFunction>add("cos", (a) -> (float) Math.tan(a));
+				IrisFunctions.<F2FFunction>add("tan", (a) -> (float) Math.tan(a));
 				IrisFunctions.<F2FFunction>add("asin", (a) -> (float) Math.asin(a));
 				IrisFunctions.<F2FFunction>add("acos", (a) -> (float) Math.acos(a));
 				IrisFunctions.<F2FFunction>add("atan", (a) -> (float) Math.atan(a));

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderer.java
Patch:
@@ -148,6 +148,9 @@ private static final class SwapPass {
 	public void renderAll() {
 		centerDepthSampler.endWorldRendering();
 
+		RenderSystem.disableBlend();
+		RenderSystem.disableAlphaTest();
+
 		final Framebuffer main = MinecraftClient.getInstance().getFramebuffer();
 		final int baseWidth = main.textureWidth;
 		final int baseHeight = main.textureHeight;

File: src/main/java/net/coderbot/iris/gl/program/ProgramBuilder.java
Patch:
@@ -47,7 +47,7 @@ public static ProgramBuilder begin(String name, @Nullable String vertexSource, @
 		vertex = buildShader(ShaderType.VERTEX, name + ".vsh", vertexSource);
 
 		if (geometrySource != null) {
-				geometry = buildShader(ShaderType.GEOMETRY, name + ".gsh", geometrySource);
+			geometry = buildShader(ShaderType.GEOMETRY, name + ".gsh", geometrySource);
 		} else {
 			geometry = null;
 		}

File: src/main/java/net/coderbot/iris/uniforms/custom/cached/BooleanCachedUniform.java
Patch:
@@ -21,7 +21,7 @@ public BooleanCachedUniform(UniformUpdateFrequency updateFrequency, BooleanSuppl
 	protected boolean doUpdate(){
 		boolean prev = this.cached;
 		this.cached = this.supplier.getAsBoolean();
-		return prev == cached;
+		return prev != cached;
 	}
 	
 	@Override

File: src/main/java/net/coderbot/iris/uniforms/custom/cached/FloatCachedUniform.java
Patch:
@@ -20,7 +20,7 @@ public FloatCachedUniform(UniformUpdateFrequency updateFrequency, FloatSupplier
 	protected boolean doUpdate(){
 		float prev = this.cached;
 		this.cached = this.supplier.getAsFloat();
-		return prev == cached;
+		return prev != cached;
 	}
 	
 	@Override

File: src/main/java/net/coderbot/iris/uniforms/custom/cached/IntCachedUniform.java
Patch:
@@ -21,7 +21,7 @@ public IntCachedUniform(UniformUpdateFrequency updateFrequency, IntSupplier supp
 	protected boolean doUpdate(){
 		int prev = this.cached;
 		this.cached = this.supplier.getAsInt();
-		return prev == cached;
+		return prev != cached;
 	}
 	
 	@Override

File: src/main/java/net/coderbot/iris/uniforms/custom/cached/VectorCachedUniform.java
Patch:
@@ -28,7 +28,7 @@ protected boolean doUpdate(){
 			Iris.logger.warn("Cached Uniform supplier gave null back");
 			return false;
 		}
-		if (this.cached.equals(other)){
+		if (!this.cached.equals(other)){
 			this.setFrom(other);
 			return true;
 		}

File: src/main/java/net/coderbot/iris/uniforms/custom/cached/BooleanCachedUniform.java
Patch:
@@ -21,7 +21,7 @@ public BooleanCachedUniform(String name, UniformUpdateFrequency updateFrequency,
 	protected boolean doUpdate(){
 		boolean prev = this.cached;
 		this.cached = this.supplier.getAsBoolean();
-		return prev == cached;
+		return prev != cached;
 	}
 	
 	@Override

File: src/main/java/net/coderbot/iris/uniforms/custom/cached/FloatCachedUniform.java
Patch:
@@ -20,7 +20,7 @@ public FloatCachedUniform(String name, UniformUpdateFrequency updateFrequency, F
 	protected boolean doUpdate(){
 		float prev = this.cached;
 		this.cached = this.supplier.getAsFloat();
-		return prev == cached;
+		return prev != cached;
 	}
 	
 	@Override

File: src/main/java/net/coderbot/iris/uniforms/custom/cached/IntCachedUniform.java
Patch:
@@ -21,7 +21,7 @@ public IntCachedUniform(String name, UniformUpdateFrequency updateFrequency, Int
 	protected boolean doUpdate(){
 		int prev = this.cached;
 		this.cached = this.supplier.getAsInt();
-		return prev == cached;
+		return prev != cached;
 	}
 	
 	@Override

File: src/main/java/net/coderbot/iris/uniforms/custom/cached/VectorCachedUniform.java
Patch:
@@ -28,7 +28,7 @@ protected boolean doUpdate(){
 			Iris.logger.warn("Cached Uniform supplier gave null back");
 			return false;
 		}
-		if (this.cached.equals(other)){
+		if (!this.cached.equals(other)){
 			this.setFrom(other);
 			return true;
 		}

File: src/main/java/net/coderbot/iris/mixin/MixinWorldRenderer.java
Patch:
@@ -96,8 +96,8 @@ public class MixinWorldRenderer {
 	}
 
 	@Inject(method = RENDER_SKY, at = @At(value = "INVOKE", target = "Lnet/minecraft/client/world/ClientWorld;getSkyAngle(F)F"),
-		slice = @Slice(from = @At(value = "FIELD", target = "Lnet/minecraft/client/util/math/Vector3f;POSITIVE_Y:Lnet/minecraft/client/util/math/Vector3f;")))
-	private void iris$renderSky$tiltSun(MatrixStack matrices, float tickDelta, CallbackInfo callback) {
+			slice = @Slice(from = @At(value = "FIELD", target = "Lnet/minecraft/util/math/Vec3f;POSITIVE_Y:Lnet/minecraft/util/math/Vec3f;")))
+	private void iris$renderSky$tiltSun(MatrixStack matrices, Matrix4f projectionMatrix, float f, CallbackInfo callback) {
 		matrices.multiply(Vec3f.POSITIVE_Z.getDegreesQuaternion(pipeline.getSunPathRotation()));
 	}
 

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -61,7 +61,7 @@ public static Shader create(String name, ProgramSource source, float alpha, Vert
 		ResourceFactory shaderResourceFactory = new IrisProgramResourceFactory(shaderJson, vertex, fragment);
 
 		return new ExtendedShader(shaderResourceFactory, name, vertexFormat, uniforms -> {
-			CommonUniforms.addCommonUniforms(uniforms, source.getParent().getPack().getIdMap());
+			CommonUniforms.addCommonUniforms(uniforms, source.getParent().getPack().getIdMap(), source.getParent().getPackDirectives());
 			SamplerUniforms.addWorldSamplerUniforms(uniforms);
 			SamplerUniforms.addDepthSamplerUniforms(uniforms);
 			BuiltinReplacementUniforms.addBuiltinReplacementUniforms(uniforms);

File: src/main/java/net/coderbot/iris/pipeline/newshader/NewShaderTests.java
Patch:
@@ -8,6 +8,7 @@
 import net.coderbot.iris.uniforms.builtin.BuiltinReplacementUniforms;
 import net.coderbot.iris.vertices.IrisVertexFormats;
 import net.minecraft.client.render.Shader;
+import net.minecraft.client.render.VertexFormat;
 import net.minecraft.resource.Resource;
 import net.minecraft.resource.ResourceFactory;
 import net.minecraft.resource.metadata.ResourceMetadataReader;
@@ -20,7 +21,7 @@
 import java.nio.charset.StandardCharsets;
 
 public class NewShaderTests {
-	public static Shader create(String name, ProgramSource source, float alpha, boolean hasColorAttrib) throws IOException{
+	public static Shader create(String name, ProgramSource source, float alpha, VertexFormat vertexFormat, boolean hasColorAttrib) throws IOException{
 		String vertex = TriforcePatcher.patch(source.getVertexSource().orElseThrow(RuntimeException::new), ShaderType.VERTEX, alpha, true, hasColorAttrib);
 		String fragment = TriforcePatcher.patch(source.getFragmentSource().orElseThrow(RuntimeException::new), ShaderType.FRAGMENT, alpha, true, hasColorAttrib);
 
@@ -59,8 +60,7 @@ public static Shader create(String name, ProgramSource source, float alpha, bool
 
 		ResourceFactory shaderResourceFactory = new IrisProgramResourceFactory(shaderJson, vertex, fragment);
 
-		// TODO: Not always the same vertex format.
-		return new ExtendedShader(shaderResourceFactory, name, IrisVertexFormats.TERRAIN, uniforms -> {
+		return new ExtendedShader(shaderResourceFactory, name, vertexFormat, uniforms -> {
 			CommonUniforms.addCommonUniforms(uniforms, source.getParent().getPack().getIdMap());
 			SamplerUniforms.addWorldSamplerUniforms(uniforms);
 			SamplerUniforms.addDepthSamplerUniforms(uniforms);

File: src/main/java/net/coderbot/iris/uniforms/CelestialUniforms.java
Patch:
@@ -70,7 +70,7 @@ private static Vector4f getCelestialPosition(float y) {
 		// This is because we need the result of it before it's actually performed in vanilla.
 		celestial.multiply(Vec3f.POSITIVE_Y.getDegreesQuaternion(-90.0F));
 		// TODO: Don't hardcode the sunPathRotation here
-		celestial.multiply(Vec3f.POSITIVE_Z.getDegreesQuaternion(-40.0F));
+		// TODO(20w10a): celestial.multiply(Vec3f.POSITIVE_Z.getDegreesQuaternion(-40.0F));
 		celestial.multiply(Vec3f.POSITIVE_X.getDegreesQuaternion(getSkyAngle() * 360.0F));
 
 		position.transform(celestial);

File: src/main/java/net/coderbot/iris/pipeline/newshader/TriforcePatcher.java
Patch:
@@ -62,6 +62,9 @@ public static String patch(String source, ShaderType type) {
 		transformations.injectLine(Transformations.InjectionPoint.AFTER_VERSION, "#define gl_Normal Normal");
 		transformations.injectLine(Transformations.InjectionPoint.AFTER_VERSION, "in vec3 Normal;");
 
+		// TODO: Should probably add the normal matrix as a proper uniform that's computed on the CPU-side of things
+		transformations.injectLine(Transformations.InjectionPoint.AFTER_VERSION, "#define gl_NormalMatrix mat3(transpose(inverse(gl_ModelViewMatrix)))");
+
 		transformations.injectLine(Transformations.InjectionPoint.AFTER_VERSION, "#define gl_Vertex vec4(Position, 1.0)");
 		transformations.injectLine(Transformations.InjectionPoint.AFTER_VERSION, "in vec3 Position;");
 

File: src/main/java/net/coderbot/iris/mixin/fantastic/MixinBlockDustParticle.java
Patch:
@@ -7,6 +7,7 @@
 import net.minecraft.client.render.RenderLayer;
 import net.minecraft.client.render.RenderLayers;
 import net.minecraft.client.world.ClientWorld;
+import net.minecraft.util.math.BlockPos;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Unique;
 import org.spongepowered.asm.mixin.injection.At;
@@ -19,8 +20,8 @@ public class MixinBlockDustParticle {
 	@Unique
 	private boolean isOpaque;
 
-	@Inject(method = "<init>(Lnet/minecraft/client/world/ClientWorld;DDDDDDLnet/minecraft/block/BlockState;)V", at = @At("RETURN"))
-	private void iris$resolveTranslucency(ClientWorld world, double x, double y, double z, double velocityX, double velocityY, double velocityZ, BlockState blockState, CallbackInfo callback) {
+	@Inject(method = "<init>(Lnet/minecraft/client/world/ClientWorld;DDDDDDLnet/minecraft/block/BlockState;Lnet/minecraft/util/math/BlockPos;)V", at = @At("RETURN"))
+	private void iris$resolveTranslucency(ClientWorld world, double x, double y, double z, double velocityX, double velocityY, double velocityZ, BlockState blockState, BlockPos pos, CallbackInfo callback) {
 		RenderLayer layer = RenderLayers.getBlockLayer(blockState);
 
 		if (layer == RenderLayer.getSolid() || layer == RenderLayer.getCutout() || layer == RenderLayer.getCutoutMipped()) {

File: src/main/java/net/coderbot/iris/rendertarget/NoiseTexture.java
Patch:
@@ -5,6 +5,7 @@
 
 import com.mojang.blaze3d.platform.GlStateManager;
 import net.coderbot.iris.gl.GlResource;
+import net.coderbot.iris.gl.texture.TextureUploadHelper;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL13C;
 
@@ -36,6 +37,8 @@ void resize(int width, int height) {
 		GlStateManager.bindTexture(getGlId());
 
 		ByteBuffer pixels = generateNoise();
+
+		TextureUploadHelper.resetTextureUploadState();
 		GL11C.glTexImage2D(GL11C.GL_TEXTURE_2D, 0, GL11C.GL_RGB, width, height, 0, GL11C.GL_RGB, GL11C.GL_UNSIGNED_BYTE, pixels);
 
 		GlStateManager.bindTexture(0);

File: src/main/java/net/coderbot/iris/rendertarget/SingleColorTexture.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.mojang.blaze3d.platform.GlStateManager;
 import net.coderbot.iris.gl.GlResource;
+import net.coderbot.iris.gl.texture.TextureUploadHelper;
 import org.lwjgl.BufferUtils;
 import org.lwjgl.opengl.GL11C;
 import org.lwjgl.opengl.GL13C;
@@ -24,6 +25,8 @@ public SingleColorTexture(int red, int green, int blue, int alpha) {
 		GL11C.glTexParameteri(GL11C.GL_TEXTURE_2D, GL11C.GL_TEXTURE_MAG_FILTER, GL11C.GL_LINEAR);
 		GL11C.glTexParameteri(GL11C.GL_TEXTURE_2D, GL11C.GL_TEXTURE_WRAP_S, GL13C.GL_REPEAT);
 		GL11C.glTexParameteri(GL11C.GL_TEXTURE_2D, GL11C.GL_TEXTURE_WRAP_T, GL13C.GL_REPEAT);
+
+		TextureUploadHelper.resetTextureUploadState();
 		GL11C.glTexImage2D(GL11C.GL_TEXTURE_2D, 0, GL11C.GL_RGBA, 1, 1, 0, GL11C.GL_RGBA, GL11C.GL_UNSIGNED_BYTE, pixel);
 
 		GlStateManager.bindTexture(0);

File: src/main/java/net/coderbot/iris/mixin/vertices/MixinChunkRebuildTask.java
Patch:
@@ -62,8 +62,7 @@ private short resolveBlockId(BlockState state) {
 			return -1;
 		}
 
-		Identifier id = Registry.BLOCK.getId(state.getBlock());
-		return (short) (int) idMap.getBlockProperties().getOrDefault(id, -1);
+		return (short) (int) idMap.getBlockProperties().getOrDefault(state, -1);
 	}
 
 	@Inject(method = RENDER, at = @At(value = "INVOKE", target = "Lnet/minecraft/client/render/block/BlockRenderManager;renderFluid(Lnet/minecraft/util/math/BlockPos;Lnet/minecraft/world/BlockRenderView;Lnet/minecraft/client/render/VertexConsumer;Lnet/minecraft/fluid/FluidState;)Z"), locals = LocalCapture.CAPTURE_FAILHARD)

File: src/main/java/net/coderbot/iris/pipeline/SodiumTerrainPipeline.java
Patch:
@@ -11,6 +11,7 @@
 import net.coderbot.iris.shaderpack.transform.StringTransformations;
 import net.coderbot.iris.shaderpack.transform.Transformations;
 import net.coderbot.iris.uniforms.CommonUniforms;
+import net.coderbot.iris.uniforms.SamplerUniforms;
 import net.coderbot.iris.uniforms.builtin.BuiltinReplacementUniforms;
 
 public class SodiumTerrainPipeline {
@@ -120,6 +121,8 @@ public ProgramUniforms initUniforms(int programId) {
 		ProgramUniforms.Builder uniforms = ProgramUniforms.builder("<sodium shaders>", programId);
 
 		CommonUniforms.addCommonUniforms(uniforms, programSet.getPack().getIdMap());
+		SamplerUniforms.addWorldSamplerUniforms(uniforms);
+		SamplerUniforms.addDepthSamplerUniforms(uniforms);
 		BuiltinReplacementUniforms.addBuiltinReplacementUniforms(uniforms);
 
 		return uniforms.buildUniforms();

File: src/main/java/net/coderbot/iris/uniforms/CelestialUniforms.java
Patch:
@@ -94,7 +94,7 @@ private static Vector4f getUpPosition() {
 		return upVector;
 	}
 
-	private static boolean isDay() {
+	public static boolean isDay() {
 		// Determine whether it is day or night based on the sky angle.
 		//
 		// World#isDay appears to do some nontrivial calculations that appear to not entirely work for us here.

File: src/main/java/net/coderbot/iris/pipeline/ShadowRenderer.java
Patch:
@@ -17,6 +17,7 @@
 import net.coderbot.iris.uniforms.CameraUniforms;
 import net.coderbot.iris.uniforms.CapturedRenderingState;
 import net.coderbot.iris.uniforms.CommonUniforms;
+import net.coderbot.iris.uniforms.SamplerUniforms;
 import net.minecraft.client.MinecraftClient;
 import net.minecraft.client.gl.GlProgramManager;
 import net.minecraft.client.render.RenderLayer;
@@ -78,14 +79,15 @@ private Pair<Program, ProgramDirectives> createProgram(ProgramSource source) {
 		ProgramBuilder builder;
 
 		try {
-			builder = ProgramBuilder.begin(source.getName(), source.getVertexSource().orElse(null),
+			builder = ProgramBuilder.begin(source.getName(), source.getVertexSource().orElse(null), source.getGeometrySource().orElse(null),
 					source.getFragmentSource().orElse(null));
 		} catch (RuntimeException e) {
 			// TODO: Better error handling
 			throw new RuntimeException("Shader compilation failed!", e);
 		}
 
 		CommonUniforms.addCommonUniforms(builder, source.getParent().getPack().getIdMap());
+		SamplerUniforms.addWorldSamplerUniforms(builder);
 
 		return new Pair<>(builder.build(), source.getDirectives());
 	}

File: src/main/java/net/coderbot/iris/gl/shader/ShaderType.java
Patch:
@@ -3,12 +3,14 @@
 package net.coderbot.iris.gl.shader;
 
 import org.lwjgl.opengl.GL20;
+import org.lwjgl.opengl.GL32C;
 
 /**
  * An enumeration over the supported OpenGL shader types.
  */
 public enum ShaderType {
     VERTEX(GL20.GL_VERTEX_SHADER),
+	GEOMETRY(GL32C.GL_GEOMETRY_SHADER),
     FRAGMENT(GL20.GL_FRAGMENT_SHADER);
 
     public final int id;

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -323,7 +323,7 @@ private Pass createPass(ProgramSource source) {
 		ProgramBuilder builder;
 
 		try {
-			builder = ProgramBuilder.begin(source.getName(), source.getVertexSource().orElse(null),
+			builder = ProgramBuilder.begin(source.getName(), source.getVertexSource().orElse(null), source.getGeometrySource().orElse(null),
 				source.getFragmentSource().orElse(null));
 		} catch (RuntimeException e) {
 			// TODO: Better error handling

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderer.java
Patch:
@@ -243,7 +243,7 @@ private Pair<Program, ProgramDirectives> createProgram(ProgramSource source) {
 		ProgramBuilder builder;
 
 		try {
-			builder = ProgramBuilder.begin(source.getName(), source.getVertexSource().orElse(null),
+			builder = ProgramBuilder.begin(source.getName(), source.getVertexSource().orElse(null), source.getGeometrySource().orElse(null),
 				source.getFragmentSource().orElse(null));
 		} catch (RuntimeException e) {
 			// TODO: Better error handling

File: src/main/java/net/coderbot/iris/uniforms/MatrixUniforms.java
Patch:
@@ -34,7 +34,7 @@ private static void addMatrix(UniformHolder uniforms, String name, Supplier<Matr
 	private static void addShadowMatrix(UniformHolder uniforms, String name, Supplier<Matrix4f> supplier) {
 		uniforms
 				.uniformMatrix(PER_FRAME, "shadow" + name, supplier)
-				.uniformMatrix(PER_FRAME, "shadow" + name + "Inverse", new Inverted.Inverted(supplier));
+				.uniformJomlMatrix(PER_FRAME, "shadow" + name + "Inverse", new Inverted(supplier));
 	}
 
 	private static void addShadowArrayMatrix(UniformHolder uniforms, String name, Supplier<float[]> supplier) {

File: src/main/java/net/coderbot/iris/vertices/BlockSensitiveBufferBuilder.java
Patch:
@@ -1,8 +1,6 @@
 package net.coderbot.iris.vertices;
 
-import net.minecraft.block.BlockState;
-
 public interface BlockSensitiveBufferBuilder {
-	void beginBlock(BlockState state);
+	void beginBlock(short block);
 	void endBlock();
 }

File: src/main/java/net/coderbot/iris/vertices/BlockSensitiveBufferBuilder.java
Patch:
@@ -4,4 +4,5 @@
 
 public interface BlockSensitiveBufferBuilder {
 	void beginBlock(BlockState state);
+	void endBlock();
 }

File: src/main/java/net/coderbot/iris/mixin/vertices/MixinBufferBuilder.java
Patch:
@@ -158,6 +158,7 @@ public void beginBlock(BlockState state) {
 
 	@Unique
 	private static short resolveBlockId(BlockState state) {
+		// TODO: This is not thread safe! It could crash during shader reloads...
 		Identifier id = Registry.BLOCK.getId(state.getBlock());
 		return (short) (int) Iris.getCurrentPack().getIdMap().getBlockProperties().getOrDefault(id, -1);
 	}

File: src/main/java/net/coderbot/iris/mixin/fantastic/MixinParticleManager.java
Patch:
@@ -1,6 +1,7 @@
 package net.coderbot.iris.mixin.fantastic;
 
 import com.google.common.collect.ImmutableList;
+import net.coderbot.iris.fantastic.IrisParticleTextureSheets;
 import net.coderbot.iris.fantastic.ParticleRenderingPhase;
 import net.coderbot.iris.fantastic.PhasedParticleManager;
 import net.minecraft.client.particle.ParticleManager;
@@ -53,6 +54,7 @@ public class MixinParticleManager implements PhasedParticleManager {
 
 	static {
 		OPAQUE_PARTICLE_TEXTURE_SHEETS = ImmutableList.of(
+			IrisParticleTextureSheets.OPAQUE_TERRAIN_SHEET,
 			ParticleTextureSheet.PARTICLE_SHEET_OPAQUE,
 			ParticleTextureSheet.PARTICLE_SHEET_LIT,
 			ParticleTextureSheet.CUSTOM,

File: src/main/java/net/coderbot/iris/pipeline/DeferredWorldRenderingPipeline.java
Patch:
@@ -126,8 +126,8 @@ public DeferredWorldRenderingPipeline(ProgramSet programs) {
 		GlStateManager.pixelStore(GL20C.GL_UNPACK_ALIGNMENT, 4);
 
 		// Create some placeholder PBR textures for now
-		normals = new SingleColorTexture(0xFF7F7FFF);
-		specular = new SingleColorTexture(0);
+		normals = new SingleColorTexture(127, 127, 255, 255);
+		specular = new SingleColorTexture(0, 0, 0, 0);
 		GlStateManager.activeTexture(GL20C.GL_TEXTURE0);
 
 		this.shadowMapRenderer = new EmptyShadowMapRenderer(2048);

File: src/main/java/net/coderbot/iris/texunits/TextureUnit.java
Patch:
@@ -5,8 +5,8 @@
 public enum TextureUnit {
 	TERRAIN(0),
 	LIGHTMAP(1),
-	// TODO: Relocate this to a different texture unit, this is used by the normal map for normal shaders
-	OVERLAY(2);
+	// TODO: Relocate this to a different texture unit, this is used by depthtex0...
+	OVERLAY(6);
 
 	private final int samplerId;
 	private final int unitId;

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -52,6 +52,8 @@ public static void addCommonUniforms(UniformHolder uniforms, IdMap idMap) {
 			.uniform1i(ONCE, "lightmap", TextureUnit.LIGHTMAP::getSamplerId)
 			.uniform1b(PER_FRAME, "hideGUI", () -> client.options.hudHidden)
 			.uniform1i(ONCE, "noisetex", () -> 15)
+			.uniform1i(ONCE, "normals", () -> 2)
+			.uniform1i(ONCE, "specular", () -> 3)
 			.uniform1i(ONCE, "shadowtex0", () -> 4)
 			.uniform1i(ONCE, "shadowtex1", () -> 5)
 			.uniform1f(PER_FRAME, "eyeAltitude", () -> Objects.requireNonNull(client.getCameraEntity()).getEyeY())

File: src/main/java/net/coderbot/iris/shaderpack/ConstDirectiveParser.java
Patch:
@@ -108,7 +108,7 @@ public static Optional<ConstDirective> findDirectiveInLine(String line) {
 			return Optional.empty();
 		}
 
-		String value = remaining.substring(0, equalsIndex).trim();
+		String value = remaining.substring(0, semicolonIndex).trim();
 
 		// The value must be a "word" (alphanumeric & underscore characters)
 		if (!isWord(value)) {

File: src/main/java/net/coderbot/iris/uniforms/CelestialUniforms.java
Patch:
@@ -69,6 +69,7 @@ private static Vector4f getCelestialPosition(float y) {
 		// This is the same transformation applied by renderSky, however, it's been moved to here.
 		// This is because we need the result of it before it's actually performed in vanilla.
 		celestial.multiply(Vector3f.POSITIVE_Y.getDegreesQuaternion(-90.0F));
+		celestial.multiply(Vector3f.POSITIVE_Z.getDegreesQuaternion(-40.0F));
 		celestial.multiply(Vector3f.POSITIVE_X.getDegreesQuaternion(getSkyAngle() * 360.0F));
 
 		position.transform(celestial);

File: src/vendored/java/net/coderbot/iris/vendored/joml/Options.java
Patch:
@@ -47,7 +47,7 @@ public final class Options {
     /**
      * Whether <i>not</i> to use sun.misc.Unsafe when copying memory with MemUtil.
      */
-    public static final boolean NO_UNSAFE = hasOption(System.getProperty("joml.nounsafe", "false"));
+    public static final boolean NO_UNSAFE = true; //hasOption(System.getProperty("joml.nounsafe", "false"));
     /**
      * Whether to <i>force</i> the use of sun.misc.Unsafe when copying memory with MemUtil.
      */

File: src/main/java/net/coderbot/iris/mixin/MixinWorldRenderer.java
Patch:
@@ -53,7 +53,7 @@ public class MixinWorldRenderer {
 
 	@Inject(method = RENDER, at = @At(value = "INVOKE", target = "Lnet/minecraft/client/render/WorldRenderer;updateChunks(J)V"))
 	private void iris$renderTerrainShadows(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager, Matrix4f matrix4f, CallbackInfo callback) {
-		Iris.getPipeline().shadowRenderer.renderShadows((WorldRendererAccessor) this);
+		Iris.getPipeline().renderShadows((WorldRendererAccessor) this);
 	}
 
 	@Inject(method = RENDER, at = @At(value = "INVOKE", target = CLEAR))

File: src/main/java/net/coderbot/iris/pipeline/ShaderPipeline.java
Patch:
@@ -109,7 +109,7 @@ public ShaderPipeline(ProgramSet programs) {
 		this.baseline = renderTargets.createFramebufferWritingToMain(new int[] {0});
 
 		this.compositeRenderer = new CompositeRenderer(programs, renderTargets);
-		this.shadowRenderer = new ShadowRenderer(pack.getShadow().orElse(null));
+		this.shadowRenderer = new ShadowRenderer(programs.getShadow().orElse(null));
 	}
 
 	public void pushProgram(GbufferProgram program) {

File: src/main/java/net/coderbot/iris/layer/GbufferProgram.java
Patch:
@@ -2,6 +2,7 @@
 
 public enum GbufferProgram {
 	NONE,
+	CLEAR,
 	BASIC,
 	TEXTURED,
 	TEXTURED_LIT,

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -52,6 +52,8 @@ public static void addCommonUniforms(UniformHolder uniforms, IdMap idMap) {
 			.uniform1i(ONCE, "lightmap", TextureUnit.LIGHTMAP::getSamplerId)
 			.uniform1b(PER_FRAME, "hideGUI", () -> client.options.hudHidden)
 			.uniform1i(ONCE, "noisetex", () -> 15)
+			.uniform1i(ONCE, "shadowtex0", () -> 4)
+			.uniform1i(ONCE, "shadowtex1", () -> 5)
 			.uniform1f(PER_FRAME, "eyeAltitude", () -> Objects.requireNonNull(client.getCameraEntity()).getEyeY())
 			.uniform1i(PER_FRAME, "isEyeInWater", CommonUniforms::isEyeInWater)
 			.uniform1f(PER_FRAME, "blindness", CommonUniforms::getBlindness)

File: src/main/java/net/coderbot/iris/mixin/MixinWorldRenderer.java
Patch:
@@ -39,9 +39,6 @@ public class MixinWorldRenderer {
 	@Inject(method = RENDER, at = @At("HEAD"))
 	private void iris$beginWorldRender(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager, Matrix4f matrix4f, CallbackInfo callback) {
 		CapturedRenderingState.INSTANCE.setGbufferModelView(matrices.peek().getModel());
-		// TODO: This makes BSL reflections less wacky but makes the sky not bob with everything else on Sildur's
-		// Closer investigation is necessary
-		// CapturedRenderingState.INSTANCE.setGbufferProjection(gameRenderer.getBasicProjectionMatrix(camera, tickDelta, true));
 		CapturedRenderingState.INSTANCE.setTickDelta(tickDelta);
 		Iris.checkDimension();
 		Iris.getPipeline().beginWorldRender();

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -157,7 +157,7 @@ private static Optional<Path> loadExternalZipShaderpack(Path shaderpackPath) {
 			Path root = zipSystem.getRootDirectories().iterator().next();//should only be one root directory for a zip shaderpack
 
 			Path potentialShaderDir = zipSystem.getPath("shaders");
-			//if the shaders dir was immediatly found return it
+			//if the shaders dir was immediately found return it
 			//otherwise, manually search through each directory path until it ends with "shaders"
 			if (Files.exists(potentialShaderDir)) {
 				return Optional.of(potentialShaderDir);

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -157,7 +157,7 @@ private static Optional<Path> loadExternalZipShaderpack(Path shaderpackPath) {
 			Path root = zipSystem.getRootDirectories().iterator().next();//should only be one root directory for a zip shaderpack
 
 			Path potentialShaderDir = zipSystem.getPath("shaders");
-			//if the shaders dir was immediatly found return it
+			//if the shaders dir was immediately found return it
 			//otherwise, manually search through each directory path until it ends with "shaders"
 			if (Files.exists(potentialShaderDir)) {
 				return Optional.of(potentialShaderDir);

File: src/main/java/net/coderbot/iris/mixin/gbuffer/MixinWorldRenderer.java
Patch:
@@ -18,7 +18,7 @@ public class MixinWorldRenderer {
 	private static final String RENDER = "render(Lnet/minecraft/client/util/math/MatrixStack;FJZLnet/minecraft/client/render/Camera;Lnet/minecraft/client/render/GameRenderer;Lnet/minecraft/client/render/LightmapTextureManager;Lnet/minecraft/util/math/Matrix4f;)V";
 
 	@Inject(method = RENDER, at = @At(value = "INVOKE", target = "Lnet/minecraft/client/render/BackgroundRenderer;render(Lnet/minecraft/client/render/Camera;FLnet/minecraft/client/world/ClientWorld;IF)V"))
-	private void iris$afterClear(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline,
+	private void iris$beforeClear(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline,
 								Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager,
 								Matrix4f matrix4f, CallbackInfo callback) {
 		Iris.getPipeline().prepareRenderTargets();

File: src/main/java/net/coderbot/iris/gl/shader/GlShader.java
Patch:
@@ -20,7 +20,7 @@ public class GlShader extends GlResource {
     private final String name;
 
     public GlShader(ShaderType type, String name, String src, ShaderConstants constants) {
-    	super(createShader(type, src, name, constants));
+    	super(createShader(type, name, src, constants));
 
         this.name = name;
     }

File: src/main/java/net/coderbot/iris/gl/shader/ProgramCreator.java
Patch:
@@ -9,7 +9,7 @@
 public class ProgramCreator {
 	private static final Logger LOGGER = LogManager.getLogger(ProgramCreator.class);
 
-	public int create(String name, GlShader... shaders) {
+	public static int create(String name, GlShader... shaders) {
 		int program = GL20C.glCreateProgram();
 
 		for (GlShader shader : shaders) {

File: src/main/java/net/coderbot/iris/pipeline/ShaderPipeline.java
Patch:
@@ -253,7 +253,7 @@ private Pass createPass(ShaderPack.ProgramSource source) {
 		try {
 			builder = ProgramBuilder.begin(source.getName(), source.getVertexSource().orElse(null),
 				source.getFragmentSource().orElse(null));
-		} catch (IOException e) {
+		} catch (RuntimeException e) {
 			// TODO: Better error handling
 			throw new RuntimeException("Shader compilation failed!", e);
 		}

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderer.java
Patch:
@@ -192,7 +192,7 @@ private Pair<Program, ProgramDirectives> createProgram(ShaderPack.ProgramSource
 		try {
 			builder = ProgramBuilder.begin(source.getName(), source.getVertexSource().orElse(null),
 				source.getFragmentSource().orElse(null));
-		} catch (IOException e) {
+		} catch (RuntimeException e) {
 			// TODO: Better error handling
 			throw new RuntimeException("Shader compilation failed!", e);
 		}

File: src/main/java/net/coderbot/iris/mixin/MixinWorldRenderer.java
Patch:
@@ -149,7 +149,7 @@ public class MixinWorldRenderer {
 		CapturedRenderingState.INSTANCE.setCurrentBlockEntity(blockEntity2);
 	}*/
 
-	@Inject(method = RENDER, at = @At(value = "FIELD", target = "Lnet/minecraft/client/render/WorldRenderer;transparencyShader:Lnet/minecraft/client/gl/ShaderEffect;"))
+	@Inject(method = RENDER, at = @At(value = "CONSTANT", args = "stringValue=translucent"))
 	private void iris$copyCurrentDepthTexture(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager, Matrix4f matrix4f, CallbackInfo callback) {
 		Iris.getPipeline().copyCurrentDepthTexture();
 	}

File: src/main/java/net/coderbot/iris/layer/GbufferProgram.java
Patch:
@@ -1,6 +1,7 @@
 package net.coderbot.iris.layer;
 
 public enum GbufferProgram {
+	NONE,
 	BASIC,
 	TEXTURED,
 	TEXTURED_LIT,

File: src/main/java/net/coderbot/iris/gl/uniform/Vector2Uniform.java
Patch:
@@ -24,7 +24,7 @@ public class Vector2Uniform extends Uniform {
 	public void update() {
 		Vec2f newValue = value.get();
 
-		if (!newValue.equals(cachedValue)) {
+		if (cachedValue == null || !newValue.equals(cachedValue)) {
 			cachedValue = newValue;
 			if (floatingPoint) {
 				GL20.glUniform2f(this.location, newValue.x, newValue.y);

File: src/main/java/net/coderbot/iris/mixin/MixinWorldRenderer.java
Patch:
@@ -37,7 +37,9 @@ public class MixinWorldRenderer {
 	@Inject(method = RENDER, at = @At("HEAD"))
 	private void iris$beginWorldRender(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager, Matrix4f matrix4f, CallbackInfo callback) {
 		CapturedRenderingState.INSTANCE.setGbufferModelView(matrices.peek().getModel());
-		CapturedRenderingState.INSTANCE.setGbufferProjection(gameRenderer.getBasicProjectionMatrix(camera, tickDelta, true));
+		// TODO: This makes BSL reflections less wacky but makes the sky not bob with everything else on Sildur's
+		// Closer investigation is necessary
+		// CapturedRenderingState.INSTANCE.setGbufferProjection(gameRenderer.getBasicProjectionMatrix(camera, tickDelta, true));
 		CapturedRenderingState.INSTANCE.setTickDelta(tickDelta);
 		Iris.getPipeline().beginWorldRender();
 	}

File: src/main/java/net/coderbot/iris/mixin/MixinWorldRenderer.java
Patch:
@@ -42,7 +42,8 @@ public class MixinWorldRenderer {
 		Iris.getPipeline().beginWorldRender();
 	}
 
-	@Inject(method = RENDER, at = @At("RETURN"))
+	// Inject a bit early so that we can end our rendering in time.
+	@Inject(method = RENDER, at = @At(value = "INVOKE", target = "Lnet/minecraft/client/render/BackgroundRenderer;method_23792()V"))
 	private void iris$endWorldRender(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager, Matrix4f matrix4f, CallbackInfo callback) {
 		Iris.getPipeline().endWorldRender();
 		Iris.getCompositeRenderer().renderAll();

File: src/main/java/net/coderbot/iris/uniforms/ViewportUniforms.java
Patch:
@@ -35,8 +35,7 @@ public static void addViewportUniforms(UniformHolder uniforms) {
 		uniforms
 			.uniform1f(PER_FRAME, "viewHeight", WINDOW::getHeight)
 			.uniform1f(PER_FRAME, "viewWidth", WINDOW::getWidth)
-			.uniform1f(PER_FRAME, "aspectRatio", ViewportUniforms::getAspectRatio)
-			.uniform1f(PER_FRAME, "screenBrightness", () -> client.options.gamma);
+			.uniform1f(PER_FRAME, "aspectRatio", ViewportUniforms::getAspectRatio);
 	}
 
 	/**

File: src/main/java/net/coderbot/iris/mixin/gbuffer/MixinWorldRenderer.java
Patch:
@@ -17,7 +17,7 @@
 public class MixinWorldRenderer {
 	private static final String RENDER = "render(Lnet/minecraft/client/util/math/MatrixStack;FJZLnet/minecraft/client/render/Camera;Lnet/minecraft/client/render/GameRenderer;Lnet/minecraft/client/render/LightmapTextureManager;Lnet/minecraft/util/math/Matrix4f;)V";
 
-	@Inject(method = RENDER, at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/systems/RenderSystem;clear(IZ)V"))
+	@Inject(method = RENDER, at = @At(value = "INVOKE", target = "Lnet/minecraft/client/render/BackgroundRenderer;render(Lnet/minecraft/client/render/Camera;FLnet/minecraft/client/world/ClientWorld;IF)V"))
 	private void iris$afterClear(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline,
 								Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager,
 								Matrix4f matrix4f, CallbackInfo callback) {

File: src/main/java/net/coderbot/iris/pipeline/ShaderPipeline.java
Patch:
@@ -289,7 +289,8 @@ public void prepareRenderTargets() {
 		RenderSystem.clearColor(0.0f, 0.0f, 0.0f, 0.0f);
 		RenderSystem.clear(GL11C.GL_COLOR_BUFFER_BIT, MinecraftClient.IS_SYSTEM_MAC);
 
-		clearMainBuffers.bind();
+		// We only want the vanilla clear color to be applied to colortex0
+		baseline.bind();
 	}
 
 	public void copyCurrentDepthTexture() {

File: src/main/java/net/coderbot/iris/mixin/MixinWorldRenderer.java
Patch:
@@ -31,6 +31,7 @@ public class MixinWorldRenderer {
 	@Inject(method = RENDER, at = @At("HEAD"))
 	private void iris$beginWorldRender(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager, Matrix4f matrix4f, CallbackInfo callback) {
 		CapturedRenderingState.INSTANCE.setGbufferModelView(matrices.peek().getModel());
+		CapturedRenderingState.INSTANCE.setGbufferProjection(gameRenderer.getBasicProjectionMatrix(camera, tickDelta, true));
 		CapturedRenderingState.INSTANCE.setTickDelta(tickDelta);
 		Iris.getPipeline().beginWorldRender();
 	}

File: src/main/java/net/coderbot/iris/uniforms/CapturedRenderingState.java
Patch:
@@ -21,15 +21,15 @@ public Matrix4f getGbufferModelView() {
 	}
 
 	public void setGbufferModelView(Matrix4f gbufferModelView) {
-		this.gbufferModelView = gbufferModelView;
+		this.gbufferModelView = gbufferModelView.copy();
 	}
 
 	public Matrix4f getGbufferProjection() {
 		return gbufferProjection;
 	}
 
 	public void setGbufferProjection(Matrix4f gbufferProjection) {
-		this.gbufferProjection = gbufferProjection;
+		this.gbufferProjection = gbufferProjection.copy();
 	}
 
 	public void setTickDelta(float tickDelta) {

File: src/main/java/net/coderbot/iris/mixin/fabulous/MixinOption.java
Patch:
@@ -12,8 +12,7 @@
 @Environment(EnvType.CLIENT)
 @Mixin(Option.class)
 public class MixinOption {
-	@Redirect(method = "method_18554(Lnet/minecraft/client/options/GameOptions;Ljava/lang/Integer;)V", remap = false,
-		at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/platform/GlStateManager;supportsGl30()Z"))
+	@Redirect(method = "method_18554", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/platform/GlStateManager;supportsGl30()Z"))
 	private static boolean iris$onAttemptedToSelectFabulousGraphics() {
 		// Returning false here will cause Minecraft to cycle between Fancy and Fast, disabling Fabulous graphics
 		return false;

File: src/main/java/net/coderbot/iris/pipeline/ShaderPipeline.java
Patch:
@@ -173,7 +173,7 @@ private static void setupAttributes(Pass pass) {
 		// location assignment, so that might be something good to pursue in the future.
 		setupAttribute(pass, "mc_Entity", blockId, -1.0F, -1.0F, -1.0F);
 		setupAttribute(pass, "mc_midTexCoord", 0.0F, 0.0F, 0.0F, 0.0F);
-		setupAttribute(pass, "at_tangent", 1.0F, 0.0F, 0.0F, 0.0F);
+		setupAttribute(pass, "at_tangent", 1.0F, 0.0F, 0.0F, 1.0F);
 	}
 
 	private static void setupAttribute(Pass pass, String name, float v0, float v1, float v2, float v3) {

File: src/main/java/net/coderbot/iris/pipeline/SodiumTerrainPipeline.java
Patch:
@@ -79,6 +79,7 @@ private static String transformVertexShader(String shader) {
 
 		shader = shader
 			.replace("gl_Vertex", "vec4((a_Pos * u_ModelScale) + d_ModelOffset.xyz, 1.0)")
+			.replace("gl_MultiTexCoord1.xy/255.0", "a_LightCoord")
 			.replace("gl_MultiTexCoord0", "vec4(a_TexCoord, 0.0, 1.0)")
 			.replace("gl_MultiTexCoord1", "vec4(a_LightCoord, 0.0, 1.0)")
 			.replace("gl_Color", "a_Color")

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -14,6 +14,7 @@
 import net.minecraft.entity.LivingEntity;
 import net.minecraft.entity.effect.StatusEffectInstance;
 import net.minecraft.entity.effect.StatusEffects;
+import net.minecraft.tag.FluidTags;
 
 public final class CommonUniforms {
 	private static final MinecraftClient client = MinecraftClient.getInstance();
@@ -61,7 +62,7 @@ private static int isEyeInWater() {
 
 		if (cameraEntity.isSubmergedInWater()) {
 			return 1;
-		} else if (cameraEntity.isInLava()) {
+		} else if (cameraEntity.isSubmergedIn(FluidTags.LAVA)) {
 			return 2;
 		} else {
 			return 0;

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -202,7 +202,7 @@ private static void destroyEverything() {
 		}
 
 		if (renderTargets != null) {
-			// TODO: This breaks things: renderTargets.destroy();
+			renderTargets.destroy();
 			renderTargets = null;
 		}
 

File: src/main/java/net/coderbot/iris/rendertarget/RenderTarget.java
Patch:
@@ -59,6 +59,8 @@ private void resizeCurrentlyBoundTexture(int width, int height) {
 
 	// Package private, call CompositeRenderTargets#resizeIfNeeded instead.
 	void resize(int width, int height) {
+		requireValid();
+
 		GlStateManager.bindTexture(mainTexture);
 		resizeCurrentlyBoundTexture(width, height);
 

File: src/main/java/net/coderbot/iris/Iris.java
Patch:
@@ -105,7 +105,7 @@ private void loadInternalShaderpack() {
 		logger.info("Using internal shaders");
 	}
 
-	private static RenderTargets getRenderTargets() {
+	public static RenderTargets getRenderTargets() {
 		if (renderTargets == null) {
 			renderTargets = new RenderTargets(MinecraftClient.getInstance().getFramebuffer(), Objects.requireNonNull(currentPack));
 		}

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderer.java
Patch:
@@ -14,7 +14,6 @@
 import net.coderbot.iris.gl.program.ProgramBuilder;
 import net.coderbot.iris.rendertarget.RenderTarget;
 import net.coderbot.iris.rendertarget.RenderTargets;
-import net.coderbot.iris.shaderpack.PackDirectives;
 import net.coderbot.iris.shaderpack.ProgramDirectives;
 import net.coderbot.iris.shaderpack.ShaderPack;
 import net.coderbot.iris.uniforms.CommonUniforms;
@@ -33,7 +32,7 @@ public class CompositeRenderer {
 	final CenterDepthSampler centerDepthSampler;
 
 	public CompositeRenderer(ShaderPack pack, RenderTargets renderTargets) {
-		centerDepthSampler = new CenterDepthSampler();
+		centerDepthSampler = new CenterDepthSampler(renderTargets);
 
 		final List<Pair<Program, ProgramDirectives>> programs = new ArrayList<>();
 
@@ -143,7 +142,8 @@ public void renderAll() {
 		// TODO: If there are no composite passes, we need to add a "fake" pass
 
 		// Make sure to reset the viewport to how it was before... Otherwise weird issues could occur.
-		RenderSystem.viewport(0, 0, main.textureWidth, main.textureHeight);
+		// Also bind the "main" framebuffer if it isn't already bound.
+		main.beginWrite(true);
 		GlStateManager.useProgram(0);
 
 		// TODO: We unbind these textures but it would probably make sense to unbind the other ones too.

File: src/main/java/net/coderbot/iris/HorizonRenderer.java
Patch:
@@ -15,7 +15,7 @@
  * Renders the sky horizon. Vanilla Minecraft simply uses the "clear color" for its horizon, and then draws a plane
  * above the player. This class extends the sky rendering so that an octagonal prism is drawn around the player instead,
  * allowing shaders to perform more advanced sky rendering.
- *
+ * <p>
  * However, the horizon rendering is designed so that when sky shaders are not being used, it looks almost exactly the
  * same as vanilla sky rendering, with the exception of a few almost entirely imperceptible differences where the walls
  * of the octagonal prism intersect the top plane.
@@ -79,9 +79,9 @@ private void buildHalf(VertexConsumer consumer, double adjacent, double opposite
 
 	/**
 	 * @param adjacent the adjacent side length of the a triangle with a hypotenuse extending from the center of the
-	 *				 octagon to a given vertex on the perimeter.
+	 *                 octagon to a given vertex on the perimeter.
 	 * @param opposite the opposite side length of the a triangle with a hypotenuse extending from the center of the
-	 * 	 *			 octagon to a given vertex on the perimeter.
+	 *                 octagon to a given vertex on the perimeter.
 	 */
 	private void buildOctagonalPrism(VertexConsumer consumer, double adjacent, double opposite) {
 		buildHalf(consumer, adjacent, opposite, false);

File: src/main/java/net/coderbot/iris/gl/framebuffer/GlFramebuffer.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.gl.framebuffer;
 
-import java.nio.ByteBuffer;
-
 import com.mojang.blaze3d.platform.GlStateManager;
 import it.unimi.dsi.fastutil.ints.Int2IntArrayMap;
 import it.unimi.dsi.fastutil.ints.Int2IntMap;

File: src/main/java/net/coderbot/iris/gl/program/ProgramBuilder.java
Patch:
@@ -1,7 +1,5 @@
 package net.coderbot.iris.gl.program;
 
-import net.coderbot.iris.Iris;
-
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -12,6 +10,7 @@
 
 import com.google.common.collect.ImmutableList;
 import com.mojang.blaze3d.systems.RenderSystem;
+import net.coderbot.iris.Iris;
 import net.coderbot.iris.gl.uniform.Uniform;
 import net.coderbot.iris.gl.uniform.UniformHolder;
 import net.coderbot.iris.gl.uniform.UniformUpdateFrequency;

File: src/main/java/net/coderbot/iris/gl/uniform/UniformHolder.java
Patch:
@@ -13,6 +13,7 @@
 
 public interface UniformHolder {
 	UniformHolder addUniform(UniformUpdateFrequency updateFrequency, Uniform uniform);
+
 	OptionalInt location(String name);
 
 	default UniformHolder uniform1f(UniformUpdateFrequency updateFrequency, String name, FloatSupplier value) {
@@ -66,7 +67,7 @@ default UniformHolder uniform3d(UniformUpdateFrequency updateFrequency, String n
 	default UniformHolder uniform4f(UniformUpdateFrequency updateFrequency, String name, Supplier<Vector4f> value) {
 		location(name).ifPresent(id -> addUniform(updateFrequency, new Vector4Uniform(id, value)));
 
-		return  this;
+		return this;
 	}
 
 	default UniformHolder uniformMatrix(UniformUpdateFrequency updateFrequency, String name, Supplier<Matrix4f> value) {

File: src/main/java/net/coderbot/iris/mixin/texunits/MixinBufferVertexConsumer.java
Patch:
@@ -30,7 +30,7 @@ public interface MixinBufferVertexConsumer {
 	 */
 	@Overwrite
 	default VertexConsumer overlay(int u, int v) {
-		return ((BufferVertexConsumer)this).texture((short)u, (short)v, TextureUnit.OVERLAY.getSamplerId());
+		return ((BufferVertexConsumer) this).texture((short) u, (short) v, TextureUnit.OVERLAY.getSamplerId());
 	}
 
 	/**
@@ -39,6 +39,6 @@ default VertexConsumer overlay(int u, int v) {
 	 */
 	@Overwrite
 	default VertexConsumer light(int u, int v) {
-		return ((BufferVertexConsumer)this).texture((short)u, (short)v, TextureUnit.LIGHTMAP.getSamplerId());
+		return ((BufferVertexConsumer) this).texture((short) u, (short) v, TextureUnit.LIGHTMAP.getSamplerId());
 	}
 }

File: src/main/java/net/coderbot/iris/pipeline/ShaderPipeline.java
Patch:
@@ -178,7 +178,7 @@ public void beginImmediateDrawing(RenderLayer layer) {
 		}
 
 		texturedLit.use();
-		if ((layer.isOutline() || layer == RenderLayer.getLines()) && basic != null){
+		if ((layer.isOutline() || layer == RenderLayer.getLines()) && basic != null) {
 			basic.use();
 		}
 	}

File: src/main/java/net/coderbot/iris/postprocess/FullScreenQuadRenderer.java
Patch:
@@ -93,7 +93,7 @@ private static void vertex(BufferBuilder buffer, boolean plusX, boolean up) {
 		buffer.color(1.0F, 1.0F, 1.0F, 1.0F);
 
 		// Texture coordinates are in the range of 0.0 to 1.0
-		buffer.texture(plusX ? 1.0F : 0.0F, up? 1.0F : 0.0F);
+		buffer.texture(plusX ? 1.0F : 0.0F, up ? 1.0F : 0.0F);
 
 		// Move to the next vertex.
 		buffer.next();

File: src/main/java/net/coderbot/iris/postprocess/target/CompositeRenderTarget.java
Patch:
@@ -82,7 +82,7 @@ public void destroy() {
 		requireValid();
 		isValid = false;
 
-		GL11C.glDeleteTextures(new int[] { mainTexture, altTexture });
+		GL11C.glDeleteTextures(new int[]{mainTexture, altTexture});
 	}
 
 	private void requireValid() {

File: src/main/java/net/coderbot/iris/postprocess/target/CompositeRenderTargets.java
Patch:
@@ -26,7 +26,7 @@ public CompositeRenderTargets(int width, int height) {
 				() -> CompositeRenderTarget.builder().setDimensions(width, height).setInternalFormat(InternalTextureFormat.RGBA32F).build();
 
 		// TODO: Don't always try to create all 8 draw buffers if they aren't actually necessary
-		targets = new CompositeRenderTarget[] {
+		targets = new CompositeRenderTarget[]{
 				colorTarget.get(),
 				depthTarget.get(),
 				colorTarget.get(),

File: src/main/java/net/coderbot/iris/shaderpack/ShaderPreprocessor.java
Patch:
@@ -26,7 +26,7 @@ private static List<String> processInternal(Path rootPath, Path shaderPath, Stri
 
 		// Match any valid newline sequence
 		// https://stackoverflow.com/a/31060125
-		for (String line: source.split("\\R")) {
+		for (String line : source.split("\\R")) {
 			String trimmedLine = line.trim();
 
 			if (trimmedLine.startsWith("#include ")) {

File: src/main/java/net/coderbot/iris/uniforms/SystemTimeUniforms.java
Patch:
@@ -19,6 +19,7 @@ private SystemTimeUniforms() {
 
 	/**
 	 * Makes system time uniforms available to the given program
+	 *
 	 * @param uniforms the program to make the uniforms available to
 	 */
 	public static void addSystemTimeUniforms(UniformHolder uniforms) {

File: src/main/java/net/coderbot/iris/uniforms/ViewportUniforms.java
Patch:
@@ -26,6 +26,7 @@ private ViewportUniforms() {
 
 	/**
 	 * Makes the viewport uniforms available to the given program
+	 *
 	 * @param uniforms the program to make the uniforms available to
 	 */
 	public static void addViewportUniforms(UniformHolder uniforms) {

File: src/main/java/net/coderbot/iris/uniforms/WorldTimeUniforms.java
Patch:
@@ -15,6 +15,7 @@ private WorldTimeUniforms() {
 
 	/**
 	 * Makes world time uniforms available to the given program
+	 *
 	 * @param uniforms the program to make the uniforms available to
 	 */
 	public static void addWorldTimeUniforms(UniformHolder uniforms) {

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderer.java
Patch:
@@ -119,8 +119,6 @@ private static GlFramebuffer createStageFramebuffer(CompositeRenderTargets rende
 			framebuffer.addColorAttachment(i, textureId);
 		}
 
-		framebuffer.addDepthAttachment(renderTargets.getDepthTexture().getTextureId());
-
 		if (!framebuffer.isComplete()) {
 			throw new IllegalStateException("Unexpected error while creating framebuffer");
 		}

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderPasses.java
Patch:
@@ -82,7 +82,7 @@ public CompositeRenderPasses(ShaderPack pack) {
 
 			GlFramebuffer framebuffer = createStageFramebuffer(renderTargets, stageReadsFromAlt, drawBuffers);
 
-			pass.stageReadsFromAlt = stageReadsFromAlt;
+			pass.stageReadsFromAlt = Arrays.copyOf(stageReadsFromAlt, stageReadsFromAlt.length);
 			pass.framebuffer = framebuffer;
 
 			if (programEntry == programs.get(programs.size() - 1)) {

File: src/main/java/net/coderbot/iris/postprocess/CompositeRenderPasses.java
Patch:
@@ -122,7 +122,7 @@ private static GlFramebuffer createStageFramebuffer(CompositeRenderTargets rende
 			framebuffer.addColorAttachment(i, textureId);
 		}
 
-		framebuffer.addDepthAttachment(main.textureWidth, main.textureHeight);
+		framebuffer.addDepthAttachment(renderTargets.getDepthTexture().getTextureId());
 
 		if (!framebuffer.isComplete()) {
 			throw new IllegalStateException("Unexpected error while creating framebuffer");

File: src/main/java/net/coderbot/iris/uniforms/SystemTimeUniforms.java
Patch:
@@ -70,7 +70,7 @@ public Timer() {
 		public void beginFrame(long frameStartTime) {
 			// Track how much time passed since the last time we began rendering a frame.
 			// If this is the first frame, then use a value of 0.
-			long diffNs = lastStartTime.orElse(frameStartTime) - frameStartTime;
+			long diffNs = frameStartTime - lastStartTime.orElse(frameStartTime);
 			// Convert to milliseconds
 			long diffMs = (diffNs / 1000) / 1000;
 

File: src/main/java/net/coderbot/iris/uniforms/CommonUniforms.java
Patch:
@@ -1,6 +1,7 @@
 package net.coderbot.iris.uniforms;
 
 import net.coderbot.iris.gl.program.ProgramBuilder;
+import net.coderbot.iris.shaderpack.IdMapParser;
 import net.coderbot.iris.texunits.TextureUnit;
 import net.minecraft.client.MinecraftClient;
 import net.minecraft.entity.Entity;
@@ -22,12 +23,12 @@ private CommonUniforms() {
 		// no construction allowed
 	}
 
-	public static void addCommonUniforms(ProgramBuilder builder) {
+	public static void addCommonUniforms(ProgramBuilder builder, IdMapParser idMap) {
 		ViewportUniforms.addViewportUniforms(builder);
 		WorldTimeUniforms.addWorldTimeUniforms(builder);
 		SystemTimeUniforms.addSystemTimeUniforms(builder);
 		CelestialUniforms.addCelestialUniforms(builder);
-		PropertiesUniforms.addPropertiesUniforms(builder);
+		PropertiesUniforms.addPropertiesUniforms(builder, idMap);
 
 		builder
 			.uniform1i(ONCE, "texture", TextureUnit.TERRAIN::getSamplerId)

File: src/main/java/net/coderbot/iris/mixin/MixinImmediateVertexConsumerProvider.java
Patch:
@@ -13,7 +13,7 @@
 public class MixinImmediateVertexConsumerProvider {
 	@Inject(method = "draw(Lnet/minecraft/client/render/RenderLayer;)V", at = @At("HEAD"))
 	private void iris$beginDraw(RenderLayer layer, CallbackInfo callback) {
-		Iris.getPipeline().beginImmediateDrawing();
+		Iris.getPipeline().beginImmediateDrawing(layer);
 	}
 
 	@Inject(method = "draw(Lnet/minecraft/client/render/RenderLayer;)V", at = @At("RETURN"))

File: src/main/java/net/coderbot/iris/mixin/MixinWorldRenderer.java
Patch:
@@ -1,3 +1,4 @@
+
 package net.coderbot.iris.mixin;
 
 import net.coderbot.iris.HorizonRenderer;
@@ -27,8 +28,6 @@ public class MixinWorldRenderer {
 	private static final String RENDER_SKY = "renderSky(Lnet/minecraft/client/util/math/MatrixStack;F)V";
 	private static final String RENDER_LAYER = "renderLayer(Lnet/minecraft/client/render/RenderLayer;Lnet/minecraft/client/util/math/MatrixStack;DDD)V";
 	private static final String RENDER_CLOUDS = "renderClouds(Lnet/minecraft/client/util/math/MatrixStack;FDDD)V";
-	private static final String POSITIVE_Y = "Lnet/minecraft/client/util/math/Vector3f;POSITIVE_Y:Lnet/minecraft/client/util/math/Vector3f;";
-	private static final String PEEK = "Lnet/minecraft/client/util/math/MatrixStack;peek()Lnet/minecraft/client/util/math/MatrixStack$Entry;";
 
 	@Inject(method = RENDER, at = @At("HEAD"))
 	private void iris$beginWorldRender(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager, Matrix4f matrix4f, CallbackInfo callback) {

File: src/main/java/net/coderbot/iris/shaderpack/ShaderPack.java
Patch:
@@ -43,6 +43,7 @@ public Optional<ProgramSource> getGbuffersClouds() {
 		return gbuffersClouds.requireValid();
 	}
 
+
 	private static ProgramSource readProgramSource(Path root, String program) throws IOException {
 		String vertexSource = null;
 		String fragmentSource = null;

File: src/main/java/net/coderbot/iris/mixin/MixinWorldRenderer.java
Patch:
@@ -29,13 +29,13 @@ public class MixinWorldRenderer {
 	private static final String PEEK = "Lnet/minecraft/client/util/math/MatrixStack;peek()Lnet/minecraft/client/util/math/MatrixStack$Entry;";
 
 	@Inject(method = RENDER, at = @At(value = "INVOKE_STRING", target = PROFILER_SWAP, args = "ldc=terrain"))
-	private void setupTerrainShaders(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager, Matrix4f matrix4f, CallbackInfo callback) {
+	private void iris$setupTerrainShaders(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager, Matrix4f matrix4f, CallbackInfo callback) {
 		CapturedRenderingState.INSTANCE.setGbufferModelView(matrices.peek().getModel());
 		Iris.useTerrainShaders();
 	}
 
 	@Inject(method = RENDER, at = @At(value = "INVOKE_STRING", target = PROFILER_SWAP, args = "ldc=entities"))
-	private void stopUsingTerrainShaders(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager, Matrix4f matrix4f, CallbackInfo callback) {
+	private void iris$stopUsingTerrainShaders(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager, Matrix4f matrix4f, CallbackInfo callback) {
 		GlProgramManager.useProgram(0);
 	}
 

File: src/main/java/net/coderbot/iris/texunits/TextureUnit.java
Patch:
@@ -4,8 +4,8 @@
 
 public enum TextureUnit {
 	TERRAIN(0),
-	OVERLAY(2),
-	LIGHTMAP(1);
+	OVERLAY(1),
+	LIGHTMAP(2);
 
 	private final int samplerId;
 	private final int unitId;

File: src/main/java/net/coderbot/iris/uniforms/Uniforms.java
Patch:
@@ -2,6 +2,7 @@
 
 import java.nio.FloatBuffer;
 
+import net.coderbot.iris.texunits.TextureUnit;
 import org.lwjgl.BufferUtils;
 import org.lwjgl.opengl.GL21;
 
@@ -40,7 +41,7 @@ public void update() {
 		GL21.glUniform1i(texture, 0);
 		// TODO: Apparently old shaders expect the lightmap to be in texture unit #1, not #2.
 		// Not sure why Mojang changed the texture unit of the lightmap - we'll need to change it back.
-		GL21.glUniform1i(lightmap, 2);
+		GL21.glUniform1i(lightmap, TextureUnit.LIGHTMAP.getSamplerId());
 
 		updateMatrix(gbufferModelView, CapturedRenderingState.INSTANCE.getGbufferModelView());
 		updateMatrix(gbufferModelViewInverse, invertedCopy(CapturedRenderingState.INSTANCE.getGbufferModelView()));

