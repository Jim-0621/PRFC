File: annotate/src/org/immutables/annotate/InjectAnnotation.java
Patch:
@@ -173,5 +173,6 @@ enum Where {
     MODIFIABLE_TYPE,
     /** Constructor if public or a factory method constructor otherwise.  */
     CONSTRUCTOR,
+    WITH_TYPE
   }
 }

File: value-processor/src/org/immutables/value/processor/meta/AnnotationInjections.java
Patch:
@@ -57,6 +57,7 @@ enum Where {
       BUILDER_TYPE,
       IMMUTABLE_TYPE,
       MODIFIABLE_TYPE,
+      WITH_TYPE,
       CONSTRUCTOR
     }
   }

File: builder/test/org/immutables/builder/fixture/GenericsImprovisedFactories.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.Set;
 import com.google.common.collect.Iterables;
 import java.util.List;
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 import org.immutables.builder.Builder;
 import org.immutables.value.Value;
 
@@ -50,7 +50,7 @@ class GenericsImprovisedFactories {
 
   @Builder.Factory
   @SuppressWarnings("all")
-  public static <T, V extends RuntimeException> String genericSuperstring(int theory, T reality, @Nullable V evidence)
+  public static <T, @Nullable V extends RuntimeException> String genericSuperstring(int theory, T reality, @Nullable V evidence)
       throws V {
     if (evidence != null) {
       throw evidence;

File: value-processor/src/org/immutables/value/processor/meta/TypeStringProvider.java
Patch:
@@ -329,7 +329,7 @@ void caseType(TypeMirror type) {
     case TYPEVAR:
       if (allowedTypevars.length != 0) {
         TypeVariable typeVariable = (TypeVariable) type;
-        String var = typeVariable.toString();
+        String var = typeVariable.asElement().getSimpleName().toString();
         int indexOfVar = Arrays.asList(allowedTypevars).indexOf(var);
         if (indexOfVar >= 0) {
           if (typevarArguments != null) {

File: builder/test/org/immutables/builder/fixture/GenericsImprovisedFactories.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.Set;
 import com.google.common.collect.Iterables;
 import java.util.List;
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 import org.immutables.builder.Builder;
 import org.immutables.value.Value;
 
@@ -50,7 +50,7 @@ class GenericsImprovisedFactories {
 
   @Builder.Factory
   @SuppressWarnings("all")
-  public static <T, V extends RuntimeException> String genericSuperstring(int theory, T reality, @Nullable V evidence)
+  public static <T, @Nullable V extends RuntimeException> String genericSuperstring(int theory, T reality, @Nullable V evidence)
       throws V {
     if (evidence != null) {
       throw evidence;

File: value-processor/src/org/immutables/value/processor/meta/TypeStringProvider.java
Patch:
@@ -329,7 +329,7 @@ void caseType(TypeMirror type) {
     case TYPEVAR:
       if (allowedTypevars.length != 0) {
         TypeVariable typeVariable = (TypeVariable) type;
-        String var = typeVariable.toString();
+        String var = typeVariable.asElement().getSimpleName().toString();
         int indexOfVar = Arrays.asList(allowedTypevars).indexOf(var);
         if (indexOfVar >= 0) {
           if (typevarArguments != null) {

File: annotate/src/org/immutables/annotate/InjectAnnotation.java
Patch:
@@ -173,5 +173,6 @@ enum Where {
     MODIFIABLE_TYPE,
     /** Constructor if public or a factory method constructor otherwise.  */
     CONSTRUCTOR,
+    WITH_TYPE
   }
 }

File: value-processor/src/org/immutables/value/processor/meta/AnnotationInjections.java
Patch:
@@ -57,6 +57,7 @@ enum Where {
       BUILDER_TYPE,
       IMMUTABLE_TYPE,
       MODIFIABLE_TYPE,
+      WITH_TYPE,
       CONSTRUCTOR
     }
   }

File: value-fixture/test/org/immutables/fixture/jdkonly/JdkOnlyTest.java
Patch:
@@ -46,12 +46,14 @@ public void collections() {
         .addOrds(4, 6, 5)
         .addAllOrds(Arrays.asList(8, 7, 9))
         .addPols(RetentionPolicy.RUNTIME, RetentionPolicy.RUNTIME)
+        .addElems(ImmutableElem.builder().value(1).build(), ImmutableElem.builder().value(2).build())
         .build();
 
     check(coll.ints()).hasContentInAnyOrder(1, 2, 3, 4, 5, 6);
     check(coll.navs()).hasContentInAnyOrder(3, 2, 1);
     check(coll.ords()).hasContentInAnyOrder(4, 5, 6, 7, 8, 9);
     check(coll.pols()).hasContentInAnyOrder(RetentionPolicy.RUNTIME);
+    check(coll.elems()).hasContentInAnyOrder(ImmutableElem.builder().value(1).build(), ImmutableElem.builder().value(2).build());
   }
 
   @Test

File: value-fixture/test/org/immutables/fixture/jdkonly/JdkOnlyTest.java
Patch:
@@ -46,12 +46,14 @@ public void collections() {
         .addOrds(4, 6, 5)
         .addAllOrds(Arrays.asList(8, 7, 9))
         .addPols(RetentionPolicy.RUNTIME, RetentionPolicy.RUNTIME)
+        .addElems(ImmutableElem.builder().value(1).build(), ImmutableElem.builder().value(2).build())
         .build();
 
     check(coll.ints()).hasContentInAnyOrder(1, 2, 3, 4, 5, 6);
     check(coll.navs()).hasContentInAnyOrder(3, 2, 1);
     check(coll.ords()).hasContentInAnyOrder(4, 5, 6, 7, 8, 9);
     check(coll.pols()).hasContentInAnyOrder(RetentionPolicy.RUNTIME);
+    check(coll.elems()).hasContentInAnyOrder(ImmutableElem.builder().value(1).build(), ImmutableElem.builder().value(2).build());
   }
 
   @Test

File: criteria/rxjava2/src/org/immutables/criteria/repository/rxjava2/RxJavaReader.java
Patch:
@@ -55,7 +55,7 @@ protected RxJavaReader<T> newReader(Query query) {
     return new RxJavaReader<>(query, session);
   }
 
-  public <T1> RxJavaMapper1<T1> select(Projection<T1> proj1) {
+  public <T1> RxJavaMapper1.DistinctLimitOffset<T1> select(Projection<T1> proj1) {
     Query newQuery = this.query.addProjections(Matchers.toExpression(proj1));
     return new RxJavaMappers.Mapper1<T1>(newQuery, session);
   }

File: criteria/mongo/src/org/immutables/criteria/mongo/MongoSession.java
Patch:
@@ -175,7 +175,7 @@ private Publisher<?> query(StandardOperations.Select select) {
     if (!query.collations().isEmpty()) {
       // add sorting
       final Function<Collation, Bson> toSortFn = col -> {
-        final String path = col.path().toStringPath();
+        final String path = this.pathNaming.name(col.path());
         return col.direction().isAscending() ? Sorts.ascending(path) : Sorts.descending(path);
 
       };

File: criteria/mongo/src/org/immutables/criteria/mongo/MongoSession.java
Patch:
@@ -175,7 +175,7 @@ private Publisher<?> query(StandardOperations.Select select) {
     if (!query.collations().isEmpty()) {
       // add sorting
       final Function<Collation, Bson> toSortFn = col -> {
-        final String path = col.path().toStringPath();
+        final String path = this.pathNaming.name(col.path());
         return col.direction().isAscending() ? Sorts.ascending(path) : Sorts.descending(path);
 
       };

File: criteria/mongo/src/org/immutables/criteria/mongo/MongoSession.java
Patch:
@@ -237,7 +237,7 @@ private <T> Publisher<WriteResult> update(StandardOperations.Update operation) {
     Publisher<BulkWriteResult> publisher = ((MongoCollection<Object>) collection).bulkWrite(docs);
     return Flowable.fromPublisher(publisher).map(x -> WriteResult.empty()
             .withUpdatedCount(x.getModifiedCount())
-            .withInsertedCount(x.getInsertedCount())
+            .withInsertedCount(operation.upsert() ? x.getUpserts().size() : x.getInsertedCount())
             .withDeletedCount(x.getDeletedCount()));
   }
 

File: criteria/common/src/org/immutables/criteria/backend/WriteResults.java
Patch:
@@ -23,7 +23,7 @@ final class WriteResults {
 
   static final ImmutableWriteResult UNKNOWN = ImmutableWriteResult.builder().build();
 
-  static final ImmutableWriteResult EMPTY = ImmutableWriteResult.builder().deletedCount(0).updatedCount(0).updatedCount(0).build();
+  static final ImmutableWriteResult EMPTY = ImmutableWriteResult.builder().deletedCount(0).updatedCount(0).insertedCount(0).build();
 
   private WriteResults () {}
 }

File: generator/src/org/immutables/generator/EnvironmentState.java
Patch:
@@ -66,6 +66,7 @@ void initProcessing(ProcessingEnvironment processing) {
   void initRound(Set<? extends TypeElement> annotations, RoundEnvironment round) {
     this.round = round;
     this.annotations = ImmutableSet.copyOf(annotations);
+    currentState.set(this);
   }
 
   void completeRound() {
@@ -74,7 +75,7 @@ void completeRound() {
     }
     afterRound.clear();
     annotations = null;
-    round = null;
+    //round = null;
   }
 
   void completeProcessing() {

File: value-processor/src/org/immutables/value/processor/meta/ValueType.java
Patch:
@@ -1641,7 +1641,7 @@ public Set<String> getNonAttributeAbstractMethodSignatures() {
 
           if (m.getModifiers().contains(Modifier.ABSTRACT)) {
             TypeMirror returnType = m.getReturnType();
-            if (!AccessorAttributesCollector.isEclipseImplementation(m)) {
+            if (!ProcessingEnvironments.isEclipseImplementation(constitution.protoclass().processing())) {
               returnType = AccessorAttributesCollector.asInheritedMemberReturnType(
                   constitution.protoclass().processing(),
                   CachingElements.getDelegate((TypeElement) element),

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -135,6 +135,8 @@ private ValueMirrors() {}
 
     String delegateToString() default "";
 
+    String includeHashCode() default "";
+
     String isInitialized() default "isInitialized";
 
     String isSet() default "*IsSet";

File: generator/src/org/immutables/generator/AbstractGenerator.java
Patch:
@@ -30,7 +30,7 @@
 import org.immutables.generator.Generator.SupportedAnnotations;
 
 /**
- * Extend this abstract processor to propertly initalize and call templates.
+ * Extend this abstract processor to properly initalize and call templates.
  * @see #process()
  */
 public abstract class AbstractGenerator extends AbstractProcessor {

File: value-processor/src/org/immutables/value/processor/meta/AccessorAttributesCollector.java
Patch:
@@ -247,9 +247,9 @@ && isJavaLangObjectType(parameters.get(0).asType())) {
         if (!definingType.equals(originalType) && hasNonInheritedAttributes && nonFinal) {
           report(originalType)
               .warning(About.INCOMPAT,
-                  "Type inherits overriden 'equals' method but have some non-inherited attributes."
+                  "Type inherits overridden 'equals' method but have some non-inherited attributes."
                   + " Please override 'equals' with abstract method to have it generate. Otherwise override"
-                  + " with calling super implemtation to use custom implementation");
+                  + " with calling super implementation to use custom implementation");
         }
       }
       return;
@@ -267,7 +267,7 @@ && isJavaLangObjectType(parameters.get(0).asType())) {
               .warning(About.INCOMPAT,
                   "Type inherits non-default 'hashCode' method but have some non-inherited attributes."
                   + " Please override 'hashCode' with abstract method to have it generated. Otherwise override"
-                  + " with calling super implemtation to use custom implementation");
+                  + " with calling super implementation to use custom implementation");
         }
       }
       return;

File: annotate/src/org/immutables/annotate/InjectAnnotation.java
Patch:
@@ -50,7 +50,7 @@
  *   String of();
  * }
  * 
- * &#64;InjectAnnotation(type = TargetAnn.class, code = "(message=[[echo]], of=\"[[!name]]\"", target = Where.BUILDER_TYPE)
+ * &#64;InjectAnnotation(type = TargetAnn.class, code = "(message=[[echo]], of=\"[[!name]]\")", target = Where.BUILDER_TYPE)
  * &#64;interface InjectBuilderTarget {
  *   String echo();
  * }
@@ -124,7 +124,7 @@
   /**
    * Specify annotation type, this is an alternative to specifying {@link #code()}. All the
    * attributes from the annotated annotation (the one which is annotated by
-   * {@link InjectAnnotation} and placed on abstract value type or abstract attribute.
+   * {@link InjectAnnotation}) are placed on abstract value type or abstract attribute.
    * Default value is {@code InjectAnnotation.class} which is just a placeholder for unspecified
    * value.
    * @see #code()
@@ -144,7 +144,7 @@
   /**
    * The places where to put generated annotation. If annotation type have been specified by
    * {@link #type()} (and is not overridden by #code()), then there will be element target check,
-   * otherwise (if fully specified by {@link #code()} annotation will be always placed and it's
+   * otherwise (if fully specified by {@link #code()}) annotation will be always placed and it's
    * better match to target element type.
    */
   Where[] target();

File: generator/src/org/immutables/generator/AnnotationMirrors.java
Patch:
@@ -312,7 +312,7 @@ private void printValue(AnnotationValue value) {
       if (Compiler.JAVAC.isPresent()
           && "com.sun.tools.javac.code.Attribute.UnresolvedClass".equals(value.getClass().getCanonicalName())) {
         Attribute.UnresolvedClass unresolved = ((Attribute.UnresolvedClass) value);
-        String typeString = unresolved.classType.tsym.name.toString();
+        String typeString = ((Name) unresolved.classType.tsym.name).toString();
         builder.append(unresovedImportsResolver.apply(typeString)).append(".class");
       } else {
         visitValue(value);

File: value-fixture/test/org/immutables/fixture/jackson/BugsTest.java
Patch:
@@ -65,6 +65,7 @@ public void roundtrip353() throws Exception {
     check(info.abraCadabra()).is(1);
     check(info.focusPocus());
 
-    check(json).is("{'abra_cadabra':1,'focus_pocus':true}".replace('\'', '"'));
+    check(json).matches("\\{(?:'abra_cadabra':1,'focus_pocus':true|'focus_pocus':true,'abra_cadabra':1)}"
+            .replace('\'', '"'));
   }
 }

File: value-fixture/test/org/immutables/fixture/modifiable/ModifiablesTest.java
Patch:
@@ -210,8 +210,8 @@ public void modifiableImmutableCollections() {
     check(m.a()).isOf("a", "b", "c");
     check(m.b()).isOf("d", "e");
 
-    check(m.c().values()).isOf(1, 2);
-    check(m.c().keySet()).isOf("x", "y");
+    check(m.c().values()).hasContentInAnyOrder(1, 2);
+    check(m.c().keySet()).hasContentInAnyOrder("x", "y");
 
     check(m.d().isEmpty());
 

File: value-fixture/test/org/immutables/fixture/jackson/BugsTest.java
Patch:
@@ -65,6 +65,7 @@ public void roundtrip353() throws Exception {
     check(info.abraCadabra()).is(1);
     check(info.focusPocus());
 
-    check(json).is("{'abra_cadabra':1,'focus_pocus':true}".replace('\'', '"'));
+    check(json).matches("\\{(?:'abra_cadabra':1,'focus_pocus':true|'focus_pocus':true,'abra_cadabra':1)}"
+            .replace('\'', '"'));
   }
 }

File: value-fixture/test/org/immutables/fixture/modifiable/ModifiablesTest.java
Patch:
@@ -210,8 +210,8 @@ public void modifiableImmutableCollections() {
     check(m.a()).isOf("a", "b", "c");
     check(m.b()).isOf("d", "e");
 
-    check(m.c().values()).isOf(1, 2);
-    check(m.c().keySet()).isOf("x", "y");
+    check(m.c().values()).hasContentInAnyOrder(1, 2);
+    check(m.c().keySet()).hasContentInAnyOrder("x", "y");
 
     check(m.d().isEmpty());
 

File: generator/src/org/immutables/generator/AbstractGenerator.java
Patch:
@@ -30,7 +30,7 @@
 import org.immutables.generator.Generator.SupportedAnnotations;
 
 /**
- * Extend this abstract processor to propertly initalize and call templates.
+ * Extend this abstract processor to properly initalize and call templates.
  * @see #process()
  */
 public abstract class AbstractGenerator extends AbstractProcessor {

File: value-processor/src/org/immutables/value/processor/meta/AccessorAttributesCollector.java
Patch:
@@ -247,9 +247,9 @@ && isJavaLangObjectType(parameters.get(0).asType())) {
         if (!definingType.equals(originalType) && hasNonInheritedAttributes && nonFinal) {
           report(originalType)
               .warning(About.INCOMPAT,
-                  "Type inherits overriden 'equals' method but have some non-inherited attributes."
+                  "Type inherits overridden 'equals' method but have some non-inherited attributes."
                   + " Please override 'equals' with abstract method to have it generate. Otherwise override"
-                  + " with calling super implemtation to use custom implementation");
+                  + " with calling super implementation to use custom implementation");
         }
       }
       return;
@@ -267,7 +267,7 @@ && isJavaLangObjectType(parameters.get(0).asType())) {
               .warning(About.INCOMPAT,
                   "Type inherits non-default 'hashCode' method but have some non-inherited attributes."
                   + " Please override 'hashCode' with abstract method to have it generated. Otherwise override"
-                  + " with calling super implemtation to use custom implementation");
+                  + " with calling super implementation to use custom implementation");
         }
       }
       return;

File: annotate/src/org/immutables/annotate/InjectAnnotation.java
Patch:
@@ -50,7 +50,7 @@
  *   String of();
  * }
  * 
- * &#64;InjectAnnotation(type = TargetAnn.class, code = "(message=[[echo]], of=\"[[!name]]\"", target = Where.BUILDER_TYPE)
+ * &#64;InjectAnnotation(type = TargetAnn.class, code = "(message=[[echo]], of=\"[[!name]]\")", target = Where.BUILDER_TYPE)
  * &#64;interface InjectBuilderTarget {
  *   String echo();
  * }
@@ -124,7 +124,7 @@
   /**
    * Specify annotation type, this is an alternative to specifying {@link #code()}. All the
    * attributes from the annotated annotation (the one which is annotated by
-   * {@link InjectAnnotation} and placed on abstract value type or abstract attribute.
+   * {@link InjectAnnotation}) are placed on abstract value type or abstract attribute.
    * Default value is {@code InjectAnnotation.class} which is just a placeholder for unspecified
    * value.
    * @see #code()
@@ -144,7 +144,7 @@
   /**
    * The places where to put generated annotation. If annotation type have been specified by
    * {@link #type()} (and is not overridden by #code()), then there will be element target check,
-   * otherwise (if fully specified by {@link #code()} annotation will be always placed and it's
+   * otherwise (if fully specified by {@link #code()}) annotation will be always placed and it's
    * better match to target element type.
    */
   Where[] target();

File: value-fixture/src/org/immutables/fixture/HasTypeAnnotation.java
Patch:
@@ -41,6 +41,9 @@ public abstract class HasTypeAnnotation {
   @Nullable
   public abstract @TypeA @TypeB String str();
 
+  @Nullable
+  public abstract @TypeA @TypeB byte[] bte();
+
   @Nullable
   public abstract @TypeA @TypeB Map<@TypeA String, @TypeB String> map();
 }

File: value-processor/test/org/immutables/value/processor/encode/TypeTest.java
Patch:
@@ -65,6 +65,9 @@ public void parseIngoreTypeAnnotationWithParameters() {
     check(parser.parse("java.lang.@javax.validation.constraints.Size(max = 10, @A(a=@B(b=1))) String")).is(Reference.STRING);
     check(parser.parse("@Ann(\"b\") int")).is(Primitive.INT);
     check(parser.parse("(@javax.validation.constraints.NotNull :: java.lang.String)")).is(Reference.STRING);
+    check(parser.parse("(@javax.validation.constraints.NotNull :: byte)[]")).is(factory.array(Primitive.BYTE));
+    check(parser.parse("(@javax.validation.constraints.NotNull:: java.lang.String)[][]"))
+        .is(factory.array(factory.array(Reference.STRING)));
   }
 
   @Test

File: value-fixture/test/org/immutables/fixture/annotation/AnnotationTest.java
Patch:
@@ -55,7 +55,7 @@ public void methodAndTypeUse() throws Exception {
   @Test
   public void customNullableAnnotations() throws Exception {
     Class<ImmutableFallbackNullable> c = ImmutableFallbackNullable.class;
-    check(c.getDeclaredField("jdkOptional").getAnnotatedType().getAnnotation(Nil.class)).notNull();
-    check(c.getDeclaredField("nullable").getAnnotatedType().getAnnotation(Nil.class)).notNull();
+    check(c.getDeclaredField("jdkOptional").getAnnotation(Nil.class)).notNull();
+    check(c.getDeclaredField("nullable").getAnnotation(Nil.class)).notNull();
   }
 }

File: value-annotations/src/org/immutables/value/Value.java
Patch:
@@ -1289,7 +1289,7 @@
      * {@literal @}{@code Serial.Structural}). When set {@code false}, the processor we will not add
      * any {@code transient} annotations to derived fields. This is only for derived fields. Any
      * fields for lazy attributes are
-     * always {@transient} and ready to be reinitialized lazily after object is deserialized
+     * always {@code transient} and ready to be reinitialized lazily after object is deserialized
      * regardless of serialization/persistence technology.
      * @return default is {@code true} for backward compatibility. Set to {@code false} to disable
      */

File: value-annotations/src/org/immutables/value/Value.java
Patch:
@@ -1289,7 +1289,7 @@
      * {@literal @}{@code Serial.Structural}). When set {@code false}, the processor we will not add
      * any {@code transient} annotations to derived fields. This is only for derived fields. Any
      * fields for lazy attributes are
-     * always {@transient} and ready to be reinitialized lazily after object is deserialized
+     * always {@code transient} and ready to be reinitialized lazily after object is deserialized
      * regardless of serialization/persistence technology.
      * @return default is {@code true} for backward compatibility. Set to {@code false} to disable
      */

File: value-fixture/src/org/immutables/fixture/modifiable/BeanFriendly.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import javax.annotation.Nullable;
 import org.immutables.value.Value;
 
@@ -36,7 +37,7 @@ public interface BeanFriendly extends Identifiable {
 
   String getDescription();
 
-  List<String> getNames();
+  Set<String> getNames();
 
   Map<String, String> getOptions();
 

File: value-processor/src/org/immutables/value/processor/meta/Constitution.java
Patch:
@@ -753,7 +753,7 @@ protected void lateValidateSuper(TypeElement t) {
         String superclassString = SourceExtraction.getSuperclassString(t);
         String rawSuperclass = SourceTypes.extract(superclassString).getKey();
         // We need to extend the base class
-        if (!rawSuperclass.equals(typeAbstract().toString())) {
+        if (!typeAbstract().toString().endsWith(rawSuperclass)) {
           protoclass()
                   .report()
                   .withElement(t)

File: value-processor/src/org/immutables/value/processor/meta/AccessorAttributesCollector.java
Patch:
@@ -197,6 +197,9 @@ private boolean isElegibleAccessorMethod(Element element) {
     if (element.getModifiers().contains(Modifier.STATIC)) {
       return false;
     }
+    if (NonAttributeMirror.isPresent(element)) {
+      return false;
+    }
     String simpleName = element.getSimpleName().toString();
     switch (simpleName) {
     case HASH_CODE_METHOD:

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -40,6 +40,9 @@ private ValueMirrors() {}
     boolean builder() default true;
   }
 
+  @Mirror.Annotation("org.immutables.value.Value.NonAttribute")
+  public @interface NonAttribute {}
+
   @Mirror.Annotation("org.immutables.value.Value.Include")
   public @interface Include {
     Class<?>[] value();

File: value-fixture/test/org/immutables/fixture/generatorext/RewriteTest.java
Patch:
@@ -23,7 +23,7 @@
 public class RewriteTest {
   @SuppressWarnings("CheckReturnValue")
   @Test
-  @Disabled("FIXME: This test doesn't pass on either of provided JDKs")
+  @Disabled("FIXME: import rewriter can still work, but now in this build due to extension loading problems")
   public void rewrite() {
     // Our changed preconditions will be able to throw IllegalArgumentException
     // instead of NullPointerException

File: value-fixture/test/org/immutables/fixture/generatorext/RewriteTest.java
Patch:
@@ -15,13 +15,15 @@
  */
 package org.immutables.fixture.generatorext;
 
+import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 
 import static org.junit.jupiter.api.Assertions.assertThrows;
 
 public class RewriteTest {
   @SuppressWarnings("CheckReturnValue")
   @Test
+  @Disabled("FIXME: This test doesn't pass on either of provided JDKs")
   public void rewrite() {
     // Our changed preconditions will be able to throw IllegalArgumentException
     // instead of NullPointerException

File: criteria/mongo/test/org/immutables/criteria/mongo/BackendResource.java
Patch:
@@ -21,7 +21,6 @@
 import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;
 import com.mongodb.reactivestreams.client.MongoCollection;
 import com.mongodb.reactivestreams.client.MongoDatabase;
-import com.mongodb.reactivestreams.client.Success;
 import io.reactivex.Flowable;
 import org.bson.codecs.configuration.CodecRegistry;
 import org.immutables.criteria.backend.ContainerNaming;
@@ -75,10 +74,9 @@ private class LazyResolver implements CollectionResolver {
     @Override
     public MongoCollection<?> resolve(Class<?> entityClass) {
       final String name = ContainerNaming.DEFAULT.name(entityClass);
-      final MongoCollection<?> collection;
       // already exists ?
       if (!Flowable.fromPublisher(database.listCollectionNames()).toList().blockingGet().contains(name)) {
-        Success success = Flowable.fromPublisher(database.createCollection(name)).blockingFirst();
+        Flowable.fromPublisher(database.createCollection(name)).blockingSubscribe();
       }
 
       return database.getCollection(name).withDocumentClass(entityClass).withCodecRegistry(registry);

File: criteria/mongo/test/org/immutables/criteria/mongo/MongoInstance.java
Patch:
@@ -20,7 +20,6 @@
 import com.mongodb.reactivestreams.client.MongoClient;
 import com.mongodb.reactivestreams.client.MongoClients;
 import com.mongodb.reactivestreams.client.MongoDatabase;
-import com.mongodb.reactivestreams.client.Success;
 import de.bwaldvogel.mongo.MongoServer;
 import de.bwaldvogel.mongo.backend.memory.MemoryBackend;
 import io.reactivex.Flowable;
@@ -51,7 +50,7 @@ private MongoInstance(MongoClient client, Closer closer) {
 
     // drop database if exists (to have a clean test)
     if (Flowable.fromPublisher(client.listDatabaseNames()).toList().blockingGet().contains(DBNAME)) {
-      Success success = Flowable.fromPublisher(client.getDatabase(DBNAME).drop()).blockingFirst();
+      Flowable.fromPublisher(client.getDatabase(DBNAME).drop()).blockingSubscribe();
     }
 
     this.database = client.getDatabase(DBNAME);

File: mongo/src/org/immutables/mongo/repository/RepositorySetup.java
Patch:
@@ -24,6 +24,7 @@
 import com.google.gson.TypeAdapterFactory;
 import com.mongodb.DB;
 import com.mongodb.MongoClient;
+import com.mongodb.MongoClientSettings;
 import com.mongodb.MongoClientURI;
 import com.mongodb.ReadPreference;
 import com.mongodb.WriteConcern;
@@ -223,7 +224,7 @@ public Builder gson(Gson gson) {
       // TypeAdapter(s) from Gson if they're explicitly defined (not a ReflectiveTypeAdapter).
       // Otherwise delegate to BSON codec.
       TypeAdapterFactory bsonAdapterFactory = GsonCodecs.delegatingTypeAdapterFactory(
-              MongoClient.getDefaultCodecRegistry()
+              MongoClientSettings.getDefaultCodecRegistry()
       );
 
       // Appending new TypeAdapterFactory to allow Gson and Bson adapters to co-exists.

File: value-fixture/test/org/immutables/fixture/modifiable/BeanFriendlyTest.java
Patch:
@@ -63,6 +63,6 @@ public void modifiableAsJavaBean() throws Exception {
 
     // from works as with Immutable
     BeanFriendly mutableFromImmutable1 = new ModifiableBeanFriendly().from(immutableBean);
-    BeanFriendly.Mod mutableFromImmutable2 = new ModifiableMod().from(immutableBean.getMod());
+    BeanFriendly.Mod mutableFromImmutable2 = new ModifiableMod().from(ImmutableMod.builder().build());
   }
 }

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -249,6 +249,8 @@ private ValueMirrors() {}
 
     String nullableAnnotation() default "Nullable";
 
+    int limitStringLengthInToString() default 1000;
+
     Class<? extends Annotation>[] allowedClasspathAnnotations() default {};
 
     public enum ImplementationVisibility {

File: data/src/org/immutables/data/Data.java
Patch:
@@ -17,9 +17,9 @@
   public @interface Ignore {}
 
   /**
-   * Marks that the type is strongly typed alias (newtype) for the other types it wraps.
+   * Marks that the type is strongly typed alias (newtype) for the other type it wraps.
    * For now it requires either single parameter to be inlined or otherwise multiple will be
-   * "inlined" as heteronenous array/tuple in their data represendation/serialization, in positional
+   * "inlined" as heterogeneous array/tuple in their data representation/serialization, in positional
    * order, for example. However, in our Datatypes metadata framework we only mark those as such on
    * a model level, we leave it up to further codecs/serialization to implement it.
    */

File: generator/src/org/immutables/generator/AbstractGenerator.java
Patch:
@@ -86,6 +86,9 @@ public final boolean process(Set<? extends TypeElement> annotations, RoundEnviro
       if (!round.processingOver() && !round.errorRaised()) {
         process();
       }
+      if (round.processingOver()) {
+        StaticEnvironment.writeServiceFiles();
+      }
       StaticEnvironment.shutdown();
     } catch (Exception ex) {
       processingEnv.getMessager()

File: criteria/common/test/org/immutables/criteria/typemodel/ExistsTemplate.java
Patch:
@@ -93,17 +93,15 @@ void basicExists() {
   @Test
   void existsWithLimit() {
     // empty
-    check(!repository.findAll().limit(0).exists());
     check(!repository.findAll().limit(1).exists());
     check(!repository.findAll().limit(2).exists());
 
     repository.insert(generator.get().withId("id1").withValue("v1"));
-    check(!repository.findAll().limit(0).exists());
     check(repository.findAll().limit(1).exists());
     check(repository.findAll().limit(2).exists());
 
-    check(!repository.find(string.id.is("id1")).limit(0).exists());
     check(repository.find(string.id.is("id1")).limit(1).exists());
+    check(!repository.find(string.id.isNot("id1")).limit(1).exists());
     check(repository.find(string.id.is("id1")).limit(2).exists());
   }
 }
\ No newline at end of file

File: criteria/mongo/test/org/immutables/criteria/mongo/MongoExtension.java
Patch:
@@ -50,7 +50,7 @@ public class MongoExtension implements BeforeTestExecutionCallback, ParameterRes
   @Override
   public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
     final Class<?> type = parameterContext.getParameter().getType();
-    return MongoDatabase.class.isAssignableFrom(type) || MongoClient.class.isAssignableFrom(type);
+    return MongoDatabase.class.isAssignableFrom(type) || MongoClient.class.isAssignableFrom(type) || MongoInstance.class.isAssignableFrom(type);
   }
 
   @Override
@@ -60,6 +60,8 @@ public Object resolveParameter(ParameterContext parameterContext, ExtensionConte
       return getOrCreate(extensionContext).instance.database();
     } else if (MongoClient.class.isAssignableFrom(type)) {
       return getOrCreate(extensionContext).instance.client();
+    } else if (MongoInstance.class.isAssignableFrom(type)) {
+      return getOrCreate(extensionContext).instance;
     }
 
     throw new ExtensionConfigurationException(String.format("%s supports only %s or %s but yours was %s", MongoExtension.class.getSimpleName(),

File: criteria/geode/src/org/immutables/criteria/geode/OqlGenerator.java
Patch:
@@ -61,8 +61,8 @@ Oql generate(Query query) {
       throw new UnsupportedOperationException("Aggregations / Group By and count(*) are not yet supported");
     }
 
-    // wherever to rewrite query as "select count(*) from (select distinct ...)"
-    boolean addOuterCountQuery = query.count() && query.distinct() && query.hasProjections();
+    // wherever to rewrite query as "select count(*) from (select [distinct] ... from ... where ... limit ?)"
+    boolean addOuterCountQuery = query.count() && (query.distinct() || query.hasProjections() || query.limit().isPresent());
 
     final StringBuilder oql = new StringBuilder("SELECT");
     if (query.distinct()) {

File: criteria/mongo/src/org/immutables/criteria/mongo/MongoSession.java
Patch:
@@ -136,7 +136,8 @@ private Publisher<?> query(StandardOperations.Select select) {
 
     final boolean hasProjections = query.hasProjections();
 
-    boolean useAggregationPipeline = query.hasAggregations() || query.distinct();
+    boolean useAggregationPipeline = query.hasAggregations() || query.distinct()
+            || query.count() && query.limit().isPresent();
     ExpressionNaming expressionNaming = useAggregationPipeline ? ExpressionNaming.from(UniqueCachedNaming.of(query.projections())) : expression -> pathNaming.name((Path) expression);
 
     MongoCollection<?> collection = this.collection;
@@ -170,6 +171,7 @@ private Publisher<?> query(StandardOperations.Select select) {
     }
 
     final FindPublisher<?> find = collection.find(filter);
+
     if (!query.collations().isEmpty()) {
       // add sorting
       final Function<Collation, Bson> toSortFn = col -> {

File: value-fixture/test/org/immutables/fixture/modifiable/BeanFriendlyTest.java
Patch:
@@ -60,5 +60,8 @@ public void modifiableAsJavaBean() throws Exception {
     check(immutableBean.getId()).is(1000);
     check(immutableBean.getNames()).isOf("name", "name2");
     check(immutableBean.getOptions()).is(ImmutableMap.of("foo", "bar"));
+
+    // from works as with Immutable
+    BeanFriendly mutableFromImmutable = new ModifiableBeanFriendly().from(immutableBean);
   }
 }

File: data/src/org/immutables/data/Datatype.java
Patch:
@@ -12,6 +12,8 @@ public interface Datatype<T> {
 
   TypeToken<T> type();
   
+  boolean isInline();
+  
   List<Feature<T, ?>> features();
 
   <F> F get(Feature<T, F> feature, T instance);

File: value-fixture/src/org/immutables/fixture/generics/ExtendingBuilderGenericBounds.java
Patch:
@@ -24,5 +24,6 @@ abstract class Abc {}
 @Value.Immutable
 public abstract class ExtendingBuilderGenericBounds<T extends Abc> {
   public abstract T attr();
+  public <S> S nonAttr() { return null; } // this should not cause validation error
   public static class Builder<T extends Abc> extends ImmutableExtendingBuilderGenericBounds.Builder<T> {}
 }
\ No newline at end of file

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -249,6 +249,8 @@ private ValueMirrors() {}
 
     String nullableAnnotation() default "Nullable";
 
+    int limitStringLengthInToString() default 1000;
+
     Class<? extends Annotation>[] allowedClasspathAnnotations() default {};
 
     public enum ImplementationVisibility {

File: value-fixture/src/org/immutables/fixture/nested/NonGrouped.java
Patch:
@@ -25,7 +25,7 @@ public abstract class NonGrouped {
   @Value.Immutable
   abstract static class Abra {}
 
-  @Value.Immutable(builder = false)
+  @Value.Immutable(builder = false, singleton = true)
   public interface Cadabra {}
 
   @Value.Immutable(builder = false)

File: annotate/src/org/immutables/annotate/InjectAnnotation.java
Patch:
@@ -92,6 +92,7 @@
  */
 @Documented
 @Target(ElementType.ANNOTATION_TYPE)
+@Repeatable(InjectManyAnnotations.class)
 public @interface InjectAnnotation {
   /**
    * Used to specify whole source code for the annotation. Can specify whole target annotation(s)

File: criteria/common/src/org/immutables/criteria/expression/Query.java
Patch:
@@ -76,7 +76,7 @@ public boolean hasProjections() {
    * Check if current query has any aggregation calls
    */
   public boolean hasAggregations() {
-    return !groupBy().isEmpty() || projections().stream().anyMatch(p -> p instanceof AggregationCall);
+    return !groupBy().isEmpty() || projections().stream().anyMatch(Visitors::isAggregationCall);
   }
 
   public ImmutableQuery addCollations(Iterable<Collation> collations) {

File: criteria/common/src/org/immutables/criteria/matcher/Combiner.java
Patch:
@@ -97,7 +97,7 @@ static Call combineAndSimplify(Operator operator, Expression leftExpr, Expressio
     Objects.requireNonNull(operator, "operator");
     if (!(leftExpr instanceof Call && rightExpr instanceof Call)) {
       // regular call which can't be simplified
-      return Expressions.call(operator, leftExpr, rightExpr);
+      return Expressions.binaryCall(operator, leftExpr, rightExpr);
     }
 
     Call left = (Call) leftExpr;
@@ -110,7 +110,7 @@ static Call combineAndSimplify(Operator operator, Expression leftExpr, Expressio
         return Expressions.call(operator, args);
       }
 
-      return Expressions.call(operator, left, right);
+      return Expressions.binaryCall(operator, left, right);
     }
 
     // combine expressions with same operator (AND / OR) into single expression

File: criteria/common/src/org/immutables/criteria/matcher/PresentAbsentMatcher.java
Patch:
@@ -29,12 +29,12 @@
 public interface PresentAbsentMatcher<R> extends Matcher {
 
   default R isPresent() {
-    final UnaryOperator<Expression> expr = e -> Expressions.call(OptionalOperators.IS_PRESENT, e);
+    final UnaryOperator<Expression> expr = e -> Expressions.unaryCall(OptionalOperators.IS_PRESENT, e);
     return Matchers.extract(this).applyAndCreateRoot(expr);
   }
 
   default R isAbsent() {
-    final UnaryOperator<Expression> expr = e -> Expressions.call(OptionalOperators.IS_ABSENT, e);
+    final UnaryOperator<Expression> expr = e -> Expressions.unaryCall(OptionalOperators.IS_ABSENT, e);
     return Matchers.extract(this).applyAndCreateRoot(expr);
   }
 }

File: criteria/elasticsearch/test/org/immutables/criteria/elasticsearch/EmbeddedElasticsearchNode.java
Patch:
@@ -23,6 +23,7 @@
 import org.elasticsearch.action.admin.cluster.node.info.NodesInfoResponse;
 import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.common.transport.TransportAddress;
+import org.elasticsearch.index.reindex.ReindexPlugin;
 import org.elasticsearch.node.InternalSettingsPreparer;
 import org.elasticsearch.node.Node;
 import org.elasticsearch.node.NodeValidationException;
@@ -60,7 +61,7 @@ private EmbeddedElasticsearchNode(Node node) {
    */
   private static EmbeddedElasticsearchNode create(Settings settings) {
     // ensure PainlessPlugin is installed or otherwise scripted fields would not work
-    Node node = new LocalNode(settings, Arrays.asList(Netty4Plugin.class, PainlessPlugin.class));
+    Node node = new LocalNode(settings, Arrays.asList(Netty4Plugin.class, PainlessPlugin.class, ReindexPlugin.class));
     return new EmbeddedElasticsearchNode(node);
   }
 

File: criteria/geode/test/org/immutables/criteria/geode/OqlGeneratorTest.java
Patch:
@@ -114,7 +114,7 @@ void pathNaming() {
 
     check(generator.withoutBindVariables().generate(Query.of(Person.class)
             .addProjections(type, value)
-            .withFilter(Expressions.call(Operators.EQUAL, select, Expressions.constant(42))))
+            .withFilter(Expressions.binaryCall(Operators.EQUAL, select, Expressions.constant(42))))
             .oql()).is("SELECT type1, value1 FROM /myRegion WHERE select1 = 42");
 
     check(generator.generate(Query.of(Person.class).addProjections(type, value).addGroupBy(type))

File: criteria/mongo/src/org/immutables/criteria/mongo/MongoPathNaming.java
Patch:
@@ -37,7 +37,7 @@ class MongoPathNaming implements PathNaming {
 
   @Override
   public String name(Path path) {
-    return idProperty.equals(path) ? "_id" : delegate.name(path);
+    return idProperty.equals(path) ? Mongos.ID_FIELD_NAME : delegate.name(path);
   }
 
   ExpressionNaming toExpression() {

File: criteria/mongo/test/org/immutables/criteria/mongo/QueryAssertion.java
Patch:
@@ -43,8 +43,8 @@ class QueryAssertion {
     this.query = Objects.requireNonNull(query, "query");
     Path idPath = Visitors.toPath(KeyExtractor.defaultFactory().create(query.entityClass()).metadata().keys().get(0));
     PathNaming pathNaming = new MongoPathNaming(idPath, PathNaming.defaultNaming());
-    FindVisitor visitor = new FindVisitor(pathNaming);
     CodecRegistry codecRegistry = MongoClientSettings.getDefaultCodecRegistry();
+    FindVisitor visitor = new FindVisitor(pathNaming, codecRegistry);
     if (query.hasAggregations() || pipeline) {
       AggregationQuery agg = new AggregationQuery(query, pathNaming);
       this.actual =  agg.toPipeline().stream()

File: value-processor/src/org/immutables/value/processor/meta/ValueAttribute.java
Patch:
@@ -1597,8 +1597,7 @@ private void initSpecialAnnotations() {
     for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
       MetaAnnotated metaAnnotated = MetaAnnotated.from(annotation, environment);
 
-      if (metaAnnotated.injectAnnotation().isPresent()) {
-        InjectionInfo info = metaAnnotated.injectAnnotation().get();
+      for (InjectionInfo info : metaAnnotated.injectAnnotation()) {
         if (annotationInjections == null) {
           annotationInjections = ImmutableList.builder();
         }

File: criteria/common/src/org/immutables/criteria/expression/Visitors.java
Patch:
@@ -89,7 +89,7 @@ public Optional<Call> visit(Call call) {
 
   public static Call toCall(Expression expression) {
     Objects.requireNonNull(expression, "expression");
-    return maybeCall(expression).orElseThrow(() -> ERROR_FN.apply(expression, Path.class));
+    return maybeCall(expression).orElseThrow(() -> ERROR_FN.apply(expression, Call.class));
   }
 
   public static boolean isAggregationCall(Expression expression) {

File: value-processor/src/org/immutables/value/processor/Processor.java
Patch:
@@ -104,6 +104,9 @@ protected void process() {
     if (round.environment().hasEncodeModule()) {
       invoke(new Generator_Encodings().generate());
     }
+    if (round.environment().hasDatatypesModule()) {
+      invoke(new Generator_Datatypes().usingValues(values).generate());
+    }
   }
 
   private void prepareOptions() {

File: value-processor/src/org/immutables/value/processor/meta/ValueType.java
Patch:
@@ -52,9 +52,6 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-
 import org.immutables.generator.Output;
 import org.immutables.generator.SourceExtraction;
 import org.immutables.generator.TypeHierarchyCollector;

File: criteria/mongo/src/org/immutables/criteria/mongo/MongoSession.java
Patch:
@@ -84,7 +84,7 @@ class MongoSession implements Backend.Session {
       pathNaming = new MongoPathNaming(idProperty, pathNaming);
     }
     this.pathNaming = pathNaming;
-    this.converter = Mongos.converter(this.pathNaming);
+    this.converter = Mongos.converter(this.pathNaming, collection.getCodecRegistry());
   }
 
   private Bson toBsonFilter(Query query) {

File: criteria/mongo/src/org/immutables/criteria/mongo/Mongos.java
Patch:
@@ -16,6 +16,7 @@
 
 package org.immutables.criteria.mongo;
 
+import org.bson.codecs.configuration.CodecRegistry;
 import org.bson.conversions.Bson;
 import org.immutables.criteria.backend.PathNaming;
 import org.immutables.criteria.expression.ExpressionConverter;
@@ -37,8 +38,8 @@ private Mongos() {}
   /**
    * Convert existing expression to Bson
    */
-  static ExpressionConverter<Bson> converter(PathNaming pathNaming) {
-    return expression -> expression.accept(new FindVisitor(pathNaming));
+  static ExpressionConverter<Bson> converter(PathNaming pathNaming, CodecRegistry codecRegistry) {
+    return expression -> expression.accept(new FindVisitor(pathNaming, codecRegistry));
   }
 
   /**

File: criteria/mongo/test/org/immutables/criteria/mongo/QueryAssertion.java
Patch:
@@ -43,8 +43,8 @@ class QueryAssertion {
     this.query = Objects.requireNonNull(query, "query");
     Path idPath = Visitors.toPath(KeyExtractor.defaultFactory().create(query.entityClass()).metadata().keys().get(0));
     PathNaming pathNaming = new MongoPathNaming(idPath, PathNaming.defaultNaming());
-    FindVisitor visitor = new FindVisitor(pathNaming);
     CodecRegistry codecRegistry = MongoClientSettings.getDefaultCodecRegistry();
+    FindVisitor visitor = new FindVisitor(pathNaming, codecRegistry);
     if (query.hasAggregations() || pipeline) {
       AggregationQuery agg = new AggregationQuery(query, pathNaming);
       this.actual =  agg.toPipeline().stream()

File: criteria/geode/test/org/immutables/criteria/geode/KeyLookupAnalyzerTest.java
Patch:
@@ -25,7 +25,6 @@
 import org.junit.jupiter.api.Test;
 
 import java.util.Collections;
-import java.util.List;
 
 import static org.immutables.check.Checkers.check;
 
@@ -87,7 +86,7 @@ void disabled() {
     Assertions.assertThrows(UnsupportedOperationException.class, result::values);
   }
 
-  private static List<String> ids(StringHolderCriteria crit) {
+  private static Iterable<String> ids(StringHolderCriteria crit) {
     Expression filter =Criterias.toQuery(crit).filter()
             .orElseThrow(() -> new AssertionError("No filter present"));
 
@@ -99,7 +98,7 @@ private static List<String> ids(StringHolderCriteria crit) {
       return Collections.emptyList();
     }
 
-    return (List<String>) result.values();
+    return (Iterable<String>) result.values();
   }
 
 }

File: criteria/elasticsearch/src/org/immutables/criteria/elasticsearch/CountCall.java
Patch:
@@ -48,7 +48,7 @@ public Single<Long> call() {
     }
 
     ObjectNode filter =  query.filter()
-            .map(f -> Elasticsearch.toBuilder(f, session.pathNaming).toJson(session.objectMapper))
+            .map(f -> Elasticsearch.toBuilder(f, session.pathNaming, session.idPredicate).toJson(session.objectMapper))
             .orElse(session.objectMapper.createObjectNode());
 
     if (filter.size() != 0) {

File: generator/src/org/immutables/generator/Output.java
Patch:
@@ -323,7 +323,7 @@ void complete() {
         } else {
           getMessager().printMessage(Kind.MANDATORY_WARNING,
               String.format(
-                  "Generated source file name colission. Attempt to overwrite already generated file: %s, %s."
+                  "Generated source file name collision. Attempt to overwrite already generated file: %s, %s."
                       + " If this happens when using @Value.Immutable on same-named nested classes in the same package,"
                       + " use can use @Value.Enclosing annotation to provide some sort of namespacing",
                   key,

File: gson/src/org/immutables/gson/stream/JsonParserReader.java
Patch:
@@ -16,6 +16,7 @@
 package org.immutables.gson.stream;
 
 import com.fasterxml.jackson.core.JsonLocation;
+import com.fasterxml.jackson.core.JsonParseException;
 import com.fasterxml.jackson.core.JsonParser;
 import com.fasterxml.jackson.core.JsonStreamContext;
 import com.fasterxml.jackson.databind.util.TokenBuffer;
@@ -31,7 +32,7 @@
 import static com.fasterxml.jackson.core.JsonToken.*;
 
 /**
- * {@link JsonReader} impementation backed by Jackson's {@link JsonParser}.
+ * {@link JsonReader} implementation backed by Jackson's {@link JsonParser}.
  * Provides measurable JSON parsing improvements over Gson's native implementation.
  * Error reporting might differ, however.
  */

File: criteria/geode/src/org/immutables/criteria/geode/Geodes.java
Patch:
@@ -47,7 +47,7 @@ final class Geodes {
    *
    * @return predicate, empty string if no predicate
    */
-  static ExpressionConverter<OqlWithVariables> converter(boolean useBindVariables, PathNaming pathNaming) {
+  static ExpressionConverter<Oql> converter(boolean useBindVariables, PathNaming pathNaming) {
     return expression -> expression.accept(new GeodeQueryVisitor(useBindVariables, pathNaming));
   }
 

File: criteria/geode/src/org/immutables/criteria/geode/Oql.java
Patch:
@@ -23,13 +23,12 @@
  * <a href="https://geode.apache.org/docs/guide/16/developing/querying_basics/query_basics.html">OQL</a>
  * with bind variables.
  */
-class OqlWithVariables {
+class Oql {
 
   private final List<Object> variables;
-
   private final String oql;
 
-  OqlWithVariables(List<Object> variables, String oql) {
+  Oql(List<Object> variables, String oql) {
     this.variables = Objects.requireNonNull(variables, "variables");
     this.oql = Objects.requireNonNull(oql, "oql");
   }

File: criteria/geode/src/org/immutables/criteria/geode/SyncDelete.java
Patch:
@@ -55,7 +55,7 @@ public WriteResult call() throws Exception {
     }
 
     GeodeQueryVisitor visitor = new GeodeQueryVisitor(true, path -> String.format("e.value.%s", session.pathNaming.name(path)));
-    OqlWithVariables oql = filter.accept(visitor);
+    Oql oql = filter.accept(visitor);
 
     // delete by query. Perform separate query to get list of IDs
     String query = String.format("select distinct e.key from %s.entries e where %s", region.getFullPath(), oql.oql());

File: criteria/geode/src/org/immutables/criteria/geode/SyncSelect.java
Patch:
@@ -65,7 +65,8 @@ private static ProjectedTuple toTuple(Query query, Object value) {
   @Override
   public Iterable<Object> call() throws Exception {
 
-    OqlWithVariables oql = session.toOql(operation.query(), true);
+    Oql oql = session.oqlGenerator().generate(operation.query());
+
     if (GeodeBackend.logger.isLoggable(Level.FINE)) {
       GeodeBackend.logger.log(Level.FINE, "Querying Geode with {0}", oql);
     }

File: criteria/common/src/org/immutables/criteria/repository/Publishers.java
Patch:
@@ -80,7 +80,7 @@ public static <X> List<X> blockingListGet(Publisher<X> publisher) {
   private static <X> io.reactivex.functions.Function<Single<X>, CompletionStage<X>> singleToFuture() {
     return single -> {
       final CompletableFuture<X> fut = new CompletableFuture<>();
-      Disposable disposable = single.subscribe(fut::complete, fut::completeExceptionally);
+      Disposable unused = single.subscribe(fut::complete, fut::completeExceptionally);
       return fut;
     };
   }

File: criteria/common/test/org/immutables/criteria/processor/JavaBeanModelTest.java
Patch:
@@ -260,6 +260,7 @@ public void setBase(String base) {
    */
   @ProcessorRule.TestImmutable
   @Criteria
+  @SuppressWarnings("unused")
   static class VisibilityModel {
     public int publicField;
     int packageField;

File: criteria/common/src/org/immutables/criteria/matcher/CriteriaContext.java
Patch:
@@ -80,8 +80,9 @@ <R> R create() {
     return (R) createWith(creator);
   }
 
-  CriteriaCreator creator() {
-    return creator;
+  @SuppressWarnings("unchecked")
+  <R> CriteriaCreator<R> creator() {
+    return (CriteriaCreator<R>) creator;
   }
 
   /**

File: criteria/common/test/org/immutables/criteria/personmodel/CriteriaChecker.java
Patch:
@@ -85,6 +85,7 @@ public <Z> IterableChecker<List<Z>, Z> toList(Function<? super T, ? extends Z> f
     return check(result.stream().map(fn).collect(Collectors.toList()));
   }
 
+  @SuppressWarnings("unchecked")
   private static <T> List<T> fetch(Reader<T> reader) {
     final List<T> result;
     if (reader instanceof SyncReader) {

File: criteria/elasticsearch/src/org/immutables/criteria/elasticsearch/Json.java
Patch:
@@ -680,8 +680,9 @@ private static Aggregations parseAggregations(JsonParser parser, ObjectNode node
 
     private static MultiValue parseValue(JsonParser parser, String name, ObjectNode node)
             throws JsonProcessingException {
-
-      return new MultiValue(name, parser.getCodec().treeToValue(node, Map.class));
+      @SuppressWarnings("unchecked")
+      Map<String, Object> values = (Map<String, Object>) parser.getCodec().treeToValue(node, Map.class);
+      return new MultiValue(name, values);
     }
 
     private static Aggregation parseBuckets(JsonParser parser, String name, ArrayNode nodes)

File: criteria/geode/test/org/immutables/criteria/geode/AutocreateRegion.java
Patch:
@@ -40,10 +40,12 @@ public void accept(Class<?> entity) {
       return;
     }
 
+    @SuppressWarnings("unchecked")
+    Class<Object> valueConstraint = (Class<Object>) entity;
     // if not, create
     cache.createRegionFactory()
             .setScope(Scope.LOCAL) // otherwise ConcurrentMap API doesn't work for Region
-            .setValueConstraint((Class<Object>) entity)
+            .setValueConstraint(valueConstraint)
             .create(name);
   }
 }

File: criteria/rxjava2/src/org/immutables/criteria/repository/rxjava2/RxJavaUpdaterDelegate.java
Patch:
@@ -44,6 +44,7 @@ public WriteExecutor<Single<WriteResult>> replace(T newValue) {
     return () -> Flowable.fromPublisher(delegate.replace(newValue).execute()).singleOrError();
   }
 
+  @SuppressWarnings("unchecked")
   private static class RxJavaSetter<T> implements Updater.Setter<Single<WriteResult>> {
 
     private final ReactiveUpdater.ReactiveSetter delegate;
@@ -59,7 +60,6 @@ public <V> RxJavaSetter<T> set(Projection<V> projection, V value) {
 
     @Override
     public Single<WriteResult> execute() {
-      @SuppressWarnings("unchecked")
       Publisher<WriteResult> execute = delegate.execute();
       return Flowable.fromPublisher(execute).singleOrError();
     }

File: criteria/common/src/org/immutables/criteria/matcher/CriteriaContext.java
Patch:
@@ -18,6 +18,7 @@
 
 import org.immutables.criteria.expression.Expression;
 import org.immutables.criteria.expression.Expressions;
+import org.immutables.criteria.expression.ImmutableQuery;
 import org.immutables.criteria.expression.Path;
 import org.immutables.criteria.expression.Query;
 import org.immutables.criteria.expression.Queryable;
@@ -123,7 +124,7 @@ private DnfExpression dnfExpression() {
 
   @Override
   public Query query() {
-    final Query query = Query.of(entityClass);
+    final ImmutableQuery query = Query.of(entityClass);
     Expression expression = expression();
     if (expression instanceof DnfExpression) {
       DnfExpression dnfExpression = dnfExpression();

File: criteria/common/src/org/immutables/criteria/matcher/OrMatcher.java
Patch:
@@ -17,8 +17,6 @@
 package org.immutables.criteria.matcher;
 
 import org.immutables.criteria.Criterion;
-import org.immutables.criteria.expression.Expression;
-import org.immutables.criteria.expression.Expressions;
 import org.immutables.criteria.expression.Operators;
 
 /**

File: criteria/common/src/org/immutables/criteria/repository/Writable.java
Patch:
@@ -19,8 +19,6 @@
 import com.google.common.collect.ImmutableList;
 import org.immutables.criteria.Criterion;
 
-import java.util.Arrays;
-
 /**
  * Declares repository as writable. Means documents can be inserted / updated / deleted.
  *

File: criteria/common/test/org/immutables/criteria/AggregationExpressionTest.java
Patch:
@@ -24,8 +24,6 @@
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
 
-import java.io.PrintWriter;
-import java.io.StringWriter;
 import java.util.Arrays;
 import java.util.stream.Collectors;
 

File: criteria/common/test/org/immutables/criteria/ExpressionAsStringTest.java
Patch:
@@ -23,8 +23,6 @@
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
 
-import java.io.PrintWriter;
-import java.io.StringWriter;
 import java.util.Arrays;
 import java.util.stream.Collectors;
 

File: criteria/common/test/org/immutables/criteria/backend/IdResolverTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package org.immutables.criteria.backend;
 
-import org.immutables.criteria.backend.IdResolver;
 import org.immutables.criteria.javabean.JavaBean1;
 import org.immutables.criteria.personmodel.Person;
 import org.junit.jupiter.api.Test;

File: criteria/common/test/org/immutables/criteria/backend/JavaBeanNamingTest.java
Patch:
@@ -19,8 +19,6 @@
 import org.immutables.criteria.expression.Path;
 import org.junit.jupiter.api.Test;
 
-import java.lang.reflect.Member;
-
 import static org.immutables.check.Checkers.check;
 
 class JavaBeanNamingTest {

File: criteria/common/test/org/immutables/criteria/reflect/ClassScannerTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package org.immutables.criteria.reflect;
 
-import org.immutables.criteria.reflect.ClassScanner;
 import org.junit.jupiter.api.Test;
 
 import java.lang.reflect.Member;

File: criteria/common/test/org/immutables/criteria/typemodel/DoubleTemplate.java
Patch:
@@ -22,7 +22,6 @@
 import org.junit.jupiter.api.Test;
 
 import java.util.List;
-import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalDouble;
 import java.util.function.Supplier;

File: criteria/common/test/org/immutables/criteria/typemodel/IntegerTemplate.java
Patch:
@@ -23,7 +23,6 @@
 
 import java.util.List;
 import java.util.Optional;
-import java.util.OptionalDouble;
 import java.util.OptionalInt;
 import java.util.function.Supplier;
 

File: criteria/elasticsearch/src/org/immutables/criteria/elasticsearch/IndexResolver.java
Patch:
@@ -21,6 +21,7 @@
 
 public interface IndexResolver extends ContainerResolver<String> {
 
+  @Override
   String resolve(Class<?> entityType);
 
   /**

File: criteria/elasticsearch/test/org/immutables/criteria/elasticsearch/ElasticAggregationTest.java
Patch:
@@ -17,7 +17,6 @@
 package org.immutables.criteria.elasticsearch;
 
 import com.fasterxml.jackson.databind.ObjectMapper;
-import com.google.common.base.Throwables;
 import org.elasticsearch.client.RestClient;
 import org.immutables.criteria.backend.Backend;
 import org.immutables.criteria.personmodel.PersonAggregationTest;

File: criteria/inmemory/test/org/immutables/criteria/inmemory/InMemoryTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package org.immutables.criteria.inmemory;
 
-import org.immutables.criteria.personmodel.ImmutablePerson;
 import org.immutables.criteria.personmodel.Person;
 import org.immutables.criteria.personmodel.PersonCriteria;
 import org.immutables.criteria.personmodel.PersonGenerator;

File: criteria/mongo/src/org/immutables/criteria/mongo/MongoBackend.java
Patch:
@@ -17,8 +17,8 @@
 package org.immutables.criteria.mongo;
 
 import org.immutables.criteria.backend.Backend;
-import org.immutables.criteria.backend.PathNaming;
 import org.immutables.criteria.backend.IdResolver;
+import org.immutables.criteria.backend.PathNaming;
 
 import java.util.Objects;
 

File: criteria/mongo/src/org/immutables/criteria/mongo/bson4jackson/BsonGenerator.java
Patch:
@@ -16,15 +16,13 @@
 package org.immutables.criteria.mongo.bson4jackson;
 
 import com.fasterxml.jackson.core.Base64Variant;
-import com.fasterxml.jackson.core.ObjectCodec;
 import com.fasterxml.jackson.core.base.GeneratorBase;
 import org.bson.BsonBinary;
 import org.bson.BsonWriter;
 import org.bson.types.Decimal128;
 
 import javax.annotation.concurrent.NotThreadSafe;
 import java.io.IOException;
-import java.io.InputStream;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Arrays;

File: criteria/mongo/src/org/immutables/criteria/mongo/bson4jackson/JacksonCodecs.java
Patch:
@@ -18,7 +18,6 @@
 
 import com.fasterxml.jackson.core.JsonGenerator;
 import com.fasterxml.jackson.core.JsonParser;
-import com.fasterxml.jackson.core.JsonProcessingException;
 import com.fasterxml.jackson.core.Version;
 import com.fasterxml.jackson.databind.BeanDescription;
 import com.fasterxml.jackson.databind.DeserializationConfig;
@@ -52,7 +51,6 @@
 import org.bson.codecs.configuration.CodecRegistry;
 import org.bson.conversions.Bson;
 
-import java.io.IOException;
 import java.util.Objects;
 import java.util.function.Predicate;
 
@@ -98,7 +96,7 @@ private static <T> JsonDeserializer<T> deserializer(final Codec<T> codec) {
     Objects.requireNonNull(codec, "codec");
     return new JsonDeserializer<T>() {
       @Override
-      public T deserialize(JsonParser parser, DeserializationContext ctxt) throws IOException, JsonProcessingException {
+      public T deserialize(JsonParser parser, DeserializationContext ctxt) {
         @SuppressWarnings("unchecked")
         final BsonReader reader = ((Wrapper<BsonReader>) parser).unwrap();
         return codec.decode(reader, DecoderContext.builder().build());

File: criteria/mongo/test/org/immutables/criteria/mongo/AggregationQueryTest.java
Patch:
@@ -38,7 +38,6 @@ class AggregationQueryTest {
 
   private final PersonCriteria person = PersonCriteria.person;
 
-
   @Test
   void basic() {
     // select nickName, sum(age) from ... group by nickName

File: criteria/mongo/test/org/immutables/criteria/mongo/bson4jackson/IdAnnotationModuleTest.java
Patch:
@@ -24,11 +24,11 @@
 import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
 import com.google.common.collect.ImmutableList;
 import org.immutables.criteria.Criteria;
+import org.immutables.criteria.backend.IdResolver;
 import org.immutables.criteria.javabean.JavaBean1;
 import org.immutables.criteria.personmodel.ImmutablePerson;
 import org.immutables.criteria.personmodel.Person;
 import org.immutables.criteria.personmodel.PersonGenerator;
-import org.immutables.criteria.backend.IdResolver;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.MethodSource;
 

File: criteria/mongo/test/org/immutables/criteria/mongo/bson4jackson/Parsers.java
Patch:
@@ -24,7 +24,6 @@
 import org.bson.BsonBinaryWriter;
 import org.bson.BsonDocument;
 import org.bson.BsonValue;
-import org.bson.BsonWriter;
 import org.bson.codecs.EncoderContext;
 import org.bson.codecs.configuration.CodecRegistry;
 import org.bson.io.BasicOutputBuffer;

File: criteria/common/src/org/immutables/criteria/backend/JavaBeanNaming.java
Patch:
@@ -76,7 +76,7 @@ public String name(Path path) {
     return path.members().stream().map(p -> maybeNameFromGetterSetter((Member) p)).collect(Collectors.joining("."));
   }
 
-  private String maybeNameFromGetterSetter(Member member) {
+  private static String maybeNameFromGetterSetter(Member member) {
     if (!(member instanceof Method)) {
       return member.getName();
     }

File: criteria/common/src/org/immutables/criteria/repository/Publishers.java
Patch:
@@ -18,6 +18,7 @@
 
 import io.reactivex.Flowable;
 import io.reactivex.Single;
+import io.reactivex.disposables.Disposable;
 import org.reactivestreams.Publisher;
 
 import java.util.List;
@@ -79,7 +80,7 @@ public static <X> List<X> blockingListGet(Publisher<X> publisher) {
   private static <X> io.reactivex.functions.Function<Single<X>, CompletionStage<X>> singleToFuture() {
     return single -> {
       final CompletableFuture<X> fut = new CompletableFuture<>();
-      single.subscribe(fut::complete, fut::completeExceptionally);
+      Disposable disposable = single.subscribe(fut::complete, fut::completeExceptionally);
       return fut;
     };
   }

File: criteria/common/test/org/immutables/criteria/backend/JavaBeanNamingTest.java
Patch:
@@ -48,7 +48,7 @@ void booleans() throws NoSuchMethodException {
     check(JavaBeanNaming.IS_GETTER.test(JavaBean.class.getDeclaredMethod("getA")));
   }
 
-  private Path path(String name) throws NoSuchMethodException {
+  private static Path path(String name) throws NoSuchMethodException {
     return Path.ofMember(JavaBean.class.getDeclaredMethod(name));
   }
 

File: criteria/common/test/org/immutables/criteria/personmodel/AbstractPersonTest.java
Patch:
@@ -638,7 +638,7 @@ private void assumeFeature(Feature feature) {
     Assumptions.assumeTrue(features().contains(feature), String.format("Feature %s not supported by current backend", feature));
   }
 
-  private <T extends Comparable<T>> void assertOrdered(Function<Person, T> extractor, SyncReader<Person> reader, Ordering<T> ordering) {
+  private static <T extends Comparable<T>> void assertOrdered(Function<Person, T> extractor, SyncReader<Person> reader, Ordering<T> ordering) {
     List<T> parts = reader.fetch().stream().map(extractor).collect(Collectors.toList());
     if (!ordering.isOrdered(parts)) {
       throw new AssertionError(String.format("%s is not ordered. Expected: %s", parts, ordering.sortedCopy(parts)));

File: criteria/common/test/org/immutables/criteria/personmodel/PersonAggregationTest.java
Patch:
@@ -165,7 +165,7 @@ public void no_groupBy() {
             .map((count, sum, min, max, avg) -> String.format(Locale.ROOT, "count=%d sum=%d max=%d min=%d avg=%.2f", count, sum, min, max, avg)))
             .hasContentInAnyOrder("count=3 sum=90 max=40 min=20 avg=30.00");
 
-    // add filter age <= 10
+    // add filter age <= 10JavaBeanNamingTest.java
     check(repository().find(person.age.atMost(10))
             .select(person.id.count(), person.age.sum(), person.age.max(), person.age.min(), person.age.avg())
             .map((count, sum, min, max, avg) -> String.format(Locale.ROOT, "count=%d sum=%d max=%d min=%d avg=%.2f", count, sum, min, max, avg)))
@@ -180,7 +180,7 @@ protected void insert(Iterable<? extends Person> persons) {
     repository().insertAll(persons);
   }
 
-  private <T> IterableChecker<List<T>, T> check(SyncFetcher<T> fetcher) {
+  private static <T> IterableChecker<List<T>, T> check(SyncFetcher<T> fetcher) {
     return Checkers.check(fetcher.fetch());
   }
 

File: criteria/elasticsearch/src/org/immutables/criteria/elasticsearch/ElasticsearchQueryVisitor.java
Patch:
@@ -79,7 +79,7 @@ public QueryBuilders.QueryBuilder visit(Call call) {
     throw new UnsupportedOperationException("Don't know how to handle " + call);
   }
 
-  private QueryBuilders.QueryBuilder binaryCall(Call call) {
+  private static QueryBuilders.QueryBuilder binaryCall(Call call) {
     final List<Expression> arguments = call.arguments();
     Preconditions.checkArgument(arguments.size() == 2, "Size should be 2 for %s but was %s",
             call.operator(), arguments.size());

File: criteria/elasticsearch/src/org/immutables/criteria/elasticsearch/QueryBuilders.java
Patch:
@@ -249,7 +249,7 @@ ObjectNode toJson(ObjectMapper mapper) {
       return result;
     }
 
-    private void writeJsonArray(String field, List<QueryBuilder> clauses, ObjectNode node, ObjectMapper mapper) {
+    private static void writeJsonArray(String field, List<QueryBuilder> clauses, ObjectNode node, ObjectMapper mapper) {
       if (clauses.isEmpty()) {
         return;
       }

File: criteria/elasticsearch/test/org/immutables/criteria/elasticsearch/ElasticAggregationTest.java
Patch:
@@ -17,6 +17,7 @@
 package org.immutables.criteria.elasticsearch;
 
 import com.fasterxml.jackson.databind.ObjectMapper;
+import com.google.common.base.Throwables;
 import org.elasticsearch.client.RestClient;
 import org.immutables.criteria.backend.Backend;
 import org.immutables.criteria.personmodel.PersonAggregationTest;
@@ -38,7 +39,7 @@ public class ElasticAggregationTest extends PersonAggregationTest {
 
   ElasticAggregationTest(RestClient restClient) throws IOException {
     IndexOps ops = new IndexOps(restClient, MAPPER, INDEX_NAME);
-    ops.create(PersonModel.MAPPING).blockingGet();
+    ops.create(PersonModel.MAPPING).blockingAwait();
     this.backend = new ElasticsearchBackend(ElasticsearchSetup.builder(restClient).objectMapper(MAPPER).build());
   }
 

File: criteria/elasticsearch/test/org/immutables/criteria/elasticsearch/ElasticExtension.java
Patch:
@@ -47,11 +47,10 @@ public Object resolveParameter(ParameterContext parameterContext, ExtensionConte
     return getOrCreate(extensionContext).restClient();
   }
 
-  private ElasticResource getOrCreate(ExtensionContext context) {
+  private static ElasticResource getOrCreate(ExtensionContext context) {
     return context.getStore(NAMESPACE).getOrComputeIfAbsent(KEY, key -> new ElasticResource(EmbeddedElasticsearchNode.create()), ElasticResource.class);
   }
 
-
   @Override
   public void afterEach(ExtensionContext context) throws Exception {
     ElasticResource resource = context.getStore(NAMESPACE).get(KEY, ElasticResource.class);

File: criteria/elasticsearch/test/org/immutables/criteria/elasticsearch/ElasticIntegrationTests.java
Patch:
@@ -57,7 +57,7 @@ class ElasticIntegrationTests {
       IndexOps ops = new IndexOps(restClient, mapper, name);
       // create index if doesn't exists
       if (!ops.exists().blockingGet()) {
-        ops.create(Mappings.of(entity)).blockingGet();
+        ops.create(Mappings.of(entity)).blockingAwait();
       }
     };
     this.backend = WithSessionCallback.wrap(backend, onOpen);

File: criteria/elasticsearch/test/org/immutables/criteria/elasticsearch/ElasticPersonTest.java
Patch:
@@ -54,7 +54,7 @@ public class ElasticPersonTest extends AbstractPersonTest  {
 
   ElasticPersonTest(RestClient restClient) throws IOException {
     ops = new IndexOps(restClient, MAPPER, INDEX_NAME);
-    ops.create(PersonModel.MAPPING).blockingGet();
+    ops.create(PersonModel.MAPPING).blockingAwait();
     this.backend = new ElasticsearchBackend(ElasticsearchSetup.builder(restClient).objectMapper(MAPPER).build());
   }
 

File: criteria/elasticsearch/test/org/immutables/criteria/elasticsearch/ScrollingTest.java
Patch:
@@ -23,6 +23,7 @@
 import org.elasticsearch.client.Request;
 import org.elasticsearch.client.Response;
 import org.elasticsearch.client.RestClient;
+import org.immutables.criteria.backend.WriteResult;
 import org.immutables.criteria.personmodel.CriteriaChecker;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
@@ -65,7 +66,7 @@ private void elasticseachInit() throws IOException {
             .put("intNumber", "integer")
             .build();
 
-    new IndexOps(restClient, MAPPER, "test").create(model).blockingGet();
+    new IndexOps(restClient, MAPPER, "test").create(model).blockingAwait();
 
     ElasticsearchBackend backend = backend();
     ElasticsearchOps ops = new ElasticsearchOps(restClient, "test", MAPPER, 1024);
@@ -75,7 +76,7 @@ private void elasticseachInit() throws IOException {
               .put("bool", true)
               .put("intNumber", i);
 
-      ops.insertDocument(doc).blockingGet();
+      WriteResult result = ops.insertDocument(doc).blockingGet();
     }
   }
 

File: criteria/geode/test/org/immutables/criteria/geode/GeodeExtension.java
Patch:
@@ -62,7 +62,7 @@ public Object resolveParameter(ParameterContext parameterContext, ExtensionConte
     return getOrCreate(extensionContext).cache();
   }
 
-  private GeodeResource getOrCreate(ExtensionContext context) {
+  private static GeodeResource getOrCreate(ExtensionContext context) {
     return context.getStore(NAMESPACE).getOrComputeIfAbsent(KEY, key -> new GeodeResource(), GeodeResource.class);
   }
 

File: criteria/inmemory/src/org/immutables/criteria/inmemory/ExpressionInterpreter.java
Patch:
@@ -166,7 +166,7 @@ public Object visit(Call call) {
       throw new UnsupportedOperationException("Don't know how to handle " + op);
     }
 
-    private Object binaryCall(Call call, Object left, Object right) {
+    private static Object binaryCall(Call call, Object left, Object right) {
       Preconditions.checkArgument(call.operator().arity() == Operator.Arity.BINARY, "Expected binary call got %s", call);
       final Operator op = call.operator();
 

File: criteria/inmemory/src/org/immutables/criteria/inmemory/TupleExtractor.java
Patch:
@@ -57,7 +57,7 @@ ProjectedTuple extract(Object instance) {
   /**
    * Expected result might be optional
    */
-  private Object maybeWrapOptional(Object value, Path path) {
+  private static Object maybeWrapOptional(Object value, Path path) {
     Type type = path.returnType();
     final Class<?> klass;
     if (type instanceof ParameterizedType) {

File: criteria/mongo/test/org/immutables/criteria/mongo/BackendResource.java
Patch:
@@ -21,6 +21,7 @@
 import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;
 import com.mongodb.reactivestreams.client.MongoCollection;
 import com.mongodb.reactivestreams.client.MongoDatabase;
+import com.mongodb.reactivestreams.client.Success;
 import io.reactivex.Flowable;
 import org.bson.codecs.configuration.CodecRegistry;
 import org.immutables.criteria.backend.ContainerNaming;
@@ -77,7 +78,7 @@ public MongoCollection<?> resolve(Class<?> entityClass) {
       final MongoCollection<?> collection;
       // already exists ?
       if (!Flowable.fromPublisher(database.listCollectionNames()).toList().blockingGet().contains(name)) {
-        Flowable.fromPublisher(database.createCollection(name)).blockingFirst();
+        Success success = Flowable.fromPublisher(database.createCollection(name)).blockingFirst();
       }
 
       return database.getCollection(name).withDocumentClass(entityClass).withCodecRegistry(registry);

File: criteria/mongo/test/org/immutables/criteria/mongo/MongoExtension.java
Patch:
@@ -66,7 +66,7 @@ public Object resolveParameter(ParameterContext parameterContext, ExtensionConte
             MongoDatabase.class.getName(), MongoClient.class.getName(), type.getName()));
   }
 
-  private MongoResource getOrCreate(ExtensionContext context) {
+  private static MongoResource getOrCreate(ExtensionContext context) {
     return context.getRoot().getStore(NAMESPACE).getOrComputeIfAbsent(KEY, key -> new MongoResource(MongoInstance.create()), MongoResource.class);
   }
 
@@ -83,6 +83,7 @@ private MongoResource(MongoInstance instance) {
       this.instance = Objects.requireNonNull(instance, "instance");
     }
 
+    @SuppressWarnings("CheckReturnValue")
     private void clear() {
       // drop all collections
       MongoDatabase database = instance.database();

File: criteria/mongo/test/org/immutables/criteria/mongo/MongoInstance.java
Patch:
@@ -20,6 +20,7 @@
 import com.mongodb.reactivestreams.client.MongoClient;
 import com.mongodb.reactivestreams.client.MongoClients;
 import com.mongodb.reactivestreams.client.MongoDatabase;
+import com.mongodb.reactivestreams.client.Success;
 import de.bwaldvogel.mongo.MongoServer;
 import de.bwaldvogel.mongo.backend.memory.MemoryBackend;
 import io.reactivex.Flowable;
@@ -47,7 +48,7 @@ private MongoInstance(MongoClient client, Closer closer) {
 
     // drop database if exists (to have a clean test)
     if (Flowable.fromPublisher(client.listDatabaseNames()).toList().blockingGet().contains(DBNAME)) {
-      Flowable.fromPublisher(client.getDatabase(DBNAME).drop()).blockingFirst();
+      Success success = Flowable.fromPublisher(client.getDatabase(DBNAME).drop()).blockingFirst();
     }
 
     this.database = client.getDatabase(DBNAME);

File: criteria/mongo/test/org/immutables/criteria/mongo/bson4jackson/BsonParserTest.java
Patch:
@@ -222,7 +222,7 @@ private ObjectNode maybeWrap(JsonNode toChange)  {
     return (ObjectNode) toChange;
   }
 
-  private BsonValue maybeUnwrap(BsonDocument document) {
+  private static BsonValue maybeUnwrap(BsonDocument document) {
     return document.containsKey("ignore") ? document.get("ignore") : document;
   }
 }

File: criteria/mongo/test/org/immutables/criteria/mongo/bson4jackson/JacksonCodecsTest.java
Patch:
@@ -155,7 +155,7 @@ public void array() throws IOException {
   }
 
   @SuppressWarnings("unchecked")
-  private <T> T writeThenRead(CodecRegistry registry, ObjectMapper mapper, T value) throws IOException {
+  private static <T> T writeThenRead(CodecRegistry registry, ObjectMapper mapper, T value) throws IOException {
     BasicOutputBuffer buffer = new BasicOutputBuffer();
     BsonWriter writer = new BsonBinaryWriter(buffer);
     registry.get((Class<T>) value.getClass()).encode(writer, value, EncoderContext.builder().build());

File: criteria/common/src/org/immutables/criteria/expression/Query.java
Patch:
@@ -113,7 +113,7 @@ public String toString() {
     final StringWriter string = new StringWriter();
     final PrintWriter writer = new PrintWriter(string);
 
-    final DebugExpressionVisitor<Object> visitor = new DebugExpressionVisitor<>(writer);
+    final DebugExpressionVisitor<PrintWriter> visitor = new DebugExpressionVisitor<>(writer);
     writer.append("entity: ").append(entityClass().getName()).println();
 
     if (!projections().isEmpty()) {

File: criteria/common/src/org/immutables/criteria/expression/SimpleCall.java
Patch:
@@ -66,7 +66,7 @@ public String toString() {
     printer.append(SimpleCall.class.getSimpleName());
     printer.append("{");
     printer.print(operator().name());
-    DebugExpressionVisitor<Void> debug = new DebugExpressionVisitor<>(printer);
+    DebugExpressionVisitor<PrintWriter> debug = new DebugExpressionVisitor<>(printer);
     arguments().forEach(a -> {
       a.accept(debug);
     });

File: criteria/common/test/org/immutables/criteria/AggregationExpressionTest.java
Patch:
@@ -46,10 +46,9 @@ public void aggregation() {
 
   private static void assertProjection(Aggregation<?> aggregation, String ... expectedLines) {
     Expression expression = Matchers.toExpression(aggregation);
-    StringWriter out = new StringWriter();
-    expression.accept(new DebugExpressionVisitor<>(new PrintWriter(out)));
+    String out = expression.accept(new DebugExpressionVisitor<>(new StringBuilder())).toString();
     final String expected = Arrays.stream(expectedLines).collect(Collectors.joining(System.lineSeparator()));
-    Assertions.assertEquals(expected, out.toString().trim());
+    Assertions.assertEquals(expected, out.trim());
   }
 
 

File: criteria/common/test/org/immutables/criteria/ExpressionAsStringTest.java
Patch:
@@ -398,9 +398,9 @@ void inner() {
 
 
   private static void assertExpressional(Criterion<?> crit, String ... expectedLines) {
-    final StringWriter out = new StringWriter();
+    final StringBuilder out = new StringBuilder();
     Query query = Criterias.toQuery(crit);
-    query.filter().ifPresent(f -> f.accept(new DebugExpressionVisitor<>(new PrintWriter(out))));
+    query.filter().ifPresent(f -> f.accept(new DebugExpressionVisitor<>(out)));
     final String expected = Arrays.stream(expectedLines).collect(Collectors.joining(System.lineSeparator()));
     Assertions.assertEquals(expected, out.toString().trim());
   }

File: criteria/common/src/org/immutables/criteria/expression/SimpleCall.java
Patch:
@@ -65,10 +65,9 @@ public String toString() {
     final PrintWriter printer = new PrintWriter(writer);
     printer.append(SimpleCall.class.getSimpleName());
     printer.append("{");
-    printer.println(operator().name());
+    printer.print(operator().name());
     DebugExpressionVisitor<Void> debug = new DebugExpressionVisitor<>(printer);
     arguments().forEach(a -> {
-      printer.println();
       a.accept(debug);
     });
     printer.append("}");

File: criteria/geode/src/org/immutables/criteria/geode/GeodeQueryVisitor.java
Patch:
@@ -85,8 +85,8 @@ public OqlWithVariables visit(Call call) {
 
     if (op == Operators.AND || op == Operators.OR) {
       Preconditions.checkArgument(!args.isEmpty(), "Size should be >=1 for %s but was %s", op, args.size());
-      final String join = " " + op.name() + " ";
-      final String newOql = args.stream().map(a -> a.accept(this)).map(OqlWithVariables::oql).collect(Collectors.joining(join));
+      final String join = ") " + op.name() + " (";
+      final String newOql = "(" + args.stream().map(a -> a.accept(this)).map(OqlWithVariables::oql).collect(Collectors.joining(join)) + ")";
       return new OqlWithVariables(variables, newOql);
     }
 

File: criteria/common/test/org/immutables/criteria/typemodel/WriteTemplate.java
Patch:
@@ -21,6 +21,7 @@
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
 
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
@@ -54,6 +55,7 @@ void insert() {
 
     // different id should be successful
     repository.insert(generator.get());
+    repository.insertAll(Arrays.asList(generator.get(), generator.get()));
   }
 
   @Test

File: value-processor/src/org/immutables/value/processor/meta/CriteriaModel.java
Patch:
@@ -549,7 +549,7 @@ public String creator() {
       final String second = def instanceof ContainerDef ? ((ContainerDef) def).element.creator : first;
 
       final String withPath = String.format("context.newChild(%s.class, \"%s\", %s)", attribute.containingType.typeDocument().toString(),
-              attribute.name(), second);
+              attribute.originalElement().getSimpleName().toString(), second);
 
       return String.format("%s.create(%s)", first, withPath);
     }

File: mongo/src/org/immutables/mongo/bson4gson/BsonReader.java
Patch:
@@ -78,8 +78,8 @@ public org.bson.BsonReader unwrap() {
     return this.delegate;
   }
 
-  private void advance() {
-    delegate.readBsonType();
+  private BsonType advance() {
+    return delegate.readBsonType();
   }
 
   @Override
@@ -129,7 +129,7 @@ public JsonToken peek() throws IOException {
     case SCOPE_DOCUMENT:
     case TYPE:
       advance();
-      return toGsonToken(delegate.getCurrentBsonType());
+      return peek();
     case NAME:
       return JsonToken.NAME;
     case END_OF_DOCUMENT:

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -35,6 +35,8 @@ private ValueMirrors() {}
 
     boolean prehash() default false;
 
+    boolean lazyhash() default false;
+
     boolean builder() default true;
   }
 

File: value-processor/src/org/immutables/value/processor/meta/ValueType.java
Patch:
@@ -1412,7 +1412,8 @@ public FromSupertypesModel getBuildFromTypes() {
           report(),
           typeAbstract().toString(),
           getSettableAttributes(),
-          accessorMapping);
+          accessorMapping,
+          constitution.protoclass().processing().getTypeUtils());
     }
     return buildFromTypes;
   }

File: criteria/common/src/org/immutables/criteria/matcher/OptionalDoubleMatcher.java
Patch:
@@ -34,7 +34,7 @@ public interface OptionalDoubleMatcher<R> extends OptionalNumberMatcher<R, Doubl
   interface Self extends Template<Self, Void>, Disjunction<Template<Self, Void>> {}
 
   interface Template<R, P> extends OptionalDoubleMatcher<R>, WithMatcher<R, Self>,
-          NotMatcher<R, Self>, Projection<OptionalDouble>, Aggregation.NumberTemplate<OptionalDouble, OptionalDouble, OptionalDouble> {}
+          NotMatcher<R, Self>, Projection<P>, Aggregation.NumberTemplate<OptionalDouble, OptionalDouble, OptionalDouble> {}
 
 
   @SuppressWarnings("unchecked")

File: value-processor/src/org/immutables/value/processor/meta/AccessorAttributesCollector.java
Patch:
@@ -299,7 +299,7 @@ private void processGenerationCandidateMethod(ExecutableElement attributeMethodC
               report(attributeMethodCandidate)
                   .annotationNamed(DefaultMirror.simpleName())
                   .warning(About.INCOMPAT,
-                      "@Value.Default annotation is superflous for default annotation attribute");
+                      "@Value.Default annotation is superfluous for default annotation attribute");
             } else {
               report(attributeMethodCandidate)
                   .annotationNamed(DefaultMirror.simpleName())
@@ -333,7 +333,7 @@ private void processGenerationCandidateMethod(ExecutableElement attributeMethodC
           report(attributeMethodCandidate)
               .annotationNamed(DefaultMirror.simpleName())
               .warning(About.INCOMPAT,
-                  "@Value.Default annotation is superflous for default annotation attribute"
+                  "@Value.Default annotation is superfluous for default annotation attribute"
                       + " when 'defaultAsDefault' style is enabled");
         }
       } else if (derivedAnnotationPresent) {

File: value-fixture/test/org/immutables/fixture/CustomBaseInternedTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.check;
 
 public class CustomBaseInternedTest {

File: value-fixture/test/org/immutables/fixture/SafeInitTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.*;
 
 public class SafeInitTest {

File: value-fixture/test/org/immutables/fixture/annotation/AnnotationTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture.annotation;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.*;
 
 @An(13)

File: value-fixture/test/org/immutables/fixture/annotation/PassAnnotationTest.java
Patch:
@@ -21,7 +21,7 @@
 import nonimmutables.B1;
 import nonimmutables.C1;
 import nonimmutables.ImmutablePassAnnsTargeting;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.check;
 
 public class PassAnnotationTest {

File: value-fixture/test/org/immutables/fixture/builder/AccessBuilderFieldsTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.util.EnumMap;
 import java.util.EnumSet;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 public class AccessBuilderFieldsTest {
   @Test

File: value-fixture/test/org/immutables/fixture/builder/AttributeBuilderTest.java
Patch:
@@ -25,7 +25,7 @@
 import org.immutables.fixture.builder.functional.AttributeBuilderValueI;
 import org.immutables.fixture.builder.functional.BuilderFunction;
 import org.immutables.fixture.builder.functional.CopyFunction;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("unused")
 public class AttributeBuilderTest {

File: value-fixture/test/org/immutables/fixture/couse/NotYetGeneratedTypesTest.java
Patch:
@@ -19,7 +19,7 @@
 import org.immutables.fixture.couse.ImmutableEnumUser;
 import org.immutables.fixture.couse.ImmutableHasEnum;
 import org.immutables.fixture.couse.sub.ImmutableHasEnumOtherPackage;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 public class NotYetGeneratedTypesTest {
   @Test

File: value-fixture/test/org/immutables/fixture/custann/CustomCollectionTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import static org.immutables.check.Checkers.check;
 import java.util.Arrays;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 public class CustomCollectionTest {
   @Test

File: value-fixture/test/org/immutables/fixture/deep/DeepImmutablesDetectionTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import com.google.common.collect.ImmutableList;
 import org.immutables.fixture.deep.Canvas.Line;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import java.util.ArrayList;
 import java.util.Collections;
 import static org.immutables.check.Checkers.check;

File: value-fixture/test/org/immutables/fixture/encoding/EncodingTest.java
Patch:
@@ -22,7 +22,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import java.util.Optional;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.check;
 
 public class EncodingTest {

File: value-fixture/test/org/immutables/fixture/jackson/BugsTest.java
Patch:
@@ -19,7 +19,7 @@
 import com.fasterxml.jackson.datatype.guava.GuavaModule;
 import com.fasterxml.jackson.databind.PropertyNamingStrategy;
 import com.fasterxml.jackson.databind.ObjectMapper;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 public class BugsTest {
   private static String SAMPLE_JSON = "{\"organizationId\": 172}";

File: value-fixture/test/org/immutables/fixture/jackson/BuilderDeserializationTest.java
Patch:
@@ -9,7 +9,7 @@
 import com.fasterxml.jackson.databind.annotation.JsonSerialize;
 import com.fasterxml.jackson.databind.util.StdConverter;
 import org.immutables.value.Value;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 public class BuilderDeserializationTest {
   @Value.Immutable

File: value-fixture/test/org/immutables/fixture/jackson/ByIdProperty.java
Patch:
@@ -25,7 +25,7 @@
 import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
 import com.fasterxml.jackson.databind.annotation.JsonSerialize;
 import org.immutables.value.Value;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.check;
 
 // regression test for rarely used functionality

File: value-fixture/test/org/immutables/fixture/jackson/DefaultTypingTest.java
Patch:
@@ -18,7 +18,7 @@
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.datatype.guava.GuavaModule;
 import java.io.IOException;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.check;
 
 public class DefaultTypingTest {

File: value-fixture/test/org/immutables/fixture/jackson/FieldConflictTest.java
Patch:
@@ -28,7 +28,7 @@
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 import org.immutables.value.Value;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 @Value.Style(forceJacksonIgnoreFields = true)
 public final class FieldConflictTest {

File: value-fixture/test/org/immutables/fixture/jackson/JacksonGenericsTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import static org.immutables.check.Checkers.check;
 import com.fasterxml.jackson.databind.ObjectMapper;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 public class JacksonGenericsTest {
   static class Abc {

File: value-fixture/test/org/immutables/fixture/jackson/ObjectMappedTest.java
Patch:
@@ -21,7 +21,7 @@
 import com.fasterxml.jackson.datatype.guava.GuavaModule;
 import java.io.IOException;
 import java.util.List;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.check;
 
 public class ObjectMappedTest {

File: value-fixture/test/org/immutables/fixture/jackson/PolymorphicTest.java
Patch:
@@ -20,7 +20,7 @@
 import com.fasterxml.jackson.databind.ObjectMapper;
 import java.io.IOException;
 import org.immutables.fixture.jackson.PolymorphicMappings.DatasetIdLocator;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 public class PolymorphicTest {
   ObjectMapper om = new ObjectMapper();

File: value-fixture/test/org/immutables/fixture/jdkonly/DefaultTest.java
Patch:
@@ -16,7 +16,7 @@
 package org.immutables.fixture.jdkonly;
 
 import com.google.common.collect.ImmutableSortedSet;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.check;
 
 public class DefaultTest {

File: value-fixture/test/org/immutables/fixture/jdkonly/JdkOptionalTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.OptionalDouble;
 import java.util.OptionalInt;
 import java.util.Optional;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.check;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;

File: value-fixture/test/org/immutables/fixture/marshal/MarshallingTest.java
Patch:
@@ -32,7 +32,7 @@
 import org.immutables.fixture.nested.ImmutableCadabra;
 import org.immutables.fixture.nested.NonGrouped;
 import org.immutables.fixture.subpack.SillySubstructure;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import java.util.List;
 import static org.immutables.check.Checkers.check;
 

File: value-fixture/test/org/immutables/fixture/modifiable/BeanFriendlyTest.java
Patch:
@@ -21,7 +21,7 @@
 import com.google.common.collect.ImmutableSet;
 import java.beans.Introspector;
 import java.beans.PropertyDescriptor;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.check;
 
 public class BeanFriendlyTest {

File: value-fixture/test/org/immutables/fixture/modifiable/ClearBuilderTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture.modifiable;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.*;
 
 public class ClearBuilderTest {

File: value-fixture/test/org/immutables/fixture/modifiable/CreateFromDetectTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture.modifiable;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.check;
 
 public class CreateFromDetectTest {

File: value-fixture/test/org/immutables/fixture/modifiable/ModifiablesTest.java
Patch:
@@ -19,7 +19,7 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableMultimap;
 import org.immutables.fixture.modifiable.FromTypesModifiables.FromType;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.hamcrest.core.IsEqual.equalTo;
 import static org.immutables.check.Checkers.check;
 

File: value-fixture/test/org/immutables/fixture/nested/BaseFromTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture.nested;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.*;
 
 public class BaseFromTest {

File: value-fixture/test/org/immutables/fixture/nested/NestedValuesTest.java
Patch:
@@ -23,7 +23,7 @@
 import org.immutables.fixture.nested.ImmutableGroupedClasses.NestedOne;
 import org.immutables.fixture.nested.ImmutableInnerNested.Inner;
 import org.immutables.fixture.nested.ImmutableInnerNested.Nested;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.*;
 
 public class NestedValuesTest {

File: value-fixture/test/org/immutables/fixture/nullable/CustomNullableAnnotationTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import static org.immutables.check.Checkers.check;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 public class CustomNullableAnnotationTest {
 

File: value-fixture/test/org/immutables/fixture/serial/SerialTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.lang.reflect.Field;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.*;
 
 public class SerialTest {

File: value-fixture/test/org/immutables/fixture/style/StyleTest.java
Patch:
@@ -18,7 +18,7 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.List;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.check;
 
 public class StyleTest {

File: value-fixture/test/org/immutables/fixture/style/SupertypeTest.java
Patch:
@@ -18,7 +18,7 @@
 import static org.immutables.check.Checkers.check;
 import com.google.common.collect.ImmutableList;
 import java.util.List;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 public class SupertypeTest {
   @Test

File: value-fixture/test/org/immutables/fixture/style/ValidationTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture.style;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.check;
 
 public class ValidationTest {

File: value-fixture/test/org/immutables/metainf/fixture/ServiceTest.java
Patch:
@@ -22,7 +22,7 @@
 import java.io.Serializable;
 import java.util.ServiceLoader;
 import java.util.TreeSet;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import static org.immutables.check.Checkers.*;
 
 public class ServiceTest {

File: criteria/common/src/org/immutables/criteria/matcher/OptionalNumberMatcher.java
Patch:
@@ -32,10 +32,10 @@ public interface OptionalNumberMatcher<R, V extends Number & Comparable<? super
   /**
    * Self-type for this matcher
    */
-  interface Self<V extends Number & Comparable<? super V>> extends Template<Self<V>, V>, Disjunction<Template<Self<V>, V>> {}
+  interface Self<V extends Number & Comparable<? super V>> extends Template<Self<V>, V, Void>, Disjunction<Template<Self<V>, V, Void>> {}
 
-  interface Template<R, V extends Number & Comparable<? super V>> extends OptionalNumberMatcher<R, V>, WithMatcher<R, Self<V>>,
-          NotMatcher<R, Self<V>>, Projection<Optional<V>>, Aggregation.NumberTemplate<Optional<V>, OptionalDouble, OptionalDouble> {}
+  interface Template<R, V extends Number & Comparable<? super V>, P> extends OptionalNumberMatcher<R, V>, WithMatcher<R, Self<V>>,
+          NotMatcher<R, Self<V>>, Projection<P>, Aggregation.NumberTemplate<Optional<V>, OptionalDouble, OptionalDouble> {}
 
   /**
    * Similar to main {@link OptionalNumberMatcher.Template} but with {@code @Nullable} projections and aggregations

File: criteria/common/src/org/immutables/criteria/matcher/OptionalStringMatcher.java
Patch:
@@ -24,9 +24,9 @@
  */
 public interface OptionalStringMatcher<R> extends StringMatcher<R>, PresentAbsentMatcher<R> {
 
-  interface Self extends Template<Self>, Disjunction<OptionalStringMatcher<Self>> {}
+  interface Self extends Template<Self, Void>, Disjunction<OptionalStringMatcher<Self>> {}
 
-  interface Template<R> extends OptionalStringMatcher<R>, WithMatcher<R, Self>, NotMatcher<R, Self>, Projection<Optional<String>>, Aggregation.ComparableTemplate<Optional<String>> {}
+  interface Template<R, P> extends OptionalStringMatcher<R>, WithMatcher<R, Self>, NotMatcher<R, Self>, Projection<P>, Aggregation.ComparableTemplate<Optional<String>> {}
 
   /**
    * Similar to main {@link OptionalStringMatcher.Template} but with {@code @Nullable} projections and aggregations

File: criteria/common/test/org/immutables/criteria/self/Node.java
Patch:
@@ -30,4 +30,5 @@
 interface Node {
   Optional<Node> parent();
   List<Node> children();
+  String value();
 }

File: criteria/common/test/org/immutables/criteria/matcher/ReturnTypeTest.java
Patch:
@@ -25,7 +25,7 @@
 
 import static org.immutables.check.Checkers.check;
 
-public class ReflectionAggregationTypeTest {
+public class ReturnTypeTest {
 
   private final PersonCriteria person = PersonCriteria.person;
 

File: criteria/common/test/org/immutables/criteria/matcher/ReflectionAggregationTypeTest.java
Patch:
@@ -41,6 +41,9 @@ public void localDate() {
   public void integer() {
     check(Matchers.toExpression(person.age.min()).returnType()).is(Integer.class);
     check(Matchers.toExpression(person.age.max()).returnType()).is(Integer.class);
+    check(Matchers.toExpression(person.age.avg()).returnType()).is(Double.class);
+    check(Matchers.toExpression(person.age.sum()).returnType()).is(Long.class);
+    check(Matchers.toExpression(person.age.count()).returnType()).is(Long.class);
     check(Matchers.toExpression(person.age).returnType()).is(int.class);
   }
 

File: criteria/common/src/org/immutables/criteria/repository/Fetcher.java
Patch:
@@ -16,8 +16,6 @@
 
 package org.immutables.criteria.repository;
 
-public interface Fetcher<R> {
-
-  R fetch();
+public interface Fetcher<T> {
 
 }

File: criteria/common/src/org/immutables/criteria/repository/async/AsyncMapper2.java
Patch:
@@ -30,6 +30,6 @@ public class AsyncMapper2<T1, T2> {
   }
 
   public <R> AsyncFetcher<R> map(MapperFunction2<T1, T2, R> mapFn) {
-    return new AsyncFetcher<R>(delegate.map(mapFn));
+    return AsyncFetcherDelegate.fromReactive(delegate.map(mapFn));
   }
 }

File: criteria/common/src/org/immutables/criteria/repository/async/AsyncMapper3.java
Patch:
@@ -30,6 +30,6 @@ public class AsyncMapper3<T1, T2, T3> {
   }
 
   public <R> AsyncFetcher<R> map(MapperFunction3<T1, T2, T3, R> mapFn) {
-    return new AsyncFetcher<R>(delegate.map(mapFn));
+    return AsyncFetcherDelegate.fromReactive(delegate.map(mapFn));
   }
 }

File: criteria/common/src/org/immutables/criteria/repository/async/AsyncMapper4.java
Patch:
@@ -30,6 +30,6 @@ public class AsyncMapper4<T1, T2, T3, T4> {
   }
 
   public <R> AsyncFetcher<R> map(MapperFunction4<T1, T2, T3, T4, R> mapFn) {
-    return new AsyncFetcher<R>(delegate.map(mapFn));
+    return AsyncFetcherDelegate.fromReactive(delegate.map(mapFn));
   }
 }

File: criteria/common/src/org/immutables/criteria/repository/async/AsyncMapper5.java
Patch:
@@ -30,6 +30,6 @@ public class AsyncMapper5<T1, T2, T3, T4, T5> {
   }
 
   public <R> AsyncFetcher<R> map(MapperFunction5<T1, T2, T3, T4, T5, R> mapFn) {
-    return new AsyncFetcher<R>(delegate.map(mapFn));
+    return AsyncFetcherDelegate.fromReactive(delegate.map(mapFn));
   }
 }

File: criteria/common/src/org/immutables/criteria/repository/reactive/ReactiveMapper2.java
Patch:
@@ -35,6 +35,6 @@ public ReactiveMapper2(Query query, Backend.Session session) {
   }
 
   public <R> ReactiveFetcher<R> map(MapperFunction2<T1, T2, R> mapFn) {
-    return new ReactiveFetcher<ProjectedTuple>(query, session).map(Mappers.fromTuple(mapFn));
+    return ReactiveFetcher.<ProjectedTuple>of(query, session).map(Mappers.fromTuple(mapFn));
   }
 }

File: criteria/common/src/org/immutables/criteria/repository/reactive/ReactiveMapper3.java
Patch:
@@ -35,7 +35,7 @@ public ReactiveMapper3(Query query, Backend.Session session) {
   }
 
   public <R> ReactiveFetcher<R> map(MapperFunction3<T1, T2, T3, R> mapFn) {
-    return new ReactiveFetcher<ProjectedTuple>(query, session).map(Mappers.fromTuple(mapFn));
+    return ReactiveFetcher.<ProjectedTuple>of(query, session).map(Mappers.fromTuple(mapFn));
   }
 
 }

File: criteria/common/src/org/immutables/criteria/repository/reactive/ReactiveMapper4.java
Patch:
@@ -35,7 +35,7 @@ public ReactiveMapper4(Query query, Backend.Session session) {
   }
 
   public <R> ReactiveFetcher<R> map(MapperFunction4<T1, T2, T3, T4, R> mapFn) {
-    return new ReactiveFetcher<ProjectedTuple>(query, session).map(Mappers.fromTuple(mapFn));
+    return ReactiveFetcher.<ProjectedTuple>of(query, session).map(Mappers.fromTuple(mapFn));
   }
   
 }

File: criteria/common/src/org/immutables/criteria/repository/reactive/ReactiveMapper5.java
Patch:
@@ -35,7 +35,7 @@ public ReactiveMapper5(Query query, Backend.Session session) {
   }
 
   public <R> ReactiveFetcher<R> map(MapperFunction5<T1, T2, T3, T4, T5, R> mapFn) {
-    return new ReactiveFetcher<ProjectedTuple>(query, session).map(Mappers.fromTuple(mapFn));
+    return ReactiveFetcher.<ProjectedTuple>of(query, session).map(Mappers.fromTuple(mapFn));
   }
   
 }

File: criteria/common/src/org/immutables/criteria/repository/sync/SyncMapper2.java
Patch:
@@ -30,6 +30,6 @@ public class SyncMapper2<T1, T2> {
   }
 
   public <R> SyncFetcher<R> map(MapperFunction2<T1, T2, R> mapFn) {
-    return new SyncFetcher<>(delegate.map(mapFn));
+    return SyncFetcherDelegate.fromReactive(delegate.map(mapFn));
   }
 }

File: criteria/common/src/org/immutables/criteria/repository/sync/SyncMapper3.java
Patch:
@@ -30,6 +30,6 @@ public class SyncMapper3<T1, T2, T3> {
   }
 
   public <R> SyncFetcher<R> map(MapperFunction3<T1, T2, T3, R> mapFn) {
-    return new SyncFetcher<>(delegate.map(mapFn));
+    return SyncFetcherDelegate.fromReactive(delegate.map(mapFn));
   }
 }

File: criteria/common/src/org/immutables/criteria/repository/sync/SyncMapper4.java
Patch:
@@ -30,6 +30,6 @@ public class SyncMapper4<T1, T2, T3, T4> {
   }
 
   public <R> SyncFetcher<R> map(MapperFunction4<T1, T2, T3, T4, R> mapFn) {
-    return new SyncFetcher<>(delegate.map(mapFn));
+    return SyncFetcherDelegate.fromReactive(delegate.map(mapFn));
   }
 }

File: criteria/common/src/org/immutables/criteria/repository/sync/SyncMapper5.java
Patch:
@@ -30,6 +30,6 @@ public class SyncMapper5<T1, T2, T3, T4, T5> {
   }
 
   public <R> SyncFetcher<R> map(MapperFunction5<T1, T2, T3, T4, T5, R> mapFn) {
-    return new SyncFetcher<>(delegate.map(mapFn));
+    return SyncFetcherDelegate.fromReactive(delegate.map(mapFn));
   }
 }

File: criteria/rxjava/src/org/immutables/criteria/repository/rxjava/RxJavaMapper2.java
Patch:
@@ -30,6 +30,6 @@ public class RxJavaMapper2<T1, T2> {
   }
 
   public <R> RxJavaFetcher<R> map(MapperFunction2<T1, T2, R> mapFn) {
-    return new RxJavaFetcher<>(delegate.map(mapFn));
+    return RxJavaFetcherDelegate.fromReactive(delegate.map(mapFn));
   }
 }

File: criteria/rxjava/src/org/immutables/criteria/repository/rxjava/RxJavaMapper3.java
Patch:
@@ -30,6 +30,6 @@ public class RxJavaMapper3<T1, T2, T3> {
   }
 
   public <R> RxJavaFetcher<R> map(MapperFunction3<T1, T2, T3, R> mapFn) {
-    return new RxJavaFetcher<>(delegate.map(mapFn));
+    return RxJavaFetcherDelegate.fromReactive(delegate.map(mapFn));
   }
 }

File: criteria/rxjava/src/org/immutables/criteria/repository/rxjava/RxJavaMapper4.java
Patch:
@@ -30,6 +30,6 @@ public class RxJavaMapper4<T1, T2, T3, T4> {
   }
 
   public <R> RxJavaFetcher<R> map(MapperFunction4<T1, T2, T3, T4, R> mapFn) {
-    return new RxJavaFetcher<>(delegate.map(mapFn));
+    return RxJavaFetcherDelegate.fromReactive(delegate.map(mapFn));
   }
 }

File: criteria/rxjava/src/org/immutables/criteria/repository/rxjava/RxJavaMapper5.java
Patch:
@@ -30,6 +30,6 @@ public class RxJavaMapper5<T1, T2, T3, T4, T5> {
   }
 
   public <R> RxJavaFetcher<R> map(MapperFunction5<T1, T2, T3, T4, T5, R> mapFn) {
-    return new RxJavaFetcher<>(delegate.map(mapFn));
+    return RxJavaFetcherDelegate.fromReactive(delegate.map(mapFn));
   }
 }

File: criteria/common/src/org/immutables/criteria/backend/ContainerNaming.java
Patch:
@@ -41,12 +41,12 @@ public interface ContainerNaming extends NamingStrategy<Class<?>> {
    */
   ContainerNaming FROM_REPOSITORY_ANNOTATION = entityClass -> {
     Objects.requireNonNull(entityClass, "entityClass");
-    final String name = entityClass.getAnnotation(Criteria.Repository.class).name();
-    if (name.isEmpty()) {
+    final Criteria.Repository annotation = entityClass.getAnnotation(Criteria.Repository.class);
+    if (annotation == null || annotation.name().isEmpty()) {
       throw new UnsupportedOperationException(String.format("%s.name annotation is not defined on %s",
               Criteria.Repository.class.getSimpleName(), entityClass.getName()));
     }
-    return name;
+    return annotation.name();
   };
 
   /**

File: criteria/elasticsearch/test/org/immutables/criteria/elasticsearch/ElasticModelTest.java
Patch:
@@ -70,7 +70,7 @@ public static void setupElastic() throws Exception {
                 .put("bool", false)
                 .put("intNumber", 44);
 
-    ops.insertBulk(Arrays.asList(doc1, doc2));
+    ops.insertBulk(Arrays.asList(doc1, doc2)).blockingGet();
   }
 
   @Before

File: criteria/elasticsearch/test/org/immutables/criteria/elasticsearch/ScrollingTest.java
Patch:
@@ -69,7 +69,7 @@ public static void elasticseachInit() throws Exception {
               .put("bool", true)
               .put("intNumber", i);
 
-      ops.insertDocument(doc);
+      ops.insertDocument(doc).blockingGet();
     }
   }
 

File: criteria/common/src/org/immutables/criteria/backend/Backend.java
Patch:
@@ -27,10 +27,10 @@ public interface Backend {
   /**
    * Open a session (or reuse existing one) with a given context
    *
-   * @param type entity type for which to open a session
+   * @param entityType entity entityType for which to open a session
    * @return new session
    */
-  Session open(Class<?> type);
+  Session open(Class<?> entityType);
 
   /**
    * Context specific "connection" to the back-end. Typically creates isolated view on a table,

File: criteria/common/test/org/immutables/criteria/repository/FakeBackend.java
Patch:
@@ -38,8 +38,8 @@ public FakeBackend(Publisher<?> existing) {
   }
 
   @Override
-  public Session open(Class<?> context) {
-    return new Session(context);
+  public Session open(Class<?> entityType) {
+    return new Session(entityType);
   }
 
   private class Session implements Backend.Session {

File: criteria/inmemory/src/org/immutables/criteria/inmemory/InMemoryBackend.java
Patch:
@@ -49,9 +49,9 @@ public InMemoryBackend() {
   }
 
   @Override
-  public Session open(Class<?> type) {
-    final Map<Object, Object> store = classToStore.computeIfAbsent(type, key -> new ConcurrentHashMap<>());
-    return new Session(type, store);
+  public Session open(Class<?> entityType) {
+    final Map<Object, Object> store = classToStore.computeIfAbsent(entityType, key -> new ConcurrentHashMap<>());
+    return new Session(entityType, store);
   }
 
   private static class Session implements Backend.Session {

File: criteria/mongo/src/org/immutables/criteria/mongo/MongoBackend.java
Patch:
@@ -38,9 +38,9 @@ public MongoBackend(MongoSetup setup) {
   }
 
   @Override
-  public Session open(Class<?> context) {
-    Objects.requireNonNull(context, "context");
-    return new MongoSession(resolver.resolve(context), pathNaming);
+  public Session open(Class<?> entityType) {
+    Objects.requireNonNull(entityType, "context");
+    return new MongoSession(resolver.resolve(entityType), pathNaming);
   }
 
 }

File: criteria/common/src/org/immutables/criteria/backend/Backend.java
Patch:
@@ -37,6 +37,9 @@ public interface Backend {
    * collection (mongo) or class.
    */
   interface Session {
+
+    Class<?> entityType();
+
     /**
      * Apply an operation on the back-end. {@code operation} in this context can mean query / update
      * / insert  / index etc.

File: criteria/common/src/org/immutables/criteria/expression/AggregationCall.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * Call using aggregation functions like {@code SUM}, {@code COUNT}, {@code MAX}, {@code AVG} etc.
  */
-class AggregationCall extends SimpleCall {
+public class AggregationCall extends SimpleCall {
 
   private final Type returnType;
 

File: criteria/mongo/src/org/immutables/criteria/mongo/MongoSession.java
Patch:
@@ -32,6 +32,7 @@
 import org.immutables.criteria.backend.ProjectedTuple;
 import org.immutables.criteria.backend.StandardOperations;
 import org.immutables.criteria.backend.WriteResult;
+import org.immutables.criteria.expression.AggregationCall;
 import org.immutables.criteria.expression.Collation;
 import org.immutables.criteria.expression.ExpressionConverter;
 import org.immutables.criteria.expression.Path;
@@ -79,7 +80,7 @@ public <X> Publisher<X> execute(Backend.Operation operation) {
   private <T> Publisher<T> query(StandardOperations.Select<T> select) {
     final Query query = select.query();
 
-    final boolean hasAggregations =  !query.groupBy().isEmpty();
+    final boolean hasAggregations =  !query.groupBy().isEmpty() || query.projections().stream().anyMatch(p -> p instanceof AggregationCall);
     final boolean hasProjections = !query.projections().isEmpty();
     ExpressionNaming expressionNaming = hasAggregations ? ExpressionNaming.of(UniqueCachedNaming.of(query.projections())) : expression -> pathNaming.name((Path) expression);
 

File: criteria/common/src/org/immutables/criteria/Criteria.java
Patch:
@@ -17,8 +17,8 @@
 package org.immutables.criteria;
 
 import org.immutables.criteria.repository.Facet;
-import org.immutables.criteria.repository.reactive.ReactiveReadable;
-import org.immutables.criteria.repository.reactive.ReactiveWritable;
+import org.immutables.criteria.repository.sync.SyncReadable;
+import org.immutables.criteria.repository.sync.SyncWritable;
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
@@ -72,7 +72,7 @@
      * Allows defining repository properties like readable / writable / watchable etc.
      * @return list of facets the repository should support
      */
-    Class<? extends Facet>[] facets() default {ReactiveReadable.class, ReactiveWritable.class};
+    Class<? extends Facet>[] facets() default {SyncReadable.class, SyncWritable.class};
   }
 
 

File: criteria/common/test/org/immutables/criteria/personmodel/Person.java
Patch:
@@ -22,6 +22,8 @@
 import org.immutables.criteria.repository.reactive.ReactiveReadable;
 import org.immutables.criteria.repository.reactive.ReactiveWatchable;
 import org.immutables.criteria.repository.reactive.ReactiveWritable;
+import org.immutables.criteria.repository.sync.SyncReadable;
+import org.immutables.criteria.repository.sync.SyncWritable;
 import org.immutables.value.Value;
 
 import java.io.Serializable;
@@ -37,7 +39,7 @@
  */
 @Value.Immutable
 @Criteria
-@Criteria.Repository(facets = {ReactiveReadable.class, ReactiveWritable.class, ReactiveWatchable.class})
+@Criteria.Repository(facets = {SyncReadable.class, SyncWritable.class, ReactiveWatchable.class})
 @JsonSerialize(as = ImmutablePerson.class)
 @JsonDeserialize(as = ImmutablePerson.class)
 public interface Person extends Serializable // serializable needed for Geode temporarily

File: criteria/mongo/test/org/immutables/criteria/mongo/MongoPersonTest.java
Patch:
@@ -82,7 +82,7 @@ public void idAttribute() {
     Checkers.check(docs.get(0).get("age")).is(new BsonInt32(22));
 
     // query using repository
-    final List<Person> persons= Flowable.fromPublisher(repository.findAll().fetch()).toList().blockingGet();
+    final List<Person> persons= repository.findAll().fetch();
     Checkers.check(persons).hasSize(1);
     Checkers.check(persons.get(0).id()).is("id123");
   }

File: criteria/common/src/org/immutables/criteria/matcher/BooleanMatcher.java
Patch:
@@ -43,7 +43,7 @@ default R is(boolean value) {
    */
   interface Self extends Template<Self> {}
 
-  interface Template<R> extends BooleanMatcher<R>, WithMatcher<R, Self>, NotMatcher<R, Self>, Projection<Boolean>, Aggregation.ObjectAggregation  {}
+  interface Template<R> extends BooleanMatcher<R>, WithMatcher<R, Self>, NotMatcher<R, Self>, Projection<Boolean>, Aggregation.Count {}
 
   @SuppressWarnings("unchecked")
   static <R> CriteriaCreator<R> creator() {

File: criteria/common/src/org/immutables/criteria/matcher/ObjectMatcher.java
Patch:
@@ -75,7 +75,9 @@ default R notIn(Iterable<? extends V> values) {
    */
   interface Self<V> extends Template<Self<V>, V>, Disjunction<Template<Self<V>, V>> {}
 
-  interface Template<R, V> extends ObjectMatcher<R, V>, WithMatcher<R, Self<V>>, NotMatcher<R, Self<V>>, Projection<V>, Aggregation.ObjectAggregation {}
+  interface Template<R, V> extends ObjectMatcher<R, V>, WithMatcher<R, Self<V>>, NotMatcher<R, Self<V>>, Projection<V>, AggregationTemplate<V> {}
+
+  interface AggregationTemplate<V> extends Aggregation.Count {}
 
   @SuppressWarnings("unchecked")
   static <R> CriteriaCreator<R> creator() {

File: criteria/common/src/org/immutables/criteria/matcher/OptionalBooleanMatcher.java
Patch:
@@ -27,7 +27,7 @@ public interface OptionalBooleanMatcher<R> extends BooleanMatcher<R>, PresentAbs
 
   interface Self extends Template<Self> {}
 
-  interface Template<R> extends OptionalBooleanMatcher<R>, WithMatcher<R, Self>, NotMatcher<R, Self>, Projection<Optional<Boolean>> {}
+  interface Template<R> extends OptionalBooleanMatcher<R>, WithMatcher<R, Self>, NotMatcher<R, Self>, Projection<Optional<Boolean>>, Aggregation.Count {}
 
   @SuppressWarnings("unchecked")
   static <R> CriteriaCreator<R> creator() {

File: criteria/common/src/org/immutables/criteria/matcher/OptionalComparableMatcher.java
Patch:
@@ -33,7 +33,9 @@ public interface OptionalComparableMatcher<R, V extends Comparable<? super V>> e
    */
   interface Self<V extends Comparable<? super V>> extends Template<Self<V>, V>, Disjunction<Template<Self<V>, V>> {}
 
-  interface Template<R, V extends Comparable<? super V>> extends OptionalComparableMatcher<R, V>, WithMatcher<R, Self<V>>, NotMatcher<R, Self<V>>, Projection<Optional<V>>, Aggregation.OptionalComparableAggregation<V> {}
+  interface Template<R, V extends Comparable<? super V>> extends OptionalComparableMatcher<R, V>, WithMatcher<R, Self<V>>, NotMatcher<R, Self<V>>, Projection<Optional<V>>, AggregationTemplate<V> {}
+
+  interface AggregationTemplate<V> extends Aggregation.Count, Aggregation.Max<Optional<V>>, Aggregation.Min<Optional<V>> {}
 
   @SuppressWarnings("unchecked")
   static <R> CriteriaCreator<R> creator() {

File: criteria/common/src/org/immutables/criteria/matcher/OptionalMatcher.java
Patch:
@@ -36,7 +36,9 @@ default S value() {
    */
   interface Self<S, V> extends Template<Self<S, V>, S, V>, Disjunction<Self<S, V>> {}
 
-  interface Template<R, S, V> extends OptionalMatcher<R, S, V>, Projection<Optional<V>>, Aggregation.ObjectAggregation {}
+  interface Template<R, S, V> extends OptionalMatcher<R, S, V>, Projection<Optional<V>>, AggregationTemplate<V> {}
+
+  interface AggregationTemplate<V> extends Aggregation.Count {}
 
   @SuppressWarnings("unchecked")
   static <R> CriteriaCreator<R> creator() {

File: criteria/common/src/org/immutables/criteria/matcher/OptionalStringMatcher.java
Patch:
@@ -16,7 +16,6 @@
 
 package org.immutables.criteria.matcher;
 
-import javax.annotation.Nullable;
 import java.util.Optional;
 
 /**
@@ -27,7 +26,9 @@ public interface OptionalStringMatcher<R> extends StringMatcher<R>, PresentAbsen
 
   interface Self extends Template<Self>, Disjunction<OptionalStringMatcher<Self>> {}
 
-  interface Template<R> extends OptionalStringMatcher<R>, WithMatcher<R, Self>, NotMatcher<R, Self>, Projection<Optional<String>>, Aggregation.OptionalComparableAggregation<String> {}
+  interface Template<R> extends OptionalStringMatcher<R>, WithMatcher<R, Self>, NotMatcher<R, Self>, Projection<Optional<String>>, AggregationTemplate {}
+
+  interface AggregationTemplate extends Aggregation.Count, Aggregation.Max<Optional<String>>, Aggregation.Min<Optional<String>> {}
 
   @SuppressWarnings("unchecked")
   static <R> CriteriaCreator<R> creator() {

File: criteria/common/src/org/immutables/criteria/matcher/StringMatcher.java
Patch:
@@ -87,7 +87,9 @@ default R hasLength(int length) {
    */
   interface Self extends Template<Self>, Disjunction<StringMatcher<Self>> {}
 
-  interface Template<R> extends StringMatcher<R>, WithMatcher<R, Self>, NotMatcher<R, Self>, Projection<String>, Aggregation.ComparableAggregation<String> {}
+  interface Template<R> extends StringMatcher<R>, WithMatcher<R, Self>, NotMatcher<R, Self>, Projection<String>, AggregationTemplate {}
+
+  interface AggregationTemplate extends Aggregation.Count, Aggregation.Min<String>, Aggregation.Max<String> {}
 
   @SuppressWarnings("unchecked")
   static <R> CriteriaCreator<R> creator() {

File: criteria/common/test/org/immutables/criteria/matcher/AggregationReturnTypeTest.java
Patch:
@@ -33,7 +33,7 @@ public class AggregationReturnTypeTest {
 
   @Test
   public void basic() {
-    class Dummy implements Aggregation.Count<Long>, Aggregation.Avg<OptionalDouble>, Aggregation.Min<Optional<Double>>, Aggregation.Sum<Integer> {}
+    class Dummy implements Aggregation.Count, Aggregation.Avg<OptionalDouble>, Aggregation.Min<Optional<Double>>, Aggregation.Sum<Integer> {}
 
     check(Matchers.aggregationType(Dummy.class, Aggregation.Count.class, "count")).is(Long.class);
     check(Matchers.aggregationType(Dummy.class, Aggregation.Avg.class, "avg")).is(OptionalDouble.class);

File: criteria/common/src/org/immutables/criteria/expression/Expressions.java
Patch:
@@ -50,8 +50,8 @@ public static Expression or(Iterable<? extends Expression> expressions) {
     return reduce(Operators.OR, expressions);
   }
 
-  public static Type returnType(Path path) {
-    return path.returnType();
+  public static Expression aggregation(AggregationOperators operator, Type returnType, Expression expression) {
+    return new AggregationCall(ImmutableList.of(expression), operator, returnType);
   }
 
   public static Query root(Class<?> entityClass) {

File: criteria/elasticsearch/src/org/immutables/criteria/elasticsearch/ToTupleConverter.java
Patch:
@@ -71,7 +71,7 @@ private ProjectedField(Expression expr, ObjectMapper mapper) {
       this.path =  path;
       this.mapper = mapper;
       this.pathAsString = path.toStringPath();
-      this.javaType = mapper.getTypeFactory().constructType(Expressions.returnType(path));
+      this.javaType = mapper.getTypeFactory().constructType(path.returnType());
     }
 
     Object convert(JsonNode json) {

File: criteria/inmemory/src/org/immutables/criteria/inmemory/TupleExtractor.java
Patch:
@@ -58,7 +58,7 @@ ProjectedTuple extract(Object instance) {
    * Expected result might be optional
    */
   private Object maybeWrapOptional(Object value, Path path) {
-    Type type = Expressions.returnType(path);
+    Type type = path.returnType();
     final Class<?> klass;
     if (type instanceof ParameterizedType) {
       klass = (Class<?>) ((ParameterizedType) type).getRawType();

File: criteria/mongo/src/org/immutables/criteria/mongo/TupleCodecProvider.java
Patch:
@@ -72,7 +72,7 @@ private static class FieldDecoder {
 
     private FieldDecoder(Path path, String name, CodecRegistry registry) {
       this.mongoField = name;
-      this.type = Expressions.returnType(path);
+      this.type = path.returnType();
       this.decoder = SimpleRegistry.of(registry).get(TypeToken.of(type));
     }
 

File: value-annotations/src/org/immutables/value/Value.java
Patch:
@@ -759,8 +759,8 @@
 
     /**
      * This funny-named named attribute, when enabled makes default accessor methods defined in
-     * interfaces/traits to behave as if they annotated as {@literal @}{@link Value.Default}.
-     * This is not a default behaviour to preserve compatibility and also to have an choice to not
+     * interfaces/traits behave as if they annotated as {@literal @}{@link Value.Default}.
+     * This is not a default behaviour to preserve compatibility and also to have a choice to not
      * opt-in for this new functionality when not needed.
      * @return if consider default method accessors as {@literal @}{@code Value.Default}
      */

File: criteria/common/src/org/immutables/criteria/repository/MapperFunction2.java
Patch:
@@ -16,7 +16,7 @@
 
 package org.immutables.criteria.repository;
 
-public interface MapperFunction2<R, T1, T2> {
+public interface MapperFunction2<T1, T2, R> {
 
   R apply(T1 arg1, T2 arg2);
 

File: criteria/common/src/org/immutables/criteria/repository/MapperFunction3.java
Patch:
@@ -16,6 +16,6 @@
 
 package org.immutables.criteria.repository;
 
-public interface MapperFunction3<R, T1, T2, T3> {
+public interface MapperFunction3<T1, T2, T3, R> {
   R apply(T1 arg1, T2 arg2, T3 arg3);
 }

File: criteria/common/src/org/immutables/criteria/repository/MapperFunction4.java
Patch:
@@ -16,6 +16,6 @@
 
 package org.immutables.criteria.repository;
 
-public interface MapperFunction4<R, T1, T2, T3, T4> {
+public interface MapperFunction4<T1, T2, T3, T4, R> {
   R apply(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
 }

File: criteria/common/src/org/immutables/criteria/repository/MapperFunction5.java
Patch:
@@ -16,6 +16,6 @@
 
 package org.immutables.criteria.repository;
 
-public interface MapperFunction5<R, T1, T2, T3, T4, T5> {
+public interface MapperFunction5<T1, T2, T3, T4, T5, R> {
   R apply(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
 }

File: criteria/common/src/org/immutables/criteria/repository/async/AsyncMapper5.java
Patch:
@@ -33,7 +33,7 @@ public class AsyncMapper5<T1, T2, T3, T4, T5> {
     this.session = session;
   }
 
-  public <R> AsyncFetcher<R> map(MapperFunction5<R, T1, T2, T3, T4, T5> mapFn) {
+  public <R> AsyncFetcher<R> map(MapperFunction5<T1, T2, T3, T4, T5, R> mapFn) {
     ReactiveFetcher<R> delegate = new ReactiveFetcher<ProjectedTuple>(query, session).map(Mappers.fromTuple(mapFn));
     return new AsyncFetcher<R>(delegate);
   }

File: criteria/common/src/org/immutables/criteria/repository/reactive/ReactiveMapper2.java
Patch:
@@ -21,8 +21,6 @@
 import org.immutables.criteria.expression.Query;
 import org.immutables.criteria.repository.MapperFunction2;
 import org.immutables.criteria.repository.Mappers;
-import org.immutables.criteria.repository.Publishers;
-import org.reactivestreams.Publisher;
 
 public class ReactiveMapper2<T1, T2> {
 
@@ -34,7 +32,7 @@ public class ReactiveMapper2<T1, T2> {
     this.session = session;
   }
 
-  public <R> ReactiveFetcher<R> map(MapperFunction2<R, T1, T2> mapFn) {
+  public <R> ReactiveFetcher<R> map(MapperFunction2<T1, T2, R> mapFn) {
     return new ReactiveFetcher<ProjectedTuple>(query, session).map(Mappers.fromTuple(mapFn));
   }
 }

File: criteria/common/src/org/immutables/criteria/repository/reactive/ReactiveMapper3.java
Patch:
@@ -21,8 +21,6 @@
 import org.immutables.criteria.expression.Query;
 import org.immutables.criteria.repository.MapperFunction3;
 import org.immutables.criteria.repository.Mappers;
-import org.immutables.criteria.repository.Publishers;
-import org.reactivestreams.Publisher;
 
 public class ReactiveMapper3<T1, T2, T3> {
 
@@ -34,7 +32,7 @@ public class ReactiveMapper3<T1, T2, T3> {
     this.session = session;
   }
 
-  public <R> ReactiveFetcher<R> map(MapperFunction3<R, T1, T2, T3> mapFn) {
+  public <R> ReactiveFetcher<R> map(MapperFunction3<T1, T2, T3, R> mapFn) {
     return new ReactiveFetcher<ProjectedTuple>(query, session).map(Mappers.fromTuple(mapFn));
   }
 

File: criteria/common/src/org/immutables/criteria/repository/reactive/ReactiveMapper4.java
Patch:
@@ -21,8 +21,6 @@
 import org.immutables.criteria.expression.Query;
 import org.immutables.criteria.repository.MapperFunction4;
 import org.immutables.criteria.repository.Mappers;
-import org.immutables.criteria.repository.Publishers;
-import org.reactivestreams.Publisher;
 
 public class ReactiveMapper4<T1, T2, T3, T4> {
 
@@ -34,7 +32,7 @@ public class ReactiveMapper4<T1, T2, T3, T4> {
     this.session = session;
   }
 
-  public <R> ReactiveFetcher<R> map(MapperFunction4<R, T1, T2, T3, T4> mapFn) {
+  public <R> ReactiveFetcher<R> map(MapperFunction4<T1, T2, T3, T4, R> mapFn) {
     return new ReactiveFetcher<ProjectedTuple>(query, session).map(Mappers.fromTuple(mapFn));
   }
   

File: criteria/rxjava/src/org/immutables/criteria/repository/rxjava/RxJavaMapper2.java
Patch:
@@ -33,7 +33,7 @@ public class RxJavaMapper2<T1, T2> {
     this.session = session;
   }
 
-  public <R> RxJavaFetcher<R> map(MapperFunction2<R, T1, T2> mapFn) {
+  public <R> RxJavaFetcher<R> map(MapperFunction2<T1, T2, R> mapFn) {
     ReactiveFetcher<R> delegate = new ReactiveFetcher<ProjectedTuple>(query, session).map(Mappers.fromTuple(mapFn));
     return new RxJavaFetcher<>(delegate);
   }

File: criteria/rxjava/src/org/immutables/criteria/repository/rxjava/RxJavaMapper3.java
Patch:
@@ -19,7 +19,6 @@
 import org.immutables.criteria.backend.Backend;
 import org.immutables.criteria.backend.ProjectedTuple;
 import org.immutables.criteria.expression.Query;
-import org.immutables.criteria.repository.MapperFunction2;
 import org.immutables.criteria.repository.MapperFunction3;
 import org.immutables.criteria.repository.Mappers;
 import org.immutables.criteria.repository.reactive.ReactiveFetcher;
@@ -34,7 +33,7 @@ public class RxJavaMapper3<T1, T2, T3> {
     this.session = session;
   }
 
-  public <R> RxJavaFetcher<R> map(MapperFunction3<R, T1, T2, T3> mapFn) {
+  public <R> RxJavaFetcher<R> map(MapperFunction3<T1, T2, T3, R> mapFn) {
     ReactiveFetcher<R> delegate = new ReactiveFetcher<ProjectedTuple>(query, session).map(Mappers.fromTuple(mapFn));
     return new RxJavaFetcher<>(delegate);
   }

File: criteria/rxjava/src/org/immutables/criteria/repository/rxjava/RxJavaMapper4.java
Patch:
@@ -33,7 +33,7 @@ public class RxJavaMapper4<T1, T2, T3, T4> {
     this.session = session;
   }
 
-  public <R> RxJavaFetcher<R> map(MapperFunction4<R, T1, T2, T3, T4> mapFn) {
+  public <R> RxJavaFetcher<R> map(MapperFunction4<T1, T2, T3, T4, R> mapFn) {
     ReactiveFetcher<R> delegate = new ReactiveFetcher<ProjectedTuple>(query, session).map(Mappers.fromTuple(mapFn));
     return new RxJavaFetcher<>(delegate);
   }

File: criteria/rxjava/src/org/immutables/criteria/repository/rxjava/RxJavaMapper5.java
Patch:
@@ -33,7 +33,7 @@ public class RxJavaMapper5<T1, T2, T3, T4, T5> {
     this.session = session;
   }
 
-  public <R> RxJavaFetcher<R> map(MapperFunction5<R, T1, T2, T3, T4, T5> mapFn) {
+  public <R> RxJavaFetcher<R> map(MapperFunction5<T1, T2, T3, T4, T5, R> mapFn) {
     ReactiveFetcher<R> delegate = new ReactiveFetcher<ProjectedTuple>(query, session).map(Mappers.fromTuple(mapFn));
     return new RxJavaFetcher<>(delegate);
   }

File: criteria/common/src/org/immutables/criteria/matcher/BooleanMatcher.java
Patch:
@@ -43,7 +43,7 @@ default R is(boolean value) {
    */
   interface Self extends Template<Self> {}
 
-  interface Template<R> extends BooleanMatcher<R>, WithMatcher<R, Self>, NotMatcher<R, Self>  {}
+  interface Template<R> extends BooleanMatcher<R>, WithMatcher<R, Self>, NotMatcher<R, Self>, Projection<Boolean>  {}
 
   @SuppressWarnings("unchecked")
   static <R> CriteriaCreator<R> creator() {

File: criteria/common/test/org/immutables/criteria/personmodel/AbstractPersonTest.java
Patch:
@@ -24,7 +24,6 @@
 import org.immutables.criteria.repository.Reader;
 import org.immutables.criteria.repository.reactive.ReactiveReader;
 import org.junit.Assume;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.reactivestreams.Publisher;
 
@@ -34,7 +33,6 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
-import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
@@ -549,7 +547,7 @@ public void projection_basic() {
     check(repository().findAll().select(criteria().age).fetch()).hasContentInAnyOrder(21, 22, 23);
     check(repository().findAll().select(criteria().fullName).fetch()).hasContentInAnyOrder("John", "Mary", "Emma");
     check(repository().findAll().select(criteria().id).fetch()).hasContentInAnyOrder("id1", "id2", "id3");
-
+    check(repository().findAll().select(criteria().dateOfBirth).fetch()).notEmpty();
 
     check(repository().findAll().select(criteria().id, criteria().fullName).map(AbstractMap.SimpleImmutableEntry::new).fetch())
             .hasContentInAnyOrder(new AbstractMap.SimpleImmutableEntry<>("id1", "John"), new AbstractMap.SimpleImmutableEntry<>("id2", "Mary"), new AbstractMap.SimpleImmutableEntry<>("id3", "Emma"));
@@ -566,10 +564,12 @@ public void projection_ofContainers() {
     insert(generator.next().withFullName("Mary").withNickName("a").withInterests("one", "two", "three"));
     insert(generator.next().withFullName("Emma").withNickName("b").withInterests("four"));
 
+    // nickname
     check(repository().findAll().select(criteria().nickName).fetch()).hasContentInAnyOrder(Optional.empty(), Optional.of("a"), Optional.of("b"));
     check(repository().findAll().select(criteria().fullName, criteria().nickName).map(AbstractMap.SimpleImmutableEntry::new).fetch())
             .hasContentInAnyOrder(new AbstractMap.SimpleImmutableEntry<>("John", Optional.empty()), new AbstractMap.SimpleImmutableEntry<>("Mary", Optional.of("a")),
                     new AbstractMap.SimpleImmutableEntry<>("Emma", Optional.of("b")));
+
   }
 
   private void assumeFeature(Feature feature) {

File: criteria/mongo/src/org/immutables/criteria/mongo/MongoSession.java
Patch:
@@ -34,6 +34,7 @@
 import org.immutables.criteria.expression.ExpressionConverter;
 import org.immutables.criteria.expression.Path;
 import org.immutables.criteria.expression.Query;
+import org.immutables.criteria.mongo.codecs.TupleCodecProvider;
 import org.reactivestreams.Publisher;
 
 import java.util.Collections;

File: criteria/mongo/src/org/immutables/criteria/mongo/Mongos.java
Patch:
@@ -30,7 +30,7 @@
 /**
  * Util methods for mongo adapter.
  */
-final class Mongos {
+public final class Mongos {
 
   private Mongos() {}
 
@@ -41,7 +41,7 @@ static ExpressionConverter<Bson> converter() {
     return expression -> expression.accept(new MongoQueryVisitor());
   }
 
-  static String toMongoFieldName(Path path) {
+  public static String toMongoFieldName(Path path) {
     Function<AnnotatedElement, String> toStringFn = a -> {
       Objects.requireNonNull(a, "null element");
       if (a.isAnnotationPresent(Criteria.Id.class)) {

File: criteria/common/test/org/immutables/criteria/personmodel/AbstractPersonTest.java
Patch:
@@ -558,7 +558,6 @@ public void projection_basic() {
   /**
    * Projection of fields which have container-like attributes: {@code Optional<T>}, {@code List<T>} etc.
    */
-  @Ignore
   @Test
   public void projection_ofContainers() {
     assumeFeature(Feature.QUERY_WITH_PROJECTION);
@@ -568,7 +567,9 @@ public void projection_ofContainers() {
     insert(generator.next().withFullName("Emma").withNickName("b").withInterests("four"));
 
     check(repository().findAll().select(criteria().nickName).fetch()).hasContentInAnyOrder(Optional.empty(), Optional.of("a"), Optional.of("b"));
-    check(repository().findAll().select(criteria().nickName, criteria().age).map((a, b) -> a).fetch()).hasContentInAnyOrder(Optional.empty(), Optional.of("a"), Optional.of("b"));
+    check(repository().findAll().select(criteria().fullName, criteria().nickName).map(AbstractMap.SimpleImmutableEntry::new).fetch())
+            .hasContentInAnyOrder(new AbstractMap.SimpleImmutableEntry<>("John", Optional.empty()), new AbstractMap.SimpleImmutableEntry<>("Mary", Optional.of("a")),
+                    new AbstractMap.SimpleImmutableEntry<>("Emma", Optional.of("b")));
   }
 
   private void assumeFeature(Feature feature) {

File: criteria/common/src/org/immutables/criteria/matcher/ComparableMatcher.java
Patch:
@@ -88,7 +88,7 @@ default R between(V lowerInclusive, V upperInclusive) {
    */
   interface Self<V extends Comparable<? super V>> extends Template<Self<V>, V>, Disjunction<Template<Self<V>, V>> {}
 
-  interface Template<R, V extends Comparable<? super V>> extends ComparableMatcher<R, V>, WithMatcher<R, Self<V>>, NotMatcher<R, Self<V>> {}
+  interface Template<R, V extends Comparable<? super V>> extends ComparableMatcher<R, V>, WithMatcher<R, Self<V>>, NotMatcher<R, Self<V>>, Projection<V> {}
 
   @SuppressWarnings("unchecked")
   static <R> CriteriaCreator<R> creator() {

File: criteria/common/src/org/immutables/criteria/matcher/ObjectMatcher.java
Patch:
@@ -75,7 +75,7 @@ default R notIn(Iterable<? extends V> values) {
    */
   interface Self<V> extends Template<Self<V>, V>, Disjunction<Template<Self<V>, V>> {}
 
-  interface Template<R, V> extends ObjectMatcher<R, V>, WithMatcher<R, Self<V>>, NotMatcher<R, Self<V>>{}
+  interface Template<R, V> extends ObjectMatcher<R, V>, WithMatcher<R, Self<V>>, NotMatcher<R, Self<V>>, Projection<V> {}
 
   @SuppressWarnings("unchecked")
   static <R> CriteriaCreator<R> creator() {

File: criteria/common/src/org/immutables/criteria/matcher/OptionalBooleanMatcher.java
Patch:
@@ -16,6 +16,8 @@
 package org.immutables.criteria.matcher;
 
 
+import java.util.Optional;
+
 /**
  * Intersection type between {@link OptionalMatcher} and {@link BooleanMatcher}
  *
@@ -25,7 +27,7 @@ public interface OptionalBooleanMatcher<R> extends BooleanMatcher<R>, PresentAbs
 
   interface Self extends Template<Self> {}
 
-  interface Template<R> extends OptionalBooleanMatcher<R>, WithMatcher<R, Self>, NotMatcher<R, Self>  {}
+  interface Template<R> extends OptionalBooleanMatcher<R>, WithMatcher<R, Self>, NotMatcher<R, Self>, Projection<Optional<Boolean>> {}
 
   @SuppressWarnings("unchecked")
   static <R> CriteriaCreator<R> creator() {

File: criteria/common/src/org/immutables/criteria/matcher/OptionalComparableMatcher.java
Patch:
@@ -16,6 +16,8 @@
 
 package org.immutables.criteria.matcher;
 
+import java.util.Optional;
+
 /**
  * Intersection type between {@link OptionalMatcher} and {@link ComparableMatcher}.
  *
@@ -31,7 +33,7 @@ public interface OptionalComparableMatcher<R, V extends Comparable<? super V>> e
    */
   interface Self<V extends Comparable<? super V>> extends Template<Self<V>, V>, Disjunction<Template<Self<V>, V>> {}
 
-  interface Template<R, V extends Comparable<? super V>> extends OptionalComparableMatcher<R, V>, WithMatcher<R, Self<V>>, NotMatcher<R, Self<V>> {}
+  interface Template<R, V extends Comparable<? super V>> extends OptionalComparableMatcher<R, V>, WithMatcher<R, Self<V>>, NotMatcher<R, Self<V>>, Projection<Optional<V>> {}
 
   @SuppressWarnings("unchecked")
   static <R> CriteriaCreator<R> creator() {

File: criteria/common/src/org/immutables/criteria/matcher/OptionalStringMatcher.java
Patch:
@@ -16,6 +16,8 @@
 
 package org.immutables.criteria.matcher;
 
+import java.util.Optional;
+
 /**
  * Intersection type between {@link OptionalMatcher} and {@link StringMatcher}
  * @param <R> root criteria type
@@ -24,7 +26,7 @@ public interface OptionalStringMatcher<R> extends StringMatcher<R>, PresentAbsen
 
   interface Self extends Template<Self>, Disjunction<OptionalStringMatcher<Self>> {}
 
-  interface Template<R> extends OptionalStringMatcher<R>, WithMatcher<R, Self>, NotMatcher<R, Self>{}
+  interface Template<R> extends OptionalStringMatcher<R>, WithMatcher<R, Self>, NotMatcher<R, Self>, Projection<Optional<String>> {}
 
   @SuppressWarnings("unchecked")
   static <R> CriteriaCreator<R> creator() {

File: criteria/common/src/org/immutables/criteria/matcher/StringMatcher.java
Patch:
@@ -26,7 +26,7 @@
  * String specific predicates like {@code startsWith}, {@code contains} etc.
  * @param <R> root criteria type
  */
-public interface StringMatcher<R> extends ComparableMatcher<R, String>  {
+public interface StringMatcher<R> extends ComparableMatcher<R, String> {
 
   /**
    * Check for empty string (equivalent to {@code string.length() == 0})
@@ -87,7 +87,7 @@ default R hasLength(int length) {
    */
   interface Self extends Template<Self>, Disjunction<StringMatcher<Self>> {}
 
-  interface Template<R> extends StringMatcher<R>, WithMatcher<R, Self>, NotMatcher<R, Self>{}
+  interface Template<R> extends StringMatcher<R>, WithMatcher<R, Self>, NotMatcher<R, Self>, Projection<String> {}
 
   @SuppressWarnings("unchecked")
   static <R> CriteriaCreator<R> creator() {

File: criteria/mongo/test/org/immutables/criteria/mongo/MongoPersonTest.java
Patch:
@@ -67,6 +67,7 @@ public class MongoPersonTest extends AbstractPersonTest {
   @Override
   protected Set<Feature> features() {
     return EnumSet.of(Feature.DELETE, Feature.QUERY, Feature.QUERY_WITH_LIMIT,
+            Feature.QUERY_WITH_PROJECTION,
             Feature.QUERY_WITH_OFFSET, Feature.ORDER_BY, Feature.REGEX,
             Feature.STRING_PREFIX_SUFFIX,
             Feature.ITERABLE_SIZE,

File: criteria/common/src/org/immutables/criteria/repository/AbstractReader.java
Patch:
@@ -33,7 +33,7 @@
  * Template class for Readers. For future API compatibility prefer extend it rather than
  * implement {@link Reader} directly.s
  */
-public abstract class AbstractReader<T, R extends Reader<T, R>> implements Reader<T, R> {
+public abstract class AbstractReader<R extends Reader<R>> implements Reader<R> {
 
   private final Query query;
   private final Backend.Session session;
@@ -48,7 +48,7 @@ protected AbstractReader(Query query, Backend.Session session) {
   /**
    * Perform read operation returning generic {@link Publisher}
    */
-  protected Publisher<T> fetchInternal() {
+  protected <T> Publisher<T> fetchInternal() {
     return session.execute(StandardOperations.Select.of(query));
   }
 

File: criteria/common/src/org/immutables/criteria/repository/Readable.java
Patch:
@@ -23,7 +23,7 @@
  * @param <T> entity type
  * @param <R> self-type of reader
  */
-public interface Readable<T, R extends Reader<T, R>> extends Facet {
+public interface Readable<T, R extends Reader<R>> extends Facet {
 
   R find(Criterion<T> criteria);
 

File: criteria/common/src/org/immutables/criteria/repository/Reader.java
Patch:
@@ -22,10 +22,9 @@
  * Allows chaining operations (like adding {@code offset} / {@code limit}) on some particular query.
  * Subclasses may add other attributes specific to their repository.
  *
- * @param <T> entity type
  * @param <R> reader type (self type)
  */
-public interface Reader<T, R> {
+public interface Reader<R> {
 
   R orderBy(Ordering first, Ordering... rest);
 

File: criteria/common/src/org/immutables/criteria/repository/Repositories.java
Patch:
@@ -30,7 +30,7 @@ private Repositories() {}
   /**
    * Extract current query from the reader
    */
-  public static Query toQuery(Reader<?, ?> reader) {
+  public static Query toQuery(Reader<?> reader) {
     Objects.requireNonNull(reader, "reader");
     Preconditions.checkArgument(reader instanceof AbstractReader,
             "expected %s to be instance of %s", reader.getClass().getName(), AbstractReader.class.getName());

File: criteria/common/src/org/immutables/criteria/repository/async/AsyncReader.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.Objects;
 import java.util.concurrent.CompletionStage;
 
-public class AsyncReader<T> extends AbstractReader<T, AsyncReader<T>> {
+public class AsyncReader<T> extends AbstractReader<AsyncReader<T>> {
 
   private final Backend.Session session;
 

File: criteria/common/src/org/immutables/criteria/repository/reactive/ReactiveReader.java
Patch:
@@ -26,7 +26,7 @@
 /**
  * Reactive implementation of the reader.
  */
-public final class ReactiveReader<T> extends AbstractReader<T, ReactiveReader<T>>  {
+public final class ReactiveReader<T> extends AbstractReader<ReactiveReader<T>>  {
 
   private final Backend.Session session;
 

File: criteria/common/src/org/immutables/criteria/repository/sync/SyncReader.java
Patch:
@@ -27,7 +27,7 @@
  * Synchronous (blocking) reader operations.
  * @param <T> entity type
  */
-public class SyncReader<T> extends AbstractReader<T, SyncReader<T>> {
+public class SyncReader<T> extends AbstractReader<SyncReader<T>> {
 
   private final Backend.Session session;
 

File: criteria/common/test/org/immutables/criteria/personmodel/AbstractPersonTest.java
Patch:
@@ -535,7 +535,7 @@ private void assumeFeature(Feature feature) {
     Assume.assumeTrue(features().contains(feature));
   }
 
-  private <T extends Comparable<T>> void assertOrdered(Function<Person, T> extractor, Reader<Person, ?> reader, Ordering<T> ordering) {
+  private <T extends Comparable<T>> void assertOrdered(Function<Person, T> extractor, Reader<?> reader, Ordering<T> ordering) {
     List<T> parts = fetch(reader).stream().map(extractor).collect(Collectors.toList());
     if (!ordering.isOrdered(parts)) {
       throw new AssertionError(String.format("%s is not ordered. Expected: %s", parts, ordering.sortedCopy(parts)));
@@ -553,15 +553,15 @@ protected void insert(Iterable<? extends Person> persons) {
             .assertComplete();
   }
 
-  protected CriteriaChecker<Person> check(Reader<Person, ?> reader) {
+  protected CriteriaChecker<Person> check(Reader<?> reader) {
     return CriteriaChecker.of(reader);
   }
 
   private CriteriaChecker<Person> check(Criterion<Person> criterion) {
     return check(repository().find(criterion));
   }
 
-  private List<Person> fetch(Reader<Person, ?> reader) {
+  private List<Person> fetch(Reader<?> reader) {
     return Flowable.fromPublisher(((ReactiveReader<Person>) reader).fetch()).toList().blockingGet();
   }
 

File: criteria/common/test/org/immutables/criteria/personmodel/CriteriaChecker.java
Patch:
@@ -20,9 +20,7 @@
 import io.reactivex.Flowable;
 import org.immutables.check.IterableChecker;
 import org.immutables.criteria.expression.Query;
-import org.immutables.criteria.expression.Queryable;
 import org.immutables.criteria.repository.Repositories;
-import org.immutables.criteria.repository.Repository;
 import org.immutables.criteria.repository.reactive.ReactiveReader;
 import org.immutables.criteria.repository.Reader;
 
@@ -97,7 +95,7 @@ private static String toDebugString(Query query) {
     return query.toString();
   }
 
-  public static <T> CriteriaChecker<T> of(Reader<T, ?> reader) {
+  public static <T> CriteriaChecker<T> of(Reader<?> reader) {
     Preconditions.checkArgument(reader instanceof ReactiveReader,
             "%s should implement %s", reader.getClass(), ReactiveReader.class.getName());
 

File: criteria/rxjava/src/org/immutables/criteria/repository/rxjava/RxJavaReader.java
Patch:
@@ -24,7 +24,7 @@
 /**
  * Reader returning {@link Flowable} type
  */
-public class RxJavaReader<T> extends AbstractReader<T, RxJavaReader<T>> {
+public class RxJavaReader<T> extends AbstractReader<RxJavaReader<T>> {
 
   private final Backend.Session session;
 

File: criteria/mongo/test/org/immutables/criteria/mongo/MongoPersonTest.java
Patch:
@@ -30,6 +30,7 @@
 import org.bson.codecs.configuration.CodecRegistry;
 import org.immutables.check.Checkers;
 import org.immutables.criteria.backend.ContainerNaming;
+import org.immutables.criteria.mongo.bson4jackson.BsonModule;
 import org.immutables.criteria.mongo.bson4jackson.IdAnnotationModule;
 import org.immutables.criteria.mongo.bson4jackson.JacksonCodecs;
 import org.immutables.criteria.personmodel.AbstractPersonTest;
@@ -66,7 +67,8 @@ public class MongoPersonTest extends AbstractPersonTest {
   @Before
   public void setUp() throws Exception {
 
-    final ObjectMapper mapper = JacksonCodecs.register(new ObjectMapper())
+    final ObjectMapper mapper = new ObjectMapper()
+            .registerModule(new BsonModule())
             .registerModule(new GuavaModule())
             .registerModule(new Jdk8Module())
             .registerModule(new IdAnnotationModule());

File: criteria/mongo/test/org/immutables/criteria/mongo/bson4jackson/JacksonCodecsTest.java
Patch:
@@ -52,7 +52,7 @@ public class JacksonCodecsTest {
    */
   @Test
   public void regex() {
-    final ObjectMapper mapper = JacksonCodecs.register(new ObjectMapper());
+    final ObjectMapper mapper = new ObjectMapper().registerModule(new BsonModule());
     final CodecRegistry registry = JacksonCodecs.registryFromMapper(mapper);
 
     Consumer<Bson> validate = bson -> {
@@ -74,7 +74,7 @@ public void encodeDecode() throws IOException {
             .putMap("key1", "val1")
             .build();
 
-    final ObjectMapper mapper = JacksonCodecs.register(new ObjectMapper())
+    final ObjectMapper mapper = new ObjectMapper().registerModule(new BsonModule())
             .registerModule(new GuavaModule());
     final CodecRegistry registry = JacksonCodecs.registryFromMapper(mapper);
 

File: criteria/common/src/org/immutables/criteria/matcher/CriteriaContext.java
Patch:
@@ -126,6 +126,7 @@ public CriteriaContext apply(UnaryOperator<Expression> fn) {
     Objects.requireNonNull(fn, "fn");
     final Expression apply = fn.apply(path);
     final DnfExpression newExpression = expression.and(apply);
+    List<CriteriaCreator<?>> creators = ImmutableList.<CriteriaCreator<?>>builder().add(this.creators.get(0)).add(this.creators.get(0)).build();
     return new CriteriaContext(entityClass, newExpression, parent != null ? parent.path : null, creators, parent);
   }
 

File: criteria/common/test/org/immutables/criteria/nested/NestedTest.java
Patch:
@@ -44,10 +44,10 @@ public void nested() {
     assertExpressional(RootCriteria.root.a.value().b.value().c.value().value.is("gem")
             , "call op=EQUAL path=a.b.c.value constant=gem");
 
-    assertExpressional(RootCriteria.root.a.value().b.value().c.value().hidden.value().is("gem")
+    assertExpressional(RootCriteria.root.a.value().b.value().c.value().hidden.is("gem")
             , "call op=EQUAL path=a.b.c.hidden constant=gem");
 
-    assertExpressional(RootCriteria.root.a.value().b.value().c.value().hidden.value().with(s -> s.is("gem"))
+    assertExpressional(RootCriteria.root.a.value().b.value().c.value().hidden.with(s -> s.is("gem"))
             , "call op=EQUAL path=a.b.c.hidden constant=gem");
 
     assertExpressional(RootCriteria.root.a.value().with(a -> a.b.isPresent()),
@@ -66,7 +66,7 @@ public void nested() {
             "call op=EQUAL path=a.b.c.value constant=gem"
     );
 
-    assertExpressional(RootCriteria.root.a.value().with(a -> a.b.value().with(b -> b.c.value().with(c -> c.hidden.value().with(h -> h.is("gem"))))),
+    assertExpressional(RootCriteria.root.a.value().with(a -> a.b.value().with(b -> b.c.value().with(c -> c.hidden.with(h -> h.is("gem"))))),
             "call op=EQUAL path=a.b.c.hidden constant=gem"
     );
 

File: criteria/elasticsearch/test/org/immutables/criteria/elasticsearch/ElasticModelTest.java
Patch:
@@ -90,8 +90,8 @@ public void criteria() {
     assertCount(crit.string.in("not", "not"), 0);
     assertCount(crit.string.is("bar"), 1);
     assertCount(crit.string.is("hello"), 0);
-    assertCount(crit.optionalString.value().is("optFoo"), 1);
-    assertCount(crit.optionalString.value().is("missing"), 0);
+    assertCount(crit.optionalString.is("optFoo"), 1);
+    assertCount(crit.optionalString.is("missing"), 0);
     assertCount(crit.intNumber.atMost(42).string.is("foo"), 1);
     assertCount(crit.intNumber.atMost(11), 0);
 

File: criteria/common/src/org/immutables/criteria/matcher/ArrayMatcher.java
Patch:
@@ -43,7 +43,7 @@ default R isEmpty() {
     return Matchers.extract(this).<R, S>factory().createRoot(e -> Expressions.call(Operators.EMPTY, e));
   }
 
-  default R isNotEmpty() {
+  default R notEmpty() {
     return Matchers.extract(this).<R, S>factory().createRoot(e -> Expressions.not(Expressions.call(Operators.EMPTY, e)));
   }
 

File: criteria/common/src/org/immutables/criteria/matcher/IterableMatcher.java
Patch:
@@ -55,7 +55,7 @@ default R isEmpty() {
     return Matchers.extract(this).<R, S>factory().createRoot(e -> Expressions.call(Operators.EMPTY, e));
   }
 
-  default R isNotEmpty() {
+  default R notEmpty() {
     return Matchers.extract(this).<R, S>factory().createRoot(e -> Expressions.not(Expressions.call(Operators.EMPTY, e)));
   }
 

File: criteria/common/src/org/immutables/criteria/matcher/StringMatcher.java
Patch:
@@ -25,11 +25,11 @@
 public interface StringMatcher<R> extends ComparableMatcher<R, String>  {
 
   default R isEmpty() {
-    return isEqualTo("");
+    return is("");
   }
 
-  default R isNotEmpty() {
-    return isNotEqualTo("");
+  default R notEmpty() {
+    return isNot("");
   }
 
   default R contains(CharSequence other) {

File: criteria/common/src/org/immutables/criteria/Criteria.java
Patch:
@@ -33,7 +33,7 @@
  */
 @Documented
 @Target(ElementType.TYPE)
-@Retention(RetentionPolicy.SOURCE)
+@Retention(RetentionPolicy.CLASS) // need at least CLASS retention because of APT unit testing
 public @interface Criteria {
 
   /**

File: value-processor/src/org/immutables/value/processor/encode/TypeExtractor.java
Patch:
@@ -89,7 +89,7 @@ private List<Type.Defined> getBounds(Type.Parameters parameters, TypeParameterEl
     return bounds;
   }
 
-  Type get(TypeMirror type) {
+  public Type get(TypeMirror type) {
     return type.accept(converter, parameters);
   }
 

File: value-processor/src/org/immutables/value/processor/meta/ValueTypeRepository.java
Patch:
@@ -135,7 +135,7 @@ public void consume(TypeMirror iface) {
           TypeMirror varType = variable.asType();
           if (types.isSubtype(varType, types.erasure(elements.getTypeElement(Class.class.getCanonicalName()).asType()))) {
             // inject entity class
-            params.add(ValueTypeRepository.this.type.name() + ".class");
+            params.add(ValueTypeRepository.this.type.typeDocument().toString() + ".class");
           } else if (types.isSubtype(varType, elements.getTypeElement(BACKEND).asType())) {
             // inject backend
             params.add("backend");

File: criteria/common/src/org/immutables/criteria/adapter/Backend.java
Patch:
@@ -32,13 +32,13 @@ public interface Backend {
    * @param operation operation to be performed on the back-end.
    * @return empty, single, multiple or unbounded event flow
    */
-  <T> Publisher<T> execute(Operation<T> operation);
+  <T> Publisher<T> execute(Operation operation);
 
   /**
    * Generic operation to be executed on the back-end. Typical operations include
    * query, update, delete etc.
    */
-  interface Operation<T> {
+  interface Operation {
 
   }
 

File: criteria/elasticsearch/src/org/immutables/criteria/elasticsearch/ElasticsearchBackend.java
Patch:
@@ -52,7 +52,7 @@ public ElasticsearchBackend(RestClient restClient,
   }
 
   @Override
-  public <T> Publisher<T> execute(Operation<T> query) {
+  public <T> Publisher<T> execute(Operation query) {
     Objects.requireNonNull(query, "query");
     if (query instanceof Operations.KeyedInsert) {
       return (Publisher<T>) keyedInsert((Operations.KeyedInsert<Object, Object>) query);

File: criteria/geode/src/org/immutables/criteria/geode/GeodeBackend.java
Patch:
@@ -53,7 +53,7 @@ public GeodeBackend(Region<?, ?> region) {
   }
 
   @Override
-  public <T> Publisher<T> execute(Operation<T> operation) {
+  public <T> Publisher<T> execute(Operation operation) {
     if (operation instanceof Operations.Select) {
       return query((Operations.Select<T>) operation);
     } else if (operation instanceof Operations.Insert) {

File: criteria/inmemory/src/org.immutables.criteria.inmemory/InMemoryBackend.java
Patch:
@@ -48,7 +48,7 @@ public InMemoryBackend(Map<Object, Object> store) {
   }
 
   @Override
-  public <T> Publisher<T> execute(Operation<T> operation) {
+  public <T> Publisher<T> execute(Operation operation) {
     if (operation instanceof Operations.Select) {
       return query((Operations.Select<T>) operation);
     } else if (operation instanceof Operations.Insert) {

File: criteria/mongo/src/org/immutables/criteria/mongo/MongoBackend.java
Patch:
@@ -59,7 +59,7 @@ private Bson toBson(Query query) {
   }
 
   @Override
-  public <T> Publisher<T> execute(Operation<T> operation) {
+  public <T> Publisher<T> execute(Operation operation) {
     if (operation instanceof Operations.Select) {
       return query((Operations.Select<T>) operation);
     } else if (operation instanceof Operations.Insert) {

File: criteria/common/src/org/immutables/criteria/repository/reactive/ReactiveReadable.java
Patch:
@@ -28,8 +28,9 @@ public class ReactiveReadable<T> implements ReactiveRepository.Readable<T> {
   private final Query query;
   private final Backend backend;
 
-  public ReactiveReadable(Query query, Backend backend) {
-    this.query = Objects.requireNonNull(query, "query");
+  public ReactiveReadable(Class<?> entity, Backend backend) {
+    Objects.requireNonNull(entity, "entity");
+    this.query = Query.of(entity);
     this.backend = backend;
   }
 

File: criteria/common/src/org/immutables/criteria/repository/reactive/ReactiveWritable.java
Patch:
@@ -19,14 +19,13 @@
 import org.immutables.criteria.Criterion;
 import org.immutables.criteria.adapter.Backend;
 import org.immutables.criteria.adapter.Operations;
-import org.immutables.criteria.repository.Writable;
 import org.immutables.criteria.repository.WriteResult;
 import org.reactivestreams.Publisher;
 
 import java.util.Objects;
 import java.util.function.Function;
 
-public class ReactiveWritable<T> implements Writable<T, Publisher<WriteResult>> {
+public class ReactiveWritable<T> implements ReactiveRepository.Writable<T> {
 
   final Backend backend;
 

File: criteria/common/test/org/immutables/criteria/personmodel/Person.java
Patch:
@@ -20,6 +20,7 @@
 import com.fasterxml.jackson.databind.annotation.JsonSerialize;
 import org.immutables.criteria.Criteria;
 import org.immutables.criteria.repository.reactive.ReactiveReadable;
+import org.immutables.criteria.repository.reactive.ReactiveWatchable;
 import org.immutables.criteria.repository.reactive.ReactiveWritable;
 import org.immutables.criteria.repository.sync.SyncRepository;
 import org.immutables.criteria.repository.sync.SyncWritable;
@@ -38,7 +39,7 @@
  */
 @Value.Immutable
 @Criteria
-@Criteria.Repository(watch = true, facets = {ReactiveReadable.class, ReactiveWritable.class})
+@Criteria.Repository(watch = true, facets = {ReactiveReadable.class, ReactiveWritable.class, ReactiveWatchable.class})
 @JsonSerialize(as = ImmutablePerson.class)
 @JsonDeserialize(as = ImmutablePerson.class)
 public interface Person extends Serializable // serializable needed for Geode temporarily

File: criteria/common/test/org/immutables/criteria/processor/CriteriaMatcherTest.java
Patch:
@@ -30,7 +30,7 @@
 
 import static org.immutables.check.Checkers.check;
 
-public class AttributeCriteriaTest {
+public class CriteriaMatcherTest {
 
   @Rule
   public final ProcessorRule rule = new ProcessorRule();

File: value-processor/src/org/immutables/value/processor/meta/CriteriaMirrors.java
Patch:
@@ -30,6 +30,8 @@ private CriteriaMirrors() {}
     boolean readonly() default false;
 
     boolean watch() default false;
+
+    Class<?>[] facets() default {};
   }
 
   @Mirror.Annotation("org.immutables.criteria.Criteria.Id")

File: criteria/common/src/org/immutables/criteria/matcher/ComparableMatcher.java
Patch:
@@ -56,7 +56,7 @@ default R isAtLeast(V lowerInclusive) {
     return Matchers.extract(this).<R, Object>factory().createRoot(e -> Expressions.call(Operators.GREATER_THAN_OR_EQUAL, e, Expressions.constant(lowerInclusive)));
   }
 
-  interface Self<V extends Comparable<? super V>> extends Template<Self<V>, V> {}
+  interface Self<V extends Comparable<? super V>> extends Template<Self<V>, V>, Disjunction<Template<Self<V>, V>> {}
 
   interface With<R, V extends Comparable<? super V>> extends WithMatcher<R, Self<V>> {}
 

File: criteria/common/src/org/immutables/criteria/matcher/IterableMatcher.java
Patch:
@@ -66,7 +66,7 @@ default R hasSize(int size) {
 
   }
 
-  interface Self<R, V> extends IterableMatcher<Self<R, V>, Self<R, V>, V> {}
+  interface Self<R, V> extends IterableMatcher<Self<R, V>, Self<R, V>, V>, Disjunction<Self<R, V>> {}
 
   @SuppressWarnings("unchecked")
   static <R> CriteriaCreator<R> creator() {

File: criteria/common/src/org/immutables/criteria/matcher/ObjectMatcher.java
Patch:
@@ -70,7 +70,7 @@ default R isNotIn(Iterable<? extends V> values) {
     return Matchers.extract(this).<R, Object>factory().createRoot(e -> Expressions.call(Operators.NOT_IN, e, Expressions.constant(ImmutableList.copyOf(values))));
   }
 
-  interface Self<V> extends Template<Self<V>, V> {}
+  interface Self<V> extends Template<Self<V>, V>, Disjunction<Template<Self<V>, V>> {}
 
   interface With<R, V> extends WithMatcher<R, Self<V>> {}
 

File: criteria/common/src/org/immutables/criteria/matcher/OptionalMatcher.java
Patch:
@@ -42,7 +42,7 @@ default S value() {
     return Matchers.extract(this).<R, S>factory().createNested();
   }
 
-  interface Self<S> extends OptionalMatcher<Self<S>, S> {}
+  interface Self<S> extends OptionalMatcher<Self<S>, S>, Disjunction<Self<S>> {}
 
   @SuppressWarnings("unchecked")
   static <R> CriteriaCreator<R> creator() {

File: criteria/common/test/org/immutables/criteria/personmodel/PersonTest.java
Patch:
@@ -36,7 +36,8 @@ public void collection() {
             .or()
             .fullName.not(f -> f.contains("bar").or().contains("foo"))
             .pets.all().name.isNotEmpty()
-            .pets.any().name.isEmpty()
+            .pets.any().name.with(n -> n.endsWith("aaa").or().startsWith("bbb"))
+            .pets.any().name.contains("aaa")
             .pets.any().name.not(n -> n.contains("bar"))
             .pets.none().name.hasLength(3)
             .not(p -> p.pets.hasSize(2))

File: criteria/common/src/org/immutables/criteria/matcher/IterableMatcher.java
Patch:
@@ -26,7 +26,7 @@
  * Matcher on {@link Iterable} types. Has methods like {@code isEmpty()} / {@code isNotEmpty()}
  * and others.
  */
-public interface IterableMatcher<R, S, C, V>  {
+public interface IterableMatcher<R, S, V>  {
 
   default S all() {
     final UnaryOperator<Expression> expr = e -> Expressions.call(Operators.ALL, e);
@@ -65,6 +65,6 @@ default R hasSize(int size) {
 
   }
 
-  interface Self<V> extends IterableMatcher<Self, Self, Self, V> {}
+  interface Self<V> extends IterableMatcher<Self<V>, Self<V>, V> {}
 
 }

File: criteria/common/src/org/immutables/criteria/matcher/Matchers.java
Patch:
@@ -89,7 +89,7 @@ public CriteriaContext context() {
     return new Local();
   }
 
-  public static <R, S, C, V> IterableMatcher<R, S, C, V> collectionMatcher(CriteriaContext context) {
+  public static <R, S, C, V> IterableMatcher<R, S, V> collectionMatcher(CriteriaContext context) {
     Objects.requireNonNull(context, "context");
 
     class Local implements IterableMatcher.Self, HasContext {
@@ -99,7 +99,7 @@ public CriteriaContext context() {
       }
     }
 
-    return (IterableMatcher<R, S, C, V>) new Local();
+    return (IterableMatcher<R, S, V>) new Local();
   }
 
   public static <T> T create(Class<T> type, CriteriaContext context) {

File: criteria/common/src/org/immutables/criteria/expression/Operators.java
Patch:
@@ -22,7 +22,7 @@ private Operators() {}
 
   public static final Operator EQUAL = new SimpleOperator("EQUAL", Boolean.class);
 
-  public static final Operator NOT_EQUAL = new SimpleOperator("EQUAL", Boolean.class);
+  public static final Operator NOT_EQUAL = new SimpleOperator("NOT_EQUAL", Boolean.class);
 
   // collection
   public static final Operator IN = new SimpleOperator("IN", Boolean.class);

File: criteria/common/src/org/immutables/criteria/matcher/AndMatcher.java
Patch:
@@ -27,7 +27,7 @@ public interface AndMatcher<R extends Criterion<?>> {
   default R and(R first) {
     final CriteriaContext context = Matchers.extract(this);
     final UnaryOperator<Expression> expr = e -> Expressions.and(Matchers.concatFilters(e, first));
-    return context.<R>factory1().create1(expr);
+    return context.<R, Object, Object>factory().createRoot(expr);
   }
 
 }

File: criteria/common/src/org/immutables/criteria/matcher/NotMatcher.java
Patch:
@@ -34,9 +34,9 @@ public interface NotMatcher<R, C> {
 
   default R not(UnaryOperator<C> operator) {
     final CriteriaContext context = Matchers.extract(this);
-    final CriteriaCreator.TriFactory<R, ?, C> factory3 = context.<R, Object, C>factory3();
-    final UnaryOperator<Expression> expr = e -> Expressions.not(Matchers.toExpressionOperator3(context, operator).apply(e));
-    return factory3.create1(expr);
+    final CriteriaCreator.Factory<R, ?, C> factory3 = context.<R, Object, C>factory();
+    final UnaryOperator<Expression> expr = e -> Expressions.not(Matchers.toInnerExpression(context, operator).apply(e));
+    return factory3.createRoot(expr);
 
   }
 

File: criteria/common/src/org/immutables/criteria/matcher/OrMatcher.java
Patch:
@@ -26,7 +26,7 @@ public interface OrMatcher<R extends Criterion<?>> {
 
   default R or(R first) {
     final UnaryOperator<Expression> expr = e -> Expressions.or(Matchers.concatFilters(e, first));
-    return Matchers.extract(this).withOperator(expr).or().<R>factory1().create1();
+    return Matchers.extract(this).withOperator(expr).or().<R, Object, Object>factory().createRoot();
   }
 
 }

File: criteria/common/src/org/immutables/criteria/matcher/StringMatcher.java
Patch:
@@ -25,11 +25,11 @@
 public interface StringMatcher<R> extends ComparableMatcher<R, String>, NotMatcher<R, StringMatcher<StringMatcher.Self>> {
 
   default R isEmpty() {
-    return Matchers.extract(this).<R>factory1().create1(e -> Expressions.call(Operators.EQUAL, e, Expressions.constant("")));
+    return Matchers.extract(this).<R, Object, Object>factory().createRoot(e -> Expressions.call(Operators.EQUAL, e, Expressions.constant("")));
   }
 
   default R isNotEmpty() {
-    return Matchers.extract(this).<R>factory1().create1(e -> Expressions.call(Operators.NOT_EQUAL, e, Expressions.constant("")));
+    return Matchers.extract(this).<R, Object, Object>factory().createRoot(e -> Expressions.call(Operators.NOT_EQUAL, e, Expressions.constant("")));
   }
 
   default R contains(CharSequence other) {
@@ -52,7 +52,7 @@ interface Self extends StringMatcher<Self>, Disjunction<StringMatcher<Self>> {
 
     @Override
     default StringMatcher<StringMatcher.Self> or() {
-      return Matchers.extract(this).or().<StringMatcher.Self>factory1().create1();
+      return Matchers.extract(this).or().<StringMatcher.Self, Object, Object>factory().createRoot();
     }
   }
 

File: criteria/common/src/org/immutables/criteria/matcher/CriteriaContext.java
Patch:
@@ -144,13 +144,14 @@ public CriteriaContext context() {
   /**
    *  adds an intermediate path
    */
-  public CriteriaContext withPath(String pathAsString) {
+  public CriteriaContext withPath(Class<?> type, String pathAsString) {
     // clazz ==
-    final Member member = Reflections.member(entityClass, pathAsString);
+    final Member member = Reflections.member(type, pathAsString);
     final Path newPath = this.path != null ? this.path.with(member) : Path.of(member);
     return new CriteriaContext(operator, entityClass, expression, newPath, creators);
   }
 
+
   public CriteriaContext or() {
     if (operator == Operators.OR) {
       return this;

File: criteria/common/test/org/immutables/criteria/personmodel/AbstractPersonTest.java
Patch:
@@ -207,6 +207,7 @@ public void basic() {
     // isPresent / isAbsent
     check(criteria().address.isAbsent()).empty();
     check(criteria().address.isPresent()).notEmpty();
+
   }
 
   @Test

File: criteria/common/test/org/immutables/criteria/personmodel/Friend.java
Patch:
@@ -29,7 +29,6 @@
 @JsonIgnoreProperties(ignoreUnknown = true)
 public interface Friend {
 
-  String nickName();
+  String hobby();
 
-  int age();
 }

File: criteria/common/src/org/immutables/criteria/AsyncRepository.java
Patch:
@@ -26,7 +26,7 @@
  */
 public interface AsyncRepository<T> extends Repository<T> {
 
-  interface Reader<T> extends Repository.Reader<T> {
+  interface Reader<T> extends Repository.Reader<T, Reader<T>> {
 
     CompletionStage<List<T>> fetch();
 

File: criteria/common/src/org/immutables/criteria/ReactiveRepository.java
Patch:
@@ -26,7 +26,7 @@
  */
 public interface ReactiveRepository<T> extends Repository<T> {
 
-  interface Reader<T> extends Repository.Reader<T> {
+  interface Reader<T> extends Repository.Reader<T, Reader<T>> {
 
     Publisher<T> fetch();
 

File: criteria/common/src/org/immutables/criteria/SyncRepository.java
Patch:
@@ -25,7 +25,7 @@
  */
 public interface SyncRepository<T> extends Repository<T> {
 
-  interface Reader<T> extends Repository.Reader<T> {
+  interface Reader<T> extends Repository.Reader<T, Reader<T>> {
 
     List<T> fetch();
 

File: criteria/common/src/org/immutables/criteria/adapter/InternalReader.java
Patch:
@@ -44,12 +44,12 @@ private InternalReader(Query query, Backend backend) {
   }
 
   @Override
-  public Repository.Reader<T> limit(long limit) {
+  public ReactiveRepository.Reader<T> limit(long limit) {
     return new InternalReader<T>(query.withLimit(limit), backend);
   }
 
   @Override
-  public Repository.Reader<T> offset(long offset) {
+  public ReactiveRepository.Reader<T> offset(long offset) {
     return new InternalReader<T>(query.withOffset(offset), backend);
   }
 

File: criteria/mongo/src/org/immutables/criteria/mongo/bson4jackson/JacksonCodecs.java
Patch:
@@ -60,7 +60,7 @@ public static CodecRegistry registryFromMapper(final ObjectMapper mapper) {
     return new CodecRegistry() {
       @Override
       public <T> Codec<T> get(final Class<T> clazz) {
-        final JavaType javaType = TypeFactory.defaultInstance().constructType(clazz);
+        final JavaType javaType = mapper.getTypeFactory().constructType(clazz);
         if (!mapper.canSerialize(clazz) || !mapper.canDeserialize(javaType)) {
           throw new CodecConfigurationException(String.format("%s (javaType: %s) not supported by Jackson Mapper", clazz, javaType));
         }

File: criteria/common/src/org/immutables/criteria/Criterias.java
Patch:
@@ -37,5 +37,5 @@ public static Query toQuery(DocumentCriteria<?> criteria) {
 
     return ((Queryable) criteria).query();
   }
-  
+
 }

File: criteria/common/src/org/immutables/criteria/matcher/ObjectMatcher.java
Patch:
@@ -60,12 +60,12 @@ default R isNotIn(V v1, V v2, V ... rest) {
     return isNotIn(values);
   }
 
-  default R isIn(Iterable<? super V> values) {
+  default R isIn(Iterable<? extends V> values) {
     Objects.requireNonNull(values, "values");
     return Matchers.extract(this).<R>factory1().create1(e -> Expressions.call(Operators.IN, e, Expressions.constant(ImmutableList.copyOf(values))));
   }
 
-  default R isNotIn(Iterable<? super V> values) {
+  default R isNotIn(Iterable<? extends V> values) {
     Objects.requireNonNull(values, "values");
     return Matchers.extract(this).<R>factory1().create1(e -> Expressions.call(Operators.NOT_IN, e, Expressions.constant(ImmutableList.copyOf(values))));
   }

File: criteria/common/src/org/immutables/criteria/expression/Operators.java
Patch:
@@ -13,6 +13,7 @@ public enum Operators implements Operator {
   ANY, // some elements match (at least one)
   EMPTY, // means collection is empty
   SIZE, // size of the collection
+  CONTAINS,
 
   // boolean ops
   AND,

File: criteria/common/test/org/immutables/criteria/PersonTest.java
Patch:
@@ -10,7 +10,7 @@ public class PersonTest {
   public void collection() {
     PersonCriteria.create()
             .friends.any().nickName.isNotEmpty()
-            .aliases.none().contains("foo")
+            .aliases.none().startsWith("foo")
             .or()//.or() should not work
             .isMarried.isTrue()
             .or()
@@ -19,6 +19,7 @@ public void collection() {
             .friends.none().nickName.hasSize(3)
             .friends.all(f -> f.nickName.isEmpty().or().nickName.hasSize(2))
             .friends.any(f -> f.nickName.isEmpty().or().nickName.hasSize(2))
+            .aliases.contains("test")
             .friends.none(f -> f.nickName.hasSize(3).nickName.startsWith("a"));
   }
 

File: criteria/common/test/org/immutables/criteria/TypeHolderTest.java
Patch:
@@ -15,7 +15,6 @@ public void name() {
     // primitives
     TypeHolderCriteria.create()
             .booleanPrimitive.isTrue()
-            .booleanPrimitive.isEqualTo(false)
             .booleanPrimitive.isFalse()
             .intPrimitive.isEqualTo(0)
             .intPrimitive.isGreaterThan(22)

File: criteria/common/src/org/immutables/criteria/constraints/Call.java
Patch:
@@ -5,12 +5,12 @@
 /**
  * An expression formed by a call to an operator (eg. {@link Operators#EQUAL}) with zero or more arguments.
  */
-public interface Call<T> extends Expression<T> {
+public interface Call extends Expression {
 
   /**
    * Get arguments of this operation
    */
-  List<Expression<?>> getArguments();
+  List<Expression> getArguments();
 
   /**
    * Get the operator symbol for this operation

File: criteria/common/src/org/immutables/criteria/constraints/ExpressionVisitor.java
Patch:
@@ -9,10 +9,10 @@
  */
 public interface ExpressionVisitor<V, C> {
 
-  V visit(Call<?> call, @Nullable C context);
+  V visit(Call call, @Nullable C context);
 
-  V visit(Literal<?> literal, @Nullable C context);
+  V visit(Literal literal, @Nullable C context);
 
-  V visit(Path<?> path, @Nullable C context);
+  V visit(Path path, @Nullable C context);
 
 }

File: criteria/common/src/org/immutables/criteria/constraints/Expressional.java
Patch:
@@ -9,6 +9,6 @@ public interface Expressional<T> {
   /**
    * Expose expression used by an object.
    */
-  Expression<T> expression();
+  Expression expression();
 
 }

File: criteria/common/src/org/immutables/criteria/constraints/NilExpression.java
Patch:
@@ -7,7 +7,7 @@
  *
  * <p>Not supposed to be visited at runtime</p>
  */
-final class NilExpression<T> implements Expression<T> {
+final class NilExpression implements Expression {
 
   static final NilExpression INSTANCE = new NilExpression();
 

File: criteria/common/src/org/immutables/criteria/constraints/ObjectCriteria.java
Patch:
@@ -42,7 +42,7 @@ public ObjectCriteria(CriteriaContext<R> context) {
   /**
    * Use context to create new root DocumentCriteria
    */
-  protected R create(UnaryOperator<Expression<?>> fn) {
+  protected R create(UnaryOperator<Expression> fn) {
     return (R) context.create(fn);
   }
 

File: criteria/common/src/org/immutables/criteria/constraints/Path.java
Patch:
@@ -2,10 +2,8 @@
 
 /**
  * Access to a field.
- * 
- * @param <T>
  */
-public interface Path<T> extends Expression<T> {
+public interface Path extends Expression {
 
   String path();
 

File: criteria/mongo/src/org/immutables/criteria/mongo/Mongos.java
Patch:
@@ -14,7 +14,7 @@ private Mongos() {}
   /**
    * Convert existing expression to Bson
    */
-  static <T> Bson toBson(CodecRegistry registry, Expression<T> expression) {
+  static <T> Bson toBson(CodecRegistry registry, Expression expression) {
     MongoVisitor visitor = new MongoVisitor(registry);
     return expression.accept(visitor, null).asDocument();
   }

File: criteria/common/src/org/immutables/criteria/DocumentCriteria.java
Patch:
@@ -22,6 +22,6 @@
  *
  * @param <R> Criteria self-type, allowing {@code this}-returning methods to avoid needing subclassing
  */
-public interface DocumentCriteria<R extends DocumentCriteria<R>>  {
+public interface DocumentCriteria<R>  {
 
 }

File: criteria/common/src/org/immutables/criteria/constraints/BooleanCriteria.java
Patch:
@@ -16,12 +16,10 @@
 package org.immutables.criteria.constraints;
 
 
-import org.immutables.criteria.DocumentCriteria;
-
 /**
  * Very simple criteria for booleans just has {@code true} / {@code false} checks.
  */
-public class BooleanCriteria<R extends DocumentCriteria<R>> extends ObjectCriteria<R, Boolean> {
+public class BooleanCriteria<R> extends ObjectCriteria<R, Boolean> {
 
   public BooleanCriteria(CriteriaContext<R> context) {
     super(context);

File: criteria/common/src/org/immutables/criteria/constraints/CollectionCriteria.java
Patch:
@@ -5,7 +5,7 @@
 import java.util.Objects;
 import java.util.function.UnaryOperator;
 
-public class CollectionCriteria<R extends DocumentCriteria<R>, S extends DocumentCriteria<R>, C extends DocumentCriteria<C>> implements DocumentCriteria<R> {
+public class CollectionCriteria<R, S, C> implements DocumentCriteria<R> {
 
   private final CriteriaContext<R> context;
 

File: criteria/common/src/org/immutables/criteria/constraints/ComparableCriteria.java
Patch:
@@ -16,12 +16,10 @@
 package org.immutables.criteria.constraints;
 
 
-import org.immutables.criteria.DocumentCriteria;
-
 /**
  * Criteria for comparables (like {@code >, <=, >} and ranges).
  */
-public class ComparableCriteria<R extends DocumentCriteria<R>, V extends Comparable<V>>
+public class ComparableCriteria<R, V extends Comparable<V>>
         extends ObjectCriteria<R, V> {
 
   public ComparableCriteria(CriteriaContext<R> context) {

File: criteria/common/src/org/immutables/criteria/constraints/CriteriaContext.java
Patch:
@@ -1,13 +1,11 @@
 package org.immutables.criteria.constraints;
 
-import org.immutables.criteria.DocumentCriteria;
-
 import java.util.function.UnaryOperator;
 
 /**
  * Link between front-end (codegened Criteria) and back-end (built {@link Expression}).
  */
-public final class CriteriaContext<R extends DocumentCriteria<R>> {
+public final class CriteriaContext<R> {
 
   private final CriteriaCreator<R> creator;
   private final DnfExpression<?> expression;

File: criteria/common/src/org/immutables/criteria/constraints/CriteriaCreator.java
Patch:
@@ -15,12 +15,10 @@
  */
 package org.immutables.criteria.constraints;
 
-import org.immutables.criteria.DocumentCriteria;
-
 /**
  * Creates document criteria from existing expression.
  */
-public interface CriteriaCreator<R extends DocumentCriteria<R>> {
+public interface CriteriaCreator<R> {
 
   R create(CriteriaContext<R> context);
 

File: criteria/common/src/org/immutables/criteria/constraints/Disjunction.java
Patch:
@@ -1,8 +1,6 @@
 package org.immutables.criteria.constraints;
 
-import org.immutables.criteria.DocumentCriteria;
-
-public interface Disjunction<R extends DocumentCriteria<R>> {
+public interface Disjunction<R> {
 
   /**
    * Builds a disjunction

File: criteria/common/src/org/immutables/criteria/constraints/ObjectCriteria.java
Patch:
@@ -31,7 +31,7 @@
  * @param <V> attribute type for which criteria is applied
  * @param <R> Criteria self-type, allowing {@code this}-returning methods to avoid needing subclassing
  */
-public class ObjectCriteria<R extends DocumentCriteria<R>, V> implements DocumentCriteria<R> {
+public class ObjectCriteria<R, V> implements DocumentCriteria<R> {
 
   private final CriteriaContext<R> context;
 

File: criteria/common/src/org/immutables/criteria/constraints/OptionalCriteria.java
Patch:
@@ -16,15 +16,13 @@
 
 package org.immutables.criteria.constraints;
 
-import org.immutables.criteria.DocumentCriteria;
-
 import java.util.Objects;
 import java.util.function.UnaryOperator;
 
 /**
  * Criteria for optional attributes.
  */
-public class OptionalCriteria<R extends DocumentCriteria<R>, S extends DocumentCriteria<R>, C extends DocumentCriteria<C>>  {
+public class OptionalCriteria<R, S, C>  {
 
   private final CriteriaContext<R> context;
 

File: criteria/common/src/org/immutables/criteria/constraints/StringCriteria.java
Patch:
@@ -16,12 +16,10 @@
 
 package org.immutables.criteria.constraints;
 
-import org.immutables.criteria.DocumentCriteria;
-
 /**
  * String specific criterias like {@code isAbsent}, {@code contains} etc.
  */
-public class StringCriteria<R extends DocumentCriteria<R>> extends ComparableCriteria<R, String> {
+public class StringCriteria<R> extends ComparableCriteria<R, String> {
 
   public StringCriteria(CriteriaContext<R> context) {
     super(context);

File: criteria/common/src/org/immutables/criteria/constraints/ValueCriteria.java
Patch:
@@ -1,10 +1,8 @@
 package org.immutables.criteria.constraints;
 
-import org.immutables.criteria.DocumentCriteria;
-
 /**
  * Base class for comparing documents and scalars (string, boolean etc.)
  */
-public interface ValueCriteria<R extends DocumentCriteria<R>, V> {
+public interface ValueCriteria<R, V> {
 
 }

File: criteria/common/test/org/immutables/criteria/ReflectionTest.java
Patch:
@@ -65,7 +65,7 @@ public void collection() {
     PersonCriteria.create()
             .friends.any().nickName.isNotEmpty()
             .friends.any(f -> f.nickName.isNotEmpty().nickName.isEmpty())
-            .friends.none(f -> f.nickName.hasSize(3))
+            .friends.none(f -> f.nickName.hasSize(3).nickName.startsWith("a"))
             .aliases.none().contains("foo")
             .lastName.value().isNotEmpty()
             .lastName.value().hasSize(2)

File: criteria/common/src/org/immutables/criteria/constraints/CollectionCriteria.java
Patch:
@@ -5,7 +5,7 @@
 import java.util.Objects;
 import java.util.function.UnaryOperator;
 
-public class CollectionCriteria<R extends DocumentCriteria<R>, S extends DocumentCriteria<R>, C extends DocumentCriteria<?>> implements DocumentCriteria<R> {
+public class CollectionCriteria<R extends DocumentCriteria<R>, S extends DocumentCriteria<R>, C extends DocumentCriteria<C>> implements DocumentCriteria<R> {
 
   private final CriteriaContext<R> context;
 

File: criteria/common/src/org/immutables/criteria/constraints/OptionalCriteria.java
Patch:
@@ -24,7 +24,7 @@
 /**
  * Criteria for optional attributes.
  */
-public class OptionalCriteria<R extends DocumentCriteria<R>, S extends DocumentCriteria<R>, C extends DocumentCriteria<?>>  {
+public class OptionalCriteria<R extends DocumentCriteria<R>, S extends DocumentCriteria<R>, C extends DocumentCriteria<C>>  {
 
   private final CriteriaContext<R> context;
 

File: criteria/common/test/org/immutables/criteria/Friend.java
Patch:
@@ -2,8 +2,6 @@
 
 import org.immutables.value.Value;
 
-import java.util.List;
-
 @Value.Immutable
 @Criteria
 public interface Friend {

File: criteria/common/test/org/immutables/criteria/ReflectionTest.java
Patch:
@@ -65,7 +65,7 @@ public void collection() {
     PersonCriteria.create()
             .friends.any().nickName.isNotEmpty()
             .friends.any(f -> f.nickName.isNotEmpty().nickName.isEmpty())
-            .friends.none(f -> f.nickName.isEmpty())
+            .friends.none(f -> f.nickName.hasSize(3))
             .aliases.none().contains("foo")
             .lastName.value().isNotEmpty()
             .lastName.value().hasSize(2)

File: criteria/common/src/org/immutables/criteria/constraints/OptionalCriteria.java
Patch:
@@ -19,7 +19,7 @@
 import org.immutables.criteria.DocumentCriteria;
 
 import java.util.Objects;
-import java.util.function.Consumer;
+import java.util.function.UnaryOperator;
 
 /**
  * Criteria for optional attributes.
@@ -44,7 +44,7 @@ public S value() {
     throw new UnsupportedOperationException();
   }
 
-  public R value(Consumer<C> consumer) {
+  public R value(UnaryOperator<C> consumer) {
     throw new UnsupportedOperationException();
   }
 

File: criteria/common/test/org/immutables/criteria/ReflectionTest.java
Patch:
@@ -65,6 +65,7 @@ public void collection() {
     PersonCriteria.create()
             .friends.any().nickName.isNotEmpty()
             .friends.any(f -> f.nickName.isNotEmpty().nickName.isEmpty())
+            .friends.none(f -> f.nickName.isEmpty())
             .aliases.none().contains("foo")
             .lastName.value().isNotEmpty()
             .lastName.value().hasSize(2)

File: criteria/common/test/org/immutables/criteria/ReflectionTest.java
Patch:
@@ -1,6 +1,7 @@
 package org.immutables.criteria;
 
 import org.immutables.criteria.constraints.DebugExpressionVisitor;
+import org.immutables.criteria.constraints.StringCriteria;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -63,10 +64,11 @@ public void empty() {
   public void collection() {
     PersonCriteria.create()
             .friends.any().nickName.isNotEmpty()
-            .friends.any(f -> f.nickName.isNotEmpty())
+            .friends.any(f -> f.nickName.isNotEmpty().nickName.isEmpty())
             .aliases.none().contains("foo")
             .lastName.value().isNotEmpty()
             .lastName.value().hasSize(2)
+            .lastName.value(StringCriteria::isNotEmpty)
             .bestFriend.nickName.startsWith("foo");
   }
 

File: criteria/common/src/org/immutables/criteria/constraints/ObjectCriteria.java
Patch:
@@ -35,7 +35,7 @@ public class ObjectCriteria<R extends DocumentCriteria<R>, V> implements ValueCr
 
   private final CriteriaContext<R> context;
 
-  ObjectCriteria(CriteriaContext<R> context) {
+  public ObjectCriteria(CriteriaContext<R> context) {
     this.context = Preconditions.checkNotNull(context, "context");
   }
 

File: criteria/common/src/org/immutables/criteria/constraints/OptionalCriteria.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.util.Optional;
 import java.util.function.Consumer;
+import java.util.function.Function;
 
 /**
  * Criteria for optional attributes.

File: criteria/common/test/org/immutables/criteria/Person.java
Patch:
@@ -1,9 +1,9 @@
 package org.immutables.criteria;
 
-import com.google.common.base.Optional;
 import org.immutables.value.Value;
 
 import java.util.List;
+import java.util.Optional;
 
 @Value.Immutable
 @Criteria
@@ -13,6 +13,7 @@ public interface Person {
 
   Optional<String> lastName();
 
+
   boolean isMarried();
 
   int age();

File: criteria/common/test/org/immutables/criteria/ReflectionTest.java
Patch:
@@ -63,10 +63,10 @@ public void empty() {
   public void collection() {
     PersonCriteria.create()
             .friends.any().nickName.isNotEmpty()
-            .friends.any(f -> f.nickName.isNotEmpty().isMarried.isTrue())
+            .friends.any(f -> f.nickName.isNotEmpty())
             .aliases.none().contains("foo")
-            .lastName.value().isNotEmpty();
-
+            .lastName.value().isNotEmpty()
+            .bestFriend.nickName.startsWith("foo");
   }
 
   @Test

File: value-annotations/src/org/immutables/value/Value.java
Patch:
@@ -61,7 +61,7 @@
      * <p>
      * This requires that all attributes have default value (including collections which can be left
      * empty). If some required attributes exist it will result in compilation error. Note that in
-     * case object do not have attributes, singleton instance will be generated automatically.
+     * case object does not have attributes, singleton instance will be generated automatically.
      * <p>
      * Note that {@code singleton=true} does not imply that only one instance of given abstract
      * type. But it does mean that only one "default" instance of the immutable implementation type
@@ -79,8 +79,8 @@
 
     /**
      * If {@code copy=false} then generation of copying methods will be disabled.
-     * This appies to static "copyOf" methods as well as modify-by-copy "withAttributeName" methods
-     * which returns modified copy using structural sharing where possible.
+     * This applies to static "copyOf" methods as well as modify-by-copy "withAttributeName" methods
+     * which return modified copy using structural sharing where possible.
      * Default value is {@literal true}, i.e generate copy methods.
      * @return if generate copy methods
      */

File: value-annotations/src/org/immutables/value/Value.java
Patch:
@@ -61,7 +61,7 @@
      * <p>
      * This requires that all attributes have default value (including collections which can be left
      * empty). If some required attributes exist it will result in compilation error. Note that in
-     * case object do not have attributes, singleton instance will be generated automatically.
+     * case object does not have attributes, singleton instance will be generated automatically.
      * <p>
      * Note that {@code singleton=true} does not imply that only one instance of given abstract
      * type. But it does mean that only one "default" instance of the immutable implementation type
@@ -79,8 +79,8 @@
 
     /**
      * If {@code copy=false} then generation of copying methods will be disabled.
-     * This appies to static "copyOf" methods as well as modify-by-copy "withAttributeName" methods
-     * which returns modified copy using structural sharing where possible.
+     * This applies to static "copyOf" methods as well as modify-by-copy "withAttributeName" methods
+     * which return modified copy using structural sharing where possible.
      * Default value is {@literal true}, i.e generate copy methods.
      * @return if generate copy methods
      */

File: mongo/test/org/immutables/mongo/fixture/MongoAsserts.java
Patch:
@@ -45,8 +45,8 @@ public static void assertDuplicateKeyException(Throwable exception) {
       String codeName = ((MongoCommandException) exception).getResponse().get("codeName").asString().getValue();
       int errorCode = ((MongoCommandException) exception).getErrorCode();
 
-      // 11000 stands for DuplicateKeyException
-      check(errorCode).is(11000);
+      check(codeName).is("DuplicateKey");
+      check(errorCode).is(11000); // code 11000 stands for DuplicateKeyException
 
       // all good here (can return)
       return;

File: value-processor/src/org/immutables/value/processor/meta/FromSupertypesModel.java
Patch:
@@ -166,7 +166,7 @@ private boolean isEligibleFromType(TypeElement typeElement, ValueAttribute attr)
 
   private @Nullable ExecutableElement findMethod(TypeElement typeElement, String getter) {
     for (ExecutableElement m : ElementFilter.methodsIn(typeElement.getEnclosedElements())) {
-      if (m.getSimpleName().contentEquals(getter)) {
+      if (m.getSimpleName().contentEquals(getter) && m.getParameters().isEmpty()) {
         return m;
       }
     }

File: value-processor/src/org/immutables/value/processor/meta/FromSupertypesModel.java
Patch:
@@ -166,7 +166,7 @@ private boolean isEligibleFromType(TypeElement typeElement, ValueAttribute attr)
 
   private @Nullable ExecutableElement findMethod(TypeElement typeElement, String getter) {
     for (ExecutableElement m : ElementFilter.methodsIn(typeElement.getEnclosedElements())) {
-      if (m.getSimpleName().contentEquals(getter)) {
+      if (m.getSimpleName().contentEquals(getter) && m.getParameters().isEmpty()) {
         return m;
       }
     }

File: generator-processor/src/org/immutables/generator/processor/Trees.java
Patch:
@@ -334,7 +334,7 @@ public String toString() {
     }
 
     public boolean isWhitespace() {
-      return CharMatcher.WHITESPACE.matchesAllOf(value());
+      return CharMatcher.whitespace().matchesAllOf(value());
     }
   }
 

File: generator/src/org/immutables/generator/Templates.java
Patch:
@@ -73,7 +73,7 @@ private void beforeAppend() {
 
     public CharSequence getCurrentIndentation() {
       CharSequence sequence = currentLine();
-      return sequence.length() > 0 && CharMatcher.WHITESPACE.matchesAllOf(sequence)
+      return sequence.length() > 0 && CharMatcher.whitespace().matchesAllOf(sequence)
           ? sequence
           : indentation;
     }
@@ -105,7 +105,7 @@ void newline() {
     }
 
     private boolean wasBlankLine() {
-      return CharMatcher.WHITESPACE.matchesAllOf(currentLine());
+      return CharMatcher.whitespace().matchesAllOf(currentLine());
     }
 
     @Override

File: trees/test/org/immutables/trees/ast/SampleNodes.java
Patch:
@@ -234,7 +234,7 @@ public static abstract class TextFragment implements TextPart {
     public abstract String value();
 
     public boolean isWhitespace() {
-      return CharMatcher.WHITESPACE.matchesAllOf(value());
+      return CharMatcher.whitespace().matchesAllOf(value());
     }
   }
 

File: value-fixture/test/org/immutables/fixture/marshal/MarshallingTest.java
Patch:
@@ -68,7 +68,7 @@ public void unmarshalWrappedNull() {
 
   @Test
   public void nullableMarshaling() {
-    check(CharMatcher.WHITESPACE.removeFrom(Marshaling.toJson(ImmutableHasNullable.of()))).is("{}");
+    check(CharMatcher.whitespace().removeFrom(Marshaling.toJson(ImmutableHasNullable.of()))).is("{}");
     check(Marshaling.fromJson("{}", ImmutableHasNullable.class)).is(ImmutableHasNullable.of());
     check(Marshaling.fromJson("{\"in\":1}", ImmutableHasNullable.class)).is(ImmutableHasNullable.of(1));
     check(Marshaling.fromJson("{\"def\":\"1\"}", ImmutableHasNullable.class))

File: value-fixture/test/org/immutables/fixture/nested/NestedValuesTest.java
Patch:
@@ -53,7 +53,7 @@ public void nonNestedGroupingCompilation() {
 
   @Test
   public void marshalingOfNested() {
-    check(CharMatcher.WHITESPACE.removeFrom(
+    check(CharMatcher.whitespace().removeFrom(
         Marshaling.toJson(
             ImmutableGroupedClasses.NestedOne.builder().build()))).is("{}");
   }

File: value-processor/src/org/immutables/value/processor/encode/Code.java
Patch:
@@ -32,7 +32,7 @@ final class Code {
   private Code() {}
 
   private static final CharMatcher DELIMITER = CharMatcher.anyOf("!\"#$%&'()*+,-./:;<=>?@[]^{|}~");
-  private static final CharMatcher WHITESPACE = CharMatcher.WHITESPACE;
+  private static final CharMatcher WHITESPACE = CharMatcher.whitespace();
   private static final CharMatcher LETTER_OR_DIGIT = CharMatcher.javaLetterOrDigit().or(CharMatcher.anyOf("$_"));
   private static final CharMatcher IDENTIFIER_START = CharMatcher.javaLetter().or(CharMatcher.anyOf("$_"));
 

File: generator/src/org/immutables/generator/Output.java
Patch:
@@ -1,5 +1,5 @@
 /*
-   Copyright 2014 Immutables Authors and Contributors
+   Copyright 2014-2018 Immutables Authors and Contributors
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
@@ -49,6 +49,7 @@
 import javax.tools.FileObject;
 import javax.tools.JavaFileObject;
 import javax.tools.StandardLocation;
+import org.immutables.generator.Delegated.Delegates;
 import org.immutables.generator.Templates.Invokable;
 import org.immutables.generator.Templates.Invokation;
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -171,7 +172,7 @@ public Invokable invoke(Invokation invokation, Object... parameters) {
       Element originatingElement = (Element) parameters[2];
       Invokable body = (Invokable) parameters[3];
 
-      ResourceKey key = new ResourceKey(packageName, simpleName, originatingElement);
+      ResourceKey key = new ResourceKey(packageName, simpleName, Delegates.unwrap(originatingElement));
       SourceFile javaFile = getFiles().sourceFiles.get(key);
       body.invoke(new Invokation(javaFile.consumer));
       javaFile.complete();

File: value-processor/src/org/immutables/value/processor/meta/ValueType.java
Patch:
@@ -22,7 +22,6 @@
 import com.google.common.base.Predicates;
 import com.google.common.base.Splitter;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ForwardingCollection;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;

File: generator/src/org/immutables/generator/Output.java
Patch:
@@ -307,7 +307,7 @@ void complete() {
         if (identicalFileIsAlreadyGenerated(sourceCode)) {
           getMessager().printMessage(Kind.MANDATORY_WARNING, "Regenerated file with the same content: " + key);
         } else {
-          getMessager().printMessage(Kind.ERROR,
+          getMessager().printMessage(Kind.MANDATORY_WARNING,
               String.format(
                   "Generated source file name colission. Attempt to overwrite already generated file: %s, %s."
                       + " If this happens when using @Value.Immutable on same-named nested classes in the same package,"

File: mongo/src/org/immutables/mongo/bson4jackson/BsonParser.java
Patch:
@@ -247,9 +247,11 @@ private JsonToken toJsonToken(BsonType type) {
         return JsonToken.VALUE_NUMBER_FLOAT;
       case DOUBLE:
         return JsonToken.VALUE_NUMBER_FLOAT;
+      case BINARY:
+        return JsonToken.VALUE_EMBEDDED_OBJECT;
       default:
         throw new IllegalStateException(String.format("Unknown type %s", type));
-    }   
+    }
   }
 
   @Override

File: mongo/test/org/immutables/mongo/fixture/JacksonRepoTest.java
Patch:
@@ -62,7 +62,6 @@
  * Tests for repository using <a href="https://github.com/FasterXML/jackson">Jackson</a> library.
  * @see JacksonCodecs
  */
-//@Gson.TypeAdapters // TODO perhaps compile warning (for missing @Gson annotation) can be removed ?
 public class JacksonRepoTest {
 
   private JacksonRepository repository;

File: value-annotations/src/org/immutables/value/Value.java
Patch:
@@ -1280,9 +1280,10 @@
      * <em>This is detection pattern, not formatting pattern. It defines how to recognize a nested
      * builder.</em>
      * Only applies if {@link #attributeBuilderDetection()} is {@code true}.
+     *
      * @return naming template
      */
-    String[] attributeBuilder() default {"*Builder", "builder", "new"};
+    String[] attributeBuilder() default {"Builder", "*Builder", "builder", "from", "build", "*Build", "new"};
 
     /**
      * Naming template for retrieving a nested builder.

File: value-fixture/src/org/immutables/fixture/builder/attribute_builders/ThirdPartyImmutableWithBuilderClassCopyMethod.java
Patch:
@@ -31,7 +31,7 @@ public ThirdPartyImmutableWithBuilderClassCopyMethod doTheBuild() {
       return new ThirdPartyImmutableWithBuilderClassCopyMethod(value);
     }
 
-    public static Builder builderFromValue(ThirdPartyImmutableWithBuilderClassCopyMethod immutable) {
+    public static Builder from(ThirdPartyImmutableWithBuilderClassCopyMethod immutable) {
       return new Builder().setValue(immutable.getValue());
     }
   }

File: value-fixture/src/org/immutables/fixture/builder/attribute_builders/ThirdPartyImmutableWithBuilderInstanceCopyMethod.java
Patch:
@@ -31,7 +31,7 @@ public ThirdPartyImmutableWithBuilderInstanceCopyMethod doTheBuild() {
       return new ThirdPartyImmutableWithBuilderInstanceCopyMethod(value);
     }
 
-    public Builder merge(ThirdPartyImmutableWithBuilderInstanceCopyMethod immutable) {
+    public Builder from(ThirdPartyImmutableWithBuilderInstanceCopyMethod immutable) {
       return setValue(immutable.getValue());
     }
   }

File: value-fixture/src/org/immutables/fixture/builder/attribute_builders/ThirdPartyImmutableWithValueClassCopyMethod.java
Patch:
@@ -11,14 +11,15 @@ public static Builder generateNewBuilder() {
     return new Builder();
   }
 
-  public static Builder geterateNewBuilderFrom(ThirdPartyImmutableWithValueClassCopyMethod third) {
+  public static Builder generateNewBuilder(ThirdPartyImmutableWithValueClassCopyMethod third) {
     return generateNewBuilder().setValue(third.getValue());
   }
 
 
   public String getValue() {
     return value;
   }
+
   public static class Builder {
 
     private String value;

File: value-fixture/src/org/immutables/fixture/builder/detection/NewTokenAttributeBuilderParent.java
Patch:
@@ -6,7 +6,7 @@
 @Immutable
 @Style(
     attributeBuilderDetection = true,
-    attributeBuilder = {"*Builder", "builder", "new"}
+    attributeBuilder = {"Builder", "*Builder", "builder", "from", "build", "*Build", "new"}
 )
 public abstract class NewTokenAttributeBuilderParent implements NestedDetection{
 }

File: value-fixture/src/org/immutables/fixture/builder/detection/NoNewTokenAttributeBuilderParent.java
Patch:
@@ -6,7 +6,7 @@
 @Immutable
 @Style(
     attributeBuilderDetection = true,
-    attributeBuilder = {"*Builder", "builder"}
+    attributeBuilder = {"Builder", "*Builder", "builder", "from", "build", "*Build"}
 )
 public abstract class NoNewTokenAttributeBuilderParent implements NestedDetection {
 }

File: value-fixture/src/org/immutables/fixture/builder/functional/AttributeBuilderBuilderI.java
Patch:
@@ -1,6 +1,7 @@
 package org.immutables.fixture.builder.functional;
 
 import java.util.List;
+
 import org.immutables.fixture.builder.attribute_builders.FirstPartyImmutable;
 import org.immutables.fixture.builder.attribute_builders.FirstPartyImmutableWithDifferentStyle;
 import org.immutables.fixture.builder.attribute_builders.ImmutableFirstPartyImmutable;

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -227,7 +227,7 @@ private ValueMirrors() {}
 
     boolean transientDerivedFields() default true;
 
-    String[] attributeBuilder() default {"*Builder", "builder", "new"};
+    String[] attributeBuilder() default {"Builder", "*Builder", "builder", "from", "build", "*Build", "new"};
 
     String getBuilder() default "*Builder";
 

File: value-processor/src/org/immutables/value/processor/meta/ValueType.java
Patch:
@@ -577,7 +577,8 @@ public boolean isUseInterned() {
 
   public boolean isUsePrehashed() {
     return immutableFeatures.prehash()
-        && !isGeneratePrivateNoargConstructor();
+        && !isGeneratePrivateNoargConstructor()
+        && !getEquivalenceAttributes().isEmpty();
   }
 
   public InnerBuilderDefinition getInnerBuilder() {

File: mongo/src/org/immutables/mongo/repository/internal/Constraints.java
Patch:
@@ -18,8 +18,10 @@
 import com.google.common.base.CharMatcher;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Range;
-import java.util.regex.Pattern;
+
 import javax.annotation.Nullable;
+import java.util.regex.Pattern;
+
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 

File: mongo/test/org/immutables/mongo/bson4gson/BsonDecimal128Test.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.mongo.repository.internal;
+package org.immutables.mongo.bson4gson;
 
 import com.google.gson.JsonObject;
 import com.google.gson.stream.JsonReader;

File: mongo/test/org/immutables/mongo/bson4gson/BsonNumbersTest.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.mongo.repository.internal;
+package org.immutables.mongo.bson4gson;
 
 import com.google.gson.JsonObject;
 import org.bson.BsonDocument;

File: mongo/test/org/immutables/mongo/bson4gson/BsonReaderTest.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.mongo.repository.internal;
+package org.immutables.mongo.bson4gson;
 
 import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;

File: mongo/test/org/immutables/mongo/bson4gson/BsonWriterTest.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.mongo.repository.internal;
+package org.immutables.mongo.bson4gson;
 
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;

File: mongo/test/org/immutables/mongo/bson4gson/Jsons.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.mongo.repository.internal;
+package org.immutables.mongo.bson4gson;
 
 import com.google.gson.JsonObject;
 import com.google.gson.internal.bind.TypeAdapters;
@@ -10,6 +10,8 @@
 import org.bson.codecs.DecoderContext;
 import org.bson.codecs.EncoderContext;
 import org.bson.io.BasicOutputBuffer;
+import org.immutables.mongo.bson4gson.BsonReader;
+import org.immutables.mongo.bson4gson.BsonWriter;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;

File: mongo/test/org/immutables/mongo/repository/internal/SupportTest.java
Patch:
@@ -1,6 +1,6 @@
 package org.immutables.mongo.repository.internal;
 
-import com.google.gson.internal.bind.DateTypeAdapter;
+import org.bson.codecs.DateCodec;
 import org.junit.Test;
 
 import java.util.Date;
@@ -20,7 +20,7 @@ public void unwrapPrimitives() throws Exception {
   @Test
   public void unwrapObject() throws Exception {
     Date date = new Date();
-    Support.Adapted<Date> adapted = new Support.Adapted<>(new DateTypeAdapter(), date);
+    Support.Adapted<Date> adapted = new Support.Adapted<>(new DateCodec(), date);
     Object result = Support.unwrapBsonable(adapted);
     check(result.toString()).isNonEmpty();
   }

File: testing/src/org/immutables/check/IterableChecker.java
Patch:
@@ -70,8 +70,8 @@ public final void isOf(T... elements) {
     verifyUsingMatcher(Matchers.contains(elements));
   }
 
-  public void hasContentInAnyOrder(Iterable<?> elements) {
-    verifyUsingMatcher((Matcher<? super Z>) Matchers.containsInAnyOrder(ImmutableList.copyOf(elements)));
+  public void hasContentInAnyOrder(Iterable<? extends T> elements) {
+    verifyUsingMatcher(Matchers.containsInAnyOrder(Iterables.toArray(elements, Object.class)));
   }
 
   @SafeVarargs

File: testing/src/org/immutables/check/IterableChecker.java
Patch:
@@ -70,7 +70,7 @@ public final void isOf(T... elements) {
     verifyUsingMatcher(Matchers.contains(elements));
   }
 
-  public void hasContentInAnyOrder(Iterable<T> elements) {
+  public void hasContentInAnyOrder(Iterable<? extends T> elements) {
     verifyUsingMatcher(Matchers.containsInAnyOrder(Iterables.toArray(elements, Object.class)));
   }
 

File: testing/src/org/immutables/check/IterableChecker.java
Patch:
@@ -71,7 +71,7 @@ public final void isOf(T... elements) {
   }
 
   public void hasContentInAnyOrder(Iterable<?> elements) {
-    verifyUsingMatcher((Matcher<? super Z>) Matchers.containsInAnyOrder(ImmutableList.copyOf(elements)));
+    verifyUsingMatcher(Matchers.containsInAnyOrder(ImmutableList.copyOf(elements).toArray()));
   }
 
   @SafeVarargs

File: value/src/org/immutables/value/Value.java
Patch:
@@ -835,10 +835,11 @@
 
     /**
      * Enabling {@code attributelessSingleton} switches to old behavior of 2.0.x version when
-     * immutables wich had no attributes defined acted as .
+     * immutables wich had no attributes defined acted as automatic singletons having
+     * {@link #instance()} accessor.
      * As of 2.1 we are more strict and explicit with singletons and are not generating it by
      * default, only when {@link Immutable#singleton()} is explicitly enabled.
-     * @return {@code true} no attribute immutables will be auto-singletons.
+     * @return {@code true} if auto singleton on new attributes (default is {@code false})
      */
     boolean attributelessSingleton() default false;
 

File: value-processor/test/org/immutables/value/processor/encode/TypeTest.java
Patch:
@@ -64,6 +64,7 @@ public void parseIngoreTypeAnnotationWithParameters() {
     check(parser.parse("java.lang.@javax.validation.constraints.Size(max = 10)String")).is(Reference.STRING);
     check(parser.parse("java.lang.@javax.validation.constraints.Size(max = 10, @A(a=@B(b=1))) String")).is(Reference.STRING);
     check(parser.parse("@Ann(\"b\") int")).is(Primitive.INT);
+    check(parser.parse("(@javax.validation.constraints.NotNull :: java.lang.String)")).is(Reference.STRING);
   }
 
   @Test

File: value-processor/test/org/immutables/value/processor/encode/TypeTest.java
Patch:
@@ -64,6 +64,7 @@ public void parseIngoreTypeAnnotationWithParameters() {
     check(parser.parse("java.lang.@javax.validation.constraints.Size(max = 10)String")).is(Reference.STRING);
     check(parser.parse("java.lang.@javax.validation.constraints.Size(max = 10, @A(a=@B(b=1))) String")).is(Reference.STRING);
     check(parser.parse("@Ann(\"b\") int")).is(Primitive.INT);
+    check(parser.parse("(@javax.validation.constraints.NotNull :: java.lang.String)")).is(Reference.STRING);
   }
 
   @Test

File: value-processor/src/org/immutables/value/processor/encode/Type.java
Patch:
@@ -759,6 +759,7 @@ Type type() {
             // just consume type annotation
             terms.poll();
             named();
+            consumeAnnotationParameters();
             consumeErraticTrailingComma();
             // and try again, yep, recursively...
             return type();

File: value-processor/test/org/immutables/value/processor/encode/TypeTest.java
Patch:
@@ -63,6 +63,7 @@ public void parseIngoreTypeAnnotation() {
   public void parseIngoreTypeAnnotationWithParameters() {
     check(parser.parse("java.lang.@javax.validation.constraints.Size(max = 10)String")).is(Reference.STRING);
     check(parser.parse("java.lang.@javax.validation.constraints.Size(max = 10, @A(a=@B(b=1))) String")).is(Reference.STRING);
+    check(parser.parse("@Ann(\"b\") int")).is(Primitive.INT);
   }
 
   @Test

File: value-fixture/src/org/immutables/fixture/CustomInternedNormalized.java
Patch:
@@ -25,8 +25,8 @@ abstract class BaseInterned<T extends BaseInterned<T>> {
 
   @SuppressWarnings("unchecked")
   @Value.Check
-  protected String intern() {
-    return "";// INTERNER.intern(this);
+  protected T intern() {
+    return (T) INTERNER.intern(this);
   }
 }
 

File: mongo/src/org/immutables/mongo/repository/internal/BsonWriter.java
Patch:
@@ -162,6 +162,9 @@ public com.google.gson.stream.JsonWriter value(Number value) throws IOException
     if (value instanceof Short) {
       return value(value.shortValue());
     }
+    if (value instanceof Byte) {
+     return value(value.byteValue());
+    }
     if (value instanceof LazilyParsedNumber) {
       return value(value.longValue());
     }

File: mongo/test/org/immutables/mongo/repository/internal/BsonWriterTest.java
Patch:
@@ -33,6 +33,7 @@ public void objects() throws Exception {
   @Test
   public void customTypes() throws Exception {
     JsonObject obj = new JsonObject();
+    obj.addProperty("byte", (byte) 1);
     obj.addProperty("short", (short) 4);
     obj.addProperty("int", 2222);
     obj.addProperty("long", 1111L);

File: value-fixture/test/org/immutables/fixture/jackson/FieldConflictTest.java
Patch:
@@ -85,9 +85,6 @@ public void customDummyWithDefaultObjectMapper() throws IOException {
     verifyRoundTrip(getMapper(false), ImmutableCustomDummy.of(true));
   }
 
-  // Fails: Unrecognized field "isSomeProperty" (class
-// com.picnic.fulfillment.model.ImmutableCustomDummy$Json), not marked as ignorable (one known
-// property: "custom_name"])
   @Test
   public void customDummyWithCustomObjectMapper() throws IOException {
     verifyRoundTrip(getMapper(true), ImmutableCustomDummy.of(true));
@@ -98,6 +95,7 @@ public void dummyWithMetaAnnotationWithDefaultObjectMapper() throws IOException
     verifyRoundTrip(getMapper(false), ImmutableDummyWithMetaAnnotation.of(true));
   }
 
+  @Test
   public void dummyWithMetaAnnotationWithCustomObjectMapper() throws IOException {
     verifyRoundTrip(getMapper(true), ImmutableDummyWithMetaAnnotation.of(true));
   }

File: value-processor/src/org/immutables/value/processor/AbstractValuesTemplate.java
Patch:
@@ -1,6 +1,7 @@
 package org.immutables.value.processor;
 
 import com.google.common.base.Function;
+import com.google.common.collect.ImmutableList;
 import org.immutables.generator.AbstractTemplate;
 import org.immutables.generator.Generator;
 import org.immutables.generator.Templates;
@@ -33,6 +34,8 @@ public abstract class AbstractValuesTemplate extends AbstractTemplate {
   @Generator.Typedef
   protected DeclaringPackage Package;
 
+  protected final ImmutableList<ValueAttribute> noAttributes = ImmutableList.of();
+
   protected final String guava = UnshadeGuava.prefix();
 
   protected final LongBits longsFor = new LongBits();

File: value-processor/src/org/immutables/value/processor/encode/Mirrors.java
Patch:
@@ -47,6 +47,9 @@ interface Mirrors {
   @Mirror.Annotation("org.immutables.encode.Encoding.Init")
   @interface Init {}
 
+  @Mirror.Annotation("org.immutables.encode.Encoding.IsInit")
+  @interface IsInit {}
+
   @Mirror.Annotation("org.immutables.encode.Encoding.Builder")
   @interface Builder {}
 

File: value/src/org/immutables/value/Value.java
Patch:
@@ -88,7 +88,7 @@
 
     /**
      * If {@code prehash=true} then {@code hashCode} will be precomputed during construction.
-     * This could speed up collection lookups for objects with lots of attributes and nested
+     * This could speed up map/set lookups for objects with lots of attributes and nested
      * objects.
      * In general, use this when {@code hashCode} computation is expensive and will be used a lot.
      * Note that if {@link Style#privateNoargConstructor()} == <code>true</code> this option will be

File: value-fixture/test/org/immutables/fixture/builder/AttributeBuilderTest.java
Patch:
@@ -59,7 +59,7 @@ public void basicApiForSamePackageParent() {
   }
 
   // Allows sharing tests between guava collections, jdk only collections and whatever other combinations are needed.
-  private <ImmutableClassT extends AttributeBuilderValueI, AbstractClassT extends AttributeBuilderValueI>
+  private static <ImmutableClassT extends AttributeBuilderValueI, AbstractClassT extends AttributeBuilderValueI>
   void assertBasicApi(Class<ImmutableClassT> immutableType, Class<AbstractClassT> returnType,
       CopyFunction<ImmutableClassT, AbstractClassT> copyFunction,
       BuilderFunction<AbstractClassT> newBuilder) {

File: value-fixture/test/org/immutables/fixture/jackson/FieldConflictTest.java
Patch:
@@ -112,15 +112,15 @@ public void customDummyWithMetaAnnotationWithCustomObjectMapper() throws IOExcep
     verifyRoundTrip(getMapper(true), ImmutableCustomDummyWithMetaAnnotation.of(true));
   }
 
-  private ObjectMapper getMapper(final boolean useFields) {
+  private static ObjectMapper getMapper(final boolean useFields) {
     final ObjectMapper mapper = new ObjectMapper();
     return useFields
         ? mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.NONE)
             .setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY)
         : mapper;
   }
 
-  private void verifyRoundTrip(final ObjectMapper mapper, final Object value) throws IOException {
+  private static void verifyRoundTrip(final ObjectMapper mapper, final Object value) throws IOException {
     final String json = mapper.writeValueAsString(value);
     final Object newValue = mapper.readValue(json, value.getClass());
     check(newValue).is(value);

File: value-fixture/test/org/immutables/fixture/jdkonly/JdkOptionalTest.java
Patch:
@@ -93,13 +93,13 @@ public void serializeRegular() throws Exception {
     check(o1.hashCode()).is(o0.hashCode());
   }
 
-  private Serializable deserialize(byte[] bytes) throws Exception {
+  private static Serializable deserialize(byte[] bytes) throws Exception {
     ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
     ObjectInputStream objectStream = new ObjectInputStream(stream);
     return (Serializable) objectStream.readObject();
   }
 
-  private byte[] serialize(Serializable instance) throws Exception {
+  private static byte[] serialize(Serializable instance) throws Exception {
     ByteArrayOutputStream stream = new ByteArrayOutputStream();
     ObjectOutputStream objectStream = new ObjectOutputStream(stream);
     objectStream.writeObject(instance);

File: value-fixture/test/org/immutables/fixture/marshal/MarshallingTest.java
Patch:
@@ -129,11 +129,11 @@ public void marshalAndUnmarshalGeneratedType() {
     check(Marshaling.fromJson(Marshaling.toJson(structure), SillyStructure.class)).is(structure);
   }
 
-  private <T> List<T> fromJsonIterable(String json, TypeToken<List<T>> typeToken) {
+  private static <T> List<T> fromJsonIterable(String json, TypeToken<List<T>> typeToken) {
     return Marshaling.getGson().fromJson(json, typeToken.getType());
   }
 
-  private <T> String toJsonIterable(List<? extends T> list, TypeToken<List<T>> typeToken) {
+  private static <T> String toJsonIterable(List<? extends T> list, TypeToken<List<T>> typeToken) {
     return Marshaling.getGson().toJson(list, typeToken.getType());
   }
 }

File: value-fixture/test/org/immutables/fixture/serial/SerialTest.java
Patch:
@@ -71,13 +71,13 @@ public void copySerialVersionModifiable() throws Exception {
     check(false);
   }
 
-  private Serializable deserialize(byte[] bytes) throws Exception {
+  private static Serializable deserialize(byte[] bytes) throws Exception {
     ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
     ObjectInputStream objectStream = new ObjectInputStream(stream);
     return (Serializable) objectStream.readObject();
   }
 
-  private byte[] serialize(Serializable instance) throws Exception {
+  private static byte[] serialize(Serializable instance) throws Exception {
     ByteArrayOutputStream stream = new ByteArrayOutputStream();
     ObjectOutputStream objectStream = new ObjectOutputStream(stream);
     objectStream.writeObject(instance);

File: value-fixture/test/org/immutables/metainf/fixture/ServiceTest.java
Patch:
@@ -34,7 +34,7 @@ public void serviceSets() {
     check(sortedToStringsFrom(ServiceLoader.load(AutoCloseable.class))).isOf("NestedService.Service");
   }
 
-  private TreeSet<String> sortedToStringsFrom(Iterable<?> iterable) {
+  private static TreeSet<String> sortedToStringsFrom(Iterable<?> iterable) {
     return Sets.newTreeSet(FluentIterable.from(iterable).transform(Functions.toStringFunction()));
   }
 }

File: mongo/test/org/immutables/mongo/fixture/GenValtem.java
Patch:
@@ -15,12 +15,14 @@
  */
 package org.immutables.mongo.fixture;
 
+import org.immutables.gson.Gson;
 import org.immutables.mongo.Mongo;
 import org.immutables.mongo.fixture.imp.Valtem;
 import org.immutables.mongo.repository.RepositorySetup;
 import org.immutables.value.Value;
 
 @Mongo.Repository
+@Gson.TypeAdapters
 @Value.Include(Valtem.class)
 enum GenValtem {
   ;

File: mongo/test/org/immutables/mongo/fixture/flags/package-info.java
Patch:
@@ -17,4 +17,5 @@
 /**
  * Tests repositories with various flags (readonly, index etc.)
  */
+@org.immutables.gson.Gson.TypeAdapters
 package org.immutables.mongo.fixture.flags;

File: mongo/test/org/immutables/mongo/types/InternalTypesTest.java
Patch:
@@ -7,9 +7,9 @@
 import org.immutables.value.Value;
 import org.junit.Rule;
 import org.junit.Test;
-
 import static org.immutables.check.Checkers.check;
 
+@Gson.TypeAdapters
 public class InternalTypesTest {
   @Rule
   public final MongoContext context = MongoContext.create();
@@ -34,7 +34,6 @@ public void readWrite() throws Exception {
 
   @Mongo.Repository
   @Value.Immutable
-  @Gson.TypeAdapters
   interface InternalTypes {
     @Mongo.Id
     ObjectId objectId();

File: value-fixture/src/org/immutables/fixture/AllMandatoryParams.java
Patch:
@@ -28,6 +28,7 @@ default String c() {
     return "C";
   }
 
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     ImmutableAllMandatoryParams.of(1, true).withC("ABC");
   }

File: value-fixture/src/org/immutables/fixture/CancelParam.java
Patch:
@@ -33,6 +33,7 @@ public interface CancelParam extends Param {
   @Value.Parameter(false)
   List<Integer> aux();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableCancelParam.of(1).withAux(1, 2, 3);
   }

File: value-fixture/src/org/immutables/fixture/DeprecateType.java
Patch:
@@ -21,6 +21,7 @@
 @Deprecated
 interface DeprecateType {
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableDeprecateType.of();
   }

File: value-fixture/src/org/immutables/fixture/DerivedNotInConstructor.java
Patch:
@@ -37,6 +37,7 @@ public int totalLength() {
     return length;
   }
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     ImmutableDerivedNotInConstructor.of(Arrays.asList("a", "b", "c"));
   }
@@ -53,6 +54,7 @@ public int b() {
     return 1;
   }
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     ImmutableDerivedNotInConstructorSimpleCons.of(1);
   }

File: value-fixture/src/org/immutables/fixture/ExtendingInnerBuilderValue.java
Patch:
@@ -26,6 +26,7 @@ static class Builder {
     void hello() {}
   }
 
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     ImmutableSuperInnerBuildeValue.builder().hello();
   }
@@ -64,6 +65,7 @@ public ExtendingInnerCreatorValue create() {
     }
   }
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableExtendingInnerCreatorValue.Creator c = new ImmutableExtendingInnerCreatorValue.Creator();
     c.create();

File: value-fixture/src/org/immutables/fixture/ExtraCollection.java
Patch:
@@ -44,6 +44,7 @@ public interface ExtraCollection {
   @Value.Parameter
   BiMap<Integer, String> biMap();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableExtraCollection.of(
         ImmutableList.<String>of(),

File: value-fixture/src/org/immutables/fixture/InheritConstructorParameter.java
Patch:
@@ -27,6 +27,7 @@ abstract class HasParam {
   @Value.Immutable
   abstract class ExtendsIt extends HasParam {}
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableExtendsIt.of(1);
   }

File: value-fixture/src/org/immutables/fixture/OptionalCast.java
Patch:
@@ -27,6 +27,7 @@ public interface OptionalCast {
 
   Optional<String[]> getStringArray();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableOptionalCast.of(
         Optional.absent(),

File: value-fixture/src/org/immutables/fixture/OptionalOfOptionalRegular.java
Patch:
@@ -23,6 +23,7 @@
 public interface OptionalOfOptionalRegular<T> {
   Option<Optional<T>> optionalOfOptional();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableOptionalOfOptionalRegular.<Void>builder()
         .optionalOfOptional(Option.some(Optional.<Void>absent()))

File: value-fixture/src/org/immutables/fixture/PrivateNoargConstructor.java
Patch:
@@ -74,6 +74,7 @@ default int test() {
     return 1;
   }
   
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutablePrivateNoargConstructorIsOverriddenBySingleton.of();
   }

File: value-fixture/src/org/immutables/fixture/UseImmutableCollections.java
Patch:
@@ -53,6 +53,7 @@ public interface UseImmutableCollections {
 
   ImmutableListMultimap<String, Integer> listMultimap();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
 
     ImmutableUseImmutableCollections.builder()

File: value-fixture/src/org/immutables/fixture/ast/InstantiationGenerics.java
Patch:
@@ -38,6 +38,7 @@ interface StringNode extends Node<String> {}
   @Value.Immutable
   interface StringLeaf extends Leaf<String> {}
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     TreeElement<String> tree =
         ImmutableStringNode.builder()

File: value-fixture/src/org/immutables/fixture/couse/AbstractB.java
Patch:
@@ -24,6 +24,7 @@ interface AbstractB {
 
   Optional<A> aO();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     B b = B.builder()
         .a(A.builder().build())

File: value-fixture/src/org/immutables/fixture/couse/sub/AbstractC.java
Patch:
@@ -45,6 +45,7 @@ interface AbstractC {
 
   Map<RetentionPolicy, C> raM();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     C c = C.builder()
         .a(A.builder().build())

File: value-fixture/src/org/immutables/fixture/custann/CustomEncl.java
Patch:
@@ -24,6 +24,7 @@ public interface CustomEncl {
   @CustomWithEncStyle
   interface Cuzt {}
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     JeNcCustomEncl.Cuzt.builder();
   }

File: value-fixture/src/org/immutables/fixture/custann/CustomImmutables.java
Patch:
@@ -23,6 +23,7 @@ interface Od {}
   @CustomWithStyle2
   interface Dv {}
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     CustoOd.builder().build();
     JcIvDv.builder().build();

File: value-fixture/src/org/immutables/fixture/deep/Canvas.java
Patch:
@@ -55,6 +55,7 @@ public interface Point {
     int y();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableLine line = ImmutableLine.builder()
         .color(0.9, 0.7, 0.4)

File: value-fixture/src/org/immutables/fixture/deep/DeepAndJdkOnly.java
Patch:
@@ -48,6 +48,7 @@ interface Container {
 
   // Compile validation of generation of immutable return type and builder initializer by
   // constructor-args .
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     ImmutableContainer c = ImmutableContainer.builder().deep(1, 2).build();
     ImmutableDeep deep = c.getDeep();

File: value-fixture/src/org/immutables/fixture/generics/RawType.java
Patch:
@@ -29,6 +29,7 @@ public interface RawType {
 
   Map map();
 
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     ImmutableRawType.builder()
         .set(Collections.emptySet())

File: value-fixture/src/org/immutables/fixture/jackson/KeywordNames.java
Patch:
@@ -26,6 +26,7 @@ public interface KeywordNames {
 
   boolean isDefault();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableKeywordNames names = ImmutableKeywordNames.builder()
         .setDefault(true)

File: value-fixture/src/org/immutables/fixture/jackson/MetaJacksonAnnotation.java
Patch:
@@ -30,7 +30,7 @@ interface Val {
   // compile check for presense of
   // the Jackson specific creator method
   // triggered by meta annotation
-  @SuppressWarnings("deprecation")
+  @SuppressWarnings({"deprecation", "CheckReturnValue"})
   default void use() {
     ImmutableVal.fromJson(null);
   }

File: value-fixture/src/org/immutables/fixture/jdkonly/JdkOptionalBuilderFactory.java
Patch:
@@ -31,6 +31,7 @@ public static int bbz(@Builder.Parameter java.util.Optional<String> b, @Builder.
     return b.hashCode() + c.hashCode();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     new ApplBuilder()
         .a(1)

File: value-fixture/src/org/immutables/fixture/jdkonly/UsingAllOptionals.java
Patch:
@@ -52,6 +52,7 @@ public interface UsingAllOptionals {
   javaslang.control.Option<String> jso();
 
   class Use {
+    @SuppressWarnings("CheckReturnValue")
     void use() {
       UsingAllOptionals value =
           ImmutableUsingAllOptionals.builder()

File: value-fixture/src/org/immutables/fixture/modifiable/CreateFromDetect.java
Patch:
@@ -31,6 +31,7 @@ interface Bbb {
     int zzz();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ModifiableAaa.create()
         .setBbb(ModifiableBbb.create());

File: value-fixture/src/org/immutables/fixture/modifiable/ToImmutableCopyFalse.java
Patch:
@@ -23,6 +23,7 @@ public interface ToImmutableCopyFalse {
   @Value.Immutable(copy = false)
   public interface A {
 
+    @SuppressWarnings("CheckReturnValue")
     default void use() {
       ModifiableA.create().toImmutable();
     }
@@ -33,6 +34,7 @@ default void use() {
   @Value.Style(strictBuilder = true)
   public interface B {
 
+    @SuppressWarnings("CheckReturnValue")
     default void use() {
       ModifiableB.create().toImmutable();
     }
@@ -44,6 +46,7 @@ public interface C {
     @Value.Parameter
     int c();
 
+    @SuppressWarnings("CheckReturnValue")
     default void use() {
       ModifiableC.create().toImmutable();
     }

File: value-fixture/src/org/immutables/fixture/packoutput/Packs.java
Patch:
@@ -32,6 +32,7 @@ public abstract class Packs {
   @Value.Immutable
   public interface Perk {}
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     borg.immutables.fixture.packoutput.impl.ImmutablePacks.builder().build();
     borg.immutables.fixture.packoutput.impl.ImmutablePacks.Perk.builder().build();

File: value-fixture/src/org/immutables/fixture/style/AbstractValueNamingDetected.java
Patch:
@@ -42,6 +42,7 @@ abstract class AbstractValueNamingDetected {
 
   abstract Set<String> collectStr();
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     ValueNamingDetected.newBuilder()
         .usingVal(1)

File: value-fixture/src/org/immutables/fixture/style/BeanStyleDetected.java
Patch:
@@ -25,6 +25,7 @@ abstract class BeanStyleDetected {
 
   abstract List<String> getEm();
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     ImmutableBeanStyleDetected.builder()
         .setIt(1)

File: value-fixture/src/org/immutables/fixture/style/ConservativeStyleDetected.java
Patch:
@@ -27,6 +27,7 @@ abstract class ConservativeStyleDetected {
 
   abstract String getString();
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     new ConservativeStyleDetectedBuilder()
         .setValue(1)

File: value-fixture/src/org/immutables/fixture/style/Depluralize.java
Patch:
@@ -43,6 +43,7 @@ public interface Depluralize {
 
   Multiset<Boolean> goods();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableDepluralize.builder()
         .addBoat("") // automatically trims s

File: value-fixture/src/org/immutables/fixture/style/EnclosingBuilderNew.java
Patch:
@@ -32,6 +32,7 @@ public abstract class EnclosingBuilderNew {
   @Value.Immutable
   public static class Hidden {}
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     new ImmutableEnclosingBuilderNew.HiddenBuilder().build();
   }

File: value-fixture/src/org/immutables/fixture/style/EnclosingHiddenImplementation.java
Patch:
@@ -55,6 +55,7 @@ public static abstract class VisibleImplementation {
     public abstract Optional<Integer> cons();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     EnclosingFactory.HiddenImplementationBuilder.create().build();
 

File: value-fixture/src/org/immutables/fixture/style/HaveBuilderNew.java
Patch:
@@ -22,6 +22,7 @@
 public interface HaveBuilderNew {
   int a();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     new ImmutableHaveBuilderNew.Builder().build();
   }

File: value-fixture/src/org/immutables/fixture/style/HiddenImplementation.java
Patch:
@@ -30,6 +30,7 @@
 @Value.Style(visibility = ImplementationVisibility.PRIVATE)
 public class HiddenImplementation {
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     HiddenImplementation instance = new HiddenImplementationBuilder().build();
     instance.toString();

File: value-fixture/src/org/immutables/fixture/style/IncludeTypes.java
Patch:
@@ -32,6 +32,7 @@
 @Value.Immutable
 public class IncludeTypes {
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     // this immutable type (package style used)
     ImIncludeTypes.builder().build();

File: value-fixture/src/org/immutables/fixture/style/LessVisibleImplementation.java
Patch:
@@ -29,6 +29,7 @@
 @Value.Style(visibility = ImplementationVisibility.PACKAGE)
 public class LessVisibleImplementation {
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     ImmutableLessVisibleImplementation.Builder lessVisibleBuilder = ImmutableLessVisibleImplementation.builder();
     ImmutableLessVisibleImplementation lessVisibleImplementation = lessVisibleBuilder.build();

File: value-fixture/src/org/immutables/fixture/style/NestingClassOrBuilder.java
Patch:
@@ -34,6 +34,7 @@ interface ImplNestedInBuild {}
       builderVisibility = BuilderVisibility.PACKAGE)
   interface NonPublicBuild {}
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImplNestedInBuildBuilder builder = new ImplNestedInBuildBuilder();
     ImplNestedInBuild abstractValue = builder.build();

File: value-fixture/src/org/immutables/fixture/style/OutsideBuildable.java
Patch:
@@ -45,6 +45,7 @@ void use() {
 @Value.Style(newBuilder = "newBuilder", visibility = ImplementationVisibility.PRIVATE)
 class OutsideBuildableNew {
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     OutsideBuildableNewBuilder.newBuilder().build();
   }

File: value-fixture/src/org/immutables/fixture/style/Tuple.java
Patch:
@@ -30,6 +30,7 @@ interface Color {
   int green();
   int blue();
   
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ColorTuple.of(0xFF, 0x00, 0xFE);
   }
@@ -48,7 +49,8 @@ default int gray() {
     return black() - gray();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     OverrideColorTuple.of(0xFF, 0x00);
   }
-}
\ No newline at end of file
+}

File: value-fixture/src/org/immutables/fixture/style/depl/DepluralizeMergeDictionary.java
Patch:
@@ -45,6 +45,7 @@ interface Inner {
     Multiset<Boolean> goods();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableInner.builder()
         .addBoat("") // automatically trims s

File: value-fixture/src/org/immutables/fixture/style/nested/PackageStyleFromParent.java
Patch:
@@ -28,6 +28,7 @@ interface Val {
   }
 
   /** Generated API dictated by parent package's style. */
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     ImVal.builder().a(1).build().copyWithA(2);
   }

File: value-fixture/src/org/immutables/fixture/style/nested/nest/PackageStyleFromAncestor.java
Patch:
@@ -28,6 +28,7 @@ interface Baj {
   }
 
   /** Generated API dictated by parent package's style. */
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     ImBaj.builder().a(1).build().copyWithA(2);
   }

File: value-fixture/src/org/immutables/fixture/with/Copied.java
Patch:
@@ -37,6 +37,7 @@ public abstract class Copied implements WithCopied {
 
   public static class Builder extends ImmutableCopied.Builder {}
 
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     new Copied.Builder()
         .attr(1)

File: value-fixture/src/org/immutables/fixture/with/Enc.java
Patch:
@@ -43,6 +43,7 @@ interface Suppied<T extends Number> extends ImmutableEnc.WithSuppied<T> {
     class Builder<T extends Number> extends ImmutableEnc.Suppied.Builder<T> {}
   }
 
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     new Suppied.Builder<Long>()
         .a("a")

File: value-fixture/test/org/immutables/fixture/PrivateDefaultConstructorTest.java
Patch:
@@ -26,6 +26,7 @@ public void testNominal() throws Exception {
     ImmutablePrivateNoargConstructorNominal.class.getDeclaredConstructor();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = NoSuchMethodException.class)
   public void testOverridePrehash() throws Exception {
     ImmutablePrivateNoargConstructorOverridePrehash.class.getDeclaredMethod("computeHashCode");

File: value-fixture/test/org/immutables/fixture/SafeInitTest.java
Patch:
@@ -20,6 +20,7 @@
 
 public class SafeInitTest {
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void cycles() {
     try {
       ImmutableSafeInitIface.builder().build();

File: value-fixture/test/org/immutables/fixture/VeryManyAttributesTest.java
Patch:
@@ -19,6 +19,7 @@
 
 public class VeryManyAttributesTest {
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void builableWhenAllSet() {
     ImmutableHugeInterface.builder()
         .number0_0(1)
@@ -94,6 +95,7 @@ public void builableWhenAllSet() {
         .build();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = IllegalStateException.class)
   public void noInitBuildOverflow() {
     ImmutableHugeInterface.builder()
@@ -171,6 +173,7 @@ public void noInitBuildOverflow() {
   }
   
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void noOccupationOverflow() {
     ImmutableHugeOccupationOverflow.builder()
         .number0(0)

File: value-fixture/test/org/immutables/fixture/annotation/AnnotationTest.java
Patch:
@@ -35,6 +35,7 @@ public void ann() {
   }
 
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void bee() {
     ImmutableHasDefault.of(1).withOtherValue("w");
 

File: value-fixture/test/org/immutables/fixture/builder/AccessBuilderFieldsTest.java
Patch:
@@ -21,6 +21,7 @@
 
 public class AccessBuilderFieldsTest {
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void accessFields() {
     new AccessBuilderFields.Builder()
         .a(1)

File: value-fixture/test/org/immutables/fixture/generatorext/RewriteTest.java
Patch:
@@ -18,6 +18,7 @@
 import org.junit.Test;
 
 public class RewriteTest {
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = IllegalArgumentException.class)
   public void rewrite() {
     // Our changed preconditions will be able to throw IllegalArgumentException

File: value-fixture/test/org/immutables/fixture/modifiable/ClearBuilderTest.java
Patch:
@@ -20,6 +20,7 @@
 
 public class ClearBuilderTest {
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void clear() {
     ImmutableClearBuilder.Builder builder = ImmutableClearBuilder.builder()
         .a(true)

File: value-fixture/test/org/immutables/fixture/nullable/NullableAttributesTest.java
Patch:
@@ -101,6 +101,7 @@ public void compactConstruction() {
     check(ImmutableNullableCompact.of(null, null)).is(c1);
   }
 
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = NullPointerException.class)
   public void nonnullDefaultBlowupOnNull() {
     ImmutableNonnullConstruction.builder()

File: value-fixture/test/org/immutables/fixture/strict/StrictBuilderTest.java
Patch:
@@ -19,6 +19,7 @@
 import org.junit.Test;
 
 public class StrictBuilderTest {
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = IllegalStateException.class)
   public void noReassignment() {
     ImmutableAar.builder()
@@ -28,6 +29,7 @@ public void noReassignment() {
         .build();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = IllegalStateException.class)
   public void noReassignmentOptional() {
     ImmutableBar.builder()

File: value-fixture/test/org/immutables/fixture/style/SpecifiedExceptionTest.java
Patch:
@@ -20,11 +20,13 @@
 import nonimmutables.SampleRuntimeException;
 
 public class SpecifiedExceptionTest {
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = SampleRuntimeException.class)
   public void itThrowsExpectedConfiguredException() {
     ImmutableSpecifiedException.builder().build();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = IllegalArgumentException.class)
   public void itThrowsSpecifiedExceptionOnBuild() {
     ImmutableSpecifiedException.builder().buildOrThrow(IllegalArgumentException::new);

File: value-fixture/src/org/immutables/fixture/AllMandatoryParams.java
Patch:
@@ -28,6 +28,7 @@ default String c() {
     return "C";
   }
 
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     ImmutableAllMandatoryParams.of(1, true).withC("ABC");
   }

File: value-fixture/src/org/immutables/fixture/CancelParam.java
Patch:
@@ -33,6 +33,7 @@ public interface CancelParam extends Param {
   @Value.Parameter(false)
   List<Integer> aux();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableCancelParam.of(1).withAux(1, 2, 3);
   }

File: value-fixture/src/org/immutables/fixture/DeprecateType.java
Patch:
@@ -21,6 +21,7 @@
 @Deprecated
 interface DeprecateType {
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableDeprecateType.of();
   }

File: value-fixture/src/org/immutables/fixture/DerivedNotInConstructor.java
Patch:
@@ -37,6 +37,7 @@ public int totalLength() {
     return length;
   }
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     ImmutableDerivedNotInConstructor.of(Arrays.asList("a", "b", "c"));
   }
@@ -53,6 +54,7 @@ public int b() {
     return 1;
   }
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     ImmutableDerivedNotInConstructorSimpleCons.of(1);
   }

File: value-fixture/src/org/immutables/fixture/ExtendingInnerBuilderValue.java
Patch:
@@ -26,6 +26,7 @@ static class Builder {
     void hello() {}
   }
 
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     ImmutableSuperInnerBuildeValue.builder().hello();
   }
@@ -64,6 +65,7 @@ public ExtendingInnerCreatorValue create() {
     }
   }
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableExtendingInnerCreatorValue.Creator c = new ImmutableExtendingInnerCreatorValue.Creator();
     c.create();

File: value-fixture/src/org/immutables/fixture/ExtraCollection.java
Patch:
@@ -44,6 +44,7 @@ public interface ExtraCollection {
   @Value.Parameter
   BiMap<Integer, String> biMap();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableExtraCollection.of(
         ImmutableList.<String>of(),

File: value-fixture/src/org/immutables/fixture/InheritConstructorParameter.java
Patch:
@@ -27,6 +27,7 @@ abstract class HasParam {
   @Value.Immutable
   abstract class ExtendsIt extends HasParam {}
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableExtendsIt.of(1);
   }

File: value-fixture/src/org/immutables/fixture/OptionalCast.java
Patch:
@@ -27,6 +27,7 @@ public interface OptionalCast {
 
   Optional<String[]> getStringArray();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableOptionalCast.of(
         Optional.absent(),

File: value-fixture/src/org/immutables/fixture/OptionalOfOptionalRegular.java
Patch:
@@ -23,6 +23,7 @@
 public interface OptionalOfOptionalRegular<T> {
   Option<Optional<T>> optionalOfOptional();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableOptionalOfOptionalRegular.<Void>builder()
         .optionalOfOptional(Option.some(Optional.<Void>absent()))

File: value-fixture/src/org/immutables/fixture/PrivateNoargConstructor.java
Patch:
@@ -74,6 +74,7 @@ default int test() {
     return 1;
   }
   
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutablePrivateNoargConstructorIsOverriddenBySingleton.of();
   }

File: value-fixture/src/org/immutables/fixture/UseImmutableCollections.java
Patch:
@@ -53,6 +53,7 @@ public interface UseImmutableCollections {
 
   ImmutableListMultimap<String, Integer> listMultimap();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
 
     ImmutableUseImmutableCollections.builder()

File: value-fixture/src/org/immutables/fixture/ast/InstantiationGenerics.java
Patch:
@@ -38,6 +38,7 @@ interface StringNode extends Node<String> {}
   @Value.Immutable
   interface StringLeaf extends Leaf<String> {}
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     TreeElement<String> tree =
         ImmutableStringNode.builder()

File: value-fixture/src/org/immutables/fixture/couse/AbstractB.java
Patch:
@@ -24,6 +24,7 @@ interface AbstractB {
 
   Optional<A> aO();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     B b = B.builder()
         .a(A.builder().build())

File: value-fixture/src/org/immutables/fixture/couse/sub/AbstractC.java
Patch:
@@ -45,6 +45,7 @@ interface AbstractC {
 
   Map<RetentionPolicy, C> raM();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     C c = C.builder()
         .a(A.builder().build())

File: value-fixture/src/org/immutables/fixture/custann/CustomEncl.java
Patch:
@@ -24,6 +24,7 @@ public interface CustomEncl {
   @CustomWithEncStyle
   interface Cuzt {}
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     JeNcCustomEncl.Cuzt.builder();
   }

File: value-fixture/src/org/immutables/fixture/custann/CustomImmutables.java
Patch:
@@ -23,6 +23,7 @@ interface Od {}
   @CustomWithStyle2
   interface Dv {}
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     CustoOd.builder().build();
     JcIvDv.builder().build();

File: value-fixture/src/org/immutables/fixture/deep/Canvas.java
Patch:
@@ -55,6 +55,7 @@ public interface Point {
     int y();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableLine line = ImmutableLine.builder()
         .color(0.9, 0.7, 0.4)

File: value-fixture/src/org/immutables/fixture/deep/DeepAndJdkOnly.java
Patch:
@@ -48,6 +48,7 @@ interface Container {
 
   // Compile validation of generation of immutable return type and builder initializer by
   // constructor-args .
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     ImmutableContainer c = ImmutableContainer.builder().deep(1, 2).build();
     ImmutableDeep deep = c.getDeep();

File: value-fixture/src/org/immutables/fixture/generics/RawType.java
Patch:
@@ -29,6 +29,7 @@ public interface RawType {
 
   Map map();
 
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     ImmutableRawType.builder()
         .set(Collections.emptySet())

File: value-fixture/src/org/immutables/fixture/jackson/KeywordNames.java
Patch:
@@ -26,6 +26,7 @@ public interface KeywordNames {
 
   boolean isDefault();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableKeywordNames names = ImmutableKeywordNames.builder()
         .setDefault(true)

File: value-fixture/src/org/immutables/fixture/jackson/MetaJacksonAnnotation.java
Patch:
@@ -30,7 +30,7 @@ interface Val {
   // compile check for presense of
   // the Jackson specific creator method
   // triggered by meta annotation
-  @SuppressWarnings("deprecation")
+  @SuppressWarnings({"deprecation", "CheckReturnValue"})
   default void use() {
     ImmutableVal.fromJson(null);
   }

File: value-fixture/src/org/immutables/fixture/jdkonly/JdkOptionalBuilderFactory.java
Patch:
@@ -31,6 +31,7 @@ public static int bbz(@Builder.Parameter java.util.Optional<String> b, @Builder.
     return b.hashCode() + c.hashCode();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     new ApplBuilder()
         .a(1)

File: value-fixture/src/org/immutables/fixture/jdkonly/UsingAllOptionals.java
Patch:
@@ -52,6 +52,7 @@ public interface UsingAllOptionals {
   javaslang.control.Option<String> jso();
 
   class Use {
+    @SuppressWarnings("CheckReturnValue")
     void use() {
       UsingAllOptionals value =
           ImmutableUsingAllOptionals.builder()

File: value-fixture/src/org/immutables/fixture/modifiable/CreateFromDetect.java
Patch:
@@ -31,6 +31,7 @@ interface Bbb {
     int zzz();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ModifiableAaa.create()
         .setBbb(ModifiableBbb.create());

File: value-fixture/src/org/immutables/fixture/modifiable/ToImmutableCopyFalse.java
Patch:
@@ -23,6 +23,7 @@ public interface ToImmutableCopyFalse {
   @Value.Immutable(copy = false)
   public interface A {
 
+    @SuppressWarnings("CheckReturnValue")
     default void use() {
       ModifiableA.create().toImmutable();
     }
@@ -33,6 +34,7 @@ default void use() {
   @Value.Style(strictBuilder = true)
   public interface B {
 
+    @SuppressWarnings("CheckReturnValue")
     default void use() {
       ModifiableB.create().toImmutable();
     }
@@ -44,6 +46,7 @@ public interface C {
     @Value.Parameter
     int c();
 
+    @SuppressWarnings("CheckReturnValue")
     default void use() {
       ModifiableC.create().toImmutable();
     }

File: value-fixture/src/org/immutables/fixture/packoutput/Packs.java
Patch:
@@ -32,6 +32,7 @@ public abstract class Packs {
   @Value.Immutable
   public interface Perk {}
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     borg.immutables.fixture.packoutput.impl.ImmutablePacks.builder().build();
     borg.immutables.fixture.packoutput.impl.ImmutablePacks.Perk.builder().build();

File: value-fixture/src/org/immutables/fixture/style/AbstractValueNamingDetected.java
Patch:
@@ -42,6 +42,7 @@ abstract class AbstractValueNamingDetected {
 
   abstract Set<String> collectStr();
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     ValueNamingDetected.newBuilder()
         .usingVal(1)

File: value-fixture/src/org/immutables/fixture/style/BeanStyleDetected.java
Patch:
@@ -25,6 +25,7 @@ abstract class BeanStyleDetected {
 
   abstract List<String> getEm();
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     ImmutableBeanStyleDetected.builder()
         .setIt(1)

File: value-fixture/src/org/immutables/fixture/style/ConservativeStyleDetected.java
Patch:
@@ -27,6 +27,7 @@ abstract class ConservativeStyleDetected {
 
   abstract String getString();
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     new ConservativeStyleDetectedBuilder()
         .setValue(1)

File: value-fixture/src/org/immutables/fixture/style/Depluralize.java
Patch:
@@ -43,6 +43,7 @@ public interface Depluralize {
 
   Multiset<Boolean> goods();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableDepluralize.builder()
         .addBoat("") // automatically trims s

File: value-fixture/src/org/immutables/fixture/style/EnclosingBuilderNew.java
Patch:
@@ -32,6 +32,7 @@ public abstract class EnclosingBuilderNew {
   @Value.Immutable
   public static class Hidden {}
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     new ImmutableEnclosingBuilderNew.HiddenBuilder().build();
   }

File: value-fixture/src/org/immutables/fixture/style/EnclosingHiddenImplementation.java
Patch:
@@ -55,6 +55,7 @@ public static abstract class VisibleImplementation {
     public abstract Optional<Integer> cons();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     EnclosingFactory.HiddenImplementationBuilder.create().build();
 

File: value-fixture/src/org/immutables/fixture/style/HaveBuilderNew.java
Patch:
@@ -22,6 +22,7 @@
 public interface HaveBuilderNew {
   int a();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     new ImmutableHaveBuilderNew.Builder().build();
   }

File: value-fixture/src/org/immutables/fixture/style/HiddenImplementation.java
Patch:
@@ -30,6 +30,7 @@
 @Value.Style(visibility = ImplementationVisibility.PRIVATE)
 public class HiddenImplementation {
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     HiddenImplementation instance = new HiddenImplementationBuilder().build();
     instance.toString();

File: value-fixture/src/org/immutables/fixture/style/IncludeTypes.java
Patch:
@@ -32,6 +32,7 @@
 @Value.Immutable
 public class IncludeTypes {
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     // this immutable type (package style used)
     ImIncludeTypes.builder().build();

File: value-fixture/src/org/immutables/fixture/style/LessVisibleImplementation.java
Patch:
@@ -29,6 +29,7 @@
 @Value.Style(visibility = ImplementationVisibility.PACKAGE)
 public class LessVisibleImplementation {
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     ImmutableLessVisibleImplementation.Builder lessVisibleBuilder = ImmutableLessVisibleImplementation.builder();
     ImmutableLessVisibleImplementation lessVisibleImplementation = lessVisibleBuilder.build();

File: value-fixture/src/org/immutables/fixture/style/NestingClassOrBuilder.java
Patch:
@@ -34,6 +34,7 @@ interface ImplNestedInBuild {}
       builderVisibility = BuilderVisibility.PACKAGE)
   interface NonPublicBuild {}
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImplNestedInBuildBuilder builder = new ImplNestedInBuildBuilder();
     ImplNestedInBuild abstractValue = builder.build();

File: value-fixture/src/org/immutables/fixture/style/OutsideBuildable.java
Patch:
@@ -45,6 +45,7 @@ void use() {
 @Value.Style(newBuilder = "newBuilder", visibility = ImplementationVisibility.PRIVATE)
 class OutsideBuildableNew {
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     OutsideBuildableNewBuilder.newBuilder().build();
   }

File: value-fixture/src/org/immutables/fixture/style/Tuple.java
Patch:
@@ -30,6 +30,7 @@ interface Color {
   int green();
   int blue();
   
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ColorTuple.of(0xFF, 0x00, 0xFE);
   }
@@ -48,7 +49,8 @@ default int gray() {
     return black() - gray();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     OverrideColorTuple.of(0xFF, 0x00);
   }
-}
\ No newline at end of file
+}

File: value-fixture/src/org/immutables/fixture/style/depl/DepluralizeMergeDictionary.java
Patch:
@@ -45,6 +45,7 @@ interface Inner {
     Multiset<Boolean> goods();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableInner.builder()
         .addBoat("") // automatically trims s

File: value-fixture/src/org/immutables/fixture/style/nested/PackageStyleFromParent.java
Patch:
@@ -28,6 +28,7 @@ interface Val {
   }
 
   /** Generated API dictated by parent package's style. */
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     ImVal.builder().a(1).build().copyWithA(2);
   }

File: value-fixture/src/org/immutables/fixture/style/nested/nest/PackageStyleFromAncestor.java
Patch:
@@ -28,6 +28,7 @@ interface Baj {
   }
 
   /** Generated API dictated by parent package's style. */
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     ImBaj.builder().a(1).build().copyWithA(2);
   }

File: value-fixture/src/org/immutables/fixture/with/Copied.java
Patch:
@@ -37,6 +37,7 @@ public abstract class Copied implements WithCopied {
 
   public static class Builder extends ImmutableCopied.Builder {}
 
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     new Copied.Builder()
         .attr(1)

File: value-fixture/src/org/immutables/fixture/with/Enc.java
Patch:
@@ -43,6 +43,7 @@ interface Suppied<T extends Number> extends ImmutableEnc.WithSuppied<T> {
     class Builder<T extends Number> extends ImmutableEnc.Suppied.Builder<T> {}
   }
 
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     new Suppied.Builder<Long>()
         .a("a")

File: value-fixture/test/org/immutables/fixture/PrivateDefaultConstructorTest.java
Patch:
@@ -26,6 +26,7 @@ public void testNominal() throws Exception {
     ImmutablePrivateNoargConstructorNominal.class.getDeclaredConstructor();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = NoSuchMethodException.class)
   public void testOverridePrehash() throws Exception {
     ImmutablePrivateNoargConstructorOverridePrehash.class.getDeclaredMethod("computeHashCode");

File: value-fixture/test/org/immutables/fixture/SafeInitTest.java
Patch:
@@ -20,6 +20,7 @@
 
 public class SafeInitTest {
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void cycles() {
     try {
       ImmutableSafeInitIface.builder().build();

File: value-fixture/test/org/immutables/fixture/VeryManyAttributesTest.java
Patch:
@@ -19,6 +19,7 @@
 
 public class VeryManyAttributesTest {
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void builableWhenAllSet() {
     ImmutableHugeInterface.builder()
         .number0_0(1)
@@ -94,6 +95,7 @@ public void builableWhenAllSet() {
         .build();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = IllegalStateException.class)
   public void noInitBuildOverflow() {
     ImmutableHugeInterface.builder()
@@ -171,6 +173,7 @@ public void noInitBuildOverflow() {
   }
   
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void noOccupationOverflow() {
     ImmutableHugeOccupationOverflow.builder()
         .number0(0)

File: value-fixture/test/org/immutables/fixture/annotation/AnnotationTest.java
Patch:
@@ -35,6 +35,7 @@ public void ann() {
   }
 
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void bee() {
     ImmutableHasDefault.of(1).withOtherValue("w");
 

File: value-fixture/test/org/immutables/fixture/builder/AccessBuilderFieldsTest.java
Patch:
@@ -21,6 +21,7 @@
 
 public class AccessBuilderFieldsTest {
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void accessFields() {
     new AccessBuilderFields.Builder()
         .a(1)

File: value-fixture/test/org/immutables/fixture/generatorext/RewriteTest.java
Patch:
@@ -18,6 +18,7 @@
 import org.junit.Test;
 
 public class RewriteTest {
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = IllegalArgumentException.class)
   public void rewrite() {
     // Our changed preconditions will be able to throw IllegalArgumentException

File: value-fixture/test/org/immutables/fixture/modifiable/ClearBuilderTest.java
Patch:
@@ -20,6 +20,7 @@
 
 public class ClearBuilderTest {
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void clear() {
     ImmutableClearBuilder.Builder builder = ImmutableClearBuilder.builder()
         .a(true)

File: value-fixture/test/org/immutables/fixture/nullable/NullableAttributesTest.java
Patch:
@@ -101,6 +101,7 @@ public void compactConstruction() {
     check(ImmutableNullableCompact.of(null, null)).is(c1);
   }
 
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = NullPointerException.class)
   public void nonnullDefaultBlowupOnNull() {
     ImmutableNonnullConstruction.builder()

File: value-fixture/test/org/immutables/fixture/strict/StrictBuilderTest.java
Patch:
@@ -19,6 +19,7 @@
 import org.junit.Test;
 
 public class StrictBuilderTest {
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = IllegalStateException.class)
   public void noReassignment() {
     ImmutableAar.builder()
@@ -28,6 +29,7 @@ public void noReassignment() {
         .build();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = IllegalStateException.class)
   public void noReassignmentOptional() {
     ImmutableBar.builder()

File: value-fixture/test/org/immutables/fixture/style/SpecifiedExceptionTest.java
Patch:
@@ -20,11 +20,13 @@
 import nonimmutables.SampleRuntimeException;
 
 public class SpecifiedExceptionTest {
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = SampleRuntimeException.class)
   public void itThrowsExpectedConfiguredException() {
     ImmutableSpecifiedException.builder().build();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = IllegalArgumentException.class)
   public void itThrowsSpecifiedExceptionOnBuild() {
     ImmutableSpecifiedException.builder().buildOrThrow(IllegalArgumentException::new);

File: value-fixture/src/org/immutables/fixture/AllMandatoryParams.java
Patch:
@@ -28,6 +28,7 @@ default String c() {
     return "C";
   }
 
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     ImmutableAllMandatoryParams.of(1, true).withC("ABC");
   }

File: value-fixture/src/org/immutables/fixture/CancelParam.java
Patch:
@@ -33,6 +33,7 @@ public interface CancelParam extends Param {
   @Value.Parameter(false)
   List<Integer> aux();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableCancelParam.of(1).withAux(1, 2, 3);
   }

File: value-fixture/src/org/immutables/fixture/DeprecateType.java
Patch:
@@ -21,6 +21,7 @@
 @Deprecated
 interface DeprecateType {
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableDeprecateType.of();
   }

File: value-fixture/src/org/immutables/fixture/DerivedNotInConstructor.java
Patch:
@@ -37,6 +37,7 @@ public int totalLength() {
     return length;
   }
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     ImmutableDerivedNotInConstructor.of(Arrays.asList("a", "b", "c"));
   }
@@ -53,6 +54,7 @@ public int b() {
     return 1;
   }
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     ImmutableDerivedNotInConstructorSimpleCons.of(1);
   }

File: value-fixture/src/org/immutables/fixture/ExtendingInnerBuilderValue.java
Patch:
@@ -26,6 +26,7 @@ static class Builder {
     void hello() {}
   }
 
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     ImmutableSuperInnerBuildeValue.builder().hello();
   }
@@ -64,6 +65,7 @@ public ExtendingInnerCreatorValue create() {
     }
   }
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableExtendingInnerCreatorValue.Creator c = new ImmutableExtendingInnerCreatorValue.Creator();
     c.create();

File: value-fixture/src/org/immutables/fixture/ExtraCollection.java
Patch:
@@ -44,6 +44,7 @@ public interface ExtraCollection {
   @Value.Parameter
   BiMap<Integer, String> biMap();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableExtraCollection.of(
         ImmutableList.<String>of(),

File: value-fixture/src/org/immutables/fixture/InheritConstructorParameter.java
Patch:
@@ -27,6 +27,7 @@ abstract class HasParam {
   @Value.Immutable
   abstract class ExtendsIt extends HasParam {}
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableExtendsIt.of(1);
   }

File: value-fixture/src/org/immutables/fixture/OptionalCast.java
Patch:
@@ -27,6 +27,7 @@ public interface OptionalCast {
 
   Optional<String[]> getStringArray();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableOptionalCast.of(
         Optional.absent(),

File: value-fixture/src/org/immutables/fixture/OptionalOfOptionalRegular.java
Patch:
@@ -23,6 +23,7 @@
 public interface OptionalOfOptionalRegular<T> {
   Option<Optional<T>> optionalOfOptional();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableOptionalOfOptionalRegular.<Void>builder()
         .optionalOfOptional(Option.some(Optional.<Void>absent()))

File: value-fixture/src/org/immutables/fixture/PrivateNoargConstructor.java
Patch:
@@ -74,6 +74,7 @@ default int test() {
     return 1;
   }
   
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutablePrivateNoargConstructorIsOverriddenBySingleton.of();
   }

File: value-fixture/src/org/immutables/fixture/UseImmutableCollections.java
Patch:
@@ -53,6 +53,7 @@ public interface UseImmutableCollections {
 
   ImmutableListMultimap<String, Integer> listMultimap();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
 
     ImmutableUseImmutableCollections.builder()

File: value-fixture/src/org/immutables/fixture/ast/InstantiationGenerics.java
Patch:
@@ -38,6 +38,7 @@ interface StringNode extends Node<String> {}
   @Value.Immutable
   interface StringLeaf extends Leaf<String> {}
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     TreeElement<String> tree =
         ImmutableStringNode.builder()

File: value-fixture/src/org/immutables/fixture/couse/AbstractB.java
Patch:
@@ -24,6 +24,7 @@ interface AbstractB {
 
   Optional<A> aO();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     B b = B.builder()
         .a(A.builder().build())

File: value-fixture/src/org/immutables/fixture/couse/sub/AbstractC.java
Patch:
@@ -45,6 +45,7 @@ interface AbstractC {
 
   Map<RetentionPolicy, C> raM();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     C c = C.builder()
         .a(A.builder().build())

File: value-fixture/src/org/immutables/fixture/custann/CustomEncl.java
Patch:
@@ -24,6 +24,7 @@ public interface CustomEncl {
   @CustomWithEncStyle
   interface Cuzt {}
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     JeNcCustomEncl.Cuzt.builder();
   }

File: value-fixture/src/org/immutables/fixture/custann/CustomImmutables.java
Patch:
@@ -23,6 +23,7 @@ interface Od {}
   @CustomWithStyle2
   interface Dv {}
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     CustoOd.builder().build();
     JcIvDv.builder().build();

File: value-fixture/src/org/immutables/fixture/deep/Canvas.java
Patch:
@@ -55,6 +55,7 @@ public interface Point {
     int y();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableLine line = ImmutableLine.builder()
         .color(0.9, 0.7, 0.4)

File: value-fixture/src/org/immutables/fixture/deep/DeepAndJdkOnly.java
Patch:
@@ -48,6 +48,7 @@ interface Container {
 
   // Compile validation of generation of immutable return type and builder initializer by
   // constructor-args .
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     ImmutableContainer c = ImmutableContainer.builder().deep(1, 2).build();
     ImmutableDeep deep = c.getDeep();

File: value-fixture/src/org/immutables/fixture/generics/RawType.java
Patch:
@@ -29,6 +29,7 @@ public interface RawType {
 
   Map map();
 
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     ImmutableRawType.builder()
         .set(Collections.emptySet())

File: value-fixture/src/org/immutables/fixture/jackson/KeywordNames.java
Patch:
@@ -26,6 +26,7 @@ public interface KeywordNames {
 
   boolean isDefault();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableKeywordNames names = ImmutableKeywordNames.builder()
         .setDefault(true)

File: value-fixture/src/org/immutables/fixture/jackson/MetaJacksonAnnotation.java
Patch:
@@ -30,7 +30,7 @@ interface Val {
   // compile check for presense of
   // the Jackson specific creator method
   // triggered by meta annotation
-  @SuppressWarnings("deprecation")
+  @SuppressWarnings({"deprecation", "CheckReturnValue"})
   default void use() {
     ImmutableVal.fromJson(null);
   }

File: value-fixture/src/org/immutables/fixture/jdkonly/JdkOptionalBuilderFactory.java
Patch:
@@ -31,6 +31,7 @@ public static int bbz(@Builder.Parameter java.util.Optional<String> b, @Builder.
     return b.hashCode() + c.hashCode();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     new ApplBuilder()
         .a(1)

File: value-fixture/src/org/immutables/fixture/jdkonly/UsingAllOptionals.java
Patch:
@@ -52,6 +52,7 @@ public interface UsingAllOptionals {
   javaslang.control.Option<String> jso();
 
   class Use {
+    @SuppressWarnings("CheckReturnValue")
     void use() {
       UsingAllOptionals value =
           ImmutableUsingAllOptionals.builder()

File: value-fixture/src/org/immutables/fixture/modifiable/CreateFromDetect.java
Patch:
@@ -31,6 +31,7 @@ interface Bbb {
     int zzz();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ModifiableAaa.create()
         .setBbb(ModifiableBbb.create());

File: value-fixture/src/org/immutables/fixture/modifiable/ToImmutableCopyFalse.java
Patch:
@@ -23,6 +23,7 @@ public interface ToImmutableCopyFalse {
   @Value.Immutable(copy = false)
   public interface A {
 
+    @SuppressWarnings("CheckReturnValue")
     default void use() {
       ModifiableA.create().toImmutable();
     }
@@ -33,6 +34,7 @@ default void use() {
   @Value.Style(strictBuilder = true)
   public interface B {
 
+    @SuppressWarnings("CheckReturnValue")
     default void use() {
       ModifiableB.create().toImmutable();
     }
@@ -44,6 +46,7 @@ public interface C {
     @Value.Parameter
     int c();
 
+    @SuppressWarnings("CheckReturnValue")
     default void use() {
       ModifiableC.create().toImmutable();
     }

File: value-fixture/src/org/immutables/fixture/packoutput/Packs.java
Patch:
@@ -32,6 +32,7 @@ public abstract class Packs {
   @Value.Immutable
   public interface Perk {}
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     borg.immutables.fixture.packoutput.impl.ImmutablePacks.builder().build();
     borg.immutables.fixture.packoutput.impl.ImmutablePacks.Perk.builder().build();

File: value-fixture/src/org/immutables/fixture/style/AbstractValueNamingDetected.java
Patch:
@@ -42,6 +42,7 @@ abstract class AbstractValueNamingDetected {
 
   abstract Set<String> collectStr();
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     ValueNamingDetected.newBuilder()
         .usingVal(1)

File: value-fixture/src/org/immutables/fixture/style/BeanStyleDetected.java
Patch:
@@ -25,6 +25,7 @@ abstract class BeanStyleDetected {
 
   abstract List<String> getEm();
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     ImmutableBeanStyleDetected.builder()
         .setIt(1)

File: value-fixture/src/org/immutables/fixture/style/ConservativeStyleDetected.java
Patch:
@@ -27,6 +27,7 @@ abstract class ConservativeStyleDetected {
 
   abstract String getString();
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     new ConservativeStyleDetectedBuilder()
         .setValue(1)

File: value-fixture/src/org/immutables/fixture/style/Depluralize.java
Patch:
@@ -43,6 +43,7 @@ public interface Depluralize {
 
   Multiset<Boolean> goods();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableDepluralize.builder()
         .addBoat("") // automatically trims s

File: value-fixture/src/org/immutables/fixture/style/EnclosingBuilderNew.java
Patch:
@@ -32,6 +32,7 @@ public abstract class EnclosingBuilderNew {
   @Value.Immutable
   public static class Hidden {}
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     new ImmutableEnclosingBuilderNew.HiddenBuilder().build();
   }

File: value-fixture/src/org/immutables/fixture/style/EnclosingHiddenImplementation.java
Patch:
@@ -55,6 +55,7 @@ public static abstract class VisibleImplementation {
     public abstract Optional<Integer> cons();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     EnclosingFactory.HiddenImplementationBuilder.create().build();
 

File: value-fixture/src/org/immutables/fixture/style/HaveBuilderNew.java
Patch:
@@ -22,6 +22,7 @@
 public interface HaveBuilderNew {
   int a();
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     new ImmutableHaveBuilderNew.Builder().build();
   }

File: value-fixture/src/org/immutables/fixture/style/HiddenImplementation.java
Patch:
@@ -30,6 +30,7 @@
 @Value.Style(visibility = ImplementationVisibility.PRIVATE)
 public class HiddenImplementation {
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     HiddenImplementation instance = new HiddenImplementationBuilder().build();
     instance.toString();

File: value-fixture/src/org/immutables/fixture/style/IncludeTypes.java
Patch:
@@ -32,6 +32,7 @@
 @Value.Immutable
 public class IncludeTypes {
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     // this immutable type (package style used)
     ImIncludeTypes.builder().build();

File: value-fixture/src/org/immutables/fixture/style/LessVisibleImplementation.java
Patch:
@@ -29,6 +29,7 @@
 @Value.Style(visibility = ImplementationVisibility.PACKAGE)
 public class LessVisibleImplementation {
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     ImmutableLessVisibleImplementation.Builder lessVisibleBuilder = ImmutableLessVisibleImplementation.builder();
     ImmutableLessVisibleImplementation lessVisibleImplementation = lessVisibleBuilder.build();

File: value-fixture/src/org/immutables/fixture/style/NestingClassOrBuilder.java
Patch:
@@ -34,6 +34,7 @@ interface ImplNestedInBuild {}
       builderVisibility = BuilderVisibility.PACKAGE)
   interface NonPublicBuild {}
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImplNestedInBuildBuilder builder = new ImplNestedInBuildBuilder();
     ImplNestedInBuild abstractValue = builder.build();

File: value-fixture/src/org/immutables/fixture/style/OutsideBuildable.java
Patch:
@@ -45,6 +45,7 @@ void use() {
 @Value.Style(newBuilder = "newBuilder", visibility = ImplementationVisibility.PRIVATE)
 class OutsideBuildableNew {
 
+  @SuppressWarnings("CheckReturnValue")
   void use() {
     OutsideBuildableNewBuilder.newBuilder().build();
   }

File: value-fixture/src/org/immutables/fixture/style/Tuple.java
Patch:
@@ -30,6 +30,7 @@ interface Color {
   int green();
   int blue();
   
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ColorTuple.of(0xFF, 0x00, 0xFE);
   }
@@ -48,7 +49,8 @@ default int gray() {
     return black() - gray();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     OverrideColorTuple.of(0xFF, 0x00);
   }
-}
\ No newline at end of file
+}

File: value-fixture/src/org/immutables/fixture/style/depl/DepluralizeMergeDictionary.java
Patch:
@@ -45,6 +45,7 @@ interface Inner {
     Multiset<Boolean> goods();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   default void use() {
     ImmutableInner.builder()
         .addBoat("") // automatically trims s

File: value-fixture/src/org/immutables/fixture/style/nested/PackageStyleFromParent.java
Patch:
@@ -28,6 +28,7 @@ interface Val {
   }
 
   /** Generated API dictated by parent package's style. */
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     ImVal.builder().a(1).build().copyWithA(2);
   }

File: value-fixture/src/org/immutables/fixture/style/nested/nest/PackageStyleFromAncestor.java
Patch:
@@ -28,6 +28,7 @@ interface Baj {
   }
 
   /** Generated API dictated by parent package's style. */
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     ImBaj.builder().a(1).build().copyWithA(2);
   }

File: value-fixture/src/org/immutables/fixture/with/Copied.java
Patch:
@@ -37,6 +37,7 @@ public abstract class Copied implements WithCopied {
 
   public static class Builder extends ImmutableCopied.Builder {}
 
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     new Copied.Builder()
         .attr(1)

File: value-fixture/src/org/immutables/fixture/with/Enc.java
Patch:
@@ -43,6 +43,7 @@ interface Suppied<T extends Number> extends ImmutableEnc.WithSuppied<T> {
     class Builder<T extends Number> extends ImmutableEnc.Suppied.Builder<T> {}
   }
 
+  @SuppressWarnings("CheckReturnValue")
   static void use() {
     new Suppied.Builder<Long>()
         .a("a")

File: value-fixture/test/org/immutables/fixture/PrivateDefaultConstructorTest.java
Patch:
@@ -26,6 +26,7 @@ public void testNominal() throws Exception {
     ImmutablePrivateNoargConstructorNominal.class.getDeclaredConstructor();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = NoSuchMethodException.class)
   public void testOverridePrehash() throws Exception {
     ImmutablePrivateNoargConstructorOverridePrehash.class.getDeclaredMethod("computeHashCode");

File: value-fixture/test/org/immutables/fixture/SafeInitTest.java
Patch:
@@ -20,6 +20,7 @@
 
 public class SafeInitTest {
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void cycles() {
     try {
       ImmutableSafeInitIface.builder().build();

File: value-fixture/test/org/immutables/fixture/VeryManyAttributesTest.java
Patch:
@@ -19,6 +19,7 @@
 
 public class VeryManyAttributesTest {
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void builableWhenAllSet() {
     ImmutableHugeInterface.builder()
         .number0_0(1)
@@ -94,6 +95,7 @@ public void builableWhenAllSet() {
         .build();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = IllegalStateException.class)
   public void noInitBuildOverflow() {
     ImmutableHugeInterface.builder()
@@ -171,6 +173,7 @@ public void noInitBuildOverflow() {
   }
   
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void noOccupationOverflow() {
     ImmutableHugeOccupationOverflow.builder()
         .number0(0)

File: value-fixture/test/org/immutables/fixture/annotation/AnnotationTest.java
Patch:
@@ -35,6 +35,7 @@ public void ann() {
   }
 
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void bee() {
     ImmutableHasDefault.of(1).withOtherValue("w");
 

File: value-fixture/test/org/immutables/fixture/builder/AccessBuilderFieldsTest.java
Patch:
@@ -21,6 +21,7 @@
 
 public class AccessBuilderFieldsTest {
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void accessFields() {
     new AccessBuilderFields.Builder()
         .a(1)

File: value-fixture/test/org/immutables/fixture/generatorext/RewriteTest.java
Patch:
@@ -18,6 +18,7 @@
 import org.junit.Test;
 
 public class RewriteTest {
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = IllegalArgumentException.class)
   public void rewrite() {
     // Our changed preconditions will be able to throw IllegalArgumentException

File: value-fixture/test/org/immutables/fixture/modifiable/ClearBuilderTest.java
Patch:
@@ -20,6 +20,7 @@
 
 public class ClearBuilderTest {
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void clear() {
     ImmutableClearBuilder.Builder builder = ImmutableClearBuilder.builder()
         .a(true)

File: value-fixture/test/org/immutables/fixture/nullable/NullableAttributesTest.java
Patch:
@@ -101,6 +101,7 @@ public void compactConstruction() {
     check(ImmutableNullableCompact.of(null, null)).is(c1);
   }
 
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = NullPointerException.class)
   public void nonnullDefaultBlowupOnNull() {
     ImmutableNonnullConstruction.builder()

File: value-fixture/test/org/immutables/fixture/strict/StrictBuilderTest.java
Patch:
@@ -19,6 +19,7 @@
 import org.junit.Test;
 
 public class StrictBuilderTest {
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = IllegalStateException.class)
   public void noReassignment() {
     ImmutableAar.builder()
@@ -28,6 +29,7 @@ public void noReassignment() {
         .build();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = IllegalStateException.class)
   public void noReassignmentOptional() {
     ImmutableBar.builder()

File: value-fixture/test/org/immutables/fixture/style/SpecifiedExceptionTest.java
Patch:
@@ -20,11 +20,13 @@
 import nonimmutables.SampleRuntimeException;
 
 public class SpecifiedExceptionTest {
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = SampleRuntimeException.class)
   public void itThrowsExpectedConfiguredException() {
     ImmutableSpecifiedException.builder().build();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   @Test(expected = IllegalArgumentException.class)
   public void itThrowsSpecifiedExceptionOnBuild() {
     ImmutableSpecifiedException.builder().buildOrThrow(IllegalArgumentException::new);

File: value-fixture/test/org/immutables/fixture/builder/AttributeBuilderTest.java
Patch:
@@ -59,7 +59,7 @@ public void basicApiForSamePackageParent() {
   }
 
   // Allows sharing tests between guava collections, jdk only collections and whatever other combinations are needed.
-  private <ImmutableClassT extends AttributeBuilderValueI, AbstractClassT extends AttributeBuilderValueI>
+  private static <ImmutableClassT extends AttributeBuilderValueI, AbstractClassT extends AttributeBuilderValueI>
   void assertBasicApi(Class<ImmutableClassT> immutableType, Class<AbstractClassT> returnType,
       CopyFunction<ImmutableClassT, AbstractClassT> copyFunction,
       BuilderFunction<AbstractClassT> newBuilder) {

File: value-fixture/test/org/immutables/fixture/jackson/FieldConflictTest.java
Patch:
@@ -112,15 +112,15 @@ public void customDummyWithMetaAnnotationWithCustomObjectMapper() throws IOExcep
     verifyRoundTrip(getMapper(true), ImmutableCustomDummyWithMetaAnnotation.of(true));
   }
 
-  private ObjectMapper getMapper(final boolean useFields) {
+  private static ObjectMapper getMapper(final boolean useFields) {
     final ObjectMapper mapper = new ObjectMapper();
     return useFields
         ? mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.NONE)
             .setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY)
         : mapper;
   }
 
-  private void verifyRoundTrip(final ObjectMapper mapper, final Object value) throws IOException {
+  private static void verifyRoundTrip(final ObjectMapper mapper, final Object value) throws IOException {
     final String json = mapper.writeValueAsString(value);
     final Object newValue = mapper.readValue(json, value.getClass());
     check(newValue).is(value);

File: value-fixture/test/org/immutables/fixture/jdkonly/JdkOptionalTest.java
Patch:
@@ -93,13 +93,13 @@ public void serializeRegular() throws Exception {
     check(o1.hashCode()).is(o0.hashCode());
   }
 
-  private Serializable deserialize(byte[] bytes) throws Exception {
+  private static Serializable deserialize(byte[] bytes) throws Exception {
     ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
     ObjectInputStream objectStream = new ObjectInputStream(stream);
     return (Serializable) objectStream.readObject();
   }
 
-  private byte[] serialize(Serializable instance) throws Exception {
+  private static byte[] serialize(Serializable instance) throws Exception {
     ByteArrayOutputStream stream = new ByteArrayOutputStream();
     ObjectOutputStream objectStream = new ObjectOutputStream(stream);
     objectStream.writeObject(instance);

File: value-fixture/test/org/immutables/fixture/marshal/MarshallingTest.java
Patch:
@@ -129,11 +129,11 @@ public void marshalAndUnmarshalGeneratedType() {
     check(Marshaling.fromJson(Marshaling.toJson(structure), SillyStructure.class)).is(structure);
   }
 
-  private <T> List<T> fromJsonIterable(String json, TypeToken<List<T>> typeToken) {
+  private static <T> List<T> fromJsonIterable(String json, TypeToken<List<T>> typeToken) {
     return Marshaling.getGson().fromJson(json, typeToken.getType());
   }
 
-  private <T> String toJsonIterable(List<? extends T> list, TypeToken<List<T>> typeToken) {
+  private static <T> String toJsonIterable(List<? extends T> list, TypeToken<List<T>> typeToken) {
     return Marshaling.getGson().toJson(list, typeToken.getType());
   }
 }

File: value-fixture/test/org/immutables/fixture/serial/SerialTest.java
Patch:
@@ -71,13 +71,13 @@ public void copySerialVersionModifiable() throws Exception {
     check(false);
   }
 
-  private Serializable deserialize(byte[] bytes) throws Exception {
+  private static Serializable deserialize(byte[] bytes) throws Exception {
     ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
     ObjectInputStream objectStream = new ObjectInputStream(stream);
     return (Serializable) objectStream.readObject();
   }
 
-  private byte[] serialize(Serializable instance) throws Exception {
+  private static byte[] serialize(Serializable instance) throws Exception {
     ByteArrayOutputStream stream = new ByteArrayOutputStream();
     ObjectOutputStream objectStream = new ObjectOutputStream(stream);
     objectStream.writeObject(instance);

File: value-fixture/test/org/immutables/metainf/fixture/ServiceTest.java
Patch:
@@ -34,7 +34,7 @@ public void serviceSets() {
     check(sortedToStringsFrom(ServiceLoader.load(AutoCloseable.class))).isOf("NestedService.Service");
   }
 
-  private TreeSet<String> sortedToStringsFrom(Iterable<?> iterable) {
+  private static TreeSet<String> sortedToStringsFrom(Iterable<?> iterable) {
     return Sets.newTreeSet(FluentIterable.from(iterable).transform(Functions.toStringFunction()));
   }
 }

File: value-processor/src/org/immutables/value/processor/meta/AttributeBuilderReflection.java
Patch:
@@ -424,7 +424,9 @@ protected static boolean isPossibleCopyMethod(ValueAttribute valueAttribute,
         } else if (onValueType
             && candidateCopyMethod.getParameters().size() == 0
             && !candidateCopyMethod.getModifiers().contains(Modifier.STATIC)) {
-          return !candidateCopyMethod.getReturnType().getKind().isPrimitive();
+
+          TypeKind kind = candidateCopyMethod.getReturnType().getKind();
+          return !kind.isPrimitive() && kind != TypeKind.ARRAY;
         }
       } else if (!onValueType && possibleCopyMethod.getKind() == ElementKind.CONSTRUCTOR) {
 

File: value-processor/src/org/immutables/value/processor/meta/AttributeBuilderReflection.java
Patch:
@@ -424,7 +424,7 @@ protected static boolean isPossibleCopyMethod(ValueAttribute valueAttribute,
         } else if (onValueType
             && candidateCopyMethod.getParameters().size() == 0
             && !candidateCopyMethod.getModifiers().contains(Modifier.STATIC)) {
-          return true;
+          return !candidateCopyMethod.getReturnType().getKind().isPrimitive();
         }
       } else if (!onValueType && possibleCopyMethod.getKind() == ElementKind.CONSTRUCTOR) {
 

File: mongo/test/org/immutables/mongo/fixture/MongoAsserts.java
Patch:
@@ -54,7 +54,7 @@ public static void assertDuplicateKeyException(Throwable exception) {
       return;
     }
 
-    // all others exceptions
+    // if we got here means there is a problem (no duplicate key exception)
     fail("Should get duplicate key exception after " + exception);
   }
 

File: mongo/test/org/immutables/mongo/fixture/SimpleIndexerTest.java
Patch:
@@ -21,7 +21,7 @@ public class SimpleIndexerTest {
 
   @Test
   public void index1() throws Exception {
-    repository.index().withId().named("id").expireAfterSeconds(1).ensure().getUnchecked();
+    repository.index().withId().named("id").ensure().getUnchecked();
     repository.index().withString().named("string").unique().expireAfterSeconds(2).ensure().getUnchecked();
     repository.index().withLongValue().named("longValue").expireAfterSeconds(3).ensure().getUnchecked();
     repository.index().withDoubleValue().named("doubleValue").ensure().getUnchecked();

File: mongo/src/org/immutables/mongo/repository/Repositories.java
Patch:
@@ -610,7 +610,7 @@ public final I expireAfterSeconds(int timeToLiveSeconds) {
 
     /**
      * Creates configured index on a set of fields, if one does not already exist.
-     * @see DBCollection#ensureIndex(DBObject, DBObject)
+     * @see DBCollection#createIndex(DBObject, DBObject)
      * @return future of indexing operation, future value is insignificant ({@code null} typed as
      *         {@link Void})
      */

File: mongo/src/org/immutables/mongo/repository/internal/BsonReader.java
Patch:
@@ -33,7 +33,7 @@
 public class BsonReader extends JsonParserReader {
   private final BsonParser parser;
 
-  public BsonReader(BsonParser parser) {
+  BsonReader(BsonParser parser) {
     super(parser);
     this.parser = parser;
   }

File: mongo/test/org/immutables/mongo/fixture/BasicMongoOperationsTest.java
Patch:
@@ -110,8 +110,6 @@ public void delete() throws Exception {
     check(repository.findAll().deleteAll().getUnchecked()).is(1);
     // second time no entries remaining
     check(repository.findAll().deleteAll().getUnchecked()).is(0);
-
-
   }
 
   private Item findItem() {

File: mongo/test/org/immutables/mongo/fixture/Entity.java
Patch:
@@ -26,6 +26,7 @@
 public abstract class Entity {
 
   @Mongo.Id
+  @Value.Parameter
   abstract String id();
 
   @Value.Default

File: mongo/test/org/immutables/mongo/fixture/Item.java
Patch:
@@ -30,6 +30,7 @@
 public interface Item {
 
   @Mongo.Id
+  @Value.Parameter
   String id();
 
   List<String> list();

File: mongo/test/org/immutables/mongo/fixture/BasicMongoOperationsTest.java
Patch:
@@ -120,6 +120,7 @@ public void index() throws Exception {
   @Test
   public void jsonQuery() throws Exception {
     check(repository.find("{}").fetchAll().getUnchecked()).isEmpty();
+    check(repository.find("{ \"_id\": \"1\"}").fetchAll().getUnchecked()).isEmpty();
     Item item = item().withList("foo");
     repository.insert(item).getUnchecked();
 

File: value-processor/src/org/immutables/value/processor/meta/Round.java
Patch:
@@ -113,7 +113,7 @@ public ImmutableList<Protoclass> collectProtoclasses() {
   }
 
   private Set<Element> allAnnotatedElements() {
-    Set<Element> elements = Sets.newHashSetWithExpectedSize(100);
+    Set<Element> elements = Sets.newLinkedHashSetWithExpectedSize(100);
     for (TypeElement annotation : annotations()) {
       Set<? extends Element> annotatedElements = round().getElementsAnnotatedWith(annotation);
       checkAnnotation(annotation, annotatedElements);

File: mongo/src/org/immutables/mongo/repository/internal/Support.java
Patch:
@@ -216,7 +216,7 @@ public static Object writable(Object value) {
   }
 
   @SuppressWarnings("unchecked")
-  public static <T extends Comparable<T>> Range<Comparable<Object>> writable(TypeAdapter<T> adapter, Range<T> range) {
+  public static <T extends Comparable<? super T>> Range<Comparable<Object>> writable(TypeAdapter<T> adapter, Range<T> range) {
     if (range.hasLowerBound() && range.hasUpperBound()) {
       return Range.range(
           (Comparable<Object>) writable(adapter, range.lowerEndpoint()),
@@ -236,7 +236,7 @@ public static <T extends Comparable<T>> Range<Comparable<Object>> writable(TypeA
   }
 
   @SuppressWarnings("unchecked")
-  public static <T extends Comparable<T>> Range<Comparable<Object>> writable(Range<T> range) {
+  public static <T extends Comparable<? super T>> Range<Comparable<Object>> writable(Range<T> range) {
     return (Range<Comparable<Object>>) writable((Object) range);
   }
 

File: mongo/src/org/immutables/mongo/repository/internal/Support.java
Patch:
@@ -216,7 +216,7 @@ public static Object writable(Object value) {
   }
 
   @SuppressWarnings("unchecked")
-  public static <T extends Comparable<T>> Range<Comparable<Object>> writable(TypeAdapter<T> adapter, Range<T> range) {
+  public static <T extends Comparable<? super T>> Range<Comparable<Object>> writable(TypeAdapter<T> adapter, Range<T> range) {
     if (range.hasLowerBound() && range.hasUpperBound()) {
       return Range.range(
           (Comparable<Object>) writable(adapter, range.lowerEndpoint()),
@@ -236,7 +236,7 @@ public static <T extends Comparable<T>> Range<Comparable<Object>> writable(TypeA
   }
 
   @SuppressWarnings("unchecked")
-  public static <T extends Comparable<T>> Range<Comparable<Object>> writable(Range<T> range) {
+  public static <T extends Comparable<? super T>> Range<Comparable<Object>> writable(Range<T> range) {
     return (Range<Comparable<Object>>) writable((Object) range);
   }
 

File: mongo/test/org/immutables/mongo/fixture/MongoContext.java
Patch:
@@ -25,7 +25,6 @@
 import com.mongodb.DB;
 import com.mongodb.MongoClient;
 import com.mongodb.MongoClientURI;
-import com.mongodb.WriteConcern;
 import org.immutables.mongo.fixture.holder.Holder;
 import org.immutables.mongo.fixture.holder.HolderJsonSerializer;
 import org.immutables.mongo.fixture.holder.ImmutableHolder;

File: value-processor/src/org/immutables/value/processor/meta/SwitcherModel.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.immutables.value.processor.meta;
 
-import org.immutables.value.processor.meta.Styles.UsingName.AttributeNames;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
@@ -33,7 +32,7 @@ public final class SwitcherModel {
 
   private final TypeElement containedTypeElement;
 
-  SwitcherModel(SwitchMirror mirror, AttributeNames names, TypeElement containedTypeElement) {
+  SwitcherModel(SwitchMirror mirror, Styles.UsingName.AttributeNames names, TypeElement containedTypeElement) {
     this.switcherNaming = Naming.from(names.raw).requireNonConstant(Preference.SUFFIX);
     this.containedTypeElement = Preconditions.checkNotNull(containedTypeElement);
     this.defaultName = mirror.defaultName();

File: value-processor/src/org/immutables/value/processor/encode/Type.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.immutables.value.processor.encode;
 
-import java.util.Iterator;
 import com.google.common.base.Ascii;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
@@ -27,13 +26,13 @@
 import java.util.Arrays;
 import java.util.Deque;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import javax.annotation.Nullable;
 import javax.annotation.concurrent.ThreadSafe;
 import org.immutables.value.processor.encode.Code.Term;
-import org.immutables.value.processor.encode.Type.Parameters;
 
 /**
  * I've created this type model as an experiment which I want to bring forward and evolve

File: value-processor/src/org/immutables/value/processor/encode/TypeExtractor.java
Patch:
@@ -17,7 +17,6 @@
 
 import com.google.common.collect.ImmutableList;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import javax.annotation.Nullable;
 import javax.lang.model.element.Parameterizable;
@@ -35,7 +34,6 @@
 import javax.lang.model.type.UnionType;
 import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.AbstractTypeVisitor7;
-import org.immutables.value.processor.encode.Type.Defined;
 
 public final class TypeExtractor {
   public final Type.Factory factory;

File: value-processor/src/org/immutables/value/processor/meta/FromSupertypesModel.java
Patch:
@@ -34,7 +34,6 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.ElementFilter;
 import org.immutables.generator.SourceTypes;
-import org.immutables.value.processor.encode.TypeExtractor;
 import org.immutables.value.processor.meta.LongBits.LongPositions;
 
 public final class FromSupertypesModel {

File: value-processor/src/org/immutables/value/processor/meta/TypeIntrospectionBase.java
Patch:
@@ -68,9 +68,9 @@ protected static String unwrapType(String typeName) {
   }
 
   private volatile boolean introspected;
-  protected ImmutableList<String> extendedClassesNames;
-  protected ImmutableSet<String> implementedInterfacesNames;
-  protected ImmutableSet<String> unresolvedYetArguments;
+  protected ImmutableList<String> extendedClassesNames = ImmutableList.of();
+  protected ImmutableSet<String> implementedInterfacesNames = ImmutableSet.of();
+  protected ImmutableSet<String> unresolvedYetArguments = ImmutableSet.of();
   private boolean isOrdinalValue;
   private boolean isEnum;
   private boolean isComparable;

File: value-fixture/test/org/immutables/fixture/jdkonly/DefaultTest.java
Patch:
@@ -23,8 +23,9 @@ public class DefaultTest {
   @Test
   public void defArray() {
     ImmutableDefaultArray a1 = ImmutableDefaultArray.builder().build();
-    check(a1.prop() != a1.prop());
-    
+    int[] array = a1.prop();
+    int[] nextArray = a1.prop();
+    check(array != nextArray);
     check(a1.ints() instanceof ImmutableSortedSet);
   }
 }

File: value-processor/src/org/immutables/value/processor/Parcelables.java
Patch:
@@ -22,8 +22,6 @@
 import org.immutables.value.processor.encode.Renderers;
 import org.immutables.value.processor.meta.ValueAttribute;
 import org.immutables.value.processor.meta.ValueType;
-import org.immutables.value.processor.encode.Generator_Renderers;
-import org.immutables.value.processor.encode.Renderers;
 
 /**
  * The Class Parcelables.

File: value-processor/src/org/immutables/value/processor/encode/Code.java
Patch:
@@ -31,7 +31,7 @@
 final class Code {
   private Code() {}
 
-  private static final CharMatcher DELIMITER = CharMatcher.anyOf("!\"#$%&'()*+,-./:;<=>?@[]^_{|}~");
+  private static final CharMatcher DELIMITER = CharMatcher.anyOf("!\"#$%&'()*+,-./:;<=>?@[]^{|}~");
   private static final CharMatcher WHITESPACE = CharMatcher.WHITESPACE;
   private static final CharMatcher LETTER_OR_DIGIT = CharMatcher.javaLetterOrDigit().or(CharMatcher.anyOf("$_"));
   private static final CharMatcher IDENTIFIER_START = CharMatcher.javaLetter().or(CharMatcher.anyOf("$_"));

File: generator/src/org/immutables/generator/ExtensionLoader.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.value.processor.meta;
+package org.immutables.generator;
 
 import com.google.common.base.Splitter;
 import com.google.common.collect.FluentIterable;
@@ -26,14 +26,14 @@
 import java.util.Enumeration;
 import java.util.List;
 
-final class ExtensionLoader {
+public final class ExtensionLoader {
   private ExtensionLoader() {}
 
   private static final Splitter RESOURCE_SPLITTER = Splitter.on("\n")
       .omitEmptyStrings()
       .trimResults();
 
-  static ImmutableSet<String> findExtensions(String resource) {
+  public static ImmutableSet<String> findExtensions(String resource) {
     List<String> annotations = Lists.newArrayList();
 
     ClassLoader classLoader = ExtensionLoader.class.getClassLoader();

File: value-processor/src/org/immutables/value/processor/meta/CustomImmutableAnnotations.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.immutables.value.processor.meta;
 
+import org.immutables.generator.ExtensionLoader;
 import com.google.common.collect.ImmutableSet;
 
 public final class CustomImmutableAnnotations {

File: value-processor/src/org/immutables/value/processor/meta/CustomImmutableCollections.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.immutables.value.processor.meta;
 
+import org.immutables.generator.ExtensionLoader;
 import com.google.common.collect.ImmutableSet;
 
 public final class CustomImmutableCollections {

File: value-processor/src/org/immutables/value/processor/meta/Round.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.immutables.value.processor.meta;
 
-import java.util.HashSet;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Maps;

File: value-fixture/test/org/immutables/fixture/encoding/UseTableEncoding.java
Patch:
@@ -23,6 +23,7 @@
 @JsonDeserialize(builder = ImmutableUseTableEncoding.Builder.class)
 @Value.Immutable(singleton = true)
 @TableEncodingEnabled
+@Value.Modifiable
 public abstract class UseTableEncoding {
 
   abstract Table<String, Integer, Void> getIt();

File: value-processor/src/org/immutables/value/processor/meta/Proto.java
Patch:
@@ -373,7 +373,7 @@ TypeAdaptersMirror defaultTypeAdapters() {
     }
 
     ValueType composeValue(Protoclass protoclass) {
-      return round().composer().compose(protoclass);
+      return round().composeValue(protoclass);
     }
 
     ImmutableList<Protoclass> protoclassesFrom(Iterable<? extends Element> elements) {

File: value-processor/src/org/immutables/value/processor/meta/ValueAttribute.java
Patch:
@@ -991,7 +991,7 @@ private void initOrderKind() {
     if (typeKind.isSortedKind()) {
       checkOrderAnnotations();
       if (orderKind == OrderKind.NONE) {
-        typeKind = AttributeTypeKind.REGULAR;
+        this.typeKind = AttributeTypeKind.REGULAR;
       }
     }
   }

File: value-processor/src/org/immutables/value/processor/meta/ValueTypeComposer.java
Patch:
@@ -42,8 +42,7 @@ public final class ValueTypeComposer {
           .or(CharMatcher.inRange('A', 'Z'))
           .or(CharMatcher.inRange('0', '9')).precomputed();
 
-  ValueType compose(Protoclass protoclass) {
-    ValueType type = new ValueType();
+  void compose(ValueType type, Protoclass protoclass) {
     type.element = protoclass.sourceElement();
     type.immutableFeatures = protoclass.features();
     type.constitution = protoclass.constitution();
@@ -77,7 +76,6 @@ ValueType compose(Protoclass protoclass) {
     checkAttributeNamesForDuplicates(type, protoclass);
     checkConstructability(type);
     checkStyleConflicts(type, protoclass);
-    return type;
   }
 
   private void checkAttributeNamesIllegalCharacters(ValueType type) {

File: value-processor/src/org/immutables/value/processor/meta/ValueAttribute.java
Patch:
@@ -145,7 +145,8 @@ public boolean hasSimpleScalarElementType() {
         || isPrimitiveWrappedType(type)
         || hasEnumContainedElementType()
         || isEnumType()
-        || isJdkSpecializedOptional(); // the last is not needed, probably
+        || isJdkSpecializedOptional()
+        || extendedClassesNames.contains(Number.class.getName());
   }
 
   public boolean requiresAlternativeStrictConstructor() {

File: value-processor/src/org/immutables/value/processor/meta/Proto.java
Patch:
@@ -1758,7 +1758,8 @@ public StyleInfo apply(StyleMirror input) {
           input.depluralize(),
           input.depluralizeDictionary(),
           ImmutableSet.copyOf(input.immutableCopyOfRoutinesName()),
-          input.stagedBuilder());
+          input.stagedBuilder(),
+          input.builtinContainerAttributes());
     }
   }
 

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -204,6 +204,8 @@ private ValueMirrors() {}
 
     boolean stagedBuilder() default false;
 
+    boolean builtinContainerAttributes() default true;
+
     public enum ImplementationVisibility {
       PUBLIC,
       SAME,

File: value-fixture/src/org/immutables/fixture/modifiable/nested/ReferenceDifferentPackage.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.fixture.modifiable.differentPackage;
+package org.immutables.fixture.modifiable.nested;
 
 
 import org.immutables.fixture.modifiable.Companion;

File: value-processor/src/org/immutables/value/processor/meta/ValueAttribute.java
Patch:
@@ -161,7 +161,8 @@ public boolean isMandatory() {
         && !isContainerType()
         && !isNullable()
         && !isEncoding()
-        && !hasBuilderSwitcherDefault();
+        && !hasBuilderSwitcherDefault()
+        && !(isPrimitive() && protoclass().styles().style().validationMethod() != ValidationMethod.SIMPLE);
   }
 
   public boolean isNullable() {
@@ -1316,7 +1317,7 @@ private void initMiscellaneous() {
         .isDeprecated(CachingElements.getDelegate(element));
 
     this.docComment = containingType.extractDocComment(element);
-    if (isMandatory() && protoclass().styles().style().validationMethod() != ValidationMethod.SIMPLE) {
+    if (!isPrimitive() && isMandatory() && protoclass().styles().style().validationMethod() != ValidationMethod.SIMPLE) {
       this.nullability = NullabilityAnnotationInfo.forTypeUse();
     }
   }

File: value-fixture/src/org/immutables/fixture/ordered/SortedCollectionWrapper.java
Patch:
@@ -6,7 +6,7 @@
 import org.immutables.value.Value;
 
 @Value.Immutable
-public interface SortedMultisetWrapper {
+public interface SortedCollectionWrapper {
     @Value.NaturalOrder
     ImmutableSortedSet<Elem> getElemSet();
 

File: value-fixture/src/org/immutables/fixture/ordered/SortedCollectionWrapper.java
Patch:
@@ -6,7 +6,7 @@
 import org.immutables.value.Value;
 
 @Value.Immutable
-public interface SortedMultisetWrapper {
+public interface SortedCollectionWrapper {
     @Value.NaturalOrder
     ImmutableSortedSet<Elem> getElemSet();
 

File: value-processor/src/org/immutables/value/processor/meta/TypeIntrospectionBase.java
Patch:
@@ -69,6 +69,7 @@ protected static String unwrapType(String typeName) {
   private volatile boolean introspected;
   protected ImmutableList<String> extendedClassesNames;
   protected ImmutableSet<String> implementedInterfacesNames;
+  protected ImmutableSet<String> unresolvedYetArguments;
   private boolean isOrdinalValue;
   private boolean isEnum;
   private boolean isComparable;
@@ -141,6 +142,7 @@ protected void introspectTypeMirror(TypeMirror typeMirror) {
     TypeHierarchyCollector collector = collectTypeHierarchy(typeMirror);
     this.extendedClassesNames = collector.extendedClassNames();
     this.implementedInterfacesNames = collector.implementedInterfaceNames();
+    this.unresolvedYetArguments = collector.unresolvedYetArguments();
   }
 
   protected TypeHierarchyCollector collectTypeHierarchy(TypeMirror typeMirror) {

File: value-processor/src/org/immutables/value/processor/meta/ValueAttribute.java
Patch:
@@ -322,10 +322,9 @@ public List<CharSequence> getBuilderAttributeAnnotation() {
     if (containingType.isGenerateJacksonProperties()) {
       List<CharSequence> jacksonPropertyAnnotation = Annotations.getAnnotationLines(element,
           Collections.singleton(JsonPropertyMirror.qualifiedName()),
-          false,
+          true,
           ElementType.METHOD,
           importsResolver);
-
       if (jacksonPropertyAnnotation.isEmpty()) {
         return ImmutableList.<CharSequence>of(jacksonPropertyAnnotation());
       }
@@ -1000,7 +999,8 @@ private void initTypeName() {
     this.importsResolver.hierarchyTraversalForUnresolvedTypes(
         protoclass().environment().round(),
         this.containingType.extendedClasses(),
-        this.containingType.implementedInterfaces());
+        this.containingType.implementedInterfaces(),
+        this.containingType.unresolvedYetArguments);
 
     TypeStringProvider provider = new TypeStringProvider(
         reporter,

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -186,6 +186,8 @@ private ValueMirrors() {}
 
     boolean forceJacksonPropertyNames() default true;
 
+    boolean jacksonIntegration() default true;
+
     BuilderVisibility builderVisibility() default BuilderVisibility.PUBLIC;
 
     Class<? extends Exception> throwForInvalidImmutableState() default IllegalStateException.class;

File: value-fixture/src/org/immutables/fixture/deep/Canvas.java
Patch:
@@ -21,6 +21,7 @@
 @Value.Style(deepImmutablesDetection = true, depluralize = true)
 public interface Canvas {
 
+  @Value.Modifiable
   @Value.Immutable
   public interface Color {
     @Value.Parameter
@@ -33,13 +34,15 @@ public interface Color {
     double blue();
   }
 
+  @Value.Modifiable
   @Value.Immutable
   public interface Line {
     List<Point> points();
 
     Color color();
   }
 
+  @Value.Modifiable
   @Value.Immutable
   public interface Point {
     @Value.Parameter

File: value-processor/src/org/immutables/value/processor/meta/ValueAttribute.java
Patch:
@@ -279,7 +279,7 @@ public String getType() {
   }
 
   public List<CharSequence> getAnnotations() {
-    if (containingType.isGenerateJacksonMapped()) {
+    if (containingType.isGenerateJacksonProperties()) {
       return extractAnnotationsForElement(
           ElementType.METHOD,
           protoclass().styles().style().passAnnotationsNames());

File: generator/src/org/immutables/generator/SourceExtraction.java
Patch:
@@ -188,7 +188,7 @@ public CharSequence extract(ProcessingEnvironment environment, TypeElement typeE
 
 		@Override
 		public CharSequence extractReturnType(ExecutableElement executableElement) {
-			return UNABLE_TO_EXTRACT;
+      return UNABLE_TO_EXTRACT;
 		}
 	}
 

File: value-fixture/src/org/immutables/fixture/nullable/NullablyElements.java
Patch:
@@ -25,7 +25,7 @@
  */
 @Value.Style(jdkOnly = true)
 @Value.Immutable
-public interface NullableElements {
+public interface NullablyElements {
   List<@NullableUse Void> al();
 
   List<@SkipNulls String> sk();

File: value/src/org/immutables/value/Value.java
Patch:
@@ -580,7 +580,7 @@
     String create() default "create";
 
     /**
-     * Method to convert to instanse of modifiable type to "canonical" immutable instance.
+     * Method to convert to instance of modifiable type to "canonical" immutable instance.
      * @return naming template
      */
     String toImmutable() default "toImmutable";
@@ -634,7 +634,7 @@
      */
     String typeModifiable() default "Modifiable*";
 
-    /*
+    /**
      * Generated "with" interface name. Used to detect a demand and generate "with" interface.
      * @return naming template
      */

File: value/src/org/immutables/value/Value.java
Patch:
@@ -580,7 +580,7 @@
     String create() default "create";
 
     /**
-     * Method to convert to instanse of modifiable type to "canonical" immutable instance.
+     * Method to convert to instance of modifiable type to "canonical" immutable instance.
      * @return naming template
      */
     String toImmutable() default "toImmutable";
@@ -634,7 +634,7 @@
      */
     String typeModifiable() default "Modifiable*";
 
-    /*
+    /**
      * Generated "with" interface name. Used to detect a demand and generate "with" interface.
      * @return naming template
      */

File: value-processor/src/org/immutables/value/processor/meta/FromSupertypesModel.java
Patch:
@@ -124,7 +124,7 @@ private boolean isEligibleFromType(TypeElement typeElement, ValueAttribute attr)
       // it (null) should never happen in theory
       return false;
     }
-    return accessor.getReturnType().equals(attr.returnType);
+    return accessor.getReturnType().toString().equals(attr.returnType.toString());
   }
 
   private @Nullable ExecutableElement findMethod(TypeElement typeElement, String getter) {

File: value-processor/src/org/immutables/value/processor/meta/ValueTypeComposer.java
Patch:
@@ -84,7 +84,8 @@ private void checkAttributeNamesIllegalCharacters(ValueType type) {
     for (ValueAttribute a : type.attributes) {
       if (!ATTRIBUTE_NAME_CHARS.matchesAllOf(a.name())) {
         a.report()
-            .error("Name '%s' contains some unsupported or reserved characters, please use only A-Z, a-z, 0-9 and _ chars",
+            .warning("Name '%s' contains some unsupported characters (a-z,A-Z,0-9,_ are ok),"
+                + " name formatting might not work as expected",
                 a.name());
       }
     }

File: value-fixture/src/org/immutables/fixture/DefaultDerivedInit.java
Patch:
@@ -22,7 +22,7 @@
 public abstract class DefaultDerivedInit {
   @Value.Derived
   public String index() {
-    return uuid() + "!!!";
+    return uuid() + "<>";
   }
 
   @Value.Parameter

File: value-processor/src/org/immutables/value/processor/meta/Proto.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.immutables.value.processor.meta;
 
+import org.immutables.value.processor.encode.Type;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.base.Preconditions;

File: value-processor/src/org/immutables/value/processor/meta/TypeStringProvider.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.immutables.value.processor.meta;
 
+import com.google.common.collect.ImmutableSet;
 import com.google.common.base.Ascii;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;

File: value-processor/src/org/immutables/value/processor/encode/Type.java
Patch:
@@ -552,7 +552,7 @@ public Type parameterized(Parameterized parameterized) {
 
     @Override
     public Type array(Array array) {
-      return new Array(array.accept(this), array.varargs);
+      return new Array(array.element.accept(this), array.varargs);
     }
 
     @Override

File: value-processor/src/org/immutables/value/processor/meta/ImportsTypeStringResolver.java
Patch:
@@ -67,9 +67,6 @@ private String getFromSourceImports(String resolvable, boolean notTypeArgument)
 
     // where types are present and are different
     if (notTypeArgument && originType != null) {
-      if (resolvable.equals("ImmutableDelta")) {
-        System.out.println("Origin " + originType + "\nUsing " + usingType);
-      }
       if (!hasStarImports(importsSet)) {
         // Strongly assuming it comes from originating type's package
         return originType.packageOf().name() + "." + resolvable;

File: value-processor/src/org/immutables/value/processor/meta/AccessorAttributesCollector.java
Patch:
@@ -368,8 +368,9 @@ private boolean returnsNormalizedAbstractValueType(ExecutableElement validationM
           reporter,
           validationMethodCandidate,
           validationMethodCandidate.getReturnType(),
-          declaringType.asSet(),
-          protoclass.constitution().generics().vars());
+          new ImportsTypeStringResolver(declaringType.orNull(), declaringType.orNull()),
+          protoclass.constitution().generics().vars(),
+          null);
       provider.process();
       String returnTypeName = provider.returnTypeName();
       return protoclass.constitution().typeAbstract().toString().equals(returnTypeName);

File: value-processor/src/org/immutables/value/processor/meta/Generics.java
Patch:
@@ -114,8 +114,9 @@ TypeStringProvider newProvider(TypeMirror type) {
             protoclass.report(),
             element,
             type,
-            Collections.singleton(declaringType),
-            vars);
+            new ImportsTypeStringResolver(declaringType, declaringType),
+            vars,
+            null);
       }
     }
     return new Creator().create();

File: value-processor/src/org/immutables/value/processor/meta/Proto.java
Patch:
@@ -15,9 +15,6 @@
  */
 package org.immutables.value.processor.meta;
 
-import javax.lang.model.element.AnnotationValue;
-import org.immutables.value.processor.encode.EncodingInfo;
-import java.util.Collection;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.base.Preconditions;
@@ -29,6 +26,7 @@
 import com.google.common.collect.Interners;
 import com.google.common.collect.ObjectArrays;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
@@ -53,6 +51,7 @@
 import org.immutables.generator.SourceExtraction;
 import org.immutables.value.Value;
 import org.immutables.value.processor.encode.EncMetadataMirror;
+import org.immutables.value.processor.encode.EncodingInfo;
 import org.immutables.value.processor.encode.Inflater;
 import org.immutables.value.processor.encode.Instantiator;
 import org.immutables.value.processor.meta.Styles.UsingName.TypeNames;

File: value-processor/src/org/immutables/value/processor/meta/FuncMirrors.java
Patch:
@@ -23,4 +23,6 @@ private FuncMirrors() {}
   @Mirror.Annotation("org.immutables.func.Functional")
   public @interface Functional {}
 
+  @Mirror.Annotation("org.immutables.func.Functional.BindParameters")
+  public @interface BindParams {}
 }

File: value-processor/src/org/immutables/value/processor/encode/Processor.java
Patch:
@@ -9,6 +9,6 @@
 public class Processor extends AbstractGenerator {
   @Override
   protected void process() {
-		invoke(newTemplate(Encodings.class).generate());
+    invoke(new Generator_Encodings().generate());
   }
 }

File: value-processor/src/org/immutables/value/processor/meta/ValueType.java
Patch:
@@ -260,7 +260,7 @@ public List<CharSequence> getConstructorAnnotations() {
                   Collections.<String>emptySet(),
                   true,
                   false,
-                  ElementType.METHOD,
+                  ElementType.CONSTRUCTOR,
                   newTypeStringResolver());
         }
       }

File: value-processor/src/org/immutables/value/processor/meta/ValueType.java
Patch:
@@ -260,7 +260,7 @@ public List<CharSequence> getConstructorAnnotations() {
                   Collections.<String>emptySet(),
                   true,
                   false,
-                  ElementType.METHOD,
+                  ElementType.CONSTRUCTOR,
                   newTypeStringResolver());
         }
       }

File: generator/src/org/immutables/generator/SourceTypes.java
Patch:
@@ -24,13 +24,13 @@
 public class SourceTypes {
   private SourceTypes() {}
 
-  public static Entry<String, List<String>> extract(CharSequence returnTypeString) {
+  public static Entry<String, List<String>> extract(CharSequence typeString) {
     StringBuilder typeName = new StringBuilder();
     StringBuilder typeArgument = new StringBuilder();
     List<String> typeArguments = Lists.newArrayList();
     int anglesOpened = 0;
-    chars: for (int i = 0; i < returnTypeString.length(); i++) {
-      char c = returnTypeString.charAt(i);
+    chars: for (int i = 0; i < typeString.length(); i++) {
+      char c = typeString.charAt(i);
       switch (c) {
       case '<':
         if (++anglesOpened > 1) {

File: value-processor/src/org/immutables/value/processor/meta/Constitution.java
Patch:
@@ -31,6 +31,7 @@
 import org.immutables.generator.Naming;
 import org.immutables.generator.Naming.Preference;
 import org.immutables.generator.SourceExtraction;
+import org.immutables.generator.SourceTypes;
 import org.immutables.value.Value;
 import org.immutables.value.processor.meta.Proto.DeclaringType;
 import org.immutables.value.processor.meta.Proto.Protoclass;
@@ -722,11 +723,10 @@ private void lateValidateExtending(TypeElement t) {
     private boolean isExtending(TypeElement element) {
       if (element.getKind() == ElementKind.CLASS) {
         String superclassString = SourceExtraction.getSuperclassString(element);
+        String rawSuperclass = SourceTypes.extract(superclassString).getKey();
         // If we are extending yet to be generated builder, we detect it by having the same name
         // as relative name of builder type
-        if (superclassString.endsWith(typeImplementationBuilder().relative())) {
-          return true;
-        }
+        return rawSuperclass.endsWith(typeImplementationBuilder().relativeRaw());
       }
       return false;
     }

File: generator/src/org/immutables/generator/PostprocessingMachine.java
Patch:
@@ -475,7 +475,7 @@ static final class QualifiedNameMachine {
     void nextChar(char c, int i) {
       switch (state) {
       case UNDEFINED:
-        if (isLowerCaseAlphabetic(c)) {
+        if (isLowerCaseAlphabetic(c) || isUnderscore(c)) {
           state = FullyQualifiedNameState.PACKAGE_PART_CANDIDATE;
           importFrom = i;
         } else if (isAlphabetic(c) || isDigit(c) || isUnderscore(c)) {
@@ -495,7 +495,7 @@ void nextChar(char c, int i) {
         }
         break;
       case DOT:
-        if (isLowerCaseAlphabetic(c)) {
+        if (isLowerCaseAlphabetic(c) || isUnderscore(c)) {
           state = FullyQualifiedNameState.PACKAGE_PART_CANDIDATE;
         } else if (isUpperCaseAlphabetic(c)) {
           state = FullyQualifiedNameState.CLASS;

File: value-processor/src/org/immutables/value/processor/meta/ImportRewriteDisabler.java
Patch:
@@ -15,8 +15,8 @@
  */
 package org.immutables.value.processor.meta;
 
-import com.google.common.base.Splitter;
 import com.google.common.base.Ascii;
+import com.google.common.base.Splitter;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.PackageElement;
@@ -63,7 +63,7 @@ static boolean shouldDisableFor(ValueType type) {
         return true;
       }
     }
-
+    
     for (ValueType nested : type.nested) {
       if (shouldDisableFor(nested)) {
         return true;

File: value-processor/src/org/immutables/value/processor/ValuesTemplate.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.immutables.value.processor;
 
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimap;
 import org.immutables.generator.AbstractTemplate;
 import org.immutables.generator.Generator;

File: value-processor/src/org/immutables/value/processor/meta/AttributeTypeKind.java
Patch:
@@ -15,8 +15,6 @@
  */
 package org.immutables.value.processor.meta;
 
-import com.google.common.reflect.Reflection;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableMap;
 

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -142,6 +142,8 @@ private ValueMirrors() {}
 
     String typeModifiable() default "Modifiable*";
 
+    String typeWith() default "With*";
+
     String packageGenerated() default "*";
 
     Immutable defaults() default @Immutable;

File: generator-processor/src/org/immutables/generator/processor/Processor.java
Patch:
@@ -36,7 +36,7 @@
 import javax.tools.JavaFileObject;
 import javax.tools.StandardLocation;
 import org.immutables.generator.Generator;
-import org.immutables.generator.processor.Trees.Unit;
+import org.immutables.generator.processor.ImmutableTrees.Unit;
 import org.parboiled.Parboiled;
 import org.parboiled.errors.ErrorUtils;
 import org.parboiled.parserunners.ReportingParseRunner;

File: value-fixture/test/org/immutables/fixture/jdkonly/DefaultTest.java
Patch:
@@ -15,9 +15,8 @@
  */
 package org.immutables.fixture.jdkonly;
 
-import java.util.Arrays;
-import org.junit.Test;
 import com.google.common.collect.ImmutableSortedSet;
+import org.junit.Test;
 import static org.immutables.check.Checkers.check;
 
 public class DefaultTest {

File: value-processor/src/org/immutables/value/processor/meta/TypeStringProvider.java
Patch:
@@ -21,9 +21,7 @@
 import com.google.common.collect.Maps;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
 import java.util.Map.Entry;
 import javax.annotation.Nullable;
 import javax.lang.model.element.AnnotationMirror;

File: generator/src/org/immutables/generator/AnnotationMirrors.java
Patch:
@@ -15,20 +15,18 @@
  */
 package org.immutables.generator;
 
-import javax.lang.model.element.Name;
-import java.util.Arrays;
 import com.google.common.collect.ImmutableCollection;
 import com.google.common.collect.ImmutableList;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.annotation.Nullable;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;

File: generator/src/org/immutables/generator/Intrinsics.java
Patch:
@@ -70,7 +70,7 @@ private Intrinsics() {}
   public static Product $(Object... parameters) {
     return new Product(parameters);
   }
-  
+
   @SafeVarargs
   public static <T> Iterable<T> $(Iterable<? extends T>... iterables) {
     return Iterables.concat(iterables);

File: gson/test/org/immutables/gson/adapter/GsonFeaturesTest.java
Patch:
@@ -15,8 +15,6 @@
  */
 package org.immutables.gson.adapter;
 
-import static org.immutables.check.Checkers.check;
-import org.immutables.gson.adapter.NullAsDefault.Val;
 import com.google.common.collect.ImmutableMap;
 import com.google.gson.FieldNamingPolicy;
 import com.google.gson.Gson;
@@ -26,7 +24,7 @@
 import java.util.Map;
 import java.util.Set;
 import org.junit.Test;
-import static org.immutables.check.Checkers.*;
+import static org.immutables.check.Checkers.check;
 
 public class GsonFeaturesTest {
   final Gson gsonWithOptions = new GsonBuilder()

File: value-fixture/src/org/immutables/fixture/jdkonly/DefaultArray.java
Patch:
@@ -17,7 +17,6 @@
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
-import javax.annotation.Nullable;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-processor/src/org/immutables/value/processor/meta/Generics.java
Patch:
@@ -102,7 +102,7 @@ TypeStringProvider newProvider(TypeMirror type) {
             protoclass.report(),
             element,
             type,
-            declaringType,
+            Collections.singleton(declaringType),
             vars);
       }
     }

File: value-processor/src/org/immutables/value/processor/meta/Proto.java
Patch:
@@ -255,7 +255,7 @@ public boolean hasAstModule() {
 
     @Value.Lazy
     public boolean hasOrdinalModule() {
-      return findElement(TypeIntrospectionBase.ORDINAL_VALUE_INTERFACE_TYPE) != null;
+      return findElement(ORDINAL_VALUE_INTERFACE_TYPE) != null;
     }
 
     @Value.Lazy

File: value-processor/src/org/immutables/value/processor/meta/ValueAttribute.java
Patch:
@@ -15,8 +15,6 @@
  */
 package org.immutables.value.processor.meta;
 
-import org.immutables.generator.StringLiterals;
-import org.immutables.generator.Builtins.Literal;
 import com.google.common.base.Joiner;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Optional;
@@ -42,6 +40,7 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import org.immutables.generator.AnnotationMirrors;
+import org.immutables.generator.StringLiterals;
 import org.immutables.value.Value;
 import org.immutables.value.processor.meta.Generics.Parameter;
 import org.immutables.value.processor.meta.Proto.DeclaringType;

File: value-processor/src/org/immutables/value/processor/meta/GsonMirrors.java
Patch:
@@ -25,6 +25,8 @@ private GsonMirrors() {}
     boolean fieldNamingStrategy() default false;
 
     boolean emptyAsNulls() default false;
+
+    boolean nullAsDefault() default false;
   }
 
   @Mirror.Annotation("org.immutables.gson.Gson.ExpectedSubtypes")

File: value-processor/src/org/immutables/value/processor/meta/ValueAttribute.java
Patch:
@@ -1068,7 +1068,7 @@ private void validateTypeAndAnnotations() {
       typeKind = AttributeTypeKind.REGULAR;
       report()
           .annotationNamed(DefaultMirror.simpleName())
-          .warning("Generic wildcards are not supported, so the container attribute loosing its special treatment");
+          .warning("Generic wildcards are not supported, so the container attribute losing its special treatment");
     }
 
     if (isNullable()) {

File: value-processor/src/org/immutables/value/processor/meta/ValueAttribute.java
Patch:
@@ -1068,7 +1068,7 @@ private void validateTypeAndAnnotations() {
       typeKind = AttributeTypeKind.REGULAR;
       report()
           .annotationNamed(DefaultMirror.simpleName())
-          .warning("Generic wildcards are not supported, so the container attribute loosing its special treatment");
+          .warning("Generic wildcards are not supported, so the container attribute losing its special treatment");
     }
 
     if (isNullable()) {

File: value-fixture/src/org/immutables/fixture/generics/Secondie.java
Patch:
@@ -15,14 +15,15 @@
  */
 package org.immutables.fixture.generics;
 
+import org.immutables.gson.Gson;
 import com.google.common.collect.Multimap;
 import org.immutables.value.Value;
-
 import javax.annotation.Nullable;
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
+@Gson.TypeAdapters
 @Value.Modifiable
 @Value.Immutable
 public interface Secondie<T, V> {

File: value-fixture/test/org/immutables/fixture/jackson/JacksonGenericsTest.java
Patch:
@@ -32,7 +32,6 @@ public void rountrip() throws Exception {
     ObjectMapper mapper = new ObjectMapper();
     Abc abc = new Abc();
     String json = mapper.writeValueAsString(abc);
-    System.out.println(json);
     Abc value = mapper.readValue(json, Abc.class);
 
     check(value.cba).is(abc.cba);

File: value-processor/src/org/immutables/value/processor/meta/Constitution.java
Patch:
@@ -15,9 +15,6 @@
  */
 package org.immutables.value.processor.meta;
 
-import static com.google.common.base.Preconditions.checkState;
-import com.google.common.base.Preconditions;
-import org.immutables.value.processor.meta.Styles.PackageNaming;
 import com.google.common.base.Joiner;
 import com.google.common.base.Strings;
 import com.google.common.collect.Lists;
@@ -37,7 +34,9 @@
 import org.immutables.value.Value;
 import org.immutables.value.processor.meta.Proto.DeclaringType;
 import org.immutables.value.processor.meta.Proto.Protoclass;
+import org.immutables.value.processor.meta.Styles.PackageNaming;
 import org.immutables.value.processor.meta.Styles.UsingName.TypeNames;
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
 
 @Value.Nested

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.immutables.value.processor.meta;
 
-import org.immutables.value.Value.Style;
 import java.lang.annotation.Annotation;
 import org.immutables.mirror.Mirror;
 

File: value-processor/src/org/immutables/value/processor/meta/ValueType.java
Patch:
@@ -943,7 +943,7 @@ private boolean hasNonNullCheckableParametersInDefaultOrder() {
       if (c.hasConstructorParameterCustomOrder()) {
         return false;
       }
-      if (!c.isPrimitive() && !c.isNullable()) {
+      if (!c.typeKind().isRegular() || (!c.isPrimitive() && !c.isNullable())) {
         return false;
       }
     }

File: value/src/org/immutables/value/Value.java
Patch:
@@ -689,7 +689,8 @@
      * favor of using additive only initializers. For regular attributes, initializers could be
      * called only once, subsequent reinitialization with throw exception.
      * Also, "from" method (named by {@link #from()}) will not be generated on builder: it
-     * becomes error-inviting to reinitialize builder values.
+     * becomes error-inviting to reinitialize builder values. {@code Nullable} and {@code Default}
+     * container attributes are not supported when {@code strictBuilder = true}.
      * <p>
      * Usage of strict builders helps to prevent initialization mistakes early on.
      * @return if strict builder enabled

File: value-fixture/src/org/immutables/fixture/serial/SomeSer.java
Patch:
@@ -18,6 +18,7 @@
 import java.io.Serializable;
 import org.immutables.value.Value;
 
+@Value.Modifiable
 @Value.Immutable(intern = true)
 public abstract class SomeSer implements Serializable {
 
@@ -33,6 +34,7 @@ int version() {
     return 1;
   }
 
+  @Value.Modifiable
   @Value.Immutable(singleton = true)
   interface OthSer extends Serializable {}
 }

File: value-fixture/src/org/immutables/fixture/PrivateNoargConstructor.java
Patch:
@@ -3,6 +3,8 @@
 import org.immutables.value.Value;
 import org.immutables.value.Value.Style;
 
+public interface PrivateNoargConstructor {}
+
 @Value.Immutable
 @Style(privateNoargConstructor = true)
 interface PrivateNoargConstructorNominal {

File: value-fixture/src/org/immutables/fixture/Singletons.java
Patch:
@@ -4,7 +4,8 @@
 import java.util.List;
 import org.immutables.value.Value;
 
-// Compilation tests for singletons/builders
+//Compilation tests for singletons/builders
+public interface Singletons {}
 
 @Value.Immutable(singleton = true)
 interface Sing1 {

File: value-fixture/src/org/immutables/fixture/Wildcards.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture;
 
-import com.google.common.base.Optional;
+import javaslang.control.Option;
 import java.util.List;
 import org.immutables.value.Value;
 
@@ -24,5 +24,5 @@ public interface Wildcards {
 
   List<?> wilcards();
 
-  Optional<? super String> optional();
+  Option<? super String> option();
 }

File: value-processor/src/org/immutables/value/processor/meta/Styles.java
Patch:
@@ -15,8 +15,6 @@
  */
 package org.immutables.value.processor.meta;
 
-import com.google.common.base.Splitter;
-import com.google.common.base.Joiner;
 import com.google.common.base.CaseFormat;
 import org.immutables.generator.Naming;
 

File: generator/src/org/immutables/generator/TypeHierarchyCollector.java
Patch:
@@ -28,7 +28,7 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
-import static com.google.common.base.Preconditions.*;
+import static com.google.common.base.Verify.verify;
 
 @NotThreadSafe
 public final class TypeHierarchyCollector {
@@ -42,7 +42,7 @@ public void collectFrom(TypeMirror typeMirror) {
   }
 
   private DeclaredType toDeclaredType(TypeMirror typeMirror) {
-    checkArgument(typeMirror.getKind() == TypeKind.DECLARED);
+    verify(typeMirror.getKind() == TypeKind.DECLARED || typeMirror.getKind() == TypeKind.ERROR);
     return (DeclaredType) typeMirror;
   }
 

File: value-processor/src/org/immutables/value/processor/meta/AccessorAttributesCollector.java
Patch:
@@ -275,7 +275,7 @@ private void processGenerationCandidateMethod(ExecutableElement attributeMethodC
             } else {
               report(attributeMethodCandidate)
                   .annotationNamed(DefaultMirror.simpleName())
-                  .error("@Value.Default attibute should have initializer body", name);
+                  .error("@Value.Default attribute should have initializer body", name);
             }
           }
           if (derivedAnnotationPresent) {
@@ -286,7 +286,7 @@ private void processGenerationCandidateMethod(ExecutableElement attributeMethodC
             } else {
               report(attributeMethodCandidate)
                   .annotationNamed(DerivedMirror.simpleName())
-                  .error("@Value.Derived attibute should have initializer body", name);
+                  .error("@Value.Derived attribute should have initializer body", name);
             }
           }
         }

File: value-processor/src/org/immutables/value/processor/meta/AccessorAttributesCollector.java
Patch:
@@ -275,7 +275,7 @@ private void processGenerationCandidateMethod(ExecutableElement attributeMethodC
             } else {
               report(attributeMethodCandidate)
                   .annotationNamed(DefaultMirror.simpleName())
-                  .error("@Value.Default attibute should have initializer body", name);
+                  .error("@Value.Default attribute should have initializer body", name);
             }
           }
           if (derivedAnnotationPresent) {
@@ -286,7 +286,7 @@ private void processGenerationCandidateMethod(ExecutableElement attributeMethodC
             } else {
               report(attributeMethodCandidate)
                   .annotationNamed(DerivedMirror.simpleName())
-                  .error("@Value.Derived attibute should have initializer body", name);
+                  .error("@Value.Derived attribute should have initializer body", name);
             }
           }
         }

File: generator-processor/src/org/immutables/generator/processor/Introspection.java
Patch:
@@ -26,11 +26,13 @@ public abstract class Introspection {
   protected final ProcessingEnvironment environment;
   protected final Elements elements;
   protected final Types types;
+  protected final boolean inEclipseCompiler;
 
   Introspection(ProcessingEnvironment environment) {
     this.environment = environment;
     this.elements = environment.getElementUtils();
     this.types = environment.getTypeUtils();
+    this.inEclipseCompiler = environment.getClass().getName().startsWith("org.eclipse.jdt");
   }
 
   protected String toSimpleName(TypeMirror typeMirror) {

File: value-fixture/src/org/immutables/fixture/style/OptionalWithNullable.java
Patch:
@@ -10,6 +10,7 @@ public interface OptionalWithNullable {
   Optional<String> getJavaOptional();
 
   OptionalInt getJavaOptionalInt();
+  Optional<Integer> getJavaOptionalInteger();
 
   com.google.common.base.Optional<String> getGuavaOptional();
 }

File: value-fixture/test/org/immutables/fixture/ValuesTest.java
Patch:
@@ -408,6 +408,7 @@ public void optionalWhichAcceptsNullable() {
     ImmutableOptionalWithNullable.builder()
         .guavaOptional((String) null)
         .javaOptional((String) null)
+        .javaOptionalInteger((Integer) null)
         .build();
   }
 

File: value-fixture/src/org/immutables/fixture/style/OptionalWithNullable.java
Patch:
@@ -10,6 +10,7 @@ public interface OptionalWithNullable {
   Optional<String> getJavaOptional();
 
   OptionalInt getJavaOptionalInt();
+  Optional<Integer> getJavaOptionalInteger();
 
   com.google.common.base.Optional<String> getGuavaOptional();
 }

File: value-fixture/test/org/immutables/fixture/ValuesTest.java
Patch:
@@ -408,6 +408,7 @@ public void optionalWhichAcceptsNullable() {
     ImmutableOptionalWithNullable.builder()
         .guavaOptional((String) null)
         .javaOptional((String) null)
+        .javaOptionalInteger((Integer) null)
         .build();
   }
 

File: value/src/org/immutables/value/Value.java
Patch:
@@ -685,7 +685,7 @@
 
     /**
      * Specify the mode in which visibility of generated value type is derived from abstract value
-     * type. It is a good idea to not specify such attributea inline with immutable values, but
+     * type. It is a good idea to not specify such attributes inline with immutable values, but
      * rather create style annotation (@see Style).
      * @return implementation visibility
      */

File: value/src/org/immutables/value/Value.java
Patch:
@@ -685,7 +685,7 @@
 
     /**
      * Specify the mode in which visibility of generated value type is derived from abstract value
-     * type. It is a good idea to not specify such attributea inline with immutable values, but
+     * type. It is a good idea to not specify such attributes inline with immutable values, but
      * rather create style annotation (@see Style).
      * @return implementation visibility
      */

File: value-fixture/src/org/immutables/fixture/jackson/Foo.java
Patch:
@@ -1,10 +1,9 @@
 package org.immutables.fixture.jackson;
 
-import org.immutables.value.Value;
 import com.fasterxml.jackson.annotation.JsonProperty;
-import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
 import com.fasterxml.jackson.databind.annotation.JsonSerialize;
+import org.immutables.value.Value;
 
 @Value.Immutable
 @JsonSerialize(as = ImmutableFoo.class)

File: func/test/org/immutables/func/fixture/Use.java
Patch:
@@ -5,9 +5,9 @@
 
 public class Use {
   public static void main(String... args) {
-    Predicate<ImmutableVal> empty = ValFunctions.isEmpty();
-    Function<ImmutableVal, String> name = ValFunctions.getName();
-    Function<ImmutableVal, Integer> age = ValFunctions.age();
+    Predicate<Val> empty = ValFunctions.isEmpty();
+    Function<Val, String> name = ValFunctions.getName();
+    Function<Val, Integer> age = ValFunctions.age();
     System.out.println(empty);
     System.out.println(name);
     System.out.println(age);

File: cases/src/org/immutables/trees/ast/Extractions.java
Patch:
@@ -116,7 +116,7 @@ public boolean run(Context<Object> context) {
 
       @Override
       public String toString() {
-        return Extractions.class.getSimpleName() + ".diagnose()";
+        return Extractions.class.getSimpleName() + ".print()";
       }
     };
   }

File: value-processor/src/org/immutables/value/processor/meta/Proto.java
Patch:
@@ -1175,6 +1175,7 @@ public StyleInfo apply(StyleMirror input) {
           input.typeImmutableEnclosing(),
           input.typeImmutableNested(),
           input.typeModifiable(),
+          input.typeWith(),
           ToImmutableInfo.FUNCTION.apply(input.defaults()),
           input.strictBuilder(),
           input.allParameters(),

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -135,6 +135,8 @@ private ValueMirrors() {}
 
     String typeModifiable() default "Modifiable*";
 
+    String typeWith() default "With";
+
     Immutable defaults() default @Immutable;
 
     boolean strictBuilder() default false;

File: generator/src/org/immutables/generator/Naming.java
Patch:
@@ -204,7 +204,7 @@ public boolean isConstant() {
     public Naming requireNonConstant(Preference preference) {
       switch (preference) {
       case SUFFIX:
-        return new PrefixSuffixNaming("", name);
+        return new PrefixSuffixNaming("", Usage.CAPITALIZED.apply(name));
       case PREFIX:
       default:
         return new PrefixSuffixNaming(name, "");
@@ -235,7 +235,7 @@ public String apply(String input) {
           ? Usage.INDIFFERENT
           : Usage.CAPITALIZED;
 
-      return prefix + resultFormat.apply(input) + Usage.CAPITALIZED.apply(suffix);
+      return prefix + resultFormat.apply(input) + suffix;
     }
 
     @Override

File: gson/test/org/immutables/gson/packg/PackgTest.java
Patch:
@@ -29,5 +29,8 @@ public void adaptersProvided() {
     check(adapterFactory.create(gson, TypeToken.get(A.class))).notNull();
     check(adapterFactory.create(gson, TypeToken.get(B.class))).notNull();
     check(adapterFactory.create(gson, TypeToken.get(B.C.class))).notNull();
+    check(adapterFactory.create(gson, TypeToken.get(D.E.class))).notNull();
+    check(adapterFactory.create(gson, TypeToken.get(D.F.class))).notNull();
+    check(adapterFactory.create(gson, TypeToken.get(G.H.class))).notNull();
   }
 }

File: value-processor/src/org/immutables/value/processor/Gsons.java
Patch:
@@ -77,6 +77,7 @@ public Iterable<TypeAdapterTypes> typeAdapters() {
   @Generator.Typedef
   Map.Entry<String, ValueAttribute> Nv;
 
+  // Uhh that's ugly )))
   public final Function<Iterable<ValueAttribute>, Multimap<Character, Map.Entry<String, ValueAttribute>>> byFirstCharacter =
       new Function<Iterable<ValueAttribute>, Multimap<Character, Map.Entry<String, ValueAttribute>>>() {
         @Override

File: value-fixture/test/org/immutables/fixture/modifiable/ModifiablesTest.java
Patch:
@@ -84,7 +84,7 @@ public void uninitializedEquals() {
   }
 
   @Test
-  public void equalsWithDifferenObjectType() {
+  public void equalsWithDifferentObjectType() {
     check(ModifiableCompanion.create()).not().is(equalTo(new Object()));
   }
 

File: value-fixture/test/org/immutables/fixture/modifiable/ModifiablesTest.java
Patch:
@@ -84,7 +84,7 @@ public void uninitializedEquals() {
   }
 
   @Test
-  public void equalsWithDifferenObjectType() {
+  public void equalsWithDifferentObjectType() {
     check(ModifiableCompanion.create()).not().is(equalTo(new Object()));
   }
 

File: value-processor/src/org/immutables/value/processor/meta/StyleInfo.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.immutables.value.processor.meta;
 
-import org.immutables.value.processor.meta.ValueMirrors.Style.BuilderVisibility;
 import java.lang.annotation.Annotation;
 import org.immutables.value.Value;
 import com.google.common.collect.ImmutableSet;

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -166,7 +166,7 @@ private ValueMirrors() {}
     boolean clearBuilder() default false;
 
     boolean deepImmutablesDetection() default false;
-    
+
     boolean overshadowImplementation() default false;
 
     boolean implementationNestedInBuilder() default false;

File: value-fixture/src/org/immutables/fixture/deep/Canvas.java
Patch:
@@ -19,10 +19,8 @@ public interface Color {
 
   @Value.Immutable
   public interface Line {
-    @Value.Parameter
     Point start();
 
-    @Value.Parameter
     Point end();
 
     Color color();

File: value-processor/src/org/immutables/value/processor/ValuesTemplate.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.immutables.value.processor;
 
+import org.immutables.value.processor.meta.UnshadeGuava;
 import com.google.common.collect.Multimap;
 import org.immutables.generator.AbstractTemplate;
 import org.immutables.generator.Generator;
@@ -42,6 +43,8 @@ abstract class ValuesTemplate extends AbstractTemplate {
 
   public abstract Templates.Invokable generate();
 
+  public final String guava = UnshadeGuava.prefix();
+
   public final LongBits longsFor = new LongBits();
 
   private Multimap<DeclaringPackage, ValueType> values;

File: value-processor/src/org/immutables/value/processor/meta/Styles.java
Patch:
@@ -15,9 +15,10 @@
  */
 package org.immutables.value.processor.meta;
 
-import com.google.common.base.CaseFormat;
 import org.immutables.generator.Naming;
 
+import com.google.common.base.CaseFormat;
+
 public final class Styles {
   private final StyleInfo style;
   private final Scheme scheme;
@@ -190,6 +191,7 @@ public class AttributeNames {
       public final String addAll = scheme.addAll.apply(raw);
       public final String put = scheme.put.apply(raw);
       public final String putAll = scheme.putAll.apply(raw);
+      public final String jsonSet = Naming.from("set*").apply(raw);
 
       public String set() {
         return scheme.set.apply(raw);

File: mongo/src/org/immutables/mongo/repository/internal/BsonEncoding.java
Patch:
@@ -69,7 +69,7 @@ public final class BsonEncoding {
       .enable(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES);
 
   /**
-   * This field name will cause an MongoDB confuse if not unwrapped correctly so it's may be a good
+   * This field name will cause an MongoDB confuse if not unwrapped correctly so it may be a good
    * choice.
    */
   private static final String PREENCODED_VALUE_WRAPPER_FIELD_NAME = "$";

File: serial/src/org/immutables/serial/Serial.java
Patch:
@@ -49,7 +49,7 @@
    * <p>
    * Structural serialization of value types use attribute names, collections, optional values and
    * map into the representation, rather than exact internal fields used to store the data. The
-   * important aspect of this is that objects are being deserialized using it's constructors and
+   * important aspect of this is that objects are being deserialized using their constructors and
    * builders, and not the internal representation, thus all singletons, interning and other
    * invariants will be preserved and data migration made possible (using either optional or
    * nullable attributes) or changing types of collections, moving from scalar values to collections

File: value-processor/src/org/immutables/value/processor/meta/FromSupertypesModel.java
Patch:
@@ -72,7 +72,7 @@ public String toString() {
     }
 
     // This abstract value type should be always present and be a from target,
-    // even if it's not defines any specific attributes (just inherits)
+    // even if it doesn't define any specific attributes (just inherits)
     if (!attributeByType.containsKey(abstractTypeName)) {
       builder.add(new FromSupertype(abstractTypeName, ImmutableList.<ValueAttribute>of()));
     }

File: value-processor/src/org/immutables/value/processor/meta/TypeStringProvider.java
Patch:
@@ -87,7 +87,7 @@ void process() {
         this.buffer = new StringBuilder(workaroundTypeString);
       }
 
-      // It's seems that array type annotations are not exposed in javac
+      // It seems that array type annotations are not exposed in javac
       // Nested type argument's type annotations are not exposed as well (in javac)
       // So currently we instert only for top level, declared type (here),
       // and primitives (see above)

File: value-processor/src/org/immutables/value/processor/meta/ValueAttribute.java
Patch:
@@ -838,7 +838,7 @@ private void makeRegularIfDefaultWithValidation() {
       typeKind = AttributeTypeKind.REGULAR;
       report()
           .annotationNamed(DefaultMirror.simpleName())
-          .warning("@Value.Default on a container attribute make it lose it's special treatment");
+          .warning("@Value.Default on a container attribute make it lose its special treatment");
     }
   }
 

File: value/src/org/immutables/value/Value.java
Patch:
@@ -244,7 +244,7 @@
   @Retention(RetentionPolicy.CLASS)
   public @interface Parameter {
     /**
-     * Used to specify order of constructor argument. It's defaults to zero and allows for
+     * Used to specify order of constructor argument. It defaults to zero and allows for
      * non-contiguous order values (arguments are sorted ascending by this order value).
      * <p>
      * <em>This attribute was introduced as potentially not all annotation processors could use source
@@ -253,7 +253,7 @@
      * developer should supply argument order explicitly.
      * As of version 1.0, we implemented workaround for
      * the Eclipse compiler, so it is not strictly needed to specify order,
-     * but it's still might be needed if you wish to reorder arguments</em>
+     * but it still might be needed if you wish to reorder arguments</em>
      * @return order
      */
     int order() default 0;
@@ -657,7 +657,7 @@
      * copied using special logic, such as {@code Nullable} annotations (and Jackson annotations)
      * <p>
      * This style parameter is experimental and may change in future.
-     * @return types of annotations to pass to an immutable implementation class and it's
+     * @return types of annotations to pass to an immutable implementation class and its
      *         attributes.
      */
     Class<? extends Annotation>[] passAnnotations() default {};

File: mongo/src/org/immutables/mongo/repository/internal/BsonEncoding.java
Patch:
@@ -69,7 +69,7 @@ public final class BsonEncoding {
       .enable(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES);
 
   /**
-   * This field name will cause an MongoDB confuse if not unwrapped correctly so it's may be a good
+   * This field name will cause an MongoDB confuse if not unwrapped correctly so it may be a good
    * choice.
    */
   private static final String PREENCODED_VALUE_WRAPPER_FIELD_NAME = "$";

File: serial/src/org/immutables/serial/Serial.java
Patch:
@@ -49,7 +49,7 @@
    * <p>
    * Structural serialization of value types use attribute names, collections, optional values and
    * map into the representation, rather than exact internal fields used to store the data. The
-   * important aspect of this is that objects are being deserialized using it's constructors and
+   * important aspect of this is that objects are being deserialized using their constructors and
    * builders, and not the internal representation, thus all singletons, interning and other
    * invariants will be preserved and data migration made possible (using either optional or
    * nullable attributes) or changing types of collections, moving from scalar values to collections

File: value-processor/src/org/immutables/value/processor/meta/FromSupertypesModel.java
Patch:
@@ -72,7 +72,7 @@ public String toString() {
     }
 
     // This abstract value type should be always present and be a from target,
-    // even if it's not defines any specific attributes (just inherits)
+    // even if it doesn't define any specific attributes (just inherits)
     if (!attributeByType.containsKey(abstractTypeName)) {
       builder.add(new FromSupertype(abstractTypeName, ImmutableList.<ValueAttribute>of()));
     }

File: value-processor/src/org/immutables/value/processor/meta/TypeStringProvider.java
Patch:
@@ -87,7 +87,7 @@ void process() {
         this.buffer = new StringBuilder(workaroundTypeString);
       }
 
-      // It's seems that array type annotations are not exposed in javac
+      // It seems that array type annotations are not exposed in javac
       // Nested type argument's type annotations are not exposed as well (in javac)
       // So currently we instert only for top level, declared type (here),
       // and primitives (see above)

File: value-processor/src/org/immutables/value/processor/meta/ValueAttribute.java
Patch:
@@ -838,7 +838,7 @@ private void makeRegularIfDefaultWithValidation() {
       typeKind = AttributeTypeKind.REGULAR;
       report()
           .annotationNamed(DefaultMirror.simpleName())
-          .warning("@Value.Default on a container attribute make it lose it's special treatment");
+          .warning("@Value.Default on a container attribute make it lose its special treatment");
     }
   }
 

File: value/src/org/immutables/value/Value.java
Patch:
@@ -244,7 +244,7 @@
   @Retention(RetentionPolicy.CLASS)
   public @interface Parameter {
     /**
-     * Used to specify order of constructor argument. It's defaults to zero and allows for
+     * Used to specify order of constructor argument. It defaults to zero and allows for
      * non-contiguous order values (arguments are sorted ascending by this order value).
      * <p>
      * <em>This attribute was introduced as potentially not all annotation processors could use source
@@ -253,7 +253,7 @@
      * developer should supply argument order explicitly.
      * As of version 1.0, we implemented workaround for
      * the Eclipse compiler, so it is not strictly needed to specify order,
-     * but it's still might be needed if you wish to reorder arguments</em>
+     * but it still might be needed if you wish to reorder arguments</em>
      * @return order
      */
     int order() default 0;
@@ -657,7 +657,7 @@
      * copied using special logic, such as {@code Nullable} annotations (and Jackson annotations)
      * <p>
      * This style parameter is experimental and may change in future.
-     * @return types of annotations to pass to an immutable implementation class and it's
+     * @return types of annotations to pass to an immutable implementation class and its
      *         attributes.
      */
     Class<? extends Annotation>[] passAnnotations() default {};

File: value-processor/src/org/immutables/value/processor/meta/AccessorAttributesCollector.java
Patch:
@@ -321,11 +321,11 @@ private void processGenerationCandidateMethod(ExecutableElement attributeMethodC
 
       // Compute this eagerly here, for no strong reason
       if (attribute.isGenerateDefault) {
-        type.hasDefaultAttributes = true;
+        type.defaultAttributesCount++;
       }
 
       if (attribute.isGenerateDerived) {
-        type.hasDerivedAttributes = true;
+        type.derivedAttributesCount++;
       }
 
       if (attributeMethodCandidate.getEnclosingElement().equals(originalType)) {

File: value-processor/src/org/immutables/value/processor/meta/Proto.java
Patch:
@@ -1081,6 +1081,7 @@ public StyleInfo apply(StyleMirror input) {
           input.generateSuppressAllWarnings(),
           input.privateNoargConstructor(),
           input.attributelessSingleton(),
+          input.unsafeDefaultAndDerived(),
           input.throwForInvalidImmutableStateName());
     }
   }

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -161,6 +161,8 @@ private ValueMirrors() {}
 
     boolean attributelessSingleton() default false;
 
+    boolean unsafeDefaultAndDerived() default false;
+
     Class<? extends Exception> throwForInvalidImmutableState() default IllegalStateException.class;
 
     public enum ImplementationVisibility {

File: value/src/org/immutables/value/Value.java
Patch:
@@ -714,7 +714,7 @@
      * Exception to throw when an immutable object is in an invalid state. The Throwable must have
      * a constructor that takes a single string
      */
-    Class<? extends Exception> throwForInvalidImmutableState() default IllegalStateException.class;
+    Class<? extends RuntimeException> throwForInvalidImmutableState() default IllegalStateException.class;
 
     /**
      * If implementation visibility is more restrictive than visibility of abstract value type, then

File: value-processor/src/org/immutables/value/processor/meta/Proto.java
Patch:
@@ -1080,6 +1080,7 @@ public StyleInfo apply(StyleMirror input) {
           input.optionalAcceptNullable(),
           input.generateSuppressAllWarnings(),
           input.privateNoargConstructor(),
+          input.attributelessSingleton(),
           input.throwForInvalidImmutableStateName());
     }
   }

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -159,6 +159,8 @@ private ValueMirrors() {}
 
     boolean privateNoargConstructor() default false;
 
+    boolean attributelessSingleton() default false;
+
     Class<? extends Exception> throwForInvalidImmutableState() default IllegalStateException.class;
 
     public enum ImplementationVisibility {

File: value-processor/src/org/immutables/value/processor/meta/Proto.java
Patch:
@@ -1053,7 +1053,8 @@ public StyleInfo apply(StyleMirror input) {
           ImmutableSet.copyOf(input.additionalJsonAnnotationsName()),
           input.visibility(),
           input.optionalAcceptNullable(),
-          input.generateSuppressAllWarnings());
+          input.generateSuppressAllWarnings(),
+          input.privateNoargConstructor());
     }
   }
 

File: value-processor/src/org/immutables/value/processor/meta/ValueAttribute.java
Patch:
@@ -26,7 +26,6 @@
 
 import java.lang.annotation.ElementType;
 import java.util.Collections;
-import java.util.HashSet;
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.Set;

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -138,6 +138,8 @@ private ValueMirrors() {}
     boolean optionalAcceptNullable() default false;
 
     boolean generateSuppressAllWarnings() default true;
+    
+    boolean privateNoargConstructor() default false;
 
     public enum ImplementationVisibility {
       PUBLIC,

File: value-processor/src/org/immutables/value/processor/meta/Proto.java
Patch:
@@ -1054,7 +1054,8 @@ public StyleInfo apply(StyleMirror input) {
           ImmutableSet.copyOf(input.additionalJsonAnnotationsName()),
           input.visibility(),
           input.optionalAcceptNullable(),
-          input.generateSuppressAllWarnings());
+          input.generateSuppressAllWarnings(),
+          input.privateNoargConstructor());
     }
   }
 

File: value-processor/src/org/immutables/value/processor/meta/ValueAttribute.java
Patch:
@@ -26,7 +26,6 @@
 
 import java.lang.annotation.ElementType;
 import java.util.Collections;
-import java.util.HashSet;
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.Set;

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -138,6 +138,8 @@ private ValueMirrors() {}
     boolean optionalAcceptNullable() default false;
 
     boolean generateSuppressAllWarnings() default true;
+    
+    boolean privateNoargConstructor() default false;
 
     public enum ImplementationVisibility {
       PUBLIC,

File: value-processor/src/org/immutables/value/processor/meta/ValueType.java
Patch:
@@ -339,7 +339,7 @@ public boolean isUseConstructorOnly() {
   public boolean isUseCopyMethods() {
     return immutableFeatures.copy()
         && !constitution.returnsAbstractValueType()
-        && !getImplementedAttributes().isEmpty();
+        && !getSettableAttributes().isEmpty();
   }
 
   public boolean isUseCopyConstructor() {

File: cases/test/org/immutables/trees/ast/SampleTree.java
Patch:
@@ -9,7 +9,7 @@
  * Compilation test for Ast Tree generation.
  */
 @Trees.Ast
-@Trees.Transform
+@Trees.Transform(include = IncludedTree.class)
 @Value.Enclosing
 public class SampleTree {
   interface Expression {}

File: value-processor/src/org/immutables/value/processor/Processor.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.immutables.value.processor;
 
+import org.immutables.value.processor.meta.TransformMirror;
 import com.google.common.collect.Multimap;
 import javax.annotation.processing.SupportedAnnotationTypes;
 import org.immutables.generator.AbstractGenerator;
@@ -36,6 +37,7 @@
     EnclosingMirror.QUALIFIED_NAME,
     IncludeMirror.QUALIFIED_NAME,
     ValueUmbrellaMirror.QUALIFIED_NAME,
+    TransformMirror.QUALIFIED_NAME,
 })
 public final class Processor extends AbstractGenerator {
   @Override

File: value-processor/src/org/immutables/value/processor/meta/TreesMirrors.java
Patch:
@@ -9,5 +9,7 @@ private TreesMirrors() {}
   public @interface Ast {}
 
   @Mirror.Annotation("org.immutables.trees.Trees.Transform")
-  public @interface Transform {}
+  public @interface Transform {
+    Class<?>[] include() default {};
+  }
 }

File: value-fixture/src/org/immutables/fixture/AlternativeConstructor.java
Patch:
@@ -1,8 +1,7 @@
 package org.immutables.fixture;
-import org.immutables.value.Value;
-
 import java.util.ArrayList;
 import java.util.List;
+import org.immutables.value.Value;
 
 @Value.Immutable
 public abstract class AlternativeConstructor {

File: value-fixture/src/org/immutables/fixture/ExtendingInnerBuilderValue.java
Patch:
@@ -1,9 +1,8 @@
 package org.immutables.fixture;
 
-import java.security.KeyStore.Entry.Attribute;
 import java.util.List;
-import org.immutables.value.Value.Style.ImplementationVisibility;
 import org.immutables.value.Value;
+import org.immutables.value.Value.Style.ImplementationVisibility;
 
 @Value.Immutable
 class SuperInnerBuildeValue {

File: value-fixture/src/org/immutables/fixture/SillyStructureWithId.java
Patch:
@@ -15,9 +15,9 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.fixture.subpack.SillySubstructure;
 import com.google.common.base.Optional;
 import java.util.List;
+import org.immutables.fixture.subpack.SillySubstructure;
 import org.immutables.gson.Gson;
 import org.immutables.mongo.Mongo;
 import org.immutables.value.Value;

File: value-fixture/src/org/immutables/fixture/couse/sub/AbstractC.java
Patch:
@@ -15,11 +15,11 @@
  */
 package org.immutables.fixture.couse.sub;
 
-import java.util.List;
 import com.google.common.base.Optional;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
+import java.util.List;
 import java.util.Map;
 import org.immutables.fixture.couse.A;
 import org.immutables.fixture.couse.B;

File: value-fixture/src/org/immutables/fixture/jackson/MetaJacksonAnnotation.java
Patch:
@@ -1,9 +1,9 @@
 package org.immutables.fixture.jackson;
 
-import org.immutables.value.Value;
 import com.fasterxml.jackson.databind.annotation.JsonSerialize;
-import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import org.immutables.value.Value;
 
 @JsonSerialize
 @Retention(RetentionPolicy.CLASS)

File: value-fixture/src/org/immutables/fixture/jackson/SampleJacksonMapped.java
Patch:
@@ -15,9 +15,9 @@
  */
 package org.immutables.fixture.jackson;
 
+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
 import com.google.common.base.Objects;
 import com.google.common.base.Optional;
-import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
 import java.util.List;
 import org.immutables.value.Value;
 

File: value-fixture/src/org/immutables/fixture/jdkonly/JdkMaps.java
Patch:
@@ -15,12 +15,12 @@
  */
 package org.immutables.fixture.jdkonly;
 
-import org.immutables.value.Value.Style.ImplementationVisibility;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Map;
 import java.util.NavigableMap;
 import java.util.SortedMap;
 import org.immutables.value.Value;
+import org.immutables.value.Value.Style.ImplementationVisibility;
 
 @Value.Immutable(singleton = true)
 @Value.Style(visibility = ImplementationVisibility.PRIVATE, jdkOnly = true)

File: value-fixture/src/org/immutables/fixture/serial/SomeSer.java
Patch:
@@ -15,8 +15,8 @@
  */
 package org.immutables.fixture.serial;
 
-import org.immutables.value.Value;
 import java.io.Serializable;
+import org.immutables.value.Value;
 
 @Value.Immutable(intern = true)
 public abstract class SomeSer implements Serializable {

File: value-fixture/src/org/immutables/fixture/strict/Aar.java
Patch:
@@ -15,10 +15,10 @@
  */
 package org.immutables.fixture.strict;
 
-import org.immutables.value.Value;
 import com.google.common.base.Optional;
-import java.util.Map;
 import java.util.List;
+import java.util.Map;
+import org.immutables.value.Value;
 
 @Value.Immutable
 interface Aar {

File: value-fixture/src/org/immutables/fixture/strict/package-info.java
Patch:
@@ -5,3 +5,4 @@
 package org.immutables.fixture.strict;
 
 import org.immutables.value.Value;
+

File: value-fixture/src/org/immutables/fixture/style/Conservative.java
Patch:
@@ -15,8 +15,8 @@
  */
 package org.immutables.fixture.style;
 
-import java.lang.annotation.Retention;
 import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 import org.immutables.value.Value;

File: value-fixture/src/org/immutables/fixture/style/EnclosingHiddenImplementation.java
Patch:
@@ -16,8 +16,8 @@
 package org.immutables.fixture.style;
 
 import com.google.common.base.Optional;
-import org.immutables.value.Value.Style.ImplementationVisibility;
 import org.immutables.value.Value;
+import org.immutables.value.Value.Style.ImplementationVisibility;
 
 @Value.Style(
     typeImmutableEnclosing = "EnclosingFactory",

File: value-fixture/src/org/immutables/fixture/style/HiddenImplementation.java
Patch:
@@ -15,8 +15,8 @@
  */
 package org.immutables.fixture.style;
 
-import org.immutables.value.Value.Style.ImplementationVisibility;
 import org.immutables.value.Value;
+import org.immutables.value.Value.Style.ImplementationVisibility;
 
 /**
  * Feature combination

File: value-fixture/src/org/immutables/fixture/style/IncludeNestedTypes.java
Patch:
@@ -15,10 +15,9 @@
  */
 package org.immutables.fixture.style;
 
-import org.immutables.value.Value;
-
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import org.immutables.value.Value;
 
 @Value.Enclosing
 @Value.Include({Target.class, Retention.class})

File: value-fixture/test/org/immutables/fixture/marshal/MarshallingTest.java
Patch:
@@ -15,13 +15,11 @@
  */
 package org.immutables.fixture.marshal;
 
-import com.google.gson.JsonNull;
-import org.immutables.fixture.subpack.SillySubstructure;
-import org.immutables.fixture.SillyStructure;
 import com.fasterxml.jackson.core.JsonFactory;
 import com.fasterxml.jackson.core.JsonGenerator;
 import com.fasterxml.jackson.core.JsonParser;
 import com.google.common.base.CharMatcher;
+import com.google.gson.JsonNull;
 import com.google.gson.reflect.TypeToken;
 import de.undercouch.bson4jackson.BsonFactory;
 import java.util.List;
@@ -33,9 +31,11 @@
 import org.immutables.fixture.JsonIgnore;
 import org.immutables.fixture.SillyPolyHost;
 import org.immutables.fixture.SillyPolyHost2;
+import org.immutables.fixture.SillyStructure;
 import org.immutables.fixture.SillyTuplie;
 import org.immutables.fixture.nested.ImmutableCadabra;
 import org.immutables.fixture.nested.NonGrouped;
+import org.immutables.fixture.subpack.SillySubstructure;
 import org.junit.Test;
 import static org.immutables.check.Checkers.*;
 

File: value-fixture/test/org/immutables/fixture/nested/BaseFromTest.java
Patch:
@@ -1,7 +1,7 @@
 package org.immutables.fixture.nested;
 
-import static org.immutables.check.Checkers.*;
 import org.junit.Test;
+import static org.immutables.check.Checkers.*;
 
 public class BaseFromTest {
   @Test

File: value-processor/src/org/immutables/value/processor/meta/CaseStructure.java
Patch:
@@ -27,9 +27,9 @@
 
 public class CaseStructure {
   public final List<ValueType> implementedTypes;
+  public final SetMultimap<String, ValueType> subtypeUsages = HashMultimap.create();
   private final Set<String> implementedTypeNames;
   private final SetMultimap<String, ValueType> subtyping;
-  public final SetMultimap<String, ValueType> subtypeUsages = HashMultimap.create();
 
   CaseStructure(ValueType discoveredValue) {
     this.implementedTypes = discoveredValue.nested;
@@ -84,9 +84,10 @@ public boolean apply(String input) {
         public Iterable<ValueType> apply(@Nullable String typeName) {
           Set<ValueType> subtypes = subtyping.get(typeName);
           subtypeUsages.putAll(typeName, subtypes);
+          /*
           for (ValueType subtype : subtypes) {
             subtypeUsages.put(subtype.typeAbstract().toString(), subtype);
-          }
+          }*/
           return subtypes;
         }
       };

File: value-fixture/test/org/immutables/fixture/marshal/MarshallingTest.java
Patch:
@@ -63,7 +63,7 @@ public void discoveredMarhaler() {
   public void unmarshalSingleton() {
     check(Marshaling.fromJson("[11]", NonGrouped.Cadabra.class)).same(ImmutableCadabra.of());
     check(Marshaling.fromJson("{\"x\": true}", NonGrouped.Cadabra.class)).same(ImmutableCadabra.of());
-    check(Marshaling.fromJson("null", NonGrouped.Cadabra.class)).same(ImmutableCadabra.of());
+    check(Marshaling.fromJson("{}", NonGrouped.Cadabra.class)).same(ImmutableCadabra.of());
   }
 
   @Test

File: value-processor/src/org/immutables/value/processor/meta/Proto.java
Patch:
@@ -983,6 +983,7 @@ public StyleInfo apply(StyleMirror input) {
           ToImmutableInfo.FUNCTION.apply(input.defaults()),
           input.strictBuilder(),
           input.allParameters(),
+          input.defaultAsDefault(),
           input.jdkOnly(),
           ImmutableSet.copyOf(input.passAnnotationsName()),
           input.visibility());

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -121,6 +121,8 @@ private ValueMirrors() {}
 
     boolean allParameters() default false;
 
+    boolean defaultAsDefault() default false;
+
     boolean jdkOnly() default false;
 
     Class<? extends Annotation>[] passAnnotations() default {};

File: value-processor/src/org/immutables/value/processor/meta/CaseStructure.java
Patch:
@@ -40,7 +40,7 @@ public class CaseStructure {
   private static Set<String> buildImplementedTypesSet(List<ValueType> implementationTypes) {
     ImmutableSet.Builder<String> builder = ImmutableSet.builder();
     for (ValueType discoveredValue : implementationTypes) {
-      builder.add(discoveredValue.typeAbstract().toString());
+      builder.add(discoveredValue.typeValue().toString());
     }
     return builder.build();
   }

File: value-fixture/src/org/immutables/fixture/ExtendingInnerBuilderValue.java
Patch:
@@ -1,5 +1,6 @@
 package org.immutables.fixture;
 
+import org.immutables.value.Value.Style.ImplementationVisibility;
 import org.immutables.value.Value;
 
 @Value.Immutable
@@ -14,10 +15,11 @@ static void use() {
   }
 }
 
+@Value.Style(typeBuilder = "*_Builder", visibility = ImplementationVisibility.PRIVATE)
 @Value.Immutable
 class ExtendingInnerBuilderValue {
 
-  static class Builder extends ImmutableExtendingInnerBuilderValue.Builder {}
+  static class Builder extends ExtendingInnerBuilderValue_Builder {}
 
   static void use() {
     new ExtendingInnerBuilderValue.Builder().build();

File: value-fixture/src/org/immutables/fixture/style/IncludeTypes.java
Patch:
@@ -34,9 +34,9 @@ public class IncludeTypes {
 
   void use() {
     // this immutable type (package style used)
-    ImIncludeTypes.of();
+    ImIncludeTypes.builder().build();
     // included on this type (package style used)
-    ImSerializable.of();
+    ImSerializable.builder().build();
     // included on package (package style used)
     ImTicker.builder().read(1).build();
 

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.immutables.value.processor.meta;
 
+import java.lang.annotation.Annotation;
 import org.immutables.mirror.Mirror;
 
 public final class ValueMirrors {
@@ -122,6 +123,8 @@ private ValueMirrors() {}
 
     boolean jdkOnly() default false;
 
+    Class<? extends Annotation>[] passAnnotations() default {};
+
     ImplementationVisibility visibility() default ImplementationVisibility.SAME;
 
     public enum ImplementationVisibility {

File: serial/src/org/immutables/serial/Serial.java
Patch:
@@ -22,6 +22,7 @@
 
 /**
  * Use nested annotations to control serialization of value objects.
+ * This serialization module currently is in experimental state.
  * <p>
  * This umbrella annotaion does nothing.
  * @see Version

File: value-processor/src/org/immutables/value/processor/meta/Proto.java
Patch:
@@ -906,6 +906,7 @@ public StyleInfo apply(StyleMirror input) {
           input.strictBuilder(),
           input.allParameters(),
           input.jdkOnly(),
+          ImmutableSet.copyOf(input.passAnnotationsName()),
           input.visibility());
     }
   }

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.immutables.value.processor.meta;
 
+import java.lang.annotation.Annotation;
 import org.immutables.mirror.Mirror;
 
 public final class ValueMirrors {
@@ -122,6 +123,8 @@ private ValueMirrors() {}
 
     boolean jdkOnly() default false;
 
+    Class<? extends Annotation>[] passAnnotations() default {};
+
     ImplementationVisibility visibility() default ImplementationVisibility.SAME;
 
     public enum ImplementationVisibility {

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -118,10 +118,12 @@ private ValueMirrors() {}
 
     boolean strictBuilder() default false;
 
-    ImplementationVisibility visibility() default ImplementationVisibility.SAME;
+    boolean allParameters() default false;
 
     boolean jdkOnly() default false;
 
+    ImplementationVisibility visibility() default ImplementationVisibility.SAME;
+
     public enum ImplementationVisibility {
       PUBLIC,
       SAME,

File: value-processor/src/org/immutables/value/processor/meta/Proto.java
Patch:
@@ -791,8 +791,9 @@ public StyleInfo apply(StyleMirror input) {
           input.typeImmutableNested(),
           ToImmutableInfo.FUNCTION.apply(input.defaults()),
           input.strictBuilder(),
-          input.visibility(),
-          input.jdkOnly());
+          input.allParameters(),
+          input.jdkOnly(),
+          input.visibility());
     }
   }
 }

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -118,10 +118,12 @@ private ValueMirrors() {}
 
     boolean strictBuilder() default false;
 
-    ImplementationVisibility visibility() default ImplementationVisibility.SAME;
+    boolean allParameters() default false;
 
     boolean jdkOnly() default false;
 
+    ImplementationVisibility visibility() default ImplementationVisibility.SAME;
+
     public enum ImplementationVisibility {
       PUBLIC,
       SAME,

File: value-processor/src/org/immutables/value/processor/meta/ValueAttribute.java
Patch:
@@ -962,9 +962,9 @@ void processAndAssign() {
         ValueAttribute.this.hasSomeUnresolvedTypes = hasMaybeUnresolvedYetAfter;
         ValueAttribute.this.rawTypeName = rawTypeName;
 
-        if (workaroundTypeString != null && workaroundTypeString != null) {
+        if (workaroundTypeParameters != null && workaroundTypeString != null) {
           ValueAttribute.this.returnTypeName = workaroundTypeString;
-          if (!typeParameterStrings.isEmpty()) {
+          if (!workaroundTypeParameters.isEmpty()) {
             ValueAttribute.this.typeParameters = ImmutableList.copyOf(workaroundTypeParameters);
           }
         } else {

File: value-processor/src/org/immutables/value/processor/meta/Proto.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.immutables.value.processor.meta;
 
+import javax.lang.model.type.TypeKind;
 import org.immutables.generator.SourceExtraction;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
@@ -401,13 +402,14 @@ public boolean verifiedFactory(ExecutableElement element) {
         return false;
       }
       if (!isTopLevel()
+          || element.getReturnType().getKind() == TypeKind.VOID
           || element.getModifiers().contains(Modifier.PRIVATE)
           || !element.getModifiers().contains(Modifier.STATIC)
           || !element.getThrownTypes().isEmpty()
           || !element.getTypeParameters().isEmpty()) {
         report().withElement(element)
             .annotationNamed(FactoryMirror.simpleName())
-            .error("@%s method '%s' should be static, non-private,"
+            .error("@%s method '%s' should be static, non-private, non-void"
                 + " with no type parameters or throws declaration, and enclosed in top level type",
                 FactoryMirror.simpleName(),
                 element.getSimpleName());

File: value-processor/src/org/immutables/value/processor/meta/Round.java
Patch:
@@ -55,7 +55,6 @@ final static class Interning {
 
     DeclaringPackage forPackage(DeclaringPackage declaringPackage) {
       return packageInterner.intern(declaringPackage);
-
     }
 
     DeclaringType forType(DeclaringType declaringType) {

File: mongo/src/org/immutables/mongo/concurrent/FluentFuture.java
Patch:
@@ -94,7 +94,7 @@ public interface FluentFuture<V> extends ListenableFuture<V> {
    *         or the original input's failure (if not)
    * @see Futures#transform(ListenableFuture, AsyncFunction)
    */
-  <T> FluentFuture<T> transform(AsyncFunction<? super V, ? extends T> function);
+  <T> FluentFuture<T> asyncTransform(AsyncFunction<? super V, ? extends T> function);
 
   /**
    * Lazily transformed future value.

File: mongo/src/org/immutables/mongo/concurrent/FluentFutures.java
Patch:
@@ -78,7 +78,7 @@ public <T> FluentFuture<T> transform(Function<? super V, ? extends T> function)
     }
 
     @Override
-    public <T> FluentFuture<T> transform(AsyncFunction<? super V, ? extends T> function) {
+    public <T> FluentFuture<T> asyncTransform(AsyncFunction<? super V, ? extends T> function) {
       return from(Futures.transform(this, function, executor));
     }
 

File: generator/src/org/immutables/generator/PostprocessingMachine.java
Patch:
@@ -331,7 +331,6 @@ void addImport(String importedPackage) {
 
     void addOriginalImport(String name, String qualifiedName, String importedPackage) {
       originalImports.put(name, qualifiedName);
-
       if (!omittedImport(name, qualifiedName)) {
         imports.add(importedPackage);
       }

File: value-fixture/src/org/immutables/fixture/SillyStructure.java
Patch:
@@ -15,9 +15,9 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.fixture.subpack.SillySubstructure;
 import com.google.common.base.Optional;
 import java.util.List;
+import org.immutables.fixture.subpack.SillySubstructure;
 import org.immutables.gson.Gson;
 import org.immutables.value.Value;
 

File: value-fixture/src/org/immutables/fixture/couse/AbstractA.java
Patch:
@@ -15,9 +15,12 @@
  */
 package org.immutables.fixture.couse;
 
+import org.immutables.fixture.couse.sub.*;
 import org.immutables.value.Value;
 
 @Value.Immutable
 interface AbstractA {
   B b();
+
+  C c();
 }

File: value-processor/src/org/immutables/value/processor/meta/FactoryMethodAttributesCollector.java
Patch:
@@ -47,7 +47,6 @@ void collect() {
       attribute.isGenerateAbstract = true;
       attribute.reporter = reporter;
       attribute.returnType = returnType;
-      attribute.returnTypeName = returnType.toString();
 
       attribute.element = parameter;
       String parameterName = parameter.getSimpleName().toString();

File: generator/src/org/immutables/generator/SourceOrdering.java
Patch:
@@ -15,8 +15,6 @@
  */
 package org.immutables.generator;
 
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.util.Types;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
 import com.google.common.base.Predicate;
@@ -37,9 +35,11 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 import org.eclipse.jdt.internal.compiler.apt.model.ElementImpl;
 import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;

File: value-fixture/src/org/immutables/fixture/SillyStructure.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.immutables.fixture;
 
+import org.immutables.fixture.subpack.SillySubstructure;
 import com.google.common.base.Optional;
 import java.util.List;
 import org.immutables.gson.Gson;

File: value-fixture/src/org/immutables/fixture/SillyStructureWithId.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.immutables.fixture;
 
+import org.immutables.fixture.subpack.SillySubstructure;
 import com.google.common.base.Optional;
 import java.util.List;
 import org.immutables.gson.Gson;

File: value-fixture/src/org/immutables/fixture/subpack/SillySubstructure.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.fixture;
+package org.immutables.fixture.subpack;
 
 import java.lang.annotation.ElementType;
 import java.lang.annotation.RetentionPolicy;

File: value-fixture/test/org/immutables/fixture/marshal/MarshallingTest.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.immutables.fixture.marshal;
 
+import org.immutables.fixture.subpack.SillySubstructure;
 import org.immutables.fixture.SillyStructure;
 import com.fasterxml.jackson.core.JsonFactory;
 import com.fasterxml.jackson.core.JsonGenerator;
@@ -31,7 +32,6 @@
 import org.immutables.fixture.JsonIgnore;
 import org.immutables.fixture.SillyPolyHost;
 import org.immutables.fixture.SillyPolyHost2;
-import org.immutables.fixture.SillySubstructure;
 import org.immutables.fixture.SillyTuplie;
 import org.immutables.fixture.nested.ImmutableCadabra;
 import org.immutables.fixture.nested.NonGrouped;

File: generator/src/org/immutables/generator/SourceOrdering.java
Patch:
@@ -15,8 +15,6 @@
  */
 package org.immutables.generator;
 
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.util.Types;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
 import com.google.common.base.Predicate;
@@ -37,9 +35,11 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 import org.eclipse.jdt.internal.compiler.apt.model.ElementImpl;
 import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;

File: generator-processor/src/org/immutables/generator/processor/Implicits.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.immutables.generator.processor;
 
+import javax.lang.model.type.TypeKind;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.ListMultimap;
@@ -76,7 +77,7 @@ public interface ImplicitResolver {
   }
 
   private DeclaredType checkDeclaredType(TypeMirror type) {
-    checkState(type instanceof DeclaredType, "'%s' should have been a declared type", type);
+    checkState(type.getKind() == TypeKind.DECLARED, "'%s' should have been a declared type", type);
     return (DeclaredType) type;
   }
 }

File: generator-processor/src/org/immutables/generator/processor/Imports.java
Patch:
@@ -100,7 +100,7 @@ private boolean shouldConsideredAsTypeUsage(ExecutableElement method) {
   }
 
   private void collectIfSimpleType(TypeMirror type, Map<String, TypeMirror> collected) {
-    if (type instanceof DeclaredType) {
+    if (type.getKind() == TypeKind.DECLARED) {
       DeclaredType declared = (DeclaredType) type;
       if (declared.getTypeArguments().isEmpty()) {
         collected.put(declared.asElement().getSimpleName().toString(), declared);

File: generator/src/org/immutables/generator/SourceOrdering.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.immutables.generator;
 
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.util.Types;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
@@ -207,7 +208,7 @@ void traverse(@Nullable TypeElement element) {
 
       @Nullable
       TypeElement asTypeElement(TypeMirror type) {
-        if (type instanceof DeclaredType) {
+        if (type.getKind() == TypeKind.DECLARED) {
           return (TypeElement) ((DeclaredType) type).asElement();
         }
         return null;

File: value-processor/src/org/immutables/value/processor/Processor.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.immutables.value.processor;
 
+import org.immutables.value.processor.meta.ValueUmbrellaMirror;
 import org.immutables.value.processor.meta.FactoryMirror;
 import org.immutables.value.processor.meta.ImmutableMirror;
 import org.immutables.value.processor.meta.EnclosingMirror;
@@ -33,7 +34,8 @@
     FactoryMirror.QUALIFIED_NAME,
     ImmutableMirror.QUALIFIED_NAME,
     EnclosingMirror.QUALIFIED_NAME,
-    IncludeMirror.QUALIFIED_NAME
+    IncludeMirror.QUALIFIED_NAME,
+    ValueUmbrellaMirror.QUALIFIED_NAME,
 })
 public final class Processor extends AbstractGenerator {
   @Override

File: value-processor/src/org/immutables/value/processor/meta/ValueMirrors.java
Patch:
@@ -20,6 +20,9 @@
 
 public final class ValueMirrors {
   private ValueMirrors() {}
+  
+  @Mirror.Annotation("org.immutables.value.Value")
+  public @interface ValueUmbrella {}
 
   @Mirror.Annotation("org.immutables.value.Value.Immutable")
   public @interface Immutable {

File: value-fixture/src/org/immutables/fixture/HasNullable.java
Patch:
@@ -15,9 +15,9 @@
  */
 package org.immutables.fixture;
 
+import javax.annotation.Nullable;
 import org.immutables.gson.Gson;
 import org.immutables.value.Value;
-import javax.annotation.Nullable;
 
 @Value.Immutable(singleton = true)
 @Gson.TypeAdapters

File: value-fixture/src/org/immutables/fixture/SampleCopyOfTypes.java
Patch:
@@ -15,9 +15,8 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.value.Value;
-
 import java.util.List;
+import org.immutables.value.Value;
 
 @Value.Enclosing
 public class SampleCopyOfTypes {

File: value-fixture/src/org/immutables/fixture/SampleValue.java
Patch:
@@ -15,9 +15,9 @@
  */
 package org.immutables.fixture;
 
-import java.util.OptionalInt;
 import com.google.common.base.Optional;
 import java.util.List;
+import java.util.OptionalInt;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/style/EnclosingHiddenImplementation.java
Patch:
@@ -23,7 +23,7 @@
     typeImmutableEnclosing = "EnclosingFactory",
     instance = "singletonInstance",
     of = "new*",
-    builder = "create",
+    newBuilder = "create",
     visibility = ImplementationVisibility.PRIVATE,
     defaults = @Value.Immutable(singleton = true))
 @interface Priv {}

File: value-fixture/src/org/immutables/fixture/style/OutsideBuildable.java
Patch:
@@ -42,7 +42,7 @@ void use() {
  * </ul>
  */
 @Value.Immutable
-@Value.Style(builder = "newBuilder", visibility = ImplementationVisibility.PRIVATE)
+@Value.Style(newBuilder = "newBuilder", visibility = ImplementationVisibility.PRIVATE)
 class OutsideBuildableNew {
 
   void use() {

File: value-fixture/test/org/immutables/fixture/nested/NestedValuesTest.java
Patch:
@@ -15,11 +15,11 @@
  */
 package org.immutables.fixture.nested;
 
-import org.immutables.fixture.marshal.Marshaling;
 import com.fasterxml.jackson.core.JsonFactory;
 import com.fasterxml.jackson.core.JsonGenerator;
 import com.fasterxml.jackson.core.JsonParser;
 import com.google.common.base.CharMatcher;
+import org.immutables.fixture.marshal.Marshaling;
 import org.immutables.fixture.nested.ImmutableGroupedClasses.NestedOne;
 import org.immutables.fixture.nested.ImmutableInnerNested.Inner;
 import org.immutables.fixture.nested.ImmutableInnerNested.Nested;

File: value-processor/src/org/immutables/value/processor/meta/BuilderMirrors.java
Patch:
@@ -13,6 +13,6 @@ private BuilderMirrors() {}
 
   @Mirror.Annotation("org.immutables.builder.Builder.Switch")
   public @interface Switch {
-    int defaultOrdinal() default -1;
+    String defaultName() default "";
   }
 }

File: generator-processor/src/org/immutables/generator/processor/TypeResolver.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.immutables.generator.processor;
 
-import com.google.common.base.Verify;
 import com.google.common.base.Optional;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.FluentIterable;

File: gson/src/org/immutables/gson/stream/JsonParserReader.java
Patch:
@@ -113,7 +113,7 @@ public JsonToken peek() throws IOException {
 
   private void expect(com.fasterxml.jackson.core.JsonToken expected) {
     if (peek != expected) {
-      throw new IllegalStateException("Expected " + toGsonToken(expected) + " but was " + toGsonToken(peek));
+      throw new IllegalStateException("Expected " + expected + " but was " + peek);
     }
   }
 

File: gson/test/org/immutables/gson/adapter/Adapt.java
Patch:
@@ -10,7 +10,7 @@
 import org.immutables.value.Value;
 
 @Value.Immutable(builder = false)
-@Value.Nested
+@Value.Enclosing
 @Gson.TypeAdapters
 public interface Adapt {
 

File: gson/test/org/immutables/gson/adapter/OtherType.java
Patch:
@@ -10,7 +10,7 @@
 import org.immutables.value.Value;
 
 @Value.Immutable(builder = false)
-@Value.Nested
+@Value.Enclosing
 @Gson.TypeAdapters
 public interface OtherType {
 

File: gson/test/org/immutables/gson/adapter/Polymorphics.java
Patch:
@@ -7,7 +7,7 @@
 import org.immutables.value.Value;
 
 @Gson.TypeAdapters
-@Value.Nested
+@Value.Enclosing
 public interface Polymorphics {
 
   @Gson.ExpectedSubtypes(D.class)

File: mongo/src/org/immutables/mongo/repository/internal/Constraints.java
Patch:
@@ -232,7 +232,7 @@ public final <V extends ConstraintVisitor<V>> V accept(V visitor) {
 
   public static Pattern prefixPatternOf(String prefix) {
     checkArgument(NON_LITERAL_REGEX_CHARACTERS.matchesNoneOf(prefix),
-        "Prefix [%s] should be literal, otherwise use regular constructed Regex Pattern",
+        "Prefix [%s] should be literal, otherwise use constructed regex Pattern",
         prefix);
     return Pattern.compile("^" + prefix);
   }

File: mongo/test/org/immutables/mongo/fixture/Item.java
Patch:
@@ -1,16 +1,16 @@
 package org.immutables.mongo.fixture;
 
+import org.immutables.gson.Gson;
 import java.util.List;
 import java.util.Set;
-import org.immutables.gson.Gson;
 import org.immutables.mongo.Mongo;
 import org.immutables.mongo.types.Binary;
 import org.immutables.mongo.types.Id;
 import org.immutables.value.Value;
 
 @Mongo.Repository
 @Value.Immutable
-@Gson.TypeAdapters
+@Gson.TypeAdapters(emptyAsNulls = true)
 public interface Item {
 
   @Mongo.Id

File: mongo/test/org/immutables/mongo/fixture/ManualStorage.java
Patch:
@@ -20,8 +20,7 @@ public static void main(String... args) {
 
     ItemRepository items = new ItemRepository(setup);
 
-    ItemRepository.Criteria where = items.where();
-
+    ItemRepository.Criteria where = items.criteria();
     FluentFuture<Integer> inserted = items.insert(ImmutableItem.builder()
         .id("1")
         .binary(Binary.create(new byte[] {1, 2, 3}))

File: ordinal/src/org/immutables/ordinal/ImmutableOrdinalSet.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.value.ordinal;
+package org.immutables.ordinal;
 
 import com.google.common.annotations.Beta;
 import com.google.common.collect.ForwardingSet;

File: ordinal/src/org/immutables/ordinal/InterningOrdinalDomain.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.value.ordinal;
+package org.immutables.ordinal;
 
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;

File: ordinal/src/org/immutables/ordinal/OrdinalDomain.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.value.ordinal;
+package org.immutables.ordinal;
 
 import com.google.common.annotations.Beta;
 import com.google.common.collect.AbstractIterator;

File: ordinal/src/org/immutables/ordinal/OrdinalValue.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.value.ordinal;
+package org.immutables.ordinal;
 
 import com.google.common.annotations.Beta;
 

File: ordinal/src/org/immutables/ordinal/package-info.java
Patch:
@@ -14,4 +14,4 @@
    limitations under the License.
  */
 @javax.annotation.ParametersAreNonnullByDefault
-package org.immutables.value.ordinal;
\ No newline at end of file
+package org.immutables.ordinal;
\ No newline at end of file

File: ordinal/test/org/immutables/ordinal/Domain.java
Patch:
@@ -13,8 +13,9 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.value.ordinal;
+package org.immutables.ordinal;
 
+import org.immutables.ordinal.OrdinalDomain;
 import com.google.common.base.MoreObjects;
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;

File: ordinal/test/org/immutables/ordinal/Ord.java
Patch:
@@ -13,8 +13,10 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.value.ordinal;
+package org.immutables.ordinal;
 
+import org.immutables.ordinal.OrdinalDomain;
+import org.immutables.ordinal.OrdinalValue;
 import com.google.common.base.MoreObjects;
 
 class Ord implements OrdinalValue<Ord> {

File: ordinal/test/org/immutables/ordinal/SillyOrdinal.java
Patch:
@@ -13,9 +13,9 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.fixture;
+package org.immutables.ordinal;
 
-import org.immutables.value.ordinal.OrdinalValue;
+import org.immutables.ordinal.OrdinalValue;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: ordinal/test/org/immutables/ordinal/SillyOrdinalHolder.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.fixture;
+package org.immutables.ordinal;
 
 import java.util.Set;
 import org.immutables.value.Value;

File: value-fixture/src/org/immutables/fixture/GenericInheritence.java
Patch:
@@ -1,10 +1,11 @@
 package org.immutables.fixture;
 
+import java.io.Serializable;
 import org.immutables.value.Value;
 
 public interface GenericInheritence {
 
-  public static interface Gen<A, B> {
+  public static interface Gen<A extends Object & Comparable<A>, B extends Serializable> {
     A a();
 
     B b();
@@ -14,5 +15,5 @@ public static interface Gen<A, B> {
   public static interface Sub1 extends Gen<String, Integer> {}
 
   @Value.Immutable
-  public static interface Sub2 extends Gen<Long, Object> {}
+  public static interface Sub2 extends Gen<Long, Double> {}
 }

File: value-fixture/src/org/immutables/fixture/SampleCopyOfTypes.java
Patch:
@@ -19,7 +19,7 @@
 
 import java.util.List;
 
-@Value.Nested
+@Value.Enclosing
 public class SampleCopyOfTypes {
   @Value.Immutable(builder = false)
   public interface ByConstructorAndWithers {

File: value-fixture/src/org/immutables/fixture/SampleNesting.java
Patch:
@@ -17,7 +17,7 @@
 
 import org.immutables.value.Value;
 
-@Value.Nested
+@Value.Enclosing
 public class SampleNesting {
   @Value.Immutable
   interface A {}

File: value-fixture/src/org/immutables/fixture/ast/AstTree.java
Patch:
@@ -22,7 +22,7 @@
  */
 //@Parboil.Ast
 //@ExtValue.Transformer
-@Value.Nested
+@Value.Enclosing
 public class AstTree {
   interface Expression {}
 

File: value-fixture/src/org/immutables/fixture/nested/GroupedClasses.java
Patch:
@@ -19,7 +19,7 @@
 import org.immutables.gson.Gson;
 import org.immutables.value.Value;
 
-@Value.Nested
+@Value.Enclosing
 @Gson.TypeAdapters(emptyAsNulls = true)
 //@ExtValue.Transformer
 class GroupedClasses {

File: value-fixture/src/org/immutables/fixture/nested/InnerNested.java
Patch:
@@ -19,7 +19,7 @@
 import org.immutables.value.Value;
 
 @Gson.TypeAdapters
-@Value.Nested
+@Value.Enclosing
 @Value.Immutable
 public interface InnerNested {
   @Value.Immutable

File: value-fixture/src/org/immutables/fixture/style/EnclosingBuilderNew.java
Patch:
@@ -24,7 +24,7 @@
  * <li>Nested Builder using constructor "new" invokation
  * </ul>
  */
-@Value.Nested
+@Value.Enclosing
 @Value.Style(
     builder = "new",
     visibility = ImplementationVisibility.PRIVATE)

File: value-fixture/src/org/immutables/fixture/style/EnclosingHiddenImplementation.java
Patch:
@@ -37,7 +37,7 @@
  * <li>Forwarding factory methods with names customization and auto-disambiguation
  * </ul>
  */
-@Value.Nested
+@Value.Enclosing
 @Priv
 public abstract class EnclosingHiddenImplementation {
   @Value.Immutable

File: value-fixture/src/org/immutables/fixture/style/IncludeNestedTypes.java
Patch:
@@ -20,6 +20,6 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-@Value.Nested
+@Value.Enclosing
 @Value.Include({Target.class, Retention.class})
 public interface IncludeNestedTypes {}

File: value-processor/src/org/immutables/value/processor/meta/Round.java
Patch:
@@ -145,6 +145,7 @@ void collect(Element element) {
       case ANNOTATION_TYPE:
       case INTERFACE:
       case CLASS:
+      case ENUM:
         collectIncludedAndDefinedBy((TypeElement) element);
         break;
       case METHOD:

File: generator/test/org/immutables/generator/PostprocessingMachineTest.java
Patch:
@@ -13,6 +13,7 @@ public void imports() {
     CharSequence rewrited = PostprocessingMachine.rewrite(
         LINES.join("package start;",
             "import java.util.List;",
+            "import org.junit.*;",
             "import some.Some.Nested;",
             "final class My extends java.util.Set {",
             "  private java.util.Map<java.lang.String, Integer> map = com.google.common.collect.Maps.newHashMap();",
@@ -25,6 +26,7 @@ public void imports() {
             "import java.util.List;",
             "import java.util.Map;",
             "import java.util.Set;",
+            "import org.junit.*;",
             "import some.Some.Nested;",
             "final class My extends Set {",
             "  private Map<String, Integer> map = Maps.newHashMap();",

File: generator/test/org/immutables/generator/PostprocessingMachineTest.java
Patch:
@@ -2,7 +2,6 @@
 package org.immutables.generator;
 
 import com.google.common.base.Joiner;
-import org.junit.Ignore;
 import org.junit.Test;
 import static org.immutables.check.Checkers.*;
 
@@ -228,7 +227,6 @@ public void conflictResolution() {
   }
 
   @Test
-  @Ignore
   public void noConflictInDifferentPackages() {
     CharSequence rewrited = PostprocessingMachine.rewrite(LINES.join(
         "import my.other.Set;",
@@ -241,7 +239,6 @@ public void noConflictInDifferentPackages() {
         "class X {",
         "  my.Set same(Set set);",
         "}"));
-
   }
 
   @Test

File: gson/src/org/immutables/gson/stream/JsonParserReader.java
Patch:
@@ -240,7 +240,7 @@ public JsonParser call() throws Exception {
 
   /**
    * Reads current value including objects and array as effiecient token buffer.
-   * this method handles. Use of Jackson's own mechanisms is important to preserve custom elements
+   * Use of Jackson's own mechanisms is important to preserve custom elements
    * such as special embedded objects in BSON or other data formats.
    * @return {@link TokenBuffer}
    * @throws IOException if error occured

File: value-fixture/src/org/immutables/fixture/style/BeanStyleDetected.java
Patch:
@@ -15,12 +15,11 @@
  */
 package org.immutables.fixture.style;
 
-import org.immutables.value.Styles;
-import org.immutables.value.Value;
 import java.util.List;
+import org.immutables.value.Value;
 
 @Value.Immutable(copy = true)
-@Styles.BeanAccessors
+@BeanAccessors
 abstract class BeanStyleDetected {
   abstract int isIt();
 

File: value-fixture/src/InDefaultPackage.java
Patch:
@@ -17,6 +17,7 @@
 
 @Value.Immutable
 interface InDefaultPackage {
+  int attr();
   @Value.Immutable
   static class ButNested {}
 }

File: value-fixture/src/org/immutables/fixture/HasNullable.java
Patch:
@@ -15,16 +15,15 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.value.ext.Json;
+import org.immutables.gson.Gson;
 import org.immutables.value.Value;
 import javax.annotation.Nullable;
 
 @Value.Immutable(singleton = true)
-@Json.Marshaled
+@Gson.TypeAdapters
 public abstract class HasNullable {
   @Nullable
   @Value.Parameter
-  @Json.ForceEmpty
   public abstract Integer in();
 
   @Nullable

File: value-fixture/src/org/immutables/fixture/HasTypeAnnotation.java
Patch:
@@ -19,7 +19,7 @@
 import java.lang.annotation.Target;
 import java.util.Map;
 import javax.annotation.Nullable;
-import org.immutables.value.ext.Json;
+import org.immutables.gson.Gson;
 import org.immutables.value.Value;
 
 @Target(ElementType.TYPE_USE)
@@ -28,8 +28,8 @@
 @Target(ElementType.TYPE_USE)
 @interface TypeB {}
 
-@Value.Immutable
-@Json.Marshaled
+//FIXME @Value.Immutable
+//FIXME @Gson.TypeAdapters
 public abstract class HasTypeAnnotation {
   @Nullable
   public abstract @TypeA @TypeB String str();

File: value-fixture/src/org/immutables/fixture/JsonIgnore.java
Patch:
@@ -16,15 +16,15 @@
 package org.immutables.fixture;
 
 import java.util.List;
+import org.immutables.gson.Gson;
 import org.immutables.value.Value;
-import org.immutables.value.ext.Json;
 
 @Value.Immutable
-@Json.Marshaled
+@Gson.TypeAdapters
 public interface JsonIgnore {
   @Value.Parameter
   int value();
 
-  @Json.Ignore
+  @Gson.Ignore
   List<Integer> values();
 }

File: value-fixture/src/org/immutables/fixture/PrimitiveDefault.java
Patch:
@@ -15,11 +15,9 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.value.Value.Style.ImplementationVisibility;
 import org.immutables.value.Value;
 
 @Value.Immutable
-@Value.Style(visibility = ImplementationVisibility.PACKAGE)
 public abstract class PrimitiveDefault {
   @Value.Default
   public boolean def() {

File: value-fixture/src/org/immutables/fixture/SillyAbstract.java
Patch:
@@ -15,9 +15,9 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.value.ext.Json;
+import org.immutables.gson.Gson;
 
-@Json.Subclasses({
+@Gson.ExpectedSubtypes({
     SillySub1.class,
     SillySub2.class
 })

File: value-fixture/src/org/immutables/fixture/SillyIntWrap.java
Patch:
@@ -15,11 +15,11 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.value.ext.Json;
+import org.immutables.gson.Gson;
 import org.immutables.value.Value;
 
 @Value.Immutable(builder = false)
-@Json.Marshaled
+@Gson.TypeAdapters
 public abstract class SillyIntWrap {
 
   @Value.Parameter

File: value-fixture/src/org/immutables/fixture/SillyMapTup.java
Patch:
@@ -17,11 +17,11 @@
 
 import java.lang.annotation.RetentionPolicy;
 import java.util.Map;
-import org.immutables.value.ext.Json;
+import org.immutables.gson.Gson;
 import org.immutables.value.Value;
 
 @Value.Immutable(builder = false)
-@Json.Marshaled
+@Gson.TypeAdapters
 public abstract class SillyMapTup {
 
   @Value.Parameter(order = 0)

File: value-fixture/src/org/immutables/fixture/SillyPolyHost.java
Patch:
@@ -16,11 +16,11 @@
 package org.immutables.fixture;
 
 import java.util.List;
-import org.immutables.value.ext.Json;
+import org.immutables.gson.Gson;
 import org.immutables.value.Value;
 
 @Value.Immutable
-@Json.Marshaled
+@Gson.TypeAdapters
 public abstract class SillyPolyHost {
 
   public abstract List<SillyAbstract> s();

File: value-fixture/src/org/immutables/fixture/SillyStructure.java
Patch:
@@ -17,11 +17,11 @@
 
 import com.google.common.base.Optional;
 import java.util.List;
-import org.immutables.value.ext.Json;
+import org.immutables.gson.Gson;
 import org.immutables.value.Value;
 
 @Value.Immutable
-@Json.Marshaled
+@Gson.TypeAdapters
 public abstract class SillyStructure {
 
   public abstract String attr1();

File: value-fixture/src/org/immutables/fixture/SillySub1.java
Patch:
@@ -15,11 +15,11 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.value.ext.Json;
+import org.immutables.gson.Gson;
 import org.immutables.value.Value;
 
 @Value.Immutable
-@Json.Marshaled
+@Gson.TypeAdapters
 public abstract class SillySub1 extends SillyAbstract {
   public abstract int a();
 }

File: value-fixture/src/org/immutables/fixture/SillySub2.java
Patch:
@@ -15,11 +15,11 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.value.ext.Json;
+import org.immutables.gson.Gson;
 import org.immutables.value.Value;
 
 @Value.Immutable
-@Json.Marshaled
+@Gson.TypeAdapters
 public abstract class SillySub2 extends SillyAbstract {
   public abstract String b();
 }

File: value-fixture/src/org/immutables/fixture/SillySub3.java
Patch:
@@ -16,11 +16,11 @@
 package org.immutables.fixture;
 
 import java.util.List;
-import org.immutables.value.ext.Json;
+import org.immutables.gson.Gson;
 import org.immutables.value.Value;
 
 @Value.Immutable
-@Json.Marshaled
+@Gson.TypeAdapters
 public abstract class SillySub3 extends SillyAbstract {
   public abstract List<Double> b();
 }

File: value-fixture/src/org/immutables/fixture/SillyTuplie.java
Patch:
@@ -17,11 +17,11 @@
 
 import com.google.common.base.Optional;
 import java.util.Set;
-import org.immutables.value.ext.Json;
+import org.immutables.gson.Gson;
 import org.immutables.value.Value;
 
 @Value.Immutable(builder = false)
-@Json.Marshaled
+@Gson.TypeAdapters
 public abstract class SillyTuplie {
 
   @Value.Parameter(order = 0)

File: value-fixture/src/org/immutables/fixture/nested/InnerNested.java
Patch:
@@ -15,17 +15,16 @@
  */
 package org.immutables.fixture.nested;
 
-import org.immutables.value.ext.Json;
+import org.immutables.gson.Gson;
 import org.immutables.value.Value;
 
+@Gson.TypeAdapters
 @Value.Nested
 @Value.Immutable
 public interface InnerNested {
   @Value.Immutable
-  @Json.Marshaled
   abstract static class Inner {}
 
   @Value.Immutable
-  @Json.Marshaled
   interface Nested {}
 }

File: value-fixture/src/simple/Type.java
Patch:
@@ -21,6 +21,7 @@
 public class Type {
   @Value.Immutable
   interface Nested {
+    int a();
     @Value.Immutable
     static class Deeper {
       @Value.Immutable

File: value-fixture/test/org/immutables/fixture/nested/NestedValuesTest.java
Patch:
@@ -15,11 +15,11 @@
  */
 package org.immutables.fixture.nested;
 
+import org.immutables.fixture.marshal.Marshaling;
 import com.fasterxml.jackson.core.JsonFactory;
 import com.fasterxml.jackson.core.JsonGenerator;
 import com.fasterxml.jackson.core.JsonParser;
 import com.google.common.base.CharMatcher;
-import org.immutables.common.marshal.Marshaling;
 import org.immutables.fixture.nested.ImmutableGroupedClasses.NestedOne;
 import org.immutables.fixture.nested.ImmutableInnerNested.Inner;
 import org.immutables.fixture.nested.ImmutableInnerNested.Nested;

File: gson/src/org/immutables/gson/Gson.java
Patch:
@@ -37,7 +37,8 @@
    * Use on a top level class to generate type adapted factory supporting directly annotated and all
    * nested immutable types.
    * <p>
-   * Type adapter factories are registered statically as services
+   * Type adapter factories are generated in the same package, named
+   * {@code GsonAdapters[name_of_annotated_type]} and registered statically as service providers in
    * {@code META-INF/services/com.google.gson.TypeAdapterFactory}. The most easy way to register all
    * such factories {@link com.google.gson.Gson}.
    * <p>

File: gson/test/org/immutables/gson/adapter/AdaptReadWriteTest.java
Patch:
@@ -9,7 +9,7 @@
 public class AdaptReadWriteTest {
 
   private final Gson gson = new GsonBuilder()
-      .registerTypeAdapterFactory(new AdaptTypeAdapters())
+      .registerTypeAdapterFactory(new GsonAdaptersAdapt())
       .create();
 
   private final Adapt adapt =

File: generator/src/org/immutables/generator/AbstractGenerator.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.immutables.generator;
 
-import com.google.common.base.Joiner;
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
@@ -93,7 +92,7 @@ public final boolean process(Set<? extends TypeElement> annotations, RoundEnviro
     } catch (Exception ex) {
       processingEnv.getMessager()
           .printMessage(Diagnostic.Kind.ERROR,
-              Joiner.on('\n').join(getClass().getName() + " threw", Throwables.getStackTraceAsString(ex)));
+              getClass().getName() + " threw " + Throwables.getStackTraceAsString(ex));
     }
     return false;
   }

File: gson/src/org/immutables/gson/Gson.java
Patch:
@@ -36,7 +36,7 @@
    */
   @Retention(RetentionPolicy.SOURCE)
   @Target({ElementType.METHOD, ElementType.TYPE})
-  public @interface Subclasses {
+  public @interface Subtypes {
 
     /**
      * Specifies expected subclasses of an abstract type that is matched during parsing by

File: value/src/org/immutables/value/Value.java
Patch:
@@ -410,7 +410,8 @@
     String[] typeAbstract() default {};
 
     /**
-     * Modifiable type name template.
+     * Name template to generate immutable implementation type by using base/raw type name.
+     * Use {@link #typeAbstract()} to customize base/raw name inference.
      * @return naming template
      */
     String typeImmutable() default "Immutable*";

File: generator/src/org/immutables/generator/PostprocessingMachine.java
Patch:
@@ -39,15 +39,13 @@ static CharSequence rewrite(CharSequence content) {
       switch (state) {
       case UNDEFINED:
         state = machine.nextChar(c).or(state);
-        if (!isAlphabetic(c)) {
-          nextPartFrom = i + 1;
-        }
         break;
       case PACKAGE:
         if (c == ' ') {
           packageFrom = i + 1;
         }
         if (c == ';') {
+          nextPartFrom = i + 2;
           currentPackage = content.subSequence(packageFrom, i).toString();
           importsBuilder.setCurrentPackage(currentPackage);
           state = State.UNDEFINED;
@@ -66,6 +64,7 @@ static CharSequence rewrite(CharSequence content) {
           importStarts = true;
         }
         if (c == ';') {
+          nextPartFrom = i + 2;
           importsBuilder.addImport(content.subSequence(importFrom, i).toString());
           state = State.UNDEFINED;
           importFrom = -1;

File: value-fixture/src/org/immutables/fixture/style/HiddenImplementation.java
Patch:
@@ -31,7 +31,7 @@
 public class HiddenImplementation {
 
   void use() {
-    HiddenImplementation instance = HiddenImplementationBuilder.builder().build();
+    HiddenImplementation instance = new HiddenImplementationBuilder().build();
     instance.toString();
   }
 }

File: value-fixture/src/org/immutables/fixture/style/LessVisibleImplementation.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.immutables.fixture.style;
 
-import org.immutables.fixture.style.ImmutableLessVisibleImplementation.LessVisibleImplementationBuilder;
 import org.immutables.value.Value;
 import org.immutables.value.Value.Style.ImplementationVisibility;
 
@@ -31,7 +30,8 @@
 public class LessVisibleImplementation {
 
   void use() {
-    LessVisibleImplementationBuilder returnsAbstract = ImmutableLessVisibleImplementation.builder();
-    returnsAbstract.build();
+    ImmutableLessVisibleImplementation.Builder lessVisibleBuilder = ImmutableLessVisibleImplementation.builder();
+    ImmutableLessVisibleImplementation lessVisibleImplementation = lessVisibleBuilder.build();
+    lessVisibleImplementation.use();
   }
 }

File: value-fixture/src/org/immutables/fixture/style/OutsideBuildable.java
Patch:
@@ -30,7 +30,7 @@
 public class OutsideBuildable {
 
   void use() {
-    OutsideBuildableBuilder.builder().build();
+    new OutsideBuildableBuilder().build();
   }
 }
 
@@ -42,10 +42,10 @@ void use() {
  * </ul>
  */
 @Value.Immutable
-@Value.Style(builder = "new", visibility = ImplementationVisibility.PRIVATE)
+@Value.Style(builder = "newBuilder", visibility = ImplementationVisibility.PRIVATE)
 class OutsideBuildableNew {
 
   void use() {
-    new OutsideBuildableNewBuilder().build();
+    OutsideBuildableNewBuilder.newBuilder().build();
   }
 }

File: value-processor/src/org/immutables/value/processor/meta/Styles.java
Patch:
@@ -151,9 +151,10 @@ public class TypeNames {
       // Builder template is being applied programatically in Constitution class
       // public final String typeBuilder = scheme.typeBuilder.apply(raw);
       public final String copyOf = scheme.copyOf.apply(raw);
-      public final String builder = scheme.builder.apply(raw);
       public final String build = scheme.build.apply(raw);
 
+//      public final String builder = scheme.builder.apply(raw);
+
 //      public final String typeModifiable = scheme.typeModifiable.apply(raw);
 //      public final String create = scheme.create.apply(raw);
 //      public final String toImmutable = scheme.toImmutable.apply(raw);

File: generator/test/org/immutables/generator/PostprocessingMachineTest.java
Patch:
@@ -99,7 +99,6 @@ public void simpleImport() {
   }
 
   @Test
-  @Ignore
   public void staticImport() {
     CharSequence rewrited = PostprocessingMachine.rewrite(LINES.join(
         "import static org.immutables.check.Checkers.*;",

File: value-processor/src/org/immutables/value/processor/meta/AccessorAttributesCollector.java
Patch:
@@ -38,6 +38,7 @@ final class AccessorAttributesCollector {
    * and long parameters and reserved slots for technical parameters).
    */
   private static final int USEFUL_PARAMETER_COUNT_LIMIT = 120;
+
   private static final String EQUALS_METHOD = "equals";
   private static final String TO_STRING_METHOD = "toString";
   private static final String HASH_CODE_METHOD = "hashCode";
@@ -62,13 +63,13 @@ void collect() {
 
     if (attributes.size() > USEFUL_PARAMETER_COUNT_LIMIT) {
       ArrayList<ValueAttribute> list = Lists.newArrayListWithCapacity(USEFUL_PARAMETER_COUNT_LIMIT);
-      list.addAll(attributes);
+      list.addAll(attributes.subList(0, USEFUL_PARAMETER_COUNT_LIMIT));
       attributes.clear();
       attributes.addAll(list);
 
       protoclass.report().error(
           "Value objects with more than %d attributes (including inherited) are not supported."
-              + " Please decompose '%s' class into a smaller ones",
+              + " You can decompose '%s' class into a smaller ones",
           USEFUL_PARAMETER_COUNT_LIMIT,
           protoclass.name());
     }

File: value-processor/src/org/immutables/value/processor/meta/ValueType.java
Patch:
@@ -33,6 +33,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map.Entry;
+import java.util.Objects;
 import java.util.Set;
 import javax.annotation.Nullable;
 import javax.lang.model.element.AnnotationMirror;
@@ -655,8 +656,7 @@ public boolean isUseCollectionUtility() {
    */
   @Override
   public int hashCode() {
-    return 31 * constitution.protoclass().name()
-        .hashCode();
+    return Objects.hash(constitution.protoclass().name());
   }
 
   @Override

File: value-processor/src/org/immutables/value/processor/meta/ValueTypeComposer.java
Patch:
@@ -73,9 +73,7 @@ ValueType compose(Protoclass protoclass) {
     type.typeMoreObjects = typeMoreObjects;
     type.element = protoclass.sourceElement();
     type.immutableFeatures = protoclass.features();
-    type.constitution = ImmutableConstitution.builder()
-        .protoclass(protoclass)
-        .build();
+    type.constitution = protoclass.constitution();
 
     if (protoclass.kind().isFactory()) {
       new FactoryMethodAttributesCollector(protoclass, type).collect();

File: common/src/org/immutables/common/marshal/JaxrsMessageBodyProvider.java
Patch:
@@ -41,7 +41,6 @@
 /**
  * JSON marshaling JAX-RS provider for immutable classes with generated marshaler.
  * @see org.immutables.value.Value.Immutable
- * @see org.immutables.value.Json.Marshaled
  */
 @Metainf.Service
 @Provider

File: common/src/org/immutables/common/marshal/Marshaling.java
Patch:
@@ -26,7 +26,7 @@
 
 /**
  * Contains convenient methods for marshaling and unmarshaling documents annotated with
- * {@link org.immutables.value.Json.Marshaled} to and from standard textual JSON.
+ * {@link org.immutables.value.ext.Json.Marshaled} to and from standard textual JSON.
  * <p>
  * You can avoid using this class in favor of using Marshalers directly. But It's not always
  * possible if dynamic lookup is needed.

File: value-fixture/src/org/immutables/fixture/GetterEncloser.java
Patch:
@@ -25,12 +25,10 @@
 
 @SuppressWarnings("deprecation")
 @Value.Immutable
-@Value.Getters
 public interface GetterEncloser {
   Optional<Integer> optional();
 
   @Value.Immutable
-  @Value.Getters
   public interface Getters {
     int ab();
 

File: value-fixture/src/org/immutables/fixture/HasNullable.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 import javax.annotation.Nullable;
 

File: value-fixture/src/org/immutables/fixture/HasTypeAnnotation.java
Patch:
@@ -19,7 +19,7 @@
 import java.lang.annotation.Target;
 import java.util.Map;
 import javax.annotation.Nullable;
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 @Target(ElementType.TYPE_USE)

File: value-fixture/src/org/immutables/fixture/JsonIgnore.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.util.List;
 import org.immutables.value.Value;
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 
 @Value.Immutable
 @Json.Marshaled

File: value-fixture/src/org/immutables/fixture/PrimitiveDefault.java
Patch:
@@ -15,10 +15,11 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.value.Value.Immutable.ImplementationVisibility;
+import org.immutables.value.Value.Style.ImplementationVisibility;
 import org.immutables.value.Value;
 
-@Value.Immutable(visibility = ImplementationVisibility.PACKAGE)
+@Value.Immutable
+@Value.Style(visibility = ImplementationVisibility.PACKAGE)
 public abstract class PrimitiveDefault {
   @Value.Default
   public boolean def() {

File: value-fixture/src/org/immutables/fixture/SillyAbstract.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 
 @Json.Subclasses({
     SillySub1.class,

File: value-fixture/src/org/immutables/fixture/SillyDumb.java
Patch:
@@ -17,7 +17,7 @@
 
 import com.google.common.base.Optional;
 import java.util.List;
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillyEntity.java
Patch:
@@ -22,8 +22,8 @@
 import java.util.List;
 import java.util.Map;
 import javax.annotation.Nullable;
-import org.immutables.value.Json;
-import org.immutables.value.Mongo;
+import org.immutables.value.ext.Json;
+import org.immutables.value.ext.Mongo;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillyEntitySecond.java
Patch:
@@ -15,9 +15,9 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.value.Mongo;
+import org.immutables.value.ext.Mongo;
 import org.immutables.common.repository.Id;
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillyIntWrap.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable(builder = false)

File: value-fixture/src/org/immutables/fixture/SillyMapHolder.java
Patch:
@@ -18,7 +18,7 @@
 import java.lang.annotation.RetentionPolicy;
 import java.util.Map;
 import java.util.Set;
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillyMapTup.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.lang.annotation.RetentionPolicy;
 import java.util.Map;
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable(builder = false)

File: value-fixture/src/org/immutables/fixture/SillyPolyHost.java
Patch:
@@ -16,7 +16,7 @@
 package org.immutables.fixture;
 
 import java.util.List;
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillyPolyHost2.java
Patch:
@@ -16,7 +16,7 @@
 package org.immutables.fixture;
 
 import com.google.common.base.Optional;
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillyStructure.java
Patch:
@@ -17,7 +17,7 @@
 
 import com.google.common.base.Optional;
 import java.util.List;
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillyStructureWithId.java
Patch:
@@ -15,10 +15,10 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.value.Mongo;
+import org.immutables.value.ext.Mongo;
 import com.google.common.base.Optional;
 import java.util.List;
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillySub1.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillySub2.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillySub3.java
Patch:
@@ -16,7 +16,7 @@
 package org.immutables.fixture;
 
 import java.util.List;
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillySubstructure.java
Patch:
@@ -15,12 +15,12 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.value.Mongo;
+import org.immutables.value.ext.Mongo;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.RetentionPolicy;
 import java.util.List;
 import java.util.Set;
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillyTuplie.java
Patch:
@@ -17,7 +17,7 @@
 
 import com.google.common.base.Optional;
 import java.util.Set;
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable(builder = false)

File: value-fixture/src/org/immutables/fixture/builder/ImprovisedFactories.java
Patch:
@@ -17,7 +17,7 @@
 
 import com.google.common.collect.Iterables;
 import org.immutables.value.Value;
-import org.immutables.value.Value.Immutable.ImplementationVisibility;
+import org.immutables.value.Value.Style.ImplementationVisibility;
 
 import javax.annotation.Nullable;
 import java.util.List;
@@ -27,7 +27,7 @@
  * Builders for simple attributes, collection, generic and primitive variations.
  * Builders are public as of style annotation.
  */
-@Value.Style(defaults = @Value.Immutable(visibility = ImplementationVisibility.PUBLIC))
+@Value.Style(visibility = ImplementationVisibility.PUBLIC)
 class ImprovisedFactories {
 
   @Value.Builder

File: value-fixture/src/org/immutables/fixture/jackson/MinimumAnnotationsMapped.java
Patch:
@@ -15,14 +15,17 @@
  */
 package org.immutables.fixture.jackson;
 
+import com.fasterxml.jackson.annotation.JsonProperty;
 import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
 import java.util.List;
 import org.immutables.value.Value;
 
 @Value.Immutable
 @JsonDeserialize(as = ImmutableMinimumAnnotationsMapped.class)
 public interface MinimumAnnotationsMapped {
+  @JsonProperty("A")
   String a();
 
+  @JsonProperty("B")
   List<Integer> b();
 }

File: value-fixture/src/org/immutables/fixture/jdbi/Record.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture.jdbi;
 
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 import com.google.common.base.Optional;
 

File: value-fixture/src/org/immutables/fixture/jdkonly/JdkColl.java
Patch:
@@ -7,7 +7,8 @@
 import java.util.List;
 import org.immutables.value.Value;
 
-@Value.Immutable(singleton = true, jdkOnly = true)
+@Value.Immutable(singleton = true)
+@Value.Style(jdkOnly = true)
 public interface JdkColl {
   List<String> str();
 

File: value-fixture/src/org/immutables/fixture/jdkonly/JdkMaps.java
Patch:
@@ -1,13 +1,14 @@
 package org.immutables.fixture.jdkonly;
 
-import org.immutables.value.Value.Immutable.ImplementationVisibility;
+import org.immutables.value.Value.Style.ImplementationVisibility;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Map;
 import java.util.NavigableMap;
 import java.util.SortedMap;
 import org.immutables.value.Value;
 
-@Value.Immutable(visibility = ImplementationVisibility.PRIVATE, jdkOnly = true)
+@Value.Immutable
+@Value.Style(visibility = ImplementationVisibility.PRIVATE, jdkOnly = true)
 public interface JdkMaps {
   Map<Long, Integer> just();
 

File: value-fixture/src/org/immutables/fixture/jdkonly/package-info.java
Patch:
@@ -1,3 +1,2 @@
-@org.immutables.value.Value.Style(
-    defaults = @org.immutables.value.Value.Immutable(jdkOnly = true))
+@org.immutables.value.Value.Style(jdkOnly = true)
 package org.immutables.fixture.jdkonly;
\ No newline at end of file

File: value-fixture/src/org/immutables/fixture/nested/GroupedClasses.java
Patch:
@@ -17,7 +17,7 @@
 
 import org.immutables.value.ext.ExtValue;
 import com.google.common.base.Optional;
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 @Value.Nested

File: value-fixture/src/org/immutables/fixture/nested/InnerNested.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture.nested;
 
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 @Value.Nested

File: value-fixture/src/org/immutables/fixture/nested/NonGrouped.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture.nested;
 
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 public abstract class NonGrouped {

File: value-fixture/src/org/immutables/fixture/routine/SillyRoutineImport.java
Patch:
@@ -16,7 +16,7 @@
 package org.immutables.fixture.routine;
 
 import com.google.common.net.HostAndPort;
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable(builder = false)

File: value-fixture/src/org/immutables/fixture/routine/package-info.java
Patch:
@@ -17,5 +17,5 @@
 @Json.Import(SillyMarshalingRoutines2.class)
 package org.immutables.fixture.routine;
 
-import org.immutables.value.Json;
+import org.immutables.value.ext.Json;
 

File: value-fixture/src/org/immutables/fixture/style/ConservativeStyleDetected.java
Patch:
@@ -15,12 +15,11 @@
  */
 package org.immutables.fixture.style;
 
-import org.immutables.value.BeanStyle;
 import java.util.List;
 import org.immutables.value.Value;
 
 @Value.Immutable
-@BeanStyle.Conservative
+@Conservative
 abstract class ConservativeStyleDetected {
   abstract List<String> getEm();
 

File: value-fixture/src/org/immutables/fixture/style/EnclosingBuilderNew.java
Patch:
@@ -16,7 +16,7 @@
 package org.immutables.fixture.style;
 
 import org.immutables.value.Value;
-import org.immutables.value.Value.Immutable.ImplementationVisibility;
+import org.immutables.value.Value.Style.ImplementationVisibility;
 
 /**
  * Feature combination
@@ -27,7 +27,7 @@
 @Value.Nested
 @Value.Style(
     builder = "new",
-    defaults = @Value.Immutable(visibility = ImplementationVisibility.PRIVATE))
+    visibility = ImplementationVisibility.PRIVATE)
 public abstract class EnclosingBuilderNew {
   @Value.Immutable
   public static class Hidden {}

File: value-fixture/src/org/immutables/fixture/style/HiddenImplementation.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture.style;
 
-import org.immutables.value.Value.Immutable.ImplementationVisibility;
+import org.immutables.value.Value.Style.ImplementationVisibility;
 import org.immutables.value.Value;
 
 /**
@@ -26,7 +26,8 @@
  * <li>Builder returns abstract
  * </ul>
  */
-@Value.Immutable(visibility = ImplementationVisibility.PRIVATE)
+@Value.Immutable
+@Value.Style(visibility = ImplementationVisibility.PRIVATE)
 public class HiddenImplementation {
 
   void use() {

File: value-fixture/src/org/immutables/fixture/style/LessVisibleImplementation.java
Patch:
@@ -17,7 +17,7 @@
 
 import org.immutables.fixture.style.ImmutableLessVisibleImplementation.LessVisibleImplementationBuilder;
 import org.immutables.value.Value;
-import org.immutables.value.Value.Immutable.ImplementationVisibility;
+import org.immutables.value.Value.Style.ImplementationVisibility;
 
 /**
  * Feature combination
@@ -26,7 +26,8 @@
  * <li>Builder returns abstract
  * </ul>
  */
-@Value.Immutable(visibility = ImplementationVisibility.PACKAGE)
+@Value.Immutable
+@Value.Style(visibility = ImplementationVisibility.PACKAGE)
 public class LessVisibleImplementation {
 
   void use() {

File: value-fixture/src/org/immutables/fixture/style/PackageStyle.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.immutables.fixture.style;
 
+import org.immutables.value.Value.Immutable;
 import org.immutables.value.Value;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Retention;
@@ -23,5 +24,5 @@
 
 @Target(ElementType.PACKAGE)
 @Retention(RetentionPolicy.SOURCE)
-@Value.Style(with = "copyWith*")
+@Value.Style(with = "copyWith*", defaults = @Immutable(copy = true))
 public @interface PackageStyle {}

File: value-processor/src/org/immutables/value/ext/Json.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.value;
+package org.immutables.value.ext;
 
 import com.google.common.annotations.Beta;
 import java.lang.annotation.Documented;

File: value-processor/src/org/immutables/value/ext/Mongo.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.value;
+package org.immutables.value.ext;
 
 import com.google.common.annotations.Beta;
 import java.lang.annotation.Documented;

File: value-processor/src/org/immutables/value/processor/meta/Reporter.java
Patch:
@@ -62,7 +62,7 @@ void error(String message, Object... parameters) {
   }
 
   void warning(String message, Object... parameters) {
-    reportMessage(Diagnostic.Kind.WARNING, message, parameters);
+    reportMessage(Diagnostic.Kind.MANDATORY_WARNING, message, parameters);
   }
 
   private void reportMessage(Diagnostic.Kind messageKind, String message, Object... parameters) {

File: value-processor/src/org/immutables/value/processor/meta/Visibility.java
Patch:
@@ -15,10 +15,10 @@
  */
 package org.immutables.value.processor.meta;
 
+import org.immutables.value.processor.meta.ValueMirrors.Style.ImplementationVisibility;
 import com.google.common.collect.Ordering;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Modifier;
-import org.immutables.value.Value.Immutable.ImplementationVisibility;
 
 /**
  * Type visibility interpretation. Treat protected as package.

File: common/src/org/immutables/common/marshal/JaxrsMessageBodyProvider.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.immutables.common.marshal;
 
+import org.immutables.metainf.Metainf;
 import com.fasterxml.jackson.core.JsonFactory;
 import com.fasterxml.jackson.core.JsonGenerator;
 import com.fasterxml.jackson.core.JsonParser;
@@ -42,6 +43,7 @@
  * @see org.immutables.value.Value.Immutable
  * @see org.immutables.value.Json.Marshaled
  */
+@Metainf.Service
 @Provider
 @Consumes(MediaType.APPLICATION_JSON)
 @Produces(MediaType.APPLICATION_JSON)

File: value-processor/src/org/immutables/value/processor/Processor.java
Patch:
@@ -15,17 +15,17 @@
  */
 package org.immutables.value.processor;
 
-import com.google.auto.service.AutoService;
 import com.google.common.collect.Multimap;
 import org.immutables.generator.AbstractGenerator;
 import org.immutables.generator.Generator;
+import org.immutables.metainf.Metainf;
 import org.immutables.value.Value;
 import org.immutables.value.processor.meta.ImmutableRound;
 import org.immutables.value.processor.meta.Proto.DeclaringPackage;
 import org.immutables.value.processor.meta.Round;
 import org.immutables.value.processor.meta.ValueType;
 
-@AutoService(javax.annotation.processing.Processor.class)
+@Metainf.Service
 @Generator.SupportedAnnotations({
     Value.Immutable.class,
     Value.Nested.class,
@@ -47,6 +47,6 @@ protected void process() {
     invoke(new Generator_Repositories().usingValues(values).generate());
 //    invoke(new Generator_Parboileds().usingValues(values).generate());
 //    invoke(new Generator_Transformers().usingValues(values).generate());
-    invoke(new Generator_Streamers().usingValues(values).generate());
+    invoke(new Generator_Gsons().usingValues(values).generate());
   }
 }

File: value-processor/src/org/immutables/value/processor/meta/ValueTypeComposer.java
Patch:
@@ -15,9 +15,6 @@
  */
 package org.immutables.value.processor.meta;
 
-import java.util.Set;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.util.ElementFilter;
 import com.google.common.collect.HashMultiset;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Multiset;
@@ -28,6 +25,8 @@
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.ElementFilter;
 import org.immutables.value.processor.meta.Proto.Protoclass;
 
 /**

File: generator/src/org/immutables/generator/AbstractGenerator.java
Patch:
@@ -93,8 +93,7 @@ public final boolean process(Set<? extends TypeElement> annotations, RoundEnviro
     } catch (Exception ex) {
       processingEnv.getMessager()
           .printMessage(Diagnostic.Kind.ERROR,
-              Joiner.on('\n').join(
-                  AbstractGenerator.class.getName() + " threw", Throwables.getStackTraceAsString(ex)));
+              Joiner.on('\n').join(getClass().getName() + " threw", Throwables.getStackTraceAsString(ex)));
     }
     return false;
   }

File: value-fixture/src/org/immutables/fixture/annotation/An.java
Patch:
@@ -19,6 +19,7 @@
 import java.lang.annotation.RetentionPolicy;
 import org.immutables.value.Value;
 
+@Value.Immutable
 @interface NoDefault {
   int value();
 

File: common/src/org/immutables/common/repository/internal/ExtendedBuiltinMarshalingRoutines.java
Patch:
@@ -41,6 +41,7 @@ private ExtendedBuiltinMarshalingRoutines() {}
    * @return the id
    * @throws IOException Signals that an I/O exception has occurred.
    */
+  @SuppressWarnings("deprecation")
   public static Id unmarshal(
       JsonParser parser,
       @Nullable Id idNull,
@@ -57,6 +58,7 @@ public static Id unmarshal(
     return Id.fromString(parser.getText());
   }
 
+  @SuppressWarnings("deprecation")
   public static void marshal(
       JsonGenerator generator,
       Id value) throws IOException {

File: value-fixture/src/org/immutables/fixture/SillyEntity.java
Patch:
@@ -27,11 +27,11 @@
 import org.immutables.value.Value;
 
 @Value.Immutable
-@Json.Import({ SillyEntity.class })
+@Json.Import({SillyEntity.class})
 @Mongo.Repository
 public abstract class SillyEntity {
 
-  @Json.Named("_id")
+  @Mongo.Id
   public abstract int id();
 
   @Json.Named("v")

File: value-processor/src/org/immutables/value/processor/Marshalers.java
Patch:
@@ -31,7 +31,8 @@ abstract class Marshalers extends ValuesTemplate {
         public Multimap<Character, ValueAttribute> apply(Iterable<ValueAttribute> attributes) {
           ImmutableMultimap.Builder<Character, ValueAttribute> builder = ImmutableMultimap.builder();
           for (ValueAttribute attribute : attributes) {
-            char firstChar = attribute.name().charAt(0);
+            String name = attribute.getMarshaledName();
+            char firstChar = name.charAt(0);
             builder.put(firstChar, attribute);
           }
           return builder.build();

File: value-processor/src/org/immutables/value/processor/meta/Constitution.java
Patch:
@@ -15,14 +15,14 @@
  */
 package org.immutables.value.processor.meta;
 
-import javax.lang.model.element.ExecutableElement;
 import com.google.common.base.Joiner;
 import com.google.common.base.Strings;
 import com.google.common.collect.Lists;
 import java.util.Collections;
 import java.util.List;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.PackageElement;
 import org.immutables.generator.Naming;
 import org.immutables.generator.Naming.Preference;

File: value-processor/src/org/immutables/value/processor/meta/ValueType.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.immutables.value.processor.meta;
 
-import javax.lang.model.element.TypeElement;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
 import com.google.common.base.Optional;
@@ -40,9 +39,11 @@
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleAnnotationValueVisitor7;
+import org.immutables.generator.Templates;
 import org.immutables.value.Jackson;
 import org.immutables.value.Json;
 import org.immutables.value.Mongo;

File: value-processor/src/org/immutables/value/processor/meta/Proto.java
Patch:
@@ -43,7 +43,7 @@
 import org.immutables.value.processor.meta.Styles.UsingName.TypeNames;
 
 @Value.Nested
-public final class Proto {
+public class Proto {
   private Proto() {}
 
   @Value.Immutable(intern = true, builder = false)

File: value/src/org/immutables/value/BeanStyle.java
Patch:
@@ -26,12 +26,13 @@
  * Bean related style-customizations. Serve mostly as examples
  */
 //@Target({})
+@Beta
 public @interface BeanStyle {
 
   /**
    * Annotations that applies speculative Java Bean-style accessor naming convention
    * to the generate immutable and other derived classes.
-   * It works by being annotated with {@litera @}{@link Value.Style} annotation which specifies
+   * It works by being annotated with {@literal @}{@link Value.Style} annotation which specifies
    * customized naming templates. This annotation could be placed on a class, surrounding
    * {@link Value.Nested} class or even a package (declared in {@code package-info.java}). This
    * annotation more of example of how to define your own styles as meta-annotation rather than a

File: value-fixture/src/org/immutables/fixture/nested/NonGrouped.java
Patch:
@@ -24,9 +24,9 @@ public abstract class NonGrouped {
   @Json.Marshaled
   abstract static class Abra {}
 
-  @Value.Immutable
+  @Value.Immutable(builder = false)
   @Json.Marshaled
-  interface Cadabra {
+  public interface Cadabra {
 
   }
 

File: value-fixture/src/org/immutables/fixture/style/LessVisibleImplementation.java
Patch:
@@ -1,8 +1,8 @@
 package org.immutables.fixture.style;
 
 import org.immutables.fixture.style.ImmutableLessVisibleImplementation.LessVisibleImplementationBuilder;
-import org.immutables.value.Value.Immutable.ImplementationVisibility;
 import org.immutables.value.Value;
+import org.immutables.value.Value.Immutable.ImplementationVisibility;
 
 /**
  * Feature combination

File: value-fixture/src/org/immutables/fixture/style/EnclosingHiddenImplementation.java
Patch:
@@ -30,7 +30,7 @@ public static class HiddenImplementation {}
   @Value.Immutable
   public static abstract class NonexposedImplementation {
     @Value.Parameter
-    public abstract int cons();
+    public abstract Optional<Integer> cons();
   }
 
   @Value.Immutable(builder = false, visibility = ImplementationVisibility.SAME)
@@ -46,7 +46,7 @@ void use() {
     EnclosingFactory.singletonInstanceHiddenImplementation();
     EnclosingFactory.singletonInstanceNonexposedImplementation();
     // Strictly follows naming template
-    EnclosingFactory.newNonexposedImplementation(11);
+    EnclosingFactory.newNonexposedImplementation(Optional.of(11));
     // Implementation is visible
     EnclosingFactory.VisibleImplementation.newVisibleImplementation(Optional.<Integer>absent());
   }

File: value-fixture/src/org/immutables/fixture/style/HiddenImplementation.java
Patch:
@@ -15,7 +15,7 @@
 public class HiddenImplementation {
 
   void use() {
-    HiddenImplementation instance = new HiddenImplementationBuilder().build();
+    HiddenImplementation instance = HiddenImplementationBuilder.builder().build();
     instance.toString();
   }
 }

File: value-fixture/src/org/immutables/fixture/style/package-info.java
Patch:
@@ -1,4 +1,5 @@
 @org.immutables.value.Value.Immutable.Include(Ticker.class)
+@org.immutables.fixture.style.PackageStyle
 package org.immutables.fixture.style;
 
 import com.google.common.base.Ticker;

File: value-processor/src/org/immutables/value/processor/meta/ValueType.java
Patch:
@@ -405,7 +405,7 @@ public List<ValueAttribute> getConstructorArguments() {
   }
 
   public List<ValueAttribute> getConstructorOmited() {
-    return attributes()
+    return FluentIterable.from(getImplementedAttributes())
         .filter(Predicates.compose(Predicates.equalTo(-1), ToConstructorArgumentOrder.FUNCTION))
         .toList();
   }

File: common/src/org/immutables/common/marshal/Marshaling.java
Patch:
@@ -49,6 +49,7 @@ public static String toJson(Object object) {
       JsonGenerator generator = JSON_FACTORY.createGenerator(writer);
       generator.useDefaultPrettyPrinter();
       marshaler.marshalInstance(generator, object);
+      generator.close();
       return writer.toString();
     } catch (IOException ex) {
       throw Throwables.propagate(ex);

File: common/src/org/immutables/common/jdbi/MapperFactory.java
Patch:
@@ -72,7 +72,7 @@ public void generateTokens(ResultSet result, TokenBuffer buffer) throws IOExcept
       ResultSetMetaData metaData = result.getMetaData();
       for (int j = 0; j < metaData.getColumnCount(); j++) {
         int i = j + 1;
-        String name = toLowerCamel(metaData.getColumnName(i));
+        String name = toLowerCamel(metaData.getColumnLabel(i));
         switch (metaData.getColumnType(i)) {
         case Types.VARCHAR://$FALL-THROUGH$
         case Types.LONGVARCHAR://$FALL-THROUGH$

File: value-fixture/src/org/immutables/fixture/nested/NonGrouped.java
Patch:
@@ -15,14 +15,17 @@
  */
 package org.immutables.fixture.nested;
 
+import org.immutables.value.Json;
 import org.immutables.value.Value;
 
 public abstract class NonGrouped {
 
   @Value.Immutable
+  @Json.Marshaled
   abstract static class Abra {}
 
   @Value.Immutable
+  @Json.Marshaled
   interface Cadabra {
 
   }

File: value-fixture/src/org/immutables/fixture/nested/NonGrouped.java
Patch:
@@ -15,14 +15,17 @@
  */
 package org.immutables.fixture.nested;
 
+import org.immutables.value.Json;
 import org.immutables.value.Value;
 
 public abstract class NonGrouped {
 
   @Value.Immutable
+  @Json.Marshaled
   abstract static class Abra {}
 
   @Value.Immutable
+  @Json.Marshaled
   interface Cadabra {
 
   }

File: common/src/org/immutables/common/marshal/internal/MarshalingContributor.java
Patch:
@@ -15,10 +15,10 @@
  */
 package org.immutables.common.marshal.internal;
 
+import java.util.Map;
 import org.immutables.common.marshal.Marshaler;
-import com.google.common.collect.ImmutableMap;
 
 public interface MarshalingContributor {
 
-  void putMarshalers(ImmutableMap.Builder<Class<?>, Marshaler<?>> builder);
+  void putMarshalers(Map<Class<?>, Marshaler<?>> marshalers);
 }

File: value-fixture/src/org/immutables/fixture/nested/GroupedClasses.java
Patch:
@@ -28,7 +28,5 @@ interface Other {}
   @Value.Immutable
   interface NestedOne extends Other {
     Optional<Other> other();
-
-    int attribute();
   }
 }

File: value-processor/src/org/immutables/value/processor/meta/AnnotationPrinting.java
Patch:
@@ -37,7 +37,7 @@ static List<String> getAnnotationLines(ExecutableElement element) {
 
     for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
       String string = annotation.toString();
-      if (string.startsWith("@org.immutables") || string.startsWith("@java.lang.Override")) {
+      if (string.startsWith("@org.immutables") || string.startsWith("@" + Override.class.getName())) {
         continue;
       }
       PrintVisitor printer = new PrintVisitor();

File: generator-processor/src/org/immutables/generator/processor/TemplateWriter.java
Patch:
@@ -74,7 +74,7 @@ public Unit transform(Context context, Unit value) {
         .ln().ln();
 
     context
-        .out("@", SuppressWarnings.class, "({", toLiteral("all"), ", ", toLiteral("unchecked"), "})")
+        .out("@", SuppressWarnings.class, "({", toLiteral("all"), "})")
         .ln()
         .out("public class ", simpleName, " extends ", sourceElement.getQualifiedName())
         .out(" {")
@@ -469,7 +469,7 @@ public InvokableDeclaration transform(Context context, InvokableDeclaration valu
       } else if (typeName.equals(Object.class.getName())) {
         context.out("__.param(", paramIndex, ");").ln();
       } else {
-        context.out("(", typeName, ") __.param(", paramIndex, ");").ln();
+        context.out("$cast(__.param(", paramIndex, "));").ln();
       }
     }
 

File: value-fixture/src/org/immutables/fixture/PrimitiveDefault.java
Patch:
@@ -17,7 +17,7 @@
 
 import org.immutables.value.Value;
 
-@Value.Immutable
+@Value.Immutable(nonpublic = true)
 public abstract class PrimitiveDefault {
   @Value.Default
   public boolean def() {

File: value-fixture/test/org/immutables/fixture/marshal/MarshallingTest.java
Patch:
@@ -127,13 +127,13 @@ public void marshalingPolymorphicOptionalTypes() throws IOException {
     check(list.get(0).o()).isOf(ImmutableSillySub2.builder().b("b").build());
   }
 
-  @Test(expected = RuntimeException.class)
+  @Test(expected = IOException.class)
   public void marshalingPolymorphicTypesFailedOnUnexpectedValues() throws IOException {
     Marshaler<SillyPolyHost2> m = SillyPolyHost2Marshaler.instance();
     fromJsonIterable("[{s:{b:['a']}}}]", m);
   }
 
-  @Test(expected = RuntimeException.class)
+  @Test(expected = IOException.class)
   public void marshalingPolymorphicTypesFailedOnMismatchedAttributes() throws IOException {
     Marshaler<SillyPolyHost> m = SillyPolyHostMarshaler.instance();
     fromJsonIterable("[{s:{c:1}}]", m);

File: value/src/org/immutables/value/Json.java
Patch:
@@ -62,7 +62,6 @@
    * @see #value()
    * @see Named
    */
-  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @Target({ ElementType.METHOD, ElementType.TYPE })
   public @interface Subclasses {

File: common/src/org/immutables/common/marshal/Marshaling.java
Patch:
@@ -25,7 +25,7 @@
 
 /**
  * Contains convenient methods for marshaling and unmarshaling documents annotated with
- * {@link org.immutables.json.Json.Marshaled} to and from standard textual JSON.
+ * {@link org.immutables.value.Json.Marshaled} to and from standard textual JSON.
  * <p>
  * You can avoid using this class in favor of using Marshalers directly. But It's not always
  * possible if dynamic lookup is needed.
@@ -62,7 +62,6 @@ public static String toJson(Object object) {
   public static <T> T fromJson(String json, Class<? extends T> expectedType) {
     Marshaler<T> marshaler = marshalerFor(expectedType);
     try (JsonParser parser = JSON_FACTORY.createParser(json)) {
-      parser.nextToken();
       return marshaler.unmarshalInstance(parser);
     } catch (IOException ex) {
       throw Throwables.propagate(ex);

File: generator-fixture/src/samplegenerators/Genie.java
Patch:
@@ -15,8 +15,8 @@
  */
 package samplegenerators;
 
-import org.immutables.generator.AbstractTemplate;
 import org.immutables.generator.Generator;
+import org.immutables.generator.AbstractTemplate;
 
-//@Generator.Template
+@Generator.Template
 public class Genie extends AbstractTemplate {}

File: generator-processor/src/org/immutables/generator/processor/TemplateWriter.java
Patch:
@@ -74,7 +74,7 @@ public Unit transform(Context context, Unit value) {
         .ln().ln();
 
     context
-        .out("@", SuppressWarnings.class, "(", toLiteral("unused"), ")")
+        .out("@", SuppressWarnings.class, "({", toLiteral("all"), ", ", toLiteral("unchecked"), "})")
         .ln()
         .out("public class ", simpleName, " extends ", sourceElement.getQualifiedName())
         .out(" {")
@@ -443,6 +443,8 @@ public InvokableDeclaration transform(Context context, InvokableDeclaration valu
         context.out("__.param(", paramIndex, ").toString();").ln();
       } else if (typeName.equals(Boolean.class.getName())) {
         context.out("$if(__.param(", paramIndex, "));").ln();
+      } else if (typeName.equals(Object.class.getName())) {
+        context.out("__.param(", paramIndex, ");").ln();
       } else {
         context.out("(", typeName, ") __.param(", paramIndex, ");").ln();
       }

File: generator/src/org/immutables/generator/Output.java
Patch:
@@ -159,7 +159,7 @@ void complete() {
     private void writeFile() throws IOException {
       LinkedHashSet<String> services = Sets.newLinkedHashSet();
       try {
-        FileObject existing = getFiler().getResource(StandardLocation.CLASS_PATH, key.packageName, key.relativeName);
+        FileObject existing = getFiler().getResource(StandardLocation.CLASS_OUTPUT, key.packageName, key.relativeName);
         FluentIterable.from(CharStreams.readLines(existing.openReader(true)))
             .filter(Predicates.not(Predicates.contains(COMMENT_LINE)))
             .copyInto(services);

File: value-fixture/src/org/immutables/fixture/SampleCopyOfTypes.java
Patch:
@@ -15,9 +15,10 @@
  */
 package org.immutables.fixture;
 
-import java.util.List;
 import org.immutables.value.Value;
 
+import java.util.List;
+
 @Value.Nested
 public class SampleCopyOfTypes {
   @Value.Immutable(builder = false)

File: generator/src/org/immutables/generator/AbstractGenerator.java
Patch:
@@ -47,16 +47,16 @@ protected final void invoke(Templates.Invokable invokable) {
 
   @Override
   public final Set<String> getSupportedAnnotationTypes() {
-    Set<String> annotationNames = Sets.newHashSet();
     @Nullable
     SupportedAnnotations annotations = getClass().getAnnotation(Generator.SupportedAnnotations.class);
     if (annotations != null) {
+      Set<String> annotationNames = Sets.newHashSet();
       for (Class<?> c : annotations.value()) {
         annotationNames.add(c.getCanonicalName());
       }
+      return ImmutableSet.copyOf(annotationNames);
     }
-    annotationNames.addAll(super.getSupportedAnnotationTypes());
-    return ImmutableSet.copyOf(annotationNames);
+    return super.getSupportedAnnotationTypes();
   }
 
   @Override

File: generator/src/org/immutables/generator/Generator.java
Patch:
@@ -76,8 +76,8 @@
 
   /**
    * Applies to the annotation processor extending {@link AbstractGenerator} to supply annotation
-   * names that processor will handle. Could be used instead of or in addition to
-   * {@link SupportedAnnotationTypes}.
+   * names that processor will handle. Could be used instead of {@link SupportedAnnotationTypes},
+   * which is also supported.
    */
   @Target({ ElementType.TYPE, ElementType.PACKAGE })
   @Retention(RetentionPolicy.RUNTIME)

File: generator/src/org/immutables/generator/SourceOrdering.java
Patch:
@@ -62,7 +62,7 @@ public Ordering<Element> enclosedBy(Element element) {
 
   // it's safe to cast immutable list of <? extends Element> to a list of <Element>
   @SuppressWarnings("unchecked")
-  public static ImmutableList<Element> getEnclosingElements(Element element) {
+  public static ImmutableList<Element> getEnclosedElements(Element element) {
     return (ImmutableList<Element>) enclosedBy(element).immutableSortedCopy(element.getEnclosedElements());
   }
 

File: common/src/org/immutables/common/repository/Repositories.java
Patch:
@@ -137,7 +137,7 @@ public WriteResult call() {
         }
       }).lazyTransform(GetN.FUNCTION);
     }
-    
+
     protected final FluentFuture<Optional<T>> doModify(
         final ConstraintSupport.ConstraintHost criteria,
         final ConstraintSupport.Constraint ordering,

File: testing/src/org/immutables/check/StringChecker.java
Patch:
@@ -71,7 +71,7 @@ public void isNullOrEmpty() {
   public void matches(String pattern) {
     String expectedButWasMessage = "\nExpected: string that match regex /" + pattern + "/" +
         "\n     but: was ";
-    
+
     verifyCheck(expectedButWasMessage + "null", actualValue != null);
     assert actualValue != null;
     verifyCheck(expectedButWasMessage + "\"" + actualValue + "\"", actualValue.matches(pattern));

File: value-fixture/src/org/immutables/fixture/SillyAbstract.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.json.Json;
+import org.immutables.value.Json;
 
 @Json.Subclasses({
     SillySub1.class,

File: value-fixture/src/org/immutables/fixture/SillyDumb.java
Patch:
@@ -17,7 +17,7 @@
 
 import com.google.common.base.Optional;
 import java.util.List;
-import org.immutables.json.Json;
+import org.immutables.value.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillyEntity.java
Patch:
@@ -22,8 +22,8 @@
 import java.util.List;
 import java.util.Map;
 import javax.annotation.Nullable;
-import org.immutables.json.Json;
-import org.immutables.mongo.Mongo;
+import org.immutables.value.Json;
+import org.immutables.value.Mongo;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillyIntWrap.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.json.Json;
+import org.immutables.value.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable(builder = false)
@@ -24,4 +24,4 @@ public abstract class SillyIntWrap {
 
   @Value.Parameter
   public abstract int value();
-}
\ No newline at end of file
+}

File: value-fixture/src/org/immutables/fixture/SillyMapHolder.java
Patch:
@@ -18,7 +18,7 @@
 import java.lang.annotation.RetentionPolicy;
 import java.util.Map;
 import java.util.Set;
-import org.immutables.json.Json;
+import org.immutables.value.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillyMapTup.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.lang.annotation.RetentionPolicy;
 import java.util.Map;
-import org.immutables.json.Json;
+import org.immutables.value.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable(builder = false)

File: value-fixture/src/org/immutables/fixture/SillyPolyHost.java
Patch:
@@ -16,7 +16,7 @@
 package org.immutables.fixture;
 
 import java.util.List;
-import org.immutables.json.Json;
+import org.immutables.value.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillyPolyHost2.java
Patch:
@@ -16,7 +16,7 @@
 package org.immutables.fixture;
 
 import com.google.common.base.Optional;
-import org.immutables.json.Json;
+import org.immutables.value.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillyStructure.java
Patch:
@@ -17,7 +17,7 @@
 
 import com.google.common.base.Optional;
 import java.util.List;
-import org.immutables.json.Json;
+import org.immutables.value.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillyStructureWithId.java
Patch:
@@ -15,10 +15,10 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.mongo.Mongo;
+import org.immutables.value.Mongo;
 import com.google.common.base.Optional;
 import java.util.List;
-import org.immutables.json.Json;
+import org.immutables.value.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillySub1.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.json.Json;
+import org.immutables.value.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillySub2.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.json.Json;
+import org.immutables.value.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillySub3.java
Patch:
@@ -16,7 +16,7 @@
 package org.immutables.fixture;
 
 import java.util.List;
-import org.immutables.json.Json;
+import org.immutables.value.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillySubstructure.java
Patch:
@@ -15,12 +15,12 @@
  */
 package org.immutables.fixture;
 
-import org.immutables.mongo.Mongo;
+import org.immutables.value.Mongo;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.RetentionPolicy;
 import java.util.List;
 import java.util.Set;
-import org.immutables.json.Json;
+import org.immutables.value.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable

File: value-fixture/src/org/immutables/fixture/SillyTuplie.java
Patch:
@@ -17,7 +17,7 @@
 
 import com.google.common.base.Optional;
 import java.util.Set;
-import org.immutables.json.Json;
+import org.immutables.value.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable(builder = false)

File: value-fixture/src/org/immutables/fixture/routine/SillyRoutineImport.java
Patch:
@@ -16,7 +16,7 @@
 package org.immutables.fixture.routine;
 
 import com.google.common.net.HostAndPort;
-import org.immutables.json.Json;
+import org.immutables.value.Json;
 import org.immutables.value.Value;
 
 @Value.Immutable(builder = false)

File: value-fixture/src/org/immutables/fixture/routine/package-info.java
Patch:
@@ -14,6 +14,8 @@
    limitations under the License.
  */
 @javax.annotation.ParametersAreNonnullByDefault
-@org.immutables.json.Json.Import(SillyMarshalingRoutines2.class)
+@Json.Import(SillyMarshalingRoutines2.class)
 package org.immutables.fixture.routine;
 
+import org.immutables.value.Json;
+

File: value-fixture/test/org/immutables/fixture/marshal/MarshallingTest.java
Patch:
@@ -27,11 +27,9 @@
 import org.immutables.fixture.routine.SillyRoutineImport;
 import org.immutables.fixture.routine.SillyRoutineImportMarshaler;
 import org.junit.Test;
-
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.StringWriter;
-
 import static org.immutables.check.Checkers.check;
 
 @SuppressWarnings("resource")

File: common/src/org/immutables/common/marshal/JaxrsMessageBodyProvider.java
Patch:
@@ -55,7 +55,7 @@ public class JaxrsMessageBodyProvider implements MessageBodyReader<Object>, Mess
           .build(new CacheLoader<Class<?>, Marshaler<Object>>() {
             @Override
             public Marshaler<Object> load(Class<?> type) throws Exception {
-              return MarshalingSupport.loadMarshalerFor(type);
+              return MarshalingSupport.getMarshalerFor(type);
             }
           });
 

File: common/src/org/immutables/common/marshal/Marshaling.java
Patch:
@@ -48,7 +48,7 @@ private Marshaling() {}
           .build(new CacheLoader<Class<?>, Marshaler<Object>>() {
             @Override
             public Marshaler<Object> load(Class<?> type) throws Exception {
-              return MarshalingSupport.loadMarshalerFor(type);
+              return MarshalingSupport.getMarshalerFor(type);
             }
           });
 

File: fixture/src/org/immutables/fixture/GetterEncloser.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import com.google.common.base.Optional;
 import java.lang.annotation.RetentionPolicy;

File: fixture/src/org/immutables/fixture/IfaceValue.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import java.util.List;
 import org.immutables.value.Value;

File: fixture/src/org/immutables/fixture/SillyAbstract.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import org.immutables.annotation.GenerateMarshaledSubclasses;
 

File: fixture/src/org/immutables/fixture/SillyDumb.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import com.google.common.base.Optional;
 import java.util.List;

File: fixture/src/org/immutables/fixture/SillyEmpty.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import org.immutables.value.Value;
 

File: fixture/src/org/immutables/fixture/SillyEntity.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import com.fasterxml.jackson.core.JsonGenerator;
 import com.fasterxml.jackson.core.JsonParser;

File: fixture/src/org/immutables/fixture/SillyEntitySecond.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import org.immutables.annotation.GenerateMarshaled;
 import org.immutables.annotation.GenerateRepository;

File: fixture/src/org/immutables/fixture/SillyExtendedBuilder.java
Patch:
@@ -1,11 +1,11 @@
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import org.immutables.value.Value;
 
 @Value.Immutable
 public abstract class SillyExtendedBuilder {
 
   public static class Builder {
-    public final boolean base = true;
+    public final boolean inheritedField = true;
   }
 }

File: fixture/src/org/immutables/fixture/SillyIntWrap.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import org.immutables.annotation.GenerateMarshaler;
 import org.immutables.value.Value;

File: fixture/src/org/immutables/fixture/SillyInterned.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import org.immutables.value.Value;
 

File: fixture/src/org/immutables/fixture/SillyLazy.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import java.util.concurrent.atomic.AtomicInteger;
 import org.immutables.value.Value;

File: fixture/src/org/immutables/fixture/SillyMapHolder.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import java.lang.annotation.RetentionPolicy;
 import java.util.Map;

File: fixture/src/org/immutables/fixture/SillyMapTup.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import java.lang.annotation.RetentionPolicy;
 import java.util.Map;

File: fixture/src/org/immutables/fixture/SillyMarshalingRoutines.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import com.fasterxml.jackson.core.JsonParser;
 import java.io.IOException;

File: fixture/src/org/immutables/fixture/SillyOrdinal.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import org.immutables.common.collect.OrdinalValue;
 import org.immutables.value.Value;

File: fixture/src/org/immutables/fixture/SillyOrdinalHolder.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import java.util.Set;
 import org.immutables.value.Value;

File: fixture/src/org/immutables/fixture/SillyPolyHost.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import java.util.List;
 import org.immutables.annotation.GenerateMarshaler;

File: fixture/src/org/immutables/fixture/SillyPolyHost2.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import com.google.common.base.Optional;
 import org.immutables.annotation.GenerateMarshaledSubclasses;

File: fixture/src/org/immutables/fixture/SillyStructure.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import com.google.common.base.Optional;
 import java.util.List;

File: fixture/src/org/immutables/fixture/SillyStructureWithId.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import com.google.common.base.Optional;
 import java.util.List;

File: fixture/src/org/immutables/fixture/SillySub1.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import org.immutables.annotation.GenerateMarshaler;
 import org.immutables.value.Value;

File: fixture/src/org/immutables/fixture/SillySub2.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import org.immutables.annotation.GenerateMarshaler;
 import org.immutables.value.Value;

File: fixture/src/org/immutables/fixture/SillySub3.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import java.util.List;
 import org.immutables.annotation.GenerateMarshaler;

File: fixture/src/org/immutables/fixture/SillySubstructure.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import java.lang.annotation.ElementType;
 import java.lang.annotation.RetentionPolicy;

File: fixture/src/org/immutables/fixture/SillyTuplie.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import com.google.common.base.Optional;
 import java.util.Set;

File: fixture/src/org/immutables/fixture/SillyValidatedBuiltValue.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import org.immutables.value.Value;
 import static com.google.common.base.Preconditions.*;

File: fixture/src/org/immutables/fixture/SillyValidatedConstructedValue.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 import org.immutables.value.Value;
 import static com.google.common.base.Preconditions.*;

File: fixture/src/org/immutables/fixture/SillyValue.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly;
+package org.immutables.fixture;
 
 enum SillyValue {
   ONE, TWO;

File: fixture/src/org/immutables/fixture/nested/GroupedClasses.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.generate.silly.nested;
+package org.immutables.fixture.nested;
 
 import com.google.common.base.Optional;
 import org.immutables.annotation.GenerateMarshaler;

File: fixture/src/org/immutables/fixture/nested/InnerNested.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.generate.silly.nested;
+package org.immutables.fixture.nested;
 
 import org.immutables.annotation.GenerateMarshaler;
 import org.immutables.value.Value;

File: fixture/src/org/immutables/fixture/nested/NonGrouped.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.generate.silly.nested;
+package org.immutables.fixture.nested;
 
 import org.immutables.value.Value;
 

File: fixture/src/org/immutables/fixture/routine/SillyMarshalingRoutines2.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly.routine;
+package org.immutables.fixture.routine;
 
 import com.fasterxml.jackson.core.JsonParser;
 import com.google.common.net.HostAndPort;

File: fixture/src/org/immutables/fixture/routine/SillyRoutineImport.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.generate.silly.routine;
+package org.immutables.fixture.routine;
 
 import com.google.common.net.HostAndPort;
 import org.immutables.annotation.GenerateMarshaler;

File: fixture/src/org/immutables/fixture/routine/package-info.java
Patch:
@@ -15,5 +15,5 @@
  */
 @javax.annotation.ParametersAreNonnullByDefault
 @org.immutables.annotation.GenerateMarshaler(importRoutines = SillyMarshalingRoutines2.class)
-package org.immutables.generate.silly.routine;
+package org.immutables.fixture.routine;
 

File: generator/src/org/immutables/generator/Builtins.java
Patch:
@@ -1,9 +1,9 @@
 package org.immutables.generator;
 
-import com.google.common.base.Predicate;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Converter;
 import com.google.common.base.Function;
+import com.google.common.base.Predicate;
 import com.google.common.collect.Iterables;
 import java.util.Map;
 import java.util.Objects;

File: generator/src/org/immutables/generator/Generator.java
Patch:
@@ -1,13 +1,13 @@
 package org.immutables.generator;
 
-import javax.annotation.processing.SupportedAnnotationTypes;
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Inherited;
-import java.lang.annotation.Target;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import javax.annotation.processing.SupportedAnnotationTypes;
 
 /**
  * Namespasing annotation used to group nested Generator - related annotations.

File: generator/src/org/immutables/generator/StaticEnvironment.java
Patch:
@@ -1,12 +1,12 @@
 package org.immutables.generator;
 
-import javax.annotation.Nullable;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Supplier;
 import com.google.common.collect.ClassToInstanceMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.MutableClassToInstanceMap;
 import java.util.Set;
+import javax.annotation.Nullable;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.element.TypeElement;

File: generator/src/org/immutables/generator/Templates.java
Patch:
@@ -56,7 +56,8 @@ private void beforeAppend() {
 
     public CharSequence getCurrentIndentation() {
       CharSequence sequence = getCurrentLine();
-      return CharMatcher.WHITESPACE.matchesAllOf(sequence)
+      return sequence.length() > 0 && CharMatcher.WHITESPACE.matchesAllOf(sequence)
+          // ? new StringBuilder(indentation).append(sequence)
           ? sequence
           : indentation;
     }
@@ -217,7 +218,7 @@ public Invokable invoke(Invokation invokation, Object... params) {
     private String cachedToString;
 
     CharSequence toCharSequence() {
-      if (capturedIndentation != null && arity == 0) {
+      if (arity == 0) {
         CharConsumer consumer = new CharConsumer();
         invoke(new Invokation(consumer));
         return consumer.asCharSequence();

File: generator/src/org/immutables/generator/processor/Implicits.java
Patch:
@@ -1,6 +1,5 @@
 package org.immutables.generator.processor;
 
-import org.immutables.generator.Implicit;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.ListMultimap;
@@ -9,6 +8,7 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVariable;
+import org.immutables.generator.Implicit;
 import static com.google.common.base.Preconditions.*;
 
 public class Implicits extends Introspection {

File: generator/src/org/immutables/generator/processor/Imports.java
Patch:
@@ -1,7 +1,5 @@
 package org.immutables.generator.processor;
 
-import org.immutables.generator.Generator;
-import org.immutables.generator.Templates;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
@@ -16,6 +14,8 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
+import org.immutables.generator.Generator;
+import org.immutables.generator.Templates;
 
 public final class Imports extends Introspection {
   private final TypeMirror importType;

File: generator/src/org/immutables/generator/processor/Parser.java
Patch:
@@ -15,20 +15,20 @@
 import org.immutables.generator.processor.ParboiledTrees.InvokableDeclaration;
 import org.immutables.generator.processor.ParboiledTrees.Invoke;
 import org.immutables.generator.processor.ParboiledTrees.InvokeEnd;
+import org.immutables.generator.processor.ParboiledTrees.InvokeString;
 import org.immutables.generator.processor.ParboiledTrees.IterationGenerator;
 import org.immutables.generator.processor.ParboiledTrees.Let;
 import org.immutables.generator.processor.ParboiledTrees.LetEnd;
 import org.immutables.generator.processor.ParboiledTrees.Newline;
 import org.immutables.generator.processor.ParboiledTrees.Parameter;
+import org.immutables.generator.processor.ParboiledTrees.StringLiteral;
 import org.immutables.generator.processor.ParboiledTrees.Template;
 import org.immutables.generator.processor.ParboiledTrees.TextBlock;
 import org.immutables.generator.processor.ParboiledTrees.TextFragment;
 import org.immutables.generator.processor.ParboiledTrees.TypeDeclaration;
 import org.immutables.generator.processor.ParboiledTrees.TypeIdentifier;
 import org.immutables.generator.processor.ParboiledTrees.Unit;
 import org.immutables.generator.processor.ParboiledTrees.ValueDeclaration;
-import org.immutables.generator.processor.ParboiledTrees.InvokeString;
-import org.immutables.generator.processor.ParboiledTrees.StringLiteral;
 import org.parboiled.BaseParser;
 import org.parboiled.Rule;
 import org.parboiled.annotations.DontLabel;

File: generator/src/org/immutables/generator/processor/Processor.java
Patch:
@@ -1,7 +1,5 @@
 package org.immutables.generator.processor;
 
-import org.immutables.generator.processor.ImmutableTrees.Unit;
-import org.immutables.generator.Generator;
 import com.google.auto.service.AutoService;
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableSet;
@@ -22,6 +20,8 @@
 import javax.tools.FileObject;
 import javax.tools.JavaFileObject;
 import javax.tools.StandardLocation;
+import org.immutables.generator.Generator;
+import org.immutables.generator.processor.ImmutableTrees.Unit;
 import org.parboiled.Parboiled;
 import org.parboiled.errors.ErrorUtils;
 import org.parboiled.parserunners.ReportingParseRunner;

File: generator/src/org/immutables/generator/processor/SwissArmyKnife.java
Patch:
@@ -1,12 +1,12 @@
 package org.immutables.generator.processor;
 
-import org.immutables.generator.processor.Implicits.ImplicitResolver;
 import com.google.common.collect.ImmutableMap;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
+import org.immutables.generator.processor.Implicits.ImplicitResolver;
 
 /**
  * Temporary "global context" class while interactions and structure is not sorted out well.

File: generator/test/org/immutables/generator/BuiltinOperationsTest.java
Patch:
@@ -1,7 +1,7 @@
 package org.immutables.generator;
 
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.truth.TestVerb;
 import com.google.common.truth.Truth;
 import org.junit.Test;

File: generator/test/org/immutables/generator/LegacyJavaPostprocessingTest.java
Patch:
@@ -1,9 +1,8 @@
 package org.immutables.generator;
 
-import static org.immutables.check.Checkers.*;
-import org.immutables.generator.LegacyJavaPostprocessing;
 import com.google.common.base.Joiner;
 import org.junit.Test;
+import static org.immutables.check.Checkers.*;
 
 @SuppressWarnings("deprecation")
 public class LegacyJavaPostprocessingTest {

File: generator/test/org/immutables/generator/processor/RunParser.java
Patch:
@@ -1,9 +1,7 @@
 package org.immutables.generator.processor;
 
-import org.immutables.generator.processor.ImmutableTrees.Unit;
-import org.immutables.generator.processor.Balancing;
-import org.immutables.generator.processor.Parser;
 import com.google.common.collect.ImmutableList;
+import org.immutables.generator.processor.ImmutableTrees.Unit;
 import org.parboiled.Parboiled;
 import org.parboiled.errors.ErrorUtils;
 import org.parboiled.parserunners.ReportingParseRunner;

File: value/test/org/immutables/value/sample/SampleValue.java
Patch:
@@ -1,6 +1,5 @@
 package org.immutables.value.sample;
 
-import org.immutables.annotation.GenerateConstructorParameter;
 import java.util.List;
 import org.immutables.value.Value;
 

File: generator-fixture/src/samplegenerators/Genie.java
Patch:
@@ -1,7 +1,7 @@
 package samplegenerators;
 
-import org.immutables.modeling.AbstractTemplate;
-import org.immutables.modeling.Generator;
+import org.immutables.generator.AbstractTemplate;
+import org.immutables.generator.Generator;
 
 //@Generator.Template
 public class Genie extends AbstractTemplate {}

File: generator/src/org/immutables/generator/AbstractTemplate.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.modeling;
+package org.immutables.generator;
 
 import java.util.Set;
 import javax.annotation.processing.ProcessingEnvironment;
@@ -8,7 +8,7 @@
 /**
  * 
  */
-public abstract class AbstractTemplate extends Operators {
+public abstract class AbstractTemplate extends BuiltinOperations {
 
   protected final ProcessingEnvironment processing() {
     return StaticEnvironment.processing();

File: generator/src/org/immutables/generator/Implicit.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.modeling;
+package org.immutables.generator;
 
 /**
  * Type should implement {@code Implicit} if it's implicitly mixable to (wrapper for) element of

File: generator/src/org/immutables/generator/LegacyJavaPostprocessing.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.modeling;
+package org.immutables.generator;
 
 import com.google.common.base.Joiner;
 import com.google.common.base.Splitter;

File: generator/src/org/immutables/generator/SourceOrdering.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.modeling;
+package org.immutables.generator;
 
 import com.google.common.base.Function;
 import com.google.common.base.Functions;

File: generator/src/org/immutables/generator/StaticEnvironment.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.modeling;
+package org.immutables.generator;
 
 import javax.annotation.Nullable;
 import com.google.common.base.Preconditions;

File: generator/src/org/immutables/generator/StringLiterals.java
Patch:
@@ -14,7 +14,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.modeling;
+package org.immutables.generator;
 
 import com.google.common.collect.ImmutableMap;
 import com.google.common.escape.ArrayBasedCharEscaper;

File: generator/src/org/immutables/generator/processor/Extractions.java
Patch:
@@ -13,7 +13,7 @@
    See the License for the specific language governing permissions and
    limitations under the License.
  */
-package org.immutables.modeling.templating;
+package org.immutables.generator.processor;
 
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;

File: generator/src/org/immutables/generator/processor/GeneratedTypes.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.modeling.processing;
+package org.immutables.generator.processor;
 
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;

File: generator/src/org/immutables/generator/processor/Implicits.java
Patch:
@@ -1,5 +1,6 @@
-package org.immutables.modeling.processing;
+package org.immutables.generator.processor;
 
+import org.immutables.generator.Implicit;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.ListMultimap;
@@ -8,7 +9,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVariable;
-import org.immutables.modeling.Implicit;
 import static com.google.common.base.Preconditions.*;
 
 public class Implicits extends Introspection {

File: generator/src/org/immutables/generator/processor/Imports.java
Patch:
@@ -1,5 +1,7 @@
-package org.immutables.modeling.processing;
+package org.immutables.generator.processor;
 
+import org.immutables.generator.Generator;
+import org.immutables.generator.Templates;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
@@ -14,8 +16,6 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
-import org.immutables.modeling.Generator;
-import org.immutables.modeling.Templates;
 
 public final class Imports extends Introspection {
   private final TypeMirror importType;

File: generator/src/org/immutables/generator/processor/Introspection.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.modeling.processing;
+package org.immutables.generator.processor;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;

File: generator/src/org/immutables/generator/processor/SwissArmyKnife.java
Patch:
@@ -1,6 +1,6 @@
-package org.immutables.modeling.processing;
+package org.immutables.generator.processor;
 
-import org.immutables.modeling.processing.Implicits.ImplicitResolver;
+import org.immutables.generator.processor.Implicits.ImplicitResolver;
 import com.google.common.collect.ImmutableMap;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.TypeElement;

File: generator/test/org/immutables/generator/LegacyJavaPostprocessingTest.java
Patch:
@@ -1,6 +1,7 @@
-package org.immutables.modeling;
+package org.immutables.generator;
 
 import static org.immutables.check.Checkers.*;
+import org.immutables.generator.LegacyJavaPostprocessing;
 import com.google.common.base.Joiner;
 import org.junit.Test;
 

File: modeling-fixture/src/samplegenerators/Genie.java
Patch:
@@ -3,5 +3,5 @@
 import org.immutables.modeling.AbstractTemplate;
 import org.immutables.modeling.Generator;
 
-@Generator.Template
+//@Generator.Template
 public class Genie extends AbstractTemplate {}

File: modeling/src/org/immutables/modeling/LegacyJavaPostprocessing.java
Patch:
@@ -24,6 +24,7 @@ final class LegacyJavaPostprocessing {
   private static final Pattern PACKAGE_DECLARATION =
       Pattern.compile("package ([a-z0-9_\\.]+)");
 
+  private static final Joiner LINE_JOINER = Joiner.on('\n');
   private static final Splitter LINE_SPLITTER = Splitter.on('\n');
 
   static CharSequence rewrite(CharSequence content) {
@@ -71,7 +72,7 @@ static CharSequence rewrite(CharSequence content) {
       indexOfGenImportsPlaceholder = indexOfPackageLine + 1;
     }
     modifiedLines.addAll(indexOfGenImportsPlaceholder, importStatements);
-    return Joiner.on('\n').join(modifiedLines) + '\n';
+    return LINE_JOINER.join(modifiedLines);
   }
 
   private static String extractPackageName(String l) {

File: modeling/src/org/immutables/modeling/templating/Spacing.java
Patch:
@@ -101,7 +101,7 @@ private Iterable<Trees.TemplatePart> trimWhitespace(final ArrayList<Trees.Templa
           TextLine after = (TextLine) next;
 
           if ((before.newline()
-              ? before.fragment().value().isEmpty()
+              ? before.isEmpty()
               : before.isBlank())
               && after.newline()
               && after.isBlank()) {

File: modeling/src/org/immutables/modeling/processing/JavaSink.java
Patch:
@@ -1,5 +1,5 @@
 package org.immutables.modeling.processing;
 
-public class JavaOutput {
+public final class JavaSink {
 
 }

File: modeling/src/org/immutables/modeling/processing/TemplateGenerator.java
Patch:
@@ -21,15 +21,15 @@
 import org.immutables.modeling.templating.Balancing;
 import org.immutables.modeling.templating.ImmutableTrees.Unit;
 import org.immutables.modeling.templating.Parser;
-import org.immutables.modeling.templating.Typing;
+import org.immutables.modeling.templating.Typer;
 import org.parboiled.Parboiled;
 import org.parboiled.errors.ErrorUtils;
 import org.parboiled.parserunners.ReportingParseRunner;
 import org.parboiled.support.ParsingResult;
 
 @AutoService(javax.annotation.processing.Processor.class)
 @SupportedSourceVersion(SourceVersion.RELEASE_7)
-public class Processor extends AbstractProcessor {
+public class TemplateGenerator extends AbstractProcessor {
   @Override
   public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment round) {
     if (!round.processingOver() && !round.errorRaised()) {
@@ -60,7 +60,7 @@ private void processTemplates(Set<? extends Element> templates) {
         Unit unit = (Unit) Iterables.getOnlyElement(result.valueStack);
 
         Unit balanced = Balancing.balance(unit);
-        Unit resolved = new Typing(knife).resolve(balanced);
+        Unit resolved = new Typer(knife).resolve(balanced);
 
         System.out.println(resolved);
 

File: modeling/src/org/immutables/modeling/Facet.java
Patch:
@@ -7,7 +7,7 @@
 import java.lang.annotation.Documented;
 
 /**
- * Type should implement {@code Facet} if it's mixable into
+ * Type should implement {@code Facet} if it's mixable into element of type E
  * @param <E> wrapped element type
  */
 public interface Facet<E> {

File: modeling/src/org/immutables/modeling/introspect/Binder.java
Patch:
@@ -0,0 +1,2 @@
+package org.immutables.modeling.introspect;
+

File: modeling/src/org/immutables/modeling/introspect/Facets.java
Patch:
@@ -1,5 +1,6 @@
-package org.immutables.modeling;
+package org.immutables.modeling.introspect;
 
+import org.immutables.modeling.Facet;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.ListMultimap;

File: modeling/src/org/immutables/modeling/introspect/Introspection.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.modeling;
+package org.immutables.modeling.introspect;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
@@ -68,6 +68,7 @@ protected String toSimpleName(TypeMirror typeMirror) {
 
   protected String toName(TypeMirror typeMirror) {
     return ((TypeElement) Preconditions.checkNotNull(
-        types.asElement(typeMirror), "not declared type")).getQualifiedName().toString();
+        types.asElement(typeMirror), "not declared type"))
+        .getQualifiedName().toString();
   }
 }

File: modeling/src/org/immutables/modeling/templating/Extractions.java
Patch:
@@ -179,6 +179,7 @@ protected Specify(Extractor<? extends V> extractor) {
     @Override
     public final boolean run(Context<Object> context) {
       V value = extractor.get(context);
+      @SuppressWarnings("unchecked")
       B builder = (B) context.getValueStack().peek();
       specify(builder, value);
       return true;
@@ -190,6 +191,7 @@ public final boolean run(Context<Object> context) {
   public static abstract class Build<B, T> extends ExtractorApplicator<T> {
     @Override
     public final T get(Context<Object> context) {
+      @SuppressWarnings("unchecked")
       B builder = (B) context.getValueStack().pop();
       return build(builder);
     }

File: modeling/src/org/immutables/modeling/templating/Parser.java
Patch:
@@ -25,6 +25,7 @@
 import org.immutables.modeling.templating.ParboiledTrees.TypeIdentifier;
 import org.immutables.modeling.templating.ParboiledTrees.Unit;
 import org.immutables.modeling.templating.ParboiledTrees.ValueDeclaration;
+import org.immutables.modeling.templating.ParboiledTrees.Comment;
 import org.parboiled.BaseParser;
 import org.parboiled.Rule;
 import org.parboiled.annotations.DontLabel;
@@ -48,7 +49,7 @@ public Rule Unit() {
   }
 
   Rule Comment() {
-    return Sequence(COMMENT, TextBlock(), Extractions.popped());
+    return Sequence(COMMENT, Optional(TextBlock(), Extractions.popped()), Comment.of());
   }
 
   Rule TextBlock() {
@@ -163,7 +164,7 @@ Rule IterationGenerator() {
         ValueDeclaration(), IterationGenerator.declaration(),
         IN,
         Expression(), IterationGenerator.from(),
-        Optional(If(), IterationGenerator.condition()),
+        Optional(IF, Expression(), IterationGenerator.condition()),
         IterationGenerator.build());
   }
 

File: generate/src/org/immutables/modeling/Introspection.java
Patch:
@@ -14,7 +14,7 @@
 import javax.lang.model.util.SimpleAnnotationValueVisitor7;
 import javax.lang.model.util.Types;
 
-public class Introspection {
+public abstract class Introspection {
   protected final ProcessingEnvironment environment;
   protected final Elements elements;
   protected final Types types;

File: modeling/src/org/immutables/modeling/templating/parse/RunParser.java
Patch:
@@ -12,7 +12,7 @@
 public class RunParser {
   public static void main(String... args) {
     String input =
-        "  [-- Comment --][template ff] [if a]sd[let s M... s]fsd[g]sdg\n\nsdg[/let][else if not b][let x]sdg\nsd[gds yyy]UUU[/gds]dgsdg[/let][else] [/if][/template]";
+        "[template our M x] [/template]  [-- Comment --][template ff] [if a]sd[let s M... s]fsd[g]sdg\n\nsdg[/let][else if not b][let x]sdg\nsd[gds yyy]UUU[/gds]dgsdg[/let][else] [/if][/template]";
     Parser templateParser = Parboiled.createParser(Parser.class);
     ParsingResult<Object> result = new ReportingParseRunner<>(templateParser.Unit()).run(input);
 
@@ -21,7 +21,7 @@ public static void main(String... args) {
     if (!copy.isEmpty()) {
       Unit unit = (Unit) copy.get(0);
 
-      Unit balance = Balancing.transformer().apply(unit);
+      Unit balance = Balancing.balance(unit);
 
       System.err.println("!!! " + balance);
     }

File: modeling/src/org/immutables/modeling/common/MetaModelProcessor.java
Patch:
@@ -1,4 +1,4 @@
-package org.immutables.modeling;
+package org.immutables.modeling.common;
 
 import com.google.auto.service.AutoService;
 import java.util.Set;
@@ -10,6 +10,7 @@
 
 @AutoService(javax.annotation.processing.Processor.class)
 @SupportedSourceVersion(SourceVersion.RELEASE_7)
+@Deprecated
 public class MetaModelProcessor extends AbstractProcessor {
   @Override
   public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {

File: modeling/src/org/immutables/modeling/meta/Meta.java
Patch:
@@ -4,6 +4,7 @@
 import org.immutables.annotation.GenerateImmutable;
 import org.immutables.annotation.GenerateNested;
 
+// TBD: remove it or make use of it
 @GenerateNested
 public final class Meta {
   private Meta() {}

File: modeling/src/org/immutables/modeling/templating/parse/RunParser.java
Patch:
@@ -12,7 +12,7 @@
 public class RunParser {
   public static void main(String... args) {
     String input =
-        "  [-- Comment --][template ff] [if a]sd[let s M s]fsd[g]sdg\n\nsdg[/let][else if not b][let x]sdg\nsd[gds yyy]UUU[/gds]dgsdg[/let][else] [/if][/template]";
+        "  [-- Comment --][template ff] [if a]sd[let s M... s]fsd[g]sdg\n\nsdg[/let][else if not b][let x]sdg\nsd[gds yyy]UUU[/gds]dgsdg[/let][else] [/if][/template]";
     Parser templateParser = Parboiled.createParser(Parser.class);
     ParsingResult<Object> result = new ReportingParseRunner<>(templateParser.Unit()).run(input);
 
@@ -21,7 +21,7 @@ public static void main(String... args) {
     if (!copy.isEmpty()) {
       Unit unit = (Unit) copy.get(0);
 
-      Unit balance = Balancing.balance(unit);
+      Unit balance = Balancing.transformer().apply(unit);
 
       System.err.println("!!! " + balance);
     }

File: common/src/org/immutables/common/concurrent/FluentFuture.java
Patch:
@@ -49,14 +49,13 @@ public interface FluentFuture<V> extends ListenableFuture<V> {
   /**
    * Add callback
    * @see Futures#addCallback(ListenableFuture, FutureCallback)
-   * @param future The future attach the callback to.
    * @param callback The callback to invoke when {@code future} is completed.
    * @return {@code this} future
    */
   FluentFuture<V> addCallback(FutureCallback<V> callback);
 
   /**
-   * With fallback.
+   * With fallback that computes value.
    * @see Futures#withFallback(ListenableFuture, FutureFallback)
    * @param fallback the fallback
    * @return derived fluent future
@@ -67,7 +66,6 @@ public interface FluentFuture<V> extends ListenableFuture<V> {
    * With fallback value.
    * @see Futures#withFallback(ListenableFuture, FutureFallback)
    * @see Futures#immediateFuture(Object)
-   * @param fallback the {@link FutureFallback} implementation to be called if {@code input} fails
    * @param value the value
    * @return derived fluent future
    */

File: common/src/org/immutables/common/marshal/internal/BuiltinMarshalingRoutines.java
Patch:
@@ -54,7 +54,7 @@ public static String unmarshal(
 
   /**
    * Default unmarshal for BigDecimal.
-   * <p/>
+   * <p>
    * Used in generated code via static imports method overload resolution by compiler.
    * @param parser the parser
    * @param numberNull the BigDecimal null, always {@code null}

File: service/src/org/immutables/service/concurrent/EventuallyProvides.java
Patch:
@@ -56,8 +56,8 @@
  * {@literal @}Provides
  * ListenableFuture&lt;B&gt; async(ListenableFuture&lt;A&gt; a, ListenableFuture&lt;B&gt; b) {
  *   return Futures.transform(Futures.allAsList(a, b),
- *      new Function&ltList&ltObject&gt;, C&gt;() {
- *        public C apply(List&ltObject&gt; input) {
+ *      new Function&lt;List&lt;Object&gt;, C&gt;() {
+ *        public C apply(List&lt;Object&gt; input) {
  *          A a = input.get(0);
  *          B b = input.get(1);
  *          return new B(a.value(), b.getProperty());

File: annotation/src/org/immutables/annotation/GenerateImmutable.java
Patch:
@@ -24,7 +24,7 @@
 
 /**
  * Instruct processor to generate immutable implementation of abstract value type.
- * <p/>
+ * <p>
  * <em>Be warned that such immutable object may contain attributes that are not recursively immutable, thus
  * not every object will be completely immutable. While this may be useful for some workarounds,
  * one should generally avoid creating immutable object with attribute values that could be mutated</em>

File: common/src/org/immutables/common/repository/Repositories.java
Patch:
@@ -249,7 +249,7 @@ public List<T> call() throws Exception {
           DBCursor cursor = collection.find(query, keys);
 
           if (!ordering.isNil()) {
-            cursor.sort(extractDbObject(exclusion));
+            cursor.sort(extractDbObject(ordering));
           }
 
           cursor.skip(skip);

File: common/src/org/immutables/common/collect/ImmutableOrdinalSet.java
Patch:
@@ -312,7 +312,7 @@ public boolean contains(Object object) {
     private boolean containsOrdinal(int ordinal) {
       int wordIndex = ordinal >>> POWER_OF_TWO_WORD_BITS;
       int bitIndex = ordinal - (wordIndex << POWER_OF_TWO_WORD_BITS);
-      return ((vector[wordIndex] >>> bitIndex) & 1) != 0;
+      return (wordIndex < vector.length) && ((vector[wordIndex] >>> bitIndex) & 1) != 0;
     }
 
     private boolean containsAllOrdinals(RegularImmutableOrdinalSet<?> ordinalSet) {

File: common/src/org/immutables/common/marshal/JaxrsMessageBodyProvider.java
Patch:
@@ -80,8 +80,8 @@ public Object readFrom(
     try (JsonParser parser = jsonFactory.createParser(entityStream)) {
       parser.nextToken();
       return marshalerCache.getUnchecked(type).unmarshalInstance(parser);
-    } catch (IOException e) {
-      throw new WebApplicationException(e, Response.Status.BAD_REQUEST);
+    } catch (Exception ex) {
+      throw new WebApplicationException(ex, Response.Status.BAD_REQUEST);
     }
   }
 

File: service/src/org/immutables/service/ServiceLauncher.java
Patch:
@@ -79,7 +79,9 @@ public void failure(Service service) {
         System.exit(1);
       }
     }, MoreExecutors.sameThreadExecutor());
+
     manager.startAsync().awaitHealthy();
+    manager.awaitStopped();
   }
 
   private static Module loadModule(String configurationClassName) {

File: fixture/test/org/immutables/generate/silly/CriteriaBuilderTest.java
Patch:
@@ -19,8 +19,7 @@
 import java.util.regex.Pattern;
 import org.immutables.common.repository.internal.ConstraintSupport.ConstraintHost;
 import org.immutables.common.repository.internal.RepositorySupport;
-import org.immutables.generate.silly.repository.SillyStructureWithIdRepository;
-import org.immutables.generate.silly.repository.SillyStructureWithIdRepository.Criteria;
+import org.immutables.generate.silly.SillyStructureWithIdRepository.Criteria;
 import org.junit.Test;
 import static org.immutables.check.Checkers.*;
 

File: service/test/org/immutables/service/concurrent/SampleEventuality.java
Patch:
@@ -45,9 +45,10 @@ String separator() {
     return ":";
   }
 
+  @Exposed
   @EventuallyProvides
   @Named("output")
-  public String output(
+  String output(
       @Named("first") String first,
       @Named("second") String second,
       @Named("separator") String separator) {

File: service/test/org/immutables/service/concurrent/SampleEventuality.java
Patch:
@@ -15,8 +15,9 @@ public class SampleEventuality {
   @Inject
   List<Integer> tracker;
 
+  @Exposed
   @EventuallyProvides
-  public ListenableFuture<Boolean> getInput(@Named("input") String input) {
+  ListenableFuture<Boolean> getInput(@Named("input") String input) {
     tracker.add(1);
     return Futures.immediateFuture(Boolean.parseBoolean(input));
   }

File: fixture/src/org/immutables/generate/silly/SillyOrdinal.java
Patch:
@@ -19,7 +19,7 @@
 import org.immutables.annotation.GenerateImmutable;
 import org.immutables.common.collect.OrdinalValue;
 
-@GenerateImmutable(builder = false)
+@GenerateImmutable
 public abstract class SillyOrdinal implements OrdinalValue<SillyOrdinal> {
 
   @GenerateConstructorParameter

File: common/src/org/immutables/common/marshal/internal/BuiltinMarshalingRoutines.java
Patch:
@@ -298,7 +298,7 @@ public static void marshal(
   public static TimeMeasure unmarshal(
       JsonParser parser,
       @Nullable TimeMeasure instantNull,
-      Class<TimeInstant> expectedClass) throws IOException {
+      Class<TimeMeasure> expectedClass) throws IOException {
     return TimeMeasure.fromString(parser.getText());
   }
 

File: common/src/org/immutables/common/collect/OrdinalDomain.java
Patch:
@@ -50,7 +50,8 @@ public abstract class OrdinalDomain<E extends OrdinalValue<E>> implements Iterab
   public abstract int length();
 
   /**
-   * Returned iterator may reflect some previous state o {@inheritDoc}
+   * Iterator over all present inhabitants of ordinal domain.
+   * @return snapshot iterator of elements in ordinal domain.
    */
   @Override
   public Iterator<E> iterator() {

File: service/src/org/immutables/service/JaxrsService.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.immutables.service;
 
-import org.immutables.common.marshal.JaxrsMessageBodyProvider;
 import com.google.common.annotations.Beta;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.AbstractIdleService;
@@ -32,10 +31,11 @@
 import org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpServerFactory;
 import org.glassfish.jersey.server.ApplicationHandler;
 import org.glassfish.jersey.server.ResourceConfig;
+import org.immutables.common.marshal.JaxrsMessageBodyProvider;
 import static com.google.common.base.Preconditions.*;
 
 /**
- * Combines power of Grizzly, Jersey and Guice to provide embedded JAX-RS 2.0 enpoints over http.
+ * Combines power of Grizzly, Jersey and Guice to provide embedded JAX-RS 2.0 endpoints over HTTP.
  */
 @Beta
 @ThreadSafe

File: service/src/org/immutables/service/logging/LogEvent.java
Patch:
@@ -38,7 +38,7 @@ public interface LogEvent {
   Severity getSeverity();
 
   /**
-   * Annotation constructs instance with given values.
+   * Queries special meta-data for the following event
    * @param <A> the generic type
    * @param annotationType the annotation type
    * @return the optional annotation value
@@ -59,7 +59,7 @@ public interface LogEvent {
 
   /**
    * Event source is category. Is category of event, or more precisely subsystem or type of
-   * activity where error occured
+   * activity where error occurred
    * @return the source category
    */
   String getSourceCategory();

File: service/src/org/immutables/service/logging/LogEventDispatcher.java
Patch:
@@ -27,7 +27,7 @@ public interface LogEventDispatcher {
 
   /**
    * Post an event generation callback to dispatch.
-   * @param eventCallaback the event callaback
+   * @param eventCallaback the event callback
    * @return future of when dispatch will happen
    */
   Future<LogEvent> post(Callable<LogEvent> eventCallaback);
@@ -40,7 +40,7 @@ public interface LogEventDispatcher {
 
   /**
    * Recent log events. Ordered by insertion order.
-   * @return the iterable that is snapshop of N recent events
+   * @return the iterable holds snapshot of N recent events
    */
   List<LogEvent> recentLogEvents();
 

File: service/src/org/immutables/service/logging/Tracing.java
Patch:
@@ -20,9 +20,9 @@
 public final class Tracing {
   public static void init() {
     // Trying to call as early as possible before any library tries to use JDK logging with default
-    // log manager. But anyway some kind of laucher should also reference and trigger this class
-    // initialisation in the early beginning. For the same reason class specified as string
+    // log manager. But anyway some kind of launcher should also reference and trigger this class
+    // initialization in the early beginning. For the same reason class specified as string
     // rather than 'Literal.class.getName()'
-    System.setProperty("java.util.logging.manager", "org.immutables.common.logging.internal.Slf4jJdkLogManager");
+    System.setProperty("java.util.logging.manager", "org.immutables.service.logging.internal.Slf4jJdkLogManager");
   }
 }

File: service/src/org/immutables/service/JaxrsService.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.immutables.service;
 
-import org.immutables.common.marshal.JaxrsMessageBodyProvider;
 import com.google.common.annotations.Beta;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.AbstractIdleService;
@@ -32,10 +31,11 @@
 import org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpServerFactory;
 import org.glassfish.jersey.server.ApplicationHandler;
 import org.glassfish.jersey.server.ResourceConfig;
+import org.immutables.common.marshal.JaxrsMessageBodyProvider;
 import static com.google.common.base.Preconditions.*;
 
 /**
- * Combines power of Grizzly, Jersey and Guice to provide embedded JAX-RS 2.0 enpoints over http.
+ * Combines power of Grizzly, Jersey and Guice to provide embedded JAX-RS 2.0 endpoints over HTTP.
  */
 @Beta
 @ThreadSafe

File: service/src/org/immutables/service/logging/LogEvent.java
Patch:
@@ -38,7 +38,7 @@ public interface LogEvent {
   Severity getSeverity();
 
   /**
-   * Annotation constructs instance with given values.
+   * Queries special meta-data for the following event
    * @param <A> the generic type
    * @param annotationType the annotation type
    * @return the optional annotation value
@@ -59,7 +59,7 @@ public interface LogEvent {
 
   /**
    * Event source is category. Is category of event, or more precisely subsystem or type of
-   * activity where error occured
+   * activity where error occurred
    * @return the source category
    */
   String getSourceCategory();

File: service/src/org/immutables/service/logging/LogEventDispatcher.java
Patch:
@@ -27,7 +27,7 @@ public interface LogEventDispatcher {
 
   /**
    * Post an event generation callback to dispatch.
-   * @param eventCallaback the event callaback
+   * @param eventCallaback the event callback
    * @return future of when dispatch will happen
    */
   Future<LogEvent> post(Callable<LogEvent> eventCallaback);
@@ -40,7 +40,7 @@ public interface LogEventDispatcher {
 
   /**
    * Recent log events. Ordered by insertion order.
-   * @return the iterable that is snapshop of N recent events
+   * @return the iterable holds snapshot of N recent events
    */
   List<LogEvent> recentLogEvents();
 

File: service/src/org/immutables/service/logging/Tracing.java
Patch:
@@ -20,9 +20,9 @@
 public final class Tracing {
   public static void init() {
     // Trying to call as early as possible before any library tries to use JDK logging with default
-    // log manager. But anyway some kind of laucher should also reference and trigger this class
-    // initialisation in the early beginning. For the same reason class specified as string
+    // log manager. But anyway some kind of launcher should also reference and trigger this class
+    // initialization in the early beginning. For the same reason class specified as string
     // rather than 'Literal.class.getName()'
-    System.setProperty("java.util.logging.manager", "org.immutables.common.logging.internal.Slf4jJdkLogManager");
+    System.setProperty("java.util.logging.manager", "org.immutables.service.logging.internal.Slf4jJdkLogManager");
   }
 }

File: common/test/org/immutables/common/collect/Domain.java
Patch:
@@ -19,7 +19,7 @@
 import com.google.common.cache.CacheLoader;
 import com.google.common.cache.LoadingCache;
 
-class Domain implements OrdinalDomain<Ord> {
+class Domain extends OrdinalDomain<Ord> {
   private final LoadingCache<Integer, Ord> values =
       CacheBuilder.newBuilder()
           .build(new CacheLoader<Integer, Ord>() {

File: common/src/org/immutables/common/marshal/internal/MarshalingSupport.java
Patch:
@@ -108,7 +108,7 @@ public static Object unmarshalWithOneOfMarshalers(
       String attributeType,
       Marshaler<?>... marshalers) throws IOException {
 
-    try (TokenBuffer buffer = new TokenBuffer(null)) { // intentional null
+    try (TokenBuffer buffer = new TokenBuffer(parser)) {
       buffer.copyCurrentStructure(parser);
 
       @Nullable

File: service/src/org/immutables/service/JerseyInjectBridges.java
Patch:
@@ -120,7 +120,7 @@ private static void initBridgeInjectorIfAvailable(ServiceLocator serviceLocator)
     }
 
     /**
-     * Overriden to skip injection for supplied instances. {@inheritDoc}
+     * Overridden to skip injection for supplied instances. {@inheritDoc}
      */
     @Override
     public void inject(Object injectMe) {
@@ -130,7 +130,7 @@ public void inject(Object injectMe) {
     }
 
     /**
-     * Overriden to skip injection for supplied instances. {@inheritDoc}
+     * Overridden to skip injection for supplied instances. {@inheritDoc}
      */
     @Override
     public void inject(Object injectMe, String strategy) {

File: fixture/test/org/immutables/generate/silly/ValuesTest.java
Patch:
@@ -29,9 +29,9 @@ public void builderInheritence() {
 
   @Test
   public void ordinalValue() {
-    SillyOrdinal a = ImmutableSillyOrdinal.of("a");
-    SillyOrdinal b = ImmutableSillyOrdinal.of("b");
-    SillyOrdinal c = ImmutableSillyOrdinal.of("c");
+    ImmutableSillyOrdinal a = ImmutableSillyOrdinal.of("a");
+    ImmutableSillyOrdinal b = ImmutableSillyOrdinal.of("b");
+    ImmutableSillyOrdinal c = ImmutableSillyOrdinal.of("c");
 
     check(Arrays.asList(a.ordinal(), b.ordinal(), c.ordinal())).isOf(0, 1, 2);
 

File: annotation/src/org/immutables/annotation/GenerateMarshaler.java
Patch:
@@ -22,11 +22,11 @@
 import java.lang.annotation.Target;
 
 /**
- * Instructs generator to generate marshaller.
+ * Instructs generator to generate marshaler.
  * When applied to abstract {@link GenerateImmutable immutable} it will generate corresponding
  * marshaler class in the same package. It will have name of abstract immutable class with
  * 'Marshaler' suffix.
- * When applied to package it may provide imports for marshaling routines for
+ * When applied to a package, it is used to specify imports of marshaling routines for
  * each generated marshaler in a package.
  */
 @Documented

File: common/src/org/immutables/common/logging/Stringification.java
Patch:
@@ -141,7 +141,7 @@ public static void appendMessage(
         }
 
         if (formatPattern.indexOf('%') >= 0) {
-
+          @SuppressWarnings("resource")
           Formatter formatter = locale != null
               ? new Formatter(locale)
               : new Formatter();

File: fixture/test/org/immutables/generate/silly/SillyManualFixture.java
Patch:
@@ -106,6 +106,7 @@ public static void main3(String... args) throws Exception {
 
     tokenBuffer.copyCurrentStructure(parser);
     System.out.println(tokenBuffer.asParser());
+    tokenBuffer.close();
   }
 
   public static void main44(String... args) throws Exception {

File: check/src/org/immutables/check/ObjectChecker.java
Patch:
@@ -37,10 +37,11 @@
  */
 public class ObjectChecker<T> {
 
+  @Nullable
   final T actualValue;
   final boolean negate;
 
-  ObjectChecker(T actualValue, boolean negate) {
+  ObjectChecker(@Nullable T actualValue, boolean negate) {
     this.actualValue = actualValue;
     this.negate = negate;
   }

File: check/src/org/immutables/check/StringChecker.java
Patch:
@@ -15,14 +15,15 @@
  */
 package org.immutables.check;
 
+import javax.annotation.Nullable;
 import org.hamcrest.Matchers;
 import org.hamcrest.text.IsEmptyString;
 import org.junit.Assert;
 
 /** The string match wrapper. */
 public class StringChecker extends ObjectChecker<String> {
 
-  StringChecker(String actualValue, boolean negate) {
+  StringChecker(@Nullable String actualValue, boolean negate) {
     super(actualValue, negate);
   }
 

File: common/src/org/immutables/common/logging/internal/Slf4jJdkLoggerAdapter.java
Patch:
@@ -15,12 +15,12 @@
  */
 package org.immutables.common.logging.internal;
 
-import org.immutables.common.logging.Stringification;
 import java.util.logging.Filter;
 import java.util.logging.Handler;
 import java.util.logging.Level;
 import java.util.logging.LogRecord;
 import java.util.logging.Logger;
+import org.immutables.common.logging.Stringification;
 import org.slf4j.LoggerFactory;
 
 class Slf4jJdkLoggerAdapter extends Logger {
@@ -64,7 +64,7 @@ public Filter getFilter() {
   }
 
   @Override
-  public synchronized Handler[] getHandlers() {
+  public Handler[] getHandlers() {
     return new Handler[0];
   }
 
@@ -88,7 +88,7 @@ public void setParent(Logger parent) {}
   public void setLevel(Level newLevel) throws SecurityException {}
 
   @Override
-  public synchronized void setUseParentHandlers(boolean useParentHandlers) {}
+  public void setUseParentHandlers(boolean useParentHandlers) {}
 
   @Override
   public Level getLevel() {

File: fixture/test/org/immutables/generate/silly/SillyManualFixture.java
Patch:
@@ -76,7 +76,7 @@ private static SillyStructureWithId fromJson(String string) throws IOException {
 
     JsonParser jsonParser = jsonFactory.createParser(string);
     jsonParser.nextToken();
-    return SillyStructureWithIdMarshaler.unmarshal(jsonParser, null, null);
+    return SillyStructureWithIdMarshaler.unmarshal(jsonParser, null, SillyStructureWithId.class);
   }
 
   private static byte[] toBson(SillyStructureWithId structure) throws IOException {

File: fixture/test/org/immutables/common/service/SillyConfig.java
Patch:
@@ -1,6 +1,5 @@
 package org.immutables.common.service;
 
-import com.google.common.collect.ImmutableList;
 import com.google.inject.Binder;
 import com.google.inject.Module;
 import javax.inject.Provider;

File: fixture/test/org/immutables/generate/silly/MarshallingGenerationTest.java
Patch:
@@ -190,7 +190,7 @@ private String marshalDumb(SillyDumb emptyDumb) throws IOException {
   }
 
   private <T> ImmutableList<T> fromJsonIterable(String string, Marshaler<T> marshaler) throws IOException {
-    JsonParser jsonParser = jsonFactory.createJsonParser(string);
+    JsonParser jsonParser = jsonFactory.createParser(string);
     jsonParser.nextToken();
     return ImmutableList.copyOf(marshaler.unmarshalIterable(jsonParser));
   }
@@ -219,7 +219,7 @@ private <T> byte[] toBsonIterable(Iterable<T> it, Marshaler<T> marshaler) throws
   }
 
   private SillyStructure fromJson(String string) throws IOException {
-    JsonParser jsonParser = jsonFactory.createJsonParser(string);
+    JsonParser jsonParser = jsonFactory.createParser(string);
     jsonParser.nextToken();
     return SillyStructureMarshaler.instance().unmarshalInstance(jsonParser);
   }

File: fixture/test/org/immutables/generate/silly/SillyManualFixture.java
Patch:
@@ -74,7 +74,7 @@ private static SillyStructureWithId fromJson(String string) throws IOException {
         .flag2(true)
         .or();
 
-    JsonParser jsonParser = jsonFactory.createJsonParser(string);
+    JsonParser jsonParser = jsonFactory.createParser(string);
     jsonParser.nextToken();
     return SillyStructureWithIdMarshaler.unmarshal(jsonParser, null, null);
   }
@@ -89,7 +89,7 @@ private static byte[] toBson(SillyStructureWithId structure) throws IOException
   }
 
   public static void main(String... args) throws Exception {
-    JsonParser parser = jsonFactory.createJsonParser("{a:1,b:2}");
+    JsonParser parser = jsonFactory.createParser("{a:1,b:2}");
     TokenBuffer tokenBuffer = new TokenBuffer(new ObjectMapper());
 
     JsonToken t = parser.nextToken();
@@ -234,7 +234,7 @@ public static void main1(String... args) throws Exception {
                 .join(Splitter.on(' ')
                     .split("26 00 00 00 10 5F 69 64 00 05 00 00 00 03 70 00 15 00 00 00 10 43 43 00 05 00 00 00 10 44 44 00 05 00 00 00 00 00")));
 
-    BsonParser p = new BsonFactory().createJsonParser(new ByteArrayInputStream(data));
+    BsonParser p = new BsonFactory().createParser(new ByteArrayInputStream(data));
     p.nextToken();
 
     SillyEntity unmarshal = SillyEntityMarshaler.instance().unmarshalInstance(p);

File: common/src/org/immutables/common/collect/ImmutableOrdinalSet.java
Patch:
@@ -30,7 +30,7 @@ public abstract class ImmutableOrdinalSet<E extends OrdinalValue<E>>
   private ImmutableOrdinalSet() {
   }
 
-  private static final ImmutableOrdinalSet<?> EMPTY_SET = new EmptyImmutableOrdinalSet<>();
+  private static final ImmutableOrdinalSet<? extends OrdinalValue<?>> EMPTY_SET = new EmptyImmutableOrdinalSet<>();
 
   @SuppressWarnings("unchecked")
   public static <E extends OrdinalValue<E>> ImmutableOrdinalSet<E> of() {

File: generate-fixture/src/org/immutables/generate/silly/SillyAbstract.java
Patch:
@@ -1,5 +1,4 @@
 package org.immutables.generate.silly;
 
 public abstract class SillyAbstract {
-
 }

File: annotation/src/org/immutables/annotation/GenerateMarshaledAs.java
Patch:
@@ -23,6 +23,8 @@
 /**
  * Use {@code GenerateMarshaledAs} to customize marshaling of annotated attribute.
  * Typical usage is to customize name in JSON/BSON representation
+ * <p>
+ * This example used to define JSON attribute name as "_id" during marshaling and unmarshaling.
  * 
  * <pre>
  * @GenerateMarshaledAs("_id")
@@ -52,8 +54,6 @@
    * result in error due to undecidable situation.
    * @return subclasses of an attributes' abstract type that annotated with
    *         {@link GenerateMarshaler}
-   * @deprecated needlessly complicated feature
    */
-  @Deprecated
   Class<?>[] expectedSubclasses() default {};
 }

File: generate-fixture/test/org/immutables/generate/silly/CriteriaBuilderTest.java
Patch:
@@ -13,7 +13,7 @@ public class CriteriaBuilderTest {
 
   @Test
   public void ranges() {
-    check(stringify(where().attr1AtLeast("1")))
+    check(stringify(SillyStructureWithIdRepository.where().attr1AtLeast("1")))
         .is("{ 'attr1' : { '$gte' : '1'}}");
 
     check(stringify(where().attr1LessThan("ZZZ")))

