File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -99,7 +99,6 @@ protected Map<String, String> getDecompilerOptions() {
   @Test public void testSyntheticAccess() { doTest("pkg/TestSyntheticAccess"); }
   @Test public void testIllegalVarName() { doTest("pkg/TestIllegalVarName"); }
   @Test public void testIffSimplification() { doTest("pkg/TestIffSimplification"); }
-  @Test public void testKotlinConstructor() { doTest("pkg/TestKotlinConstructorKt"); }
   @Test public void testAsserts() { doTest("pkg/TestAsserts"); }
   @Test public void testLocalsNames() { doTest("pkg/TestLocalsNames"); }
   @Test public void testAnonymousParamNames() { doTest("pkg/TestAnonymousParamNames"); }
@@ -256,5 +255,4 @@ protected Map<String, String> getDecompilerOptions() {
   @Test public void testTryCatchFinallyMismatched() { doTest("pkg/TestTryCatchFinallyMismatched"); }
   @Test public void testNestedCalls() { doTest("pkg/TestNestedCalls"); }
   @Test public void testBreakpointsContextProvider() { doTest("com/intellij/tasks/context/java/BreakpointsContextProvider"); }
-  @Test public void testKotlinDefaultValueConstructor() {doTest("pkg/KotlinDefaultValue"); }
 }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -256,5 +256,5 @@ protected Map<String, String> getDecompilerOptions() {
   @Test public void testTryCatchFinallyMismatched() { doTest("pkg/TestTryCatchFinallyMismatched"); }
   @Test public void testNestedCalls() { doTest("pkg/TestNestedCalls"); }
   @Test public void testBreakpointsContextProvider() { doTest("com/intellij/tasks/context/java/BreakpointsContextProvider"); }
-
+  @Test public void testKotlinDefaultValueConstructor() {doTest("pkg/KotlinDefaultValue"); }
 }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -255,5 +255,6 @@ protected Map<String, String> getDecompilerOptions() {
   @Test public void testNestedInheritor() { doTest("pkg/TestNestedInheritor"); }
   @Test public void testTryCatchFinallyMismatched() { doTest("pkg/TestTryCatchFinallyMismatched"); }
   @Test public void testNestedCalls() { doTest("pkg/TestNestedCalls"); }
+  @Test public void testBreakpointsContextProvider() { doTest("com/intellij/tasks/context/java/BreakpointsContextProvider"); }
 
 }

File: src/org/jetbrains/java/decompiler/modules/decompiler/SwitchPatternHelper.java
Patch:
@@ -1265,7 +1265,6 @@ private static void changeDefaultToFullCase(@NotNull SwitchStatement myRoot, @No
               statementWithFirstAssignment.getExprents().get(0) instanceof AssignmentExprent assignmentExprent &&
               assignmentExprent.getRight() != null &&
               assignmentExprent.getLeft() instanceof VarExprent newVarExprent &&
-              assignmentExprent.getLeft().getExprType() != null &&
               assignmentExprent.getRight().equals(newSwitch) &&
               assignmentExprent.getLeft().getExprType().equals(newSwitch.getExprType())) {
             statementWithFirstAssignment.getExprents().remove(0);

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/ArrayExprent.java
Patch:
@@ -1,6 +1,7 @@
 // Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
+import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
@@ -32,6 +33,7 @@ public Exprent copy() {
     return new ArrayExprent(array.copy(), index.copy(), hardType, bytecode);
   }
 
+  @NotNull
   @Override
   public VarType getExprType() {
     VarType exprType = array.getExprType();

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java
Patch:
@@ -1,6 +1,7 @@
 // Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
+import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;
@@ -46,6 +47,7 @@ public AssignmentExprent(Exprent left, Exprent right, BitSet bytecodeOffsets) {
     addBytecodeOffsets(bytecodeOffsets);
   }
 
+  @NotNull
   @Override
   public VarType getExprType() {
     return left.getExprType();

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
Patch:
@@ -1,6 +1,7 @@
 // Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
+import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;
@@ -58,6 +59,7 @@ public int getPrecedence() {
     return 0; // the highest precedence
   }
 
+  @NotNull
   public VarType getExprType() {
     return VarType.VARTYPE_VOID;
   }

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/SwitchExprent.java
Patch:
@@ -1,6 +1,7 @@
 // Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
+import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.CheckTypesResult;
@@ -41,6 +42,7 @@ public Exprent copy() {
     return swExpr;
   }
 
+  @NotNull
   @Override
   public VarType getExprType() {
     return value.getExprType();

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
Patch:
@@ -65,6 +65,7 @@ public VarExprent(int index, VarType varType, VarProcessor processor, BitSet byt
     this.addBytecodeOffsets(bytecode);
   }
 
+  @NotNull
   @Override
   public VarType getExprType() {
     return getVarType();
@@ -241,6 +242,7 @@ public void setInsideLVT(boolean insideLVT) {
     this.insideLVT = insideLVT;
   }
 
+  @NotNull
   public VarType getVarType() {
     if (inferredType != null) {
       return inferredType;

File: src/org/jetbrains/java/decompiler/struct/gen/VarType.java
Patch:
@@ -1,6 +1,7 @@
 // Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.struct.gen;
 
+import org.jetbrains.annotations.NotNull;
 import org.jetbrains.java.decompiler.code.CodeConstants;
 
 import java.util.Map;
@@ -177,6 +178,7 @@ protected static int getFamily(int type, int arrayDim) {
     };
   }
 
+  @NotNull
   public VarType decreaseArrayDim() {
     if (getArrayDim() > 0) {
       return new VarType(getType(), getArrayDim() - 1, getValue());

File: src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
Patch:
@@ -1,6 +1,7 @@
 // Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.struct.gen.generics;
 
+import org.jetbrains.annotations.NotNull;
 import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
@@ -227,6 +228,7 @@ public static String getNextType(String value) {
     return value.substring(0, index + 1);
   }
 
+  @NotNull
   @Override
   public GenericType decreaseArrayDim() {
     assert getArrayDim() > 0 : this;

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -254,5 +254,6 @@ protected Map<String, String> getDecompilerOptions() {
   @Test public void testNotNullRecord() { doTest("pkg/TestNotNullRecord"); }
   @Test public void testNestedInheritor() { doTest("pkg/TestNestedInheritor"); }
   @Test public void testTryCatchFinallyMismatched() { doTest("pkg/TestTryCatchFinallyMismatched"); }
+  @Test public void testNestedCalls() { doTest("pkg/TestNestedCalls"); }
 
 }

File: src/org/jetbrains/java/decompiler/modules/decompiler/SecondaryFunctionsHelper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
@@ -89,7 +89,7 @@ public static boolean identifySecondaryFunctions(Statement stat, VarProcessor va
       List<? extends IMatchable> lstObjects = new ArrayList<>(stat.getExprentsOrSequentialObjects());
 
       for (int i = 0; i < lstObjects.size(); i++) {
-        Object obj = lstObjects.get(i);
+        IMatchable obj = lstObjects.get(i);
 
         if (obj instanceof Statement) {
           if (identifySecondaryFunctions((Statement)obj, varProc)) {
@@ -423,7 +423,7 @@ public static Exprent propagateBoolNot(Exprent exprent) {
   public static void updateAssignments(Statement stat) {
     List<? extends IMatchable> objects = new ArrayList<>(stat.getExprentsOrSequentialObjects());
 
-    for (Object obj : objects) {
+    for (IMatchable obj : objects) {
       if (obj instanceof Statement) {
         updateAssignments((Statement) obj);
       } else if (obj instanceof Exprent) {

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -89,7 +89,7 @@ public void classLambdaToJava(ClassNode node, TextBuffer buffer, Exprent method_
       if (node.lambdaInformation.is_method_reference) {
         if (!node.lambdaInformation.is_content_method_static && method_object != null) {
           // reference to a virtual method
-          method_object.getInferredExprType(new VarType(CodeConstants.TYPE_OBJECT, 0, node.lambdaInformation.content_class_name));
+          method_object.inferExprType(new VarType(CodeConstants.TYPE_OBJECT, 0, node.lambdaInformation.content_class_name));
           String instance = method_object.toJava(indent, tracer).toString();
           // If the instance is casted, then we need to wrap it
           if (method_object.type == Exprent.EXPRENT_FUNCTION && ((FunctionExprent)method_object).getFuncType() == FunctionExprent.FUNCTION_CAST && ((FunctionExprent)method_object).doesCast()) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/EliminateLoopsHelper.java
Patch:
@@ -62,14 +62,14 @@ private static boolean eliminateLoopsRec(Statement stat) {
       }
     }
 
-    if (stat.type == Statement.StatementType.DO && isLoopRedundant((DoStatement)stat)) {
+    if (stat.type == Statement.StatementType.DO && findAndReduceRedundantLoop((DoStatement)stat)) {
       return true;
     }
 
     return false;
   }
 
-  private static boolean isLoopRedundant(DoStatement loop) {
+  private static boolean findAndReduceRedundantLoop(DoStatement loop) {
 
     if (loop.getLoopType() != DoStatement.LoopType.DO) {
       return false;

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
Patch:
@@ -976,7 +976,7 @@ public static TextBuffer listToJava(List<? extends Exprent> lst, int indent, Byt
         tracer.incrementCurrentSourceLine();
       }
 
-      expr.getInferredExprType(null);
+      expr.inferExprType(null);
 
       TextBuffer content = expr.toJava(indent, tracer);
 
@@ -1050,7 +1050,8 @@ public static boolean getCastedExprent(Exprent exprent,
       }
     }
 
-    VarType rightType = exprent.getInferredExprType(leftType);
+    exprent.inferExprType(leftType);
+    VarType rightType = exprent.getExprType();
 
     boolean isCastNull =
       rightType.getType() == CodeConstants.TYPE_NULL && !UNDEFINED_TYPE_STRING.equals(getTypeName(leftType, Collections.emptyList()));

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/DoStatement.java
Patch:
@@ -111,7 +111,7 @@ private DoStatement(Statement head) {
         Exprent initFirstExprent = initExprent.get(0);
         if (initFirstExprent != null && incFirstExprent != null) {
           buf.appendIndent(indent).append("for(").append(initFirstExprent.toJava(indent, tracer));
-          incFirstExprent.getInferredExprType(null); //TODO: Find a better then null? For now just calls it to clear casts if needed
+          incFirstExprent.inferExprType(null); //TODO: Find a better then null? For now just calls it to clear casts if needed
           buf.append(" : ").append(incFirstExprent.toJava(indent, tracer)).append(") {").appendLineSeparator();
           tracer.incrementCurrentSourceLine();
           buf.append(ExprProcessor.jmpWrapper(first, indent + 1, true, tracer));

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java
Patch:
@@ -70,7 +70,7 @@ public void setDebugVarNames(Map<VarVersion, String> mapDebugVarNames) {
     Map<Integer, VarVersion> mapOriginalVarIndices = varVersions.getMapOriginalVarIndices();
 
     List<VarVersion> listVars = new ArrayList<>(mapVarNames.keySet());
-    listVars.sort(Comparator.<VarVersion>comparingInt(o -> mapPurgedAssignmentNames.containsKey(o) ? 0 : 1)
+    listVars.sort(Comparator.<VarVersion, Boolean>comparing(o -> !mapPurgedAssignmentNames.containsKey(o))
                     .thenComparingInt(o -> o.var));
 
     Map<String, Integer> mapNames = new HashMap<>();

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/RecordVarExprent.java
Patch:
@@ -56,6 +56,7 @@ public void addComponent(@NotNull RecordVarExprent exprent) {
   public RecordVarExprent copy() {
     VarExprent copy = (VarExprent)super.copy();
     RecordVarExprent newRoot = new RecordVarExprent(copy);
+    newRoot.setLVTEntry(copy.getLVTEntry());
     for (RecordVarExprent component : components) {
       newRoot.addComponent(component.copy());
     }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -148,8 +148,6 @@ protected Map<String, String> getDecompilerOptions() {
   @Test public void testSimpleInstanceOfRecordPatternJavac() { doTest("pkg/TestSimpleInstanceOfRecordPatternJavac"); }
   @Test public void testComplexInstanceOfRecordPatternJavac() { doTest("pkg/TestComplexInstanceOfRecordPatternJavac"); }
   @Test public void testSwitchWithDeconstructionsWithoutNestedJavac() { doTest("pkg/TestSwitchWithDeconstructionsWithoutNestedJavac"); }
-
-  //todo fix nested variables
   @Test public void testSwitchNestedDeconstructionJavac() { doTest("pkg/TestSwitchNestedDeconstructionsJavac"); }
   @Test public void testSwitchWrapReturnJavac() { doTest("pkg/TestSwitchWrapReturnJavac"); }
 

File: src/org/jetbrains/java/decompiler/code/Instruction.java
Patch:
@@ -6,7 +6,7 @@
 
 public class Instruction {
   public static Instruction create(int opcode, boolean wide, int group, int bytecodeVersion, int[] operands, int length) {
-	return create(opcode, wide, group, bytecodeVersion, operands, length, null);
+    return create(opcode, wide, group, bytecodeVersion, operands, length, null);
   }
   public static Instruction create(int opcode, boolean wide, int group, int bytecodeVersion, int[] operands, int length, ConstantPool pool) {
     if (opcode >= CodeConstants.opc_ifeq && opcode <= CodeConstants.opc_if_acmpne ||

File: src/org/jetbrains/java/decompiler/main/InitializerProcessor.java
Patch:
@@ -89,7 +89,7 @@ private static void hideEmptySuper(ClassWrapper wrapper) {
     for (MethodWrapper method : wrapper.getMethods()) {
       if (CodeConstants.INIT_NAME.equals(method.methodStruct.getName()) && method.root != null) {
         Statement firstData = Statements.findFirstData(method.root);
-        if (firstData == null || firstData.getExprents().isEmpty()) {
+        if (firstData == null || firstData.getExprents() == null || firstData.getExprents().isEmpty()) {
           return;
         }
 

File: src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
Patch:
@@ -4,7 +4,6 @@
 import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.code.InstructionSequence;
 import org.jetbrains.java.decompiler.code.cfg.ControlFlowGraph;
-import org.jetbrains.java.decompiler.decompiler.modules.decompiler.EliminateLoopsHelper;
 import org.jetbrains.java.decompiler.main.CancellationManager;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.collectors.CounterContainer;
@@ -183,7 +182,7 @@ public static RootStatement codeToJava(StructClass cl, StructMethod mt, MethodDe
       LabelHelper.cleanUpEdges(root);
 
       while (true) {
-        if (EliminateLoopsHelper.eliminateLoops(root, cl)) {
+        if (EliminateLoopsHelper.eliminateLoops(root, mt, cl)) {
           continue;
         }
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/LowBreakHelper.java
Patch:
@@ -1,7 +1,6 @@
 // Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
-package org.jetbrains.java.decompiler.decompiler.modules.decompiler;
+package org.jetbrains.java.decompiler.modules.decompiler;
 
-import org.jetbrains.java.decompiler.modules.decompiler.StatEdge;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.IfStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.SynchronizedStatement;

File: src/org/jetbrains/java/decompiler/modules/decompiler/decompose/FastExtendedPostdominanceHelper.java
Patch:
@@ -1,7 +1,6 @@
 // Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler.decompose;
 
-import org.jetbrains.java.decompiler.decompiler.modules.decompiler.decompose.SupportComponent;
 import org.jetbrains.java.decompiler.modules.decompiler.StatEdge;
 import org.jetbrains.java.decompiler.modules.decompiler.StatEdge.EdgeType;
 import org.jetbrains.java.decompiler.modules.decompiler.StrongConnectivityHelper;

File: src/org/jetbrains/java/decompiler/modules/decompiler/decompose/SupportComponent.java
Patch:
@@ -1,8 +1,7 @@
 // Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
-package org.jetbrains.java.decompiler.decompiler.modules.decompiler.decompose;
+package org.jetbrains.java.decompiler.modules.decompiler.decompose;
 
 import org.jetbrains.java.decompiler.modules.decompiler.StatEdge;
-import org.jetbrains.java.decompiler.modules.decompiler.decompose.DominatorEngine;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
 import org.jetbrains.java.decompiler.util.FastFixedSetFactory;
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/RecordVarExprent.java
Patch:
@@ -80,6 +80,7 @@ public boolean copyFrom(@NotNull VarExprent varExprent) {
     this.setVarType(varExprent.getVarType());
     this.setIndex(varExprent.getIndex());
     this.setVersion(varExprent.getVersion());
+    this.setLVT(varExprent.getLVT());
     return true;
   }
 

File: testData/bulk/pkg/res/Loader.java
Patch:
@@ -17,8 +17,8 @@ public String getResource() {
             stream.read(bytes);
             stream.close();
             return new String(bytes, "UTF-8");
-         } catch (Exception var5) {
-            throw new RuntimeException("Resource load failed", var5);
+         } catch (Exception e) {
+            throw new RuntimeException("Resource load failed", e);
          }
       }
    }

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExprUtil.java
Patch:
@@ -46,7 +46,7 @@ else if (parameters > 0 && node.type == ClassNode.CLASS_MEMBER && !isStatic(node
     return mask;
   }
 
-  private static boolean isStatic(StructClass struct) {
+  public static boolean isStatic(StructClass struct) {
     if (struct.hasModifier(CodeConstants.ACC_STATIC))
       return true;
     if (struct.hasAttribute(StructGeneralAttribute.ATTRIBUTE_INNER_CLASSES)) {

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -147,9 +147,8 @@ protected Map<String, String> getDecompilerOptions() {
   @Test public void testComplexInstanceOfRecordPatternJavac() { doTest("pkg/TestComplexInstanceOfRecordPatternJavac"); }
   @Test public void testSwitchWithDeconstructionsWithoutNestedJavac() { doTest("pkg/TestSwitchWithDeconstructionsWithoutNestedJavac"); }
 
-  //todo fix after merging
   //todo fix nested variables
-  //@Test public void testSwitchNestedDeconstructionJavac() { doTest("pkg/TestSwitchNestedDeconstructionsJavac"); }
+  @Test public void testSwitchNestedDeconstructionJavac() { doTest("pkg/TestSwitchNestedDeconstructionsJavac"); }
   @Test public void testSwitchWrapReturnJavac() { doTest("pkg/TestSwitchWrapReturnJavac"); }
 
   // TODO: fix all below

File: src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
Patch:
@@ -243,6 +243,7 @@ public static RootStatement codeToJava(StructClass cl, StructMethod mt, MethodDe
     varProc.setVarDefinitions(root);
 
     cancellationManager.checkCanceled();
+    SecondaryFunctionsHelper.updateAssignments(root);
 
     // must be the last invocation, because it makes the statement structure inconsistent
     // FIXME: new edge type needed

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -242,9 +242,8 @@ protected Map<String, String> getDecompilerOptions() {
 
   @Test(expected = ClassFormatException.class)
   public void testUnsupportedConstantPoolEntry() { doTest("java11/TestUnsupportedConstantPoolEntry"); }
-
   @Test public void testSwitchOnStatic() { doTest("pkg/SwitchOnStatic"); }
-
+  @Test public void testCompoundAssignment() { doTest("pkg/TestCompoundAssignment"); }
   @Test public void testTryToPreserveCast() { doTest("pkg/TryToPreserveCast"); }
 
   @Test public void testPreserveAssignmentToRecord() { doTest("pkg/PreserveAssignmentToRecord"); }

File: src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java
Patch:
@@ -175,7 +175,7 @@ public static RootStatement codeToJava(StructClass cl, StructMethod mt, MethodDe
 
     cancellationManager.checkCanceled();
 
-    if (cl.isVersion(CodeConstants.BYTECODE_JAVA_9)) {
+    if (cl.isVersion9()) {
       ConcatenationHelper.simplifyStringConcat(root);
     }
 

File: testData/src/java11/TestJava11StringConcatEmptyAffix.java
Patch:
@@ -45,7 +45,7 @@ public String testIntIntSuffix(int first, int second) {
     }
 
     public String testIntString(int intValue, String stringValue) {
-        return "" + intValue + stringValue;
+        return intValue + stringValue;
     }
 
     public String testStringInt(int intValue, String stringValue) {

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -26,7 +26,7 @@ protected Map<String, String> getDecompilerOptions() {
                          IFernflowerPreferences.VERIFY_ANONYMOUS_CLASSES, "1",
                          IFernflowerPreferences.CONVERT_PATTERN_SWITCH, "1",
                          IFernflowerPreferences.CONVERT_RECORD_PATTERN, "1",
-                         IFernflowerPreferences.INLINE_SIMPLE_LAMBDAS, "0"
+                         IFernflowerPreferences.INLINE_SIMPLE_LAMBDAS, "1"
                          //IFernflowerPreferences.INCLUDE_ENTIRE_CLASSPATH, "1"
     );
   }

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -722,7 +722,8 @@ else if (CodeConstants.CLINIT_NAME.equals(name)) {
         //if (init && !isEnum && ((node.access & CodeConstants.ACC_STATIC) == 0) && node.type == ClassNode.CLASS_MEMBER)
         //    index++;
         for (int i = methodWrapper.varproc.getFirstParameterPosition(); i < md.params.length; i++) {
-          VarType parameterType = hasDescriptor && !descriptor.parameterTypes.isEmpty() ? descriptor.parameterTypes.get(paramCount) : md.params[i];
+          VarType parameterType =
+            hasDescriptor && descriptor.parameterTypes.size() > paramCount ? descriptor.parameterTypes.get(paramCount) : md.params[i];
           if (mask == null || mask.get(i) == null) {
             if (paramCount > 0) {
               buffer.append(", ");

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
Patch:
@@ -252,7 +252,7 @@ protected void wrapInCast(VarType left, VarType right, TextBuffer buf, int prece
     boolean needsCast =
       (left != null && !left.isSuperset(right)) && (right.equals(VarType.VARTYPE_OBJECT) || left.getType() != CodeConstants.TYPE_OBJECT);
 
-    if (left.isGeneric() || right.isGeneric()) {
+    if (left != null && right != null && (left.isGeneric() || right.isGeneric())) {
       Map<VarType, List<VarType>> names = this.getNamedGenerics();
       int arrayDim = 0;
 

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -158,8 +158,7 @@ protected Map<String, String> getDecompilerOptions() {
   //@Test public void testInUse() { doTest("pkg/TestInUse"); }
   @Test public void testGroovyClass() { doTest("pkg/TestGroovyClass"); }
   @Test public void testGroovyTrait() { doTest("pkg/TestGroovyTrait"); }
-  //todo check after all fixes
-  //@Test public void testPrivateClasses() { doTest("pkg/PrivateClasses"); }
+  @Test public void testPrivateClasses() { doTest("pkg/PrivateClasses"); }
   @Test public void testSuspendLambda() { doTest("pkg/TestSuspendLambdaKt"); }
   @Test public void testNamedSuspendFun2Kt() { doTest("pkg/TestNamedSuspendFun2Kt"); }
   @Test public void testGenericArgs() { doTest("pkg/TestGenericArgs"); }

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
Patch:
@@ -252,11 +252,11 @@ protected void wrapInCast(VarType left, VarType right, TextBuffer buf, int prece
     boolean needsCast =
       (left != null && !left.isSuperset(right)) && (right.equals(VarType.VARTYPE_OBJECT) || left.getType() != CodeConstants.TYPE_OBJECT);
 
-    if (left != null && left.isGeneric()) {
+    if (left.isGeneric() || right.isGeneric()) {
       Map<VarType, List<VarType>> names = this.getNamedGenerics();
       int arrayDim = 0;
 
-      if (left.getArrayDim() == right.getArrayDim()) {
+      if (left.getArrayDim() == right.getArrayDim() && left.getArrayDim() > 0) {
         arrayDim = left.getArrayDim();
         left = left.resizeArrayDim(0);
         right = right.resizeArrayDim(0);

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -830,7 +830,7 @@ else if (CodeConstants.CLINIT_NAME.equals(name)) {
             tracer.addTracer(codeTracer);
           }
           catch (Throwable t) {
-            String message = "Method " + mt.getName() + " " + mt.getDescriptor() + " couldn't be written.";
+            String message = "Method " + mt.getName() + " " + mt.getDescriptor() + " in class " + node.classStruct.qualifiedName + " couldn't be written.";
             DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN, t);
             methodWrapper.decompiledWithErrors = true;
           }

File: src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
Patch:
@@ -102,7 +102,7 @@ public void init() {
         throw e;
       }
       catch (Throwable t) {
-        String message = "Method " + mt.getName() + " " + mt.getDescriptor() + " couldn't be decompiled.";
+        String message = "Method " + mt.getName() + " " + mt.getDescriptor() + " in class " + classStruct.qualifiedName + " couldn't be decompiled.";
         DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN, t);
         isError = true;
       }

File: src/org/jetbrains/java/decompiler/struct/StructContext.java
Patch:
@@ -2,6 +2,7 @@
 package org.jetbrains.java.decompiler.struct;
 
 import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger.Severity;
 import org.jetbrains.java.decompiler.main.extern.IResultSaver;
 import org.jetbrains.java.decompiler.struct.lazy.LazyLoader;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
@@ -122,6 +123,7 @@ else if (filename.endsWith(".zip")) {
   }
 
   private void addArchive(String path, File file, int type, boolean isOwn) throws IOException {
+    DecompilerContext.getLogger().writeMessage("Adding Archive: " + file.getAbsolutePath(), Severity.INFO);
     try (ZipFile archive = type == ContextUnit.TYPE_JAR ? new JarFile(file) : new ZipFile(file)) {
       Enumeration<? extends ZipEntry> entries = archive.entries();
       while (entries.hasMoreElements()) {
@@ -145,6 +147,7 @@ private void addArchive(String path, File file, int type, boolean isOwn) throws
         if (!entry.isDirectory()) {
           if (name.endsWith(".class")) {
             byte[] bytes = InterpreterUtil.getBytes(archive, entry);
+            DecompilerContext.getLogger().writeMessage("  Loading Class: " + name, Severity.INFO);
             StructClass cl = StructClass.create(new DataInputFullStream(bytes), isOwn, loader);
             classes.put(cl.qualifiedName, cl);
             unit.addClass(cl, name);

File: src/org/jetbrains/java/decompiler/main/extern/IVariableNameProvider.java
Patch:
@@ -7,7 +7,7 @@
 import java.util.Map;
 
 public interface IVariableNameProvider {
-  public Map<VarVersionPair,String> rename(Map<VarVersionPair,String> variables);
+  Map<VarVersionPair,String> rename(Map<VarVersionPair, String> variables);
 
   default String renameAbstractParameter(String name, int index) {
      return name;
@@ -19,5 +19,5 @@ default String renameParameter(int flags, String type, String name, int index) {
      return name;
   }
 
-  public void addParentContext(IVariableNameProvider renamer);
+  void addParentContext(IVariableNameProvider renamer);
 }

File: src/org/jetbrains/java/decompiler/struct/StructMethod.java
Patch:
@@ -75,7 +75,7 @@ public static StructMethod create(DataInputFullStream in, ConstantPool pool, Str
   private final String classQualifiedName;
   private final GenericMethodDescriptor signature;
   private IVariableNameProvider renamer;
-  public Set<String> enclosedClasses; // Dirty hack, but the management of nested classes is trash.
+  public Set<String> enclosedClasses; // Dirty hack, not to manage nested classes.
 
   private StructMethod(int accessFlags,
                        Map<String, StructGeneralAttribute> attributes,

File: src/org/jetbrains/java/decompiler/util/StatementIterator.java
Patch:
@@ -7,7 +7,7 @@
 
 import java.util.List;
 
-public class StatementIterator {
+public final class StatementIterator {
   public static void iterate(Statement stat, ExprentIterator itr) {
     if (stat == null) {
       return;

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -53,7 +53,6 @@ protected Map<String, String> getDecompilerOptions() {
     doTest("pkg/TestConstants");
   }
 
-  //todo fix after merging
   @Test public void testInteger() {
     DecompilerContext.setProperty(IFernflowerPreferences.LITERALS_AS_IS, "0");
     doTest("java/lang/Integer");
@@ -149,6 +148,7 @@ protected Map<String, String> getDecompilerOptions() {
 
   //todo fix after merging
   //todo fix ++i
+  //todo fix nested variables
   //@Test public void testSwitchNestedDeconstructionJavac() { doTest("pkg/TestSwitchNestedDeconstructionsJavac"); }
   @Test public void testSwitchWrapReturnJavac() { doTest("pkg/TestSwitchWrapReturnJavac"); }
 

File: src/org/jetbrains/java/decompiler/main/ClassReference14Processor.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.main;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
@@ -142,7 +142,8 @@ private static void mapClassMethods(ClassNode node, Map<ClassWrapper, MethodWrap
             BasicBlockStatement body = (BasicBlockStatement)cst.getFirst();
             BasicBlockStatement handler = (BasicBlockStatement)cst.getStats().get(1);
 
-            if (body.getExprents().size() == 1 && handler.getExprents().size() == 1) {
+            if (body.getExprents() != null && body.getExprents().size() == 1 &&
+                handler.getExprents() != null && handler.getExprents().size() == 1) {
               if (BODY_EXPR.equals(body.getExprents().get(0)) &&
                   HANDLER_EXPR.equals(handler.getExprents().get(0))) {
                 map.put(wrapper, method);

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.main;
 
 import org.jetbrains.annotations.NotNull;

File: src/org/jetbrains/java/decompiler/main/DecompilerContext.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.main;
 
 import org.jetbrains.annotations.NotNull;

File: src/org/jetbrains/java/decompiler/main/Fernflower.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.main;
 
 import org.jetbrains.annotations.Nullable;

File: src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
Patch:
@@ -89,7 +89,7 @@ static Map<String, Object> getDefaults() {
     defaults.put(CONVERT_RECORD_PATTERN, "0");
     defaults.put(CONVERT_PATTERN_SWITCH, "0");
 
-    defaults.put(STANDARDIZE_FLOATING_POINT_NUMBERS, "1");
+    defaults.put(STANDARDIZE_FLOATING_POINT_NUMBERS, "0");
     defaults.put(INCLUDE_ENTIRE_CLASSPATH, "0");
 
     defaults.put(LOG_LEVEL, IFernflowerLogger.Severity.INFO.name());

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
Patch:
@@ -249,7 +249,8 @@ protected Map<VarType, List<VarType>> getNamedGenerics() {
   }
 
   protected void wrapInCast(VarType left, VarType right, TextBuffer buf, int precedence) {
-    boolean needsCast = !left.isSuperset(right) && (right.equals(VarType.VARTYPE_OBJECT) || left.getType() != CodeConstants.TYPE_OBJECT);
+    boolean needsCast =
+      (left != null && !left.isSuperset(right)) && (right.equals(VarType.VARTYPE_OBJECT) || left.getType() != CodeConstants.TYPE_OBJECT);
 
     if (left != null && left.isGeneric()) {
       Map<VarType, List<VarType>> names = this.getNamedGenerics();

File: src/org/jetbrains/java/decompiler/struct/StructClass.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.struct;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;

File: src/org/jetbrains/java/decompiler/struct/StructField.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.struct;
 
 import org.jetbrains.java.decompiler.main.DecompilerContext;

File: src/org/jetbrains/java/decompiler/struct/StructMethod.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.struct;
 
 import org.jetbrains.java.decompiler.code.*;

File: src/org/jetbrains/java/decompiler/struct/StructRecordComponent.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.struct;
 
 import org.jetbrains.java.decompiler.main.DecompilerContext;

File: src/org/jetbrains/java/decompiler/struct/gen/MethodDescriptor.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.struct.gen;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;

File: src/org/jetbrains/java/decompiler/struct/gen/VarType.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.struct.gen;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;

File: src/org/jetbrains/java/decompiler/struct/gen/generics/GenericClassDescriptor.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.struct.gen.generics;
 
 import org.jetbrains.java.decompiler.struct.gen.VarType;

File: src/org/jetbrains/java/decompiler/struct/gen/generics/GenericFieldDescriptor.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.struct.gen.generics;
 
 import org.jetbrains.java.decompiler.struct.gen.VarType;

File: src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMethodDescriptor.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.struct.gen.generics;
 
 import org.jetbrains.java.decompiler.struct.gen.VarType;

File: src/org/jetbrains/java/decompiler/struct/lazy/LazyLoader.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.struct.lazy;
 
 import org.jetbrains.java.decompiler.main.extern.IBytecodeProvider;

File: src/org/jetbrains/java/decompiler/util/ClasspathScanner.java
Patch:
@@ -14,8 +14,8 @@
 import java.util.HashSet;
 import java.util.Optional;
 import java.util.Set;
-
-public class ClasspathScanner {
+//todo support path from idea?
+public final class ClasspathScanner {
 
     public static void addAllClasspath(StructContext ctx) {
       Set<String> found = new HashSet<>();
@@ -53,7 +53,7 @@ private static void addAllModulePath(StructContext ctx) {
             DecompilerContext.getLogger().writeMessage("  " + cls, Severity.INFO);
             try {
               Optional<ByteBuffer> bb = reader.read(cls);
-              if (!bb.isPresent()) {
+              if (bb.isEmpty()) {
                 DecompilerContext.getLogger().writeMessage("    Error Reading Class: " + cls, Severity.ERROR);
                 return;
               }

File: testData/kt25937/kt/Kt25937_1Kt.java
Patch:
@@ -19,7 +19,7 @@
 )
 public final class Kt25937_1Kt {
    public static final int some1() {
-      return Kt25937Kt.callSuspendBlock((Function1)(new Function1<Continuation<? super Unit>, Object>((Continuation)null) {
+      return Kt25937Kt.callSuspendBlock(new Function1<Continuation<? super Unit>, Object>((Continuation)null) {
          int label;
 
          @Nullable
@@ -44,6 +44,6 @@ public final Continuation<Unit> create(@NotNull Continuation<?> completion) {
          public final Object invoke(Object var1) {
             return ((<undefinedtype>)this.create((Continuation)var1)).invokeSuspend(Unit.INSTANCE);
          }
-      }));
+      });
    }
 }

File: testData/obfuscated/a1.java
Patch:
@@ -86,6 +86,6 @@ public String toString() {
    }
 
    public o e(String var1) throws XPathExpressionException {
-      return o.b((Object)this.d(var1));
+      return o.b(this.d(var1));
    }
 }

File: testData/obfuscated/a4.java
Patch:
@@ -112,7 +112,7 @@ public void a() throws Exception {
             var10000[1] = (new String(var9)).intern();
             c = var10000;
             a = false;
-            b = y.a(ad.class);
+            b = y.<ad>a(ad.class);
             return;
          }
 
@@ -150,7 +150,7 @@ public void a() throws Exception {
                var10000[1] = (new String(var17)).intern();
                c = var10000;
                a = false;
-               b = y.a(ad.class);
+               b = y.<ad>a(ad.class);
                return;
             }
 

File: testData/obfuscated/aj.java
Patch:
@@ -101,7 +101,7 @@ protected void b(k<ak> var1) {
                Long var7 = (Long)this.b.get(var6.getKey());
                if (var7 != null) {
                   double var8 = (double)(((Long)var6.getValue() - var7) * 10L) / (double)var3;
-                  var1.a((Object)(new ar(h[1], (String)var6.getKey(), "%", var8 * 100.0)));
+                  var1.a(new ar(h[1], (String)var6.getKey(), "%", var8 * 100.0));
                }
             }
          }

File: testData/obfuscated/b.java
Patch:
@@ -42,7 +42,7 @@ public V f() {
    }
 
    public void a(V var1) {
-      this.e = var1;
+      this.e = (V)var1;
    }
 
    public b(K var1, V var2, long var3, long var5) {
@@ -51,12 +51,12 @@ public b(K var1, V var2, long var3, long var5) {
       this.a = new ah();
       this.b = 0L;
       this.c = 0L;
-      this.d = var1;
+      this.d = (K)var1;
       this.f = var3;
       this.g = var5;
       this.c = System.currentTimeMillis();
       this.b = this.c;
-      this.e = var2;
+      this.e = (V)var2;
       if (ap.c != 0) {
          boolean var10000;
          label18: {

File: testData/obfuscated/e.java
Patch:
@@ -87,7 +87,7 @@ public void j() {
    }
 
    public V a(K var1) {
-      return this.a(var1, this.c);
+      return (V)this.a(var1, this.c);
    }
 
    public boolean c(K var1) {

File: testData/obfuscated/v.java
Patch:
@@ -78,7 +78,7 @@ private static void b(Field var0, Object var1) {
 
    public <I> I a(Class<I> var1) {
       try {
-         return a(var1.newInstance());
+         return (I)a(var1.newInstance());
       } catch (Throwable var3) {
          throw new IllegalArgumentException(var3);
       }

File: testData/obfuscated/y.java
Patch:
@@ -9,7 +9,7 @@ private y(Class<P> var1) {
    }
 
    public static <P> y<P> a(Class<P> var0) {
-      return new y(var0);
+      return new y<P>(var0);
    }
 
    public P a() {

File: testData/obfuscated/z.java
Patch:
@@ -9,7 +9,7 @@ private z(Class<P> var1) {
    }
 
    public static <P> z<P> a(Class<P> var0) {
-      return new z(var0);
+      return new z<P>(var0);
    }
 
    public List<P> a() {

File: src/org/jetbrains/java/decompiler/decompiler/modules/decompiler/EliminateLoopsHelper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.decompiler.modules.decompiler;
 
 import org.jetbrains.java.decompiler.modules.decompiler.SequenceHelper;
@@ -10,8 +10,7 @@
 
 import java.util.*;
 
-
-public class EliminateLoopsHelper {
+public final class EliminateLoopsHelper {
 
   public static boolean eliminateLoops(Statement root, StructClass cl) {
 

File: src/org/jetbrains/java/decompiler/decompiler/modules/decompiler/LowBreakHelper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.decompiler.modules.decompiler;
 
 import org.jetbrains.java.decompiler.modules.decompiler.StatEdge;

File: src/org/jetbrains/java/decompiler/decompiler/modules/decompiler/decompose/SupportComponent.java
Patch:
@@ -1,3 +1,4 @@
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.decompiler.modules.decompiler.decompose;
 
 import org.jetbrains.java.decompiler.modules.decompiler.StatEdge;

File: src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.main.rels;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;

File: src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.main.rels;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
@@ -960,7 +960,7 @@ public int hashCode() {
     }
   }
 
-  private static interface ExprentIteratorWithReplace {
+  private interface ExprentIteratorWithReplace {
     // null - remove exprent
     // ret != exprent - replace exprent with ret
     Exprent processExprent(Exprent exprent);

File: src/org/jetbrains/java/decompiler/modules/decompiler/DomHelper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler;
 
 import org.jetbrains.java.decompiler.code.cfg.BasicBlock;

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExitHelper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler;
 
 import org.jetbrains.java.decompiler.code.cfg.BasicBlock;

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
@@ -348,7 +348,7 @@ else if (cn instanceof LinkConstant) {
           if (offsets != null) { //TODO: Figure out why this nulls in some cases
             offsets.set(offset, offset + instr.length);
           }
-          VarExprent left = new VarExprent(varIndex, varTypes[instr.opcode - CodeConstants.opc_istore], varProcessor, offsets, true);
+          VarExprent left = new VarExprent(varIndex, varTypes[instr.opcode - CodeConstants.opc_istore], varProcessor, offsets);
           varProcessor.findLVT(left, offset + instr.length);
           exprList.add(new AssignmentExprent(left, value, offsets));
           break;

File: src/org/jetbrains/java/decompiler/modules/decompiler/InlineSingleBlockHelper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler;
 
 import org.jetbrains.java.decompiler.modules.decompiler.StatEdge.EdgeDirection;

File: src/org/jetbrains/java/decompiler/modules/decompiler/PPandMMHelper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler;
 
 import org.jetbrains.java.decompiler.modules.decompiler.exps.*;

File: src/org/jetbrains/java/decompiler/modules/decompiler/StackVarsProcessor.java
Patch:
@@ -18,8 +18,6 @@
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionsGraph;
 import org.jetbrains.java.decompiler.struct.StructClass;
 import org.jetbrains.java.decompiler.struct.StructMethod;
-import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
-import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTableAttribute;
 import org.jetbrains.java.decompiler.util.FastSparseSetFactory.FastSparseSet;
 import org.jetbrains.java.decompiler.util.SFormsFastMapDirect;
 
@@ -367,6 +365,7 @@ else if (right.type == Exprent.EXPRENT_VAR) {
       }
     }
 
+    /*local variables are used now
     //workaround to preserve variable names
     AssignmentExprent assignmentExprent = (AssignmentExprent)exprent;
     if (assignmentExprent.getRight() instanceof VarExprent && assignmentExprent.getLeft() instanceof VarExprent leftExp) {
@@ -380,6 +379,7 @@ else if (right.type == Exprent.EXPRENT_VAR) {
         }
       }
     }
+    */
 
     if (isSelfReference && vernotreplaced) {
       return new int[]{-1, changed};

File: src/org/jetbrains/java/decompiler/modules/decompiler/StatEdge.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler;
 
 import org.jetbrains.annotations.NotNull;

File: src/org/jetbrains/java/decompiler/modules/decompiler/decompose/FastExtendedPostdominanceHelper.java
Patch:
@@ -1,6 +1,7 @@
-// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler.decompose;
 
+import org.jetbrains.java.decompiler.decompiler.modules.decompiler.decompose.SupportComponent;
 import org.jetbrains.java.decompiler.modules.decompiler.StatEdge;
 import org.jetbrains.java.decompiler.modules.decompiler.StatEdge.EdgeType;
 import org.jetbrains.java.decompiler.modules.decompiler.StrongConnectivityHelper;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
 import org.jetbrains.annotations.NotNull;

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/DirectGraph.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler.sforms;
 
 import org.jetbrains.java.decompiler.main.CancellationManager;

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/FlattenStatementsHelper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler.sforms;
 
 import org.jetbrains.java.decompiler.modules.decompiler.StatEdge;

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/Statement.java
Patch:
@@ -819,7 +819,7 @@ public void setCopied(boolean copied) {
 
   // helper methods
   public String toString() {
-    return String.format("{%d}:%d", type, id);
+    return String.format("{%s}:%d", type, id);
   }
 
   //TODO: Cleanup/cache?

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarTypeProcessor.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler.vars;
 
 import org.jetbrains.annotations.NotNull;
@@ -170,7 +170,7 @@ else if (newType.getTypeFamily() < currentMinType.getTypeFamily()) {
         ((ConstExprent)exprent).setConstType(newMinType);
       }
       return currentMinType == null ||
-             (newMinType.getTypeFamily() <= currentMinType.getTypeFamily() && !newMinType.isStrictSuperset(currentMinType));
+             (newMinType!=null && newMinType.getTypeFamily() <= currentMinType.getTypeFamily() && !newMinType.isStrictSuperset(currentMinType));
     }
     VarType currentMaxType = maxExprentTypes.get(varVersion);
     VarType newMaxType;

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler.vars;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;

File: src/org/jetbrains/java/decompiler/struct/StructContext.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.struct;
 
 import org.jetbrains.java.decompiler.main.DecompilerContext;
@@ -180,8 +180,8 @@ public boolean instanceOf(String valclass, String refclass) {
     }
 
     int[] interfaces = cl.getInterfaces();
-    for (int i = 0; i < interfaces.length; i++) {
-      String intfc = cl.getPool().getPrimitiveConstant(interfaces[i]).getString();
+    for (int anInterface : interfaces) {
+      String intfc = cl.getPool().getPrimitiveConstant(anInterface).getString();
 
       if (this.instanceOf(intfc, refclass)) {
         return true;

File: src/org/jetbrains/java/decompiler/struct/StructMember.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.struct;
 
 import org.jetbrains.annotations.NotNull;

File: src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTypeTableAttribute.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.struct.attr;
 
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;

File: testData/bulk/pkg/res/Loader.java
Patch:
@@ -17,8 +17,8 @@ public String getResource() {
             stream.read(bytes);
             stream.close();
             return new String(bytes, "UTF-8");
-         } catch (Exception e) {
-            throw new RuntimeException("Resource load failed", e);
+         } catch (Exception var5) {
+            throw new RuntimeException("Resource load failed", var5);
          }
       }
    }

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExitHelper.java
Patch:
@@ -175,7 +175,7 @@ private static int integrateExits(Statement stat) {
   private static Statement isExitEdge(StatEdge edge) {
     Statement dest = edge.getDestination();
 
-    if (edge.getType() == EdgeType.BREAK && dest.type == StatementType.BASIC_BLOCK && edge.explicit && (edge.labeled || isOnlyEdge(edge))) {
+    if (edge.getType() == EdgeType.BREAK && dest.type == StatementType.BASIC_BLOCK && edge.explicit && (edge.labeled || isOnlyEdge(edge)) && edge.canInline) {
       List<Exprent> data = dest.getExprents();
 
       if (data != null && data.size() == 1) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/InlineSingleBlockHelper.java
Patch:
@@ -121,6 +121,9 @@ private static boolean isInlineable(SequenceStatement seq, int index) {
       StatEdge edge = lst.get(0);
 
       if (sameCatchRanges(edge)) {
+        if (!edge.canInline) {
+          return false; //Dirty hack, but lets do it!
+        }
         if (!edge.explicit) {
           for (int i = index; i < seq.getStats().size(); i++) {
             if (!noExitLabels(seq.getStats().get(i), seq)) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/StatEdge.java
Patch:
@@ -15,6 +15,7 @@ public class StatEdge {
   public Statement closure;
   public boolean labeled = true;
   public boolean explicit = true;
+  public boolean canInline = true;
 
   private StatEdge(@NotNull EdgeType type,
                   Statement source,

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
Patch:
@@ -453,7 +453,7 @@ private static String getClassNameForPrimitiveType(int type) {
     "charValue", "java/lang/Character"
   );
 
-  private boolean isUnboxingCall() {
+  public boolean isUnboxingCall() {
     return !isStatic && parameters.isEmpty() && className.equals(UNBOXING_METHODS.get(name));
   }
 
@@ -653,4 +653,4 @@ else if (key == MatchProperties.EXPRENT_INVOCATION_SIGNATURE) {
 
     return true;
   }
-}
\ No newline at end of file
+}

File: src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTypeTableAttribute.java
Patch:
@@ -17,7 +17,7 @@
 */
 public class StructLocalVariableTypeTableAttribute extends StructGeneralAttribute {
   // store signature instead of descriptor
-  private final StructLocalVariableTableAttribute backingAttribute = new StructLocalVariableTableAttribute();
+  final StructLocalVariableTableAttribute backingAttribute = new StructLocalVariableTableAttribute();
 
   @Override
   public void initContent(DataInputFullStream data, ConstantPool pool) throws IOException {

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -29,6 +29,7 @@ protected Map<String, String> getDecompilerOptions() {
     );
   }
 
+  @Test public void testEnhancedForLoops() { doTest("pkg/TestEnhancedForLoops"); }
   @Test public void testPrimitiveNarrowing() { doTest("pkg/TestPrimitiveNarrowing"); }
   @Test public void testClassFields() { doTest("pkg/TestClassFields"); }
   @Test public void testInterfaceFields() { doTest("pkg/TestInterfaceFields"); }

File: testData/bulk/pkg/res/Loader.java
Patch:
@@ -17,8 +17,7 @@ public String getResource() {
             stream.read(bytes);
             stream.close();
             return new String(bytes, "UTF-8");
-         } catch (Exception var5) {
-            Exception e = var5;
+         } catch (Exception e) {
             throw new RuntimeException("Resource load failed", e);
          }
       }

File: src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
Patch:
@@ -49,6 +49,7 @@ public interface IFernflowerPreferences {
 
   String DUMP_ORIGINAL_LINES = "__dump_original_lines__";
   String UNIT_TEST_MODE = "__unit_test_mode__";
+  String DOTS_FOLDER = "dsf";
 
   String LINE_SEPARATOR_WIN = "\r\n";
   String LINE_SEPARATOR_UNX = "\n";

File: src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
Patch:
@@ -714,10 +714,10 @@ private static boolean isEqual(boolean both, VarFieldPair fObj, VarFieldPair sOb
     }
     else {
       eq = true;
-      if (fObj.fieldKey.length() == 0) {
+      if (fObj.fieldKey.isEmpty()) {
         fObj.fieldKey = sObj.fieldKey;
       }
-      else if (sObj.fieldKey.length() == 0) {
+      else if (sObj.fieldKey.isEmpty()) {
         if (both) {
           sObj.fieldKey = fObj.fieldKey;
         }

File: src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
Patch:
@@ -24,6 +24,7 @@
 import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
+import org.jetbrains.java.decompiler.util.DotExporter;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
 
 import java.util.*;
@@ -261,6 +262,7 @@ private static void computeLocalVarsAndDefinitions(ClassNode node) {
       // iterate enclosing class
       for (MethodWrapper method : node.getWrapper().getMethods()) {
         if (method.root != null) { // neither abstract, nor native
+          DotExporter.toDotFile(method.getOrBuildGraph(), method.methodStruct, "computeLocalVars");
           method.getOrBuildGraph().iterateExprents(exprent -> {
             List<Exprent> lst = exprent.getAllExprents(true);
             lst.add(exprent);

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
Patch:
@@ -14,6 +14,7 @@
 import org.jetbrains.java.decompiler.struct.StructMethod;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
+import org.jetbrains.java.decompiler.util.DotExporter;
 import org.jetbrains.java.decompiler.util.FastSparseSetFactory.FastSparseSet;
 
 import java.util.*;
@@ -36,6 +37,8 @@ public void setVarVersions(RootStatement root, VarVersionsProcessor previousVers
     FlattenStatementsHelper flattenHelper = new FlattenStatementsHelper();
     DirectGraph graph = flattenHelper.buildDirectGraph(root);
 
+    DotExporter.toDotFile(graph, method, "setVarVersions");
+
     mergePhiVersions(ssa, graph);
 
     typeProcessor.calculateVarTypes(root, graph);

File: src/org/jetbrains/java/decompiler/code/JumpInstruction.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.code;
 
 public class JumpInstruction extends Instruction {

File: src/org/jetbrains/java/decompiler/code/SwitchInstruction.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.code;
 
 public class SwitchInstruction extends Instruction {

File: src/org/jetbrains/java/decompiler/code/cfg/BasicBlock.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.code.cfg;
 
 import org.jetbrains.java.decompiler.code.Instruction;

File: src/org/jetbrains/java/decompiler/main/collectors/BytecodeMappingTracer.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.main.collectors;
 
 import org.jetbrains.java.decompiler.struct.attr.StructLineNumberTableAttribute;

File: src/org/jetbrains/java/decompiler/modules/decompiler/ConcatenationHelper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler;
 
 import org.jetbrains.java.decompiler.ClassNameConstants;

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
Patch:
@@ -346,7 +346,7 @@ else if (cn instanceof LinkConstant) {
           if (offsets != null) { //TODO: Figure out why this nulls in some cases
             offsets.set(offset, offset + instr.length);
           }
-          VarExprent left = new VarExprent(varIndex, varTypes[instr.opcode - CodeConstants.opc_istore], varProcessor, offsets);
+          VarExprent left = new VarExprent(varIndex, varTypes[instr.opcode - CodeConstants.opc_istore], varProcessor, offsets, true);
           exprList.add(new AssignmentExprent(left, value, offsets));
           break;
         }

File: src/org/jetbrains/java/decompiler/modules/decompiler/MergeHelper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler;
 
 import org.jetbrains.java.decompiler.code.cfg.BasicBlock;

File: src/org/jetbrains/java/decompiler/modules/decompiler/SimplifyExprentsHelper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;

File: src/org/jetbrains/java/decompiler/modules/decompiler/StackVarsProcessor.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
@@ -18,6 +18,8 @@
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionsGraph;
 import org.jetbrains.java.decompiler.struct.StructClass;
 import org.jetbrains.java.decompiler.struct.StructMethod;
+import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
+import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTableAttribute;
 import org.jetbrains.java.decompiler.util.FastSparseSetFactory.FastSparseSet;
 import org.jetbrains.java.decompiler.util.SFormsFastMapDirect;
 
@@ -365,7 +367,6 @@ else if (right.type == Exprent.EXPRENT_VAR) {
       }
     }
 
-    /* This workaround isn't needed with Forge's cleanups.
     //workaround to preserve variable names
     AssignmentExprent assignmentExprent = (AssignmentExprent)exprent;
     if (assignmentExprent.getRight() instanceof VarExprent && assignmentExprent.getLeft() instanceof VarExprent leftExp) {
@@ -379,7 +380,6 @@ else if (right.type == Exprent.EXPRENT_VAR) {
         }
       }
     }
-    */
 
     if (isSelfReference && vernotreplaced) {
       return new int[]{-1, changed};

File: src/org/jetbrains/java/decompiler/modules/decompiler/deobfuscator/ExceptionDeobfuscator.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.deobfuscator;
 
 import org.jetbrains.annotations.NotNull;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/AnnotationExprent.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
 import org.jetbrains.java.decompiler.main.DecompilerContext;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/ArrayExprent.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssertExprent.java
Patch:
@@ -1,6 +1,4 @@
-/*
- * Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
- */
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/FunctionExprent.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/IfExprent.java
Patch:
@@ -1,6 +1,4 @@
-/*
- * Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
- */
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
 import org.jetbrains.annotations.NotNull;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/MonitorExprent.java
Patch:
@@ -1,6 +1,4 @@
-/*
- * Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
- */
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/SwitchExprent.java
Patch:
@@ -1,6 +1,4 @@
-/*
- * Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
- */
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/BasicBlockStatement.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.stats;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/DummyExitStatement.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.stats;
 
 import java.util.BitSet;

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/IfStatement.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.stats;
 
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/RootStatement.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.stats;
 
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/Statement.java
Patch:
@@ -830,8 +830,6 @@ public void getOffset(BitSet values) {
           ((Statement)obj).getOffset(values);
         } else if (obj instanceof Exprent) {
           ((Exprent)obj).getBytecodeRange(values);
-        } else {
-          System.out.println("WTF?" + obj.getClass());
         }
       }
     }

File: src/org/jetbrains/java/decompiler/struct/StructMethod.java
Patch:
@@ -93,7 +93,6 @@ public void releaseResources() {
     }
   }
 
-  @SuppressWarnings("AssignmentToForLoopParameter")
   private InstructionSequence parseBytecode(DataInputFullStream in, int length, ConstantPool pool) throws IOException {
     VBStyleCollection<Instruction, Integer> instructions = new VBStyleCollection<>();
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/Statement.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler.stats;
 
 import org.jetbrains.annotations.NotNull;

File: test/org/jetbrains/java/decompiler/DecompilerTestFixture.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler;
 
 import org.jetbrains.annotations.NotNull;

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler;
 
 import org.jetbrains.java.decompiler.main.DecompilerContext;

File: test/org/jetbrains/java/decompiler/SingleClassesTestBase.java
Patch:
@@ -17,7 +17,7 @@
 import static org.jetbrains.java.decompiler.DecompilerTestFixture.assertFilesEqual;
 import static org.junit.Assert.assertTrue;
 
-public class SingleClassesTestBase {
+public abstract class SingleClassesTestBase {
   protected DecompilerTestFixture fixture;
 
   protected Map<String, String> getDecompilerOptions() {

File: src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.main.extern;
 
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
@@ -87,8 +87,6 @@ static Map<String, Object> getDefaults() {
     defaults.put(CONVERT_RECORD_PATTERN, "0");
     defaults.put(CONVERT_PATTERN_SWITCH, "0");
 
-    defaults.put(STANDARDIZE_FLOATING_POINT_NUMBERS, "1");
-
     defaults.put(LOG_LEVEL, IFernflowerLogger.Severity.INFO.name());
     defaults.put(MAX_PROCESSING_METHOD, "0");
     defaults.put(RENAME_ENTITIES, "0");

File: src/org/jetbrains/java/decompiler/main/extern/IResultSaver.java
Patch:
@@ -1,10 +1,9 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.main.extern;
 
 import java.util.jar.Manifest;
 
 public interface IResultSaver {
-  long STABLE_ZIP_TIMESTAMP = 0x386D4380; // 01/01/2000 00:00:00 java 8 breaks when using 0.
 
   void saveFolder(String path);
 

File: src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.main.rels;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;

File: src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.main.rels;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;

File: src/org/jetbrains/java/decompiler/modules/decompiler/DomHelper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler;
 
 import org.jetbrains.java.decompiler.code.cfg.BasicBlock;

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;

File: src/org/jetbrains/java/decompiler/modules/decompiler/LabelHelper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler;
 
 import org.jetbrains.java.decompiler.modules.decompiler.StatEdge.EdgeDirection;

File: src/org/jetbrains/java/decompiler/modules/decompiler/decompose/DominatorTreeExceptionFilter.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.decompose;
 
 import org.jetbrains.java.decompiler.modules.decompiler.StatEdge.EdgeDirection;

File: src/org/jetbrains/java/decompiler/modules/decompiler/decompose/FastExtendedPostdominanceHelper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.decompose;
 
 import org.jetbrains.java.decompiler.modules.decompiler.StatEdge;

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAConstructorSparseEx.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.sforms;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAUConstructorSparseEx.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.sforms;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/GeneralStatement.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.stats;
 
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
+// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.vars;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
@@ -246,7 +246,8 @@ private void setNewVarIndices(VarTypeProcessor typeProcessor, DirectGraph graph,
 
     // map var-version pairs on new var indexes
     List<VarVersionPair> vvps = new ArrayList<>(mapExprentMinTypes.keySet());
-    Collections.sort(vvps, (o1, o2) -> o1.var != o2.var ?  o1.var - o2.var : o1.version - o2.version);
+    Collections.sort(vvps,
+                     Comparator.<VarVersionPair>comparingInt(pair -> pair.var).thenComparing(pair -> pair.version));
 
     for (VarVersionPair pair : vvps) {
 

File: testData/obfuscated/a2.java
Patch:
@@ -37,8 +37,8 @@ public InputSource resolveEntity(String var1, String var2) throws SAXException,
       int var1 = 0;
       char[] var10001 = var10000;
       int var2 = var10002;
-      int var10003;
       char[] var4;
+      int var10003;
       if (var10002 <= 1) {
          var4 = var10000;
          var10003 = var1;

File: testData/obfuscated/a4.java
Patch:
@@ -33,12 +33,12 @@ public void a() throws Exception {
    }
 
    static {
-      String[] var10000;
       int var1;
       int var2;
+      char[] var4;
+      String[] var10000;
       char[] var10003;
       char[] var10004;
-      char[] var4;
       int var10005;
       int var10006;
       char var10007;

File: testData/obfuscated/a7.java
Patch:
@@ -12,12 +12,12 @@ public static void main(String[] var0) throws Exception {
    }
 
    static {
-      String[] var10000;
       int var1;
       int var2;
+      char[] var4;
+      String[] var10000;
       char[] var10003;
       char[] var10004;
-      char[] var4;
       int var10005;
       int var10006;
       char var10007;

File: testData/obfuscated/a8.java
Patch:
@@ -6,12 +6,12 @@ public void a(a0 param1) {
    }
 
    static {
-      String[] var10000;
       int var1;
       int var2;
+      char[] var4;
+      String[] var10000;
       char[] var10003;
       char[] var10004;
-      char[] var4;
       int var10005;
       int var10006;
       char var10007;

File: testData/obfuscated/an.java
Patch:
@@ -114,12 +114,12 @@ static List e(an var0) {
    }
 
    static {
-      String[] var10000;
       int var1;
       int var2;
+      char[] var4;
+      String[] var10000;
       char[] var10003;
       char[] var10004;
-      char[] var4;
       int var10005;
       int var10006;
       char var10007;

File: testData/obfuscated/ap.java
Patch:
@@ -35,8 +35,8 @@ public String toString() {
       int var1 = 0;
       char[] var10001 = var10000;
       int var2 = var10002;
-      int var10003;
       char[] var4;
+      int var10003;
       if (var10002 <= 1) {
          var4 = var10000;
          var10003 = var1;

File: testData/obfuscated/at.java
Patch:
@@ -25,8 +25,8 @@ public Double e() {
       int var1 = 0;
       char[] var10001 = var10000;
       int var2 = var10002;
-      int var10003;
       char[] var4;
+      int var10003;
       if (var10002 <= 1) {
          var4 = var10000;
          var10003 = var1;

File: testData/obfuscated/ax.java
Patch:
@@ -45,12 +45,12 @@ public String e() {
    }
 
    static {
-      String[] var10000;
       int var1;
       int var2;
+      char[] var4;
+      String[] var10000;
       char[] var10003;
       char[] var10004;
-      char[] var4;
       int var10005;
       int var10006;
       char var10007;

File: testData/obfuscated/az.java
Patch:
@@ -78,12 +78,12 @@ public ay d() {
    }
 
    static {
-      String[] var10000;
       int var1;
       int var2;
+      char[] var4;
+      String[] var10000;
       char[] var10003;
       char[] var10004;
-      char[] var4;
       int var10005;
       int var10006;
       char var10007;

File: testData/obfuscated/ba.java
Patch:
@@ -50,12 +50,12 @@ public void run() {
    }
 
    static {
-      String[] var10000;
       int var1;
       int var2;
+      char[] var4;
+      String[] var10000;
       char[] var10003;
       char[] var10004;
-      char[] var4;
       int var10005;
       int var10006;
       char var10007;

File: testData/obfuscated/n.java
Patch:
@@ -66,8 +66,8 @@ public int hashCode() {
          var10000 = this.a;
       }
 
-      Object var10001;
       int var3;
+      Object var10001;
       try {
          var3 = var10000.hashCode() / 2;
          if (this.b == null) {
@@ -152,8 +152,8 @@ public static <K, V> Map<K, V> c(Collection<n<K, V>> var0) {
       int var1 = 0;
       char[] var10001 = var10000;
       int var2 = var10002;
-      int var10003;
       char[] var4;
+      int var10003;
       if (var10002 <= 1) {
          var4 = var10000;
          var10003 = var1;

File: testData/obfuscated/o.java
Patch:
@@ -338,13 +338,13 @@ public boolean b(Class<?> param1) {
    }
 
    static {
-      char[] var10000;
       int var1;
+      int var2;
+      char[] var4;
+      char[] var10000;
       char[] var10001;
       int var10002;
-      int var2;
       int var10003;
-      char[] var4;
       char var10004;
       byte var10005;
       label51: {

File: testData/obfuscated/r.java
Patch:
@@ -43,12 +43,12 @@ static a9 b(p var0) {
    }
 
    static {
-      String[] var10000;
       int var1;
       int var2;
+      char[] var4;
+      String[] var10000;
       char[] var10003;
       char[] var10004;
-      char[] var4;
       int var10005;
       int var10006;
       char var10007;

File: src/org/jetbrains/java/decompiler/main/extern/IResultSaver.java
Patch:
@@ -4,6 +4,8 @@
 import java.util.jar.Manifest;
 
 public interface IResultSaver {
+  long STABLE_ZIP_TIMESTAMP = 0x386D4380; // 01/01/2000 00:00:00 java 8 breaks when using 0.
+
   void saveFolder(String path);
 
   void copyFile(String source, String path, String entryName);

File: src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
Patch:
@@ -218,6 +218,7 @@ private static boolean insertNestedClass(ClassNode root, ClassNode child) {
       if (setEnclosing.contains(node.classStruct.qualifiedName)) {
         node.nested.add(child);
         child.parent = node;
+        Collections.sort(node.nested);
 
         return true;
       }

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
Patch:
@@ -933,6 +933,7 @@ public static TextBuffer listToJava(List<? extends Exprent> lst, int indent, Byt
     }
 
     TextBuffer buf = new TextBuffer();
+    lst = Exprent.sortIndexed(lst);
 
     for (Exprent expr : lst) {
       if (buf.length() > 0 && expr.type == Exprent.EXPRENT_VAR && ((VarExprent)expr).isClassDef()) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/LabelHelper.java
Patch:
@@ -23,7 +23,7 @@ public static void cleanUpEdges(RootStatement root) {
 
     liftClosures(root);
 
-    lowContinueLabels(root, new HashSet<>());
+    lowContinueLabels(root, new LinkedHashSet<>());
 
     lowClosures(root);
   }
@@ -120,7 +120,7 @@ public static void lowContinueLabels(Statement stat, HashSet<StatEdge> edges) {
         lowContinueLabels(st, edges);
       }
       else {
-        lowContinueLabels(st, new HashSet<>());
+        lowContinueLabels(st, new LinkedHashSet<>());
       }
     }
   }

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAUConstructorSparseEx.java
Patch:
@@ -71,7 +71,7 @@ public void splitVariables(RootStatement root, StructMethod mt) {
     FlattenStatementsHelper flatthelper = new FlattenStatementsHelper();
     DirectGraph dgraph = flatthelper.buildDirectGraph(root);
 
-    HashSet<Integer> setInit = new HashSet<>();
+    List<Integer> setInit = new ArrayList<>();
     for (int i = 0; i < 64; i++) {
       setInit.add(i);
     }

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/GeneralStatement.java
Patch:
@@ -5,7 +5,8 @@
 import org.jetbrains.java.decompiler.util.TextBuffer;
 
 import java.util.Collection;
-import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.Set;
 
 
 public class GeneralStatement extends Statement {
@@ -25,7 +26,7 @@ public GeneralStatement(Statement head, Collection<? extends Statement> statemen
     first = head;
     stats.addWithKey(head, head.id);
 
-    HashSet<Statement> set = new HashSet<>(statements);
+    Set<Statement> set = new LinkedHashSet<>(statements);
     set.remove(head);
 
     for (Statement st : set) {

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -47,6 +47,7 @@ private static void invokeProcessors(ClassNode node) {
     StructClass cl = wrapper.getClassStruct();
 
     InitializerProcessor.extractInitializers(wrapper);
+    InitializerProcessor.hideInitalizers(wrapper);
 
     if (node.type == ClassNode.CLASS_ROOT &&
         !cl.isVersion5() &&

File: src/org/jetbrains/java/decompiler/modules/decompiler/SwitchHelper.java
Patch:
@@ -424,7 +424,7 @@ private static class JavacStringRecognizer extends StringSwitchRecognizer {
       @Override
       public SwitchOnStringCandidate recognize(@NotNull SwitchStatement firstSwitch,
                                                @NotNull InvocationExprent switchSelector) {
-        if (switchSelector.getInstance().type != Exprent.EXPRENT_VAR) return null;
+        if (switchSelector.getInstance() == null || switchSelector.getInstance().type != Exprent.EXPRENT_VAR) return null;
         if (!switchSelector.isInstanceCall(ClassNameConstants.JAVA_LANG_STRING, "hashCode", 0)) return null;
 
         Set<Object> realCaseValueHashCodes = findRealCaseValuesHashCodes(firstSwitch);

File: testData/bulk/pkg/res/Loader.java
Patch:
@@ -18,7 +18,8 @@ public String getResource() {
             stream.close();
             return new String(bytes, "UTF-8");
          } catch (Exception var5) {
-            throw new RuntimeException("Resource load failed", var5);
+            Exception e = var5;
+            throw new RuntimeException("Resource load failed", e);
          }
       }
    }

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/SwitchExprent.java
Patch:
@@ -87,7 +87,7 @@ public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
       List<Exprent> parameters = invocationExprent.getParameters();
       if (parameters.size() == 2) {
         Exprent exprent = parameters.get(1);
-        buf.append("//").append(exprent.toJava(indent, tracer)).append("->").append("value").appendLineSeparator();
+        buf.append("//$FF: ").append(exprent.toJava(indent, tracer)).append("->").append("value").appendLineSeparator();
         tracer.incrementCurrentSourceLine();
         List<PooledConstant> arguments = invocationExprent.getBootstrapArguments();
         for (int i = 0; i < arguments.size(); i++) {

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -1,6 +1,7 @@
 // Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.main;
 
+import org.jetbrains.annotations.NotNull;
 import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
@@ -1188,7 +1189,7 @@ private static void appendAnnotations(TextBuffer buffer, int indent, StructMembe
     }
   }
 
-  private static void appendParameterAnnotations(TextBuffer buffer, StructMethod mt, Type type, int param) {
+  private static void appendParameterAnnotations(TextBuffer buffer, StructMethod mt, @NotNull Type type, int param) {
     for (StructGeneralAttribute.Key<?> key : StructGeneralAttribute.PARAMETER_ANNOTATION_ATTRIBUTES) {
       StructAnnotationParameterAttribute attribute = (StructAnnotationParameterAttribute)mt.getAttribute(key);
       if (attribute != null) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/typeann/TypeAnnotation.java
Patch:
@@ -103,7 +103,7 @@ public static List<TypeAnnotation> listFrom(StructMember md) {
       .collect(Collectors.toList());
   }
 
-  public boolean isWrittenBeforeType(Type type) {
+  public boolean isWrittenBeforeType(@NotNull Type type) {
     StructTypePathEntry pathEntry = getPaths().stream().findFirst().orElse(null);
     if (pathEntry == null && type.getArrayDim() == 0) {
       return type.isAnnotatable();

File: src/org/jetbrains/java/decompiler/main/decompiler/ConsoleDecompiler.java
Patch:
@@ -102,7 +102,7 @@ private static void addPath(List<? super File> list, String path) {
   private final Map<String, ZipOutputStream> mapArchiveStreams = new HashMap<>();
   private final Map<String, Set<String>> mapArchiveEntries = new HashMap<>();
 
-  protected ConsoleDecompiler(File destination, Map<String, Object> options, IFernflowerLogger logger) {
+  public ConsoleDecompiler(File destination, Map<String, Object> options, IFernflowerLogger logger) {
     root = destination;
     engine = new Fernflower(this, this, options, logger);
   }

File: src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
Patch:
@@ -474,7 +474,7 @@ public ClassNode(String content_class_name,
 
       anonymousClassType = new VarType(lambda_class_name, true);
 
-      boolean is_method_reference = (content_class_name != classStruct.qualifiedName);
+      boolean is_method_reference = !Objects.equals(content_class_name, classStruct.qualifiedName);
       if (!is_method_reference) { // content method in the same class, check synthetic flag
         StructMethod mt = classStruct.getMethod(content_method_name, content_method_descriptor);
         is_method_reference = !mt.isSynthetic(); // if not synthetic -> method reference

File: src/org/jetbrains/java/decompiler/struct/StructContext.java
Patch:
@@ -9,7 +9,6 @@
 
 import java.io.File;
 import java.io.IOException;
-import java.nio.file.Path;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Map;
@@ -138,8 +137,8 @@ private void addArchive(String path, File file, int type, boolean isOwn) throws
         }
 
         String name = entry.getName();
-        Path testPath = Path.of(file.getAbsolutePath(), name);
-        if (!testPath.normalize().startsWith(file.toPath().normalize())) { // check for zip slip exploit
+        File test = new File(file.getAbsolutePath(), name);
+        if (!test.getCanonicalPath().startsWith(file.getCanonicalPath() + File.separator)) { // check for zip slip exploit
           throw new RuntimeException("Zip entry '" + entry.getName() + "' tries to escape target directory");
         }
 

File: test/org/jetbrains/java/decompiler/BulkDecompilationTest.java
Patch:
@@ -76,6 +76,7 @@ private static void unpack(File archive, File targetDir) {
         ZipEntry entry = entries.nextElement();
         if (!entry.isDirectory()) {
           File file = new File(targetDir, entry.getName());
+          assertTrue(file.toPath().normalize().startsWith(targetDir.toPath().normalize())); // check for zip-slip vulnerability
           assertTrue(file.getParentFile().mkdirs() || file.getParentFile().isDirectory());
           try (InputStream in = zip.getInputStream(entry); OutputStream out = new FileOutputStream(file)) {
             InterpreterUtil.copyStream(in, out);

File: src/org/jetbrains/java/decompiler/code/cfg/ControlFlowGraph.java
Patch:
@@ -64,7 +64,7 @@ public String toString() {
 
     for (BasicBlock block : blocks) {
       buf.append("----- Block ").append(block.id).append(" -----").append(new_line_separator);
-      buf.append(block.toString());
+      buf.append(block);
       buf.append("----- Edges -----").append(new_line_separator);
 
       List<BasicBlock> suc = block.getSuccessors();

File: src/org/jetbrains/java/decompiler/modules/renamer/ConverterHelper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.renamer;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
@@ -40,7 +40,7 @@ public boolean toBeRenamed(Type elementType, String className, String element, S
   /**
    * Return {@code true} if, and only if identifier passed is compliant to JLS9 section 3.8 AND DOES NOT CONTAINS so-called "ignorable" characters.
    * Ignorable characters are removed by javac silently during compilation and thus may appear only in specially crafted obfuscated classes.
-   * For more information about "ignorable" characters see <a href="https://bugs.openjdk.java.net/browse/JDK-7144981">JDK-7144981</a>.
+   * For more information about "ignorable" characters see <a href="https://bugs.openjdk.org/browse/JDK-7144981">JDK-7144981</a>.
    *
    * @param identifier Identifier to be checked
    * @return {@code true} in case {@code identifier} passed can be used as an identifier; {@code false} otherwise.

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -120,6 +120,7 @@ public void tearDown() {
           "pkg/SharedName2", "pkg/SharedName3", "pkg/SharedName4", "pkg/NonSharedName",
           "pkg/TestClashNameParent", "ext/TestClashNameParent","pkg/TestClashNameIface", "ext/TestClashNameIface"); }
   @Test public void testSwitchOnEnum() { doTest("pkg/TestSwitchOnEnum");}
+  @Test public void testSwitchOnEnumEclipse() { doTest("pkg/TestSwitchOnEnumEclipse"); }
   @Test public void testVarArgCalls() { doTest("pkg/TestVarArgCalls"); }
   @Test public void testLambdaParams() { doTest("pkg/TestLambdaParams"); }
   @Test public void testInterfaceMethods() { doTest("pkg/TestInterfaceMethods"); }
@@ -215,8 +216,6 @@ public void tearDown() {
   @Test public void testNestedType() { doTest("pkg/NestedType"); }
   @Test public void testInheritanceChainCycle() { doTest("pkg/TestInheritanceChainCycle"); }
   @Test public void testDynamicConstantPoolEntry() { doTest("java11/TestDynamicConstantPoolEntry"); }
-
-
   @Test public void testInstanceofWithPattern() {
     doTest("patterns/TestInstanceofWithPattern");
   }

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -344,7 +344,7 @@ private void writeClassDefinition(ClassNode node, TextBuffer buffer, int indent)
 
     appendModifiers(buffer, flags, CLASS_ALLOWED, isInterface, CLASS_EXCLUDED);
 
-    if (permittedSubclassQualifiedNames != null) {
+    if (permittedSubclassQualifiedNames != null && !isEnum) {
       buffer.append("sealed ");
     }
     else if (node.isNonSealed()) {

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -177,6 +177,7 @@ public void tearDown() {
   }
   @Test public void testRootWithModule() { doTest("sealed/foo/RootWithModule", "sealed/bar/BarClassExtends");}
   @Test public void testRootWithInterfaceInnerAndOuter() { doTest("sealed/RootWithInterfaceInnerAndOuter", "sealed/ClassNonSealed");}
+  @Test public void testEnumWithOverride() { doTest("sealed/EnumWithOverride");}
   @Test public void testArrayTypeAnnotations() { doTest("typeAnnotations/ArrayTypeAnnotations",
     "typeAnnotations/A", "typeAnnotations/B", "typeAnnotations/C", "typeAnnotations/D");
   }

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -758,7 +758,7 @@ else if (CodeConstants.CLINIT_NAME.equals(name)) {
 
             Type paramType;
             if (descriptor != null) paramType = descriptor.parameterTypes.get(paramCount); else paramType = md.params[i];
-            appendParameterAnnotations(buffer, mt, paramType.getArrayDim(), paramCount);
+            appendParameterAnnotations(buffer, mt, paramType, paramCount);
 
             VarVersionPair pair = new VarVersionPair(index, 0);
             if (methodWrapper.varproc.isParameterFinal(pair) ||
@@ -1195,14 +1195,14 @@ private static void appendAnnotations(TextBuffer buffer, int indent, StructMembe
     }
   }
 
-  private static void appendParameterAnnotations(TextBuffer buffer, StructMethod mt, int arrayDim, int param) {
+  private static void appendParameterAnnotations(TextBuffer buffer, StructMethod mt, Type type, int param) {
     for (StructGeneralAttribute.Key<?> key : StructGeneralAttribute.PARAMETER_ANNOTATION_ATTRIBUTES) {
       StructAnnotationParameterAttribute attribute = (StructAnnotationParameterAttribute)mt.getAttribute(key);
       if (attribute != null) {
         List<List<AnnotationExprent>> annotations = attribute.getParamAnnotations();
         if (param < annotations.size()) {
           for (AnnotationExprent annotation : annotations.get(param)) {
-            if (mt.paramAnnCollidesWithTypeAnnotation(annotation, arrayDim, param)) continue;
+            if (mt.paramAnnCollidesWithTypeAnnotation(annotation, type, param)) continue;
             String text = annotation.toJava(-1, BytecodeMappingTracer.DUMMY).toString();
             buffer.append(text).append(' ');
           }

File: src/org/jetbrains/java/decompiler/struct/StructClass.java
Patch:
@@ -7,6 +7,7 @@
 import org.jetbrains.java.decompiler.struct.attr.StructRecordAttribute;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
 import org.jetbrains.java.decompiler.struct.consts.PrimitiveConstant;
+import org.jetbrains.java.decompiler.struct.gen.Type;
 import org.jetbrains.java.decompiler.struct.lazy.LazyLoader;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
@@ -238,7 +239,7 @@ public String toString() {
   }
 
   @Override
-  protected int getArrayDimensions() {
-    return 0;
+  protected Type getType() {
+    return null;
   }
 }

File: src/org/jetbrains/java/decompiler/struct/StructField.java
Patch:
@@ -3,6 +3,7 @@
 
 import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
+import org.jetbrains.java.decompiler.struct.gen.Type;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 
@@ -54,7 +55,7 @@ public String toString() {
   }
 
   @Override
-  protected int getArrayDimensions() {
-    return new VarType(descriptor).getArrayDim();
+  protected Type getType() {
+    return new VarType(descriptor);
   }
 }

File: src/org/jetbrains/java/decompiler/struct/StructMethod.java
Patch:
@@ -7,6 +7,7 @@
 import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTableAttribute;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
+import org.jetbrains.java.decompiler.struct.gen.Type;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 import org.jetbrains.java.decompiler.util.VBStyleCollection;
 
@@ -369,8 +370,8 @@ public StructLocalVariableTableAttribute getLocalVariableAttr() {
   }
 
   @Override
-  protected int getArrayDimensions() {
-    return MethodDescriptor.parseDescriptor(getDescriptor()).ret.getArrayDim();
+  protected Type getType() {
+    return MethodDescriptor.parseDescriptor(getDescriptor()).ret;
   }
 
   @Override

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -188,7 +188,7 @@ public void tearDown() {
   }
   @Test public void testNestedTypeAnnotations() {doTest("typeAnnotations/NestedTypeAnnotations",
     "typeAnnotations/A", "typeAnnotations/B", "typeAnnotations/C", "typeAnnotations/D", "typeAnnotations/E",
-    "typeAnnotations/F", "typeAnnotations/Z");
+    "typeAnnotations/F", "typeAnnotations/Z", "typeAnnotations/P", "typeAnnotations/S", "typeAnnotations/T");
   }
   @Test public void testArrayNestedTypeAnnotations() {doTest("typeAnnotations/ArrayNestedTypeAnnotations",
     "typeAnnotations/A", "typeAnnotations/B", "typeAnnotations/C", "typeAnnotations/D", "typeAnnotations/Z");

File: src/org/jetbrains/java/decompiler/code/cfg/ControlFlowGraph.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.code.cfg;
 
 import org.jetbrains.java.decompiler.code.*;
@@ -693,7 +693,7 @@ private static void removeJsrInstructions(ConstantPool pool, BasicBlock block, D
           break;
         case CodeConstants.opc_astore:
         case CodeConstants.opc_pop:
-          if (var.type == CodeConstants.TYPE_ADDRESS) {
+          if (var.getType() == CodeConstants.TYPE_ADDRESS) {
             seq.removeInstruction(i);
             i--;
           }

File: src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.main.rels;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
@@ -105,7 +105,7 @@ public void init() {
           }
           for (int i = 0; i < md.params.length; i++) {
             varProc.setVarName(new VarVersionPair(varIndex, 0), vc.getFreeName(varIndex));
-            varIndex += md.params[i].stackSize;
+            varIndex += md.params[i].getStackSize();
           }
         }
       }
@@ -151,7 +151,7 @@ private static void applyParameterNames(StructMethod mt, MethodDescriptor md, Va
           if ((entry.myAccessFlags & CodeConstants.ACC_FINAL) != 0) {
             varProc.setParameterFinal(new VarVersionPair(index, 0));
           }
-          index += md.params[i].stackSize;
+          index += md.params[i].getStackSize();
         }
       }
     }

File: src/org/jetbrains/java/decompiler/main/rels/NestedMemberAccess.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.main.rels;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
@@ -149,7 +149,7 @@ private void computeMethodType(ClassNode node, MethodWrapper method) {
                     equalpars = false;
                     break;
                   }
-                  index += mtdesc.params[i + (isStatic ? 0 : 1)].stackSize;
+                  index += mtdesc.params[i + (isStatic ? 0 : 1)].getStackSize();
                 }
 
                 if (equalpars) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/ClasspathHelper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler;
 
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
@@ -64,8 +64,8 @@ private static String buildMethodSignature(String name, MethodDescriptor md) {
   }
 
   private static void appendType(StringBuilder sb, VarType type) {
-    sb.append(type.value.replace('/', '.'));
-    for (int i = 0; i < type.arrayDim; i++) {
+    sb.append(type.getValue().replace('/', '.'));
+    for (int i = 0; i < type.getArrayDim(); i++) {
       sb.append("[]");
     }
   }

File: src/org/jetbrains/java/decompiler/modules/decompiler/ConcatenationHelper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler;
 
 import org.jetbrains.java.decompiler.ClassNameConstants;
@@ -222,7 +222,7 @@ private static boolean isAppendConcat(InvocationExprent expr, VarType cltype) {
       MethodDescriptor md = expr.getDescriptor();
       if (md.ret.equals(cltype) && md.params.length == 1) {
         VarType param = md.params[0];
-        switch (param.type) {
+        switch (param.getType()) {
           case CodeConstants.TYPE_OBJECT:
             if (!param.equals(VarType.VARTYPE_STRING) &&
                 !param.equals(VarType.VARTYPE_OBJECT)) {
@@ -260,7 +260,7 @@ private static Exprent removeStringValueOf(Exprent exprent) {
         MethodDescriptor md = iex.getDescriptor();
         if (md.params.length == 1) {
           VarType param = md.params[0];
-          switch (param.type) {
+          switch (param.getType()) {
             case CodeConstants.TYPE_OBJECT:
               if (!param.equals(VarType.VARTYPE_OBJECT)) {
                 break;

File: src/org/jetbrains/java/decompiler/modules/decompiler/StackVarsProcessor.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
@@ -282,8 +282,8 @@ private int[] iterateExprent(List<Exprent> lstExprents,
         if (right.type == Exprent.EXPRENT_NEW) {
           // new Object(); permitted
           NewExprent nexpr = (NewExprent)right;
-          if (nexpr.isAnonymous() || nexpr.getNewType().arrayDim > 0
-              || nexpr.getNewType().type != CodeConstants.TYPE_OBJECT) {
+          if (nexpr.isAnonymous() || nexpr.getNewType().getArrayDim() > 0
+              || nexpr.getNewType().getType() != CodeConstants.TYPE_OBJECT) {
             return new int[]{-1, changed};
           }
         }

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/ArrayExprent.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
@@ -69,7 +69,7 @@ public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
     }
 
     VarType arrType = array.getExprType();
-    if (arrType.arrayDim == 0) {
+    if (arrType.getArrayDim() == 0) {
       VarType objArr = VarType.VARTYPE_OBJECT.resizeArrayDim(1); // type family does not change
       res.enclose("((" + ExprProcessor.getCastTypeName(objArr, Collections.emptyList()) + ")", ")");
     }

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
Patch:
@@ -86,7 +86,7 @@ public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
     tracer.addMapping(bytecode);
 
     if (classDef) {
-      ClassNode child = DecompilerContext.getClassProcessor().getMapRootClasses().get(varType.value);
+      ClassNode child = DecompilerContext.getClassProcessor().getMapRootClasses().get(varType.getValue());
       new ClassWriter().classToJava(child, buffer, indent, tracer);
       tracer.incrementCurrentSourceLine(buffer.countLines());
     }
@@ -195,7 +195,7 @@ public VarType getVarType() {
       vt = processor.getVarType(getVarVersionPair());
     }
 
-    if (vt == null || (varType != null && varType.type != CodeConstants.TYPE_UNKNOWN)) {
+    if (vt == null || (varType != null && varType.getType() != CodeConstants.TYPE_UNKNOWN)) {
       vt = varType;
     }
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAConstructorSparseEx.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler.sforms;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
@@ -490,11 +490,11 @@ private SFormsFastMapDirect createFirstMap(StructMethod mt) {
           varindex++;
         }
         else {
-          varindex += md.params[i - 1].stackSize;
+          varindex += md.params[i - 1].getStackSize();
         }
       }
       else {
-        varindex += md.params[i].stackSize;
+        varindex += md.params[i].getStackSize();
       }
     }
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler.vars;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
@@ -63,11 +63,11 @@ public VarDefinitionHelper(Statement root, StructMethod mt, VarProcessor varproc
           varindex++;
         }
         else {
-          varindex += md.params[i - 1].stackSize;
+          varindex += md.params[i - 1].getStackSize();
         }
       }
       else {
-        varindex += md.params[i].stackSize;
+        varindex += md.params[i].getStackSize();
       }
     }
 

File: src/org/jetbrains/java/decompiler/struct/StructField.java
Patch:
@@ -55,6 +55,6 @@ public String toString() {
 
   @Override
   protected int getArrayDimensions() {
-    return new VarType(descriptor).arrayDim;
+    return new VarType(descriptor).getArrayDim();
   }
 }

File: src/org/jetbrains/java/decompiler/struct/StructMethod.java
Patch:
@@ -370,7 +370,7 @@ public StructLocalVariableTableAttribute getLocalVariableAttr() {
 
   @Override
   protected int getArrayDimensions() {
-    return MethodDescriptor.parseDescriptor(getDescriptor()).ret.arrayDim;
+    return MethodDescriptor.parseDescriptor(getDescriptor()).ret.getArrayDim();
   }
 
   @Override

File: src/org/jetbrains/java/decompiler/struct/gen/DataPoint.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.struct.gen;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
@@ -58,7 +58,7 @@ public static DataPoint getInitialDataPoint(StructMethod mt) {
       VarType var = md.params[i];
 
       point.setVariable(k++, var);
-      if (var.stackSize == 2) {
+      if (var.getStackSize() == 2) {
         point.setVariable(k++, new VarType(CodeConstants.TYPE_GROUP2EMPTY));
       }
     }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -208,7 +208,8 @@ public void tearDown() {
     "typeAnnotations/A", "typeAnnotations/B", "typeAnnotations/F");
   }
   @Test public void testMemberDeclarationTypeAnnotations() {doTest("typeAnnotations/MemberDeclarationTypeAnnotations",
-    "typeAnnotations/A", "typeAnnotations/B", "typeAnnotations/C", "typeAnnotations/D", "typeAnnotations/E",  "typeAnnotations/K");
+    "typeAnnotations/A", "typeAnnotations/B", "typeAnnotations/C", "typeAnnotations/D", "typeAnnotations/E",
+                                                                   "typeAnnotations/K", "typeAnnotations/L");
   }
   @Test public void testNestedType() { doTest("pkg/NestedType"); }
   @Test public void testInheritanceChainCycle() { doTest("pkg/TestInheritanceChainCycle"); }

File: testData/src/typeAnnotations/MemberDeclarationTypeAnnotations.java
Patch:
@@ -21,4 +21,7 @@ public class MemberDeclarationTypeAnnotations<@A P extends @B Number & @F Serial
     public <T> @C Number bar(@D T @E [] a) throws @A IOException, @B IllegalStateException {
         return 0;
     }
+
+    public void fooBar(@L @A String param1, @K @L @B String param2) {
+    }
 }
\ No newline at end of file

File: src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java
Patch:
@@ -214,7 +214,7 @@ private static void appendClassName(GenericType type, StringBuilder sb, List<Typ
         ExprProcessor.writeNestedClass(sb, nestedClasses, typePathWriteHelper);
         appendTypeArguments(tp, sb, typePathWriteHelper);
         sb.append('.');
-        ExprProcessor.checkNestedTypeAnnotation(sb, typePathWriteHelper);
+        ExprProcessor.writeNestedTypeAnnotations(sb, typePathWriteHelper);
       }
       sb.append(type.value);
     }

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
Patch:
@@ -662,7 +662,7 @@ public static String getTypeName(VarType type, boolean getShort, List<TypeAnnota
         typeAnnotationWriteHelper.writeTo(sb);
         return true;
       }
-      if (path != null && path.getTypePathEntryKind() == StructTypePathEntry.Kind.ARRAY.getOpcode() &&
+      if (path != null && path.getTypePathEntryKind() == StructTypePathEntry.Kind.ARRAY.getId() &&
         typeAnnotationWriteHelper.getPaths().size() == type.arrayDim
       ) {
         typeAnnotationWriteHelper.writeTo(sb);
@@ -745,7 +745,7 @@ public static boolean checkNestedTypeAnnotation(StringBuilder sb, List<TypeAnnot
     var wroteAnnotation = new Object() { boolean value = false; };
     typePathWriteHelper.removeIf(typeAnnotationWriteHelper -> {
       StructTypePathEntry path = typeAnnotationWriteHelper.getPaths().peek();
-      if (path != null && path.getTypePathEntryKind() == StructTypePathEntry.Kind.NESTED.getOpcode()) {
+      if (path != null && path.getTypePathEntryKind() == StructTypePathEntry.Kind.NESTED.getId()) {
         typeAnnotationWriteHelper.getPaths().pop();
         if (typeAnnotationWriteHelper.getPaths().isEmpty()) {
           typeAnnotationWriteHelper.writeTo(sb);

File: src/org/jetbrains/java/decompiler/modules/decompiler/typeann/TypeAnnotation.java
Patch:
@@ -70,7 +70,7 @@ public boolean isForDeepestArrayComponent(int arrayDim) {
     StructTypePathEntry pathEntry = getPaths().stream().findFirst().orElse(null);
     if (pathEntry == null && arrayDim == 0) return true;
     if (pathEntry != null
-        && pathEntry.getTypePathEntryKind() == StructTypePathEntry.Kind.ARRAY.getOpcode()
+        && pathEntry.getTypePathEntryKind() == StructTypePathEntry.Kind.ARRAY.getId()
         && getPaths().size() == arrayDim
     ) return true;
     return false;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
@@ -147,7 +147,7 @@ private void appendDefinitionType(TextBuffer buffer) {
               if (signature != null) {
                 GenericFieldDescriptor descriptor = GenericMain.parseFieldSignature(signature);
                 if (descriptor != null) {
-                  buffer.append(GenericMain.getGenericCastTypeName(descriptor.type, java.util.Collections.emptyList()));
+                  buffer.append(GenericMain.getGenericCastTypeName(descriptor.type, Collections.emptyList()));
                   return;
                 }
               }

File: src/org/jetbrains/java/decompiler/modules/decompiler/typeann/TypeAnnotation.java
Patch:
@@ -49,7 +49,7 @@ public TypeAnnotation(
     this.annotation = annotation;
   }
 
-  @MagicConstant(flagsFromClass = TypeAnnotation.class)
+  @MagicConstant(valuesFromClass = TypeAnnotation.class)
   public int getTargetType() {
     return targetType;
   }

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -17,7 +17,7 @@
 import org.jetbrains.java.decompiler.modules.decompiler.typeann.TargetInfo;
 import org.jetbrains.java.decompiler.modules.decompiler.typeann.TypeAnnotation;
 import org.jetbrains.java.decompiler.modules.decompiler.typeann.TypeAnnotationWriteHelper;
-import org.jetbrains.java.decompiler.modules.decompiler.vars.VarTypeProcessor;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.VarProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
 import org.jetbrains.java.decompiler.modules.renamer.PoolInterceptor;
 import org.jetbrains.java.decompiler.struct.*;
@@ -756,7 +756,7 @@ else if (CodeConstants.CLINIT_NAME.equals(name)) {
 
             VarVersionPair pair = new VarVersionPair(index, 0);
             if (methodWrapper.varproc.isParameterFinal(pair) ||
-                methodWrapper.varproc.getVarFinal(pair) == VarTypeProcessor.VAR_EXPLICIT_FINAL) {
+                methodWrapper.varproc.getVarFinal(pair) == VarProcessor.VAR_EXPLICIT_FINAL) {
               buffer.append("final ");
             }
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
Patch:
@@ -736,7 +736,7 @@ public static List<ClassesProcessor.ClassNode> enclosingClassList() {
       enclosingClassList.add(0, enclosingClass);
     }
     return enclosingClassList.stream()
-      .filter(classNode -> classNode.type != ClassesProcessor.ClassNode.CLASS_ANONYMOUS ||
+      .filter(classNode -> classNode.type != ClassesProcessor.ClassNode.CLASS_ANONYMOUS &&
                            classNode.type != ClassesProcessor.ClassNode.CLASS_LAMBDA
       ).collect(Collectors.toList());
   }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -186,7 +186,7 @@ public void tearDown() {
   @Test public void testGenericArrayTypeAnnotations() {doTest("typeAnnotations/GenericArrayTypeAnnotations",
       "typeAnnotations/A", "typeAnnotations/B", "typeAnnotations/C", "typeAnnotations/D", "typeAnnotations/E", "typeAnnotations/F");
   }
-  @Test public void TypeAnnotations() {doTest("typeAnnotations/NestedTypeAnnotations",
+  @Test public void testNestedTypeAnnotations() {doTest("typeAnnotations/NestedTypeAnnotations",
     "typeAnnotations/A", "typeAnnotations/B", "typeAnnotations/C", "typeAnnotations/D", "typeAnnotations/E",
     "typeAnnotations/F", "typeAnnotations/Z");
   }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -186,7 +186,7 @@ public void tearDown() {
   @Test public void testGenericArrayTypeAnnotations() {doTest("typeAnnotations/GenericArrayTypeAnnotations",
       "typeAnnotations/A", "typeAnnotations/B", "typeAnnotations/C", "typeAnnotations/D", "typeAnnotations/E", "typeAnnotations/F");
   }
-  @Test public void testNestedTypeAnnotations() {doTest("typeAnnotations/NestedTypeAnnotations",
+  @Test public void TypeAnnotations() {doTest("typeAnnotations/NestedTypeAnnotations",
     "typeAnnotations/A", "typeAnnotations/B", "typeAnnotations/C", "typeAnnotations/D", "typeAnnotations/E",
     "typeAnnotations/F", "typeAnnotations/Z");
   }
@@ -210,6 +210,7 @@ public void tearDown() {
   @Test public void testMemberDeclarationTypeAnnotations() {doTest("typeAnnotations/MemberDeclarationTypeAnnotations",
     "typeAnnotations/A", "typeAnnotations/B", "typeAnnotations/C", "typeAnnotations/D", "typeAnnotations/E",  "typeAnnotations/K");
   }
+  @Test public void testNestedType() { doTest("pkg/NestedType"); }
   @Test public void testInheritanceChainCycle() { doTest("pkg/TestInheritanceChainCycle"); }
   @Test public void testDynamicConstantPoolEntry() { doTest("java11/TestDynamicConstantPoolEntry"); }
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/DecHelper.java
Patch:
@@ -5,6 +5,7 @@
 import org.jetbrains.java.decompiler.modules.decompiler.StatEdge.EdgeType;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement.StatementType;
 
 import java.util.ArrayList;
 import java.util.HashSet;
@@ -76,7 +77,7 @@ public static boolean isChoiceStatement(Statement head, List<? super Statement>
       setDest.remove(post);
 
       for (Statement stat : setDest) {
-        if (stat.getLastBasicType() != Statement.LASTBASICTYPE_GENERAL) {
+        if (stat.getLastBasicType() != StatementType.GENERAL) {
           if (post == null) {
             post = stat;
             repeat = true;

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/FlattenStatementsHelper.java
Patch:
@@ -121,7 +121,7 @@ class StatementStackEntry {
             }
 
             // 'if' statement: record positive branch
-            if (stat.getLastBasicType() == Statement.LASTBASICTYPE_IF) {
+            if (stat.getLastBasicType() == StatementType.IF) {
               mapPosIfBranch.put(sourcenode.id, lstSuccEdges.get(0).getDestination().id);
             }
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/BasicBlockStatement.java
Patch:
@@ -27,10 +27,10 @@ public BasicBlockStatement(BasicBlock block) {
     Instruction instr = block.getLastInstruction();
     if (instr != null) {
       if (instr.group == CodeConstants.GROUP_JUMP && instr.opcode != CodeConstants.opc_goto) {
-        lastBasicType = LASTBASICTYPE_IF;
+        lastBasicType = StatementType.IF;
       }
       else if (instr.group == CodeConstants.GROUP_SWITCH) {
-        lastBasicType = LASTBASICTYPE_SWITCH;
+        lastBasicType = StatementType.SWITCH;
       }
     }
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchAllStatement.java
Patch:
@@ -65,7 +65,7 @@ private CatchAllStatement(Statement head, Statement handler) {
   // *****************************************************************************
 
   public static Statement isHead(Statement head) {
-    if (head.getLastBasicType() != Statement.LASTBASICTYPE_GENERAL) {
+    if (head.getLastBasicType() != StatementType.GENERAL) {
       return null;
     }
 
@@ -77,7 +77,7 @@ public static Statement isHead(Statement head) {
     for (StatEdge edge : head.getSuccessorEdges(EdgeType.EXCEPTION)) {
       Statement exc = edge.getDestination();
 
-      if (edge.getExceptions() == null && exc.getLastBasicType() == LASTBASICTYPE_GENERAL && setHandlers.contains(exc)) {
+      if (edge.getExceptions() == null && exc.getLastBasicType() == StatementType.GENERAL && setHandlers.contains(exc)) {
         List<StatEdge> lstSuccs = exc.getSuccessorEdges(EdgeType.DIRECT_ALL);
         if (lstSuccs.isEmpty() || lstSuccs.get(0).getType() != EdgeType.REGULAR) {
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchStatement.java
Patch:
@@ -61,7 +61,7 @@ private CatchStatement(Statement head, Statement next, Set<Statement> setHandler
   // *****************************************************************************
 
   public static Statement isHead(Statement head) {
-    if (head.getLastBasicType() != LASTBASICTYPE_GENERAL) {
+    if (head.getLastBasicType() != StatementType.GENERAL) {
       return null;
     }
 
@@ -82,7 +82,7 @@ public static Statement isHead(Statement head) {
         boolean handlerok = true;
 
         if (edge.getExceptions() != null && setHandlers.contains(stat)) {
-          if (stat.getLastBasicType() != LASTBASICTYPE_GENERAL) {
+          if (stat.getLastBasicType() != StatementType.GENERAL) {
             handlerok = false;
           }
           else {

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/DoStatement.java
Patch:
@@ -37,7 +37,7 @@ private DoStatement(Statement head) {
   }
 
   public static @Nullable Statement isHead(Statement head) {
-    if (head.getLastBasicType() == LASTBASICTYPE_GENERAL && !head.isMonitorEnter()) {
+    if (head.getLastBasicType() == StatementType.GENERAL && !head.isMonitorEnter()) {
       // at most one outgoing edge
       StatEdge edge = null;
       List<StatEdge> successorEdges = head.getSuccessorEdges(EdgeType.DIRECT_ALL);

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/IfStatement.java
Patch:
@@ -159,7 +159,7 @@ else if (regedges == 1) {
 
   public static Statement isHead(Statement head) {
 
-    if (head.type == StatementType.BASIC_BLOCK && head.getLastBasicType() == LASTBASICTYPE_IF) {
+    if (head.type == StatementType.BASIC_BLOCK && head.getLastBasicType() == StatementType.IF) {
       int regsize = head.getSuccessorEdges(EdgeType.REGULAR).size();
 
       Statement p = null;

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/SequenceStatement.java
Patch:
@@ -57,7 +57,7 @@ private SequenceStatement(Statement head, Statement tail) {
 
   public static Statement isHead2Block(Statement head) {
 
-    if (head.getLastBasicType() != Statement.LASTBASICTYPE_GENERAL) {
+    if (head.getLastBasicType() != StatementType.GENERAL) {
       return null;
     }
 
@@ -74,7 +74,7 @@ public static Statement isHead2Block(Statement head) {
       if (stat != head && stat.getPredecessorEdges(EdgeType.REGULAR).size() == 1
           && !stat.isMonitorEnter()) {
 
-        if (stat.getLastBasicType() == Statement.LASTBASICTYPE_GENERAL) {
+        if (stat.getLastBasicType() == StatementType.GENERAL) {
           if (DecHelper.checkStatementExceptions(Arrays.asList(head, stat))) {
             return new SequenceStatement(head, stat);
           }

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/SwitchStatement.java
Patch:
@@ -53,7 +53,7 @@ private SwitchStatement(@NotNull Statement head, @Nullable Statement postStateme
 
   @Nullable
   public static Statement isHead(@NotNull Statement head) {
-    if (head.type == StatementType.BASIC_BLOCK && head.getLastBasicType() == Statement.LASTBASICTYPE_SWITCH) {
+    if (head.type == StatementType.BASIC_BLOCK && head.getLastBasicType() == StatementType.SWITCH) {
       List<Statement> statements = new ArrayList<>();
       if (DecHelper.isChoiceStatement(head, statements)) {
         Statement post = statements.remove(0);

File: src/org/jetbrains/java/decompiler/main/AssertProcessor.java
Patch:
@@ -13,6 +13,7 @@
 import org.jetbrains.java.decompiler.modules.decompiler.StatEdge.EdgeType;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.*;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.*;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement.StatementType;
 import org.jetbrains.java.decompiler.struct.StructField;
 import org.jetbrains.java.decompiler.struct.gen.FieldDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
@@ -128,7 +129,7 @@ private static boolean replaceAssertions(Statement statement, String classname,
       replaced = false;
 
       for (Statement st : statement.getStats()) {
-        if (st.type == Statement.TYPE_IF) {
+        if (st.type == StatementType.IF) {
           if (replaceAssertion(statement, (IfStatement)st, classname, key)) {
             replaced = true;
             break;

File: src/org/jetbrains/java/decompiler/modules/decompiler/SimplifyExprentsHelper.java
Patch:
@@ -11,6 +11,7 @@
 import org.jetbrains.java.decompiler.modules.decompiler.sforms.SSAConstructorSparseEx;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.IfStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement.StatementType;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
 import org.jetbrains.java.decompiler.struct.StructClass;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
@@ -636,7 +637,7 @@ private static Exprent isSimpleConstructorInvocation(Exprent exprent) {
   }
 
   private static boolean buildIff(Statement stat, SSAConstructorSparseEx ssa) {
-    if (stat.type == Statement.TYPE_IF && stat.getExprents() == null) {
+    if (stat.type == StatementType.IF && stat.getExprents() == null) {
       IfStatement statement = (IfStatement)stat;
       Exprent ifHeadExpr = statement.getHeadexprent();
       Set<Integer> ifHeadExprBytecode = (ifHeadExpr == null ? null : ifHeadExpr.bytecode);

File: src/org/jetbrains/java/decompiler/modules/decompiler/StackVarsProcessor.java
Patch:
@@ -9,6 +9,7 @@
 import org.jetbrains.java.decompiler.modules.decompiler.stats.DoStatement.LoopType;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.RootStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement.StatementType;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionEdge;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionNode;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
@@ -166,7 +167,7 @@ private boolean iterateStatements(RootStatement root, SSAUConstructorSparseEx ss
           (nd.type == DirectNodeType.INIT || nd.type == DirectNodeType.CONDITION || nd.type == DirectNodeType.INCREMENT)) {
         nd.exprents.add(null);
 
-        if (nd.statement.type == Statement.TYPE_DO) {
+        if (nd.statement.type == StatementType.DO) {
           DoStatement loop = (DoStatement)nd.statement;
 
           if (loop.getLoopType() == LoopType.FOR &&

File: src/org/jetbrains/java/decompiler/modules/decompiler/deobfuscator/IrreducibleCFGDeobfuscator.java
Patch:
@@ -6,6 +6,7 @@
 import org.jetbrains.java.decompiler.modules.decompiler.StatEdge.EdgeType;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.BasicBlockStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement.StatementType;
 
 import java.util.HashMap;
 import java.util.HashSet;
@@ -162,7 +163,7 @@ private static int getStatementSize(Statement statement) {
 
     int res;
 
-    if (statement.type == Statement.TYPE_BASIC_BLOCK) {
+    if (statement.type == StatementType.BASIC_BLOCK) {
       res = ((BasicBlockStatement)statement).getBlock().getSeq().length();
     }
     else {

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/BasicBlockStatement.java
Patch:
@@ -15,7 +15,7 @@ public class BasicBlockStatement extends Statement {
   private final BasicBlock block;
 
   public BasicBlockStatement(BasicBlock block) {
-    super(Statement.TYPE_BASIC_BLOCK);
+    super(StatementType.BASIC_BLOCK);
     id = block.id;
     this.block = block;
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchAllStatement.java
Patch:
@@ -33,7 +33,7 @@ public final class CatchAllStatement extends Statement {
   // *****************************************************************************
 
   private CatchAllStatement() {
-    super(Statement.TYPE_CATCH_ALL);
+    super(StatementType.CATCH_ALL);
   }
 
   private CatchAllStatement(Statement head, Statement handler) {
@@ -110,7 +110,7 @@ public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
     }
 
     List<StatEdge> lstSuccs = first.getSuccessorEdges(EdgeType.DIRECT_ALL);
-    if (first.type == TYPE_TRY_CATCH && first.varDefinitions.isEmpty() && isFinally &&
+    if (first.type == StatementType.TRY_CATCH && first.varDefinitions.isEmpty() && isFinally &&
         !labeled && !first.isLabeled() && (lstSuccs.isEmpty() || !lstSuccs.get(0).explicit)) {
       TextBuffer content = ExprProcessor.jmpWrapper(first, indent, true, tracer);
       content.setLength(content.length() - new_line_separator.length());

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchStatement.java
Patch:
@@ -28,7 +28,7 @@ public final class CatchStatement extends Statement {
   // *****************************************************************************
 
   private CatchStatement() {
-    super(TYPE_TRY_CATCH);
+    super(StatementType.TRY_CATCH);
   }
 
   private CatchStatement(Statement head, Statement next, Set<Statement> setHandlers) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/DoStatement.java
Patch:
@@ -22,7 +22,7 @@ public final class DoStatement extends Statement {
   private @NotNull LoopType loopType;
 
   private DoStatement() {
-    super(Statement.TYPE_DO);
+    super(StatementType.DO);
     initExprent.add(null);
     conditionExprent.add(null);
     incExprent.add(null);
@@ -49,7 +49,7 @@ private DoStatement(Statement head) {
         return new DoStatement(head);
       }
       // continues
-      if (head.type != TYPE_DO && (edge == null || edge.getType() != EdgeType.REGULAR) &&
+      if (head.type != StatementType.DO && (edge == null || edge.getType() != EdgeType.REGULAR) &&
           head.getContinueSet().contains(head.getBasichead())) {
         return new DoStatement(head);
       }

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/DummyExitStatement.java
Patch:
@@ -9,7 +9,7 @@ public class DummyExitStatement extends Statement {
   public Set<Integer> bytecode = null;  // offsets of bytecode instructions mapped to dummy exit
 
   public DummyExitStatement() {
-    super(Statement.TYPE_DUMMY_EXIT);
+    super(StatementType.DUMMY_EXIT);
   }
 
   public void addBytecodeOffsets(Collection<Integer> bytecodeOffsets) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/GeneralStatement.java
Patch:
@@ -15,7 +15,7 @@ public class GeneralStatement extends Statement {
   // *****************************************************************************
 
   private GeneralStatement() {
-    super(Statement.TYPE_GENERAL);
+    super(StatementType.GENERAL);
   }
 
   public GeneralStatement(Statement head, Collection<? extends Statement> statements, Statement post) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/IfStatement.java
Patch:
@@ -44,7 +44,7 @@ public final class IfStatement extends Statement {
   // *****************************************************************************
 
   private IfStatement() {
-    super(TYPE_IF);
+    super(StatementType.IF);
 
     headexprent.add(null);
   }
@@ -159,7 +159,7 @@ else if (regedges == 1) {
 
   public static Statement isHead(Statement head) {
 
-    if (head.type == TYPE_BASIC_BLOCK && head.getLastBasicType() == LASTBASICTYPE_IF) {
+    if (head.type == StatementType.BASIC_BLOCK && head.getLastBasicType() == LASTBASICTYPE_IF) {
       int regsize = head.getSuccessorEdges(EdgeType.REGULAR).size();
 
       Statement p = null;
@@ -232,7 +232,7 @@ public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
     boolean elseif = false;
 
     if (elsestat != null) {
-      if (elsestat.type == Statement.TYPE_IF
+      if (elsestat.type == StatementType.IF
           && elsestat.varDefinitions.isEmpty() && elsestat.getFirst().getExprents().isEmpty() &&
           !elsestat.isLabeled() &&
           (elsestat.getSuccessorEdges(EdgeType.DIRECT_ALL).isEmpty()

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/RootStatement.java
Patch:
@@ -9,7 +9,7 @@ public class RootStatement extends Statement {
   private final DummyExitStatement dummyExit;
 
   public RootStatement(Statement head, DummyExitStatement dummyExit) {
-    super(Statement.TYPE_ROOT);
+    super(StatementType.ROOT);
 
     first = head;
     this.dummyExit = dummyExit;

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/SequenceStatement.java
Patch:
@@ -20,7 +20,7 @@ public class SequenceStatement extends Statement {
   // *****************************************************************************
 
   private SequenceStatement() {
-    super(Statement.TYPE_SEQUENCE);
+    super(StatementType.SEQUENCE);
   }
 
   public SequenceStatement(List<? extends Statement> lst) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/SwitchStatement.java
Patch:
@@ -31,7 +31,7 @@ public final class SwitchStatement extends Statement {
   private Exprent headExprent;
 
   private SwitchStatement() {
-    super(TYPE_SWITCH);
+    super(StatementType.SWITCH);
   }
 
   private SwitchStatement(@NotNull Statement head, @Nullable Statement postStatement) {
@@ -53,7 +53,7 @@ private SwitchStatement(@NotNull Statement head, @Nullable Statement postStateme
 
   @Nullable
   public static Statement isHead(@NotNull Statement head) {
-    if (head.type == Statement.TYPE_BASIC_BLOCK && head.getLastBasicType() == Statement.LASTBASICTYPE_SWITCH) {
+    if (head.type == StatementType.BASIC_BLOCK && head.getLastBasicType() == Statement.LASTBASICTYPE_SWITCH) {
       List<Statement> statements = new ArrayList<>();
       if (DecHelper.isChoiceStatement(head, statements)) {
         Statement post = statements.remove(0);

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/SynchronizedStatement.java
Patch:
@@ -26,7 +26,7 @@ public class SynchronizedStatement extends Statement {
   // *****************************************************************************
 
   public SynchronizedStatement() {
-    super(TYPE_SYNCHRONIZED);
+    super(StatementType.SYNCHRONIZED);
 
     headexprent.add(null);
   }

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarTypeProcessor.java
Patch:
@@ -9,6 +9,7 @@
 import org.jetbrains.java.decompiler.modules.decompiler.stats.CatchStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.RootStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement.StatementType;
 import org.jetbrains.java.decompiler.struct.StructClass;
 import org.jetbrains.java.decompiler.struct.StructMethod;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
@@ -71,10 +72,10 @@ private void setInitVars(RootStatement root) {
       Statement stat = stack.removeFirst();
 
       List<VarExprent> lstVars = null;
-      if (stat.type == Statement.TYPE_CATCH_ALL) {
+      if (stat.type == StatementType.CATCH_ALL) {
         lstVars = ((CatchAllStatement)stat).getVars();
       }
-      else if (stat.type == Statement.TYPE_TRY_CATCH) {
+      else if (stat.type == StatementType.TRY_CATCH) {
         lstVars = ((CatchStatement)stat).getVars();
       }
 

File: testData/src/typeAnnotations/ArrayNestedTypeAnnotations.java
Patch:
@@ -6,4 +6,5 @@ public class ArrayNestedTypeAnnotations {
     Z.Y.@C X.W @F [] @A [] @B [] w3;
     Z.Y.X.@D W @D [] w4;
     @A Z.@B Y.@C X.@D W[][] w5;
+    @L Z. Y.X.@L W[] @L [] w6;
 }

File: testData/src/typeAnnotations/ArrayTypeAnnotations.java
Patch:
@@ -8,4 +8,5 @@ public class ArrayTypeAnnotations implements ParentInterface {
     @A String[] s5() { return null; }
     String @B [] s6() { return null; }
     @A String @B [] @C [] @D [] s7() { return null; }
+    @L String @L [][] @L [] s8() { return null; }
 }

File: testData/src/typeAnnotations/ClassSuperTypeAnnotations.java
Patch:
@@ -1,4 +1,4 @@
 package typeAnnotations;
 
-public class ClassSuperTypeAnnotations extends @A Foo implements @B Bar, @B BarGeneric<@F String, @A String @B []> {
+public class ClassSuperTypeAnnotations extends @L @A Foo implements @B Bar, @B BarGeneric<@F String, @L @A String @B []> {
 }

File: testData/src/typeAnnotations/GenericArrayNestedTypeAnnotations.java
Patch:
@@ -6,4 +6,5 @@ public class GenericArrayNestedTypeAnnotations {
     V.U<String>.@C T<Boolean, Integer, Float> @B [] @D [] t3;
     V.U<@D String>.T<Boolean, Integer, Float> @F [] t4;
     @B V.@A U<@A String>.@A T<@E Boolean, @F Integer, Float>[] t5;
+    @L V.U<String>.T<Boolean, Integer, Float>[][] t6;
 }

File: testData/src/typeAnnotations/GenericNestedTypeAnnotations.java
Patch:
@@ -6,4 +6,5 @@ public class GenericNestedTypeAnnotations {
     V.U<String>.@C T<Boolean, Integer, Float> t3;
     V.U<@D String>.T<Boolean, Integer, Float> t4;
     V.U<String>.T<@E Boolean, @F Integer, Float> t5;
+    @L V.U<String>.T<@L Boolean, @F Integer, Float> t6;
 }

File: testData/src/typeAnnotations/GenericTypeAnnotations.java
Patch:
@@ -14,7 +14,8 @@ public class GenericTypeAnnotations {
     Map<? extends @C @D String, List<Object>> m8;
     Map<? extends String, @D @E List<Object>> m9;
     Map<? extends String, List<@E @F Object>> m10;
-    @A Map<@B ? extends @C String, @D List<@E Object>> m11;
+    @A Map<@B ? extends @C String, @L @D List<@E Object>> m11;
     @A Map<@A Object, @B List<@C Object>> m12() { return null; }
     @A @B List<@C Object> l1() { return null; }
+    @L Map<? extends String, List<Object>> m13;
 }

File: testData/src/typeAnnotations/InterfaceSuperTypeAnnotations.java
Patch:
@@ -1,4 +1,4 @@
 package typeAnnotations;
 
-public interface InterfaceSuperTypeAnnotations extends @B Bar, @B BarGeneric<@F String, @A String @B []> {
+public interface InterfaceSuperTypeAnnotations extends @B Bar, @L @B BarGeneric<@F String, @L @A String @B []> {
 }

File: testData/src/typeAnnotations/NestedTypeAnnotations.java
Patch:
@@ -6,4 +6,5 @@ public class NestedTypeAnnotations {
     Z.Y.@C X.W w3;
     Z.Y.X.@D W w4;
     @A Z.@B Y.@C X.@D W w5;
+    @L Z.Y.X.W w6;
 }

File: src/org/jetbrains/java/decompiler/main/AssertProcessor.java
Patch:
@@ -10,6 +10,7 @@
 import org.jetbrains.java.decompiler.main.rels.MethodWrapper;
 import org.jetbrains.java.decompiler.modules.decompiler.SecondaryFunctionsHelper;
 import org.jetbrains.java.decompiler.modules.decompiler.StatEdge;
+import org.jetbrains.java.decompiler.modules.decompiler.StatEdge.EdgeType;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.*;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.*;
 import org.jetbrains.java.decompiler.struct.StructField;
@@ -217,7 +218,7 @@ private static boolean replaceAssertion(Statement parent, IfStatement stat, Stri
       sequence.setAllParent();
 
       for (int i = 0; i < sequence.getStats().size() - 1; i++) {
-        sequence.getStats().get(i).addSuccessor(new StatEdge(StatEdge.TYPE_REGULAR,
+        sequence.getStats().get(i).addSuccessor(new StatEdge(EdgeType.REGULAR,
                                                              sequence.getStats().get(i), sequence.getStats().get(i + 1)));
       }
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/FinallyProcessor.java
Patch:
@@ -12,6 +12,7 @@
 import org.jetbrains.java.decompiler.main.collectors.CounterContainer;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.modules.code.DeadCodeHelper;
+import org.jetbrains.java.decompiler.modules.decompiler.StatEdge.EdgeType;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.AssignmentExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.ExitExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
@@ -248,8 +249,8 @@ else if (firstcode == 2) {
       // find finally exits
       if (blockStatement != null && blockStatement.getBlock() != null) {
         Statement handler = fstat.getHandler();
-        for (StatEdge edge : blockStatement.getSuccessorEdges(Statement.STATEDGE_DIRECT_ALL)) {
-          if (edge.getType() != StatEdge.TYPE_REGULAR && handler.containsStatement(blockStatement)
+        for (StatEdge edge : blockStatement.getSuccessorEdges(EdgeType.DIRECT_ALL)) {
+          if (edge.getType() != EdgeType.REGULAR && handler.containsStatement(blockStatement)
               && !handler.containsStatement(edge.getDestination())) {
             Boolean existingFlag = mapLast.get(blockStatement.getBlock());
             // note: the dummy node is also processed!

File: src/org/jetbrains/java/decompiler/modules/decompiler/SimplifyExprentsHelper.java
Patch:
@@ -6,6 +6,7 @@
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.main.rels.ClassWrapper;
+import org.jetbrains.java.decompiler.modules.decompiler.StatEdge.EdgeType;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.*;
 import org.jetbrains.java.decompiler.modules.decompiler.sforms.SSAConstructorSparseEx;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.IfStatement;
@@ -724,7 +725,7 @@ else if (ifExpr.type == Exprent.EXPRENT_EXIT && elseExpr.type == Exprent.EXPRENT
 
               StatEdge retEdge = ifStatement.getAllSuccessorEdges().get(0);
               Statement closure = retEdge.closure == statement ? statement.getParent() : retEdge.closure;
-              statement.addSuccessor(new StatEdge(StatEdge.TYPE_BREAK, statement, retEdge.getDestination(), closure));
+              statement.addSuccessor(new StatEdge(EdgeType.BREAK, statement, retEdge.getDestination(), closure));
 
               SequenceHelper.destroyAndFlattenStatement(statement);
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/SwitchHelper.java
Patch:
@@ -8,6 +8,7 @@
 import org.jetbrains.java.decompiler.main.ClassesProcessor;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.rels.MethodWrapper;
+import org.jetbrains.java.decompiler.modules.decompiler.StatEdge.EdgeType;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.*;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.*;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
@@ -479,10 +480,10 @@ void simplify(@NotNull Map<VarExprent, Statement> tempVarAssignments) {
       }
 
       private static void removeOuterBreakEdge(@NotNull IfStatement ifStatement) {
-        List<StatEdge> ifStatementBreakEdges = ifStatement.getSuccessorEdges(StatEdge.TYPE_BREAK);
+        List<StatEdge> ifStatementBreakEdges = ifStatement.getSuccessorEdges(EdgeType.BREAK);
         if (ifStatementBreakEdges.size() != 1) return;
         Statement lastStatement = ifStatement.getStats().get(ifStatement.getStats().size() - 1);
-        List<StatEdge> lastStatementBreakEdges = lastStatement.getSuccessorEdges(StatEdge.TYPE_BREAK);
+        List<StatEdge> lastStatementBreakEdges = lastStatement.getSuccessorEdges(EdgeType.BREAK);
         if (lastStatementBreakEdges.size() != 1) return;
         StatEdge firstIfStatementBreakEdge = ifStatementBreakEdges.get(0);
         StatEdge lastStatementBreakEdge = lastStatementBreakEdges.get(0);

File: src/org/jetbrains/java/decompiler/modules/decompiler/decompose/DominatorTreeExceptionFilter.java
Patch:
@@ -1,7 +1,7 @@
 // Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.modules.decompiler.decompose;
 
-import org.jetbrains.java.decompiler.modules.decompiler.StatEdge;
+import org.jetbrains.java.decompiler.modules.decompiler.StatEdge.EdgeType;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
 import org.jetbrains.java.decompiler.util.VBStyleCollection;
 
@@ -75,7 +75,7 @@ private void buildDominatorTree() {
 
   private void buildExceptionRanges() {
     for (Statement stat : statement.getStats()) {
-      List<Statement> lstPreds = stat.getNeighbours(StatEdge.TYPE_EXCEPTION, Statement.DIRECTION_BACKWARD);
+      List<Statement> lstPreds = stat.getNeighbours(EdgeType.EXCEPTION, Statement.DIRECTION_BACKWARD);
       if (!lstPreds.isEmpty()) {
 
         Set<Integer> set = new HashSet<>();

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/SynchronizedStatement.java
Patch:
@@ -7,6 +7,7 @@
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.SequenceHelper;
 import org.jetbrains.java.decompiler.modules.decompiler.StatEdge;
+import org.jetbrains.java.decompiler.modules.decompiler.StatEdge.EdgeType;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
 import org.jetbrains.java.decompiler.util.TextBuffer;
 
@@ -42,10 +43,10 @@ public SynchronizedStatement(Statement head, Statement body, Statement exc) {
 
     stats.addWithKey(exc, exc.id);
 
-    List<StatEdge> lstSuccs = body.getSuccessorEdges(STATEDGE_DIRECT_ALL);
+    List<StatEdge> lstSuccs = body.getSuccessorEdges(EdgeType.DIRECT_ALL);
     if (!lstSuccs.isEmpty()) {
       StatEdge edge = lstSuccs.get(0);
-      if (edge.getType() == StatEdge.TYPE_REGULAR) {
+      if (edge.getType() == EdgeType.REGULAR) {
         post = edge.getDestination();
       }
     }

File: src/org/jetbrains/java/decompiler/struct/attr/StructTypeAnnotationAttribute.java
Patch:
@@ -4,7 +4,7 @@
 import org.jetbrains.java.decompiler.modules.decompiler.exps.AnnotationExprent;
 import org.jetbrains.java.decompiler.modules.decompiler.typeann.TargetInfo;
 import org.jetbrains.java.decompiler.modules.decompiler.typeann.TypeAnnotation;
-import org.jetbrains.java.decompiler.struct.StructTypePath;
+import org.jetbrains.java.decompiler.struct.StructTypePathEntry;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 
@@ -90,9 +90,9 @@ private static TypeAnnotation parse(DataInputStream data, ConstantPool pool) thr
     }
 
     int pathLength = data.readUnsignedByte();
-    List<StructTypePath> paths = new ArrayList<>(pathLength);
+    List<StructTypePathEntry> paths = new ArrayList<>(pathLength);
     for (int i = 0; i < pathLength; i++) {
-      paths.add(i, new StructTypePath(data.readUnsignedByte(), data.readUnsignedByte()));
+      paths.add(i, new StructTypePathEntry(data.readUnsignedByte(), data.readUnsignedByte()));
     }
 
     AnnotationExprent annotation = StructAnnotationAttribute.parseAnnotation(data, pool);

File: testData/src/typeAnnotations/ArrayTypeAnnotations.java
Patch:
@@ -2,10 +2,10 @@
 
 public class ArrayTypeAnnotations implements ParentInterface {
     @A String[] s1 = new String[0];
-
     String @B [] s2 = new String[0];
-
     String @C [][] s3 = new String[0][0];
-
     String [] @D [] s4 = new String[0][0];
+    @A String[] s5() { return null; }
+    String @B [] s6() { return null; }
+    @A String @B [] @C [] @D [] s7() { return null; }
 }

File: src/org/jetbrains/java/decompiler/modules/decompiler/SwitchHelper.java
Patch:
@@ -181,8 +181,8 @@ Set<Object> findRealCaseValuesHashCodes(@NotNull SwitchStatement switchStatement
         // null value represents default branch and no temp variable is assigned there.
         // Also, the bucket with null value may also contain fictive case values,
         // generated for tableswitch instruction (see com.sun.tools.javac.jvm.Gen.visitSwitch)
-        .filter(values -> values.stream().noneMatch(Objects::isNull)).flatMap(values -> values.stream())
-        .map(value -> ((ConstExprent)value)).map(value -> value.getValue())
+        .filter(values -> values.stream().noneMatch(Objects::isNull)).flatMap(Collection::stream)
+        .map(value -> ((ConstExprent)value)).map(ConstExprent::getValue)
         .collect(Collectors.toSet());
     }
 
@@ -313,7 +313,7 @@ else if (switchSelectorQualifier.type == Exprent.EXPRENT_CONST) {
               .filter(exprent -> exprent instanceof AssignmentExprent)
               .map(exprent -> (AssignmentExprent)exprent)
               .filter(exprent -> exprent.getRight().equals(finalSwitchSelectorQualifier))
-              .map(exprent -> exprent.getLeft())
+              .map(AssignmentExprent::getLeft)
               .findFirst()
               .orElse(null);
             if (tempSwitchSelectorQualifier == null) return null;

File: testData/obfuscated/aj.java
Patch:
@@ -5,7 +5,6 @@
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.Map;
-import java.util.Map.Entry;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -102,7 +101,7 @@ protected void b(k<ak> var1) {
             Iterator var5 = var2.entrySet().iterator();
 
             while(var5.hasNext()) {
-               Entry var6 = (Entry)var5.next();
+               Map.Entry var6 = (Map.Entry)var5.next();
                Long var7 = (Long)this.b.get(var6.getKey());
                if (var7 != null) {
                   double var8 = (double)(((Long)var6.getValue() - var7) * 10L) / (double)var3;

File: testData/obfuscated/n.java
Patch:
@@ -4,7 +4,6 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Map.Entry;
 
 public class n<F, S> {
    private F a;
@@ -107,7 +106,7 @@ public static <K, V> List<n<K, V>> a(Map<K, V> var0) {
       ArrayList var10000;
       while(true) {
          if (var2.hasNext()) {
-            Entry var3 = (Entry)var2.next();
+            Map.Entry var3 = (Map.Entry)var2.next();
 
             try {
                var10000 = var1;

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -207,7 +207,7 @@ public void tearDown() {
     "typeAnnotations/A", "typeAnnotations/B", "typeAnnotations/F");
   }
   @Test public void testMemberDeclarationTypeAnnotations() {doTest("typeAnnotations/MemberDeclarationTypeAnnotations",
-    "typeAnnotations/A", "typeAnnotations/B", "typeAnnotations/C", "typeAnnotations/D", "typeAnnotations/E");
+    "typeAnnotations/A", "typeAnnotations/B", "typeAnnotations/C", "typeAnnotations/D", "typeAnnotations/E",  "typeAnnotations/K");
   }
   @Test public void testInheritanceChainCycle() { doTest("pkg/TestInheritanceChainCycle"); }
   @Test public void testDynamicConstantPoolEntry() { doTest("java11/TestDynamicConstantPoolEntry"); }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -206,6 +206,9 @@ public void tearDown() {
   @Test public void testInterfaceSuperTypeAnnotations() {doTest("typeAnnotations/InterfaceSuperTypeAnnotations",
     "typeAnnotations/A", "typeAnnotations/B", "typeAnnotations/F");
   }
+  @Test public void testMemberDeclarationTypeAnnotations() {doTest("typeAnnotations/MemberDeclarationTypeAnnotations",
+    "typeAnnotations/A", "typeAnnotations/B", "typeAnnotations/C", "typeAnnotations/D", "typeAnnotations/E");
+  }
   @Test public void testInheritanceChainCycle() { doTest("pkg/TestInheritanceChainCycle"); }
   @Test public void testDynamicConstantPoolEntry() { doTest("java11/TestDynamicConstantPoolEntry"); }
 

File: src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
Patch:
@@ -609,7 +609,7 @@ private static String getEnclosingVarField(StructClass cl, MethodWrapper method,
 
     // no loop at the begin
     DirectNode firstNode = graph.first;
-    if (firstNode.preds.isEmpty()) {
+    if (firstNode.predecessors.isEmpty()) {
       // assignment to a synthetic field?
       for (Exprent exprent : firstNode.exprents) {
         if (exprent.type == Exprent.EXPRENT_ASSIGNMENT) {

File: src/org/jetbrains/java/decompiler/main/rels/NestedMemberAccess.java
Patch:
@@ -247,7 +247,7 @@ private void eliminateStaticAccess(ClassNode node) {
             }
           }
 
-          stack.addAll(nd.succs);
+          stack.addAll(nd.successors);
         }
 
         if (replaced) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
Patch:
@@ -158,7 +158,7 @@ public void processStatement(RootStatement root, StructClass cl) {
 
       String currentEntrypoint = entryPoints.isEmpty() ? null : entryPoints.getLast();
 
-      for (DirectNode nd : node.succs) {
+      for (DirectNode nd : node.successors) {
         boolean isSuccessor = true;
 
         if (currentEntrypoint != null && dgraph.mapLongRangeFinallyPaths.containsKey(node.id)) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/PPandMMHelper.java
Patch:
@@ -42,7 +42,7 @@ public boolean findPPandMM(RootStatement root) {
 
       res |= processExprentList(node.exprents);
 
-      stack.addAll(node.succs);
+      stack.addAll(node.successors);
     }
 
     return res;

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAConstructorSparseEx.java
Patch:
@@ -121,7 +121,7 @@ private void ssaStatements(DirectGraph dgraph, HashSet<String> updated) {
           outNegVarVersions.put(node.id, varmaparr[1]);
         }
 
-        for (DirectNode nd : node.succs) {
+        for (DirectNode nd : node.successors) {
           updated.add(nd.id);
         }
       }
@@ -284,7 +284,7 @@ private void mergeInVarMaps(DirectNode node, DirectGraph dgraph) {
 
     SFormsFastMapDirect mapNew = new SFormsFastMapDirect();
 
-    for (DirectNode pred : node.preds) {
+    for (DirectNode pred : node.predecessors) {
       SFormsFastMapDirect mapOut = getFilteredOutMap(node.id, pred.id, dgraph, node.id);
       if (mapNew.isEmpty()) {
         mapNew = mapOut.getCopy();

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAUConstructorSparseEx.java
Patch:
@@ -118,7 +118,7 @@ private void ssaStatements(DirectGraph dgraph, HashSet<String> updated, boolean
 
       // quick solution: 'dummy' field variables should not cross basic block borders (otherwise problems e.g. with finally loops - usage without assignment in a loop)
       // For the full solution consider adding a dummy assignment at the entry point of the method
-      boolean allow_field_propagation = node.succs.isEmpty() || (node.succs.size() == 1 && node.succs.get(0).preds.size() == 1);
+      boolean allow_field_propagation = node.successors.isEmpty() || (node.successors.size() == 1 && node.successors.get(0).predecessors.size() == 1);
 
       if (!allow_field_propagation && varmaparr[0] != null) {
         varmaparr[0].removeAllFields();
@@ -135,7 +135,7 @@ private void ssaStatements(DirectGraph dgraph, HashSet<String> updated, boolean
           outNegVarVersions.put(node.id, varmaparr[1]);
         }
 
-        for (DirectNode nd : node.succs) {
+        for (DirectNode nd : node.successors) {
           updated.add(nd.id);
         }
       }
@@ -500,7 +500,7 @@ private void mergeInVarMaps(DirectNode node, DirectGraph dgraph) {
 
     SFormsFastMapDirect mapNew = new SFormsFastMapDirect();
 
-    for (DirectNode pred : node.preds) {
+    for (DirectNode pred : node.predecessors) {
       SFormsFastMapDirect mapOut = getFilteredOutMap(node.id, pred.id, dgraph, node.id);
       if (mapNew.isEmpty()) {
         mapNew = mapOut.getCopy();

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
Patch:
@@ -13,6 +13,7 @@
 import org.jetbrains.java.decompiler.modules.decompiler.sforms.FlattenStatementsHelper;
 import org.jetbrains.java.decompiler.modules.decompiler.sforms.FlattenStatementsHelper.FinallyPathWrapper;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.*;
+import org.jetbrains.java.decompiler.modules.decompiler.typeann.TypePathWriteProgress;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarProcessor;
 import org.jetbrains.java.decompiler.struct.StructClass;
 import org.jetbrains.java.decompiler.struct.attr.StructBootstrapMethodsAttribute;

File: src/org/jetbrains/java/decompiler/modules/decompiler/typeann/TypePathWriteProgress.java
Patch:
@@ -1,7 +1,6 @@
-package org.jetbrains.java.decompiler.modules.decompiler;
+package org.jetbrains.java.decompiler.modules.decompiler.typeann;
 
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
-import org.jetbrains.java.decompiler.modules.decompiler.exps.TypeAnnotation;
 import org.jetbrains.java.decompiler.struct.StructTypePath;
 
 import java.util.Deque;

File: src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java
Patch:
@@ -4,7 +4,7 @@
 import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger;
-import org.jetbrains.java.decompiler.modules.decompiler.TypePathWriteProgress;
+import org.jetbrains.java.decompiler.modules.decompiler.typeann.TypePathWriteProgress;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
 import org.jetbrains.java.decompiler.struct.StructTypePath;
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/ConstExprent.java
Patch:
@@ -128,7 +128,7 @@ public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
     tracer.addMapping(bytecode);
 
     if (constType.type != CodeConstants.TYPE_NULL && value == null) {
-      return new TextBuffer(ExprProcessor.getCastTypeName(constType));
+      return new TextBuffer(ExprProcessor.getCastTypeName(constType, Collections.emptyList()));
     }
 
     switch (constType.type) {
@@ -270,7 +270,7 @@ else if (doubleVal == Double.NEGATIVE_INFINITY) {
         else if (constType.equals(VarType.VARTYPE_CLASS)) {
           String stringVal = value.toString();
           VarType type = new VarType(stringVal, !stringVal.startsWith("["));
-          return new TextBuffer(ExprProcessor.getCastTypeName(type)).append(".class");
+          return new TextBuffer(ExprProcessor.getCastTypeName(type, Collections.emptyList())).append(".class");
         }
     }
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/FunctionExprent.java
Patch:
@@ -473,7 +473,7 @@ else if (left.type == EXPRENT_CONST) {
         TextBuffer res = wrapOperandString(arr, false, indent, tracer);
         if (arr.getExprType().arrayDim == 0) {
           VarType objArr = VarType.VARTYPE_OBJECT.resizeArrayDim(1); // type family does not change
-          res.enclose("((" + ExprProcessor.getCastTypeName(objArr) + ")", ")");
+          res.enclose("((" + ExprProcessor.getCastTypeName(objArr, Collections.emptyList()) + ")", ")");
         }
         return res.append(".length");
       case FUNCTION_IIF:
@@ -522,7 +522,7 @@ else if (left.type == EXPRENT_CONST) {
 
     if (funcType <= FUNCTION_I2S) {
       return wrapOperandString(lstOperands.get(0), true, indent, tracer).prepend("(" + ExprProcessor.getTypeName(
-        TYPES[funcType - FUNCTION_I2L]) + ")");
+        TYPES[funcType - FUNCTION_I2L], Collections.emptyList()) + ")");
     }
 
     //		return "<unknown function>";

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
Patch:
@@ -272,7 +272,7 @@ else if (instance != null) {
           VarType leftType = new VarType(CodeConstants.TYPE_OBJECT, 0, className);
 
           if (rightType.equals(VarType.VARTYPE_OBJECT) && !leftType.equals(rightType)) {
-            buf.append("((").append(ExprProcessor.getCastTypeName(leftType)).append(")");
+            buf.append("((").append(ExprProcessor.getCastTypeName(leftType, Collections.emptyList())).append(")");
 
             if (instance.getPrecedence() >= FunctionExprent.getPrecedence(FunctionExprent.FUNCTION_CAST)) {
               res.enclose("(", ")");

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/TypeAnnotation.java
Patch:
@@ -57,7 +57,7 @@ public boolean isTopLevel(int dims) {
     return (dims == 0 && paths.isEmpty()) || (dims == paths.size());
   }
 
-  public @NotNull AnnotationExprent getAnnotation() {
+  public @NotNull AnnotationExprent getAnnotationExpr() {
     return annotation;
   }
 

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -103,7 +103,6 @@ public void tearDown() {
   @Test public void testConstructorReference() { doTest("pkg/TestConstructorReference"); }
   @Test public void testMemberAnnotations() { doTest("pkg/TestMemberAnnotations"); }
   @Test public void testMoreAnnotations() { doTest("pkg/MoreAnnotations"); }
-  @Test public void testTypeAnnotations() { doTest("pkg/TypeAnnotations"); }
   @Test public void testStaticNameClash() { doTest("pkg/TestStaticNameClash"); }
   @Test public void testExtendingSubclass() { doTest("pkg/TestExtendingSubclass"); }
   @Test public void testSyntheticAccess() { doTest("pkg/TestSyntheticAccess"); }
@@ -178,6 +177,9 @@ public void tearDown() {
     "sealed/RootWithInterfaceOuter", "sealed/ClassImplements", "sealed/ClassNonSealedExtendsImplements");
   }
   @Test public void testRootWithModule() { doTest("sealed/foo/RootWithModule", "sealed/bar/BarClassExtends");}
+  @Test public void testArrayTypeAnnotations() { doTest("typeAnnotations/ArrayTypeAnnotations",
+    "typeAnnotations/A", "typeAnnotations/B", "typeAnnotations/C", "typeAnnotations/D");
+  }
   @Test public void testInheritanceChainCycle() { doTest("pkg/TestInheritanceChainCycle"); }
   @Test public void testDynamicConstantPoolEntry() { doTest("java11/TestDynamicConstantPoolEntry"); }
 

File: src/org/jetbrains/java/decompiler/struct/attr/StructAnnotationAttribute.java
Patch:
@@ -1,6 +1,7 @@
 // Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.struct.attr;
 
+import org.jetbrains.annotations.NotNull;
 import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.*;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
@@ -37,7 +38,7 @@ public static List<AnnotationExprent> parseAnnotations(ConstantPool pool, DataIn
     }
   }
 
-  public static AnnotationExprent parseAnnotation(DataInputStream data, ConstantPool pool) throws IOException {
+  public static @NotNull AnnotationExprent parseAnnotation(DataInputStream data, ConstantPool pool) throws IOException {
     String className = pool.getPrimitiveConstant(data.readUnsignedShort()).getString();
 
     List<String> names;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/SwitchExprent.java
Patch:
@@ -76,7 +76,7 @@ public List<Exprent> getAllExprents() {
   @Override
   public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
     tracer.addMapping(bytecode);
-    return value.toJava(indent, tracer).enclose("switch(", ")");
+    return value.toJava(indent, tracer).enclose("switch (", ")");
   }
 
   @Override

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/SwitchStatement.java
Patch:
@@ -88,10 +88,10 @@ public TextBuffer toJava(int indent, @NotNull BytecodeMappingTracer tracer) {
       List<Exprent> values = caseValues.get(i);
       for (int j = 0; j < edges.size(); j++) {
         if (edges.get(j) == defaultEdge) {
-          buf.appendIndent(indent).append("default:").appendLineSeparator();
+          buf.appendIndent(indent + 1).append("default:").appendLineSeparator();
         }
         else {
-          buf.appendIndent(indent).append("case ");
+          buf.appendIndent(indent + 1).append("case ");
           Exprent value = values.get(j);
           if (value instanceof ConstExprent) {
             value = value.copy();
@@ -107,7 +107,7 @@ public TextBuffer toJava(int indent, @NotNull BytecodeMappingTracer tracer) {
         }
         tracer.incrementCurrentSourceLine();
       }
-      buf.append(ExprProcessor.jmpWrapper(stat, indent + 1, false, tracer));
+      buf.append(ExprProcessor.jmpWrapper(stat, indent + 2, false, tracer));
     }
     buf.appendIndent(indent).append("}").appendLineSeparator();
     tracer.incrementCurrentSourceLine();

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -510,7 +510,7 @@ else if (components != null) {
       Set<String> qualifiedNested = node.nested.stream()
         .map(nestedNode -> nestedNode.classStruct.qualifiedName)
         .collect(Collectors.toSet());
-      boolean allSubClassesAreNested = Set.copyOf(permittedSubclassQualifiedNames).equals(qualifiedNested);
+      boolean allSubClassesAreNested = qualifiedNested.containsAll(permittedSubclassQualifiedNames);
       if (!allSubClassesAreNested) { // only generate permits lists for non-nested classes
         buffer.append("permits ");
         for (int i = 0; i < permittedSubclassQualifiedNames.size(); i++) {

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -161,6 +161,7 @@ public void tearDown() {
   @Test public void testRootWithClassOuter() { doTest("sealed/RootWithClassOuter",
     "sealed/ClassExtends", "sealed/ClassNonSealed", "sealed/ClassNonSealedExtendsImplements");
   }
+  @Test public void testRootWithClassOuterUnresolvable() { doTest("sealed/RootWithClassOuter"); }
   @Test public void testRootWithInterfaceOuter() { doTest("sealed/RootWithInterfaceOuter",
     "sealed/ClassImplements", "sealed/InterfaceNonSealed", "sealed/ClassNonSealedExtendsImplements");
   }

File: src/org/jetbrains/java/decompiler/main/InitializerProcessor.java
Patch:
@@ -90,7 +90,7 @@ private static void hideEmptySuper(ClassWrapper wrapper) {
         Exprent exprent = firstData.getExprents().get(0);
         if (exprent.type == Exprent.EXPRENT_INVOCATION) {
           InvocationExprent invExpr = (InvocationExprent)exprent;
-          if (Statements.isInvocationInitConstructor(invExpr, method, wrapper, false) && invExpr.getLstParameters().isEmpty()) {
+          if (Statements.isInvocationInitConstructor(invExpr, method, wrapper, false) && invExpr.getParameters().isEmpty()) {
             firstData.getExprents().remove(0);
           }
         }

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
Patch:
@@ -844,7 +844,7 @@ public static boolean getCastedExprent(Exprent exprent,
       // "unbox" invocation parameters, e.g. 'byteSet.add((byte)123)' or 'new ShortContainer((short)813)'
       if (exprent.type == Exprent.EXPRENT_INVOCATION && ((InvocationExprent)exprent).isBoxingCall()) {
         InvocationExprent invocationExprent = (InvocationExprent)exprent;
-        exprent = invocationExprent.getLstParameters().get(0);
+        exprent = invocationExprent.getParameters().get(0);
         int paramType = invocationExprent.getDescriptor().params[0].type;
         if (exprent.type == Exprent.EXPRENT_CONST && ((ConstExprent)exprent).getConstType().type != paramType) {
           leftType = new VarType(paramType);

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/Statements.java
Patch:
@@ -30,12 +30,12 @@ else if (stat.isLabeled()) { // FIXME: Why??
   }
 
   public static boolean isInvocationInitConstructor(InvocationExprent inv, MethodWrapper method, ClassWrapper wrapper, boolean withThis) {
-    if (inv.getFunctype() == InvocationExprent.TYP_INIT && inv.getInstance().type == Exprent.EXPRENT_VAR) {
+    if (inv.getFuncType() == InvocationExprent.TYPE_INIT && inv.getInstance().type == Exprent.EXPRENT_VAR) {
       VarExprent instVar = (VarExprent)inv.getInstance();
       VarVersionPair varPair = new VarVersionPair(instVar);
       String className = method.varproc.getThisVars().get(varPair);
       if (className != null) { // any this instance. TODO: Restrict to current class?
-        return withThis || !wrapper.getClassStruct().qualifiedName.equals(inv.getClassname());
+        return withThis || !wrapper.getClassStruct().qualifiedName.equals(inv.getClassName());
       }
     }
 

File: src/org/jetbrains/java/decompiler/main/ClassReference14Processor.java
Patch:
@@ -133,10 +133,10 @@ private static void mapClassMethods(ClassNode node, Map<ClassWrapper, MethodWrap
           mt.hasModifier(CodeConstants.ACC_STATIC)) {
 
         RootStatement root = method.root;
-        if (root != null && root.getFirst().type == Statement.TYPE_TRYCATCH) {
+        if (root != null && root.getFirst().type == Statement.TYPE_TRY_CATCH) {
           CatchStatement cst = (CatchStatement)root.getFirst();
-          if (cst.getStats().size() == 2 && cst.getFirst().type == Statement.TYPE_BASICBLOCK &&
-              cst.getStats().get(1).type == Statement.TYPE_BASICBLOCK &&
+          if (cst.getStats().size() == 2 && cst.getFirst().type == Statement.TYPE_BASIC_BLOCK &&
+              cst.getStats().get(1).type == Statement.TYPE_BASIC_BLOCK &&
               cst.getVars().get(0).getVarType().equals(new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/ClassNotFoundException"))) {
 
             BasicBlockStatement body = (BasicBlockStatement)cst.getFirst();

File: src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
Patch:
@@ -786,7 +786,7 @@ private static Statement findFirstBlock(Statement stat, Set<Statement> setStats)
           case Statement.TYPE_IF:
           case Statement.TYPE_ROOT:
           case Statement.TYPE_SWITCH:
-          case Statement.TYPE_SYNCRONIZED:
+          case Statement.TYPE_SYNCHRONIZED:
             stack.add(st.getFirst());
             break;
           default:

File: src/org/jetbrains/java/decompiler/modules/decompiler/DomHelper.java
Patch:
@@ -220,7 +220,7 @@ public static void removeSynchronizedHandler(Statement stat) {
       removeSynchronizedHandler(st);
     }
 
-    if (stat.type == Statement.TYPE_SYNCRONIZED) {
+    if (stat.type == Statement.TYPE_SYNCHRONIZED) {
       ((SynchronizedStatement)stat).removeExc();
     }
   }
@@ -251,7 +251,7 @@ private static void buildSynchronized(Statement stat) {
               next = next.getFirst();
             }
 
-            if (next.type == Statement.TYPE_CATCHALL) {
+            if (next.type == Statement.TYPE_CATCH_ALL) {
 
               CatchAllStatement ca = (CatchAllStatement)next;
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExitHelper.java
Patch:
@@ -171,7 +171,7 @@ private static int integrateExits(Statement stat) {
   private static Statement isExitEdge(StatEdge edge) {
     Statement dest = edge.getDestination();
 
-    if (edge.getType() == StatEdge.TYPE_BREAK && dest.type == Statement.TYPE_BASICBLOCK && edge.explicit && (edge.labeled || isOnlyEdge(edge))) {
+    if (edge.getType() == StatEdge.TYPE_BREAK && dest.type == Statement.TYPE_BASIC_BLOCK && edge.explicit && (edge.labeled || isOnlyEdge(edge))) {
       List<Exprent> data = dest.getExprents();
 
       if (data != null && data.size() == 1) {
@@ -192,7 +192,7 @@ private static boolean isOnlyEdge(StatEdge edge) {
         if (ed.getType() == StatEdge.TYPE_REGULAR) {
           Statement source = ed.getSource();
 
-          if (source.type == Statement.TYPE_BASICBLOCK || (source.type == Statement.TYPE_IF &&
+          if (source.type == Statement.TYPE_BASIC_BLOCK || (source.type == Statement.TYPE_IF &&
                                                            ((IfStatement)source).iftype == IfStatement.IFTYPE_IF) ||
               (source.type == Statement.TYPE_DO && ((DoStatement)source).getLooptype() != DoStatement.LOOP_DO)) {
             return false;

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
Patch:
@@ -220,13 +220,13 @@ else if (entryPoints.size() == 1) {
   private static void collectCatchVars(Statement stat, FlattenStatementsHelper flatthelper, Map<String, VarExprent> map) {
     List<VarExprent> lst = null;
 
-    if (stat.type == Statement.TYPE_CATCHALL) {
+    if (stat.type == Statement.TYPE_CATCH_ALL) {
       CatchAllStatement catchall = (CatchAllStatement)stat;
       if (!catchall.isFinally()) {
         lst = catchall.getVars();
       }
     }
-    else if (stat.type == Statement.TYPE_TRYCATCH) {
+    else if (stat.type == Statement.TYPE_TRY_CATCH) {
       lst = ((CatchStatement)stat).getVars();
     }
 
@@ -723,7 +723,7 @@ public static TextBuffer jmpWrapper(Statement stat, int indent, boolean semicolo
     List<StatEdge> lstSuccs = stat.getSuccessorEdges(Statement.STATEDGE_DIRECT_ALL);
     if (lstSuccs.size() == 1) {
       StatEdge edge = lstSuccs.get(0);
-      if (edge.getType() != StatEdge.TYPE_REGULAR && edge.explicit && edge.getDestination().type != Statement.TYPE_DUMMYEXIT) {
+      if (edge.getType() != StatEdge.TYPE_REGULAR && edge.explicit && edge.getDestination().type != Statement.TYPE_DUMMY_EXIT) {
         buf.appendIndent(indent);
 
         switch (edge.getType()) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/FinallyProcessor.java
Patch:
@@ -57,7 +57,7 @@ public boolean iterateGraph(StructClass cl, StructMethod mt, RootStatement root,
       Statement stat = stack.removeLast();
 
       Statement parent = stat.getParent();
-      if (parent != null && parent.type == Statement.TYPE_CATCHALL &&
+      if (parent != null && parent.type == Statement.TYPE_CATCH_ALL &&
           stat == parent.getFirst() && !parent.isCopied()) {
 
         CatchAllStatement fin = (CatchAllStatement)parent;
@@ -265,7 +265,7 @@ else if (firstcode == 2) {
     }
 
     // empty finally block?
-    if (fstat.getHandler().type == Statement.TYPE_BASICBLOCK) {
+    if (fstat.getHandler().type == Statement.TYPE_BASIC_BLOCK) {
 
       boolean isEmpty = false;
       boolean isFirstLast = mapLast.containsKey(firstBasicBlock);
@@ -420,7 +420,7 @@ private static Set<BasicBlock> getAllBasicBlocks(Statement stat) {
     do {
       Statement st = lst.get(index);
 
-      if (st.type == Statement.TYPE_BASICBLOCK) {
+      if (st.type == Statement.TYPE_BASIC_BLOCK) {
         index++;
       }
       else {

File: src/org/jetbrains/java/decompiler/modules/decompiler/IfHelper.java
Patch:
@@ -617,8 +617,8 @@ private static boolean hasDirectEndEdge(Statement stat, Statement from) {
       switch (stat.type) {
         case Statement.TYPE_SEQUENCE:
           return hasDirectEndEdge(stat.getStats().getLast(), from);
-        case Statement.TYPE_CATCHALL:
-        case Statement.TYPE_TRYCATCH:
+        case Statement.TYPE_CATCH_ALL:
+        case Statement.TYPE_TRY_CATCH:
           for (Statement st : stat.getStats()) {
             if (hasDirectEndEdge(st, from)) {
               return true;
@@ -632,7 +632,7 @@ private static boolean hasDirectEndEdge(Statement stat, Statement from) {
                    hasDirectEndEdge(ifstat.getElsestat(), from);
           }
           break;
-        case Statement.TYPE_SYNCRONIZED:
+        case Statement.TYPE_SYNCHRONIZED:
           return hasDirectEndEdge(stat.getStats().get(1), from);
         case Statement.TYPE_SWITCH:
           for (Statement st : stat.getStats()) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/LoopExtractHelper.java
Patch:
@@ -64,7 +64,7 @@ private static boolean extractLoop(DoStatement stat) {
     }
 
     for (StatEdge edge : stat.getLabelEdges()) {
-      if (edge.getType() != StatEdge.TYPE_CONTINUE && edge.getDestination().type != Statement.TYPE_DUMMYEXIT) {
+      if (edge.getType() != StatEdge.TYPE_CONTINUE && edge.getDestination().type != Statement.TYPE_DUMMY_EXIT) {
         return false;
       }
     }

File: src/org/jetbrains/java/decompiler/modules/decompiler/MergeHelper.java
Patch:
@@ -241,7 +241,7 @@ public static boolean isDirectPath(Statement stat, Statement endstat) {
       else {
         switch (parent.type) {
           case Statement.TYPE_ROOT:
-            return endstat.type == Statement.TYPE_DUMMYEXIT;
+            return endstat.type == Statement.TYPE_DUMMY_EXIT;
           case Statement.TYPE_DO:
             return (endstat == parent);
           case Statement.TYPE_SWITCH:

File: src/org/jetbrains/java/decompiler/modules/decompiler/SequenceHelper.java
Patch:
@@ -128,7 +128,7 @@ private static void condenseSequencesRec(Statement stat) {
     outer:
     while (true) {
       for (Statement st : stat.getStats()) {
-        if ((st.getStats().isEmpty() || st.getExprents() != null) && st.type != Statement.TYPE_BASICBLOCK) {
+        if ((st.getStats().isEmpty() || st.getExprents() != null) && st.type != Statement.TYPE_BASIC_BLOCK) {
           destroyAndFlattenStatement(st);
           continue outer;
         }
@@ -271,7 +271,7 @@ private static Statement getFirstExprentlist(Statement stat) {
       case Statement.TYPE_IF:
       case Statement.TYPE_SEQUENCE:
       case Statement.TYPE_SWITCH:
-      case Statement.TYPE_SYNCRONIZED:
+      case Statement.TYPE_SYNCHRONIZED:
         return getFirstExprentlist(stat.getFirst());
     }
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/deobfuscator/IrreducibleCFGDeobfuscator.java
Patch:
@@ -160,7 +160,7 @@ private static int getStatementSize(Statement statement) {
 
     int res;
 
-    if (statement.type == Statement.TYPE_BASICBLOCK) {
+    if (statement.type == Statement.TYPE_BASIC_BLOCK) {
       res = ((BasicBlockStatement)statement).getBlock().getSeq().length();
     }
     else {

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAConstructorSparseEx.java
Patch:
@@ -441,11 +441,11 @@ private void setCatchMaps(Statement stat, DirectGraph dgraph, FlattenStatementsH
     SFormsFastMapDirect map;
 
     switch (stat.type) {
-      case Statement.TYPE_CATCHALL:
-      case Statement.TYPE_TRYCATCH:
+      case Statement.TYPE_CATCH_ALL:
+      case Statement.TYPE_TRY_CATCH:
 
         List<VarExprent> lstVars;
-        if (stat.type == Statement.TYPE_CATCHALL) {
+        if (stat.type == Statement.TYPE_CATCH_ALL) {
           lstVars = ((CatchAllStatement)stat).getVars();
         }
         else {

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/BasicBlockStatement.java
Patch:
@@ -15,7 +15,7 @@ public class BasicBlockStatement extends Statement {
   private final BasicBlock block;
 
   public BasicBlockStatement(BasicBlock block) {
-    type = Statement.TYPE_BASICBLOCK;
+    super(Statement.TYPE_BASIC_BLOCK);
     id = block.id;
     this.block = block;
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchAllStatement.java
Patch:
@@ -32,7 +32,7 @@ public final class CatchAllStatement extends Statement {
   // *****************************************************************************
 
   private CatchAllStatement() {
-    type = Statement.TYPE_CATCHALL;
+    super(Statement.TYPE_CATCH_ALL);
   }
 
   private CatchAllStatement(Statement head, Statement handler) {
@@ -109,7 +109,7 @@ public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
     }
 
     List<StatEdge> lstSuccs = first.getSuccessorEdges(STATEDGE_DIRECT_ALL);
-    if (first.type == TYPE_TRYCATCH && first.varDefinitions.isEmpty() && isFinally &&
+    if (first.type == TYPE_TRY_CATCH && first.varDefinitions.isEmpty() && isFinally &&
         !labeled && !first.isLabeled() && (lstSuccs.isEmpty() || !lstSuccs.get(0).explicit)) {
       TextBuffer content = ExprProcessor.jmpWrapper(first, indent, true, tracer);
       content.setLength(content.length() - new_line_separator.length());

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchStatement.java
Patch:
@@ -26,7 +26,7 @@ public final class CatchStatement extends Statement {
   // *****************************************************************************
 
   private CatchStatement() {
-    type = TYPE_TRYCATCH;
+    super(TYPE_TRY_CATCH);
   }
 
   private CatchStatement(Statement head, Statement next, Set<Statement> setHandlers) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/DoStatement.java
Patch:
@@ -29,7 +29,7 @@ public final class DoStatement extends Statement {
   // *****************************************************************************
 
   private DoStatement() {
-    type = Statement.TYPE_DO;
+    super(Statement.TYPE_DO);
     looptype = LOOP_DO;
 
     initExprent.add(null);

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/DummyExitStatement.java
Patch:
@@ -9,7 +9,7 @@ public class DummyExitStatement extends Statement {
   public Set<Integer> bytecode = null;  // offsets of bytecode instructions mapped to dummy exit
 
   public DummyExitStatement() {
-    type = Statement.TYPE_DUMMYEXIT;
+    super(Statement.TYPE_DUMMY_EXIT);
   }
 
   public void addBytecodeOffsets(Collection<Integer> bytecodeOffsets) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/GeneralStatement.java
Patch:
@@ -15,7 +15,7 @@ public class GeneralStatement extends Statement {
   // *****************************************************************************
 
   private GeneralStatement() {
-    type = Statement.TYPE_GENERAL;
+    super(Statement.TYPE_GENERAL);
   }
 
   public GeneralStatement(Statement head, Collection<? extends Statement> statements, Statement post) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/IfStatement.java
Patch:
@@ -43,7 +43,7 @@ public final class IfStatement extends Statement {
   // *****************************************************************************
 
   private IfStatement() {
-    type = TYPE_IF;
+    super(TYPE_IF);
 
     headexprent.add(null);
   }
@@ -158,7 +158,7 @@ else if (regedges == 1) {
 
   public static Statement isHead(Statement head) {
 
-    if (head.type == TYPE_BASICBLOCK && head.getLastBasicType() == LASTBASICTYPE_IF) {
+    if (head.type == TYPE_BASIC_BLOCK && head.getLastBasicType() == LASTBASICTYPE_IF) {
       int regsize = head.getSuccessorEdges(StatEdge.TYPE_REGULAR).size();
 
       Statement p = null;

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/RootStatement.java
Patch:
@@ -9,7 +9,7 @@ public class RootStatement extends Statement {
   private final DummyExitStatement dummyExit;
 
   public RootStatement(Statement head, DummyExitStatement dummyExit) {
-    type = Statement.TYPE_ROOT;
+    super(Statement.TYPE_ROOT);
 
     first = head;
     this.dummyExit = dummyExit;

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/SequenceStatement.java
Patch:
@@ -19,7 +19,7 @@ public class SequenceStatement extends Statement {
   // *****************************************************************************
 
   private SequenceStatement() {
-    type = Statement.TYPE_SEQUENCE;
+    super(Statement.TYPE_SEQUENCE);
   }
 
   public SequenceStatement(List<? extends Statement> lst) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/Statements.java
Patch:
@@ -22,7 +22,7 @@ else if (stat.isLabeled()) { // FIXME: Why??
       case Statement.TYPE_IF:
       case Statement.TYPE_ROOT:
       case Statement.TYPE_SWITCH:
-      case Statement.TYPE_SYNCRONIZED:
+      case Statement.TYPE_SYNCHRONIZED:
         return findFirstData(stat.getFirst());
       default:
         return null;

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/SwitchStatement.java
Patch:
@@ -29,7 +29,7 @@ public final class SwitchStatement extends Statement {
   private Exprent headExprent;
 
   private SwitchStatement() {
-    type = TYPE_SWITCH;
+    super(TYPE_SWITCH);
   }
 
   private SwitchStatement(@NotNull Statement head, @Nullable Statement postStatement) {
@@ -51,7 +51,7 @@ private SwitchStatement(@NotNull Statement head, @Nullable Statement postStateme
 
   @Nullable
   public static Statement isHead(@NotNull Statement head) {
-    if (head.type == Statement.TYPE_BASICBLOCK && head.getLastBasicType() == Statement.LASTBASICTYPE_SWITCH) {
+    if (head.type == Statement.TYPE_BASIC_BLOCK && head.getLastBasicType() == Statement.LASTBASICTYPE_SWITCH) {
       List<Statement> statements = new ArrayList<>();
       if (DecHelper.isChoiceStatement(head, statements)) {
         Statement post = statements.remove(0);

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/SynchronizedStatement.java
Patch:
@@ -25,7 +25,7 @@ public class SynchronizedStatement extends Statement {
   // *****************************************************************************
 
   public SynchronizedStatement() {
-    type = TYPE_SYNCRONIZED;
+    super(TYPE_SYNCHRONIZED);
 
     headexprent.add(null);
   }

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarTypeProcessor.java
Patch:
@@ -71,10 +71,10 @@ private void setInitVars(RootStatement root) {
       Statement stat = stack.removeFirst();
 
       List<VarExprent> lstVars = null;
-      if (stat.type == Statement.TYPE_CATCHALL) {
+      if (stat.type == Statement.TYPE_CATCH_ALL) {
         lstVars = ((CatchAllStatement)stat).getVars();
       }
-      else if (stat.type == Statement.TYPE_TRYCATCH) {
+      else if (stat.type == Statement.TYPE_TRY_CATCH) {
         lstVars = ((CatchStatement)stat).getVars();
       }
 

File: src/org/jetbrains/java/decompiler/struct/match/MatchEngine.java
Patch:
@@ -44,8 +44,8 @@ public class MatchEngine {
     "if", Statement.TYPE_IF,
     "do", Statement.TYPE_DO,
     "switch", Statement.TYPE_SWITCH,
-    "trycatch", Statement.TYPE_TRYCATCH,
-    "basicblock", Statement.TYPE_BASICBLOCK,
+    "trycatch", Statement.TYPE_TRY_CATCH,
+    "basicblock", Statement.TYPE_BASIC_BLOCK,
     "sequence", Statement.TYPE_SEQUENCE);
 
   private static final Map<String, Integer> expr_type = Map.ofEntries(

File: testData/obfuscated/ag.java
Patch:
@@ -11,13 +11,13 @@ public void a(long param1) {
    public double a() {
       try {
          if (this.d == 0) {
-            return 0.0D;
+            return 0.0;
          }
       } catch (a_ var4) {
          throw var4;
       }
 
-      double var1 = 0.0D;
+      double var1 = 0.0;
 
       for(int var3 = 0; var3 <= this.d; ++var3) {
          var1 += (double)this.b[var3];

File: testData/obfuscated/aj.java
Patch:
@@ -106,7 +106,7 @@ protected void b(k<ak> var1) {
                Long var7 = (Long)this.b.get(var6.getKey());
                if (var7 != null) {
                   double var8 = (double)(((Long)var6.getValue() - var7) * 10L) / (double)var3;
-                  var1.a((Object)(new ar(h[1], (String)var6.getKey(), "%", var8 * 100.0D)));
+                  var1.a((Object)(new ar(h[1], (String)var6.getKey(), "%", var8 * 100.0)));
                }
             }
          }

File: testData/obfuscated/at.java
Patch:
@@ -8,15 +8,15 @@ class at extends ap {
    }
 
    public double d() {
-      return (double)an.a(this.d).getHeapMemoryUsage().getUsed() / 1024.0D / 1024.0D;
+      return (double)an.a(this.d).getHeapMemoryUsage().getUsed() / 1024.0 / 1024.0;
    }
 
    public String c() {
       return e;
    }
 
    public Double e() {
-      return (double)an.a(this.d).getHeapMemoryUsage().getMax() / 1024.0D / 1024.0D;
+      return (double)an.a(this.d).getHeapMemoryUsage().getMax() / 1024.0 / 1024.0;
    }
 
    static {

File: testData/obfuscated/au.java
Patch:
@@ -19,6 +19,6 @@ public String c() {
    }
 
    public Double e() {
-      return 100.0D;
+      return 100.0;
    }
 }

File: testData/obfuscated/av.java
Patch:
@@ -19,6 +19,6 @@ public String c() {
    }
 
    public Double e() {
-      return 100.0D;
+      return 100.0;
    }
 }

File: testData/obfuscated/ax.java
Patch:
@@ -25,7 +25,7 @@ public String d() {
    }
 
    public String a(boolean var1) {
-      String var2 = String.valueOf(((double)System.nanoTime() - (double)this.a) / 1000.0D);
+      String var2 = String.valueOf(((double)System.nanoTime() - (double)this.a) / 1000.0);
 
       try {
          if (var1) {

File: testData/obfuscated/e.java
Patch:
@@ -67,7 +67,7 @@ public Long f() {
          throw var5;
       }
 
-      var10000 = Math.round(100.0D * (double)var1 / (double)(var1 + var3));
+      var10000 = Math.round(100.0 * (double)var1 / (double)(var1 + var3));
       return var10000;
    }
 

File: src/org/jetbrains/java/decompiler/code/CodeConstants.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.code;
 
 @SuppressWarnings({"unused", "SpellCheckingInspection"})
@@ -113,6 +113,7 @@ public interface CodeConstants {
   int CONSTANT_NameAndType = 12;
   int CONSTANT_MethodHandle = 15;
   int CONSTANT_MethodType = 16;
+  int CONSTANT_Dynamic = 17;
   int CONSTANT_InvokeDynamic = 18;
   int CONSTANT_Module = 19;
   int CONSTANT_Package = 20;
@@ -340,4 +341,4 @@ public interface CodeConstants {
 
   String CLINIT_NAME = "<clinit>";
   String INIT_NAME = "<init>";
-}
\ No newline at end of file
+}

File: src/org/jetbrains/java/decompiler/struct/consts/LinkConstant.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.struct.consts;
 
 public class LinkConstant extends PooledConstant {
@@ -49,7 +49,7 @@ else if (type == CONSTANT_MethodHandle) {
       descriptor = ref_info.descriptor;
     }
     else {
-      if (type != CONSTANT_InvokeDynamic) {
+      if (type != CONSTANT_InvokeDynamic && type != CONSTANT_Dynamic) {
         classname = pool.getPrimitiveConstant(index1).getString();
       }
 
@@ -72,4 +72,4 @@ public boolean equals(Object o) {
            this.descriptor.equals(cn.descriptor) &&
            (this.type != CONSTANT_NameAndType || this.classname.equals(cn.classname));
   }
-}
\ No newline at end of file
+}

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -776,7 +776,7 @@ private boolean methodToJava(ClassNode node, StructMethod mt, TextBuffer buffer,
 
       appendModifiers(buffer, flags, METHOD_ALLOWED, isInterface, METHOD_EXCLUDED);
 
-      if (isInterface && !mt.hasModifier(CodeConstants.ACC_STATIC) && mt.containsCode()) {
+      if (isInterface && !mt.hasModifier(CodeConstants.ACC_STATIC) && !mt.hasModifier(CodeConstants.ACC_PRIVATE) && mt.containsCode()) {
         // 'default' modifier (Java 8)
         buffer.append("default ");
       }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -84,6 +84,7 @@ public void tearDown() {
   @Test public void testStringConcat() { doTest("pkg/TestStringConcat"); }
   @Test public void testJava9StringConcat() { doTest("java9/TestJava9StringConcat"); }
   @Test public void testJava9ModuleInfo() { doTest("java9/module-info"); }
+  @Test public void testJava9PrivateInterfaceMethod() { doTest("java9/TestJava9PrivateInterfaceMethod"); }
   @Test public void testJava11StringConcat() { doTest("java11/TestJava11StringConcat"); }
   @Test public void testJava11StringConcatEmptyAffix() { doTest("java11/TestJava11StringConcatEmptyAffix"); }
   @Test public void testJava11StringConcatSpecialChars() { doTest("java11/TestJava11StringConcatSpecialChars"); }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler;
 
 import org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler;
@@ -85,6 +85,8 @@ public void tearDown() {
   @Test public void testJava9StringConcat() { doTest("java9/TestJava9StringConcat"); }
   @Test public void testJava9ModuleInfo() { doTest("java9/module-info"); }
   @Test public void testJava11StringConcat() { doTest("java11/TestJava11StringConcat"); }
+  @Test public void testJava11StringConcatEmptyAffix() { doTest("java11/TestJava11StringConcatEmptyAffix"); }
+  @Test public void testJava11StringConcatSpecialChars() { doTest("java11/TestJava11StringConcatSpecialChars"); }
   @Test public void testMethodReferenceSameName() { doTest("pkg/TestMethodReferenceSameName"); }
   @Test public void testMethodReferenceLetterClass() { doTest("pkg/TestMethodReferenceLetterClass"); }
   @Test public void testConstructorReference() { doTest("pkg/TestConstructorReference"); }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -125,6 +125,7 @@ public void tearDown() {
   @Test public void testInterfaceSuper() { doTest("pkg/TestInterfaceSuper"); }
   @Test public void testFieldSingleAccess() { doTest("pkg/TestFieldSingleAccess"); }
   @Test public void testPackageInfo() { doTest("pkg/package-info"); }
+  @Test public void testIntVarMerge() { doTest("pkg/TestIntVarMerge"); }
 
   // TODO: fix all below
   //@Test public void testSwitchOnStrings() { doTest("pkg/TestSwitchOnStrings");}

File: src/org/jetbrains/java/decompiler/util/FastFixedSetFactory.java
Patch:
@@ -146,7 +146,7 @@ public boolean equals(Object o) {
       if (o == this) return true;
       if (!(o instanceof FastFixedSet)) return false;
 
-      int[] extdata = ((FastFixedSet)o).getData();
+      int[] extdata = ((FastFixedSet<?>)o).getData();
       int[] intdata = data;
 
       for (int i = intdata.length - 1; i >= 0; i--) {

File: src/org/jetbrains/java/decompiler/util/FastSparseSetFactory.java
Patch:
@@ -249,7 +249,7 @@ public boolean equals(Object o) {
       if (o == this) return true;
       if (!(o instanceof FastSparseSet)) return false;
 
-      int[] longdata = ((FastSparseSet)o).getData();
+      int[] longdata = ((FastSparseSet<?>)o).getData();
       int[] shortdata = data;
 
       if (data.length > longdata.length) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
Patch:
@@ -26,7 +26,7 @@
 public class NewExprent extends Exprent {
   private InvocationExprent constructor;
   private final VarType newType;
-  private List<Exprent> lstDims = new ArrayList<>();
+  private final List<Exprent> lstDims;
   private List<Exprent> lstArrayElements = new ArrayList<>();
   private boolean directArrayInit;
   private boolean isVarArgParam;

File: testData/src/records/TestRecordEmpty.java
Patch:
@@ -0,0 +1,3 @@
+package records;
+
+public record TestRecordEmpty() {}
\ No newline at end of file

File: testData/src/records/TestRecordSimple.java
Patch:
@@ -0,0 +1,3 @@
+package records;
+
+public record TestRecordSimple(int x, int y) {}
\ No newline at end of file

File: testData/src/records/TestRecordVararg.java
Patch:
@@ -0,0 +1,3 @@
+package records;
+
+public record TestRecordVararg(int x, int[]... y) {}
\ No newline at end of file

File: src/org/jetbrains/java/decompiler/struct/consts/LinkConstant.java
Patch:
@@ -26,10 +26,11 @@ private void initConstant() {
     if (type == CONSTANT_Methodref ||
         type == CONSTANT_InterfaceMethodref ||
         type == CONSTANT_InvokeDynamic ||
-        type == CONSTANT_MethodHandle) {
+        (type == CONSTANT_MethodHandle && index1 != CONSTANT_MethodHandle_REF_getField && index1 != CONSTANT_MethodHandle_REF_putField)) {
       int parenth = descriptor.indexOf(')');
       if (descriptor.length() < 2 || parenth < 0 || descriptor.charAt(0) != '(') {
-        throw new IllegalArgumentException("Invalid descriptor: " + descriptor);
+        throw new IllegalArgumentException("Invalid descriptor: " + descriptor +
+                                           "; type = " + type + "; classname = " + classname + "; elementname = " + elementname);
       }
     }
   }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler;
 
 import org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler;
@@ -110,6 +110,7 @@ public void tearDown() {
   @Test public void testMissingConstructorCallGood() { doTest("pkg/TestMissingConstructorCallGood"); }
   @Test public void testMissingConstructorCallBad() { doTest("pkg/TestMissingConstructorCallBad"); }
   @Test public void testEmptyBlocks() { doTest("pkg/TestEmptyBlocks"); }
+  @Test public void testInvertedFloatComparison() { doTest("pkg/TestInvertedFloatComparison"); }
   @Test public void testPrivateEmptyConstructor() { doTest("pkg/TestPrivateEmptyConstructor"); }
   @Test public void testSynchronizedUnprotected() { doTest("pkg/TestSynchronizedUnprotected"); }
   @Test public void testInterfaceSuper() { doTest("pkg/TestInterfaceSuper"); }

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/ConstExprent.java
Patch:
@@ -28,7 +28,7 @@ public class ConstExprent extends Exprent {
     CHAR_ESCAPES.put(0xC, "\\f");   /* \u000c: form feed FF */
     CHAR_ESCAPES.put(0xD, "\\r");   /* \u000d: carriage return CR */
     //CHAR_ESCAPES.put(0x22, "\\\""); /* \u0022: double quote " */
-    CHAR_ESCAPES.put(0x27, "\\\'"); /* \u0027: single quote ' */
+    CHAR_ESCAPES.put(0x27, "\\'"); /* \u0027: single quote ' */
     CHAR_ESCAPES.put(0x5C, "\\\\"); /* \u005c: backslash \ */
   }
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/IfHelper.java
Patch:
@@ -100,7 +100,7 @@ public static boolean mergeIfs(Statement statement, Set<? super Integer> setReor
         break;
       }
 
-      res |= true;
+      res = true;
     }
 
     return res;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/AnnotationExprent.java
Patch:
@@ -17,10 +17,10 @@ public class AnnotationExprent extends Exprent {
   public static final int ANNOTATION_SINGLE_ELEMENT = 3;
 
   private final String className;
-  private final List<? extends String> parNames;
+  private final List<String> parNames;
   private final List<? extends Exprent> parValues;
 
-  public AnnotationExprent(String className, List<? extends String> parNames, List<? extends Exprent> parValues) {
+  public AnnotationExprent(String className, List<String> parNames, List<? extends Exprent> parValues) {
     super(EXPRENT_ANNOTATION);
     this.className = className;
     this.parNames = parNames;

File: src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
Patch:
@@ -65,7 +65,7 @@ public void init() {
             MethodProcessorRunnable mtProc = new MethodProcessorRunnable(mt, md, varProc, DecompilerContext.getCurrentContext());
 
             Thread mtThread = new Thread(mtProc, "Java decompiler");
-            long stopAt = System.currentTimeMillis() + maxSec * 1000;
+            long stopAt = System.currentTimeMillis() + maxSec * 1000L;
 
             mtThread.start();
 

File: src/org/jetbrains/java/decompiler/main/decompiler/ConsoleDecompiler.java
Patch:
@@ -172,7 +172,7 @@ public void copyFile(String source, String path, String entryName) {
   @Override
   public void saveClassFile(String path, String qualifiedName, String entryName, String content, int[] mapping) {
     File file = new File(getAbsolutePath(path), entryName);
-    try (Writer out = new OutputStreamWriter(new FileOutputStream(file), "UTF8")) {
+    try (Writer out = new OutputStreamWriter(new FileOutputStream(file), StandardCharsets.UTF_8)) {
       out.write(content);
     }
     catch (IOException ex) {

File: src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.main.rels;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
@@ -20,6 +20,7 @@
 import org.jetbrains.java.decompiler.struct.StructField;
 import org.jetbrains.java.decompiler.struct.StructMethod;
 import org.jetbrains.java.decompiler.struct.attr.StructEnclosingMethodAttribute;
+import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
@@ -171,8 +172,7 @@ private static void checkNotFoundClasses(ClassNode root, ClassNode node) {
         Set<String> setEnclosing = child.enclosingClasses;
 
         if (!setEnclosing.isEmpty()) {
-          StructEnclosingMethodAttribute attr =
-            (StructEnclosingMethodAttribute)child.classStruct.getAttribute("EnclosingMethod");
+          StructEnclosingMethodAttribute attr = child.classStruct.getAttribute(StructGeneralAttribute.ATTRIBUTE_ENCLOSING_METHOD);
           if (attr != null &&
               attr.getMethodName() != null &&
               node.classStruct.qualifiedName.equals(attr.getClassName()) &&

File: src/org/jetbrains/java/decompiler/struct/StructMethod.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.struct;
 
 import org.jetbrains.java.decompiler.code.*;
@@ -63,7 +63,7 @@ public StructMethod(DataInputFullStream in, StructClass clStruct) throws IOExcep
 
   @Override
   protected StructGeneralAttribute readAttribute(DataInputFullStream in, ConstantPool pool, String name) throws IOException {
-    if (StructGeneralAttribute.ATTRIBUTE_CODE.equals(name)) {
+    if (StructGeneralAttribute.ATTRIBUTE_CODE.getName().equals(name)) {
       if (!classStruct.isOwn()) {
         // skip code in foreign classes
         in.discard(8);

File: src/org/jetbrains/java/decompiler/struct/lazy/LazyLoader.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
+// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
 package org.jetbrains.java.decompiler.struct.lazy;
 
 import org.jetbrains.java.decompiler.main.extern.IBytecodeProvider;
@@ -90,7 +90,7 @@ public byte[] loadBytecode(StructMethod mt, int codeFullLength) {
           for (int j = 0; j < attrSize; j++) {
             int attrNameIndex = in.readUnsignedShort();
             String attrName = pool.getPrimitiveConstant(attrNameIndex).getString();
-            if (!StructGeneralAttribute.ATTRIBUTE_CODE.equals(attrName)) {
+            if (!StructGeneralAttribute.ATTRIBUTE_CODE.getName().equals(attrName)) {
               in.discard(in.readInt());
               continue;
             }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -70,7 +70,8 @@ public void tearDown() {
   @Test public void testAnonymousSignature() { doTest("pkg/TestAnonymousSignature"); }
   @Test public void testLocalsSignature() { doTest("pkg/TestLocalsSignature"); }
   @Test public void testParameterizedTypes() { doTest("pkg/TestParameterizedTypes"); }
-  @Test public void testShadowing() { doTest("pkg/TestShadowing", "pkg/Shadow", "ext/Shadow"); }
+  @Test public void testShadowing() { doTest("pkg/TestShadowing", "pkg/Shadow", "ext/Shadow",
+           "pkg/TestShadowingSuperClass"); }
   @Test public void testStringConcat() { doTest("pkg/TestStringConcat"); }
   @Test public void testJava9StringConcat() { doTest("java9/TestJava9StringConcat"); }
   @Test public void testMethodReferenceSameName() { doTest("pkg/TestMethodReferenceSameName"); }

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
Patch:
@@ -247,7 +247,9 @@ public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
 
           if (invocationTyp == INVOKE_SPECIAL) {
             if (!classname.equals(this_classname)) { // TODO: direct comparison to the super class?
-              super_qualifier = this_classname;
+              StructClass cl = DecompilerContext.getStructContext().getClass(classname);
+              boolean isInterface = cl != null && (cl.getAccessFlags() & CodeConstants.ACC_INTERFACE) != 0;
+              super_qualifier = !isInterface ? this_classname : classname;
             }
           }
         }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -110,15 +110,14 @@ public void tearDown() {
   @Test public void testEmptyBlocks() { doTest("pkg/TestEmptyBlocks"); }
   @Test public void testPrivateEmptyConstructor() { doTest("pkg/TestPrivateEmptyConstructor"); }
   @Test public void testSynchronizedUnprotected() { doTest("pkg/TestSynchronizedUnprotected"); }
-
+  @Test public void testInterfaceSuper() { doTest("pkg/TestInterfaceSuper"); }
 
   // TODO: fix all below
   //@Test public void testPackageInfo() { doTest("pkg/package-info"); }
   //@Test public void testSwitchOnStrings() { doTest("pkg/TestSwitchOnStrings");}
   //@Test public void testUnionType() { doTest("pkg/TestUnionType"); }
   //@Test public void testInnerClassConstructor2() { doTest("pkg/TestInner2"); }
   //@Test public void testInUse() { doTest("pkg/TestInUse"); }
-  //@Test public void testInterfaceSuper() { doTest("pkg/TestInterfaceSuper"); }
 
   @Test public void testGroovyClass() { doTest("pkg/TestGroovyClass"); }
   @Test public void testGroovyTrait() { doTest("pkg/TestGroovyTrait"); }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -108,6 +108,7 @@ public void tearDown() {
   @Test public void testMissingConstructorCallGood() { doTest("pkg/TestMissingConstructorCallGood"); }
   @Test public void testMissingConstructorCallBad() { doTest("pkg/TestMissingConstructorCallBad"); }
   @Test public void testEmptyBlocks() { doTest("pkg/TestEmptyBlocks"); }
+  @Test public void testPrivateEmptyConstructor() { doTest("pkg/TestPrivateEmptyConstructor"); }
 
 
   // TODO: fix all below

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -107,6 +107,7 @@ public void tearDown() {
   @Test public void testSuperInner() { doTest("pkg/TestSuperInner", "pkg/TestSuperInnerBase"); }
   @Test public void testMissingConstructorCallGood() { doTest("pkg/TestMissingConstructorCallGood"); }
   @Test public void testMissingConstructorCallBad() { doTest("pkg/TestMissingConstructorCallBad"); }
+  @Test public void testEmptyBlocks() { doTest("pkg/TestEmptyBlocks"); }
 
 
   // TODO: fix all below

File: testData/obfuscated/bc.java
Patch:
@@ -150,7 +150,6 @@ public void a(InputStream var1) throws ParserConfigurationException, SAXExceptio
          var4.setContentHandler(this);
          var4.parse(new InputSource(var1));
       } catch (a_ var8) {
-         ;
       } finally {
          var1.close();
       }

File: testData/obfuscated/bd.java
Patch:
@@ -236,7 +236,6 @@ private static String b(String var0) {
          try {
             b.update(var0.getBytes(j));
          } catch (UnsupportedEncodingException var4) {
-            ;
          }
 
          byte[] var2 = b.digest();
@@ -260,7 +259,6 @@ private static String a(String var0, String var1) {
       try {
          var2 = (var0 + a).getBytes(j);
       } catch (UnsupportedEncodingException var9) {
-         ;
       }
 
       b.update(var2);

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -104,6 +104,9 @@ public void tearDown() {
   @Test public void testPop2TwoIntPop2() { doTest("pkg/TestPop2TwoIntPop2"); }
   @Test public void testPop2TwoIntTwoPop() { doTest("pkg/TestPop2TwoIntTwoPop"); }
   @Test public void testSuperInner() { doTest("pkg/TestSuperInner", "pkg/TestSuperInnerBase"); }
+  @Test public void testMissingConstructorCallGood() { doTest("pkg/TestMissingConstructorCallGood"); }
+  @Test public void testMissingConstructorCallBad() { doTest("pkg/TestMissingConstructorCallBad"); }
+
 
   // TODO: fix all below
   //@Test public void testPackageInfo() { doTest("pkg/package-info"); }

File: src/org/jetbrains/java/decompiler/struct/gen/VarType.java
Patch:
@@ -82,7 +82,7 @@ public VarType(String signature, boolean clType) {
           }
 
         default:
-          value = signature.substring(i, signature.length());
+          value = signature.substring(i);
           if ((clType && i == 0) || value.length() > 1) {
             type = CodeConstants.TYPE_OBJECT;
           }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -105,6 +105,7 @@ public void tearDown() {
   @Test public void testPop2OneLongPop2() { doTest("pkg/TestPop2OneLongPop2"); }
   @Test public void testPop2TwoIntPop2() { doTest("pkg/TestPop2TwoIntPop2"); }
   @Test public void testPop2TwoIntTwoPop() { doTest("pkg/TestPop2TwoIntTwoPop"); }
+  @Test public void testSuperInner2() { doTest("pkg/TestSuperInner2", "pkg/TestSuperInner"); }
 
   // TODO: fix all below
   //@Test public void testPackageInfo() { doTest("pkg/package-info"); }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -113,6 +113,7 @@ public void tearDown() {
 
   @Test public void testGroovyClass() { doTest("pkg/TestGroovyClass"); }
   @Test public void testGroovyTrait() { doTest("pkg/TestGroovyTrait"); }
+  @Test public void testPrivateClasses() { doTest("pkg/PrivateClasses"); }
 
   private void doTest(String testFile, String... companionFiles) {
     ConsoleDecompiler decompiler = fixture.getDecompiler();

File: src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
Patch:
@@ -64,7 +64,7 @@ static Map<String, Object> getDefaults() {
     defaults.put(LITERALS_AS_IS, "0");
     defaults.put(BOOLEAN_TRUE_ONE, "1");
     defaults.put(ASCII_STRING_CHARACTERS, "0");
-    defaults.put(SYNTHETIC_NOT_SET, "1");
+    defaults.put(SYNTHETIC_NOT_SET, "0");
     defaults.put(UNDEFINED_PARAM_TYPE_OBJECT, "1");
     defaults.put(USE_DEBUG_VAR_NAMES, "1");
     defaults.put(REMOVE_EMPTY_RANGES, "1");

File: src/org/jetbrains/java/decompiler/main/collectors/ImportCollector.java
Patch:
@@ -72,7 +72,7 @@ public String getShortName(String fullName, boolean imported) {
 
     StringBuilder result = null;
     if (node != null && node.classStruct.isOwn()) {
-      result = new StringBuilder(node.simpleName);
+      result = new StringBuilder(String.valueOf(node.simpleName));
 
       while (node.parent != null && node.type == ClassNode.CLASS_MEMBER) {
         result.insert(0, node.parent.simpleName + '.');

File: src/org/jetbrains/java/decompiler/modules/decompiler/FinallyProcessor.java
Patch:
@@ -898,8 +898,7 @@ private boolean compareBasicBlocksEx(ControlFlowGraph graph,
       newblock.setSeq(seq);
       newblock.getInstrOldOffsets().addAll(oldOffsets);
 
-      List<BasicBlock> lstTemp = new ArrayList<>();
-      lstTemp.addAll(sample.getSuccs());
+      List<BasicBlock> lstTemp = new ArrayList<>(sample.getSuccs());
 
       // move successors
       for (BasicBlock suc : lstTemp) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/SequenceHelper.java
Patch:
@@ -18,7 +18,6 @@
 import org.jetbrains.java.decompiler.code.cfg.BasicBlock;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.collectors.CounterContainer;
-import org.jetbrains.java.decompiler.modules.decompiler.exps.Exprent;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.BasicBlockStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.SequenceStatement;
 import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
@@ -39,8 +38,7 @@ private static void condenseSequencesRec(Statement stat) {
 
     if (stat.type == Statement.TYPE_SEQUENCE) {
 
-      List<Statement> lst = new ArrayList<>();
-      lst.addAll(stat.getStats());
+      List<Statement> lst = new ArrayList<>(stat.getStats());
 
       boolean unfolded = false;
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/deobfuscator/ExceptionDeobfuscator.java
Patch:
@@ -172,9 +172,8 @@ public static void insertEmptyExceptionHandlerBlocks(ControlFlowGraph graph) {
       BasicBlock emptyblock = new BasicBlock(++graph.last_id);
       graph.getBlocks().addWithKey(emptyblock, emptyblock.id);
 
-      List<BasicBlock> lstTemp = new ArrayList<>();
       // only exception predecessors considered
-      lstTemp.addAll(handler.getPredExceptions());
+      List<BasicBlock> lstTemp = new ArrayList<>(handler.getPredExceptions());
 
       // replace predecessors
       for (BasicBlock pred : lstTemp) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/FunctionExprent.java
Patch:
@@ -413,8 +413,7 @@ else if (type2.type == CodeConstants.TYPE_BOOLEAN) {
 
   @Override
   public List<Exprent> getAllExprents() {
-    List<Exprent> lst = new ArrayList<>();
-    lst.addAll(lstOperands);
+    List<Exprent> lst = new ArrayList<>(lstOperands);
     return lst;
   }
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
Patch:
@@ -326,7 +326,7 @@ else if (newNode.type == ClassNode.CLASS_MEMBER && (newNode.access & CodeConstan
           boolean firstParam = true;
           for (int i = start; i < lstParameters.size(); i++) {
             if (sigFields == null || sigFields.get(i) == null) {
-              Exprent expr = lstParameters.get(i);
+              Exprent expr = InvocationExprent.unboxIfNeeded(lstParameters.get(i));
               VarType leftType = constructor.getDescriptor().params[i];
 
               if (i == lstParameters.size() - 1 && expr.getExprType() == VarType.VARTYPE_NULL) {

File: src/org/jetbrains/java/decompiler/struct/gen/VarType.java
Patch:
@@ -40,6 +40,8 @@ public class VarType {  // TODO: optimize switch
   public static final VarType VARTYPE_OBJECT = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Object");
   public static final VarType VARTYPE_INTEGER = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Integer");
   public static final VarType VARTYPE_CHARACTER = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Character");
+  public static final VarType VARTYPE_BYTE_OBJ = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Byte");
+  public static final VarType VARTYPE_SHORT_OBJ = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Short");
   public static final VarType VARTYPE_VOID = new VarType(CodeConstants.TYPE_VOID);
 
   public final int type;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
Patch:
@@ -410,10 +410,10 @@ private boolean isBoxingCall() {
       // special handling for ambiguous types
       if (lstParameters.get(0).type == Exprent.EXPRENT_CONST) {
         // 'Integer.valueOf(1)' has '1' type detected as TYPE_BYTECHAR
+        // 'Integer.valueOf(40_000)' has '40_000' type detected as TYPE_CHAR
+        // so we check the type family instead
         if (lstParameters.get(0).getExprType().typeFamily == CodeConstants.TYPE_FAMILY_INTEGER) {
           if (classname.equals("java/lang/Integer")) {
-            // 'Integer.valueOf(40_000)' will change to '40_000' and that will be interpreted as 'char' type
-            ((ConstExprent) lstParameters.get(0)).setConstType(VarType.VARTYPE_INT);
             return true;
           }
         }

File: src/org/jetbrains/java/decompiler/struct/gen/VarType.java
Patch:
@@ -38,6 +38,8 @@ public class VarType {  // TODO: optimize switch
   public static final VarType VARTYPE_STRING = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/String");
   public static final VarType VARTYPE_CLASS = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Class");
   public static final VarType VARTYPE_OBJECT = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Object");
+  public static final VarType VARTYPE_INTEGER = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Integer");
+  public static final VarType VARTYPE_CHARACTER = new VarType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Character");
   public static final VarType VARTYPE_VOID = new VarType(CodeConstants.TYPE_VOID);
 
   public final int type;

File: testData/obfuscated/ac.java
Patch:
@@ -0,0 +1,3 @@
+public interface ac {
+   void a() throws Exception;
+}

File: testData/obfuscated/ad.java
Patch:
@@ -0,0 +1,3 @@
+public interface ad {
+   String a();
+}

File: testData/obfuscated/af.java
Patch:
@@ -0,0 +1,3 @@
+// $FF: synthetic class
+class af {
+}

File: testData/obfuscated/am.java
Patch:
@@ -0,0 +1,3 @@
+public interface am {
+   void a(k<ak> var1);
+}

File: testData/obfuscated/ay.java
Patch:
@@ -0,0 +1,3 @@
+public interface ay {
+   void a(a0 var1);
+}

File: testData/obfuscated/f.java
Patch:
@@ -0,0 +1,3 @@
+public interface f<K, V> {
+   V a(K var1);
+}

File: testData/obfuscated/g.java
Patch:
@@ -0,0 +1,3 @@
+public interface g<V> {
+   boolean a(V var1);
+}

File: testData/obfuscated/q.java
Patch:
@@ -0,0 +1,3 @@
+public interface q {
+   void a(p var1);
+}

File: src/org/jetbrains/java/decompiler/modules/decompiler/SwitchHelper.java
Patch:
@@ -42,7 +42,7 @@ public static void simplify(SwitchStatement switchStatement) {
         DecompilerContext.getClassProcessor().getMapRootClasses().get(arrayField.getClassname());
       if (classNode != null) {
         MethodWrapper wrapper = classNode.getWrapper().getMethodWrapper(CodeConstants.CLINIT_NAME, "()V");
-        if (wrapper != null) {
+        if (wrapper != null && wrapper.root != null) {
           wrapper.getOrBuildGraph().iterateExprents(new DirectGraph.ExprentIterator() {
             @Override
             public int processExprent(Exprent exprent) {

File: src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
Patch:
@@ -142,7 +142,9 @@ public void init() throws IOException {
         }
       }
       catch (Throwable ex) {
-        DecompilerContext.getLogger().writeMessage("Method " + mt.getName() + " " + mt.getDescriptor() + " couldn't be decompiled.", ex);
+        DecompilerContext.getLogger().writeMessage("Method " + mt.getName() + " " + mt.getDescriptor() + " couldn't be decompiled.",
+                                                   IFernflowerLogger.Severity.WARN,
+                                                   ex);
         isError = true;
       }
 

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -118,6 +118,7 @@ public void tearDown() {
   //@Test public void testUnionType() { doTest("pkg/TestUnionType"); }
   //@Test public void testInnerClassConstructor2() { doTest("pkg/TestInner2"); }
   //@Test public void testInUse() { doTest("pkg/TestInUse"); }
+  //@Test public void testInterfaceSuper() { doTest("pkg/TestInterfaceSuper"); }
 
   private void doTest(String testFile, String... companionFiles) {
     ConsoleDecompiler decompiler = fixture.getDecompiler();

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
Patch:
@@ -340,7 +340,7 @@ else if (newNode.type == ClassNode.CLASS_MEMBER && (newNode.access & CodeConstan
                 buf.append(", ");
               }
 
-              ExprProcessor.getCastedExprent(expr, leftType, buf, indent, true, tracer);
+              ExprProcessor.getCastedExprent(expr, leftType, buf, indent, true, false, true, tracer);
 
               firstParam = false;
             }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -112,6 +112,7 @@ public void tearDown() {
   @Test public void testVarArgCalls() { doTest("pkg/TestVarArgCalls"); }
   @Test public void testLambdaParams() { doTest("pkg/TestLambdaParams"); }
   @Test public void testInterfaceMethods() { doTest("pkg/TestInterfaceMethods"); }
+  //@Test public void testUnionType() { doTest("pkg/TestUnionType"); } //TODO: fix
 
   private void doTest(String testFile, String... companionFiles) {
     ConsoleDecompiler decompiler = fixture.getDecompiler();

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -624,7 +624,7 @@ private boolean methodToJava(ClassNode node, StructMethod mt, TextBuffer buffer,
 
       appendModifiers(buffer, flags, METHOD_ALLOWED, isInterface, METHOD_EXCLUDED);
 
-      if (isInterface && mt.containsCode()) {
+      if (isInterface && !mt.hasModifier(CodeConstants.ACC_STATIC) && mt.containsCode()) {
         // 'default' modifier (Java 8)
         buffer.append("default ");
       }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -111,6 +111,7 @@ public void tearDown() {
   //@Test public void TestSwitchOnStrings() { doTest("pkg/TestSwitchOnStrings");}
   @Test public void testVarArgCalls() { doTest("pkg/TestVarArgCalls"); }
   @Test public void testLambdaParams() { doTest("pkg/TestLambdaParams"); }
+  @Test public void testInterfaceMethods() { doTest("pkg/TestInterfaceMethods"); }
 
   private void doTest(String testFile, String... companionFiles) {
     ConsoleDecompiler decompiler = fixture.getDecompiler();

File: src/org/jetbrains/java/decompiler/main/collectors/VarNamesCollector.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2000-2015 JetBrains s.r.o.
+ * Copyright 2000-2017 JetBrains s.r.o.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,6 +15,7 @@
  */
 package org.jetbrains.java.decompiler.main.collectors;
 
+import java.util.Collection;
 import java.util.HashSet;
 import java.util.Set;
 
@@ -24,7 +25,7 @@ public class VarNamesCollector {
 
   public VarNamesCollector() { }
 
-  public VarNamesCollector(Set<String> setNames) {
+  public VarNamesCollector(Collection<String> setNames) {
     usedNames.addAll(setNames);
   }
 

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -110,6 +110,7 @@ public void tearDown() {
   @Test public void testSwitchOnEnum() { doTest("pkg/TestSwitchOnEnum");}
   //@Test public void TestSwitchOnStrings() { doTest("pkg/TestSwitchOnStrings");}
   @Test public void testVarArgCalls() { doTest("pkg/TestVarArgCalls"); }
+  @Test public void testLambdaParams() { doTest("pkg/TestLambdaParams"); }
 
   private void doTest(String testFile, String... companionFiles) {
     ConsoleDecompiler decompiler = fixture.getDecompiler();

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -98,8 +98,8 @@ public void classLambdaToJava(ClassNode node, TextBuffer buffer, Exprent method_
           buffer.append(ExprProcessor.getCastTypeName(new VarType(node.lambdaInformation.content_class_name, true)));
         }
 
-        buffer.append("::");
-        buffer.append(node.lambdaInformation.content_method_name);
+        buffer.append("::")
+          .append(CodeConstants.INIT_NAME.equals(node.lambdaInformation.content_method_name) ? "new" : node.lambdaInformation.content_method_name);
       }
       else {
         // lambda method

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -86,6 +86,7 @@ public void tearDown() {
   @Test public void testJava9StringConcat() { doTest("java9/TestJava9StringConcat"); }
   @Test public void testMethodReferenceSameName() { doTest("pkg/TestMethodReferenceSameName"); }
   @Test public void testMethodReferenceLetterClass() { doTest("pkg/TestMethodReferenceLetterClass"); }
+  @Test public void testConstructorReference() { doTest("pkg/TestConstructorReference"); }
   @Test public void testMemberAnnotations() { doTest("pkg/TestMemberAnnotations"); }
   @Test public void testMoreAnnotations() { doTest("pkg/MoreAnnotations"); }
   @Test public void testTypeAnnotations() { doTest("pkg/TypeAnnotations"); }

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
Patch:
@@ -860,7 +860,7 @@ public static boolean getCastedExprent(Exprent exprent,
                                          int indent,
                                          boolean castNull,
                                          BytecodeMappingTracer tracer) {
-    return getCastedExprent(exprent, leftType, buffer, indent, castNull, false, tracer);
+    return getCastedExprent(exprent, leftType, buffer, indent, castNull, false, false, tracer);
   }
 
   public static boolean getCastedExprent(Exprent exprent,
@@ -869,14 +869,15 @@ public static boolean getCastedExprent(Exprent exprent,
                                          int indent,
                                          boolean castNull,
                                          boolean castAlways,
+                                         boolean castNarrowing,
                                          BytecodeMappingTracer tracer) {
     VarType rightType = exprent.getExprType();
 
     boolean cast =
       castAlways ||
       (!leftType.isSuperset(rightType) && (rightType.equals(VarType.VARTYPE_OBJECT) || leftType.type != CodeConstants.TYPE_OBJECT)) ||
       (castNull && rightType.type == CodeConstants.TYPE_NULL && !UNDEFINED_TYPE_STRING.equals(getTypeName(leftType))) ||
-      (isIntConstant(exprent) && VarType.VARTYPE_INT.isStrictSuperset(leftType));
+      (castNarrowing && isIntConstant(exprent) && VarType.VARTYPE_INT.isStrictSuperset(leftType));
 
     boolean quote = cast && exprent.getPrecedence() >= FunctionExprent.getPrecedence(FunctionExprent.FUNCTION_CAST);
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
Patch:
@@ -876,7 +876,7 @@ public static boolean getCastedExprent(Exprent exprent,
       castAlways ||
       (!leftType.isSuperset(rightType) && (rightType.equals(VarType.VARTYPE_OBJECT) || leftType.type != CodeConstants.TYPE_OBJECT)) ||
       (castNull && rightType.type == CodeConstants.TYPE_NULL && !UNDEFINED_TYPE_STRING.equals(getTypeName(leftType))) ||
-      (isIntConstant(exprent) && rightType.isStrictSuperset(leftType));
+      (isIntConstant(exprent) && VarType.VARTYPE_INT.isStrictSuperset(leftType));
 
     boolean quote = cast && exprent.getPrecedence() >= FunctionExprent.getPrecedence(FunctionExprent.FUNCTION_CAST);
 

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -101,6 +101,7 @@ public void tearDown() {
   @Test public void testAnonymousParams() { doTest("pkg/TestAnonymousParams"); }
   @Test public void testAccessReplace() { doTest("pkg/TestAccessReplace"); }
   @Test public void testStringLiterals() { doTest("pkg/TestStringLiterals"); }
+  @Test public void testPrimitives() { doTest("pkg/TestPrimitives"); }
 
   private void doTest(String testFile, String... companionFiles) {
     ConsoleDecompiler decompiler = fixture.getDecompiler();

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -97,6 +97,7 @@ public void tearDown() {
   @Test public void testLocalsNames() { doTest("pkg/TestLocalsNames"); }
   @Test public void testAnonymousParamNames() { doTest("pkg/TestAnonymousParamNames"); }
   @Test public void testAnonymousParams() { doTest("pkg/TestAnonymousParams"); }
+  @Test public void testAccessReplace() { doTest("pkg/TestAccessReplace"); }
 
   private void doTest(String testFile, String... companionFiles) {
     ConsoleDecompiler decompiler = fixture.getDecompiler();

File: src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
Patch:
@@ -405,8 +405,10 @@ public int processExprent(Exprent exprent) {
         MethodWrapper method = nestedNode.getWrapper().getMethodWrapper(CodeConstants.INIT_NAME, entry.getKey());
         method.signatureFields = new ArrayList<>();
 
+        boolean firstSignField = nestedNode.type != ClassNode.CLASS_ANONYMOUS;
         for (VarFieldPair pair : entry.getValue()) {
-          method.signatureFields.add(pair == null || pair.fieldKey.isEmpty() ? null : pair.varPair);
+          method.signatureFields.add(pair == null || (!firstSignField && pair.fieldKey.isEmpty()) ? null : pair.varPair);
+          firstSignField = false;
         }
       }
     }

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java
Patch:
@@ -84,12 +84,12 @@ public void setDebugVarNames(Map<Integer, String> mapDebugVarNames) {
     }
   }
 
-  public Integer getVarOriginalIndex(VarVersionPair pair) {
+  public Integer getVarOriginalIndex(int index) {
     if (varVersions == null) {
       return null;
     }
 
-    return varVersions.getMapOriginalVarIndices().get(pair.var);
+    return varVersions.getMapOriginalVarIndices().get(index);
   }
 
   public void refreshVarNames(VarNamesCollector vc) {

File: src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
Patch:
@@ -393,7 +393,7 @@ public int processExprent(Exprent exprent) {
       mergeListSignatures(interPairMask, interMask, true);
 
       for (VarFieldPair pair : interPairMask) {
-        if (pair != null && pair.fieldKey.length() > 0) {
+        if (pair != null && !pair.fieldKey.isEmpty()) {
           nestedNode.mapFieldsToVars.put(pair.fieldKey, pair.varPair);
         }
       }
@@ -406,7 +406,7 @@ public int processExprent(Exprent exprent) {
         method.signatureFields = new ArrayList<>();
 
         for (VarFieldPair pair : entry.getValue()) {
-          method.signatureFields.add(pair == null ? null : pair.varPair);
+          method.signatureFields.add(pair == null || pair.fieldKey.isEmpty() ? null : pair.varPair);
         }
       }
     }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -62,6 +62,7 @@ public void tearDown() {
   @Test public void testEnum() { doTest("pkg/TestEnum"); }
   @Test public void testDebugSymbols() { doTest("pkg/TestDebugSymbols"); }
   @Test public void testInvalidMethodSignature() { doTest("InvalidMethodSignature"); }
+  @Test public void testAnonymousClassConstructor() { doTest("pkg/TestAnonymousClassConstructor"); }
   @Test public void testInnerClassConstructor() { doTest("pkg/TestInnerClassConstructor"); }
   @Test public void testInnerClassConstructor11() { doTest("v11/TestInnerClassConstructor"); }
   @Test public void testTryCatchFinally() { doTest("pkg/TestTryCatchFinally"); }
@@ -94,6 +95,7 @@ public void tearDown() {
   @Test public void testKotlinConstructor() { doTest("pkg/TestKotlinConstructorKt"); }
   @Test public void testAsserts() { doTest("pkg/TestAsserts"); }
   @Test public void testLocalsNames() { doTest("pkg/TestLocalsNames"); }
+  @Test public void testAnonymousParamNames() { doTest("pkg/TestAnonymousParamNames"); }
 
   private void doTest(String testFile, String... companionFiles) {
     ConsoleDecompiler decompiler = fixture.getDecompiler();

File: src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2000-2016 JetBrains s.r.o.
+ * Copyright 2000-2017 JetBrains s.r.o.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -163,7 +163,8 @@ public void init() throws IOException {
       if (DecompilerContext.getOption(IFernflowerPreferences.USE_DEBUG_VAR_NAMES)) {
         StructLocalVariableTableAttribute attr = mt.getLocalVariableAttr();
         if (attr != null) {
-          varProc.setDebugVarNames(attr.getMapVarNames());
+          // only param names here
+          varProc.setDebugVarNames(attr.getMapParamNames());
         }
       }
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2000-2016 JetBrains s.r.o.
+ * Copyright 2000-2017 JetBrains s.r.o.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -88,7 +88,7 @@ private boolean isAmbiguous() {
     if (method != null) {
       StructLocalVariableTableAttribute attr = method.methodStruct.getLocalVariableAttr();
       if (attr != null) {
-        return attr.getMapVarNames().containsValue(name);
+        return attr.containsName(name);
       }
     }
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java
Patch:
@@ -40,8 +40,9 @@ public VarProcessor(StructMethod mt, MethodDescriptor md) {
   }
 
   public void setVarVersions(RootStatement root) {
+    VarVersionsProcessor oldProcessor = varVersions;
     varVersions = new VarVersionsProcessor(method, methodDescriptor);
-    varVersions.setVarVersions(root);
+    varVersions.setVarVersions(root, oldProcessor);
   }
 
   public void setVarDefinitions(Statement root) {

File: src/org/jetbrains/java/decompiler/struct/StructMember.java
Patch:
@@ -61,7 +61,7 @@ protected VBStyleCollection<StructGeneralAttribute, String> readAttributes(DataI
         if (StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TABLE.equals(name) && attributes.containsKey(name)) {
           // merge all variable tables
           StructLocalVariableTableAttribute table = (StructLocalVariableTableAttribute)attributes.getWithKey(name);
-          table.addLocalVariableTable((StructLocalVariableTableAttribute)attribute);
+          table.add((StructLocalVariableTableAttribute)attribute);
         }
         else if (StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TYPE_TABLE.equals(name) && attributes.containsKey(name)) {
           // merge all variable tables

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -93,6 +93,7 @@ public void tearDown() {
   @Test public void testIllegalVarName() { doTest("pkg/TestIllegalVarName"); }
   @Test public void testKotlinConstructor() { doTest("pkg/TestKotlinConstructorKt"); }
   @Test public void testAsserts() { doTest("pkg/TestAsserts"); }
+  @Test public void testLocalsNames() { doTest("pkg/TestLocalsNames"); }
 
   private void doTest(String testFile, String... companionFiles) {
     ConsoleDecompiler decompiler = fixture.getDecompiler();

File: testData/bulk/pkg/res/Loader.java
Patch:
@@ -11,9 +11,9 @@ public String getResource() {
          throw new RuntimeException("Resource missing");
       } else {
          try {
-            File e = new File(resource.toURI());
-            byte[] bytes = new byte[(int)e.length()];
-            FileInputStream stream = new FileInputStream(e);
+            File file = new File(resource.toURI());
+            byte[] bytes = new byte[(int)file.length()];
+            FileInputStream stream = new FileInputStream(file);
             stream.read(bytes);
             stream.close();
             return new String(bytes, "UTF-8");

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
Patch:
@@ -191,7 +191,7 @@ public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
             buf.append(GenericMain.getGenericCastTypeName(descriptor.superclass));
           }
           else {
-            if (descriptor.superinterfaces.size() > 1) {
+            if (descriptor.superinterfaces.size() > 1 && !lambda) {
               DecompilerContext.getLogger().writeMessage("Inconsistent anonymous class signature: " + child.classStruct.qualifiedName,
                                                          IFernflowerLogger.Severity.WARN);
             }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -77,6 +77,7 @@ public void tearDown() {
   @Test public void testInnerLocalPkg() { doTest("pkg/TestInnerLocalPkg"); }
   @Test public void testInnerSignature() { doTest("pkg/TestInnerSignature"); }
   @Test public void testAnonymousSignature() { doTest("pkg/TestAnonymousSignature"); }
+  @Test public void testLocalsSignature() { doTest("pkg/TestLocalsSignature"); }
   @Test public void testParameterizedTypes() { doTest("pkg/TestParameterizedTypes"); }
   @Test public void testShadowing() { doTest("pkg/TestShadowing", "pkg/Shadow", "ext/Shadow"); }
   @Test public void testStringConcat() { doTest("pkg/TestStringConcat"); }

File: src/org/jetbrains/java/decompiler/code/InstructionSequence.java
Patch:
@@ -41,7 +41,7 @@ public abstract class InstructionSequence {
   protected ExceptionTable exceptionTable = ExceptionTable.EMPTY;
 
   protected InstructionSequence() {
-    this(new VBStyleCollection<Instruction, Integer>());
+    this(new VBStyleCollection<>());
   }
 
   protected InstructionSequence(VBStyleCollection<Instruction, Integer> collinstr) {

File: src/org/jetbrains/java/decompiler/code/cfg/ExceptionRangeCFG.java
Patch:
@@ -24,7 +24,7 @@
 
 public class ExceptionRangeCFG {
 
-  private List<BasicBlock> protectedRange = new ArrayList<BasicBlock>(); // FIXME: replace with set
+  private List<BasicBlock> protectedRange = new ArrayList<>(); // FIXME: replace with set
 
   private BasicBlock handler;
 
@@ -35,7 +35,7 @@ public ExceptionRangeCFG(List<BasicBlock> protectedRange, BasicBlock handler, Li
     this.handler = handler;
 
     if (exceptionType != null) {
-      this.exceptionTypes = new ArrayList<String>(exceptionType);
+      this.exceptionTypes = new ArrayList<>(exceptionType);
     }
   }
 
@@ -105,7 +105,7 @@ public String getUniqueExceptionsString() {
       return null;
     }
 
-    Set<String> setExceptionStrings = new HashSet<String>();
+    Set<String> setExceptionStrings = new HashSet<>();
 
     for (String exceptionType : exceptionTypes) { // normalize order
       setExceptionStrings.add(exceptionType);

File: src/org/jetbrains/java/decompiler/main/AssertProcessor.java
Patch:
@@ -169,7 +169,7 @@ private static boolean replaceAssertion(Statement parent, IfStatement stat, Stri
       return false;
     }
 
-    List<Exprent> lstParams = new ArrayList<Exprent>();
+    List<Exprent> lstParams = new ArrayList<>();
 
     Exprent ascond = null, retcond = null;
     if (exprres[0] != null) {
@@ -196,7 +196,7 @@ private static boolean replaceAssertion(Statement parent, IfStatement stat, Stri
       first.removeSuccessor(stat.getIfEdge());
       first.removeSuccessor(stat.getElseEdge());
 
-      List<Statement> lstStatements = new ArrayList<Statement>();
+      List<Statement> lstStatements = new ArrayList<>();
       if (first.getExprents() != null && !first.getExprents().isEmpty()) {
         lstStatements.add(first);
       }

File: src/org/jetbrains/java/decompiler/main/ClassReference14Processor.java
Patch:
@@ -74,12 +74,12 @@ public class ClassReference14Processor {
 
   public static void processClassReferences(ClassNode node) {
     // find the synthetic method Class class$(String) if present
-    HashMap<ClassWrapper, MethodWrapper> mapClassMeths = new HashMap<ClassWrapper, MethodWrapper>();
+    HashMap<ClassWrapper, MethodWrapper> mapClassMeths = new HashMap<>();
     mapClassMethods(node, mapClassMeths);
     if (mapClassMeths.isEmpty()) {
       return;
     }
-    HashSet<ClassWrapper> setFound = new HashSet<ClassWrapper>();
+    HashSet<ClassWrapper> setFound = new HashSet<>();
     processClassRec(node, mapClassMeths, setFound);
 
     if (!setFound.isEmpty()) {

File: src/org/jetbrains/java/decompiler/main/DecompilerContext.java
Patch:
@@ -35,7 +35,7 @@ public class DecompilerContext {
   public static final String CURRENT_METHOD_WRAPPER = "CURRENT_METHOD_WRAPPER";
   public static final String CURRENT_VAR_PROCESSOR = "CURRENT_VAR_PROCESSOR";
 
-  private static final ThreadLocal<DecompilerContext> currentContext = new ThreadLocal<DecompilerContext>();
+  private static final ThreadLocal<DecompilerContext> currentContext = new ThreadLocal<>();
 
   private final Map<String, Object> properties;
   private StructContext structContext;
@@ -52,7 +52,7 @@ private DecompilerContext(Map<String, Object> properties) {
   }
 
   public static void initContext(Map<String, Object> propertiesCustom) {
-    Map<String, Object> properties = new HashMap<String, Object>(IFernflowerPreferences.DEFAULTS);
+    Map<String, Object> properties = new HashMap<>(IFernflowerPreferences.DEFAULTS);
     if (propertiesCustom != null) {
       properties.putAll(propertiesCustom);
     }

File: src/org/jetbrains/java/decompiler/main/InitializerProcessor.java
Patch:
@@ -156,8 +156,8 @@ private static void extractDynamicInitializers(ClassWrapper wrapper) {
 
     boolean isAnonymous = DecompilerContext.getClassProcessor().getMapRootClasses().get(cl.qualifiedName).type == ClassNode.CLASS_ANONYMOUS;
 
-    List<List<Exprent>> lstFirst = new ArrayList<List<Exprent>>();
-    List<MethodWrapper> lstMethodWrappers = new ArrayList<MethodWrapper>();
+    List<List<Exprent>> lstFirst = new ArrayList<>();
+    List<MethodWrapper> lstMethodWrappers = new ArrayList<>();
 
     for (MethodWrapper method : wrapper.getMethods()) {
       if (CodeConstants.INIT_NAME.equals(method.methodStruct.getName()) && method.root != null) { // successfully decompiled constructor

File: src/org/jetbrains/java/decompiler/main/collectors/BytecodeMappingTracer.java
Patch:
@@ -25,7 +25,7 @@ public class BytecodeMappingTracer {
 
   private int currentSourceLine;
   private StructLineNumberTableAttribute lineNumberTable = null;
-  private final Map<Integer, Integer> mapping = new HashMap<Integer, Integer>();  // bytecode offset, source line
+  private final Map<Integer, Integer> mapping = new HashMap<>();  // bytecode offset, source line
 
   public BytecodeMappingTracer() { }
 
@@ -81,7 +81,7 @@ public void setLineNumberTable(StructLineNumberTableAttribute lineNumberTable) {
     this.lineNumberTable = lineNumberTable;
   }
 
-  private final Set<Integer> unmappedLines = new HashSet<Integer>();
+  private final Set<Integer> unmappedLines = new HashSet<>();
 
   public Set<Integer> getUnmappedLines() {
     return unmappedLines;
@@ -92,7 +92,7 @@ public Map<Integer, Integer> getOriginalLinesMapping() {
       return Collections.emptyMap();
     }
 
-    Map<Integer, Integer> res = new HashMap<Integer, Integer>();
+    Map<Integer, Integer> res = new HashMap<>();
 
     // first match offsets from line number table
     int[] data = lineNumberTable.getRawData();

File: src/org/jetbrains/java/decompiler/main/collectors/VarNamesCollector.java
Patch:
@@ -20,7 +20,7 @@
 
 public class VarNamesCollector {
 
-  private final Set<String> usedNames = new HashSet<String>();
+  private final Set<String> usedNames = new HashSet<>();
 
   public VarNamesCollector() { }
 

File: src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java
Patch:
@@ -78,7 +78,7 @@ public boolean hasLambda(ClassNode node) throws IOException {
       return false; // no lambda bootstrap constant found
     }
 
-    Map<String, String> mapMethodsLambda = new HashMap<String, String>();
+    Map<String, String> mapMethodsLambda = new HashMap<>();
 
     // iterate over code and find invocations of bootstrap methods. Replace them with anonymous classes.
     for (StructMethod mt : cl.getMethods()) {

File: src/org/jetbrains/java/decompiler/main/rels/MethodWrapper.java
Patch:
@@ -31,7 +31,7 @@ public class MethodWrapper {
   public final VarProcessor varproc;
   public final StructMethod methodStruct;
   public final CounterContainer counter;
-  public final HashSet<String> setOuterVarNames = new HashSet<String>();
+  public final HashSet<String> setOuterVarNames = new HashSet<>();
 
   public DirectGraph graph;
   public List<VarVersionPair> signatureFields;

File: src/org/jetbrains/java/decompiler/main/rels/NestedMemberAccess.java
Patch:
@@ -36,7 +36,7 @@ public class NestedMemberAccess {
   private enum MethodAccess {NORMAL, FIELD_GET, FIELD_SET, METHOD, FUNCTION}
 
   private boolean noSynthFlag;
-  private final Map<MethodWrapper, MethodAccess> mapMethodType = new HashMap<MethodWrapper, MethodAccess>();
+  private final Map<MethodWrapper, MethodAccess> mapMethodType = new HashMap<>();
 
 
   public void propagateMemberAccess(ClassNode root) {
@@ -231,8 +231,8 @@ private void eliminateStaticAccess(ClassNode node) {
 
         DirectGraph graph = meth.getOrBuildGraph();
 
-        HashSet<DirectNode> setVisited = new HashSet<DirectNode>();
-        LinkedList<DirectNode> stack = new LinkedList<DirectNode>();
+        HashSet<DirectNode> setVisited = new HashSet<>();
+        LinkedList<DirectNode> stack = new LinkedList<>();
         stack.add(graph.first);
 
         while (!stack.isEmpty()) {  // TODO: replace with interface iterator?

File: src/org/jetbrains/java/decompiler/modules/decompiler/ClearStructHelper.java
Patch:
@@ -25,7 +25,7 @@ public class ClearStructHelper {
 
   public static void clearStatements(RootStatement root) {
 
-    LinkedList<Statement> stack = new LinkedList<Statement>();
+    LinkedList<Statement> stack = new LinkedList<>();
     stack.add(root);
 
     while (!stack.isEmpty()) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/ConcatenationHelper.java
Patch:
@@ -70,7 +70,7 @@ else if ("makeConcatWithConstants".equals(iex.getName())) { // java 9 style
 
 
     // iterate in depth, collecting possible operands
-    List<Exprent> lstOperands = new ArrayList<Exprent>();
+    List<Exprent> lstOperands = new ArrayList<>();
 
     while (true) {
 
@@ -160,7 +160,7 @@ private static List<Exprent> extractParameters(List<PooledConstant> bootstrapArg
       if (constant.type == CodeConstants.CONSTANT_String) {
         String recipe = ((PrimitiveConstant)constant).getString();
 
-        List<Exprent> res = new ArrayList<Exprent>();
+        List<Exprent> res = new ArrayList<>();
         StringBuilder acc = new StringBuilder();
         int parameterId = 0;
         for (int i = 0; i < recipe.length(); i++) {
@@ -195,7 +195,7 @@ private static List<Exprent> extractParameters(List<PooledConstant> bootstrapArg
         return res;
       }
     }
-    return new ArrayList<Exprent>(parameters);
+    return new ArrayList<>(parameters);
   }
 
   private static boolean isAppendConcat(InvocationExprent expr, VarType cltype) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExitHelper.java
Patch:
@@ -61,7 +61,7 @@ private static void cleanUpUnreachableBlocks(Statement stat) {
               set.remove(secondlast);
 
               if (set.isEmpty()) {
-                last.setExprents(new ArrayList<Exprent>());
+                last.setExprents(new ArrayList<>());
                 found = true;
                 break;
               }

File: src/org/jetbrains/java/decompiler/modules/decompiler/InlineSingleBlockHelper.java
Patch:
@@ -68,7 +68,7 @@ private static void inlineBlock(SequenceStatement seq, int index) {
     Statement parent = source.getParent();
     source.removeSuccessor(edge);
 
-    List<Statement> lst = new ArrayList<Statement>();
+    List<Statement> lst = new ArrayList<>();
     for (int i = seq.getStats().size() - 1; i >= index; i--) {
       lst.add(0, seq.getStats().remove(i));
     }

File: src/org/jetbrains/java/decompiler/modules/decompiler/LoopExtractHelper.java
Patch:
@@ -189,7 +189,7 @@ private static void extractIfBlock(DoStatement loop, IfStatement ifstat) {
 
     loop.addSuccessor(new StatEdge(StatEdge.TYPE_REGULAR, loop, target));
 
-    for (StatEdge edge : new ArrayList<StatEdge>(block.getLabelEdges())) {
+    for (StatEdge edge : new ArrayList<>(block.getLabelEdges())) {
       if (edge.getType() == StatEdge.TYPE_CONTINUE || edge == ifedge) {
         loop.addLabeledEdge(edge);
       }

File: src/org/jetbrains/java/decompiler/modules/decompiler/MergeHelper.java
Patch:
@@ -185,7 +185,7 @@ private static boolean matchWhile(DoStatement stat) {
               if (firstif == stat.getFirst()) {
                 BasicBlockStatement bstat = new BasicBlockStatement(new BasicBlock(
                   DecompilerContext.getCounterContainer().getCounterAndIncrement(CounterContainer.STATEMENT_COUNTER)));
-                bstat.setExprents(new ArrayList<Exprent>());
+                bstat.setExprents(new ArrayList<>());
                 stat.replaceStatement(firstif, bstat);
               }
               else {
@@ -224,7 +224,7 @@ private static boolean matchWhile(DoStatement stat) {
               if (firstif.getIfstat() == null) {
                 BasicBlockStatement bstat = new BasicBlockStatement(new BasicBlock(
                   DecompilerContext.getCounterContainer().getCounterAndIncrement(CounterContainer.STATEMENT_COUNTER)));
-                bstat.setExprents(new ArrayList<Exprent>());
+                bstat.setExprents(new ArrayList<>());
 
                 ifedge.setSource(bstat);
                 bstat.addSuccessor(ifedge);
@@ -382,7 +382,7 @@ private static void removeLastEmptyStatement(DoStatement dostat, Statement stat)
     if (stat == dostat.getFirst()) {
       BasicBlockStatement bstat = new BasicBlockStatement(new BasicBlock(
         DecompilerContext.getCounterContainer().getCounterAndIncrement(CounterContainer.STATEMENT_COUNTER)));
-      bstat.setExprents(new ArrayList<Exprent>());
+      bstat.setExprents(new ArrayList<>());
       dostat.replaceStatement(stat, bstat);
     }
     else {

File: src/org/jetbrains/java/decompiler/modules/decompiler/PPandMMHelper.java
Patch:
@@ -38,10 +38,10 @@ public boolean findPPandMM(RootStatement root) {
     FlattenStatementsHelper flatthelper = new FlattenStatementsHelper();
     DirectGraph dgraph = flatthelper.buildDirectGraph(root);
 
-    LinkedList<DirectNode> stack = new LinkedList<DirectNode>();
+    LinkedList<DirectNode> stack = new LinkedList<>();
     stack.add(dgraph.first);
 
-    HashSet<DirectNode> setVisited = new HashSet<DirectNode>();
+    HashSet<DirectNode> setVisited = new HashSet<>();
 
     boolean res = false;
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/PrimitiveExprsList.java
Patch:
@@ -22,7 +22,7 @@
 
 public class PrimitiveExprsList {
 
-  private final List<Exprent> lstExprents = new ArrayList<Exprent>();
+  private final List<Exprent> lstExprents = new ArrayList<>();
 
   private ExprentStack stack = new ExprentStack();
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/SequenceHelper.java
Patch:
@@ -39,7 +39,7 @@ private static void condenseSequencesRec(Statement stat) {
 
     if (stat.type == Statement.TYPE_SEQUENCE) {
 
-      List<Statement> lst = new ArrayList<Statement>();
+      List<Statement> lst = new ArrayList<>();
       lst.addAll(stat.getStats());
 
       boolean unfolded = false;
@@ -84,7 +84,7 @@ private static void condenseSequencesRec(Statement stat) {
               st.removeSuccessor(edge);
             }
 
-            for (StatEdge edge : new HashSet<StatEdge>(st.getLabelEdges())) {
+            for (StatEdge edge : new HashSet<>(st.getLabelEdges())) {
               if (edge.getSource() != last) {
                 last.addLabeledEdge(edge);
               }
@@ -302,7 +302,7 @@ public static void destroyAndFlattenStatement(Statement stat) {
     BasicBlockStatement bstat = new BasicBlockStatement(new BasicBlock(
       DecompilerContext.getCounterContainer().getCounterAndIncrement(CounterContainer.STATEMENT_COUNTER)));
     if (stat.getExprents() == null) {
-      bstat.setExprents(new ArrayList<Exprent>());
+      bstat.setExprents(new ArrayList<>());
     }
     else {
       bstat.setExprents(DecHelper.copyExprentList(stat.getExprents()));

File: src/org/jetbrains/java/decompiler/modules/decompiler/StatEdge.java
Patch:
@@ -66,7 +66,7 @@ public StatEdge(int type, Statement source, Statement destination) {
   public StatEdge(Statement source, Statement destination, List<String> exceptions) {
     this(TYPE_EXCEPTION, source, destination);
     if (exceptions != null) {
-      this.exceptions = new ArrayList<String>(exceptions);
+      this.exceptions = new ArrayList<>(exceptions);
     }
   }
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/decompose/DominatorEngine.java
Patch:
@@ -25,7 +25,7 @@ public class DominatorEngine {
 
   private final Statement statement;
 
-  private final VBStyleCollection<Integer, Integer> colOrderedIDoms = new VBStyleCollection<Integer, Integer>();
+  private final VBStyleCollection<Integer, Integer> colOrderedIDoms = new VBStyleCollection<>();
 
 
   public DominatorEngine(Statement statement) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/decompose/GenericDominatorEngine.java
Patch:
@@ -24,7 +24,7 @@ public class GenericDominatorEngine {
 
   private final IGraph graph;
 
-  private final VBStyleCollection<IGraphNode, IGraphNode> colOrderedIDoms = new VBStyleCollection<IGraphNode, IGraphNode>();
+  private final VBStyleCollection<IGraphNode, IGraphNode> colOrderedIDoms = new VBStyleCollection<>();
 
   private Set<? extends IGraphNode> setRoots;
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/ArrayExprent.java
Patch:
@@ -68,7 +68,7 @@ public CheckTypesResult checkExprTypeBounds() {
   }
 
   public List<Exprent> getAllExprents() {
-    List<Exprent> lst = new ArrayList<Exprent>();
+    List<Exprent> lst = new ArrayList<>();
     lst.add(array);
     lst.add(index);
     return lst;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java
Patch:
@@ -87,7 +87,7 @@ else if (typeLeft.typeFamily < typeRight.typeFamily) {
 
   @Override
   public List<Exprent> getAllExprents() {
-    List<Exprent> lst = new ArrayList<Exprent>();
+    List<Exprent> lst = new ArrayList<>();
     lst.add(left);
     lst.add(right);
     return lst;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/ConstExprent.java
Patch:
@@ -110,7 +110,7 @@ public int getExprentUse() {
   }
 
   public List<Exprent> getAllExprents() {
-    return new ArrayList<Exprent>();
+    return new ArrayList<>();
   }
 
   @Override

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java
Patch:
@@ -70,7 +70,7 @@ public CheckTypesResult checkExprTypeBounds() {
 
   @Override
   public List<Exprent> getAllExprents() {
-    List<Exprent> lst = new ArrayList<Exprent>();
+    List<Exprent> lst = new ArrayList<>();
     if (value != null) {
       lst.add(value);
     }

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
Patch:
@@ -76,7 +76,7 @@ public CheckTypesResult checkExprTypeBounds() {
   }
 
   public boolean containsExprent(Exprent exprent) {
-    List<Exprent> listTemp = new ArrayList<Exprent>(getAllExprents(true));
+    List<Exprent> listTemp = new ArrayList<>(getAllExprents(true));
     listTemp.add(this);
 
     for (Exprent lstExpr : listTemp) {
@@ -102,7 +102,7 @@ public Set<VarVersionPair> getAllVariables() {
     List<Exprent> lstAllExprents = getAllExprents(true);
     lstAllExprents.add(this);
 
-    Set<VarVersionPair> set = new HashSet<VarVersionPair>();
+    Set<VarVersionPair> set = new HashSet<>();
     for (Exprent expr : lstAllExprents) {
       if (expr.type == EXPRENT_VAR) {
         set.add(new VarVersionPair((VarExprent)expr));
@@ -128,7 +128,7 @@ public void replaceExprent(Exprent oldExpr, Exprent newExpr) { }
   public void addBytecodeOffsets(Collection<Integer> bytecodeOffsets) {
     if (bytecodeOffsets != null && !bytecodeOffsets.isEmpty()) {
       if (bytecode == null) {
-        bytecode = new HashSet<Integer>(bytecodeOffsets);
+        bytecode = new HashSet<>(bytecodeOffsets);
       }
       else {
         bytecode.addAll(bytecodeOffsets);

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java
Patch:
@@ -71,7 +71,7 @@ public int getExprentUse() {
 
   @Override
   public List<Exprent> getAllExprents() {
-    List<Exprent> lst = new ArrayList<Exprent>();
+    List<Exprent> lst = new ArrayList<>();
     if (instance != null) {
       lst.add(instance);
     }

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/IfExprent.java
Patch:
@@ -107,7 +107,7 @@ public Exprent copy() {
 
   @Override
   public List<Exprent> getAllExprents() {
-    List<Exprent> lst = new ArrayList<Exprent>();
+    List<Exprent> lst = new ArrayList<>();
     lst.add(condition);
     return lst;
   }

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/MonitorExprent.java
Patch:
@@ -46,7 +46,7 @@ public Exprent copy() {
 
   @Override
   public List<Exprent> getAllExprents() {
-    List<Exprent> lst = new ArrayList<Exprent>();
+    List<Exprent> lst = new ArrayList<>();
     lst.add(value);
     return lst;
   }

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
Patch:
@@ -67,7 +67,7 @@ public int getExprentUse() {
 
   @Override
   public List<Exprent> getAllExprents() {
-    return new ArrayList<Exprent>();
+    return new ArrayList<>();
   }
 
   @Override

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/DirectNode.java
Patch:
@@ -40,11 +40,11 @@ public class DirectNode {
 
   public final Statement statement;
 
-  public List<Exprent> exprents = new ArrayList<Exprent>();
+  public List<Exprent> exprents = new ArrayList<>();
 
-  public final List<DirectNode> succs = new ArrayList<DirectNode>();
+  public final List<DirectNode> succs = new ArrayList<>();
 
-  public final List<DirectNode> preds = new ArrayList<DirectNode>();
+  public final List<DirectNode> preds = new ArrayList<>();
 
   public DirectNode(int type, Statement statement, String id) {
     this.type = type;

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchAllStatement.java
Patch:
@@ -40,7 +40,7 @@ public class CatchAllStatement extends Statement {
 
   private VarExprent monitor;
 
-  private final List<VarExprent> vars = new ArrayList<VarExprent>();
+  private final List<VarExprent> vars = new ArrayList<>();
 
   // *****************************************************************************
   // constructors

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/DummyExitStatement.java
Patch:
@@ -32,7 +32,7 @@ public DummyExitStatement() {
   public void addBytecodeOffsets(Collection<Integer> bytecodeOffsets) {
     if (bytecodeOffsets != null && !bytecodeOffsets.isEmpty()) {
       if (bytecode == null) {
-        bytecode = new HashSet<Integer>(bytecodeOffsets);
+        bytecode = new HashSet<>(bytecodeOffsets);
       }
       else {
         bytecode.addAll(bytecodeOffsets);

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/GeneralStatement.java
Patch:
@@ -39,7 +39,7 @@ public GeneralStatement(Statement head, Collection<Statement> statements, Statem
     first = head;
     stats.addWithKey(head, head.id);
 
-    HashSet<Statement> set = new HashSet<Statement>(statements);
+    HashSet<Statement> set = new HashSet<>(statements);
     set.remove(head);
 
     for (Statement st : set) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/IfStatement.java
Patch:
@@ -52,7 +52,7 @@ public class IfStatement extends Statement {
 
   private boolean iffflag;
 
-  private final List<Exprent> headexprent = new ArrayList<Exprent>(); // contains IfExprent
+  private final List<Exprent> headexprent = new ArrayList<>(); // contains IfExprent
 
   // *****************************************************************************
   // constructors
@@ -181,7 +181,7 @@ public static Statement isHead(Statement head) {
 
       boolean ok = (regsize < 2);
       if (!ok) {
-        List<Statement> lst = new ArrayList<Statement>();
+        List<Statement> lst = new ArrayList<>();
         if (DecHelper.isChoiceStatement(head, lst)) {
           p = lst.remove(0);
 
@@ -295,7 +295,7 @@ public void initExprents() {
 
   public List<Object> getSequentialObjects() {
 
-    List<Object> lst = new ArrayList<Object>(stats);
+    List<Object> lst = new ArrayList<>(stats);
     lst.add(1, headexprent.get(0));
 
     return lst;

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/SynchronizedStatement.java
Patch:
@@ -32,7 +32,7 @@ public class SynchronizedStatement extends Statement {
 
   private Statement body;
 
-  private final List<Exprent> headexprent = new ArrayList<Exprent>();
+  private final List<Exprent> headexprent = new ArrayList<>();
 
   // *****************************************************************************
   // constructors
@@ -106,7 +106,7 @@ public void initExprents() {
 
   public List<Object> getSequentialObjects() {
 
-    List<Object> lst = new ArrayList<Object>(stats);
+    List<Object> lst = new ArrayList<>(stats);
     lst.add(1, headexprent.get(0));
 
     return lst;

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/CheckTypesResult.java
Patch:
@@ -23,9 +23,9 @@
 
 public class CheckTypesResult {
 
-  private final List<ExprentTypePair> lstMaxTypeExprents = new ArrayList<ExprentTypePair>();
+  private final List<ExprentTypePair> lstMaxTypeExprents = new ArrayList<>();
 
-  private final List<ExprentTypePair> lstMinTypeExprents = new ArrayList<ExprentTypePair>();
+  private final List<ExprentTypePair> lstMinTypeExprents = new ArrayList<>();
 
   public void addMaxTypeExprent(Exprent exprent, VarType type) {
     lstMaxTypeExprents.add(new ExprentTypePair(exprent, type, null));

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionNode.java
Patch:
@@ -31,9 +31,9 @@ public class VarVersionNode implements IGraphNode {
 
   public final int version;
 
-  public final Set<VarVersionEdge> succs = new HashSet<VarVersionEdge>();
+  public final Set<VarVersionEdge> succs = new HashSet<>();
 
-  public final Set<VarVersionEdge> preds = new HashSet<VarVersionEdge>();
+  public final Set<VarVersionEdge> preds = new HashSet<>();
 
   public int flags;
 
@@ -50,7 +50,7 @@ public VarVersionPair getVarPaar() {
   }
 
   public List<IGraphNode> getPredecessors() {
-    List<IGraphNode> lst = new ArrayList<IGraphNode>(preds.size());
+    List<IGraphNode> lst = new ArrayList<>(preds.size());
     for (VarVersionEdge edge : preds) {
       lst.add(edge.source);
     }

File: src/org/jetbrains/java/decompiler/modules/renamer/ClassWrapperNode.java
Patch:
@@ -26,7 +26,7 @@ public class ClassWrapperNode {
 
   private ClassWrapperNode superclass;
 
-  private final List<ClassWrapperNode> subclasses = new ArrayList<ClassWrapperNode>();
+  private final List<ClassWrapperNode> subclasses = new ArrayList<>();
 
   public ClassWrapperNode(StructClass cl) {
     this.classStruct = cl;

File: src/org/jetbrains/java/decompiler/modules/renamer/ConverterHelper.java
Patch:
@@ -23,20 +23,20 @@
 
 public class ConverterHelper implements IIdentifierRenamer {
 
-  private static final Set<String> KEYWORDS = new HashSet<String>(Arrays.asList(
+  private static final Set<String> KEYWORDS = new HashSet<>(Arrays.asList(
     "abstract", "do", "if", "package", "synchronized", "boolean", "double", "implements", "private", "this", "break", "else", "import",
     "protected", "throw", "byte", "extends", "instanceof", "public", "throws", "case", "false", "int", "return", "transient", "catch",
     "final", "interface", "short", "true", "char", "finally", "long", "static", "try", "class", "float", "native", "strictfp", "void",
     "const", "for", "new", "super", "volatile", "continue", "goto", "null", "switch", "while", "default", "assert", "enum"));
-  private static final Set<String> RESERVED_WINDOWS_NAMESPACE = new HashSet<String>(Arrays.asList(
+  private static final Set<String> RESERVED_WINDOWS_NAMESPACE = new HashSet<>(Arrays.asList(
     "aux", "prn", "aux", "nul",
     "com1", "com2", "com3", "com4", "com5", "com6", "com7", "com8", "com9",
     "lpt1", "lpt2", "lpt3", "lpt4", "lpt5", "lpt6", "lpt7", "lpt8", "lpt9"));
 
   private int classCounter = 0;
   private int fieldCounter = 0;
   private int methodCounter = 0;
-  private final Set<String> setNonStandardClassNames = new HashSet<String>();
+  private final Set<String> setNonStandardClassNames = new HashSet<>();
 
   @Override
   public boolean toBeRenamed(Type elementType, String className, String element, String descriptor) {

File: src/org/jetbrains/java/decompiler/modules/renamer/PoolInterceptor.java
Patch:
@@ -23,9 +23,9 @@ public class PoolInterceptor {
 
   private final IIdentifierRenamer helper;
 
-  private final HashMap<String, String> mapOldToNewNames = new HashMap<String, String>();
+  private final HashMap<String, String> mapOldToNewNames = new HashMap<>();
 
-  private final HashMap<String, String> mapNewToOldNames = new HashMap<String, String>();
+  private final HashMap<String, String> mapNewToOldNames = new HashMap<>();
 
   public PoolInterceptor(IIdentifierRenamer helper) {
     this.helper = helper;

File: src/org/jetbrains/java/decompiler/struct/StructClass.java
Patch:
@@ -93,15 +93,15 @@ public StructClass(DataInputFullStream in, boolean own, LazyLoader loader) throw
 
     // fields
     length = in.readUnsignedShort();
-    fields = new VBStyleCollection<StructField, String>();
+    fields = new VBStyleCollection<>();
     for (int i = 0; i < length; i++) {
       StructField field = new StructField(in, this);
       fields.addWithKey(field, InterpreterUtil.makeUniqueKey(field.getName(), field.getDescriptor()));
     }
 
     // methods
     length = in.readUnsignedShort();
-    methods = new VBStyleCollection<StructMethod, String>();
+    methods = new VBStyleCollection<>();
     for (int i = 0; i < length; i++) {
       StructMethod method = new StructMethod(in, this);
       methods.addWithKey(method, InterpreterUtil.makeUniqueKey(method.getName(), method.getDescriptor()));

File: src/org/jetbrains/java/decompiler/struct/StructContext.java
Patch:
@@ -35,8 +35,8 @@ public class StructContext {
   private final IResultSaver saver;
   private final IDecompiledData decompiledData;
   private final LazyLoader loader;
-  private final Map<String, ContextUnit> units = new HashMap<String, ContextUnit>();
-  private final Map<String, StructClass> classes = new HashMap<String, StructClass>();
+  private final Map<String, ContextUnit> units = new HashMap<>();
+  private final Map<String, StructClass> classes = new HashMap<>();
 
   public StructContext(IResultSaver saver, IDecompiledData decompiledData, LazyLoader loader) {
     this.saver = saver;

File: src/org/jetbrains/java/decompiler/struct/StructMember.java
Patch:
@@ -47,7 +47,7 @@ public boolean isSynthetic() {
   }
 
   protected VBStyleCollection<StructGeneralAttribute, String> readAttributes(DataInputFullStream in, ConstantPool pool) throws IOException {
-    VBStyleCollection<StructGeneralAttribute, String> attributes = new VBStyleCollection<StructGeneralAttribute, String>();
+    VBStyleCollection<StructGeneralAttribute, String> attributes = new VBStyleCollection<>();
 
     int length = in.readUnsignedShort();
     for (int i = 0; i < length; i++) {

File: src/org/jetbrains/java/decompiler/struct/StructMethod.java
Patch:
@@ -119,7 +119,7 @@ public void releaseResources() throws IOException {
 
   @SuppressWarnings("AssignmentToForLoopParameter")
   private InstructionSequence parseBytecode(DataInputFullStream in, int length, ConstantPool pool) throws IOException {
-    VBStyleCollection<Instruction, Integer> instructions = new VBStyleCollection<Instruction, Integer>();
+    VBStyleCollection<Instruction, Integer> instructions = new VBStyleCollection<>();
 
     int bytecode_version = classStruct.getBytecodeVersion();
 
@@ -137,7 +137,7 @@ private InstructionSequence parseBytecode(DataInputFullStream in, int length, Co
         opcode = in.readUnsignedByte();
       }
 
-      List<Integer> operands = new ArrayList<Integer>();
+      List<Integer> operands = new ArrayList<>();
 
       if (opcode >= opc_iconst_m1 && opcode <= opc_iconst_5) {
         operands.add(new Integer(opr_iconst[opcode - opc_iconst_m1]));
@@ -331,7 +331,7 @@ else if (opcode >= opc_invokevirtual && opcode <= opc_invokestatic) {
     }
 
     // initialize exception table
-    List<ExceptionHandler> lstHandlers = new ArrayList<ExceptionHandler>();
+    List<ExceptionHandler> lstHandlers = new ArrayList<>();
 
     int exception_count = in.readUnsignedShort();
     for (int i = 0; i < exception_count; i++) {

File: src/org/jetbrains/java/decompiler/struct/attr/StructAnnotationParameterAttribute.java
Patch:
@@ -34,7 +34,7 @@ public void initContent(ConstantPool pool) throws IOException {
 
     int len = data.readUnsignedByte();
     if (len > 0) {
-      paramAnnotations = new ArrayList<List<AnnotationExprent>>(len);
+      paramAnnotations = new ArrayList<>(len);
       for (int i = 0; i < len; i++) {
         List<AnnotationExprent> annotations = StructAnnotationAttribute.parseAnnotations(pool, data);
         paramAnnotations.add(annotations);

File: src/org/jetbrains/java/decompiler/struct/attr/StructBootstrapMethodsAttribute.java
Patch:
@@ -26,8 +26,8 @@
 
 public class StructBootstrapMethodsAttribute extends StructGeneralAttribute {
 
-  private final List<LinkConstant> methodRefs = new ArrayList<LinkConstant>();
-  private final List<List<PooledConstant>> methodArguments = new ArrayList<List<PooledConstant>>();
+  private final List<LinkConstant> methodRefs = new ArrayList<>();
+  private final List<List<PooledConstant>> methodArguments = new ArrayList<>();
 
   @Override
   public void initContent(ConstantPool pool) throws IOException {
@@ -39,7 +39,7 @@ public void initContent(ConstantPool pool) throws IOException {
       int bootstrap_method_ref = data.readUnsignedShort();
       int num_bootstrap_arguments = data.readUnsignedShort();
 
-      List<PooledConstant> list_arguments = new ArrayList<PooledConstant>();
+      List<PooledConstant> list_arguments = new ArrayList<>();
 
       for (int j = 0; j < num_bootstrap_arguments; ++j) {
         int bootstrap_argument_ref = data.readUnsignedShort();

File: src/org/jetbrains/java/decompiler/struct/attr/StructExceptionsAttribute.java
Patch:
@@ -32,7 +32,7 @@ public void initContent(ConstantPool pool) throws IOException {
     DataInputStream data = stream();
     int len = data.readUnsignedShort();
     if (len > 0) {
-      throwsExceptions = new ArrayList<Integer>(len);
+      throwsExceptions = new ArrayList<>(len);
       for (int i = 0; i < len; i++) {
         throwsExceptions.add(data.readUnsignedShort());
       }

File: src/org/jetbrains/java/decompiler/struct/attr/StructInnerClassesAttribute.java
Patch:
@@ -52,7 +52,7 @@ public void initContent(ConstantPool pool) throws IOException {
 
     int len = data.readUnsignedShort();
     if (len > 0) {
-      entries = new ArrayList<Entry>(len);
+      entries = new ArrayList<>(len);
 
       for (int i = 0; i < len; i++) {
         int innerNameIdx = data.readUnsignedShort();

File: src/org/jetbrains/java/decompiler/struct/attr/StructLocalVariableTableAttribute.java
Patch:
@@ -43,7 +43,7 @@ public void initContent(ConstantPool pool) throws IOException {
 
     int len = data.readUnsignedShort();
     if (len > 0) {
-      mapVarNames = new HashMap<Integer, String>(len);
+      mapVarNames = new HashMap<>(len);
       for (int i = 0; i < len; i++) {
         data.discard(4);
         int nameIndex = data.readUnsignedShort();

File: src/org/jetbrains/java/decompiler/struct/consts/ConstantPool.java
Patch:
@@ -40,7 +40,7 @@ public class ConstantPool implements NewClassNameBuilder {
 
   public ConstantPool(DataInputStream in) throws IOException {
     int size = in.readUnsignedShort();
-    pool = new ArrayList<PooledConstant>(size);
+    pool = new ArrayList<>(size);
     BitSet[] nextPass = {new BitSet(size), new BitSet(size), new BitSet(size)};
 
     // first dummy constant

File: src/org/jetbrains/java/decompiler/struct/gen/DataPoint.java
Patch:
@@ -24,9 +24,9 @@
 
 public class DataPoint {
 
-  private List<VarType> localVariables = new ArrayList<VarType>();
+  private List<VarType> localVariables = new ArrayList<>();
 
-  private ListStack<VarType> stack = new ListStack<VarType>();
+  private ListStack<VarType> stack = new ListStack<>();
 
 
   public void setVariable(int index, VarType value) {
@@ -53,7 +53,7 @@ else if (index < 0) {
 
   public DataPoint copy() {
     DataPoint point = new DataPoint();
-    point.setLocalVariables(new ArrayList<VarType>(localVariables));
+    point.setLocalVariables(new ArrayList<>(localVariables));
     point.setStack(stack.clone());
     return point;
   }

File: src/org/jetbrains/java/decompiler/struct/gen/MethodDescriptor.java
Patch:
@@ -41,7 +41,7 @@ public static MethodDescriptor parseDescriptor(String descriptor) {
 
     if (parenth > 1) {
       String parameters = descriptor.substring(1, parenth);
-      List<String> lst = new ArrayList<String>();
+      List<String> lst = new ArrayList<>();
 
       int indexFrom = -1, ind, len = parameters.length(), index = 0;
       while (index < len) {

File: src/org/jetbrains/java/decompiler/struct/gen/generics/GenericClassDescriptor.java
Patch:
@@ -22,9 +22,9 @@ public class GenericClassDescriptor {
 
   public GenericType superclass;
 
-  public final List<GenericType> superinterfaces = new ArrayList<GenericType>();
+  public final List<GenericType> superinterfaces = new ArrayList<>();
 
-  public final List<String> fparameters = new ArrayList<String>();
+  public final List<String> fparameters = new ArrayList<>();
 
-  public final List<List<GenericType>> fbounds = new ArrayList<List<GenericType>>();
+  public final List<List<GenericType>> fbounds = new ArrayList<>();
 }

File: src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java
Patch:
@@ -142,7 +142,7 @@ private static String parseFormalParameters(String signature, List<String> param
       String param = value.substring(0, to);
       value = value.substring(to + 1);
 
-      List<GenericType> lstBounds = new ArrayList<GenericType>();
+      List<GenericType> lstBounds = new ArrayList<>();
 
       while (true) {
         if (value.charAt(0) == ':') {

File: src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
Patch:
@@ -32,9 +32,9 @@ public class GenericType {
   public final int arrayDim;
   public final String value;
 
-  private final List<GenericType> enclosingClasses = new ArrayList<GenericType>();
-  private final List<GenericType> arguments = new ArrayList<GenericType>();
-  private final List<Integer> wildcards = new ArrayList<Integer>();
+  private final List<GenericType> enclosingClasses = new ArrayList<>();
+  private final List<GenericType> arguments = new ArrayList<>();
+  private final List<Integer> wildcards = new ArrayList<>();
 
   public GenericType(int type, int arrayDim, String value) {
     this.type = type;

File: src/org/jetbrains/java/decompiler/struct/lazy/LazyLoader.java
Patch:
@@ -27,7 +27,7 @@
 
 public class LazyLoader {
 
-  private final Map<String, Link> mapClassLinks = new HashMap<String, Link>();
+  private final Map<String, Link> mapClassLinks = new HashMap<>();
   private final IBytecodeProvider provider;
 
   public LazyLoader(IBytecodeProvider provider) {

File: src/org/jetbrains/java/decompiler/struct/match/MatchNode.java
Patch:
@@ -48,9 +48,9 @@ public String toString() {
   
   private final int type;
   
-  private final Map<MatchProperties, RuleValue> rules = new HashMap<MatchProperties, RuleValue>();
+  private final Map<MatchProperties, RuleValue> rules = new HashMap<>();
   
-  private final List<MatchNode> children = new ArrayList<MatchNode>();
+  private final List<MatchNode> children = new ArrayList<>();
   
   
   public MatchNode(int type) {

File: src/org/jetbrains/java/decompiler/util/InterpreterUtil.java
Patch:
@@ -88,7 +88,7 @@ else if (c2 == null) {
       return false;
     }
 
-    HashSet<Object> set = new HashSet<Object>(c1);
+    HashSet<Object> set = new HashSet<>(c1);
     set.removeAll(c2);
     return (set.size() == 0);
   }

File: src/org/jetbrains/java/decompiler/util/ListStack.java
Patch:
@@ -30,7 +30,7 @@ public ListStack(ArrayList<T> list) {
   }
 
   public ListStack<T> clone() {
-    ListStack<T> newstack = new ListStack<T>(this);
+    ListStack<T> newstack = new ListStack<>(this);
     newstack.pointer = this.pointer;
     return newstack;
   }

File: src/org/jetbrains/java/decompiler/util/SFormsFastMapDirect.java
Patch:
@@ -353,7 +353,7 @@ public String toString() {
   }
 
   public List<Entry<Integer, FastSparseSet<Integer>>> entryList() {
-    List<Entry<Integer, FastSparseSet<Integer>>> list = new ArrayList<Entry<Integer, FastSparseSet<Integer>>>();
+    List<Entry<Integer, FastSparseSet<Integer>>> list = new ArrayList<>();
 
     for (int i = 2; i >= 0; i--) {
       int ikey = 0;

File: test/org/jetbrains/java/decompiler/DecompilerTestFixture.java
Patch:
@@ -52,7 +52,7 @@ public void setUp(String... optionPairs) throws IOException {
     targetDir = new File(tempDir, "decompiled");
     assertThat(targetDir.mkdirs()).isTrue();
 
-    Map<String, Object> options = new HashMap<String, Object>();
+    Map<String, Object> options = new HashMap<>();
     options.put(IFernflowerPreferences.LOG_LEVEL, "warn");
     options.put(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES, "1");
     options.put(IFernflowerPreferences.REMOVE_SYNTHETIC, "1");

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -118,7 +118,7 @@ private void doTest(String testFile, String... companionFiles) {
   }
 
   private static List<File> collectClasses(File classFile) {
-    List<File> files = new ArrayList<File>();
+    List<File> files = new ArrayList<>();
     files.add(classFile);
 
     File parent = classFile.getParentFile();

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -84,6 +84,7 @@ public void tearDown() {
   @Test public void testMethodReferenceLetterClass() { doTest("pkg/TestMethodReferenceLetterClass"); }
   @Test public void testMemberAnnotations() { doTest("pkg/TestMemberAnnotations"); }
   @Test public void testMoreAnnotations() { doTest("pkg/MoreAnnotations"); }
+  @Test public void testTypeAnnotations() { doTest("pkg/TypeAnnotations"); }
   @Test public void testStaticNameClash() { doTest("pkg/TestStaticNameClash"); }
   @Test public void testExtendingSubclass() { doTest("pkg/TestExtendingSubclass"); }
   @Test public void testSyntheticAccess() { doTest("pkg/TestSyntheticAccess"); }

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -816,7 +816,7 @@ else if (CodeConstants.CLINIT_NAME.equals(name)) {
           StructAnnDefaultAttribute attr = (StructAnnDefaultAttribute)mt.getAttributes().getWithKey("AnnotationDefault");
           if (attr != null) {
             buffer.append(" default ");
-            buffer.append(attr.getDefaultValue().toJava(indent + 1, new BytecodeMappingTracer())); // dummy tracer
+            buffer.append(attr.getDefaultValue().toJava(0, new BytecodeMappingTracer())); // dummy tracer
           }
         }
 
@@ -970,7 +970,6 @@ private static void appendAnnotations(TextBuffer buffer, StructMember mb, int in
     StructGeneralAttribute.ATTRIBUTE_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS};
 
   private static void appendParameterAnnotations(TextBuffer buffer, StructMethod mt, int param) {
-
     BytecodeMappingTracer tracer_dummy = new BytecodeMappingTracer(); // FIXME: replace with a real one
 
     for (String name : PARAMETER_ANNOTATION_ATTRIBUTES) {

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -83,6 +83,7 @@ public void tearDown() {
   @Test public void testMethodReferenceSameName() { doTest("pkg/TestMethodReferenceSameName"); }
   @Test public void testMethodReferenceLetterClass() { doTest("pkg/TestMethodReferenceLetterClass"); }
   @Test public void testMemberAnnotations() { doTest("pkg/TestMemberAnnotations"); }
+  @Test public void testMoreAnnotations() { doTest("pkg/MoreAnnotations"); }
   @Test public void testStaticNameClash() { doTest("pkg/TestStaticNameClash"); }
   @Test public void testExtendingSubclass() { doTest("pkg/TestExtendingSubclass"); }
   @Test public void testSyntheticAccess() { doTest("pkg/TestSyntheticAccess"); }

File: src/org/jetbrains/java/decompiler/main/InitializerProcessor.java
Patch:
@@ -117,7 +117,8 @@ private static void extractStaticInitializers(ClassWrapper wrapper, MethodWrappe
     StructClass cl = wrapper.getClassStruct();
     Statement firstData = Statements.findFirstData(root);
     if (firstData != null) {
-      boolean isInterface = cl.hasModifier(CodeConstants.ACC_INTERFACE);
+      boolean inlineInitializers = cl.hasModifier(CodeConstants.ACC_INTERFACE) || cl.hasModifier(CodeConstants.ACC_ENUM);
+
       while (!firstData.getExprents().isEmpty()) {
         Exprent exprent = firstData.getExprents().get(0);
 
@@ -131,8 +132,7 @@ private static void extractStaticInitializers(ClassWrapper wrapper, MethodWrappe
                 cl.hasField(fExpr.getName(), fExpr.getDescriptor().descriptorString)) {
 
               // interfaces fields should always be initialized inline
-              if (isInterface || isExprentIndependent(assignExpr.getRight(), method)) {
-
+              if (inlineInitializers || isExprentIndependent(assignExpr.getRight(), method)) {
                 String keyField = InterpreterUtil.makeUniqueKey(fExpr.getName(), fExpr.getDescriptor().descriptorString);
                 if (!wrapper.getStaticFieldInitializers().containsKey(keyField)) {
                   wrapper.getStaticFieldInitializers().addWithKey(assignExpr.getRight(), keyField);

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
Patch:
@@ -334,7 +334,7 @@ else if (isInstanceThis) {
     boolean firstParameter = true;
     int start = isEnum ? 2 : 0;
     for (int i = start; i < lstParameters.size(); i++) {
-      if (sigFields == null) {
+      if (sigFields == null || null == sigFields.get(i)) {
         if (!firstParameter) {
           buf.append(", ");
         }

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -84,6 +84,7 @@ public void tearDown() {
   @Test public void testMethodReferenceLetterClass() { doTest("pkg/TestMethodReferenceLetterClass"); }
   @Test public void testMemberAnnotations() { doTest("pkg/TestMemberAnnotations"); }
   @Test public void testStaticNameClash() { doTest("pkg/TestStaticNameClash"); }
+  @Test public void testExtendingSubclass() { doTest("pkg/TestExtendingSubclass"); }
 
   protected void doTest(String testFile, String... companionFiles) {
     ConsoleDecompiler decompiler = fixture.getDecompiler();
@@ -130,4 +131,4 @@ public boolean accept(File dir, String name) {
 
     return files;
   }
-}
\ No newline at end of file
+}

File: src/org/jetbrains/java/decompiler/code/cfg/BasicBlock.java
Patch:
@@ -118,7 +118,7 @@ public void removeSuccessor(BasicBlock block) {
     block.removePredecessor(this);
   }
 
-  // FIXME: unify block comparisons: id or direkt equality
+  // FIXME: unify block comparisons: id or direct equality
   public void replaceSuccessor(BasicBlock oldBlock, BasicBlock newBlock) {
     for (int i = 0; i < succs.size(); i++) {
       if (succs.get(i).id == oldBlock.id) {

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -54,7 +54,7 @@ public ClassWriter() {
     interceptor = DecompilerContext.getPoolInterceptor();
   }
 
-  private void invokeProcessors(ClassNode node) {
+  private static void invokeProcessors(ClassNode node) {
     ClassWrapper wrapper = node.getWrapper();
     StructClass cl = wrapper.getClassStruct();
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/BasicBlockStatement.java
Patch:
@@ -68,7 +68,9 @@ else if (instr.group == CodeConstants.GROUP_SWITCH) {
   // *****************************************************************************
 
   public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
-    return ExprProcessor.listToJava(varDefinitions, indent, tracer).append(ExprProcessor.listToJava(exprents, indent, tracer));
+    TextBuffer tb = ExprProcessor.listToJava(varDefinitions, indent, tracer);
+    tb.append(ExprProcessor.listToJava(exprents, indent, tracer));
+    return tb;
   }
 
   public Statement getSimpleCopy() {

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2000-2015 JetBrains s.r.o.
+ * Copyright 2000-2016 JetBrains s.r.o.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -98,7 +98,7 @@ public void classLambdaToJava(ClassNode node, TextBuffer buffer, Exprent method_
         }
         else {
           // reference to a static method
-          buffer.append(ExprProcessor.getCastTypeName(new VarType(node.lambdaInformation.content_class_name, false)));
+          buffer.append(ExprProcessor.getCastTypeName(new VarType(node.lambdaInformation.content_class_name, true)));
         }
 
         buffer.append("::");

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -80,6 +80,7 @@ public void tearDown() {
   @Test public void testStringConcat() { doTest("pkg/TestStringConcat"); }
   @Test public void testJava9StringConcat() { doTest("java9/TestJava9StringConcat"); }
   @Test public void testMethodReferenceSameName() { doTest("pkg/TestMethodReferenceSameName"); }
+  @Test public void testMethodReferenceLetterClass() { doTest("pkg/TestMethodReferenceLetterClass"); }
 
   protected void doTest(String testFile, String... companionFiles) {
     ConsoleDecompiler decompiler = fixture.getDecompiler();

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -79,6 +79,7 @@ public void tearDown() {
   @Test public void testShadowing() { doTest("pkg/TestShadowing", "pkg/Shadow", "ext/Shadow"); }
   @Test public void testStringConcat() { doTest("pkg/TestStringConcat"); }
   @Test public void testJava9StringConcat() { doTest("java9/TestJava9StringConcat"); }
+  @Test public void testMethodReferenceSameName() { doTest("pkg/TestMethodReferenceSameName"); }
 
   protected void doTest(String testFile, String... companionFiles) {
     ConsoleDecompiler decompiler = fixture.getDecompiler();

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -60,4 +60,5 @@ protected Map<String, Object> getDecompilerOptions() {
   @Test public void testInnerLocal() { doTest("pkg/TestInnerLocal"); }
   @Test public void testInnerLocalPkg() { doTest("pkg/TestInnerLocalPkg"); }
   @Test public void testInnerSignature() { doTest("pkg/TestInnerSignature"); }
+  @Test public void testParameterizedTypes() { doTest("pkg/TestParameterizedTypes"); }
 }

File: testData/src/pkg/TestSynchronizedMapping.java
Patch:
@@ -6,8 +6,9 @@
 public class TestSynchronizedMapping {
   public int test(int a) {
     synchronized (this) {
-      return a++;
+      a++;
     }
+    return a++;
   }
 
   public void test2(String a) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/IfExprent.java
Patch:
@@ -89,7 +89,7 @@ else if (ifType <= IF_NONNULL) {
       condition = stack.pop();
     }
     else {
-      condition = new FunctionExprent(FUNC_TYPES[ifType], stack, null);
+      condition = new FunctionExprent(FUNC_TYPES[ifType], stack, bytecodeOffsets);
     }
   }
 

File: src/org/jetbrains/java/decompiler/modules/code/DeadCodeHelper.java
Patch:
@@ -252,7 +252,7 @@ public static void removeGotos(ControlFlowGraph graph) {
       Instruction instr = block.getLastInstruction();
 
       if (instr != null && instr.opcode == CodeConstants.opc_goto) {
-        block.getSeq().removeInstruction(block.getSeq().length() - 1);
+        block.getSeq().removeLast();
       }
     }
 

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -58,5 +58,6 @@ protected Map<String, Object> getDecompilerOptions() {
   @Test public void testAnonymousClass() { doTest("pkg/TestAnonymousClass"); }
   @Test public void testThrowException() { doTest("pkg/TestThrowException"); }
   @Test public void testInnerLocal() { doTest("pkg/TestInnerLocal"); }
+  @Test public void testInnerLocalPkg() { doTest("pkg/TestInnerLocalPkg"); }
   @Test public void testInnerSignature() { doTest("pkg/TestInnerSignature"); }
 }

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/Statement.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2000-2014 JetBrains s.r.o.
+ * Copyright 2000-2015 JetBrains s.r.o.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -879,7 +879,7 @@ public IMatchable findObject(MatchNode matchNode, int index) {
     
     int node_type = matchNode.getType();
     
-    if(node_type == MatchNode.MATCHNODE_STATEMENT) {
+    if (node_type == MatchNode.MATCHNODE_STATEMENT && !this.stats.isEmpty()) {
       String position = (String)matchNode.getRuleValue(MatchProperties.STATEMENT_POSITION);
       if(position != null) {
         if(position.matches("-?\\d+")) {
@@ -888,7 +888,7 @@ public IMatchable findObject(MatchNode matchNode, int index) {
       } else if(index < this.stats.size()) { // use 'index' parameter
         return this.stats.get(index);
       }
-    } else if(node_type == MatchNode.MATCHNODE_EXPRENT && this.exprents != null) {
+    } else if(node_type == MatchNode.MATCHNODE_EXPRENT && this.exprents != null && !this.exprents.isEmpty()) {
       String position = (String)matchNode.getRuleValue(MatchProperties.EXPRENT_POSITION);
       if(position != null) {
         if(position.matches("-?\\d+")) {

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -58,4 +58,5 @@ protected Map<String, Object> getDecompilerOptions() {
   @Test public void testAnonymousClass() { doTest("pkg/TestAnonymousClass"); }
   @Test public void testThrowException() { doTest("pkg/TestThrowException"); }
   @Test public void testInnerLocal() { doTest("pkg/TestInnerLocal"); }
+  @Test public void testInnerSignature() { doTest("pkg/TestInnerSignature"); }
 }

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
Patch:
@@ -85,6 +85,7 @@ public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
     if (classDef) {
       ClassNode child = DecompilerContext.getClassProcessor().getMapRootClasses().get(varType.value);
       new ClassWriter().classToJava(child, buffer, indent, tracer);
+      tracer.incrementCurrentSourceLine(buffer.countLines());
     }
     else {
       String name = null;

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/IfStatement.java
Patch:
@@ -256,14 +256,13 @@ public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
         elseif = true;
       }
       else {
-        BytecodeMappingTracer else_tracer = new BytecodeMappingTracer(tracer.getCurrentSourceLine());
+        BytecodeMappingTracer else_tracer = new BytecodeMappingTracer(tracer.getCurrentSourceLine() + 1);
         TextBuffer content = ExprProcessor.jmpWrapper(elsestat, indent + 1, false, else_tracer);
 
         if (content.length() > 0) {
           buf.appendIndent(indent).append("} else {").appendLineSeparator();
 
-          else_tracer.shiftSourceLines(1);
-          tracer.setCurrentSourceLine(else_tracer.getCurrentSourceLine() + 1);
+          tracer.setCurrentSourceLine(else_tracer.getCurrentSourceLine());
           tracer.addTracer(else_tracer);
 
           buf.append(content);

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -782,6 +782,7 @@ else if ("<clinit>".equals(name)) {
 
         buffer.append(';');
         buffer.appendLineSeparator();
+        tracer.incrementCurrentSourceLine();
       }
       else {
         if (!clinit && !dinit) {

File: test/org/jetbrains/java/decompiler/BytecodeToSourceMappingTest.java
Patch:
@@ -26,9 +26,11 @@ public class BytecodeToSourceMappingTest extends SingleClassesTestBase {
   protected Map<String, Object> getDecompilerOptions() {
     return new HashMap<String, Object>() {{
       put(IFernflowerPreferences.BYTECODE_SOURCE_MAPPING, "1");
+      put(IFernflowerPreferences.DUMP_ORIGINAL_LINES, "1");
     }};
   }
 
   @Test public void testSimpleBytecodeMapping() { doTest("pkg/TestClassSimpleBytecodeMapping"); }
   @Test public void testSynchronizedMapping() { doTest("pkg/TestSynchronizedMapping"); }
+  @Test public void testAbstractMethods() { doTest("pkg/TestAbstractMethods"); }
 }

File: src/org/jetbrains/java/decompiler/main/EnumProcessor.java
Patch:
@@ -103,7 +103,7 @@ private static boolean isInvocationSuperConstructor(InvocationExprent inv, Metho
         VarExprent instvar = (VarExprent)inv.getInstance();
         VarVersionPaar varpaar = new VarVersionPaar(instvar);
 
-        String classname = meth.varproc.getThisvars().get(varpaar);
+        String classname = meth.varproc.getThisVars().get(varpaar);
 
         if (classname != null) { // any this instance. TODO: Restrict to current class?
           if (!wrapper.getClassStruct().qualifiedName.equals(inv.getClassname())) {

File: src/org/jetbrains/java/decompiler/main/InitializerProcessor.java
Patch:
@@ -261,7 +261,7 @@ private static boolean isExprentIndependent(Exprent exprent, MethodWrapper meth)
       switch (expr.type) {
         case Exprent.EXPRENT_VAR:
           VarVersionPaar varpaar = new VarVersionPaar((VarExprent)expr);
-          if (!meth.varproc.getExternvars().contains(varpaar)) {
+          if (!meth.varproc.getExternalVars().contains(varpaar)) {
             String varname = meth.varproc.getVarName(varpaar);
 
             if (!varname.equals("this") && !varname.endsWith(".this")) { // FIXME: remove direct comparison with strings
@@ -308,7 +308,7 @@ private static boolean isInvocationInitConstructor(InvocationExprent inv, Method
         VarExprent instvar = (VarExprent)inv.getInstance();
         VarVersionPaar varpaar = new VarVersionPaar(instvar);
 
-        String classname = meth.varproc.getThisvars().get(varpaar);
+        String classname = meth.varproc.getThisVars().get(varpaar);
 
         if (classname != null) { // any this instance. TODO: Restrict to current class?
           if (withThis || !wrapper.getClassStruct().qualifiedName.equals(inv.getClassname())) {

File: src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
Patch:
@@ -124,7 +124,7 @@ public void init() throws IOException {
 
           int paramcount = 0;
           if (thisvar) {
-            varproc.getThisvars().put(new VarVersionPaar(0, 0), classStruct.qualifiedName);
+            varproc.getThisVars().put(new VarVersionPaar(0, 0), classStruct.qualifiedName);
             paramcount = 1;
           }
           paramcount += md.params.length;
@@ -138,11 +138,11 @@ public void init() throws IOException {
                 varindex++;
               }
               else {
-                varindex += md.params[i - 1].stack_size;
+                varindex += md.params[i - 1].stackSize;
               }
             }
             else {
-              varindex += md.params[i].stack_size;
+              varindex += md.params[i].stackSize;
             }
           }
         }

File: src/org/jetbrains/java/decompiler/main/rels/NestedMemberAccess.java
Patch:
@@ -91,7 +91,7 @@ private void computeMethodType(ClassNode node, MethodWrapper method) {
 
             if (exprent.type == Exprent.EXPRENT_EXIT) {
               ExitExprent exexpr = (ExitExprent)exprent;
-              if (exexpr.getExittype() == ExitExprent.EXIT_RETURN && exexpr.getValue() != null) {
+              if (exexpr.getExitType() == ExitExprent.EXIT_RETURN && exexpr.getValue() != null) {
                 exprCore = exexpr.getValue();
               }
             }
@@ -188,7 +188,7 @@ else if (graph.first.exprents.size() == 2) {
                       if (((VarExprent)asexpr.getRight()).getIndex() == parcount - 1) {
 
                         ExitExprent exexpr = (ExitExprent)exprentSecond;
-                        if (exexpr.getExittype() == ExitExprent.EXIT_RETURN && exexpr.getValue() != null) {
+                        if (exexpr.getExitType() == ExitExprent.EXIT_RETURN && exexpr.getValue() != null) {
                           if (exexpr.getValue().type == Exprent.EXPRENT_VAR &&
                               ((VarExprent)asexpr.getRight()).getIndex() == parcount - 1) {
                             type = METHOD_ACCESS_FIELD_SET;
@@ -375,7 +375,7 @@ private Exprent replaceAccessExprent(ClassNode caller, MethodWrapper methdest, I
           }
 
           int index = methdest.counter.getCounterAndIncrement(CounterContainer.VAR_COUNTER);
-          VarExprent ret = new VarExprent(index, var.getVartype(), methdest.varproc);
+          VarExprent ret = new VarExprent(index, var.getVarType(), methdest.varproc);
           methdest.varproc.setVarName(new VarVersionPaar(index, 0), varname);
 
           retexprent = ret;

File: src/org/jetbrains/java/decompiler/modules/decompiler/ConcatenationHelper.java
Patch:
@@ -133,7 +133,7 @@ else if (found == 2) {
       List<Exprent> lstTmp = new ArrayList<Exprent>();
       lstTmp.add(func);
       lstTmp.add(lstOperands.get(i));
-      func = new FunctionExprent(FunctionExprent.FUNCTION_STRCONCAT, lstTmp, expr.bytecode);
+      func = new FunctionExprent(FunctionExprent.FUNCTION_STR_CONCAT, lstTmp, expr.bytecode);
     }
 
     return func;
@@ -168,7 +168,7 @@ private static boolean isAppendConcat(InvocationExprent expr, VarType cltype) {
 
   private static boolean isNewConcat(NewExprent expr, VarType cltype) {
 
-    if (expr.getNewtype().equals(cltype)) {
+    if (expr.getNewType().equals(cltype)) {
       VarType[] params = expr.getConstructor().getDescriptor().params;
       if (params.length == 0 || (params.length == 1 &&
                                  params[0].equals(VarType.VARTYPE_STRING))) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExitHelper.java
Patch:
@@ -255,7 +255,7 @@ public static boolean removeRedundantReturns(RootStatement root) {
           Exprent expr = lstExpr.get(lstExpr.size() - 1);
           if (expr.type == Exprent.EXPRENT_EXIT) {
             ExitExprent ex = (ExitExprent)expr;
-            if (ex.getExittype() == ExitExprent.EXIT_RETURN && ex.getValue() == null) {
+            if (ex.getExitType() == ExitExprent.EXIT_RETURN && ex.getValue() == null) {
               // remove redundant return
               lstExpr.remove(lstExpr.size() - 1);
               res = true;
@@ -292,7 +292,7 @@ public static boolean handleReturnFromInitializer(RootStatement root) {
           Exprent expr = lstExpr.get(lstExpr.size() - 1);
           if (expr.type == Exprent.EXPRENT_EXIT) {
             ExitExprent ex = (ExitExprent)expr;
-            if (ex.getExittype() == ExitExprent.EXIT_RETURN && ex.getValue() == null) {
+            if (ex.getExitType() == ExitExprent.EXIT_RETURN && ex.getValue() == null) {
               lstExpr.remove(lstExpr.size() - 1);
 
               source.removeSuccessor(edge);

File: src/org/jetbrains/java/decompiler/modules/decompiler/FinallyProcessor.java
Patch:
@@ -269,7 +269,7 @@ else if (node.preds.size() == 1) {
               found = false;
               if (exprent.type == Exprent.EXPRENT_EXIT) {
                 ExitExprent exexpr = (ExitExprent)exprent;
-                if (exexpr.getExittype() == ExitExprent.EXIT_THROW && exexpr.getValue().type == Exprent.EXPRENT_VAR) {
+                if (exexpr.getExitType() == ExitExprent.EXIT_THROW && exexpr.getValue().type == Exprent.EXPRENT_VAR) {
                   found = true;
                 }
               }
@@ -305,7 +305,7 @@ else if (firstcode == 2) {
                 boolean found = false;
                 if (next != null && next.type == Exprent.EXPRENT_EXIT) {
                   ExitExprent exexpr = (ExitExprent)next;
-                  if (exexpr.getExittype() == ExitExprent.EXIT_THROW && exexpr.getValue().type == Exprent.EXPRENT_VAR
+                  if (exexpr.getExitType() == ExitExprent.EXIT_THROW && exexpr.getValue().type == Exprent.EXPRENT_VAR
                       && assexpr.getLeft().equals(exexpr.getValue())) {
                     found = true;
                   }

File: src/org/jetbrains/java/decompiler/modules/decompiler/StackVarsProcessor.java
Patch:
@@ -338,8 +338,8 @@ private int[] iterateExprent(List<Exprent> lstExprents, int index, Exprent next,
         if (right.type == Exprent.EXPRENT_NEW) {
           // new Object(); permitted
           NewExprent nexpr = (NewExprent)right;
-          if (nexpr.isAnonymous() || nexpr.getNewtype().arraydim > 0
-              || nexpr.getNewtype().type != CodeConstants.TYPE_OBJECT) {
+          if (nexpr.isAnonymous() || nexpr.getNewType().arrayDim > 0
+              || nexpr.getNewType().type != CodeConstants.TYPE_OBJECT) {
             return new int[]{-1, changed};
           }
         }
@@ -511,7 +511,7 @@ private static Object[] iterateChildExprent(Exprent exprent,
     boolean isHeadSynchronized = false;
     if (next == null && parent.type == Exprent.EXPRENT_MONITOR) {
       MonitorExprent monexpr = (MonitorExprent)parent;
-      if (monexpr.getMontype() == MonitorExprent.MONITOR_ENTER && exprent.equals(monexpr.getValue())) {
+      if (monexpr.getMonType() == MonitorExprent.MONITOR_ENTER && exprent.equals(monexpr.getValue())) {
         isHeadSynchronized = true;
       }
     }

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/SwitchStatement.java
Patch:
@@ -135,7 +135,7 @@ public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
         }
         else {
           ConstExprent value = (ConstExprent)values.get(j).copy();
-          value.setConsttype(switch_type);
+          value.setConstType(switch_type);
 
           buf.appendIndent(indent).append("case ").append(value.toJava(indent, tracer)).append(":").appendLineSeparator();
           tracer.incrementCurrentSourceLine();

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
Patch:
@@ -75,18 +75,18 @@ public VarDefinitionHelper(Statement root, StructMethod mt, VarProcessor varproc
           varindex++;
         }
         else {
-          varindex += md.params[i - 1].stack_size;
+          varindex += md.params[i - 1].stackSize;
         }
       }
       else {
-        varindex += md.params[i].stack_size;
+        varindex += md.params[i].stackSize;
       }
     }
 
     if (thisvar) {
       StructClass current_class = (StructClass)DecompilerContext.getProperty(DecompilerContext.CURRENT_CLASS);
 
-      varproc.getThisvars().put(new VarVersionPaar(0, 0), current_class.qualifiedName);
+      varproc.getThisVars().put(new VarVersionPaar(0, 0), current_class.qualifiedName);
       varproc.setVarName(new VarVersionPaar(0, 0), "this");
       vc.addName("this");
     }

File: src/org/jetbrains/java/decompiler/struct/gen/DataPoint.java
Patch:
@@ -73,7 +73,7 @@ public static DataPoint getInitialDataPoint(StructMethod mt) {
       VarType var = md.params[i];
 
       point.setVariable(k++, var);
-      if (var.stack_size == 2) {
+      if (var.stackSize == 2) {
         point.setVariable(k++, new VarType(CodeConstants.TYPE_GROUP2EMPTY));
       }
     }

File: src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java
Patch:
@@ -173,7 +173,7 @@ private static String parseFormalParameters(String signature, List<String> param
 
   public static String getGenericCastTypeName(GenericType type) {
     String s = getTypeName(type);
-    int dim = type.arraydim;
+    int dim = type.arrayDim;
     while (dim-- > 0) {
       s += "[]";
     }

File: test/org/jetbrains/java/decompiler/BytecodeToSourceMappingTest.java
Patch:
@@ -30,4 +30,5 @@ protected Map<String, Object> getDecompilerOptions() {
   }
 
   @Test public void testSimpleBytecodeMapping() { doTest("pkg/TestClassSimpleBytecodeMapping"); }
+  @Test public void testSynchronizedMapping() { doTest("pkg/TestSynchronizedMapping"); }
 }

File: testData/src/pkg/TestClassSimpleBytecodeMapping.java
Patch:
@@ -34,6 +34,8 @@ public void test2(String a) {
       Integer.parseInt(a);
     } catch (Exception e) {
       System.out.println(e);
+    } finally {
+      System.out.println("Finally");
     }
   }
 

File: src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
Patch:
@@ -280,6 +280,7 @@ public void writeClass(StructClass cl, TextBuffer buffer) throws IOException {
       }
       //buffer.append(lineSeparator);
 
+      total_offset_lines = buffer.countLines();
       buffer.append(classBuffer);
 
       if (DecompilerContext.getOption(IFernflowerPreferences.BYTECODE_SOURCE_MAPPING)) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchStatement.java
Patch:
@@ -187,7 +187,6 @@ public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
       tracer.incrementCurrentSourceLine();
       buf.append(ExprProcessor.jmpWrapper(stats.get(i), indent + 1, true, tracer)).append(indstr)
         .append("}");
-      tracer.incrementCurrentSourceLine();
     }
     buf.append(new_line_separator);
 

File: src/org/jetbrains/java/decompiler/main/collectors/BytecodeSourceMapper.java
Patch:
@@ -97,7 +97,7 @@ public void dumpMapping(TextBuffer buffer, boolean offsetsToHex) {
     buffer.append("Lines mapping:").appendLineSeparator();
     Map<Integer, Integer> sorted = new TreeMap<Integer, Integer>(linesMapping);
     for (Entry<Integer, Integer> entry : sorted.entrySet()) {
-      buffer.append(entry.getKey()).append(" <-> ").append(entry.getValue()).appendLineSeparator();
+      buffer.append(entry.getKey()).append(" <-> ").append(entry.getValue()+ offset_total + 1).appendLineSeparator();
     }
   }
 

File: src/org/jetbrains/java/decompiler/main/decompiler/ConsoleDecompiler.java
Patch:
@@ -181,7 +181,7 @@ public void copyFile(String source, String path, String entryName) {
   }
 
   @Override
-  public void saveClassFile(String path, String qualifiedName, String entryName, String content) {
+  public void saveClassFile(String path, String qualifiedName, String entryName, String content, int[] mapping) {
     File file = new File(getAbsolutePath(path), entryName);
     try {
       Writer out = new OutputStreamWriter(new FileOutputStream(file), "UTF8");

File: src/org/jetbrains/java/decompiler/main/extern/IResultSaver.java
Patch:
@@ -22,7 +22,7 @@ public interface IResultSaver {
 
   void copyFile(String source, String path, String entryName);
 
-  void saveClassFile(String path, String qualifiedName, String entryName, String content);
+  void saveClassFile(String path, String qualifiedName, String entryName, String content, int[] mapping);
 
   void createArchive(String path, String archiveName, Manifest manifest);
 

File: src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
Patch:
@@ -256,7 +256,7 @@ public void writeClass(StructClass cl, TextBuffer buffer) throws IOException {
       new NestedMemberAccess().propagateMemberAccess(root);
 
       TextBuffer classBuffer = new TextBuffer(AVERAGE_CLASS_SIZE);
-      new ClassWriter().classToJava(root, classBuffer, 0);
+      new ClassWriter().classToJava(root, classBuffer, 0, null);
 
       String lineSeparator = DecompilerContext.getNewLineSeparator();
       int total_offset_lines = 0;

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
Patch:
@@ -270,9 +270,11 @@ public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
         }
         Exprent methodObject = constructor == null ? null : constructor.getInstance();
         new ClassWriter().classLambdaToJava(child, buf, methodObject, indent);
+        tracer.incrementCurrentSourceLine(buf.countLines());
       }
       else {
-        new ClassWriter().classToJava(child, buf, indent);
+        new ClassWriter().classToJava(child, buf, indent, tracer);
+        tracer.incrementCurrentSourceLine(buf.countLines());
       }
     }
     else if (directArrayInit) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Set;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.main.ClassWriter;
@@ -92,7 +91,7 @@ public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
 
     if (classdef) {
       ClassNode child = DecompilerContext.getClassProcessor().getMapRootClasses().get(vartype.value);
-      new ClassWriter().classToJava(child, buffer, indent);
+      new ClassWriter().classToJava(child, buffer, indent, tracer);
     }
     else {
       String name = null;

File: src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
Patch:
@@ -236,6 +236,7 @@ public void writeClass(StructClass cl, TextBuffer buffer) throws IOException {
       return;
     }
 
+    DecompilerContext.getLogger().startReadingClass(cl.qualifiedName);
     try {
       ImportCollector importCollector = new ImportCollector(root);
       DecompilerContext.setImportCollector(importCollector);
@@ -291,6 +292,7 @@ public void writeClass(StructClass cl, TextBuffer buffer) throws IOException {
     }
     finally {
       destroyWrappers(root);
+      DecompilerContext.getLogger().endReadingClass();
     }
   }
 

File: src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
Patch:
@@ -236,7 +236,7 @@ else if (nestednode.type == ClassNode.CLASS_LOCAL) {
     }
   }
 
-  public void writeClass(StructClass cl, StringBuilder buffer) throws IOException {
+  public void writeClass(StructClass cl, TextBuffer buffer) throws IOException {
     ClassNode root = mapRootClasses.get(cl.qualifiedName);
     if (root.type != ClassNode.CLASS_ROOT) {
       return;
@@ -260,7 +260,7 @@ public void writeClass(StructClass cl, StringBuilder buffer) throws IOException
 
       new NestedMemberAccess().propagateMemberAccess(root);
 
-      StringBuilder classBuffer = new StringBuilder(AVERAGE_CLASS_SIZE);
+      TextBuffer classBuffer = new TextBuffer(AVERAGE_CLASS_SIZE);
       new ClassWriter().classToJava(root, classBuffer, 0);
 
       String lineSeparator = DecompilerContext.getNewLineSeparator();

File: src/org/jetbrains/java/decompiler/main/Fernflower.java
Patch:
@@ -80,11 +80,11 @@ public String getClassEntryName(StructClass cl, String entryName) {
   }
 
   @Override
-  public String getClassContent(StructClass cl) {
+  public TextBuffer getClassContent(StructClass cl) {
     try {
-      StringBuilder buffer = new StringBuilder(ClassesProcessor.AVERAGE_CLASS_SIZE);
+      TextBuffer buffer = new TextBuffer(ClassesProcessor.AVERAGE_CLASS_SIZE);
       classesProcessor.writeClass(cl, buffer);
-      return buffer.toString();
+      return buffer;
     }
     catch (Throwable ex) {
       DecompilerContext.getLogger().writeMessage("Class " + cl.qualifiedName + " couldn't be fully decompiled.", ex);

File: src/org/jetbrains/java/decompiler/main/collectors/BytecodeSourceMapper.java
Patch:
@@ -4,6 +4,7 @@
 import java.util.Map.Entry;
 
 import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.TextBuffer;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
 
 public class BytecodeSourceMapper {
@@ -37,7 +38,7 @@ public void addTracer(String classname, String methodname, BytecodeMappingTracer
     }
   }
 
-  public void dumpMapping(StringBuilder buffer) {
+  public void dumpMapping(TextBuffer buffer) {
 
     String lineSeparator = DecompilerContext.getNewLineSeparator();
     String indentstr1 = InterpreterUtil.getIndentString(1);

File: src/org/jetbrains/java/decompiler/main/collectors/ImportCollector.java
Patch:
@@ -18,6 +18,7 @@
 import org.jetbrains.java.decompiler.main.ClassesProcessor;
 import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.TextBuffer;
 import org.jetbrains.java.decompiler.struct.StructContext;
 
 import java.util.*;
@@ -107,7 +108,7 @@ else if (!mapSimpleNames.containsKey(nshort)) {
     return retname == null ? nshort : retname;
   }
 
-  public int writeImports(StringBuilder buffer) {
+  public int writeImports(TextBuffer buffer) {
 
     int importlines_written = 0;
     String new_line_separator = DecompilerContext.getNewLineSeparator();

File: src/org/jetbrains/java/decompiler/main/decompiler/ConsoleDecompiler.java
Patch:
@@ -17,6 +17,7 @@
 
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.Fernflower;
+import org.jetbrains.java.decompiler.main.TextBuffer;
 import org.jetbrains.java.decompiler.main.extern.IBytecodeProvider;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger;
 import org.jetbrains.java.decompiler.main.extern.IResultSaver;
@@ -181,12 +182,12 @@ public void copyFile(String source, String path, String entryName) {
   }
 
   @Override
-  public void saveClassFile(String path, String qualifiedName, String entryName, String content) {
+  public void saveClassFile(String path, String qualifiedName, String entryName, TextBuffer content) {
     File file = new File(getAbsolutePath(path), entryName);
     try {
       Writer out = new OutputStreamWriter(new FileOutputStream(file), "UTF8");
       try {
-        out.write(content);
+        out.write(content.toString());
       }
       finally {
         out.close();

File: src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
Patch:
@@ -45,6 +45,7 @@ public interface IFernflowerPreferences {
   String LAMBDA_TO_ANONYMOUS_CLASS = "lac";
 
   String BYTECODE_SOURCE_MAPPING = "bsm";
+  String USE_DEBUG_LINE_NUMBERS = "udl";
 
   String LOG_LEVEL = "log";
   String MAX_PROCESSING_METHOD = "mpm";
@@ -80,6 +81,7 @@ public interface IFernflowerPreferences {
     put(LAMBDA_TO_ANONYMOUS_CLASS, "0");
 
     put(BYTECODE_SOURCE_MAPPING, "0");
+    put(USE_DEBUG_LINE_NUMBERS, "0");
 
     put(LOG_LEVEL, IFernflowerLogger.Severity.INFO.name());
     put(MAX_PROCESSING_METHOD, "0");

File: src/org/jetbrains/java/decompiler/main/extern/IResultSaver.java
Patch:
@@ -15,14 +15,16 @@
  */
 package org.jetbrains.java.decompiler.main.extern;
 
+import org.jetbrains.java.decompiler.main.TextBuffer;
+
 import java.util.jar.Manifest;
 
 public interface IResultSaver {
   void saveFolder(String path);
 
   void copyFile(String source, String path, String entryName);
 
-  void saveClassFile(String path, String qualifiedName, String entryName, String content);
+  void saveClassFile(String path, String qualifiedName, String entryName, TextBuffer content);
 
   void createArchive(String path, String archiveName, Manifest manifest);
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
Patch:
@@ -20,6 +20,7 @@
 import org.jetbrains.java.decompiler.code.InstructionSequence;
 import org.jetbrains.java.decompiler.code.cfg.BasicBlock;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.TextBuffer;
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
 import org.jetbrains.java.decompiler.modules.decompiler.exps.*;
 import org.jetbrains.java.decompiler.modules.decompiler.sforms.DirectGraph;
@@ -857,14 +858,14 @@ else if (arrtype.type == CodeConstants.TYPE_DOUBLE) {
     return defaultval;
   }
 
-  public static boolean getCastedExprent(Exprent exprent, VarType leftType, StringBuilder buffer, int indent,
+  public static boolean getCastedExprent(Exprent exprent, VarType leftType, TextBuffer buffer, int indent,
                                                                boolean castNull, BytecodeMappingTracer tracer) {
     return getCastedExprent(exprent, leftType, buffer, indent, castNull, false, tracer);
   }
 
   public static boolean getCastedExprent(Exprent exprent,
                                          VarType leftType,
-                                         StringBuilder buffer,
+                                         TextBuffer buffer,
                                          int indent,
                                          boolean castNull,
                                          boolean castAlways, BytecodeMappingTracer tracer) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java
Patch:
@@ -18,6 +18,7 @@
 import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.TextBuffer;
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
 import org.jetbrains.java.decompiler.main.rels.MethodWrapper;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
@@ -81,7 +82,7 @@ public String toJava(int indent, BytecodeMappingTracer tracer) {
     tracer.addMapping(bytecode);
 
     if (exittype == EXIT_RETURN) {
-      StringBuilder buffer = new StringBuilder();
+      TextBuffer buffer = new TextBuffer();
 
       if (rettype.type != CodeConstants.TYPE_VOID) {
         buffer.append(" ");
@@ -115,7 +116,7 @@ else if ("java/lang/Exception".equals(excclassname)) {
           if (classname != null) {
             VarType exctype = new VarType(classname, true);
 
-            StringBuilder buffer = new StringBuilder();
+            TextBuffer buffer = new TextBuffer();
             ExprProcessor.getCastedExprent(value, exctype, buffer, indent, false, tracer);
 
             return "throw " + buffer.toString();

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java
Patch:
@@ -18,6 +18,7 @@
 import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.TextBuffer;
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
 import org.jetbrains.java.decompiler.main.rels.MethodWrapper;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
@@ -137,7 +138,7 @@ public String toJava(int indent, BytecodeMappingTracer tracer) {
         buf.append("super");
       }
       else {
-        StringBuilder buff = new StringBuilder();
+        TextBuffer buff = new TextBuffer();
         boolean casted = ExprProcessor.getCastedExprent(instance, new VarType(CodeConstants.TYPE_OBJECT, 0, classname), buff, indent, true, tracer);
         String res = buff.toString();
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
Patch:
@@ -18,6 +18,7 @@
 import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.TextBuffer;
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.main.rels.MethodWrapper;
@@ -360,7 +361,7 @@ else if (isInstanceThis) {
           buf.append(", ");
         }
 
-        StringBuilder buff = new StringBuilder();
+        TextBuffer buff = new TextBuffer();
         ExprProcessor.getCastedExprent(lstParameters.get(i), descriptor.params[i], buff, indent, true, setAmbiguousParameters.contains(i), tracer);
 
         buf.append(buff);

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
Patch:
@@ -18,6 +18,7 @@
 import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.main.ClassWriter;
 import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;
+import org.jetbrains.java.decompiler.main.TextBuffer;
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
@@ -83,7 +84,7 @@ public Exprent copy() {
 
   @Override
   public String toJava(int indent, BytecodeMappingTracer tracer) {
-    StringBuilder buffer = new StringBuilder();
+    TextBuffer buffer = new TextBuffer();
 
     tracer.addMapping(bytecode);
 

File: src/org/jetbrains/java/decompiler/struct/IDecompiledData.java
Patch:
@@ -15,9 +15,11 @@
  */
 package org.jetbrains.java.decompiler.struct;
 
+import org.jetbrains.java.decompiler.main.TextBuffer;
+
 public interface IDecompiledData {
 
   String getClassEntryName(StructClass cl, String entryname);
 
-  String getClassContent(StructClass cl);
+  TextBuffer getClassContent(StructClass cl);
 }

File: src/org/jetbrains/java/decompiler/util/InterpreterUtil.java
Patch:
@@ -16,6 +16,7 @@
 package org.jetbrains.java.decompiler.util;
 
 import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.TextBuffer;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 
 import java.io.*;
@@ -91,12 +92,12 @@ private static byte[] readAndClose(InputStream stream, int length) throws IOExce
 
   public static String getIndentString(int length) {
     if (length == 0) return "";
-    StringBuilder buf = new StringBuilder();
+    TextBuffer buf = new TextBuffer();
     appendIndent(buf, length);
     return buf.toString();
   }
 
-  public static void appendIndent(StringBuilder buffer, int length) {
+  public static void appendIndent(TextBuffer buffer, int length) {
     if (length == 0) return;
     String indent = (String)DecompilerContext.getProperty(IFernflowerPreferences.INDENT_STRING);
     while (length-- > 0) {

File: src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
Patch:
@@ -268,7 +268,7 @@ public void writeClass(StructClass cl, StringBuilder buffer) throws IOException
 
       int index = cl.qualifiedName.lastIndexOf("/");
       if (index >= 0) {
-        total_offset_lines++;
+        total_offset_lines+=2;
         String packageName = cl.qualifiedName.substring(0, index).replace('/', '.');
 
         buffer.append("package ");
@@ -283,6 +283,7 @@ public void writeClass(StructClass cl, StringBuilder buffer) throws IOException
         buffer.append(lineSeparator);
         total_offset_lines += import_lines_written + 1;
       }
+      //buffer.append(lineSeparator);
 
       buffer.append(classBuffer);
 

File: src/org/jetbrains/java/decompiler/main/collectors/BytecodeSourceMapper.java
Patch:
@@ -59,7 +59,7 @@ public void dumpMapping(StringBuilder buffer) {
         buffer.append(indentstr1 + "method " + method_entry.getKey() + "{" + lineSeparator);
 
         for(Entry<Integer, Integer> line : method_mapping.entrySet()) {
-          buffer.append(indentstr2 + line.getKey() + indentstr2 + line.getValue() + lineSeparator);
+          buffer.append(indentstr2 + line.getKey() + indentstr2 + (line.getValue() +offset_total) + lineSeparator);
         }
         buffer.append(indentstr1 + "}" + lineSeparator);
         is_first_method = false;

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
Patch:
@@ -778,13 +778,13 @@ public static String jmpWrapper(Statement stat, int indent, boolean semicolon, B
           buf.append(" label").append(edge.closure.id);
         }
         buf.append(";").append(new_line_separator);
-        tracer.incrementSourceLine();
+        tracer.incrementCurrentSourceLine();
       }
     }
 
     if (buf.length() == 0 && semicolon) {
       buf.append(InterpreterUtil.getIndentString(indent)).append(";").append(new_line_separator);
-      tracer.incrementSourceLine();
+      tracer.incrementCurrentSourceLine();
     }
 
     return buf.toString();
@@ -828,7 +828,7 @@ public static String listToJava(List<Exprent> lst, int indent, BytecodeMappingTr
           buf.append(";");
         }
         buf.append(new_line_separator);
-        tracer.incrementSourceLine();
+        tracer.incrementCurrentSourceLine();
       }
     }
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/SequenceStatement.java
Patch:
@@ -114,7 +114,7 @@ public String toJava(int indent, BytecodeMappingTracer tracer) {
       indstr = InterpreterUtil.getIndentString(indent);
       indent++;
       buf.append(indstr).append("label").append(this.id).append(": {").append(new_line_separator);
-      tracer.incrementSourceLine();
+      tracer.incrementCurrentSourceLine();
     }
 
     boolean notempty = false;
@@ -125,7 +125,7 @@ public String toJava(int indent, BytecodeMappingTracer tracer) {
 
       if (i > 0 && notempty) {
         buf.append(new_line_separator);
-        tracer.incrementSourceLine();
+        tracer.incrementCurrentSourceLine();
       }
 
       String str = ExprProcessor.jmpWrapper(st, indent, false, tracer);
@@ -136,7 +136,7 @@ public String toJava(int indent, BytecodeMappingTracer tracer) {
 
     if (islabeled) {
       buf.append(indstr).append("}").append(new_line_separator);
-      tracer.incrementSourceLine();
+      tracer.incrementCurrentSourceLine();
     }
 
     return buf.toString();

File: test/org/jetbrains/java/decompiler/DecompilerTestFixture.java
Patch:
@@ -33,6 +33,8 @@ public void setUp() throws IOException {
     testDataDir = new File("testData");
     if (!isTestDataDir(testDataDir)) testDataDir = new File("community/plugins/java-decompiler/engine/testData");
     if (!isTestDataDir(testDataDir)) testDataDir = new File("plugins/java-decompiler/engine/testData");
+    if (!isTestDataDir(testDataDir)) testDataDir = new File("../community/plugins/java-decompiler/engine/testData");
+    if (!isTestDataDir(testDataDir)) testDataDir = new File("../plugins/java-decompiler/engine/testData");
     assertTrue("current dir: " + new File("").getAbsolutePath(), isTestDataDir(testDataDir));
 
     //noinspection SSBasedInspection

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -630,7 +630,7 @@ else if ("<clinit>".equals(name)) {
           if (isEnum && init) actualParams -= 2;
           if (actualParams != descriptor.params.size()) {
             String message = "Inconsistent generic signature in method " + mt.getName() + " " + mt.getDescriptor();
-            DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.WARNING);
+            DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN);
             descriptor = null;
           }
         }

File: src/org/jetbrains/java/decompiler/main/extern/IBytecodeProvider.java
Patch:
@@ -15,9 +15,8 @@
  */
 package org.jetbrains.java.decompiler.main.extern;
 
-import java.io.InputStream;
+import java.io.IOException;
 
 public interface IBytecodeProvider {
-
-  InputStream getBytecodeStream(String externPath, String internPath);
+  byte[] getBytecode(String externalPath, String internalPath) throws IOException;
 }

File: src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
Patch:
@@ -77,6 +77,7 @@ public interface IFernflowerPreferences {
     put(IDEA_NOT_NULL_ANNOTATION, "1");
     put(LAMBDA_TO_ANONYMOUS_CLASS, "0");
 
+    put(LOG_LEVEL, IFernflowerLogger.Severity.INFO.name());
     put(MAX_PROCESSING_METHOD, "0");
     put(RENAME_ENTITIES, "0");
     put(NEW_LINE_SEPARATOR, (InterpreterUtil.IS_WINDOWS ? "0" : "1"));

File: src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
Patch:
@@ -106,7 +106,7 @@ public void init() throws IOException {
 
               if (System.currentTimeMillis() >= stopAt) {
                 String message = "Processing time limit exceeded for method " + mt.getName() + ", execution interrupted.";
-                DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.ERROR);
+                DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.ERROR);
                 killThread(mtthread);
                 isError = true;
                 break;

File: src/org/jetbrains/java/decompiler/main/rels/MethodProcessorThread.java
Patch:
@@ -130,7 +130,7 @@ public static RootStatement codeToJava(StructMethod mt, VarProcessor varproc) th
     //System.out.println(graph.toString());
 
     if (ExceptionDeobfuscator.hasObfuscatedExceptions(graph)) {
-      DecompilerContext.getLogger().writeMessage("Heavily obfuscated exception ranges found!", IFernflowerLogger.WARNING);
+      DecompilerContext.getLogger().writeMessage("Heavily obfuscated exception ranges found!", IFernflowerLogger.Severity.WARN);
     }
 
     RootStatement root = DomHelper.parseGraph(graph);

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/Statement.java
Patch:
@@ -463,7 +463,7 @@ public List<Statement> getPostReversePostOrderList(List<Statement> lstexits) {
     }
 
     if (res.size() != stats.size()) {
-      DecompilerContext.getLogger().writeMessage("computing post reverse post order failed!", IFernflowerLogger.ERROR);
+      DecompilerContext.getLogger().writeMessage("computing post reverse post order failed!", IFernflowerLogger.Severity.ERROR);
 
       throw new RuntimeException("parsing failure!");
     }

File: src/org/jetbrains/java/decompiler/modules/renamer/IdentifierConverter.java
Patch:
@@ -387,8 +387,8 @@ private static List<ClassWrapperNode> getReversePostOrderListIterative(List<Clas
 
   private void buildInheritanceTree() {
 
-    HashMap<String, ClassWrapperNode> nodes = new HashMap<String, ClassWrapperNode>();
-    HashMap<String, StructClass> classes = context.getClasses();
+    Map<String, ClassWrapperNode> nodes = new HashMap<String, ClassWrapperNode>();
+    Map<String, StructClass> classes = context.getClasses();
 
     List<ClassWrapperNode> rootClasses = new ArrayList<ClassWrapperNode>();
     List<ClassWrapperNode> rootInterfaces = new ArrayList<ClassWrapperNode>();

File: src/org/jetbrains/java/decompiler/struct/StructClass.java
Patch:
@@ -24,7 +24,6 @@
 import org.jetbrains.java.decompiler.util.VBStyleCollection;
 
 import java.io.IOException;
-import java.io.InputStream;
 
 /*
   class_file {
@@ -62,8 +61,8 @@ public class StructClass extends StructMember {
 
   private ConstantPool pool;
 
-  public StructClass(InputStream inStream, boolean own, LazyLoader loader) throws IOException {
-    this(new DataInputFullStream(inStream), own, loader);
+  public StructClass(byte[] bytes, boolean own, LazyLoader loader) throws IOException {
+    this(new DataInputFullStream(bytes), own, loader);
   }
 
   public StructClass(DataInputFullStream in, boolean own, LazyLoader loader) throws IOException {

File: src/org/jetbrains/java/decompiler/struct/StructMethod.java
Patch:
@@ -21,7 +21,6 @@
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 import org.jetbrains.java.decompiler.util.VBStyleCollection;
 
-import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
@@ -106,7 +105,7 @@ protected StructGeneralAttribute readAttribute(DataInputFullStream in, ConstantP
   public void expandData() throws IOException {
     if (containsCode && !expanded) {
       byte[] code = classStruct.getLoader().loadBytecode(this, codeFullLength);
-      seq = parseBytecode(new DataInputFullStream(new ByteArrayInputStream(code)), codeLength, classStruct.getPool());
+      seq = parseBytecode(new DataInputFullStream(code), codeLength, classStruct.getPool());
       expanded = true;
     }
   }

File: src/org/jetbrains/java/decompiler/struct/attr/StructGeneralAttribute.java
Patch:
@@ -18,7 +18,6 @@
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 
-import java.io.ByteArrayInputStream;
 import java.io.IOException;
 
 /*
@@ -104,7 +103,7 @@ else if (ATTRIBUTE_SYNTHETIC.equals(name) ||
   }
 
   protected DataInputFullStream stream() {
-    return new DataInputFullStream(new ByteArrayInputStream(info));
+    return new DataInputFullStream(info);
   }
 
   public void initContent(ConstantPool pool) throws IOException { }

File: src/org/jetbrains/java/decompiler/util/DataInputFullStream.java
Patch:
@@ -15,14 +15,14 @@
  */
 package org.jetbrains.java.decompiler.util;
 
+import java.io.ByteArrayInputStream;
 import java.io.DataInputStream;
 import java.io.IOException;
-import java.io.InputStream;
 
 public class DataInputFullStream extends DataInputStream {
 
-  public DataInputFullStream(InputStream in) {
-    super(in);
+  public DataInputFullStream(byte[] bytes) {
+    super(new ByteArrayInputStream(bytes));
   }
 
   public int readFull(byte[] b) throws IOException {

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -44,7 +44,7 @@ public void setUp() throws IOException {
     assertTrue(tempDir.delete());
     assertTrue(tempDir.mkdirs());
 
-    decompiler = new ConsoleDecompiler(new HashMap<String, Object>() {{
+    decompiler = new ConsoleDecompiler(tempDir, new HashMap<String, Object>() {{
       put(IFernflowerPreferences.LOG_LEVEL, "warn");
       put(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES, "1");
       put(IFernflowerPreferences.REMOVE_SYNTHETIC, "1");
@@ -91,7 +91,7 @@ public boolean accept(File dir, String name) {
         decompiler.addSpace(inner, true);
       }
 
-      decompiler.decompileContext(tempDir);
+      decompiler.decompileContext();
 
       File decompiledFile = new File(tempDir, testName + ".java");
       assertTrue(decompiledFile.isFile());

File: src/org/jetbrains/java/decompiler/main/EnumProcessor.java
Patch:
@@ -82,7 +82,7 @@ else if ("valueOf".equals(name)) {
 
     // hide dummy synthetic fields of enum constants
     for (StructField fd : cl.getFields()) {
-      if ((fd.access_flags & CodeConstants.ACC_ENUM) != 0) {
+      if (fd.hasModifier(CodeConstants.ACC_ENUM)) {
         Exprent initializer =
           wrapper.getStaticFieldInitializers().getWithKey(InterpreterUtil.makeUniqueKey(fd.getName(), fd.getDescriptor()));
         if (initializer != null && initializer.type == Exprent.EXPRENT_NEW) {
@@ -97,10 +97,9 @@ else if ("valueOf".equals(name)) {
   }
 
   private static void hideDummyFieldInConstant(ClassWrapper wrapper) {
-
     StructClass cl = wrapper.getClassStruct();
     for (StructField fd : cl.getFields()) {
-      if ((fd.access_flags & CodeConstants.ACC_SYNTHETIC) != 0) {
+      if (fd.isSynthetic()) {
         FieldDescriptor descr = FieldDescriptor.parseDescriptor(fd.getDescriptor());
         VarType ret = descr.type;
 

File: src/org/jetbrains/java/decompiler/main/InitializerProcessor.java
Patch:
@@ -76,7 +76,7 @@ private static void liftConstructor(ClassWrapper wrapper) {
               FieldExprent fexpr = (FieldExprent)asexpr.getLeft();
               if (fexpr.getClassname().equals(wrapper.getClassStruct().qualifiedName)) {
                 StructField structField = wrapper.getClassStruct().getField(fexpr.getName(), fexpr.getDescriptor().descriptorString);
-                if (structField != null && (structField.access_flags & CodeConstants.ACC_FINAL) != 0) {
+                if (structField != null && structField.hasModifier(CodeConstants.ACC_FINAL)) {
                   action = 1;
                 }
               }

File: src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java
Patch:
@@ -123,7 +123,7 @@ public void init() throws IOException {
           }
         }
         else {
-          boolean thisvar = (mt.getAccessFlags() & CodeConstants.ACC_STATIC) == 0;
+          boolean thisvar = !mt.hasModifier(CodeConstants.ACC_STATIC);
           MethodDescriptor md = MethodDescriptor.parseDescriptor(mt.getDescriptor());
 
           int paramcount = 0;

File: src/org/jetbrains/java/decompiler/modules/decompiler/IdeaNotNullHelper.java
Patch:
@@ -82,7 +82,7 @@ private static boolean findAndRemoveParameterCheck(Statement stat, StructMethod
           if (first_param.type == Exprent.EXPRENT_VAR) {
             VarExprent var = (VarExprent)first_param;
 
-            boolean thisvar = (mt.getAccessFlags() & CodeConstants.ACC_STATIC) == 0;
+            boolean thisvar = !mt.hasModifier(CodeConstants.ACC_STATIC);
 
             MethodDescriptor md = MethodDescriptor.parseDescriptor(mt.getDescriptor());
             VBStyleCollection<StructGeneralAttribute, String> attributes = mt.getAttributes();

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAConstructorSparseEx.java
Patch:
@@ -487,8 +487,7 @@ private void setCatchMaps(Statement stat, DirectGraph dgraph, FlattenStatementsH
   }
 
   private SFormsFastMapDirect createFirstMap(StructMethod mt) {
-
-    boolean thisvar = (mt.getAccessFlags() & CodeConstants.ACC_STATIC) == 0;
+    boolean thisvar = !mt.hasModifier(CodeConstants.ACC_STATIC);
 
     MethodDescriptor md = MethodDescriptor.parseDescriptor(mt.getDescriptor());
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAUConstructorSparseEx.java
Patch:
@@ -756,8 +756,7 @@ private void setCatchMaps(Statement stat, DirectGraph dgraph, FlattenStatementsH
   }
 
   private SFormsFastMapDirect createFirstMap(StructMethod mt, RootStatement root) {
-
-    boolean thisvar = (mt.getAccessFlags() & CodeConstants.ACC_STATIC) == 0;
+    boolean thisvar = !mt.hasModifier(CodeConstants.ACC_STATIC);
 
     MethodDescriptor md = MethodDescriptor.parseDescriptor(mt.getDescriptor());
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
Patch:
@@ -53,7 +53,7 @@ public VarDefinitionHelper(Statement root, StructMethod mt, VarProcessor varproc
 
     VarNamesCollector vc = DecompilerContext.getVarNamesCollector();
 
-    boolean thisvar = (mt.getAccessFlags() & CodeConstants.ACC_STATIC) == 0;
+    boolean thisvar = !mt.hasModifier(CodeConstants.ACC_STATIC);
 
     MethodDescriptor md = MethodDescriptor.parseDescriptor(mt.getDescriptor());
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarTypeProcessor.java
Patch:
@@ -49,7 +49,7 @@ private void setInitVars(RootStatement root) {
     StructMethod mt = (StructMethod)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD);
 
     // method descriptor
-    boolean thisvar = (mt.getAccessFlags() & CodeConstants.ACC_STATIC) == 0;
+    boolean thisvar = !mt.hasModifier(CodeConstants.ACC_STATIC);
 
     MethodDescriptor md = (MethodDescriptor)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_DESCRIPTOR);
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
Patch:
@@ -170,7 +170,7 @@ private static void simpleMerge(VarTypeProcessor typeproc, DirectGraph dgraph, S
       }
     }
 
-    boolean is_method_static = (mt.getAccessFlags() & CodeConstants.ACC_STATIC) != 0;
+    boolean is_method_static = mt.hasModifier(CodeConstants.ACC_STATIC);
 
     final HashMap<VarVersionPaar, Integer> mapMergedVersions = new HashMap<VarVersionPaar, Integer>();
 

File: src/org/jetbrains/java/decompiler/struct/gen/DataPoint.java
Patch:
@@ -65,7 +65,7 @@ public static DataPoint getInitialDataPoint(StructMethod mt) {
     MethodDescriptor md = MethodDescriptor.parseDescriptor(mt.getDescriptor());
 
     int k = 0;
-    if ((mt.getAccessFlags() & CodeConstants.ACC_STATIC) == 0) {
+    if (!mt.hasModifier(CodeConstants.ACC_STATIC)) {
       point.setVariable(k++, new VarType(CodeConstants.TYPE_OBJECT, 0, null));
     }
 

File: test/org/jetbrains/java/decompiler/SingleClassesTest.java
Patch:
@@ -33,9 +33,11 @@ public class SingleClassesTest {
 
   @Before
   public void setUp() throws IOException {
+    //noinspection SSBasedInspection
     tempDir = File.createTempFile("decompiler_test_", "_dir");
     assertTrue(tempDir.delete());
     assertTrue(tempDir.mkdirs());
+
     decompiler = new ConsoleDecompiler(new HashMap<String, Object>() {{
       put(IFernflowerPreferences.LOG_LEVEL, "warn");
       put(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES, "1");

File: src/org/jetbrains/java/decompiler/main/decompiler/ConsoleDecompiler.java
Patch:
@@ -72,7 +72,7 @@ public static void main(String[] args) {
 
           if (isOption && arg.startsWith("-") &&
               arg.length() > 5 && arg.charAt(4) == '=') {
-            String value = arg.substring(5).toUpperCase();
+            String value = arg.substring(5).toUpperCase(Locale.US);
             if ("TRUE".equals(value)) {
               value = "1";
             }

File: src/org/jetbrains/java/decompiler/code/InstructionSequence.java
Patch:
@@ -140,7 +140,7 @@ public String toString(int indent) {
 
     String new_line_separator = DecompilerContext.getNewLineSeparator();
 
-    StringBuffer buf = new StringBuffer();
+    StringBuilder buf = new StringBuilder();
 
     for (int i = 0; i < collinstr.size(); i++) {
     buf.append(InterpreterUtil.getIndentString(indent));

File: src/org/jetbrains/java/decompiler/code/cfg/BasicBlock.java
Patch:
@@ -169,7 +169,7 @@ public String toStringOldIndices() {
 
     String new_line_separator = DecompilerContext.getNewLineSeparator();
 
-    StringBuffer buf = new StringBuffer();
+    StringBuilder buf = new StringBuilder();
 
     for (int i = 0; i < seq.length(); i++) {
       if (i < instrOldOffsets.size()) {

File: src/org/jetbrains/java/decompiler/main/Fernflower.java
Patch:
@@ -50,9 +50,7 @@ public Fernflower(IBytecodeProvider provider, IDecompilatSaver saver, HashMap<St
   public void decompileContext() {
 
     if (DecompilerContext.getOption(IFernflowerPreferences.RENAME_ENTITIES)) {
-      IdentifierConverter ren = new IdentifierConverter();
-      ren.rename(structcontext);
-      ren = null;
+      new IdentifierConverter().rename(structcontext);
     }
 
     clprocessor = new ClassesProcessor(structcontext);

File: src/org/jetbrains/java/decompiler/main/decompiler/ConsoleDecompiler.java
Patch:
@@ -311,8 +311,7 @@ public void closeArchive(String path, String archivename) {
       String filename = new File(getAbsolutePath(path), archivename).getAbsolutePath();
 
       mapArchiveEntries.remove(filename);
-      ZipOutputStream out = mapArchiveStreams.remove(filename);
-
+      OutputStream out = mapArchiveStreams.remove(filename);
       out.flush();
       out.close();
     }

File: src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java
Patch:
@@ -112,9 +112,9 @@ public boolean hasLambda(ClassNode node) throws IOException {
 
               LinkConstant content_method_handle = (LinkConstant)bootstrap_arguments.get(1);
 
-              ClassNode node_lambda = clprocessor.new ClassNode(content_method_handle.classname, content_method_handle.elementname,
-                                                                content_method_handle.descriptor, content_method_handle.index1,
-                                                                lambda_class_name, lambda_method_name, lambda_method_descriptor, cl);
+              ClassNode node_lambda = new ClassNode(content_method_handle.classname, content_method_handle.elementname,
+                                                    content_method_handle.descriptor, content_method_handle.index1,
+                                                    lambda_class_name, lambda_method_name, lambda_method_descriptor, cl);
               node_lambda.simpleName = cl.qualifiedName + "##Lambda_" + invoke_dynamic.index1 + "_" + invoke_dynamic.index2;
               node_lambda.enclosingMethod = InterpreterUtil.makeUniqueKey(mt.getName(), mt.getDescriptor());
 

File: src/org/jetbrains/java/decompiler/main/rels/NestedMemberAccess.java
Patch:
@@ -310,7 +310,7 @@ private boolean replaceInvocations(ClassNode caller, MethodWrapper meth, Exprent
     return res;
   }
 
-  private boolean sameTree(ClassNode caller, ClassNode callee) {
+  private static boolean sameTree(ClassNode caller, ClassNode callee) {
 
     if (caller.classStruct.qualifiedName.equals(callee.classStruct.qualifiedName)) {
       return false;

File: src/org/jetbrains/java/decompiler/modules/decompiler/decompose/DominatorEngine.java
Patch:
@@ -43,7 +43,7 @@ private void orderStatements() {
     }
   }
 
-  private Integer getCommonIDom(Integer key1, Integer key2, VBStyleCollection<Integer, Integer> orderedIDoms) {
+  private static Integer getCommonIDom(Integer key1, Integer key2, VBStyleCollection<Integer, Integer> orderedIDoms) {
 
     if (key1 == null) {
       return key2;

File: src/org/jetbrains/java/decompiler/modules/decompiler/decompose/GenericDominatorEngine.java
Patch:
@@ -45,7 +45,7 @@ private void orderNodes() {
     }
   }
 
-  private IGraphNode getCommonIDom(IGraphNode node1, IGraphNode node2, VBStyleCollection<IGraphNode, IGraphNode> orderedIDoms) {
+  private static IGraphNode getCommonIDom(IGraphNode node1, IGraphNode node2, VBStyleCollection<IGraphNode, IGraphNode> orderedIDoms) {
 
     IGraphNode nodeOld;
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/AnnotationExprent.java
Patch:
@@ -65,7 +65,7 @@ public String toJava(int indent) {
         String indstr1 = InterpreterUtil.getIndentString(indent + 1);
 
         for (int i = 0; i < parnames.size(); i++) {
-          buffer.append(new_line_separator + indstr1);
+          buffer.append(new_line_separator).append(indstr1);
           buffer.append(parnames.get(i));
           buffer.append(" = ");
           buffer.append(parvalues.get(i).toJava(indent + 2));
@@ -74,7 +74,7 @@ public String toJava(int indent) {
             buffer.append(",");
           }
         }
-        buffer.append(new_line_separator + indstr);
+        buffer.append(new_line_separator).append(indstr);
       }
 
       buffer.append(")");

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/ConstExprent.java
Patch:
@@ -116,7 +116,7 @@ public String toJava(int indent) {
     else {
       switch (consttype.type) {
         case CodeConstants.TYPE_BOOLEAN:
-          return new Boolean(((Integer)value).intValue() != 0).toString();
+          return Boolean.toString(((Integer)value).intValue() != 0);
         case CodeConstants.TYPE_CHAR:
           Integer val = (Integer)value;
           String ret = escapes.get(val);
@@ -267,7 +267,7 @@ else if (consttype.equals(VarType.VARTYPE_CLASS)) {
     throw new RuntimeException("invalid constant type");
   }
 
-  private String convertStringToJava(String value, boolean ascii) {
+  private static String convertStringToJava(String value, boolean ascii) {
     char[] arr = value.toCharArray();
     StringBuilder buffer = new StringBuilder(arr.length);
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java
Patch:
@@ -94,7 +94,7 @@ public Exprent copy() {
   }
 
   public String toJava(int indent) {
-    StringBuffer buf = new StringBuffer();
+    StringBuilder buf = new StringBuilder();
 
 
     if (isStatic) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/FunctionExprent.java
Patch:
@@ -568,7 +568,7 @@ private String wrapOperandString(Exprent expr, boolean eq, int indent) {
     return res;
   }
 
-  private VarType getMaxVarType(VarType[] arr) {
+  private static VarType getMaxVarType(VarType[] arr) {
 
     int[] types = new int[]{CodeConstants.TYPE_DOUBLE, CodeConstants.TYPE_FLOAT, CodeConstants.TYPE_LONG};
     VarType[] vartypes = new VarType[]{VarType.VARTYPE_DOUBLE, VarType.VARTYPE_FLOAT, VarType.VARTYPE_LONG};

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
Patch:
@@ -277,15 +277,15 @@ else if (isStatic) {
           VarType leftType = new VarType(CodeConstants.TYPE_OBJECT, 0, classname);
 
           if (rightType.equals(VarType.VARTYPE_OBJECT) && !leftType.equals(rightType)) {
-            buf.append("((" + ExprProcessor.getCastTypeName(leftType) + ")");
+            buf.append("((").append(ExprProcessor.getCastTypeName(leftType)).append(")");
 
             if (instance.getPrecedence() >= FunctionExprent.getPrecedence(FunctionExprent.FUNCTION_CAST)) {
               res = "(" + res + ")";
             }
-            buf.append(res + ")");
+            buf.append(res).append(")");
           }
           else if (instance.getPrecedence() > getPrecedence()) {
-            buf.append("(" + res + ")");
+            buf.append("(").append(res).append(")");
           }
           else {
             buf.append(res);

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
Patch:
@@ -402,7 +402,7 @@ else if (directArrayInit) {
     return buf.toString();
   }
 
-  private String getQualifiedNewInstance(String classname, List<Exprent> lstParams, int indent) {
+  private static String getQualifiedNewInstance(String classname, List<Exprent> lstParams, int indent) {
 
     ClassNode node = DecompilerContext.getClassprocessor().getMapRootClasses().get(classname);
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
Patch:
@@ -115,7 +115,7 @@ public String toJava(int indent) {
         if (processor != null && processor.getVarFinal(new VarVersionPaar(index, version)) == VarTypeProcessor.VAR_FINALEXPLICIT) {
           buf.append("final ");
         }
-        buf.append(ExprProcessor.getCastTypeName(getVartype()) + " ");
+        buf.append(ExprProcessor.getCastTypeName(getVartype())).append(" ");
       }
       buf.append(name == null ? ("var" + index + (version == 0 ? "" : "_" + version)) : name);
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/DirectGraph.java
Patch:
@@ -53,7 +53,7 @@ public void sortReversePostOrder() {
     }
   }
 
-  private void addToReversePostOrderListIterative(DirectNode root, List<DirectNode> lst) {
+  private static void addToReversePostOrderListIterative(DirectNode root, List<DirectNode> lst) {
 
     LinkedList<DirectNode> stackNode = new LinkedList<DirectNode>();
     LinkedList<Integer> stackIndex = new LinkedList<Integer>();

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAConstructorSparseEx.java
Patch:
@@ -416,7 +416,7 @@ else if (outVarVersions.containsKey(predid)) {
     return mapNew;
   }
 
-  private SFormsFastMapDirect mergeMaps(SFormsFastMapDirect mapTo, SFormsFastMapDirect map2) {
+  private static SFormsFastMapDirect mergeMaps(SFormsFastMapDirect mapTo, SFormsFastMapDirect map2) {
 
     if (map2 != null && !map2.isEmpty()) {
       mapTo.union(map2);
@@ -425,7 +425,7 @@ private SFormsFastMapDirect mergeMaps(SFormsFastMapDirect mapTo, SFormsFastMapDi
     return mapTo;
   }
 
-  private boolean mapsEqual(SFormsFastMapDirect map1, SFormsFastMapDirect map2) {
+  private static boolean mapsEqual(SFormsFastMapDirect map1, SFormsFastMapDirect map2) {
 
     if (map1 == null) {
       return map2 == null;

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAUConstructorSparseEx.java
Patch:
@@ -683,7 +683,7 @@ else if (outVarVersions.containsKey(predid)) {
     return mapNew;
   }
 
-  private SFormsFastMapDirect mergeMaps(SFormsFastMapDirect mapTo, SFormsFastMapDirect map2) {
+  private static SFormsFastMapDirect mergeMaps(SFormsFastMapDirect mapTo, SFormsFastMapDirect map2) {
 
     if (map2 != null && !map2.isEmpty()) {
       mapTo.union(map2);
@@ -692,7 +692,7 @@ private SFormsFastMapDirect mergeMaps(SFormsFastMapDirect mapTo, SFormsFastMapDi
     return mapTo;
   }
 
-  private boolean mapsEqual(SFormsFastMapDirect map1, SFormsFastMapDirect map2) {
+  private static boolean mapsEqual(SFormsFastMapDirect map1, SFormsFastMapDirect map2) {
 
     if (map1 == null) {
       return map2 == null;
@@ -789,7 +789,7 @@ private SFormsFastMapDirect createFirstMap(StructMethod mt, RootStatement root)
     return map;
   }
 
-  private Integer getFirstProtectedRange(Statement stat) {
+  private static Integer getFirstProtectedRange(Statement stat) {
 
     while (true) {
       Statement parent = stat.getParent();

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/SequenceStatement.java
Patch:
@@ -112,7 +112,7 @@ public String toJava(int indent) {
     if (islabeled) {
       indstr = InterpreterUtil.getIndentString(indent);
       indent++;
-      buf.append(indstr + "label" + this.id + ": {" + new_line_separator);
+      buf.append(indstr).append("label").append(this.id).append(": {").append(new_line_separator);
     }
 
     boolean notempty = false;
@@ -132,7 +132,7 @@ public String toJava(int indent) {
     }
 
     if (islabeled) {
-      buf.append(indstr + "}" + new_line_separator);
+      buf.append(indstr).append("}").append(new_line_separator);
     }
 
     return buf.toString();

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/CheckTypesResult.java
Patch:
@@ -43,7 +43,7 @@ public List<ExprentTypePair> getLstMinTypeExprents() {
     return lstMinTypeExprents;
   }
 
-  public class ExprentTypePair {
+  public static class ExprentTypePair {
     public Exprent exprent;
     public VarType type;
     public VarType desttype;

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarTypeProcessor.java
Patch:
@@ -102,7 +102,7 @@ public void calculateVarTypes(RootStatement root, DirectGraph dgraph) {
     while (!processVarTypes(dgraph)) ;
   }
 
-  private void resetExprentTypes(DirectGraph dgraph) {
+  private static void resetExprentTypes(DirectGraph dgraph) {
 
     dgraph.iterateExprents(new DirectGraph.ExprentIterator() {
       public int processExprent(Exprent exprent) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsGraph.java
Patch:
@@ -106,7 +106,7 @@ public Set<? extends IGraphNode> getRoots() {
     engine.initialize();
   }
 
-  private LinkedList<VarVersionNode> getReversedPostOrder(Collection<VarVersionNode> roots) {
+  private static LinkedList<VarVersionNode> getReversedPostOrder(Collection<VarVersionNode> roots) {
 
     LinkedList<VarVersionNode> lst = new LinkedList<VarVersionNode>();
     HashSet<VarVersionNode> setVisited = new HashSet<VarVersionNode>();
@@ -122,7 +122,7 @@ private LinkedList<VarVersionNode> getReversedPostOrder(Collection<VarVersionNod
     return lst;
   }
 
-  private void addToReversePostOrderListIterative(VarVersionNode root, List<VarVersionNode> lst, HashSet<VarVersionNode> setVisited) {
+  private static void addToReversePostOrderListIterative(VarVersionNode root, List<VarVersionNode> lst, HashSet<VarVersionNode> setVisited) {
 
     HashMap<VarVersionNode, List<VarVersionEdge>> mapNodeSuccs = new HashMap<VarVersionNode, List<VarVersionEdge>>();
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
Patch:
@@ -66,7 +66,7 @@ public void setVarVersions(RootStatement root) {
     setNewVarIndices(typeproc, dgraph);
   }
 
-  private void mergePhiVersions(SSAConstructorSparseEx ssa, DirectGraph dgraph) {
+  private static void mergePhiVersions(SSAConstructorSparseEx ssa, DirectGraph dgraph) {
 
     // collect phi versions
     List<HashSet<VarVersionPaar>> lst = new ArrayList<HashSet<VarVersionPaar>>();
@@ -125,7 +125,7 @@ public int processExprent(Exprent exprent) {
     });
   }
 
-  private void eliminateNonJavaTypes(VarTypeProcessor typeproc) {
+  private static void eliminateNonJavaTypes(VarTypeProcessor typeproc) {
 
     HashMap<VarVersionPaar, VarType> mapExprentMaxTypes = typeproc.getMapExprentMaxTypes();
     HashMap<VarVersionPaar, VarType> mapExprentMinTypes = typeproc.getMapExprentMinTypes();
@@ -152,7 +152,7 @@ else if (type.type == CodeConstants.TYPE_NULL) {
     }
   }
 
-  private void simpleMerge(VarTypeProcessor typeproc, DirectGraph dgraph, StructMethod mt) {
+  private static void simpleMerge(VarTypeProcessor typeproc, DirectGraph dgraph, StructMethod mt) {
 
     HashMap<VarVersionPaar, VarType> mapExprentMaxTypes = typeproc.getMapExprentMaxTypes();
     HashMap<VarVersionPaar, VarType> mapExprentMinTypes = typeproc.getMapExprentMinTypes();

File: src/org/jetbrains/java/decompiler/modules/renamer/IdentifierConverter.java
Patch:
@@ -193,11 +193,12 @@ private void renameClass(StructClass cl) {
     }
 
     String classOldFullName = cl.qualifiedName;
-    String classNewFullName = classOldFullName;
 
     // TODO: rename packages
     String clsimplename = ConverterHelper.getSimpleClassName(classOldFullName);
     if (helper.toBeRenamed(IIdentifierRenamer.ELEMENT_CLASS, clsimplename, null, null)) {
+      String classNewFullName;
+
       do {
         classNewFullName = ConverterHelper.replaceSimpleClassName(classOldFullName,
                                                                   helper.getNextClassname(classOldFullName, ConverterHelper
@@ -339,7 +340,7 @@ private String buildNewDescriptor(boolean isField, String descriptor) {
     return descriptor;
   }
 
-  private List<ClassWrapperNode> getReversePostOrderListIterative(List<ClassWrapperNode> roots) {
+  private static List<ClassWrapperNode> getReversePostOrderListIterative(List<ClassWrapperNode> roots) {
 
     List<ClassWrapperNode> res = new ArrayList<ClassWrapperNode>();
 

File: src/org/jetbrains/java/decompiler/struct/consts/ConstantPool.java
Patch:
@@ -252,7 +252,7 @@ private String buildNewClassname(String classname) {
           buffer.append("[");
         }
 
-        buffer.append("L" + newname + ";");
+        buffer.append("L").append(newname).append(";");
       }
       else {
         buffer.append(newname);

File: src/org/jetbrains/java/decompiler/struct/gen/VarType.java
Patch:
@@ -306,7 +306,7 @@ private void setStackSize(int type) {
     }
   }
 
-  private int getType(char c) {
+  private static int getType(char c) {
     switch (c) {
       case 'B':
         return CodeConstants.TYPE_BYTE;
@@ -343,7 +343,7 @@ private int getType(char c) {
     }
   }
 
-  private String getChar(int type) {
+  private static String getChar(int type) {
     switch (type) {
       case CodeConstants.TYPE_BYTE:
         return "B";

File: src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java
Patch:
@@ -221,7 +221,7 @@ public static String buildJavaClassName(GenericType type) {
 
     String res = name.replace('/', '.');
 
-    if (res.indexOf("$") >= 0) {
+    if (res.contains("$")) {
       StructClass cl = DecompilerContext.getStructcontext().getClass(name);
       if (cl == null || !cl.isOwn()) {
         res = res.replace('$', '.');

File: src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
Patch:
@@ -105,7 +105,7 @@ private void parseSignature(String sig) {
     }
   }
 
-  private String getNextClassSignature(String value) {
+  private static String getNextClassSignature(String value) {
 
     int counter = 0;
     int index = 0;
@@ -131,7 +131,7 @@ private String getNextClassSignature(String value) {
     return value.substring(0, index);
   }
 
-  private void parseArgumentsList(String value, GenericType type) {
+  private static void parseArgumentsList(String value, GenericType type) {
 
     if (value == null) {
       return;
@@ -214,7 +214,7 @@ public static String getNextType(String value) {
     return value.substring(0, index + 1);
   }
 
-  private int getType(char c) {
+  private static int getType(char c) {
     switch (c) {
       case 'B':
         return CodeConstants.TYPE_BYTE;

File: src/org/jetbrains/java/decompiler/struct/lazy/LazyLoader.java
Patch:
@@ -158,7 +158,7 @@ public DataInputFullStream getClassStream(String qualifiedClassName) throws IOEx
     return link == null ? null : getClassStream(link.externPath, link.internPath);
   }
 
-  private void skipAttributes(DataInputFullStream in) throws IOException {
+  private static void skipAttributes(DataInputFullStream in) throws IOException {
 
     int length = in.readUnsignedShort();
     for (int i = 0; i < length; i++) {

File: src/org/jetbrains/java/decompiler/util/FastSparseSetFactory.java
Patch:
@@ -253,7 +253,7 @@ private void setNext() {
       }
     }
 
-    private void changeNext(int[] arrnext, int key, int oldnext, int newnext) {
+    private static void changeNext(int[] arrnext, int key, int oldnext, int newnext) {
       for (int i = key - 1; i >= 0; i--) {
         if (arrnext[i] == oldnext) {
           arrnext[i] = newnext;

File: src/org/jetbrains/java/decompiler/util/InterpreterUtil.java
Patch:
@@ -83,9 +83,8 @@ else if (c2 == null) {
       return false;
     }
 
-    HashSet<?> set = new HashSet(c1);
+    HashSet<Object> set = new HashSet<Object>(c1);
     set.removeAll(c2);
-
     return (set.size() == 0);
   }
 

File: src/org/jetbrains/java/decompiler/util/VBStyleCollection.java
Patch:
@@ -115,7 +115,7 @@ public void removeWithKey(K key) {
 
   public E remove(int index) {
     addToListIndex(index + 1, -1);
-    Object obj = lstKeys.get(index);
+    K obj = lstKeys.get(index);
     if (obj != null) {
       map.remove(obj);
     }

File: src/org/jetbrains/java/decompiler/code/Instruction.java
Patch:
@@ -58,7 +58,7 @@ public int getOperand(int index) {
   }
 
   public Instruction clone() {
-    return ConstantsUtil.getInstructionInstance(opcode, wide, group, bytecode_version, operands == null ? null : (int[])operands.clone());
+    return ConstantsUtil.getInstructionInstance(opcode, wide, group, bytecode_version, operands == null ? null : operands.clone());
   }
 
   public String toString() {

File: src/org/jetbrains/java/decompiler/code/interpreter/InstructionImpact.java
Patch:
@@ -432,7 +432,7 @@ private static void processSpecialInstructions(DataPoint data, Instruction instr
         stack.push(new VarType(var1.type, var1.arraydim - 1, var1.value));
         break;
       case CodeConstants.opc_astore:
-        data.setVariable(instr.getOperand(0), (VarType)stack.pop());
+        data.setVariable(instr.getOperand(0), stack.pop());
         break;
       case CodeConstants.opc_dup:
       case CodeConstants.opc_dup_x1:

File: src/org/jetbrains/java/decompiler/main/ClassReference14Processor.java
Patch:
@@ -225,7 +225,7 @@ private boolean replaceInvocations(Exprent exprent, ClassWrapper wrapper, Method
 
     boolean res = false;
 
-    for (; ; ) {
+    while (true) {
 
       boolean found = false;
 

File: src/org/jetbrains/java/decompiler/main/ClassWriter.java
Patch:
@@ -159,7 +159,6 @@ public void classLambdaToJava(ClassNode node, BufferedWriter writer, Exprent met
 
         boolean firstpar = true;
         int index = node.lambda_information.is_content_method_static ? 0 : 1;
-        ;
 
         int start_index = md_content.params.length - md_lambda.params.length;
 
@@ -625,7 +624,6 @@ public boolean methodLambdaToJava(ClassNode node_lambda,
 
       boolean firstpar = true;
       int index = node_lambda.lambda_information.is_content_method_static ? 0 : 1;
-      ;
 
       int start_index = md_content.params.length - md_lambda.params.length;
 

File: src/org/jetbrains/java/decompiler/main/InitializerProcessor.java
Patch:
@@ -191,7 +191,7 @@ private static void extractDynamicInitializers(ClassWrapper wrapper) {
       return;
     }
 
-    for (; ; ) {
+    while (true) {
 
       String fieldWithDescr = null;
       Exprent value = null;

File: src/org/jetbrains/java/decompiler/main/decompiler/ConsoleDecompiler.java
Patch:
@@ -31,7 +31,7 @@
 import java.util.zip.ZipFile;
 import java.util.zip.ZipOutputStream;
 
-
+@SuppressWarnings({"UseOfSystemOutOrSystemErr", "CallToPrintStackTrace"})
 public class ConsoleDecompiler implements IBytecodeProvider, IDecompilatSaver {
 
   private File root;

File: src/org/jetbrains/java/decompiler/main/extern/IBytecodeProvider.java
Patch:
@@ -19,5 +19,5 @@
 
 public interface IBytecodeProvider {
 
-  public InputStream getBytecodeStream(String externPath, String internPath);
+  InputStream getBytecodeStream(String externPath, String internPath);
 }

File: src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
Patch:
@@ -151,7 +151,6 @@ public int processExprent(Exprent exprent) {
               InvocationExprent inv_dynamic = new_expr.getConstructor();
 
               int param_index = is_static_lambda_content ? 0 : 1;
-              ;
               int varindex = is_static_lambda_content ? 0 : 1;
 
               for (int i = 0; i < vars_count; ++i) {
@@ -713,7 +712,7 @@ private String getEnclosingVarField(StructClass cl, MethodWrapper meth, DirectGr
   private void mergeListSignatures(List<VarFieldPair> first, List<VarFieldPair> second, boolean both) {
 
     int i = 1;
-    for (; ; ) {
+    while (true) {
       if (first.size() <= i || second.size() <= i) {
         break;
       }

File: src/org/jetbrains/java/decompiler/main/rels/NestedMemberAccess.java
Patch:
@@ -286,7 +286,7 @@ private boolean replaceInvocations(ClassNode caller, MethodWrapper meth, Exprent
       res |= replaceInvocations(caller, meth, expr);
     }
 
-    for (; ; ) {
+    while (true) {
 
       boolean found = false;
 
@@ -397,10 +397,10 @@ private Exprent replaceAccessExprent(ClassNode caller, MethodWrapper methdest, I
         AssignmentExprent ret;
         if (source.type == Exprent.EXPRENT_EXIT) {
           ExitExprent extex = (ExitExprent)source;
-          ret = (AssignmentExprent)((AssignmentExprent)extex.getValue()).copy();
+          ret = (AssignmentExprent)extex.getValue().copy();
         }
         else {
-          ret = (AssignmentExprent)((AssignmentExprent)source).copy();
+          ret = (AssignmentExprent)source.copy();
         }
         FieldExprent fexpr = (FieldExprent)ret.getLeft();
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/ConcatenationHelper.java
Patch:
@@ -62,7 +62,7 @@ else if (bufferClass.equals(iex.getClassname())) {
     // iterate in depth, collecting possible operands
     List<Exprent> lstOperands = new ArrayList<Exprent>();
 
-    for (; ; ) {
+    while (true) {
 
       int found = 0;
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/DecHelper.java
Patch:
@@ -76,7 +76,7 @@ public static boolean isChoiceStatement(Statement head, List<Statement> lst) {
       return false;
     }
 
-    for (; ; ) {
+    while (true) {
 
       lst.clear();
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/DomHelper.java
Patch:
@@ -254,7 +254,7 @@ private static void buildSynchronized(Statement stat) {
 
     if (stat.type == Statement.TYPE_SEQUENCE) {
 
-      for (; ; ) {
+      while (true) {
 
         boolean found = false;
 
@@ -371,7 +371,7 @@ private static boolean processStatement(Statement general, HashMap<Integer, Set<
 
           boolean forceall = i != 0;
 
-          for (; ; ) {
+          while (true) {
 
             if (findSimpleStatements(general, mapExtPost)) {
               reducibility = 0;
@@ -494,7 +494,7 @@ private static Statement findGeneralStatement(Statement stat, boolean forceall,
         // collect statement nodes
         HashSet<Statement> setHandlers = new HashSet<Statement>();
         setHandlers.add(head);
-        for (; ; ) {
+        while (true) {
 
           boolean hdfound = false;
           Iterator<Statement> itHandlers = setHandlers.iterator();

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExitHelper.java
Patch:
@@ -91,7 +91,7 @@ private static int integrateExits(Statement stat) {
 
     if (stat.getExprents() == null) {
 
-      for (; ; ) {
+      while (true) {
 
         int changed = 0;
 
@@ -160,7 +160,7 @@ private static int integrateExits(Statement stat) {
           bstat.addSuccessor(newexitedge);
           oldexitedge.closure.addLabeledEdge(newexitedge);
 
-          SequenceStatement block = new SequenceStatement(Arrays.asList(new Statement[]{stat, bstat}));
+          SequenceStatement block = new SequenceStatement(Arrays.asList(stat, bstat));
           block.setAllParent();
 
           parent.replaceStatement(stat, block);
@@ -324,7 +324,7 @@ private static Statement addSharedInitializerReturn(RootStatement root) {
     bstat.setExprents(new ArrayList<Exprent>(Arrays.asList(new Exprent[]{retexpr})));
 
     // build sequence to replace the former top statement
-    SequenceStatement seq = new SequenceStatement(Arrays.asList(new Statement[]{top, bstat}));
+    SequenceStatement seq = new SequenceStatement(Arrays.asList(top, bstat));
     top.setParent(seq);
     bstat.setParent(seq);
     seq.setParent(root);

File: src/org/jetbrains/java/decompiler/modules/decompiler/ExprentStack.java
Patch:
@@ -36,9 +36,7 @@ public Exprent push(Exprent item) {
 
   public Exprent pop() {
 
-    Exprent o = this.remove(--pointer);
-
-    return o;
+    return this.remove(--pointer);
   }
 
   public ExprentStack clone() {

File: src/org/jetbrains/java/decompiler/modules/decompiler/IdeaNotNullHelper.java
Patch:
@@ -78,7 +78,7 @@ private static boolean findAndRemoveParameterCheck(Statement stat, StructMethod
         Exprent second_param = func.getLstOperands().get(1);
 
         if (second_param.type == Exprent.EXPRENT_CONST &&
-            ((ConstExprent)second_param).getExprType().type == CodeConstants.TYPE_NULL) { // TODO: reversed parameter order
+            second_param.getExprType().type == CodeConstants.TYPE_NULL) { // TODO: reversed parameter order
           if (first_param.type == Exprent.EXPRENT_VAR) {
             VarExprent var = (VarExprent)first_param;
 
@@ -227,7 +227,7 @@ private static boolean removeReturnCheck(Statement stat, StructMethod mt) {
             Statement elsebranch = ifparent.getElsestat();
 
             if (second_param.type == Exprent.EXPRENT_CONST &&
-                ((ConstExprent)second_param).getExprType().type == CodeConstants.TYPE_NULL) { // TODO: reversed parameter order
+                second_param.getExprType().type == CodeConstants.TYPE_NULL) { // TODO: reversed parameter order
               //if(first_param.type == Exprent.EXPRENT_VAR && ((VarExprent)first_param).getIndex() == var_value.getIndex()) {
               if (first_param.equals(exprent_value)) {        // TODO: check for absence of side effects like method invocations etc.
                 if (ifbranch.type == Statement.TYPE_BASICBLOCK &&
@@ -291,7 +291,7 @@ else if (parent != null &&
               Statement ifbranch = ifstat.getIfstat();
 
               if (second_param.type == Exprent.EXPRENT_CONST &&
-                  ((ConstExprent)second_param).getExprType().type == CodeConstants.TYPE_NULL) { // TODO: reversed parameter order
+                  second_param.getExprType().type == CodeConstants.TYPE_NULL) { // TODO: reversed parameter order
                 if (first_param.equals(exprent_value)) {        // TODO: check for absence of side effects like method invocations etc.
                   if (ifbranch.type == Statement.TYPE_BASICBLOCK &&
                       ifbranch.getExprents().size() == 1 &&

File: src/org/jetbrains/java/decompiler/modules/decompiler/InlineSingleBlockHelper.java
Patch:
@@ -155,7 +155,7 @@ private static boolean sameCatchRanges(StatEdge edge) {
     Statement from = edge.getSource();
     Statement to = edge.getDestination();
 
-    for (; ; ) {
+    while (true) {
 
       Statement parent = from.getParent();
       if (parent.containsStatementStrict(to)) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/LabelHelper.java
Patch:
@@ -65,7 +65,7 @@ private static void liftClosures(Statement stat) {
 
             List<Statement> lst = new ArrayList<Statement>();
             if (parent.type == Statement.TYPE_SEQUENCE) {
-              lst.addAll(((SequenceStatement)parent).getStats());
+              lst.addAll(parent.getStats());
             }
             else if (parent.type == Statement.TYPE_SWITCH) {
               lst.addAll(((SwitchStatement)parent).getCaseStatements());
@@ -489,7 +489,7 @@ public static void replaceContinueWithBreak(Statement stat) {
   private static Statement getMinContinueClosure(StatEdge edge) {
 
     Statement closure = edge.closure;
-    for (; ; ) {
+    while (true) {
 
       boolean found = false;
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/LoopExtractHelper.java
Patch:
@@ -44,7 +44,7 @@ private static int extractLoopsRec(Statement stat) {
 
     boolean res = false;
 
-    for (; ; ) {
+    while (true) {
 
       boolean updated = false;
 
@@ -183,7 +183,7 @@ private static void extractIfBlock(DoStatement loop, IfStatement ifstat) {
 
     loop.addLabeledEdge(ifedge);
 
-    SequenceStatement block = new SequenceStatement(Arrays.asList(new Statement[]{loop, target}));
+    SequenceStatement block = new SequenceStatement(Arrays.asList(loop, target));
     loop.getParent().replaceStatement(loop, block);
     block.setAllParent();
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/LowBreakHelper.java
Patch:
@@ -32,7 +32,7 @@ public static void lowBreakLabels(Statement root) {
 
   private static void lowBreakLabelsRec(Statement stat) {
 
-    for (; ; ) {
+    while (true) {
 
       boolean found = false;
 
@@ -79,7 +79,7 @@ public static boolean isBreakEdgeLabeled(Statement source, Statement closure) {
 
   public static Statement getMinClosure(Statement closure, Statement source) {
 
-    for (; ; ) {
+    while (true) {
 
       Statement newclosure = null;
 
@@ -152,7 +152,7 @@ private static void liftBreakLabels(Statement stat) {
     }
 
 
-    for (; ; ) {
+    while (true) {
 
       boolean found = false;
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/MergeHelper.java
Patch:
@@ -323,7 +323,7 @@ private static boolean matchFor(DoStatement stat) {
 
     // search for an initializing exprent
     Statement current = stat;
-    for (; ; ) {
+    while (true) {
       Statement parent = current.getParent();
       if (parent == null) {
         break;

File: src/org/jetbrains/java/decompiler/modules/decompiler/SequenceHelper.java
Patch:
@@ -142,7 +142,7 @@ private static void condenseSequencesRec(Statement stat) {
 
     // replace flat statements with synthetic basic blocks
     outer:
-    for (; ; ) {
+    while (true) {
       for (Statement st : stat.getStats()) {
         if ((st.getStats().isEmpty() || st.getExprents() != null) && st.type != Statement.TYPE_BASICBLOCK) {
           destroyAndFlattenStatement(st);
@@ -185,7 +185,7 @@ private static void removeEmptyStatements(SequenceStatement sequence) {
 
     mergeFlatStatements(sequence);
 
-    for (; ; ) {
+    while (true) {
 
       boolean found = false;
 
@@ -242,7 +242,7 @@ private static void removeEmptyStatements(SequenceStatement sequence) {
 
   private static void mergeFlatStatements(SequenceStatement sequence) {
 
-    for (; ; ) {
+    while (true) {
 
       Statement next = null;
       Statement current = null;

File: src/org/jetbrains/java/decompiler/modules/decompiler/StackVarsProcessor.java
Patch:
@@ -43,7 +43,7 @@ public void simplifyStackVars(RootStatement root, StructMethod mt, StructClass c
 
     SSAUConstructorSparseEx ssau = null;
 
-    for (; ; ) {
+    while (true) {
 
       boolean found = false;
 
@@ -287,7 +287,7 @@ private int[] iterateExprent(List<Exprent> lstExprents, int index, Exprent next,
     int changed = 0;
 
     for (Exprent expr : exprent.getAllExprents()) {
-      for (; ; ) {
+      while (true) {
         Object[] arr = iterateChildExprent(expr, exprent, next, mapVarValues, ssau);
         Exprent retexpr = (Exprent)arr[0];
         changed |= (Boolean)arr[1] ? 1 : 0;
@@ -464,7 +464,7 @@ private Object[] iterateChildExprent(Exprent exprent,
     boolean changed = false;
 
     for (Exprent expr : exprent.getAllExprents()) {
-      for (; ; ) {
+      while (true) {
         Object[] arr = iterateChildExprent(expr, parent, next, mapVarValues, ssau);
         Exprent retexpr = (Exprent)arr[0];
         changed |= (Boolean)arr[1];

File: src/org/jetbrains/java/decompiler/modules/decompiler/decompose/DominatorEngine.java
Patch:
@@ -78,7 +78,7 @@ private void calcIDoms() {
     // exclude first statement
     List<Integer> lstIds = colOrderedIDoms.getLstKeys().subList(1, colOrderedIDoms.getLstKeys().size());
 
-    for (; ; ) {
+    while (true) {
 
       boolean changed = false;
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/decompose/FastExtendedPostdominanceHelper.java
Patch:
@@ -286,7 +286,7 @@ public boolean action(Statement node, HashMap<Integer, FastFixedSet<Integer>> ma
 
   private void iterateReachability(IReachabilityAction action, int edgetype) {
 
-    for (; ; ) {
+    while (true) {
 
       boolean iterate = false;
 
@@ -350,6 +350,6 @@ private void iterateReachability(IReachabilityAction action, int edgetype) {
 
 
   private interface IReachabilityAction {
-    public boolean action(Statement node, HashMap<Integer, FastFixedSet<Integer>> mapSets);
+    boolean action(Statement node, HashMap<Integer, FastFixedSet<Integer>> mapSets);
   }
 }

File: src/org/jetbrains/java/decompiler/modules/decompiler/decompose/GenericDominatorEngine.java
Patch:
@@ -91,7 +91,7 @@ private void calcIDoms() {
 
     List<IGraphNode> lstNodes = colOrderedIDoms.getLstKeys();
 
-    for (; ; ) {
+    while (true) {
 
       boolean changed = false;
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/decompose/IGraph.java
Patch:
@@ -20,7 +20,7 @@
 
 public interface IGraph {
 
-  public List<? extends IGraphNode> getReversePostOrderList();
+  List<? extends IGraphNode> getReversePostOrderList();
 
-  public Set<? extends IGraphNode> getRoots();
+  Set<? extends IGraphNode> getRoots();
 }

File: src/org/jetbrains/java/decompiler/modules/decompiler/decompose/IGraphNode.java
Patch:
@@ -19,5 +19,5 @@
 
 public interface IGraphNode {
 
-  public List<? extends IGraphNode> getPredecessors();
+  List<? extends IGraphNode> getPredecessors();
 }

File: src/org/jetbrains/java/decompiler/modules/decompiler/deobfuscator/IrreducibleCFGDeobfuscator.java
Patch:
@@ -63,7 +63,7 @@ public Node(Integer id) {
     }
 
     // transforming and reducing the graph
-    for (; ; ) {
+    while (true) {
       int ttype = 0;
       Node node = null;
 

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
Patch:
@@ -108,7 +108,7 @@ public Set<VarVersionPaar> getAllVariables() {
     lstAllExprents.add(this);
 
     for (Exprent expr : lstAllExprents) {
-      if (expr.type == Exprent.EXPRENT_VAR) {
+      if (expr.type == EXPRENT_VAR) {
         set.add(new VarVersionPaar((VarExprent)expr));
       }
     }

File: src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
Patch:
@@ -43,7 +43,6 @@ public class VarExprent extends Exprent {
   private VarType vartype;
 
   private boolean definition = false;
-  ;
 
   private VarProcessor processor;
 
@@ -52,7 +51,6 @@ public class VarExprent extends Exprent {
   private boolean classdef = false;
 
   private boolean stack = false;
-  ;
 
   {
     this.type = EXPRENT_VAR;

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/DirectGraph.java
Patch:
@@ -131,6 +131,6 @@ public interface ExprentIterator {
     // 0 - success, do nothing
     // 1 - cancel iteration
     // 2 - success, delete exprent
-    public int processExprent(Exprent exprent);
+    int processExprent(Exprent exprent);
   }
 }

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/FlattenStatementsHelper.java
Patch:
@@ -321,7 +321,7 @@ public StatementStackEntry(Statement statement, LinkedList<StackEntry> stackFina
 
           boolean isFinallyExit = false;
 
-          for (; ; ) {
+          while (true) {
 
             StackEntry entry = null;
             if (!stack.isEmpty()) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAUConstructorSparseEx.java
Patch:
@@ -791,7 +791,7 @@ private SFormsFastMapDirect createFirstMap(StructMethod mt, RootStatement root)
 
   private Integer getFirstProtectedRange(Statement stat) {
 
-    for (; ; ) {
+    while (true) {
       Statement parent = stat.getParent();
 
       if (parent == null) {

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/CatchAllStatement.java
Patch:
@@ -49,8 +49,6 @@ private CatchAllStatement() {
     type = Statement.TYPE_CATCHALL;
   }
 
-  ;
-
   private CatchAllStatement(Statement head, Statement handler) {
 
     this();
@@ -102,7 +100,7 @@ public static Statement isHead(Statement head) {
             return null;
           }
 
-          if (DecHelper.checkStatementExceptions(Arrays.asList(new Statement[]{head, exc}))) {
+          if (DecHelper.checkStatementExceptions(Arrays.asList(head, exc))) {
             return new CatchAllStatement(head, exc);
           }
         }

File: src/org/jetbrains/java/decompiler/modules/decompiler/stats/SequenceStatement.java
Patch:
@@ -51,7 +51,7 @@ public SequenceStatement(List<Statement> lst) {
 
   private SequenceStatement(Statement head, Statement tail) {
 
-    this(Arrays.asList(new Statement[]{head, tail}));
+    this(Arrays.asList(head, tail));
 
     List<StatEdge> lstSuccs = tail.getSuccessorEdges(STATEDGE_DIRECT_ALL);
     if (!lstSuccs.isEmpty()) {
@@ -88,7 +88,7 @@ public static Statement isHead2Block(Statement head) {
           && !stat.isMonitorEnter()) {
 
         if (stat.getLastBasicType() == Statement.LASTBASICTYPE_GENERAL) {
-          if (DecHelper.checkStatementExceptions(Arrays.asList(new Statement[]{head, stat}))) {
+          if (DecHelper.checkStatementExceptions(Arrays.asList(head, stat))) {
             return new SequenceStatement(head, stat);
           }
         }

File: src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
Patch:
@@ -148,7 +148,7 @@ public void setVarDefinitions() {
             continue;
           }
           else {
-            List<Exprent> lstSpecial = Arrays.asList(new Exprent[]{dstat.getConditionExprent(), dstat.getIncExprent()});
+            List<Exprent> lstSpecial = Arrays.asList(dstat.getConditionExprent(), dstat.getIncExprent());
             for (VarExprent var : getAllVars(lstSpecial)) {
               if (var.getIndex() == index.intValue()) {
                 stat = stat.getParent();

File: src/org/jetbrains/java/decompiler/modules/renamer/IdentifierConverter.java
Patch:
@@ -56,7 +56,7 @@ public void rename(StructContext context) {
           helper = (IIdentifierRenamer)IdentifierConverter.class.getClassLoader().loadClass(user_class).newInstance();
         }
         catch (Exception ex) {
-          ; // ignore errors
+          // ignore errors
         }
       }
 

File: src/org/jetbrains/java/decompiler/struct/IDecompiledData.java
Patch:
@@ -17,7 +17,7 @@
 
 public interface IDecompiledData {
 
-  public String getClassEntryName(StructClass cl, String entryname);
+  String getClassEntryName(StructClass cl, String entryname);
 
-  public String getClassContent(StructClass cl);
+  String getClassContent(StructClass cl);
 }

File: src/org/jetbrains/java/decompiler/struct/ISaveClass.java
Patch:
@@ -22,9 +22,9 @@
 
 public interface ISaveClass {
 
-  public String getClassEntryName(StructClass cl, String entryname);
+  String getClassEntryName(StructClass cl, String entryname);
 
-  public void saveClassToFile(StructClass cl, File file) throws FileNotFoundException, IOException;
+  void saveClassToFile(StructClass cl, File file) throws FileNotFoundException, IOException;
 
-  public void saveClassToStream(StructClass cl, DataOutputStream out);
+  void saveClassToStream(StructClass cl, DataOutputStream out);
 }

File: src/org/jetbrains/java/decompiler/struct/StructContext.java
Patch:
@@ -41,8 +41,6 @@ public class StructContext {
 
   private HashMap<String, ContextUnit> units = new HashMap<String, ContextUnit>();
 
-  private ContextUnit defaultUnit;
-
   private IDecompilatSaver saver;
 
   private IDecompiledData decdata;
@@ -53,7 +51,7 @@ public StructContext(IDecompilatSaver saver, IDecompiledData decdata, LazyLoader
     this.decdata = decdata;
     this.loader = loader;
 
-    defaultUnit = new ContextUnit(ContextUnit.TYPE_FOLDER, null, "", true, saver, decdata);
+    ContextUnit defaultUnit = new ContextUnit(ContextUnit.TYPE_FOLDER, null, "", true, saver, decdata);
     units.put("", defaultUnit);
   }
 

File: src/org/jetbrains/java/decompiler/struct/attr/StructExceptionsAttribute.java
Patch:
@@ -51,7 +51,7 @@ public void writeToStream(DataOutputStream out) throws IOException {
     if (len > 0) {
       info = new byte[len * 2];
       for (int i = 0, j = 0; i < len; i++, j += 2) {
-        int index = ((Integer)throwsExceptions.get(i)).intValue();
+        int index = throwsExceptions.get(i).intValue();
         info[j] = (byte)(index >> 8);
         info[j + 1] = (byte)(index & 0xFF);
       }
@@ -63,7 +63,7 @@ public void writeToStream(DataOutputStream out) throws IOException {
   }
 
   public String getExcClassname(int index, ConstantPool pool) {
-    return pool.getPrimitiveConstant(((Integer)throwsExceptions.get(index)).intValue()).getString();
+    return pool.getPrimitiveConstant(throwsExceptions.get(index).intValue()).getString();
   }
 
   public List<Integer> getThrowsExceptions() {

File: src/org/jetbrains/java/decompiler/struct/consts/ConstantPool.java
Patch:
@@ -129,7 +129,7 @@ public void writeToOutputStream(DataOutputStream out) throws FileNotFoundExcepti
 
     out.writeShort(pool.size());
     for (int i = 1; i < pool.size(); i++) {
-      PooledConstant cnst = (PooledConstant)pool.get(i);
+      PooledConstant cnst = pool.get(i);
       if (cnst != null) {
         cnst.writeToStream(out);
       }

File: src/org/jetbrains/java/decompiler/struct/consts/LinkConstant.java
Patch:
@@ -40,7 +40,6 @@ public class LinkConstant extends PooledConstant {
   public int paramCount = 0;
 
   public boolean isVoid = false;
-  ;
 
   public boolean returnCategory2 = false;
 

File: src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java
Patch:
@@ -127,7 +127,7 @@ private static String parseFormalParameters(String signature, List<String> fpara
 
       List<GenericType> lstBounds = new ArrayList<GenericType>();
 
-      for (; ; ) {
+      while (true) {
         if (value.charAt(0) == ':') {
           // empty superclass, skip
           value = value.substring(1);
@@ -199,7 +199,7 @@ else if (tp == CodeConstants.TYPE_OBJECT) {
 
           GenericType genpar = type.getArguments().get(i);
           if (genpar != null) {
-            buffer.append(GenericMain.getGenericCastTypeName(genpar));
+            buffer.append(getGenericCastTypeName(genpar));
           }
         }
         buffer.append(">");

File: src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
Patch:
@@ -70,7 +70,7 @@ private void parseSignature(String sig) {
           type = CodeConstants.TYPE_OBJECT;
           sig = sig.substring(index + 1, sig.length() - 1);
 
-          for (; ; ) {
+          while (true) {
             String cl = getNextClassSignature(sig);
 
             String name = cl;

File: src/org/jetbrains/java/decompiler/struct/lazy/LazyLoader.java
Patch:
@@ -109,7 +109,7 @@ public byte[] loadBytecode(StructMethod mt, int code_fulllength) {
         int name_index = in.readUnsignedShort();
         int descriptor_index = in.readUnsignedShort();
 
-        String elem_arr[] = pool.getClassElement(ConstantPool.METHOD, this_class, name_index, descriptor_index);
+        String[] elem_arr = pool.getClassElement(ConstantPool.METHOD, this_class, name_index, descriptor_index);
         String name = elem_arr[0];
 
         if (mt.getName().equals(name)) {

File: src/org/jetbrains/java/decompiler/util/DataInputFullStream.java
Patch:
@@ -25,14 +25,14 @@ public DataInputFullStream(InputStream in) {
     super(in);
   }
 
-  public final int readFull(byte b[]) throws IOException {
+  public final int readFull(byte[] b) throws IOException {
 
     int length = b.length;
     byte[] btemp = new byte[length];
     int pos = 0;
 
     int bytes_read = -1;
-    for (; ; ) {
+    while (true) {
       bytes_read = read(btemp, 0, length - pos);
       if (bytes_read == -1) {
         return -1;

File: src/org/jetbrains/java/decompiler/util/FastSparseSetFactory.java
Patch:
@@ -122,9 +122,7 @@ public FastSparseSet<E> getCopy() {
       System.arraycopy(data, 0, cpdata, 0, arrlength);
       System.arraycopy(next, 0, cpnext, 0, arrlength);
 
-      FastSparseSet<E> copy = new FastSparseSet<E>(factory, cpdata, cpnext);
-
-      return copy;
+      return new FastSparseSet<E>(factory, cpdata, cpnext);
     }
 
     private int[] ensureCapacity(int index) {

File: src/org/jetbrains/java/decompiler/util/SFormsFastMap.java
Patch:
@@ -243,9 +243,9 @@ private E[] ensureCapacity(E[] arr, int size, boolean exact) {
     return arrnew;
   }
 
-  public static interface IElementsUnion<E> {
-    public E union(E first, E second);
+  public interface IElementsUnion<E> {
+    E union(E first, E second);
 
-    public E copy(E element);
+    E copy(E element);
   }
 }

File: src/org/jetbrains/java/decompiler/util/SFormsFastMapOld.java
Patch:
@@ -217,10 +217,10 @@ private void ensureCapacity(ArrayList<Entry<Integer, E>> lst, int size, boolean
     }
   }
 
-  public static interface IElementsUnion<E> {
-    public E union(E first, E second);
+  public interface IElementsUnion<E> {
+    E union(E first, E second);
 
-    public E copy(E element);
+    E copy(E element);
   }
 
   //	public class SFormsFastMapIterator implements Iterator<Entry<Integer, E>> {

File: src/org/jetbrains/java/decompiler/util/VBStyleCollection.java
Patch:
@@ -106,7 +106,7 @@ public void addWithKeyAndIndex(int index, E element, K key) {
   }
 
   public void removeWithKey(K key) {
-    int index = ((Integer)map.get(key)).intValue();
+    int index = map.get(key).intValue();
     addToListIndex(index + 1, -1);
     super.remove(index);
     lstKeys.remove(index);

File: src/de/fernflower/modules/decompiler/exps/AssignmentExprent.java
Patch:
@@ -65,7 +65,7 @@ public AssignmentExprent(Exprent left, Exprent right) {
 	
 	
 	public VarType getExprType() {
-		return right.getExprType();
+		return left.getExprType();
 	}
 	
 

File: src/de/fernflower/main/InitializerProcessor.java
Patch:
@@ -208,7 +208,9 @@ private static void extractDynamicInitializers(ClassWrapper wrapper) {
 					AssignmentExprent asexpr = (AssignmentExprent)exprent;
 					if(asexpr.getLeft().type == Exprent.EXPRENT_FIELD) {
 						FieldExprent fexpr = (FieldExprent)asexpr.getLeft();
-						if(!fexpr.isStatic() && fexpr.getClassname().equals(cl.qualifiedName)) {
+						if(!fexpr.isStatic() && fexpr.getClassname().equals(cl.qualifiedName) &&
+								cl.hasField(fexpr.getName(), fexpr.getDescriptor().descriptorString)) { // check for the physical existence of the field. Could be defined in a superclass.
+							
 							if(isExprentIndependent(asexpr.getRight(), lstMethWrappers.get(i))) {
 								String fieldKey = InterpreterUtil.makeUniqueKey(fexpr.getName(), fexpr.getDescriptor().descriptorString);
 								if(fieldWithDescr == null) {

File: src/de/fernflower/main/rels/LambdaProcessor.java
Patch:
@@ -98,7 +98,8 @@ public boolean hasLambda(ClassNode node) throws IOException {
 							
 							LinkConstant content_method_handle = (LinkConstant)bootstrap_arguments.get(1);
 
-							ClassNode node_lambda = clprocessor.new ClassNode(content_method_handle.classname, content_method_handle.elementname, content_method_handle.descriptor, 
+							ClassNode node_lambda = clprocessor.new ClassNode(content_method_handle.classname, content_method_handle.elementname, 
+									                                          content_method_handle.descriptor, content_method_handle.index1,
 									                                          lambda_class_name, lambda_method_name, lambda_method_descriptor, cl);
 							node_lambda.simpleName = cl.qualifiedName + "##Lambda_" + invoke_dynamic.index1 + "_" + invoke_dynamic.index2;
 							node_lambda.enclosingMethod = InterpreterUtil.makeUniqueKey(mt.getName(), mt.getDescriptor());

File: src/de/fernflower/main/rels/MethodProcessorThread.java
Patch:
@@ -175,7 +175,7 @@ public static RootStatement codeToJava(StructMethod mt, VarProcessor varproc) th
 		ClearStructHelper.clearStatements(root);
 		
 		ExprProcessor proc = new ExprProcessor();
-		proc.processStatement(root, cl.getPool());
+		proc.processStatement(root, cl);
 
 //		DotExporter.toDotFile(graph, new File("c:\\Temp\\fern3.dot"), true);
 //		System.out.println(graph.toString());

File: src/de/fernflower/main/rels/NestedClassProcessor.java
Patch:
@@ -56,8 +56,8 @@ public class NestedClassProcessor {
 	
 	public void processClass(ClassNode root, ClassNode node) {
 
-		// hide lambda content methods
-		if(node.type == ClassNode.CLASS_LAMBDA) {
+		// hide synthetic lambda content methods
+		if(node.type == ClassNode.CLASS_LAMBDA && !node.lambda_information.is_method_reference) {
 			ClassNode node_content = DecompilerContext.getClassprocessor().getMapRootClasses().get(node.classStruct.qualifiedName);
 			if(node_content != null && node_content.wrapper != null) {
 				node_content.wrapper.getHideMembers().add(node.lambda_information.content_method_key);

File: src/de/fernflower/modules/decompiler/FinallyProcessor.java
Patch:
@@ -206,7 +206,7 @@ private Object[] getFinallyInformation(StructMethod mt, RootStatement root, Catc
 		}
 		
 		ExprProcessor proc = new ExprProcessor();
-		proc.processStatement(root, mt.getClassStruct().getPool());
+		proc.processStatement(root, mt.getClassStruct());
 
 		SSAConstructorSparseEx ssa = new SSAConstructorSparseEx();
 		ssa.splitVariables(root, mt);

File: src/de/fernflower/modules/decompiler/StackVarsProcessor.java
Patch:
@@ -206,6 +206,8 @@ private boolean iterateStatements(RootStatement root, SSAUConstructorSparseEx ss
 					
 					int[] ret = iterateExprent(lst, index, next, mapVarValues, ssa);
 					
+					//System.out.println("***************** \r\n"+root.toJava());
+					
 					if(ret[0] >= 0) {
 						index = ret[0];
 					} else {

File: src/de/fernflower/modules/decompiler/exps/NewExprent.java
Patch:
@@ -307,7 +307,7 @@ public String toJava(int indent) {
 					}
 
           int start = enumconst ? 2 : 0;
-          if(start < lstParameters.size()) {
+          if(!enumconst || start < lstParameters.size()) {
             buf.append("(");
 
             boolean firstpar = true;

File: src/de/fernflower/main/DecompilerContext.java
Patch:
@@ -190,6 +190,7 @@ private static void setLogSeverity() {
 	}
 	
 	public static String getNewLineSeparator() {
-		return getOption(IFernflowerPreferences.NEW_LINE_SEPARATOR) ? IFernflowerPreferences.LINE_SEPARATOR_LIN : IFernflowerPreferences.LINE_SEPARATOR_WIN ;
+		return getOption(IFernflowerPreferences.NEW_LINE_SEPARATOR) ?
+               IFernflowerPreferences.LINE_SEPARATOR_LIN : IFernflowerPreferences.LINE_SEPARATOR_WIN ;
 	}
 }

File: src/de/fernflower/modules/decompiler/IdeaNotNullHelper.java
Patch:
@@ -295,6 +295,7 @@ private static boolean removeReturnCheck(Statement stat, StructMethod mt) {
 										}										
 										
 										sequence.getStats().removeWithKey(ifstat.id);
+										sequence.setFirst(sequence.getStats().get(0));
 										
 										return true;
 									}

File: src/de/fernflower/modules/decompiler/StackVarsProcessor.java
Patch:
@@ -229,7 +229,7 @@ private boolean iterateStatements(RootStatement root, SSAUConstructorSparseEx ss
 				if(nd.statement.type == Statement.TYPE_DO) {
 					DoStatement loop = (DoStatement)nd.statement;
 					
-					if(nd.type == DirectNode.NODE_INCREMENT && loop.getLooptype() == DoStatement.LOOP_FOR) { // "downgrade" loop to 'while'
+					if(loop.getLooptype() == DoStatement.LOOP_FOR && loop.getInitExprent() == null && loop.getIncExprent() == null) { // "downgrade" loop to 'while'
 						loop.setLooptype(DoStatement.LOOP_WHILE);
 					}
 				}

File: src/de/fernflower/main/rels/NestedClassProcessor.java
Patch:
@@ -786,7 +786,7 @@ private void mergeListSignatures(List<VarFieldPair> first, List<VarFieldPair> se
 				if(both) {
 					second.set(0, null);
 				}
-			} else {
+			} else if(fobj != null) {
 				if(fobj.varpaar.var == -1) {
 					fobj.varpaar = sobj.varpaar;
 				} else {

File: src/de/fernflower/main/extern/IFernflowerPreferences.java
Patch:
@@ -28,7 +28,7 @@ public interface IFernflowerPreferences {
 	public static final String NO_EXCEPTIONS_RETURN = "ner";			
 	public static final String DECOMPILE_ENUM = "den";						
 	public static final String REMOVE_GETCLASS_NEW = "rgn";				
-	public static final String LITERALS_AS_IS = "bto";
+	public static final String LITERALS_AS_IS = "lit";
 	public static final String BOOLEAN_TRUE_ONE = "bto";
 	public static final String SYNTHETIC_NOT_SET = "nns";		
 	public static final String UNDEFINED_PARAM_TYPE_OBJECT = "uto";

File: src/de/fernflower/main/ClassWriter.java
Patch:
@@ -838,8 +838,8 @@ public boolean methodToJava(ClassNode node, StructMethod mt, BufferedWriter writ
 						bufstrwriter.write(", ");
 					}
 					
-					if(lstParAnn.size() > i) {
-						List<AnnotationExprent> annotations = lstParAnn.get(i); 
+					if(lstParAnn.size() > param_count_explicit) {
+						List<AnnotationExprent> annotations = lstParAnn.get(param_count_explicit);
 						for(int j=0;j<annotations.size();j++) {
 							AnnotationExprent annexpr = annotations.get(j);
 							if(annexpr.getAnnotationType() == AnnotationExprent.ANNOTATION_NORMAL) {

File: src/de/fernflower/struct/gen/generics/GenericMain.java
Patch:
@@ -127,8 +127,8 @@ private static String parseFormalParameters(String signature, List<String> fpara
 			List<GenericType> lstBounds = new ArrayList<GenericType>();
 			
 			for(;;) {
-				if(value.charAt(0) == ':') { // empty superclass
-					lstBounds.add(new GenericType(CodeConstants.TYPE_OBJECT, 0, "java/lang/Object"));
+				if(value.charAt(0) == ':') {
+				  // empty superclass, skip
 					value = value.substring(1);
 				} 
 				

File: src/de/fernflower/main/extern/IFernflowerPreferences.java
Patch:
@@ -46,7 +46,6 @@ public interface IFernflowerPreferences {
 	
 	public static final String LOG_LEVEL = "log";	
 	
-	public static final String DEPRECATED_COMMENT = "dpc";
 	public static final String NEW_LINE_SEPARATOR = "nls";
 	public static final String IDEA_NOT_NULL_ANNOTATION = "inn";
 	public static final String LAMBDA_TO_ANONYMOUS_CLASS = "lac";

File: src/de/fernflower/modules/decompiler/stats/CatchAllStatement.java
Patch:
@@ -129,7 +129,7 @@ public String toJava(int indent) {
 		if(first.type == TYPE_TRYCATCH && first.varDefinitions.isEmpty() && isFinally &&
 				!labeled && !first.isLabeled() && (lstSuccs.isEmpty() || !lstSuccs.get(0).explicit)) {
 			String content = ExprProcessor.jmpWrapper(first, indent, true);
-			content = content.substring(0, content.length()-2);
+			content = content.substring(0, content.length()-new_line_separator.length());
 			
 			buf.append(content);
 		} else {

File: src/de/fernflower/code/Instruction.java
Patch:
@@ -29,6 +29,7 @@ public class Instruction implements CodeConstants {
 	
 	public boolean wide = false;
 	
+	public int bytecode_version = BYTECODE_JAVA_LE_4;
 	
 	// *****************************************************************************
 	// private fields
@@ -55,7 +56,7 @@ public int getOperand(int index) {
 	}
 	
 	public Instruction clone() {
-		return ConstantsUtil.getInstructionInstance(opcode, wide, group, operands==null?null:(int[])operands.clone());
+		return ConstantsUtil.getInstructionInstance(opcode, wide, group, bytecode_version, operands==null?null:(int[])operands.clone());
 	}
 	
 	public String toString() {

File: src/de/fernflower/main/rels/MethodProcessorThread.java
Patch:
@@ -102,7 +102,7 @@ public static RootStatement codeToJava(StructMethod mt, VarProcessor varproc) th
 //			System.out.println();
 //		}
 		
-//		DotExporter.toDotFile(graph, new File("c:\\Temp\\fern1.dot"), true);
+		//DotExporter.toDotFile(graph, new File("c:\\Temp\\fern1.dot"), true);
 		
 		DeadCodeHelper.removeDeadBlocks(graph);
 		graph.inlineJsr(mt);
@@ -142,7 +142,7 @@ public static RootStatement codeToJava(StructMethod mt, VarProcessor varproc) th
 		DecompilerContext.getCountercontainer().setCounter(CounterContainer.VAR_COUNTER, mt.getLocalVariables());
 		
 		//DotExporter.toDotFile(graph, new File("c:\\Temp\\fern3.dot"), true);
-		System.out.println(graph.toString());
+		//System.out.println(graph.toString());
 		
 		if(ExceptionDeobfuscator.hasObfuscatedExceptions(graph)) {
 			DecompilerContext.getLogger().writeMessage("Heavily obfuscated exception ranges found!", IFernflowerLogger.WARNING);
@@ -157,7 +157,7 @@ public static RootStatement codeToJava(StructMethod mt, VarProcessor varproc) th
 				//DotExporter.toDotFile(graph, new File("c:\\Temp\\fern2.dot"), true);
 				//System.out.println(graph.toString());
 
-				System.out.println("~~~~~~~~~~~~~~~~~~~~~~ \r\n"+root.toJava());
+				//System.out.println("~~~~~~~~~~~~~~~~~~~~~~ \r\n"+root.toJava());
 				
 				root = DomHelper.parseGraph(graph);
 			}

